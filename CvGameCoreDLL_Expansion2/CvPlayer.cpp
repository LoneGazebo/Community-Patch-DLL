/*	-------------------------------------------------------------------------------------------------------
	© 1991-2012 Take-Two Interactive Software and its subsidiaries.  Developed by Firaxis Games.  
	Sid Meier's Civilization V, Civ, Civilization, 2K Games, Firaxis Games, Take-Two Interactive Software 
	and their respective logos are all trademarks of Take-Two interactive Software, Inc.  
	All other marks and trademarks are the property of their respective owners.  
	All rights reserved. 
	------------------------------------------------------------------------------------------------------- */

#include "CvGameCoreDLLPCH.h"
#include "CvGlobals.h"
#include "CvArea.h"
#include "CvMap.h"
#include "CvPlot.h"
#include "CvRandom.h"
#include "CvTeam.h"
#include "CvGameCoreUtils.h"
#include "CvPlayerAI.h"
#include "CvPlayer.h"
#include "CvInfos.h"
#include "CvAStar.h"
#include "CvGameTextMgr.h"
#include "CvDiplomacyAI.h"
#include "CvEconomicAI.h"
#include "CvMilitaryAI.h"
#include "CvCitySpecializationAI.h"
#include "CvWonderProductionAI.h"
#include "CvGrandStrategyAI.h"
#include "CvDiplomacyAI.h"
#include "CvTechAI.h"
#include "CvFlavorManager.h"
#include "CvHomelandAI.h"
#include "CvMinorCivAI.h"
#include "CvDealAI.h"
#include "CvImprovementClasses.h"
#include "CvBuilderTaskingAI.h"
#include "CvDangerPlots.h"
#if defined(MOD_BALANCE_CORE)
#include "CvDistanceMap.h"
#include "CvBarbarians.h"
#endif
#include "CvGoodyHuts.h"
#include "CvCityConnections.h"
#include "CvNotifications.h"
#if defined(MOD_WH_MILITARY_LOG)
#include "CvEventLog.h"
#endif
#include "CvDiplomacyRequests.h"
#include "cvStopWatch.h"
#include "CvTypes.h"
#include "CvEnums.h"

#include "ICvDLLUserInterface.h"
#include "CvEnumSerialization.h"
#include "FStlContainerSerialization.h"
#include <sstream>
#if defined(MOD_BALANCE_CORE)
#include <iomanip>
#endif

#include "CvInternalGameCoreUtils.h"
#include "CvAchievementUnlocker.h"
#include "CvInfosSerializationHelper.h"

#include "CvDllCity.h"
#if defined(MOD_GLOBAL_NO_CONQUERED_SPACESHIPS)
#include "CvDllPlot.h"
#endif
#include "CvGoodyHuts.h"

#include "CvDllNetMessageExt.h"
// Include this after all other headers.
#define LINT_WARNINGS_ONLY
#include "LintFree.h"

//Simply empty check utility.
bool isEmpty(const char* szString)
{
	return szString == NULL || szString[0] == '\0';
}

//	--------------------------------------------------------------------------------
// Public Functions...
namespace FSerialization
{
void SyncPlayer()
{
	if(GC.getGame().isNetworkMultiPlayer())
	{
		PlayerTypes eAuthoritativePlayerID = GC.getGame().getActivePlayer();
		CvPlayer& authoritativePlayer = GET_PLAYER(eAuthoritativePlayerID);
		CvSyncArchive<CvPlayer>& archive = authoritativePlayer.getSyncArchive();
		archive.collectDeltas();
		if(archive.hasDeltas())
		{
			FMemoryStream ms;
			std::vector<std::pair<std::string, std::string> > callStacks;
			archive.saveDelta(ms, callStacks);
			gDLL->sendPlayerSyncCheck(eAuthoritativePlayerID, ms, callStacks);
		}

		// host is authoritative for AI players

		if(gDLL->IsHost())
		{
			for(int i = 0; i < MAX_PLAYERS; ++i)
			{
				CvPlayer& player = GET_PLAYER(static_cast<PlayerTypes>(i));
				if(!player.isHuman() && player.isAlive())
				{
					CvSyncArchive<CvPlayer>& aiArchive = player.getSyncArchive();
					aiArchive.collectDeltas();
					if (aiArchive.hasDeltas())
					{
						FMemoryStream ms;
						std::vector<std::pair<std::string, std::string> > callStacks;
						aiArchive.saveDelta(ms, callStacks);
						gDLL->sendPlayerSyncCheck(static_cast<PlayerTypes>(i), ms, callStacks);
					}
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
// clears ALL deltas for ALL players
void ClearPlayerDeltas()
{
	int i = 0;
	for(i = 0; i < MAX_PLAYERS; ++i)
	{
		CvPlayer& player = GET_PLAYER(static_cast<PlayerTypes>(i));
		FAutoArchive& archive = player.getSyncArchive();
		archive.clearDelta();
	}
}
}

//	--------------------------------------------------------------------------------
CvPlayer::CvPlayer() :
	m_syncArchive()
	, m_iStartingX()
	, m_iStartingY()
	, m_iTotalPopulation()
	, m_iTotalLand()
	, m_iTotalLandScored()
	, m_iJONSCulturePerTurnForFree()
	, m_iJONSCultureCityModifier()
	, m_iJONSCulture()
	, m_iJONSCultureEverGenerated()
	, m_iWondersConstructed()
	, m_iCulturePerWonder()
	, m_iCultureWonderMultiplier()
	, m_iCulturePerTechResearched()
	, m_iFaith()
	, m_iFaithEverGenerated()
	, m_iHappiness()
	, m_iUprisingCounter()
	, m_iExtraHappinessPerLuxury()
	, m_iUnhappinessFromUnits()
	, m_iUnhappinessFromUnitsMod()
	, m_iUnhappinessMod()
	, m_iCityCountUnhappinessMod()
	, m_iOccupiedPopulationUnhappinessMod()
	, m_iCapitalUnhappinessMod()
	, m_iCityRevoltCounter()
	, m_iHappinessPerGarrisonedUnitCount()
	, m_iHappinessPerTradeRouteCount()
	, m_iHappinessPerXPopulation()
	, m_iHappinessFromLeagues()
	, m_iEspionageModifier()
	, m_iSpyStartingRank()
	, m_iExtraLeagueVotes()
	, m_iWoundedUnitDamageMod()
	, m_iUnitUpgradeCostMod()
	, m_iBarbarianCombatBonus()
	, m_iAlwaysSeeBarbCampsCount()
	, m_iHappinessPerCity()
	, m_iHappinessPerXPolicies()
	, m_iExtraHappinessPerXPoliciesFromPolicies()
	, m_iHappinessPerXGreatWorks()
	, m_iAdvancedStartPoints()
	, m_iAttackBonusTurns()
	, m_iCultureBonusTurns()
	, m_iTourismBonusTurns()
	, m_iGoldenAgeProgressMeter()
	, m_iGoldenAgeMeterMod()
	, m_iNumGoldenAges()
	, m_iGoldenAgeTurns()
	, m_iNumUnitGoldenAges()
	, m_iStrikeTurns()
	, m_iGoldenAgeModifier()
	, m_iGreatPeopleCreated()
	, m_iGreatGeneralsCreated()
	, m_iGreatAdmiralsCreated()
	, m_iGreatWritersCreated()
	, m_iGreatArtistsCreated()
	, m_iGreatMusiciansCreated()
	, m_iMerchantsFromFaith()
	, m_iScientistsFromFaith()
	, m_iWritersFromFaith()
	, m_iArtistsFromFaith()
	, m_iMusiciansFromFaith()
	, m_iGeneralsFromFaith()
	, m_iAdmiralsFromFaith()
	, m_iEngineersFromFaith()
	, m_iGreatPeopleThresholdModifier()
	, m_iGreatGeneralsThresholdModifier()
	, m_iGreatAdmiralsThresholdModifier()
	, m_iGreatGeneralCombatBonus()
	, m_iAnarchyNumTurns()
	, m_iPolicyCostModifier()
	, m_iGreatPeopleRateModifier()
	, m_iGreatPeopleRateModFromBldgs()
	, m_iGreatGeneralRateModifier()
	, m_iGreatGeneralRateModFromBldgs()
	, m_iDomesticGreatGeneralRateModifier()
	, m_iGreatAdmiralRateModifier()
	, m_iGreatWriterRateModifier()
	, m_iGreatArtistRateModifier()
	, m_iGreatMusicianRateModifier()
	, m_iGreatMerchantRateModifier()
	, m_iGreatDiplomatRateModifier()
	, m_iGreatScientistRateModifier()
	, m_iGreatScientistBeakerModifier()
	, m_iGreatEngineerHurryMod()
	, m_iTechCostXCitiesModifier()
	, m_iTourismCostXCitiesMod()
	, m_iGreatEngineerRateModifier()
	, m_iGreatPersonExpendGold()
	, m_iMaxGlobalBuildingProductionModifier()
	, m_iMaxTeamBuildingProductionModifier()
	, m_iMaxPlayerBuildingProductionModifier()
	, m_iFreeExperience()
	, m_iFreeExperienceFromBldgs()
	, m_iFreeExperienceFromMinors()
	, m_iFeatureProductionModifier()
	, m_iWorkerSpeedModifier()
	, m_iImprovementCostModifier()
	, m_iImprovementUpgradeRateModifier()
	, m_iSpecialistProductionModifier()
	, m_iMilitaryProductionModifier()
	, m_iSpaceProductionModifier()
	, m_iCityDefenseModifier()
	, m_iUnitFortificationModifier()
	, m_iUnitBaseHealModifier()
	, m_iWonderProductionModifier()
	, m_iSettlerProductionModifier()
	, m_iCapitalSettlerProductionModifier()
	, m_iUnitProductionMaintenanceMod()
	, m_iUnitGrowthMaintenanceMod()
	, m_iPolicyCostBuildingModifier()
	, m_iPolicyCostMinorCivModifier()
	, m_iInfluenceSpreadModifier()
	, m_iExtraVotesPerDiplomat()
	, m_iNumNukeUnits()
	, m_iNumOutsideUnits()
	, m_iBaseFreeUnits()
	, m_iBaseFreeMilitaryUnits()
	, m_iFreeUnitsPopulationPercent()
	, m_iFreeMilitaryUnitsPopulationPercent()
	, m_iGoldPerUnit()
	, m_iGoldPerMilitaryUnit()
	, m_iImprovementGoldMaintenanceMod()
#if defined(MOD_CIV6_WORKER)
	, m_iRouteBuilderCostMod()
#endif
	, m_iBuildingGoldMaintenanceMod()
	, m_iUnitGoldMaintenanceMod()
	, m_iUnitSupplyMod()
	, m_iExtraUnitCost()
	, m_iNumMilitaryUnits()
	, m_iHappyPerMilitaryUnit()
	, m_iHappinessToCulture()
	, m_iHappinessToScience()
	, m_iHalfSpecialistUnhappinessCount()
	, m_iHalfSpecialistFoodCount()
	, m_iMilitaryFoodProductionCount()
	, m_iGoldenAgeCultureBonusDisabledCount()
	, m_iNumMissionarySpreads()
	, m_iSecondReligionPantheonCount()
	, m_iEnablesSSPartHurryCount()
	, m_iEnablesSSPartPurchaseCount()
	, m_iConscriptCount()
	, m_iMaxConscript()
	, m_iHighestUnitLevel()
	, m_iOverflowResearch()
	, m_iExpModifier()
	, m_iExpInBorderModifier()
	, m_iLevelExperienceModifier()
	, m_iMinorQuestFriendshipMod()
	, m_iMinorGoldFriendshipMod()
	, m_iMinorFriendshipMinimum()
	, m_iMinorFriendshipDecayMod()
	, m_iMinorScienceAlliesCount()
	, m_iMinorResourceBonusCount()
	, m_iAbleToAnnexCityStatesCount()
	, m_iOnlyTradeSameIdeology()
	, m_iFreeSpecialist()
	, m_iCultureBombTimer()
	, m_iConversionTimer()
	, m_iCapitalCityID()
	, m_iCitiesLost()
	, m_iMilitaryRating()
	, m_iMilitaryMight()
	, m_iEconomicMight()
	, m_iProductionMight()
	, m_iTurnSliceMightRecomputed()
	, m_iNewCityExtraPopulation()
	, m_iFreeFoodBox()
	, m_iScenarioScore1()
	, m_iScenarioScore2()
	, m_iScenarioScore3()
	, m_iScenarioScore4()
	, m_iScoreFromFutureTech()
	, m_iTurnLastAttackedMinorCiv()
	, m_iCombatExperienceTimes100()
	, m_iLifetimeCombatExperienceTimes100()
	, m_iNavalCombatExperienceTimes100()
	, m_iBorderObstacleCount()
#if defined(HH_MOD_BUILDINGS_FRUITLESS_PILLAGE)
	, m_iBorderGainlessPillageCount()
#endif
	, m_iPopRushHurryCount()
	, m_iTotalImprovementsBuilt()
	, m_iCostNextPolicy()
	, m_iNumBuilders()
	, m_iMaxNumBuilders()
	, m_iCityStrengthMod()
	, m_iCityGrowthMod()
	, m_iCapitalGrowthMod()
	, m_iNumPlotsBought()
	, m_iPlotGoldCostMod()
	, m_iCachedGoldRate()
	, m_iPlotCultureCostModifier()
	, m_iPlotCultureExponentModifier()
	, m_iNumCitiesPolicyCostDiscount()
	, m_iGarrisonedCityRangeStrikeModifier()
	, m_iGarrisonFreeMaintenanceCount()
	, m_iNumCitiesFreeCultureBuilding()
	, m_iNumCitiesFreeFoodBuilding()
	, m_iUnitPurchaseCostModifier()
	, m_iAllFeatureProduction()
	, m_iCityDistanceHighwaterMark()
	, m_iOriginalCapitalX()
	, m_iOriginalCapitalY()
	, m_iHolyCityX()
	, m_iHolyCityY()
	, m_iNumWonders()
	, m_iNumPolicies()
	, m_iNumGreatPeople()
	, m_uiStartTime()  // XXX save these?
	, m_bHasUUPeriod()
	, m_bNoNewWars()
	, m_bTerribleShapeForWar()
	, m_bHasBetrayedMinorCiv()
	, m_bAlive()
	, m_bEverAlive()
	, m_bPotentiallyAlive()
	, m_bTurnActive(false)
	, m_bAutoMoves(false)
	, m_bEndTurn(false)
	, m_bDynamicTurnsSimultMode(true)
	, m_bPbemNewTurn()
	, m_bExtendedGame()
	, m_bFoundedFirstCity()
	, m_iNumCitiesFounded()
	, m_bStrike()
	, m_bCramped()
	, m_bLostCapital()
	, m_eConqueror(NO_PLAYER)
	, m_bLostHolyCity()
	, m_eHolyCityConqueror(NO_PLAYER)
	, m_bHasAdoptedStateReligion()
	, m_eID()
	, m_ePersonalityType()
	, m_aiCityYieldChange()
	, m_aiCoastalCityYieldChange()
	, m_aiCapitalYieldChange()
	, m_aiCapitalYieldPerPopChange()
	, m_aiCapitalYieldPerPopChangeEmpire()
	, m_aiSeaPlotYield()
	, m_aiYieldRateModifier()
	, m_aiCapitalYieldRateModifier()
	, m_aiExtraYieldThreshold()
	, m_aiSpecialistExtraYield()
	, m_aiPlayerNumTurnsAtPeace()
	, m_aiPlayerNumTurnsAtWar()
	, m_aiPlayerNumTurnsSinceCityCapture()
	, m_aiWarValueLost()
	, m_aiWarDamageValue()
	, m_aiNumUnitsBuilt()
	, m_aiProximityToPlayer()
	, m_aiResearchAgreementCounter()
	, m_aiSiphonLuxuryCount()
	, m_aiTourismBonusTurnsPlayer()
	, m_aiGreatWorkYieldChange()
	, m_aOptions()
	, m_strReligionKey()
	, m_strScriptData()
	, m_paiNumResourceUsed()
	, m_paiNumResourceTotal()
	, m_paiResourceGiftedToMinors()
	, m_paiResourceExport()
	, m_paiResourceImportFromMajor()
	, m_paiResourceFromMinors()
	, m_paiResourcesSiphoned()
	, m_aiNumResourceFromGP()
	, m_paiImprovementCount()
	, m_paiImprovementBuiltCount()
#if defined(MOD_BALANCE_CORE)
	, m_paiTotalImprovementsBuilt()
#endif
	, m_paiFreeBuildingCount()
	, m_paiFreePromotionCount()
	, m_paiUnitCombatProductionModifiers()
	, m_paiUnitCombatFreeExperiences()
	, m_paiUnitClassCount()
	, m_paiUnitClassMaking()
	, m_paiBuildingClassCount()
	, m_paiBuildingClassMaking()
	, m_paiProjectMaking()
	, m_paiHurryCount()
	, m_paiHurryModifier()
	, m_pabLoyalMember()
	, m_pabGetsScienceFromPlayer()
	, m_ppaaiSpecialistExtraYield()
	, m_ppiYieldFromYieldGlobal()
	, m_ppaaiImprovementYieldChange()
	, m_bEverPoppedGoody()
	, m_bEverTrainedBuilder()
	, m_iCityConnectionHappiness()
	, m_iHolyCityID()
	, m_iTurnsSinceSettledLastCity()
	, m_iNumNaturalWondersDiscoveredInArea()
	, m_iStrategicResourceMod()
	, m_iSpecialistCultureChange()
	, m_iGreatPeopleSpawnCounter()
	, m_iFreeTechCount()
	, m_iMedianTechPercentage(50)
	, m_iNumFreePolicies()
	, m_iNumFreePoliciesEver()
	, m_iNumFreeTenets()
	, m_iLastSliceMoved()
	, m_eEndTurnBlockingType(NO_ENDTURN_BLOCKING_TYPE)
	, m_iEndTurnBlockingNotificationIndex(0)
	, m_activeWaitingForEndTurnMessage(false)
	, m_endTurnBusyUnitUpdatesLeft(0)
	, m_lastGameTurnInitialAIProcessed(-1)
	, m_iNumFreeGreatPeople()
	, m_iNumMayaBoosts()
	, m_iNumFaithGreatPeople()
	, m_iNumArchaeologyChoices()
	, m_eFaithPurchaseType(NO_AUTOMATIC_FAITH_PURCHASE)
	, m_iFaithPurchaseIndex()
	, m_bProcessedAutoMoves(false)
#pragma warning(push)
#pragma warning(disable:4355 )
	, m_kPlayerAchievements(*this)
#pragma warning(pop)
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	, m_neededUnitAITypes()
	, m_aiCityYieldModFromMonopoly()
	, m_iUnhappiness()
	, m_iHappinessTotal()
	, m_iEmpireNeedsModifierGlobal()
	, m_iChangePovertyUnhappinessGlobal()
	, m_iChangeDefenseUnhappinessGlobal()
	, m_iChangeUnculturedUnhappinessGlobal()
	, m_iChangeIlliteracyUnhappinessGlobal()
	, m_iChangeMinorityUnhappinessGlobal()
	, m_iLandmarksTourismPercentGlobal()
	, m_iGreatWorksTourismModifierGlobal()
	, m_bAllowsProductionTradeRoutesGlobal()
	, m_bAllowsFoodTradeRoutesGlobal()
#endif
#if defined(MOD_BALANCE_CORE)
	, m_iCenterOfMassX()
	, m_iCenterOfMassY()
	, m_iReferenceFoundValue()
	, m_iReformationFollowerReduction()
	, m_bIsReformation()
	, m_iSupplyFreeUnits()
	, m_viInstantYieldsTotal()
	, m_miLocalInstantYieldsTotal()
	, m_aiYieldHistory()
#endif
#if defined(MOD_BALANCE_CORE_POLICIES)
	, m_iHappinessPerXPopulationGlobal()
	, m_iIdeologyPoint()
	, m_iNoXPLossUnitPurchase()
	, m_iXCSAlliesLowersPolicyNeedWonders()
	, m_iHappinessFromMinorCivs()
	, m_iPositiveWarScoreTourismMod()
	, m_iIsNoCSDecayAtWar()
	, m_iCanBullyFriendlyCS()
	, m_iBullyGlobalCSReduction()
#endif
	, m_iIsVassalsNoRebel()
	, m_iVassalYieldBonusModifier()
	, m_iCSYieldBonusModifier()
#if defined(MOD_RELIGION_CONVERSION_MODIFIERS)
	, m_iConversionModifier()
#endif
	, m_iImprovementLeagueVotes()
	, m_iFaithToVotes()
	, m_iCapitalsToVotes()
	, m_iDoFToVotes()
	, m_iRAToVotes()
	, m_iDefensePactsToVotes()
	, m_iGPExpendInfluence()
	, m_bIsLeagueAid()
	, m_bIsLeagueScholar()
	, m_bIsLeagueArt()
	, m_iScienceRateFromLeague()
	, m_iScienceRateFromLeagueAid()
	, m_iLeagueCultureCityModifier()
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
	, m_iProductionBonusTurnsConquest()
	, m_iCultureBonusTurnsConquest()
	, m_iFreeGreatPeopleCreated()
	, m_iFreeGreatGeneralsCreated()
	, m_iFreeGreatAdmiralsCreated()
#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
	, m_iFreeGreatMerchantsCreated()
	, m_iFreeGreatScientistsCreated()
	, m_iFreeGreatEngineersCreated()
#endif
	, m_iFreeGreatWritersCreated()
	, m_iFreeGreatArtistsCreated()
	, m_iFreeGreatMusiciansCreated()
	, m_iFreeGreatDiplomatsCreated()
#endif
#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
	, m_iGPExtra1Created()
	, m_iGPExtra2Created()
	, m_iGPExtra3Created()
	, m_iGPExtra4Created()
	, m_iGPExtra5Created()
	, m_iGPExtra1FromFaith()
	, m_iGPExtra2FromFaith()
	, m_iGPExtra3FromFaith()
	, m_iGPExtra4FromFaith()
	, m_iGPExtra5FromFaith()
	, m_iFreeGPExtra1Created()
	, m_iFreeGPExtra2Created()
	, m_iFreeGPExtra3Created()
	, m_iFreeGPExtra4Created()
	, m_iFreeGPExtra5Created()
	, m_iGreatMerchantsCreated()
	, m_iGreatScientistsCreated()
	, m_iGreatEngineersCreated()
#endif
	, m_iGreatDiplomatsCreated()
	, m_iDiplomatsFromFaith()
#if defined(MOD_BALANCE_CORE)
	, m_iHalfSpecialistFoodCapitalCount()
	, m_iTradeRouteLandDistanceModifier()
	, m_iTradeRouteSeaDistanceModifier()
	, m_bNullifyInfluenceModifier()
#endif
#if defined(MOD_BALANCE_CORE)
	, m_aistrInstantYield()
	, m_aistrInstantGreatPersonProgress()
	, m_iJFDCurrency()
	, m_iJFDProsperity()
	, m_strJFDCurrencyName()
	, m_strJFDLegislatureName()
	, m_strJFDPoliticKey()
	, m_iJFDPoliticLeader()
	, m_iJFDSovereignty()
	, m_iJFDGovernment()
	, m_iJFDReformCooldown()
	, m_iJFDGovernmentCooldown()
	, m_iJFDReformCooldownRate()
	, m_iJFDGovernmentCooldownRate()
	, m_iJFDPiety()
	, m_iJFDPietyRate()
	, m_iJFDConversionTurn()
	, m_bJFDSecularized()
	, m_abActiveContract()
	, m_iUpgradeCSVassalTerritory()
	, m_iArchaeologicalDigTourism()
	, m_iGoldenAgeTourism()
	, m_iExtraCultureandScienceTradeRoutes()
	, m_iRazingSpeedBonus()
	, m_iNoPartisans()
	, m_iSpawnCooldown()
	, m_bTradeRoutesInvulnerable()
	, m_iTRSpeedBoost()
	, m_iVotesPerGPT()
	, m_iTRVisionBoost()
	, m_iEventTourism()
	, m_iEventTourismCS()
	, m_iNumHistoricEvent()
	, m_iSingleVotes()
	, m_iMonopolyModFlat()
	, m_iMonopolyModPercent()
	, m_iCachedValueOfPeaceWithHuman()
	, m_iFaithPurchaseCooldown()
	, m_iCSAllies()
	, m_iCSFriends()
	, m_iCitiesNeedingTerrainImprovements()
	, m_aiBestMilitaryCombatClassCity()
	, m_aiBestMilitaryDomainCity()
	, m_aiEventChoiceDuration()
	, m_aiEventIncrement()
	, m_abEventActive()
	, m_abEventChoiceActive()
	, m_aiEventCooldown()
	, m_abEventChoiceFired()
	, m_abEventFired()
	, m_iPlayerEventCooldown()
	, m_ownedNaturalWonders()
	, m_paiUnitClassProductionModifiers()
	, m_iExtraSupplyPerPopulation()
	, m_iCitySupplyFlatGlobal()
	, m_iUnitSupplyFromExpendedGP()
	, m_iMissionaryExtraStrength()
	, m_piDomainFreeExperience()
#endif
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	, m_iPovertyUnhappinessMod()
	, m_iDefenseUnhappinessMod()
	, m_iUnculturedUnhappinessMod()
	, m_iIlliteracyUnhappinessMod()
	, m_iMinorityUnhappinessMod()
	, m_iPovertyUnhappinessModCapital()
	, m_iDefenseUnhappinessModCapital()
	, m_iUnculturedUnhappinessModCapital()
	, m_iIlliteracyUnhappinessModCapital()
	, m_iMinorityUnhappinessModCapital()
	, m_iNoUnhappfromXSpecialists()
	, m_iHappfromXSpecialists()
	, m_iNoUnhappfromXSpecialistsCapital()
	, m_iSpecialistFoodChange()
	, m_iWarWearinessModifier()
	, m_iWarScoreModifier()
#endif
#if defined(MOD_TRAITS_CITY_WORKING) || defined(MOD_BUILDINGS_CITY_WORKING) || defined(MOD_POLICIES_CITY_WORKING) || defined(MOD_TECHS_CITY_WORKING)
	, m_iCityWorkingChange()
#endif
#if defined(MOD_TRAITS_CITY_AUTOMATON_WORKERS) || defined(MOD_BUILDINGS_CITY_AUTOMATON_WORKERS) || defined(MOD_POLICIES_CITY_AUTOMATON_WORKERS) || defined(MOD_TECHS_CITY_AUTOMATON_WORKERS)
	, m_iCityAutomatonWorkersChange()
#endif
#if defined(MOD_BALANCE_CORE_POLICIES)
	, m_paiBuildingChainSteps()
	, m_paiJFDPoliticPercent()
	, m_paiResourceFromCSAlliances()
	, m_paiResourceShortageValue()
	, m_aiGlobalTourismAlreadyReceived()
	, m_aiYieldFromMinors()
	, m_aiYieldFromBirth()
	, m_aiYieldFromBirthCapital()
	, m_aiYieldFromDeath()
	, m_aiYieldFromPillage()
	, m_aiYieldFromVictory()
	, m_aiYieldFromConstruction()
	, m_aiYieldFromWorldWonderConstruction()
	, m_aiYieldFromTech()
	, m_aiYieldFromBorderGrowth()
	, m_aiYieldGPExpend()
	, m_aiConquerorYield()
	, m_aiFounderYield()
	, m_aiArtifactYieldBonus()
	, m_aiArtYieldBonus()
	, m_aiMusicYieldBonus()
	, m_aiLitYieldBonus()
	, m_aiFilmYieldBonus()
	, m_aiRelicYieldBonus()
	, m_aiReligionYieldRateModifier()
	, m_aiGoldenAgeYieldMod()
	, m_aiYieldFromNonSpecialistCitizens()
	, m_aiYieldModifierFromGreatWorks()
	, m_aiYieldModifierFromActiveSpies()
	, m_aiYieldFromDelegateCount()
	, m_aiYieldForLiberation()
	, m_iInfluenceForLiberation()
	, m_iExperienceForLiberation()
	, m_iCityCaptureHealGlobal()
	, m_aiBuildingClassInLiberatedCities()
	, m_iUnitsInLiberatedCities()
	, m_paiBuildingClassCulture()
	, m_aiDomainFreeExperiencePerGreatWorkGlobal()
	, m_iGarrisonsOccupiedUnhapppinessMod()
	, m_iXPopulationConscription()
	, m_iExtraMoves()
	, m_iNoUnhappinessExpansion()
	, m_iNoUnhappyIsolation()
	, m_iDoubleBorderGrowthGA()
	, m_iDoubleBorderGrowthWLTKD()
	, m_iIncreasedQuestInfluence()
	, m_iCultureBombBoost()
	, m_iPuppetProdMod()
	, m_iOccupiedProdMod()
	, m_iGoldInternalTrade()
	, m_iFreeWCVotes()
	, m_iInfluenceGPExpend()
	, m_iFreeTradeRoute()
	, m_iFreeSpy()
	, m_iReligionDistance()
	, m_iPressureMod()
	, m_iTradeReligionModifier()
	, m_iCityStateCombatModifier()
#endif
#if defined(MOD_BALANCE_CORE_SPIES)
	, m_iMaxAirUnits()
#endif
#if defined(MOD_BALANCE_CORE_BUILDING_INVESTMENTS)
	, m_iInvestmentModifier()
	, m_iMissionInfluenceModifier()
	, m_iHappinessPerActiveTradeRoute()
	, m_iCSResourcesCountMonopolies()
	, m_iConquestPerEraBuildingProductionMod()
	, m_iAdmiralLuxuryBonus()
	, m_iPuppetYieldPenaltyMod()
	, m_iNeedsModifierFromAirUnits()
	, m_iFlatDefenseFromAirUnits()
#endif
#if defined(MOD_POLICIES_UNIT_CLASS_REPLACEMENTS)
	, m_piUnitClassReplacements()
#endif
#if defined(MOD_BALANCE_CORE)
	, m_paiNumCitiesFreeChosenBuilding()
	, m_pabFreeChosenBuildingNewCity()
	, m_pabAllCityFreeBuilding()
	, m_pabNewFoundCityFreeUnit()
	, m_pabNewFoundCityFreeBuilding()
#endif
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	, m_pabHasGlobalMonopoly()
	, m_pabHasStrategicMonopoly()
#endif
	, m_piGoldenAgeGreatPersonRateModifier()
	, m_piYieldFromKills()
	, m_piYieldFromBarbarianKills()
	, m_piYieldChangeTradeRoute()
	, m_piYieldChangesNaturalWonder()
	, m_piYieldChangesPerReligion()
	, m_piYieldChangeWorldWonder()
	, m_piYieldFromMinorDemand()
	, m_piYieldFromWLTKD()
	, m_piCityFeatures()
	, m_piNumBuildings()
	, m_piNumBuildingsInPuppets()
	, m_ppiBuildingClassYieldChange()
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	, m_ppiSpecificGreatPersonRateModifierFromMonopoly()
	, m_ppiSpecificGreatPersonRateChangeFromMonopoly()
#endif
	, m_bVassalLevy()
	, m_iVassalGoldMaintenanceMod()
	, m_iPreviousBestSettlePlot()
	, m_iFoundValueOfCapital()
#if defined(MOD_BALANCE_CORE_MILITARY)
	, m_iFractionOriginalCapitalsUnderControl()
	, m_iAvgUnitExp100()
#endif
#if defined(MOD_BATTLE_ROYALE)
	, m_iNumMilitarySeaUnits()
	, m_iNumMilitaryAirUnits()
	, m_iNumMilitaryLandUnits()
	, m_iMilitarySeaMight()
	, m_iMilitaryAirMight()
	, m_iMilitaryLandMight()
#endif
{
	m_pPlayerPolicies = FNEW(CvPlayerPolicies, c_eCiv5GameplayDLL, 0);
	m_pEconomicAI = FNEW(CvEconomicAI, c_eCiv5GameplayDLL, 0);
	m_pMilitaryAI = FNEW(CvMilitaryAI, c_eCiv5GameplayDLL, 0);
	m_pCitySpecializationAI = FNEW(CvCitySpecializationAI, c_eCiv5GameplayDLL, 0);
	m_pWonderProductionAI = FNEW(CvWonderProductionAI(this, GC.GetGameBuildings()), c_eCiv5GameplayDLL, 0);
	m_pGrandStrategyAI = FNEW(CvGrandStrategyAI, c_eCiv5GameplayDLL, 0);
	m_pDiplomacyAI = FNEW(CvDiplomacyAI, c_eCiv5GameplayDLL, 0);
	m_pReligions = FNEW(CvPlayerReligions, c_eCiv5GameplayDLL, 0);
	m_pReligionAI = FNEW(CvReligionAI, c_eCiv5GameplayDLL, 0);
#if defined(MOD_BALANCE_CORE)
	m_pCorporations = FNEW(CvPlayerCorporations, c_eCiv5GameplayDLL, 0);
	m_pContracts = FNEW(CvPlayerContracts, c_eCiv5GameplayDLL, 0);
#endif
	m_pPlayerTechs = FNEW(CvPlayerTechs, c_eCiv5GameplayDLL, 0);
	m_pFlavorManager = FNEW(CvFlavorManager, c_eCiv5GameplayDLL, 0);
	m_pTacticalAI = FNEW(CvTacticalAI, c_eCiv5GameplayDLL, 0);
	m_pHomelandAI = FNEW(CvHomelandAI, c_eCiv5GameplayDLL, 0);
	m_pMinorCivAI = FNEW(CvMinorCivAI, c_eCiv5GameplayDLL, 0);
	m_pDealAI = FNEW(CvDealAI, c_eCiv5GameplayDLL, 0);
	m_pBuilderTaskingAI = FNEW(CvBuilderTaskingAI, c_eCiv5GameplayDLL, 0);
	m_pDangerPlots = FNEW(CvDangerPlots, c_eCiv5GameplayDLL, 0);
	m_pCityConnections = FNEW(CvCityConnections, c_eCiv5GameplayDLL, 0);
	m_pTreasury = FNEW(CvTreasury, c_eCiv5GameplayDLL, 0);
	m_pTraits = FNEW(CvPlayerTraits, c_eCiv5GameplayDLL, 0);
	m_pEspionage = FNEW(CvPlayerEspionage, c_eCiv5GameplayDLL, 0);
	m_pEspionageAI = FNEW(CvEspionageAI, c_eCiv5GameplayDLL, 0);
	m_pTrade = FNEW(CvPlayerTrade, c_eCiv5GameplayDLL, 0);
	m_pTradeAI = FNEW(CvTradeAI, c_eCiv5GameplayDLL, 0);
	m_pLeagueAI = FNEW(CvLeagueAI, c_eCiv5GameplayDLL, 0);
	m_pCulture = FNEW(CvPlayerCulture, c_eCiv5GameplayDLL, 0);

	m_pNotifications = NULL;
#if defined(MOD_WH_MILITARY_LOG)
	m_pMilitaryLog = NULL; // Not serialized but re-created at every load to keep savegames light
#endif
	m_pDiplomacyRequests = NULL;

	m_aiPlots.clear();
	m_bfEverConqueredBy.ClearAll();

	m_aiGreatWorkYieldChange.clear();
	m_aiSiphonLuxuryCount.clear();
	m_aiTourismBonusTurnsPlayer.clear();

	reset(NO_PLAYER, true);
}
//	--------------------------------------------------------------------------------
CvPlayer::~CvPlayer()
{
#if defined(MOD_BALANCE_CORE) && defined(MOD_UNIT_KILL_STATS)
	if (isMajorCiv() && GC.getAILogging())
		GC.getMap().ExportUnitKillCount(GetID());
#endif

	uninit();

	SAFE_DELETE(m_pDangerPlots);
	SAFE_DELETE(m_pPlayerPolicies);
	SAFE_DELETE(m_pEconomicAI);
	SAFE_DELETE(m_pMilitaryAI);
	SAFE_DELETE(m_pCitySpecializationAI);
	SAFE_DELETE(m_pWonderProductionAI);
	SAFE_DELETE(m_pGrandStrategyAI);
	SAFE_DELETE(m_pDiplomacyAI);
	SAFE_DELETE(m_pReligions);
	SAFE_DELETE(m_pReligionAI);
	SAFE_DELETE(m_pPlayerTechs);
	SAFE_DELETE(m_pFlavorManager);
	SAFE_DELETE(m_pTacticalAI);
	SAFE_DELETE(m_pHomelandAI);
	SAFE_DELETE(m_pMinorCivAI);
	SAFE_DELETE(m_pDealAI);
	SAFE_DELETE(m_pBuilderTaskingAI);
	SAFE_DELETE(m_pCityConnections);
	SAFE_DELETE(m_pNotifications);
#if defined(MOD_WH_MILITARY_LOG)
	SAFE_DELETE(m_pMilitaryLog);
#endif
	SAFE_DELETE(m_pDiplomacyRequests);
	SAFE_DELETE(m_pTreasury);
	SAFE_DELETE(m_pTraits);
	SAFE_DELETE(m_pEspionage);
	SAFE_DELETE(m_pEspionageAI);
	SAFE_DELETE(m_pTrade);
	SAFE_DELETE(m_pTradeAI);
	SAFE_DELETE(m_pLeagueAI);
#if defined(MOD_BALANCE_CORE)
	SAFE_DELETE(m_pCorporations);
	SAFE_DELETE(m_pContracts);
#endif
}


//	--------------------------------------------------------------------------------
void CvPlayer::init(PlayerTypes eID)
{
	LeaderHeadTypes eBestPersonality;
	int iValue;
	int iBestValue;
	int iI, iJ;

	// only allocate notifications for civs that players can play as
	if(eID < MAX_MAJOR_CIVS)
	{
		if (!m_pNotifications)
			m_pNotifications = FNEW(CvNotifications, c_eCiv5GameplayDLL, 0);
#if defined(MOD_WH_MILITARY_LOG)
		if (MOD_WH_MILITARY_LOG && !m_pMilitaryLog)
			m_pMilitaryLog = FNEW(CvEventLog, c_eCiv5GameplayDLL, 0);
#endif
		if (!m_pDiplomacyRequests)
			m_pDiplomacyRequests = FNEW(CvDiplomacyRequests, c_eCiv5GameplayDLL, 0);
	}

	//--------------------------------
	// Init saved data
	reset(eID);

	//--------------------------------
	// Init containers
	m_cities.RemoveAll();

	m_units.RemoveAll();

	m_armyAIs.RemoveAll();

	m_AIOperations.clear();

	//--------------------------------
	// Init non-saved data
	setupGraphical();

	//--------------------------------
	// Init other game data
	CvAssert(getTeam() != NO_TEAM);

	PlayerTypes p = GetID();
	SlotStatus s = CvPreGame::slotStatus(p);

	GET_TEAM(getTeam()).addPlayer(GetID());

	//minors can become free cities...but we have to make sure the UI can know this.
	if (eID >= MAX_MAJOR_CIVS && eID < MAX_CIV_PLAYERS && s == SS_CLOSED && CvPreGame::isMinorCiv(eID))
	{
		m_bPotentiallyAlive = true;
	}

	
	if ((s == SS_TAKEN) || (s == SS_COMPUTER))
	{
		setAlive(true);

		if (GC.getGame().isOption(GAMEOPTION_RANDOM_PERSONALITIES))
		{
			if (!isBarbarian() && !isMinorCiv())
			{
				iBestValue = 0;
				eBestPersonality = NO_LEADER;

				for (iI = 0; iI < GC.getNumLeaderHeadInfos(); iI++)
				{
					if (iI == GD_INT_GET(BARBARIAN_LEADER) || iI == GD_INT_GET(MINOR_CIVILIZATION))
						continue;

					if ((LeaderHeadTypes)iI == getLeaderType())
						continue;

					iValue = (1 + GC.getGame().getJonRandNum(10000, "Choosing Personality"));

					if (iValue > iBestValue)
					{
						iBestValue = iValue;
						eBestPersonality = ((LeaderHeadTypes)iI);
					}
				}

				if (eBestPersonality != NO_LEADER)
				{
					setPersonalityType(eBestPersonality);
				}
			}
		}

		CvAssert(m_pTraits);
		m_pTraits->InitPlayerTraits();

		// Special handling for the Polynesian trait's overriding of embarked unit graphics
		if(m_pTraits->IsEmbarkedAllWater())
		{
			SetEmbarkedGraphicOverride("ART_DEF_UNIT_U_POLYNESIAN_WAR_CANOE");
		}
		else if(m_pTraits->IsEmbarkedToLandFlatCost())
		{
			SetEmbarkedGraphicOverride("ART_DEF_UNIT_U_DANISH_LONGBOAT");
		}

		changeGoldPerUnitTimes100(/*50*/ GD_INT_GET(INITIAL_GOLD_PER_UNIT_TIMES_100));

		ChangeMaxNumBuilders(/*-1*/ GD_INT_GET(DEFAULT_MAX_NUM_BUILDERS));

		changeLevelExperienceModifier(GetPlayerTraits()->GetLevelExperienceModifier());
		changeMaxGlobalBuildingProductionModifier(GetPlayerTraits()->GetMaxGlobalBuildingProductionModifier());
		changeMaxTeamBuildingProductionModifier(GetPlayerTraits()->GetMaxTeamBuildingProductionModifier());
		changeMaxPlayerBuildingProductionModifier(GetPlayerTraits()->GetMaxPlayerBuildingProductionModifier());
		ChangePlotGoldCostMod(GetPlayerTraits()->GetPlotBuyCostModifier());
#if defined(MOD_TRAITS_CITY_WORKING)
		ChangeCityWorkingChange(GetPlayerTraits()->GetCityWorkingChange());
#endif
#if defined(MOD_TRAITS_CITY_AUTOMATON_WORKERS)
		ChangeCityAutomatonWorkersChange(GetPlayerTraits()->GetCityAutomatonWorkersChange());
#endif
		ChangePlotCultureCostModifier(GetPlayerTraits()->GetPlotCultureCostModifier());
		GetTreasury()->ChangeCityConnectionTradeRouteGoldChange(GetPlayerTraits()->GetCityConnectionTradeRouteChange());
		changeWonderProductionModifier(GetPlayerTraits()->GetWonderProductionModifier());
		ChangeImprovementGoldMaintenanceMod(GetPlayerTraits()->GetImprovementMaintenanceModifier());

		for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
		{
			ChangeCityYieldChangeTimes100((YieldTypes)iJ, 100 * GetPlayerTraits()->GetFreeCityYield((YieldTypes)iJ));
			changeYieldRateModifier((YieldTypes)iJ, GetPlayerTraits()->GetYieldRateModifier((YieldTypes)iJ));
		}

		recomputeGreatPeopleModifiers();

		for(iI = 0; iI < NUM_YIELD_TYPES; iI++)
		{
			updateExtraYieldThreshold((YieldTypes)iI);
		}
#if defined(MOD_BALANCE_CORE)
		if (GetPlayerTraits()->GetEspionageModifier() != 0)
		{
			ChangeEspionageModifier(GetPlayerTraits()->GetEspionageModifier());
		}
		if(GetPlayerTraits()->GetEventTourismBoost() > 0)
		{
			ChangeEventTourism(GetPlayerTraits()->GetEventTourismBoost());
		}
		if(GetPlayerTraits()->GetStartingSpyRank() > 0)
		{
			ChangeStartingSpyRank(GetPlayerTraits()->GetStartingSpyRank());
		}
		if(GetPlayerTraits()->GetQuestYieldModifier() > 0)
		{
			ChangeIncreasedQuestInfluence(GetPlayerTraits()->GetQuestYieldModifier());
		}
#endif
		const CvCivilizationInfo& playerCivilizationInfo = getCivilizationInfo();
		for(iI = 0; iI < GC.getNumUnitClassInfos(); ++iI)
		{
			const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
			CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
			if(pkUnitClassInfo != NULL)
			{
				const UnitTypes eUnit = ((UnitTypes)(playerCivilizationInfo.getCivilizationUnits(iI)));
				if(NO_UNIT != eUnit)
				{
					CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
#if defined(MOD_BALANCE_CORE_SETTLER_ADVANCED)
					if (pkUnitInfo != NULL && pkUnitInfo->IsFoundLate())
					{
						if (pkUnitInfo->IsFoodProduction())
						{
							setUnitExtraCost(eUnitClass, getNewCityProductionValue());
						}
					}
					else if (pkUnitInfo != NULL && pkUnitInfo->IsFoundMid())
					{
						if (pkUnitInfo->IsFoodProduction())
						{
							setUnitExtraCost(eUnitClass, getNewCityProductionValue());
						}
					}
#endif
					else if(NULL != pkUnitInfo && pkUnitInfo->IsFound())
					{
						setUnitExtraCost(eUnitClass, getNewCityProductionValue());
					}
				}
			}
		}

		BuildingTypes eFreeBuilding = GetPlayerTraits()->GetFreeBuilding();
		if(eFreeBuilding != NO_BUILDING)
		{
#if defined(MOD_BALANCE_CORE)
			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eFreeBuilding);
			if(pkBuildingInfo)
			{
				int iNumBuilding = GetPlayerTraits()->GetNumFreeBuildings();
				if(iNumBuilding > 0)
				{
					ChangeNumCitiesFreeChosenBuilding(pkBuildingInfo->GetBuildingClassType(), iNumBuilding);
				}
				else
				{
					changeFreeBuildingCount(eFreeBuilding, 1);
				}
			}
#else
					changeFreeBuildingCount(eFreeBuilding, 1);
#endif
		}

		SetGreatGeneralCombatBonus(/*15*/ GD_INT_GET(GREAT_GENERAL_STRENGTH_MOD));
	}
#if defined(MOD_BALANCE_CORE)
	GET_TEAM(getTeam()).DoUpdateBestRoute();
#endif

	m_aiPlots.clear();
	m_bfEverConqueredBy.ClearAll();

	BuildBuildingStepValues();

	AI_init();
}


//	--------------------------------------------------------------------------------
void CvPlayer::uninit()
{
	m_units.RemoveAll();
	m_cities.RemoveAll();

	m_paiNumResourceUsed.clear();
	m_paiNumResourceTotal.clear();
	m_paiResourceGiftedToMinors.clear();
	m_paiResourceExport.clear();
	m_paiResourceImportFromMajor.clear();
	m_paiResourceFromMinors.clear();
	m_paiResourcesSiphoned.clear();
	m_aiNumResourceFromGP.clear();
	m_paiImprovementCount.clear();
	m_paiImprovementBuiltCount.clear();
#if defined(MOD_BALANCE_CORE)
	m_paiTotalImprovementsBuilt.clear();
#endif
#if defined(MOD_IMPROVEMENTS_EXTENSIONS)
	m_piResponsibleForRouteCount.clear();
	m_piResponsibleForImprovementCount.clear();
#endif
	m_paiFreeBuildingCount.clear();
	m_paiBuildingChainSteps.clear();
	m_paiFreePromotionCount.clear();
	m_paiUnitCombatProductionModifiers.clear();
	m_paiUnitCombatFreeExperiences.clear();
	m_paiUnitClassCount.clear();
	m_paiUnitClassMaking.clear();
	m_paiBuildingClassCount.clear();
	m_paiBuildingClassMaking.clear();
	m_paiProjectMaking.clear();
	m_paiHurryCount.clear();
	m_paiHurryModifier.clear();
#if defined(MOD_BALANCE_CORE)
	m_paiNumCitiesFreeChosenBuilding.clear();
	m_aistrInstantYield.clear();
	m_aistrInstantGreatPersonProgress.clear();
	m_pabFreeChosenBuildingNewCity.clear();
	m_pabAllCityFreeBuilding.clear();
	m_pabNewFoundCityFreeUnit.clear();
	m_pabNewFoundCityFreeBuilding.clear();
#endif
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	m_pabHasGlobalMonopoly.clear();
	m_pabHasStrategicMonopoly.clear();
	m_vResourcesWGlobalMonopoly.clear();
	m_vResourcesWStrategicMonopoly.clear();
	m_iCombatAttackBonusFromMonopolies = 0;
	m_iCombatDefenseBonusFromMonopolies = 0;
#endif
	m_pabLoyalMember.clear();
	m_pabGetsScienceFromPlayer.clear();

	m_pPlayerPolicies->Uninit();
	m_pEconomicAI->Uninit();
	m_pMilitaryAI->Uninit();
	m_pCitySpecializationAI->Uninit();
	m_pWonderProductionAI->Uninit();
	m_pGrandStrategyAI->Uninit();
	m_pDiplomacyAI->Uninit();
	m_pReligions->Uninit();
	m_pReligionAI->Uninit();
#if defined(MOD_BALANCE_CORE)
	m_pCorporations->Uninit();
	m_pContracts->Uninit();
#endif
	m_pEspionage->Uninit();
	m_pEspionageAI->Uninit();
	m_pTrade->Uninit();
	m_pTradeAI->Uninit();
	m_pLeagueAI->Uninit();
	m_pPlayerTechs->Uninit();
	m_pFlavorManager->Uninit();
	m_pTacticalAI->Uninit();
	m_pHomelandAI->Uninit();
	m_pMinorCivAI->Uninit();
	m_pDealAI->Uninit();
	m_pBuilderTaskingAI->Uninit();
	m_pCityConnections->Reset();
	if(m_pNotifications)
	{
		m_pNotifications->Uninit();
	}
#if defined(MOD_WH_MILITARY_LOG)
	if(MOD_WH_MILITARY_LOG && m_pMilitaryLog)
	{
		m_pMilitaryLog->Uninit();
	}
#endif
	if(m_pDiplomacyRequests)
	{
		m_pDiplomacyRequests->Uninit();
	}
	m_pTreasury->Uninit();
	m_pTraits->Uninit();

	if(m_pDangerPlots)
	{
		m_pDangerPlots->Uninit();
	}

	m_ppaaiSpecialistExtraYield.clear();
	m_ppiYieldFromYieldGlobal.clear();
	m_ppiPlotYieldChange.clear();
	m_ppiInstantYieldHistoryValues.clear();
	m_ppiInstantTourismPerPlayerHistoryValues.clear();
	m_ppiImprovementYieldChange.clear();
	m_ppiFeatureYieldChange.clear();
	m_ppiResourceYieldChange.clear();
	m_ppiTerrainYieldChange.clear();
	m_ppiTradeRouteYieldChange.clear();
	m_ppiSpecialistYieldChange.clear();
	m_ppiGreatPersonExpendedYield.clear();
	m_piGoldenAgeGreatPersonRateModifier.clear();
	m_ppiUnimprovedFeatureYieldChange.clear();
	m_ppiCityYieldFromUnimprovedFeature.clear();
	m_piYieldFromKills.clear();
	m_piYieldFromBarbarianKills.clear();
	m_ppiBuildingClassYieldChange.clear();
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	m_ppiSpecificGreatPersonRateModifierFromMonopoly.clear();
	m_ppiSpecificGreatPersonRateChangeFromMonopoly.clear();
#endif
	m_ppaaiImprovementYieldChange.clear();

	m_researchQueue.clear();
	m_cityNames.clear();

	// loop through all entries freeing them up
	for(size_t i=0; i<m_AIOperations.size(); i++)
		delete( m_AIOperations[i].second );

	m_AIOperations.clear();

	m_aiPlots.clear();
	m_bfEverConqueredBy.ClearAll();

	FAutoArchive& archive = getSyncArchive();
	archive.clearDelta();

	m_iStartingX = INVALID_PLOT_COORD;
	m_iStartingY = INVALID_PLOT_COORD;
	m_iTotalPopulation = 0;
	m_iTotalLand = 0;
	m_iTotalLandScored = 0;
	m_iCityConnectionHappiness = 0;
	m_iJONSCulturePerTurnForFree = 0;
	m_iJONSCultureCityModifier = 0;
	m_iJONSCulture = 0;
	m_iJONSCultureEverGenerated = 0;
	m_iWondersConstructed = 0;
	m_iCulturePerWonder = 0;
	m_iCultureWonderMultiplier = 0;
	m_iCulturePerTechResearched = 0;
	m_iFaith = 0;
	m_iFaithEverGenerated = 0;
	m_iHappiness = 0;
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	m_iUnhappiness = 0;
	m_iHappinessTotal = 0;
	m_iEmpireNeedsModifierGlobal = 0;
	m_iChangePovertyUnhappinessGlobal = 0;
	m_iChangeDefenseUnhappinessGlobal = 0;
	m_iChangeUnculturedUnhappinessGlobal = 0;
	m_iChangeIlliteracyUnhappinessGlobal = 0;
	m_iChangeMinorityUnhappinessGlobal = 0;
	m_iLandmarksTourismPercentGlobal = 0;
	m_iGreatWorksTourismModifierGlobal = 0;
#endif
#if defined(MOD_BALANCE_CORE)
	m_iCenterOfMassX = 0;
	m_iCenterOfMassY = 0;
	m_iReferenceFoundValue = 10000;
	m_iReformationFollowerReduction = 0;
	m_bIsReformation = false;
#endif
	m_iUprisingCounter = 0;
	m_iExtraHappinessPerLuxury = 0;
	m_iUnhappinessFromUnits = 0;
	m_iUnhappinessFromUnitsMod = 0;
	m_iUnhappinessMod = 0;
	m_iCityCountUnhappinessMod = 0;
	m_iOccupiedPopulationUnhappinessMod = 0;
	m_iCapitalUnhappinessMod = 0;
	m_iCityRevoltCounter = 0;
	m_iHappinessPerGarrisonedUnitCount = 0;
	m_iHappinessPerTradeRouteCount = 0;
	m_iHappinessPerXPopulation = 0;
#if defined(MOD_BALANCE_CORE_POLICIES)
	m_iHappinessPerXPopulationGlobal = 0;
	m_iIdeologyPoint = 0;
	m_iNoXPLossUnitPurchase = 0;
	m_iXCSAlliesLowersPolicyNeedWonders = 0;
	m_iHappinessFromMinorCivs = 0;
	m_iPositiveWarScoreTourismMod = 0;
	m_iIsNoCSDecayAtWar = 0;
	m_iCanBullyFriendlyCS = 0;
	m_iBullyGlobalCSReduction = 0;
#endif
	m_iIsVassalsNoRebel = 0;
	m_iVassalYieldBonusModifier = 0;
	m_iCSYieldBonusModifier = 0;
	m_iHappinessFromLeagues = 0;
	m_iEspionageModifier = 0;
	m_iSpyStartingRank = 0;
#if defined(MOD_RELIGION_CONVERSION_MODIFIERS)
	m_iConversionModifier = 0;
#endif
	m_iExtraLeagueVotes = 0;
	m_iImprovementLeagueVotes = 0;
	m_iFaithToVotes = 0;
	m_iCapitalsToVotes = 0;
	m_iDoFToVotes = 0;
	m_iRAToVotes = 0;
	m_iDefensePactsToVotes = 0;
	m_iGPExpendInfluence = 0;
	m_bIsLeagueAid = false;
	m_bIsLeagueScholar = false;
	m_bIsLeagueArt = false;
	m_iScienceRateFromLeague = 0;
	m_iScienceRateFromLeagueAid = 0;
	m_iLeagueCultureCityModifier = 0;
	m_iWoundedUnitDamageMod = 0;
	m_iUnitUpgradeCostMod = 0;
	m_iBarbarianCombatBonus = 0;
	m_iAlwaysSeeBarbCampsCount = 0;
	m_iHappinessPerCity = 0;
	m_iHappinessPerXPolicies = 0;
	m_iExtraHappinessPerXPoliciesFromPolicies = 0;
	m_iHappinessPerXGreatWorks = 0;
	m_iAdvancedStartPoints = -1;
	m_iAttackBonusTurns = 0;
	m_iCultureBonusTurns = 0;
	m_iTourismBonusTurns = 0;
	m_iGoldenAgeProgressMeter = 0;
	m_iGoldenAgeMeterMod = 0;
	m_iNumGoldenAges = 0;
	m_iGoldenAgeTurns = 0;
	m_iNumUnitGoldenAges = 0;
	m_iStrikeTurns = 0;
	m_iGoldenAgeModifier = 0;
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
	m_iProductionBonusTurnsConquest = 0;
	m_iCultureBonusTurnsConquest = 0;
	m_iFreeGreatPeopleCreated = 0;
	m_iFreeGreatGeneralsCreated = 0;
	m_iFreeGreatAdmiralsCreated = 0;
#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
	m_iFreeGreatMerchantsCreated = 0;
	m_iFreeGreatScientistsCreated = 0;
	m_iFreeGreatEngineersCreated = 0;
#endif
	m_iFreeGreatWritersCreated = 0;
	m_iFreeGreatArtistsCreated = 0;
	m_iFreeGreatMusiciansCreated = 0;
	m_iFreeGreatDiplomatsCreated = 0;
#endif
	m_iGreatPeopleCreated = 0;
	m_iGreatGeneralsCreated = 0;
	m_iGreatAdmiralsCreated = 0;
#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
	m_iGPExtra1Created = 0;
	m_iGPExtra2Created = 0;
	m_iGPExtra3Created = 0;
	m_iGPExtra4Created = 0;
	m_iGPExtra5Created = 0;
	m_iFreeGPExtra1Created = 0;
	m_iFreeGPExtra2Created = 0;
	m_iFreeGPExtra3Created = 0;
	m_iFreeGPExtra4Created = 0;
	m_iFreeGPExtra5Created = 0;
	m_iGPExtra1FromFaith = 0;
	m_iGPExtra2FromFaith = 0;
	m_iGPExtra3FromFaith = 0;
	m_iGPExtra4FromFaith = 0;
	m_iGPExtra5FromFaith = 0;
	m_iGreatMerchantsCreated = 0;
	m_iGreatScientistsCreated = 0;
	m_iGreatEngineersCreated = 0;
#endif
	m_iGreatWritersCreated = 0;
	m_iGreatArtistsCreated = 0;
	m_iGreatMusiciansCreated = 0;
	m_iGreatDiplomatsCreated = 0;
	m_iDiplomatsFromFaith = 0;
	m_iMerchantsFromFaith = 0;
	m_iScientistsFromFaith = 0;
	m_iWritersFromFaith = 0;
	m_iArtistsFromFaith = 0;
	m_iMusiciansFromFaith = 0;
	m_iGeneralsFromFaith = 0;
	m_iAdmiralsFromFaith = 0;
	m_iEngineersFromFaith = 0;
	m_iGreatPeopleThresholdModifier = 0;
	m_iGreatGeneralsThresholdModifier = 0;
	m_iGreatAdmiralsThresholdModifier = 0;
	m_iGreatGeneralCombatBonus = 0;
	m_iAnarchyNumTurns = 0;
	m_iPolicyCostModifier = 0;
	m_iGreatPeopleRateModifier = 0;
	m_iGreatPeopleRateModFromBldgs = 0;
	m_iGreatGeneralRateModifier = 0;
	m_iGreatGeneralRateModFromBldgs = 0;
	m_iDomesticGreatGeneralRateModifier = 0;
	m_iGreatAdmiralRateModifier = 0;
	m_iGreatWriterRateModifier = 0;
	m_iGreatArtistRateModifier = 0;
	m_iGreatMusicianRateModifier = 0;
	m_iGreatMerchantRateModifier = 0;
	m_iGreatDiplomatRateModifier = 0;
	m_iGreatScientistRateModifier = 0;
	m_iGreatScientistBeakerModifier = 0;
	m_iGreatEngineerHurryMod = 0;
	m_iTechCostXCitiesModifier = 0;
	m_iTourismCostXCitiesMod = 0;
	m_iGreatEngineerRateModifier = 0;
	m_iGreatPersonExpendGold = 0;
	m_iMaxGlobalBuildingProductionModifier = 0;
	m_iMaxTeamBuildingProductionModifier = 0;
	m_iMaxPlayerBuildingProductionModifier = 0;
	m_iFreeExperience = 0;
	m_iFreeExperienceFromBldgs = 0;
	m_iFreeExperienceFromMinors = 0;
	m_iFeatureProductionModifier = 0;
	m_iWorkerSpeedModifier = 0;
	m_iImprovementCostModifier = 0;
	m_iImprovementUpgradeRateModifier = 0;
	m_iSpecialistProductionModifier = 0;
	m_iMilitaryProductionModifier = 0;
	m_iSpaceProductionModifier = 0;
	m_iCityDefenseModifier = 0;
	m_iUnitFortificationModifier = 0;
	m_iUnitBaseHealModifier = 0;
	m_iWonderProductionModifier = 0;
	m_iSettlerProductionModifier = 0;
	m_iCapitalSettlerProductionModifier = 0;
	m_iUnitProductionMaintenanceMod = 0;
	m_iUnitGrowthMaintenanceMod = 0;
	m_iPolicyCostBuildingModifier = 0;
	m_iPolicyCostMinorCivModifier = 0;
	m_iInfluenceSpreadModifier = 0;
	m_iExtraVotesPerDiplomat = 0;
	m_iNumNukeUnits = 0;
	m_iNumOutsideUnits = 0;
	m_iBaseFreeUnits = 0;
	m_iBaseFreeMilitaryUnits = 0;
	m_iFreeUnitsPopulationPercent = 0;
	m_iFreeMilitaryUnitsPopulationPercent = 0;
	m_iGoldPerUnit = 0;
	m_iGoldPerMilitaryUnit = 0;
	m_iImprovementGoldMaintenanceMod = 0;
#if defined(MOD_CIV6_WORKER)
	m_iRouteBuilderCostMod = 0;
#endif
	m_iBuildingGoldMaintenanceMod = 0;
	m_iUnitGoldMaintenanceMod = 0;
	m_iUnitSupplyMod = 0;
	m_iExtraUnitCost = 0;
	m_iNumMilitaryUnits = 0;
	m_iHappyPerMilitaryUnit = 0;
	m_iHappinessToCulture = 0;
	m_iHappinessToScience = 0;
	m_iHalfSpecialistUnhappinessCount = 0;
	m_iHalfSpecialistFoodCount = 0;
#if defined(MOD_BALANCE_CORE)
	m_iHalfSpecialistFoodCapitalCount = 0;
	m_iTradeRouteLandDistanceModifier = 0;
	m_iTradeRouteSeaDistanceModifier = 0;
	m_bNullifyInfluenceModifier = false;
#endif
	m_iMilitaryFoodProductionCount = 0;
	m_iGoldenAgeCultureBonusDisabledCount = 0;
	m_iNumMissionarySpreads = 0;
	m_iSecondReligionPantheonCount = 0;
	m_iEnablesSSPartHurryCount = 0;
	m_iEnablesSSPartPurchaseCount = 0;
	m_iConscriptCount = 0;
	m_iMaxConscript = 0;
	m_iHighestUnitLevel = 1;
	m_iOverflowResearch = 0;
	m_iExpModifier = 0;
	m_iExpInBorderModifier = 0;
	m_iLevelExperienceModifier = 0;
	m_iMinorQuestFriendshipMod = 0;
	m_iMinorGoldFriendshipMod = 0;
	m_iMinorFriendshipMinimum = 0;
	m_iMinorFriendshipDecayMod = 0;
	m_iMinorScienceAlliesCount = 0;
	m_iMinorResourceBonusCount = 0;
	m_iAbleToAnnexCityStatesCount = 0;
	m_iOnlyTradeSameIdeology = 0;
#if defined(MOD_BALANCE_CORE)
	m_iSupplyFreeUnits = 0;
	m_strJFDCurrencyName = "";
	m_iJFDCurrency = -1;
	m_iJFDProsperity = 0;
	m_strJFDLegislatureName = "";
	m_strJFDPoliticKey = "";
	m_iJFDPoliticLeader = 0;
	m_iJFDSovereignty = 0;
	m_iJFDGovernment = -1;
	m_iJFDReformCooldown = 0;
	m_iJFDGovernmentCooldown = 0;
	m_iJFDGovernmentCooldownRate = 0;
	m_iJFDReformCooldownRate = 0;
	m_iJFDPiety = 0;
	m_iJFDPietyRate = 0;
	m_iJFDConversionTurn = 0;
	m_bJFDSecularized = false;
	m_iUpgradeCSVassalTerritory = 0;
	m_iArchaeologicalDigTourism = 0;
	m_iGoldenAgeTourism = 0;
	m_iExtraCultureandScienceTradeRoutes = 0;
	m_iRazingSpeedBonus = 0;
	m_iNoPartisans = 0;
	m_iSpawnCooldown = 0;
	m_bTradeRoutesInvulnerable = false;
	m_iTRSpeedBoost = 0;
	m_iVotesPerGPT = 0;
	m_iTRVisionBoost = 0;
	m_iEventTourism = 0;
	m_iEventTourismCS = 0;
	m_iNumHistoricEvent = 0;
	m_iSingleVotes = 0;
	m_iMonopolyModFlat = 0;
	m_iMonopolyModPercent = 0;
	m_iCachedValueOfPeaceWithHuman = 0;
	m_iFaithPurchaseCooldown = 0;
	m_iCSAllies = 0;
	m_iCSFriends = 0;
	m_iCitiesNeedingTerrainImprovements = 0;
	m_piDomainFreeExperience.clear();
#endif
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	m_iPovertyUnhappinessMod = 0;
	m_iDefenseUnhappinessMod = 0;
	m_iUnculturedUnhappinessMod = 0;
	m_iIlliteracyUnhappinessMod = 0;
	m_iMinorityUnhappinessMod = 0;
	m_iPovertyUnhappinessModCapital = 0;
	m_iDefenseUnhappinessModCapital = 0;
	m_iUnculturedUnhappinessModCapital = 0;
	m_iIlliteracyUnhappinessModCapital = 0;
	m_iMinorityUnhappinessModCapital = 0;
	m_iNoUnhappfromXSpecialists = 0;
	m_iHappfromXSpecialists = 0;
	m_iNoUnhappfromXSpecialistsCapital = 0;
	m_iSpecialistFoodChange = 0;
	m_iWarWearinessModifier = 0;
	m_iWarScoreModifier = 0;
	m_iPlayerEventCooldown = 0;
	m_iExtraSupplyPerPopulation = 0;
	m_iCitySupplyFlatGlobal = 0;
	m_iUnitSupplyFromExpendedGP = 0;
	m_iMissionaryExtraStrength = 0;
#endif
#if defined(MOD_BALANCE_CORE_POLICIES)
	m_iGarrisonsOccupiedUnhapppinessMod = 0;
	m_iXPopulationConscription = 0;
	m_iExtraMoves = 0;
	m_iNoUnhappinessExpansion = 0;
	m_iNoUnhappyIsolation = 0;
	m_iDoubleBorderGrowthGA = 0;
	m_iDoubleBorderGrowthWLTKD = 0;
	m_iIncreasedQuestInfluence = 0;
	m_iCultureBombBoost = 0;
	m_iPuppetProdMod = 0;
	m_iOccupiedProdMod = 0;
	m_iGoldInternalTrade = 0;
	m_iFreeWCVotes = 0;
	m_iInfluenceGPExpend = 0;
	m_iFreeTradeRoute = 0;
	m_iFreeSpy = 0;
	m_iReligionDistance = 0;
	m_iPressureMod = 0;
	m_iTradeReligionModifier = 0;
	m_iCityStateCombatModifier = 0;
	m_iInfluenceForLiberation = 0;
	m_iExperienceForLiberation = 0;
	m_iUnitsInLiberatedCities = 0;
	m_iCityCaptureHealGlobal = 0;
#endif
#if defined(MOD_BALANCE_CORE_SPIES)
	m_iMaxAirUnits = 0;
#endif
#if defined(MOD_BALANCE_CORE_BUILDING_INVESTMENTS)
	m_iInvestmentModifier = 0;
	m_bAllowsProductionTradeRoutesGlobal = false;
	m_bAllowsFoodTradeRoutesGlobal = false;
	m_iMissionInfluenceModifier = 0;
	m_iHappinessPerActiveTradeRoute = 0;
	m_iCSResourcesCountMonopolies = 0;
	m_iConquestPerEraBuildingProductionMod = 0;
	m_iAdmiralLuxuryBonus = 0;
	m_iPuppetYieldPenaltyMod = 0;
	m_iNeedsModifierFromAirUnits = 0;
	m_iFlatDefenseFromAirUnits = 0;
#endif
#if defined(MOD_POLICIES_UNIT_CLASS_REPLACEMENTS)
	m_piUnitClassReplacements.clear();
#endif
	m_iCultureBombTimer = 0;
	m_iConversionTimer = 0;
	m_iCapitalCityID = -1;
	m_iCitiesLost = 0;
	m_iMilitaryRating = 0;
	m_iMilitaryMight = 0;
	m_iEconomicMight = 0;
	m_iProductionMight = 0;
	m_iTurnSliceMightRecomputed = -1;
	m_iNewCityExtraPopulation = 0;
	m_iFreeFoodBox = 0;
	m_iScenarioScore1 = 0;
	m_iScenarioScore2 = 0;
	m_iScenarioScore3 = 0;
	m_iScenarioScore4 = 0;
	m_iScoreFromFutureTech = 0;
	m_iTurnLastAttackedMinorCiv = -1;
	m_iCombatExperienceTimes100 = 0;
	m_iLifetimeCombatExperienceTimes100 = 0;
	m_iNavalCombatExperienceTimes100 = 0;
	m_iBorderObstacleCount = 0;
#if defined(HH_MOD_BUILDINGS_FRUITLESS_PILLAGE)
	m_iBorderGainlessPillageCount = 0;
#endif
	m_iPopRushHurryCount = 0;
	m_uiStartTime = 0;
	m_bHasUUPeriod = false;
	m_iTotalImprovementsBuilt = 0;
	m_iCostNextPolicy = 0;
	m_iNumBuilders = 0;
	m_iMaxNumBuilders = 0;
	m_iCityStrengthMod = 0;
	m_iCityGrowthMod = 0;
	m_iCapitalGrowthMod = 0;
	m_iNumPlotsBought = 0;
	m_iPlotGoldCostMod = 0;
#if defined(MOD_TRAITS_CITY_WORKING) || defined(MOD_BUILDINGS_CITY_WORKING) || defined(MOD_POLICIES_CITY_WORKING) || defined(MOD_TECHS_CITY_WORKING)
	m_iCityWorkingChange = 0;
#endif
#if defined(MOD_TRAITS_CITY_AUTOMATON_WORKERS) || defined(MOD_BUILDINGS_CITY_AUTOMATON_WORKERS) || defined(MOD_POLICIES_CITY_AUTOMATON_WORKERS) || defined(MOD_TECHS_CITY_AUTOMATON_WORKERS)
	m_iCityAutomatonWorkersChange = 0;
#endif
	m_iCachedGoldRate = 0;
	m_iPlotCultureCostModifier = 0;
	m_iPlotCultureExponentModifier = 0;
	m_iNumCitiesPolicyCostDiscount = 0;
	m_iGarrisonedCityRangeStrikeModifier = 0;
	m_iGarrisonFreeMaintenanceCount = 0;
	m_iNumCitiesFreeCultureBuilding = 0;
	m_iNumCitiesFreeFoodBuilding = 0;
	m_iUnitPurchaseCostModifier = 0;
	m_iAllFeatureProduction = 0;
	m_iCityDistanceHighwaterMark = 1;
	m_iOriginalCapitalX = -1;
	m_iOriginalCapitalY = -1;
	m_iHolyCityX = -1;
	m_iHolyCityY = -1;
	m_iNumWonders = 0;
	m_iNumPolicies = 0;
	m_iNumGreatPeople = 0;
	m_iHolyCityID = -1;
	m_iTurnsSinceSettledLastCity = -1;
	m_iNumNaturalWondersDiscoveredInArea = 0;
	m_iStrategicResourceMod = 0;
	m_iSpecialistCultureChange = 0;
	m_iGreatPeopleSpawnCounter = -1;
	m_iFreeTechCount = 0;
	m_iMedianTechPercentage = 50;
	m_iNumFreePolicies = 0;
	m_iNumFreePoliciesEver = 0;
	m_iNumFreeTenets = 0;
	m_iNumFreeGreatPeople = 0;
	m_iNumMayaBoosts = 0;
	m_iNumFaithGreatPeople = 0;
	m_iNumArchaeologyChoices = 0;
	m_eFaithPurchaseType = NO_AUTOMATIC_FAITH_PURCHASE;
	m_iFaithPurchaseIndex = 0;
	m_iLastSliceMoved = 0;

	m_bNoNewWars = false;
	m_bTerribleShapeForWar = false;
	m_bHasBetrayedMinorCiv = false;
	m_bAlive = false;
	m_bEverAlive = false;
	m_bPotentiallyAlive = false;
	m_bTurnActive = false;
	m_bAutoMoves = false;
	m_bProcessedAutoMoves = false;
	m_bEndTurn = false;
	m_bDynamicTurnsSimultMode = true;
	m_bPbemNewTurn = false;
	m_bExtendedGame = false;
	m_bFoundedFirstCity = false;
	m_iNumCitiesFounded = 0;
	m_bStrike = false;
	m_bCramped = false;
	m_bLostCapital = false;
	m_eConqueror = NO_PLAYER;
	m_bLostHolyCity = false;
	m_eHolyCityConqueror = NO_PLAYER;
	m_bHasAdoptedStateReligion = false;
	m_lastGameTurnInitialAIProcessed = -1;
	m_bVassalLevy = false;
	m_iVassalGoldMaintenanceMod = 0;
#if defined(MOD_BATTLE_ROYALE)
	m_iNumMilitarySeaUnits = 0;
	m_iNumMilitaryAirUnits = 0; 
	m_iNumMilitaryLandUnits = 0;
	m_iMilitarySeaMight = 0;
	m_iMilitaryAirMight = 0;
	m_iMilitaryLandMight = 0;
#endif

	m_vCityConnectionPlots.clear();
	m_eID = NO_PLAYER;
}


//	--------------------------------------------------------------------------------
// FUNCTION: reset()
// Initializes data members that are serialized.
void CvPlayer::reset(PlayerTypes eID, bool bConstructorCall)
{
	m_syncArchive.reset();
	//--------------------------------
	// Uninit class
	uninit();

	m_eID = eID;
	if(m_eID != NO_PLAYER)
	{
		m_ePersonalityType = CvPreGame::leaderHead(m_eID); //??? Is this repeated data???
	}
	else
	{
		m_ePersonalityType = NO_LEADER;
	}

	// tutorial info
	m_bEverPoppedGoody = false;

	// lazy update scheme ...
	m_iPlotFoundValuesUpdateTurn = -1;

	m_aiCityYieldChange.clear();
	m_aiCityYieldChange.resize(NUM_YIELD_TYPES, 0);

	m_aiCoastalCityYieldChange.clear();
	m_aiCoastalCityYieldChange.resize(NUM_YIELD_TYPES, 0);

	m_aiCapitalYieldChange.clear();
	m_aiCapitalYieldChange.resize(NUM_YIELD_TYPES, 0);

	m_aiCapitalYieldPerPopChange.clear();
	m_aiCapitalYieldPerPopChange.resize(NUM_YIELD_TYPES, 0);

	m_aiCapitalYieldPerPopChangeEmpire.clear();
	m_aiCapitalYieldPerPopChangeEmpire.resize(NUM_YIELD_TYPES, 0);

	m_aiSeaPlotYield.clear();
	m_aiSeaPlotYield.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldRateModifier.clear();
	m_aiYieldRateModifier.resize(NUM_YIELD_TYPES, 0);

#if defined(MOD_BALANCE_CORE_POLICIES)
	m_aiGlobalTourismAlreadyReceived.clear();
	m_aiGlobalTourismAlreadyReceived.resize(NUM_MINOR_CIV_QUEST_TYPES, 0);

	m_aiYieldFromMinors.clear();
	m_aiYieldFromMinors.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromBirth.clear();
	m_aiYieldFromBirth.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromBirthCapital.clear();
	m_aiYieldFromBirthCapital.resize(NUM_YIELD_TYPES, 0);
	
	m_aiYieldFromDeath.clear();
	m_aiYieldFromDeath.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromPillage.clear();
	m_aiYieldFromPillage.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromVictory.clear();
	m_aiYieldFromVictory.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromConstruction.clear();
	m_aiYieldFromConstruction.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromWorldWonderConstruction.clear();
	m_aiYieldFromWorldWonderConstruction.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromTech.clear();
	m_aiYieldFromTech.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromBorderGrowth.clear();
	m_aiYieldFromBorderGrowth.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldGPExpend.clear();
	m_aiYieldGPExpend.resize(NUM_YIELD_TYPES, 0);

	m_aiConquerorYield.clear();
	m_aiConquerorYield.resize(NUM_YIELD_TYPES, 0);

	m_aiFounderYield.clear();
	m_aiFounderYield.resize(NUM_YIELD_TYPES, 0);

	m_aiArtifactYieldBonus.clear();
	m_aiArtifactYieldBonus.resize(NUM_YIELD_TYPES, 0);

	m_aiArtYieldBonus.clear();
	m_aiArtYieldBonus.resize(NUM_YIELD_TYPES, 0);

	m_aiMusicYieldBonus.clear();
	m_aiMusicYieldBonus.resize(NUM_YIELD_TYPES, 0);

	m_aiLitYieldBonus.clear();
	m_aiLitYieldBonus.resize(NUM_YIELD_TYPES, 0);	

	m_aiFilmYieldBonus.clear();
	m_aiFilmYieldBonus.resize(NUM_YIELD_TYPES, 0);

	m_aiRelicYieldBonus.clear();
	m_aiRelicYieldBonus.resize(NUM_YIELD_TYPES, 0);

	m_aiReligionYieldRateModifier.clear();
	m_aiReligionYieldRateModifier.resize(NUM_YIELD_TYPES, 0);

	m_aiGoldenAgeYieldMod.clear();
	m_aiGoldenAgeYieldMod.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromNonSpecialistCitizens.clear();
	m_aiYieldFromNonSpecialistCitizens.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldModifierFromGreatWorks.clear();
	m_aiYieldModifierFromGreatWorks.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldModifierFromActiveSpies.clear();
	m_aiYieldModifierFromActiveSpies.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromDelegateCount.clear();
	m_aiYieldFromDelegateCount.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldForLiberation.clear();
	m_aiYieldForLiberation.resize(NUM_YIELD_TYPES, 0);

	m_aiBuildingClassInLiberatedCities.clear();
	m_aiBuildingClassInLiberatedCities.resize(GC.getNumBuildingClassInfos(), 0);

	m_aiDomainFreeExperiencePerGreatWorkGlobal.clear();
	m_aiDomainFreeExperiencePerGreatWorkGlobal.resize(NUM_DOMAIN_TYPES, 0);

	m_aiBestMilitaryCombatClassCity.clear();
	m_aiBestMilitaryCombatClassCity.resize(GC.getNumUnitCombatClassInfos(), 0);

	m_aiBestMilitaryDomainCity.clear();
	m_aiBestMilitaryDomainCity.resize(NUM_DOMAIN_TYPES, 0);

	m_aiEventChoiceDuration.clear();
	m_aiEventChoiceDuration.resize(GC.getNumEventChoiceInfos(), 0);

	m_aiEventIncrement.clear();
	m_aiEventIncrement.resize(GC.getNumEventInfos(), 0);

	m_aiEventCooldown.clear();
	m_aiEventCooldown.resize(GC.getNumEventInfos(), 0);

	m_abEventActive.clear();
	m_abEventActive.resize(GC.getNumEventInfos(), false);

	m_abEventChoiceActive.clear();
	m_abEventChoiceActive.resize(GC.getNumEventChoiceInfos(), false);

	m_abEventFired.clear();
	m_abEventFired.resize(GC.getNumEventInfos(), false);

	m_abEventChoiceFired.clear();
	m_abEventChoiceFired.resize(GC.getNumEventChoiceInfos(), false);

	m_ownedNaturalWonders.clear();

	m_paiUnitClassProductionModifiers.clear();
	m_paiUnitClassProductionModifiers.resize(GC.getNumUnitClassInfos(), 0);

	m_aiCityYieldModFromMonopoly.clear();
	m_aiCityYieldModFromMonopoly.resize(NUM_YIELD_TYPES, 0);

	m_neededUnitAITypes.clear();

	m_abActiveContract.clear();
	m_abActiveContract.resize(GC.getNumContractInfos(), false);

	m_aistrInstantYield.clear();
	m_aistrInstantYield.resize(NUM_INSTANT_YIELD_TYPES);

	m_aistrInstantGreatPersonProgress.clear();

	m_viInstantYieldsTotal.clear();
	m_viInstantYieldsTotal.resize(NUM_YIELD_TYPES, 0);

	m_miLocalInstantYieldsTotal.clear();
	m_aiYieldHistory.clear();

#endif
#if defined(MOD_BALANCE_CORE)
	m_piDomainFreeExperience.clear();
#endif

#if defined(MOD_POLICIES_UNIT_CLASS_REPLACEMENTS)
	m_piUnitClassReplacements.clear();
#endif

	m_aiCapitalYieldRateModifier.clear();
	m_aiCapitalYieldRateModifier.resize(NUM_YIELD_TYPES, 0);

	m_aiGreatWorkYieldChange.clear();
	m_aiGreatWorkYieldChange.resize(NUM_YIELD_TYPES, 0);

	m_aiExtraYieldThreshold.clear();
	m_aiExtraYieldThreshold.resize(NUM_YIELD_TYPES, 0);

	m_aiSpecialistExtraYield.clear();
	m_aiSpecialistExtraYield.resize(NUM_YIELD_TYPES, 0);

	m_aiPlayerNumTurnsAtPeace.clear();
	m_aiPlayerNumTurnsAtPeace.resize(MAX_PLAYERS, 0);

	m_aiPlayerNumTurnsAtWar.clear();
	m_aiPlayerNumTurnsAtWar.resize(MAX_PLAYERS, 0);

	m_aiPlayerNumTurnsSinceCityCapture.clear();
	m_aiPlayerNumTurnsSinceCityCapture.resize(MAX_PLAYERS, 0);

	m_aiWarValueLost.clear();
	m_aiWarValueLost.resize(MAX_PLAYERS, 0);

	m_aiWarDamageValue.clear();
	m_aiWarDamageValue.resize(MAX_PLAYERS, 0);

	m_aiNumUnitsBuilt.clear();
	m_aiNumUnitsBuilt.resize(GC.getNumUnitInfos());

	m_aiProximityToPlayer.clear();
	m_aiProximityToPlayer.resize(MAX_PLAYERS, 0);

	m_aiResearchAgreementCounter.clear();
	m_aiResearchAgreementCounter.resize(MAX_PLAYERS, 0);

	m_aiSiphonLuxuryCount.clear();
	m_aiSiphonLuxuryCount.resize(MAX_PLAYERS, 0);
	
	m_aiTourismBonusTurnsPlayer.clear();
	m_aiTourismBonusTurnsPlayer.resize(MAX_PLAYERS, 0);

	m_aOptions.clear();

	m_strReligionKey = "";
	m_strScriptData = "";
	m_strEmbarkedGraphicOverride = "";

	if(!bConstructorCall)
	{
		//important, do this first
		m_cities.RemoveAll();
		m_units.RemoveAll();
		m_armyAIs.RemoveAll();

		// loop through all entries freeing them up
		for(size_t i=0; i<m_AIOperations.size(); i++)
			delete(m_AIOperations[i].second);
		m_AIOperations.clear();

		CvAssertMsg(0 < GC.getNumResourceInfos(), "GC.getNumResourceInfos() is not greater than zero but it is used to allocate memory in CvPlayer::reset");
		m_paiNumResourceUsed.clear();
		m_paiNumResourceUsed.resize(GC.getNumResourceInfos(), 0);

		m_paiNumResourceTotal.clear();
		m_paiNumResourceTotal.resize(GC.getNumResourceInfos(), 0);

		m_paiResourceGiftedToMinors.clear();
		m_paiResourceGiftedToMinors.resize(GC.getNumResourceInfos(), 0);

		m_paiResourceExport.clear();
		m_paiResourceExport.resize(GC.getNumResourceInfos(), 0);

		m_paiResourceImportFromMajor.clear();
		m_paiResourceImportFromMajor.resize(GC.getNumResourceInfos(), 0);

		m_paiResourceFromMinors.clear();
		m_paiResourceFromMinors.resize(GC.getNumResourceInfos(), 0);

		m_paiResourcesSiphoned.clear();
		m_paiResourcesSiphoned.resize(GC.getNumResourceInfos(), 0);

		m_aiNumResourceFromGP.clear();
		m_aiNumResourceFromGP.resize(GC.getNumResourceInfos(), 0);

		CvAssertMsg(0 < GC.getNumImprovementInfos(), "GC.getNumImprovementInfos() is not greater than zero but it is used to allocate memory in CvPlayer::reset");
		m_paiImprovementCount.clear();
		m_paiImprovementCount.resize(GC.getNumImprovementInfos(), 0);
		m_paiImprovementBuiltCount.clear();
		m_paiImprovementBuiltCount.resize(GC.getNumImprovementInfos(), 0);
#if defined(MOD_BALANCE_CORE)
		m_paiTotalImprovementsBuilt.clear();
		m_paiTotalImprovementsBuilt.resize(GC.getNumImprovementInfos(), 0);
#endif

#if defined(MOD_IMPROVEMENTS_EXTENSIONS)
		m_piResponsibleForRouteCount.clear();
		m_piResponsibleForImprovementCount.clear();
#endif

		m_paiUnitCombatProductionModifiers.clear();
		m_paiUnitCombatProductionModifiers.resize(GC.getNumUnitCombatClassInfos(), 0);

		m_paiUnitCombatFreeExperiences.clear();
		m_paiUnitCombatFreeExperiences.resize(GC.getNumUnitCombatClassInfos(), 0);

		m_paiBuildingChainSteps.clear();
		m_paiBuildingChainSteps.resize(GC.getNumBuildingInfos(), 0);

		m_paiFreeBuildingCount.clear();
		m_paiFreeBuildingCount.resize(GC.getNumBuildingInfos(), 0);

		m_paiFreePromotionCount.clear();
		m_paiFreePromotionCount.resize(GC.getNumPromotionInfos(), 0);

		m_paiUnitClassCount.clear();
		m_paiUnitClassCount.resize(GC.getNumUnitClassInfos(), 0);

		m_paiUnitClassMaking.clear();
		m_paiUnitClassMaking.resize(GC.getNumUnitClassInfos(), 0);

		m_paiBuildingClassCount.clear();
		m_paiBuildingClassCount.resize(GC.getNumBuildingClassInfos(), 0);

		m_paiBuildingClassMaking.clear();
		m_paiBuildingClassMaking.resize(GC.getNumBuildingClassInfos(), 0);

		m_paiProjectMaking.clear();
		m_paiProjectMaking.resize(GC.getNumProjectInfos(), 0);

		m_paiHurryCount.clear();
		m_paiHurryCount.resize(GC.getNumHurryInfos(), 0);

		m_paiHurryModifier.clear();
		m_paiHurryModifier.resize(GC.getNumHurryInfos(), 0);

#if defined(MOD_BALANCE_CORE)
		m_paiJFDPoliticPercent.clear();
		m_paiJFDPoliticPercent.resize(MAX_CIV_PLAYERS, 0);

		m_paiResourceFromCSAlliances.clear();
		m_paiResourceFromCSAlliances.resize(GC.getNumResourceInfos(), 0);

		m_paiResourceShortageValue.clear();
		m_paiResourceShortageValue.resize(GC.getNumResourceInfos(), 0);

		m_paiNumCitiesFreeChosenBuilding.clear();
		m_paiNumCitiesFreeChosenBuilding.resize(GC.getNumBuildingClassInfos(), 0);

		m_pabFreeChosenBuildingNewCity.clear();
		m_pabFreeChosenBuildingNewCity.resize(GC.getNumBuildingClassInfos(), false);

		m_pabAllCityFreeBuilding.clear();
		m_pabAllCityFreeBuilding.resize(GC.getNumBuildingClassInfos(), false);

		m_pabNewFoundCityFreeUnit.clear();
		m_pabNewFoundCityFreeUnit.resize(GC.getNumUnitClassInfos(), false);

		m_pabNewFoundCityFreeBuilding.clear();
		m_pabNewFoundCityFreeBuilding.resize(GC.getNumBuildingClassInfos(), false);


		m_paiBuildingClassCulture.clear();
		m_paiBuildingClassCulture.resize(GC.getNumBuildingClassInfos(), 0);
#endif
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
		m_pabHasGlobalMonopoly.clear();
		m_pabHasGlobalMonopoly.resize(GC.getNumResourceInfos(), false);
		m_pabHasStrategicMonopoly.clear();
		m_pabHasStrategicMonopoly.resize(GC.getNumResourceInfos(), false);
		m_vResourcesWGlobalMonopoly.clear();
		m_vResourcesWStrategicMonopoly.clear();
		m_iCombatAttackBonusFromMonopolies = 0;
		m_iCombatDefenseBonusFromMonopolies = 0;
#endif
		m_pabLoyalMember.clear();
		m_pabLoyalMember.resize(GC.getNumVoteSourceInfos(), true);

		m_pabGetsScienceFromPlayer.clear();
		m_pabGetsScienceFromPlayer.resize(MAX_CIV_PLAYERS, false);

		m_pEconomicAI->Init(GC.GetGameEconomicAIStrategies(), this);
		m_pMilitaryAI->Init(GC.GetGameMilitaryAIStrategies(), this, GetDiplomacyAI());
		m_pCitySpecializationAI->Init(GC.GetGameCitySpecializations(), this);
		m_pWonderProductionAI->Init(GC.GetGameBuildings(), this, false);
		m_pGrandStrategyAI->Init(GC.GetGameAIGrandStrategies(), this);
		m_pDiplomacyAI->Init(this);
		m_pReligions->Init(this);
		m_pReligionAI->Init(GC.GetGameBeliefs(), this);
#if defined(MOD_BALANCE_CORE)
		m_pCorporations->Init(this);
		m_pContracts->Init(this);
#endif
		m_pPlayerPolicies->Init(GC.GetGamePolicies(), this, false);
		m_pPlayerTechs->Init(GC.GetGameTechs(), this, false);
		m_pTacticalAI->Init(this);
		m_pHomelandAI->Init(this);
		m_pMinorCivAI->Init(this);
		m_pDealAI->Init(this);
		m_pBuilderTaskingAI->Init(this);
		m_pCityConnections->Init(this);
		if(m_pNotifications)
		{
			m_pNotifications->Init(eID);
		}
#if defined(MOD_WH_MILITARY_LOG)
		if(MOD_WH_MILITARY_LOG && m_pMilitaryLog)
		{
			m_pMilitaryLog->Init(eID);
		}
#endif
		if(m_pDiplomacyRequests)
		{
			m_pDiplomacyRequests->Init(eID);
		}
		m_pDangerPlots->Init(eID, false /*bAllocate*/);
		m_pTreasury->Init(this);
		m_pTraits->Init(GC.GetGameTraits(), this);
		m_pEspionage->Init(this);
		m_pEspionageAI->Init(this);
		m_pTrade->Init(this);
		m_pTradeAI->Init(this);
		m_pLeagueAI->Init(this);
		m_pCulture->Init(this);

		// Set up flavor manager
		m_pFlavorManager->Init(this);

		// And if this is a real player, hook up the player-level flavor recipients
		PlayerTypes p = GetID();
		if(p != NO_PLAYER)
		{
			SlotStatus s = CvPreGame::slotStatus(p);
			if((s == SS_TAKEN || s == SS_COMPUTER) && !isBarbarian())
			{
				m_pFlavorManager->AddFlavorRecipient(m_pPlayerTechs);
				m_pFlavorManager->AddFlavorRecipient(m_pPlayerPolicies);
				m_pFlavorManager->AddFlavorRecipient(m_pWonderProductionAI);
			}
		}

		Firaxis::Array< int, NUM_YIELD_TYPES > yield;
		for(unsigned int j = 0; j < NUM_YIELD_TYPES; ++j)
		{
			yield[j] = 0;
		}

		m_ppaaiSpecialistExtraYield.clear();
		m_ppaaiSpecialistExtraYield.resize(GC.getNumSpecialistInfos());
		for(unsigned int i = 0; i < m_ppaaiSpecialistExtraYield.size(); ++i)
		{
			m_ppaaiSpecialistExtraYield[i] = yield;
		}

		m_ppiYieldFromYieldGlobal.clear();
		m_ppiYieldFromYieldGlobal.resize(NUM_YIELD_TYPES);
		for (unsigned int i = 0; i < m_ppiYieldFromYieldGlobal.size(); ++i)
		{
			m_ppiYieldFromYieldGlobal[i] = yield;
		}

		m_ppiPlotYieldChange.clear();
		m_ppiPlotYieldChange.resize(GC.getNumPlotInfos());
		for(unsigned int i = 0; i < m_ppiPlotYieldChange.size(); ++i)
		{
			m_ppiPlotYieldChange[i] = yield;
		}

		m_ppiInstantYieldHistoryValues.clear();
		m_ppiInstantTourismPerPlayerHistoryValues.clear();

		m_ppiImprovementYieldChange.clear();
		m_ppiImprovementYieldChange.resize(GC.getNumImprovementInfos());
		for(unsigned int i = 0; i < m_ppiImprovementYieldChange.size(); ++i)
		{
			m_ppiImprovementYieldChange[i] = yield;
		}

		m_ppiFeatureYieldChange.clear();
		m_ppiFeatureYieldChange.resize(GC.getNumFeatureInfos());
		for(unsigned int i = 0; i < m_ppiFeatureYieldChange.size(); ++i)
		{
			m_ppiFeatureYieldChange[i] = yield;
		}
		
		m_ppiResourceYieldChange.clear();
		m_ppiResourceYieldChange.resize(GC.getNumResourceInfos());
		for(unsigned int i = 0; i < m_ppiResourceYieldChange.size(); ++i)
		{
			m_ppiResourceYieldChange[i] = yield;
		}
		
		m_ppiTerrainYieldChange.clear();
		m_ppiTerrainYieldChange.resize(GC.getNumTerrainInfos());
		for(unsigned int i = 0; i < m_ppiTerrainYieldChange.size(); ++i)
		{
			m_ppiTerrainYieldChange[i] = yield;
		}
		
		m_ppiTradeRouteYieldChange.clear();
		m_ppiTradeRouteYieldChange.resize(NUM_DOMAIN_TYPES);
		for(unsigned int i = 0; i < m_ppiTradeRouteYieldChange.size(); ++i)
		{
			m_ppiTradeRouteYieldChange[i] = yield;
		}
		
		m_ppiSpecialistYieldChange.clear();
		m_ppiSpecialistYieldChange.resize(GC.getNumSpecialistInfos());
		for(unsigned int i = 0; i < m_ppiSpecialistYieldChange.size(); ++i)
		{
			m_ppiSpecialistYieldChange[i] = yield;
		}
		
		m_ppiGreatPersonExpendedYield.clear();
		m_ppiGreatPersonExpendedYield.resize(GC.getNumGreatPersonInfos());
		for(unsigned int i = 0; i < m_ppiGreatPersonExpendedYield.size(); ++i)
		{
			m_ppiGreatPersonExpendedYield[i] = yield;
		}
		
		m_piGoldenAgeGreatPersonRateModifier.clear();
		m_piGoldenAgeGreatPersonRateModifier.resize(GC.getNumGreatPersonInfos(), 0);

		m_ppiUnimprovedFeatureYieldChange.clear();
		m_ppiUnimprovedFeatureYieldChange.resize(GC.getNumFeatureInfos());
		for(unsigned int i = 0; i < m_ppiUnimprovedFeatureYieldChange.size(); ++i)
		{
			m_ppiUnimprovedFeatureYieldChange[i] = yield;
		}
		
		m_ppiCityYieldFromUnimprovedFeature.clear();
		m_ppiCityYieldFromUnimprovedFeature.resize(GC.getNumFeatureInfos());
		for(unsigned int i = 0; i < m_ppiCityYieldFromUnimprovedFeature.size(); ++i)
		{
			m_ppiCityYieldFromUnimprovedFeature[i] = yield;
		}
		
		m_piYieldFromKills.clear();
		m_piYieldFromKills.resize(NUM_YIELD_TYPES, 0);

		m_piYieldFromBarbarianKills.clear();
		m_piYieldFromBarbarianKills.resize(NUM_YIELD_TYPES, 0);

		m_piYieldChangeTradeRoute.clear();
		m_piYieldChangeTradeRoute.resize(NUM_YIELD_TYPES, 0);

		m_piYieldChangesNaturalWonder.clear();
		m_piYieldChangesNaturalWonder.resize(NUM_YIELD_TYPES, 0);

		m_piYieldChangesPerReligion.clear();
		m_piYieldChangesPerReligion.resize(NUM_YIELD_TYPES, 0);

		m_piYieldChangeWorldWonder.clear();
		m_piYieldChangeWorldWonder.resize(NUM_YIELD_TYPES, 0);

		m_piYieldFromMinorDemand.clear();
		m_piYieldFromMinorDemand.resize(NUM_YIELD_TYPES, 0);

		m_piYieldFromWLTKD.clear();
		m_piYieldFromWLTKD.resize(NUM_YIELD_TYPES, 0);

		m_piCityFeatures.clear();
		m_piCityFeatures.resize(GC.getNumFeatureInfos(), 0);

		m_piNumBuildings.clear();
		m_piNumBuildings.resize(GC.getNumBuildingInfos(), 0);

		m_piNumBuildingsInPuppets.clear();
		m_piNumBuildingsInPuppets.resize(GC.getNumBuildingInfos(), 0);

		m_ppiBuildingClassYieldChange.clear();
		m_ppiBuildingClassYieldChange.resize(GC.getNumBuildingClassInfos());
		for(unsigned int i = 0; i < m_ppiBuildingClassYieldChange.size(); ++i)
		{
			m_ppiBuildingClassYieldChange[i] = yield;
		}

#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
		m_ppiSpecificGreatPersonRateModifierFromMonopoly.clear();
		m_ppiSpecificGreatPersonRateChangeFromMonopoly.clear();
#endif

		m_ppaaiImprovementYieldChange.clear();
		m_ppaaiImprovementYieldChange.resize(GC.getNumImprovementInfos());
		for(unsigned int i = 0; i < m_ppaaiImprovementYieldChange.size(); ++i)
		{
			m_ppaaiImprovementYieldChange[i] = yield;
		}

		m_aUnitExtraCosts.clear();

		AI_reset();
	}

	m_vCityConnectionPlots.clear();
	m_iNumUnitsSuppliedCached = -1;
	m_bUnlockedGrowthAnywhereThisTurn = false;

	m_iPlotFoundValuesUpdateTurn = -1;
	m_iPreviousBestSettlePlot = -1;
	m_iFoundValueOfCapital = 0;
}

//	--------------------------------------------------------------------------------
/// This is called after the map and other game constructs have been setup and just before the game starts.
void CvPlayer::gameStartInit()
{
#if defined(MOD_BALANCE_CORE)
	//make sure the non-serialized infos are up to date
	m_pDangerPlots->Init(GetID(), true);
#else
	// if the game is loaded, don't init the danger plots. This was already done in the serialization process.
	if(CvPreGame::gameStartType() != GAME_LOADED)
	{
		if(!GC.GetEngineUserInterface()->IsLoadedGame())
		{
			InitDangerPlots(); // moved this up because everyone should have danger plots inited. This is bad because saved games get much bigger for no reason.
		}
	}
#endif
	verifyAlive();
	if(!isAlive())
	{
		return;
	}

	if(!GC.GetEngineUserInterface()->IsLoadedGame())
	{
		UpdatePlots();
	}

	if (GC.getGame().isNetworkMultiPlayer())
	{
		m_syncArchive.initSyncVars(*FNEW(CvSyncArchive<CvPlayer>::SyncVars(*this), c_eCiv5GameplayDLL, 0));
	}
	else
	{
		m_syncArchive.destroySyncVars();
	}
}


//////////////////////////////////////
// graphical only setup
//////////////////////////////////////
void CvPlayer::setupGraphical()
{
	// Setup m_cities
	int iLoop;
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->setupGraphical();
	}

	// Setup m_units
	for(CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		pLoopUnit->setupGraphical();
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::initFreeState(CvGameInitialItemsOverrides& kOverrides)
{
	const CvHandicapInfo& kHandicapInfo = getHandicapInfo();

	// Starting Gold
	if(kOverrides.GrantInitialGoldPerPlayer[GetID()])
	{
		int iInitialGold = kHandicapInfo.getStartingGold() + GC.getGame().getStartEraInfo().getStartingGold();
		iInitialGold *= GC.getGame().getGameSpeedInfo().getTrainPercent();
		iInitialGold /= 100;
		GetTreasury()->SetGold(iInitialGold);
	}

	// Free Culture
	if(kOverrides.GrantInitialCulturePerPlayer[GetID()])
	{
		int iInitialCulture = kHandicapInfo.getStartingPolicyPoints() + GC.getGame().getStartEraInfo().getStartingCulture();
		iInitialCulture *= GC.getGame().getGameSpeedInfo().getTrainPercent();
		iInitialCulture /= 100;
		setJONSCulture(iInitialCulture);

		 // I think policy points is a better name than Jon's Culture, don't you?
		ChangeJONSCulturePerTurnForFree(kHandicapInfo.getFreeCulturePerTurn()); // No, IMNSHO ;P
	}
	// Extra Happiness from Luxuries
	ChangeExtraHappinessPerLuxury(kHandicapInfo.getExtraHappinessPerLuxury());

	// Free starting Resources
	for(int iLoop = 0; iLoop < GC.getNumResourceInfos(); iLoop++)
	{
		const ResourceTypes eResource = static_cast<ResourceTypes>(iLoop);
		CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
		if(pkResource)
		{
			if(pkResource->getStartingResourceQuantity() != 0)
			{
				changeNumResourceTotal(eResource, pkResource->getStartingResourceQuantity());
			}
		}

	}

	CalculateNetHappiness();

	clearResearchQueue();
}

//	--------------------------------------------------------------------------------
void CvPlayer::initFreeUnits(CvGameInitialItemsOverrides& /*kOverrides*/)
{
	UnitTypes eLoopUnit;
	int iFreeCount;
	int iDefaultAI;
	int iI, iJ;

	const CvEraInfo& gameStartEra = GC.getGame().getStartEraInfo();
	const CvHandicapInfo& gameHandicap = GC.getGame().getHandicapInfo();
	const CvHandicapInfo& playerHandicap = getHandicapInfo();
	const CvCivilizationInfo& playerCivilization = getCivilizationInfo();
#if defined(MOD_BALANCE_CORE)
	int iFree = 0;
#endif
	for(iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
	{
		const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
		CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
		if(pkUnitClassInfo)
		{
			eLoopUnit = (UnitTypes)playerCivilization.getCivilizationUnits(iI);

			if(eLoopUnit != NO_UNIT)
			{
				iFreeCount = playerCivilization.getCivilizationFreeUnitsClass(iI);
				iDefaultAI = playerCivilization.getCivilizationFreeUnitsDefaultUnitAI(iI);
#if defined(MOD_BALANCE_CORE)
				if(!canTrainUnit(eLoopUnit) && iDefaultAI != UNITAI_SETTLE) 
				{
					// Loop through adding the available units
					for(int iUnitLoop = 0; iUnitLoop < GC.GetGameUnits()->GetNumUnits(); iUnitLoop++)
					{
						const UnitTypes eUnit = static_cast<UnitTypes>(iUnitLoop);
						CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
						if(pkUnitInfo)
						{
							// Make sure this unit can be built now
							if(canTrainUnit(eUnit))
							{
								// Make sure it matches the requested unit AI type
								if(pkUnitInfo->GetDefaultUnitAIType() == iDefaultAI)
								{
									eLoopUnit = eUnit;
									break;
								}
							}
						}
					}
				}
#endif
				iFreeCount *= (gameStartEra.getStartingUnitMultiplier() + ((!isHuman()) ? gameHandicap.getAIStartingUnitMultiplier() : 0));

				// City states only get 1 of something
				if(isMinorCiv() && iFreeCount > 1)
					iFreeCount = 1;

				for(iJ = 0; iJ < iFreeCount; iJ++)
				{
					addFreeUnit(eLoopUnit,(UnitAITypes)iDefaultAI);
#if defined(MOD_BALANCE_CORE)
					if(iDefaultAI != UNITAI_SETTLE)
					{
						iFree++;
					}
#endif
				}
			}
		}
	}

	// Trait units
	int iUnitClass = GetPlayerTraits()->GetFirstFreeUnit(NO_TECH);
	while(iUnitClass != NO_UNITCLASS)
	{
		eLoopUnit = (UnitTypes)playerCivilization.getCivilizationUnits(iUnitClass);
		iDefaultAI = GC.GetGameUnits()->GetEntry(eLoopUnit)->GetDefaultUnitAIType();
		addFreeUnit(eLoopUnit,(UnitAITypes)iDefaultAI);

		// Another?
		iUnitClass = GetPlayerTraits()->GetNextFreeUnit();
	}

	// Defensive units
	iFreeCount = gameStartEra.getStartingDefenseUnits();
	iFreeCount += playerHandicap.getStartingDefenseUnits();
	if(!isHuman())
		iFreeCount += gameHandicap.getAIStartingDefenseUnits();
#if defined(MOD_BALANCE_CORE)
	iFreeCount -= iFree;
#endif
	if(iFreeCount > 0 && !isMinorCiv())
		addFreeUnitAI(UNITAI_DEFENSE, iFreeCount);

	// Worker units
	iFreeCount = gameStartEra.getStartingWorkerUnits();
	iFreeCount += playerHandicap.getStartingWorkerUnits();

	if(!isHuman())
		iFreeCount += gameHandicap.getAIStartingWorkerUnits();

	if(iFreeCount > 0 && !isMinorCiv())
		addFreeUnitAI(UNITAI_WORKER, iFreeCount);

	// Explore units
	iFreeCount = gameStartEra.getStartingExploreUnits();
	iFreeCount += playerHandicap.getStartingExploreUnits();

	if(!isHuman())
		iFreeCount += gameHandicap.getAIStartingExploreUnits();

	if(iFreeCount > 0 && !isMinorCiv())
		addFreeUnitAI(UNITAI_EXPLORE, iFreeCount);

#if defined(MOD_BALANCE_CORE)
	//Minor Civ Units
	if(isMinorCiv())
	{
		iFreeCount = gameStartEra.getStartingMinorDefenseUnits();
		iFreeCount += gameHandicap.getStartingMinorDefenseUnits();
		if(iFreeCount > 0)
		{
			addFreeUnitAI(UNITAI_DEFENSE, iFreeCount);
		}
	}
#endif
	// If we only have one military unit and it's on defense then change its AI to explore
	if(GetNumUnitsWithUnitAI(UNITAI_EXPLORE) == 0)
	{
#if defined(MOD_BALANCE_CORE)
		if(!isMinorCiv())
		{
#endif
		int iLoop;
		CvUnit* pLoopUnit;
		for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		{
			if(pLoopUnit->AI_getUnitAIType() == UNITAI_DEFENSE)
			{
				pLoopUnit->AI_setUnitAIType(UNITAI_EXPLORE);
				break;
			}
		}
#if defined(MOD_BALANCE_CORE)
		}
#endif
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::addFreeUnitAI(UnitAITypes eUnitAI, int iCount)
{
	int iI;

	UnitTypes eBestUnit = NO_UNIT;
	int iBestValue = 0;

	for(iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
	{
		const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
		CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
		if(pkUnitClassInfo)
		{
			UnitTypes eLoopUnit = GetSpecificUnitType(eUnitClass);
			if(eLoopUnit != NO_UNIT)
			{
				CvUnitEntry* pUnitInfo = GC.getUnitInfo(eLoopUnit);
				if(pUnitInfo != NULL)
				{
					if(canTrainUnit(eLoopUnit))
					{
						bool bValid = true;
						for(int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
						{
							const ResourceTypes eResource = static_cast<ResourceTypes>(iJ);
							CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
							if(pkResource)
							{
								if(pUnitInfo->GetResourceQuantityRequirement(iJ) > 0)
								{
									bValid = false;
									break;
								}
#if defined(MOD_UNITS_RESOURCE_QUANTITY_TOTALS)
								if (MOD_UNITS_RESOURCE_QUANTITY_TOTALS && pUnitInfo->GetResourceQuantityTotal(iJ) > 0)
								{
									bValid = false;
									break;
								}
#endif
							}
						}

						if(bValid)
						{
							int iValue = 0;

							// Default unit AI matches
							if(pUnitInfo->GetDefaultUnitAIType() == eUnitAI)
								iValue += (pUnitInfo->GetProductionCost() * 2);
							// Not default, but still possible
							else if(pUnitInfo->GetUnitAIType(eUnitAI))
								iValue += (pUnitInfo->GetProductionCost());

							if(iValue > iBestValue)
							{
								eBestUnit = eLoopUnit;
								iBestValue = iValue;
							}
						}
					}
				}
			}
		}

	}

	if(eBestUnit != NO_UNIT)
	{
		for(iI = 0; iI < iCount; iI++)
		{
			addFreeUnit(eBestUnit, eUnitAI);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Returns plot where new unit was created
CvPlot* CvPlayer::addFreeUnit(UnitTypes eUnit, UnitAITypes eUnitAI)
{
	CvPlot* pStartingPlot;
	CvPlot* pBestPlot;
	CvPlot* pLoopPlot;
	CvPlot* pReturnValuePlot = NULL;

	CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
	if(pkUnitInfo == NULL)
		return pReturnValuePlot;

	if (isHuman() && GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE))
	{
		if((eUnitAI == UNITAI_SETTLE) || (pkUnitInfo->GetDefaultUnitAIType() == UNITAI_SETTLE))
		{
			if(GetNumUnitsWithUnitAI(UNITAI_SETTLE) >= 1)
			{
				return pReturnValuePlot;
			}
		}
	}

	// Venice can receive settlers but not build any ...
	if (GetPlayerTraits()->IsNoAnnexing())
	{
		// if we're trying to drop a settler
		if((eUnitAI == UNITAI_SETTLE) || (pkUnitInfo->GetDefaultUnitAIType() == UNITAI_SETTLE))
		{
			// if we already have a settler
			if(GetNumUnitsWithUnitAI(UNITAI_SETTLE) >= 1)
			{
				// drop a merchant of venice instead
				// find the eUnit replacement that's the merchant of venice
				for(int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
				{
					const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
					CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
					if(pkUnitClassInfo)
					{
						const UnitTypes eLocalUnit = GetSpecificUnitType(eUnitClass);
						if (eLocalUnit != NO_UNIT)
						{
							CvUnitEntry* pUnitEntry = GC.getUnitInfo(eLocalUnit);
							if (pUnitEntry->IsCanBuyCityState())
							{
								// replacing the parameters
								eUnit = eLocalUnit;
								eUnitAI = (UnitAITypes)pkUnitInfo->GetDefaultUnitAIType();
								break;
							}
						}
					}
				}
			}
		}	
	}

	CvCity* pCapital = getCapitalCity();

	if(pCapital)
	{
		pStartingPlot = pCapital->plot();
	}
	else
	{
		pStartingPlot = getStartingPlot();
	}

	if(pStartingPlot != NULL)
	{
		pBestPlot = NULL;

		if (!pkUnitInfo->IsFound())
		{
			DirectionTypes eDirection;

			bool bDirectionValid;
			int iCount = 0;

			// Find a random direction
			do
			{
				bDirectionValid = true;
				eDirection = (DirectionTypes)GC.getGame().getJonRandNum(NUM_DIRECTION_TYPES, "Placing Starting Units");

				if (bDirectionValid)
				{
					pLoopPlot = plotDirection(pStartingPlot->getX(), pStartingPlot->getY(), eDirection);

					if (pkUnitInfo->GetDomainType() == DOMAIN_SEA) 
					{
						if (pLoopPlot != NULL && pLoopPlot->isWater()) 
						{
							if (!pLoopPlot->isImpassable(getTeam())) 
							{
								if (!pLoopPlot->isUnit())
								{
									pBestPlot = pLoopPlot;
									break;
								}
							}
						}
					}
					else 
					{
						if (pLoopPlot != NULL && pLoopPlot->getLandmass() == pStartingPlot->getLandmass())
						{
							if (!pLoopPlot->isImpassable(getTeam()))
							{
								if (!pLoopPlot->isUnit())
								{
									if (!pLoopPlot->isGoody())
									{
										pBestPlot = pLoopPlot;
										break;
									}
								}
							}
						}
					}
				}

				// Emergency escape.  Should only really break on Debug Micro map or something really funky
				iCount++;
			}
			while (iCount < 1000);
		}

		if (pBestPlot == NULL)
		{
			pBestPlot = pStartingPlot;
		}

		CvUnit* pNewUnit = initUnit(eUnit, pBestPlot->getX(), pBestPlot->getY(), eUnitAI);
		CvAssert(pNewUnit != NULL);
		if (pNewUnit == NULL)
			return NULL;

		if (pCapital)
		{
			pCapital->addProductionExperience(pNewUnit);
		}
		// Remove XP bonuses from starting scouts
		else if (MOD_BALANCE_CORE_DIFFICULTY && !isHuman() && pkUnitInfo->GetDefaultUnitAIType() == UNITAI_EXPLORE && GC.getGame().getElapsedGameTurns() <= 0)
		{
			pNewUnit->setExperienceTimes100(0);
			pNewUnit->changeExperiencePercent(-pNewUnit->getExperiencePercent());
		}

		if(pNewUnit->isWLKTKDOnBirth())
		{
			int iLoop;
			for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				if(pLoopCity != NULL && pLoopCity->getOwner() == GetID())
				{
					int iWLTKD = /*6*/ GD_INT_GET(CITY_RESOURCE_WLTKD_TURNS) / 3;
					iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
					iWLTKD /= 100;

					if (iWLTKD > 0)
					{
						pLoopCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
						CvNotifications* pNotifications = GetNotifications();
						if (pNotifications)
						{
							Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UNIT");
							strText << pNewUnit->getNameKey() << pLoopCity->getNameKey();
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UNIT");
							strSummary << pLoopCity->getNameKey();
							pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pLoopCity->getX(), pLoopCity->getY(), -1);
						}
					}
				}
			}
		}
		if(pNewUnit->isGoldenAgeOnBirth())
		{
			changeGoldenAgeTurns(getGoldenAgeLength());
		}
		if(pNewUnit->isCultureBoost())
		{
			int iValue = GetTotalJONSCulturePerTurn() * 4;
			changeJONSCulture(iValue);
			if(getCapitalCity() != NULL)
			{
				getCapitalCity()->ChangeJONSCultureStored(iValue);
			}
			CvNotifications* pNotifications = GetNotifications();
			if (pNotifications)
			{
				Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CULTURE_UNIT");
				strText << pNewUnit->getNameKey();
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CULTURE_UNIT");
				strSummary << pNewUnit->getNameKey();
				pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pNewUnit->getX(), pNewUnit->getY(), -1);
			}
		}
		if (pNewUnit->getUnitInfo().IsSpreadReligion())
		{
			ReligionTypes eReligion = GetReligions()->GetStateReligion();

			if (GetHolyCity() && GetHolyCity()->getOwner() == GetID())
				pNewUnit->GetReligionDataMutable()->SetFullStrength(GetID(),pNewUnit->getUnitInfo(),eReligion,GetHolyCity());
			else if (getCapitalCity())
				pNewUnit->GetReligionDataMutable()->SetFullStrength(GetID(),pNewUnit->getUnitInfo(),eReligion,getCapitalCity());
			else
				pNewUnit->GetReligionDataMutable()->SetFullStrength(GetID(),pNewUnit->getUnitInfo(),eReligion,NULL);
		}

		// Don't stack any units
		if(pBestPlot->getNumUnits() > 1)
		{
			if (!pNewUnit->jumpToNearestValidPlot())
			{
				// Could not find a spot for the unit
				pNewUnit->kill(false);		
				return NULL;
			}
		}
		pReturnValuePlot = pNewUnit->plot();
	}

	return pReturnValuePlot;
}


//	--------------------------------------------------------------------------------
CvCity* CvPlayer::initCity(int iX, int iY, bool bBumpUnits, bool bInitialFounding, ReligionTypes eInitialReligion, const char* szName, CvUnitEntry* pkSettlerUnitEntry)
{
	CvCity* pNewCity = addCity();

	CvAssertMsg(pNewCity != NULL, "City is not assigned a valid value");
	if(pNewCity != NULL)
	{
		CvAssertMsg(!(GC.getMap().plot(iX, iY)->isCity()), "No city is expected at this plot when initializing new city");
		pNewCity->init(pNewCity->GetID(), GetID(), iX, iY, bBumpUnits, bInitialFounding, eInitialReligion, szName, pkSettlerUnitEntry);
		pNewCity->GetCityStrategyAI()->UpdateFlavorsForNewCity();
		pNewCity->DoUpdateCheapestPlotInfluenceDistance();

		GC.getGame().SetClosestCityMapDirty();

		int iLoop=0;
		for (CvCity* pCity=firstCity(&iLoop); pCity!=NULL; pCity=nextCity(&iLoop))
			pCity->UpdateClosestFriendlyNeighbors();
	}

	return pNewCity;
}

/// This player acquires a city. 
/// bConquest is true if the city was directly captured by this player's units, and false otherwise.
/// bGift is true if the city was gifted to the player (can be from a trade or from the Austria/Venice UAs; liberation does NOT count in this)
CvCity* CvPlayer::acquireCity(CvCity* pCity, bool bConquest, bool bGift)
{
	if (!pCity)
		return NULL;

	CvPlot* pCityPlot = pCity->plot();
	if (!pCityPlot)
		return NULL;

	PlayerTypes eOldOwner = pCity->getOwner(), ePreviousOwner = pCity->getPreviousOwner(), eOriginalOwner = pCity->getOriginalOwner();
	int iCityX = pCity->getX(), iCityY = pCity->getY(), iPopulation = pCity->getPopulation(), iNumCities = getNumCities();
	const CvCivilizationInfo& playerCivilizationInfo = getCivilizationInfo();

	// Can't acquire a city from yourself
	if (eOldOwner == GetID())
		return pCity;

	// Is this the capital?
	bool bCapital = pCity->isCapital();
	bool bOriginalCapital = pCity->IsOriginalCapitalForPlayer(eOldOwner);

	// Is this a Holy City?
	bool bHolyCity = pCity->GetCityReligions()->IsHolyCityAnyReligion();
	CvString szReligionName = "";
	if (bHolyCity)
	{
		const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(pCity->GetCityReligions()->GetReligionForHolyCity(), NO_PLAYER);
		if (pReligion)
			szReligionName = pReligion->GetName();
		else
			bHolyCity = false;
	}
	
	PlayerTypes ePlayerToLiberate = NO_PLAYER;

	// Can this city be liberated?
	if (eOriginalOwner != eOldOwner && eOriginalOwner != GetID())
	{
		ePlayerToLiberate = eOriginalOwner;

		// If we're at war with the original owner and the last owner was a City-State, liberate them instead
		if (IsAtWarWith(ePlayerToLiberate))
		{
			if (ePreviousOwner != NO_PLAYER && eOriginalOwner != ePreviousOwner && GET_PLAYER(ePreviousOwner).isMinorCiv())
			{
				ePlayerToLiberate = ePreviousOwner;
			}
			else
			{
				ePlayerToLiberate = NO_PLAYER;
			}
		}

		if (ePlayerToLiberate != NO_PLAYER && !CanLiberatePlayerCity(ePlayerToLiberate))
		{
			ePlayerToLiberate = NO_PLAYER;
		}
	}

	// Kill all immobile units on the city plot that don't belong to the acquirer's team
	FFastSmallFixedList<IDInfo, 25, true, c_eCiv5GameplayDLL > oldUnits;
	IDInfo* pUnitNode = pCityPlot->headUnitNode();
	while (pUnitNode != NULL)
	{
		oldUnits.insertAtEnd(pUnitNode);
		pUnitNode = pCityPlot->nextUnitNode((IDInfo*)pUnitNode);
	}

	pUnitNode = oldUnits.head();

	while (pUnitNode != NULL)
	{
		CvUnit* pLoopUnit = ::GetPlayerUnit(*pUnitNode);
		pUnitNode = oldUnits.next(pUnitNode);

		if (pLoopUnit && pLoopUnit->getTeam() != getTeam())
		{
			if (pLoopUnit->IsImmobile() && !pLoopUnit->isCargo())
			{
				pLoopUnit->kill(false, GetID());
				DoUnitKilledCombat(NULL, pLoopUnit->getOwner(), pLoopUnit->getUnitType());
			}
		}
	}

	// Change cities lost stat
	if (eOriginalOwner != NO_PLAYER && eOriginalOwner != BARBARIAN_PLAYER)
	{
		if (eOriginalOwner == eOldOwner)
		{
			GET_PLAYER(eOldOwner).changeCitiesLost(1);
		}
		else if (eOriginalOwner == GetID())
		{
			changeCitiesLost(-1);
		}
	}

	// Did this player trade us back our capital/Holy City? Diplo bonus!
	if (bGift)
	{
		// I've traded for this city? I don't want to trade it again.
		pCity->SetTraded(GetID(), true);

		if (pCity->IsOriginalCapitalForPlayer(GetID()))
		{
			GetDiplomacyAI()->SetPlayerReturnedCapital(eOldOwner, true);
		}
		else if (bHolyCity && IsHasLostHolyCity() && pCity->GetCityReligions()->IsHolyCityForReligion(GetReligions()->GetOriginalReligionCreatedByPlayer()))
		{
			GetDiplomacyAI()->SetPlayerReturnedHolyCity(eOldOwner, true);
		}
	}

	int iCaptureGold = 0, iCaptureCulture = 0;
	bool bSlaughter = bConquest && !bGift;
	bool bFirstConquest = false;

	// This city was conquered! We have much to do!
	if (bConquest)
	{
		// First things first, notify the world!
		GetMilitaryAI()->LogCityCaptured(pCity, eOldOwner);

		// First, the standard global notification
		PlayerTypes eActivePlayer = GC.getGame().getActivePlayer();
		CvPlayer& activePlayer = GET_PLAYER(eActivePlayer);
		CvString strName;
		strName.Format("%s (%s)", pCity->getName().GetCString(), GET_PLAYER(eOldOwner).getName());

		if (GetID() == eActivePlayer)
		{
			if (activePlayer.GetNotifications())
			{
				CvString strBuffer = GetLocalizedText("TXT_KEY_MISC_CAPTURED_CITY", pCity->getNameKey()).GetCString();
				GC.GetEngineUserInterface()->AddCityMessage(0, pCity->GetIDInfo(), GetID(), true, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), strBuffer);
				if (MOD_WH_MILITARY_LOG)
					MILITARYLOG(GetID(), strBuffer.c_str(), pCity->plot(), pCity->getOwner());
			}
		}
		else
		{
			if (activePlayer.isObserver() || 
				(activePlayer.isAlive() && activePlayer.GetNotifications() && 
					pCity->isRevealed(activePlayer.getTeam(), false, false) && 
					GET_TEAM(activePlayer.getTeam()).isHasMet(GET_PLAYER(eOldOwner).getTeam()) && 
					GET_TEAM(activePlayer.getTeam()).isHasMet(getTeam())))
			{
				CvString strBuffer = GetLocalizedText("TXT_KEY_MISC_CITY_CAPTURED_BY", strName.GetCString(), getCivilizationShortDescriptionKey());
				GC.GetEngineUserInterface()->AddCityMessage(0, pCity->GetIDInfo(), activePlayer.GetID(), false, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), strBuffer);
			}
		}

		CvString strBuffer = GetLocalizedText("TXT_KEY_MISC_CITY_WAS_CAPTURED_BY", strName.GetCString(), getCivilizationShortDescriptionKey());
		GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, GetID(), strBuffer, iCityX, iCityY);
		GC.getGame().addReplayMessage(REPLAY_MESSAGE_CITY_CAPTURED, GetID(), "", iCityX, iCityY);

		// Holy Cities have a second global notification.
		if (bHolyCity)
		{
			// Notification for conqueror
			CvNotifications* pNotify = GetNotifications();
			if (pNotify)
			{
				Localization::String locString = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_GAINED_HOLY");
				Localization::String locSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_GAINED_HOLY");
				locString << pCity->getNameKey() << szReligionName;
				locSummary << pCity->getNameKey();
				pNotify->Add(NOTIFICATION_CAPITAL_RECOVERED, locString.toUTF8(), locSummary.toUTF8(), iCityX, iCityY, -1);
			}

			// Notification for everyone else
			Localization::String locString = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_LOST_HOLY");
			Localization::String locSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_LOST_HOLY");
			locString << pCity->getNameKey() << getNameKey() << szReligionName;
			locSummary << pCity->getNameKey();
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_PLAYERS; iPlayerLoop++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
				if (eLoopPlayer == GetID())
					continue;

				if (GET_PLAYER(eLoopPlayer).isObserver())
				{
					pNotify = GET_PLAYER(eLoopPlayer).GetNotifications();
					if (pNotify)
						pNotify->Add(NOTIFICATION_CITY_LOST, locString.toUTF8(), locSummary.toUTF8(), iCityX, iCityY, -1);

					continue;
				}
				else if (!GET_PLAYER(eLoopPlayer).isAlive() || !GET_PLAYER(eLoopPlayer).isMajorCiv() || !GET_PLAYER(eLoopPlayer).isHuman() || !GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).isHasMet(GET_PLAYER(eOldOwner).getTeam()) || !GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).isHasMet(getTeam()))
					continue;

				pNotify = GET_PLAYER(eLoopPlayer).GetNotifications();
				if (pNotify)
					pNotify->Add(NOTIFICATION_CITY_LOST, locString.toUTF8(), locSummary.toUTF8(), iCityX, iCityY, -1);
			}
		}
		// Normal city - only notify the conquered player
		else
		{
			CvNotifications* pNotify = GET_PLAYER(eOldOwner).GetNotifications();
			if (pNotify)
			{
				Localization::String locString = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_LOST");
				Localization::String locSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_LOST");
				locString << pCity->getNameKey() << getNameKey();
				locSummary << pCity->getNameKey();
				pNotify->Add(NOTIFICATION_CITY_LOST, locString.toUTF8(), locSummary.toUTF8(), iCityX, iCityY, -1);
			}
		}

		// War damage calculations
		if (!pCity->isBarbarian())
		{
			int iCityValue = /*175*/ GD_INT_GET(WAR_DAMAGE_LEVEL_CITY_WEIGHT);
			iCityValue += (iPopulation * /*150*/ GD_INT_GET(WAR_DAMAGE_LEVEL_INVOLVED_CITY_POP_MULTIPLIER));
			iCityValue += (pCity->getNumWorldWonders() * /*200*/ GD_INT_GET(WAR_DAMAGE_LEVEL_WORLD_WONDER_MULTIPLIER));
			int iWinnerProgressValue = /*100*/ GD_INT_GET(WAR_PROGRESS_CAPTURED_CITY), iLoserProgressValue = /*-50*/ GD_INT_GET(WAR_PROGRESS_LOST_CITY);

			// Multipliers
			// Their original capital!
			if (bOriginalCapital)
			{
				iCityValue *= 200;
				iCityValue /= 100;
				iWinnerProgressValue *= /*200*/ GD_INT_GET(WAR_PROGRESS_CAPITAL_MULTIPLIER);
				iWinnerProgressValue /= 100;
				iLoserProgressValue *= /*200*/ GD_INT_GET(WAR_PROGRESS_CAPITAL_MULTIPLIER);
				iLoserProgressValue /= 100;

				if (GET_PLAYER(eOldOwner).isMajorCiv())
				{
					GET_PLAYER(eOldOwner).SetHasLostCapital(true, GetID());

					if (isMajorCiv())
					{
						GET_PLAYER(eOldOwner).GetDiplomacyAI()->SetPlayerCapturedCapital(GetID(), true);
						GET_PLAYER(eOldOwner).GetDiplomacyAI()->SetBackstabbedBy(GetID(), true, true);
					}
				}
			}
			// Their Holy City!
			else if (GET_PLAYER(eOldOwner).isMajorCiv() && bHolyCity && pCity->GetCityReligions()->IsHolyCityForReligion(GET_PLAYER(eOldOwner).GetReligions()->GetOriginalReligionCreatedByPlayer()))
			{
				iCityValue *= 150;
				iCityValue /= 100;
				iWinnerProgressValue *= /*150*/ GD_INT_GET(WAR_PROGRESS_HOLY_CITY_MULTIPLIER);
				iWinnerProgressValue /= 100;
				iLoserProgressValue *= /*150*/ GD_INT_GET(WAR_PROGRESS_HOLY_CITY_MULTIPLIER);
				iLoserProgressValue /= 100;

				GET_PLAYER(eOldOwner).SetHasLostHolyCity(true, GetID());
				GET_PLAYER(eOldOwner).SetLostHolyCityXY(iCityX, iCityY);

				if (isMajorCiv())
				{
					GET_PLAYER(eOldOwner).GetDiplomacyAI()->SetPlayerCapturedHolyCity(GetID(), true);
					GET_PLAYER(eOldOwner).GetDiplomacyAI()->SetBackstabbedBy(GetID(), true, true);
				}
			}
			// Another major's original capital
			else if (pCity->IsOriginalMajorCapital())
			{
				iCityValue *= 150;
				iCityValue /= 100;
			}
			// A City-State's capital
			else if (pCity->IsOriginalMinorCapital())
			{
				iCityValue *= 115;
				iCityValue /= 100;
			}

			// Dramatically reduce the value if conqueror has owned the city before
			int iNumTimesOwned = pCity->GetNumTimesOwned(GetID());
			if (iNumTimesOwned > 1)
			{
				iCityValue /= (iNumTimesOwned * 3);
			}

			// Update military rating for both players
			if (isMajorCiv())
			{
				ChangeMilitaryRating(iCityValue); // rating up for winner (us)
				GetDiplomacyAI()->ChangeWarProgressScore(eOldOwner, iWinnerProgressValue);

				// If the conqueror has any vassals, see if any nearby vassals are grateful for the protection
				if (GetNumVassals() > 0)
				{
					for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
					{
						PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
						if (GetDiplomacyAI()->IsPlayerValid(eLoopPlayer) && GetDiplomacyAI()->IsMaster(eLoopPlayer) && GET_PLAYER(eLoopPlayer).GetProximityToPlayer(eOldOwner) >= PLAYER_PROXIMITY_CLOSE)
						{
							GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeVassalProtectValue(GetID(), iCityValue);
						}
					}
				}
			}
			if (GET_PLAYER(eOldOwner).isMajorCiv())
			{
				GET_PLAYER(eOldOwner).ChangeMilitaryRating(-iCityValue); // rating down for loser (them)
				GET_PLAYER(eOldOwner).GetDiplomacyAI()->ChangeWarProgressScore(GetID(), iLoserProgressValue);

				// If the city belonged to a vassal, penalize the masters
				if (GET_PLAYER(eOldOwner).IsVassalOfSomeone())
				{
					for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
					{
						PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
						if (GET_PLAYER(eOldOwner).GetDiplomacyAI()->IsPlayerValid(eLoopPlayer) && GET_PLAYER(eOldOwner).GetDiplomacyAI()->IsVassal(eLoopPlayer))
						{
							GET_PLAYER(eOldOwner).GetDiplomacyAI()->ChangeVassalFailedProtectValue(eLoopPlayer, iCityValue);
						}
					}
				}
			}

			// Do we have a bonus to war score accumulation?
			iCityValue *= (100 + GetWarScoreModifier());
			iCityValue /= 100;

			GET_PLAYER(eOldOwner).ChangeWarValueLost(GetID(), iCityValue);
			SetPlayerNumTurnsSinceCityCapture(eOldOwner, 0);
		}

		// Notify diplomacy AI that the damage was done
		if (isMajorCiv())
		{
			if (GET_PLAYER(eOldOwner).isMajorCiv())
			{
				CvDiplomacyAI* pOldOwnerDiploAI = GET_PLAYER(eOldOwner).GetDiplomacyAI();
				pOldOwnerDiploAI->ChangeNumCitiesCapturedBy(GetID(), 1);

				// Zero out any liberation credit since we just captured a city from them
				pOldOwnerDiploAI->SetResurrectedBy(GetID(), false);

				if (GET_TEAM(GET_PLAYER(eOldOwner).getTeam()).GetLiberatedByTeam() == getTeam())
					GET_TEAM(GET_PLAYER(eOldOwner).getTeam()).SetLiberatedByTeam(NO_TEAM);

				pOldOwnerDiploAI->SetPlayerLiberatedCapital(GetID(), false);
				pOldOwnerDiploAI->SetPlayerLiberatedHolyCity(GetID(), false);
				pOldOwnerDiploAI->SetNumCitiesLiberatedBy(GetID(), 0);
				pOldOwnerDiploAI->SetPlayerReturnedCapital(GetID(), false);
				pOldOwnerDiploAI->SetPlayerReturnedHolyCity(GetID(), false);
				pOldOwnerDiploAI->SetMasterLiberatedMeFromVassalage(GetID(), false);
				pOldOwnerDiploAI->SetVassalagePeacefullyRevokedTurn(GetID(), -1);
				
				// Clear positive diplomatic values
				pOldOwnerDiploAI->SetNumCiviliansReturnedToMe(GetID(), 0);
				pOldOwnerDiploAI->SetNumLandmarksBuiltForMe(GetID(), 0);
				pOldOwnerDiploAI->SetNumTimesIntrigueSharedBy(GetID(), 0);
				pOldOwnerDiploAI->SetCommonFoeValue(GetID(), 0);
				pOldOwnerDiploAI->SetVassalProtectValue(GetID(), 0);
				if (pOldOwnerDiploAI->GetRecentAssistValue(GetID()) < 0)
					pOldOwnerDiploAI->SetRecentAssistValue(GetID(), 0);
			}

			// Warmonger calculations
			bool bDoWarmonger = true;
			pCity->SetNoWarmonger(false); // Reset this value!

			// Don't award warmongering if you're conquering a city you owned back
			if (eOriginalOwner == GetID())
				bDoWarmonger = false;

			// Don't award warmongering if you're conquering a city that you were the last to own.
			if (ePreviousOwner == GetID())
				bDoWarmonger = false;

			//Captured a city from barbs? Everyone likes that!
			if (GET_PLAYER(eOldOwner).isBarbarian())
				bDoWarmonger = false;

			if (bDoWarmonger && ePlayerToLiberate != NO_PLAYER)
			{
				bDoWarmonger = false;
				pCity->SetNoWarmonger(true);
			}

			if (bDoWarmonger)
			{
				CvDiplomacyAIHelpers::ApplyWarmongerPenalties(pCity, GetID(), eOldOwner);
			}
		}

		// Process plunder rewards
		if (isMajorCiv())
		{
			iCaptureGold = /*20*/ GD_INT_GET(BASE_CAPTURE_GOLD) + (iPopulation * /*10*/ GD_INT_GET(CAPTURE_GOLD_PER_POPULATION));
			iCaptureGold += /*2 to 40*/ GC.getGame().getSmallFakeRandNum(GD_INT_GET(CAPTURE_GOLD_RAND1), pCity->plot()->GetPlotIndex()) * 2;
			iCaptureGold += /*2 to 40*/ GC.getGame().getSmallFakeRandNum(GD_INT_GET(CAPTURE_GOLD_RAND2), GET_PLAYER(eOldOwner).GetPseudoRandomSeed()) * 2;

			// Reduce reward if acquired recently by the previous owner
			if (/*50*/ GD_INT_GET(CAPTURE_GOLD_MAX_TURNS) > 0)
			{
				iCaptureGold *= range((GC.getGame().getGameTurn() - pCity->getGameTurnAcquired()), 0, GD_INT_GET(CAPTURE_GOLD_MAX_TURNS));
				iCaptureGold /= GD_INT_GET(CAPTURE_GOLD_MAX_TURNS);
			}

			// City increases plunder gold? (Burial Tomb)
			iCaptureGold *= 100 + pCity->getCapturePlunderModifier();
			iCaptureGold /= 100;

			// UA increases plunder gold? (Songhai)
			iCaptureGold *= 100 + GetPlayerTraits()->GetPlunderModifier();
			iCaptureGold /= 100;

			if (iCaptureGold <= 0)
				iCaptureGold = 0;
			else
				GetTreasury()->ChangeGold(iCaptureGold);

			// Culture from plundering?
			iCaptureCulture = pCity->getJONSCulturePerTurn();
			iCaptureCulture *= GetPlayerPolicies()->GetNumericModifier(POLICYMOD_CULTURAL_PLUNDER_MULTIPLIER);

			// Reduce reward if acquired recently by the previous owner
			if (/*50*/ GD_INT_GET(CAPTURE_GOLD_MAX_TURNS) > 0)
			{
				iCaptureCulture *= range((GC.getGame().getGameTurn() - pCity->getGameTurnAcquired()), 0, GD_INT_GET(CAPTURE_GOLD_MAX_TURNS));
				iCaptureCulture /= GD_INT_GET(CAPTURE_GOLD_MAX_TURNS);
			}

			if (iCaptureCulture <= 0)
				iCaptureCulture = 0;
			else
				changeJONSCulture(iCaptureCulture);
		}

		// Should the conqueror slaughter some of the city's population?
		// Our city originally? Don't slaughter.
		if (eOriginalOwner == GetID())
		{
			bSlaughter = false;
		}
		// We are liberators, so don't slaughter.
		if (pCity->isBarbarian())
		{
			bSlaughter = false;
		}
		// Recently captured and still in resistance? Don't slaughter.
		if (pCity->IsResistance())
		{
			bSlaughter = false;
		}

		// Trigger most "first conquest" bonuses now.
		if (!pCity->isEverOwned(GetID()))
		{
			bFirstConquest = true; // remember this for later checks

			// Free technology from conquering a city?
			if (GetPlayerTraits()->IsTechFromCityConquer())
			{
				if (MOD_ALTERNATE_ASSYRIA_TRAIT)
				{
					if (!isHuman())
					{
						AI_chooseFreeTech();
					}
					else
					{
						Localization::String localizedText = Localization::Lookup("TXT_KEY_SCIENCE_BOOST_CONQUEST_ASSYRIA");
						localizedText << pCity->getNameKey();
						chooseTech(1, localizedText.toUTF8());						
					}
				}
				else
					DoTechFromCityConquer(pCity);
			}

			// Golden Age turns from conquering a city?
			if (GetPlayerTraits()->IsConquestOfTheWorld())
			{
				if (isGoldenAge())
					changeGoldenAgeTurns(getGoldenAgeLength(3));
				else
					changeGoldenAgeTurns(getGoldenAgeLength(5));
			}

			// Culture bonus turns from conquering a city?
			if (GetPlayerTraits()->GetCultureBonusModifierConquest() > 0)
			{
				int iTurns = ((iPopulation / 2) * GC.getGame().getGameSpeedInfo().getInstantYieldPercent()) / 100;
				if (iTurns > 0)
				{
					ChangeCultureBonusTurnsConquest(iTurns);

					if (GetID() == GC.getGame().getActivePlayer())
					{
						Localization::String strMessage = Localization::Lookup("TXT_KEY_CULTURE_BOOST_ART");
						strMessage << iTurns;
						strMessage << pCity->getNameKey();
						strMessage << GetPlayerTraits()->GetCultureBonusModifierConquest();
						Localization::String strSummary = Localization::Lookup("TXT_KEY_CULTURE_BOOST_ART_SUMMARY");

						CvNotifications* pNotify = GetNotifications();
						if (pNotify)
						{
							pNotify->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), iCityX, iCityY, (int)pCity->GetID(), GetID());
						}
					}
					if (GC.getLogging() && GC.getAILogging())
					{
						CvGameCulture *pCulture = GC.getGame().GetGameCulture();
						if (pCulture)
						{
							CvString strLogString;
							strLogString.Format("Conquest culture boost: %d", iTurns);
							GetHomelandAI()->LogHomelandMessage(strLogString);
						}
					}
				}
			}

			// Production bonus turns from conquering a city?
			if (GetPlayerTraits()->GetProductionBonusModifierConquest() > 0)
			{
				int iTurns = ((iPopulation / 2) * GC.getGame().getGameSpeedInfo().getInstantYieldPercent()) / 100;
				if (iTurns > 0)
				{
					ChangeProductionBonusTurnsConquest(iTurns);

					if (GetID() == GC.getGame().getActivePlayer())
					{
						Localization::String strMessage = Localization::Lookup("TXT_KEY_PRODUCTION_BOOST_ART");
						strMessage << iTurns;
						strMessage << pCity->getNameKey();
						strMessage << GetPlayerTraits()->GetProductionBonusModifierConquest();
						Localization::String strSummary = Localization::Lookup("TXT_KEY_PRODUCTION_BOOST_ART_SUMMARY");

						CvNotifications* pNotify = GetNotifications();
						if (pNotify)
						{
							pNotify->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), iCityX, iCityY, (int)pCity->GetID(), GetID());
						}
					}
					if (GC.getLogging() && GC.getAILogging())
					{
						CvGameCulture *pCulture = GC.getGame().GetGameCulture();
						if (pCulture)
						{
							CvString strLogString;
							strLogString.Format("Conquest production boost: %d", iTurns);
							GetHomelandAI()->LogHomelandMessage(strLogString);
						}
					}
				}
			}

			// Free Great Work from conquering a city?
			if (GetPlayerTraits()->IsFreeGreatWorkOnConquest())
			{
				DoFreeGreatWorkOnConquest(eOldOwner, pCity);
			}

			// Great Writer, Artist and Musician points from conquering a city?
			if (GetPlayerTraits()->GetCityConquestGWAM() > 0)
			{
				doInstantGWAM(NO_GREATPERSON, pCity->getName(), true);
			}

			// We Love the King Day in all cities from conquering a city?
			if (GetPlayerTraits()->IsExpansionWLTKD())
			{
				int iWLTKD = /*6*/ GD_INT_GET(CITY_RESOURCE_WLTKD_TURNS) / 3;
				iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iWLTKD /= 100;

				if (iWLTKD > 0)
				{
					// Loop through owner's cities.
					int iCityLoop;
					for (CvCity* pLoopCity = firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = nextCity(&iCityLoop))
					{
						pLoopCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
					}

					CvNotifications* pNotify = GetNotifications();
					if (pNotify)
					{
						Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UA_CITY_CONQUEST");
						strText << iWLTKD << GetPlayerTraits()->GetGrowthBoon();
						Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UA_CITY_CONQUEST");
						pNotify->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), iCityX, iCityY, -1);
					}
				}
			}

			// Additional territory from conquering a city?
			int iExtraTerritoryClaim = GetPlayerTraits()->GetExtraConqueredCityTerritoryClaimRange();
			for (int i = 0; i < iExtraTerritoryClaim; i++)
			{
				CvPlot* pPlotToAcquire = pCity->GetNextBuyablePlot(false);

				if (pPlotToAcquire)
				{
					pCity->DoAcquirePlot(pPlotToAcquire->getX(), pPlotToAcquire->getY());
				}
			}

			// Lump sum of yields from conquering a City-State?
			if (MOD_BALANCE_CORE_AFRAID_ANNEX && GET_PLAYER(eOldOwner).isMinorCiv() && GetPlayerTraits()->IsBullyAnnex() && GetPlayerTraits()->GetBullyYieldMultiplierAnnex() != 0)
			{
				CvMinorCivAI* pMinorAI = GET_PLAYER(eOldOwner).GetMinorCivAI();
				MinorCivTraitTypes eTrait = pMinorAI->GetTrait();
				int iYield = GetPlayerTraits()->GetBullyYieldMultiplierAnnex();

				switch (eTrait)
				{
				case NO_MINOR_CIV_TRAIT_TYPE:
					UNREACHABLE();
				case MINOR_CIV_TRAIT_CULTURED:
					iYield *= pMinorAI->GetYieldTheftAmount(GetID(), YIELD_CULTURE);
					iYield /= 100;
					doInstantYield(INSTANT_YIELD_TYPE_BULLY, true, NO_GREATPERSON, NO_BUILDING, iYield, true, NO_PLAYER, NULL, false, getCapitalCity(), false, true, false, YIELD_CULTURE);
					break;
				case MINOR_CIV_TRAIT_MARITIME:
					iYield *= pMinorAI->GetYieldTheftAmount(GetID(), YIELD_FOOD);
					iYield /= 100;
					doInstantYield(INSTANT_YIELD_TYPE_BULLY, true, NO_GREATPERSON, NO_BUILDING, iYield, true, NO_PLAYER, NULL, false, getCapitalCity(), false, true, false, YIELD_FOOD);
					break;
				case MINOR_CIV_TRAIT_MERCANTILE:
					iYield *= pMinorAI->GetYieldTheftAmount(GetID(), YIELD_GOLD);
					iYield /= 100;
					doInstantYield(INSTANT_YIELD_TYPE_BULLY, true, NO_GREATPERSON, NO_BUILDING, iYield, true, NO_PLAYER, NULL, false, getCapitalCity(), false, true, false, YIELD_GOLD);
					break;
				case MINOR_CIV_TRAIT_MILITARISTIC:
					iYield *= pMinorAI->GetYieldTheftAmount(GetID(), YIELD_SCIENCE);
					iYield /= 100;
					doInstantYield(INSTANT_YIELD_TYPE_BULLY, true, NO_GREATPERSON, NO_BUILDING, iYield, true, NO_PLAYER, NULL, false, getCapitalCity(), false, true, false, YIELD_SCIENCE);
					break;
				case MINOR_CIV_TRAIT_RELIGIOUS:
					iYield *= pMinorAI->GetYieldTheftAmount(GetID(), YIELD_FAITH);
					iYield /= 100;
					doInstantYield(INSTANT_YIELD_TYPE_BULLY, true, NO_GREATPERSON, NO_BUILDING, iYield, true, NO_PLAYER, NULL, false, getCapitalCity(), false, true, false, YIELD_FAITH);
					break;
				}
			}

			// Other instant yields from conquering a city?
			int iScaler = max(1, (iPopulation / 2) - GetCurrentEra());
			doInstantYield(INSTANT_YIELD_TYPE_F_CONQUEST, false, NO_GREATPERSON, NO_BUILDING, iScaler, true, NO_PLAYER, NULL, false, NULL, pCity->isCoastal(), true, false, NO_YIELD, NULL, NO_TERRAIN, NULL, pCity);

			// All units heal from conquering a city?
			if (MOD_BALANCE_CORE_POLICIES && getCityCaptureHealGlobal() > 0)
			{
				DoHealGlobal(getCityCaptureHealGlobal());
			}
		}

		// Lastly, run the achievement code...
		if (MOD_API_ACHIEVEMENTS && !GC.getGame().isGameMultiPlayer() && isHuman())
		{
			const char* szLeaderKey = getLeaderTypeKey();
			const char* szCivKey = getCivilizationTypeKey();
			const char* szNameKey = pCity->getNameKey();

			// Check for Kris Swordsman achievement
			if (strcmp(szCivKey, "CIVILIZATION_INDONESIA") == 0)
			{
				CvUnit *pConqueringUnit = pCityPlot->getUnitByIndex(0);
				if (pConqueringUnit->getUnitType() == (UnitTypes)GC.getInfoTypeForString("UNIT_KRIS_SWORDSMAN", true))
				{
					PromotionTypes ePromotion = (PromotionTypes)GC.getInfoTypeForString("PROMOTION_ENEMY_BLADE", true);
					if (pConqueringUnit->isHasPromotion(ePromotion))
					{
						gDLL->UnlockAchievement(ACHIEVEMENT_XP2_21);
					}
				}
			}

			// Check for Askia Achievement
			if (strcmp(szLeaderKey, "LEADER_ASKIA") == 0)
			{
				CvCity* pCapital = getCapitalCity();
				if (pCapital)
				{
					CvPlot* pCapitalPlot = pCapital->plot();
					if (pCapitalPlot)
					{
						CvArea* pkCapitalArea = pCapitalPlot->area();
						CvArea* pkNewCityArea = pCityPlot->area();

						// The area the new city is located on has to be of a certain size to qualify so that tiny islands are not included
						if (pkCapitalArea && pkNewCityArea && pkCapitalArea->GetID() != pkNewCityArea->GetID() && pkNewCityArea->getNumTiles() >= 8)
						{
							gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_WARCANOE);
						}
					}
				}
			}

			bool bUsingXP2Scenario1 = gDLL->IsModActivated(CIV5_XP2_SCENARIO1_MODID);
			bool bUsingXP1Scenario1 = gDLL->IsModActivated(CIV5_XP1_SCENARIO1_MODID);
			bool bUsingXP1Scenario2 = gDLL->IsModActivated(CIV5_XP1_SCENARIO2_MODID);

			if (bUsingXP2Scenario1 && strcmp(szCivKey, "CIVILIZATION_ENGLAND") == 0 && strcmp(szNameKey, "TXT_KEY_CIVIL_WAR_SCENARIO_CITY_NAME_GETTYSBURG") == 0)
			{
				CvUnit *pConqueringUnit = pCityPlot->getUnitByIndex(0);
				PromotionTypes ePromotion = (PromotionTypes)GC.getInfoTypeForString("PROMOTION_PICKETT", true);
				if (pConqueringUnit->isHasPromotion(ePromotion))
				{
					gDLL->UnlockAchievement(ACHIEVEMENT_XP2_59);
				}
			}

			if (bUsingXP1Scenario1)
			{
				const HandicapTypes eCurrentHandicap = GC.getGame().getHandicapType();
				HandicapTypes eEmperorHandicap = NO_HANDICAP;
				HandicapTypes eDeityHandicap = NO_HANDICAP;

				const int numHandicapInfos = GC.getNumHandicapInfos();
				for (int i = 0; i < numHandicapInfos; ++i)
				{
					const HandicapTypes eHandicap = static_cast<HandicapTypes>(i);
					CvHandicapInfo* pkInfo = GC.getHandicapInfo(eHandicap);
					if (pkInfo != NULL)
					{
						if (strcmp(pkInfo->GetType(), "HANDICAP_EMPEROR") == 0)
						{
							eEmperorHandicap = eHandicap;
						}
						else if (strcmp(pkInfo->GetType(), "HANDICAP_DEITY") == 0)
						{
							eDeityHandicap = eHandicap;
						}
					}
				}

				if (strcmp(szCivKey, "CIVILIZATION_ENGLAND") == 0 && strcmp(szNameKey, "TXT_KEY_CITYSTATE_JERUSALEM") == 0)
				{
					if (eCurrentHandicap >= eEmperorHandicap)
					{
						gDLL->UnlockAchievement(ACHIEVEMENT_XP1_39);
					}
				}
				else if (strcmp(szCivKey, "CIVILIZATION_OTTOMAN") == 0 && strcmp(szNameKey, "TXT_KEY_CITY_NAME_CONSTANTINOPLE") == 0)
				{
					if (eCurrentHandicap >= eDeityHandicap)
					{
						gDLL->UnlockAchievement(ACHIEVEMENT_XP1_40);
					}
				}
			}

			if (bUsingXP1Scenario2)
			{
				bool bHasConstantinople = strcmp(szNameKey, "TXT_KEY_CITY_NAME_CONSTANTINOPLE") == 0;
				bool bHasRome = strcmp(szNameKey, "TXT_KEY_CITY_NAME_ROME") == 0;

				if (bHasConstantinople && eOriginalOwner != GetID())
				{
					gDLL->UnlockAchievement(ACHIEVEMENT_XP1_47);
				}

				if (bHasConstantinople || bHasRome)
				{
					int iLoop = 0;
					for (CvCity* pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
					{
						const char* szOtherNameKey = pCity->getNameKey();
						bHasConstantinople |= strcmp(szOtherNameKey, "TXT_KEY_CITY_NAME_CONSTANTINOPLE") == 0;
						bHasRome |= strcmp(szOtherNameKey, "TXT_KEY_CITY_NAME_ROME") == 0;
					}
				}

				if (bHasConstantinople && bHasRome)
				{
					gDLL->UnlockAchievement(ACHIEVEMENT_XP1_48);
				}

				if (strcmp(szCivKey, "CIVILIZATION_CELTS") == 0)
				{
					//Did we cap what was originally a sassinid city?
					typedef std::pair<int,int> Location;
					typedef std::tr1::array<Location, 7> SassanidCityArray;
					SassanidCityArray SassanidCities = 
					{
						Location(87,17), //Ctesiphon
						Location(85,20), //Singara
						Location(81,21), //Nisibis
						Location(79,24), //Amida
						Location(82,28), //Thospia
						Location(81,33), //Anium
						Location(87,33), //Artaxata
					};

					//Test if we still own each city.
					for (SassanidCityArray::iterator it = SassanidCities.begin(); it != SassanidCities.end(); ++it)
					{
						if (it->first == iCityX && it->second == iCityY)
						{
							gDLL->UnlockAchievement(ACHIEVEMENT_XP1_51);
						}
					}
				}
			}
		}
	}

	// Spies in the city? YOU'RE OUTTA HERE!~
	CvCityEspionage* pCityEspionage = pCity->GetCityEspionage();
	if (pCityEspionage)
	{
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes)iPlayerLoop;

			if (!GET_PLAYER(eLoopPlayer).isAlive())
				continue;

			CvPlayerEspionage* pEspionage = GET_PLAYER(eLoopPlayer).GetEspionage();
			if (!pEspionage)
				continue;

			int iAssignedSpy = pCityEspionage->m_aiSpyAssignment[iPlayerLoop];
			if (iAssignedSpy == -1)
				continue;

			// There's a spy! Remove it!
			GET_PLAYER(eLoopPlayer).GetEspionage()->ExtractSpyFromCity(iAssignedSpy);

			// Notify the spy's owner
			CvNotifications* pNotify = GET_PLAYER(eLoopPlayer).GetNotifications();
			if (!pNotify)
				continue;

			CvEspionageSpy* pSpy = pEspionage->GetSpyByID(iAssignedSpy);
			Localization::String strSummary(bConquest ? GetLocalizedText("TXT_KEY_NOTIFICATION_SPY_EVICTED_CONQUEST_S") : GetLocalizedText("TXT_KEY_NOTIFICATION_SPY_EVICTED_TRADE_S"));

			// City acquirer gets a different notification
			if (eLoopPlayer == GetID())
			{
				Localization::String strNotification = bConquest ? Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_EVICTED_CONQUEST_YOU") : Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_EVICTED_TRADE_YOU");
				strNotification << pEspionage->GetSpyRankName(pSpy->m_eRank);
				strNotification << pSpy->GetSpyName(&GET_PLAYER(eLoopPlayer));
				strNotification << pCity->getNameKey();
				pNotify->Add(NOTIFICATION_SPY_EVICTED, strNotification.toUTF8(), strSummary.toUTF8(), -1, -1, eOldOwner);
			}
			else
			{
				Localization::String strNotification = bConquest ? Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_EVICTED_CONQUEST") : Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_EVICTED_TRADE");
				strNotification << pEspionage->GetSpyRankName(pSpy->m_eRank);
				strNotification << pSpy->GetSpyName(&GET_PLAYER(eLoopPlayer));
				strNotification << pCity->getNameKey();
				strNotification << getCivilizationInfo().getShortDescriptionKey();
				pNotify->Add(NOTIFICATION_SPY_EVICTED, strNotification.toUTF8(), strSummary.toUTF8(), -1, -1, eOldOwner);
			}
		}
	}

	// Disassemble spaceship if the civ lost the capital
	if (bCapital && MOD_GLOBAL_NO_CONQUERED_SPACESHIPS)
		GET_PLAYER(eOldOwner).disassembleSpaceship(pCityPlot);

	// If Holy City, update religion status
	if (bHolyCity)
		UpdateReligion();

	// Remove any Corporations from this city if it is acquired by another player
	GetCorporations()->ClearAllCorporationsFromCity(pCity);
	if (eOldOwner != NO_PLAYER)
		GET_PLAYER(eOldOwner).GetCorporations()->ClearAllCorporationsFromCity(pCity);

	// If city was Barbarian-owned, turn off the spawn counter
	if (MOD_BALANCE_VP && pCity->isBarbarian())
		CvBarbarians::DoBarbCityCleared(pCityPlot);

	// If city was City-State-owned, update resource bonuses for allies
	if (GET_PLAYER(eOldOwner).isMinorCiv())
		GET_PLAYER(eOldOwner).GetMinorCivAI()->DoUpdateAlliesResourceBonus(GET_PLAYER(eOldOwner).GetMinorCivAI()->GetAlly(), GET_PLAYER(eOldOwner).GetMinorCivAI()->GetAlly());

	// Cancel trade routes to/from this city
	GC.getGame().GetGameTrade()->ClearAllCityTradeRoutes(pCityPlot);

	// Now the complicated part: we need to copy all relevant data from the city
	// Start with miscellaneous things
	CvString strName = pCity->getNameKey();
	int iGameTurnFounded = pCity->getGameTurnFounded();
	int iHighestPopulation = pCity->getHighestPopulation();
	int iCultureLevel = pCity->GetJONSCultureLevel();
	int iBattleDamage = pCity->getDamage();
	bool bHasMadeAttack = pCity->isMadeAttack();
	bool bNoWarmongerYet = pCity->IsNoWarmongerYet();

	//economic value is copied over to the new city so that the conquering AI sees the actual value of the city, not the value of the city in resistance (much lower)
	std::vector<int> viEconValue(MAX_PLAYERS, false);

	std::vector<bool> vbTraded(MAX_PLAYERS, false);
	std::vector<bool> vbIgnoredForExpansionBickering(MAX_MAJOR_CIVS, false);
	std::vector<bool> vbEverLiberated(MAX_PLAYERS, false);
	std::vector<int> viNumTimesOwned(MAX_PLAYERS, false);
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		vbTraded[iPlayerLoop] = pCity->IsTraded(eLoopPlayer);
		vbEverLiberated[iPlayerLoop] = pCity->isEverLiberated(eLoopPlayer);
		viNumTimesOwned[iPlayerLoop] = pCity->GetNumTimesOwned(eLoopPlayer);
		viEconValue[iPlayerLoop] = pCity->getEconomicValue(eLoopPlayer);

		if (iPlayerLoop < MAX_MAJOR_CIVS)
			vbIgnoredForExpansionBickering[iPlayerLoop] = pCity->IsIgnoredForExpansionBickering(eLoopPlayer);
	}

	// Remember the plots so we can re-assign them later
	int iCityRings = pCity->getWorkPlotDistance();
	std::vector<CvPlot*> ownedPlots;
	for (int iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);
		if (pLoopPlot && pLoopPlot->getOwningCityID() == pCity->GetID())
			ownedPlots.push_back(pLoopPlot);
	}

	// Next, handle religion data
	CvCityReligions tempReligions;
	int iNumReligionInfos = GC.getNumReligionInfos();
	tempReligions.Init(pCity);
	tempReligions.Copy(pCity->GetCityReligions());
	std::vector<bool> vbAdoptionBonus(iNumReligionInfos, false);

	for (int iI = 0; iI < iNumReligionInfos; iI++)
	{
		ReligionTypes eReligion = (ReligionTypes)iI;
		CvReligionEntry* pEntry = GC.getReligionInfo(eReligion);
		if (!pEntry)
			continue;
		if (eReligion == RELIGION_PANTHEON)
			continue;

		vbAdoptionBonus[iI] = pCity->HasPaidAdoptionBonus(eReligion);
	}

	// And finally, store buildings and Great Works
	int iNumBuildingInfos = GC.getNumBuildingInfos();
	int iNumBuildingClassInfos = GC.getNumBuildingClassInfos();
	std::vector<int> viNumRealBuilding(iNumBuildingInfos, 0);
	std::vector<int> viNumFreeBuilding(iNumBuildingInfos, 0);
	std::vector<int> viBuildingOriginalOwner(iNumBuildingInfos, 0);
	std::vector<int> viBuildingOriginalTime(iNumBuildingInfos, 0);
	std::vector<BuildingYieldChange> vcBuildingYieldChange;
	struct CopyGreatWorkData
	{
		int m_iGreatWork;
		BuildingTypes m_eBuildingType;
		int m_iSlot;
		bool m_bTransferred;
	};
	std::vector<CopyGreatWorkData> vcGreatWorkData;

	for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		BuildingTypes eBuilding = (BuildingTypes)iI;
		viNumRealBuilding[iI] = pCity->GetCityBuildings()->GetNumRealBuilding(eBuilding);
		viNumFreeBuilding[iI] = pCity->GetCityBuildings()->GetNumFreeBuilding(eBuilding);
		viBuildingOriginalOwner[iI] = pCity->GetCityBuildings()->GetBuildingOriginalOwner(eBuilding);
		viBuildingOriginalTime[iI] = pCity->GetCityBuildings()->GetBuildingOriginalTime(eBuilding);

		if (pCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
		{
			CvBuildingEntry *pkBuilding = GC.getBuildingInfo(eBuilding);
			if (pkBuilding)
			{
				for (int iJ = 0; iJ < pkBuilding->GetGreatWorkCount(); iJ++)
				{
					int iGreatWork = pCity->GetCityBuildings()->GetBuildingGreatWork(pkBuilding->GetBuildingClassType(), iJ);
					if (iGreatWork != NO_GREAT_WORK)
					{
						CopyGreatWorkData kData;
						kData.m_iGreatWork = iGreatWork;
						kData.m_eBuildingType = eBuilding;
						kData.m_iSlot = iJ;
						kData.m_bTransferred = false;
						vcGreatWorkData.push_back(kData);

						CvPlayer &kOldOwner = GET_PLAYER(eOriginalOwner); // Recursive: shouldn't this be eOldOwner?
						if (kOldOwner.GetCulture()->GetSwappableWritingIndex() == iGreatWork)
							kOldOwner.GetCulture()->SetSwappableWritingIndex(-1);

						if (kOldOwner.GetCulture()->GetSwappableArtifactIndex() == iGreatWork)
							kOldOwner.GetCulture()->SetSwappableArtifactIndex(-1);

						if (kOldOwner.GetCulture()->GetSwappableArtIndex() == iGreatWork)
							kOldOwner.GetCulture()->SetSwappableArtIndex(-1);

						if (kOldOwner.GetCulture()->GetSwappableMusicIndex() == iGreatWork)
							kOldOwner.GetCulture()->SetSwappableMusicIndex(-1);
					}
				}
			}
		}
	}
	for (int iI = 0; iI < iNumBuildingClassInfos; iI++)
	{
		BuildingClassTypes eBuildingClass = (BuildingClassTypes)iI;
		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
		if (!pkBuildingClassInfo)
			continue;

		for (int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)
		{
			YieldTypes Yield = (YieldTypes)iYield;
			BuildingYieldChange kChange;

			kChange.eBuildingClass = eBuildingClass;
			kChange.eYield = Yield;
			kChange.iChange = pCity->GetCityBuildings()->GetBuildingYieldChange(eBuildingClass, Yield);
			if (kChange.iChange != 0)
				vcBuildingYieldChange.push_back(kChange);
		}
	}

	// Prepare the city to be destroyed
	pCity->PreKill();
	CvInterfacePtr<ICvCity1> pkDllOldCity(new CvDllCity(pCity));
	gDLL->GameplayCityCaptured(pkDllOldCity.get(), GetID());

	// Get rid of the old city!
	GET_PLAYER(eOldOwner).deleteCity(pCity->GetID());
	pCity = NULL; // Do not use this pointer anymore!

	// Trigger a few things if the capital was captured
	if (bCapital)
	{
		GET_PLAYER(eOldOwner).findNewCapital();

		if (bOriginalCapital)
			GET_TEAM(getTeam()).resetVictoryProgress();
	}

	// Update who owns all nearby plots
	GC.getMap().updateOwningCityForPlots(pCityPlot,iCityRings*2);
	GC.GetEngineUserInterface()->setDirty(NationalBorders_DIRTY_BIT, true);

	// Now create a new city!
	CvCity* pNewCity = initCity(iCityX, iCityY, !bConquest, false, NO_RELIGION, strName.c_str());
	if (!pNewCity)
		return NULL;

	iNumCities++;
	bool bMinorCivBuyout = !bConquest && bGift && GET_PLAYER(eOldOwner).isMinorCiv();

	// Copy over data from the previous city
	pNewCity->setName(strName);

	if (bMinorCivBuyout && !MOD_GLOBAL_CS_LIBERATE_AFTER_BUYOUT)
	{
		// Prevent liberation later on.
		pNewCity->setPreviousOwner(NO_PLAYER);
		pNewCity->setOriginalOwner(GetID());
		pNewCity->setGameTurnFounded(GC.getGame().getGameTurn());
		pNewCity->setNeverLost(true);
	}
	else
	{
		pNewCity->setPreviousOwner(eOldOwner);
		pNewCity->setOriginalOwner(eOriginalOwner);
		pNewCity->setGameTurnFounded(iGameTurnFounded);
		pNewCity->setNeverLost(false);
	}

	// Slaughtering time!
	int iPercentPopulationRetained = 100;
	if (bSlaughter)
	{
		iPercentPopulationRetained = min(/*50 in CP, 75 in VP*/ GD_INT_GET(CITY_CAPTURE_POPULATION_PERCENT), 100);
		int iRetentionFromTourism = GetCulture()->GetInfluenceCityConquestReduction(eOldOwner) * (100 - iPercentPopulationRetained) / 100;
		iPercentPopulationRetained += iRetentionFromTourism;
	}

	int iNewPopulation = max(1, (iPopulation * iPercentPopulationRetained) / 100);
	pNewCity->setPopulation(iNewPopulation, true, true);
	pNewCity->setLowestRazingPop(iNewPopulation);
	pNewCity->setHighestPopulation(iHighestPopulation);
	pNewCity->SetJONSCultureLevel(iCultureLevel);
	pNewCity->setMadeAttack(bHasMadeAttack);
	pNewCity->SetNoWarmonger(bNoWarmongerYet);

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		pNewCity->SetTraded(eLoopPlayer, vbTraded[iPlayerLoop]);
		pNewCity->setEverLiberated(eLoopPlayer, vbEverLiberated[iPlayerLoop]);
		pNewCity->SetNumTimesOwned(eLoopPlayer, viNumTimesOwned[iPlayerLoop]);
		pNewCity->setEconomicValue(eLoopPlayer, viEconValue[iPlayerLoop]);

		if (iPlayerLoop < MAX_MAJOR_CIVS)
		{
			if (bMinorCivBuyout && !MOD_GLOBAL_CS_LIBERATE_AFTER_BUYOUT)
				pNewCity->SetIgnoredForExpansionBickering(eLoopPlayer, true);
			else
				pNewCity->SetIgnoredForExpansionBickering(eLoopPlayer, vbIgnoredForExpansionBickering[iPlayerLoop]);
		}
	}

	// Copy over religion data
	for (int iI = 0; iI < GC.getNumReligionInfos(); iI++)
	{
		ReligionTypes eReligion = (ReligionTypes)iI;
		CvReligionEntry* pEntry = GC.getReligionInfo(eReligion);
		if (!pEntry)
			continue;
		if (eReligion == RELIGION_PANTHEON)
			continue;

		pNewCity->SetPaidAdoptionBonus(eReligion, vbAdoptionBonus[iI]);
	}

	pNewCity->GetCityReligions()->Copy(&tempReligions);
	pNewCity->GetCityReligions()->RemoveFormerPantheon();

	// "Instant conversion" UA? Trigger it now.
	if (GetPlayerTraits()->IsReconquista())
	{
		ReligionTypes eReligion = GetReligions()->GetStateReligion();
		if (eReligion != NO_RELIGION)
		{
			pNewCity->GetCityReligions()->AdoptReligionFully(eReligion);
		}
	}

	// Reacquired our Holy City?
	if (bHolyCity && IsHasLostHolyCity() && pNewCity->GetCityReligions()->IsHolyCityForReligion(GetReligions()->GetOriginalReligionCreatedByPlayer()))
	{
		// Notify, etc.
		SetHasLostHolyCity(false, NO_PLAYER);
	}

	// Reacquired our original capital?
	bool bRegainedCapital = false;
	if (pNewCity->IsOriginalCapitalForPlayer(m_eID))
	{
		// Notify, etc.
		SetHasLostCapital(false, NO_PLAYER);
		bRegainedCapital = true;

		BuildingTypes ePalace = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(GD_INT_GET(CAPITAL_BUILDINGCLASS));
		CvCity* pCurrentCapital = getCapitalCity();
		bool bRome = GetPlayerTraits()->IsKeepConqueredBuildings();

		if (ePalace != NO_BUILDING)
		{
			// Remove the Palace from the current capital, if any
			if (pCurrentCapital)
			{
				if (MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome)
				{
					pCurrentCapital->GetCityBuildings()->RemoveAllRealBuildingsOfClass((BuildingClassTypes)GD_INT_GET(CAPITAL_BUILDINGCLASS));
				}
				else
				{
					pCurrentCapital->GetCityBuildings()->SetNumRealBuilding(ePalace, 0);
				}

				// If Venice reacquires its original capital, its old capital becomes puppeted
				if (GetPlayerTraits()->IsNoAnnexing())
				{
					pCurrentCapital->DoCreatePuppet();
				}
			}

			// Add the Palace to the reacquired capital
			pNewCity->GetCityBuildings()->SetNumRealBuilding(ePalace, 1);
		}

		// Check for policies that add capital buildings and transfer them.
		for (int iI = 0; iI < iNumBuildingClassInfos; iI++)
		{
			BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iI);
			CvBuildingClassInfo* pkBuildingClass = GC.getBuildingClassInfo(eBuildingClass);
			if (!pkBuildingClass)
				continue;

			if (GetNumCitiesFreeChosenBuilding(eBuildingClass) > 0 || IsFreeChosenBuildingNewCity(eBuildingClass) || IsFreeBuildingAllCity(eBuildingClass))
			{
				BuildingTypes eBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(pkBuildingClass->GetID());
				if (eBuilding == NO_BUILDING || eBuilding == ePalace)
					continue;

				CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
				if (!pkBuildingInfo)
					continue;

				if (!pkBuildingInfo->IsCapitalOnly())
					continue;

				// Delete from current capital
				if (pCurrentCapital)
				{
					if (MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome)
					{
						pCurrentCapital->GetCityBuildings()->RemoveAllRealBuildingsOfClass(eBuildingClass);
					}
					else
					{
						pCurrentCapital->GetCityBuildings()->SetNumRealBuilding(eBuilding, 0);
					}
				}

				// Add to reacquired capital
				pNewCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, 1);
			}
		}

		if (MOD_EVENTS_CITY_CAPITAL)
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_CapitalChanged, GetID(), pNewCity->GetID(), (pCurrentCapital ? pCurrentCapital->GetID() : -1));
	}

	// Austria & Venice UA: Award free buildings
	if (bMinorCivBuyout)
		AwardFreeBuildings(pNewCity);

	// Award free conquest buildings
	if (bConquest)
	{
		BuildingTypes eTraitFreeBuilding = GetPlayerTraits()->GetFreeBuildingOnConquest();
		if (eTraitFreeBuilding != NO_BUILDING)
		{
			CvBuildingEntry* pkLoopBuilding = GC.getBuildingInfo(eTraitFreeBuilding);
			if (pkLoopBuilding && pNewCity->isValidBuildingLocation(eTraitFreeBuilding))
			{
				// If a non-free building of this type exists in the city, remove it!
				if (pNewCity->GetCityBuildings()->GetNumRealBuilding(eTraitFreeBuilding) > 0)
				{
					pNewCity->GetCityBuildings()->SetNumRealBuilding(eTraitFreeBuilding, 0);
					int iProductionValue = pNewCity->getProductionNeeded(eTraitFreeBuilding);
					doInstantYield(INSTANT_YIELD_TYPE_REFUND, false, NO_GREATPERSON, NO_BUILDING, iProductionValue, false, NO_PLAYER, NULL, false, pNewCity);
				}

				pNewCity->GetCityBuildings()->SetNumFreeBuilding(eTraitFreeBuilding, 1);
			}
		}

		std::vector<BuildingTypes> freeConquestBuildings = m_pPlayerPolicies->GetFreeBuildingsOnConquest();
		for (int iI = 0; iI < (int)freeConquestBuildings.size(); iI++)
		{
			const BuildingTypes eLoopBuilding = freeConquestBuildings[iI];
			if (eLoopBuilding == NO_BUILDING)
				continue;

			CvBuildingEntry* pkLoopBuilding = GC.getBuildingInfo(eLoopBuilding);
			if (!pkLoopBuilding)
				continue;

			BuildingTypes eFreeBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(pkLoopBuilding->GetBuildingClassType());

			if (!pNewCity->isValidBuildingLocation(eFreeBuilding))
				continue;

			// If a non-free building of this type exists in the city, remove it!
			if (pNewCity->GetCityBuildings()->GetNumRealBuilding(eFreeBuilding) > 0)
			{
				pNewCity->GetCityBuildings()->SetNumRealBuilding(eFreeBuilding, 0);
				int iProductionValue = pNewCity->getProductionNeeded(eFreeBuilding);
				doInstantYield(INSTANT_YIELD_TYPE_REFUND, false, NO_GREATPERSON, NO_BUILDING, iProductionValue, false, NO_PLAYER, NULL, false, pNewCity);
			}

			pNewCity->GetCityBuildings()->SetNumFreeBuilding(eFreeBuilding, 1);
		}
	}

	// Award free buildings from policies, etc.
	for (int iI = 0; iI < iNumBuildingClassInfos; iI++)
	{
		const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iI);
		CvBuildingClassInfo* pkBuildingClass = GC.getBuildingClassInfo(eBuildingClass);
		if (!pkBuildingClass)
			continue;

		int iNumFreeBuildings = GetNumCitiesFreeChosenBuilding(eBuildingClass);
		if (iNumFreeBuildings > 0 || IsFreeChosenBuildingNewCity(eBuildingClass) || IsFreeBuildingAllCity(eBuildingClass))
		{
			BuildingTypes eBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(pkBuildingClass->GetID());
			if (eBuilding == NO_BUILDING)
				continue;

			CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
			if (!pkBuilding)
				continue;

			if (!pNewCity->isValidBuildingLocation(eBuilding))
				continue;

			// If a non-free building of this type exists in the city, remove it!
			if (pNewCity->GetCityBuildings()->GetNumRealBuilding(eBuilding) > 0)
			{
				pNewCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, 0);
				int iProductionValue = pNewCity->getProductionNeeded(eBuilding);
				doInstantYield(INSTANT_YIELD_TYPE_REFUND, false, NO_GREATPERSON, NO_BUILDING, iProductionValue, false, NO_PLAYER, NULL, false, pNewCity);
			}

			// Award the building!
			pNewCity->GetCityBuildings()->SetNumFreeBuilding(eBuilding, 1);

			if (pNewCity->GetCityBuildings()->GetNumFreeBuilding(eBuilding) > 0)
				ChangeNumCitiesFreeChosenBuilding(eBuildingClass, -1);
		}
	}

	// Gifted/liberated/revolting cities and Rome always keep valid buildings
	bool bKeepAllValidBuildings = GetPlayerTraits()->IsKeepConqueredBuildings() || !bConquest || bGift;
	int iCaptureGreatWorks = 0;

	// Now transfer buildings from the old city
	for (int iI = 0; iI < iNumBuildingInfos; iI++)
	{
		BuildingTypes eLoopBuilding = static_cast<BuildingTypes>(iI);
		if (eLoopBuilding == NO_BUILDING)
			continue;

		CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eLoopBuilding);
		if (!pkBuilding)
			continue;

		BuildingClassTypes eBuildingClass = pkBuilding->GetBuildingClassType();
		const CvBuildingClassInfo& pkBuildingClass = pkBuilding->GetBuildingClassInfo();

		BuildingTypes eBuilding = NO_BUILDING;
		int iBuildingCount = 0;

		// Free buildings are destroyed automatically unless all valid buildings are being kept
		bool bFree = bKeepAllValidBuildings && viNumFreeBuilding[iI] > 0;

		if (bFree || viNumRealBuilding[iI] > 0)
		{
			if (::isWorldWonderClass(pkBuildingClass))
			{
				eBuilding = eLoopBuilding;
			}
			else if (bKeepAllValidBuildings)
			{
				// If we have a replacement building, grab the replacement instead.
				if (playerCivilizationInfo.isCivilizationBuildingOverridden(eBuildingClass))
				{
					eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings(eBuildingClass);
				}
				else
				{
					eBuilding = eLoopBuilding;
				}
			}
			else
			{
				eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings(eBuildingClass);
			}

			if (eBuilding == NO_BUILDING)
				continue;

			pkBuilding = GC.getBuildingInfo(eBuilding);
			if (!pkBuilding)
				continue;

			// This tests for conquest probability and building validity.
			if (!IsValidBuildingForPlayer(pNewCity, eBuilding, (bConquest && !bGift)))
				continue;

			if (bFree)
			{
				iBuildingCount += viNumFreeBuilding[iI];
				pNewCity->GetCityBuildings()->SetNumFreeBuilding(eBuilding, iBuildingCount);
			}
			else
			{
				iBuildingCount += viNumRealBuilding[iI];
				pNewCity->GetCityBuildings()->SetNumRealBuildingTimed(eBuilding, iBuildingCount, false, (PlayerTypes)viBuildingOriginalOwner[iI], viBuildingOriginalTime[iI]);
			}
		}
		if (iBuildingCount > 0)
		{
			// Transfer Great Works to the building
			int iGreatWorksCount = pkBuilding->GetGreatWorkCount();
			int iGreatWorksAdded = 0;
			if (iGreatWorksCount > 0)
			{
				for (int iJ = 0; iJ < (int)vcGreatWorkData.size(); iJ++)
				{
					if (vcGreatWorkData[iJ].m_bTransferred)
						continue;

					if (vcGreatWorkData[iJ].m_eBuildingType == (BuildingTypes)iI)
					{
						// Try to add the Great Work to the same slot number. If this fails, the transfer will be done after all buildings are added.
						if (vcGreatWorkData[iJ].m_iSlot < iGreatWorksCount)
						{
							pNewCity->GetCityBuildings()->SetBuildingGreatWork(eBuildingClass, vcGreatWorkData[iJ].m_iSlot, vcGreatWorkData[iJ].m_iGreatWork);
							vcGreatWorkData[iJ].m_bTransferred = true;
							iGreatWorksAdded++;
							iCaptureGreatWorks++;
						}
					}

					if (iGreatWorksAdded >= iGreatWorksCount)
						break;
				}
			}
			if (bConquest && MOD_API_ACHIEVEMENTS && !GC.getGame().isGameMultiPlayer() && isHuman())
			{
				// Check for Tomb Raider achievement
				if (_stricmp(pkBuilding->GetType(), "BUILDING_BURIAL_TOMB") == 0 && iCaptureGold > 0) // Need to actually pillage something from the 'tomb'
				{
					gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_TOMBRAIDER);
				}
				// Check for Rome conquering Statue of Zeus achievement
				else if (_stricmp(pkBuilding->GetType(), "BUILDING_STATUE_ZEUS") == 0 && strcmp(getCivilizationTypeKey(), "CIVILIZATION_ROME") == 0)
				{
					gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_ROME_GETS_ZEUS);
				}
			}
		}
	}
	// Recursive: why is this cached? Shouldn't this be recomputed? Some buildings may have been destroyed!
	for (std::vector<BuildingYieldChange>::iterator it = vcBuildingYieldChange.begin(); it != vcBuildingYieldChange.end(); it++)
	{
		pNewCity->GetCityBuildings()->SetBuildingYieldChange((*it).eBuildingClass, (*it).eYield, (*it).iChange);
	}

	// Distribute any remaining Great Works to other buildings
	for (int iI = 0; iI < (int)vcGreatWorkData.size(); iI++)
	{
		if (vcGreatWorkData[iI].m_bTransferred)
			continue;

		BuildingClassTypes eBuildingClass = NO_BUILDINGCLASS; // Passed by reference below
		int iSlot = -1; // Passed by reference below

		GreatWorkType eType = GC.getGame().GetGameCulture()->m_CurrentGreatWorks[vcGreatWorkData[iI].m_iGreatWork].m_eType;
		GreatWorkSlotType eGreatWorkSlot = CultureHelpers::GetGreatWorkSlot(eType);

		// Attempt to keep the Great Work in the current city, if possible
		if (pNewCity->GetCityBuildings()->GetNextAvailableGreatWorkSlot(eGreatWorkSlot, &eBuildingClass, &iSlot))
		{
			pNewCity->GetCityBuildings()->SetBuildingGreatWork(eBuildingClass, iSlot, vcGreatWorkData[iI].m_iGreatWork);
			vcGreatWorkData[iI].m_bTransferred = true;
			iCaptureGreatWorks++;
		}
		// Not possible? Look for the closest available Great Work slot.
		else
		{
			BuildingClassTypes eGWBuildingClass; // Passed by reference below
			int iGWSlot; // Passed by reference below
			CvCity* pClosestValidCity = GetCulture()->GetClosestAvailableGreatWorkSlot(iCityX, iCityY, eGreatWorkSlot, &eGWBuildingClass, &iGWSlot);
			if (pClosestValidCity)
			{
				pClosestValidCity->GetCityBuildings()->SetBuildingGreatWork(eGWBuildingClass, iGWSlot, vcGreatWorkData[iI].m_iGreatWork);
				vcGreatWorkData[iI].m_bTransferred = true;
				iCaptureGreatWorks++;
			}
		}
	}

	// Test to see if the city acquirer has won a Domination Victory
	GC.getGame().DoTestConquestVictory();

	// Update ownership of nearby plots
	// Recursive: Still needed?
	GC.getMap().updateOwningCityForPlots(pCityPlot, pNewCity->getWorkPlotDistance()*2);
	if (bConquest)
	{
		const int iMaxRange = /*5*/ range(GD_INT_GET(MAXIMUM_ACQUIRE_PLOT_DISTANCE), 1, MAX_CITY_RADIUS);
		for (int iDX = -iMaxRange; iDX <= iMaxRange; iDX++)
		{
			for (int iDY = -iMaxRange; iDY <= iMaxRange; iDY++)
			{
				CvPlot* pLoopPlot = plotXYWithRangeCheck(iCityX, iCityY, iDX, iDY, iMaxRange);
				if (pLoopPlot)
					pLoopPlot->verifyUnitValidPlot();
			}
		}
	}

	// Set the plots to the new owner.
	bool bBumpUnits = isMajorCiv();
	
	for (size_t i = 0; i < ownedPlots.size(); i++)
	{
		ownedPlots[i]->setOwner(GetID(), pNewCity->GetID(), (bBumpUnits || ownedPlots[i]->isCity()), true);
	}

	// Update Player Proximity
	GET_PLAYER(eOldOwner).DoUpdateProximityToPlayers();
	DoUpdateProximityToPlayers();

	// Update events
	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if (pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(eOldOwner);
		args->Push(bCapital);
		args->Push(iCityX);
		args->Push(iCityY);
		args->Push(GetID());
		args->Push(iPopulation);
		args->Push(bConquest);
		args->Push((int)vcGreatWorkData.size());
		args->Push(iCaptureGreatWorks);

		bool bResult;
		LuaSupport::CallHook(pkScriptSystem, "CityCaptureComplete", args.get(), bResult);
	}

	if (MOD_BALANCE_CORE_EVENTS)
		CheckActivePlayerEvents(pNewCity);

	if (bFirstConquest && isMajorCiv())
	{
		// Spawn unique luxuries on city conquest?
		if (MOD_BALANCE_CORE_LUXURIES_TRAIT && GetPlayerTraits()->GetUniqueLuxuryQuantity() > 0)
		{
			GetPlayerTraits()->AddUniqueLuxuriesAround(pNewCity, GetPlayerTraits()->GetUniqueLuxuryQuantity());
		}

		// Free unit on city conquest?
		UnitTypes eFreeUnitConquest = GetPlayerTraits()->GetFreeUnitOnConquest();
		if (eFreeUnitConquest != NO_UNIT && canTrainUnit(eFreeUnitConquest, false, false, true, true))
		{
			CvUnit* pkUnit = initUnit(eFreeUnitConquest, iCityX, iCityY);
			CvCity* pCapital = getCapitalCity();
			bool bShouldSpawn = true;

			// Give religious units the player's religion
			if (pkUnit->isReligiousUnit())
			{
				ReligionTypes eStateReligion = GetReligions()->GetStateReligion(false);

				// Unless it's a prophet we shouldn't give a free religious unit without a religion
				if (eStateReligion == NO_RELIGION && !pkUnit->IsGreatPerson())
					bShouldSpawn = false;
				else
					pkUnit->GetReligionDataMutable()->SetReligion(eStateReligion);
			}

			bool bJumpSuccess = bShouldSpawn ? pkUnit->jumpToNearestValidPlot() : false;

			if (bJumpSuccess)
			{
				if (pCapital)
					pCapital->addProductionExperience(pkUnit);
			}
			else
			{
				pkUnit->kill(false);
			}
		}
	}

	// Increment how many times we have owned the city
	pNewCity->ChangeNumTimesOwned(GetID(), 1);

	// Set city damage (only do this after having added all buildings, some of which might have increased city HP)
	int iMaximumBattleDamage = bConquest ? (pNewCity->GetMaxHitPoints() * /*50*/ GD_INT_GET(CITY_CAPTURE_DAMAGE_PERCENT)) / 100 : pNewCity->GetMaxHitPoints();
	if (iMaximumBattleDamage >= pNewCity->GetMaxHitPoints())
		iMaximumBattleDamage = max(0, pNewCity->GetMaxHitPoints() - 1);
	if (iBattleDamage > iMaximumBattleDamage)
		iBattleDamage = iMaximumBattleDamage;

	pNewCity->setDamage(iBattleDamage, true);
	bool bMajorEliminated = false;

	if (!bMinorCivBuyout)
	{
		// Test if the old owner is dead
		CheckForMurder(eOldOwner);

		// Dead?
		if (!GET_PLAYER(eOldOwner).isAlive())
		{
			// Let's give the Embassy votes of the defeated player to the new player
			if (isMajorCiv() && GET_PLAYER(eOldOwner).GetImprovementLeagueVotes() > 0)
			{
				ChangeImprovementLeagueVotes(GET_PLAYER(eOldOwner).GetImprovementLeagueVotes());
			}
			if (GET_PLAYER(eOldOwner).isMajorCiv())
			{
				bMajorEliminated = true;
			}
		}
		// If not dead, old owner should update city specializations
		else
		{
			GET_PLAYER(eOldOwner).GetCitySpecializationAI()->SetSpecializationsDirty(SPECIALIZATION_UPDATE_MY_CITY_CAPTURED);
		}
	}

	// New owner should update city specializations
	GetCitySpecializationAI()->SetSpecializationsDirty(SPECIALIZATION_UPDATE_ENEMY_CITY_CAPTURED);

	// Display the notification for the spoils of plundering
	if (GC.getGame().getActivePlayer() == GetID())
	{
		if (iCaptureGold > 0 || iCaptureCulture > 0 || iCaptureGreatWorks > 0)
		{
			CvString strBuffer;
			if (iCaptureCulture == 0 && iCaptureGreatWorks == 0)
			{
				strBuffer = GetLocalizedText("TXT_KEY_POPUP_GOLD_CITY_CAPTURE", iCaptureGold, pNewCity->getNameKey());
			}
			else
			{
				strBuffer = GetLocalizedText("TXT_KEY_POPUP_GOLD_AND_CULTURE_CITY_CAPTURE", iCaptureGold, iCaptureCulture, iCaptureGreatWorks, pNewCity->getNameKey());
			}
			GC.GetEngineUserInterface()->AddCityMessage(0, pNewCity->GetIDInfo(), GetID(), true, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), strBuffer);
			if (MOD_WH_MILITARY_LOG)
				MILITARYLOG(GetID(), strBuffer.c_str(), pNewCity->plot(), eOldOwner);
		}
	}

	if (pNewCity)
	{
		// Is this City being occupied?
		if (GET_PLAYER(pNewCity->getOriginalOwner()).getTeam() != getTeam() || isBarbarian())
		{
			pNewCity->SetOccupied(true);

			// Determine resistance turns.
			if (bConquest && !bGift)
			{
				int iReductionFromTourism = (isMajorCiv() && GET_PLAYER(eOldOwner).isMajorCiv()) ? GetCulture()->GetInfluenceCityConquestReduction(eOldOwner) : 0;
				int iResistanceTurns = MOD_BALANCE_CORE_SETTLER_ADVANCED ? (pNewCity->getPopulation() * 2) / 3 : pNewCity->getPopulation();
				iResistanceTurns *= 100 - iReductionFromTourism;
				iResistanceTurns /= 100;
				pNewCity->ChangeResistanceTurns(max(iResistanceTurns, 1));
			}
		}
		// Our team's city?
		else if (GET_PLAYER(pNewCity->getOriginalOwner()).getTeam() == getTeam())
		{
			// A teammate's city? Automatically liberated!
			if (ePlayerToLiberate != NO_PLAYER)
			{
				DoLiberatePlayer(ePlayerToLiberate, pNewCity->GetID());
				pNewCity = NULL; // delete the pointer
			}
			else if (iNumCities > 1)
			{
				if (GetPlayerTraits()->IsNoAnnexing() && !bRegainedCapital)
				{
					pNewCity->DoCreatePuppet();
				}
			}
			// Is this our only city? It's now the capital!
			else if (iNumCities == 1 && !bRegainedCapital)
			{
				BuildingTypes ePalace = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(GD_INT_GET(CAPITAL_BUILDINGCLASS));
				if (ePalace != NO_BUILDING)
				{
					// Add the Palace to the new capital
					pNewCity->GetCityBuildings()->SetNumRealBuilding(ePalace, 1);
				}

				// Check for policies that add capital buildings and transfer them.
				for (int iI = 0; iI < iNumBuildingClassInfos; iI++)
				{
					BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iI);
					CvBuildingClassInfo* pkBuildingClass = GC.getBuildingClassInfo(eBuildingClass);
					if (!pkBuildingClass)
						continue;

					if (GetNumCitiesFreeChosenBuilding(eBuildingClass) > 0 || IsFreeChosenBuildingNewCity(eBuildingClass) || IsFreeBuildingAllCity(eBuildingClass))
					{
						BuildingTypes eBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(pkBuildingClass->GetID());
						if (eBuilding == NO_BUILDING || eBuilding == ePalace)
							continue;

						CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
						if (!pkBuildingInfo)
							continue;

						if (!pkBuildingInfo->IsCapitalOnly())
							continue;

						// Add to reacquired capital
						pNewCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, 1);
					}
				}

				if (MOD_EVENTS_CITY_CAPITAL)
					GAMEEVENTINVOKE_HOOK(GAMEEVENT_CapitalChanged, GetID(), pNewCity->GetID(), -1);
			}
		}
	}

	if (pNewCity && !isBarbarian())
	{
		// If we don't have ANY cities, we must annex & make a capital.
		if (iNumCities == 1)
		{
			if (!bRegainedCapital)
			{
				BuildingTypes ePalace = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(GD_INT_GET(CAPITAL_BUILDINGCLASS));
				if (ePalace != NO_BUILDING)
				{
					// Add the Palace to the new capital
					pNewCity->GetCityBuildings()->SetNumRealBuilding(ePalace, 1);
				}

				// Check for policies that add capital buildings and transfer them.
				for (int iI = 0; iI < iNumBuildingClassInfos; iI++)
				{
					BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iI);
					CvBuildingClassInfo* pkBuildingClass = GC.getBuildingClassInfo(eBuildingClass);
					if (!pkBuildingClass)
						continue;

					if (GetNumCitiesFreeChosenBuilding(eBuildingClass) > 0 || IsFreeChosenBuildingNewCity(eBuildingClass) || IsFreeBuildingAllCity(eBuildingClass))
					{
						BuildingTypes eBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(pkBuildingClass->GetID());
						if (eBuilding == NO_BUILDING || eBuilding == ePalace)
							continue;

						CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
						if (!pkBuildingInfo)
							continue;

						if (!pkBuildingInfo->IsCapitalOnly())
							continue;

						// Add to reacquired capital
						pNewCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, 1);
					}
				}

				if (MOD_EVENTS_CITY_CAPITAL)
					GAMEEVENTINVOKE_HOOK(GAMEEVENT_CapitalChanged, GetID(), pNewCity->GetID(), -1);
			}
		}
		// If the city was originally ours, do nothing
		else if (pNewCity->getOriginalOwner() != m_eID)
		{
			// AI decides what to do with a City
			if (!isHuman())
			{
				AI_conquerCity(pNewCity, ePlayerToLiberate, bGift); // Calling this could delete the pointer...

				// So we will check to see if the plot still contains the city.
				CvCity* pkCurrentCity = pCityPlot->getPlotCity();
				if (pkCurrentCity == NULL || pNewCity != pkCurrentCity || pkCurrentCity->getOwner() != GetID())
				{
					pNewCity = NULL; // The city is gone or is not ours anymore (we gave it away)
				}
			}
			// Human decides what to do with a City
			else
			{
				pNewCity->SetIgnoreCityForHappiness(true); // Used to display info for annex/puppet/raze popup - turned off in DoCreatePuppet and DoAnnex
				CvNotifications* pNotify = GetNotifications();

				if (GetPlayerTraits()->IsNoAnnexing() && bMinorCivBuyout)
				{
					pNewCity->DoCreatePuppet();
				}
				else if (GC.getGame().getActivePlayer() == GetID() && pNotify)
				{
					int iTemp[5] = { pNewCity->GetID(), iCaptureGold, iCaptureCulture, iCaptureGreatWorks, ePlayerToLiberate };
					bool bTemp[2] = { bMinorCivBuyout, bConquest };
					pNewCity->setCaptureData(iTemp, bTemp);

					CvString strBuffer = GetLocalizedText("TXT_KEY_CHOOSE_CITY_CAPTURE", pNewCity->getNameKey());
					CvString strSummary = GetLocalizedText("TXT_KEY_CHOOSE_CITY_CAPTURE_TT", pNewCity->getNameKey());
					pNotify->Add((NotificationTypes)FString::Hash("NOTIFICATION_CITY_CAPTURE"), strSummary.c_str(), strBuffer.c_str(), pNewCity->getX(), pNewCity->getY(), -1);
				}
				else
				{
					pNewCity->SetIgnoreCityForHappiness(false);
				}
			}
		}
	}

	if (GC.getGame().getActiveTeam() == GET_PLAYER(eOldOwner).getTeam())
		GC.getMap().updateDeferredFog();

	// City acquired by Barbarians? Start the spawn counter.
	if (pNewCity && MOD_BALANCE_VP && isBarbarian())
		CvBarbarians::DoCityActivationNotice(pCityPlot);

	// Now that everything is done, we need to update diplomacy!
	// This prevents the AI from getting exploited in peace deals, among other things
	vector<PlayerTypes> vNewOwnerTeam = GET_TEAM(getTeam()).getPlayers();

	// New owner's team reevaluates all players now that they're in possession of this city
	for (size_t i=0; i<vNewOwnerTeam.size(); i++)
	{
		PlayerTypes eOwnerTeamMember = GET_PLAYER(vNewOwnerTeam[i]).GetID();
		if (!GET_PLAYER(eOwnerTeamMember).isAlive() || !GET_PLAYER(eOwnerTeamMember).isMajorCiv())
			continue;

		vector<PlayerTypes> v = GET_PLAYER(eOwnerTeamMember).GetDiplomacyAI()->GetAllValidMajorCivs();
		GET_PLAYER(eOwnerTeamMember).GetDiplomacyAI()->DoUpdateConquestStats();
		GET_PLAYER(eOwnerTeamMember).GetDiplomacyAI()->DoReevaluatePlayers(v, true, bMajorEliminated);
	}

	// The rest of the world reevaluates the new owner's team in return - unless a player was eliminated, in which case everyone reevaluates everyone
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		bool bReevaluate = bMajorEliminated || GET_TEAM(GET_PLAYER(eLoopPlayer).getTeam()).isHasMet(getTeam());

		if (GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).isMajorCiv() && GET_PLAYER(eLoopPlayer).getTeam() != getTeam())
		{
			GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->DoUpdateConquestStats();

			if (bReevaluate)
			{
				if (!bMajorEliminated)
					GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->DoReevaluatePlayers(vNewOwnerTeam, true);
				else
				{
					vector<PlayerTypes> vAllMajors = GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetAllValidMajorCivs();
					GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->DoReevaluatePlayers(vAllMajors, true, true);
				}
			}
		}
	}

	return pNewCity;
}

bool CvPlayer::IsValidBuildingForPlayer(CvCity* pCity, BuildingTypes eBuilding, bool bConquest)
{
	CvBuildingEntry* pkLoopBuildingInfo = GC.getBuildingInfo(eBuilding);
	if (!pkLoopBuildingInfo)
		return false;

	if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_ConquerorValidBuilding, pCity->getOwner(), pCity->GetID(), GetID(), eBuilding) == GAMEEVENTRETURN_FALSE)
		return false;

	const CvBuildingClassInfo& pkClassInfo = pkLoopBuildingInfo->GetBuildingClassInfo();

	bool bIsNationalWonder = ::isNationalWonderClass(pkClassInfo);
	bool bCivUnique = pkClassInfo.getDefaultBuildingIndex() != eBuilding;
	bool bProductionMaxed = isProductionMaxedBuildingClass(pkLoopBuildingInfo->GetBuildingClassType(), true);

	if (GetPlayerTraits()->IsKeepConqueredBuildings())
	{
		if (!bCivUnique)
		{
			if (bIsNationalWonder || bProductionMaxed)
				return false;
		}
		else
		{
			if (bIsNationalWonder && getNumBuildings(eBuilding) > 0)
				return false;
			else if (bProductionMaxed)
				return false;
		}
	}
	else
	{
		if (pkLoopBuildingInfo->IsNeverCapture() || bProductionMaxed || bIsNationalWonder)
			return false;

		if (!bConquest)
			return true;

		int iConquestChance = GC.getGame().getSmallFakeRandNum(34, *pCity->plot()) + GC.getGame().getSmallFakeRandNum(34, pkLoopBuildingInfo->GetID()) + GC.getGame().getSmallFakeRandNum(32, GetPseudoRandomSeed() + GC.getGame().GetGoldMedian());

		return iConquestChance <= pkLoopBuildingInfo->GetConquestProbability();
	}

	return true;
}

//	--------------------------------------------------------------------------------
void CvPlayer::killCities()
{
	//can't kill the cities directly because that invalidates the iterator
	std::vector<int> citiesToKill;

	int iLoop;
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		citiesToKill.push_back(pLoopCity->GetID());
	}

	for (std::vector<int>::iterator it=citiesToKill.begin(); it!=citiesToKill.end(); ++it)
	{
		CvCity* pLoopCity = getCity(*it);
		pLoopCity->kill();
	}
}

const int RESERVE_TOP_X_NAMES = 5;	/// Never steal one of the first 5 names

//	--------------------------------------------------------------------------------
CvString CvPlayer::getNewCityName() const
{
	const CLLNode<CvString>* pNode;
	CvString strName;

	for(pNode = headCityNameNode(); (pNode != NULL); pNode = nextCityNameNode(pNode))
	{
		strName = pNode->m_data;
		if(isCityNameValid(strName, true))
		{
			strName = pNode->m_data;
			break;
		}
	}

	if(strName.IsEmpty())
	{
		getCivilizationCityName(strName, getCivilizationType());
	}

	if(strName.IsEmpty())
	{
		// Pick a name from another civ in the game
		int iPlayersAlive = 0;
		for(int iI = 0; iI < MAX_PLAYERS; iI++)
		{
			const PlayerTypes ePlayer = static_cast<PlayerTypes>(iI);
			CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);
			if(ePlayer != GetID() && kPlayer.isAlive() && !kPlayer.isMinorCiv() && !kPlayer.isBarbarian())
			{
				iPlayersAlive++;
			}
		}

		int iChosenPlayer = GC.getGame().getJonRandNum(iPlayersAlive, "Random Player To Steal City Name");

		int iPlayersFound = 0;
		for(int iI = 0; iI < MAX_PLAYERS; iI++)
		{
			const PlayerTypes ePlayer = static_cast<PlayerTypes>(iI);
			CvPlayerAI &kPlayer = GET_PLAYER(ePlayer);
			if(ePlayer != GetID() && kPlayer.isAlive() && !kPlayer.isMinorCiv() && !kPlayer.isBarbarian())
			{
				if(iPlayersFound == iChosenPlayer)
				{
					strName = GetBorrowedCityName(kPlayer.getCivilizationType());			
					break;
				}
				else
				{
					iPlayersFound++;
				}
			}
		}
	}

	if(strName.IsEmpty())
	{
		// Pick a name from another civ in the DATABASE
		int iCivsInDB = 0;
		for(int iI = 0; iI < GC.getNumCivilizationInfos(); iI++)
		{
			const CivilizationTypes eCiv = static_cast<CivilizationTypes>(iI);

			CvCivilizationInfo* pkCivilizationInfo = GC.getCivilizationInfo(eCiv);
			if(pkCivilizationInfo != NULL && pkCivilizationInfo->getNumCityNames() > RESERVE_TOP_X_NAMES)
			{
				iCivsInDB++;
			}
		}

		int iChosenCiv = GC.getGame().getJonRandNum(iCivsInDB, "Random Civ To Steal City Name");

		int iCivsFound = 0;
		for(int iI = 0; iI < GC.getNumCivilizationInfos(); iI++)
		{
			const CivilizationTypes eCiv = static_cast<CivilizationTypes>(iI);

			CvCivilizationInfo* pkCivilizationInfo = GC.getCivilizationInfo(eCiv);
			if (pkCivilizationInfo != NULL && pkCivilizationInfo->getNumCityNames() > RESERVE_TOP_X_NAMES)
			{
				if (iCivsFound == iChosenCiv)
				{
					strName = GetBorrowedCityName(eCiv);
					break;
				}
				else
				{
					iCivsFound++;
				}
			}
		}
	}

	if(strName.IsEmpty())
	{
		strName = "TXT_KEY_CITY";
	}

	return strName;
}

//	--------------------------------------------------------------------------------
CvString CvPlayer::GetBorrowedCityName(CivilizationTypes eCivToBorrowFrom) const
{
	CvString szRtnValue;
	CvCivilizationInfo *pCivInfo = GC.getCivilizationInfo(eCivToBorrowFrom);

	if (pCivInfo)
	{
		int iRange = pCivInfo->getNumCityNames() - RESERVE_TOP_X_NAMES;
		int iRandOffset = GC.getGame().getJonRandNum(iRange, "Random City Name To Steal");
		for(int iI = 0; iI < iRange; iI++)     
		{
			CvString strCityName = pCivInfo->getCityNames(RESERVE_TOP_X_NAMES + ((iI + iRandOffset) % iRange));
			szRtnValue = GetLocalizedText(strCityName.c_str());

			if(isCityNameValid(szRtnValue, true))
			{
				break;
			}
		}
	}

	return szRtnValue;

}

//	--------------------------------------------------------------------------------
void CvPlayer::getCivilizationCityName(CvString& szBuffer, CivilizationTypes eCivilization) const
{
	int iRandOffset;
	int iLoopName;

	CvCivilizationInfo* pkCivilizationInfo = GC.getCivilizationInfo(eCivilization);
	if(pkCivilizationInfo == NULL)
	{
		//This should never happen.
		return;
	}

	if(isBarbarian())
	{
		iRandOffset = GC.getGame().getJonRandNum(pkCivilizationInfo->getNumCityNames(), "Random Barb Name");
	}
	else
	{
		iRandOffset = 0;
	}

	// Minor Civs use special lists
	if(isMinorCiv())
	{
		CvMinorCivInfo* pkMinorCivInfo = GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType());
		if(pkMinorCivInfo)
		{
			CvMinorCivInfo& kMinorCivInfo = *pkMinorCivInfo;
			for(int iI = 0; iI < kMinorCivInfo.getNumCityNames(); iI++)
			{
				iLoopName = ((iI + iRandOffset) % kMinorCivInfo.getNumCityNames());

				const CvString strCityName = kMinorCivInfo.getCityNames(iLoopName);
				CvString strName = GetLocalizedText(strCityName.c_str());

				if(isCityNameValid(strName, true))
				{
					szBuffer = strCityName;
					break;
				}
			}
		}
	}
	else
	{
		const CvCivilizationInfo& kCivInfo = *pkCivilizationInfo;
		for(int iI = 0; iI < kCivInfo.getNumCityNames(); iI++)
		{
			iLoopName = ((iI + iRandOffset) % kCivInfo.getNumCityNames());

			const CvString strCityName = kCivInfo.getCityNames(iLoopName);
			CvString strName = GetLocalizedText(strCityName.c_str());

			if(isCityNameValid(strName, true))
			{
				szBuffer = strCityName;
				break;
			}
		}
	}
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isCityNameValid(CvString& szName, bool bTestDestroyed, bool bForce) const
{
	if (bForce)
		return true;

	int iLoop;

	if(bTestDestroyed)
	{
		if(GC.getGame().isDestroyedCityName(szName))
		{
			return false;
		}

		for(int iPlayer = 0; iPlayer < MAX_PLAYERS; ++iPlayer)
		{
			CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iPlayer);
			for(const CvCity* pLoopCity = kLoopPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kLoopPlayer.nextCity(&iLoop))
			{
				if(pLoopCity->getName() == szName)
				{
					return false;
				}
			}
		}
	}
	else
	{
		for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity->getName() == szName)
			{
				return false;
			}
		}
	}

	return true;
}

//	--------------------------------------------------------------------------------
/// How far out this player may buy plots
int CvPlayer::getBuyPlotDistance() const
{
	int iDistance = /*3*/ GD_INT_GET(MAXIMUM_BUY_PLOT_DISTANCE);
	return std::min(MAX_CITY_RADIUS, std::max(getWorkPlotDistance(), iDistance));
}

//	--------------------------------------------------------------------------------
/// How far out this player may work plots
int CvPlayer::getWorkPlotDistance() const
{
	int iDistance = /*3*/ GD_INT_GET(MAXIMUM_WORK_PLOT_DISTANCE);
	
#if defined(MOD_TRAITS_CITY_WORKING) || defined(MOD_BUILDINGS_CITY_WORKING) || defined(MOD_POLICIES_CITY_WORKING)
	// Change distance based on traits, policies, wonders, etc
	iDistance += GetCityWorkingChange();
#endif
#if defined(MOD_TECHS_CITY_WORKING)
	// Change distance based on techs, etc
	if (getTeam()!=NO_TEAM)
		iDistance += GET_TEAM(getTeam()).GetCityWorkingChange();
#endif
	
	return std::min(MAX_CITY_RADIUS, std::max(MIN_CITY_RADIUS, iDistance));
}

//	--------------------------------------------------------------------------------
/// How many plots a generic city may work
int CvPlayer::GetNumWorkablePlots() const
{
	return ((6 * (1+getWorkPlotDistance()) * getWorkPlotDistance() / 2) + 1);
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// This player liberates iOldCityID and gives it back to ePlayer
void CvPlayer::DoRevolutionPlayer(PlayerTypes ePlayer, int iOldCityID)
{
	CvCity* pCity = getCity(iOldCityID);
	CvAssert(pCity);
	if (!pCity)
		return;

	if(ePlayer == NO_PLAYER)
	{
		return;
	}

	if (GC.getLogging() && GC.getAILogging() && pCity != NULL)
	{
		CvString playerName;
		FILogFile* pLog;
		CvString strBaseString;
		CvString strOutBuf;
		CvString strFileName = "CityRevolutions.csv";
		playerName = getCivilizationShortDescription();
		pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";
		strOutBuf.Format("Revolution! Civ Liberated and %s restored to %s", pCity->getName().GetCString(), GET_PLAYER(ePlayer).getName());
		strBaseString += strOutBuf;
		pLog->Msg(strBaseString);
	}

	DoLiberatePlayer(ePlayer, pCity->GetID(), true);
}

void CvPlayer::UpdateCityThreatCriteria()
{
	CvTacticalAnalysisMap* pTactMap = GetTacticalAI()->GetTacticalAnalysisMap();

	int iLoopCity = 0;
	for(CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity))
	{
		//ignore danger - it's too volatile or rather it's too late then
		int iThreatValue = 0;

		if (pTactMap)
		{
			CvTacticalDominanceZone* pLandZone = pTactMap->GetZoneByCity(pLoopCity,false);
			CvTacticalDominanceZone* pWaterZone = pTactMap->GetZoneByCity(pLoopCity,true);

			//todo: scale dominance contribution by exposure score?
			if (pLandZone)
			{
				iThreatValue += pLandZone->GetBorderScore(DOMAIN_LAND);
				if (pLandZone->GetOverallDominanceFlag() == TACTICAL_DOMINANCE_ENEMY)
					iThreatValue += 50;
				else if (pLandZone->GetOverallDominanceFlag() == TACTICAL_DOMINANCE_EVEN)
					iThreatValue += 23;
			}
			if (pWaterZone)
			{
				iThreatValue += pWaterZone->GetBorderScore(DOMAIN_SEA);
				if (pWaterZone->GetOverallDominanceFlag() == TACTICAL_DOMINANCE_ENEMY)
					iThreatValue += 50;
				else if (pWaterZone->GetOverallDominanceFlag() == TACTICAL_DOMINANCE_EVEN)
					iThreatValue += 23;
			}
		}

		// Is this a focused city? If so, we need to support it ASAP.
		if (GetTacticalAI()->IsInFocusArea(pLoopCity->plot()))
			iThreatValue += /*125*/ GD_INT_GET(AI_MILITARY_CITY_THREAT_WEIGHT_CAPITAL);
		
		//check the wider area for enemy tiles. may also be on another landmass
		for(int i=RING2_PLOTS; i<RING5_PLOTS; i++)
		{
			CvPlot* pLoopNearbyPlot = iterateRingPlots(pLoopCity->plot(), i);

			//Don't want them adjacent to cities, but we do want to check for plot ownership.
			if (pLoopNearbyPlot != NULL && pLoopNearbyPlot->isRevealed(getTeam()))
			{
				if((pLoopNearbyPlot->getOwner() != GetID()) && (pLoopNearbyPlot->getOwner() != NO_PLAYER) && !(GET_PLAYER(pLoopNearbyPlot->getOwner()).isMinorCiv()))
				{
					PlayerTypes pNeighborNearby = pLoopNearbyPlot->getOwner();
					CivOpinionTypes eNeighborOpinion = GetDiplomacyAI()->GetCivOpinion(pNeighborNearby);

					if(pNeighborNearby != NO_PLAYER)
					{
						if (eNeighborOpinion == CIV_OPINION_NEUTRAL)
						{
							iThreatValue += (i<RING3_PLOTS) ? 3 : 1;
						}
						else if (eNeighborOpinion == CIV_OPINION_COMPETITOR)
						{
							iThreatValue += (i<RING3_PLOTS) ? 5 : 2;
						}
						else if (eNeighborOpinion < CIV_OPINION_COMPETITOR)
						{
							iThreatValue += (i<RING3_PLOTS) ? 7 : 3;
						}
					}
				}
			}
		}

		//note: we don't consider a cities size or economic importance here
		//after all, small border cities are especially vulnerable
		pLoopCity->setThreatValue(iThreatValue);
	}
}

//sorted by threat level, descending
vector<CvCity*> CvPlayer::GetThreatenedCities(bool bCoastalOnly)
{
	vector<CvCity*> result;
	struct SortByThreatLevel
	{
		bool operator()(const CvCity* lhs, const CvCity* rhs) const { return lhs->getThreatValue() > rhs->getThreatValue(); }
	};

	int iLoop;
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (bCoastalOnly && !pLoopCity->isCoastal())
			continue;

		result.push_back(pLoopCity);
	}

	sort(result.begin(), result.end(), SortByThreatLevel());
	return result;
}

void CvPlayer::UpdateBestMilitaryCities()
{
	//What are you doing here? Get out!
	if(isMinorCiv() || isBarbarian())
		return;

	//First let's test domain, then we'll test combat class.
	CvCity* pLoopCity = NULL;
	int iLoop;

	//Unitcombat Value - let's find the best unitcombat class city (includes promotions for unit combat classes below).
	for(int iI = 0; iI < GC.getNumUnitCombatClassInfos(); iI++)
	{
		int iBestCombatClassValue = 0;
		const UnitCombatTypes eUnitCombatClass = static_cast<UnitCombatTypes>(iI);
		CvBaseInfo* pkUnitCombatClassInfo = GC.getUnitCombatClassInfo(eUnitCombatClass);
		if(pkUnitCombatClassInfo)
		{
			CvCity* pBestCombatClassCity = NULL;
			for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				//Production is king, and also our base value.
				int iCombatClassValue = (pLoopCity->getYieldRate(YIELD_PRODUCTION, false) / 5);

				//Also get our XP boosts local to this city.
				iCombatClassValue += pLoopCity->getFreeExperience();

				if(pLoopCity->getUnitCombatFreeExperience(eUnitCombatClass) > 0)
				{
					iCombatClassValue += max(1, pLoopCity->getUnitCombatFreeExperience(eUnitCombatClass));
				}
				if(pLoopCity->getUnitCombatProductionModifier(eUnitCombatClass) > 0)
				{
					iCombatClassValue += max(1, pLoopCity->getUnitCombatProductionModifier(eUnitCombatClass));
				}

				//Promotion Bonus
				vector<PromotionTypes> freePromotions = pLoopCity->getFreePromotions();
				for (size_t iI = 0; iI < freePromotions.size(); iI++)
				{
					CvPromotionEntry* pkPromotionInfo = GC.getPromotionInfo(freePromotions[iI]);
					if(pkPromotionInfo)
					{
						if(pkPromotionInfo->GetUnitCombatClass(eUnitCombatClass))
						{
							iCombatClassValue += 50;
						}
					}
				}
				if(iCombatClassValue > iBestCombatClassValue)
				{
					iBestCombatClassValue = iCombatClassValue;
					pBestCombatClassCity = pLoopCity;
				}
			}
			if(pBestCombatClassCity != NULL && pBestCombatClassCity != GetBestMilitaryCity(eUnitCombatClass, NO_DOMAIN))
			{
				SetBestMilitaryCityCombatClass(pBestCombatClassCity->GetID(), eUnitCombatClass);
				if(GC.getLogging() && GC.getAILogging())
				{
					CvString strCity = pBestCombatClassCity->getName();
					CvString strLogString;
					strLogString.Format("***************** New Military Combat Class City Chosen for class %d: %s. ****************", eUnitCombatClass, strCity.c_str());
					GetHomelandAI()->LogHomelandMessage(strLogString);
				}
			}
		}
	}

	//Domain Value - let's get the city with the higher # of domain bonuses, and make it our best domain city.
	for (int iDomainLoop = 0; iDomainLoop < NUM_DOMAIN_TYPES; iDomainLoop++)
	{
		int iBestDomainValue = 0;
		DomainTypes eTestDomain = (DomainTypes)iDomainLoop;
		if (eTestDomain != NO_DOMAIN)
		{
			CvCity* pBestDomainCity = NULL;
			for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				//Production is king, and also our base value.
				int iDomainValue = (pLoopCity->getYieldRate(YIELD_PRODUCTION, false) / 5);

				//Also get our XP boosts local to this city.
				iDomainValue += pLoopCity->getFreeExperience();

				if (pLoopCity->getDomainFreeExperience(eTestDomain) > 0)
				{
					iDomainValue += max(1, pLoopCity->getDomainFreeExperience(eTestDomain));
				}
				if (pLoopCity->getDomainFreeExperienceFromGreatWorks(eTestDomain) > 0)
				{
					iDomainValue += max(1, pLoopCity->getDomainFreeExperienceFromGreatWorks(eTestDomain));
				}
				if (pLoopCity->getDomainFreeExperienceFromGreatWorksGlobal(eTestDomain) > 0)
				{
					iDomainValue += max(1, pLoopCity->getDomainFreeExperienceFromGreatWorksGlobal(eTestDomain));
				}
				if (pLoopCity->getDomainProductionModifier(eTestDomain) > 0)
				{
					iDomainValue += max(1, pLoopCity->getDomainProductionModifier(eTestDomain));
				}

				//Let's try to synergize our domain and combat class productions in the same cities.
				for (int iI = 0; iI < GC.getNumUnitCombatClassInfos(); iI++)
				{
					const UnitCombatTypes eUnitCombatClass = static_cast<UnitCombatTypes>(iI);
					CvBaseInfo* pkUnitCombatClassInfo = GC.getUnitCombatClassInfo(eUnitCombatClass);
					if (pkUnitCombatClassInfo)
					{
						if (GetBestMilitaryCity(eUnitCombatClass, NO_DOMAIN) == pLoopCity)
						{
							iDomainValue *= 2;
						}
					}
				}
				if (iDomainValue > iBestDomainValue)
				{
					iBestDomainValue = iDomainValue;
					pBestDomainCity = pLoopCity;
				}
			}
			if (pBestDomainCity != NULL && pBestDomainCity != GetBestMilitaryCity(NO_UNITCOMBAT, eTestDomain))
			{
				if (GC.getLogging() && GC.getAILogging())
				{
					CvString strCity = pBestDomainCity->getName();
					CvString strLogString;
					strLogString.Format("***************** New Military Domain City Chosen for domain %d: %s. ****************", eTestDomain, strCity.c_str());
					GetHomelandAI()->LogHomelandMessage(strLogString);
				}
				SetBestMilitaryCityDomain(pBestDomainCity->GetID(), eTestDomain);
			}
		}
	}
}
void CvPlayer::SetBestMilitaryCityDomain(int iValue, DomainTypes eDomain)
{
	VALIDATE_OBJECT
	CvAssertMsg(eDomain >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eDomain < NUM_DOMAIN_TYPES, "eIndex1 is expected to be within maximum bounds (invalid Index)");
	m_aiBestMilitaryDomainCity[eDomain] = iValue;
}
void CvPlayer::SetBestMilitaryCityCombatClass(int iValue, UnitCombatTypes eUnitCombat)
{
	VALIDATE_OBJECT
	CvAssertMsg(eUnitCombat >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eUnitCombat < GC.getNumUnitCombatClassInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	m_aiBestMilitaryCombatClassCity[eUnitCombat] = iValue;
}
CvCity* CvPlayer::GetBestMilitaryCity(UnitCombatTypes eUnitCombat, DomainTypes eDomain)
{
	if(eUnitCombat != NO_UNITCOMBAT)
	{
		return getCity(m_aiBestMilitaryCombatClassCity[eUnitCombat]);
	}
	else if(eDomain != NO_DOMAIN)
	{
		return getCity(m_aiBestMilitaryDomainCity[eDomain]);
	}
	else
	{
		return NULL;
	}
}
#endif
#if defined(MOD_BALANCE_CORE_EVENTS)
int CvPlayer::GetEventChoiceDuration(EventChoiceTypes eEventChoice) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEventChoice >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEventChoice < GC.getNumEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	return m_aiEventChoiceDuration[eEventChoice];
}
void CvPlayer::ChangeEventChoiceDuration(EventChoiceTypes eEventChoice,int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEventChoice >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEventChoice < GC.getNumEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	if(iValue != 0)
	{
		m_aiEventChoiceDuration[eEventChoice] = m_aiEventChoiceDuration[eEventChoice] + iValue;
	}
}
void CvPlayer::SetEventChoiceDuration(EventChoiceTypes eEventChoice,int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEventChoice >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEventChoice < GC.getNumEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	m_aiEventChoiceDuration[eEventChoice] = iValue;
}
int CvPlayer::GetEventIncrement(EventTypes eEvent) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	return m_aiEventIncrement[eEvent];
}
void CvPlayer::IncrementEvent(EventTypes eEvent, int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	if(iValue != 0)
	{
		m_aiEventIncrement[eEvent] = m_aiEventIncrement[eEvent] + iValue;
	}
}
int CvPlayer::GetPlayerEventCooldown() const
{
	VALIDATE_OBJECT
	return m_iPlayerEventCooldown;
}
void CvPlayer::ChangePlayerEventCooldown(int iValue)
{
	VALIDATE_OBJECT
	if(iValue != 0)
	{
		m_iPlayerEventCooldown += iValue;
	}
}
int CvPlayer::GetEventCooldown(EventTypes eEvent) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	return m_aiEventCooldown[eEvent];
}
void CvPlayer::ChangeEventCooldown(EventTypes eEvent,int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	if(iValue != 0)
	{
		m_aiEventCooldown[eEvent] = m_aiEventCooldown[eEvent] + iValue;
	}
}
void CvPlayer::SetEventCooldown(EventTypes eEvent,int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	m_aiEventCooldown[eEvent] = iValue;
}

void CvPlayer::SetEventActive(EventTypes eEvent, bool bValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	m_abEventActive[eEvent] = bValue;
}
bool CvPlayer::IsEventActive(EventTypes eEvent) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	return m_abEventActive[eEvent];
}
void CvPlayer::SetEventChoiceActive(EventChoiceTypes eEventChoice, bool bValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEventChoice >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEventChoice < GC.getNumEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	m_abEventChoiceActive[eEventChoice] = bValue;
}
bool CvPlayer::IsEventChoiceActive(EventChoiceTypes eEventChoice) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEventChoice >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEventChoice < GC.getNumEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	return m_abEventChoiceActive[eEventChoice];
}
void CvPlayer::SetEventChoiceFired(EventChoiceTypes eEvent, bool bValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	m_abEventChoiceFired[eEvent] = bValue;
}
bool CvPlayer::IsEventChoiceFired(EventChoiceTypes eEvent) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	return m_abEventChoiceFired[eEvent];
}
void CvPlayer::SetEventFired(EventTypes eEvent, bool bValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	m_abEventFired[eEvent] = bValue;
}
bool CvPlayer::IsEventFired(EventTypes eEvent) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	return m_abEventFired[eEvent];
}
void CvPlayer::DoEvents()
{
	//Minors? Barbs? Get out!
	if(isMinorCiv() || isBarbarian())
		return;

	//Event Choice Duration First - if we're in one, let's do the countdown now.
	//We need to do this first so we can cancel the event(s).
	
	for (int iLoop = 0; iLoop < GC.getNumEventChoiceInfos(); iLoop++)
	{
		EventChoiceTypes eEventChoice = (EventChoiceTypes)iLoop;
		if (eEventChoice != NO_EVENT_CHOICE)
		{
			if (GetEventChoiceDuration(eEventChoice) > 0)
			{
				ChangeEventChoiceDuration(eEventChoice, -1);
				if (GC.getLogging())
				{
					CvModEventChoiceInfo* pkEventInfo = GC.getEventChoiceInfo(eEventChoice);
					if (pkEventInfo != NULL)
					{
						CvString playerName;
						FILogFile* pLog;
						CvString strBaseString;
						CvString strOutBuf;
						CvString strFileName = "EventLogging.csv";
						playerName = getCivilizationShortDescription();
						pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
						strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
						strBaseString += playerName + ", ";
						strOutBuf.Format("Event Choice Cooldown: %s Changing Value by -1. Cooldown Remaining: %d", pkEventInfo->GetDescription(), GetEventChoiceDuration(eEventChoice));
						strBaseString += strOutBuf;
						pLog->Msg(strBaseString);
					}
				}
				if (GetEventChoiceDuration(eEventChoice) == 0)
				{
					DoCancelEventChoice(eEventChoice);
				}
			}
		}
	}

	if (GetPlayerEventCooldown() > 0)
	{
		if (GC.getLogging())
		{
			CvString playerName;
			FILogFile* pLog;
			CvString strBaseString;
			CvString strOutBuf;
			CvString strFileName = "EventLogging.csv";
			playerName = getCivilizationShortDescription();
			pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			strBaseString += playerName + ", ";
			strOutBuf.Format("Player Event: Global Cooldown Active. Cooldown: %d", GetPlayerEventCooldown());
			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}
		ChangePlayerEventCooldown(-1);
	}

	//Let's loop through all events.
	CvWeightedVector<int> veValidEvents;

	for(int iLoop = 0; iLoop < GC.getNumEventInfos(); iLoop++)
	{
		EventTypes eEvent = (EventTypes)iLoop;
		if (eEvent != NO_EVENT)
		{
			CvModEventInfo* pkEventInfo = GC.getEventInfo(eEvent);
			if (pkEventInfo == NULL)
			{
				continue;
			}

			if (pkEventInfo->getRandomChance() == -1)
				continue;

			if (pkEventInfo->isOneShot() && IsEventFired(eEvent))
				continue;

			//Lua Hook
			if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_EventCanTake, GetID(), eEvent) == GAMEEVENTRETURN_FALSE)
			{
				continue;
			}

			//Global Cooldown Second - if we've had this event recently, let's check this.
			if (GetEventCooldown(eEvent) > 0)
			{
				if (GC.getLogging())
				{
					CvModEventInfo* pkEventInfo = GC.getEventInfo(eEvent);
					if (pkEventInfo != NULL)
					{
						CvString playerName;
						FILogFile* pLog;
						CvString strBaseString;
						CvString strOutBuf;
						CvString strFileName = "EventLogging.csv";
						playerName = getCivilizationShortDescription();
						pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
						strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
						strBaseString += playerName + ", ";
						strOutBuf.Format("Player Event: %s. Cooldown Active. Cooldown: %d", pkEventInfo->GetDescription(), GetEventCooldown(eEvent));
						strBaseString += strOutBuf;
						pLog->Msg(strBaseString);
					}
				}
				ChangeEventCooldown(eEvent, -1);
				continue;
			}

			if (GetPlayerEventCooldown() > 0 && !pkEventInfo->IgnoresGlobalCooldown())
			{
				continue;
			}

			//most expensive check last
			if (IsEventValid(eEvent))
			{
				veValidEvents.push_back(eEvent, (pkEventInfo->getRandomChance() + GetEventIncrement(eEvent)));
			}
		}
	}

	EventTypes eChosenEvent = NO_EVENT;

	if (veValidEvents.size() > 0)
	{
		//afw		veValidEvents.SortItems();
		int iRandIndex = GC.getGame().getSmallFakeRandNum(2000, GetTreasury()->GetLifetimeGrossGold()); //afw
		if (GC.getLogging())
		{
			CvString strBaseString;
			CvString strOutBuf;
			CvString strFileName = "EventLogging.csv";
			CvString playerName = getCivilizationShortDescription();
			FILogFile* pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			strBaseString += playerName + ", ";
			strOutBuf.Format("Found %d Events for seeding. Random=%d", veValidEvents.size(), iRandIndex);
			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}

		//afw		int iRandIndex = GC.getGame().getJonRandNum(1000, "Picking random event for player.");

		//which one is it?
		int iWeight = 0;
		for (int iLoop = 0; iLoop < veValidEvents.size(); iLoop++)
		{
			EventTypes eEvent = (EventTypes)veValidEvents.GetElement(iLoop);
			CvModEventInfo* pkEventInfo = GC.getEventInfo(eEvent);
			if (!pkEventInfo)
				continue;

			//afw			iWeight = veValidEvents.GetWeight(iLoop);
			iWeight += veValidEvents.GetWeight(iLoop); //afw
			if (iRandIndex < iWeight)
			{
				eChosenEvent = eEvent;
				break;
			}
		}

		if (eChosenEvent != NO_EVENT)
		{
			CvModEventInfo* pkEventInfo = GC.getEventInfo(eChosenEvent);
			if (pkEventInfo != NULL)
			{
				for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
				{
					PlayerTypes ePlayer = (PlayerTypes)iPlayerLoop;
					if (ePlayer != NO_PLAYER && GET_PLAYER(ePlayer).isAlive())
					{
						//Not global?
						if (!pkEventInfo->isGlobal() && ePlayer != GetID())
							continue;

						GET_PLAYER(ePlayer).DoStartEvent(eChosenEvent);

						GET_PLAYER(ePlayer).ChangePlayerEventCooldown(/*10*/ GD_INT_GET(EVENT_MIN_DURATION_BETWEEN));

						//reset probability
						IncrementEvent(eChosenEvent, -GetEventIncrement(eChosenEvent));
						if (GC.getLogging())
						{
							CvString strBaseString;
							CvString strOutBuf;
							CvString strFileName = "EventLogging.csv";
							CvString playerName = getCivilizationShortDescription();
							FILogFile* pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
							strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
							strBaseString += playerName + ", ";
							strOutBuf.Format("Resetting event chance for: %s", pkEventInfo->GetDescription());
							strBaseString += strOutBuf;
							pLog->Msg(strBaseString);
						}
					}
				}
			}
		}
	}

	for (int iLoop = 0; iLoop < veValidEvents.size(); iLoop++)
	{
		EventTypes eEvent = (EventTypes)veValidEvents.GetElement(iLoop);
		if (eEvent != NO_EVENT)
		{
			CvModEventInfo* pkEventInfo = GC.getEventInfo(eEvent);
			if (!pkEventInfo)
				continue;

			//But not for the one we just did!
			if (eChosenEvent == eEvent)
				continue;

			//make it more likely
			if (pkEventInfo->getRandomChanceDelta() > 0)
			{
				IncrementEvent(eEvent, pkEventInfo->getRandomChanceDelta());
				if (GC.getLogging())
				{
					CvString strBaseString;
					CvString strOutBuf;
					CvString strFileName = "EventLogging.csv";
					CvString playerName = getCivilizationShortDescription();
					FILogFile* pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
					strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
					strBaseString += playerName + ", ";
					strOutBuf.Format("Incrementing event chance for: %s, Increment: %d", pkEventInfo->GetDescription(), GetEventIncrement(eEvent));
					strBaseString += strOutBuf;
					pLog->Msg(strBaseString);
				}
			}
		}
	}
}

bool CvPlayer::IsEventValid(EventTypes eEvent)
{
	CvModEventInfo* pkEventInfo = GC.getEventInfo(eEvent);
	if(pkEventInfo == NULL)
	{
		return false;
	}

	//Lua Hook
	if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_EventCanActivate, GetID(), eEvent) == GAMEEVENTRETURN_FALSE) 
	{
		return false;
	}

	EventClassTypes eEventClass = (EventClassTypes)pkEventInfo->getEventClass();
	if (eEventClass != NO_EVENT_CLASS)
	{
		if (eEventClass == EVENT_CLASS_GOOD)
		{
			if (GC.getGame().isOption(GAMEOPTION_GOOD_EVENTS_OFF))
				return false;
		}
		else if (eEventClass == EVENT_CLASS_BAD)
		{
			if (GC.getGame().isOption(GAMEOPTION_BAD_EVENTS_OFF))
				return false;
		}
		else if (eEventClass == EVENT_CLASS_NEUTRAL)
		{
			if (GC.getGame().isOption(GAMEOPTION_NEUTRAL_EVENTS_OFF))
				return false;
		}
		else if (eEventClass == EVENT_CLASS_TRADE)
		{
			if (GC.getGame().isOption(GAMEOPTION_TRADE_EVENTS_OFF))
				return false;
		}
		else if (eEventClass == EVENT_CLASS_CIV_SPECIFIC)
		{
			if (GC.getGame().isOption(GAMEOPTION_CIV_SPECIFIC_EVENTS_OFF))
				return false;
		}
	}

	if(pkEventInfo->getPrereqTech() != -1 && !GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
		return false;

	if(pkEventInfo->getObsoleteTech() != -1 && GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getObsoleteTech()))
		return false;

	if(pkEventInfo->getRequiredEra() != -1 && GetCurrentEra() < (EraTypes)pkEventInfo->getRequiredEra())
		return false;

	if(pkEventInfo->getObsoleteEra() != -1 && GetCurrentEra() >= (EraTypes)pkEventInfo->getObsoleteEra())
		return false;

	if(pkEventInfo->getMinimumNationalPopulation() > 0 && getTotalPopulation() < pkEventInfo->getMinimumNationalPopulation())
		return false;

	if(pkEventInfo->getMinimumNumberCities() > 0 && getNumCities() < pkEventInfo->getMinimumNumberCities())
		return false;

	if(pkEventInfo->getRequiredCiv() != -1 && getCivilizationType() != (CivilizationTypes)pkEventInfo->getRequiredCiv())
		return false;

	if(pkEventInfo->getRequiredPolicy() != -1 && !GetPlayerPolicies()->HasPolicy((PolicyTypes)pkEventInfo->getRequiredPolicy()))
		return false;

	if(pkEventInfo->getRequiredIdeology() != -1 && GetPlayerPolicies()->GetLateGamePolicyTree() != (PolicyBranchTypes)pkEventInfo->getRequiredIdeology())
		return false;

	if(pkEventInfo->hasStateReligion() && GetReligions()->GetStateReligion(false) == NO_RELIGION)
		return false;

	if(pkEventInfo->hasPantheon() && (GetReligions()->GetOwnedReligion() != NO_RELIGION || GetReligions()->GetReligionCreatedByPlayer(true) != RELIGION_PANTHEON))
		return false;

	if (pkEventInfo->isUnhappy() && !IsEmpireUnhappy())
		return false;

	if(pkEventInfo->isSuperUnhappy() && !IsEmpireSuperUnhappy())
		return false;

	if(pkEventInfo->isRequiresIdeology() && GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
		return false;

	if(pkEventInfo->isRequiresWar() && GetMilitaryAI()->GetNumberCivsAtWarWith(false) <= 0)
		return false;

	//Let's do our linker checks here.
	for(int iI = 0; iI <= pkEventInfo->GetNumLinkers(); iI++)
	{
		CvEventLinkingInfo *pLinkerInfo = pkEventInfo->GetLinkerInfo(iI);
		if(pLinkerInfo)
		{
			EventTypes eLinkerEvent = (EventTypes)pLinkerInfo->GetLinkingEvent();
			EventChoiceTypes eLinkerEventChoice = (EventChoiceTypes)pLinkerInfo->GetLinkingEventChoice();
			CityEventTypes eLinkerCityEvent = (CityEventTypes)pLinkerInfo->GetCityLinkingEvent();
			CityEventChoiceTypes eLinkerCityEventChoice = (CityEventChoiceTypes)pLinkerInfo->GetCityLinkingEventChoice();

			PlayerTypes ePlayer;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				ePlayer = (PlayerTypes) iPlayerLoop;
				if(ePlayer == NO_PLAYER)
					continue;

				CvPlayer &kPlayer2 = GET_PLAYER(ePlayer);

				if(!pLinkerInfo->CheckOtherPlayers() && ePlayer != GetID())
					continue;

				if(eLinkerEvent != NO_EVENT)
				{
					bool bActive = (kPlayer2.GetEventCooldown(eLinkerEvent) > 0 || kPlayer2.IsEventFired(eLinkerEvent));
					if(bActive != pLinkerInfo->CheckForActive())
						return false;
				}

				if(eLinkerEventChoice != NO_EVENT_CHOICE)
				{
					bool bActive = (kPlayer2.GetEventChoiceDuration(eLinkerEventChoice) > 0 || kPlayer2.IsEventChoiceFired(eLinkerEventChoice));
					if(bActive != pLinkerInfo->CheckForActive())
						return false;
				}

				if(eLinkerCityEvent != NO_EVENT_CITY || eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
				{
					int iLoop;
					for(CvCity* pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))
					{
						if(eLinkerCityEvent != NO_EVENT_CITY)
						{
							bool bActive = (pLoopCity->GetEventCooldown(eLinkerCityEvent) > 0 || pLoopCity->IsEventFired(eLinkerCityEvent));
							if(bActive != pLinkerInfo->CheckForActive())
								return false;
						}

						if(eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
						{
							bool bActive = (pLoopCity->GetEventChoiceDuration(eLinkerCityEventChoice) > 0 || pLoopCity->IsEventChoiceFired(eLinkerCityEventChoice));
							if(bActive != pLinkerInfo->CheckForActive())
								return false;
						}
					}
				}
			}
		}
	}

	if (pkEventInfo->getRequiredStateReligion() != -1)
	{
		if (GetReligions()->GetOwnedReligion() != pkEventInfo->getRequiredStateReligion())
			return false;
	}

	if (!pkEventInfo->isRequiresHolyCity() && pkEventInfo->getRequiredReligion() != -1)
	{
		if (GetReligions()->GetStateReligion(false) != (ReligionTypes)pkEventInfo->getRequiredReligion())
			return false;
	}

	if(pkEventInfo->hasMetAnotherCiv())
	{
		if(GET_TEAM(getTeam()).getHasMetCivCount(true) <= 0)
			return false;
	}

	if (pkEventInfo->isMaster() && GetNumVassals() <= 0)
		return false;

	if (pkEventInfo->isVassal() && !IsVassalOfSomeone())
		return false;

	if (pkEventInfo->isTradeCapped() && GetTrade()->GetNumTradeUnitsRemaining(true) <= 0)
		return false;


	if(pkEventInfo->getUnitTypeRequired() != -1)
	{
		bool bHas = false;
		CvUnit* pLoopUnit;
		int iLoop;
		for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		{
			if(pLoopUnit != NULL && pLoopUnit->getUnitClassType() == (UnitClassTypes)pkEventInfo->getUnitTypeRequired())
			{
				bHas = true;
				break;
			}
		}
		if(!bHas)
		{
			return false;
		}
	}

	if(pkEventInfo->isRequiresHolyCity())
	{
		bool bHas = false;
		CvCity* pCity = NULL;
		int iLoop;
		for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
		{
			if(pkEventInfo->getRequiredReligion() != -1)
			{
				if(pCity != NULL && pCity->GetCityReligions()->IsHolyCityForReligion((ReligionTypes)pkEventInfo->getRequiredReligion()))
				{
					bHas = true;
					break;
				}
			}
			else
			{
				if(pCity != NULL && pCity->GetCityReligions()->IsHolyCityAnyReligion())
				{
					bHas = true;
					break;
				}
			}
		}
		if(!bHas)
		{
			return false;
		}
	}
	if(pkEventInfo->getNumCoastalRequired() > 0)
	{
		bool bHas = false;
		CvCity* pCity = NULL;
		int iLoop;
		int iNumCoastal = 0;
		for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
		{
			if(pCity != NULL && pCity->isCoastal())
			{
				iNumCoastal++;
			}
			if(iNumCoastal >= pkEventInfo->getNumCoastalRequired())
			{
				bHas = true;
				break;
			}
		}
		if(!bHas)
		{
			return false;
		}
	}

	if(pkEventInfo->isRequiresWarMinor())
	{
		bool bHas = false;
		for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			// Is this a player we have relations with?
			if(GET_PLAYER(eLoopPlayer).isBarbarian())
			{
				continue;
			}
			if(!GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				continue;
			}
			if(eLoopPlayer != GetID())
			{
				if(GET_TEAM(getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
				{
					bHas = true;
					break;
				}
			}
		}
		if(!bHas)
		{
			return false;
		}
	}
	bool bHas = true;
	for(int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
	{
		const ResourceTypes eResource = static_cast<ResourceTypes>(iJ);
		CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
		if(pkResource)
		{
			if(pkEventInfo->getResourceRequired(eResource) > 0)
			{
				if(getNumResourceTotal(eResource, false) < pkEventInfo->getResourceRequired(eResource))
				{
					bHas = false;
					break;
				}
			}
		}
	}
	if(!bHas)
	{
		return false;
	}
	for(int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
	{
		const FeatureTypes eFeature = static_cast<FeatureTypes>(iJ);
		CvFeatureInfo* pkFeature = GC.getFeatureInfo(eFeature);
		if(pkFeature)
		{
			if(pkEventInfo->getFeatureRequired(eFeature) > 0)
			{
				bool bHas = false;
				CvCity* pCity = NULL;
				int iLoop;
				int iNeeded = pkEventInfo->getFeatureRequired(eFeature);
				int iHave = 0;
				for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
				{

					if(pCity != NULL && pCity->HasFeature(eFeature))
					{
						iHave++;
					}
					if(iHave >= iNeeded)
					{
						bHas = true;
						break;
					}
				}
				if(!bHas)
				{
					return false;
				}
			}
		}
	}

	if(pkEventInfo->getBuildingRequired() != -1)
	{
		BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventInfo->getBuildingRequired();
		if(eBuildingClass != NO_BUILDINGCLASS)
		{
			bool bHas = false;
			CvCity* pCity = NULL;
			int iLoop;
			for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
			{
				if(pCity != NULL && pCity->GetCityBuildings()->GetNumBuildingClass(eBuildingClass) > 0)
				{
					bHas = true;
					break;
				}
			}
			if(!bHas)
			{
				return false;
			}
		}
	}
	if(pkEventInfo->getBuildingLimiter() != -1)
	{
		BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventInfo->getBuildingLimiter();
		if(eBuildingClass != NO_BUILDINGCLASS)
		{
			bool bHas = false;
			CvCity* pCity = NULL;
			int iLoop;
			for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
			{
				if(pCity != NULL && pCity->GetCityBuildings()->GetNumBuildingClass(eBuildingClass) > 0)
				{
					bHas = true;
					break;
				}
			}
			if(bHas)
			{
				return false;
			}
		}
	}
	if(pkEventInfo->getRequiredImprovement() != -1)
	{
		ImprovementTypes eImprovement = (ImprovementTypes)pkEventInfo->getRequiredImprovement();
		if(eImprovement != NO_IMPROVEMENT)
		{
			bool bHas = false;
			CvPlot* pLoopPlot;
			int iNumPlotsInEntireWorld = GC.getMap().numPlots();
			for(int iI = 0; iI < iNumPlotsInEntireWorld; iI++)
			{
				pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

				if(pLoopPlot == NULL)
					return false;

				if(pLoopPlot->getOwner() == GetID() && pLoopPlot->getImprovementType() == eImprovement)
				{
					bHas = true;
					break;
				}
			}
			if(!bHas)
			{
				return false;
			}
		}
	}
	//Check our minimum yields - this looks at stored values, not yields per turn.
	bHas = true;
	for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes)iI;
		if(eYield == NO_YIELD)
			return false;
							
		int iNeededYield = pkEventInfo->getYieldMinimum(eYield);
		iNeededYield *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
		iNeededYield /= 100;
		if(pkEventInfo->isEraScaling())
		{
			int iEra = GetCurrentEra();
			if(iEra <= 0)
			{
				iEra = 1;
			}
			iNeededYield *= iEra;
		}
		if(iNeededYield != 0)
		{
			if(eYield == YIELD_GOLD)
			{
				if(iNeededYield > GetTreasury()->GetGold())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_SCIENCE)
			{
				TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
				int iTech = 0;
				if(eCurrentTech != NO_TECH)
				{
					iTech = GetPlayerTechs()->GetResearchProgress(eCurrentTech);
				}
				if(iNeededYield > iTech)
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_FAITH)
			{
				if(iNeededYield > GetFaith())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_GOLDEN_AGE_POINTS)
			{
				if(iNeededYield > GetGoldenAgeProgressMeter())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_CULTURE)
			{
				if(iNeededYield > getJONSCulture())
				{
					bHas = false;
					break;
				}
			}
		}
	}
	if(!bHas)
	{
		return false;
	}

	if(pkEventInfo->isInDebt() && GetTreasury()->GetGold() > 0)
		return false;

	if(pkEventInfo->isLosingMoney() && GetTreasury()->CalculateBaseNetGold() > 0)
		return false;

	return true;
}
bool CvPlayer::IsEventChoiceValid(EventChoiceTypes eChosenEventChoice, EventTypes eParentEvent)
{
	if(eChosenEventChoice == NO_EVENT_CHOICE)
		return false;

	CvModEventChoiceInfo* pkEventInfo = GC.getEventChoiceInfo(eChosenEventChoice);
	if(pkEventInfo == NULL)
	{
		return false;
	}

	if (!pkEventInfo->isParentEvent(eParentEvent))
		return false;

	if (!IsEventActive(eParentEvent))
		return false;

	//Lua Hook
	if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_EventChoiceCanTake, GetID(), eChosenEventChoice) == GAMEEVENTRETURN_FALSE) {
		return false;
	}

	if(pkEventInfo->isOneShot() && IsEventChoiceFired(eChosenEventChoice))
		return false;

	//Event Choice already active for this event? Abort!
	if(GetEventChoiceDuration(eChosenEventChoice) > 0)
	{
		if(GC.getLogging())
		{
			CvString playerName;
			FILogFile* pLog;
			CvString strBaseString;
			CvString strOutBuf;
			CvString strFileName = "EventLogging.csv";
			playerName = getCivilizationShortDescription();
			pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			strBaseString += playerName + ", ";
			strOutBuf.Format("Event choice already active for player, skipping: %s, Event: %s. Cooldown: %d", pkEventInfo->GetDescription(), pkEventInfo->GetDescription(), GetEventChoiceDuration(eChosenEventChoice));
			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}
		return false;
	}

	//Let's narrow down all events here!
	if(pkEventInfo->getPrereqTech() != -1 && !GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
		return false;

	if(pkEventInfo->getObsoleteTech() != -1 && GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getObsoleteTech()))
		return false;

	if(pkEventInfo->getRequiredEra() != -1 && GetCurrentEra() < (EraTypes)pkEventInfo->getRequiredEra())
		return false;

	if(pkEventInfo->getObsoleteEra() != -1 && GetCurrentEra() >= (EraTypes)pkEventInfo->getObsoleteEra())
		return false;

	if(pkEventInfo->getMinimumNationalPopulation() > 0 && getTotalPopulation() < pkEventInfo->getMinimumNationalPopulation())
		return false;

	if(pkEventInfo->getMinimumNumberCities() > 0 && getNumCities() < pkEventInfo->getMinimumNumberCities())
		return false;

	if(pkEventInfo->getRequiredCiv() != -1 && getCivilizationType() != (CivilizationTypes)pkEventInfo->getRequiredCiv())
		return false;

	if(pkEventInfo->getRequiredPolicy() != -1 && !GetPlayerPolicies()->HasPolicy((PolicyTypes)pkEventInfo->getRequiredPolicy()))
		return false;

	if(pkEventInfo->getRequiredIdeology() != -1 && GetPlayerPolicies()->GetLateGamePolicyTree() != (PolicyBranchTypes)pkEventInfo->getRequiredIdeology())
		return false;

	if(pkEventInfo->hasStateReligion() && GetReligions()->GetStateReligion(false) == NO_RELIGION)
		return false;

	if(pkEventInfo->hasPantheon() && (GetReligions()->GetOwnedReligion() != NO_RELIGION || GetReligions()->GetReligionCreatedByPlayer(true) != RELIGION_PANTHEON))
		return false;

	if(pkEventInfo->isUnhappy() && !IsEmpireUnhappy())
		return false;

	if(pkEventInfo->isSuperUnhappy() && !IsEmpireSuperUnhappy())
		return false;

	if(pkEventInfo->isRequiresIdeology() && GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
		return false;

	if(pkEventInfo->isRequiresWar() && GetMilitaryAI()->GetNumberCivsAtWarWith(false) <= 0)
		return false;

	if (pkEventInfo->getRequiredStateReligion() != -1)
	{
		if (GetReligions()->GetOwnedReligion() != pkEventInfo->getRequiredStateReligion())
			return false;
	}

	if (!pkEventInfo->isRequiresHolyCity() && pkEventInfo->getRequiredReligion() != -1)
	{
		if (GetReligions()->GetStateReligion(false) != (ReligionTypes)pkEventInfo->getRequiredReligion())
			return false;
	}

	//Let's do our linker checks here.
	for(int iI = 0; iI <= pkEventInfo->GetNumLinkers(); iI++)
	{
		CvEventChoiceLinkingInfo *pLinkerInfo = pkEventInfo->GetLinkerInfo(iI);
		if(pLinkerInfo)
		{
			EventTypes eLinkerEvent = (EventTypes)pLinkerInfo->GetLinkingEvent();
			EventChoiceTypes eLinkerEventChoice = (EventChoiceTypes)pLinkerInfo->GetLinkingEventChoice();
			CityEventTypes eLinkerCityEvent = (CityEventTypes)pLinkerInfo->GetCityLinkingEvent();
			CityEventChoiceTypes eLinkerCityEventChoice = (CityEventChoiceTypes)pLinkerInfo->GetCityLinkingEventChoice();

			PlayerTypes ePlayer;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				ePlayer = (PlayerTypes) iPlayerLoop;
				if(ePlayer == NO_PLAYER)
					continue;

				CvPlayer &kPlayer2 = GET_PLAYER(ePlayer);

				if(!pLinkerInfo->CheckOtherPlayers() && ePlayer != GetID())
					continue;

				if(eLinkerEvent != NO_EVENT)
				{
					bool bActive = (kPlayer2.GetEventCooldown(eLinkerEvent) > 0 || kPlayer2.IsEventFired(eLinkerEvent));
					if(bActive != pLinkerInfo->CheckForActive())
						return false;
				}

				if(eLinkerEventChoice != NO_EVENT_CHOICE)
				{
					bool bActive = (kPlayer2.GetEventChoiceDuration(eLinkerEventChoice) > 0 || kPlayer2.IsEventChoiceFired(eLinkerEventChoice));
					if(bActive != pLinkerInfo->CheckForActive())
						return false;
				}

				if(eLinkerCityEvent != NO_EVENT_CITY || eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
				{
					int iLoop;
					for(CvCity* pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))
					{
						if(eLinkerCityEvent != NO_EVENT_CITY)
						{
							bool bActive = (pLoopCity->GetEventCooldown(eLinkerCityEvent) > 0 || pLoopCity->IsEventFired(eLinkerCityEvent));
							if(bActive != pLinkerInfo->CheckForActive())
								return false;
						}

						if(eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
						{
							bool bActive = (pLoopCity->GetEventChoiceDuration(eLinkerCityEventChoice) > 0 || pLoopCity->IsEventChoiceFired(eLinkerCityEventChoice));
							if(bActive != pLinkerInfo->CheckForActive())
								return false;
						}
					}
				}
			}
		}
	}

	if(pkEventInfo->hasMetAnotherCiv())
	{
		if(GET_TEAM(getTeam()).getHasMetCivCount(true) <= 0)
			return false;
	}

	if (pkEventInfo->isMaster() && GetNumVassals() <= 0)
		return false;

	if (pkEventInfo->isVassal() && !IsVassalOfSomeone())
		return false;

	if(pkEventInfo->isTradeCapped() && GetTrade()->GetNumTradeUnitsRemaining(true) <= 0)
		return false;

	if(pkEventInfo->getUnitTypeRequired() != -1)
	{
		bool bHas = false;
		CvUnit* pLoopUnit;
		int iLoop;
		for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		{
			if(pLoopUnit != NULL && pLoopUnit->getUnitClassType() == (UnitClassTypes)pkEventInfo->getUnitTypeRequired())
			{
				bHas = true;
				break;
			}
		}
		if(!bHas)
		{
			return false;
		}
	}


	if(pkEventInfo->isRequiresHolyCity())
	{
		bool bHas = false;
		CvCity* pCity = NULL;
		int iLoop;
		for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
		{
			if(pkEventInfo->getRequiredReligion() != -1)
			{
				if(pCity != NULL && pCity->GetCityReligions()->IsHolyCityForReligion((ReligionTypes)pkEventInfo->getRequiredReligion()))
				{
					bHas = true;
					break;
				}
			}
			else
			{
				if(pCity != NULL && pCity->GetCityReligions()->IsHolyCityAnyReligion())
				{
					bHas = true;
					break;
				}
			}
		}
		if(!bHas)
		{
			return false;
		}
	}
	if(pkEventInfo->getNumCoastalRequired() > 0)
	{
		bool bHas = false;
		CvCity* pCity = NULL;
		int iLoop;
		int iNumCoastal = 0;
		for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
		{
			if(pCity != NULL && pCity->isCoastal())
			{
				iNumCoastal++;
			}
			if(iNumCoastal >= pkEventInfo->getNumCoastalRequired())
			{
				bHas = true;
				break;
			}
		}
		if(!bHas)
		{
			return false;
		}
	}

	if(pkEventInfo->isRequiresWarMinor())
	{
		bool bHas = false;
		for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			// Is this a player we have relations with?
			if(GET_PLAYER(eLoopPlayer).isBarbarian())
			{
				continue;
			}
			if(!GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				continue;
			}
			if(eLoopPlayer != GetID())
			{
				if(GET_TEAM(getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
				{
					bHas = true;
					break;
				}
			}
		}
		if(!bHas)
		{
			return false;
		}
	}
	bool bHas = true;
	for(int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
	{
		const ResourceTypes eResource = static_cast<ResourceTypes>(iJ);
		CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
		if(pkResource)
		{
			if(pkEventInfo->getResourceRequired(eResource) > 0)
			{
				if(getNumResourceTotal(eResource, false) < pkEventInfo->getResourceRequired(eResource))
				{
					bHas = false;
					break;
				}
			}
		}
	}
	if(!bHas)
	{
		return false;
	}
	for(int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
	{
		const FeatureTypes eFeature = static_cast<FeatureTypes>(iJ);
		CvFeatureInfo* pkFeature = GC.getFeatureInfo(eFeature);
		if(pkFeature)
		{
			if(pkEventInfo->getFeatureRequired(eFeature) > 0)
			{
				bool bHas = false;
				CvCity* pCity = NULL;
				int iLoop;
				int iNeeded = pkEventInfo->getFeatureRequired(eFeature);
				int iHave = 0;
				for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
				{

					if(pCity != NULL && pCity->HasFeature(eFeature))
					{
						iHave++;
					}
					if(iHave >= iNeeded)
					{
						bHas = true;
						break;
					}
				}
				if(!bHas)
				{
					return false;
				}
			}
		}
	}
	if(pkEventInfo->getBuildingRequired() != -1)
	{
		BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventInfo->getBuildingRequired();
		if(eBuildingClass != NO_BUILDINGCLASS)
		{
			bool bHas = false;
			CvCity* pCity = NULL;
			int iLoop;
			for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
			{
				if(pCity != NULL && pCity->GetCityBuildings()->GetNumBuildingClass(eBuildingClass) > 0)
				{
					bHas = true;
					break;
				}
			}
			if(!bHas)
			{
				return false;
			}
		}
	}
	if(pkEventInfo->getBuildingLimiter() != -1)
	{
		BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventInfo->getBuildingLimiter();
		if(eBuildingClass != NO_BUILDINGCLASS)
		{
			bool bHas = false;
			CvCity* pCity = NULL;
			int iLoop;
			for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
			{
				if(pCity != NULL && pCity->GetCityBuildings()->GetNumBuildingClass(eBuildingClass) > 0)
				{
					bHas = true;
					break;
				}
			}
			if(bHas)
			{
				return false;
			}
		}
	}
	if(pkEventInfo->getRequiredImprovement() != -1)
	{
		ImprovementTypes eImprovement = (ImprovementTypes)pkEventInfo->getRequiredImprovement();
		if(eImprovement != NO_IMPROVEMENT)
		{
			bool bHas = false;
			CvPlot* pLoopPlot;
			int iNumPlotsInEntireWorld = GC.getMap().numPlots();
			for(int iI = 0; iI < iNumPlotsInEntireWorld; iI++)
			{
				pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

				if(pLoopPlot == NULL)
					continue;

				if(pLoopPlot->getOwner() == GetID() && pLoopPlot->getImprovementType() == eImprovement)
				{
					bHas = true;
					break;
				}
			}
			if(!bHas)
			{
				return false;
			}
		}
	}
	//Check our minimum yields - this looks at stored values, not yields per turn.
	bHas = true;
	for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes)iI;
		if(eYield == NO_YIELD)
			continue;
							
		int iNeededYield = pkEventInfo->getYieldMinimum(eYield);
		if(pkEventInfo->getPreCheckEventYield(eYield) != 0)
		{
			if(iNeededYield < pkEventInfo->getPreCheckEventYield(eYield))
			{
				iNeededYield = pkEventInfo->getPreCheckEventYield(eYield);
			}
		}
		iNeededYield *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
		iNeededYield /= 100;
		if(pkEventInfo->IsEraScaling())
		{
			int iEra = GetCurrentEra();
			if(iEra <= 0)
			{
				iEra = 1;
			}
			iNeededYield *= iEra;
		}
		if(iNeededYield != 0)
		{
			if(eYield == YIELD_GOLD)
			{
				if(iNeededYield > GetTreasury()->GetGold())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_SCIENCE)
			{
				TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
				int iTech = 0;
				if(eCurrentTech != NO_TECH)
				{
					iTech = GetPlayerTechs()->GetResearchProgress(eCurrentTech);
				}
				if(iNeededYield > iTech)
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_FAITH)
			{
				if(iNeededYield > GetFaith())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_GOLDEN_AGE_POINTS)
			{
				if(iNeededYield > GetGoldenAgeProgressMeter())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_CULTURE)
			{
				if(iNeededYield > getJONSCulture())
				{
					bHas = false;
					break;
				}
			}
		}
	}
	if(!bHas)
	{
		return false;
	}

	if(pkEventInfo->isInDebt() && GetTreasury()->GetGold() > 0)
		return false;

	if(pkEventInfo->isLosingMoney() && GetTreasury()->CalculateBaseNetGold() > 0)
		return false;

	return true;
}
void CvPlayer::DoStartEvent(EventTypes eChosenEvent)
{
	if(eChosenEvent != NO_EVENT)
	{
		CvModEventInfo* pkEventInfo = GC.getEventInfo(eChosenEvent);
		if(pkEventInfo != NULL)
		{
			//Set true so we know we're doing an event right now.
			SetEventActive(eChosenEvent, true);
	
			//Set oneshot stuff so this event can't fire ever again.
			if(pkEventInfo->isOneShot())
			{
				SetEventFired(eChosenEvent, true);
			}

			//Lua Hook
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_EventActivated, GetID(), eChosenEvent);

			//Gamespeed.
			int iEventDuration = pkEventInfo->getCooldown();
			iEventDuration *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iEventDuration /= 100;
			ChangeEventCooldown(eChosenEvent, iEventDuration);
			if(GC.getLogging())
			{
				CvString playerName;
				FILogFile* pLog;
				CvString strBaseString;
				CvString strOutBuf;
				CvString strFileName = "EventLogging.csv";
				playerName = getCivilizationShortDescription();
				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				strBaseString += playerName + ", ";
				strOutBuf.Format("Event started for player: %s. Cooldown: %d", pkEventInfo->GetDescription(), iEventDuration);
				strBaseString += strOutBuf;
				pLog->Msg(strBaseString);
			}
			int iNumEvents = 0;
			EventChoiceTypes eEventChoice = NO_EVENT_CHOICE;
			for(int iLoop = 0; iLoop < GC.getNumEventChoiceInfos(); iLoop++)
			{
				eEventChoice = (EventChoiceTypes)iLoop;
				if(eEventChoice != NO_EVENT_CHOICE)
				{
					CvModEventChoiceInfo* pkEventChoiceInfo = GC.getEventChoiceInfo(eEventChoice);
					if(pkEventChoiceInfo != NULL)
					{
						if(IsEventChoiceValid(eEventChoice, eChosenEvent))
						{
							iNumEvents++;
							if(pkEventInfo->getNumChoices() == 1)
							{
								DoEventChoice(eEventChoice, eChosenEvent);
								if(isHuman())
								{
									CvPopupInfo kPopupInfo(BUTTONPOPUP_MODDER_9, eEventChoice, GetID());
									GC.GetEngineUserInterface()->AddPopup(kPopupInfo);
								}
								return;
							}
						}
					}
				}
			}
			if(iNumEvents > 0 && pkEventInfo->getNumChoices() > 1)
			{
				if(isHuman())
				{
					CvNotifications* pNotifications = GetNotifications();
					if(pNotifications)
					{
						CvString strBuffer = GetLocalizedText("TXT_KEY_CHOOSE_EVENT_CHOICE");
						CvString strSummary = GetLocalizedText("TXT_KEY_CHOOSE_EVENT_CHOICE_TT");
						pNotifications->Add((NotificationTypes)FString::Hash("NOTIFICATION_EVENT_CHOICE"), strSummary.c_str(), strBuffer.c_str(), -1, -1, eChosenEvent);
					}
				}
				else
				{
					//Lua Hook
					if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_OverrideAIEvent, GetID(), eChosenEvent) == GAMEEVENTRETURN_TRUE) 
					{
						return;
					}

					AI_DoEventChoice(eChosenEvent);
				}
			}
		}
	}
}
void CvPlayer::DoCancelEventChoice(EventChoiceTypes eChosenEventChoice)
{
	if(eChosenEventChoice == NO_EVENT_CHOICE)
		return;

	CvModEventChoiceInfo* pkEventChoiceInfo = GC.getEventChoiceInfo(eChosenEventChoice);
	if(pkEventChoiceInfo != NULL)
	{
		//Lua Hook
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_EventChoiceEnded, GetID(), eChosenEventChoice);

		bool bChanged = false;
		if(GC.getLogging())
		{
			CvString playerName;
			FILogFile* pLog;
			CvString strBaseString;
			CvString strOutBuf;
			CvString strFileName = "EventLogging.csv";
			playerName = getCivilizationShortDescription();
			pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			strBaseString += playerName + ", ";
			strOutBuf.Format("Event choice ended for player: %s", pkEventChoiceInfo->GetDescription());
			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}
		//Let's make sure this is at zero.
		ChangeEventChoiceDuration(eChosenEventChoice, -GetEventChoiceDuration(eChosenEventChoice));
					
		//Let's only deduct if we actually started this event and it expires.
		if(IsEventChoiceActive(eChosenEventChoice) && pkEventChoiceInfo->Expires())
		{
			if(pkEventChoiceInfo->getEventPolicy() != -1)
			{
				PolicyTypes ePolicy = (PolicyTypes)pkEventChoiceInfo->getEventPolicy();
				if(ePolicy != -1)
				{
					setHasPolicy(ePolicy, false, true);
					bChanged = true;
				}
			}
			if(pkEventChoiceInfo->getEventTech() != -1)
			{
				TechTypes eTech = (TechTypes)pkEventChoiceInfo->getEventTech();
				if(eTech != -1)
				{
					GET_TEAM(getTeam()).GetTeamTechs()->SetHasTech(eTech, false);
				}
			}
			if(pkEventChoiceInfo->getEventBuilding() != -1)
			{
				BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventChoiceInfo->getEventBuilding();
				if(eBuildingClass != -1)
				{
					const CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
	
					if (pkBuildingClassInfo)
					{
						CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
		
						if (pCivilizationInfo != NULL)
						{
							BuildingTypes eBuildingType = NO_BUILDING;
							bool bRome = GetPlayerTraits()->IsKeepConqueredBuildings();
							if (!MOD_BUILDINGS_THOROUGH_PREREQUISITES && !bRome)
							{
								eBuildingType = (BuildingTypes)pCivilizationInfo->getCivilizationBuildings(eBuildingClass);
							}
							if (MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome || eBuildingType != NO_BUILDING)
							{
								int iLoop;
								for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
								{
									if (pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
									{
										continue;
									}
									if (pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
									{
										continue;
									}
									if (MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome || GET_PLAYER(pLoopCity->getOwner()).GetPlayerTraits()->IsKeepConqueredBuildings())
									{
										eBuildingType = pLoopCity->GetCityBuildings()->GetBuildingTypeFromClass(eBuildingClass);
										if (eBuildingType == NO_BUILDING)
										{
											continue;
										}
									}

									pLoopCity->GetCityBuildings()->SetNumRealBuilding(eBuildingType, 0);
									bChanged = true;
								}
							}
						}
					}
				}
			}
			if(pkEventChoiceInfo->getEventPromotion() != -1)
			{
				PromotionTypes ePromotion = (PromotionTypes)pkEventChoiceInfo->getEventPromotion();
				if(ePromotion != -1)
				{
					CvUnit* pLoopUnit;
					int iLoop;
					for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
					{
						if(pLoopUnit->getUnitType() != NO_UNIT)
						{
							if(::IsPromotionValidForUnitCombatType(ePromotion, pLoopUnit->getUnitType()))
							{
								pLoopUnit->setHasPromotion(ePromotion, false);
								bChanged = true;
							}
						}
					}
					ChangeFreePromotionCount(ePromotion, -1);
				}
			}
			for(int iI = 0; iI < GC.getNumResourceInfos(); iI++)
			{
				ResourceTypes eResource = (ResourceTypes)iI;
				if(eResource != NO_RESOURCE)
				{
					int iBonus = pkEventChoiceInfo->getEventResourceChange(eResource);
					iBonus *= -1;
					if(iBonus != 0)
					{
						changeNumResourceTotal(eResource, iBonus);
						bChanged = true;
					}
				}
			}
			if(pkEventChoiceInfo->getPlayerHappiness() != 0)
			{
				if(getCapitalCity() != NULL)
				{
					getCapitalCity()->ChangeEventHappiness(pkEventChoiceInfo->getPlayerHappiness() * -1);
					bChanged = true;
				}
			}
			if(pkEventChoiceInfo->getCityHappinessGlobal() != 0)
			{
				int iLoop;
				for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
					{
						continue;
					}
					if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
					{
						continue;
					}
					pLoopCity->ChangeEventHappiness(pkEventChoiceInfo->getCityHappinessGlobal() * -1);
					bChanged = true;
				}
			}
			for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				YieldTypes eYield = (YieldTypes)iI;
				if(eYield == NO_YIELD)
					continue;

				if(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS)
				{
					int iUnhappinessNeedMod = pkEventChoiceInfo->getCityUnhappinessNeedMod(eYield);
					if(iUnhappinessNeedMod != 0)
					{
						iUnhappinessNeedMod *= -1;
						if(eYield == YIELD_GOLD)
						{
							ChangePovertyUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_CULTURE)
						{
							ChangeUnculturedUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_PRODUCTION)
						{
							ChangeDefenseUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_SCIENCE)
						{
							ChangeIlliteracyUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_FAITH)
						{
							ChangeMinorityUnhappinessGlobal(iUnhappinessNeedMod);
						}
					}
				}

				int iYieldChange = pkEventChoiceInfo->getCityYield(eYield);
				if(iYieldChange != 0)
				{
					if(pkEventChoiceInfo->IsEraScaling())
					{
						int iEra = GetCurrentEra();
						if(iEra <= 0)
						{
							iEra = 1;
						}
						iYieldChange *= iEra;
					}
					int iLoop;
					for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
						{
							continue;
						}
						if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
						{
							continue;
						}
						pLoopCity->ChangeEventCityYield(eYield, iYieldChange * -1);
						bChanged = true;
					}
				}
				// Building modifiers
				for(int iJ = 0; iJ < GC.getNumBuildingClassInfos(); iJ++)
				{
					BuildingClassTypes eBuildingClass = (BuildingClassTypes) iJ;

					CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
					if(!pkBuildingClassInfo)
					{
						continue;
					}
					if(pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield) != 0)
					{
						BuildingTypes eBuilding = NO_BUILDING;
						bool bRome = GetPlayerTraits()->IsKeepConqueredBuildings();
						if (!MOD_BUILDINGS_THOROUGH_PREREQUISITES && !bRome)
						{
							eBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(eBuildingClass);
						}

						if(MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome || eBuilding != NO_BUILDING)
						{
							int iLoop;
							for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
								{
									continue;
								}
								if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
								{
									continue;
								}
								if (MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome)
								{
									eBuilding = pLoopCity->GetCityBuildings()->GetBuildingTypeFromClass(eBuildingClass);
									if (eBuilding == NO_BUILDING)
									{
										continue;
									}
								}

								pLoopCity->ChangeEventBuildingClassYield(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield) * -1);
								bChanged = true;
								if(MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome || pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
								{
									pLoopCity->ChangeBaseYieldRateFromBuildings(eYield, pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield) * -1);
								}
							}
						}
					}
					if(pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield) != 0)
					{
						BuildingTypes eBuilding = NO_BUILDING;
						bool bRome = GetPlayerTraits()->IsKeepConqueredBuildings();
						if (!MOD_BUILDINGS_THOROUGH_PREREQUISITES && !bRome)
						{
							eBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(eBuildingClass);
						}

						if(MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome || eBuilding != NO_BUILDING)
						{
							int iLoop;
							for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
								{
									continue;
								}
								if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
								{
									continue;
								}
								if (MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome)
								{
									eBuilding = pLoopCity->GetCityBuildings()->GetBuildingTypeFromClass(eBuildingClass);
									if (eBuilding == NO_BUILDING)
									{
										continue;
									}
								}

								pLoopCity->ChangeEventBuildingClassYieldModifier(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield) * -1);
								bChanged = true;
								if(MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome || pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
								{
									pLoopCity->changeYieldRateModifier(eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield) * -1);
								}
							}
						}
					}
				}
				for(int iJ = 0; iJ < GC.getNumImprovementInfos(); iJ++)
				{
					ImprovementTypes eImprovement = (ImprovementTypes)iJ;
					if(eImprovement != NO_IMPROVEMENT && pkEventChoiceInfo->getImprovementYield(eImprovement, eYield) != 0)
					{
						int iLoop;
						for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
							{
								continue;
							}
							if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
							{
								continue;
							}
							pLoopCity->ChangeEventImprovementYield(eImprovement, eYield, pkEventChoiceInfo->getImprovementYield(eImprovement, eYield) * -1);
						}
						bChanged = true;
					}
				}
				for(int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
				{
					FeatureTypes eFeature = (FeatureTypes)iJ;
					if(eFeature != NO_FEATURE && pkEventChoiceInfo->getFeatureYield(eFeature, eYield) != 0)
					{
						int iLoop;
						for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
							{
								continue;
							}
							if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
							{
								continue;
							}
							pLoopCity->ChangeEventFeatureYield(eFeature, eYield, pkEventChoiceInfo->getFeatureYield(eFeature, eYield) * -1);
						}
						bChanged = true;
					}
				}
				for(int iJ = 0; iJ < GC.getNumTerrainInfos(); iJ++)
				{
					TerrainTypes eTerrain = (TerrainTypes)iJ;
					if(eTerrain != NO_TERRAIN && pkEventChoiceInfo->getTerrainYield(eTerrain, eYield) != 0)
					{
						int iLoop;
						for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
							{
								continue;
							}
							if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
							{
								continue;
							}
							pLoopCity->ChangeEventTerrainYield(eTerrain, eYield, pkEventChoiceInfo->getTerrainYield(eTerrain, eYield) * -1);
						}
						bChanged = true;
					}
				}
				for(int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
				{
					ResourceTypes eResource = (ResourceTypes)iJ;
					if(eResource != NO_RESOURCE && pkEventChoiceInfo->getResourceYield(eResource, eYield) != 0)
					{
						int iLoop;
						for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
							{
								continue;
							}
							if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
							{
								continue;
							}
							pLoopCity->ChangeEventResourceYield(eResource, eYield, pkEventChoiceInfo->getResourceYield(eResource, eYield) * -1);
						}
						bChanged = true;
					}
				}
				for(int iJ = 0; iJ < GC.getNumSpecialistInfos(); iJ++)
				{
					const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iJ);
					CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
					if(pkSpecialistInfo)
					{
						int iLoop;
						for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
							{
								continue;
							}
							if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
							{
								continue;
							}
							pLoopCity->ChangeEventSpecialistYield(eSpecialist, eYield, pkEventChoiceInfo->getGlobalSpecialistYieldChange(eSpecialist, eYield) * -1);
						}
						bChanged = true;
					}
				}
			}
		}
		if(bChanged)
		{
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications && GC.getGame().getActivePlayer() == GetID())
			{
				Localization::String strMessage;
				Localization::String strSummary;
				strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_EVENT_HAS_ENDED");
				strMessage << GetScaledHelpText(eChosenEventChoice, true);
				strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_EVENT_HAS_ENDED_T");

				pNotifications->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, -1, GetID());
			}
			int iLoop;
			for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				if(pLoopCity != NULL)
				{
					if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
					{
						continue;
					}
					if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
					{
						continue;
					}

					pLoopCity->UpdateReligion(pLoopCity->GetCityReligions()->GetReligiousMajority());
					for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
					{
						YieldTypes eYield = (YieldTypes) iI;
						if(eYield == NO_YIELD)
							continue;

						pLoopCity->UpdateSpecialReligionYields(eYield);
						pLoopCity->UpdateCityYields(eYield);
					}
					CalculateNetHappiness();
				}
			}
		}
		if (!pkEventChoiceInfo->isOneShot())
		{
			//Set it false here so we know the event choice is over now.
			SetEventChoiceActive(eChosenEventChoice, false);
		}
	}
}
CvString CvPlayer::GetScaledHelpText(EventChoiceTypes eEventChoice, bool bYieldsOnly)
{
	CvString CoreYieldTip = "";
	CvModEventChoiceInfo* pkEventChoiceInfo = GC.getEventChoiceInfo(eEventChoice);
	if(pkEventChoiceInfo == NULL)
	{
		return "";
	}
	Localization::String localizedCoreText;
	if(bYieldsOnly)
	{
		localizedCoreText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION");
	}
	else
	{
		localizedCoreText = Localization::Lookup(pkEventChoiceInfo->GetHelp());
	}

	int iEra = GetCurrentEra();
	if(iEra <= 0)
	{
		iEra = 1;
	}
	CvString yieldCostTip = "";
	CvString yieldInstantTip = "";
	CvString yieldCityTip = "";
	CvString turnsTip = "";
				
	for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eIndex = (YieldTypes)iI;
		if(eIndex == NO_YIELD)
		{
			continue;
		}
		CvYieldInfo* pYield = GC.getYieldInfo(eIndex);
		if(pYield)
		{
			int iPreValue = pkEventChoiceInfo->getPreCheckEventYield(eIndex);
			if(pkEventChoiceInfo->IsEraScaling())
			{
				iPreValue *= iEra;
			}
			iPreValue *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
			iPreValue /= 100;
			if(iPreValue != 0)
			{
				iPreValue *= -1;
				if(yieldCostTip != "")
				{
					yieldCostTip += ", ";
				}
				Localization::String localizedCostText;
				if(bYieldsOnly)
				{
					localizedCostText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_SPENT");
				}
				else
				{
					localizedCostText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED");
				}
				localizedCostText << pYield->GetDescription();
				localizedCostText << pYield->getIconString();
				localizedCostText << iPreValue;

				const char* const localized = localizedCostText.toUTF8();
				if(localized)
				{
					yieldCostTip += localized;
				}
			}
			int iYieldValue = pkEventChoiceInfo->getEventYield(eIndex);
			if(pkEventChoiceInfo->IsEraScaling())
			{
				iYieldValue *= iEra;
			}
			iYieldValue *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
			iYieldValue /= 100;
			if(iYieldValue != 0)
			{
				if(yieldInstantTip != "")
				{
					yieldInstantTip += ", ";
				}
				Localization::String localizedEventText;
				if(bYieldsOnly)
				{
					localizedEventText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_INSTANT");
				}
				else
				{
					localizedEventText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED");
				}
				localizedEventText << pYield->GetDescription();
				localizedEventText << pYield->getIconString();
				localizedEventText << iYieldValue;

				const char* const localized = localizedEventText.toUTF8();
				if(localized)
				{
					yieldInstantTip += localized;
				}
			}
			int iCityValue = pkEventChoiceInfo->getCityYield(eIndex);
			if(pkEventChoiceInfo->IsEraScaling())
			{
				iCityValue *= iEra;
			}
			if(iCityValue != 0)
			{
				if(yieldCityTip != "")
				{
					yieldCityTip += ", ";
				}
				Localization::String localizedCityText;
				if(bYieldsOnly)
				{
					localizedCityText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_CITY");
				}
				else
				{
					localizedCityText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED");
				}
				localizedCityText << pYield->GetDescription();
				localizedCityText << pYield->getIconString();
				localizedCityText << iCityValue;

				const char* const localized = localizedCityText.toUTF8();
				if(localized)
				{
					yieldCityTip += localized;
				}
			}
		}
	}
	localizedCoreText << yieldCostTip;
	localizedCoreText << yieldInstantTip;
	localizedCoreText << yieldCityTip;

	//Duration
	int iDuration = pkEventChoiceInfo->getEventDuration();
	if(iDuration > 0)
	{
		iDuration *= GC.getGame().getGameSpeedInfo().getTrainPercent();
		iDuration /= 100;
		Localization::String localizedDurationText;
		if(bYieldsOnly)
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_TURNS");
		}
		else
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_YIELD_DURATION");
		}
		localizedDurationText << iDuration;
		const char* const localized = localizedDurationText.toUTF8();
		if(localized)
		{
			turnsTip += localized;
		}
	}
	localizedCoreText << turnsTip;

	const char* const finallocalized = localizedCoreText.toUTF8();
	if(finallocalized)
	{
		CoreYieldTip += pkEventChoiceInfo->GetDescription();
		CoreYieldTip += "[NEWLINE]";
		CoreYieldTip += finallocalized;
	}
	return CoreYieldTip.c_str();
}
CvString CvPlayer::GetDisabledTooltip(EventChoiceTypes eChosenEventChoice)
{
	CvString DisabledTT = Localization::Lookup("TXT_KEY_EVENT_DISABLED_REASONS_HEADER").toUTF8();
	Localization::String localizedDurationText;

	if(eChosenEventChoice == NO_EVENT_CHOICE)
		return "";

	CvModEventChoiceInfo* pkEventInfo = GC.getEventChoiceInfo(eChosenEventChoice);
	if(pkEventInfo == NULL)
	{
		return "";
	}

	CvString strOverrideText = GetLocalizedText(pkEventInfo->getDisabledTooltip());
	if(strOverrideText != "")
	{
		return strOverrideText.c_str();
	}

	//Lua Hook
	if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_EventChoiceCanTake, GetID(), eChosenEventChoice) == GAMEEVENTRETURN_FALSE) 
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_DISABLED_LUA");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->isOneShot() && IsEventChoiceFired(eChosenEventChoice))
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_ONESHOT");
		DisabledTT += localizedDurationText.toUTF8();
	}

	//Event Choice already active for this event? Abort!
	if(GetEventChoiceDuration(eChosenEventChoice) > 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_ACTIVE");
		DisabledTT += localizedDurationText.toUTF8();
	}

	//Let's narrow down all events here!
	if(pkEventInfo->getPrereqTech() != -1 && !GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_TECH");
		localizedDurationText << GC.getTechInfo((TechTypes)pkEventInfo->getPrereqTech())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->getObsoleteTech() != -1 && GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getObsoleteTech()))
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_OBSOLETE_TECH");
		localizedDurationText << GC.getTechInfo((TechTypes)pkEventInfo->getObsoleteTech())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->getRequiredEra() != -1 && GetCurrentEra() < (EraTypes)pkEventInfo->getRequiredEra())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ERA");
		localizedDurationText << GC.getEraInfo((EraTypes)pkEventInfo->getRequiredEra())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->getObsoleteEra() != -1 && GetCurrentEra() >= (EraTypes)pkEventInfo->getObsoleteEra())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_OBSOLETE_ERA");
		localizedDurationText << GC.getEraInfo((EraTypes)pkEventInfo->getObsoleteEra())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->getMinimumNationalPopulation() > 0 && getTotalPopulation() < pkEventInfo->getMinimumNationalPopulation())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_POP_NATIONAL");
		localizedDurationText << pkEventInfo->getMinimumNationalPopulation();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->getMinimumNumberCities() > 0 && getNumCities() < pkEventInfo->getMinimumNumberCities())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_CITIES");
		localizedDurationText << pkEventInfo->getMinimumNumberCities();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->getRequiredCiv() != -1 && getCivilizationType() != (CivilizationTypes)pkEventInfo->getRequiredCiv())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_CIV");
		localizedDurationText << GC.getCivilizationInfo((CivilizationTypes)pkEventInfo->getRequiredCiv())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->getRequiredPolicy() != -1 && !GetPlayerPolicies()->HasPolicy((PolicyTypes)pkEventInfo->getRequiredPolicy()))
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_POLICY");
		localizedDurationText << GC.getPolicyInfo((PolicyTypes)pkEventInfo->getRequiredPolicy())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->getRequiredIdeology() != -1 && GetPlayerPolicies()->GetLateGamePolicyTree() != (PolicyBranchTypes)pkEventInfo->getRequiredIdeology())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_IDEOLOGY");
		localizedDurationText << GC.getPolicyBranchInfo((PolicyBranchTypes)pkEventInfo->getRequiredIdeology())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->hasStateReligion() && GetReligions()->GetStateReligion(false) == NO_RELIGION)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ANY_STATE_RELIGION");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->hasPantheon() && (GetReligions()->GetOwnedReligion() != NO_RELIGION || GetReligions()->GetReligionCreatedByPlayer(true) != RELIGION_PANTHEON))
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ANY_PANTHEON");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->isUnhappy() && !IsEmpireUnhappy())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_UNHAPPY");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->isSuperUnhappy() && !IsEmpireSuperUnhappy())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_SUPER_UNHAPPY");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->isRequiresIdeology() && GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ANY_IDEOLOGY");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->isRequiresWar() && GetMilitaryAI()->GetNumberCivsAtWarWith(false) <= 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_WAR_MAJOR");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->getRequiredStateReligion() != -1)
	{
		if (GetReligions()->GetOwnedReligion() != pkEventInfo->getRequiredStateReligion())
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_SPECIFIC_STATE_RELIGION");
			localizedDurationText << GC.getReligionInfo((ReligionTypes)pkEventInfo->getRequiredStateReligion())->GetDescription();
			DisabledTT += localizedDurationText.toUTF8();
		}
	}

	if (!pkEventInfo->isRequiresHolyCity() && pkEventInfo->getRequiredReligion() != -1)
	{
		if (GetReligions()->GetStateReligion(false) != (ReligionTypes)pkEventInfo->getRequiredReligion())
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_SPECIFIC_RELIGION");
			localizedDurationText << GC.getReligionInfo((ReligionTypes)pkEventInfo->getRequiredReligion())->GetDescription();
			DisabledTT += localizedDurationText.toUTF8();
		}
	}

	//Let's do our linker checks here.
	for(int iI = 0; iI <= pkEventInfo->GetNumLinkers(); iI++)
	{
		CvEventChoiceLinkingInfo *pLinkerInfo = pkEventInfo->GetLinkerInfo(iI);
		if(pLinkerInfo)
		{
			EventTypes eLinkerEvent = (EventTypes)pLinkerInfo->GetLinkingEvent();
			EventChoiceTypes eLinkerEventChoice = (EventChoiceTypes)pLinkerInfo->GetLinkingEventChoice();
			CityEventTypes eLinkerCityEvent = (CityEventTypes)pLinkerInfo->GetCityLinkingEvent();
			CityEventChoiceTypes eLinkerCityEventChoice = (CityEventChoiceTypes)pLinkerInfo->GetCityLinkingEventChoice();

			PlayerTypes ePlayer;

			bool bEventFound = false;
			bool bEventChoiceFound = false;
			bool bCityEventFound = false;
			bool bCityEventChoiceFound = false;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				ePlayer = (PlayerTypes) iPlayerLoop;
				if(ePlayer == NO_PLAYER)
					continue;

				if(!pLinkerInfo->CheckOtherPlayers() && ePlayer != GetID())
					continue;

				if(eLinkerEvent != NO_EVENT && !bEventFound)
				{
					bool bActive = (GetEventCooldown(eLinkerEvent) > 0 || IsEventFired(eLinkerEvent));
					if(bActive != pLinkerInfo->CheckForActive())
					{
						if(bActive)
						{
							if(pLinkerInfo->CheckOtherPlayers())
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_EVENT_ACTIVE");
							}
							else
							{	
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ACTIVE_EVENT");
							}
						}
						else
						{
							if(pLinkerInfo->CheckOtherPlayers())
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_EVENT_NO_ACTIVE");
							}
							else
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NO_ACTIVE_PLAYER_EVENT");
								
							}
						}
						localizedDurationText << GC.getEventInfo(eLinkerEvent)->GetDescription();
						DisabledTT += localizedDurationText.toUTF8();
						bEventFound = true;
					}
				}

				if(eLinkerEventChoice != NO_EVENT_CHOICE && !bEventChoiceFound)
				{
					bool bActive = (GetEventChoiceDuration(eLinkerEventChoice) > 0 || IsEventChoiceFired(eLinkerEventChoice));
					if(bActive != pLinkerInfo->CheckForActive())
					{
						if(bActive)
						{
							if(pLinkerInfo->CheckOtherPlayers())
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_EVENT_CHOICE_ACTIVE");

							}
							else
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ACTIVE_EVENT_CHOICE");
							}
						}
						else
						{
							if(pLinkerInfo->CheckOtherPlayers())
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_NO_EVENT_CHOICE_ACTIVE");
							}
							else
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NO_ACTIVE_PLAYER_EVENT_CHOICE");
							}
						}
						localizedDurationText << GC.getEventChoiceInfo(eLinkerEventChoice)->GetDescription();
						DisabledTT += localizedDurationText.toUTF8();
						bEventChoiceFound = true;
						break;
					}
				}

				if(eLinkerCityEvent != NO_EVENT_CITY || eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
				{
					int iLoop;
					for(CvCity* pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))
					{
						if(eLinkerCityEvent != NO_EVENT_CITY && !bCityEventFound)
						{
							bool bActive = (pLoopCity->GetEventCooldown(eLinkerCityEvent) > 0 || pLoopCity->IsEventFired(eLinkerCityEvent));
							if(bActive != pLinkerInfo->CheckForActive())
							{
								if(bActive)
								{
									if(pLinkerInfo->CheckOtherPlayers())
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_CITY_EVENT_ACTIVE");
									}
									else
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ACTIVE_CITY_EVENT");
									}
								}
								else
								{
									if(pLinkerInfo->CheckOtherPlayers())
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_NO_CITY_EVENT_ACTIVE");
									}
									else
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NO_ACTIVE_CITY_EVENT");
									}
								}
								localizedDurationText << GC.getCityEventInfo(eLinkerCityEvent)->GetDescription();
								DisabledTT += localizedDurationText.toUTF8();
								bCityEventFound = true;
								break;
							}
						}

						if(!bCityEventChoiceFound && eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
						{
							bool bActive = (pLoopCity->GetEventChoiceDuration(eLinkerCityEventChoice) > 0 || pLoopCity->IsEventChoiceFired(eLinkerCityEventChoice));
							if(bActive != pLinkerInfo->CheckForActive())
							{
								if(bActive)
								{
									if(pLinkerInfo->CheckOtherPlayers())
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_CITY_EVENT_CHOICE_ACTIVE");
									}
									else
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ACTIVE_CITY_EVENT_CHOICE");
									}
								}
								else
								{
									if(pLinkerInfo->CheckOtherPlayers())
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_CITY_EVENT_CHOICE_NO_ACTIVE");
									}
									else
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NO_ACTIVE_CITY_EVENT_CHOICE");
									}
								}
								localizedDurationText << GC.getCityEventChoiceInfo(eLinkerCityEventChoice)->GetDescription();
								DisabledTT += localizedDurationText.toUTF8();
								bCityEventChoiceFound = true;
								break;
							}
						}
					}
				}
			}
		}
	}

	if(pkEventInfo->hasMetAnotherCiv())
	{
		if(GET_TEAM(getTeam()).getHasMetCivCount(true) <= 0)
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_MET_OTHER_CIV");
			DisabledTT += localizedDurationText.toUTF8();
		}
	}

	if (pkEventInfo->isMaster() && GetNumVassals() <= 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_VASSAL");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isVassal() && !IsVassalOfSomeone())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_BE_VASSAL");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->isTradeCapped() && GetTrade()->GetNumTradeUnitsRemaining(true) <= 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_TRADE_SLOT");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->getUnitTypeRequired() != -1)
	{
		bool bHas = false;
		CvUnit* pLoopUnit;
		int iLoop;
		for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		{
			if(pLoopUnit != NULL && pLoopUnit->getUnitClassType() == (UnitClassTypes)pkEventInfo->getUnitTypeRequired())
			{
				bHas = true;
				break;
			}
		}
		if(!bHas)
		{
			CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());

			if (pCivilizationInfo != NULL)
			{
				UnitTypes eUnitType = (UnitTypes)pCivilizationInfo->getCivilizationUnits((UnitClassTypes)pkEventInfo->getUnitTypeRequired());
				if (eUnitType != NO_UNIT)
				{
					localizedDurationText = Localization::Lookup("TXT_KEY_NEED_UNITCLASS_TYPE");
					localizedDurationText << GC.getUnitInfo(eUnitType)->GetDescription();
					DisabledTT += localizedDurationText.toUTF8();
				}
			}
		}
	}


	if(pkEventInfo->isRequiresHolyCity())
	{
		bool bHas = false;
		bool bSpecific = false;
		CvCity* pCity = NULL;
		int iLoop;
		for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
		{
			if(pkEventInfo->getRequiredReligion() != -1)
			{
				if(pCity != NULL && pCity->GetCityReligions()->IsHolyCityForReligion((ReligionTypes)pkEventInfo->getRequiredReligion()))
				{
					bHas = true;
					bSpecific = true;
					break;
				}
			}
			else
			{
				if(pCity != NULL && pCity->GetCityReligions()->IsHolyCityAnyReligion())
				{
					bHas = true;
					break;
				}
			}
		}
		if(!bHas && !bSpecific)
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_HOLY_CITY");
			DisabledTT += localizedDurationText.toUTF8();
		}
		if(!bHas && bSpecific)
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_HOLY_CITY_SPECIFIC");
			DisabledTT += localizedDurationText.toUTF8();
		}
	}
	if(pkEventInfo->getNumCoastalRequired() > 0)
	{
		bool bHas = false;
		CvCity* pCity = NULL;
		int iLoop;
		int iNumCoastal = 0;
		for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
		{
			if(pCity != NULL && pCity->isCoastal())
			{
				iNumCoastal++;
			}
			if(iNumCoastal >= pkEventInfo->getNumCoastalRequired())
			{
				bHas = true;
				break;
			}
		}
		if(!bHas)
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_COASTAL_CITIES");
			localizedDurationText << pkEventInfo->getNumCoastalRequired();
			DisabledTT += localizedDurationText.toUTF8();
		}
	}

	if(pkEventInfo->isRequiresWarMinor())
	{
		bool bHas = false;
		for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			// Is this a player we have relations with?
			if(GET_PLAYER(eLoopPlayer).isBarbarian())
			{
				continue;
			}
			if(!GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				continue;
			}
			if(eLoopPlayer != GetID())
			{
				if(GET_TEAM(getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
				{
					bHas = true;
					break;
				}
			}
		}
		if(!bHas)
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_WAR_MINOR");
			DisabledTT += localizedDurationText.toUTF8();
		}
	}
	for(int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
	{
		const ResourceTypes eResource = static_cast<ResourceTypes>(iJ);
		CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
		if(pkResource)
		{
			if(pkEventInfo->getResourceRequired(eResource) > 0)
			{
				if(getNumResourceTotal(eResource, false) < pkEventInfo->getResourceRequired(eResource))
				{
					localizedDurationText = Localization::Lookup("TXT_KEY_NEED_RESOURCE");
					localizedDurationText << pkResource->GetDescription();
					DisabledTT += localizedDurationText.toUTF8();
				}
			}
		}
	}
	bool bHas = true;
	for(int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
	{
		const FeatureTypes eFeature = static_cast<FeatureTypes>(iJ);
		CvFeatureInfo* pkFeature = GC.getFeatureInfo(eFeature);
		if(pkFeature)
		{
			if(pkEventInfo->getFeatureRequired(eFeature) > 0)
			{
				CvCity* pCity = NULL;
				int iLoop;
				int iNeeded = pkEventInfo->getFeatureRequired(eFeature);
				int iHave = 0;
				for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
				{

					if(pCity != NULL && pCity->HasFeature(eFeature))
					{
						iHave++;
					}
				}
				if(iHave < iNeeded)
				{
					localizedDurationText = Localization::Lookup("TXT_KEY_NEED_FEATURE");
					localizedDurationText << pkFeature->GetDescription();
					DisabledTT += localizedDurationText.toUTF8();
				}
			}
		}
	}
	if(pkEventInfo->getBuildingRequired() != -1)
	{
		BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventInfo->getBuildingRequired();
		if(eBuildingClass != NO_BUILDINGCLASS)
		{
			bool bHas = false;
			CvCity* pCity = NULL;
			int iLoop;
			for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
			{
				if(pCity != NULL && pCity->GetCityBuildings()->GetNumBuildingClass(eBuildingClass) > 0)
				{
					bHas = true;
					break;
				}
			}
			if(!bHas)
			{
				CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());

				if (pCivilizationInfo != NULL)
				{
					BuildingTypes eBuildingType = (BuildingTypes)pCivilizationInfo->getCivilizationBuildings((BuildingClassTypes)pkEventInfo->getBuildingRequired());
					if (eBuildingType != NO_BUILDING)
					{
						localizedDurationText = Localization::Lookup("TXT_KEY_NEED_BUILDING_CLASS");
						localizedDurationText << GC.getBuildingInfo(eBuildingType)->GetDescription();
						DisabledTT += localizedDurationText.toUTF8();
					}
				}
			}
		}
	}
	if(pkEventInfo->getBuildingLimiter() != -1)
	{
		BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventInfo->getBuildingLimiter();
		if(eBuildingClass != NO_BUILDINGCLASS)
		{
			bool bHas = false;
			CvCity* pCity = NULL;
			int iLoop;
			for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
			{
				if(pCity != NULL && pCity->GetCityBuildings()->GetNumBuildingClass(eBuildingClass) > 0)
				{
					bHas = true;
					break;
				}
			}
			if(bHas)
			{
				CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());

				if (pCivilizationInfo != NULL)
				{
					BuildingTypes eBuildingType = (BuildingTypes)pCivilizationInfo->getCivilizationBuildings((BuildingClassTypes)pkEventInfo->getBuildingLimiter());
					if (eBuildingType != NO_BUILDING)
					{
						localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NO_BUILDING_CLASS");
						localizedDurationText << GC.getBuildingInfo(eBuildingType)->GetDescription();
						DisabledTT += localizedDurationText.toUTF8();
					}
				}
			}
		}
	}
	if(pkEventInfo->getRequiredImprovement() != -1)
	{
		ImprovementTypes eImprovement = (ImprovementTypes)pkEventInfo->getRequiredImprovement();
		if(eImprovement != NO_IMPROVEMENT)
		{
			bool bHas = false;
			// go through all the plots the player has under their control
			for (PlotIndexContainer::const_iterator it = m_aiPlots.begin(); it != m_aiPlots.end(); ++it)
			{
				CvPlot* pPlot = GC.getMap().plotByIndex(*it);
				if (!pPlot)
				{
					continue;
				}

				if(pPlot->getOwner() == GetID() && pPlot->getImprovementType() == eImprovement)
				{
					bHas = true;
					break;
				}
			}
			if(!bHas)
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_NEED_IMPROVEMENT");
				localizedDurationText << GC.getImprovementInfo((ImprovementTypes)pkEventInfo->getRequiredImprovement())->GetDescription();
				DisabledTT += localizedDurationText.toUTF8();
			}
		}
	}
	//Check our minimum yields - this looks at stored values, not yields per turn.
	bHas = true;
	for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes)iI;
		if(eYield == NO_YIELD)
			continue;
							
		int iNeededYield = pkEventInfo->getYieldMinimum(eYield);
		if(pkEventInfo->getPreCheckEventYield(eYield) != 0)
		{
			if(iNeededYield < pkEventInfo->getPreCheckEventYield(eYield))
			{
				iNeededYield = pkEventInfo->getPreCheckEventYield(eYield);
			}
		}
		iNeededYield *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
		iNeededYield /= 100;
		if(pkEventInfo->IsEraScaling())
		{
			int iEra = GetCurrentEra();
			if(iEra <= 0)
			{
				iEra = 1;
			}
			iNeededYield *= iEra;
		}
		if(iNeededYield != 0)
		{
			if(eYield == YIELD_GOLD)
			{
				if(iNeededYield > GetTreasury()->GetGold())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_SCIENCE)
			{
				TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
				int iTech = 0;
				if(eCurrentTech != NO_TECH)
				{
					iTech = GetPlayerTechs()->GetResearchProgress(eCurrentTech);
				}
				if(iNeededYield > iTech)
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_FAITH)
			{
				if(iNeededYield > GetFaith())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_GOLDEN_AGE_POINTS)
			{
				if(iNeededYield > GetGoldenAgeProgressMeter())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_CULTURE)
			{
				if(iNeededYield > getJONSCulture())
				{
					bHas = false;
					break;
				}
			}
		}
	}
	if(!bHas)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_YIELDS");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->isInDebt() && GetTreasury()->GetGold() > 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_DEBT");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->isLosingMoney() && GetTreasury()->CalculateBaseNetGold() > 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NEGATIVE_GPT");
		DisabledTT += localizedDurationText.toUTF8();
	}

	return DisabledTT.c_str();
}
//Let's look for global events that affect a city being built/captured.
void CvPlayer::CheckActivePlayerEvents(CvCity* pCity)
{
	if(pCity == NULL)
		return;

	//Event Choice Duration First - if we're in one, let's do the countdown now.
	//We need to do this first so we can cancel the event(s).
	for(int iLoop = 0; iLoop < GC.getNumEventChoiceInfos(); iLoop++)
	{
		EventChoiceTypes eEventChoice = (EventChoiceTypes)iLoop;
		if(eEventChoice != NO_EVENT_CHOICE)
		{
			if(GetEventChoiceDuration(eEventChoice) > 0 || IsEventChoiceFired(eEventChoice))
			{
				DoEventSyncChoices(eEventChoice, pCity);
			}
		}
	}
}
//Let's grab all the global events that affect cities.
void CvPlayer::DoEventSyncChoices(EventChoiceTypes eEventChoice, CvCity* pCity)
{
	if(eEventChoice != NO_EVENT_CHOICE)
	{
		CvModEventChoiceInfo* pkEventChoiceInfo = GC.getEventChoiceInfo(eEventChoice);
		if(pkEventChoiceInfo != NULL)
		{
			if(pkEventChoiceInfo->getEventChance() <= 0)
			{
				if(pkEventChoiceInfo->getEventBuilding() != -1)
				{
					BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventChoiceInfo->getEventBuilding();
					if(eBuildingClass != NO_BUILDINGCLASS)
					{
						const CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
	
						if (pkBuildingClassInfo)
						{
							CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
		
							if (pCivilizationInfo != NULL)
							{
								BuildingTypes eBuildingType = NO_BUILDING;
								bool bRome = GetPlayerTraits()->IsKeepConqueredBuildings();

								if (!MOD_BUILDINGS_THOROUGH_PREREQUISITES && !bRome)
								{
									eBuildingType = (BuildingTypes)pCivilizationInfo->getCivilizationBuildings(eBuildingClass);
								}

								if(MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome || eBuildingType != NO_BUILDING)
								{
									int iLoop;
									for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
									{
										if(pLoopCity != pCity)
											continue;

										if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
										{
											continue;
										}

										if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
										{
											continue;
										}

										if (MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome)
										{
											eBuildingType = pLoopCity->GetCityBuildings()->GetBuildingTypeFromClass(eBuildingClass);
											if (eBuildingType == NO_BUILDING)
											{
												continue;
											}
										}

										if (pLoopCity->HasBuilding(eBuildingType))
										{
											continue;
										}

										pLoopCity->GetCityBuildings()->SetNumRealBuilding(eBuildingType, 1);
									}
								}
							}
						}
					}
				}
				for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
				{
					YieldTypes eYield = (YieldTypes)iI;
					if(eYield == NO_YIELD)
						continue;
					int iYieldChange = pkEventChoiceInfo->getCityYield(eYield);
					if(iYieldChange != 0)
					{
						if(pkEventChoiceInfo->IsEraScaling())
						{
							int iEra = GetCurrentEra();
							if(iEra <= 0)
							{
								iEra = 1;
							}
							iYieldChange *= iEra;
						}
						int iLoop;
						for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pLoopCity != pCity)
								continue;

							if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
							{
								continue;
							}
							if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
							{
								continue;
							}
							pLoopCity->ChangeEventCityYield(eYield, iYieldChange);
						}
					}
					// Building modifiers
					for(int iJ = 0; iJ < GC.getNumBuildingClassInfos(); iJ++)
					{
						BuildingClassTypes eBuildingClass = (BuildingClassTypes) iJ;

						CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
						if(!pkBuildingClassInfo)
						{
							continue;
						}
						if(pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield) != 0)
						{
							BuildingTypes eBuilding = NO_BUILDING;
							bool bRome = GetPlayerTraits()->IsKeepConqueredBuildings();
							if (!MOD_BUILDINGS_THOROUGH_PREREQUISITES && !bRome)
							{
								eBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(eBuildingClass);
							}

							if(MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome || eBuilding != NO_BUILDING)
							{
								int iLoop;
								for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
								{
									if(pLoopCity != pCity)
										continue;

									if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
									{
										continue;
									}
									if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
									{
										continue;
									}
									if (MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome)
									{
										eBuilding = pLoopCity->GetCityBuildings()->GetBuildingTypeFromClass(eBuildingClass);
									}
									pLoopCity->ChangeEventBuildingClassYield(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield));
									if(eBuilding != NO_BUILDING && pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
									{
										pLoopCity->ChangeBaseYieldRateFromBuildings(eYield, pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield));
									}
								}
							}
						}
						if(pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield) != 0)
						{
							BuildingTypes eBuilding = NO_BUILDING;
							bool bRome = GetPlayerTraits()->IsKeepConqueredBuildings();
							if (!MOD_BUILDINGS_THOROUGH_PREREQUISITES && !bRome)
							{
								eBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(eBuildingClass);
							}

							if(MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome || eBuilding != NO_BUILDING)
							{
								int iLoop;
								for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
								{
									if(pLoopCity != pCity)
										continue;

									if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
									{
										continue;
									}
									if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
									{
										continue;
									}
									if (MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome)
									{
										eBuilding = pLoopCity->GetCityBuildings()->GetBuildingTypeFromClass(eBuildingClass);
									}
									pLoopCity->ChangeEventBuildingClassYieldModifier(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield));
									if(eBuilding != NO_BUILDING && pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
									{
										pLoopCity->changeYieldRateModifier(eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield));
									}
								}
							}
						}
					}
					for(int iJ = 0; iJ < GC.getNumImprovementInfos(); iJ++)
					{
						ImprovementTypes eImprovement = (ImprovementTypes)iJ;
						if(eImprovement != NO_IMPROVEMENT && pkEventChoiceInfo->getImprovementYield(eImprovement, eYield) != 0)
						{
							int iLoop;
							for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								if(pLoopCity != pCity)
									continue;

								if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
								{
									continue;
								}
								if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
								{
									continue;
								}
								pLoopCity->ChangeEventImprovementYield(eImprovement, eYield, pkEventChoiceInfo->getImprovementYield(eImprovement, eYield));
							}
						}
					}
					for(int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
					{
						FeatureTypes eFeature = (FeatureTypes)iJ;
						if(eFeature != NO_FEATURE && pkEventChoiceInfo->getFeatureYield(eFeature, eYield) != 0)
						{
							int iLoop;
							for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								if(pLoopCity != pCity)
									continue;

								if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
								{
									continue;
								}
								if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
								{
									continue;
								}
								pLoopCity->ChangeEventFeatureYield(eFeature, eYield, pkEventChoiceInfo->getFeatureYield(eFeature, eYield));
							}
						}
					}
					for(int iJ = 0; iJ < GC.getNumTerrainInfos(); iJ++)
					{
						TerrainTypes eTerrain = (TerrainTypes)iJ;
						if(eTerrain != NO_TERRAIN && pkEventChoiceInfo->getTerrainYield(eTerrain, eYield) != 0)
						{
							int iLoop;
							for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								if(pLoopCity != pCity)
									continue;

								if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
								{
									continue;
								}
								if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
								{
									continue;
								}
								pLoopCity->ChangeEventTerrainYield(eTerrain, eYield, pkEventChoiceInfo->getTerrainYield(eTerrain, eYield));
							}
						}
					}
					for(int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
					{
						ResourceTypes eResource = (ResourceTypes)iJ;
						if(eResource != NO_RESOURCE && pkEventChoiceInfo->getResourceYield(eResource, eYield) != 0)
						{
							int iLoop;
							for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								if(pLoopCity != pCity)
									continue;

								if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
								{
									continue;
								}
								if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
								{
									continue;
								}
								pLoopCity->ChangeEventResourceYield(eResource, eYield, pkEventChoiceInfo->getResourceYield(eResource, eYield));
							}
						}
					}
					for(int iJ = 0; iJ < GC.getNumSpecialistInfos(); iJ++)
					{
						const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iJ);
						CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
						if(pkSpecialistInfo)
						{
							int iLoop;
							for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								if(pLoopCity != pCity)
									continue;

								if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
								{
									continue;
								}
								if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
								{
									continue;
								}
								pLoopCity->ChangeEventSpecialistYield(eSpecialist, eYield, pkEventChoiceInfo->getGlobalSpecialistYieldChange(eSpecialist, eYield));
							}
						}
					}
				}
				if(pkEventChoiceInfo->getCityHappinessGlobal() != 0)
				{
					int iLoop;
					for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if(pLoopCity != pCity)
							continue;

						if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
						{
							continue;
						}
						if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
						{
							continue;
						}
						pLoopCity->ChangeEventHappiness(pkEventChoiceInfo->getCityHappinessGlobal());
					}
				}
				int iLoop;
				for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if(pLoopCity != NULL)
					{
						if(pLoopCity != pCity)
							continue;

						if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
						{
							continue;
						}
						if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
						{
							continue;
						}

						pLoopCity->UpdateReligion(pLoopCity->GetCityReligions()->GetReligiousMajority());
						for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
						{
							YieldTypes eYield = (YieldTypes) iI;
							if(eYield == NO_YIELD)
								continue;

							pLoopCity->UpdateSpecialReligionYields(eYield);
							pLoopCity->UpdateCityYields(eYield);
						}
						CalculateNetHappiness();
					}
				}
			}
		}
	}
}
void CvPlayer::DoEventChoice(EventChoiceTypes eEventChoice, EventTypes eEvent, bool bSendMsg, bool bEspionage)
{
	if (GC.getGame().isNetworkMultiPlayer() && bSendMsg && isHuman()) {
		NetMessageExt::Send::DoEventChoice(GetID(), eEventChoice, eEvent);
		return;
	}
	if(eEventChoice != NO_EVENT_CHOICE)
	{
		CvModEventChoiceInfo* pkEventChoiceInfo = GC.getEventChoiceInfo(eEventChoice);
		if(pkEventChoiceInfo != NULL)
		{
			//Set oneshot stuff so this event can't fire ever again.
			if(pkEventChoiceInfo->isOneShot())
			{
				SetEventChoiceFired(eEventChoice, true);
			}
			//Set false so we know we've completed the city event.
			//Loop through all city events and set any related to this to false, just to be sure.
			//This is purely for the notification system to keep the icon from disappearing until a choice has been made.
			if(eEvent == NO_EVENT)
			{
				for(int iLoop = 0; iLoop < GC.getNumEventInfos(); iLoop++)
				{
					EventTypes eEvent = (EventTypes)iLoop;
					if(eEvent != NO_EVENT)
					{
						if(pkEventChoiceInfo->isParentEvent(eEvent))
						{
							SetEventActive(eEvent, false);
						}
					}
				}
			}
			else
			{
				SetEventActive(eEvent, false);
			}

			if(GC.getLogging())
			{
				CvString playerName;
				FILogFile* pLog;
				CvString strBaseString;
				CvString strOutBuf;
				CvString strFileName = "EventLogging.csv";
				playerName = getCivilizationShortDescription();
				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				strBaseString += playerName + ", ";
				strOutBuf.Format("Event choice chosen by player: %s", pkEventChoiceInfo->GetDescription());
				strBaseString += strOutBuf;
				pLog->Msg(strBaseString);
			}
			bool bAlreadyActive = false;
			//Set the cooldown for all events.
			if(pkEventChoiceInfo->getEventDuration() > 0)
			{
				//already active? Apply the extended duration, but don't duplicate the yield effect.
				if (bEspionage && GetEventChoiceDuration(eEventChoice) > 0)
					bAlreadyActive = true;

				//Gamespeed.
				int iEventDuration = pkEventChoiceInfo->getEventDuration();
				iEventDuration *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iEventDuration /= 100;
				ChangeEventChoiceDuration(eEventChoice, iEventDuration);
			}

			//Lua Hook
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_EventChoiceActivated, GetID(), eEventChoice);

			//Do the cost first, as that goes through whether or not the event succeeds!
			for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				YieldTypes eYield = (YieldTypes)iI;
				if(eYield == NO_YIELD)
					continue;
							
				int iPassYield = pkEventChoiceInfo->getPreCheckEventYield(eYield);
				if(iPassYield != 0)
				{
					iPassYield *= -1;
					CvCity* pCity = getCapitalCity();
					if(pCity != NULL)
					{
						doInstantYield(INSTANT_YIELD_TYPE_INSTANT, false, NO_GREATPERSON, NO_BUILDING, iPassYield, pkEventChoiceInfo->IsEraScaling(), NO_PLAYER, NULL, true, pCity, false, true, true, eYield);
					}
				}
			}
			//Let's see if it even happens.
			if(pkEventChoiceInfo->getEventChance() > 0)
			{
				int iRandom = GC.getGame().getJonRandNum(100, "Random Event Chance");
				int iLimit = pkEventChoiceInfo->getEventChance();
				if(iRandom > iLimit)
				{
					//Notify if it did not work.
					CvNotifications* pNotifications = GetNotifications();
					if(pNotifications && GC.getGame().getActivePlayer() == GetID())
					{
						for(int iLoop = 0; iLoop < GC.getNumCityEventInfos(); iLoop++)
						{
							EventTypes eEvent = (EventTypes)iLoop;
							if(eEvent != NO_EVENT)
							{
								if(pkEventChoiceInfo->isParentEvent(eEvent))
								{
									CvModEventInfo* pkEventInfo = GC.getEventInfo(eEvent);
									if(pkEventInfo != NULL)
									{
										Localization::String strMessage;
										Localization::String strSummary;
										strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_EVENT_FAILED");
										strMessage << pkEventChoiceInfo->GetDescription();
										strMessage << GetScaledHelpText(eEventChoice, false);
										strMessage << pkEventInfo->GetDescription();
										strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_EVENT_FAILED_T");
										strSummary << pkEventInfo->GetDescription();

										pNotifications->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, -1, GetID());
										break;
									}
								}
							}
						}
					}
					return;
				}
			}
			//Succeeded? Set event choice active here so we know to deduct it later.
			SetEventChoiceActive(eEventChoice, true);

			//Now on to the actions themselves.
			if (pkEventChoiceInfo->getEventPolicy() != -1)
			{
				PolicyTypes ePolicy = (PolicyTypes)pkEventChoiceInfo->getEventPolicy();
				if(ePolicy != -1)
				{
					setHasPolicy(ePolicy, true, true);
				}
			}
			if(pkEventChoiceInfo->getEventTech() != -1)
			{
				TechTypes eTech = (TechTypes)pkEventChoiceInfo->getEventTech();
				if(eTech != -1)
				{
					GET_TEAM(getTeam()).GetTeamTechs()->SetHasTech(eTech, true);
				}
			}
			if(pkEventChoiceInfo->getEventBuilding() != -1)
			{
				BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventChoiceInfo->getEventBuilding();
				if(eBuildingClass != NO_BUILDINGCLASS)
				{
					const CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
	
					if (pkBuildingClassInfo)
					{
						CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
		
						if (pCivilizationInfo != NULL)
						{
							BuildingTypes eBuildingType = NO_BUILDING;
							bool bRome = GetPlayerTraits()->IsKeepConqueredBuildings();
							if (!MOD_BUILDINGS_THOROUGH_PREREQUISITES && !bRome)
							{
								eBuildingType = (BuildingTypes)pCivilizationInfo->getCivilizationBuildings(eBuildingClass);
							}
							
							if (MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome || eBuildingType != NO_BUILDING)
							{
								int iLoop;
								for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
								{
									if (pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
									{
										continue;
									}

									if (pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
									{
										continue;
									}

									if (MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome)
									{
										eBuildingType = (BuildingTypes)pCivilizationInfo->getCivilizationBuildings(eBuildingClass);
										if (eBuildingType == NO_BUILDING)
										{
											continue;
										}
									}

									if (pLoopCity->HasBuilding(eBuildingType))
									{
										continue;
									}

									pLoopCity->GetCityBuildings()->SetNumRealBuilding(eBuildingType, 1, true);
								}
							}
						}
					}
				}
			}
			if(pkEventChoiceInfo->getEventPromotion() != -1)
			{
				PromotionTypes ePromotion = (PromotionTypes)pkEventChoiceInfo->getEventPromotion();
				if(ePromotion != -1)
				{
					CvUnit* pLoopUnit;
					int iLoop;
					for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
					{
						if(pLoopUnit->getUnitType() != NO_UNIT)
						{
							if(::IsPromotionValidForUnitCombatType(ePromotion, pLoopUnit->getUnitType()))
							{
								if(pLoopUnit->HasPromotion(ePromotion))
								{
									pLoopUnit->changeExperienceTimes100(15 * 100);
								}
								else
								{
									pLoopUnit->setHasPromotion(ePromotion, true);
								}
							}
						}
					}
					ChangeFreePromotionCount(ePromotion, 1);
				}
			}
			for(int iI = 0; iI < GC.getNumResourceInfos(); iI++)
			{
				ResourceTypes eResource = (ResourceTypes)iI;
				if(eResource != NO_RESOURCE)
				{
					int iBonus = pkEventChoiceInfo->getEventResourceChange(eResource);
					if(iBonus != 0)
					{
						changeNumResourceTotal(eResource, iBonus);
					}
				}
			}
			for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				YieldTypes eYield = (YieldTypes)iI;
				if(eYield == NO_YIELD)
					continue;

				if(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS)
				{
					int iUnhappinessNeedMod = pkEventChoiceInfo->getCityUnhappinessNeedMod(eYield);
					if(iUnhappinessNeedMod != 0)
					{
						if(eYield == YIELD_GOLD)
						{
							ChangePovertyUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_CULTURE)
						{
							ChangeUnculturedUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_PRODUCTION)
						{
							ChangeDefenseUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_SCIENCE)
						{
							ChangeIlliteracyUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_FAITH)
						{
							ChangeMinorityUnhappinessGlobal(iUnhappinessNeedMod);
						}
					}
				}

				if (!bAlreadyActive)
				{
					int iYieldChange = pkEventChoiceInfo->getCityYield(eYield);
					if (iYieldChange != 0)
					{
						if (pkEventChoiceInfo->IsEraScaling())
						{
							int iEra = GetCurrentEra();
							if (iEra <= 0)
							{
								iEra = 1;
							}
							iYieldChange *= iEra;
						}
						int iLoop;
						for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if (pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
							{
								continue;
							}
							if (pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
							{
								continue;
							}
							pLoopCity->ChangeEventCityYield(eYield, iYieldChange);
						}
					}
					// Building modifiers
					for (int iJ = 0; iJ < GC.getNumBuildingClassInfos(); iJ++)
					{
						BuildingClassTypes eBuildingClass = (BuildingClassTypes)iJ;

						CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
						if (!pkBuildingClassInfo)
						{
							continue;
						}
						if (pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield) != 0)
						{
							BuildingTypes eBuilding = NO_BUILDING;
							bool bRome = GetPlayerTraits()->IsKeepConqueredBuildings();
							if (!MOD_BUILDINGS_THOROUGH_PREREQUISITES && !bRome)
							{
								eBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(eBuildingClass);
							}

							if (MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome || eBuilding != NO_BUILDING)
							{
								int iLoop;
								for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
								{
									if (pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
									{
										continue;
									}
									if (pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
									{
										continue;
									}
									if (MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome)
									{
										eBuilding = pLoopCity->GetCityBuildings()->GetBuildingTypeFromClass(eBuildingClass);
									}

									pLoopCity->ChangeEventBuildingClassYield(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield));
									if (eBuilding != NO_BUILDING && pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
									{
										pLoopCity->ChangeBaseYieldRateFromBuildings(eYield, pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield));
									}
								}
							}
						}
						if (pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield) != 0)
						{
							BuildingTypes eBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(eBuildingClass);
							bool bRome = GetPlayerTraits()->IsKeepConqueredBuildings();
							if (!MOD_BUILDINGS_THOROUGH_PREREQUISITES && !bRome)
							{
								eBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(eBuildingClass);
							}

							if (MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome || eBuilding != NO_BUILDING)
							{
								int iLoop;
								for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
								{
									if (pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
									{
										continue;
									}
									if (pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
									{
										continue;
									}
									if (MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome)
									{
										eBuilding = pLoopCity->GetCityBuildings()->GetBuildingTypeFromClass(eBuildingClass);
									}

									pLoopCity->ChangeEventBuildingClassYieldModifier(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield));
									if (eBuilding != NO_BUILDING && pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
									{
										pLoopCity->changeYieldRateModifier(eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield));
									}
								}
							}
						}
					}
				}
							
				int iPassYield = pkEventChoiceInfo->getEventYield(eYield);
				if(iPassYield != 0)
				{
					int iLoop;
					for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if(!pkEventChoiceInfo->isInstantYieldAllCities() && !pLoopCity->isCapital())
							continue;

						doInstantYield(INSTANT_YIELD_TYPE_INSTANT, false, NO_GREATPERSON, NO_BUILDING, iPassYield, pkEventChoiceInfo->IsEraScaling(), NO_PLAYER, NULL, true, pLoopCity, false, true, true, eYield);
					}
				}
				if (!bAlreadyActive)
				{
					for (int iJ = 0; iJ < GC.getNumImprovementInfos(); iJ++)
					{
						ImprovementTypes eImprovement = (ImprovementTypes)iJ;
						if (eImprovement != NO_IMPROVEMENT && pkEventChoiceInfo->getImprovementYield(eImprovement, eYield) != 0)
						{
							int iLoop;
							for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								if (pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
								{
									continue;
								}
								if (pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
								{
									continue;
								}
								pLoopCity->ChangeEventImprovementYield(eImprovement, eYield, pkEventChoiceInfo->getImprovementYield(eImprovement, eYield));
							}
						}
					}
					for (int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
					{
						FeatureTypes eFeature = (FeatureTypes)iJ;
						if (eFeature != NO_FEATURE && pkEventChoiceInfo->getFeatureYield(eFeature, eYield) != 0)
						{
							int iLoop;
							for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								if (pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
								{
									continue;
								}
								if (pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
								{
									continue;
								}
								pLoopCity->ChangeEventFeatureYield(eFeature, eYield, pkEventChoiceInfo->getFeatureYield(eFeature, eYield));
							}
						}
					}
					for (int iJ = 0; iJ < GC.getNumTerrainInfos(); iJ++)
					{
						TerrainTypes eTerrain = (TerrainTypes)iJ;
						if (eTerrain != NO_TERRAIN && pkEventChoiceInfo->getTerrainYield(eTerrain, eYield) != 0)
						{
							int iLoop;
							for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								if (pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
								{
									continue;
								}
								if (pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
								{
									continue;
								}
								pLoopCity->ChangeEventTerrainYield(eTerrain, eYield, pkEventChoiceInfo->getTerrainYield(eTerrain, eYield));
							}
						}
					}
					for (int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
					{
						ResourceTypes eResource = (ResourceTypes)iJ;
						if (eResource != NO_RESOURCE && pkEventChoiceInfo->getResourceYield(eResource, eYield) != 0)
						{
							int iLoop;
							for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								if (pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
								{
									continue;
								}
								if (pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
								{
									continue;
								}
								pLoopCity->ChangeEventResourceYield(eResource, eYield, pkEventChoiceInfo->getResourceYield(eResource, eYield));
							}
						}
					}
					for (int iJ = 0; iJ < GC.getNumSpecialistInfos(); iJ++)
					{
						const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iJ);
						CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
						if (pkSpecialistInfo)
						{
							int iLoop;
							for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								if (pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
								{
									continue;
								}
								if (pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
								{
									continue;
								}
								pLoopCity->ChangeEventSpecialistYield(eSpecialist, eYield, pkEventChoiceInfo->getGlobalSpecialistYieldChange(eSpecialist, eYield));
							}
						}
					}
				}
			}
			if(pkEventChoiceInfo->getGoldenAgeTurns() > 0)
			{
				int iTurns = pkEventChoiceInfo->getGoldenAgeTurns();
				iTurns = iTurns * GC.getGame().getGameSpeedInfo().getTrainPercent() / 100;
				changeGoldenAgeTurns(getGoldenAgeLength(max(1, iTurns)), true);
			}
			if(pkEventChoiceInfo->getNumFreeGreatPeople() > 0)
			{
				ChangeNumFreeGreatPeople(pkEventChoiceInfo->getNumFreeGreatPeople());
			}
			if(pkEventChoiceInfo->getNumFreePolicies() > 0)
			{
				ChangeNumFreePolicies(pkEventChoiceInfo->getNumFreePolicies());
			}
			if(pkEventChoiceInfo->getNumFreeTechs() > 0)
			{
				SetNumFreeTechs(GetNumFreeTechs() + pkEventChoiceInfo->getNumFreeTechs());
			}
			if(pkEventChoiceInfo->getPlayerHappiness() != 0)
			{
				if(getCapitalCity() != NULL)
				{
					getCapitalCity()->ChangeEventHappiness(pkEventChoiceInfo->getPlayerHappiness());
				}
			}
			if(pkEventChoiceInfo->getCityHappinessGlobal() != 0)
			{
				int iLoop;
				for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
					{
						continue;
					}
					if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
					{
						continue;
					}
					pLoopCity->ChangeEventHappiness(pkEventChoiceInfo->getCityHappinessGlobal());
				}
			}
			if(pkEventChoiceInfo->getRandomBarbs() > 0)
			{
				if (GC.getGame().isOption(GAMEOPTION_NO_BARBARIANS))
					return;
				
				// In hundreds
				int iNumRebels = pkEventChoiceInfo->getRandomBarbs();

				int iLoop;
				for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					// Found a place to set up an uprising?
					if(pLoopCity != NULL)
					{
						if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
						{
							continue;
						}
						if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
						{
							continue;
						}
						GC.getGame().DoSpawnUnitsAroundTargetCity(BARBARIAN_PLAYER, pLoopCity, iNumRebels, false, false, false, false);
					}
				}
			}
			if(pkEventChoiceInfo->getFreeScaledUnits() > 0)
			{
				// In hundreds
				int iNumRecruits = pkEventChoiceInfo->getFreeScaledUnits();

				int iLoop;
				for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					// Found a place to set up an uprising?
					if(pLoopCity != NULL)
					{
						if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
						{
							continue;
						}
						if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
						{
							continue;
						}

						GC.getGame().DoSpawnUnitsAroundTargetCity(GetID(), pLoopCity, iNumRecruits, false, pLoopCity->isCoastal(), false, true);
					}
				}
			}
			for(int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
			{
				const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
				CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
				if(pkUnitClassInfo)
				{
					if(pkEventChoiceInfo->getNumFreeUnits((UnitClassTypes)iI) <= 0)
						continue;

					const UnitTypes eLoopUnit = GetSpecificUnitType(eUnitClass);
					if(eLoopUnit != NO_UNIT)
					{
						CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eLoopUnit);
						if(pkUnitEntry)
						{
							int iLoop;
							for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
								{
									continue;
								}
								if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
								{
									continue;
								}
								for(int iJ = 0; iJ < pkEventChoiceInfo->getNumFreeUnits((UnitClassTypes)iI); iJ++)
								{
									UnitAITypes eUnitAI = pkUnitEntry->GetDefaultUnitAIType();
									CvUnit* pUnit = pLoopCity->CreateUnit(eLoopUnit, eUnitAI, REASON_GIFT);

									if (pUnit)
									{
										if (!pUnit->jumpToNearestValidPlot())
										{
											pUnit->kill(false);	// Could not find a valid spot!
										}
										else
										{
											pUnit->finishMoves();
											//Lua Hook
											GAMEEVENTINVOKE_HOOK(GAMEEVENT_EventUnitCreated, GetID(), eEventChoice, pUnit);
										}
									}
								}
							}
						}
					}
				}
			}
			for(int iI = 0; iI < GC.getNumUnitInfos(); iI++)
			{
				const UnitTypes eUnit = static_cast<UnitTypes>(iI);
				CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eUnit);
				if(pkUnitEntry)
				{
					if(pkEventChoiceInfo->getNumFreeSpecificUnits((UnitTypes)iI) <= 0)
						continue;
	
					for(int iJ = 0; iJ < pkEventChoiceInfo->getNumFreeSpecificUnits((UnitTypes)iI); iJ++)
					{
						UnitAITypes eUnitAI = pkUnitEntry->GetDefaultUnitAIType();
						int iLoop;
						for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pLoopCity != NULL)
							{
								if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
								{
									continue;
								}
								if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
								{
									continue;
								}
								CvUnit* pUnit = pLoopCity->CreateUnit(eUnit, eUnitAI, REASON_GIFT);
								if (pUnit)
								{
									if (!pUnit->IsCivilianUnit() && !pUnit->jumpToNearestValidPlot())
									{
										pUnit->kill(false);	// Could not find a valid spot!
									}
									else
									{
										pUnit->finishMoves();
										//Lua Hook
										GAMEEVENTINVOKE_HOOK(GAMEEVENT_EventUnitCreated, GetID(), eEventChoice, pUnit);
									}
								}
							}
						}
					}
				}
			}
			for(int iI = 0; iI < GC.getNumReligionInfos(); iI++)
			{
				ReligionTypes eReligion = (ReligionTypes)iI;
				if(eReligion == NO_RELIGION)
					continue;

				int iLoop;
				int iPercent = (ReligionTypes)pkEventChoiceInfo->getEventConvertReligionPercent(iI);
				if(iPercent > 0)
				{
					for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
						{
							continue;
						}
						if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
						{
							continue;
						}
						pLoopCity->GetCityReligions()->ConvertPercentAllOtherFollowers(eReligion, iPercent);
					}
				}
				int iPop = (ReligionTypes)pkEventChoiceInfo->getEventConvertReligion(iI);
				if(iPop > 0)
				{
					for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
						{
							continue;
						}
						if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
						{
							continue;
						}
						pLoopCity->GetCityReligions()->ConvertNumberAllOtherFollowers(eReligion, iPop);
					}
				}
			}
			if(pkEventChoiceInfo->getResistanceTurns() > 0)
			{
				int iTurns = pkEventChoiceInfo->getResistanceTurns();
				iTurns *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iTurns /= 100;
				int iLoop;
				for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
					{
						continue;
					}
					if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
					{
						continue;
					}
					pLoopCity->ChangeResistanceTurns(max(1, iTurns));
				}
			}
			if(pkEventChoiceInfo->getWLTKD() > 0)
			{
				int iTurns = pkEventChoiceInfo->getWLTKD();
				iTurns *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iTurns /= 100;
				int iLoop;
				for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
					{
						continue;
					}
					if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
					{
						continue;
					}
					pLoopCity->ChangeWeLoveTheKingDayCounter(max(1, iTurns));
				}
			}

			//Let's do our notification stuff here.
			for(int iI = 0; iI < pkEventChoiceInfo->GetNumNotifications(); iI++)
			{
				CvString strNotificationString = pkEventChoiceInfo->GetNotificationInfo(iI)->GetNotificationString();		
				if(strNotificationString != NULL && strNotificationString != "")
				{
					NotificationTypes eNotificationType = (NotificationTypes)FString::Hash(strNotificationString);
					
					if(eNotificationType != NO_NOTIFICATION_TYPE)
					{
						Localization::String strMessage;
						Localization::String strSummary;
						strSummary = Localization::Lookup(pkEventChoiceInfo->GetNotificationInfo(iI)->GetShortDescription());
						strSummary << getCivilizationShortDescriptionKey();
						strSummary << getCivilizationDescription();
						strSummary << getName();
						strMessage = Localization::Lookup(pkEventChoiceInfo->GetNotificationInfo(iI)->GetDescription());
						strMessage << getCivilizationShortDescriptionKey();
						strMessage << getCivilizationDescription();
						strMessage << getName();
						strMessage << GetScaledHelpText(eEventChoice, true);
						bool bGlobal = pkEventChoiceInfo->GetNotificationInfo(iI)->IsWorldEvent();
						for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
						{
							PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;
							if(ePlayer != NO_PLAYER && GET_PLAYER(ePlayer).isMajorCiv())
							{
								//Not global? Skip all but me.
								if(!bGlobal && ePlayer != GetID())
									continue;

								//Global? Seed only to known players.
								if(bGlobal && ePlayer != GetID() && !GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(getTeam()))
									continue;

								//Send out notifications!
								CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();
								if(pNotifications && GC.getGame().getActivePlayer() == ePlayer)
								{
									if(pkEventChoiceInfo->GetNotificationInfo(iI)->IsNeedPlayerID())
									{
										pNotifications->Add(eNotificationType, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, GetID(), pkEventChoiceInfo->GetNotificationInfo(iI)->GetVariable2());
									}
									else
									{
										pNotifications->Add(eNotificationType, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, pkEventChoiceInfo->GetNotificationInfo(iI)->GetVariable1(), pkEventChoiceInfo->GetNotificationInfo(iI)->GetVariable2());
									}
								}
							}
						}
					}
				}
			}
			int iLoop;
			for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				if(pLoopCity != NULL)
				{
					if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
					{
						continue;
					}
					if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
					{
						continue;
					}

					pLoopCity->UpdateReligion(pLoopCity->GetCityReligions()->GetReligiousMajority());
					for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
					{
						YieldTypes eYield = (YieldTypes) iI;
						if(eYield == NO_YIELD)
							continue;

						pLoopCity->UpdateSpecialReligionYields(eYield);
						pLoopCity->UpdateCityYields(eYield);
					}
					CalculateNetHappiness();
				}
			}
		}
	}
}
#endif

//	--------------------------------------------------------------------------------
/// This player liberates iOldCityID and gives it back to ePlayer
void CvPlayer::DoLiberatePlayer(PlayerTypes ePlayer, int iOldCityID, bool bForced)
{
	CvCity* pCity = getCity(iOldCityID);
	CvAssert(pCity);
	if (!pCity)
		return;

	PlayerTypes eOldOwner = pCity->getOwner();
	CvPlot* pPlot = pCity->plot();

	if (ePlayer == NO_PLAYER || ePlayer == BARBARIAN_PLAYER)
	{
		ePlayer = pCity->getOriginalOwner();
	}
	if (ePlayer == NO_PLAYER || ePlayer == BARBARIAN_PLAYER)
	{
		return;
	}

	// Set that this team has been liberated
	TeamTypes eTeam = getTeam();
	TeamTypes eLiberatedTeam = GET_PLAYER(ePlayer).getTeam();

	// Who originally took out this team?
	TeamTypes eConquerorTeam = GET_TEAM(eLiberatedTeam).GetKilledByTeam();

	CvDiplomacyAI* pDiploAI = GET_PLAYER(ePlayer).GetDiplomacyAI();
	bool bAlive = GET_PLAYER(ePlayer).isAlive();

	// If they aren't alive, start the resurrection process
	if (!bAlive)
	{
		// Mark the liberators
		if (!bForced)
		{
			GET_TEAM(eLiberatedTeam).SetLiberatedByTeam(eTeam);
		}

		// Put everyone at peace with this guy
		for (int iOtherTeamLoop = 0; iOtherTeamLoop < MAX_CIV_TEAMS; iOtherTeamLoop++)
		{
			if (eLiberatedTeam != iOtherTeamLoop)
			{
				GET_TEAM(eLiberatedTeam).makePeace((TeamTypes)iOtherTeamLoop, /*bBumpUnits*/false, /*bSuppressNotification*/true, GetID());
			}
		}
	}

	// Diplo bonus for returning the city
	if (!bForced)
	{
		if (GET_PLAYER(ePlayer).isMajorCiv())
		{
			// Liberated the capital - big diplo bonus!
			if (pCity->getX() == GET_PLAYER(ePlayer).GetOriginalCapitalX() && pCity->getY() == GET_PLAYER(ePlayer).GetOriginalCapitalY())
			{
				pDiploAI->SetPlayerLiberatedCapital(m_eID, true);
			}

			// Liberated the Holy City - big bonus IF the Holy City status still remains
			if (GET_PLAYER(ePlayer).IsHasLostHolyCity() && pCity->GetCityReligions()->IsHolyCityForReligion(GET_PLAYER(ePlayer).GetReligions()->GetOriginalReligionCreatedByPlayer()))
			{
				pDiploAI->SetPlayerLiberatedHolyCity(m_eID, true);
			}

			pDiploAI->ChangeNumCitiesLiberatedBy(m_eID, 1);
		}
	}

	// Give the city back to the liberated player
	CvCity* pNewCity = GET_PLAYER(ePlayer).acquireCity(pCity, false, false);
	if (!pNewCity)
		return;

	//do not use this anymore!
	pCity = NULL;

	// Now verify that the player is alive
	GET_PLAYER(ePlayer).verifyAlive();

	// Process other diplomatic consequences if a major was liberated
	if (!bForced && GET_PLAYER(ePlayer).isMajorCiv())
	{
		// Player was alive? Just notify that a city was liberated.
		if (bAlive)
		{
			Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_LIBERATED");
			if (GC.getGame().isGameMultiPlayer() && isHuman())
			{
				strMessage << getNickName();
			}
			else
			{
				strMessage << getNameKey();
			}
			strMessage << pNewCity->getNameKey(); // CITY NAME
			strMessage << GET_PLAYER(ePlayer).getCivilizationShortDescriptionKey();// RESTORED CIV NAME

			Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CIV_LIBERATED_SHORT");
			strSummary << pNewCity->getNameKey();
			if (GC.getGame().isGameMultiPlayer() && GET_PLAYER(ePlayer).isHuman())
			{
				strSummary << GET_PLAYER(ePlayer).getNickName();
			}
			else
			{
				strSummary << GET_PLAYER(ePlayer).getNameKey();
			}

			for (int iI = 0; iI < MAX_MAJOR_CIVS; iI++)
			{
				CvPlayerAI& kOtherPlayer = GET_PLAYER((PlayerTypes)iI);
				if (iI == m_eID)
					continue;

				if (!kOtherPlayer.isObserver())
				{
					if (!kOtherPlayer.isAlive())
						continue;

					if (!GET_TEAM(kOtherPlayer.getTeam()).isHasMet(getTeam()) && !GET_TEAM(kOtherPlayer.getTeam()).isHasMet(eLiberatedTeam))
						continue;
				}

				if (kOtherPlayer.GetNotifications())
					kOtherPlayer.GetNotifications()->Add(NOTIFICATION_LIBERATED_MAJOR_CITY, strMessage.toUTF8(), strSummary.toUTF8(), pNewCity->getX(), pNewCity->getY(), -1);
			}
		}

		// Player was dead? Huge diplo bonuses!
		else
		{
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				PlayerTypes eMyTeamPlayer = (PlayerTypes) iPlayerLoop;

				if (GET_PLAYER(eMyTeamPlayer).getTeam() == getTeam() && !GET_PLAYER(ePlayer).GetDiplomacyAI()->IsResurrectorAttackedUs(eMyTeamPlayer))
				{
					pDiploAI->SetResurrectedBy(eMyTeamPlayer, true);

					pDiploAI->SetLandDisputeLevel(eMyTeamPlayer, DISPUTE_LEVEL_NONE);
					pDiploAI->SetWonderDisputeLevel(eMyTeamPlayer, DISPUTE_LEVEL_NONE);
					pDiploAI->SetMinorCivDisputeLevel(eMyTeamPlayer, DISPUTE_LEVEL_NONE);
					pDiploAI->SetVictoryDisputeLevel(eMyTeamPlayer, DISPUTE_LEVEL_NONE);
					pDiploAI->SetVictoryBlockLevel(eMyTeamPlayer, BLOCK_LEVEL_NONE);
					pDiploAI->SetTechBlockLevel(eMyTeamPlayer, BLOCK_LEVEL_NONE);
					pDiploAI->SetPolicyBlockLevel(eMyTeamPlayer, BLOCK_LEVEL_NONE);

					pDiploAI->SetWarmongerThreat(eMyTeamPlayer, THREAT_NONE);
					pDiploAI->SetOtherPlayerWarmongerAmountTimes100(eMyTeamPlayer, 0);
					
					pDiploAI->SetNumDemandsMade(eMyTeamPlayer, 0);

					if (pDiploAI->GetCoopWarScore(eMyTeamPlayer) < 0)
					{
						pDiploAI->SetCoopWarScore(eMyTeamPlayer, 0);
					}

					if (GET_PLAYER(eMyTeamPlayer).GetDiplomacyAI()->GetCoopWarScore(ePlayer) < 0)
					{
						pDiploAI->SetCoopWarScore(ePlayer, 0);
					}
					
					// Forget war history
					pDiploAI->SetNumWarsDeclaredOnUs(eMyTeamPlayer, 0);
					pDiploAI->SetNumCitiesCapturedBy(eMyTeamPlayer, 0);
					pDiploAI->SetNumTradeRoutesPlundered(eMyTeamPlayer, 0);
					GET_PLAYER(eMyTeamPlayer).GetDiplomacyAI()->SetNumWarsDeclaredOnUs(ePlayer, 0);
					GET_PLAYER(eMyTeamPlayer).GetDiplomacyAI()->SetNumCitiesCapturedBy(ePlayer, 0);
					GET_PLAYER(eMyTeamPlayer).GetDiplomacyAI()->SetNumTradeRoutesPlundered(ePlayer, 0);
					
					pDiploAI->SetNumArtifactsEverDugUp(eMyTeamPlayer, 0);
					pDiploAI->SetEverConvertedCity(eMyTeamPlayer, false);
					
					pDiploAI->SetNumTimesTheyPlottedAgainstUs(eMyTeamPlayer, 0);
					pDiploAI->SetNumTimesTheyLoweredOurInfluence(eMyTeamPlayer, 0);
					pDiploAI->SetNumTimesPerformedCoupAgainstUs(eMyTeamPlayer, 0);
					pDiploAI->SetNumTimesCultureBombed(eMyTeamPlayer, 0);
					pDiploAI->SetNegativeReligiousConversionPoints(eMyTeamPlayer, 0);
					pDiploAI->SetNegativeArchaeologyPoints(eMyTeamPlayer, 0);
					pDiploAI->SetNumTimesRobbedBy(eMyTeamPlayer, 0);
					
					// Reset all promises
					pDiploAI->SetPlayerMilitaryPromiseState(eMyTeamPlayer, NO_PROMISE_STATE);
					pDiploAI->SetPlayerExpansionPromiseState(eMyTeamPlayer, NO_PROMISE_STATE);
					pDiploAI->SetPlayerBorderPromiseState(eMyTeamPlayer, NO_PROMISE_STATE);
					pDiploAI->SetPlayerBullyCityStatePromiseState(eMyTeamPlayer, NO_PROMISE_STATE);
					pDiploAI->SetPlayerAttackCityStatePromiseState(eMyTeamPlayer, NO_PROMISE_STATE);
					pDiploAI->SetPlayerSpyPromiseState(eMyTeamPlayer, NO_PROMISE_STATE);
					pDiploAI->SetPlayerNoConvertPromiseState(eMyTeamPlayer, NO_PROMISE_STATE);
					pDiploAI->SetPlayerNoDiggingPromiseState(eMyTeamPlayer, NO_PROMISE_STATE);
					pDiploAI->SetPlayerBrokenCoopWarPromise(eMyTeamPlayer, false);

					pDiploAI->SetOtherPlayerNumProtectedMinorsKilled(eMyTeamPlayer, 0);
					pDiploAI->SetOtherPlayerNumProtectedMinorsAttacked(eMyTeamPlayer, 0);
					pDiploAI->SetOtherPlayerNumProtectedMinorsBullied(eMyTeamPlayer, 0);
					pDiploAI->SetOtherPlayerSidedWithProtectedMinorTurn(eMyTeamPlayer, -1);

					pDiploAI->SetDoFBroken(eMyTeamPlayer, false, true);
					pDiploAI->SetFriendDenouncedUs(eMyTeamPlayer, false); // clear backstabbing penalties
					pDiploAI->SetFriendDeclaredWarOnUs(eMyTeamPlayer, false); // clear backstabbing penalties
					pDiploAI->SetDenouncedPlayer(eMyTeamPlayer, false); // forget any denouncing
					GET_PLAYER(eMyTeamPlayer).GetDiplomacyAI()->SetDenouncedPlayer(ePlayer, false); // forget any denouncing

					pDiploAI->SetNumTimesNuked(eMyTeamPlayer, 0);

					pDiploAI->SetWeDislikedTheirProposalTurn(eMyTeamPlayer, -1);
					pDiploAI->SetTheyFoiledOurProposalTurn(eMyTeamPlayer, -1);

					if (pDiploAI->GetLikedTheirProposalValue(eMyTeamPlayer) > 0)
					{
						pDiploAI->SetLikedTheirProposalValue(eMyTeamPlayer, 0);
					}
					if (pDiploAI->GetSupportedOurProposalValue(eMyTeamPlayer) > 0)
					{
						pDiploAI->SetSupportedOurProposalValue(eMyTeamPlayer, 0);
					}
					if (pDiploAI->GetVotingHistoryScore(eMyTeamPlayer) < 0)
					{
						pDiploAI->SetVotingHistoryScore(eMyTeamPlayer, 0);
					}
					pDiploAI->SetTheySanctionedUsTurn(eMyTeamPlayer, -1);
					pDiploAI->SetEverSanctionedUs(eMyTeamPlayer, false);

					pDiploAI->SetVassalageForcefullyRevokedTurn(eMyTeamPlayer, -1);
					pDiploAI->SetPlayerBrokenVassalAgreement(eMyTeamPlayer, false);

					// Clear this player's backstabbing penalties
					GET_PLAYER(eMyTeamPlayer).GetDiplomacyAI()->SetDoFBroken(ePlayer, false, true);
					GET_PLAYER(eMyTeamPlayer).GetDiplomacyAI()->SetFriendDenouncedUs(ePlayer, false);
					GET_PLAYER(eMyTeamPlayer).GetDiplomacyAI()->SetFriendDeclaredWarOnUs(ePlayer, false);
					GET_PLAYER(eMyTeamPlayer).GetDiplomacyAI()->SetVassalageForcefullyRevokedTurn(ePlayer, -1);
					GET_PLAYER(eMyTeamPlayer).GetDiplomacyAI()->SetPlayerBrokenVassalAgreement(ePlayer, false);

					// Clear backstabbing mark
					pDiploAI->SetBackstabbedBy(eMyTeamPlayer, false, false);
					GET_PLAYER(eMyTeamPlayer).GetDiplomacyAI()->SetBackstabbedBy(ePlayer, false, false);
				}
			}

			// Resurrected civ becomes a vassal of the resurrector, if possible
			if (GET_TEAM(eLiberatedTeam).GetLiberatedByTeam() != eConquerorTeam && !IsVassalOfSomeone() && GD_INT_GET(DIPLOAI_DISABLE_VOLUNTARY_VASSALAGE) == 0)
			{
				if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassal(getTeam()))
				{
					GET_TEAM(GET_PLAYER(ePlayer).getTeam()).SetNumTurnsIsVassal(-1);
					GET_TEAM(GET_PLAYER(ePlayer).getTeam()).SetNumTurnsSinceVassalEnded(getTeam(), -1);
					GET_TEAM(GET_PLAYER(ePlayer).getTeam()).DoBecomeVassal(getTeam(), true, GetID());
				}
			}

			// Add resurrection notification
			Localization::String strMessage;

			if (GET_TEAM(eLiberatedTeam).GetMaster() == getTeam())
			{
				strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_CIV_RESURRECTED_VOLUNTARY_VASSAL");
			}
			else
			{
				strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_CIV_RESURRECTED");
			}

			strMessage << getCivilizationShortDescriptionKey(); // LIBERATING CIV NAME
			strMessage << pNewCity->getNameKey(); // CITY NAME
			strMessage << GET_PLAYER(ePlayer).getCivilizationAdjectiveKey(); // LIBERATED CIV NAME
			strMessage << GET_PLAYER(ePlayer).getCivilizationDescriptionKey();// LIBERATED CIV NAME
			Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CIV_RESURRECTED_SHORT");

			if (GC.getGame().isGameMultiPlayer() && GET_PLAYER(ePlayer).isHuman())
			{
				strSummary << GET_PLAYER(ePlayer).getNickName();
			}
			else
			{
				strSummary << GET_PLAYER(ePlayer).getNameKey();
			}
			if (GC.getGame().isGameMultiPlayer() && GET_PLAYER(m_eID).isHuman())
			{
				strSummary << GET_PLAYER(m_eID).getNickName();
			}
			else
			{
				strSummary << GET_PLAYER(m_eID).getNameKey();
			}			

			for (int iI = 0; iI < MAX_MAJOR_CIVS; iI++)
			{
				CvPlayerAI& kOtherPlayer = GET_PLAYER((PlayerTypes)iI);
				if (iI == m_eID)
					continue;

				if (!kOtherPlayer.isObserver())
				{
					if (!kOtherPlayer.isAlive())
						continue;

					if (!GET_TEAM(kOtherPlayer.getTeam()).isHasMet(getTeam()) && !GET_TEAM(kOtherPlayer.getTeam()).isHasMet(eLiberatedTeam))
						continue;
				}

				if (kOtherPlayer.GetNotifications())
					kOtherPlayer.GetNotifications()->Add(NOTIFICATION_RESURRECTED_MAJOR_CIV, strMessage.toUTF8(), strSummary.toUTF8(), pNewCity->getX(), pNewCity->getY(), -1);
			}

			CvString temp = strMessage.toUTF8();
			GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, m_eID, temp);
		}
	}

	// Kick out all other players' units from the city plot
	if (pPlot->getNumUnits() > 0)
	{
		// Get the current list of units because we will possibly be moving them out of the plot's list
		IDInfoVector currentUnits;
		if (pPlot->getUnits(&currentUnits) > 0)
		{
			for (IDInfoVector::const_iterator itr = currentUnits.begin(); itr != currentUnits.end(); ++itr)
			{
				CvUnit* pLoopUnit = (CvUnit*)GetPlayerUnit(*itr);

				if (pLoopUnit && pLoopUnit->getOwner() != ePlayer)
				{
					pLoopUnit->finishMoves();
					if (!pLoopUnit->jumpToNearestValidPlot())
						pLoopUnit->kill(false);
				}
			}
		}
	}

	// If a City-State was liberated, adjust Influence levels and give the City-State a basic but state-of-the-art garrison
	if (GET_PLAYER(ePlayer).isMinorCiv())
	{
		if (!bForced)
			GET_PLAYER(ePlayer).GetMinorCivAI()->DoLiberationByMajor(eOldOwner, eConquerorTeam);
		else
			GET_PLAYER(ePlayer).GetMinorCivAI()->SetFriendshipWithMajor(GetID(), /*-60*/ GD_INT_GET(MINOR_FRIENDSHIP_AT_WAR));

		UnitTypes eUnit = GC.getGame().GetCompetitiveSpawnUnitType(ePlayer, false, false, false, true, false);
		if (eUnit != NO_UNIT)
			GET_PLAYER(ePlayer).initUnit(eUnit, pNewCity->getX(), pNewCity->getY());
	}

	if (!bForced)
	{
		if (!pNewCity->isEverLiberated(GetID()))
		{
			pNewCity->setEverLiberated(GetID(), true);

			// Reduce liberator's warmongering penalties (if any), unless this is their own team's city
			if (getTeam() != GET_PLAYER(ePlayer).getTeam())
				CvDiplomacyAIHelpers::ApplyLiberationBonuses(pNewCity, GetID(), ePlayer);

			// Reduce liberator's war weariness by 25%
			GetCulture()->SetWarWeariness(GetCulture()->GetWarWeariness() - (GetCulture()->GetWarWeariness() / 4));
		}

#if defined(MOD_BALANCE_CORE_POLICIES)
		//gain yields for liberation
		int iPop = pNewCity->getPopulation();
		for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
		{
			YieldTypes eYield = (YieldTypes)iI;
			int iLiberationYield = getYieldForLiberation(eYield);
			if (iLiberationYield > 0)
				doInstantYield(INSTANT_YIELD_TYPE_INSTANT, false, NO_GREATPERSON, NO_BUILDING, iLiberationYield * iPop, true, NO_PLAYER, NULL, false, getCapitalCity(), false, true, true, eYield);
		}

		//liberator gets influence with all City-States?
		int iInfluence = getInfluenceForLiberation();
		if (iInfluence > 0)
		{
			for (int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
			{
				PlayerTypes eMinorLoop = (PlayerTypes)iMinorLoop;
				if (eMinorLoop != NO_PLAYER)
				{
					CvPlayer* pMinorLoop = &GET_PLAYER(eMinorLoop);
					if (pMinorLoop->isMinorCiv() && pMinorLoop->isAlive())
					{
						if (GET_TEAM(pMinorLoop->getTeam()).isHasMet(getTeam()))
						{
							pMinorLoop->GetMinorCivAI()->ChangeFriendshipWithMajor(GetID(), iInfluence, false);
						}
					}
				}
			}
		}

		//liberator gets XP with all of their units?
		int iNumXP = getExperienceForLiberation();
		if (iNumXP > 0)
		{
			doInstantYield(INSTANT_YIELD_TYPE_INSTANT, false, NO_GREATPERSON, NO_BUILDING, iNumXP, false, NO_PLAYER, NULL, false, getCapitalCity(), false, true, false, YIELD_JFD_SOVEREIGNTY);
			int iLoop;
			for (CvUnit* pLoopUnit = firstUnit(&iLoop); NULL != pLoopUnit; pLoopUnit = nextUnit(&iLoop))
			{
				if (pLoopUnit && pLoopUnit->IsCombatUnit())
				{
					pLoopUnit->changeExperienceTimes100(iNumXP * 100);
				}
			}
		}

		//liberated city gets a building?
		for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
		{
			if ((BuildingClassTypes)iI != NO_BUILDINGCLASS && getNumBuildingClassInLiberatedCities((BuildingClassTypes)iI) > 0)
			{
				CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo((BuildingClassTypes)iI);
				if (pkBuildingClassInfo)
				{
					BuildingTypes eBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(pkBuildingClassInfo->GetID())));
					if (eBuilding != NO_BUILDING)
					{
						pNewCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, getNumBuildingClassInLiberatedCities((BuildingClassTypes)iI));
					}
				}
			}
		}

		//liberated city gets units?
		int iNumUnit = getUnitsInLiberatedCities();
		if (iNumUnit > 0) 
		{
			for (int i = 0; i < iNumUnit; i++) 
			{
				UnitTypes eUnit = GC.getGame().GetCompetitiveSpawnUnitType(ePlayer, false, false, false, true, true);
				if (eUnit != NO_UNIT)
					GET_PLAYER(ePlayer).initUnit(eUnit, pNewCity->getX(), pNewCity->getY());
			}
		}
#endif
	}

	// Meet the team, if we haven't already
	if (!GET_TEAM(getTeam()).isHasMet(GET_PLAYER(ePlayer).getTeam()))
		GET_TEAM(getTeam()).makeHasMet(GET_PLAYER(ePlayer).getTeam(), true);

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (!GET_PLAYER(eLoopPlayer).isAlive())
			continue;

		GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->DoUpdateConquestStats();
	}

	// Update Proximity between the liberated player and all others
	GET_PLAYER(ePlayer).DoUpdateProximityToPlayers();

	// Update diplo stuff
	if (bAlive)
	{
		vector<PlayerTypes> v = GET_TEAM(getTeam()).getPlayers();
		pDiploAI->DoReevaluatePlayers(v, false, false);
	}
	else
	{
		vector<PlayerTypes> v = GET_PLAYER(ePlayer).GetDiplomacyAI()->GetAllValidMajorCivs();
		pDiploAI->DoReevaluatePlayers(v, false, false, true);
	}

	vector<PlayerTypes> v = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).getPlayers();
	GetDiplomacyAI()->DoReevaluatePlayers(v, false, false);

	if (MOD_EVENTS_LIBERATION) 
	{
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerLiberated, GetID(), ePlayer, pNewCity->GetID());
	}

	//Let's give the Embassies of the defeated player back to the liberated player
	if (GET_PLAYER(ePlayer).GetImprovementLeagueVotes() > 0)
	{
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			ePlayer = (PlayerTypes) iPlayerLoop;
			if (ePlayer != NO_PLAYER && GET_PLAYER(ePlayer).getTeam() == eConquerorTeam)
			{
				int iEmbassyVotes = GET_PLAYER(ePlayer).GetImprovementLeagueVotes();
				GET_PLAYER(ePlayer).ChangeImprovementLeagueVotes(-iEmbassyVotes);
			}
		}
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::CanLiberatePlayer(PlayerTypes ePlayer)
{
	// Other Player must be dead now
	if(GET_PLAYER(ePlayer).isAlive())
	{
		return false;
	}

	if(GET_PLAYER(ePlayer).IsEverConqueredBy(m_eID))
	{
		return false;
	}

	if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetKilledByTeam() == getTeam())
	{
		return false;
	}

	// No resurrection in always war games
	if (getTeam() != GET_PLAYER(ePlayer).getTeam())
	{
		if (GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR) || GC.getGame().isOption(GAMEOPTION_NO_CHANGING_WAR_PEACE))
		{
			return false;
		}
	}

	// Exploit fix - if we attacked a player we resurrected, we can't resurrect them again
	if (GET_PLAYER(ePlayer).GetDiplomacyAI()->IsResurrectorAttackedUs(m_eID))
	{
		return false;
	}
	
#if defined(MOD_EVENTS_LIBERATION)
	if (MOD_EVENTS_LIBERATION) {
		if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_PlayerCanLiberate, GetID(), ePlayer) == GAMEEVENTRETURN_FALSE) {
			return false;
		}
	}
#endif

	return true;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::CanLiberatePlayerCity(PlayerTypes ePlayer)
{
	if (!GET_PLAYER(ePlayer).isAlive())
	{
		return CanLiberatePlayer(ePlayer);
	}

	return IsAtPeaceWith(ePlayer);
}

//	--------------------------------------------------------------------------------
CvUnit* CvPlayer::initUnit(UnitTypes eUnit, int iX, int iY, UnitAITypes eUnitAI, UnitCreationReason eReason, bool bNoMove, bool bSetupGraphical, int iMapLayer /* = 0 */, int iNumGoodyHutsPopped, ContractTypes eContract, bool bHistoric, CvUnit* pPassUnit)
{
	CvAssertMsg(eUnit != NO_UNIT, "Unit is not assigned a valid value");
	if (eUnit == NO_UNIT)
		return NULL;

	CvUnitEntry* pkUnitDef = GC.getUnitInfo(eUnit);
	CvAssertFmt(pkUnitDef != NULL, "Trying to create unit of type %d, which does not exist", eUnit);
	if (pkUnitDef == NULL)
		return NULL;

	if (isMajorCiv() && pkUnitDef->IsMilitarySupport() && GetNumUnitsOutOfSupply() > 4 && eReason!=REASON_UPGRADE && eReason!=REASON_GIFT)
	{
		OutputDebugString("Creating unit over supply limit\n");
	}

	CvUnit* pUnit = addUnit();
	CvAssertMsg(pUnit != NULL, "Unit is not assigned a valid value");
	if(NULL != pUnit)
	{
		pUnit->init(pUnit->GetID(), eUnit, ((eUnitAI == NO_UNITAI) ? pkUnitDef->GetDefaultUnitAIType() : eUnitAI), GetID(), iX, iY, eReason, bNoMove, bSetupGraphical, iMapLayer, iNumGoodyHutsPopped, eContract, bHistoric, pPassUnit);

#if !defined(NO_TUTORIALS)
		// slewis - added for the tutorial
		if(pUnit->getUnitInfo().GetWorkRate() > 0 && pUnit->getUnitInfo().GetDomainType() == DOMAIN_LAND)
		{
			m_bEverTrainedBuilder = true;
		}
		// end added for the tutorial
#endif
	}

	m_kPlayerAchievements.AddUnit(pUnit);
	return pUnit;
}

CvUnit* CvPlayer::initUnitWithNameOffset(UnitTypes eUnit, int nameOffset, int iX, int iY, UnitAITypes eUnitAI, UnitCreationReason eReason, bool bNoMove, bool bSetupGraphical, int iMapLayer /* = 0 */, int iNumGoodyHutsPopped, ContractTypes eContract, bool bHistoric, CvUnit* pPassUnit)
{
	CvAssertMsg(eUnit != NO_UNIT, "Unit is not assigned a valid value");
	if (eUnit == NO_UNIT)
		return NULL;

	CvUnitEntry* pkUnitDef = GC.getUnitInfo(eUnit);
	CvAssertFmt(pkUnitDef != NULL, "Trying to create unit of type %d, which does not exist", eUnit);
	if (pkUnitDef == NULL)
		return NULL;

	CvUnit* pUnit = addUnit();
	CvAssertMsg(pUnit != NULL, "Unit is not assigned a valid value");
	if(NULL != pUnit)
	{
		pUnit->initWithNameOffset(pUnit->GetID(), eUnit, nameOffset, ((eUnitAI == NO_UNITAI) ? pkUnitDef->GetDefaultUnitAIType() : eUnitAI), GetID(), iX, iY, eReason, bNoMove, bSetupGraphical, iMapLayer, iNumGoodyHutsPopped, eContract, bHistoric, false, pPassUnit);

#if !defined(NO_TUTORIALS)
		// slewis - added for the tutorial
		if(pUnit->getUnitInfo().GetWorkRate() > 0 && pUnit->getUnitInfo().GetDomainType() == DOMAIN_LAND)
		{
			m_bEverTrainedBuilder = true;
		}
		// end added for the tutorial
#endif
	}

	m_kPlayerAchievements.AddUnit(pUnit);

	return pUnit;
}

//	--------------------------------------------------------------------------------
CvUnit* CvPlayer::initNamedUnit(UnitTypes eUnit, const char* strKey, int iX, int iY, UnitAITypes eUnitAI, UnitCreationReason eReason, bool bNoMove, bool bSetupGraphical, int iMapLayer /* = 0 */, int iNumGoodyHutsPopped)
{
	CvAssertMsg(eUnit != NO_UNIT, "Unit is not assigned a valid value");
	if (eUnit == NO_UNIT)
		return NULL;

	CvUnitEntry* pkUnitDef = GC.getUnitInfo(eUnit);
	CvAssertFmt(pkUnitDef != NULL, "Trying to create unit of type %d, which does not exist", eUnit);
	if (pkUnitDef == NULL)
		return NULL;

	if(strKey == NULL)
		return NULL;

	CvString strName = strKey;
	if(GC.getGame().isGreatPersonBorn(strName))
	{
		return NULL;
	}

	CvUnit* pUnit = addUnit();
	CvAssertMsg(pUnit != NULL, "Unit is not assigned a valid value");
	if (NULL != pUnit)
	{
		pUnit->initWithNameOffset(pUnit->GetID(), eUnit, -1, ((eUnitAI == NO_UNITAI) ? pkUnitDef->GetDefaultUnitAIType() : eUnitAI), GetID(), iX, iY, eReason, bNoMove, bSetupGraphical, iMapLayer, iNumGoodyHutsPopped, NO_CONTRACT, true, true);

#if !defined(NO_TUTORIALS)
		// slewis - added for the tutorial
		if (pUnit->getUnitInfo().GetWorkRate() > 0 && pUnit->getUnitInfo().GetDomainType() == DOMAIN_LAND)
		{
			m_bEverTrainedBuilder = true;
		}
		// end added for the tutorial
#endif

		pUnit->SetGreatWork(NO_GREAT_WORK);
#if !defined(MOD_GLOBAL_NO_LOST_GREATWORKS)
		int iUnitName = GC.getGame().getUnitCreatedCount(getUnitType());
		int iNumNames = pUnit->getUnitInfo().GetNumUnitNames();
		if (iUnitName < iNumNames)
#endif
		{
			if (strKey != NULL)
			{
				CvString strName = strKey;
				int iNumNames = pUnit->getUnitInfo().GetNumUnitNames();
				for (int iI = 0; iI < iNumNames; iI++)
				{
					CvString strOtherName = pUnit->getUnitInfo().GetUnitNames(iI);
					if (strOtherName == strName)
					{
						pUnit->setName(strName);
						pUnit->SetGreatWork(pUnit->getUnitInfo().GetGreatWorks(iI));
						GC.getGame().addGreatPersonBornName(strName);
#if defined(MOD_GLOBAL_NO_LOST_GREATWORKS)
						if (MOD_GLOBAL_NO_LOST_GREATWORKS)
						{
							// setName strips undesirable characters, but we stored those into the list of GPs born, so we need to keep the original name
							pUnit->setGreatName(strName);
						}
#endif
						break;
					}
				}
			}
		}
	}

	m_kPlayerAchievements.AddUnit(pUnit);

	return pUnit;
}

//	--------------------------------------------------------------------------------
void CvPlayer::disbandUnit(bool)
{
	CvUnit* pLoopUnit;
	CvUnit* pBestUnit;
	char szBuffer[1024];
	const size_t lenBuffer = 1024;
	int iValue;
	int iBestValue;
	int iLoop;

	iBestValue = INT_MAX;
	pBestUnit = NULL;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(!(pLoopUnit->hasCargo()))
		{
			if(!(pLoopUnit->isGoldenAge()))
			{
				if(pLoopUnit->getUnitInfo().GetProductionCost() > 0)
				{
					{
						iValue = (10000 + GC.getGame().getSmallFakeRandNum(1000, pLoopUnit->GetID() + iLoop));

						iValue += (pLoopUnit->getUnitInfo().GetProductionCost() * 5);
						iValue += (pLoopUnit->getExperienceTimes100() / 100 * 20);
						iValue += (pLoopUnit->getLevel() * 100);

						if(pLoopUnit->IsGarrisoned())
						{
							iValue *= 2;
						}

						if(pLoopUnit->plot()->getTeam() == pLoopUnit->getTeam())
						{
							iValue *= 3;
						}

						switch(pLoopUnit->AI_getUnitAIType())
						{
						case UNITAI_UNKNOWN:
							break;

						case UNITAI_SETTLE:
							iValue *= 20;
							break;

						case UNITAI_WORKER:
							iValue *= 10;
							break;

						case UNITAI_ATTACK:
						case UNITAI_CITY_BOMBARD:
						case UNITAI_FAST_ATTACK:
						case UNITAI_DEFENSE:
						case UNITAI_COUNTER:
							iValue *= 2;
							break;

						case UNITAI_RANGED:
						case UNITAI_CITY_SPECIAL:
						case UNITAI_PARADROP:
							iValue *= 6;
							break;

						case UNITAI_EXPLORE:
							iValue *= 15;
							break;

						case UNITAI_ARTIST:
						case UNITAI_SCIENTIST:
						case UNITAI_GENERAL:
						case UNITAI_MERCHANT:
						case UNITAI_DIPLOMAT:
						case UNITAI_MESSENGER:
						case UNITAI_ENGINEER:
						case UNITAI_SPACESHIP_PART:
						case UNITAI_TREASURE:
						case UNITAI_PROPHET:
						case UNITAI_MISSIONARY:
						case UNITAI_INQUISITOR:
						case UNITAI_ADMIRAL:
						case UNITAI_WRITER:
						case UNITAI_MUSICIAN:
							break;

						case UNITAI_ICBM:
							iValue *= 4;
							break;

						case UNITAI_WORKER_SEA:
							iValue *= 18;
							break;

						case UNITAI_ATTACK_SEA:
						case UNITAI_RESERVE_SEA:
						case UNITAI_ESCORT_SEA:
							break;

						case UNITAI_EXPLORE_SEA:
							iValue *= 25;
							break;

						case UNITAI_ASSAULT_SEA:
						case UNITAI_SETTLER_SEA:
						case UNITAI_CARRIER_SEA:
						case UNITAI_MISSILE_CARRIER_SEA:
							iValue *= 5;
							break;

						case UNITAI_PIRATE_SEA:
						case UNITAI_ATTACK_AIR:
							break;

						case UNITAI_DEFENSE_AIR:
						case UNITAI_CARRIER_AIR:
						case UNITAI_MISSILE_AIR:
							iValue *= 3;
							break;

						default:
							CvAssert(false);
							break;
						}

						if(pLoopUnit->getUnitInfo().GetExtraMaintenanceCost() > 0)
						{
							iValue /= (pLoopUnit->getUnitInfo().GetExtraMaintenanceCost() + 1);
						}

						if(iValue < iBestValue)
						{
							iBestValue = iValue;
							pBestUnit = pLoopUnit;
						}
					}
				}
			}
		}
	}

	if(pBestUnit != NULL)
	{
		if(GetID() == GC.getGame().getActivePlayer())
		{
			sprintf_s(szBuffer, lenBuffer, GetLocalizedText("TXT_KEY_MISC_UNIT_DISBANDED_NO_MONEY", pBestUnit->getNameKey()).GetCString());
			GC.GetEngineUserInterface()->AddUnitMessage(0, pBestUnit->GetIDInfo(), GetID(), false, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), szBuffer);//, "AS2D_UNITDISBANDED", MESSAGE_TYPE_MINOR_EVENT, pBestUnit->getUnitInfo().GetButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pBestUnit->getX(), pBestUnit->getY(), true, true);
		}

		CvAssert(!(pBestUnit->isGoldenAge()));

		pBestUnit->kill(false);
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::killUnits()
{
	//can't kill the units directly because that invalidates the iterator
	std::vector<int> unitsToKill;

	int iLoop;
	for(CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		unitsToKill.push_back(pLoopUnit->GetID());
	}

	//debugging ...
	for (std::vector<int>::iterator it = unitsToKill.begin(); it != unitsToKill.end(); ++it)
	{
		if (std::count(unitsToKill.begin(), unitsToKill.end(),*it)>1)
			OutputDebugString("inconsistent state: non-unique unit ID to kill!\n");
	}

	for (std::vector<int>::iterator it=unitsToKill.begin(); it!=unitsToKill.end(); ++it)
	{
		CvUnit* pLoopUnit = getUnit(*it);
		if (pLoopUnit)
			pLoopUnit->kill(false);
	}
}

//	--------------------------------------------------------------------------------
// Given a unit class, get the players specific unit of that class
UnitTypes CvPlayer::GetSpecificUnitType(const char* szUnitClass, bool hideAssert)
{
	UnitClassTypes eUnitClassType = (UnitClassTypes)GC.getInfoTypeForString(szUnitClass, hideAssert);
	return GetSpecificUnitType(eUnitClassType);
}

//	--------------------------------------------------------------------------------
// Given a unit class, get the players specific unit of that class
UnitTypes CvPlayer::GetSpecificUnitType(UnitClassTypes eUnitClassType) const
{
	UnitTypes eUnitType = NO_UNIT;

	if (eUnitClassType != NO_UNITCLASS)
	{
		const CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClassType);

		if (pkUnitClassInfo)
		{
			CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());

			if (pCivilizationInfo != NULL)
			{
				eUnitType = (UnitTypes)pCivilizationInfo->getCivilizationUnits(eUnitClassType);

				if (MOD_POLICIES_UNIT_CLASS_REPLACEMENTS && GetUnitClassReplacement(eUnitClassType) != NO_UNITCLASS && (UnitTypes)pkUnitClassInfo->getDefaultUnitIndex() == eUnitType)
				{
					eUnitType = (UnitTypes)pCivilizationInfo->getCivilizationUnits(GetUnitClassReplacement(eUnitClassType));
				}
			}
			else
			{
				eUnitType = (UnitTypes)pkUnitClassInfo->getDefaultUnitIndex();
			}
		}
	}

	return eUnitType;
}

//	--------------------------------------------------------------------------------
// Given a building class, get the players specific building of that class
BuildingTypes CvPlayer::GetSpecificBuildingType(const char* szBuildingClass, bool hideAssert)
{
	BuildingTypes eBuildingType = NO_BUILDING;
	BuildingClassTypes eBuildingClassType = (BuildingClassTypes) GC.getInfoTypeForString(szBuildingClass, hideAssert);

	const CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClassType);
	
	if (pkBuildingClassInfo)
	{
		CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
		
		if (pCivilizationInfo != NULL)
		{
			eBuildingType = (BuildingTypes) pCivilizationInfo->getCivilizationBuildings(eBuildingClassType);
		}
		else
		{
			eBuildingType = (BuildingTypes) pkBuildingClassInfo->getDefaultBuildingIndex();
		}
	}
	
	if (!isMinorCiv() && !isBarbarian()) {
		if (eBuildingType == NO_BUILDING) {
			CUSTOMLOG("GetSpecificBuildingType for player %s: %s is UNKNOWN!!!", getName(), szBuildingClass);
		} else {
			// CUSTOMLOG("GetSpecificBuildingType for player %s: %s is %s", getName(), szBuildingClass, GC.getBuildingInfo(eBuildingType)->GetType());
		}
	}

	return eBuildingType;
}

//	--------------------------------------------------------------------------------
CvPlot* CvPlayer::GetBestCoastalSpawnPlot (CvUnit *pUnit)
{
	CvPlot* pLargestWaterAreaPlot = NULL;
	int iLargestWaterSize = -1;

	// let's look at all our cities and find the largest ocean
	int iLoop;
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (!pLoopCity->isCoastal())
			continue;

		if (pUnit && !pUnit->canEndTurnAtPlot(pLoopCity->plot()))
			continue;

		CvLandmass* pLocalMax = pLoopCity->plot()->GetLargestAdjacentWater();
		if (pLocalMax && pLocalMax->getNumTiles()>iLargestWaterSize)
		{
			iLargestWaterSize = pLocalMax->getNumTiles();
			pLargestWaterAreaPlot = pLoopCity->plot();
		}
	}

	if (pLargestWaterAreaPlot)
		return pLargestWaterAreaPlot;
	else
		return pUnit ? pUnit->plot() : NULL;
}


//	--------------------------------------------------------------------------------
/// The number of Builders a player has
int CvPlayer::GetNumBuilders() const
{
	return m_iNumBuilders;
}

//	--------------------------------------------------------------------------------
/// Sets the number of Builders a player has
void CvPlayer::SetNumBuilders(int iNum)
{
	if(GetNumBuilders() != iNum)
	{
		m_iNumBuilders = iNum;
	}
}

//	--------------------------------------------------------------------------------
/// Changes the number of Builders a player has
void CvPlayer::ChangeNumBuilders(int iChange)
{
	if(iChange != 0)
	{
		SetNumBuilders(GetNumBuilders() + iChange);
	}
}


//	--------------------------------------------------------------------------------
/// The maximum number of Builders a player can Train
int CvPlayer::GetMaxNumBuilders() const
{
	return m_iMaxNumBuilders;
}

//	--------------------------------------------------------------------------------
/// Sets the maximum number of Builders a player can Train
void CvPlayer::SetMaxNumBuilders(int iNum)
{
	if(GetMaxNumBuilders() != iNum)
	{
		m_iMaxNumBuilders = iNum;
	}
}

//	--------------------------------------------------------------------------------
/// Changes the maximum number of Builders a player can Train
void CvPlayer::ChangeMaxNumBuilders(int iChange)
{
	if(iChange != 0)
	{
		SetMaxNumBuilders(GetMaxNumBuilders() + iChange);
	}
}


//	--------------------------------------------------------------------------------
/// Does this player have a living Settler unit?
bool CvPlayer::HasActiveSettler()
{
	int iLoop;
	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if (pLoopUnit->canFoundCity(NULL, true, true, true))
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
/// Returns number of Units a player has with a particular UnitAI.  The second argument allows you to check whether or not to include Units currently being trained in Cities.
int CvPlayer::GetNumUnitsWithUnitAI(UnitAITypes eUnitAIType, bool bIncludeBeingTrained, bool bIncludeWater)
{
	int iNumUnits = 0;
	int iLoop;

	// Current Units
	for(CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		// Don't include Water Units if we don't want them
		if(pLoopUnit->getDomainType() != DOMAIN_SEA || bIncludeWater)
		{
			if(pLoopUnit->AI_getUnitAIType() == eUnitAIType)
			{
				iNumUnits++;
			}
		}
	}

	// Units being trained now
	if(bIncludeBeingTrained)
	{
		for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity->isProductionUnit())
			{
				CvUnitEntry* pkUnitEntry = GC.getUnitInfo(pLoopCity->getProductionUnit());
				if(pkUnitEntry)
				{
					// Don't include Water Units if we don't want them
					if(pkUnitEntry->GetDomainType() != DOMAIN_SEA || bIncludeWater)
					{
						if(pkUnitEntry->GetDefaultUnitAIType() == eUnitAIType)
						{
							iNumUnits++;
						}
					}
				}
			}
		}
	}

	return iNumUnits;
}

//	--------------------------------------------------------------------------------
/// Returns number of Units a player has of a particular domain.  The second argument allows you to check whether or not to include civilians.
int CvPlayer::GetNumUnitsWithDomain(DomainTypes eDomain, bool bMilitaryOnly)
{
	int iNumUnits = 0;

	CvUnit* pLoopUnit;
	int iLoop;

	// Current Units
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->getDomainType() == eDomain)
		{
			if(!bMilitaryOnly || pLoopUnit->IsCombatUnit())
			{
				iNumUnits++;
			}
		}
	}

	return iNumUnits;
}

//	-----------------------------------------------------------------------------------------------
int CvPlayer::GetNumUnitsWithUnitCombat(UnitCombatTypes eUnitCombat)
{
	int iNumUnits = 0;

	CvUnit* pLoopUnit;
	int iLoop;

	// Current Units
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->getUnitCombatType() == eUnitCombat)
		{
			iNumUnits++;
		}
	}

	return iNumUnits;
}

//	-----------------------------------------------------------------------------------------------
int CvPlayer::GetNumUnitsOfType(UnitTypes eUnit, bool bIncludeBeingTrained)
{
	int iNumUnits = 0;
	int iLoop;

	// Current Units
	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if (pLoopUnit->getUnitType() == eUnit)
		{
			iNumUnits++;
		}
	}

	// Units being trained now
	if (bIncludeBeingTrained)
	{
		for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if (pLoopCity->isProductionUnit())
			{
				CvUnitEntry* pkUnitEntry = GC.getUnitInfo(pLoopCity->getProductionUnit());
				if (pkUnitEntry)
				{
					if (pLoopCity->getProductionUnit() == eUnit)
					{
						iNumUnits++;
					}
				}
			}
		}
	}

	return iNumUnits;
}

//	-----------------------------------------------------------------------------------------------
int CvPlayer::GetNumUnitPromotions(PromotionTypes ePromotion)
{
	int iNum = 0;

	CvUnit* pLoopUnit;
	int iLoop;

	// Current Units
	for (pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if (pLoopUnit->isHasPromotion(ePromotion))
		{
			iNum++;
		}
	}

	return iNum;
}

//	-----------------------------------------------------------------------------------------------
void CvPlayer::UpdateDangerPlots(bool bKeepKnownUnits)
{
	m_pDangerPlots->UpdateDanger(bKeepKnownUnits);
}

//	-----------------------------------------------------------------------------------------------
void CvPlayer::SetDangerPlotsDirty()
{
	m_pDangerPlots->SetDirty();
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isHuman() const
{
	if(GetID() == NO_PLAYER)
	{
		return false;
	}

	return CvPreGame::isHuman(GetID());
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isObserver() const
{
	if(GetID() == NO_PLAYER)
	{
		return false;
	}

	return CvPreGame::slotStatus(GetID()) == SS_OBSERVER;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isBarbarian() const
{
	return (GetID() == BARBARIAN_PLAYER);
}

//	-----------------------------------------------------------------------------------------------
const char* CvPlayer::getName() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->GetDescription();
	}

	if(GC.getGame().isMPOption(MPOPTION_ANONYMOUS) && isAlive() && GC.getGame().getGameState() == GAMESTATE_ON)
	{
		return getLeaderInfo().GetDescription();
	}

	if(GC.getGame().isGameMultiPlayer() && isHuman())
	{
		const CvString& szDisplayName = CvPreGame::nicknameDisplayed(GetID());
		if(szDisplayName.GetLength())
			return szDisplayName.c_str();
	}
	
	const CvString& szPlayerName = CvPreGame::leaderName(GetID());
	if(szPlayerName.GetLength() == 0)
	{
		return getLeaderInfo().GetDescription();
	}

	return szPlayerName.c_str();
}

//	-----------------------------------------------------------------------------------------------
const char* CvPlayer::getNameKey() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->GetTextKey();
	}

	if(GC.getGame().isMPOption(MPOPTION_ANONYMOUS) && isAlive())
	{
		return getLeaderInfo().GetTextKey();
	}

	if(GC.getGame().isGameMultiPlayer() && isHuman())
	{
		// No, this won't be a 'key', but it should just pass through the lookup code and display as is.
		const CvString& szDisplayName = CvPreGame::nicknameDisplayed(GetID());
		if(szDisplayName.GetLength())
			return szDisplayName.c_str();
	}

	const CvString& szPlayerName = CvPreGame::leaderNameKey(GetID());
	if(szPlayerName.GetLength() == 0)
	{
		return getLeaderInfo().GetTextKey();
	}

	return szPlayerName.c_str();
}


//	--------------------------------------------------------------------------------
const char* CvPlayer::getCivilizationDescription() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->GetDescription();
	}
	else if(CvPreGame::civilizationDescription(GetID()).GetLength() == 0)
	{
		return GC.getCivilizationInfo(getCivilizationType()) ? getCivilizationInfo().GetDescription() : "unknown";
	}
	else
	{
		return CvPreGame::civilizationDescription(GetID()).c_str();
	}
}


//	--------------------------------------------------------------------------------
const char* CvPlayer::getCivilizationDescriptionKey() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->GetTextKey();
	}
	else if(CvPreGame::civilizationDescriptionKey(GetID()).GetLength() == 0)
	{
		return GC.getCivilizationInfo(getCivilizationType()) ? getCivilizationInfo().GetTextKey() : "TXT_UNKNOWN";
	}
	else
	{
		return CvPreGame::civilizationDescriptionKey(GetID()).c_str();
	}
}


//	--------------------------------------------------------------------------------
const char* CvPlayer::getCivilizationShortDescription() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->getShortDescription();
	}
	else if(CvPreGame::civilizationShortDescription(GetID()).GetLength() == 0)
	{
		return GC.getCivilizationInfo(getCivilizationType()) ? getCivilizationInfo().getShortDescription() : "unknown";
	}
	else
	{
		return CvPreGame::civilizationShortDescription(GetID()).c_str();
	}
}


//	--------------------------------------------------------------------------------
const char* CvPlayer::getCivilizationShortDescriptionKey() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->getShortDescriptionKey();
	}
	else if(CvPreGame::civilizationShortDescriptionKey(GetID()).GetLength() == 0)
	{
		return GC.getCivilizationInfo(getCivilizationType()) ? getCivilizationInfo().getShortDescriptionKey() : "TXT_UNKNOWN";
	}
	else
	{
		return CvPreGame::civilizationShortDescriptionKey(GetID()).c_str();
	}
}


//	--------------------------------------------------------------------------------
const char* CvPlayer::getCivilizationAdjective() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->getAdjective();
	}
	else if(CvPreGame::civilizationAdjective(GetID()).GetLength() == 0)
	{
		return GC.getCivilizationInfo(getCivilizationType()) ? getCivilizationInfo().getAdjective() : "unknown";
	}
	else
	{
		return CvPreGame::civilizationAdjective(GetID()).c_str();
	}
}

//	--------------------------------------------------------------------------------
const char* CvPlayer::getCivilizationAdjectiveKey() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->getAdjectiveKeyWide();
	}
	else if(CvPreGame::civilizationAdjectiveKey(GetID()).GetLength() == 0)
	{
		return GC.getCivilizationInfo(getCivilizationType()) ? getCivilizationInfo().getAdjectiveKey() : "TXT_UNKNOWN";
	}
	else
	{
		return CvPreGame::civilizationAdjectiveKey(GetID()).c_str();
	}
}

//	--------------------------------------------------------------------------------
const char* CvPlayer::getCivilizationTypeKey() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->GetType();
	}
	else
	{
		return getCivilizationInfo().GetType();
	}
}

//	--------------------------------------------------------------------------------
const char* CvPlayer::getLeaderTypeKey() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->GetType();
	}
	else
	{
		return getLeaderInfo().GetType();
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isWhiteFlag() const
{
	return CvPreGame::isWhiteFlag(GetID());
}


//	--------------------------------------------------------------------------------
const char* CvPlayer::GetStateReligionName() const
{
	return GetLocalizedText(m_strReligionKey);
}

//	--------------------------------------------------------------------------------
CvString CvPlayer::GetStateReligionKey() const
{
	return m_strReligionKey;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetStateReligionKey(const char* strKey)
{
	m_strReligionKey = strKey;
}


//	--------------------------------------------------------------------------------
const CvString CvPlayer::getWorstEnemyName() const
{
	TeamTypes eWorstEnemy;

	eWorstEnemy = NO_TEAM;

	if(eWorstEnemy != NO_TEAM)
	{
		return GET_TEAM(eWorstEnemy).getName();
	}

	return "";
}


//	--------------------------------------------------------------------------------
ArtStyleTypes CvPlayer::getArtStyleType() const
{
	if(CvPreGame::artStyle(GetID()) == NO_ARTSTYLE)
	{
		return ((ArtStyleTypes)(getCivilizationInfo().getArtStyleType()));
	}
	else
	{
		return CvPreGame::artStyle(GetID());
	}
}

//	---------------------------------------------------------------------------
void CvPlayer::doTurn()
{
	// Time building of these maps

	CvAssertMsg(isAlive(), "isAlive is expected to be true");

	//cache reset
	m_iNumUnitsSuppliedCached = -1;
	m_bUnlockedGrowthAnywhereThisTurn = false;

	AI_doTurnPre();

	if(getCultureBombTimer() > 0)
		changeCultureBombTimer(-1);

	if(getConversionTimer() > 0)
		changeConversionTimer(-1);

	if(GetTurnsSinceSettledLastCity() >= 0)
		ChangeTurnsSinceSettledLastCity(1);

	setConscriptCount(0);
#if defined(MOD_BALANCE_CORE)
	DoVassalLevy();

	SetHasUUPeriod();

	if(MOD_BALANCE_CORE_JFD)
	{
		GetContracts()->DoTurn();
	}
	GET_TEAM(getTeam()).updateTeamStatus();
	UpdateBestMilitaryCities();
	
	if(GetFaithPurchaseCooldown() > 0)
	{
		ChangeFaithPurchaseCooldown(-1);
	}
	if (MOD_ABC_TRIGGER_CHANGE && !isHuman() && isMajorCiv() && getNumCities() > 0)
	{
		if (GC.getGame().getElapsedGameTurns() % 10 == 0)
		{
			DoDifficultyBonus(HISTORIC_EVENT_GA);
		}
	}

	if (!isBarbarian())
	{
		DoWarValueLostDecay();
		DoUpdateWarDamage();

		if (isMajorCiv())
		{
			GetDiplomacyAI()->SetEndedFriendshipThisTurn(false);
			GetDiplomacyAI()->SetUpdatedWarProgressThisTurn(false);
		}
	}

	if(MOD_BALANCE_CORE && !isMinorCiv() && !isBarbarian())
	{
		RefreshCSAlliesFriends();
		UpdateHappinessFromMinorCivs();
#endif
		DoUnitDiversity();
		DoUpdateCramped();

		DoUpdateUprisings();
		DoUpdateCityRevolts();
		CalculateNetHappiness();
		SetBestWonderCities();

		const CvCivilizationInfo& playerCivilizationInfo = GET_PLAYER(GetID()).getCivilizationInfo();
		for (int iI = 0; iI < GC.getNumUnitClassInfos(); ++iI)
		{
			const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
			CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
			if (pkUnitClassInfo != NULL)
			{
				const UnitTypes eUnit = ((UnitTypes)(playerCivilizationInfo.getCivilizationUnits(iI)));
				if (NO_UNIT != eUnit)
				{
					CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
#if defined(MOD_BALANCE_CORE_SETTLER_ADVANCED)
					if (pkUnitInfo != NULL && pkUnitInfo->IsFoundLate())
					{
						if (pkUnitInfo->IsFoodProduction())
						{
							setUnitExtraCost(eUnitClass, getNewCityProductionValue());
						}
					}
					else if (pkUnitInfo != NULL && pkUnitInfo->IsFoundMid())
					{
						if (pkUnitInfo->IsFoodProduction())
						{
							setUnitExtraCost(eUnitClass, getNewCityProductionValue());
						}
					}
					else
					{
#endif
						if (NULL != pkUnitInfo && pkUnitInfo->IsFound())
						{
							setUnitExtraCost(eUnitClass, getNewCityProductionValue());
						}
					}
				}
			}
		}

#if defined(MOD_BALANCE_CORE_HAPPINESS)
		if(MOD_BALANCE_CORE_HAPPINESS)
		{
			if(GC.getLogging() && GC.getAILogging())
			{
				CvString playerName;
				FILogFile* pLog;
				CvString strBaseString;
				CvString strOutBuf;
				CvString strFileName = "PlayerHappinessStats.csv";
				playerName = getCivilizationShortDescription();
				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				strBaseString += playerName + ", ";
				strOutBuf.Format("Approval: %d, GoldU: %d, DefenseU: %d, ScienceU: %d, CultureU: %d, War Weariness: %d, Supply: %d, Use: %d", 
					GetExcessHappiness() , GetUnhappinessFromCityGold(), GetUnhappinessFromCityDefense(), GetUnhappinessFromCityScience(), 
					GetUnhappinessFromCityCulture(), GetUnhappinessFromWarWeariness(), GetNumUnitsSupplied(), GetNumUnitsToSupply());
				strBaseString += strOutBuf;
				pLog->Msg(strBaseString);
			}
		}
#endif
#if defined(MOD_BALANCE_CORE)
		//Reset every turn for CS events.
		for(int iQuestLoop = 0; iQuestLoop < NUM_MINOR_CIV_QUEST_TYPES; iQuestLoop++)
		{
			SetGlobalTourismAlreadyReceived((MinorCivQuestTypes)iQuestLoop, 0);
		}

		GetCorporations()->DoTurn();
	
		//Reset for reevaluation of citystrategy AI
		countCitiesNeedingTerrainImprovements(true);
#endif
#if defined(MOD_BALANCE_CORE_AFRAID_ANNEX)
		if(MOD_BALANCE_CORE_AFRAID_ANNEX)
		{
			if(GetPlayerTraits()->IsBullyAnnex() && !IsEmpireVeryUnhappy() && !isHuman())
			{
				for(int iPlayerLoop = MAX_MAJOR_CIVS; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
				{
					PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
					if(GET_PLAYER(eLoopPlayer).isMinorCiv() && GET_PLAYER(eLoopPlayer).isAlive())
					{
						if(GET_PLAYER(eLoopPlayer).GetMinorCivAI()->CanMajorBullyUnit(GetID()))
						{
							GC.getGame().DoMinorBullyUnit(GetID(), eLoopPlayer);
						}
					}
				}
			}
		}
#endif
		if(GetPlayerTraits()->IsEndOfMayaLongCount())
		{
			ChangeNumMayaBoosts(1);
		}
#if defined(MOD_BALANCE_CORE)
		if(GetPlayerTraits()->IsTradeRouteMinorInfluenceAdmiralPoints())
		{
			DoTradeInfluenceAP();
		}
	}
#endif

	bool bHasActiveDiploRequest = false;
	if (isAlive() && isMajorCiv())
	{
		GetGrandStrategyAI()->DoTurn();
#if defined(MOD_ACTIVE_DIPLOMACY)
		if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
		{
			GetDiplomacyAI()->DoTurn(DIPLO_AI_PLAYERS);
		}
		else
		{
			if(GC.getGame().isHotSeat() && !isHuman())
			{
				// In Hotseat, AIs only do their diplomacy pass for other AIs on their turn
				// Diplomacy toward a human is done at the beginning of the humans turn.
				GetDiplomacyAI()->DoTurn(DIPLO_AI_PLAYERS);		// Do diplomacy for toward everyone
			}
			else
				GetDiplomacyAI()->DoTurn(DIPLO_ALL_PLAYERS);	// Do diplomacy for toward everyone

			if (!isHuman())
				bHasActiveDiploRequest = CvDiplomacyRequests::HasActiveDiploRequestWithHuman(GetID());
		}
#else
		if(GC.getGame().isHotSeat() && !isHuman())
		{
			// In Hotseat, AIs only do their diplomacy pass for other AIs on their turn
			// Diplomacy toward a human is done at the beginning of the humans turn.
			GetDiplomacyAI()->DoTurn(CvDiplomacyAI::DIPLO_AI_PLAYERS);		// Do diplomacy for toward everyone
		}
		else
			GetDiplomacyAI()->DoTurn(CvDiplomacyAI::DIPLO_ALL_PLAYERS);	// Do diplomacy for toward everyone

		if (!isHuman())
			bHasActiveDiploRequest = CvDiplomacyRequests::HasActiveDiploRequestWithHuman(GetID());
#endif
	}

#if defined(MOD_BALANCE_CORE)
	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
		if (eResourceLoop != NO_RESOURCE)
		{
			DoTestOverResourceNotification(eResourceLoop);
		}
	}
#endif

	if(isHuman() && !GC.getGame().isGameMultiPlayer())
		checkArmySizeAchievement();

	if( (bHasActiveDiploRequest || GC.GetEngineUserInterface()->isDiploActive()) && !GC.getGame().isGameMultiPlayer() && !isHuman())
	{
		GC.getGame().SetWaitingForBlockingInput(m_eID);
	}
	else
	{
#if defined(MOD_BALANCE_CORE)
		UpdateCityThreatCriteria();
#endif
		doTurnPostDiplomacy();
	}
	if (isAlive() && isMajorCiv())
	{
		GetTrade()->DoTurn();
	}
#if defined(MOD_BALANCE_CORE)
	if(MOD_BALANCE_CORE_JFD)
	{
		DoPiety();
		DoReformCooldown();
		DoGovernmentCooldown();
	}
#endif
#if defined(MOD_BALANCE_CORE_EVENTS)
	if(MOD_BALANCE_CORE_EVENTS)
	{
		if(GC.getGame().isOption(GAMEOPTION_EVENTS))
		{
			DoEvents();
		}
	}
	if (GetEspionage() != NULL)
		GetEspionage()->ProcessSpyFocus();

	updateYieldPerTurnHistory();
#endif
#if defined(MOD_BALANCE_CORE)
	for (int iInstantYield = 0; iInstantYield < NUM_INSTANT_YIELD_TYPES; iInstantYield++)
	{
		InstantYieldType eInstantYield = (InstantYieldType)iInstantYield;
		if(getInstantYieldText(eInstantYield) != "" && getInstantYieldText(eInstantYield) != NULL)
		{
			// Instant yield
			Localization::String strInstantYield = Localization::Lookup(getInstantYieldText(eInstantYield));
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_INSTANT_YIELD_EMPIRE");
				pNotifications->Add((NotificationTypes)FString::Hash("NOTIFICATION_INSTANT_YIELD"), strInstantYield.toUTF8(), strSummary.toUTF8(), -1, -1, GetID());
			}
			setInstantYieldText(eInstantYield, "");
			// Instant great person progress
			Localization::String strInstantGreatPersonProgress = Localization::Lookup(getInstantGreatPersonProgressText(eInstantYield));
			/*if (pNotifications) // Can't get this to work correctly for some reason
			{
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_GREAT_PERSON_PROGRESS_EMPIRE");
				pNotifications->Add((NotificationTypes)FString::Hash("NOTIFICATION_INSTANT_YIELD"), strInstantGreatPersonProgress.toUTF8(), strSummary.toUTF8(), -1, -1, GetID());
			}*/
			setInstantGreatPersonProgressText(eInstantYield, "");
		}
	}
#endif

	//note that this isn't actually the end of the turn - AI_unitUpdate is called later
	AI_doTurnPost();

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());

		bool bResult;
		LuaSupport::CallHook(pkScriptSystem, "PlayerDoTurn", args.get(), bResult);
	}

	// Certain counters update now
	DoUpdateWarPeaceTurnCounters();

	if (isMajorCiv())
	{
		DoMilitaryRatingDecay();
	}

	m_kPlayerAchievements.StartTurn();
}

//	--------------------------------------------------------------------------------
void CvPlayer::doTurnPostDiplomacy()
{
	CvGame& kGame = GC.getGame();

	if (isAlive())
	{
		UpdatePlots();
		UpdateAreaEffectUnits();
		UpdateAreaEffectPlots();
		UpdateDangerPlots(false);
		GetTacticalAI()->GetTacticalAnalysisMap()->Invalidate();
		UpdateMilitaryStats();
		GET_TEAM(getTeam()).ClearWarDeclarationCache();
		UpdateCurrentAndFutureWars();

		if (!isBarbarian())
		{
			GetEconomicAI()->DoTurn();
			GetMilitaryAI()->DoTurn();

			if (isMajorCiv())
			{
				GetReligionAI()->DoTurn();
				GetTradeAI()->DoTurn();
				GetCitySpecializationAI()->DoTurn();
				GetLeagueAI()->DoTurn();
			}
		}
		else
		{
			CvBarbarians::DoCampSpawnCounter();
			CvBarbarians::DoCamps();
			CvBarbarians::DoUnits();
			DoUpdateWarPeaceTurnCounters();
		}

		if(isMinorCiv())
		{
			GetMinorCivAI()->DoTurn();
		}
	}

	// Temporary boosts
	if (GetAttackBonusTurns() > 0)
	{
		ChangeAttackBonusTurns(-1);
	}
	if (GetCultureBonusTurns() > 0)
	{
		ChangeCultureBonusTurns(-1);
	}
	if (GetTourismBonusTurns() > 0)
	{
		ChangeTourismBonusTurns(-1);
	}
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes)iPlayerLoop;

		if (getTourismBonusTurnsPlayer(eLoopPlayer) > 0)
			changeTourismBonusTurnsPlayer(eLoopPlayer, -1);
	}

	if (GetCultureBonusTurnsConquest() > 0)
	{
		ChangeCultureBonusTurnsConquest(-1);
	}
	if (GetProductionBonusTurnsConquest() > 0)
	{
		ChangeProductionBonusTurnsConquest(-1);
	}

	if (isMajorCiv())
	{
		DoProcessVotes();
		ProcessLeagueResolutions();
	}

	if (MOD_BALANCE_CORE_YIELDS)
	{
		DoChangeGreatGeneralRate();
		DoChangeGreatAdmiralRate();
	}

	// Golden Age
	DoProcessGoldenAge();

	// Great People gifts from Allied City States (if we have that policy)
	DoGreatPeopleSpawnTurn();

	// Do turn for all Cities
	if (getNumCities() > 0)
	{
		int iLoop = 0;
		for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			pLoopCity->doTurn();
		}
	}

	// Gold
	GetTreasury()->DoGold();

	// Tax out from after we've calculated our gold for this turn
	GetTreasury()->CalculateExpensePerTurnFromVassalTaxes();

	// Culture

	// Prevent exploits in turn timed MP games - no accumulation of culture if player hasn't picked yet
	GetCulture()->SetLastTurnCPT(GetJONSCultureEverGenerated() - GetCulture()->GetLastTurnLifetimeCulture());
	GetCulture()->SetLastTurnLifetimeCulture(GetJONSCultureEverGenerated());
	if (kGame.isOption(GAMEOPTION_END_TURN_TIMER_ENABLED))
	{
		if (getJONSCulture() < getNextPolicyCost())
			changeJONSCulture(GetTotalJONSCulturePerTurn());
	}
	else
	{
		changeJONSCulture(GetTotalJONSCulturePerTurn());
	}

	// Compute the cost of policies for this turn
	DoUpdateNextPolicyCost();

	// if this is the human player, have the popup come up so that he can choose a new policy
	if(isAlive() && isHuman() && getNumCities() > 0)
	{
		if(!GC.GetEngineUserInterface()->IsPolicyNotificationSeen())
		{
			if(getNextPolicyCost() <= getJONSCulture() && GetPlayerPolicies()->GetNumPoliciesCanBeAdopted() > 0)
			{
				CvNotifications* pNotifications = GetNotifications();
				if(pNotifications)
				{
					CvString strBuffer;

					if(kGame.isOption(GAMEOPTION_POLICY_SAVING))
						strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_ENOUGH_CULTURE_FOR_POLICY_DISMISS");
					else
						strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_ENOUGH_CULTURE_FOR_POLICY");

					CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_ENOUGH_CULTURE_FOR_POLICY");
					pNotifications->Add(NOTIFICATION_POLICY, strBuffer, strSummary, -1, -1, -1);
				}
			}
		}

		if (GetPlayerPolicies()->IsTimeToChooseIdeology() && GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
		{
			if(GetPlayerTraits()->IsAdoptionFreeTech())
			{
				CvString strBuffer = GetLocalizedText("TXT_KEY_MISC_CHOSE_IDEOLOGY_UA_CHOOSE_TECH");
				chooseTech(1, strBuffer.GetCString());
			}

			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				CvString strBuffer;
				if (GetCurrentEra() > /*INDUSTRIAL IN CP, MODERN IN VP*/ GD_INT_GET(IDEOLOGY_START_ERA))
				{
					strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_CHOOSE_IDEOLOGY_ERA");
				}
				else
				{
					strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_CHOOSE_IDEOLOGY_FACTORIES");
				}
				CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_CHOOSE_IDEOLOGY");
				pNotifications->Add(NOTIFICATION_CHOOSE_IDEOLOGY, strBuffer, strSummary, -1, -1, GetID());
			}
		}
	}

	if (isAlive() && getNumCities() > 0 && !isHuman() && !isMinorCiv())
	{
		if (GetPlayerPolicies()->IsTimeToChooseIdeology() && GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
		{
			if(GetPlayerTraits()->IsAdoptionFreeTech())
			{
				AI_chooseFreeTech();
			}

			GetPlayerPolicies()->DoChooseIdeology();
		}
	}

	if (!isBarbarian() && !isHuman() && !isMinorCiv())
	{
		GetPlayerPolicies()->DoPolicyAI();
	}

	// Science
	doResearch();

	GetEspionage()->DoTurn();

	if (isMajorCiv())
	{
		// Faith
		CvGameReligions* pGameReligions = kGame.GetGameReligions();
		pGameReligions->DoPlayerTurn(*this);

		// Leagues
		CvGameLeagues* pGameLeagues = kGame.GetGameLeagues();
		pGameLeagues->DoPlayerTurn(*this);

		// Anarchy counter
		if(GetAnarchyNumTurns() > 0)
			ChangeAnarchyNumTurns(-1);
	}

	const int iGameTurn = kGame.getGameTurn();

	GatherPerTurnReplayStats(iGameTurn);

	GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
}

//	--------------------------------------------------------------------------------
void CvPlayer::doTurnUnits()
{
	AI_doTurnUnitsPre();

	// Start: old unit AI processing
	for(int iPass = 0; iPass < 4; iPass++)
	{
		int iLoop;
		for(CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		{
			switch(pLoopUnit->getDomainType())
			{
			case DOMAIN_AIR:
				if(iPass == 1)
				{
					pLoopUnit->doTurn();
				}
				break;
			case DOMAIN_SEA:
				if(iPass == 2)
				{
					pLoopUnit->doTurn();
				}
				break;
			case DOMAIN_LAND:
				if(iPass == 3)
				{
					pLoopUnit->doTurn();
				}
				break;
			case DOMAIN_IMMOBILE:
				if(iPass == 0)
				{
					pLoopUnit->doTurn();
				}
				break;
			case NO_DOMAIN:
				CvAssertMsg(false, "Unit with no Domain");
				break;
			default:
				if(iPass == 3)
				{
					pLoopUnit->doTurn();
				}
				break;
			}
		}
	}

	if(GetID() == GC.getGame().getActivePlayer())
	{
		GC.GetEngineUserInterface()->setDirty(Waypoints_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(SelectionButtons_DIRTY_BIT, true);
	}

	GC.GetEngineUserInterface()->setDirty(UnitInfo_DIRTY_BIT, true);

	AI_doTurnUnitsPost();
}

//	--------------------------------------------------------------------------------
/// Indicate that the AI has not processed any units yet
void CvPlayer::SetAllUnitsUnprocessed()
{
	int iLoop;
	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		pLoopUnit->SetTurnProcessed(false);

#if defined(MOD_CORE_PER_TURN_DAMAGE)
		pLoopUnit->flipDamageReceivedPerTurn();
#endif
	}

#if defined(MOD_CORE_PER_TURN_DAMAGE)
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->flipDamageReceivedPerTurn();
	}
#endif
}

//	--------------------------------------------------------------------------------
/// Units heal and then get their movement back
void CvPlayer::DoUnitReset()
{
	//some statistics
	static int tactMovesCount[NUM_AI_TACTICAL_MOVES] = { 0 };
	static int homeMovesCount[NUM_AI_HOMELAND_MOVES] = { 0 };

	int iLoop;
	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		// First heal the unit
		pLoopUnit->doHeal();

		//collect some stats
		gTactMovesCount[pLoopUnit->getTacticalMove()]++;
		gHomeMovesCount[pLoopUnit->getHomelandMove()]++;

		CvPlot* pUnitPlot = pLoopUnit->plot();

		// Sanity check
		if (pLoopUnit->IsGreatGeneral() && pLoopUnit->GetDanger() == INT_MAX && pUnitPlot->getNumUnits() == 1)
			OutputDebugString( CvString::format("ouch, general about to be captured at %d:%d!\n",pLoopUnit->getX(),pLoopUnit->getY()).c_str());

		// then damage it again
		int iCitadelDamage = pUnitPlot->GetDamageFromAdjacentPlots(pLoopUnit->getOwner());
		if (iCitadelDamage != 0 && !pLoopUnit->isInvisible(NO_TEAM, false, false))
		{
			
			pLoopUnit->changeDamage(iCitadelDamage, pUnitPlot->getOwner(), /*fAdditionalTextDelay*/ 0.5f);
#if defined(MOD_CORE_PER_TURN_DAMAGE)
			pLoopUnit->addDamageReceivedThisTurn(iCitadelDamage);
#endif
		}
		
		if (pUnitPlot->isDeepWater())
		{
			CvCity* pOwner = pUnitPlot->getEffectiveOwningCity();
			if (pOwner != NULL && GET_TEAM(pOwner->getTeam()).isAtWar(getTeam()))
			{
				int iTempDamage = pUnitPlot->getEffectiveOwningCity()->GetDeepWaterTileDamage();
				if (iTempDamage > 0)
				{
					pLoopUnit->changeDamage(iTempDamage, pUnitPlot->getOwner(), /*fAdditionalTextDelay*/ 0.5f);
#if defined(MOD_CORE_PER_TURN_DAMAGE)
					pLoopUnit->addDamageReceivedThisTurn(iTempDamage);
#endif
				}
			}
		}

		// Bonus for entrenched units
		if (!pLoopUnit->hasMoved() && pLoopUnit->canFortify(pLoopUnit->plot()))
			pLoopUnit->SetFortified(true);

		// Finally (now that healing is done), restore movement points
		pLoopUnit->restoreFullMoves();

		// Archaeologist can't move on turn he finishes a dig (while waiting for user to decide his next action)
		if (pLoopUnit->AI_getUnitAIType() == UNITAI_ARCHAEOLOGIST)
		{
			CvPlayer &kPlayer = GET_PLAYER(pLoopUnit->getOwner());
			if (kPlayer.GetCulture()->HasDigCompleteHere(pLoopUnit->plot()))
			{
				pLoopUnit->finishMoves();
			}
		}

		pLoopUnit->setMadeAttack(false);
		pLoopUnit->resetInterceptionCount();

		if(!isHuman())
		{
			const MissionData* pkMissionData = pLoopUnit->GetHeadMissionData();
			if(pkMissionData)
			{
				if(pkMissionData->eMissionType == CvTypes::getMISSION_RANGE_ATTACK() ||
				        pkMissionData->eMissionType == CvTypes::getMISSION_AIRSTRIKE() ||
				        pkMissionData->eMissionType == CvTypes::getMISSION_AIR_SWEEP() ||
				        pkMissionData->eMissionType == CvTypes::getMISSION_NUKE())
				{
					CvAssertMsg(0, "An AI unit has a combat mission queued at the end of its turn.");
					pLoopUnit->ClearMissionQueue();	// Clear the whole thing, the AI will re-evaluate next turn.
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Damage units from attrition (start of turn so we can get notifications)
void CvPlayer::DoUnitAttrition()
{
	int iLoop;
	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		pLoopUnit->DoAttrition();
}

//	--------------------------------------------------------------------------------
void CvPlayer::RepositionInvalidUnits()
{
	int iLoop;
	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if (!pLoopUnit->canEndTurnAtPlot(pLoopUnit->plot()))
		{
			if (!pLoopUnit->jumpToNearestValidPlot())
				pLoopUnit->kill(false);	// Could not find a valid location!
		}
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::updateYield()
{
	// This will go through all of the plots and update the yield if the player owns it.
	// The plot will not contribute to the player's yield unless it is worked by a city.
	// Previously this would just go through all the plots the city can work (3 rings around it)
	// but all plots have their yields updated on load and not updating them here could lead to 
	// a visual discrepancy.
	CvMap& kMap = GC.getMap();
	int iNumPlots = kMap.numPlots();
	PlayerTypes ePlayer = GetID();
	for (int iI = 0; iI < iNumPlots; iI++)
	{
		CvPlot* pkPlot = kMap.plotByIndexUnchecked(iI);
		if (pkPlot->getOwner() == ePlayer)
			pkPlot->updateYield();
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::updateExtraSpecialistYield()
{
	int iLoop;
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->updateExtraSpecialistYield();
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::updateCityPlotYield()
{
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->plot()->updateYield();
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::updateCitySight(bool bIncrement)
{
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->plot()->updateSight(bIncrement);
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::UpdateNotifications()
{
	if(GetNotifications())
	{
		GetNotifications()->Update();
	}

	if(GetDiplomacyRequests())
	{
		GetDiplomacyRequests()->Update();
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::UpdateReligion()
{
	CalculateNetHappiness();

	int iLoop;
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
		{
			YieldTypes eYield = (YieldTypes)iI;
			if(eYield == NO_YIELD)
				continue;

			pLoopCity->UpdateSpecialReligionYields(eYield);
		}
	}

	GetReligions()->UpdateStateReligion();
}

//	--------------------------------------------------------------------------------
void CvPlayer::updateTimers()
{
	int iLoop;
	m_endTurnBusyUnitUpdatesLeft--;

	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
		pLoopUnit->UpdateMission();

	//unit cleanup (two step approach because deleting a unit invalidates the iterator)
	std::vector<CvUnit*> unitsToDelete;
	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		if (pLoopUnit->isDelayedDeath())
			unitsToDelete.push_back(pLoopUnit);

	for (size_t i = 0; i < unitsToDelete.size(); i++)
		unitsToDelete[i]->doDelayedDeath();

#if defined(MOD_CORE_DELAYED_VISIBILITY)
	//force explicit visibility update for killed units (but not if the player is currently active) 
	if (!unitsToDelete.empty() && GetID()!=GC.getGame().getActivePlayer())
		for (int iI = 0; iI < GC.getMap().numPlots(); iI++)
			GC.getMap().plotByIndexUnchecked(iI)->flipVisibility(getTeam());
#endif

	GetDiplomacyAI()->update();
}

//	--------------------------------------------------------------------------------
bool CvPlayer::hasPromotableUnit() const
{
	const CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->isPromotionReady() && !pLoopUnit->isDelayedDeath())
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::hasReadyUnit() const
{
	const CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->ReadyToMove() && !pLoopUnit->isDelayedDeath() && !pLoopUnit->TurnProcessed())
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetCountReadyUnits() const
{
	int iRtnValue = 0;
	const CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->ReadyToMove() && !pLoopUnit->isDelayedDeath() && !pLoopUnit->TurnProcessed())
		{
			iRtnValue++;
		}
	}

	return iRtnValue;
}

//	--------------------------------------------------------------------------------
const CvUnit* CvPlayer::GetFirstReadyUnit() const
{
	int iLoop;
	for(const CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->ReadyToMove() && !pLoopUnit->isDelayedDeath() && !pLoopUnit->TurnProcessed())
		{
			return pLoopUnit;
		}
	}

	return NULL;
}

//	--------------------------------------------------------------------------------
void CvPlayer::EndTurnsForReadyUnits(bool bLinkedUnitsOnly)
{
	int iLoop;
	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if (!bLinkedUnitsOnly && pLoopUnit->ReadyToMove() && !pLoopUnit->isDelayedDeath() && !pLoopUnit->TurnProcessed())
		{
			pLoopUnit->PushMission(CvTypes::getMISSION_SKIP());
			pLoopUnit->SetTurnProcessed(true);

			if (GC.getLogging() && GC.getAILogging())
			{
				CvString strCiv = GET_PLAYER(pLoopUnit->getOwner()).getCivilizationAdjective();
				CvString strLogString;
				strLogString.Format("Warning: Forcing turn end for %s %s at %d,d", strCiv.c_str(), pLoopUnit->getName().c_str(), pLoopUnit->getX(), pLoopUnit->getY());
				GetHomelandAI()->LogHomelandMessage(strLogString);
			}
		}
		if (MOD_LINKED_MOVEMENT && bLinkedUnitsOnly && pLoopUnit->IsLinked() && !pLoopUnit->IsLinkedLeader())
		{
			if (pLoopUnit->canFortify(pLoopUnit->plot())) {
				pLoopUnit->PushMission(CvTypes::getMISSION_FORTIFY());
			}
			else {
				pLoopUnit->PushMission(CvTypes::getMISSION_SLEEP());
			}
		}
	}
}
//	--------------------------------------------------------------------------------
bool CvPlayer::hasAutoUnit() const
{
	int iLoop;
	for(const CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->ReadyToAuto())
		{
			return true;
		}
	}

	return false;
}

//	----------------------------------------------------------------------------
bool CvPlayer::hasBusyUnit() const
{
	int iLoop;
	for(const CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->IsBusy())
		{
			return true;
		}
	}

	return false;
}

//	----------------------------------------------------------------------------
bool CvPlayer::hasBusyCity() const
{
	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity->IsBusy())
		{
			return true;
		}
	}

	return false;
}

//	----------------------------------------------------------------------------
const CvCity* CvPlayer::getBusyCity() const
{
	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity->IsBusy())
		{
			return pLoopCity;
		}
	}

	return NULL;
}

//	----------------------------------------------------------------------------
bool CvPlayer::hasBusyUnitOrCity() const
{
	if(hasBusyUnit())
		return true;
	return hasBusyCity();
}

//	--------------------------------------------------------------------------------
const CvUnit* CvPlayer::getBusyUnit() const
{
	const CvUnit* result = NULL;
	int iLoop;
	for(const CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->IsBusy())
		{
			result = pLoopUnit;
		}
	}
	return result;
}


//	--------------------------------------------------------------------------------
void CvPlayer::chooseTech(int iDiscover, const char* strText, TechTypes iTechJustDiscovered)
{
	if(GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))
	{
		return;
	}

	if(iDiscover > 0)
	{
		SetNumFreeTechs(GetNumFreeTechs()+iDiscover);
	}

	if(iDiscover > 0)
	{
		CvNotifications* pNotifications = GetNotifications();
		if(pNotifications)
		{
			pNotifications->Add(NOTIFICATION_FREE_TECH, strText, strText, -1, -1, iDiscover, iTechJustDiscovered);
		}
	}
	else if(strText == 0 || strText[0] == 0)
	{
		CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_NEW_RESEARCH");
		CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_NEW_RESEARCH");
		CvNotifications* pNotifications = GetNotifications();
		if(pNotifications)
		{
			pNotifications->Add(NOTIFICATION_TECH, strBuffer, strSummary, -1, -1, iDiscover, iTechJustDiscovered);
		}
	}
	else
	{
		CvNotifications* pNotifications = GetNotifications();
		if(pNotifications)
		{
			pNotifications->Add(NOTIFICATION_TECH, strText, strText, -1, -1, iDiscover, iTechJustDiscovered);
		}
	}
}

//////////////////////////////////////////////////////////////////////////
// Civ 5 Score
//////////////////////////////////////////////////////////////////////////

//	--------------------------------------------------------------------------------
/// What is this player's score?
int CvPlayer::GetScore(bool bFinal, bool bWinner) const
{
	if(!isAlive())
		return 0;

	if(GET_TEAM(getTeam()).getNumMembers() == 0)
		return 0;

	int iScore = 0;

	iScore += GetScoreFromCities();
	iScore += GetScoreFromPopulation();
	iScore += GetScoreFromLand();
	iScore += GetScoreFromWonders();
	iScore += GetScoreFromPolicies();
	iScore += GetScoreFromGreatWorks();
	iScore += GetScoreFromReligion();
	iScore += GetScoreFromTechs();
	iScore += GetScoreFromVassals();

#if defined(MOD_BALANCE_CORE)
	iScore += GetScoreFromMinorAllies();
	iScore += GetScoreFromMilitarySize();
#endif
	iScore += GetScoreFromFutureTech();
	iScore += GetScoreFromScenario1();
	iScore += GetScoreFromScenario2();
	iScore += GetScoreFromScenario3();
	iScore += GetScoreFromScenario4();

	// If the game is over, we apply a mod to the value, rewarding players who finish early
	if(bFinal && bWinner)
	{
		int iGameProgressPercent = 100 * GC.getGame().getGameTurn() / GC.getGame().getEstimateEndTurn();
		iGameProgressPercent = iGameProgressPercent < 1 ? 1 : iGameProgressPercent;
		iScore *= 100;
		iScore /= iGameProgressPercent;
	}

	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from Cities: 10 per city (with mod for map size)
int CvPlayer::GetScoreFromCities() const
{
	int iScore = getNumCities() * /*8 in CP, 10 in VP*/ GD_INT_GET(SCORE_CITY_MULTIPLIER);

	iScore *= GC.getGame().GetMapScoreMod();
	iScore /= 100;

	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from Population: 6 per pop (with mod for map size)
int CvPlayer::GetScoreFromPopulation() const
{
	int iScore = getTotalPopulation() * /*4 in CP, 2 in VP*/ GD_INT_GET(SCORE_POPULATION_MULTIPLIER);

	iScore *= GC.getGame().GetMapScoreMod();
	iScore /= 100;

	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from Land: 6 per plot (with mod for map size)
int CvPlayer::GetScoreFromLand() const
{
	int iScore = getTotalLand() * /*1*/ GD_INT_GET(SCORE_LAND_MULTIPLIER);

	iScore *= GC.getGame().GetMapScoreMod();
	iScore /= 100;

	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from world wonders
int CvPlayer::GetScoreFromWonders() const
{
	int iScore = GetNumWonders() * /*25*/ GD_INT_GET(SCORE_WONDER_MULTIPLIER);
	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from policies
int CvPlayer::GetScoreFromPolicies() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_POLICIES))
	{
		return 0;
	}

	int iScore = GetPlayerPolicies()->GetNumPoliciesOwned() * /*4 in CP, 16 in VP*/ GD_INT_GET(SCORE_POLICY_MULTIPLIER);

	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from world wonders: 40 per
int CvPlayer::GetScoreFromGreatWorks() const
{
	int iScore = GetCulture()->GetNumGreatWorks() * /*4*/ GD_INT_GET(SCORE_GREAT_WORK_MULTIPLIER);
	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from world wonders: 40 per
int CvPlayer::GetScoreFromReligion() const
{
	if (GC.getGame().isOption(GAMEOPTION_NO_RELIGION))
		return 0;

	int iScore = 0;
	CvGameReligions *pGameReligions = GC.getGame().GetGameReligions();
	ReligionTypes eReligion = GetReligions()->GetOwnedReligion();
	if (eReligion > RELIGION_PANTHEON)
	{
		const CvReligion *pReligion = pGameReligions->GetReligion(eReligion, GetID());
		iScore += pReligion->m_Beliefs.GetNumBeliefs() * /*20 in CP, 5 in VP*/ GD_INT_GET(SCORE_BELIEF_MULTIPLIER);
		iScore += pGameReligions->GetNumCitiesFollowing(eReligion) * /*1 in CP, 3 in VP*/ GD_INT_GET(SCORE_RELIGION_CITIES_MULTIPLIER);
	}
	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from Tech: 4 per
int CvPlayer::GetScoreFromTechs() const
{
	if (GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))
		return 0;

	// Normally we recompute it each time
	int iScore = GET_TEAM(getTeam()).GetTeamTechs()->GetNumTechsKnown() * /*4 in CP, 6 in VP*/ GD_INT_GET(SCORE_TECH_MULTIPLIER);
	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from Future Tech: 10 per
int CvPlayer::GetScoreFromFutureTech() const
{
	if (GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))
		return 0;

	return m_iScoreFromFutureTech;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeScoreFromFutureTech(int iChange)
{
	m_iScoreFromFutureTech += iChange;
}

//	--------------------------------------------------------------------------------
// Score from scenario-specific items
int CvPlayer::GetScoreFromScenario1() const
{
	return m_iScenarioScore1;
}
void CvPlayer::ChangeScoreFromScenario1(int iChange)
{
	if(iChange != 0)
		m_iScenarioScore1 += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetScoreFromScenario2() const
{
	return m_iScenarioScore2;
}
void CvPlayer::ChangeScoreFromScenario2(int iChange)
{
	if(iChange != 0)
		m_iScenarioScore2 += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetScoreFromScenario3() const
{
	return m_iScenarioScore3;
}
void CvPlayer::ChangeScoreFromScenario3(int iChange)
{
	if(iChange != 0)
		m_iScenarioScore3 += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetScoreFromScenario4() const
{
	return m_iScenarioScore4;
}
void CvPlayer::ChangeScoreFromScenario4(int iChange)
{
	if(iChange != 0)
		m_iScenarioScore4 += iChange;
}

//////////////////////////////////////////////////////////////////////////
// End Civ 5 Score
//////////////////////////////////////////////////////////////////////////

//	--------------------------------------------------------------------------------
int CvPlayer::countCityFeatures(FeatureTypes eFeature, bool bReset) const
{
	if (bReset)
	{
		int iCount = 0;
		int iLoop = 0;

		for (const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			for (int iI = 0; iI < pLoopCity->GetNumWorkablePlots(); iI++)
			{
				const CvPlot* pLoopPlot = iterateRingPlots(pLoopCity->getX(), pLoopCity->getY(), iI);

				if (pLoopPlot && pLoopPlot->getFeatureType() == eFeature)
					iCount++;
			}
		}

		//const call hack
		GET_PLAYER(GetID()).setCityFeatures(eFeature, iCount);
	}

	return getCityFeatures(eFeature);
}

//	--------------------------------------------------------------------------------
int CvPlayer::countNumBuildingsInPuppets(BuildingTypes eBuilding, bool bReset) const
{
	if (bReset)
	{
		int iCount = 0;
		int iLoop = 0;

		for (const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if (!pLoopCity->IsPuppet())
				continue;

			if (pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
				iCount += pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding);
		}

		//const call hack
		GET_PLAYER(GetID()).setNumBuildingsInPuppets(eBuilding, iCount);
	}

	return getNumBuildingsInPuppets(eBuilding);
}

int CvPlayer::countNumBuildings(BuildingTypes eBuilding, bool bReset) const
{
	if(bReset)
	{
		int iCount = 0;
		int iLoop = 0;

		for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
			{
				iCount += pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding);
			}
		}

		//const call hack
		GET_PLAYER(GetID()).setNumBuildings(eBuilding, iCount);
	}

	return getNumBuildings(eBuilding);
}

//	--------------------------------------------------------------------------------
/// How many cities in the empire surrounded by features?
int CvPlayer::countCitiesNeedingTerrainImprovements(bool bReset) const
{
	if (bReset)
	{
		int iCount = 0;
		int iLoop = 0;

		for (const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			//what is a sensible threshold here?
			if (pLoopCity->GetTerrainImprovementNeed()>0)
				iCount++;
		}

		GET_PLAYER(GetID()).setCitiesNeedingTerrainImprovements(iCount);
	}

	return getCitiesNeedingTerrainImprovements();
}

void CvPlayer::setCityFeatures(FeatureTypes eFeature, int iValue)
{
	CvAssertMsg(eFeature >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFeature < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	
	m_piCityFeatures[eFeature] = iValue;
}
int CvPlayer::getCityFeatures(FeatureTypes eFeature) const
{
	CvAssertMsg(eFeature >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFeature < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	return m_piCityFeatures[eFeature];
}
void CvPlayer::setNumBuildings(BuildingTypes eBuilding, int iValue)
{
	CvAssertMsg(eBuilding >= 0, "eBuilding is expected to be non-negative (invalid Index)");
	CvAssertMsg(eBuilding < GC.getNumBuildingInfos(), "eBuilding is expected to be within maximum bounds (invalid Index)");

	m_piNumBuildings[eBuilding] = iValue;
}
int CvPlayer::getNumBuildings(BuildingTypes eBuilding) const
{
	CvAssertMsg(eBuilding >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eBuilding < GC.getNumBuildingInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	return m_piNumBuildings[eBuilding];
}

void CvPlayer::setNumBuildingsInPuppets(BuildingTypes eBuilding, int iValue)
{
	CvAssertMsg(eBuilding >= 0, "eBuilding is expected to be non-negative (invalid Index)");
	CvAssertMsg(eBuilding < GC.getNumBuildingInfos(), "eBuilding is expected to be within maximum bounds (invalid Index)");

	m_piNumBuildingsInPuppets[eBuilding] = iValue;
}
int CvPlayer::getNumBuildingsInPuppets(BuildingTypes eBuilding) const
{
	CvAssertMsg(eBuilding >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eBuilding < GC.getNumBuildingInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	return m_piNumBuildingsInPuppets[eBuilding];
}

void CvPlayer::setCitiesNeedingTerrainImprovements(int iValue)
{
	m_iCitiesNeedingTerrainImprovements = iValue;
}
int CvPlayer::getCitiesNeedingTerrainImprovements() const
{
	return m_iCitiesNeedingTerrainImprovements;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsCityConnectedToCity(CvCity* pCity1, CvCity* pCity2, RouteTypes eRestrictRoute, bool bIgnoreHarbors, SPath* pPathOut)
{
	if (!pCity1 || !pCity2)
		return false;

	return IsPlotConnectedToPlot(m_eID, pCity1->plot(), pCity2->plot(), eRestrictRoute, !bIgnoreHarbors, false, pPathOut);
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsCapitalConnectedToPlayer(PlayerTypes ePlayer)
{
	// everybody needs to be alive!
	if(!isAlive() || !(GET_PLAYER(ePlayer).isAlive()))
	{
		return false;
	}

	CvCity* pOtherPlayerCapital = GET_PLAYER(ePlayer).getCapitalCity();
	if(pOtherPlayerCapital == NULL)
	{
		return false;
	}

	CvCity* pPlayerCapital = getCapitalCity();
	if(pPlayerCapital == NULL)
	{
		return false;
	}

	return IsPlotConnectedToPlot(m_eID, pPlayerCapital->plot(), pOtherPlayerCapital->plot());
}

//	--------------------------------------------------------------------------------
void CvPlayer::findNewCapital()
{
	int iLoop;

	BuildingClassTypes eCapitalBuildingClass = (BuildingClassTypes)GD_INT_GET(CAPITAL_BUILDINGCLASS);
	BuildingTypes eCapitalBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(eCapitalBuildingClass)));
	bool bRome = GetPlayerTraits()->IsKeepConqueredBuildings();

	CvCity* pOldCapital = getCapitalCity();
	int iBestValue = 0;
	CvCity* pBestCity = NULL;

	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != pOldCapital)
		{
			if(0 == pLoopCity->GetCityBuildings()->GetNumRealBuilding(eCapitalBuilding) || ((MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome) && !HasBuildingClass(eCapitalBuildingClass)))
			{
				// First pass, exclude cities in resistance, puppets, and those burning to the ground
				if (!(pLoopCity->IsResistance() || pLoopCity->IsPuppet() || pLoopCity->IsRazing()))
				{
					int iValue = (pLoopCity->getPopulation() * 4);

					int iYieldValueTimes100 = pLoopCity->getYieldRateTimes100(YIELD_FOOD, false);
					iYieldValueTimes100 += (pLoopCity->getYieldRateTimes100(YIELD_PRODUCTION, false) * 3);
					iYieldValueTimes100 += (pLoopCity->getYieldRateTimes100(YIELD_GOLD, false) * 2);
					iValue += (iYieldValueTimes100 / 100);

					iValue += (pLoopCity->getNumGreatPeople() * 2);

					if (iValue > iBestValue)
					{
						iBestValue = iValue;
						pBestCity = pLoopCity;
					}
				}
			}
		}
	}

	if (pBestCity == NULL)
	{
		for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if (pLoopCity != pOldCapital)
			{
				if (0 == pLoopCity->GetCityBuildings()->GetNumRealBuilding(eCapitalBuilding) || ((MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome) && !HasBuildingClass(eCapitalBuildingClass)))
				{
					int iValue = 0;

					// Second pass, consider only those we ignored first time
					if (pLoopCity->IsResistance())
					{
						// We'll take a city in resistance (ie one we have decided to assimilate) over all others
						iValue = pLoopCity->getPopulation() + 500;
					}
					else if (pLoopCity->IsPuppet())
					{
						// We'll take a puppet city next, at least we're not burning it to the ground!
						iValue = pLoopCity->getPopulation() + 250;
					}
					else if (pLoopCity->IsRazing())
					{
						// Might be an idea to stop the burning!
						iValue = pLoopCity->getPopulation();
					}

					if (iValue > iBestValue)
					{
						iBestValue = iValue;
						pBestCity = pLoopCity;
					}
				}
			}
		}
	}

	if (pBestCity != NULL)
	{
		if (pOldCapital != NULL)
		{
			if (MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome)
			{
				if (pOldCapital->HasBuildingClass(eCapitalBuildingClass))
				{
					BuildingTypes eReplacedCapitalBuilding = pOldCapital->GetCityBuildings()->GetBuildingTypeFromClass(eCapitalBuildingClass);
					if (eReplacedCapitalBuilding != NO_BUILDING)
					{
						if (pOldCapital->GetCityBuildings()->GetNumRealBuilding(eReplacedCapitalBuilding) > 0)
						{
							int iProductionValue = pOldCapital->getProductionNeeded(eReplacedCapitalBuilding);
							doInstantYield(INSTANT_YIELD_TYPE_REFUND, false, NO_GREATPERSON, NO_BUILDING, iProductionValue, false, NO_PLAYER, NULL, false, pOldCapital);
							pOldCapital->GetCityBuildings()->SetNumRealBuilding(eReplacedCapitalBuilding, 0);
						}
					}
				}
			}
			else
			{
				if (pOldCapital->GetCityBuildings()->GetNumRealBuilding(eCapitalBuilding) > 0)
				{
					int iProductionValue = pOldCapital->getProductionNeeded(eCapitalBuilding);
					doInstantYield(INSTANT_YIELD_TYPE_REFUND, false, NO_GREATPERSON, NO_BUILDING, iProductionValue, false, NO_PLAYER, NULL, false, pOldCapital);
					pOldCapital->GetCityBuildings()->SetNumRealBuilding(eCapitalBuilding, 0);
				}
			}
		}
		CvAssertMsg(!(pBestCity->GetCityBuildings()->GetNumRealBuilding(eCapitalBuilding)), "(pBestCity->getNumRealBuilding(eCapitalBuilding)) did not return false as expected");
		pBestCity->GetCityBuildings()->SetNumRealBuilding(eCapitalBuilding, 1);

#if defined(MOD_BALANCE_CORE)
		for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
		{
			const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iI);
			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
			if (pkBuildingClassInfo)
			{
				int iNumFreeBuildings = GetNumCitiesFreeChosenBuilding(eBuildingClass);
				if (iNumFreeBuildings > 0 || IsFreeChosenBuildingNewCity(eBuildingClass) || IsFreeBuildingAllCity(eBuildingClass))
				{
					const BuildingTypes eBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(pkBuildingClassInfo->GetID())));
					if (NO_BUILDING != eBuilding)
					{
						CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
						if (pkBuildingInfo && pkBuildingInfo->IsCapitalOnly())
						{
							pBestCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, 1);
						}
					}
				}
			}
		}
#endif

#if defined(MOD_EVENTS_CITY_CAPITAL)
		if (MOD_EVENTS_CITY_CAPITAL) {
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_CapitalChanged, GetID(), pBestCity->GetID(), (pOldCapital ? pOldCapital->GetID() : -1));
		}
#endif

		if (pBestCity->IsPuppet())
		{
			gDLL->sendDoTask(pBestCity->GetID(), TASK_ANNEX_PUPPET, -1, -1, false, false, false, false);
		}
		else if (pBestCity->IsRazing() && !isHuman())
		{
			// For the AI, we'll stop burning our new capital!
			gDLL->sendDoTask(pBestCity->GetID(), TASK_UNRAZE, -1, -1, false, false, false, false);
		}

#if defined(MOD_GLOBAL_NO_CONQUERED_SPACESHIPS)
		if (MOD_GLOBAL_NO_CONQUERED_SPACESHIPS && !isMinorCiv() && !isBarbarian()) {
			// Rebuild the spaceship launch pad
			CvTeam& thisTeam = GET_TEAM(getTeam());

			if (thisTeam.getProjectCount((ProjectTypes)GD_INT_GET(SPACE_RACE_TRIGGER_PROJECT)) == 1) {
				if (isAlive()) {
					CUSTOMLOG("Rebuilding launch pad at (%i, %i)", pBestCity->getX(), pBestCity->getY());
					CvInterfacePtr<ICvPlot1> pDllPlot(new CvDllPlot(pBestCity->plot()));
					gDLL->GameplaySpaceshipEdited(pDllPlot.get(), 0x0001); // Display just the launch pad
				}
			}
		}
#endif
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canRaze(CvCity* pCity, bool bIgnoreCapitals) const
{
	if (GC.getGame().isOption(GAMEOPTION_NO_CITY_RAZING))
	{
		return false;
	}

	// If we don't own this city right now then we can't raze it!
	if (pCity->getOwner() != GetID())
	{
		return false;
	}

	// Humans cannot raze in a OCC game - it's destroyed instead
	if (GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && GET_PLAYER(pCity->getOwner()).isHuman())
	{
		return false;
	}

	// Can't raze a city that originally belonged to us
	if (pCity->getOriginalOwner() == GetID())
	{
		return false;
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(pCity->getOwner());
		args->Push(pCity->GetID());

		bool bResult = false;
		if(LuaSupport::CallTestAll(pkScriptSystem, "CanRazeOverride", args.get(), bResult))
		{
			// Check the result.
			if(bResult == true)
			{
				return true;
			}
		}
	}

	if (MOD_EVENTS_CITY_RAZING)
	{
		// Note the subtle difference between CanRazeOverride and PlayerCanRaze, the former needs everyone to agree, the latter anyone
		if (GAMEEVENTINVOKE_TESTANY(GAMEEVENT_PlayerCanRaze, pCity->getOwner(), pCity->GetID()) == GAMEEVENTRETURN_TRUE)
			return true;
	}

	// No razing of capitals
	CvPlayer* pOriginalOwner = &GET_PLAYER(pCity->getOriginalOwner());
	bool bOriginalCapital =	pCity->getX() == pOriginalOwner->GetOriginalCapitalX() &&
	                        pCity->getY() == pOriginalOwner->GetOriginalCapitalY();

	if(!bIgnoreCapitals && bOriginalCapital)
	{
		return false;
	}

	// No razing of Holy Cities
	if (pCity->GetCityReligions()->IsHolyCityAnyReligion())
	{
		return false;
	}

	if (!MOD_BALANCE_CORE_SETTLER_ADVANCED)
	{
		// No razing of cities with unique luxuries
		ResourceTypes eResource = pCity->plot()->getResourceType();
		if (eResource != NO_RESOURCE)
		{
			CvResourceInfo *pkResource = GC.getResourceInfo(eResource);
			if (pkResource && pkResource->GetRequiredCivilization() != NO_CIVILIZATION)
			{
				return false;
			}
		}
	}

	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(pCity->getOwner());
		args->Push(pCity->GetID());

		bool bResult = false;
		if(LuaSupport::CallTestAll(pkScriptSystem, "CanRaze", args.get(), bResult))
		{
			// Check the result.
			if(bResult == false)
			{
				return false;
			}
		}
	}

	return true;
}


//	--------------------------------------------------------------------------------
void CvPlayer::raze(CvCity* pCity)
{
	if (!pCity || !canRaze(pCity))
		return;

	char szBuffer[1024];
	const size_t lenBuffer = 1024;

	if (GetID() == GC.getGame().getActivePlayer())
	{
		sprintf_s(szBuffer, lenBuffer, GetLocalizedText("TXT_KEY_MISC_DESTROYED_CITY", pCity->getNameKey()).GetCString());
		GC.GetEngineUserInterface()->AddCityMessage(0, pCity->GetIDInfo(), GetID(), true, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), szBuffer);
	}

	for (int iI = 0; iI < MAX_PLAYERS; iI++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iI;
		if (ePlayer == GetID())
			continue;
		if (ePlayer != GC.getGame().getActivePlayer())
			continue;

		if (GET_PLAYER(ePlayer).isObserver() || (GET_PLAYER(ePlayer).isAlive() && pCity->isRevealed(GET_PLAYER(ePlayer).getTeam(), false, false)))
		{
			sprintf_s(szBuffer, lenBuffer, GetLocalizedText("TXT_KEY_MISC_CITY_HAS_BEEN_RAZED_BY", pCity->getNameKey(), getCivilizationDescriptionKey()).GetCString());
			GC.GetEngineUserInterface()->AddCityMessage(0, pCity->GetIDInfo(), ePlayer, false, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), szBuffer);
		}
	}

	sprintf_s(szBuffer, lenBuffer, GetLocalizedText("TXT_KEY_MISC_CITY_RAZED_BY", pCity->getNameKey(), getCivilizationShortDescriptionKey()).GetCString());
	GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, GetID(), szBuffer, pCity->getX(), pCity->getY());

	// Can't raze a puppet or "undetermined fate" city - must annex first
	if (pCity->IsPuppet() || pCity->IsIgnoreCityForHappiness())
		pCity->DoAnnex(true);

	int iPopulationDrop = 1;
	iPopulationDrop *= (100 + GetPlayerTraits()->GetRazeSpeedModifier() + GetRazingSpeedBonus());
	iPopulationDrop /= 100;

	int iTurnsToRaze = pCity->getPopulation();
	if (iPopulationDrop > 0)
	{
		iTurnsToRaze = (iTurnsToRaze + iPopulationDrop - 1) / iPopulationDrop;
	}

	pCity->ChangeRazingTurns(iTurnsToRaze);
	CalculateNetHappiness();

	// Update City UI
	if (GetID() == GC.getGame().getActivePlayer())
	{
		GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::unraze(CvCity* pCity)
{
	if (GetPlayerTraits()->IsUnableToCancelRazing())
		return;

	pCity->ChangeRazingTurns(-pCity->GetRazingTurns());
	pCity->DoAnnex();

	// Update City UI
	if (GetID() == GC.getGame().getActivePlayer())
	{
		GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::disband(CvCity* pCity)
{
	CvPlot* pPlot = pCity->plot();

	GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityRazed, GetID(), pPlot->getX(), pPlot->getY());

	if (getNumCities() == 1)
	{
		setFoundedFirstCity(false);
	}

	// Remove Holy City status!
	if (pCity->GetCityReligions()->IsHolyCityAnyReligion())
	{
		GC.getGame().GetGameReligions()->SetHolyCity(pCity->GetCityReligions()->GetReligionForHolyCity(), NULL);
	}

	GC.getGame().addDestroyedCityName(pCity->getNameKey());

	for (int eBuildingType = 0; eBuildingType < GC.getNumBuildingInfos(); eBuildingType++)
	{
		CvBuildingEntry* buildingInfo = GC.getBuildingInfo((BuildingTypes) eBuildingType);
		if (buildingInfo)
		{
			// if this building exists
			int iExists = pCity->GetCityBuildings()->GetNumRealBuilding((BuildingTypes) eBuildingType);
			int iPreferredPosition = buildingInfo->GetPreferredDisplayPosition();
			if (iPreferredPosition > 0)
			{
				CvInterfacePtr<ICvCity1> pDllCity(new CvDllCity(pCity));

				if (iExists > 0)
				{
					// kill the wonder
					GC.GetEngineUserInterface()->AddDeferredWonderCommand(WONDER_REMOVED, pDllCity.get(), (BuildingTypes) eBuildingType, 0);
				}
				else
				{
					// else if we are currently in the process of building this wonder
					if (pCity->getProductionBuilding() == eBuildingType)
					{
						// kill the half built wonder
						if (isWorldWonderClass(buildingInfo->GetBuildingClassInfo()))
						{
							GC.GetEngineUserInterface()->AddDeferredWonderCommand(WONDER_REMOVED, pDllCity.get(), (BuildingTypes) eBuildingType, 0);
						}
					}
				}
			}
		}
	}

	{
		CvInterfacePtr<ICvCity1> pkDllCity(new CvDllCity(pCity));
		gDLL->GameplayCitySetDamage(pkDllCity.get(), 0, pCity->getDamage());
		gDLL->GameplayCityDestroyed(pkDllCity.get(), NO_PLAYER);
	}

	pCity->kill();

	// Update Proximity between this Player and all others
	DoUpdateProximityToPlayers();

	if (pPlot)
	{
		pPlot->SetPlayerThatDestroyedCityHere(GetID());
		IDInfoVector currentUnits;
		if (pPlot->getUnits(&currentUnits) > 0)
		{
			for (IDInfoVector::const_iterator itr = currentUnits.begin(); itr != currentUnits.end(); ++itr)
			{
				CvUnit* pUnit = ::GetPlayerUnit(*itr);

				if (pUnit && !pUnit->canEndTurnAtPlot(pPlot))
				{
					if (!pUnit->jumpToNearestValidPlot())
						pUnit->kill(false);
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Is a Particular Goody ID a valid Goody for a certain plot?
bool CvPlayer::canReceiveGoody(CvPlot* pPlot, GoodyTypes eGoody, CvUnit* pUnit) const
{
	CvCity* pCity;
	UnitTypes eUnit;
	bool bTechFound;
	int iI;

	Database::SingleResult kResult;
	CvGoodyInfo kGoodyInfo;
	const bool bResult = DB.SelectAt(kResult, "GoodyHuts", eGoody);
	DEBUG_VARIABLE(bResult);
	CvAssertMsg(bResult, "Cannot find goody info.");
	kGoodyInfo.CacheResult(kResult);

#if defined(MOD_EVENTS_GOODY_CHOICE)
	if (MOD_EVENTS_GOODY_CHOICE) {
		bool bPick = (pUnit && pUnit->isHasPromotion((PromotionTypes)GD_INT_GET(PROMOTION_GOODY_HUT_PICKER)));
		int iUnit = pUnit ? pUnit->GetID() : -1;
		if (GAMEEVENTINVOKE_TESTANY(GAMEEVENT_GoodyHutCanNotReceive, GetID(), iUnit, eGoody, bPick) == GAMEEVENTRETURN_TRUE) {
			return false;
		}
	}
#endif

	if (!CvGoodyHuts::IsCanPlayerReceiveGoody(GetID(), eGoody))
	{
		return false;
	}

	// No XP in first 10 turns
	if (kGoodyInfo.getExperience() > 0)
	{
		if ((pUnit == NULL) || !(pUnit->canAcquirePromotionAny()) || (GC.getGame().getElapsedGameTurns() < 10))
		{
			return false;
		}

		if (MOD_BALANCE_CORE && pUnit->IsGainsXPFromScouting())
		{
			return false;
		}
	}

	// Unit Healing
	if (kGoodyInfo.getDamagePrereq() > 0)
	{
		if ((pUnit == NULL) || (pUnit->getDamage() < ((pUnit->GetMaxHitPoints() * kGoodyInfo.getDamagePrereq()) / 100)))
		{
			return false;
		}
	}

	// Faith towards pantheon or Great Prophet
	if (kGoodyInfo.isPantheonFaith() || kGoodyInfo.getProphetPercent() > 0)
	{
		if (GC.getGame().isOption(GAMEOPTION_NO_RELIGION))
			return false;

		if (GC.getGame().getElapsedGameTurns() < 20)
			return false;

		if (GetReligions()->HasCreatedReligion())
			return false;

		if (GC.getGame().GetGameReligions()->GetNumReligionsStillToFound() <= 0 && !GetPlayerTraits()->IsAlwaysReligion())
			return false;

		if (kGoodyInfo.isPantheonFaith() && GC.getGame().GetGameReligions()->GetNumReligionsFounded() > 0)
			return false;

		return kGoodyInfo.isPantheonFaith() ? !GetReligions()->HasCreatedPantheon() : GetReligions()->HasCreatedPantheon();
	}

	// Population
	if (kGoodyInfo.getPopulation() > 0)
	{
		if (getNumCities() == 0)
			return false;

		// Don't give more Population if we're already unhappy
		if (IsEmpireUnhappy())
			return false;
	}

	// Production
	if (kGoodyInfo.getProduction() > 0)
	{
		if (!MOD_BALANCE_CORE)
			return false;

		if (getNumCities() == 0)
			return false;
	}

	//Golden Age
	if (kGoodyInfo.getGoldenAge() > 0)
	{
		if (!MOD_BALANCE_CORE)
			return false;

		if (GetNumGoldenAges() > 0)
			return false;

		if (GC.getGame().getElapsedGameTurns() < 30)
			return false;
	}

	//Free Tiles
	if (kGoodyInfo.getFreeTiles() > 0)
	{
		if (!MOD_BALANCE_CORE)
			return false;

		if (pPlot == NULL)
			return false;

		if (getNumCities() == 0)
			return false;
	}

	// Science
	if (kGoodyInfo.getScience() > 0)
	{
		if (!MOD_BALANCE_CORE)
			return false;

		if (GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))
			return false;
	}

	// New Goodies modmod
	if (MOD_NEW_GOODIES && (kGoodyInfo.getFood() > 0 || kGoodyInfo.getBorderGrowth() > 0))
	{
		if (getNumCities() == 0)
			return false;
	}

	// Map
	if (kGoodyInfo.getMapRange() > 0 && kGoodyInfo.getMapOffset() > 0)
	{
		if (pPlot == NULL)
			return false;

		if (pUnit == NULL)
			return false;

		if (MOD_BALANCE_CORE && !pUnit->IsGainsXPFromScouting())
			return false;

		bool bGood = false;
		int iOffset = kGoodyInfo.getMapOffset();
		int iDX, iDY;
		for(iDX = -(iOffset); iDX <= iOffset; iDX++)
		{
			for(iDY = -(iOffset); iDY <= iOffset; iDY++)
			{
				CvPlot* pLoopPlot = plotXYWithRangeCheck(pPlot->getX(), pPlot->getY(), iDX, iDY, iOffset);

				if(pLoopPlot != NULL)
				{
					if(!(pLoopPlot->isRevealed(getTeam())))
					{
						if(pLoopPlot->isCity() && pLoopPlot->getOwner() != GetID() && pLoopPlot->getOwner() != NO_PLAYER)
						{
							bGood = true;
							break;
						}
					}
				}
			}
		}
		if(!bGood)
		{
			return false;
		}
	}

	// Reveal Nearby Barbs
	if(kGoodyInfo.getRevealNearbyBarbariansRange() > 0)
	{
		int iDX, iDY;
		int iBarbCampDistance = kGoodyInfo.getRevealNearbyBarbariansRange();
		CvPlot* pNearbyPlot;

		int iNumCampsFound = 0;

		ImprovementTypes barbCampType = (ImprovementTypes) GD_INT_GET(BARBARIAN_CAMP_IMPROVEMENT);

		// Look at nearby Plots to make sure another camp isn't too close
		for(iDX = -(iBarbCampDistance); iDX <= iBarbCampDistance; iDX++)
		{
			for(iDY = -(iBarbCampDistance); iDY <= iBarbCampDistance; iDY++)
			{
				pNearbyPlot = plotXY(pPlot->getX(), pPlot->getY(), iDX, iDY);

				if(pNearbyPlot != NULL)
				{
					if(plotDistance(pNearbyPlot->getX(), pNearbyPlot->getY(), pPlot->getX(), pPlot->getY()) <= iBarbCampDistance)
					{
						if(pNearbyPlot->getImprovementType() == barbCampType)
						{
							iNumCampsFound++;
						}
					}
				}
			}
		}

		// Needs to be at least 2 nearby Camps
		if(iNumCampsFound < 2)
		{
			return false;
		}
	}

	// Reveal Unknown Resource
	if (kGoodyInfo.isRevealUnknownResource())
	{
		CvCity* pCapital = getCapitalCity();

		// Can't get this if you have no Capital City
		if (!pCapital)
			return false;

		ResourceClassTypes eResourceClassBonus = (ResourceClassTypes) GC.getInfoTypeForString("RESOURCECLASS_BONUS");
		bool bPlayerDoesntKnowOfResource = false;

		// Look at Resources on all Plots
		for (int iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)
		{
			CvPlot* pResourcePlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);
			ResourceTypes eResource = pResourcePlot->getResourceType();

			if (eResource != NO_RESOURCE)
			{
				CvResourceInfo& pResource = *GC.getResourceInfo(eResource);

				// No "Bonus" Resources (that only give Yields), because those are lame to get from a Hut
				if (pResource.getResourceClassType() != eResourceClassBonus)
				{
					// Can't be on a Plot that we've already force-revealed!
					if (!pResourcePlot->IsResourceForceReveal(getTeam()))
					{
						// Must be a Resource we don't already see
						if (!GET_TEAM(getTeam()).IsResourceRevealed(eResource))
						{
							int iResourceDistance = plotDistance(pResourcePlot->getX(), pResourcePlot->getY(), pCapital->getX(), pCapital->getY());

							// Must be within 10 plots of our Capital
							if (iResourceDistance <= 10)
							{
								bPlayerDoesntKnowOfResource = true;
								break;
							}
						}
					}
				}
			}
		}

		// If the player already knows where all the Resources are then there's no point in this Goody
		if (!bPlayerDoesntKnowOfResource)
		{
			return false;
		}
	}

	// Unit Upgrade
	if(kGoodyInfo.isUpgradeUnit())
	{
		if(pUnit == NULL)
		{
			return false;
		}

		if(pUnit->IsHasBeenPromotedFromGoody())
		{
			return false;
		}

		UnitClassTypes eUpgradeUnitClass = (UnitClassTypes) GC.getUnitInfo(pUnit->getUnitType())->GetGoodyHutUpgradeUnitClass();

		if(eUpgradeUnitClass == NO_UNITCLASS)
		{
			return false;
		}

		UnitTypes eUpgradeUnit = GetSpecificUnitType(eUpgradeUnitClass);

		if(eUpgradeUnit == NO_UNIT)
		{
			return false;
		}
	}

	// Tech
	if (kGoodyInfo.isTech())
	{
		if (GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))
			return false;

		bTechFound = false;

		for (iI = 0; iI < GC.getNumTechInfos(); iI++)
		{
			const TechTypes eTech = static_cast<TechTypes>(iI);
			CvTechEntry* pkTech = GC.getTechInfo(eTech);
			if (pkTech != NULL && pkTech->IsGoodyTech() && GetPlayerTechs()->CanResearch(eTech))
			{
				if (!MOD_BALANCE_CORE || GetPlayerTechs()->GetCurrentResearch() != eTech)
				{
					bool bUseTech = true;
					ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
					if (pkScriptSystem) 
					{
						CvLuaArgsHandle args;
						args->Push(GetID());
						args->Push(eTech);

						// Attempt to execute the game events.
						// Will return false if there are no registered listeners.
						bool bScriptResult = false;
						if (LuaSupport::CallTestAll(pkScriptSystem, "GoodyHutCanResearch", args.get(), bScriptResult)) 
						{
							bUseTech = bResult;
						}
					}

					if (bUseTech)
					{
						bTechFound = true;
					}
					break;
				}
			}
		}

		if (!bTechFound)
		{
			return false;
		}
	}

	///////////////////////////////////////
	///////////////////////////////////////
	// Bad Goodies follow beneath this line
	///////////////////////////////////////
	///////////////////////////////////////

	if(kGoodyInfo.isBad())
	{
		if((pUnit == NULL) || pUnit->isNoBadGoodies())
		{
			return false;
		}
	}

	if(kGoodyInfo.getUnitClassType() != NO_UNITCLASS)
	{
		eUnit = GetSpecificUnitType((UnitClassTypes)kGoodyInfo.getUnitClassType());

		if(eUnit == NO_UNIT)
		{
			return false;
		}

		CvUnitEntry* pUnitInfo = GC.getUnitInfo(eUnit);
		if(pUnitInfo == NULL)
		{
			return false;
		}

		// No combat units in MP in the first 20 turns
		if(pUnitInfo->GetCombat() > 0)
		{
			if(GC.getGame().isGameMultiPlayer() || (GC.getGame().getElapsedGameTurns() < 20))
			{
				return false;
			}
		}

		// Builders
		if(pUnitInfo->GetWorkRate() > 0)
		{
			// Max limit
			if(GetMaxNumBuilders() > -1 && GetNumBuilders() >= GetMaxNumBuilders())
			{
				return false;
			}

			bool bHasTechWhichUnlocksImprovement = false;

			// Need a tech which unlocks something to do
			int iNumTechInfos = GC.getNumTechInfos();
			int iNumBuildInfos = GC.getNumBuildInfos();
			for(int iTechLoop = 0; iTechLoop < iNumTechInfos; iTechLoop++)
			{
				if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes) iTechLoop))
				{
					// Look at Builds
					for(int iBuildLoop = 0; iBuildLoop < iNumBuildInfos; iBuildLoop++)
					{
						CvBuildInfo* pkBuildInfo = GC.getBuildInfo((BuildTypes) iBuildLoop);
						if(!pkBuildInfo)
						{
							continue;
						}
						if(pkBuildInfo->getTechPrereq() == (TechTypes) iTechLoop)
						{
							if(pkBuildInfo->getImprovement() != NO_IMPROVEMENT || pkBuildInfo->getRoute() != NO_ROUTE)
							{
								bHasTechWhichUnlocksImprovement = true;
								break;
							}
						}
					}
				}
				// Already found something
				if(bHasTechWhichUnlocksImprovement)
				{
					break;
				}
			}

			// Player doesn't have any Tech which allows Improvements
			if(!bHasTechWhichUnlocksImprovement)
			{
				return false;
			}
		}

		// OCC games - no Settlers
		if(GetPlayerTraits()->IsNoAnnexing() || (GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && isHuman()))
		{
			if(pUnitInfo->IsFound() || pUnitInfo->IsFoundAbroad())
			{
				return false;
			}
		}
	}

	// Barbarians
	if(kGoodyInfo.getBarbarianUnitClass() != NO_UNITCLASS)
	{
		if(GC.getGame().isOption(GAMEOPTION_NO_BARBARIANS))
		{
			return false;
		}

		if(getNumCities() == 0)
		{
			return false;
		}

		if(getNumCities() == 1)
		{
			pCity = GC.getMap().findCity(pPlot->getX(), pPlot->getY(), NO_PLAYER, getTeam());

			if(pCity != NULL)
			{
				if(plotDistance(pPlot->getX(), pPlot->getY(), pCity->getX(), pCity->getY()) <= (8 - getNumCities()))
				{
					return false;
				}
			}
		}
	}

	return true;
}


//	--------------------------------------------------------------------------------
void CvPlayer::receiveGoody(CvPlot* pPlot, GoodyTypes eGoody, CvUnit* pUnit)
{
	CvPlot* pLoopPlot;
	CvPlot* pBestPlot = NULL;
	CvString strBuffer;
	CvString strTempBuffer;
	TechTypes eBestTech;
	UnitTypes eUnit;
	int iOffset;
	int iRange;
	int iBarbCount;
	int iValue;
	int iBestValue;
	int iPass;
	int iDX, iDY;
	int iI;

	CvAssertMsg(canReceiveGoody(pPlot, eGoody, pUnit), "Instance is expected to be able to receive goody");

	// Wishing we had lambdas right about now
	struct BestCityFinder
	{
		CvCity* operator()(CvPlayer& kPlayer, const CvPlot& kPlot)
		{
			int iBestCityDistance = 0;
			bool bBestCityIsProductive = false;
			CvCity* pBestCity = NULL;

			int iLoop;
			for (CvCity* pLoopCity = kPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kPlayer.nextCity(&iLoop))
			{
				bool bCityIsProductive = !(pLoopCity->IsResistance() || pLoopCity->IsRazing());

				// Only select unproductive cities if we also have no productive cities
				if (bBestCityIsProductive && !bCityIsProductive)
					continue;

				// Prefer cities nearest the plot
				int iDistance = plotDistance(kPlot.getX(), kPlot.getY(), pLoopCity->getX(), pLoopCity->getY());

				if (pBestCity == NULL || iDistance < iBestCityDistance || (!bBestCityIsProductive && bCityIsProductive))
				{
					iBestCityDistance = iDistance;
					bBestCityIsProductive = bCityIsProductive;
					pBestCity = pLoopCity;
				}
			}

			return pBestCity;
		}
	} bestCityFinder;

	struct GoodyValueModifier
	{
		GoodyValueModifier(CvPlayer& kPlayer, CvUnit* pUnit)
		{
			m_iGoodyModifier = pUnit != NULL ? pUnit->getUnitInfo().GetGoodyModifier() + pUnit->GetGoodyHutYieldBonus() : 0;

			m_iEraScale = MOD_BALANCE_CORE ? kPlayer.GetCurrentEra() : 1;
			if (m_iEraScale <= 0)
				m_iEraScale = 1;
		}

		void operator()(int& iValue, int iGameSpeedPercent, bool bUseUnitModifier, bool bScaleByEra)
		{
			if (iGameSpeedPercent != -1)
			{
				iValue *= iGameSpeedPercent;
				iValue /= 100;
			}
			if (bUseUnitModifier)
			{
				iValue *= (100 + m_iGoodyModifier);
				iValue /= 100;
			}
			if (bScaleByEra)
			{
				iValue *= m_iEraScale;
			}
		}

		int m_iGoodyModifier;
		int m_iEraScale;
	} goodyValueModifier(*this, pUnit);

	Database::SingleResult kResult;
	CvGoodyInfo kGoodyInfo;
	const bool bResult = DB.SelectAt(kResult, "GoodyHuts", eGoody);
	DEBUG_VARIABLE(bResult);
	CvAssertMsg(bResult, "Cannot find goody info.");
	kGoodyInfo.CacheResult(kResult);

	CvGoodyHuts::DoPlayerReceivedGoody(GetID(), eGoody);

	strBuffer = kGoodyInfo.GetDescription();

	// Gold
	int iGold = 0;
	{
		if (kGoodyInfo.getNumGoldRandRolls() > 0 && kGoodyInfo.getGoldRandAmount() > 0)
		{
			iGold = kGoodyInfo.getGold() + (kGoodyInfo.getNumGoldRandRolls() * GC.getGame().getSmallFakeRandNum(kGoodyInfo.getGoldRandAmount(), *pPlot));
		}

		if (iGold != 0)
		{
			goodyValueModifier(iGold, GC.getGame().getGameSpeedInfo().getGoldPercent(), true, true);
			GetTreasury()->ChangeGold(iGold);
			changeInstantYieldValue(YIELD_GOLD, iGold);
			strBuffer += " ";
			strBuffer += GetLocalizedText("TXT_KEY_MISC_RECEIVED_GOLD", iGold);
		}
	}

	// Population
	int iPop = kGoodyInfo.getPopulation();
	if (kGoodyInfo.getPopulation() > 0)
	{
		CvCity* pBestCity = bestCityFinder(*this, *pPlot);
		if (pBestCity != NULL)
		{
			goodyValueModifier(iPop, -1, false, true);
			pBestCity->changePopulation(iPop, true, true);
		}
		else
		{
			// Remember that no growth happened just in case something cares
			iPop = 0;
		}
	}

	// Production
	int iProduction = MOD_BALANCE_CORE ? kGoodyInfo.getProduction() : 0;
	if (iProduction > 0)
	{
		CvCity* pBestCity = bestCityFinder(*this, *pPlot);
		if (pBestCity != NULL)
		{
			goodyValueModifier(iProduction, GC.getGame().getGameSpeedInfo().getInstantYieldPercent(), true, true);
			pBestCity->changeProduction(iProduction);
			changeInstantYieldValue(YIELD_PRODUCTION, iProduction);
		}
		else
		{
			// Remember that no production was yielded just in case something cares
			iProduction = 0;
		}
	}

	// Golden Age Points
	int iGoldenAge = MOD_BALANCE_CORE ? kGoodyInfo.getGoldenAge() : 0;
	if (iGoldenAge > 0 && GetNumGoldenAges() <= 0)
	{
		goodyValueModifier(iGoldenAge, GC.getGame().getGameSpeedInfo().getGoldenAgePercent(), true, true);
		ChangeGoldenAgeProgressMeter(iGoldenAge);
		changeInstantYieldValue(YIELD_GOLDEN_AGE_POINTS, iGoldenAge);
	}

	// Free Tiles
	int iFreeTiles = MOD_BALANCE_CORE ? kGoodyInfo.getFreeTiles() : 0;
	if(iFreeTiles > 0)
	{
		CvCity* pBestCity = bestCityFinder(*this, *pPlot);
		if(pBestCity != NULL)
		{
			goodyValueModifier(iFreeTiles, -1, true, false);
			if(iFreeTiles > 0)
			{
				for (int i = 0; i < iFreeTiles; i++)
				{
					CvPlot* pPlotToAcquire = pBestCity->GetNextBuyablePlot(false);
					// maybe the player owns ALL of the plots or there are none available?
					if(pPlotToAcquire)
					{
						// Instant yield from tiles gained by culture bombing
						for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
						{
							YieldTypes eYield = (YieldTypes)iI;

							int iPassYield = 0;

							if (eYield == NO_YIELD)
								continue;

							TerrainTypes eTerrain = pPlotToAcquire->getTerrainType();

							if (eTerrain == NO_TERRAIN)
								continue;

							// Stole foreign tiles
							if (pPlotToAcquire->getOwner() != NO_PLAYER)
							{
								iPassYield += GetPlayerTraits()->GetYieldChangeFromTileStealCultureBomb(eTerrain, eYield);
							}
							// Obtained neutral tiles
							else
							{
								iPassYield += GetPlayerTraits()->GetYieldChangeFromTileCultureBomb(eTerrain, eYield);
							}

							doInstantYield(INSTANT_YIELD_TYPE_CULTURE_BOMB, false, NO_GREATPERSON, NO_BUILDING, iPassYield, true, NO_PLAYER, NULL, false, pBestCity, false, true, false, eYield);
						}

						pBestCity->DoAcquirePlot(pPlotToAcquire->getX(), pPlotToAcquire->getY());
					}
				}
			}
		}
		else
		{
			// Remember that no city received tiles just in case something cares
			iFreeTiles = 0;
		}
	}

	// Science
	int iScience = MOD_BALANCE_CORE ? kGoodyInfo.getScience() : 0;
	if (iScience > 0)
	{
		goodyValueModifier(iScience, GC.getGame().getGameSpeedInfo().getResearchPercent(), true, true);

		TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
		if (eCurrentTech == NO_TECH)
		{
			changeOverflowResearch(iScience);
		}
		else
		{
			CvTeam& kTeam = GET_TEAM(getTeam());
			kTeam.GetTeamTechs()->ChangeResearchProgress(eCurrentTech, iScience, GetID());
		}

		changeInstantYieldValue(YIELD_SCIENCE, iScience);
	}

	// New Goodies modmod 
	if (MOD_NEW_GOODIES)
	{
		int iFood = kGoodyInfo.getFood();
		if (iFood > 0)
		{
			CvCity* pBestCity = bestCityFinder(*this, *pPlot);
			if (pBestCity != NULL)
			{
				goodyValueModifier(iFood, GC.getGame().getGameSpeedInfo().getInstantYieldPercent(), true, true);
				pBestCity->changeFood(iFood);
				changeInstantYieldValue(YIELD_FOOD, iFood);
			}
			else
			{
				// Remember that no production was yielded just in case something cares
				iFood = 0;
			}
		}

		int iBorderGrowth = kGoodyInfo.getBorderGrowth();
		if (iBorderGrowth > 0)
		{

			CvCity* pBestCity = bestCityFinder(*this, *pPlot);
			if (pBestCity != NULL)
			{
				goodyValueModifier(iBorderGrowth, GC.getGame().getGameSpeedInfo().getInstantYieldPercent(), true, true);
				pBestCity->ChangeJONSCultureStored(iBorderGrowth);
				changeInstantYieldValue(YIELD_CULTURE_LOCAL, iBorderGrowth);
			}
			else
			{
				// Remember that no production was yielded just in case something cares
				iBorderGrowth = 0;
			}
		}
	}

	// Culture
	int iCulture = kGoodyInfo.getCulture();
	if(iCulture > 0)
	{
		goodyValueModifier(iCulture, GC.getGame().getGameSpeedInfo().getCulturePercent(), true, true);
		if (MOD_BALANCE_CORE_BARBARIAN_THEFT)
		{
			iCulture *= max(1, (GetPlayerPolicies()->GetNumPoliciesOwned(true, true) / 2));
		}

		changeJONSCulture(iCulture);

		strBuffer += " ";
		strBuffer += GetLocalizedText("TXT_KEY_MISC_RECEIVED_CULTURE", iCulture);

		changeInstantYieldValue(YIELD_CULTURE, iCulture);
	}

	// Faith
	int iFaith = kGoodyInfo.getFaith();
	if(iFaith > 0)
	{
		goodyValueModifier(iFaith, GC.getGame().getGameSpeedInfo().getFaithPercent(), true, true);
		ChangeFaith(iFaith);

		changeInstantYieldValue(YIELD_FAITH, iFaith);

		strBuffer += " ";
		strBuffer += GetLocalizedText("TXT_KEY_MISC_RECEIVED_FAITH", iFaith);
	}

	// Faith for pantheon
	bool bPantheon = kGoodyInfo.isPantheonFaith();
	if(bPantheon)
	{
		// Enough so still get a pantheon if 3 civs pop this in same turn
		iFaith = GC.getGame().GetGameReligions()->GetMinimumFaithNextPantheon() + 2 * /*5 in CP, 0 in VP*/ GD_INT_GET(RELIGION_GAME_FAITH_DELTA_NEXT_PANTHEON);
		int iDivisor = /*10*/ GD_INT_GET(GOLD_PURCHASE_VISIBLE_DIVISOR);
		iFaith /= iDivisor;
		iFaith *= iDivisor;

		goodyValueModifier(iFaith, -1, true, true);
		ChangeFaith(iFaith);

		changeInstantYieldValue(YIELD_FAITH, iFaith);

		strBuffer += " ";
		strBuffer += GetLocalizedText("TXT_KEY_MISC_RECEIVED_FAITH", iFaith);
	}

	// Faith for percent of great prophet
	int iProphetPercent = kGoodyInfo.getProphetPercent();
	if(iProphetPercent > 0)
	{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
		iFaith = GetReligions()->GetCostNextProphet(false /*bIncludeBeliefDiscounts*/, true /*bAdjustForSpeedDifficulty*/, MOD_GLOBAL_TRULY_FREE_GP) * iProphetPercent / 100;
#else
		iFaith = GetReligions()->GetCostNextProphet(false /*bIncludeBeliefDiscounts*/, true /*bAdjustForSpeedDifficulty*/) * iProphetPercent / 100;
#endif
		int iDivisor = /*10*/ GD_INT_GET(GOLD_PURCHASE_VISIBLE_DIVISOR);
		iFaith /= iDivisor;
		iFaith *= (iDivisor / 2);

		goodyValueModifier(iFaith, -1, false, true);
		ChangeFaith(iFaith);

		changeInstantYieldValue(YIELD_FAITH, iFaith);

		strBuffer += " ";
		strBuffer += GetLocalizedText("TXT_KEY_MISC_RECEIVED_FAITH", iFaith);
	}

	// Reveal Nearby Barbs
	if(kGoodyInfo.getRevealNearbyBarbariansRange() > 0)
	{
		// Look at nearby Plots to make sure another camp isn't too close
		const int iBarbCampDistance = kGoodyInfo.getRevealNearbyBarbariansRange();
		for(iDX = -(iBarbCampDistance); iDX <= iBarbCampDistance; iDX++)
		{
			for(iDY = -(iBarbCampDistance); iDY <= iBarbCampDistance; iDY++)
			{
				CvPlot* pNearbyBarbarianPlot = plotXY(pPlot->getX(), pPlot->getY(), iDX, iDY);
				if(pNearbyBarbarianPlot != NULL)
				{
					if(plotDistance(pNearbyBarbarianPlot->getX(), pNearbyBarbarianPlot->getY(), pPlot->getX(), pPlot->getY()) <= iBarbCampDistance)
					{
						if(pNearbyBarbarianPlot->getImprovementType() == GD_INT_GET(BARBARIAN_CAMP_IMPROVEMENT))
						{
							// Reveal Plot
							pNearbyBarbarianPlot->setRevealed(getTeam(), true);
							// Reveal Barb Camp here
							pNearbyBarbarianPlot->setRevealedImprovementType(getTeam(), pNearbyBarbarianPlot->getImprovementType());
						}
					}
				}
			}
		}
	}

	// Map
	iRange = kGoodyInfo.getMapRange();

	if(iRange > 0)
	{
		iOffset = kGoodyInfo.getMapOffset();

		if(iOffset > 0)
		{
			iBestValue = 0;
			pBestPlot = NULL;

			int iRandLimit;

			for(iDX = -(iOffset); iDX <= iOffset; iDX++)
			{
				for(iDY = -(iOffset); iDY <= iOffset; iDY++)
				{
					pLoopPlot = plotXYWithRangeCheck(pPlot->getX(), pPlot->getY(), iDX, iDY, iOffset);

					if(pLoopPlot != NULL)
					{
						if(!(pLoopPlot->isRevealed(getTeam())))
						{
							// Avoid water plots!
#if defined(MOD_BALANCE_CORE)
							//Let's reveal cities instead.
							if(pLoopPlot->isCity() && pLoopPlot->getOwner() != GetID() && pLoopPlot->getOwner() != NO_PLAYER)
							{
								iRandLimit = 0;
								if(GET_PLAYER(pLoopPlot->getOwner()).isMajorCiv())
								{
									iRandLimit += 10000;
								}
								else if(GET_PLAYER(pLoopPlot->getOwner()).isMinorCiv())
								{
									iRandLimit += 1000;
								}

#else
							if(pPlot->isWater())
								iRandLimit = 10;
							else
								iRandLimit = 10000;
#endif
							iValue = (1 + GC.getGame().getSmallFakeRandNum(iRandLimit, *pLoopPlot));

							iValue *= plotDistance(pPlot->getX(), pPlot->getY(), pLoopPlot->getX(), pLoopPlot->getY());

							if(iValue > iBestValue)
							{
								iBestValue = iValue;
								pBestPlot = pLoopPlot;
							}
#if defined(MOD_BALANCE_CORE)
							}
#endif
						}
					}
				}
			}
		}

		if(pBestPlot == NULL)
		{
			pBestPlot = pPlot;
		}

		int iNumPlotsRevealed = 0;
		for(iDX = -(iRange); iDX <= iRange; iDX++)
		{
			for(iDY = -(iRange); iDY <= iRange; iDY++)
			{
				pLoopPlot = plotXY(pBestPlot->getX(), pBestPlot->getY(), iDX, iDY);

				if(pLoopPlot != NULL)
				{
					if(plotDistance(pBestPlot->getX(), pBestPlot->getY(), pLoopPlot->getX(), pLoopPlot->getY()) <= iRange)
					{
						if(GC.getGame().getSmallFakeRandNum(100, *pLoopPlot) < kGoodyInfo.getMapProb())
						{
							pLoopPlot->setRevealed(getTeam(), true);
							iNumPlotsRevealed++;
						}
					}
				}
			}
		}
		if (pUnit != NULL && pUnit->IsGainsXPFromScouting())
		{
			pUnit->changeExperienceTimes100(iNumPlotsRevealed * 100);
		}
	}

	// Experience
	if(pUnit != NULL)
	{
		int iExperience = kGoodyInfo.getExperience() * 100;
		goodyValueModifier(iExperience, -1, true, false);
		pUnit->changeExperienceTimes100(iExperience);
	}

	// Unit Heal
	if(pUnit != NULL)
	{
		pUnit->changeDamage(-(kGoodyInfo.getHealing()));
	}

	// Reveal Unknown Resource
	if (kGoodyInfo.isRevealUnknownResource())
	{
		if (getCapitalCity() != NULL)
		{
			CvCity* pCapital = getCapitalCity();
			int iShortestResourceDistance = INT_MAX;
			ResourceTypes eBestResource = NO_RESOURCE;
			CvPlot* pBestResourcePlot = NULL;
			ResourceClassTypes eResourceClassBonus = (ResourceClassTypes) GC.getInfoTypeForString("RESOURCECLASS_BONUS");

			// Look at Resources on all Plots
			for (int iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)
			{
				CvPlot* pResourcePlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);
				ResourceTypes eResource = pResourcePlot->getResourceType();

				if (eResource != NO_RESOURCE)
				{
					CvResourceInfo& pResource = *GC.getResourceInfo(eResource);

					// No "Bonus" Resources (that only give Yields), because those are lame to get from a Hut
					if (pResource.getResourceClassType() != eResourceClassBonus)
					{
						// Can't be on a Plot that we've already force-revealed!
						if (!pResourcePlot->IsResourceForceReveal(getTeam()))
						{
							// Must be a Resource we don't already see
							if (!GET_TEAM(getTeam()).IsResourceRevealed(eResource))
							{
								int iResourceDistance = plotDistance(pResourcePlot->getX(), pResourcePlot->getY(), pCapital->getX(), pCapital->getY());

								// Must be within 10 plots of our Capital (prefer shorter)
								if (iResourceDistance <= 10 && iResourceDistance < iShortestResourceDistance)
								{
									iShortestResourceDistance = iResourceDistance;
									eBestResource = eResource;
									pBestResourcePlot = pResourcePlot;
								}
							}
						}
					}
				}
			}

			// Did we find something to show?
			if (pBestResourcePlot != NULL)
			{
				pBestResourcePlot->setRevealed(getTeam(), true);
				pBestResourcePlot->SetResourceForceReveal(getTeam(), true);

				if (getTeam() == GC.getGame().getActiveTeam())
				{
					pBestResourcePlot->setLayoutDirty(true);
				}

				// Also reveal adjacent Plots
				for (int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; iDirectionLoop++)
				{
					CvPlot* pAdjacentPlot = plotDirection(pBestResourcePlot->getX(), pBestResourcePlot->getY(), ((DirectionTypes) iDirectionLoop));

					if (pAdjacentPlot)
						pAdjacentPlot->setRevealed(getTeam(), true);
				}

				CvString strTempString;
				strTempString.Format(" (%s)", GC.getResourceInfo(eBestResource)->GetDescription());
				strBuffer += strTempString;
			}
		}
	}

	// Unit Upgrade
	if(kGoodyInfo.isUpgradeUnit())
	{
		UnitClassTypes eUpgradeUnitClass = NO_UNITCLASS;
		UnitTypes eUpgradeUnit = NO_UNIT;

		if(pUnit != NULL)
		{
			eUpgradeUnitClass = (UnitClassTypes) pUnit->getUnitInfo().GetGoodyHutUpgradeUnitClass();
			eUpgradeUnit = GetSpecificUnitType(eUpgradeUnitClass);
		}
		
		if(eUpgradeUnit != NO_UNIT)
		{
			// Add new upgrade Unit

			// if we promoted an scouting unit from a goody hut, turn him into whatever the new unit's default AI is if it is not a suitable explorer anymore
			UnitAITypes currentAIDefault = pUnit->AI_getUnitAIType();
			UnitAITypes newAIDefault = GC.getUnitInfo(eUpgradeUnit)->GetDefaultUnitAIType();
			if(currentAIDefault == UNITAI_EXPLORE)
			{
				if(newAIDefault == UNITAI_EXPLORE || newAIDefault == UNITAI_ATTACK || newAIDefault == UNITAI_DEFENSE || newAIDefault == UNITAI_FAST_ATTACK || newAIDefault == UNITAI_COUNTER)
				{
					newAIDefault = UNITAI_EXPLORE;
				}
			}

			CvUnit* pNewUnit = initUnit(eUpgradeUnit, pPlot->getX(), pPlot->getY(), newAIDefault, REASON_GIFT, false, false, 0, pUnit->GetNumGoodyHutsPopped());
			pUnit->finishMoves();
			pUnit->SetBeenPromotedFromGoody(true);

			CvAssert(pNewUnit);
			if (pNewUnit != NULL)
			{
#if defined(MOD_EVENTS_UNIT_UPGRADES)
			// MUST call the event before convert() as that kills the old unit
			if (MOD_EVENTS_UNIT_UPGRADES) {
				GAMEEVENTINVOKE_HOOK(GAMEEVENT_UnitUpgraded, GetID(), pUnit->GetID(), pNewUnit->GetID(), true);
			} else {
#endif
				ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
				if (pkScriptSystem)
				{
					CvLuaArgsHandle args;
					args->Push(GetID());
					args->Push(pUnit->GetID());
					args->Push(pNewUnit->GetID());
					args->Push(true); // bGoodyHut

					bool bScriptResult;
					LuaSupport::CallHook(pkScriptSystem, "UnitUpgraded", args.get(), bScriptResult);
				}
#if defined(MOD_EVENTS_UNIT_UPGRADES)
			}
#endif

				pNewUnit->convert(pUnit, true);
				pNewUnit->setupGraphical();
			}
			else
				pUnit->kill(false);

			// Since the old unit died, it will block the goody reward popup unless we call this
			GC.GetEngineUserInterface()->SetDontShowPopups(false);
		}
	}

	// Tech
	if(kGoodyInfo.isTech())
	{
		iBestValue = 0;
		eBestTech = NO_TECH;

		for(iI = 0; iI < GC.getNumTechInfos(); iI++)
		{
			const TechTypes eTech = static_cast<TechTypes>(iI);
			CvTechEntry* pkTech = GC.getTechInfo(eTech);
			if(pkTech != NULL && pkTech->IsGoodyTech())
			{
				if(GetPlayerTechs()->CanResearch(eTech))
				{
					bool bUseTech = true;

#if defined(MOD_EVENTS_GOODY_TECH)
					if (MOD_EVENTS_GOODY_TECH) {
						if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_GoodyHutCanResearch, GetID(), iI) == GAMEEVENTRETURN_FALSE) {
							bUseTech = false;
						}
					} else {
#endif
					ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
					if (pkScriptSystem)
					{
						CvLuaArgsHandle args;
						args->Push(GetID());
						args->Push(eTech);

						// Attempt to execute the game events.
						// Will return false if there are no registered listeners.
						bool bScriptResult = false;
						if (LuaSupport::CallTestAll(pkScriptSystem, "GoodyHutCanResearch", args.get(), bScriptResult))
						{
							bUseTech = bScriptResult;
						}
					}
#if defined(MOD_EVENTS_GOODY_TECH)
					}
#endif
#if defined(MOD_BALANCE_CORE)
					//Are we already researching a tech? No value here.
					if(MOD_BALANCE_CORE && GetPlayerTechs()->GetCurrentResearch() == eTech)
					{
						bUseTech = false;
					}
#endif
					if(bUseTech)
					{
						iValue = (1 + GC.getGame().getSmallFakeRandNum(10, iI));

						if(iValue > iBestValue)
						{
							iBestValue = iValue;
							eBestTech = eTech;
						}
					}
				}
			}
		}

		CvAssertMsg(eBestTech != NO_TECH, "BestTech is not assigned a valid value");

#if defined(MOD_EVENTS_GOODY_TECH)
		if (MOD_EVENTS_GOODY_TECH) {
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_GoodyHutTechResearched, GetID(), eBestTech);
		} else {
#endif
		ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
		if (pkScriptSystem) 
		{
			CvLuaArgsHandle args;
			args->Push(GetID());
			args->Push(eBestTech);

			bool bScriptResult;
			LuaSupport::CallHook(pkScriptSystem, "GoodyHutTechResearched", args.get(), bScriptResult);
		}
#if defined(MOD_EVENTS_GOODY_TECH)
		}
#endif

		GET_TEAM(getTeam()).setHasTech(eBestTech, true, GetID(), true, true);
		GET_TEAM(getTeam()).GetTeamTechs()->SetNoTradeTech(eBestTech, true);
	}

	// Units
	if(kGoodyInfo.getUnitClassType() != NO_UNITCLASS)
	{
		eUnit = GetSpecificUnitType((UnitClassTypes)kGoodyInfo.getUnitClassType());

		if(eUnit != NO_UNIT)
		{
			CvUnit* pNewUnit = initUnit(eUnit, pPlot->getX(), pPlot->getY());
			// see if there is an open spot to put him - no over-stacking allowed!
			if(pNewUnit && pUnit && pNewUnit->IsCombatUnit())  
			{
				pBestPlot = NULL;
				iBestValue = INT_MAX;
				const int iPopRange = 2;
				for(iDX = -(iPopRange); iDX <= iPopRange; iDX++)
				{
					for(iDY = -(iPopRange); iDY <= iPopRange; iDY++)
					{
						pLoopPlot	= plotXYWithRangeCheck(pPlot->getX(), pPlot->getY(), iDX, iDY, iPopRange);
						if(pLoopPlot != NULL)
						{
							if(pNewUnit->isNativeDomain(pLoopPlot))
							{
								if(pNewUnit->canMoveInto(*pLoopPlot,CvUnit::MOVEFLAG_DESTINATION|CvUnit::MOVEFLAG_NO_ENEMY_TERRITORY))
								{
									if((pNewUnit->getDomainType() != DOMAIN_AIR) || pLoopPlot->isFriendlyCity(*pNewUnit))
									{
										if(pLoopPlot->isRevealed(getTeam()))
										{
											iValue = 1 + GC.getGame().getSmallFakeRandNum(6, *pLoopPlot); // okay, I'll admit it, not a great heuristic

											if(plotDistance(pPlot->getX(),pPlot->getY(),pLoopPlot->getX(),pLoopPlot->getY()) > 1)
											{
												iValue += 12;
											}

											if(pLoopPlot->area() != pPlot->area())  // jumped to a different land mass, cool
											{
												iValue *= 10;
											}

											if(iValue < iBestValue)
											{
												iBestValue = iValue;
												pBestPlot = pLoopPlot;
											}
										}
									}
								}
							}
						}
					}
				}
				if(pBestPlot != NULL)
				{
					bool bVis = pBestPlot->isVisibleToWatchingHuman();
					pNewUnit->setXY(pBestPlot->getX(), pBestPlot->getY(), false, true, true && bVis, true);
					pNewUnit->SetPosition(pBestPlot);	// Need this to put the unit in the right spot graphically
					pNewUnit->finishMoves();
				}
				else
				{
					pNewUnit->kill(false);
				}
			}
		}
	}

	// Barbarians
	if(kGoodyInfo.getBarbarianUnitClass() != NO_UNITCLASS)
	{
		iBarbCount = 0;

		eUnit = (UnitTypes)GET_PLAYER(BARBARIAN_PLAYER).getCivilizationInfo().getCivilizationUnits(kGoodyInfo.getBarbarianUnitClass());

		if(eUnit != NO_UNIT)
		{
			for(iPass = 0; iPass < 10; iPass++)
			{
				if(iBarbCount < kGoodyInfo.getMinBarbarians())
				{
					for(iI = 0; iI < NUM_DIRECTION_TYPES; iI++)
					{
						pLoopPlot = plotDirection(pPlot->getX(), pPlot->getY(), ((DirectionTypes)iI));

						if(pLoopPlot != NULL)
						{
							if(pLoopPlot->getArea() == pPlot->getArea())
							{
								if(pLoopPlot->isValidMovePlot(GetID()) && !pLoopPlot->isCity())
								{
									if(pLoopPlot->getNumUnits() == 0)
									{
										if((iPass > 0) || (GC.getGame().getSmallFakeRandNum(10, *pLoopPlot) * 10 < kGoodyInfo.getBarbarianUnitProb()))
										{
											GET_PLAYER(BARBARIAN_PLAYER).initUnit(eUnit, pLoopPlot->getX(), pLoopPlot->getY(), ((pLoopPlot->isWater()) ? UNITAI_ATTACK_SEA : UNITAI_ATTACK));
											iBarbCount++;

											if((iPass > 0) && (iBarbCount == kGoodyInfo.getMinBarbarians()))
											{
												break;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if(!strBuffer.empty() && GC.getGame().getActivePlayer() == GetID())
	{
		GC.GetEngineUserInterface()->AddPlotMessage(0, pPlot->GetPlotIndex(), GetID(), true, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), strBuffer);
	}

	// If it's the active player then show the popup
	if(GetID() == GC.getGame().getActivePlayer())
	{
		GC.getMap().updateDeferredFog();

		bool bDontShowRewardPopup = GC.GetEngineUserInterface()->IsOptionNoRewardPopups();

		// Don't show in MP, or if the player has turned it off
		if(!GC.getGame().isReallyNetworkMultiPlayer() && !bDontShowRewardPopup)
		{
			int iSpecialValue = 0;

			if(iGold > 0)
				iSpecialValue = iGold;
			else if(iCulture > 0)
				iSpecialValue = iCulture;
			else if(iFaith > 0)
				iSpecialValue = iFaith;
#if defined(MOD_BALANCE_CORE)
			else if(iProduction > 0)
				iSpecialValue = iProduction;
			else if (iScience > 0)
				iSpecialValue = iScience;
#endif

			CvPopupInfo kPopupInfo(BUTTONPOPUP_GOODY_HUT_REWARD, eGoody, iSpecialValue);
			GC.GetEngineUserInterface()->AddPopup(kPopupInfo);
			// We are adding a popup that the player must make a choice in, make sure they are not in the end-turn phase.
			CancelActivePlayerEndTurn();
		}
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::doGoody(CvPlot* pPlot, CvUnit* pUnit)
{
	const CvHandicapInfo& playerHandicapInfo = getHandicapInfo();

	GoodyTypes eGoody;

	CvAssertMsg(pPlot->isGoody(), "pPlot->isGoody is expected to be true");

	if(!isBarbarian())
	{
		m_bEverPoppedGoody = true;
		pPlot->removeGoody();

		// Minors don't get Goodies :(
		if(isMinorCiv())
		{
			return;
		}

		// Need to have Goodies in the Handicap file to pick from
		if(playerHandicapInfo.getNumGoodies() > 0)
		{
			// Make a list of valid Goodies to pick randomly from
			int iValidGoodiesLoop;
			bool bValid;

			std::vector<GoodyTypes> avValidGoodies;
			for(int iGoodyLoop = 0; iGoodyLoop < playerHandicapInfo.getNumGoodies(); iGoodyLoop++)
			{
				eGoody = (GoodyTypes) playerHandicapInfo.getGoodies(iGoodyLoop);
				bValid = false;

				// Check to see if we've already verified this Goody is valid (since there can be multiples in the vector)
				for(iValidGoodiesLoop = 0; iValidGoodiesLoop < (int) avValidGoodies.size(); iValidGoodiesLoop++)
				{
					if(avValidGoodies[iValidGoodiesLoop] == eGoody)
					{
						avValidGoodies.push_back(eGoody);
						bValid = true;
						break;
					}
				}

				if(bValid)
					continue;

				if(canReceiveGoody(pPlot, eGoody, pUnit))
				{
					avValidGoodies.push_back(eGoody);
				}
			}

#if defined(MOD_GLOBAL_ANYTIME_GOODY_GOLD)
			// Any valid Goodies?  If not, add back the gold goody hut(s)
			if(MOD_GLOBAL_ANYTIME_GOODY_GOLD && avValidGoodies.size() == 0)
			{
				for(int iGoodyLoop = 0; iGoodyLoop < playerHandicapInfo.getNumGoodies(); iGoodyLoop++)
				{
					eGoody = (GoodyTypes) playerHandicapInfo.getGoodies(iGoodyLoop);

					Database::SingleResult kResult;
					const bool bResult = DB.SelectAt(kResult, "GoodyHuts", eGoody);
					DEBUG_VARIABLE(bResult);
					CvAssertMsg(bResult, "Cannot find goody info.");

					CvGoodyInfo kGoodyInfo;
					kGoodyInfo.CacheResult(kResult);

					if (kGoodyInfo.getGold() > 0)
					{
						avValidGoodies.push_back(eGoody);
					}
				}
			}
#endif

			// Any valid Goodies?
			if(avValidGoodies.size() > 0)
			{
				// Fix the bug where the AI won't get anything for Goody Hut pickers!!!
				if (pUnit && pUnit->isHasPromotion((PromotionTypes)GD_INT_GET(PROMOTION_GOODY_HUT_PICKER)) && GET_PLAYER(pUnit->getOwner()).isHuman())
				{
					if (GC.getGame().getActivePlayer() == GetID())

					{
						CvPopupInfo kPopupInfo(BUTTONPOPUP_CHOOSE_GOODY_HUT_REWARD, GetID(), pUnit->GetID());
						GC.GetEngineUserInterface()->AddPopup(kPopupInfo);
						// We are adding a popup that the player must make a choice in, make sure they are not in the end-turn phase.
						if (!GC.getGame().isReallyNetworkMultiPlayer())
						{
							CancelActivePlayerEndTurn();
						}
					}
				}
				else
				{
#if defined(MOD_CORE_REDUCE_RANDOMNESS)
					int iRand = GC.getGame().getSmallFakeRandNum(avValidGoodies.size(),*pPlot);
#else
					int iRand = GC.getGame().getJonRandNum(avValidGoodies.size(), "Picking a Goody result");
#endif
					eGoody = (GoodyTypes) avValidGoodies[iRand];
					receiveGoody(pPlot, eGoody, pUnit);
#if defined(MOD_EVENTS_GOODY_CHOICE)
					if (MOD_EVENTS_GOODY_CHOICE)
						//   GameEvents.GoodyHutReceivedBonus.Add(function(iPlayer, iUnit, eGoody, iX, iY) end)
						GAMEEVENTINVOKE_HOOK(GAMEEVENT_GoodyHutReceivedBonus, GetID(), pUnit ? pUnit->GetID() : -1, eGoody, pPlot->getX(), pPlot->getY());
#endif
				}
				
#if defined(MOD_API_ACHIEVEMENTS)
				if (pUnit && isHuman() && !GC.getGame().isGameMultiPlayer())
				{
					pUnit->SetNumGoodyHutsPopped(pUnit->GetNumGoodyHutsPopped() + 1);
					if (pUnit->isHasPromotion((PromotionTypes)GD_INT_GET(PROMOTION_GOODY_HUT_PICKER)) && pUnit->GetNumGoodyHutsPopped() >= 5)
					{
						gDLL->UnlockAchievement(ACHIEVEMENT_XP2_25);
					}
				}
#endif
			}

			pPlot->AddArchaeologicalRecord(CvTypes::getARTIFACT_ANCIENT_RUIN(), m_eID, NO_PLAYER);
		}
	}
}

//this is an AI helper to let it know if a building is part of a prereq chain
void CvPlayer::BuildBuildingStepValues()
{
	std::vector<BuildingTypes>v_StarterBuildings = FindInitialBuildings();
	for (uint i = 0; i < v_StarterBuildings.size(); i++)
	{
		BuildingTypes eCurrent = v_StarterBuildings[i];
		if (eCurrent == NO_BUILDING)
			continue;
		SetChainLength(eCurrent);
	}
}
std::vector<BuildingTypes> CvPlayer::FindInitialBuildings()
{
	std::vector<BuildingTypes>v_StarterBuildings;

	CvCivilizationInfo* pkCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
	if (pkCivilizationInfo == NULL)
		return v_StarterBuildings;

	//first, loop through all buildings...
	for (int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
		if (!pkBuildingInfo)
			continue;

		//skip wonders
		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(pkBuildingInfo->GetBuildingClassType());
		if (pkBuildingClassInfo)
			if (pkBuildingClassInfo->getMaxGlobalInstances() > 0 || pkBuildingClassInfo->getMaxPlayerInstances() > 0 || pkBuildingClassInfo->getMaxTeamInstances() > 0)
				continue;

		bool bHasPrereq = false;
		if (pkBuildingInfo)
		{
			BuildingTypes eCivBuilding = (BuildingTypes)pkCivilizationInfo->getCivilizationBuildings(pkBuildingInfo->GetBuildingClassType());
			if (eCivBuilding != eBuilding)
				continue;

			// Does this building have prereq buildings?
			for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
			{
				//if it has a prereq, skip it!
				if (pkBuildingInfo->IsBuildingClassNeededInCity(iI))
				{
					bHasPrereq = true;
					break;
				}
			}
			if (!bHasPrereq)
			{
				v_StarterBuildings.push_back(eBuilding);
			}
		}
	}
	//return all standard buildings with no prereqs
	return v_StarterBuildings;
}
void CvPlayer::SetChainLength(BuildingTypes eBuilding)
{
	std::vector<BuildingTypes>v_ChainBuildings;
	v_ChainBuildings.push_back(eBuilding);

	CvCivilizationInfo* pkCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
	if (pkCivilizationInfo == NULL)
		return;

	//check our current building
	while (v_ChainBuildings.size() > 0)
	{
		std::vector<BuildingTypes>v_TempChainBuildings;
		for (uint i = 0; i < v_ChainBuildings.size(); i++)
		{
			BuildingTypes eCurrent = v_ChainBuildings[i];
			if (eCurrent == NO_BUILDING)
				break;

			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eCurrent);
			if (!pkBuildingInfo)
				break;

			//find the class
			BuildingClassTypes eBuildingClass = pkBuildingInfo->GetBuildingClassType();
			if (eBuildingClass == NO_BUILDINGCLASS)
				break;

			//next, loop through all other buildings...
			for (int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
			{
				const BuildingTypes eBuilding2 = static_cast<BuildingTypes>(iBuildingLoop);

				CvBuildingEntry* pkBuildingInfo2 = GC.getBuildingInfo(eBuilding2);
				if (!pkBuildingInfo2)
					continue;

				BuildingTypes eCivBuilding = (BuildingTypes)pkCivilizationInfo->getCivilizationBuildings((BuildingClassTypes)pkBuildingInfo2->GetBuildingClassType());
				if (eCivBuilding != eBuilding2)
					continue;

				//if it has a prereq, count it!
				if (pkBuildingInfo2->IsBuildingClassNeededInCity((int)eBuildingClass))
				{
					m_paiBuildingChainSteps[eCurrent] = m_paiBuildingChainSteps[eCurrent] + 1;
					m_paiBuildingChainSteps[eBuilding] = m_paiBuildingChainSteps[eBuilding] + 1;
					v_TempChainBuildings.push_back(eBuilding2);
				}
			}
		}
		
		v_ChainBuildings = v_TempChainBuildings;
		v_TempChainBuildings.clear();

	}
}
int CvPlayer::GetChainLength(BuildingTypes eBuilding)
{
	CvAssertMsg(eBuilding >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eBuilding < GC.getNumBuildingInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiBuildingChainSteps[eBuilding];
}

//	--------------------------------------------------------------------------------
void CvPlayer::AwardFreeBuildings(CvCity* pCity)
{
	int iNumFreeCultureBuildings = GetNumCitiesFreeCultureBuilding();
	if(iNumFreeCultureBuildings > 0)
	{
		BuildingTypes eBuilding = pCity->ChooseFreeCultureBuilding();
		if(eBuilding != NO_BUILDING)
		{
			pCity->GetCityBuildings()->SetNumFreeBuilding(eBuilding, 1);
		}
		else
		{
			pCity->SetOwedCultureBuilding(true);
		}

		ChangeNumCitiesFreeCultureBuilding(-1);
	}

	int iNumFreeFoodBuildings = GetNumCitiesFreeFoodBuilding();
	if(iNumFreeFoodBuildings > 0)
	{
		BuildingTypes eBuilding = pCity->ChooseFreeFoodBuilding();
		if(eBuilding != NO_BUILDING)
		{
			pCity->GetCityBuildings()->SetNumFreeBuilding(eBuilding, 1);
		}
		else
		{
			pCity->SetOwedFoodBuilding(true);
		}

		ChangeNumCitiesFreeFoodBuilding(-1);
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canFoundCity(int iX, int iY) const
{
	return canFoundCityExt(iX,iY,false,false);
}

bool CvPlayer::canFoundCityExt(int iX, int iY, bool bIgnoreDistanceToExistingCities, bool bIgnoreHappiness) const
{
	CvPlot* pPlot = GC.getMap().plot(iX, iY);

#if defined(MOD_EVENTS_CITY_FOUNDING)
	if (MOD_EVENTS_CITY_FOUNDING) {
		if (GAMEEVENTINVOKE_TESTANY(GAMEEVENT_PlayerCanFoundCityRegardless, GetID(), iX, iY) == GAMEEVENTRETURN_TRUE) {
			return true;
		}
	}
#endif

#if defined(MOD_EVENTS_CITY_FOUNDING)
	if (MOD_EVENTS_CITY_FOUNDING) {
		if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_PlayerCanFoundCity, GetID(), iX, iY) == GAMEEVENTRETURN_FALSE) {
			return false;
		}
	}
#endif

	if (!pPlot->isRevealed(getTeam()))
		return false;

	// Settlers cannot found cities while empire is very unhappy
	if(!bIgnoreHappiness && IsEmpireVeryUnhappy())
		return false;

	return GC.getGame().GetSettlerSiteEvaluator()->CanFoundCity(pPlot, this, bIgnoreDistanceToExistingCities);
}

//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_RELIGIOUS_SETTLERS) && defined(MOD_BALANCE_CORE)
void CvPlayer::foundCity(int iX, int iY, ReligionTypes eReligion, bool bForce, CvUnitEntry* pkSettlerUnitEntry)
#elif defined(MOD_GLOBAL_RELIGIOUS_SETTLERS)
void CvPlayer::foundCity(int iX, int iY, ReligionTypes eReligion, bool bForce)
#elif defined(MOD_BALANCE_CORE)
void CvPlayer::foundCity(int iX, int iY, CvUnitEntry* pkSettlerUnitEntry = NULL)
#else
void CvPlayer::foundCity(int iX, int iY)
#endif
{
	if(!bForce && !canFoundCity(iX, iY))
		return;

	SetTurnsSinceSettledLastCity(0);

	//if this is our first city, remember how good it is as a reference
	if (GetNumCitiesFounded() == 0)
		m_iFoundValueOfCapital = getPlotFoundValue(iX, iY);

#if defined(MOD_GLOBAL_RELIGIOUS_SETTLERS) && defined(MOD_BALANCE_CORE)
	CvCity* pCity = initCity(iX, iY, true, true, eReligion, NULL, pkSettlerUnitEntry);
#elif defined(MOD_GLOBAL_RELIGIOUS_SETTLERS)
	CvCity* pCity = initCity(iX, iY, true, true, eReligion);
#elif defined(MOD_BALANCE_CORE)
	CvCity* pCity = initCity(iX, iY, pkSettlerUnitEntry);
#else
	CvCity* pCity = initCity(iX, iY);
#endif
	CvAssertMsg(pCity != NULL, "City is not assigned a valid value");
	if(pCity == NULL)
		return;

	int iExtraTerritoryClaim = GetPlayerTraits()->GetExtraFoundedCityTerritoryClaimRange();
	for (int i = 0; i < iExtraTerritoryClaim; i++)
	{
		CvPlot* pPlotToAcquire = pCity->GetNextBuyablePlot(false);

		// maybe the player owns ALL of the plots or there are none available?
		if(pPlotToAcquire)
		{
			pCity->DoAcquirePlot(pPlotToAcquire->getX(), pPlotToAcquire->getY());
		}
	}
#if defined(MOD_BALANCE_CORE)
	if(MOD_BALANCE_CORE && !isMinorCiv() && (GetNumCitiesFounded() <= 1))
	{
		if(GetPlayerTraits()->IsPopulationBoostReligion())
		{
			int iFaith = GC.getGame().GetGameReligions()->GetMinimumFaithNextPantheon();
			SetFaith(iFaith);
			if(GC.getGame().GetGameReligions()->CanCreatePantheon(GetID(), true) == 0)
			{
				// Create the pantheon
				if(isHuman())
				{
					//If the player is human then a net message will be received which will pick the pantheon.
					CvNotifications* pNotifications = GetNotifications();
					if(pNotifications)
					{
						CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_ENOUGH_FAITH_FOR_PANTHEON");

						CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_ENOUGH_FAITH_FOR_PANTHEON");
						pNotifications->Add(NOTIFICATION_FOUND_PANTHEON, strBuffer, strSummary, -1, -1, -1);
					}
				}
				else
				{
	#if defined(MOD_EVENTS_ACQUIRE_BELIEFS)
					const BeliefTypes eBelief = GetReligionAI()->ChoosePantheonBelief(GetID());
	#else
					const BeliefTypes eBelief = owningPlayer.GetReligionAI()->ChoosePantheonBelief();
	#endif

					GC.getGame().GetGameReligions()->FoundPantheon(GetID(), eBelief);
				}
			}
		}
	}
#endif
	std::vector<int> allBuildingCount = GetTotalBuildingCount();
	for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
	{
		const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iI);
		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
		if(pkBuildingClassInfo)
		{
			const BuildingTypes eLoopBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(iI)));
			if(eLoopBuilding != NO_BUILDING)
			{
				CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eLoopBuilding);
				if(pkBuildingInfo)
				{
					if(pkBuildingInfo->GetFreeStartEra() != NO_ERA)
					{
						if(GC.getGame().getStartEra() >= pkBuildingInfo->GetFreeStartEra())
						{
							if(pCity->canConstruct(eLoopBuilding,allBuildingCount))
							{
								pCity->GetCityBuildings()->SetNumRealBuilding(eLoopBuilding, 1);

#if defined(MOD_EVENTS_CITY)
								if (MOD_EVENTS_CITY)
								{
									GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityConstructed, pCity->getOwner(), pCity->GetID(), eLoopBuilding, false, false);
								}
#endif
							}
						}
					}
				}
			}
		}
	}

	AwardFreeBuildings(pCity);

	DoUpdateNextPolicyCost();

	if(isHuman() && getAdvancedStartPoints() < 0)
	{
		// Human player is prompted to choose production BEFORE the AI runs for the turn.
		// So we'll force the AI strategies on the city now, just after it is founded.
		// And if the very first turn, we haven't even run player strategies once yet, so do that too.
		if(GC.getGame().getGameTurn() == 0)
		{
			GetEconomicAI()->DoTurn();
			GetMilitaryAI()->DoTurn();
			GetReligionAI()->DoTurn();
			GetEspionageAI()->DoTurn();
			GetTradeAI()->DoTurn();
		}
		pCity->GetCityStrategyAI()->DoTurn();

		if (!pCity->IsPuppet())
			pCity->chooseProduction();

		pCity->doFoundMessage();

		// If this is the first city (or we still aren't getting tech for some other reason notify the player)
		if(GetPlayerTechs()->GetCurrentResearch() == NO_TECH && GetScienceTimes100() > 0)
		{
			if(GetID() == GC.getGame().getActivePlayer())
			{
				chooseTech();
			}
		}
	}
	else
	{
		pCity->doFoundMessage();

		// AI civ, may need to redo city specializations
		GetCitySpecializationAI()->SetSpecializationsDirty(SPECIALIZATION_UPDATE_CITY_FOUNDED);
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(pCity->getX());
		args->Push(pCity->getY());
		
		bool bResult;
		LuaSupport::CallHook(pkScriptSystem, "PlayerCityFounded", args.get(), bResult);
	}
}

void CvPlayer::cityBoost(int iX, int iY, CvUnitEntry* pkUnitEntry, int iExtraPlots, int iPopChange, int iFoodPercent)
{
	//Advanced Settler Buildings
	if(pkUnitEntry && !isMinorCiv() && !isBarbarian())
	{
		CvPlot* pPlot = GC.getMap().plot(iX, iY);
		CvCity* pCity = pPlot ? pPlot->getPlotCity() : NULL;

		if(!pCity)
			return;

		const int iNumBuildingClassInfos = GC.getNumBuildingClassInfos();
		const CvCivilizationInfo& thisCivilization = getCivilizationInfo();
		for(int iBuildingClassLoop = 0; iBuildingClassLoop < iNumBuildingClassInfos; iBuildingClassLoop++)
		{
			const BuildingClassTypes eBuildingClass = (BuildingClassTypes) iBuildingClassLoop;
			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
			if(!pkBuildingClassInfo)
			{
				continue;
			}
			if(pkUnitEntry->GetBuildOnFound(eBuildingClass))
			{
				const BuildingTypes eFreeBuilding = (BuildingTypes)(thisCivilization.getCivilizationBuildings(eBuildingClass));
				if(pCity->isValidBuildingLocation(eFreeBuilding))
				{
					pCity->GetCityBuildings()->SetNumRealBuilding(eFreeBuilding, 1, true);
				}
			}
		}

		pCity->setPopulation(GetNewCityExtraPopulation() + iPopChange, true, true);

		//25% food, to prevent instant-starvation
		pCity->changeFood((pCity->growthThreshold() * iFoodPercent / 100));

		//And a little territory to boot
		for (int i = 0; i < iExtraPlots; i++)
		{
			CvPlot* pPlotToAcquire = pCity->GetNextBuyablePlot(false);

			// maybe the player owns ALL of the plots or there are none available?
			if(pPlotToAcquire)
			{
				pCity->DoAcquirePlot(pPlotToAcquire->getX(), pPlotToAcquire->getY());
			}
		}
	}
}

//	--------------------------------------------------------------------------------
//	this should be more or less "static" conditions, all the transient factor should be checked in CvCity::canTrain()
//	--------------------------------------------------------------------------------
bool CvPlayer::canTrainUnit(UnitTypes eUnit, bool bContinue, bool bTestVisible, bool bIgnoreCost, bool bIgnoreUniqueUnitStatus, CvString* toolTipSink) const
{
	CvUnitEntry* pUnitInfoPtr = GC.getUnitInfo(eUnit);
	if(pUnitInfoPtr == NULL)
		return false;

	CvUnitEntry& pUnitInfo = *pUnitInfoPtr;

	const UnitClassTypes eUnitClass = (UnitClassTypes) pUnitInfo.GetUnitClassType();
	if(eUnitClass == NO_UNITCLASS)
	{
		return false;
	}

	CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
	if(pkUnitClassInfo == NULL)
	{
		return false;
	}

	if (GetPlayerTraits()->NoTrain(eUnitClass))
	{
		return false;
	}

#if defined(MOD_BALANCE_CORE_MINOR_CIV_GIFT)
	if(MOD_BALANCE_CORE_MINOR_CIV_GIFT && pUnitInfo.IsMinorCivGift() && !isBarbarian())
	{
		return false;
	}
#endif

	// Should we check whether this Unit has been blocked out by the civ XML?
	if(!bIgnoreUniqueUnitStatus)
	{
		UnitTypes eThisPlayersUnitType = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eUnitClass);

		// If the player isn't allowed to train this Unit (via XML) then return false
		if(eThisPlayersUnitType != eUnit)
		{
			return false;
		}
	}

#if defined(MOD_POLICIES_UNIT_CLASS_REPLACEMENTS)
	// If there is a replacement for the unit class, and this unit is not a unique unit
	if (MOD_POLICIES_UNIT_CLASS_REPLACEMENTS && !bIgnoreUniqueUnitStatus && GetUnitClassReplacement(eUnitClass) != NO_UNITCLASS)
	{
		if (eUnit == (UnitTypes)pkUnitClassInfo->getDefaultUnitIndex())
		{
			return false;
		}
	}
#endif

	if(!bIgnoreCost)
	{
		if(pUnitInfo.GetProductionCost() == -1)
		{
			return false;
		}
	}

#if defined(MOD_BALANCE_CORE)
	ResourceTypes eResource = (ResourceTypes)pUnitInfo.GetResourceType();
	if (MOD_BALANCE_CORE && eResource != NO_RESOURCE && !isBarbarian())
	{
		if (getNumResourceTotal(eResource, true) <= 0)
		{
			return false;
		}
	}

	if(pUnitInfo.IsWarOnly())
	{
		if(!IsAtWarAnyMajor())
		{
			return false;
		}
	}
#endif

	
	if (pUnitInfo.IsFound() || pUnitInfo.IsFoundAbroad())
	{
		// No Settlers for non-majors
		if (!isMajorCiv())
		{
			return false;
		}
		// One City Challenge
		if (GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && isHuman())
		{
			return false;
		}
	}
	
	//Policy Requirement
	PolicyTypes ePolicy = (PolicyTypes)pUnitInfo.GetPolicyType();
	if (ePolicy != NO_POLICY)
	{
		if (!GetPlayerPolicies()->HasPolicy(ePolicy))
		{
			return false;
		}
	}


	if (GC.getGame().isOption(GAMEOPTION_NO_RELIGION))
	{
		if (pUnitInfo.IsFoundReligion() || pUnitInfo.IsSpreadReligion() || pUnitInfo.IsRemoveHeresy())
		{
			return false;
		}
	}

	// Builder Limit
	if(pUnitInfo.GetWorkRate() > 0 && pUnitInfo.GetDomainType() == DOMAIN_LAND)
	{
		if(GetMaxNumBuilders() > -1 && GetNumBuilders() >= GetMaxNumBuilders())
		{
			return false;
		}
	}

	// Tech requirements
	if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pUnitInfo.GetPrereqAndTech()))))
	{
		return false;
	}

	for(int iI = 0; iI < /*3*/ GD_INT_GET(NUM_UNIT_AND_TECH_PREREQS); iI++)
	{
		if(pUnitInfo.GetPrereqAndTechs(iI) != NO_TECH)
		{
			if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pUnitInfo.GetPrereqAndTechs(iI)))))
			{
				return false;
			}
		}
	}

	// Obsolete Tech
	if((TechTypes)pUnitInfo.GetObsoleteTech() != NO_TECH)
	{
		if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pUnitInfo.GetObsoleteTech())))
		{
			return false;
		}
	}

	// Game Unit Class Max
	if(GC.getGame().isUnitClassMaxedOut(eUnitClass))
	{
		return false;
	}

	// Team Unit Class Max
	if(GET_TEAM(getTeam()).isUnitClassMaxedOut(eUnitClass))
	{
		return false;
	}

	// Player Unit Class Max
	if(isUnitClassMaxedOut(eUnitClass))
	{
		return false;
	}

	// Spaceship part we already have?
	ProjectTypes eProject = (ProjectTypes) pUnitInfo.GetSpaceshipProject();
	if(eProject != NO_PROJECT)
	{
		if(GET_TEAM(getTeam()).isProjectMaxedOut(eProject))
			return false;

		int iUnitAndProjectCount = GET_TEAM(getTeam()).getProjectCount(eProject) + getUnitClassCount(eUnitClass) + GET_TEAM(getTeam()).getUnitClassMaking(eUnitClass) + ((bContinue) ? -1 : 0);
		if(iUnitAndProjectCount >= pkUnitClassInfo->getMaxPlayerInstances())
		{
			return false;
		}
	}

	//this flag seems to be needed to check whether we should show the unit in the build list at all, and if it's greyed out generate a tooltip why
	if(!bTestVisible)
	{
		// Settlers
		if(pUnitInfo.IsFound() || pUnitInfo.IsFoundAbroad())
		{
			if (IsEmpireVeryUnhappy() && /*1 in CP, 0 in VP*/ GD_INT_GET(VERY_UNHAPPY_CANT_TRAIN_SETTLERS) == 1)
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_VERY_UNHAPPY_SETTLERS");
				if(toolTipSink == NULL)
					return false;
			}
		}

		// Project required?
		ProjectTypes ePrereqProject = (ProjectTypes) pUnitInfo.GetProjectPrereq();
		if(ePrereqProject != NO_PROJECT)
		{
			CvProjectEntry* pkProjectInfo = GC.getProjectInfo(ePrereqProject);
			if(pkProjectInfo)
			{
				if(GET_TEAM(getTeam()).getProjectCount(ePrereqProject) == 0)
				{
					GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_UNIT_PROJECT_REQUIRED", pkProjectInfo->GetDescription());
					if(toolTipSink == NULL)
						return false;
				}
			}
		}

		// Resource Requirements
		for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
		{
			const ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);
			CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);
			if(pkResourceInfo)
			{
				const int iNumResource = pUnitInfo.GetResourceQuantityRequirement(eResource);

				if(iNumResource > 0)
				{
					// Starting project, need enough Resources plus some to start
					if(!bContinue && getNumResourceAvailable(eResource) < iNumResource)
					{
						GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_UNIT_LACKS_RESOURCES", pkResourceInfo->GetIconString(), pkResourceInfo->GetTextKey(), iNumResource);
						if(toolTipSink == NULL)
							return false;
					}
					// Continuing project, need enough Resources
					else if(bContinue && (getNumResourceAvailable(eResource) < 0))
					{
						GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_UNIT_LACKS_RESOURCES", pkResourceInfo->GetIconString(), pkResourceInfo->GetTextKey(), iNumResource);
						if(toolTipSink == NULL)
							return false;
					}
				}
#if defined(MOD_UNITS_RESOURCE_QUANTITY_TOTALS)
				if (MOD_UNITS_RESOURCE_QUANTITY_TOTALS)
				{
					int iNumResourceTotal = pUnitInfo.GetResourceQuantityTotal(eResource);

					if (iNumResourceTotal > 0)
					{
						if (getNumResourceTotal(eResource) < iNumResourceTotal)
						{
							GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_UNIT_LACKS_GROSS_RESOURCES", pkResourceInfo->GetIconString(), pkResourceInfo->GetTextKey(), iNumResourceTotal);
							if (toolTipSink == NULL)
								return false;
						}
						else if (getNumResourceAvailable(eResource) < 0)
						{
							GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_UNIT_NET_RESOURCES_NEGATIVE", pkResourceInfo->GetIconString(), pkResourceInfo->GetTextKey());
							if (toolTipSink == NULL)
								return false;
						}
					}
				}
#endif
			}

		}

		if(GC.getGame().isUnitClassMaxedOut(eUnitClass, (GET_TEAM(getTeam()).getUnitClassMaking(eUnitClass) + ((bContinue) ? -1 : 0))))
		{
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_GAME_COUNT_MAX", "", "", pkUnitClassInfo->getMaxTeamInstances());
			if(toolTipSink == NULL)
				return false;
		}

		if(GET_TEAM(getTeam()).isUnitClassMaxedOut(eUnitClass, (GET_TEAM(getTeam()).getUnitClassMaking(eUnitClass) + ((bContinue) ? -1 : 0))))
		{
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_TEAM_COUNT_MAX", "", "", pkUnitClassInfo->getMaxTeamInstances());
			if(toolTipSink == NULL)
				return false;
		}

		if(isUnitClassMaxedOut(eUnitClass, (getUnitClassMaking(eUnitClass) + ((bContinue) ? -1 : 0))))
		{
#if defined(MOD_BALANCE_CORE)
			if(isNationalUnitClass(eUnitClass))
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_PLAYER_COUNT_MAX", "", "", pkUnitClassInfo->getMaxPlayerInstances());
				if(toolTipSink == NULL)
					return false;
			}
			if(isUnitLimitPerCity(eUnitClass))
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_PLAYER_CITY_COUNT_MAX", "", "", (getNumCities() * pkUnitClassInfo->getUnitInstancePerCity()));
				if(toolTipSink == NULL)
					return false;
			}
#else
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_PLAYER_COUNT_MAX", "", "", pkUnitClassInfo->getMaxPlayerInstances());
			if(toolTipSink == NULL)
				return false;
#endif
		}

		if(GC.getGame().isNoNukes() || !GC.getGame().isNukesValid())
		{
			if(pUnitInfo.GetNukeDamageLevel() != -1)
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_NUKES");
				if(toolTipSink == NULL)
					return false;
			}
		}

		if(pUnitInfo.GetNukeDamageLevel() != -1)
		{
			if(GC.getGame().GetGameLeagues()->IsNoTrainingNuclearWeapons(GetID()))
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_NUKES_BY_RESOLUTION");
				if(toolTipSink == NULL)
					return false;
			}
		}

		if(pUnitInfo.GetSpecialUnitType() != NO_SPECIALUNIT)
		{
			if(!(GC.getGame().isSpecialUnitValid((SpecialUnitTypes)(pUnitInfo.GetSpecialUnitType()))))
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_SPECIAL_UNIT");
				if(toolTipSink == NULL)
					return false;
			}
		}

		if (pUnitInfo.IsTrade())
		{
			if (GetTrade()->GetNumTradeUnitsRemaining(!bContinue) <= 0)
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_TRADE_UNIT_CONSTRUCTION_NO_EXTRA_SLOTS");
				if (toolTipSink == NULL)
					return false;			
			}

			DomainTypes eDomain = (DomainTypes)pUnitInfo.GetDomainType();
			if (!GetTrade()->CanCreateTradeRoute(eDomain))
			{
				if (eDomain == DOMAIN_LAND)
				{
					GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_TRADE_UNIT_CONSTRUCTION_NONE_OF_TYPE_LAND");
				}
				else if (eDomain == DOMAIN_SEA)
				{
					GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_TRADE_UNIT_CONSTRUCTION_NONE_OF_TYPE_SEA");
				}
				if (toolTipSink == NULL)
					return false;
			}
		}
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(eUnit);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if(LuaSupport::CallTestAll(pkScriptSystem, "PlayerCanTrain", args.get(), bResult))
		{
			// Check the result.
			if(bResult == false)
			{
				return false;
			}
		}
	}

	return true;
}

#if defined(MOD_BALANCE_CORE)
bool CvPlayer::canBarbariansTrain(UnitTypes eUnit, bool bIgnoreUniqueUnitStatus, ResourceTypes eResourceNearby) const
{
	CvUnitEntry* pUnitInfoPtr = GC.getUnitInfo(eUnit);
	if (pUnitInfoPtr == NULL)
		return false;

	CvUnitEntry& pUnitInfo = *pUnitInfoPtr;

	const UnitClassTypes eUnitClass = (UnitClassTypes)pUnitInfo.GetUnitClassType();
	if (eUnitClass == NO_UNITCLASS)
	{
		return false;
	}

	CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
	if (pkUnitClassInfo == NULL)
	{
		return false;
	}

	if (GetPlayerTraits()->NoTrain(eUnitClass))
	{
		return false;
	}

	// Should we check whether this Unit has been blocked out by the civ XML?
	if (!bIgnoreUniqueUnitStatus)
	{
		UnitTypes eThisPlayersUnitType = GetSpecificUnitType(eUnitClass);

		// If the player isn't allowed to train this Unit (via XML) then return false
		if (eThisPlayersUnitType != eUnit)
		{
			return false;
		}
	}

	if (pUnitInfo.GetProductionCost() == -1)
	{
		return false;
	}

	//Policy Requirement
	PolicyTypes ePolicy = (PolicyTypes)pUnitInfo.GetPolicyType();
	if (ePolicy != NO_POLICY)
	{
		if (!GetPlayerPolicies()->HasPolicy(ePolicy))
		{
			return false;
		}
	}

	if (pUnitInfo.IsFoundReligion() || pUnitInfo.IsSpreadReligion() || pUnitInfo.IsRemoveHeresy())
	{
		return false;
	}
	// Builder Limit
	if (pUnitInfo.GetWorkRate() > 0 && pUnitInfo.GetDomainType() == DOMAIN_LAND)
	{
		return false;
	}

	// Tech requirements
	if (!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pUnitInfo.GetPrereqAndTech()))))
	{
		return false;
	}

	int iI;
	for (iI = 0; iI < /*3*/ GD_INT_GET(NUM_UNIT_AND_TECH_PREREQS); iI++)
	{
		if (pUnitInfo.GetPrereqAndTechs(iI) != NO_TECH)
		{
			if (!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pUnitInfo.GetPrereqAndTechs(iI)))))
			{
				return false;
			}
		}
	}

	// Obsolete Tech
	if ((TechTypes)pUnitInfo.GetObsoleteTech() != NO_TECH)
	{
		if (GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pUnitInfo.GetObsoleteTech())))
		{
			return false;
		}
	}

	// Game Unit Class Max
	if (GC.getGame().isUnitClassMaxedOut(eUnitClass))
	{
		return false;
	}

	// Team Unit Class Max
	if (GET_TEAM(getTeam()).isUnitClassMaxedOut(eUnitClass))
	{
		return false;
	}

	// Player Unit Class Max
	if (isUnitClassMaxedOut(eUnitClass))
	{
		return false;
	}

	// Spaceship part we already have?
	ProjectTypes eProject = (ProjectTypes)pUnitInfo.GetSpaceshipProject();
	if (eProject != NO_PROJECT)
	{
		return false;
	}

	// Settlers
	if (pUnitInfo.IsFound() || pUnitInfo.IsFoundAbroad())
	{
		return false;
	}

	// Project required?
	ProjectTypes ePrereqProject = (ProjectTypes)pUnitInfo.GetProjectPrereq();
	if (ePrereqProject != NO_PROJECT)
	{
		return false;
	}

	// Resource Requirements
	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		const ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);
		CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);
		if (pkResourceInfo)
		{
			const int iNumResource = pUnitInfo.GetResourceQuantityRequirement(eResource);

			if (iNumResource > 0 && eResource != eResourceNearby)
			{
				return false;
			}

#if defined(MOD_UNITS_RESOURCE_QUANTITY_TOTALS)
			if (MOD_UNITS_RESOURCE_QUANTITY_TOTALS)
			{
				int iNumResourceTotal = pUnitInfo.GetResourceQuantityTotal(eResource);

				if (iNumResourceTotal > 0 && eResource != eResourceNearby)
				{
					return false;
				}
			}
#endif
		}

	}

	if (pUnitInfo.GetNukeDamageLevel() != -1)
	{
		return false;
	}
	//Had to set it this way because Barbarian land units are "SPECIALUNIT_CARGO_ARMY" in MOD_CARGO_SHIPS. Need to be able to spawn them.
	SpecialUnitTypes eSpedcialPeople = (SpecialUnitTypes) GC.getInfoTypeForString("SPECIALUNIT_PEOPLE");
	SpecialUnitTypes eSpedcialFighter = (SpecialUnitTypes) GC.getInfoTypeForString("SPECIALUNIT_FIGHTER");
	SpecialUnitTypes eSpedcialStealth = (SpecialUnitTypes) GC.getInfoTypeForString("SPECIALUNIT_STEALTH");
	SpecialUnitTypes eSpedcialMissile = (SpecialUnitTypes) GC.getInfoTypeForString("SPECIALUNIT_MISSILE");
	if ((pUnitInfo.GetSpecialUnitType() == eSpedcialPeople) || (pUnitInfo.GetSpecialUnitType() == eSpedcialFighter) || (pUnitInfo.GetSpecialUnitType() == eSpedcialStealth) || (pUnitInfo.GetSpecialUnitType() == eSpedcialMissile))
	{
		return false;
	}

	if (pUnitInfo.IsTrade())
	{
		return false;
	}

	return true;
}
#endif
//	--------------------------------------------------------------------------------
bool CvPlayer::canConstruct(BuildingTypes eBuilding, bool bContinue, bool bTestVisible, bool bIgnoreCost, CvString* toolTipSink) const
{
	std::vector<int> vTotalBuildingCount( GC.getNumBuildingInfos(), 0);
	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity && !pLoopCity->IsPuppet())
		{
			const std::vector<BuildingTypes>& vBuildings = pLoopCity->GetCityBuildings()->GetAllBuildingsHere();
			for (size_t i=0; i<vBuildings.size(); i++)
				vTotalBuildingCount[ vBuildings[i] ]++;
		}
	}

	return canConstruct(eBuilding,vTotalBuildingCount,bContinue,bTestVisible,bIgnoreCost,toolTipSink);
}

bool CvPlayer::canConstruct(BuildingTypes eBuilding, const std::vector<int>& vPreExistingBuildings, bool bContinue, bool bTestVisible, bool bIgnoreCost, CvString* toolTipSink) const
{
	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if(pkBuildingInfo == NULL)
		return false;

	// Don't allow a city to consider an espionage building if they are playing a non-espionage game
	if (pkBuildingInfo->IsEspionage() && pkBuildingInfo->GetDefenseHappinessChangeBuilding() == 0 && pkBuildingInfo->GetDefenseHappinessChangeBuildingGlobal() == 0 && GC.getGame().isOption(GAMEOPTION_NO_ESPIONAGE))
	{
		return false;
	}

	CvBuildingEntry& pBuildingInfo = *pkBuildingInfo;

	int iI;
	CvTeam& currentTeam = GET_TEAM(getTeam());

	const BuildingClassTypes eBuildingClass = ((BuildingClassTypes)(pBuildingInfo.GetBuildingClassType()));
	const CvBuildingClassInfo& kBuildingClass = pkBuildingInfo->GetBuildingClassInfo();

	// Checks to make sure civilization doesn't have an override that prevents construction of this building
	if(getCivilizationInfo().getCivilizationBuildings(eBuildingClass) != eBuilding)
	{
		return false;
	}

	if(!bIgnoreCost)
	{
		if(pBuildingInfo.GetProductionCost() == -1)
		{
			return false;
		}
	}

	PolicyBranchTypes eBranch = (PolicyBranchTypes)pBuildingInfo.GetPolicyBranchType();
	if (eBranch != NO_POLICY_BRANCH_TYPE)
	{
		if (!GetPlayerPolicies()->IsPolicyBranchUnlocked(eBranch))
		{
			return false;
		}
	}
#if defined(MOD_BALANCE_CORE_POLICIES)
	PolicyTypes ePolicy = (PolicyTypes)pBuildingInfo.GetPolicyType();
	if (MOD_BALANCE_CORE_POLICIES && ePolicy != NO_POLICY)
	{
		if (!GetPlayerPolicies()->HasPolicy(ePolicy))
		{
			return false;
		}
	}
#endif
#if defined(MOD_BALANCE_CORE)
	ResourceTypes eResource = (ResourceTypes)pBuildingInfo.GetResourceType();
	if (MOD_BALANCE_CORE && eResource != NO_RESOURCE)
	{
		if (getNumResourceTotal(eResource, true) <= 0)
		{
			return false;
		}
	}
#endif
	if(!(currentTeam.GetTeamTechs()->HasTech((TechTypes)(pBuildingInfo.GetPrereqAndTech()))))
	{
		return false;
	}
	for(iI = 0; iI < /*3*/ GD_INT_GET(NUM_BUILDING_AND_TECH_PREREQS); iI++)
	{
		if(pBuildingInfo.GetPrereqAndTechs(iI) != NO_TECH)
		{
			if(!(currentTeam.GetTeamTechs()->HasTech((TechTypes)(pBuildingInfo.GetPrereqAndTechs(iI)))))
			{
				return false;
			}
		}
	}

	if(currentTeam.isObsoleteBuilding(eBuilding))
	{
		return false;
	}

	// Building upgrade to another type
	BuildingClassTypes eReplacementBuildingClass = (BuildingClassTypes) pBuildingInfo.GetReplacementBuildingClass();

	if(eReplacementBuildingClass != NO_BUILDINGCLASS)
	{
		BuildingTypes eUpgradeBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(eReplacementBuildingClass)));

		if(canConstruct(eUpgradeBuilding))
		{
			return false;
		}
	}

	if(pBuildingInfo.GetVictoryPrereq() != NO_VICTORY)
	{
		if(!(GC.getGame().isVictoryValid((VictoryTypes)(pBuildingInfo.GetVictoryPrereq()))))
		{
			return false;
		}

		if(isMinorCiv())
		{
			return false;
		}

		if(currentTeam.getVictoryCountdown((VictoryTypes)pBuildingInfo.GetVictoryPrereq()) >= 0)
		{
			return false;
		}
	}

	if(pBuildingInfo.GetMaxStartEra() != NO_ERA)
	{
		if(GC.getGame().getStartEra() > pBuildingInfo.GetMaxStartEra())
		{
			return false;
		}
	}

	if(GC.getGame().isBuildingClassMaxedOut(eBuildingClass))
	{
		return false;
	}

	if(currentTeam.isBuildingClassMaxedOut(eBuildingClass))
	{
		return false;
	}

	if(isBuildingClassMaxedOut(eBuildingClass))
	{
		return false;
	}

	if (pBuildingInfo.GetNumRequiredTier3Tenets() > 0)
	{
		PolicyBranchTypes eIdeology = GetPlayerPolicies()->GetLateGamePolicyTree();
		if (eIdeology == NO_POLICY_BRANCH_TYPE)
			return false;
	}
	

	///////////////////////////////////////////////////////////////////////////////////
	// Everything above this is what is checked to see if Building shows up in the list of construction items
	///////////////////////////////////////////////////////////////////////////////////

	if(!bTestVisible)
	{
		if (pBuildingInfo.GetNumRequiredTier3Tenets() > 0)
		{
			PolicyBranchTypes eIdeology = GetPlayerPolicies()->GetLateGamePolicyTree();

			int iNumTenets = GetPlayerPolicies()->GetNumTenetsOfLevel(eIdeology, 3);
			if (iNumTenets < pBuildingInfo.GetNumRequiredTier3Tenets())
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_TENETS_COUNT_NEEDED", pkBuildingInfo->GetTextKey(), "", pBuildingInfo.GetNumRequiredTier3Tenets() - iNumTenets);

				if (toolTipSink == NULL)
					return false;
			}
		}

		// Num buildings in the empire... uhhh, how is this different from the very last check in this function? (JON: It doesn't appear to be used, but I can't say for sure :)
		const CvCivilizationInfo& civilizationInfo = getCivilizationInfo();
		int numBuildingClassInfos = GC.getNumBuildingClassInfos();

		for(iI = 0; iI < numBuildingClassInfos; iI++)
		{
			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo((BuildingClassTypes)iI);
			if(!pkBuildingClassInfo)
			{
				continue;
			}

			BuildingTypes ePrereqBuilding = (BuildingTypes)civilizationInfo.getCivilizationBuildings(iI);

			if(NO_BUILDING != ePrereqBuilding && currentTeam.isObsoleteBuilding(ePrereqBuilding))
			{
				CvBuildingEntry* pkPrereqBuilding = GC.getBuildingInfo(ePrereqBuilding);
				if(pkPrereqBuilding)
				{
					int iNumHave = getBuildingClassCount((BuildingClassTypes)iI);

					int iNumNeeded = getBuildingClassPrereqBuilding(eBuilding, (BuildingClassTypes)iI, 0);

					if(iNumHave < iNumNeeded)
					{
						GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_COUNT_NEEDED", pkPrereqBuilding->GetTextKey(), "", iNumNeeded - iNumHave);

						if(toolTipSink == NULL)
							return false;
					}
				}
			}
		}

		// Resource Requirements
		for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
		{
			const ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);
			CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
			if(pkResource)
			{
				int iNumResource = pBuildingInfo.GetResourceQuantityRequirement(eResource);
				if(iNumResource > 0)
				{
					if(bContinue)
						iNumResource = 0;

					if(getNumResourceAvailable(eResource) < iNumResource)
					{
						GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_LACKS_RESOURCES", pkResource->GetIconString(), pkResource->GetTextKey(), iNumResource);
						if(toolTipSink == NULL)
							return false;
					}
				}
			}
		}

		if(GC.getGame().isBuildingClassMaxedOut(eBuildingClass, (currentTeam.getBuildingClassMaking(eBuildingClass) + ((bContinue) ? -1 : 0))))
		{
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_GAME_COUNT_MAX", "", "", kBuildingClass.getMaxGlobalInstances());
			if(toolTipSink == NULL)
				return false;
		}

		if(currentTeam.isBuildingClassMaxedOut(eBuildingClass, (currentTeam.getBuildingClassMaking(eBuildingClass) + ((bContinue) ? -1 : 0))))
		{
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_TEAM_COUNT_MAX", "", "", kBuildingClass.getMaxTeamInstances());
			if(toolTipSink == NULL)
				return false;
		}

		if(isBuildingClassMaxedOut(eBuildingClass, (getBuildingClassMaking(eBuildingClass) + ((bContinue) ? -1 : 0))))
		{
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_PLAYER_COUNT_MAX", "", "", kBuildingClass.getMaxPlayerInstances());
			if(toolTipSink == NULL)
				return false;
		}

		if(getNumCities() < pBuildingInfo.GetNumCitiesPrereq())
		{
			return false;
		}

		if(getHighestUnitLevel() < pBuildingInfo.GetUnitLevelPrereq())
		{
			return false;
		}
#if defined(MOD_BALANCE_CORE)
		if(GetPlayerPolicies() && !isMinorCiv() && !isBarbarian())
		{
			int iNumPoliciesNeeded = pBuildingInfo.GetNumPoliciesNeeded();
			if (iNumPoliciesNeeded > 0)
			{
				//If # of policies will do it, then we need to see the either/or here.
				int iNumPolicies = GetPlayerPolicies()->GetNumPoliciesOwned(true);

				int iCSPolicyReduction = GetCSAlliesLowersPolicyNeedWonders();
				if (iCSPolicyReduction > 0)
				{
					int iNumAllies = GetNumCSAllies();
					iNumPoliciesNeeded -= (iNumAllies / iCSPolicyReduction);
				}

				CvGameReligions* pReligions = GC.getGame().GetGameReligions();
				ReligionTypes eOwnedReligion = GetReligions()->GetOwnedReligion();
				if (eOwnedReligion != NO_RELIGION)
				{
					const CvReligion* pReligion = pReligions->GetReligion(eOwnedReligion, GetID());
					if (pReligion)
					{
						CvCity* pHolyCity = pReligion->GetHolyCity();
						if (pHolyCity == NULL)
						{
							pHolyCity = GET_PLAYER(GetID()).getCapitalCity();
						}
						int iReligionPolicyReduction = pReligion->m_Beliefs.GetPolicyReductionWonderXFollowerCities(GetID(), pHolyCity);
						if (iReligionPolicyReduction > 0)
						{
							int iNumFollowerCities = pReligions->GetNumCitiesFollowing(eOwnedReligion);
							if (iNumFollowerCities > 0)
							{
								iNumPoliciesNeeded -= (iNumFollowerCities / iReligionPolicyReduction);
							}
						}

						// Depends on era of wonder
						EraTypes eEra;
						TechTypes eTech = (TechTypes)pBuildingInfo.GetPrereqAndTech();
						if (eTech != NO_TECH)
						{
							CvTechEntry* pEntry = GC.GetGameTechs()->GetEntry(eTech);
							if (pEntry)
							{
								eEra = (EraTypes)pEntry->GetEra();
								if (eEra != NO_ERA)
								{
									CvCity* pHolyCity = pReligion->GetHolyCity();
									if (pHolyCity == NULL)
									{
										pHolyCity = GET_PLAYER(GetID()).getCapitalCity();
									}
									iNumPoliciesNeeded -= pReligion->m_Beliefs.GetIgnorePolicyRequirementsAmount(eEra, GetID(), pHolyCity);
								}
							}
						}
					}
				}
				if (iNumPolicies < iNumPoliciesNeeded)
				{
					GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_NEED_POLICIES", pkBuildingInfo->GetTextKey(), "", iNumPoliciesNeeded - iNumPolicies);
					if (toolTipSink == NULL)
						return false;
				}
			}
		}
#endif

#if defined(MOD_BALANCE_CORE_POP_REQ_BUILDINGS)
		//Requires a certain population size, nationally.
		if(MOD_BALANCE_CORE_POP_REQ_BUILDINGS)
		{
			int iPopRequired = GetScalingNationalPopulationRequrired(eBuilding);
			if(iPopRequired > 0)
			{
				int iCurrentPop = getTotalPopulation();
				if(iCurrentPop < iPopRequired)
				{
					GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_NEED_NATIONAL_POP", pkBuildingInfo->GetTextKey(), "", iPopRequired - iCurrentPop);
					if(toolTipSink == NULL)
					return false;
				}
			}
		}
#endif
		//Requires a certain religion follower size, either nationally or globally.
		if (MOD_BALANCE_CORE_FOLLOWER_POP_WONDER)
		{
			CvGameReligions* pReligions = GC.getGame().GetGameReligions();
			ReligionTypes eOwnedReligion = GetReligions()->GetOwnedReligion();
			if (eOwnedReligion != NO_RELIGION)
			{
				const CvReligion* pReligion = pReligions->GetReligion(eOwnedReligion, GetID());
				if (pReligion)
				{
					if (pkBuildingInfo->GetNationalFollowerPopRequired() > 0)
					{
						CvCity* pHolyCity = pReligion->GetHolyCity();
						if (pHolyCity == NULL)
						{
							pHolyCity = GET_PLAYER(GetID()).getCapitalCity();
						}
						if (pReligion->m_Beliefs.IsBuildingClassEnabled(eBuildingClass, GetID(), pHolyCity, true))
						{
							int iPopRequired = pkBuildingInfo->GetNationalFollowerPopRequired();
							int iLoop;
							int iCurrentPop = 0;
							for (CvCity* pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
							{
								iCurrentPop += pLoopCity->GetCityReligions()->GetNumFollowers(eOwnedReligion);
							}
							if (iCurrentPop < iPopRequired)
							{
								GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_NEED_FOLLOWER_POP", pkBuildingInfo->GetTextKey(), "", iPopRequired - iCurrentPop);
								if (toolTipSink == NULL)
									return false;
							}
						}
					}
					if(pkBuildingInfo->GetGlobalFollowerPopRequired() > 0)
					{
						CvCity* pHolyCity = pReligion->GetHolyCity();
						if (pHolyCity == NULL)
						{
							pHolyCity = GET_PLAYER(GetID()).getCapitalCity();
						}
						if (pReligion->m_Beliefs.IsBuildingClassEnabled(eBuildingClass, GetID(), pHolyCity))
						{
							int iPopRequiredPercent = pkBuildingInfo->GetGlobalFollowerPopRequired();
							iPopRequiredPercent -= GetReformationFollowerReduction();
							if (GC.getMap().getWorldInfo().getReformationPercent() > 0)
							{
								iPopRequiredPercent *= GC.getMap().getWorldInfo().getReformationPercent();
								iPopRequiredPercent /= 100;
							}

							int iCurrentPop = pReligions->GetNumFollowers(eOwnedReligion);
							int iCurrentPopPercent = (iCurrentPop * 100) / GC.getGame().getTotalPopulation();

							if (iCurrentPopPercent < iPopRequiredPercent)
							{
								int iPercentage = iPopRequiredPercent - iCurrentPopPercent;
								GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_NEED_GLOBAL_FOLLOWER_POP", pkBuildingInfo->GetTextKey(), "", iPercentage);
								if (toolTipSink == NULL)
									return false;
							}
						}
					}
				}
			}
		}

		BuildingTypes ePrereqBuilding;
		int iNumNeeded;
		for(iI = 0; iI < numBuildingClassInfos; iI++)
		{
			iNumNeeded = getBuildingClassPrereqBuilding(eBuilding, ((BuildingClassTypes)iI), bContinue);
			//int iNumHave = getBuildingClassCount((BuildingClassTypes)iI);
			ePrereqBuilding = (BuildingTypes) civilizationInfo.getCivilizationBuildings(iI);
			if(NO_BUILDING != ePrereqBuilding)
			{
				CvBuildingEntry* pkPrereqBuilding = GC.getBuildingInfo(ePrereqBuilding);
				if(pkPrereqBuilding)
				{
					int iNumHave = vPreExistingBuildings[ePrereqBuilding];
					if(iNumHave < iNumNeeded)
					{
						ePrereqBuilding = (BuildingTypes) civilizationInfo.getCivilizationBuildings(iI);

						GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_COUNT_NEEDED", pkPrereqBuilding->GetTextKey(), "", iNumNeeded - iNumHave);

						if(toolTipSink == NULL)
							return false;

						// If we have less than 5 to go, list what cities need them
						int iNonPuppetCities = getNumCities() - GetNumPuppetCities();
						if(iNumNeeded == iNonPuppetCities && iNumNeeded - iNumHave < 5)
						{
							(*toolTipSink) += "[NEWLINE]";

							int iLoop=0;
							for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								if(pLoopCity && !pLoopCity->IsPuppet() && pLoopCity->GetCityBuildings()->GetNumBuilding(ePrereqBuilding) == 0)
								{
									(*toolTipSink) += pLoopCity->getName();
									(*toolTipSink) += " ";
								}
							}
						}
					}
				}
			}
		}
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(eBuilding);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if(LuaSupport::CallTestAll(pkScriptSystem, "PlayerCanConstruct", args.get(), bResult))
		{
			// Check the result.
			if(bResult == false)
			{
				return false;
			}
		}
	}

	return true;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::canCreate(ProjectTypes eProject, bool bContinue, bool bTestVisible) const
{
	CvProjectEntry* pkProjectInfo = GC.getProjectInfo(eProject);
	if(!pkProjectInfo)
	{
		return false;
	}

	CvProjectEntry& pProjectInfo = *pkProjectInfo;

	int iI;

	// No projects for barbs
	if(isBarbarian())
	{
		return false;
	}

	// no minors either
	if(isMinorCiv())
	{
		return false;
	}

	// If cost is -1 then that means it can't be built
	if(pProjectInfo.GetProductionCost() == -1)
	{
		return false;
	}

	// Tech requirement
	if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pProjectInfo.GetTechPrereq()))))
	{
		return false;
	}

	// Policy branch requirement?
	if(pProjectInfo.GetCultureBranchesRequired() > 0)
	{
		if(GetPlayerPolicies()->GetNumPolicyBranchesFinished() < pProjectInfo.GetCultureBranchesRequired())
		{
			return false;
		}
	}

	// Requires a particular victory condition to be enabled?
	if(pProjectInfo.GetVictoryPrereq() != NO_VICTORY)
	{
		if(!(GC.getGame().isVictoryValid((VictoryTypes)(pProjectInfo.GetVictoryPrereq()))))
		{
			return false;
		}

		if(isMinorCiv())
		{
			return false;
		}

		if(GET_TEAM(getTeam()).getVictoryCountdown((VictoryTypes)pProjectInfo.GetVictoryPrereq()) >= 0)
		{
			return false;
		}
	}

	if (!pProjectInfo.IsRepeatable())
	{
		if (GC.getGame().isProjectMaxedOut(eProject))
		{
			return false;
		}

		if (GET_TEAM(getTeam()).isProjectMaxedOut(eProject))
		{
			return false;
		}
	}

	if (pProjectInfo.GetNumRequiredTier3Tenets())
	{
		PolicyBranchTypes eIdeology = GetPlayerPolicies()->GetLateGamePolicyTree();
		if (eIdeology == NO_POLICY_BRANCH_TYPE)
			return false;

		int iNumTenets = GetPlayerPolicies()->GetNumTenetsOfLevel(eIdeology, 3);
		if (iNumTenets < pProjectInfo.GetNumRequiredTier3Tenets())
			return false;
	}

	if(!bTestVisible)
	{
		if (pProjectInfo.InfluenceAllRequired())
		{
			if (GetCulture()->GetNumCivsInfluentialOn() < GC.getGame().GetGameCulture()->GetNumCivsInfluentialForWin())
				return false;
		}

		if (pProjectInfo.IdeologyRequired())
		{
			if (GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
				return false;
			else if (GetCulture()->GetPublicOpinionType() > PUBLIC_OPINION_CONTENT)
				return false;
		}

		// Resource Requirements
		ResourceTypes eResource;
		int iNumResource;
		for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
		{
			eResource = (ResourceTypes) iResourceLoop;
			iNumResource = pProjectInfo.GetResourceQuantityRequirement(eResource);

			if(iNumResource > 0)
			{
				if(getNumResourceAvailable(eResource) < iNumResource)
				{
					return false;
				}
			}
		}

		if (!pProjectInfo.IsRepeatable())
		{
			if (GC.getGame().isProjectMaxedOut(eProject, (GET_TEAM(getTeam()).getProjectMaking(eProject) + ((bContinue) ? -1 : 0))))
			{
				return false;
			}

			if (GET_TEAM(getTeam()).isProjectMaxedOut(eProject, (GET_TEAM(getTeam()).getProjectMaking(eProject) + ((bContinue) ? -1 : 0))))
			{
				return false;
			}
		}

		// Nukes disabled? (by UN or something)
		if(GC.getGame().isNoNukes())
		{
			if(pProjectInfo.IsAllowsNukes())
			{
				for(iI = 0; iI < GC.getNumUnitInfos(); iI++)
				{
					CvUnitEntry* pkUnitEntry = GC.getUnitInfo((UnitTypes)iI);
					if(pkUnitEntry && pkUnitEntry->GetNukeDamageLevel() != -1)
					{
						return false;
					}
				}
			}
		}

		if(pProjectInfo.GetAnyoneProjectPrereq() != NO_PROJECT)
		{
			if(GC.getGame().getProjectCreatedCount((ProjectTypes)(pProjectInfo.GetAnyoneProjectPrereq())) == 0)
			{
				return false;
			}
		}

		for(iI = 0; iI < GC.getNumProjectInfos(); iI++)
		{
			if(GET_TEAM(getTeam()).getProjectCount((ProjectTypes)iI) < pProjectInfo.GetProjectsNeeded(iI))
			{
				return false;
			}
		}
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(eProject);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if(LuaSupport::CallTestAll(pkScriptSystem, "PlayerCanCreate", args.get(), bResult))
		{
			// Check the result.
			if(bResult == false)
			{
				return false;
			}
		}
	}

	return true;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::canPrepare(SpecialistTypes eSpecialist, bool) const
{
	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(eSpecialist);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if(LuaSupport::CallTestAll(pkScriptSystem, "PlayerCanPrepare", args.get(), bResult))
		{
			// Check the result.
			if(bResult == false)
			{
				return false;
			}
		}
	}


	return false;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::canMaintain(ProcessTypes eProcess, bool) const
{
	// Check to see if it exists, scenarios can remove them and leave holes in the list.
	const CvProcessInfo* pkProcessInfo = GC.getProcessInfo(eProcess);
	if (!pkProcessInfo)
		return false;

	if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pkProcessInfo->getTechPrereq()))))
	{
		return false;
	}

#if defined(MOD_CIVILIZATIONS_UNIQUE_PROCESSES)
	// Is this a process that is only useable by a specific civ?
	if (MOD_CIVILIZATIONS_UNIQUE_PROCESSES)
	{
		CivilizationTypes eCivilization = pkProcessInfo->GetRequiredCivilization();
		if (eCivilization != NO_CIVILIZATION && eCivilization != getCivilizationType())
		{
			return false;
		}
	}
#endif

	for(int iI = 0; iI < GC.getNumLeagueProjectInfos(); iI++)
	{
		LeagueProjectTypes eLeagueProject = (LeagueProjectTypes) iI;
		CvLeagueProjectEntry* pInfo = GC.getLeagueProjectInfo(eLeagueProject);
		if (pInfo && pInfo->GetProcess() == eProcess)
		{
			if (!GC.getGame().GetGameLeagues()->CanContributeToLeagueProject(GetID(), eLeagueProject))
			{
				return false;
			}
		}
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(eProcess);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if(LuaSupport::CallTestAll(pkScriptSystem, "PlayerCanMaintain", args.get(), bResult))
		{
			// Check the result.
			if(bResult == false)
			{
				return false;
			}
		}
	}

	return true;
}

//	--------------------------------------------------------------------------------
/// Can we purchase this unit or building in any of our cities?
bool CvPlayer::IsCanPurchaseAnyCity(bool bTestPurchaseCost, bool bTestTrainable, UnitTypes eUnit, BuildingTypes eBuilding, YieldTypes ePurchaseYield)
{
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (pLoopCity->IsCanPurchase(bTestPurchaseCost, bTestTrainable, eUnit, eBuilding, NO_PROJECT, ePurchaseYield))
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isProductionMaxedUnitClass(UnitClassTypes eUnitClass) const
{
	if(eUnitClass == NO_UNITCLASS)
	{
		return false;
	}

	if(GC.getGame().isUnitClassMaxedOut(eUnitClass))
	{
		return true;
	}

	if(GET_TEAM(getTeam()).isUnitClassMaxedOut(eUnitClass))
	{
		return true;
	}

	if(isUnitClassMaxedOut(eUnitClass))
	{
		return true;
	}

	return false;
}

void CvPlayer::changeUnitsBuiltCount(UnitTypes eUnitType, int iValue)
{
	VALIDATE_OBJECT
		CvAssertMsg(eUnitType >= 0, "eUnitType expected to be >= 0");
	CvAssertMsg(eUnitType < GC.getNumUnitInfos(), "eUnitType expected to be < GC.getNumUnitInfos()");

	m_aiNumUnitsBuilt[eUnitType] = m_aiNumUnitsBuilt[eUnitType] + iValue;
}

int CvPlayer::getUnitsBuiltCount(UnitTypes eUnitType) const
{
	VALIDATE_OBJECT
		CvAssertMsg(eUnitType >= 0, "eUnitType expected to be >= 0");
	CvAssertMsg(eUnitType < GC.getNumUnitInfos(), "eUnitType expected to be < GC.getNumUnitInfos()");

	return m_aiNumUnitsBuilt[eUnitType];
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isProductionMaxedBuildingClass(BuildingClassTypes eBuildingClass, bool bAcquireCity) const
{
	if(eBuildingClass == NO_BUILDINGCLASS)
	{
		return false;
	}

	CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
	if(pkBuildingClassInfo == NULL)
	{
		return false;
	}

	if(!bAcquireCity)
	{
		if(GC.getGame().isBuildingClassMaxedOut(eBuildingClass))
		{
			return true;
		}
	}

	if(GET_TEAM(getTeam()).isBuildingClassMaxedOut(eBuildingClass))
	{
		return true;
	}

	if(isBuildingClassMaxedOut(eBuildingClass, ((bAcquireCity) ? pkBuildingClassInfo->getExtraPlayerInstances() : 0)))
	{
		return true;
	}

	return false;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isProductionMaxedProject(ProjectTypes eProject) const
{
	if(eProject == NO_PROJECT)
	{
		return false;
	}

	if (GC.getProjectInfo(eProject) != NULL && GC.getProjectInfo(eProject)->IsRepeatable())
		return false;

	if(GC.getGame().isProjectMaxedOut(eProject))
	{
		return true;
	}

	if(GET_TEAM(getTeam()).isProjectMaxedOut(eProject))
	{
		return true;
	}

	return false;
}


//	--------------------------------------------------------------------------------
int CvPlayer::getProductionNeeded(UnitTypes eUnit) const
{
	CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eUnit);

	CvAssertMsg(pkUnitEntry, "This should never be hit");
	if (pkUnitEntry == NULL)
		return 0;

	UnitClassTypes eUnitClass = (UnitClassTypes)pkUnitEntry->GetUnitClassType();
	CvAssert(NO_UNITCLASS != eUnitClass);

	CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
	CvAssert(pkUnitClassInfo);
	if (pkUnitClassInfo == NULL)
		return 0;

	bool bCombat = (pkUnitEntry->GetCombat() > 0 || pkUnitEntry->GetRangedCombat() > 0);
	int iProductionNeeded = pkUnitEntry->GetProductionCost();

	iProductionNeeded *= (100 + getUnitClassCount(eUnitClass) * pkUnitClassInfo->getInstanceCostModifier());
	iProductionNeeded /= 100;

	if (pkUnitEntry->GetProductionCostPerEra() != 0)
	{
		int iEra = GetCurrentEra() - 1;
		if (iEra > 0)
		{
			iProductionNeeded += pkUnitEntry->GetProductionCostPerEra() * iEra;
		}
	}

	iProductionNeeded += (pkUnitEntry->GetCostScalerNumberBuilt() * getUnitsBuiltCount(eUnit));

	if (isMinorCiv())
	{
		iProductionNeeded *= /*120 in CP, 100 in VP*/ GD_INT_GET(MINOR_CIV_PRODUCTION_PERCENT);
		iProductionNeeded /= 100;
	}

	iProductionNeeded *= /*100*/ GD_INT_GET(UNIT_PRODUCTION_PERCENT);
	iProductionNeeded /= 100;

	iProductionNeeded *= GC.getGame().getGameSpeedInfo().getTrainPercent();
	iProductionNeeded /= 100;

	iProductionNeeded *= GC.getGame().getStartEraInfo().getTrainPercent();
	iProductionNeeded /= 100;

#if defined(MOD_BALANCE_CORE)
	int iMod = 100;
	UnitCombatTypes eUnitCombat = (UnitCombatTypes)pkUnitEntry->GetUnitCombatType();
	if (eUnitCombat != NO_UNITCOMBAT && GetPlayerTraits()->GetUnitCombatProductionCostModifier(eUnitCombat).first != 0)
	{
		if (GetPlayerTraits()->GetUnitCombatProductionCostModifier(eUnitCombat).second == false || (GetPlayerTraits()->GetUnitCombatProductionCostModifier(eUnitCombat).second == true && isGoldenAge()))
		{
			iMod += GetPlayerTraits()->GetUnitCombatProductionCostModifier(eUnitCombat).first;
		}
	}
	iProductionNeeded *= iMod;
	iProductionNeeded /= 100;
#endif

	if (!isBarbarian())
	{
		if (isHuman())
		{
			if (MOD_ALTERNATIVE_DIFFICULTY)
			{
				iProductionNeeded *= std::max(0, GC.getGame().getHandicapInfo().getHumanPerEraMod() * GC.getGame().getCurrentEra() + 100);
				iProductionNeeded /= 100;
			}
		}
		else
		{
			if (bCombat)
			{
				if (isWorldUnitClass(eUnitClass))
				{
					iProductionNeeded *= GC.getGame().getHandicapInfo().getAIWorldTrainPercent();
					iProductionNeeded /= 100;
				}
				else
				{
					iProductionNeeded *= GC.getGame().getHandicapInfo().getAITrainPercent();
					iProductionNeeded /= 100;
				}

				iProductionNeeded *= std::max(0, GC.getGame().getHandicapInfo().getAIPerEraModifier() * GC.getGame().getCurrentEra() + 100);
				iProductionNeeded /= 100;
			}
			else if (MOD_ALTERNATIVE_DIFFICULTY)
			{
				iProductionNeeded *= GC.getGame().getHandicapInfo().getAICivilianPercent();
				iProductionNeeded /= 100;
			}
		}
	}

	iProductionNeeded += getUnitExtraCost(eUnitClass);

	return std::max(1, iProductionNeeded);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionNeeded(BuildingTypes eTheBuilding) const
{
	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eTheBuilding);
	if (pkBuildingInfo == NULL)
	{
		//This should never happen.
		return 1;
	}

	int iProductionNeeded = pkBuildingInfo->GetProductionCost();
	int iProductionModifier = 0;

	if (pkBuildingInfo->GetNumCityCostMod() > 0 && getNumCities() > 0)
	{
		iProductionModifier += (pkBuildingInfo->GetNumCityCostMod() * getNumCities());
	}
#if defined(MOD_BALANCE_CORE_WONDER_COST_INCREASE)
	if (MOD_BALANCE_CORE_WONDER_COST_INCREASE && isWorldWonderClass(pkBuildingInfo->GetBuildingClassInfo()))
	{
		int iLoop;
		for (const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if (pLoopCity->getNumWorldWonders() > 0)
			{
				for (int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
				{
					const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
					CvBuildingEntry* pkeBuildingInfo = GC.getBuildingInfo(eBuilding);
					if (pkeBuildingInfo == NULL)
					{
						//This should never happen.
						continue;
					}
				
					// Has this Building
					if (pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
					{
						if (isWorldWonderClass(pkeBuildingInfo->GetBuildingClassInfo()))
						{
							if (pkeBuildingInfo->GetPrereqAndTech() == NO_TECH)
								continue;

							CvTechEntry* pkTechInfo = GC.getTechInfo((TechTypes)pkeBuildingInfo->GetPrereqAndTech());
							if (pkTechInfo)
							{
								// Loop through all eras and apply Building production mod based on how much time has passed
								EraTypes eBuildingUnlockedEra = (EraTypes)pkTechInfo->GetEra();

								if (eBuildingUnlockedEra == NO_ERA)
									continue;

								int iEraDivisor = GetCurrentEra() - eBuildingUnlockedEra;
								switch (iEraDivisor)
								{
								case 0:
									iProductionModifier += /*25*/ GD_INT_GET(BALANCE_CORE_WORLD_WONDER_SAME_ERA_COST_MODIFIER);
									break;
								case 1:
									iProductionModifier += /*15*/ GD_INT_GET(BALANCE_CORE_WORLD_WONDER_PREVIOUS_ERA_COST_MODIFIER);
									break;
								case 2:
									iProductionModifier += /*10*/ GD_INT_GET(BALANCE_CORE_WORLD_WONDER_EARLIER_ERA_COST_MODIFIER);
									break;
								}
							}
						}
					}
				}
			}
		}
	}
#endif

	if (isMinorCiv())
	{
		iProductionNeeded *= /*120 in CP, 100 in VP*/ GD_INT_GET(MINOR_CIV_PRODUCTION_PERCENT);
		iProductionNeeded /= 100;
	}

	iProductionNeeded *= /*100*/ GD_INT_GET(BUILDING_PRODUCTION_PERCENT);
	iProductionNeeded /= 100;

	iProductionNeeded *= GC.getGame().getGameSpeedInfo().getConstructPercent();
	iProductionNeeded /= 100;

	iProductionNeeded *= GC.getGame().getStartEraInfo().getConstructPercent();
	iProductionNeeded /= 100;

	if (pkBuildingInfo->GetPrereqAndTech() != NO_TECH)
	{
		CvTechEntry* pkTechInfo = GC.getTechInfo((TechTypes)pkBuildingInfo->GetPrereqAndTech());
		if (pkTechInfo)
		{
			// Loop through all eras and apply Building production mod based on how much time has passed
			int iTotalEraMod = 0;
			EraTypes eBuildingUnlockedEra = (EraTypes) pkTechInfo->GetEra();

			if (eBuildingUnlockedEra < GetCurrentEra())
			{
				for (int iLoop = eBuildingUnlockedEra; iLoop < GetCurrentEra(); iLoop++)
				{
					CvAssertMsg(iLoop >= 0, "Loop should be within era bounds");
					CvAssertMsg(iLoop <GC.getNumEraInfos(), "Loop should be within era bounds");

					if (iLoop >= 0 && iLoop < GC.getNumEraInfos())
					{
						CvEraInfo* pkEraInfo = GC.getEraInfo((EraTypes)iLoop);
						if (pkEraInfo)
						{
							iTotalEraMod += pkEraInfo->getLaterEraBuildingConstructMod();
						}
					}
				}

				iProductionNeeded *= (100 + iTotalEraMod);
				iProductionNeeded /= 100;
			}
		}
	}
	else
	{
		int iTotalEraMod = 0;
		for (int iLoop = 0; iLoop < GetCurrentEra(); iLoop++)
		{
			CvAssertMsg(iLoop >= 0, "Loop should be within era bounds");
			CvAssertMsg(iLoop <GC.getNumEraInfos(), "Loop should be within era bounds");

			if (iLoop >= 0 && iLoop < GC.getNumEraInfos())
			{
				CvEraInfo* pkEraInfo = GC.getEraInfo((EraTypes)iLoop);
				if (pkEraInfo)
				{
					iTotalEraMod += pkEraInfo->getLaterEraBuildingConstructMod();
				}
			}
		}

		iProductionNeeded *= (100 + iTotalEraMod);
		iProductionNeeded /= 100;
	}

	if (!isBarbarian())
	{
		if (isHuman())
		{
			if (MOD_ALTERNATIVE_DIFFICULTY && !isWorldWonderClass(pkBuildingInfo->GetBuildingClassInfo()))
			{
				iProductionNeeded *= std::max(0, ((GC.getGame().getHandicapInfo().getHumanPerEraMod() * GC.getGame().getCurrentEra()) + 100));
				iProductionNeeded /= 100;
			}
		}
		else
		{
			if (isWorldWonderClass(pkBuildingInfo->GetBuildingClassInfo()))
			{
				iProductionNeeded *= GC.getGame().getHandicapInfo().getAIWorldConstructPercent();
				iProductionNeeded /= 100;
			}
			else
			{
				iProductionNeeded *= GC.getGame().getHandicapInfo().getAIConstructPercent();
				iProductionNeeded /= 100;
			}

			if (MOD_BALANCE_CORE_DIFFICULTY)
			{
				if (!isWorldWonderClass(pkBuildingInfo->GetBuildingClassInfo()))
				{
					if (MOD_ALTERNATIVE_DIFFICULTY)
					{
						iProductionNeeded *= std::max(0, ((GC.getGame().getHandicapInfo().getAIConstructPerEraMod() * GC.getGame().getCurrentEra()) + 100));
						iProductionNeeded /= 100;
					}
					else
					{
						iProductionNeeded *= std::max(0, ((GC.getGame().getHandicapInfo().getAIPerEraModifier() * GC.getGame().getCurrentEra()) + 100));
						iProductionNeeded /= 100;
					}
				}
			}
			else
			{
				iProductionNeeded *= std::max(0, ((GC.getGame().getHandicapInfo().getAIPerEraModifier() * GetCurrentEra()) + 100));
				iProductionNeeded /= 100;
			}
		}
	}

	iProductionNeeded *= (100 + iProductionModifier);
	iProductionNeeded /= 100;

	return std::max(1, iProductionNeeded);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionNeeded(ProjectTypes eProject) const
{
	int iProductionNeeded = GC.getProjectInfo(eProject)->GetProductionCost();

	if (isMinorCiv())
	{
		iProductionNeeded *= /*120 in CP, 100 in VP*/ GD_INT_GET(MINOR_CIV_PRODUCTION_PERCENT);
		iProductionNeeded /= 100;
	}

	iProductionNeeded *= /*100*/ GD_INT_GET(PROJECT_PRODUCTION_PERCENT);
	iProductionNeeded /= 100;

	iProductionNeeded *= GC.getGame().getGameSpeedInfo().getCreatePercent();
	iProductionNeeded /= 100;

	iProductionNeeded *= GC.getGame().getStartEraInfo().getCreatePercent();
	iProductionNeeded /= 100;

	if (!isHuman() && !isBarbarian() && !GC.getProjectInfo(eProject)->IsRepeatable())
	{
		if (isWorldProject(eProject))
		{
			iProductionNeeded *= GC.getGame().getHandicapInfo().getAIWorldCreatePercent();
			iProductionNeeded /= 100;
		}
		else
		{
			iProductionNeeded *= GC.getGame().getHandicapInfo().getAICreatePercent();
			iProductionNeeded /= 100;
		}

		if (!MOD_BALANCE_CORE_DIFFICULTY)
		{
			iProductionNeeded *= std::max(0, ((GC.getGame().getHandicapInfo().getAIPerEraModifier() * GetCurrentEra()) + 100));
			iProductionNeeded /= 100;
		}
	}

	return std::max(1, iProductionNeeded);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionNeeded(SpecialistTypes eSpecialist) const
{
	CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
	if (pkSpecialistInfo == NULL)
	{
		// This should never happen! If this does, fix the calling function!
		CvAssert(pkSpecialistInfo);
		return 0;
	}

	int iProductionNeeded = pkSpecialistInfo->getCost();

	if (isMinorCiv())
	{
		iProductionNeeded *= /*120 in CP, 100 in VP*/ GD_INT_GET(MINOR_CIV_PRODUCTION_PERCENT);
		iProductionNeeded /= 100;
	}

	iProductionNeeded *= GC.getGame().getGameSpeedInfo().getCreatePercent();
	iProductionNeeded /= 100;

	iProductionNeeded *= GC.getGame().getStartEraInfo().getCreatePercent();
	iProductionNeeded /= 100;

	return std::max(1, iProductionNeeded);
}

#if defined(MOD_PROCESS_STOCKPILE)
//	--------------------------------------------------------------------------------
int CvPlayer::getMaxStockpile() const
{
	// The default of 30 hammers means a city can stockpile between 15% and 30% of the production of a World Wonder
	int iProdPerEra = gCustomMods.getOption("PROCESS_STOCKPILE_PER_ERA", 30);
	// Adjust for game speed
	iProdPerEra *= GC.getGame().getGameSpeedInfo().getConstructPercent();

	return ((GetCurrentEra() + 1) * iProdPerEra) / 100;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionModifier(CvString* toolTipSink) const
{
	int iMultiplier = 0;

	int iTempMod;

	// Unit Supply
	iTempMod = GetUnitProductionMaintenanceMod();
	iMultiplier += iTempMod;
	GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_UNIT_SUPPLY", iTempMod);

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionModifier(UnitTypes eUnit, CvString* toolTipSink) const
{
	int iMultiplier = getProductionModifier(toolTipSink);
	int iTempMod;

	CvUnitEntry* pUnitEntry = GC.getUnitInfo(eUnit);

	if(pUnitEntry)
	{
		// Military bonus
		if(pUnitEntry->IsMilitaryProduction())
		{
			iTempMod = getMilitaryProductionModifier();
			iMultiplier += iTempMod;
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_MILITARY_PLAYER", iTempMod);
		}

		// Settler bonus
		if(pUnitEntry->IsFound())
		{
			iTempMod = getSettlerProductionModifier();
			iMultiplier += iTempMod;
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_SETTLER_PLAYER", iTempMod);
		}

		// Unit Combat class bonus
		if(pUnitEntry->GetUnitCombatType() != NO_UNITCOMBAT)
		{
			iTempMod = getUnitCombatProductionModifiers((UnitCombatTypes) pUnitEntry->GetUnitCombatType());
			iMultiplier += iTempMod;
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_UNIT_COBMAT_CLASS_PLAYER", iTempMod);
		}

		// Trait bonus
		CvPlayerTraits* pPlayerTraits = GetPlayerTraits();
		std::vector<TraitTypes> vTraits = pPlayerTraits->GetPotentiallyActiveTraits();
		for(size_t iI = 0; iI < vTraits.size(); iI++)
		{
			if(pPlayerTraits->HasTrait(vTraits[iI]))
			{
				iMultiplier += pUnitEntry->GetProductionTraits(iI);

				if(pUnitEntry->GetSpecialUnitType() != NO_SPECIALUNIT)
				{
					CvSpecialUnitInfo* pkSpecialUnitInfo = GC.getSpecialUnitInfo((SpecialUnitTypes) pUnitEntry->GetSpecialUnitType());
					if(pkSpecialUnitInfo)
					{
						iTempMod = pkSpecialUnitInfo->getProductionTraits(iI);
						iMultiplier += iTempMod;
						GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_UNIT_TRAIT", iTempMod);
					}
				}
			}
		}
	}

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionModifier(BuildingTypes eBuilding, CvString* toolTipSink) const
{
	int iMultiplier = getProductionModifier(toolTipSink);
	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if(pkBuildingInfo == NULL)
	{
		return iMultiplier;
	}

	CvGame& kGame = GC.getGame();
	const CvBuildingClassInfo& kBuildingClassInfo = pkBuildingInfo->GetBuildingClassInfo();

	int iTempMod;

	CvPlayerTraits* pPlayerTraits = GetPlayerTraits();
	std::vector<TraitTypes> vTraits = pPlayerTraits->GetPotentiallyActiveTraits();
	for(size_t iI = 0; iI < vTraits.size(); iI++)
	{
		if(pPlayerTraits->HasTrait(vTraits[iI]))
		{
			iTempMod = pkBuildingInfo->GetProductionTraits(iI);
			iMultiplier += iTempMod;
			kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_BUILDING_TRAIT", iTempMod);
		}
	}

	// World Wonder
	if(::isWorldWonderClass(kBuildingClassInfo))
	{
		iTempMod = getMaxGlobalBuildingProductionModifier();
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WORLD_WONDER_PLAYER", iTempMod);
		iTempMod = m_pPlayerPolicies->GetNumericModifier(POLICYMOD_WONDER_PRODUCTION_MODIFIER);
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_POLICY", iTempMod);
	}

	// Team Wonder
	else if(::isTeamWonderClass(kBuildingClassInfo))
	{
		iTempMod = getMaxTeamBuildingProductionModifier();
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_TEAM_WONDER_PLAYER", iTempMod);
		iTempMod = m_pPlayerPolicies->GetNumericModifier(POLICYMOD_WONDER_PRODUCTION_MODIFIER);
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_POLICY", iTempMod);
	}

	// National Wonder
	else if(::isNationalWonderClass(kBuildingClassInfo))
	{
		iTempMod = getMaxPlayerBuildingProductionModifier();
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_NATIONAL_WONDER_PLAYER", iTempMod);
		iTempMod = m_pPlayerPolicies->GetNumericModifier(POLICYMOD_WONDER_PRODUCTION_MODIFIER);
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_POLICY", iTempMod);
	}

	// Normal Building
	else
	{
		iTempMod = m_pPlayerPolicies->GetNumericModifier(POLICYMOD_BUILDING_PRODUCTION_MODIFIER);
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_BUILDING_POLICY_PLAYER", iTempMod);
	}

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionModifier(ProjectTypes eProject, CvString* toolTipSink) const
{
	int iMultiplier = getProductionModifier(toolTipSink);
	int iTempMod;

	if(GC.getProjectInfo(eProject)->IsSpaceship())
	{
		iTempMod = getSpaceProductionModifier();
		iMultiplier += iTempMod;
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_SPACE_PLAYER", iTempMod);
	}

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionModifier(SpecialistTypes, CvString* toolTipSink) const
{
	int iMultiplier = getProductionModifier(toolTipSink);
	int iTempMod;

	iTempMod = getSpecialistProductionModifier();
	iMultiplier += iTempMod;
	GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_SPECIALIST_PLAYER", iTempMod);

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionModifier(ProcessTypes /*eProcess*/, CvString* toolTipSink) const
{
	int iMultiplier = getProductionModifier(toolTipSink);

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getBuildingClassPrereqBuilding(BuildingTypes eBuilding, BuildingClassTypes ePrereqBuildingClass, int iExtra) const
{
	CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
	if(pkBuilding == NULL)
	{
		CvAssertMsg(pkBuilding, "Should never happen...");
		return -1;
	}

	int iPrereqs = pkBuilding->GetPrereqNumOfBuildingClass(ePrereqBuildingClass);

	// dont bother with the rest of the calcs if we have no prereqs
	if(iPrereqs == 0)
	{
		return 0;
	}
	// -1 means Building is needed in all Cities
	else if(iPrereqs == -1)
	{
		int iNonPuppetCities = 0;
		int iLoop = 0;
		const CvCity* pLoopCity = NULL;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity && !pLoopCity->IsPuppet())
			{
#if defined(MOD_BUILDINGS_NW_EXCLUDE_RAZING)
				// Don't count this city if it is being razed and doesn't already have the pre-req building
				if (!(MOD_BUILDINGS_NW_EXCLUDE_RAZING && pLoopCity->IsRazing() && pLoopCity->GetCityBuildings()->GetNumBuildingClass(ePrereqBuildingClass) == 0))
#endif
				iNonPuppetCities++;
			}
		}

		return iNonPuppetCities;
	}
	else
	{
		iPrereqs *= std::max(0, GC.getMap().getWorldInfo().getBuildingClassPrereqModifier() + 100);
		iPrereqs /= 100;
	}

	if(!isLimitedWonderClass(pkBuilding->GetBuildingClassInfo()))
	{
		BuildingClassTypes eBuildingClass = pkBuilding->GetBuildingClassType();
		iPrereqs *= (getBuildingClassCount(eBuildingClass) + iExtra + 1);
	}

	bool OCC = GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE);
	if (OCC && isHuman())
	{
		iPrereqs = std::min(1, iPrereqs);
	}
#if defined(MOD_BALANCE_CORE)
	//Poor Venice got ignored here...
	if (MOD_BALANCE_CORE && OCC || GET_PLAYER(GetID()).GetPlayerTraits()->IsNoAnnexing())
	{
		iPrereqs = std::min(1, iPrereqs);
	}
#endif

	return iPrereqs;
}


//	--------------------------------------------------------------------------------
void CvPlayer::removeBuildingClass(BuildingClassTypes eBuildingClass)
{
	BuildingTypes eBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(eBuildingClass)));
	int iLoop;

	bool bRome = GetPlayerTraits()->IsKeepConqueredBuildings();
	if (MOD_BUILDINGS_THOROUGH_PREREQUISITES || eBuilding != NO_BUILDING || bRome)
	{
		for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if (MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome)
			{
				eBuilding = pLoopCity->GetCityBuildings()->GetBuildingTypeFromClass(eBuildingClass);
			}
			if (eBuilding != NO_BUILDING && pLoopCity->GetCityBuildings()->GetNumRealBuilding(eBuilding) > 0)
			{
				pLoopCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, 0);
				break;
			}
		}
	}
}

//	--------------------------------------------------------------------------------
// What is the effect of a building on the player?
void CvPlayer::processBuilding(BuildingTypes eBuilding, int iChange, bool bFirst, CvArea* pArea)
{
	int iI, iJ;

	CvBuildingEntry* pBuildingInfo = GC.getBuildingInfo(eBuilding);
	if(pBuildingInfo == NULL)
		return;

	// One-shot items
	if(bFirst && iChange > 0)
	{
		// Free Policies
		int iFreePolicies = pBuildingInfo->GetFreePolicies();
		if(iFreePolicies > 0)
			ChangeNumFreePolicies(iFreePolicies);

		int iFreeGreatPeople = pBuildingInfo->GetFreeGreatPeople();
		if(iFreeGreatPeople > 0)
			ChangeNumFreeGreatPeople(iFreeGreatPeople);

		// Golden Age
		if(pBuildingInfo->IsGoldenAge())
		{
			changeGoldenAgeTurns(getGoldenAgeLength(), true);
		}

		// Global Pop change
		if(pBuildingInfo->GetGlobalPopulationChange() != 0)
		{
			int iLoop;

			for(iI = 0; iI < MAX_PLAYERS; iI++)
			{
				if(GET_PLAYER((PlayerTypes)iI).isAlive())
				{
					if(GET_PLAYER((PlayerTypes)iI).getTeam() == getTeam())
					{
						if(pBuildingInfo->IsTeamShare() || (iI == GetID()))
						{
							for(CvCity* pLoopCity = GET_PLAYER((PlayerTypes)iI).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER((PlayerTypes)iI).nextCity(&iLoop))
							{
								pLoopCity->setPopulation(std::max(1, (pLoopCity->getPopulation() + iChange * GC.getBuildingInfo(eBuilding)->GetGlobalPopulationChange())));
							}
						}
					}
				}
			}
		}

		// Free techs
		if(pBuildingInfo->GetFreeTechs() > 0)
		{
			if(!isHuman())
			{
				for(iI = 0; iI < pBuildingInfo->GetFreeTechs(); iI++)
				{
					for(int iLoop = 0; iLoop < iChange; iLoop++)
						AI_chooseFreeTech();
				}
			}
			else
			{
				Localization::String localizedText = Localization::Lookup("TXT_KEY_MISC_COMPLETED_WONDER_CHOOSE_TECH");
				localizedText << pBuildingInfo->GetTextKey();
				chooseTech(pBuildingInfo->GetFreeTechs() * iChange, localizedText.toUTF8());
			}
		}
		if(pBuildingInfo->GetMedianTechPercentChange() > 0)
		{
			ChangeMedianTechPercentage(pBuildingInfo->GetMedianTechPercentChange());
		}

		if(pBuildingInfo->GetExtraSpies() > 0)
		{
			CvPlayerEspionage* pEspionage = GetEspionage();
			CvAssertMsg(pEspionage, "pEspionage is null! What's up with that?!");
			if(pEspionage)
			{
				int iNumSpies = pBuildingInfo->GetExtraSpies();
#if defined(MOD_BALANCE_CORE_SPIES)
				if (MOD_BALANCE_CORE_SPIES) 
				{
					//Optional: Spies scaled for the number of City-States in the game.
					int iNumMinor = ((GC.getGame().GetNumMinorCivsEver(true) * /*10*/ GD_INT_GET(BALANCE_SPY_TO_MINOR_RATIO)) / 100);
					if(iNumMinor > 1)
					{
						iNumSpies += iNumMinor;
					}
				}
#endif
				for(int i = 0; i < iNumSpies; i++)
				{
					pEspionage->CreateSpy();
				}
			}
		}

		if(pBuildingInfo->GetInstantSpyRankChange() > 0)
		{
			CvPlayerEspionage* pEspionage = GetEspionage();
			CvAssertMsg(pEspionage, "pEspionage is null! What's up with that?!");
			if(pEspionage)
			{
				for(uint ui = 0; ui < pEspionage->m_aSpyList.size(); ui++)
				{
					pEspionage->LevelUpSpy(ui);
				}
			}
		}

		if(pBuildingInfo->GetSpyRankChange() > 0)
		{
			ChangeStartingSpyRank(pBuildingInfo->GetSpyRankChange());
		}

		// Free Gold
		if(pBuildingInfo->GetGold() > 0)
			GetTreasury()->ChangeGold(pBuildingInfo->GetGold());

		// Instant Friendship change with all Minors
		int iMinorFriendshipChange = pBuildingInfo->GetMinorFriendshipChange();
		if(iMinorFriendshipChange != 0)
		{
			int iNewValue;
			//iMinorFriendshipChange += 100;	// Make it a mod

			for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
			{
				iNewValue = GET_PLAYER((PlayerTypes) iMinorLoop).GetMinorCivAI()->GetBaseFriendshipWithMajorTimes100(GetID());
				iNewValue += iMinorFriendshipChange * 100;

				GET_PLAYER((PlayerTypes) iMinorLoop).GetMinorCivAI()->SetFriendshipWithMajorTimes100(GetID(), iNewValue);
			}
		}
	}
#if defined(MOD_BALANCE_CORE)
	for(int iDomains = 0; iDomains < NUM_DOMAIN_TYPES; iDomains++)
	{
		DomainTypes eDomain = (DomainTypes)iDomains;
		if(eDomain != NO_DOMAIN)
		{
			int iNewValue;
			iNewValue = pBuildingInfo->GetDomainFreeExperiencePerGreatWorkGlobal(iDomains);
			if(iNewValue > 0)
			{
				ChangeDomainFreeExperiencePerGreatWorkGlobal(eDomain, iNewValue);
			}
			iNewValue = pBuildingInfo->GetDomainFreeExperienceGlobal(iDomains);
			if (iNewValue > 0)
			{
				ChangeDomainFreeExperience(eDomain, iNewValue);
			}
		}
	}

	ChangeReformationFollowerReduction(pBuildingInfo->GetReformationFollowerReduction() * iChange);
	ChangeNumMissionarySpreads(pBuildingInfo->GetExtraMissionarySpreadsGlobal() * iChange);

	if (pBuildingInfo->NullifyInfluenceModifier())
	{
		if (iChange > 0)
			SetNullifyInfluenceModifier(true);
		else
			SetNullifyInfluenceModifier(false);
	}

	if (pBuildingInfo->GetNoUnhappfromXSpecialistsGlobal() != 0)
	{
		ChangeNoUnhappfromXSpecialists(pBuildingInfo->GetNoUnhappfromXSpecialistsGlobal() * iChange);
	}

	if(pBuildingInfo->IsSecondaryPantheon())
	{
		ChangeSecondReligionPantheonCount((pBuildingInfo->IsSecondaryPantheon()) ? iChange : 0);
	}
	if(pBuildingInfo->GetTRSpeedBoost() != 0)
	{
		ChangeTRSpeedBoost(pBuildingInfo->GetTRSpeedBoost() * iChange);
	}
	if(pBuildingInfo->GetTRVisionBoost() != 0)
	{
		ChangeTRVisionBoost(pBuildingInfo->GetTRVisionBoost() * iChange);
	}
	if(pBuildingInfo->GetVotesPerGPT() != 0)
	{
		ChangeVotesPerGPT(pBuildingInfo->GetVotesPerGPT() * iChange);
	}
	if(pBuildingInfo->GetGlobalBuildingGoldMaintenanceMod() != 0)
	{
		ChangeBuildingGoldMaintenanceMod(pBuildingInfo->GetGlobalBuildingGoldMaintenanceMod() * iChange);
	}
	if(pBuildingInfo->GetEventTourism() != 0)
	{
		ChangeEventTourism(pBuildingInfo->GetEventTourism() * iChange);
	}
	if(pBuildingInfo->GetSingleVotes() > 0)
	{
		ChangeSingleVotes(pBuildingInfo->GetSingleVotes() * iChange);
	}

	if (pBuildingInfo->GetExtraMissionaryStrength() != 0)
	{
		ChangeMissionaryExtraStrength(pBuildingInfo->GetExtraMissionaryStrength() * iChange);
	}

	if (MOD_BALANCE_CORE_HAPPINESS_MODIFIERS && pBuildingInfo->GetEmpireNeedsModifierGlobal() != 0)
	{
		ChangeEmpireNeedsModifierGlobal(pBuildingInfo->GetEmpireNeedsModifierGlobal() * iChange);
	}
	if(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS && pBuildingInfo->GetPovertyHappinessChangeBuildingGlobal() != 0)
	{
		ChangePovertyUnhappinessGlobal(pBuildingInfo->GetPovertyHappinessChangeBuildingGlobal() * iChange);
	}
	if(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS && pBuildingInfo->GetDefenseHappinessChangeBuildingGlobal() != 0)
	{
		ChangeDefenseUnhappinessGlobal(pBuildingInfo->GetDefenseHappinessChangeBuildingGlobal() * iChange);
	}
	if(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS && pBuildingInfo->GetIlliteracyHappinessChangeBuildingGlobal() != 0)
	{
		ChangeIlliteracyUnhappinessGlobal(pBuildingInfo->GetIlliteracyHappinessChangeBuildingGlobal() * iChange);
	}
	if(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS && pBuildingInfo->GetUnculturedHappinessChangeBuildingGlobal() != 0)
	{
		ChangeUnculturedUnhappinessGlobal(pBuildingInfo->GetUnculturedHappinessChangeBuildingGlobal() * iChange);
	}
	if(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS && pBuildingInfo->GetMinorityHappinessChangeBuildingGlobal() != 0)
	{
		ChangeMinorityUnhappinessGlobal(pBuildingInfo->GetMinorityHappinessChangeBuildingGlobal() * iChange);
	}
	ChangeLandmarksTourismPercentGlobal(pBuildingInfo->GetLandmarksTourismPercentGlobal() * iChange);
	ChangeGreatWorksTourismModifierGlobal(pBuildingInfo->GetGreatWorksTourismModifierGlobal() * iChange);

	ChangeExtraSupplyPerPopulation(pBuildingInfo->GetCitySupplyModifierGlobal() * iChange);
	changeCitySupplyFlatGlobal(pBuildingInfo->GetCitySupplyFlatGlobal() * iChange);

	if (pBuildingInfo->AllowsProductionTradeRoutesGlobal())
	{
		if (iChange > 0)
			SetProductionRoutesAllCities(true);
		else
			SetProductionRoutesAllCities(false);
	}
	if (pBuildingInfo->AllowsFoodTradeRoutesGlobal())
	{
		if (iChange > 0)
			SetFoodRoutesAllCities(true);
		else
			SetFoodRoutesAllCities(false);
	}
#endif

	if(pBuildingInfo->GetFreeBuildingClass() != NO_BUILDINGCLASS)
	{
		BuildingTypes eFreeBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(pBuildingInfo->GetFreeBuildingClass());
		changeFreeBuildingCount(eFreeBuilding, iChange);
	}

	// Unit upgrade cost mod
	ChangeUnitUpgradeCostMod(pBuildingInfo->GetUnitUpgradeCostMod() * iChange);

	// Policy cost mod
	ChangePolicyCostBuildingModifier(pBuildingInfo->GetPolicyCostModifier() * iChange);

	// Border growth mods
	ChangePlotCultureCostModifier(pBuildingInfo->GetGlobalPlotCultureCostModifier() * iChange);
	ChangePlotGoldCostMod(pBuildingInfo->GetGlobalPlotBuyCostModifier() * iChange);
#if defined(MOD_BUILDINGS_CITY_WORKING)
	ChangeCityWorkingChange(pBuildingInfo->GetGlobalCityWorkingChange() * iChange);
#endif

#if defined(MOD_BUILDINGS_CITY_AUTOMATON_WORKERS)
	ChangeCityAutomatonWorkersChange(pBuildingInfo->GetGlobalCityAutomatonWorkersChange() * iChange);
#endif

	// City Culture Mod
	ChangeJONSCultureCityModifier(pBuildingInfo->GetGlobalCultureRateModifier() * iChange);

	// Trade route gold modifier
	GetTreasury()->ChangeCityConnectionTradeRouteGoldModifier(pBuildingInfo->GetCityConnectionTradeRouteModifier() * iChange);

	// Free Promotion
	PromotionTypes eFreePromotion = (PromotionTypes) pBuildingInfo->GetFreePromotion();
	if(eFreePromotion != NO_PROMOTION)
		ChangeFreePromotionCount(eFreePromotion, iChange);

	// Free Promotion Removed
	PromotionTypes eFreePromotionRemoved = (PromotionTypes) pBuildingInfo->GetFreePromotionRemoved();
	if(eFreePromotionRemoved != NO_PROMOTION)
		ChangeFreePromotionCount(eFreePromotionRemoved, -iChange);

	// Extra Happiness Per City
	ChangeExtraHappinessPerCity(pBuildingInfo->GetHappinessPerCity() * iChange);

	// Extra Happiness Per Policy
	ChangeExtraHappinessPerXPolicies(pBuildingInfo->GetHappinessPerXPolicies() * iChange);

	// City Count Unhappiness Mod
	ChangeCityCountUnhappinessMod(pBuildingInfo->GetCityCountUnhappinessMod() * iChange);

	// Hurries
	for(iI = 0; iI < GC.getNumHurryInfos(); iI++)
	{
		changeHurryModifier((HurryTypes) iI, (pBuildingInfo->GetHurryModifier(iI) * iChange));
	}

	changeGreatPeopleRateModFromBldgs(pBuildingInfo->GetGlobalGreatPeopleRateModifier() * iChange);
	changeGreatGeneralRateModFromBldgs(pBuildingInfo->GetGreatGeneralRateModifier() * iChange);
	ChangeGreatScientistBeakerMod(pBuildingInfo->GetGreatScientistBeakerModifier() * iChange);
	ChangeGreatPersonExpendGold(pBuildingInfo->GetGreatPersonExpendGold() * iChange);
	ChangeGPExpendInfluence(pBuildingInfo->GetGPExpendInfluence() * iChange);

	recomputeGreatPeopleModifiers();

	changeGoldenAgeModifier(pBuildingInfo->GetGoldenAgeModifier() * iChange);
	changeFreeExperienceFromBldgs(pBuildingInfo->GetGlobalFreeExperience() * iChange);
	changeWorkerSpeedModifier(pBuildingInfo->GetWorkerSpeedModifier() * iChange);
	ChangeSpecialistCultureChange(pBuildingInfo->GetSpecialistExtraCulture() * iChange);
	changeBorderObstacleCount(pBuildingInfo->IsPlayerBorderObstacle() * iChange);

#if defined(HH_MOD_BUILDINGS_FRUITLESS_PILLAGE)
	changeBorderGainlessPillageCount(pBuildingInfo->IsPlayerBorderGainlessPillage() * iChange);
#endif
	changeSpaceProductionModifier(pBuildingInfo->GetGlobalSpaceProductionModifier() * iChange);

	for(iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		if (pArea)
			pArea->changeYieldRateModifier(GetID(), ((YieldTypes)iI), (pBuildingInfo->GetAreaYieldModifier(iI) * iChange));

		changeYieldRateModifier(((YieldTypes)iI), (pBuildingInfo->GetGlobalYieldModifier(iI) * iChange));
#if defined(MOD_BALANCE_CORE_POLICIES)
		changeYieldFromDeath(((YieldTypes)iI), (pBuildingInfo->GetYieldFromDeath(iI) * iChange));

		ChangeYieldFromPillage(((YieldTypes)iI), (pBuildingInfo->GetYieldFromPillageGlobalPlayer(iI) * iChange));
		ChangeYieldFromVictory(((YieldTypes)iI), (pBuildingInfo->GetYieldFromVictoryGlobalPlayer(iI) * iChange));
#endif
#if defined(MOD_BALANCE_CORE)
		changeYieldGPExpend(((YieldTypes)iI), (pBuildingInfo->GetYieldFromGPExpend(iI) * iChange));
		int iMod = pBuildingInfo->GetGreatWorkYieldChange(iI) * iChange;
		if(iMod != 0)
		{
			ChangeGreatWorkYieldChange((YieldTypes)iI, iMod);
		}

		for (iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
		{
			changeResourceYieldChange(((ResourceTypes)iJ), ((YieldTypes)iI), (pBuildingInfo->GetResourceYieldChangeGlobal((ResourceTypes)iJ, (YieldTypes)iI) * iChange));
		}
#endif
	}

	for(iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
	{
		for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
		{
			changeSpecialistExtraYield(((SpecialistTypes)iI), ((YieldTypes)iJ), (pBuildingInfo->GetSpecialistYieldChange(iI, iJ) * iChange));
		}
	}

	int iOldEspionageModifier = GetEspionageModifier();
	ChangeEspionageModifier(pBuildingInfo->GetGlobalEspionageModifier() * iChange);
	if(iOldEspionageModifier != GetEspionageModifier())
	{
		int iLoop;
		for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
			{
				PlayerTypes ePlayer = (PlayerTypes)ui;
				GET_PLAYER(ePlayer).GetEspionage()->UpdateCity(pLoopCity);
			}
		}
	}

	ChangeExtraLeagueVotes(pBuildingInfo->GetExtraLeagueVotes() * iChange);
	changeMaxAirUnits(pBuildingInfo->GetAirModifierGlobal() * iChange);
	for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
	{
		YieldTypes eYield = (YieldTypes) iJ;
		for(int iK = 0; iK < GC.getNumImprovementInfos(); iK++)
		{
			ImprovementTypes eImprovement = (ImprovementTypes)iK;
			if(eImprovement != NO_IMPROVEMENT)
			{
				int iYieldChange = pBuildingInfo->GetImprovementYieldChangeGlobal(eImprovement, eYield);
				if(iYieldChange != 0)
				{
					ChangeImprovementExtraYield(eImprovement, eYield, (iYieldChange * iChange));
				}
			}
		}
	}

	// Loop through Cities
	int iLoop;
	int iBuildingCount;
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		// Building modifiers
		BuildingClassTypes eBuildingClass;

		CvCityBuildings* pLoopCityBuildings = pLoopCity->GetCityBuildings();

		for(iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
		{
			eBuildingClass = (BuildingClassTypes) iI;

			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
			if(!pkBuildingClassInfo)
			{
				continue;
			}

			BuildingTypes eTestBuilding = NO_BUILDING;
			if (MOD_BUILDINGS_THOROUGH_PREREQUISITES || GetPlayerTraits()->IsKeepConqueredBuildings())
			{
				eTestBuilding = pLoopCityBuildings->GetBuildingTypeFromClass(eBuildingClass);
			}
			else
			{
				eTestBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(eBuildingClass);
			}

			if(eTestBuilding != NO_BUILDING)
			{
				CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eTestBuilding);
				CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
				if(pkBuilding)
				{
					iBuildingCount = pLoopCityBuildings->GetNumBuilding(eTestBuilding);
					if(iBuildingCount > 0)
					{
						// Building Class Yield Stuff
						for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
						{
							YieldTypes eYield = (YieldTypes) iJ;
							int iYieldChange = pBuildingInfo->GetBuildingClassYieldChange(eBuildingClass, eYield);
							if(iYieldChange > 0)
							{
								pLoopCity->ChangeBaseYieldRateFromBuildings(eYield, iYieldChange * iBuildingCount * iChange);
							}

							int iWonderYieldChange = pBuildingInfo->GetYieldChangeWorldWonderGlobal(eYield);
							if (iWonderYieldChange > 0 && isWorldWonderClass(*pkBuildingClassInfo))
							{
								pLoopCityBuildings->ChangeBuildingYieldChange(eBuildingClass, eYield, (iWonderYieldChange * iBuildingCount * iChange));
								pLoopCity->changeLocalBuildingClassYield(eBuildingClass, eYield, (iWonderYieldChange * iBuildingCount * iChange));
							}

							int iYieldMod = pBuildingInfo->GetBuildingClassYieldModifier(eBuildingClass, eYield);
							if (iYieldMod != 0)
							{
								pLoopCity->changeYieldRateModifier(eYield, iYieldMod * iBuildingCount * iChange);
							}
						}
					}
				}

			}
		}
		//and update city happiness for all cities, as we may have changed something somewhere...
		pLoopCity->UpdateHappinessFromBuildingClasses();
	}
#if defined(MOD_BALANCE_CORE)
	//Refresh cache data.
	countNumBuildings(eBuilding, true);
	countNumBuildingsInPuppets(eBuilding, true);
#endif
}

//	--------------------------------------------------------------------------------
/// Get yield change from buildings for a specific building class
int CvPlayer::GetBuildingClassYieldChange(BuildingClassTypes eBuildingClass, YieldTypes eYieldType)
{
	return GetBuildingClassYieldChange(eBuildingClass, eYieldType, GetTotalBuildingCount());
}

//	--------------------------------------------------------------------------------
/// Get yield change from buildings for a specific building class
int CvPlayer::GetBuildingClassYieldModifier(BuildingClassTypes eBuildingClass, YieldTypes eYieldType)
{
	return GetBuildingClassYieldModifier(eBuildingClass, eYieldType, GetTotalBuildingCount());
}

int CvPlayer::GetBuildingClassYieldChange(BuildingClassTypes eBuildingClass, YieldTypes eYieldType, const vector<int>& preexistingBuildingsCount)
{
	int rtnValue = 0;

	CvBuildingXMLEntries* pBuildings = GC.GetGameBuildings();

	if(pBuildings)
	{
		for(int i = 0; i < pBuildings->GetNumBuildings(); i++)
		{
			// Do we have this building anywhere in empire?
			int iNum = preexistingBuildingsCount[i];

			if(iNum > 0)
			{
				CvBuildingEntry* pEntry = pBuildings->GetEntry(i);
				if(pEntry)
				{
					rtnValue += (pEntry->GetBuildingClassYieldChange(eBuildingClass, eYieldType) * iNum);
				}
			}
		}
	}

#if defined(MOD_BALANCE_CORE)
	CorporationTypes eCorporation = GetCorporations()->GetFoundedCorporation();
	if (eCorporation != NO_CORPORATION)
	{
		CvCorporationEntry* pkCorporation = GC.getCorporationInfo(eCorporation);
		if (pkCorporation)
		{
			rtnValue += pkCorporation->GetBuildingClassYieldChange(eBuildingClass, eYieldType);
		}
	}
#endif

	return rtnValue;
}

int CvPlayer::GetBuildingClassYieldModifier(BuildingClassTypes eBuildingClass, YieldTypes eYieldType, const vector<int>& preexistingBuildingsCount)
{
	int rtnValue = 0;

	CvBuildingXMLEntries* pBuildings = GC.GetGameBuildings();

	if (pBuildings)
	{
		for (int i = 0; i < pBuildings->GetNumBuildings(); i++)
		{
			// Do we have this building anywhere in empire?
			int iNum = preexistingBuildingsCount[i];
			if (iNum > 0)
			{
				CvBuildingEntry* pEntry = pBuildings->GetEntry(i);
				if (pEntry)
				{
					rtnValue += (pEntry->GetBuildingClassYieldModifier(eBuildingClass, eYieldType) * iNum);
				}
			}
		}
	}

	return rtnValue;
}

//	--------------------------------------------------------------------------------
/// Get yield change from buildings for wonders
int CvPlayer::GetWorldWonderYieldChange(int iYield)
{
	int rtnValue = 0;

	CvBuildingXMLEntries* pBuildings = GC.GetGameBuildings();

	if (pBuildings)
	{
		for (int i = 0; i < pBuildings->GetNumBuildings(); i++)
		{
			// Do we have this building anywhere in empire?
			int iNum = countNumBuildings((BuildingTypes)i);

			if (iNum > 0)
			{
				CvBuildingEntry* pEntry = pBuildings->GetEntry(i);
				if (pEntry)
				{
					rtnValue += (pEntry->GetYieldChangeWorldWonderGlobal(iYield) * iNum);
				}
			}
		}
	}
	return rtnValue;
}

//	--------------------------------------------------------------------------------
/// Can we eBuild on pPlot?
bool CvPlayer::canBuild(const CvPlot* pPlot, BuildTypes eBuild, bool bTestEra, bool bTestVisible, bool bTestGold, bool bTestPlotOwner, const CvUnit* pUnit) const
{
	if(!(pPlot->canBuild(eBuild, GetID(), bTestVisible, bTestPlotOwner)))
	{
		return false;
	}

	if(GC.getBuildInfo(eBuild)->getTechPrereq() != NO_TECH)
	{
		if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)GC.getBuildInfo(eBuild)->getTechPrereq())))
		{
			if((!bTestEra && !bTestVisible) || ((GetCurrentEra() + 1) < GC.getTechInfo((TechTypes) GC.getBuildInfo(eBuild)->getTechPrereq())->GetEra()))
			{
				return false;
			}
		}
	}
#if defined(MOD_BALANCE_CORE)
	if(MOD_BALANCE_CORE && GC.getBuildInfo(eBuild)->getTechObsolete() != NO_TECH)
	{
		if((GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)GC.getBuildInfo(eBuild)->getTechObsolete())))
		{
			return false;
		}
	}
#endif


	// Is this an improvement that is only useable by a specific civ?
	ImprovementTypes eImprovement = (ImprovementTypes)GC.getBuildInfo(eBuild)->getImprovement();
	if(eImprovement != NO_IMPROVEMENT)
	{
		CvImprovementEntry* pkEntry = GC.getImprovementInfo(eImprovement);
		if(pkEntry->IsSpecificCivRequired())
		{
			CivilizationTypes eCiv = pkEntry->GetRequiredCivilization();
			if(eCiv != getCivilizationType())
			{
				return false;
			}
		}

#if defined(MOD_IMPROVEMENTS_EXTENSIONS)
		if (MOD_IMPROVEMENTS_EXTENSIONS && pkEntry && !bTestVisible)
		{
			// Check resource requirements
			for (int iI = 0; iI < GC.getNumResourceInfos(); iI++)
			{
				ResourceTypes eResource = (ResourceTypes)iI;
				if (eResource != NO_RESOURCE)
				{
					int iNumResource = pkEntry->GetResourceQuantityRequirement(iI);
					if (iNumResource > 0)
					{
						if (pUnit && pUnit->getBuildType() == eBuild)
						{
							// If a unit is checking while building the improvement, we just need to see if the resource count is negative
							if (getNumResourceAvailable(eResource) < 0)
							{
								return false;
							}
						}
						else
						{
							if (getNumResourceAvailable(eResource) < iNumResource)
							{
								return false;
							}
						}
					}
				}
			}
		}
#endif
	}

#if defined(MOD_IMPROVEMENTS_EXTENSIONS)
	if (MOD_IMPROVEMENTS_EXTENSIONS && !bTestVisible)
	{
		RouteTypes eRoute = (RouteTypes)GC.getBuildInfo(eBuild)->getRoute();
		if (eRoute != NO_ROUTE)
		{
			CvRouteInfo* pkBuildRoute = GC.getRouteInfo(eRoute);
			// Check resource requirements
			for (int iI = 0; iI < GC.getNumResourceInfos(); iI++)
			{
				ResourceTypes eResource = (ResourceTypes)iI;
				if (eResource != NO_RESOURCE)
				{
					int iNumResource = pkBuildRoute->getResourceQuantityRequirement(iI);
					if (iNumResource > 0)
					{
						if (pUnit && pUnit->getBuildType() == eBuild)
						{
							// If a unit is checking while building the route, we just need to see if the resource count is negative
							if (getNumResourceAvailable(eResource) < 0)
							{
								return false;
							}
						}
						else
						{
							if (getNumResourceAvailable(eResource) < iNumResource)
							{
								return false;
							}
						}
					}
				}
			}
		}
	}
#endif

	if(!bTestVisible)
	{
		if(IsBuildBlockedByFeature(eBuild, pPlot->getFeatureType()))
		{
			return false;
		}

		if(bTestGold)
		{
			if(std::max(0, GetTreasury()->GetGold()) < getBuildCost(pPlot, eBuild))
			{
				return false;
			}
		}
	}

	return true;
}

//	--------------------------------------------------------------------------------
/// Are we prevented from eBuild-ing because of a Feature on this plot?
bool CvPlayer::IsBuildBlockedByFeature(BuildTypes eBuild, FeatureTypes eFeature) const
{
	// No Feature here to block us
	if(eFeature == NO_FEATURE)
	{
		return false;
	}

	// Build does not remove the Feature on pPlot
	if(!GC.getBuildInfo(eBuild)->isFeatureRemove(eFeature))
	{
		return false;
	}

	TechTypes ePrereqTech = (TechTypes) GC.getBuildInfo(eBuild)->getFeatureTech(eFeature);

	// Clearing Feature doesn't require any Tech, so we can do it right now if we have to
	if(ePrereqTech == NO_TECH)
	{
		return false;
	}

	// Clearing eFeature requires a Tech, but we have it
	if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech(ePrereqTech))
	{
		return false;
	}

	// Feature is blocking us!
	return true;
}

//	--------------------------------------------------------------------------------
// Returns the cost
int CvPlayer::getBuildCost(const CvPlot* pPlot, BuildTypes eBuild) const
{
	CvAssert(eBuild >= 0 && eBuild < GC.getNumBuildInfos());


	CvBuildInfo* pkBuildInfo = GC.getBuildInfo(eBuild);
	if(pkBuildInfo == NULL)
	{
		return 0;
	}

	if(pPlot->getBuildProgress(eBuild) > 0)
	{
		return 0;
	}

	if(pPlot->getRouteType() != NO_ROUTE && pPlot->getRouteType() == pkBuildInfo->getRoute() && pPlot->IsRoutePillaged())
	{
		return 0;
	}

	int iBuildCost = pkBuildInfo->getCost();

	// Cost increases as more Improvements are built
	iBuildCost += (getTotalImprovementsBuilt() * pkBuildInfo->getCostIncreasePerImprovement());

	iBuildCost *= (100 + getImprovementCostModifier());
	iBuildCost /= 100;

	if(pPlot->getFeatureType() != NO_FEATURE)
	{
		iBuildCost += pkBuildInfo->getFeatureCost(pPlot->getFeatureType());
	}

	iBuildCost *= getHandicapInfo().getImprovementCostPercent();
	iBuildCost /= 100;

	iBuildCost *= GC.getGame().getGameSpeedInfo().getImprovementPercent();
	iBuildCost /= 100;

	return std::max(0, iBuildCost);
}


//	--------------------------------------------------------------------------------
RouteTypes CvPlayer::getBestRoute(CvPlot* pPlot) const
{
	if (pPlot==NULL)
		return GET_TEAM(getTeam()).GetBestPossibleRoute();

	RouteTypes eRoute;
	RouteTypes eBestRoute;
	int iValue;
	int iBestValue;
	int iI;

	iBestValue = 0;
	eBestRoute = NO_ROUTE;

	for(iI = 0; iI < GC.getNumBuildInfos(); iI++)
	{
		const BuildTypes eBuild = static_cast<BuildTypes>(iI);
		CvBuildInfo* pkBuildInfo = GC.getBuildInfo(eBuild);
		if(pkBuildInfo)
		{
			eRoute = ((RouteTypes)(pkBuildInfo->getRoute()));
			if(eRoute != NO_ROUTE)
			{
				CvRouteInfo* pkRouteInfo = GC.getRouteInfo(eRoute);
				if(pkRouteInfo)
				{
					if( (pPlot->getRouteType() == eRoute) || canBuild(pPlot, eBuild) )
					{
#if defined(MOD_BALANCE_CORE)
						if(MOD_BALANCE_CORE && pkBuildInfo->getTechObsolete() == NO_TECH)
						{
							iValue = pkRouteInfo->getValue();
						}
						else if(MOD_BALANCE_CORE && !GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pkBuildInfo->getTechObsolete())))
						{
							iValue = pkRouteInfo->getValue();
						}
						else
						{
							iValue = 0;
						}
#else
						iValue = pkRouteInfo->getValue();
#endif
						if(iValue > iBestValue)
						{
							iBestValue = iValue;
							eBestRoute = eRoute;
						}

					}
				}
			}
		}
	}

	return eBestRoute;
}


//	--------------------------------------------------------------------------------
int CvPlayer::getImprovementUpgradeRate() const
{
	int iRate;

	iRate = 100; // XXX

	iRate *= std::max(0, (getImprovementUpgradeRateModifier() + 100));
	iRate /= 100;

	return iRate;
}

//	--------------------------------------------------------------------------------
/// How much Production do we get from removing ANY Feature in the game? (Policy Bonus)
int CvPlayer::GetAllFeatureProduction() const
{
	return m_iAllFeatureProduction;
}

//	--------------------------------------------------------------------------------
/// Changes how much Production we get from removing ANY Feature in the game (Policy Bonus)
void CvPlayer::ChangeAllFeatureProduction(int iChange)
{
	if(iChange != 0)
	{
		m_iAllFeatureProduction += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// How far a tile is from a city (1-3) This is used to determine camera zoom on the city view
int CvPlayer::GetCityDistanceHighwaterMark() const
{
	return m_iCityDistanceHighwaterMark;
}

//	--------------------------------------------------------------------------------
/// Set how far a tile is from a city (1-3) This is used to determine camera zoom on the city view
void CvPlayer::SetCityDistanceHighwaterMark(int iNewValue)
{
	m_iCityDistanceHighwaterMark = iNewValue;
}


//	--------------------------------------------------------------------------------
int CvPlayer::calculateTotalYield(YieldTypes eYield) const
{
	// This is based on the switch in CvEconomicAI::LogMonitor() that calls different methods for culture and faith
	// I've added this here as a "safe guard"
	if (eYield == YIELD_CULTURE)
	{
		return GetTotalJONSCulturePerTurn() + m_viInstantYieldsTotal[YIELD_CULTURE] / (GC.getGame().getElapsedGameTurns() + 1);
	}
	else if (eYield == YIELD_FAITH)
	{
		return GetTotalFaithPerTurn() + m_viInstantYieldsTotal[YIELD_FAITH] / (GC.getGame().getElapsedGameTurns() + 1);
	}
	else if (eYield == YIELD_TOURISM)
	{
		return GetCulture()->GetTourism() / 100 + m_viInstantYieldsTotal[YIELD_TOURISM] / (GC.getGame().getElapsedGameTurns() + 1);
	}

	int iTotalYield = 0;
	int iLoop;

	for (const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iTotalYield += pLoopCity->getYieldRateTimes100(eYield, false);
	}

	//average accumulated instant yields over elapsed turns
	iTotalYield += (m_viInstantYieldsTotal[eYield] * 100) / (GC.getGame().getElapsedGameTurns() + 1);

	return iTotalYield / 100;
}

//	--------------------------------------------------------------------------------
/// How much Production is being eaten up by Units over the supply limit? (cached)
int CvPlayer::GetUnitProductionMaintenanceMod() const
{
	// Kind of a cop-out, but it fixes some bugs for now
	return calculateUnitProductionMaintenanceMod();
}

//	--------------------------------------------------------------------------------
/// How much Production is being eaten up by Units over the supply limit? (update cache)
void CvPlayer::UpdateUnitProductionMaintenanceMod()
{
	m_iUnitProductionMaintenanceMod = calculateUnitProductionMaintenanceMod();

	if(GetID() == GC.getGame().getActivePlayer())
	{
		GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
	}
}

//	--------------------------------------------------------------------------------
/// How much Production is being eaten up by Units over the supply limit?
int CvPlayer::calculateUnitProductionMaintenanceMod() const
{
	int iUnitsOverSupply = GetNumUnitsOutOfSupply();
	if (iUnitsOverSupply > 0)
	{
		// Example: Player can support 8 Units, he has 12. 4 * 5 means he loses 20% of his Production
		int iMaintenanceMod = min(/*70*/ max(GD_INT_GET(MAX_UNIT_SUPPLY_PRODMOD), 0), iUnitsOverSupply * /*10 in CP, 5 in VP*/ max(GD_INT_GET(PRODUCTION_PENALTY_PER_UNIT_OVER_SUPPLY), 0));
		return iMaintenanceMod * -1;
	}

	return 0;
}

//	--------------------------------------------------------------------------------
/// How much Growth is being eaten up by Units over the supply limit? (cached)
int CvPlayer::GetUnitGrowthMaintenanceMod() const
{
	// Kind of a cop-out, but it fixes some bugs for now
	return calculateUnitGrowthMaintenanceMod();
}

//	--------------------------------------------------------------------------------
/// How much Growth is being eaten up by Units over the supply limit? (update cache)
void CvPlayer::UpdateUnitGrowthMaintenanceMod()
{
	m_iUnitGrowthMaintenanceMod = calculateUnitGrowthMaintenanceMod();

	if (GetID() == GC.getGame().getActivePlayer())
	{
		GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
	}
}

//	--------------------------------------------------------------------------------
/// How much Growth is being eaten up by Units over the supply limit?
int CvPlayer::calculateUnitGrowthMaintenanceMod() const
{
	int iUnitsOverSupply = GetNumUnitsOutOfSupply();
	if (iUnitsOverSupply > 0)
	{
		// Example: Player can support 8 Units, he has 12. 4 * 5 means he loses 20% of his Food
		int iMaintenanceMod = min(/*70*/ max(GD_INT_GET(MAX_UNIT_SUPPLY_GROWTH_MOD), 0), iUnitsOverSupply * /*5*/ max(GD_INT_GET(GROWTH_PENALTY_PER_UNIT_OVER_SUPPLY), 0));
		return iMaintenanceMod * -1;
	}

	return 0;
}

//	--------------------------------------------------------------------------------
/// How many Units can we support for free without losing Production and Growth?
int CvPlayer::GetNumUnitsSupplied(bool bCheckWarWeariness) const
{
	if (m_iNumUnitsSuppliedCached == -1)
	{
		int iFreeUnits = GetNumUnitsSuppliedByHandicap();
		iFreeUnits += GetNumUnitsSuppliedByCities();
		iFreeUnits += GetNumUnitsSuppliedByPopulation();
		iFreeUnits += GetUnitSupplyFromExpendedGreatPeople();

		if (MOD_BALANCE_DYNAMIC_UNIT_SUPPLY && bCheckWarWeariness)
		{
			int iWarWeariness = GetCulture()->GetWarWeariness()/2;
			int iMod = (100 - min(75, iWarWeariness));
			iFreeUnits *= iMod;
			iFreeUnits /= 100;
		}

		if (!isMinorCiv() && !isHuman())
		{
			int iMod = (100 + GC.getGame().getHandicapInfo().getAIUnitSupplyPercent());
			iFreeUnits *= iMod;
			iFreeUnits /= 100;
		}

		m_iNumUnitsSuppliedCached = max(0,iFreeUnits);
	}

	return m_iNumUnitsSuppliedCached;
}

//	--------------------------------------------------------------------------------
/// Units supplied from Difficulty Level
int CvPlayer::GetNumUnitsSuppliedByHandicap(bool bIgnoreReduction) const
{
#if defined(MOD_TRAITS_EXTRA_SUPPLY)
	int iSupply = getHandicapInfo().getProductionFreeUnits() + m_pTraits->GetExtraSupply();
	if (MOD_BALANCE_DYNAMIC_UNIT_SUPPLY)
	{
		if (GC.getGame().getStartEra() > 0)
		{
			iSupply += GC.getGame().getStartEra() * 2;
		}
		
		if (!bIgnoreReduction)
		{
			iSupply -= GetCurrentEra();
			if (iSupply <= 0)
				iSupply = 0;
		}
	}
	// Don't need a test here for MOD_TRAITS_EXTRA_SUPPLY being enabled, as if it isn't GetExtraSupply() will return 0
	return iSupply;
#else
	return getHandicapInfo().getProductionFreeUnits();
#endif
}

//	--------------------------------------------------------------------------------
/// Units supplied by Cities
int CvPlayer::GetNumUnitsSuppliedByCities(bool bIgnoreReduction) const
{
	if (MOD_BALANCE_DYNAMIC_UNIT_SUPPLY)
	{
		int iStartingSupply = getHandicapInfo().getProductionFreeUnitsPerCity();
		int iValue = m_pTraits->GetExtraSupply();
		int iLoop;
		for (const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			int iSupply = (iStartingSupply + pLoopCity->getCitySupplyFlat() + getCitySupplyFlatGlobal());
			iValue += iSupply;
		}

		if (!bIgnoreReduction)
		{
			int iTechProgress = (GET_TEAM(getTeam()).GetTeamTechs()->GetNumTechsKnown() * 100) / GC.getNumTechInfos();
			if (iTechProgress >= 100)
				iTechProgress = 100;
			
			iTechProgress *= 5;
			iTechProgress /= 6;

			iValue *= 100;
			iValue /= (100 + iTechProgress);
		}
		if (iValue < 0)
			return 0;

		return iValue;
	}
#if defined(MOD_TRAITS_EXTRA_SUPPLY)
	// Don't need a test here for MOD_TRAITS_EXTRA_SUPPLY being enabled, as if it isn't GetExtraSupply() will return 0
	return ((getHandicapInfo().getProductionFreeUnitsPerCity() + m_pTraits->GetExtraSupply()) * getNumCities());
#else
	return getHandicapInfo().getProductionFreeUnitsPerCity() * getNumCities();
#endif
}

//	--------------------------------------------------------------------------------
/// Units supplied by Population
int CvPlayer::GetNumUnitsSuppliedByPopulation(bool bIgnoreReduction) const
{
#if defined(MOD_TRAITS_EXTRA_SUPPLY)
	if (MOD_BALANCE_DYNAMIC_UNIT_SUPPLY)
	{
		int iStartingSupply = getHandicapInfo().getProductionFreeUnitsPopulationPercent();
		int iValue = 0;
		int iLoop;
		for (const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			int iPopulation = 0;
			int iSupply = (iStartingSupply + pLoopCity->getCitySupplyModifier() + m_pTraits->GetExtraSupplyPerPopulation() + GetExtraSupplyPerPopulation());
			if (CityStrategyAIHelpers::IsTestCityStrategy_IsPuppetAndAnnexable(pLoopCity))
			{
				iPopulation = (pLoopCity->getPopulation() / 2) * 100;
			}
			else
			{
				iPopulation = pLoopCity->getPopulation() * 100;
			}

			iValue += ((iPopulation * iSupply) / 100);
		}

		if (!bIgnoreReduction)
		{
			int iTechProgress = (GET_TEAM(getTeam()).GetTeamTechs()->GetNumTechsKnown() * 100) / GC.getNumTechInfos();
			if (iTechProgress >= 100)
				iTechProgress = 100;
			
			iTechProgress *= 7;
				
			iValue *= 100;
			iValue /= (100 + iTechProgress);
		}

		iValue /= 100;

		if (iValue < 0)
			return 0;

		return iValue; 
	}
	// Don't need a test here for MOD_TRAITS_EXTRA_SUPPLY being enabled, as if it isn't GetExtraSupply() will return 0
	return getTotalPopulation() * (m_pTraits->GetExtraSupplyPerPopulation() + GetExtraSupplyPerPopulation() + getHandicapInfo().getProductionFreeUnitsPopulationPercent()) / 100;
#else
	return getTotalPopulation() * getHandicapInfo().getProductionFreeUnitsPopulationPercent() / 100;
#endif
}

//	--------------------------------------------------------------------------------
/// How much Units are eating Production?
int CvPlayer::GetNumUnitsOutOfSupply(bool bCheckWarWeariness) const
{
	bool bCheckWW = bCheckWarWeariness;
	int iNumUnitsToSupply = getNumMilitaryUnits() - getNumUnitsSupplyFree();
	return std::max(0, iNumUnitsToSupply - GetNumUnitsSupplied(bCheckWW));
}

#if defined(MOD_BALANCE_CORE)
int CvPlayer::GetNumUnitsToSupply() const
{
	return getNumMilitaryUnits() - getNumUnitsSupplyFree();
}

//these are mercenaries etc
int CvPlayer::getNumUnitsSupplyFree() const
{
	return m_iSupplyFreeUnits;
}

void CvPlayer::changeNumUnitsSupplyFree(int iValue)
{
	if (iValue != 0)
	{
		m_iSupplyFreeUnits += iValue;
	}
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::calculateUnitCost() const
{
	int iFreeUnits;
	int iPaidUnits;
	int iBaseUnitCost;
	int iExtraCost;

	return GetTreasury()->CalculateUnitCost(iFreeUnits, iPaidUnits, iBaseUnitCost, iExtraCost);
}

//	--------------------------------------------------------------------------------
// HAS NOTHING TO DO WITH UNIT SUPPLY, this is part of the unit maintenance Gold cost calculation
int CvPlayer::calculateUnitSupply() const
{
	return GetTreasury()->CalculateUnitSupply();
}

//	--------------------------------------------------------------------------------
int CvPlayer::calculateResearchModifier(TechTypes eTech)
{
	int iModifier = 100;

	if(NO_TECH == eTech)
	{
		return iModifier;
	}

	int iKnownCount = 0;
	int iPossibleKnownCount = 0;
	for(int iI = 0; iI < MAX_CIV_TEAMS; iI++)
	{
		CvTeam& kLoopTeam = GET_TEAM((TeamTypes)iI);
		if(kLoopTeam.isAlive() && !kLoopTeam.isMinorCiv() && kLoopTeam.GetID() != getTeam())
		{
#if defined(MOD_DIPLOMACY_TECH_BONUSES)
			bool bCouldBorrowTech;
			
			if (MOD_DIPLOMACY_TECH_BONUSES)
			{
				if (GetEspionage()->GetNumSpies() > 0)
				{
					// We've got spies!  So we need one in a capital of a player in the other team
					bCouldBorrowTech = GET_TEAM(getTeam()).HasSpyAtTeam((TeamTypes)iI);
				}
				else
				{
					// No spies yet, so use embassy status
					bCouldBorrowTech = GET_TEAM(getTeam()).HasEmbassyAtTeam((TeamTypes)iI);
				}
			}
			else
			{
				bCouldBorrowTech = GET_TEAM(getTeam()).isHasMet((TeamTypes)iI);
			}
			
			if(bCouldBorrowTech)
#else
			if(GET_TEAM(getTeam()).isHasMet((TeamTypes)iI))
#endif
			{
				if(kLoopTeam.GetTeamTechs()->HasTech(eTech))
				{
					iKnownCount++;
				}
				iPossibleKnownCount++;
			}
		}
	}

	if (iPossibleKnownCount > 0)
	{
		int iExtraAICatchUP = 0;
		if (MOD_ALTERNATIVE_DIFFICULTY && !isHuman() && isMajorCiv())
		{
			iExtraAICatchUP = GC.getGame().getHandicapInfo().getAITechCatchUpMod() * GC.getGame().getCurrentEra();
		}
		iModifier += ((/*30 in CP, 10 in VP*/ GD_INT_GET(TECH_COST_TOTAL_KNOWN_TEAM_MODIFIER) + iExtraAICatchUP) * iKnownCount) / iPossibleKnownCount;
	}

	int iPossiblePaths = 0;
	int iUnknownPaths = 0;
	for(int iI = 0; iI < /*3*/ GD_INT_GET(NUM_OR_TECH_PREREQS); iI++)
	{
		if(GC.getTechInfo(eTech)->GetPrereqOrTechs(iI) != NO_TECH)
		{
			if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(GC.getTechInfo(eTech)->GetPrereqOrTechs(iI)))))
			{
				iUnknownPaths++;
			}

			iPossiblePaths++;
		}
	}
	CvAssertMsg(iPossiblePaths >= iUnknownPaths, "The number of possible paths is expected to match or exceed the number of unknown ones");
	iModifier += (iPossiblePaths - iUnknownPaths) * /*20*/ GD_INT_GET(TECH_COST_KNOWN_PREREQ_MODIFIER);

	// Leagues mod
	int iLeaguesMod = GC.getGame().GetGameLeagues()->GetResearchMod(GetID(), eTech);
	if (iLeaguesMod != 0)
	{
		if (isMajorCiv() && MOD_BALANCE_VP)
		{
			//Research bonus for city-state alliances
			int iMinorAllies = GetNumCSAllies();

			if (iMinorAllies > 0)
			{
				// -2% tech costs per ally.
				int iLeaguesAidScience = min(50, (iMinorAllies * /*2*/ GD_INT_GET(SCHOLAR_MINOR_ALLY_MULTIPLIER)));
				SetScienceRateFromMinorAllies(iLeaguesAidScience);
				iLeaguesMod += GetScienceRateFromMinorAllies();
			}
			else
			{
				SetScienceRateFromMinorAllies(0);
			}
		}

		iModifier *= (100 + iLeaguesMod);
		iModifier /= 100;
	}
	if (MOD_ALTERNATIVE_DIFFICULTY && isMajorCiv())
	{
		if (isHuman())
		{
			iModifier *= 100;
			iModifier /= std::max(1, 100 + (GC.getGame().getHandicapInfo().getHumanPerEraMod() * GC.getGame().getCurrentEra()));
		}
		else
		{
			iModifier *= 100;
			iModifier /= std::max(1, GC.getGame().getHandicapInfo().getAITechPercent());
			iModifier *= 100;
			iModifier /= std::max(1, 100 + (GC.getGame().getHandicapInfo().getAITechPerEraMod() * GC.getGame().getCurrentEra()));
		}
	}

	return iModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::calculateGoldRate() const
{
	return calculateGoldRateTimes100() / 100;
}

//	--------------------------------------------------------------------------------
int CvPlayer::calculateGoldRateTimes100() const
{
	return GetTreasury()->CalculateBaseNetGoldTimes100();
}

//	--------------------------------------------------------------------------------
int CvPlayer::getAvgGoldRate() const
{
	return m_iCachedGoldRate;
}

//	--------------------------------------------------------------------------------
void CvPlayer::cacheAvgGoldRate()
{
	m_iCachedGoldRate = calculateGoldRate() + GetTreasury()->AverageIncome100(/*10*/ GD_INT_GET(HISTORY_NUM_TURNS_TO_AVERAGE))/100;
}

int CvPlayer::getTurnsToBankruptcy(int iAssumedExtraExpense) const
{
	int iGold = GetTreasury()->GetGold();
	int iAvgGPT = getAvgGoldRate() - iAssumedExtraExpense;

	if (iAvgGPT > 0)
		return INT_MAX;

	return -iGold/max(1,iAvgGPT);
}

/// What is the average production produced by our cities?
int CvPlayer::GetAverageProduction() const
{
	return GetAverageProductionTimes100() / 100;
}
/// What is the average production produced by our cities (with decimals)?
int CvPlayer::GetAverageProductionTimes100() const
{
	vector<int> viCityProduction;
	int iNumBestCities = /*4*/ GD_INT_GET(HISTORY_LOCAL_NUM_BEST_CITIES);

	int iProduction = 0;

	const CvCity* pLoopCity;

	int iLoop;
	// Collect production from each city
	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		viCityProduction.push_back(pLoopCity->getYieldRateTimes100(YIELD_PRODUCTION, false));
	}
	int iNumCities = max((int)viCityProduction.size(), 1);
	// Sort production from lowest to highest
	sort(viCityProduction.begin(), viCityProduction.end());

	// Add the X highest city production together
	int iCurrentCity = 0;
	for (vector<int>::reverse_iterator it = viCityProduction.rbegin(); it != viCityProduction.rend(); ++it)
	{
		iProduction += *it;
		if (++iCurrentCity >= iNumBestCities)
			break;
	}

	return iProduction / min(iNumBestCities, iNumCities);
}

/// What is the average instant production produced by our cities?
int CvPlayer::GetAverageInstantProduction()
{
	return GetAverageInstantProductionTimes100() / 100;
}
/// What is the average production produced by our cities (with decimals)?
int CvPlayer::GetAverageInstantProductionTimes100()
{
	vector<int> viCityProduction;
	int iNumBestCities = /*4*/ GD_INT_GET(HISTORY_LOCAL_NUM_BEST_CITIES);

	int iProduction = 0;

	CvCity* pLoopCity;

	int iLoop;
	// Collect average instant production from each city since the time of founding
	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		int iTurnsExisted = max(GC.getGame().getElapsedGameTurns() - pLoopCity->getGameTurnFounded(), 1);
		viCityProduction.push_back(pLoopCity->GetInstantYieldTotal(YIELD_PRODUCTION) * 100 / iTurnsExisted);
	}
	int iNumCities = max((int)viCityProduction.size(), 1);
	// Sort production from lowest to highest
	sort(viCityProduction.begin(), viCityProduction.end());

	// Add the X highest city production together
	int iCurrentCity = 0;
	for (vector<int>::reverse_iterator it = viCityProduction.rbegin(); it != viCityProduction.rend(); ++it)
	{
		iProduction += *it;
		if (++iCurrentCity >= iNumBestCities)
			break;
	}

	return iProduction / min(iNumBestCities, iNumCities);
}

//	--------------------------------------------------------------------------------
int CvPlayer::unitsRequiredForGoldenAge() const
{
	return (/*1*/ GD_INT_GET(BASE_GOLDEN_AGE_UNITS) + (getNumUnitGoldenAges() * /*1*/ GD_INT_GET(GOLDEN_AGE_UNITS_MULTIPLIER)));
}

//	--------------------------------------------------------------------------------
int CvPlayer::unitsGoldenAgeCapable() const
{
	int iLoop;
	int iCount = 0;

	for (const CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if (pLoopUnit->isGoldenAge())
		{
			iCount++;
		}
	}

	return iCount;
}

//	--------------------------------------------------------------------------------
int CvPlayer::unitsGoldenAgeReady() const
{
	bool* pabUnitUsed = FNEW(bool[GC.getNumUnitInfos()], c_eCiv5GameplayDLL, 0);

	for (int iI = 0; iI < GC.getNumUnitInfos(); iI++)
	{
		pabUnitUsed[iI] = false;
	}

	int iCount = 0;

	int iLoop;
	for(const CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(!(pabUnitUsed[pLoopUnit->getUnitType()]))
		{
			if(pLoopUnit->isGoldenAge())
			{
				pabUnitUsed[pLoopUnit->getUnitType()] = true;
				iCount++;
			}
		}
	}

	SAFE_DELETE_ARRAY(pabUnitUsed);
	return iCount;
}

//	--------------------------------------------------------------------------------
int CvPlayer::greatGeneralThreshold() const
{
	int iThreshold = ((/*200*/ GD_INT_GET(GREAT_GENERALS_THRESHOLD) * std::max(0, (getGreatGeneralsThresholdModifier() + 100))) / 100);

	UnitClassTypes eUnitClassGeneral = (UnitClassTypes)GC.getInfoTypeForString("UNITCLASS_GREAT_GENERAL");
	int iMod = GetPlayerTraits()->GetGreatPersonCostReduction(GetGreatPersonFromUnitClass(eUnitClassGeneral));
	if (iMod != 0)
	{
		iThreshold *= (100 + iMod);
		iThreshold /= 100;
	}

	iThreshold *= GC.getGame().getGameSpeedInfo().getTrainPercent();
	iThreshold /= 100;

	return std::max(1, iThreshold);
}

//	--------------------------------------------------------------------------------
int CvPlayer::greatAdmiralThreshold() const
{
	int iThreshold = ((/*200*/ GD_INT_GET(GREAT_GENERALS_THRESHOLD) * std::max(0, (getGreatAdmiralsThresholdModifier() + 100))) / 100);

	UnitClassTypes eUnitClassAdmiral = (UnitClassTypes)GC.getInfoTypeForString("UNITCLASS_GREAT_ADMIRAL");
	int iMod = GetPlayerTraits()->GetGreatPersonCostReduction(GetGreatPersonFromUnitClass(eUnitClassAdmiral));
	if (iMod != 0)
	{
		iThreshold *= (100 + iMod);
		iThreshold /= 100;
	}

	iThreshold *= GC.getGame().getGameSpeedInfo().getTrainPercent();
	iThreshold /= 100;

	return std::max(1, iThreshold);
}

//	--------------------------------------------------------------------------------
int CvPlayer::specialistYield(SpecialistTypes eSpecialist, YieldTypes eYield) const
{
	CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
	if(pkSpecialistInfo == NULL)
	{
		//This function REQUIRES a valid specialist info.
		CvAssert(pkSpecialistInfo);
		return 0;
	}

	int iRtnValue = pkSpecialistInfo->getYieldChange(eYield) + getSpecialistExtraYield(eSpecialist, eYield) + GetPlayerTraits()->GetSpecialistYieldChange(eSpecialist, eYield);
	iRtnValue += getSpecialistYieldChange(eSpecialist, eYield);

	if (eSpecialist != GD_INT_GET(DEFAULT_SPECIALIST))
	{
		iRtnValue += getSpecialistExtraYield(eYield);
	}
	return (iRtnValue);
}

//	--------------------------------------------------------------------------------
/// How much additional Yield does every City produce?
int CvPlayer::GetCityYieldChangeTimes100(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiCityYieldChange[eYield];
}

//	--------------------------------------------------------------------------------
/// Changes how much additional Yield every City produces
void CvPlayer::ChangeCityYieldChangeTimes100(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiCityYieldChange[eYield] = m_aiCityYieldChange[eYield] + iChange;

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
/// How much additional Yield do coastal Cities produce?
int CvPlayer::GetCoastalCityYieldChange(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiCoastalCityYieldChange[eYield];
}

//	--------------------------------------------------------------------------------
/// Changes how much additional Yield coastal Cities produce
void CvPlayer::ChangeCoastalCityYieldChange(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiCoastalCityYieldChange[eYield] = m_aiCoastalCityYieldChange[eYield] + iChange;

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
/// How much additional Yield does the Capital produce?
int CvPlayer::GetCapitalYieldChangeTimes100(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiCapitalYieldChange[eYield];
}

//	--------------------------------------------------------------------------------
/// Changes how much additional Yield the Capital produces
void CvPlayer::ChangeCapitalYieldChangeTimes100(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiCapitalYieldChange[eYield] = m_aiCapitalYieldChange[eYield] + iChange;

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
/// How much additional Yield does the Capital produce per pop?
int CvPlayer::GetCapitalYieldPerPopChange(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiCapitalYieldPerPopChange[eYield];
}

//	--------------------------------------------------------------------------------
/// Changes how much additional Yield the Capital produces per pop
void CvPlayer::ChangeCapitalYieldPerPopChange(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiCapitalYieldPerPopChange[eYield] = m_aiCapitalYieldPerPopChange[eYield] + iChange;

		updateYield();
	}
}


//	--------------------------------------------------------------------------------
/// How much additional Yield does the Capital produce per pop?
int CvPlayer::GetCapitalYieldPerPopChangeEmpire(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiCapitalYieldPerPopChangeEmpire[eYield];
}

//	--------------------------------------------------------------------------------
/// Changes how much additional Yield the Capital produces per pop
void CvPlayer::ChangeCapitalYieldPerPopChangeEmpire(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiCapitalYieldPerPopChangeEmpire[eYield] = m_aiCapitalYieldPerPopChangeEmpire[eYield] + iChange;

		updateYield();
	}
}


//	--------------------------------------------------------------------------------
/// How much additional Yield does a Great Work produce?
int CvPlayer::GetGreatWorkYieldChange(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiGreatWorkYieldChange[eYield];
}

//	--------------------------------------------------------------------------------
/// Changes how much additional Yield a Great Work produces
void CvPlayer::ChangeGreatWorkYieldChange(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiGreatWorkYieldChange[eYield] = m_aiGreatWorkYieldChange[eYield] + iChange;
	}
}

//	--------------------------------------------------------------------------------
CvPlot* CvPlayer::getStartingPlot() const
{
	return GC.getMap().plotCheckInvalid(m_iStartingX, m_iStartingY);
}


//	--------------------------------------------------------------------------------
void CvPlayer::setStartingPlot(CvPlot* pNewValue)
{
	CvPlot* pOldStartingPlot = getStartingPlot();

	if(pOldStartingPlot != pNewValue)
	{
		if(pOldStartingPlot != NULL)
		{
			pOldStartingPlot->area()->changeNumStartingPlots(-1);
		}

		if(pNewValue == NULL)
		{
			m_iStartingX = INVALID_PLOT_COORD;
			m_iStartingY = INVALID_PLOT_COORD;
		}
		else
		{
			m_iStartingX = pNewValue->getX();
			m_iStartingY = pNewValue->getY();

			getStartingPlot()->setStartingPlot(true);

			CvArea* pArea = getStartingPlot()->area();
			if(pArea != NULL)
				pArea->changeNumStartingPlots(1);
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getTotalPopulation() const
{
	return m_iTotalPopulation;
}


//	--------------------------------------------------------------------------------
float CvPlayer::getAveragePopulation() const
{
	if(getNumCities() == 0)
	{
		return 0;
	}

	return getTotalPopulation() / (float)getNumCities();
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeTotalPopulation(int iChange)
{
	m_iTotalPopulation = (m_iTotalPopulation + iChange);
	CvAssert(getTotalPopulation() >= 0);
}


//	--------------------------------------------------------------------------------
long CvPlayer::getRealPopulation() const
{
	__int64 iTotalPopulation = 0;
	int iLoop;

	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iTotalPopulation += pLoopCity->getRealPopulation();
	}

	if(iTotalPopulation > INT_MAX)
	{
		iTotalPopulation = INT_MAX;
	}

	return ((long)(iTotalPopulation));
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNewCityExtraPopulation() const
{
	return m_iNewCityExtraPopulation;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNewCityExtraPopulation(int iChange)
{
	if(iChange != 0)
	{
		m_iNewCityExtraPopulation += iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetFreeFoodBox() const
{
	return m_iFreeFoodBox;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeFreeFoodBox(int iChange)
{
	if(iChange != 0)
	{
		m_iFreeFoodBox += iChange;
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getTotalLand() const
{
	return m_iTotalLand;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeTotalLand(int iChange)
{
	m_iTotalLand = (m_iTotalLand + iChange);
	CvAssert(getTotalLand() >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getTotalLandScored() const
{
	return m_iTotalLandScored;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeTotalLandScored(int iChange)
{
	if(iChange != 0)
	{
		m_iTotalLandScored = (m_iTotalLandScored + iChange);
		CvAssert(getTotalLandScored() >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Total culture per turn
int CvPlayer::GetTotalJONSCulturePerTurn() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_POLICIES))
	{
		return 0;
	}

	// No culture during Anarchy
	if(IsAnarchy())
	{
		return 0;
	}

	int iCulturePerTurn = 0;

	// Culture per turn from Cities
	iCulturePerTurn += GetJONSCulturePerTurnFromCities();

	// Special bonus which adds excess Happiness to Culture?
	iCulturePerTurn += GetJONSCulturePerTurnFromExcessHappiness();

	// Trait bonus which adds Culture for trade partners? 
	iCulturePerTurn += GetJONSCulturePerTurnFromTraits();

	// Free culture that's part of the player
	iCulturePerTurn += GetJONSCulturePerTurnForFree();

	// Culture from Minor Civs
	iCulturePerTurn += GetCulturePerTurnFromMinorCivs();

	// Culture from Religion
	iCulturePerTurn += GetCulturePerTurnFromReligion();
	
	// Temporary boost from bonus turns
	iCulturePerTurn += GetCulturePerTurnFromBonusTurns();

	// We have vassals, we get x% of their culture
	iCulturePerTurn += (GetYieldPerTurnFromVassals(YIELD_CULTURE));

	if (MOD_BALANCE_CORE_JFD)
	{
		iCulturePerTurn += GetYieldPerTurnFromMinors(YIELD_CULTURE);
	}

	// Golden Age bonus
	if (isGoldenAge() && !IsGoldenAgeCultureBonusDisabled())
	{
		iCulturePerTurn += ((iCulturePerTurn * /*20*/ GD_INT_GET(GOLDEN_AGE_CULTURE_MODIFIER)) / 100);
	}

	return iCulturePerTurn;
}

//	--------------------------------------------------------------------------------
/// Culture per turn from Cities
int CvPlayer::GetJONSCulturePerTurnFromCities() const
{
	int iCulturePerTurn = 0;

	// Add in culture from Cities
	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iCulturePerTurn += pLoopCity->getJONSCulturePerTurn();
	}

	return iCulturePerTurn;
}

//	--------------------------------------------------------------------------------
/// Culture per turn from Cities times 100
int CvPlayer::GetJONSCultureFromCitiesTimes100(bool bIgnoreTrade) const
{
	int iCulture = 0;

	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iCulture += pLoopCity->getYieldRateTimes100(YIELD_CULTURE, bIgnoreTrade);
	}

	return iCulture;
}

//	--------------------------------------------------------------------------------
/// Special bonus which adds excess Happiness to Culture?
int CvPlayer::GetJONSCulturePerTurnFromExcessHappiness() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS))
	{
		return 0;
	}
	if (MOD_BALANCE_CORE_HAPPINESS)
		return 0;

	if(getHappinessToCulture() != 0)
	{
		if(GetExcessHappiness() > 0)
		{
			int iFreeCulture = GetExcessHappiness() * getHappinessToCulture();
			iFreeCulture /= 100;

			return iFreeCulture;
		}
	}

	return 0;
}

//	--------------------------------------------------------------------------------
/// Trait bonus which adds Culture for trade partners? //ADDED: Culture from resources exported/imported
int CvPlayer::GetJONSCulturePerTurnFromTraits() const
{
	return (GetYieldPerTurnFromTraits(YIELD_CULTURE) + GetYieldPerTurnFromResources(YIELD_CULTURE, true, true));
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Yield per turn from resources imported/exported
int CvPlayer::GetYieldPerTurnFromResources(YieldTypes eYield, bool bExported, bool bImported) const
{
	int iExport = 0;
	int iImport = 0;
	int iTotal = 0;
	int iEra = GetCurrentEra();
	if(iEra < 1)
	{
		iEra = 1;
	}
	//Let's get our total imports/exports
	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
		CvResourceInfo* pInfo = GC.getResourceInfo(eResourceLoop);
		// Is it a luxury?
		if (pInfo && pInfo->getResourceUsage() == RESOURCEUSAGE_LUXURY)
		{
			if(getResourceExport(eResourceLoop) > 0)
			{
				iExport++;
			}
			if(getResourceImportFromMajor(eResourceLoop) > 0)
			{
				iImport++;
			}
			else if(getResourceFromMinors(eResourceLoop) > 0)
			{
				iImport++;
			}
			else if(getResourceFromCSAlliances(eResourceLoop) > 0)
			{
				iImport++;
			}
			else if(getResourceSiphoned(eResourceLoop) > 0)
			{
				iImport++;
			}
		}
	}
	if(bExported)
	{
		if(GetPlayerTraits()->GetYieldFromExport(eYield) > 0)
		{
			iTotal += (iEra * iExport * GetPlayerTraits()->GetYieldFromExport(eYield));
		}
	}
	if(bImported)
	{
		if(GetPlayerTraits()->GetYieldFromImport(eYield) > 0)
		{
			iTotal += (iEra * iImport * GetPlayerTraits()->GetYieldFromImport(eYield));
		}
	}

	return iTotal;
}
#endif
//	--------------------------------------------------------------------------------
/// Culture per turn player starts with for free
int CvPlayer::GetJONSCulturePerTurnForFree() const
{
	return m_iJONSCulturePerTurnForFree;
}

//	--------------------------------------------------------------------------------
/// Culture per turn player starts with for free
void CvPlayer::ChangeJONSCulturePerTurnForFree(int iChange)
{
	m_iJONSCulturePerTurnForFree += iChange;

	if (GC.getGame().getActivePlayer() == GetID())
	{
		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
	}
}

//	--------------------------------------------------------------------------------
/// Culture per turn from all minor civs
int CvPlayer::GetCulturePerTurnFromMinorCivs() const
{
	int iAmount = 0;
	for (int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		PlayerTypes eMinor = (PlayerTypes) iMinorLoop;
		iAmount += GetCulturePerTurnFromMinor(eMinor);
	}

	return iAmount;
}

//	--------------------------------------------------------------------------------
// Culture per turn from a minor civ
int CvPlayer::GetCulturePerTurnFromMinor(PlayerTypes eMinor) const
{
	int iAmount = 0;

	if (GET_PLAYER(eMinor).isAlive())
	{
		// Includes flat bonus and any bonus from cultural buildings
		iAmount += GET_PLAYER(eMinor).GetMinorCivAI()->GetCurrentCultureBonus(GetID());
	}

	return iAmount;
}

//	--------------------------------------------------------------------------------
/// Culture per turn from religion
int CvPlayer::GetCulturePerTurnFromReligion() const
{
	int iOtherCulturePerTurn = 0;
	int iReligionCulturePerTurn = 0;

	// Start by seeing how much the other types are bringing in
	iOtherCulturePerTurn += GetJONSCulturePerTurnFromCities();
	iOtherCulturePerTurn += GetJONSCulturePerTurnFromExcessHappiness();
	iOtherCulturePerTurn += GetJONSCulturePerTurnForFree();
	iOtherCulturePerTurn += GetCulturePerTurnFromMinorCivs();

	// Founder beliefs
	CvGameReligions* pReligions = GC.getGame().GetGameReligions();
	ReligionTypes eOwnedReligion = GetReligions()->GetOwnedReligion();
	if (eOwnedReligion != NO_RELIGION)
	{
		const CvReligion* pReligion = pReligions->GetReligion(eOwnedReligion, NO_PLAYER);
		if (pReligion)
		{
			iReligionCulturePerTurn += GetYieldPerTurnFromReligion(YIELD_CULTURE);

			bool bAtPeace = GET_TEAM(getTeam()).getAtWarCount(false) == 0;
			CvCity* pHolyCity = pReligion->GetHolyCity();
			int iMod = pReligion->m_Beliefs.GetPlayerCultureModifier(bAtPeace, GetID(), pHolyCity, true);

			if (iMod != 0)
			{
				iReligionCulturePerTurn += ((iReligionCulturePerTurn + iOtherCulturePerTurn) * iMod) / 100;
			}
			return iReligionCulturePerTurn;
		}
	}
	return 0;
}

//	--------------------------------------------------------------------------------
/// Culture from Bonus Turns
int CvPlayer::GetCulturePerTurnFromBonusTurns() const
{
	int iValue = 0;

	int iCulturePerTurn = 0;
	if (GetCultureBonusTurns() > 0 || GetCultureBonusTurnsConquest() > 0)
	{
		// Culture per turn from Cities
		iCulturePerTurn += GetJONSCulturePerTurnFromCities();

		// Special bonus which adds excess Happiness to Culture?
		iCulturePerTurn += GetJONSCulturePerTurnFromExcessHappiness();

		// Trait bonus which adds Culture for trade partners? 
		iCulturePerTurn += GetJONSCulturePerTurnFromTraits();

		// Free culture that's part of the player
		iCulturePerTurn += GetJONSCulturePerTurnForFree();

		// Culture from Minor Civs
		iCulturePerTurn += GetCulturePerTurnFromMinorCivs();

		// Culture from Religion
		iCulturePerTurn += GetCulturePerTurnFromReligion();

		// We have vassals, we get x% of their culture
		iCulturePerTurn += (GetYieldPerTurnFromVassals(YIELD_CULTURE));

		if (MOD_BALANCE_CORE_JFD)
		{
			iCulturePerTurn += GetYieldPerTurnFromMinors(YIELD_CULTURE);
		}

		// Golden Age bonus
		if (isGoldenAge() && !IsGoldenAgeCultureBonusDisabled())
		{
			iCulturePerTurn += ((iCulturePerTurn * /*20*/ GD_INT_GET(GOLDEN_AGE_CULTURE_MODIFIER)) / 100);
		}
	}

	if (GetCultureBonusTurns() > 0)
	{
		iValue += ((iCulturePerTurn * /*100 in CP, 33 in VP*/ GD_INT_GET(TEMPORARY_CULTURE_BOOST_MOD)) / 100);
	}
#if defined(MOD_BALANCE_CORE)
	if (GetCultureBonusTurnsConquest() > 0)
	{
		iValue += ((iCulturePerTurn * GetPlayerTraits()->GetCultureBonusModifierConquest()) / 100);
	}	
#endif

	return iValue;
}

//	--------------------------------------------------------------------------------
/// Modifier for all Cities' culture
int CvPlayer::GetJONSCultureCityModifier() const
{
	return m_iJONSCultureCityModifier;
}

//	--------------------------------------------------------------------------------
/// Modifier for all Cities' culture
void CvPlayer::ChangeJONSCultureCityModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iJONSCultureCityModifier += iChange;

		if(GC.getGame().getActivePlayer() == GetID())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Modifier for all Cities' culture
int CvPlayer::GetLeagueCultureCityModifier() const
{
	return m_iLeagueCultureCityModifier;
}

//	--------------------------------------------------------------------------------
/// Modifier for all Cities' culture
void CvPlayer::ChangeLeagueCultureCityModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iLeagueCultureCityModifier += iChange;

		if(GC.getGame().getActivePlayer() == GetID())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getJONSCulture() const
{
	// City States can't pick Policies, sorry!
	if(isMinorCiv())
		return 0;

	if(GC.getGame().isOption(GAMEOPTION_NO_POLICIES))
	{
		return 0;
	}

	return m_iJONSCulture;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setJONSCulture(int iNewValue)
{
	if(getJONSCulture() != iNewValue)
	{
		// Add to the total we've ever had
		if(iNewValue > m_iJONSCulture)
		{
			ChangeJONSCultureEverGenerated(iNewValue - m_iJONSCulture);
		}

		m_iJONSCulture = max(0,iNewValue);

		if(GC.getGame().getActivePlayer() == GetID())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeJONSCulture(int iChange)
{
	setJONSCulture(getJONSCulture() + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::GetJONSCultureEverGenerated() const
{
	return m_iJONSCultureEverGenerated;
}


//	--------------------------------------------------------------------------------
void CvPlayer::SetJONSCultureEverGenerated(int iNewValue)
{
	if(GetJONSCultureEverGenerated() != iNewValue)
	{
		m_iJONSCultureEverGenerated = iNewValue;
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeJONSCultureEverGenerated(int iChange)
{
	SetJONSCultureEverGenerated(GetJONSCultureEverGenerated() + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::GetJONSCulturePerCityPerTurn() const
{
	int iCulture = GetJONSCultureEverGenerated();
	int iNumCities = getNumCities();

	// Puppet Cities don't count
	iNumCities -= GetNumPuppetCities();

	int iNumTurns = GC.getGame().getElapsedGameTurns();

	if(iNumTurns == 0)
	{
		iNumTurns = 1;
	}

	int iCulturePerCityPerTurn = 100 * iCulture / iNumCities / iNumTurns;
	return iCulturePerCityPerTurn;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetWondersConstructed() const
{
	return m_iWondersConstructed;
}


//	--------------------------------------------------------------------------------
void CvPlayer::SetWondersConstructed(int iNewValue)
{
	m_iWondersConstructed = iNewValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeWondersConstructed(int iChange)
{
	SetWondersConstructed(GetWondersConstructed() + iChange);
}

//	--------------------------------------------------------------------------------
/// Amount of extra Culture per Wonder
int CvPlayer::GetCulturePerWonder() const
{
	return m_iCulturePerWonder;
}

//	--------------------------------------------------------------------------------
/// Changes amount of extra Culture per Wonder
void CvPlayer::ChangeCulturePerWonder(int iChange)
{
	if(iChange != 0)
	{
		m_iCulturePerWonder += iChange;

		int iTotalCultureChange;

		// Loop through all Cities and change how much Culture they produce based on how many Wonders they have
		int iLoop;
		for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			iTotalCultureChange = pLoopCity->getNumWorldWonders() * iChange;
			pLoopCity->ChangeJONSCulturePerTurnFromPolicies(iTotalCultureChange);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Culture multiplier for having a world wonder
int CvPlayer::GetCultureWonderMultiplier() const
{
	return m_iCultureWonderMultiplier;
}

//	--------------------------------------------------------------------------------
/// Changes amount of extra Culture per Wonder
void CvPlayer::ChangeCultureWonderMultiplier(int iChange)
{
	if(iChange != 0)
		m_iCultureWonderMultiplier += iChange;
}

//	--------------------------------------------------------------------------------
/// Amount of Culture provided for each Tech Researched
int CvPlayer::GetCulturePerTechResearched() const
{
	return m_iCulturePerTechResearched;
}

//	--------------------------------------------------------------------------------
/// Changes amount of Culture provided for each Tech Researched
void CvPlayer::ChangeCulturePerTechResearched(int iChange)
{
	if(iChange != 0)
	{
		m_iCulturePerTechResearched += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Specialist Culture Modifier
int CvPlayer::GetSpecialistCultureChange() const
{
	return m_iSpecialistCultureChange;
}

//	--------------------------------------------------------------------------------
/// Specialist Culture Modifier
void CvPlayer::ChangeSpecialistCultureChange(int iChange)
{
	if(iChange != 0)
	{
		int iLoop;
		int iTotalCulture = 0;

		// Undo old culture
		for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			for(int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
			{
				SpecialistTypes eSpecialist = (SpecialistTypes) iSpecialistLoop;
				int iSpecialistCount = pLoopCity->GetCityCitizens()->GetSpecialistCount(eSpecialist);
				iTotalCulture += (iSpecialistCount * pLoopCity->GetCultureFromSpecialist(eSpecialist));
			}

			pLoopCity->ChangeJONSCulturePerTurnFromSpecialists(-iTotalCulture);
		}

		// CHANGE VALUE
		m_iSpecialistCultureChange += iChange;

		iTotalCulture = 0;

		// Apply new culture
		for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			for(int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
			{
				SpecialistTypes eSpecialist = (SpecialistTypes) iSpecialistLoop;
				int iSpecialistCount = pLoopCity->GetCityCitizens()->GetSpecialistCount(eSpecialist);
				iTotalCulture += (iSpecialistCount * pLoopCity->GetCultureFromSpecialist(eSpecialist));
			}

			pLoopCity->ChangeJONSCulturePerTurnFromSpecialists(iTotalCulture);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Cities remaining to get a free culture building
int CvPlayer::GetNumCitiesFreeCultureBuilding() const
{
	return m_iNumCitiesFreeCultureBuilding;
}

//	--------------------------------------------------------------------------------
/// Changes number of cities remaining to get a free culture building
void CvPlayer::ChangeNumCitiesFreeCultureBuilding(int iChange)
{
	if(iChange != 0)
		m_iNumCitiesFreeCultureBuilding += iChange;
}

//	--------------------------------------------------------------------------------
/// Cities remaining to get a free culture building
int CvPlayer::GetNumCitiesFreeFoodBuilding() const
{
	return m_iNumCitiesFreeFoodBuilding;
}

//	--------------------------------------------------------------------------------
/// Changes number of cities remaining to get a free culture building
void CvPlayer::ChangeNumCitiesFreeFoodBuilding(int iChange)
{
	if(iChange != 0)
		m_iNumCitiesFreeFoodBuilding += iChange;
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Cities remaining to get a free building
int CvPlayer::GetNumCitiesFreeChosenBuilding(BuildingClassTypes eBuildingClass) const
{
	CvAssertMsg(eBuildingClass < GC.getNumBuildingClassInfos(), "Index out of bounds");
	CvAssertMsg(eBuildingClass > -1, "Index out of bounds");
	return m_paiNumCitiesFreeChosenBuilding[eBuildingClass];
}

//	--------------------------------------------------------------------------------
/// Changes number of cities remaining to get a free building
void CvPlayer::ChangeNumCitiesFreeChosenBuilding(BuildingClassTypes eBuildingClass, int iChange)
{
	m_paiNumCitiesFreeChosenBuilding[eBuildingClass] = (m_paiNumCitiesFreeChosenBuilding[eBuildingClass] + iChange);
}
/// New Founded City waiting to get a free unit?
bool CvPlayer::IsFreeUnitNewFoundCity(UnitClassTypes eUnitClass) const
{
	CvAssertMsg(eUnitClass < GC.getNumUnitClassInfos(), "Index out of bounds");
	CvAssertMsg(eUnitClass > -1, "Index out of bounds");
	return m_pabNewFoundCityFreeUnit[eUnitClass];
}
//	--------------------------------------------------------------------------------
/// Changes number of newly founded cities to get a free building
void CvPlayer::ChangeNewFoundCityFreeUnit(UnitClassTypes eUnitClass, bool bValue)
{
	m_pabNewFoundCityFreeUnit[eUnitClass] = bValue;
}
/// New Founded City waiting to get a free building?
bool CvPlayer::IsFreeBuildingNewFoundCity(BuildingClassTypes eBuildingClass) const
{
	CvAssertMsg(eBuildingClass < GC.getNumBuildingClassInfos(), "Index out of bounds");
	CvAssertMsg(eBuildingClass > -1, "Index out of bounds");
	return m_pabNewFoundCityFreeBuilding[eBuildingClass];
}
//	--------------------------------------------------------------------------------
/// Changes number of newly founded cities to get a free building
void CvPlayer::ChangeNewFoundCityFreeBuilding(BuildingClassTypes eBuildingClass, bool bValue)
{
	m_pabNewFoundCityFreeBuilding[eBuildingClass] = bValue;
}
/// Cities remaining to get a free building
bool CvPlayer::IsFreeChosenBuildingNewCity(BuildingClassTypes eBuildingClass) const
{
	CvAssertMsg(eBuildingClass < GC.getNumBuildingClassInfos(), "Index out of bounds");
	CvAssertMsg(eBuildingClass > -1, "Index out of bounds");
	return m_pabFreeChosenBuildingNewCity[eBuildingClass];
}

//	--------------------------------------------------------------------------------
/// Changes number of new cities remaining to get a free building
void CvPlayer::ChangeFreeChosenBuildingNewCity(BuildingClassTypes eBuildingClass, bool bValue)
{
	m_pabFreeChosenBuildingNewCity[eBuildingClass] = bValue;
}
// City waiting to get a free building?
bool CvPlayer::IsFreeBuildingAllCity(BuildingClassTypes eBuildingClass) const
{
	CvAssertMsg(eBuildingClass < GC.getNumBuildingClassInfos(), "Index out of bounds");
	CvAssertMsg(eBuildingClass > -1, "Index out of bounds");
	return m_pabAllCityFreeBuilding[eBuildingClass];
}
// Change Cities that get a Free building
void CvPlayer::ChangeAllCityFreeBuilding(BuildingClassTypes eBuildingClass, bool bValue)
{
	m_pabAllCityFreeBuilding[eBuildingClass] = bValue;
}

/// Reformation Unlock
void CvPlayer::SetReformation(bool bValue)
{
	if(m_bIsReformation != bValue)
	{
		m_bIsReformation = bValue;
	}
}

bool CvPlayer::IsReformation() const
{
	return m_bIsReformation;
}

int CvPlayer::GetReformationFollowerReduction() const
{
	return m_iReformationFollowerReduction;
}

void CvPlayer::ChangeReformationFollowerReduction(int iValue)
{
	m_iReformationFollowerReduction += iValue;
}
#endif
//	--------------------------------------------------------------------------------
/// Handle earning yields from a combat win
void CvPlayer::DoYieldsFromKill(CvUnit* pAttackingUnit, CvUnit* pDefendingUnit, CvCity* pCity)
{
#if defined(MOD_BALANCE_CORE)
	//Bonus resource in a city every time you win a battle.
	if (MOD_BALANCE_CORE && pDefendingUnit != NULL && pDefendingUnit->IsCombatUnit())
	{
		CvCity* pOriginCity = pCity;
		CvCity* pCapitalCity = getCapitalCity();
		if (pAttackingUnit != NULL)
		{
			pOriginCity = pAttackingUnit->getOriginCity();
			if (pOriginCity == NULL)
				pOriginCity = pCapitalCity;
		}
		else if (pDefendingUnit->plot()->getOwner() == GetID())
		{
			pOriginCity = pDefendingUnit->plot()->getOwningCity();
		}

		doInstantYield(INSTANT_YIELD_TYPE_VICTORY, false, NO_GREATPERSON, NO_BUILDING, 0, true, NO_PLAYER, NULL, false, pOriginCity, pDefendingUnit->getDomainType() == DOMAIN_SEA, true, false, NO_YIELD, pDefendingUnit, NO_TERRAIN, NULL, NULL, pAttackingUnit);
		doInstantYield(INSTANT_YIELD_TYPE_VICTORY_GLOBAL, false, NO_GREATPERSON, NO_BUILDING, 0, true, NO_PLAYER, NULL, false, NULL, pDefendingUnit->getDomainType() == DOMAIN_SEA, true, false, NO_YIELD, pDefendingUnit, NO_TERRAIN, NULL, NULL, pAttackingUnit);

		if (pCapitalCity)
		{
			doInstantGreatPersonProgress(INSTANT_YIELD_TYPE_VICTORY, false, pCapitalCity);
			if (GetPlayerTraits()->IsRandomGreatPersonProgressFromKills())
			{
				std::pair <GreatPersonTypes, int> aResults = GetPlayerTraits()->GetRandomGreatPersonProgressFromKills(pAttackingUnit->GetID() + pAttackingUnit->getMoves() + pDefendingUnit->GetID() + pDefendingUnit->getMoves());
				if (aResults.first != NO_GREATPERSON && aResults.second > 0)
				{
					doInstantGreatPersonProgress(INSTANT_YIELD_TYPE_VICTORY, false, pCapitalCity, NO_BUILDING, aResults.second, aResults.first);
				}
			}
		}
	}
#endif
}

//	--------------------------------------------------------------------------------
/// Each a technology from conquering a city
void CvPlayer::DoTechFromCityConquer(CvCity* pConqueredCity)
{
	PlayerTypes eOpponent = pConqueredCity->getOwner();
	vector<TechTypes> vePossibleTechs;
	int iCheapestTechCost = MAX_INT;
	for (int i = 0; i < GC.getNumTechInfos(); i++)
	{
		TechTypes e = (TechTypes) i;
		CvTechEntry* pInfo = GC.getTechInfo(e);
		if (pInfo)
		{
			// They have it
			if (GET_TEAM(GET_PLAYER(eOpponent).getTeam()).GetTeamTechs()->HasTech(e))
			{
				// We don't
				if (!GET_TEAM(getTeam()).GetTeamTechs()->HasTech(e))
				{
					// But we could
					if (GetPlayerTechs()->CanResearch(e))
					{
						if (pInfo->GetResearchCost() < iCheapestTechCost)
						{
							iCheapestTechCost = pInfo->GetResearchCost();
							vePossibleTechs.clear();
							vePossibleTechs.push_back(e);
						}
						else if (pInfo->GetResearchCost() == iCheapestTechCost)
						{
							vePossibleTechs.push_back(e);
						}
					}
				}
			}
		}
	}

	if (!vePossibleTechs.empty())
	{
		int iRoll = GC.getGame().getSmallFakeRandNum((int)vePossibleTechs.size(), GET_PLAYER(pConqueredCity->getOwner()).GetPseudoRandomSeed());
		TechTypes eFreeTech = vePossibleTechs[iRoll];
		CvAssert(eFreeTech != NO_TECH)
		if (eFreeTech != NO_TECH)
		{
			GET_TEAM(getTeam()).setHasTech(eFreeTech, true, GetID(), true, true);
			GET_TEAM(getTeam()).GetTeamTechs()->SetNoTradeTech(eFreeTech, true);
		}
	}
#if defined(MOD_BALANCE_CORE)
	else
	{
		int iEra = GetCurrentEra();
		if(iEra <= 1)
		{
			iEra = 1;
		}
		const char* strTargetNameKey = pConqueredCity->getNameKey();
		TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
		int iValue = (pConqueredCity->getPopulation() * 20 * iEra);
		iValue *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
		iValue /= 100;
		if(eCurrentTech == NO_TECH)
		{
			changeOverflowResearch(iValue);
		}
		else
		{
			GET_TEAM(GET_PLAYER(GetID()).getTeam()).GetTeamTechs()->ChangeResearchProgress(eCurrentTech, iValue, GetID());
		}
		if(GetID() == GC.getGame().getActivePlayer())
		{
			Localization::String strMessage;
			Localization::String strSummary;
			strMessage = Localization::Lookup("TXT_KEY_SCIENCE_BOOST_CONQUEST");
			strMessage << iValue;
			strMessage << strTargetNameKey;
			strSummary = Localization::Lookup("TXT_KEY_SCIENCE_BOOST_CONQUEST_SUMMARY");

			CvNotifications* pNotification = GetNotifications();
			if(pNotification)
			{
				pNotification->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), pConqueredCity->getX(), pConqueredCity->getY(), (int) pConqueredCity->GetID(), GetID());
			}
		}
	}
#endif
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Generate a random great work on city conquest
void CvPlayer::DoFreeGreatWorkOnConquest(PlayerTypes ePlayer, CvCity* pCity)
{
	GreatWorkSlotType eArtArtifactSlot = CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT();
	GreatWorkSlotType eMusicSlot = CvTypes::getGREAT_WORK_SLOT_MUSIC();
	GreatWorkSlotType eWritingSlot = CvTypes::getGREAT_WORK_SLOT_LITERATURE();

	int iOpenSlots = 0;
	int iStuffStolen = 0;
	CvWeightedVector<int> artChoices;
	const char* strTargetNameKey = pCity->getNameKey();
	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iOpenSlots += pLoopCity->GetCityBuildings()->GetNumAvailableGreatWorkSlots(eArtArtifactSlot);
		iOpenSlots += pLoopCity->GetCityBuildings()->GetNumAvailableGreatWorkSlots(eMusicSlot);
		iOpenSlots += pLoopCity->GetCityBuildings()->GetNumAvailableGreatWorkSlots(eWritingSlot);
	}
	if (GET_PLAYER(ePlayer).isAlive() && !GET_PLAYER(ePlayer).isMinorCiv() && !GET_PLAYER(ePlayer).isBarbarian())
	{
		if (iOpenSlots > 0)
		{
			int iCityLoop;
			CvCity* pPlayerCity = NULL;
			int iGreatWorkIndex;
			for (pPlayerCity = GET_PLAYER(ePlayer).firstCity(&iCityLoop); pPlayerCity != NULL; pPlayerCity = GET_PLAYER(ePlayer).nextCity(&iCityLoop))
			{
				if (pPlayerCity != NULL && pPlayerCity != pCity)
				{
					int iDistance = plotDistance(pCity->getX(), pCity->getY(), pPlayerCity->getX(), pPlayerCity->getY());
					if (iDistance > 0)
					{
						for (int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
						{
							const CvCivilizationInfo& playerCivilizationInfo = GET_PLAYER(ePlayer).getCivilizationInfo();
							BuildingTypes eBuilding = NO_BUILDING;
							if (MOD_BUILDINGS_THOROUGH_PREREQUISITES || GET_PLAYER(ePlayer).GetPlayerTraits()->IsKeepConqueredBuildings())
							{
								eBuilding = pPlayerCity->GetCityBuildings()->GetBuildingTypeFromClass((BuildingClassTypes)iBuildingClassLoop);
							}
							else
							{
								eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings((BuildingClassTypes)iBuildingClassLoop);
							}
							if (eBuilding != NO_BUILDING)
							{
								CvBuildingEntry *pkBuilding = GC.getBuildingInfo(eBuilding);
								if (pkBuilding)
								{
									if (pPlayerCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0 && (pkBuilding->GetGreatWorkSlotType() == eArtArtifactSlot || pkBuilding->GetGreatWorkSlotType() == eMusicSlot || pkBuilding->GetGreatWorkSlotType() == eWritingSlot))
									{
										int iNumSlots = pkBuilding->GetGreatWorkCount();
										if (iNumSlots > 0)
										{
											for (int iI = 0; iI < iNumSlots; iI++)
											{
												iGreatWorkIndex = pPlayerCity->GetCityBuildings()->GetBuildingGreatWork((BuildingClassTypes)iBuildingClassLoop, iI);
												if (iGreatWorkIndex != -1 && !GetCulture()->ControlsGreatWork(iGreatWorkIndex))
												{
													artChoices.push_back(iGreatWorkIndex, iDistance);
													if ((GC.getLogging() && GC.getAILogging()))
													{
														CvGameCulture *pCulture = GC.getGame().GetGameCulture();
														if (pCulture)
														{
															CvString strLogString;
															strLogString.Format("Found Great Work for Conquest Plunder: %d, Distance: %d, Name: %s", iGreatWorkIndex, iDistance, pCulture->GetGreatWorkName(iGreatWorkIndex).GetCString());
															GetHomelandAI()->LogHomelandMessage(strLogString);
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			artChoices.SortItems();
			int iNotificationArtwork = -1;
			if (artChoices.size() > 0)
			{
				int iPlunder = GC.getGame().getSmallFakeRandNum(max(1, (iOpenSlots / 5)), GET_PLAYER(pCity->getOwner()).GetPseudoRandomSeed());
				if (iPlunder <= 2)
				{
					iPlunder = 2;
				}
				if (iPlunder > artChoices.size())
				{
					iPlunder = artChoices.size();
				}
				if ((GC.getLogging() && GC.getAILogging()))
				{
					CvString strLogString;
					strLogString.Format("Number of Great Works to steal for Conquest Plunder: %d", iPlunder);
					GetHomelandAI()->LogHomelandMessage(strLogString);
				}
				for (int iGrab = 0; iGrab < artChoices.size(); iGrab++)
				{
					if (iStuffStolen >= iPlunder)
					{
						break;
					}
					int iCityLoop;
					CvCity* pPlayerCity = NULL;
					int iGreatWorkIndex;
					for (pPlayerCity = GET_PLAYER(ePlayer).firstCity(&iCityLoop); pPlayerCity != NULL; pPlayerCity = GET_PLAYER(ePlayer).nextCity(&iCityLoop))
					{
						if (iStuffStolen >= iPlunder)
						{
							break;
						}
						if (pPlayerCity != NULL && pPlayerCity != pCity)
						{
							for (int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
							{
								if (iStuffStolen >= iPlunder)
								{
									break;
								}
								const CvCivilizationInfo& playerCivilizationInfo = GET_PLAYER(ePlayer).getCivilizationInfo();
								BuildingTypes eBuilding = NO_BUILDING;
								if (MOD_BUILDINGS_THOROUGH_PREREQUISITES || GET_PLAYER(ePlayer).GetPlayerTraits()->IsKeepConqueredBuildings())
								{
									eBuilding = pPlayerCity->GetCityBuildings()->GetBuildingTypeFromClass((BuildingClassTypes)iBuildingClassLoop);
								}
								else
								{
									eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings((BuildingClassTypes)iBuildingClassLoop);
								}
								if (eBuilding != NO_BUILDING)
								{
									CvBuildingEntry *pkBuilding = GC.getBuildingInfo(eBuilding);
									if (pkBuilding)
									{
										if (pPlayerCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0 && (pkBuilding->GetGreatWorkSlotType() == eArtArtifactSlot || pkBuilding->GetGreatWorkSlotType() == eMusicSlot || pkBuilding->GetGreatWorkSlotType() == eWritingSlot))
										{
											int iNumSlots = pkBuilding->GetGreatWorkCount();
											if (iNumSlots > 0)
											{
												for (int iI = 0; iI < iNumSlots; iI++)
												{
													if (iStuffStolen >= iPlunder)
													{
														break;
													}
													iGreatWorkIndex = pPlayerCity->GetCityBuildings()->GetBuildingGreatWork((BuildingClassTypes)iBuildingClassLoop, iI);
													if (iGreatWorkIndex == artChoices.GetElement(iGrab))
													{
														iNotificationArtwork = iGreatWorkIndex;
														// and create great work at home
														BuildingClassTypes eGWBuildingClass;
														int iGWSlot;
														CvCity *pArtCity = GetCulture()->GetClosestAvailableGreatWorkSlot(pPlayerCity->getX(), pPlayerCity->getY(), pkBuilding->GetGreatWorkSlotType(), &eGWBuildingClass, &iGWSlot);
														if (pArtCity)
														{
															// remove existing great works
															pPlayerCity->GetCityBuildings()->SetBuildingGreatWork((BuildingClassTypes)iBuildingClassLoop, iI, -1);
															pArtCity->GetCityBuildings()->SetBuildingGreatWork(eGWBuildingClass, iGWSlot, iGreatWorkIndex);
															iStuffStolen++;
															if ((GC.getLogging() && GC.getAILogging()))
															{
																CvGameCulture *pCulture = GC.getGame().GetGameCulture();
																if (pCulture)
																{
																	CvString strLogString;
																	strLogString.Format("Great Work STOLEN for Conquest Plunder: %s. Number stolen: %d. Max to steal: %d", pCulture->GetGreatWorkName(iGreatWorkIndex).GetCString(), iStuffStolen, iPlunder);
																	GetHomelandAI()->LogHomelandMessage(strLogString);
																}
															}
															if (GetID() == GC.getGame().getActivePlayer())
															{
																CvPopupInfo kPopup(BUTTONPOPUP_GREAT_WORK_COMPLETED_ACTIVE_PLAYER, iGreatWorkIndex);
																GC.GetEngineUserInterface()->AddPopup(kPopup);
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			if (iStuffStolen > 0)
			{
				if (GetID() == GC.getGame().getActivePlayer())
				{
					Localization::String strMessage;
					Localization::String strSummary;
					strMessage = Localization::Lookup("TXT_KEY_ART_STOLEN");
					strMessage << iStuffStolen;
					strMessage << strTargetNameKey;
					strSummary = Localization::Lookup("TXT_KEY_ART_STOLEN_SUMMARY");

					CvNotifications* pNotification = GetNotifications();
					if (pNotification)
					{
						pNotification->Add(NOTIFICATION_GREAT_WORK_COMPLETED_ACTIVE_PLAYER, strMessage.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), iNotificationArtwork, GET_PLAYER(ePlayer).GetID());
					}
				}
				if (ePlayer == GC.getGame().getActivePlayer())
				{
					Localization::String strMessage;
					Localization::String strSummary;
					strMessage = Localization::Lookup("TXT_KEY_ART_PLUNDERED");
					strMessage << iStuffStolen;
					strMessage << strTargetNameKey;
					strSummary = Localization::Lookup("TXT_KEY_ART_PLUNDERED_SUMMARY");

					CvNotifications* pNotification = GET_PLAYER(ePlayer).GetNotifications();
					if (pNotification)
					{
						pNotification->Add(NOTIFICATION_GREAT_WORK_COMPLETED_ACTIVE_PLAYER, strMessage.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), iNotificationArtwork, pCity->getOwner());
					}
				}
			}
		}
	}
}
void CvPlayer::DoWarVictoryBonuses()
{
	int iTurns = GetPlayerTraits()->GetGoldenAgeFromVictory();
	if(iTurns > 0)
	{
		changeGoldenAgeTurns(getGoldenAgeLength(iTurns), true);
	}

	int iTourism = GetHistoricEventTourism(HISTORIC_EVENT_WAR);
	ChangeNumHistoricEvents(HISTORIC_EVENT_WAR, 1);
	// Culture boost based on previous turns
	if(iTourism > 0)
	{
		GetCulture()->AddTourismAllKnownCivsWithModifiers(iTourism);
		if(GetID() == GC.getGame().getActivePlayer())
		{
			CvCity* pCity = getCapitalCity();
			if(pCity != NULL)
			{
				char text[256] = {0};
				sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_TOURISM]", iTourism);
				SHOW_PLOT_POPUP(pCity->plot(), GetID(), text);

				CvNotifications* pNotification = GetNotifications();
				if(pNotification)
				{
					CvString strMessage;
					CvString strSummary;
					strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_WAR", iTourism);
					strSummary = GetLocalizedText("TXT_KEY_TOURISM_EVENT_SUMMARY");
					pNotification->Add(NOTIFICATION_CULTURE_VICTORY_SOMEONE_INFLUENTIAL, strMessage, strSummary, pCity->getX(), pCity->getY(), GetID());
				}
			}
		}
	}
}
void CvPlayer::DoDifficultyBonus(HistoricEventTypes eHistoricEvent)
{
	int iEra = GC.getGame().getCurrentEra();
	if (MOD_ABC_TRIGGER_CHANGE)
	{
		iEra += 1;
	}
	if (iEra <= 0)
	{
		iEra = 1;
	}
	int iHandicapBase = 0;
	int iHandicapA = 0;
	int iHandicapB = 0;
	int iHandicapC = 0;
	int iYieldHandicap = 0;
	int iYieldHandicapSmall = 0;
	int iLoop;

	CvString strLogString;

	CvHandicapInfo* pHandicapInfo = GC.getHandicapInfo(GC.getGame().getHandicapType());
	if (pHandicapInfo)
	{
		iHandicapBase = pHandicapInfo->getAIDifficultyBonusBase();
		iHandicapA = pHandicapInfo->getAIDifficultyBonusEarly();
		iHandicapB = pHandicapInfo->getAIDifficultyBonusMid();
		iHandicapC = pHandicapInfo->getAIDifficultyBonusLate();
		iYieldHandicap = iHandicapBase * ((iHandicapC * iEra * iEra) + (iHandicapB * iEra) + iHandicapA) / 100;
		iYieldHandicapSmall = iYieldHandicap * iEra;
		iYieldHandicapSmall = iYieldHandicapSmall / 10;

		if (!MOD_ABC_TRIGGER_CHANGE)
		{
			iYieldHandicap *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
			iYieldHandicap /= 100;
		}
	}
	int iYieldForCities = max(1, iYieldHandicap / max(1, getNumCities()));
	if (MOD_ABC_TRIGGER_CHANGE)
	{
		if (eHistoricEvent == HISTORIC_EVENT_GA)
		{
			GetTreasury()->ChangeGold(iYieldHandicap);
			changeJONSCulture(iYieldHandicapSmall);
			TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
			if (eCurrentTech == NO_TECH)
			{
				changeOverflowResearch(iYieldHandicapSmall);
			}
			else
			{
				GET_TEAM(getTeam()).GetTeamTechs()->ChangeResearchProgress(eCurrentTech, iYieldHandicapSmall, GetID());
			}
			strLogString.Format("ALTERNATIVE DIFFICULTY BONUS FROM 10th Turn - Received Handicap Bonus (%d in Yields): GOLD, CULTURE, SCIENCE.", iYieldHandicap);
		}
	}
	else
	{
		if (iYieldHandicap > 0)
		{
			switch (eHistoricEvent)
			{
				case HISTORIC_EVENT_ERA:
				{
					iYieldHandicap *= 3;
					for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if (pLoopCity != NULL)
						{
							pLoopCity->changeFood(iYieldForCities);
							pLoopCity->changeProduction(iYieldForCities);
						}
					}
					GetTreasury()->ChangeGold(iYieldHandicap);
					ChangeGoldenAgeProgressMeter(iYieldHandicap);
					changeJONSCulture(iYieldHandicap);

					TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
					if (eCurrentTech == NO_TECH)
					{
						changeOverflowResearch(iYieldHandicap);
					}
					else
					{
						GET_TEAM(getTeam()).GetTeamTechs()->ChangeResearchProgress(eCurrentTech, iYieldHandicap, GetID());
					}
					strLogString.Format("CBP AI DIFFICULTY BONUS FROM HISTORIC EVENT: ERA - Received Handicap Bonus (%d in Yields): FOOD, PRODUCTION, GOLD, GAP, CULTURE, SCIENCE.", iYieldHandicap);
					break;
				}
				case HISTORIC_EVENT_WONDER:
				{
					GetTreasury()->ChangeGold(iYieldHandicap);
					ChangeGoldenAgeProgressMeter(iYieldHandicap);
					strLogString.Format("CBP AI DIFFICULTY BONUS FROM HISTORIC EVENT: WONDER - Received Handicap Bonus (%d in Yields): GOLD, GAP.", iYieldHandicap);
					break;
				}
				case HISTORIC_EVENT_GP:
				{
					GetTreasury()->ChangeGold(iYieldHandicap);
					ChangeGoldenAgeProgressMeter(iYieldHandicap);
					strLogString.Format("CBP AI DIFFICULTY BONUS FROM HISTORIC EVENT: GREAT PERSON - Received Handicap Bonus (%d in Yields): GOLD, GAP.", iYieldHandicap);
					break;
				}
				case HISTORIC_EVENT_WAR:
				{
					for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if (pLoopCity != NULL)
						{
							pLoopCity->changeFood(iYieldForCities);
							pLoopCity->changeProduction(iYieldForCities);
						}
					}
					GetTreasury()->ChangeGold(iYieldHandicap);
					ChangeGoldenAgeProgressMeter(iYieldHandicap);
					changeJONSCulture(iYieldHandicap);

					TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
					if (eCurrentTech == NO_TECH)
					{
						changeOverflowResearch(iYieldHandicap);
					}
					else
					{
						GET_TEAM(getTeam()).GetTeamTechs()->ChangeResearchProgress(eCurrentTech, iYieldHandicap, GetID());
					}
					strLogString.Format("CBP AI DIFFICULTY BONUS FROM HISTORIC EVENT: WAR - Received Handicap Bonus (%d in Yields): FOOD, PRODUCTION, GOLD, GAP, CULTURE, SCIENCE.", iYieldHandicap);
					break;
				}
				case HISTORIC_EVENT_GA:
				{
					for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if (pLoopCity != NULL)
						{
							pLoopCity->changeFood(iYieldForCities);
							pLoopCity->changeProduction(iYieldForCities);
						}
					}
					GetTreasury()->ChangeGold(iYieldHandicap);
					changeJONSCulture(iYieldHandicap);

					TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
					if (eCurrentTech == NO_TECH)
					{
						changeOverflowResearch(iYieldHandicap);
					}
					else
					{
						GET_TEAM(getTeam()).GetTeamTechs()->ChangeResearchProgress(eCurrentTech, iYieldHandicap, GetID());
					}
					strLogString.Format("CBP AI DIFFICULTY BONUS FROM HISTORIC EVENT: GOLDEN AGE - Received Handicap Bonus (%d in Yields): FOOD, PRODUCTION, GOLD, CULTURE, SCIENCE.", iYieldHandicap);
					break;
				}
				case HISTORIC_EVENT_DIG:
				{
					GetTreasury()->ChangeGold(iYieldHandicap);
					strLogString.Format("CBP AI DIFFICULTY BONUS FROM HISTORIC EVENT: DIG - Received Handicap Bonus (%d in Yields): GOLD.", iYieldHandicap);
					break;
				}
				case HISTORIC_EVENT_TRADE_CS:
				{
					GetTreasury()->ChangeGold(iYieldHandicap);
					strLogString.Format("CBP AI DIFFICULTY BONUS FROM HISTORIC EVENT: TRADE (CITY-STATE) - Received Handicap Bonus (%d in Yields): GOLD.", iYieldHandicap);
					break;
				}
				case HISTORIC_EVENT_TRADE_LAND:
				{
					GetTreasury()->ChangeGold(iYieldHandicap);
					strLogString.Format("CBP AI DIFFICULTY BONUS FROM HISTORIC EVENT: TRADE (LAND) - Received Handicap Bonus (%d in Yields): GOLD.", iYieldHandicap);
					break;
				}
				case HISTORIC_EVENT_TRADE_SEA:
				{
					GetTreasury()->ChangeGold(iYieldHandicap);
					strLogString.Format("CBP AI DIFFICULTY BONUS FROM HISTORIC EVENT: TRADE (SEA) - Received Handicap Bonus (%d in Yields): GOLD.", iYieldHandicap);
					break;
				}
				case HISTORIC_EVENT_CITY_FOUND_CAPITAL:
				{
					GetTreasury()->ChangeGold(iYieldHandicap);
					ChangeGoldenAgeProgressMeter(iYieldHandicap);
					strLogString.Format("CBP AI DIFFICULTY BONUS FROM HISTORIC EVENT: FOUND CAPITAL - Received Handicap Bonus (%d in Yields): GOLD, GAP.", iYieldHandicap);
					break;
				}
				case HISTORIC_EVENT_CITY_FOUND:
				{
					for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if (pLoopCity != NULL)
						{
							pLoopCity->changeFood(iYieldForCities);
							pLoopCity->changeProduction(iYieldForCities);
						}
					}
					GetTreasury()->ChangeGold(iYieldHandicap);
					ChangeGoldenAgeProgressMeter(iYieldHandicap);
					changeJONSCulture(iYieldHandicap);

					TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
					if (eCurrentTech == NO_TECH)
					{
						changeOverflowResearch(iYieldHandicap);
					}
					else
					{
						GET_TEAM(getTeam()).GetTeamTechs()->ChangeResearchProgress(eCurrentTech, iYieldHandicap, GetID());
					}
					strLogString.Format("CBP AI DIFFICULTY BONUS FROM HISTORIC EVENT: FOUND CITY - Received Handicap Bonus (%d in Yields): FOOD, PRODUCTION, GOLD, GAP, CULTURE, SCIENCE.", iYieldHandicap);
					break;
				}
			}
		}
	}

	if (GC.getLogging() && GC.getAILogging())
	{
		CvString strTemp;

		CvString strFileName = "DifficultyHandicapLog.csv";
		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

		CvString strPlayerName;
		strPlayerName = getCivilizationShortDescription();
		strTemp += strPlayerName;
		strTemp += ", ";

		CvString strTurn;

		strTurn.Format("%d, ", GC.getGame().getGameTurn()); // turn
		strTemp += strTurn;

		strTemp += strLogString;

		pLog->Msg(strTemp);
	}
}
void CvPlayer::DoHealGlobal(int iHealPercent)
{
	int iLoop;
	CvUnit* pLoopUnit = NULL;
	for (pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if (!pLoopUnit)
			continue;
		if (pLoopUnit->IsCombatUnit())
		{
			if (iHealPercent == 100)
				pLoopUnit->changeDamage(-pLoopUnit->getDamage());
			else
			{
				int iHealHP = pLoopUnit->GetMaxHitPoints() * iHealPercent / 100;
				pLoopUnit->changeDamage(-iHealHP);
			}
			
		}
	}
}
#endif

//	--------------------------------------------------------------------------------
/// Yield per turn from Religion
int CvPlayer::GetYieldPerTurnFromReligion(YieldTypes) const
{
	return 0;
}

//	--------------------------------------------------------------------------------
/// Trait bonus which adds Faith for trade partners? 
int CvPlayer::GetYieldPerTurnFromTraits(YieldTypes eYield) const
{
	if (!MOD_BALANCE_YIELD_SCALE_ERA)
		return GetPlayerTraits()->GetYieldChangePerTradePartner(eYield) * GetTrade()->GetNumDifferentTradingPartners();

	return 0;
}

//	--------------------------------------------------------------------------------
/// Total faith per turn
int CvPlayer::GetTotalFaithPerTurn() const
{
	//No barbs or minors, please!
	if (isBarbarian() || isMinorCiv())
		return 0;

	// If we're in anarchy, then no Faith is generated!
	if (IsAnarchy())
		return 0;

	// Faith per turn from Cities
	int iFaithPerTurn = GetFaithPerTurnFromCities();

	// Trait bonus which adds Faith for trade partners? 
	iFaithPerTurn += GetYieldPerTurnFromTraits(YIELD_FAITH);

	// Faith per turn from Minor Civs
	iFaithPerTurn += GetFaithPerTurnFromMinorCivs();

	// Faith per turn from Religion (Founder beliefs)
	iFaithPerTurn += GetFaithPerTurnFromReligion();

	iFaithPerTurn += GetYieldPerTurnFromVassals(YIELD_FAITH);

	if (MOD_BALANCE_CORE_JFD)
		iFaithPerTurn += GetYieldPerTurnFromMinors(YIELD_FAITH);

	return iFaithPerTurn;
}

//	--------------------------------------------------------------------------------
/// Faith per turn from Cities
int CvPlayer::GetFaithPerTurnFromCities() const
{
	int iFaithPerTurn = 0;

	// Add in culture from Cities
	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iFaithPerTurn += pLoopCity->GetFaithPerTurn();
	}

	return iFaithPerTurn;
}

//	--------------------------------------------------------------------------------
/// Faith per turn from Minor Civs
int CvPlayer::GetFaithPerTurnFromMinorCivs() const
{
	int iFaithPerTurn = 0;
	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		iFaithPerTurn += GetFaithPerTurnFromMinor((PlayerTypes)iMinorLoop);
	}
	return iFaithPerTurn;
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Gold per turn from Minor Civs
int CvPlayer::GetGoldPerTurnFromMinorCivs() const
{
	int iFaithPerTurn = 0;
	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		iFaithPerTurn += GetGoldPerTurnFromMinor((PlayerTypes)iMinorLoop);
	}
	return iFaithPerTurn;
}
//	--------------------------------------------------------------------------------
/// Science per turn from Minor Civs
int CvPlayer::GetSciencePerTurnFromMinorCivs() const
{
	int iSciencePerTurn = 0;
	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		iSciencePerTurn += GetSciencePerTurnFromMinor((PlayerTypes)iMinorLoop);
	}
	return iSciencePerTurn;
}
//	--------------------------------------------------------------------------------
/// Gold per turn from a Minor Civ
int CvPlayer::GetGoldPerTurnFromMinor(PlayerTypes eMinor) const
{
	int iGoldPerTurn = 0;

	if(GET_PLAYER(eMinor).isAlive())
	{
		iGoldPerTurn += GET_PLAYER(eMinor).GetMinorCivAI()->GetCurrentGoldBonus(GetID());
	}

	return iGoldPerTurn;
}
//	--------------------------------------------------------------------------------
/// Science per turn from a Minor Civ
int CvPlayer::GetSciencePerTurnFromMinor(PlayerTypes eMinor) const
{
	int iSciencePerTurn = 0;

	if(GET_PLAYER(eMinor).isAlive())
	{
		iSciencePerTurn += GET_PLAYER(eMinor).GetMinorCivAI()->GetCurrentScienceBonus(GetID());
	}

	return iSciencePerTurn;
}

int CvPlayer::GetYieldPerTurnFromMinors(YieldTypes eYield) const
{
	return m_aiYieldFromMinors[eYield];
}
void CvPlayer::SetYieldPerTurnFromMinors(YieldTypes eYield, int iValue)
{
	if (iValue != m_aiYieldFromMinors[eYield])
	{
		m_aiYieldFromMinors[eYield] = iValue;
	}
}
#endif
//	--------------------------------------------------------------------------------
/// Faith per turn from a Minor Civ
int CvPlayer::GetFaithPerTurnFromMinor(PlayerTypes eMinor) const
{
	int iFaithPerTurn = 0;

	if(GET_PLAYER(eMinor).isAlive())
	{
		iFaithPerTurn += GET_PLAYER(eMinor).GetMinorCivAI()->GetCurrentFaithBonus(GetID());
	}

	return iFaithPerTurn;
}

//	--------------------------------------------------------------------------------
/// Faith per turn from Religion
int CvPlayer::GetFaithPerTurnFromReligion() const
{
	return GetYieldPerTurnFromReligion(YIELD_FAITH);
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetFaith() const
{
	return m_iFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetFaith(int iNewValue)
{
	if(GC.getGame().isOption(GAMEOPTION_NO_RELIGION))
	{
		return;
	}

	if(GetFaith() != iNewValue)
	{
		// Add to the total we've ever had
		if(iNewValue > m_iFaith)
		{
			ChangeFaithEverGenerated(iNewValue - m_iFaith);
		}

		m_iFaith = max(0,iNewValue);

		if(GC.getGame().getActivePlayer() == GetID())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeFaith(int iChange)
{
	if(GC.getGame().isOption(GAMEOPTION_NO_RELIGION))
	{
		return;
	}

	SetFaith(GetFaith() + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetFaithEverGenerated() const
{
	return m_iFaithEverGenerated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetFaithEverGenerated(int iNewValue)
{
	if(m_iFaithEverGenerated != iNewValue)
		m_iFaithEverGenerated = iNewValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeFaithEverGenerated(int iChange)
{
	SetFaithEverGenerated(GetFaithEverGenerated() + iChange);
}

//	--------------------------------------------------------------------------------
/// Updates how much Happiness we have
void CvPlayer::DoUpdateTotalHappiness()
{
	// Start level
	m_iHappiness = getHandicapInfo().getHappinessDefault() + GC.getGame().getGameSpeedInfo().GetStartingHappiness();

	if (MOD_BALANCE_VP)
	{
		m_iHappiness += GetBonusHappinessFromLuxuriesFlat();
	}
	else
	{
		// Increase from Luxury Resources
		m_iHappiness += GetHappinessFromResources();

		// Happiness bonus for multiple Resource types
		m_iHappiness += GetHappinessFromResourceVariety();

		// Increase from Local City Happiness
		m_iHappiness += GetHappinessFromCities();
	}

	/* MOVED TO CVCITY (?)
	// Increase from buildings
	m_iHappiness += GetHappinessFromBuildings();

	// Increase from policies
	m_iHappiness += GetHappinessFromPolicies();

	// Increase from num cities (player based, for buildings and such)
	m_iHappiness += getNumCities() * m_iHappinessPerCity;
	*/

	// Increase from Religion
	m_iHappiness += GetHappinessFromReligion();

	// Increase from Natural Wonders
	m_iHappiness += GetHappinessFromNaturalWonders();

	// Friendship with Minors can provide Happiness
	m_iHappiness += GetHappinessFromMinorCivs();

	// Increase from Leagues
	m_iHappiness += GetHappinessFromLeagues();

	// Increase from Vassals
	m_iHappiness += GetHappinessFromVassals();

	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		m_iHappiness += pLoopCity->GetEventHappiness();
	}

	// Increase for each City Connection to the Capital
	DoUpdateCityConnectionHappiness();
	m_iHappiness += GetHappinessFromTradeRoutes();

	if (MOD_API_ACHIEVEMENTS && isLocalPlayer() && GetExcessHappiness() >= 100)
		gDLL->UnlockAchievement(ACHIEVEMENT_XP2_45);

	if (MOD_BALANCE_VP)
		DistributeHappinessToCities();

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
}

void CvPlayer::DistributeHappinessToCities()
{
	if (getNumCities() <= 0)
		return;

	int iHappiness = m_iHappiness;

	// If we only have one city, all happiness goes there
	if (getNumCities() == 1)
	{
		CvCity* pCapital = getCapitalCity();
		if (pCapital) // This can be NULL when happiness is updated mid-capital founding
		{
			pCapital->ResetHappinessFromEmpire();
			pCapital->ChangeHappinessFromEmpire(iHappiness);
		}
		return;
	}

	int iLoop;
	CvWeightedVector<CvCity*> CitiesSortedByNeed;
	CvWeightedVector<CvCity*> CitiesSortedByPopulation;

	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		// Ignore puppets, unless Venice
		if (CityStrategyAIHelpers::IsTestCityStrategy_IsPuppetAndAnnexable(pLoopCity))
			continue;

		// Reset current happiness from empire
		pLoopCity->ResetHappinessFromEmpire();

		// Do not distribute happiness to occupied, razing or resistance cities
		if (pLoopCity->IsRazing() || pLoopCity->IsResistance() || (pLoopCity->IsOccupied() && !pLoopCity->IsNoOccupiedUnhappiness()))
			continue;

		// "Need" = Population - Local Happiness
		int iPopulation = pLoopCity->getPopulation();
		int iLocalHappiness = pLoopCity->GetLocalHappiness(0, /*bExcludeEmpireContributions*/ true);
		int iScore = iPopulation - iLocalHappiness;
		if (iScore > 0)
			CitiesSortedByNeed.push_back(pLoopCity, iScore);
		
		CitiesSortedByPopulation.push_back(pLoopCity, iPopulation);
	}

	CitiesSortedByNeed.SortItems();
	CitiesSortedByPopulation.SortItems();

	// Distribute happiness to cities in descending order of Need until all cities are full
	bool bAllCitiesFull = false;

	while (iHappiness > 0 && !bAllCitiesFull && CitiesSortedByNeed.size() > 0)
	{
		for (int i = 0; i < CitiesSortedByNeed.size(); i++)
		{
			CvCity* pLoopCity = CitiesSortedByNeed.GetElement(i);
			int iNeedScore = CitiesSortedByNeed.GetWeight(i);

			// This city has Need - give it 1 Happiness from the empire
			if (iNeedScore > 0)
			{
				pLoopCity->ChangeHappinessFromEmpire(1);
				iHappiness--;
				CitiesSortedByNeed.SetWeight(i, iNeedScore - 1);
			}

			// No more Happiness left - we're done!
			if (iHappiness == 0)
				return;
		}

		// Check if all cities are full, to prevent endless recursion
		bAllCitiesFull = true;
		for (int i = 0; i < CitiesSortedByNeed.size(); i++)
		{
			if (CitiesSortedByNeed.GetWeight(i) > 0)
				bAllCitiesFull = false;
		}
	}

	// If there's any happiness left over, distribute it in descending order of population until there's none left
	while (iHappiness > 0 && CitiesSortedByPopulation.size() > 0)
	{
		for (int i = 0; i < CitiesSortedByPopulation.size(); i++)
		{
			CvCity* pLoopCity = CitiesSortedByPopulation.GetElement(i);
			pLoopCity->ChangeHappinessFromEmpire(1);
			iHappiness--;

			// No more Happiness left - we're done!
			if (iHappiness == 0)
				return;
		}
	}
}

//sum up the local happiness sources in each city
int CvPlayer::GetEmpireHappinessFromCities() const
{
	int iTotal = 0;
	int iLoop;
	for (const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		iTotal += pLoopCity->GetLocalHappiness(0,true); 

	return iTotal;
}

//	--------------------------------------------------------------------------------
/// How much Happiness we have
int CvPlayer::GetHappiness() const
{
	return m_iHappiness;
}

//	--------------------------------------------------------------------------------
/// Sets how much Happiness we have
void CvPlayer::SetHappiness(int iNewValue)
{
	if(GetHappiness() != iNewValue)
	{
		m_iHappiness = iNewValue;
	}
}

/// Sets how much Unhappiness we have
void CvPlayer::SetUnhappiness(int iNewValue)
{
	if(m_iUnhappiness != iNewValue)
	{
		m_iUnhappiness = iNewValue;

		int iLoop;
		for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if (CityStrategyAIHelpers::IsTestCityStrategy_IsPuppetAndAnnexable(pLoopCity))
				continue;

			pLoopCity->UpdateUnhappinessFromEmpire();
		}
	}
}
int CvPlayer::GetUnhappiness() const
{
	return m_iUnhappiness;
}

int CvPlayer::GetHappinessRatioRawPercent()
{
	int iUnhappyCitizens = GetUnhappinessFromCitizenNeeds();
	int iHappyCitizens = GetHappinessFromCitizenNeeds();
	return ((iHappyCitizens * 100) / max(1, iUnhappyCitizens) / 2);
}

void CvPlayer::CalculateNetHappiness()
{
	if (isMinorCiv() || isBarbarian())
		return;

	//reset this as well, when a building is constructed or a policy adopted
	m_iNumUnitsSuppliedCached = -1;

	DoUpdateTotalHappiness();
	DoUpdateTotalUnhappiness();

	if (MOD_BALANCE_CORE_HAPPINESS)
	{
		int iUnhappyCitizens = GetUnhappinessFromCitizenNeeds();
		if (iUnhappyCitizens == 0)
			m_iHappinessTotal = 100;
		else
		{
			int iHappyCitizens = GetHappinessFromCitizenNeeds();
			int iPercent = min(200, (iHappyCitizens * 100) / max(1, iUnhappyCitizens));
			iPercent /= 2;

			if (iPercent != m_iHappinessTotal)
			{
				m_iHappinessTotal = iPercent;
				GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
			}
		}
	}
	else
	{
		int iHappiness = GetHappiness();
		int iUnhappiness = GetUnhappiness();

		int iDiff = iHappiness - iUnhappiness;
		if (iDiff != m_iHappinessTotal)
		{
			m_iHappinessTotal = iDiff;
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

void CvPlayer::ChangeEmpireNeedsModifierGlobal(int iChange)
{
	m_iEmpireNeedsModifierGlobal += iChange;
}
int CvPlayer::GetEmpireNeedsModifierGlobal() const
{
	return m_iEmpireNeedsModifierGlobal;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvPlayer::GetPovertyUnhappinessGlobal() const
{
	return m_iChangePovertyUnhappinessGlobal;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangePovertyUnhappinessGlobal(int iChange)
{
	m_iChangePovertyUnhappinessGlobal += iChange;
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvPlayer::GetDefenseUnhappinessGlobal() const
{
	return m_iChangeDefenseUnhappinessGlobal;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangeDefenseUnhappinessGlobal(int iChange)
{
	m_iChangeDefenseUnhappinessGlobal += iChange;
}
/// Extra yield from building
int CvPlayer::GetUnculturedUnhappinessGlobal() const
{
	return m_iChangeUnculturedUnhappinessGlobal;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangeUnculturedUnhappinessGlobal(int iChange)
{
	m_iChangeUnculturedUnhappinessGlobal += iChange;
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvPlayer::GetIlliteracyUnhappinessGlobal() const
{
	return m_iChangeIlliteracyUnhappinessGlobal;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangeIlliteracyUnhappinessGlobal(int iChange)
{
	m_iChangeIlliteracyUnhappinessGlobal += iChange;
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvPlayer::GetMinorityUnhappinessGlobal() const
{
	return m_iChangeMinorityUnhappinessGlobal;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangeMinorityUnhappinessGlobal(int iChange)
{
	m_iChangeMinorityUnhappinessGlobal += iChange;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvPlayer::GetLandmarksTourismPercentGlobal() const
{
	return m_iLandmarksTourismPercentGlobal;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangeLandmarksTourismPercentGlobal(int iChange)
{
	m_iLandmarksTourismPercentGlobal += iChange;
}


//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvPlayer::GetGreatWorksTourismModifierGlobal() const
{
	return m_iGreatWorksTourismModifierGlobal;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangeGreatWorksTourismModifierGlobal(int iChange)
{
	m_iGreatWorksTourismModifierGlobal += iChange;
}

//	--------------------------------------------------------------------------------
/// Are we in bad shape to start a war?
void CvPlayer::DoTestEmpireInBadShapeForWar()
{
	// Losing all our wars?
	if (GetDiplomacyAI()->GetStateAllWars() == STATE_ALL_WARS_LOSING)
	{
		SetInTerribleShapeForWar(true);
		SetNoNewWars(true);
		return;
	}

	// Bankrupt?
	if (GetTreasury()->GetGold() <= 0 && getAvgGoldRate() <= 0)
	{
		SetInTerribleShapeForWar(true);
		SetNoNewWars(true);
		return;
	}

	// Lost our capital?
	if (IsHasLostCapital())
	{
		SetInTerribleShapeForWar(true);
		SetNoNewWars(true);
		return;
	}

	// Very unhappy?
	if (IsEmpireVeryUnhappy())
	{
		SetInTerribleShapeForWar(true);
		SetNoNewWars(true);
		return;
	}

	bool bSetNoNewWars = false;
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).isMajorCiv() && IsAtWarWith(eLoopPlayer))
		{
			WarStateTypes eWarState = GetDiplomacyAI()->GetWarState(eLoopPlayer);

			if (eWarState <= WAR_STATE_TROUBLED)
			{
				if (GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(eLoopPlayer) >= STRENGTH_POWERFUL && GET_PLAYER(eLoopPlayer).GetProximityToPlayer(m_eID) >= PLAYER_PROXIMITY_CLOSE)
				{
					SetInTerribleShapeForWar(true);
					SetNoNewWars(true);
					return;
				}

				bSetNoNewWars = true;
			}
			else
			{
				if (GetDiplomacyAI()->IsPhonyWar(eLoopPlayer))
					continue;

				if (eWarState == WAR_STATE_STALEMATE)
				{
					if (!GetDiplomacyAI()->IsEasyTarget(eLoopPlayer) && GetProximityToPlayer(eLoopPlayer) >= PLAYER_PROXIMITY_CLOSE)
					{
						bSetNoNewWars = true;
					}
				}
			}
		}
	}

	SetInTerribleShapeForWar(false);
	SetNoNewWars(bSetNoNewWars);
}

bool CvPlayer::IsNoNewWars() const
{
	return m_bNoNewWars;
}

void CvPlayer::SetNoNewWars(bool bValue)
{
	m_bNoNewWars = bValue;
}

bool CvPlayer::IsInTerribleShapeForWar() const
{
	return m_bTerribleShapeForWar;
}

void CvPlayer::SetInTerribleShapeForWar(bool bValue)
{
	m_bTerribleShapeForWar = bValue;
}

// Prevent infinite warmongering exploit
int CvPlayer::GetTurnsSinceLastAttackedMinorCiv() const
{
	int iTurn = m_iTurnLastAttackedMinorCiv;
	if (iTurn < 0)
		return -1;

	return GC.getGame().getGameTurn() - m_iTurnLastAttackedMinorCiv;
}

void CvPlayer::SetTurnLastAttackedMinorCiv(int iTurn)
{
	if (GetTurnsSinceLastAttackedMinorCiv() > -1 && GetTurnsSinceLastAttackedMinorCiv() < 10)
		return;

	m_iTurnLastAttackedMinorCiv = max(iTurn, -1);
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetHappinessForGAP() const
{
	if (MOD_BALANCE_CORE_HAPPINESS)
	{
		int iTotalGAP = 0;
		int iLoop;
		for (const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			int iGAP = pLoopCity->getHappinessDelta();
			if (iGAP > 0)
				iTotalGAP += iGAP;
		}

		return iTotalGAP;
	}
	return GetExcessHappiness();
}
/// How much over our Happiness limit are we?
int CvPlayer::GetExcessHappiness() const
{
	if(isMinorCiv() || isBarbarian() || (getNumCities() == 0) || GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS))
	{
		if (MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
			return /*50*/ GD_INT_GET(UNHAPPY_THRESHOLD);
		else
			return 0;
	}

	return m_iHappinessTotal;
}

//	--------------------------------------------------------------------------------
/// Has the player passed the Happiness limit?
bool CvPlayer::IsEmpireUnhappy() const
{
	if (MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	{
		return GetExcessHappiness() < /*50*/ GD_INT_GET(UNHAPPY_THRESHOLD);
	}

	return GetExcessHappiness() < 0;
}

//	--------------------------------------------------------------------------------
/// Is the empire REALLY unhappy? (other penalties)
bool CvPlayer::IsEmpireVeryUnhappy() const
{
	if (MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	{
		return GetExcessHappiness() < /*35*/ GD_INT_GET(VERY_UNHAPPY_THRESHOLD);
	}

	return GetExcessHappiness() <= /*-10*/ GD_INT_GET(VERY_UNHAPPY_THRESHOLD);
}

//	--------------------------------------------------------------------------------
/// Is the empire SUPER unhappy? (leads to revolts)
bool CvPlayer::IsEmpireSuperUnhappy() const
{
	if (MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	{
		return GetExcessHappiness() < /*20*/ GD_INT_GET(SUPER_UNHAPPY_THRESHOLD);
	}

	return GetExcessHappiness() <= /*-20*/ GD_INT_GET(SUPER_UNHAPPY_THRESHOLD);
}

//	--------------------------------------------------------------------------------
/// Uprisings pop up if the empire is Very Unhappy
void CvPlayer::DoUpdateUprisings()
{
	if ((MOD_BALANCE_CORE_HAPPINESS && IsEmpireVeryUnhappy()) || IsEmpireSuperUnhappy())
	{
		if (MOD_BALANCE_CORE_HAPPINESS && GC.getGame().isOption(GAMEOPTION_NO_BARBARIANS))
			return;

		// If we're very unhappy, make the counter wind down
		if (GetUprisingCounter() > 0)
		{
			ChangeUprisingCounter(-1);

			// Time's up!
			if (GetUprisingCounter() == 0)
			{
				DoUprising();
				DoResetUprisingCounter(/*bFirstTime*/ false);
			}
		}
		// Very Unhappy for the first time - seed the counter
		else
		{
			DoResetUprisingCounter(/*bFirstTime*/ true);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Uprising countdown - get
int CvPlayer::GetUprisingCounter() const
{
	return m_iUprisingCounter;
}

//	--------------------------------------------------------------------------------
/// Uprising countdown - set
void CvPlayer::SetUprisingCounter(int iValue)
{
	m_iUprisingCounter = iValue;
}

//	--------------------------------------------------------------------------------
/// Uprising countdown - change
void CvPlayer::ChangeUprisingCounter(int iChange)
{
	SetUprisingCounter(GetUprisingCounter() + iChange);
}

//	--------------------------------------------------------------------------------
/// Uprising countdown - seed
void CvPlayer::DoResetUprisingCounter(bool bFirstTime)
{
	int iTurns = /*4*/ GD_INT_GET(UPRISING_COUNTER_MIN) + GC.getGame().getSmallFakeRandNum(/*3*/ GD_INT_GET(UPRISING_COUNTER_POSSIBLE), GetPseudoRandomSeed());

	// Game speed mod
	int iMod = GC.getGame().getGameSpeedInfo().getTrainPercent();
	// Only LENGTHEN time between rebels
	if(iMod > 100)
	{
		iTurns *= iMod;
		iTurns /= 100;
	}

	if(bFirstTime)
		iTurns /= 2;

	if (IsEmpireSuperUnhappy())
	{
		iTurns *= 75;
		iTurns /= 100;
	}
	if(iTurns <= 0)
		iTurns = 1;

	SetUprisingCounter(iTurns);
}

//	--------------------------------------------------------------------------------
// Fire off an uprising somewhere
void CvPlayer::DoUprising()
{
	// In hundreds
	int iNumRebels = /*100*/ GD_INT_GET(UPRISING_NUM_BASE);
	int iExtra = getNumCities() + GC.getGame().getSmallFakeRandNum(getNumCities(), GetPseudoRandomSeed());
		
	iNumRebels += iExtra * /*20*/ GD_INT_GET(UPRISING_NUM_CITY_COUNT);
	iNumRebels /= 100;

	// Find a random city to pop up a bad man
	CvCity* pBestCity = NULL;
	int iBestWeight = 0;

	int iLoop;
	CvGame& theGame = GC.getGame();
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		int iTempWeight = pLoopCity->getPopulation();
		iTempWeight += theGame.getSmallFakeRandNum(10, GetPseudoRandomSeed() + pLoopCity->plot()->GetPlotIndex());

		if(iTempWeight > iBestWeight)
		{
			iBestWeight = iTempWeight;
			pBestCity = pLoopCity;
		}
	}

	// Found a place to set up an uprising?
	if(pBestCity != NULL)
	{
		int iBestPlot = -1;
		int iBestPlotWeight = -1;
		CvPlot* pPlot;

		CvCityCitizens* pCitizens = pBestCity->GetCityCitizens();

		// Start at 1, since ID 0 is the city plot itself

		for(int iPlotLoop = 1; iPlotLoop < pBestCity->GetNumWorkablePlots(); iPlotLoop++)
		{
			pPlot = pCitizens->GetCityPlotFromIndex(iPlotLoop);

			if(!pPlot)		// Should be valid, but make sure
				continue;

			// Can't be impassable
			if(!pPlot->isValidMovePlot(GetID()))
				continue;

			// Can't be water
			if(pPlot->isWater())
				continue;

			// Can't be ANOTHER city
			if(pPlot->isCity())
				continue;

			// Don't place on a plot where a unit is already standing
			if(pPlot->getNumUnits() > 0)
				continue;

			int iTempWeight = theGame.getSmallFakeRandNum(10, GetPseudoRandomSeed() + iPlotLoop);

			// Add weight if there's an improvement here!
			if(pPlot->getImprovementType() != NO_IMPROVEMENT)
			{
				iTempWeight += 4;

				// If there's also a resource, even more weight!
				if(pPlot->getResourceType(getTeam()) != NO_RESOURCE)
					iTempWeight += 3;
			}

			// Add weight if there's a defensive bonus for this plot
			if(pPlot->defenseModifier(BARBARIAN_TEAM, false, false))
				iTempWeight += 4;

			// Don't pick plots that aren't ours
			if(pPlot->getOwner() != GetID())
				iTempWeight = -1;

			if(iTempWeight > iBestPlotWeight)
			{
				iBestPlotWeight = iTempWeight;
				iBestPlot = iPlotLoop;
			}
		}

		// Found valid plot
		if(iBestPlot != -1)
		{
			// Make barbs able to enter ANYONE'S territory
			theGame.SetBarbarianReleaseTurn(0);

			pPlot = pCitizens->GetCityPlotFromIndex(iBestPlot);

			// Pick a unit type
			UnitTypes eUnit = theGame.GetRandomSpawnUnitType(GetID(), /*bIncludeUUs*/ true, /*bIncludeRanged*/ true);

			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_REBELS");
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_REBELS_SUMMARY");
				pNotifications->Add(NOTIFICATION_REBELS, strMessage.toUTF8(), strSummary.toUTF8(), pPlot->getX(), pPlot->getY(), eUnit, BARBARIAN_PLAYER);
			}

			// Init unit
			GET_PLAYER(BARBARIAN_PLAYER).initUnit(eUnit, pPlot->getX(), pPlot->getY());
			iNumRebels--;	// Reduce the count since we just added the seed rebel

			// Loop until all rebels are placed
			do
			{
				iNumRebels--;

				// Pick a new unit type (for variety)
				UnitTypes eUnit = theGame.GetRandomSpawnUnitType(GetID(), /*bIncludeUUs*/ true, /*bIncludeRanged*/ true);

				// Init unit
				CvUnit* pUnit = GET_PLAYER(BARBARIAN_PLAYER).initUnit(eUnit, pPlot->getX(), pPlot->getY());
				CvAssert(pUnit);
				if (pUnit)
				{
					if (!pUnit->jumpToNearestValidPlotWithinRange(5))
						pUnit->kill(false);		// Could not find a spot!
				}
			}
			while(iNumRebels > 0);
		}
	}
}

//	--------------------------------------------------------------------------------
/// City can revolt if the empire is Very Unhappy
void CvPlayer::DoUpdateCityRevolts()
{
	int iPublicUnhappiness = 0;
	if (GetCulture()->GetPublicOpinionUnhappiness() > 0 || IsEmpireSuperUnhappy() || (MOD_BALANCE_CORE_HAPPINESS && IsEmpireVeryUnhappy()))
	{
		iPublicUnhappiness = 1;
	}
	if (IsEmpireVeryUnhappy() && iPublicUnhappiness > 0)
	{
		if(GetCityRevoltCounter() > 0)
		{
			ChangeCityRevoltCounter(-iPublicUnhappiness);

			// Time's up!
			if(GetCityRevoltCounter() == 0)
			{
				DoCityRevolt();
				SetCityRevoltCounter(0);
			}
			else
			{
				CvCity *pMostUnhappyCity = GetMostUnhappyCity();
				PlayerTypes eRecipient = GetMostUnhappyCityRecipient(pMostUnhappyCity);
				if (pMostUnhappyCity != NULL && eRecipient != NO_PLAYER)
				{
					if (GET_PLAYER(eRecipient).isAlive())
					{
						CvNotifications* pNotifications = GetNotifications();
						if (pNotifications && isHuman())
						{
							Localization::String strMessage(GetLocalizedText("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLT", GetCityRevoltCounter(), pMostUnhappyCity->getName(), GET_PLAYER(eRecipient).getCivilizationShortDescription()));
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLT_SUMMARY");
							pNotifications->Add(NOTIFICATION_CITY_REVOLT_POSSIBLE, strMessage.toUTF8(), strSummary.toUTF8(), pMostUnhappyCity->getX(), pMostUnhappyCity->getY(), -1);
						}
					}
					else if (GET_PLAYER(eRecipient).isEverAlive())
					{
						CvNotifications* pNotifications = GetNotifications();
						if (pNotifications && isHuman())
						{
							Localization::String strMessage(GetLocalizedText("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLUTION_CP", GetCityRevoltCounter(), pMostUnhappyCity->getName(), GET_PLAYER(eRecipient).getCivilizationShortDescription()));
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLUTION_CP_SUMMARY");
							pNotifications->Add(NOTIFICATION_CITY_REVOLT_POSSIBLE, strMessage.toUTF8(), strSummary.toUTF8(), pMostUnhappyCity->getX(), pMostUnhappyCity->getY(), -1);
						}
					}
					else
					{
						CvNotifications* pNotifications = GetNotifications();
						if (pNotifications && isHuman())
						{
							Localization::String strMessage(GetLocalizedText("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLUTION_CP_FREE_CITY", GetCityRevoltCounter(), pMostUnhappyCity->getName()));
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLUTION_CP_SUMMARY");
							pNotifications->Add(NOTIFICATION_CITY_REVOLT_POSSIBLE, strMessage.toUTF8(), strSummary.toUTF8(), pMostUnhappyCity->getX(), pMostUnhappyCity->getY(), -1);
						}
					}
				}
			}
		}
		// Super Unhappy for the first time - seed the counter
		else
		{
			DoResetCityRevoltCounter();
		}
	}
	else
	{
		SetCityRevoltCounter(-1);
	}
}

//	--------------------------------------------------------------------------------
/// City revolt countdown - get
int CvPlayer::GetCityRevoltCounter() const
{
	return m_iCityRevoltCounter;
}

//	--------------------------------------------------------------------------------
/// City revolt countdown - set
void CvPlayer::SetCityRevoltCounter(int iValue)
{
	if (iValue != m_iCityRevoltCounter)
		m_iCityRevoltCounter = iValue;
}

//	--------------------------------------------------------------------------------
/// City revolt countdown - change
void CvPlayer::ChangeCityRevoltCounter(int iChange)
{
	SetCityRevoltCounter(GetCityRevoltCounter() + iChange);

	if ((GC.getLogging() && GC.getAILogging()))
	{
		int Counter = m_iCityRevoltCounter;
		CvString strLogString;
		strLogString.Format("CP - Countdown for City Revolt CONTINUES - %d turns.", Counter);

		CvString strTemp;

		CvString strFileName = "CityRevolutions.csv";
		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

		CvString strPlayerName;
		strPlayerName = getCivilizationShortDescription();
		strTemp += strPlayerName;
		strTemp += ", ";

		CvString strTurn;

		strTurn.Format("%d, ", GC.getGame().getGameTurn()); // turn
		strTemp += strTurn;

		strTemp += strLogString;

		pLog->Msg(strTemp);
	}
}

//	--------------------------------------------------------------------------------
/// City revolt countdown - seed
void CvPlayer::DoResetCityRevoltCounter()
{
	int iTurns = /*10*/ GD_INT_GET(REVOLT_COUNTER_MIN);
	CvGame& theGame = GC.getGame();

	// Game speed mod
	int iMod = theGame.getGameSpeedInfo().getTrainPercent();
	// Only LENGTHEN time between rebels
	if(iMod > 100)
	{
		iTurns *= iMod;
		iTurns /= 100;
	}

	if (MOD_BALANCE_CORE_HAPPINESS && IsEmpireSuperUnhappy())
	{
		iTurns *= 75;
		iTurns /= 100;
	}

	if(iTurns <= 0)
		iTurns = 1;

	CvCity *pMostUnhappyCity = GetMostUnhappyCity();
	PlayerTypes eRecipient = GetMostUnhappyCityRecipient(pMostUnhappyCity);
	if(pMostUnhappyCity != NULL && eRecipient != NO_PLAYER)
	{
		SetCityRevoltCounter(iTurns);

		if (GET_PLAYER(eRecipient).isAlive())
		{
			CvNotifications* pNotifications = GetNotifications();
			if (pNotifications && isHuman())
			{
				Localization::String strMessage(GetLocalizedText("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLT", iTurns, pMostUnhappyCity->getName(), GET_PLAYER(eRecipient).getCivilizationShortDescription()));
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLT_SUMMARY");
				pNotifications->Add(NOTIFICATION_CITY_REVOLT_POSSIBLE, strMessage.toUTF8(), strSummary.toUTF8(), pMostUnhappyCity->getX(), pMostUnhappyCity->getY(), -1);
			}

			if ((GC.getLogging() && GC.getAILogging()))
			{
				CvString strLogString;
				strLogString.Format("CP - Countdown for City Revolt BEGINS - %s, will go to %s in %d turns.", pMostUnhappyCity->getName().GetCString(), GET_PLAYER(eRecipient).getCivilizationShortDescription(), iTurns);

				CvString strTemp;

				CvString strFileName = "CityRevolutions.csv";
				FILogFile* pLog;
				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

				CvString strPlayerName;
				strPlayerName = getCivilizationShortDescription();
				strTemp += strPlayerName;
				strTemp += ", ";

				CvString strTurn;

				strTurn.Format("%d, ", GC.getGame().getGameTurn()); // turn
				strTemp += strTurn;

				strTemp += strLogString;

				pLog->Msg(strTemp);
			}
		}
		else if (GET_PLAYER(eRecipient).isEverAlive())
		{
			CvNotifications* pNotifications = GetNotifications();
			if (pNotifications && isHuman())
			{
				Localization::String strMessage(GetLocalizedText("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLUTION_CP", iTurns, pMostUnhappyCity->getName(), GET_PLAYER(eRecipient).getCivilizationShortDescription()));
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLUTION_CP_SUMMARY");
				pNotifications->Add(NOTIFICATION_CITY_REVOLT_POSSIBLE, strMessage.toUTF8(), strSummary.toUTF8(), pMostUnhappyCity->getX(), pMostUnhappyCity->getY(), -1);
			}

			if ((GC.getLogging() && GC.getAILogging()))
			{
				CvString strLogString;
				strLogString.Format("CP - Countdown for City Revolt BEGINS - %s, will go to DEAD PLAYER %s in %d turns.", pMostUnhappyCity->getName().GetCString(), GET_PLAYER(eRecipient).getName(), iTurns);

				CvString strTemp;

				CvString strFileName = "CityRevolutions.csv";
				FILogFile* pLog;
				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

				CvString strPlayerName;
				strPlayerName = getCivilizationShortDescription();
				strTemp += strPlayerName;
				strTemp += ", ";

				CvString strTurn;

				strTurn.Format("%d, ", GC.getGame().getGameTurn()); // turn
				strTemp += strTurn;

				strTemp += strLogString;

				pLog->Msg(strTemp);
			}
		}
		else
		{
			CvNotifications* pNotifications = GetNotifications();
			if (pNotifications && isHuman())
			{
				Localization::String strMessage(GetLocalizedText("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLUTION_CP_FREE_CITY", iTurns, pMostUnhappyCity->getName()));
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLUTION_CP_SUMMARY");
				pNotifications->Add(NOTIFICATION_CITY_REVOLT_POSSIBLE, strMessage.toUTF8(), strSummary.toUTF8(), pMostUnhappyCity->getX(), pMostUnhappyCity->getY(), -1);
			}

			if ((GC.getLogging() && GC.getAILogging()))
			{
				CvString strLogString;
				strLogString.Format("CP - Countdown for City Revolt BEGINS - %s, will go to FREE CITY PLAYER in %d turns.", pMostUnhappyCity->getName().GetCString(), iTurns);

				CvString strTemp;

				CvString strFileName = "CityRevolutions.csv";
				FILogFile* pLog;
				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

				CvString strPlayerName;
				strPlayerName = getCivilizationShortDescription();
				strTemp += strPlayerName;
				strTemp += ", ";

				CvString strTurn;

				strTurn.Format("%d, ", GC.getGame().getGameTurn()); // turn
				strTemp += strTurn;

				strTemp += strLogString;

				pLog->Msg(strTemp);
			}
		}
	}
}

//	--------------------------------------------------------------------------------
// Fire off a city revolt somewhere
void CvPlayer::DoCityRevolt()
{
	CvCity *pMostUnhappyCity = GetMostUnhappyCity();
	PlayerTypes eRecipient = GetMostUnhappyCityRecipient(pMostUnhappyCity);
	if(pMostUnhappyCity != NULL && eRecipient != NO_PLAYER)
	{
#if defined(MOD_BALANCE_CORE)
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityFlipped, pMostUnhappyCity, eRecipient, pMostUnhappyCity->getOwner());
#endif
		if (!GET_PLAYER(eRecipient).isAlive())
		{ 
			if (GET_PLAYER(eRecipient).isEverAlive())
			{
				PlayerTypes eOldPlayer = pMostUnhappyCity->getOriginalOwner();
				if (eOldPlayer != NO_PLAYER && !GET_PLAYER(eOldPlayer).isAlive())
				{
					DoRevolutionPlayer(eOldPlayer, pMostUnhappyCity->GetID());
				}
			}
			else
			{
				const CvString strCityName = pMostUnhappyCity->getName();
				const char* charCityName = pMostUnhappyCity->getName().GetCString();
				if (GC.getGame().CreateFreeCityPlayer(pMostUnhappyCity))
				{
					CvPlayer &kRecipient = GET_PLAYER(eRecipient);
					for (int iNotifyLoop = 0; iNotifyLoop < MAX_MAJOR_CIVS; ++iNotifyLoop){
						PlayerTypes eNotifyPlayer = (PlayerTypes)iNotifyLoop;

						if (eNotifyPlayer == NO_PLAYER)
							continue;

						CvPlayerAI& kCurNotifyPlayer = GET_PLAYER(eNotifyPlayer);

						if (!kCurNotifyPlayer.isAlive())
							continue;

						if (!GET_TEAM(kCurNotifyPlayer.getTeam()).isHasMet(getTeam()))
							continue;

						if (!GET_TEAM(kCurNotifyPlayer.getTeam()).isHasMet(kRecipient.getTeam()))
							continue;

						CvNotifications* pNotifications = kCurNotifyPlayer.GetNotifications();
						if (pNotifications)
						{
							Localization::String strMessage;
							if (eNotifyPlayer == GetID())
							{
								strMessage = GetLocalizedText("TXT_KEY_NOTIFICATION_CITY_REVOLT_FREE_CITY", strCityName, kRecipient.getCivilizationShortDescription());
							}
							else
							{
								strMessage = GetLocalizedText("TXT_KEY_NOTIFICATION_OTHER_PLAYER_CITY_REVOLT_FREE_CITY", getCivilizationAdjective(), strCityName, kRecipient.getCivilizationShortDescription());
							}
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_REVOLT_SUMMARY");
							pNotifications->Add(NOTIFICATION_CITY_REVOLT, strMessage.toUTF8(), strSummary.toUTF8(), GET_PLAYER(eRecipient).getCapitalCity()->getX(), GET_PLAYER(eRecipient).getCapitalCity()->getY(), -1);
						}
					}

					if (GC.getLogging() && GC.getAILogging() && pMostUnhappyCity != NULL)
					{
						CvString playerName;
						FILogFile* pLog;
						CvString strBaseString;
						CvString strOutBuf;
						CvString strFileName = "CityRevolutions.csv";
						playerName = getCivilizationShortDescription();
						pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
						strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
						strBaseString += playerName + ", ";
						strOutBuf.Format("Defection! %s ceded to new FREE CITY of %s", charCityName, kRecipient.getName());
						strBaseString += strOutBuf;
						pLog->Msg(strBaseString);
					}
				}
			}
		}
		else
		{
			CvPlayer &kRecipient = GET_PLAYER(eRecipient);
			for (int iNotifyLoop = 0; iNotifyLoop < MAX_MAJOR_CIVS; ++iNotifyLoop){
				PlayerTypes eNotifyPlayer = (PlayerTypes)iNotifyLoop;
				CvPlayerAI& kCurNotifyPlayer = GET_PLAYER(eNotifyPlayer);
				CvNotifications* pNotifications = kCurNotifyPlayer.GetNotifications();
				if (pNotifications)
				{
					if (!GET_TEAM(getTeam()).isHasMet(GET_PLAYER(eNotifyPlayer).getTeam()))
						continue;

					Localization::String strMessage;
					if (eNotifyPlayer == GetID())
					{
						strMessage = GetLocalizedText("TXT_KEY_NOTIFICATION_CITY_REVOLT", pMostUnhappyCity->getName(), kRecipient.getCivilizationShortDescription());
					}
					else if (GET_TEAM(getTeam()).isHasMet(GET_PLAYER(eNotifyPlayer).getTeam()))
					{
						strMessage = GetLocalizedText("TXT_KEY_NOTIFICATION_OTHER_PLAYER_CITY_REVOLT", getCivilizationAdjective(), pMostUnhappyCity->getName(), kRecipient.getCivilizationShortDescription());
					}
					else
					{
						strMessage = GetLocalizedText("TXT_KEY_NOTIFICATION_OTHER_PLAYER_CITY_REVOLT_UNKNOWN", kRecipient.getCivilizationShortDescription());
					}
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_REVOLT_SUMMARY");
					pNotifications->Add(NOTIFICATION_CITY_REVOLT, strMessage.toUTF8(), strSummary.toUTF8(), pMostUnhappyCity->getX(), pMostUnhappyCity->getY(), -1);
				}
			}

			if (GC.getLogging() && GC.getAILogging() && pMostUnhappyCity != NULL)
			{
				CvString playerName;
				FILogFile* pLog;
				CvString strBaseString;
				CvString strOutBuf;
				CvString strFileName = "CityRevolutions.csv";
				playerName = getCivilizationShortDescription();
				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				strBaseString += playerName + ", ";
				strOutBuf.Format("Defection! %s ceded to %s", pMostUnhappyCity->getName().GetCString(), kRecipient.getName());
				strBaseString += strOutBuf;
				pLog->Msg(strBaseString);
			}

			// get the plot before transferring ownership
			CvPlot *pPlot = pMostUnhappyCity->plot();
			kRecipient.acquireCity(pMostUnhappyCity, false, false);
			pMostUnhappyCity = NULL; //no longer valid

			 // Move Units from player that don't belong here
			if (pPlot->getNumUnits() > 0)
			{
				// Get the current list of units because we will possibly be moving them out of the plot's list
				IDInfoVector currentUnits;
				if (pPlot->getUnits(&currentUnits) > 0)
				{
					for (IDInfoVector::const_iterator itr = currentUnits.begin(); itr != currentUnits.end(); ++itr)
					{
						CvUnit* pLoopUnit = (CvUnit*)GetPlayerUnit(*itr);

						if (pLoopUnit && pLoopUnit->getOwner() == GetID())
						{
							pLoopUnit->finishMoves();
							if (!pLoopUnit->jumpToNearestValidPlot())
								pLoopUnit->kill(false);
						}
					}
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
// Calculate city that will want to revolt
CvCity *CvPlayer::GetMostUnhappyCity()
{
	CvCity *pRtnValue = NULL;
	int iHighestUnhappiness = -1;

	if (getNumCities() > 1)
	{
		PolicyBranchTypes ePreferredIdeology = GetCulture()->GetPublicOpinionPreferredIdeology();

		int iLoop;
		for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if (pLoopCity->isCapital())
				continue;

			if (pLoopCity->IsOriginalMajorCapital())
				continue;

			// mind the sign change
			int iUnhappiness = -1 * pLoopCity->getHappinessDelta();
			if (iUnhappiness <= 0)
				continue;

			// Look at each civ
			for (int iLoopPlayer = 0; iLoopPlayer < MAX_CIV_PLAYERS; iLoopPlayer++)
			{
				CvPlayer &kPlayer = GET_PLAYER((PlayerTypes)iLoopPlayer);
				if (iLoopPlayer != GetID())
				{		
					PolicyBranchTypes eOtherCivIdeology = NO_POLICY_BRANCH_TYPE;
					int iCulturalDominanceOverUs = 0;
					if (kPlayer.isAlive() && !kPlayer.isMinorCiv())
					{
						if (eOtherCivIdeology != NO_POLICY_BRANCH_TYPE && eOtherCivIdeology == ePreferredIdeology)
						{
							iUnhappiness *= 20;
						}
						iCulturalDominanceOverUs = kPlayer.GetCulture()->GetInfluenceLevel(GetID()) - GetCulture()->GetInfluenceLevel((PlayerTypes)iLoopPlayer);
					}
					else
					{
						if (!kPlayer.isAlive() && kPlayer.isMinorCiv())
						{
							iCulturalDominanceOverUs = 5;
						}
						else if (!kPlayer.isAlive())
						{
							iCulturalDominanceOverUs = 5;
						}
					}
					// Find how far their capital is from this city
					int iX = kPlayer.GetOriginalCapitalX();
					int iY = kPlayer.GetOriginalCapitalY();
					int iCapitalDistance = plotDistance(pLoopCity->getX(), pLoopCity->getY(), iX, iY);

					int iDistanceFactor = 100 - iCapitalDistance;
					if (iDistanceFactor <= 0)
						iDistanceFactor = 1;

					iDistanceFactor = (int)sqrt((float)iDistanceFactor);
					iUnhappiness += (iDistanceFactor * iCulturalDominanceOverUs);
				}
			}

			if (pLoopCity->getOriginalOwner() == GetID())
				iUnhappiness /= 4;

			if (pLoopCity->IsPuppet())
				iUnhappiness *= 2;

			int iCapitalDistance = plotDistance(pLoopCity->getX(), pLoopCity->getY(), getCapitalCity()->getX(), getCapitalCity()->getY());

			int iDistanceFactor = 100 - iCapitalDistance;
			if (iDistanceFactor <= 0)
				iDistanceFactor = 1;

			iUnhappiness += iDistanceFactor / 10;

			int iModifier = 0;
			if (GAMEEVENTINVOKE_VALUE(iModifier, GAMEEVENT_CityFlipChance, pLoopCity->GetID(), GetID()) == GAMEEVENTRETURN_VALUE) {
				if (iModifier != 0) {
					iUnhappiness += iModifier;
				}
			}

			if (iUnhappiness > iHighestUnhappiness)
			{
				iHighestUnhappiness = iUnhappiness;
				pRtnValue = pLoopCity;
			}
		}
	}

	return pRtnValue;
}

// Calculate player that will receive city if it revolts
PlayerTypes CvPlayer::GetMostUnhappyCityRecipient(CvCity* pMostUnhappyCity)
{
	PlayerTypes eRtnValue = NO_PLAYER;
	int iBestValue = 0;

	if (pMostUnhappyCity != NULL)
	{
		if (!GET_PLAYER(pMostUnhappyCity->getOriginalOwner()).isAlive())
			return pMostUnhappyCity->getOriginalOwner();

		if (pMostUnhappyCity->getOriginalOwner() != pMostUnhappyCity->getOwner())
			return pMostUnhappyCity->getOriginalOwner();

		PolicyBranchTypes ePreferredIdeology = GetCulture()->GetPublicOpinionPreferredIdeology();

		//doesn't happen if we're influenced by someone
		if (ePreferredIdeology == NO_POLICY_BRANCH_TYPE || ePreferredIdeology == GetPlayerPolicies()->GetLateGamePolicyTree())
		{
			if (GC.getGame().CreateFreeCityPlayer(pMostUnhappyCity, true))
			{
				PlayerTypes ePotentialFreeCityPlayer = GC.getGame().GetPotentialFreeCityPlayer(pMostUnhappyCity);
				if (ePotentialFreeCityPlayer != NO_PLAYER && GC.getGame().GetPotentialFreeCityTeam(pMostUnhappyCity) != NO_TEAM)
					return ePotentialFreeCityPlayer;
			}
		}

		// Look at each civ
		for (int iLoopPlayer = 0; iLoopPlayer < MAX_MAJOR_CIVS; iLoopPlayer++)
		{
			CvPlayer &kPlayer = GET_PLAYER((PlayerTypes)iLoopPlayer);
			if (iLoopPlayer != GetID())
			{
				if (kPlayer.isAlive() && !kPlayer.isMinorCiv() && kPlayer.getCapitalCity() != NULL)
				{
					if (kPlayer.IsEmpireSuperUnhappy())
						continue;

					PublicOpinionTypes eOpinionInMyCiv = GetCulture()->GetPublicOpinionType();
					int iCulturalDominanceOverUs = kPlayer.GetCulture()->GetInfluenceLevel(GetID()) - GetCulture()->GetInfluenceLevel((PlayerTypes)iLoopPlayer);
					if (eOpinionInMyCiv == PUBLIC_OPINION_REVOLUTIONARY_WAVE || (IsEmpireSuperUnhappy() && iCulturalDominanceOverUs > 1))
					{
						int iValue = 1000;
						if (iCulturalDominanceOverUs > 0)
						{
							iValue *= iCulturalDominanceOverUs+1;
						}
						// Find how far their capital is from this city
						int iCapitalDistance = plotDistance(pMostUnhappyCity->getX(), pMostUnhappyCity->getY(), kPlayer.getCapitalCity()->getX(), kPlayer.getCapitalCity()->getY());

						iValue -= iCapitalDistance * 2;

						PolicyBranchTypes eOtherCivIdeology = kPlayer.GetPlayerPolicies()->GetLateGamePolicyTree();
						if (eOtherCivIdeology != NO_POLICY_BRANCH_TYPE && eOtherCivIdeology == ePreferredIdeology)
							iValue *= 3;

						int iModifier = 0;
						if (GAMEEVENTINVOKE_VALUE(iModifier, GAMEEVENT_CityFlipRecipientChance, pMostUnhappyCity->GetID(), GetID(), (PlayerTypes)iLoopPlayer) == GAMEEVENTRETURN_VALUE) {
							if (iModifier != 0) {
								iValue += iModifier;
							}
						}

						if (iValue > iBestValue)
						{
							iBestValue = iValue;
							eRtnValue = (PlayerTypes)iLoopPlayer;
						}
					}
				}
			}
		}
	}

	return eRtnValue;
}

//	--------------------------------------------------------------------------------
/// Returns the amount of Happiness being added by Policies
int CvPlayer::GetHappinessFromPolicies() const
{
	return 0;
}

//	--------------------------------------------------------------------------------
/// Returns the amount of Local Happiness generated in the cities
int CvPlayer::GetHappinessFromCities() const
{
	int iHappiness = 0;
	int iLoop;

	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (pLoopCity->IsPuppet() && MOD_BALANCE_CORE_PUPPET_CHANGES)
			continue;

		iHappiness += pLoopCity->GetLocalHappiness();
	}

	return iHappiness;
}

//	--------------------------------------------------------------------------------
/// Returns the amount of extra Happiness per City
int CvPlayer::GetExtraHappinessPerCity() const
{
	return m_iHappinessPerCity;
}

//	--------------------------------------------------------------------------------
/// Returns the amount of extra Happiness per City
int CvPlayer::GetHappinessFromBuildings() const
{
	return 0;
}

//	--------------------------------------------------------------------------------
/// Changes amount of extra Happiness per City
void CvPlayer::ChangeExtraHappinessPerCity(int iChange)
{
	CvAssertMsg(m_iHappinessPerCity >= 0, "Count of buildings helping Happiness is corrupted");

	if(iChange != 0)
		m_iHappinessPerCity += iChange;
}

//	--------------------------------------------------------------------------------
/// Returns the amount of extra Happiness per City
int CvPlayer::GetExtraHappinessPerXPolicies() const
{
	return m_iHappinessPerXPolicies;
}

//	--------------------------------------------------------------------------------
/// Changes amount of extra Happiness per City
void CvPlayer::ChangeExtraHappinessPerXPolicies(int iChange)
{
	CvAssertMsg(m_iHappinessPerXPolicies >= 0, "Count of extra happiness per buildings is corrupted");

	if(iChange != 0)
		m_iHappinessPerXPolicies += iChange;
}

/// Returns the amount of extra Happiness per City
int CvPlayer::GetExtraHappinessPerXPoliciesFromPolicies() const
{
	return m_iExtraHappinessPerXPoliciesFromPolicies;
}

//	--------------------------------------------------------------------------------
/// Changes amount of extra Happiness per City
void CvPlayer::ChangeExtraHappinessPerXPoliciesFromPolicies(int iChange)
{
	CvAssertMsg(m_iExtraHappinessPerXPoliciesFromPolicies >= 0, "Count of extra happiness per buildings is corrupted");

	if (iChange != 0)
		m_iExtraHappinessPerXPoliciesFromPolicies += iChange;
}

/// Returns the amount of extra Happiness per City
int CvPlayer::GetHappinessPerXGreatWorks() const
{
	return m_iHappinessPerXGreatWorks;
}

//	--------------------------------------------------------------------------------
/// Changes amount of extra Happiness per City
void CvPlayer::ChangeHappinessPerXGreatWorks(int iChange)
{
	CvAssertMsg(m_iHappinessPerXGreatWorks  >= 0, "Count of extra happiness per buildings is corrupted");

	if (iChange != 0)
		m_iHappinessPerXGreatWorks += iChange;
}
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
int CvPlayer::GetHappinessFromResourceMonopolies() const
{
	int iTotalHappiness = 0;
	// Do we get increased Happiness from a resource monopoly?
	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
		CvResourceInfo* pInfo = GC.getResourceInfo(eResourceLoop);
		if (pInfo && pInfo->isMonopoly())
		{
			if(HasGlobalMonopoly(eResourceLoop) && pInfo->getMonopolyHappiness() > 0)
			{
				int iTemp = pInfo->getMonopolyHappiness();
				iTemp += GetMonopolyModFlat();
				iTotalHappiness += iTemp;
			}
		}
	}
	return iTotalHappiness;
}
#endif
//	--------------------------------------------------------------------------------
/// Total amount of Happiness gained from Resources
int CvPlayer::GetHappinessFromResources() const
{
	int iTotalHappiness = 0;

	// Check all connected Resources
	for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResource = (ResourceTypes) iResourceLoop;

		int iBaseHappiness = GetHappinessFromLuxury(eResource);
		if (iBaseHappiness > 0)
		{
			// Resource bonus from Minors, and this is a Luxury we're getting from one (Policies, etc.)
			if (IsMinorResourceBonus() && getResourceFromMinors(eResource) > 0)
			{
				iBaseHappiness *= /*150 in CP, 100 in VP*/ GD_INT_GET(MINOR_POLICY_RESOURCE_HAPPINESS_MULTIPLIER);
				iBaseHappiness /= 100;
			}

			iTotalHappiness += iBaseHappiness;
			iTotalHappiness += GetExtraHappinessPerLuxury();
		}
	}

	return iTotalHappiness;
}

//	--------------------------------------------------------------------------------
/// Amount of Happiness from having a variety of Luxuries
int CvPlayer::GetHappinessFromResourceVariety() const
{
	int iMultipleLuxuriesBonus = /*0*/ GD_INT_GET(HAPPINESS_PER_EXTRA_LUXURY);
	if (iMultipleLuxuriesBonus == 0)
		return 0;

	// Check all connected Resources
	int iNumHappinessResources = 0;
	for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResource = (ResourceTypes) iResourceLoop;
		if(GetHappinessFromLuxury(eResource) > 0)
		{
			iNumHappinessResources++;
		}
	}

	if(iNumHappinessResources > 1)
	{
		return (iNumHappinessResources-1) * iMultipleLuxuriesBonus;
	}

	return 0;
}


//	--------------------------------------------------------------------------------
/// Total amount of Happiness gained from Religion
int CvPlayer::GetHappinessFromReligion()
{
	int iHappinessFromReligion = 0;
	CvGameReligions* pReligions = GC.getGame().GetGameReligions();

	// Founder beliefs
	ReligionTypes eStateReligion = GetReligions()->GetStateReligion();
	if (eStateReligion != NO_RELIGION)
	{
		const CvReligion* pReligion = pReligions->GetReligion(eStateReligion, GetID());
		if (pReligion)
		{
			CvCity* pHolyCity = pReligion->GetHolyCity();
			bool bAtPeace = GET_TEAM(getTeam()).getAtWarCount(false) == 0;
			iHappinessFromReligion += pReligion->m_Beliefs.GetPlayerHappiness(bAtPeace, GetID(), pHolyCity, true);

			float iHappinessPerFollowingCity = pReligion->m_Beliefs.GetHappinessPerFollowingCity(GetID(), pHolyCity, true);
			iHappinessFromReligion += (int)((float)pReligions->GetNumCitiesFollowing(eStateReligion) * iHappinessPerFollowingCity);

			int iHappinessPerXPeacefulForeignFollowers = pReligion->m_Beliefs.GetHappinessPerXPeacefulForeignFollowers(GetID(), pHolyCity, true);
			if (iHappinessPerXPeacefulForeignFollowers > 0)
			{
				iHappinessFromReligion += GetReligions()->GetNumForeignFollowers(/*bAtPeace*/ true, eStateReligion) / iHappinessPerXPeacefulForeignFollowers;
			}

			int iPantheon = 0;
			if (pHolyCity == NULL)
			{
				pHolyCity = getCapitalCity();
			}
			int iHappiness = pReligion->m_Beliefs.GetHappinessPerPantheon(GetID(), pHolyCity, true);
			if (iHappiness > 0)
			{
				iPantheon = GC.getGame().GetGameReligions()->GetNumPantheonsCreated();
				if (iPantheon > 0)
				{
					if (iPantheon > 8)
					{
						iPantheon = 8;
					}
					iHappinessFromReligion += (iPantheon * iHappiness);
				}
			}
			
			int iSpyHappiness = pReligion->m_Beliefs.GetHappinessFromForeignSpies(GetID(), pHolyCity, true);
			if (iSpyHappiness > 0)
			{
				int numForeignSpies = 0;
				CvPlayerEspionage* pEspionage = GetEspionage();
				if (pEspionage)
				{
					for (uint ui = 0; ui < pEspionage->m_aSpyList.size(); ui++)
					{
						if (pEspionage->m_aSpyList[ui].m_eSpyState == SPY_STATE_DEAD)
							continue;

						if (pEspionage->m_aSpyList[ui].m_eSpyState == SPY_STATE_TRAVELLING)
							continue;

						CvPlot* pPlot = GC.getMap().plot(pEspionage->m_aSpyList[ui].m_iCityX, pEspionage->m_aSpyList[ui].m_iCityY);
						if (pPlot == NULL)
							continue;

						CvCity* pSpyCity = pPlot->getPlotCity();

						if (pSpyCity == NULL)
							continue;

						if (pSpyCity->getOwner() == GetID())
							continue;

						numForeignSpies++;
					}
				}
				iHappinessFromReligion += numForeignSpies * iSpyHappiness;
			}
		}
	}

	return iHappinessFromReligion;
}

//	--------------------------------------------------------------------------------
// Happiness from finding Natural Wonders
int CvPlayer::GetHappinessFromNaturalWonders() const
{
	int iNumWonders = GET_TEAM(getTeam()).GetNumNaturalWondersDiscovered();

	int iHappiness = iNumWonders * /*1*/ GD_INT_GET(HAPPINESS_PER_NATURAL_WONDER);
	
#if defined(HH_MOD_NATURAL_WONDER_MODULARITY)
	int iBonusHappiness = iNumWonders* (m_pPlayerPolicies->GetNumericModifier(POLICYMOD_EXTRA_NATURALWONDER_HAPPINESS));
	iHappiness += iBonusHappiness;
#endif

	// Trait boosts this further?
	if(m_pTraits->GetNaturalWonderHappinessModifier() > 0)
	{
		iHappiness *= (100 + m_pTraits->GetNaturalWonderHappinessModifier());
		iHappiness /= 100;
	}

	for (vector<FeatureTypes>::const_iterator it=m_ownedNaturalWonders.begin(); it!=m_ownedNaturalWonders.end(); ++it)
	{
		int iPlotHappiness = GC.getFeatureInfo(*it)->getInBorderHappiness();

		// Trait boosts this further?
		if (m_pTraits->GetNaturalWonderYieldModifier() > 0)
		{
			iPlotHappiness *= (100 + m_pTraits->GetNaturalWonderYieldModifier());
			iPlotHappiness /= 100;
		}

		iHappiness += iPlotHappiness;
	}

	return iHappiness + GET_TEAM(getTeam()).GetNumLandmarksBuilt();
}

#if defined(MOD_BALANCE_CORE)
void CvPlayer::SetNaturalWonderOwned(FeatureTypes eFeature, bool bValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eFeature >= 0, "eFeature is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFeature < GC.getNumFeatureInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	vector<FeatureTypes>::const_iterator it = std::find(m_ownedNaturalWonders.begin(), m_ownedNaturalWonders.end(), eFeature);

	if (bValue && it==m_ownedNaturalWonders.end())
		m_ownedNaturalWonders.push_back(eFeature);
	else if (!bValue && it!=m_ownedNaturalWonders.end())
		m_ownedNaturalWonders.erase(it);
}

void CvPlayer::ChangeUnitClassProductionModifier(UnitClassTypes eUnitClass, int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eUnitClass >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eUnitClass < GC.getNumUnitClassInfos(), "eUnitClass expected to be < GC.getNumUnitClassInfos()");
	m_paiUnitClassProductionModifiers[eUnitClass] = m_paiUnitClassProductionModifiers[eUnitClass] + iValue;
}
int CvPlayer::GetUnitClassProductionModifier(UnitClassTypes eUnitClass) const
{
	VALIDATE_OBJECT
		CvAssertMsg(eUnitClass >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eUnitClass < GC.getNumUnitClassInfos(), "eUnitClass expected to be < GC.getNumUnitClassInfos()");
	return m_paiUnitClassProductionModifiers[eUnitClass];
}
#endif
//	--------------------------------------------------------------------------------
/// Extra Happiness from every connected Luxury
int CvPlayer::GetExtraHappinessPerLuxury() const
{
	return m_iExtraHappinessPerLuxury;
}

//	--------------------------------------------------------------------------------
/// Change Extra Happiness from every connected Luxury
void CvPlayer::ChangeExtraHappinessPerLuxury(int iChange)
{
	//antonjs: consider: this check wasn't here before, maybe we shouldn't have it in case mods, scenarios use luxuries in a unique malus way
	//CvAssertMsg(m_iExtraHappinessPerLuxury + iChange >= 0, "Net extra happiness per luxury not expected to be negative!");
	// slewis - Hey Anton, I removed this because it was complaining during my awesome Fall of Rome scenario.
	m_iExtraHappinessPerLuxury += iChange;
}

#if defined(MOD_BALANCE_CORE_HAPPINESS_LUXURY)
//	--------------------------------------------------------------------------------
int CvPlayer::GetPlayerHappinessLuxuryPopulationFactor1000() const
{
	return /*20*/ GD_INT_GET(BALANCE_HAPPINESS_LUXURY_POP_SCALER);
}

int CvPlayer::GetBonusHappinessFromLuxuries(int iPop) const
{
	if (iPop == 0)
		return 0;

	int iTotalResourceWeight = 0;
	for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResource = (ResourceTypes) iResourceLoop;
		int iBaseVal = GetHappinessFromLuxury(eResource, false) * 1000;
		if (iBaseVal <= 0)
			continue;

		iBaseVal += (GetExtraHappinessPerLuxury() * 1000);

		CvResourceInfo* pInfo = GC.getResourceInfo(eResource);
		if (pInfo && pInfo->isMonopoly())
		{
			if (HasGlobalMonopoly(eResource) && pInfo->getMonopolyHappiness() > 0)
			{
				iBaseVal += (pInfo->getMonopolyHappiness() + GetMonopolyModFlat()) * 1000;
			}
		}

		// Resource bonus from Minors, and this is a Luxury we're getting from one (Policies, etc.)
		if (IsMinorResourceBonus() && getResourceFromMinors(eResource) > 0)
		{
			iBaseVal *= /*150 in CP, 100 in VP*/ GD_INT_GET(MINOR_POLICY_RESOURCE_HAPPINESS_MULTIPLIER);
			iBaseVal /= 100;
		}

		iTotalResourceWeight += iBaseVal;
	}

	if (iTotalResourceWeight <= 0)
		return 0;

	//scaler is in 1/1000th
	int iScaled = int(0.5f + iTotalResourceWeight / 1000.f * iPop * GetPlayerHappinessLuxuryPopulationFactor1000() / 1000);

	return max(1, iScaled);
	
}

int CvPlayer::GetBonusHappinessFromLuxuriesFlat() const
{
	int iTotalResourceWeight = 0;

	int iCityScaler = getNumCities() * (/*20*/ GD_INT_GET(BALANCE_HAPPINESS_LUXURY_POP_SCALER) + GetCurrentEra());
	iCityScaler /= 100;

	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResource = (ResourceTypes)iResourceLoop;
		int iBaseVal = GetHappinessFromLuxury(eResource);
		if (iBaseVal <= 0)
			continue;

		iBaseVal += GetExtraHappinessPerLuxury();
		iBaseVal += iCityScaler;

		CvResourceInfo* pInfo = GC.getResourceInfo(eResource);
		if (pInfo && pInfo->isMonopoly())
		{
			if (HasGlobalMonopoly(eResource) && pInfo->getMonopolyHappiness() > 0)
			{
				iBaseVal += (pInfo->getMonopolyHappiness() + GetMonopolyModFlat());
			}
		}

		// Resource bonus from Minors, and this is a Luxury we're getting from one (Policies, etc.)
		if (IsMinorResourceBonus() && getResourceFromMinors(eResource) > 0)
		{
			iBaseVal *= /*150 in CP, 100 in VP*/ GD_INT_GET(MINOR_POLICY_RESOURCE_HAPPINESS_MULTIPLIER);
			iBaseVal /= 100;
		}

		iTotalResourceWeight += iBaseVal;
	}

	if (iTotalResourceWeight <= 0)
		return 0;

	return iTotalResourceWeight;

}

int CvPlayer::GetBonusHappinessFromLuxuriesFlatForUI() const
{
	int iTotalResourceWeight = 0;

	int iCityScaler = getNumCities() * /*20*/ GD_INT_GET(BALANCE_HAPPINESS_LUXURY_POP_SCALER);
	iCityScaler /= 100;
	
	int iNumResources = 0;
	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResource = (ResourceTypes)iResourceLoop;
		int iBaseVal = GetHappinessFromLuxury(eResource);
		if (iBaseVal <= 0)
			continue;

		iBaseVal += GetExtraHappinessPerLuxury();
		iBaseVal += iCityScaler;

		CvResourceInfo* pInfo = GC.getResourceInfo(eResource);
		if (pInfo && pInfo->isMonopoly())
		{
			if (HasGlobalMonopoly(eResource) && pInfo->getMonopolyHappiness() > 0)
			{
				iBaseVal += (pInfo->getMonopolyHappiness() + GetMonopolyModFlat());
			}
		}

		// Resource bonus from Minors, and this is a Luxury we're getting from one (Policies, etc.)
		if (IsMinorResourceBonus() && getResourceFromMinors(eResource) > 0)
		{
			iBaseVal *= /*150 in CP, 100 in VP*/ GD_INT_GET(MINOR_POLICY_RESOURCE_HAPPINESS_MULTIPLIER);
			iBaseVal /= 100;
		}

		iTotalResourceWeight += iBaseVal;

		iNumResources++;
	}

	if (iTotalResourceWeight <= 0)
		return 0;

	return iTotalResourceWeight / max(1, iNumResources);
	 
}
#endif

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvPlayer::GetUnhappinessFromWarWeariness() const
{
	return GetCulture()->GetWarWeariness();
}
#endif
//	--------------------------------------------------------------------------------
/// How much happiness credit for having this resource as a luxury?
int CvPlayer::GetHappinessFromLuxury(ResourceTypes eResource, bool bIncludeImport) const
{
	// No Happiness if banned by World Congress
	if (GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(GetID(), eResource))
		return 0;

	CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);
	if (pkResourceInfo && pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_LUXURY)
	{
		// Any extras?
		if (getNumResourceAvailable(eResource, /*bIncludeImport*/ bIncludeImport) > 0)
		{
			return pkResourceInfo->getHappiness();
		}
		// Vanilla Netherlands UA? (retain 50% of the Happiness if you trade away your last copy)
		else if (GetPlayerTraits()->GetLuxuryHappinessRetention() > 0 && getResourceExport(eResource) > 0)
		{
			return (pkResourceInfo->getHappiness() * GetPlayerTraits()->GetLuxuryHappinessRetention()) / 100;
		}
	}

	return 0;
}

//	--------------------------------------------------------------------------------
/// How much Unhappiness are Units producing?
int CvPlayer::GetUnhappinessFromUnits() const
{
	int iUnhappinessFromUnits = m_iUnhappinessFromUnits;

	int iFreeUnitUnhappiness = /*0*/ GD_INT_GET(FREE_UNIT_HAPPINESS);
	if (iFreeUnitUnhappiness != 0)
	{
		// If unhappy is 2 and free happy is 4, we need to subtract 2
		// If unhappy is 5 and free happy is 4, we need to subtract 4 --> these two make "the min of unhappy and free happy"
		// If unhappy is -2 and free happy is 4, we need to subtract 0 --> this one adds "the previous figure not to be negative"
		iUnhappinessFromUnits -= std::max(0, std::min(iUnhappinessFromUnits, iFreeUnitUnhappiness));
	}

	if (iUnhappinessFromUnits > 0 && GetUnhappinessFromUnitsMod() != 0)
	{
		iUnhappinessFromUnits *= (100 + GetUnhappinessFromUnitsMod());
		iUnhappinessFromUnits /= 100;
	}

	return iUnhappinessFromUnits;
}

//	--------------------------------------------------------------------------------
/// Changes how much Happiness Units produce
void CvPlayer::ChangeUnhappinessFromUnits(int iChange)
{
	m_iUnhappinessFromUnits += iChange;
}

//	--------------------------------------------------------------------------------
/// How much of our Happiness is being used up? (Population + Units)
int CvPlayer::DoUpdateTotalUnhappiness(CvCity* pAssumeCityAnnexed, CvCity* pAssumeCityPuppeted)
{
	if (isMinorCiv() || isBarbarian())
		return 0;

	int iUnhappiness = 0;

	if (!MOD_BALANCE_CORE_HAPPINESS)
	{
		// City Count Unhappiness
		iUnhappiness += GetUnhappinessFromCityCount(pAssumeCityAnnexed, pAssumeCityPuppeted);

		// Occupied City Count Unhappiness
		iUnhappiness += GetUnhappinessFromCapturedCityCount(pAssumeCityAnnexed, pAssumeCityPuppeted);

		// City Population Unhappiness
		iUnhappiness += GetUnhappinessFromCityPopulation(pAssumeCityAnnexed, pAssumeCityPuppeted);

		// Occupied City Population Unhappiness
		iUnhappiness += GetUnhappinessFromOccupiedCities(pAssumeCityAnnexed, pAssumeCityPuppeted);

		// Unit Unhappiness (Builders)
		iUnhappiness += GetUnhappinessFromUnits();

		iUnhappiness /= 100;
	}

	iUnhappiness += GetCulture()->GetPublicOpinionUnhappiness();

	if (MOD_BALANCE_CORE_JFD && !isMinorCiv() && !isBarbarian())
	{
		iUnhappiness += GetUnhappinessFromCityJFDSpecial();
	}

	if (MOD_BALANCE_CORE_HAPPINESS && !isMinorCiv() && !isBarbarian())
	{
		iUnhappiness += GetUnhappinessFromWarWeariness();
	}
	if (!MOD_BALANCE_CORE_DIFFICULTY)
	{
		// AI gets reduced Unhappiness on higher levels
		if (!isHuman())
		{
			iUnhappiness *= GC.getGame().getHandicapInfo().getAIUnhappinessPercent();
			iUnhappiness /= 100;
		}
	}

	SetUnhappiness(iUnhappiness);
	return iUnhappiness;
}

//	--------------------------------------------------------------------------------
/// Used for providing info to the player
int CvPlayer::GetUnhappinessFromCityForUI(CvCity* pCity) const
{
	int iNumCitiesUnhappinessTimes100 = 0;
	float iPopulationUnhappinessTimes100 = 0;

	int iPopulation = pCity->getPopulation() * 100;

	// No Unhappiness from Specialist Pop? (Policies, etc.)
	if(isHalfSpecialistUnhappiness())
	{
		int iSpecialistCount = pCity->GetCityCitizens()->GetTotalSpecialistCount() * 100;
		iPopulation -= (iSpecialistCount / 2);
	}

	// Occupied?
	if(pCity->IsOccupied() && !pCity->IsIgnoreCityForHappiness())
	{
		iNumCitiesUnhappinessTimes100 += (100 * /*5*/ GD_INT_GET(UNHAPPINESS_PER_CAPTURED_CITY));
		iPopulationUnhappinessTimes100 += int(iPopulation* /*1.34f in CP, 1.00f in VP*/ GD_FLOAT_GET(UNHAPPINESS_PER_OCCUPIED_POPULATION));

		// Mod (Policies, etc.)
		if(GetOccupiedPopulationUnhappinessMod() != 0)
		{
			iPopulationUnhappinessTimes100 *= (100 + GetOccupiedPopulationUnhappinessMod());
			iPopulationUnhappinessTimes100 /= 100;
		}
	}
	// Normal City
	else
	{
		iNumCitiesUnhappinessTimes100 += (100 * /*3*/ GD_INT_GET(UNHAPPINESS_PER_CITY));
		iPopulationUnhappinessTimes100 += (iPopulation* (/*1*/ GD_INT_GET(UNHAPPINESS_PER_POPULATION) + GD_FLOAT_GET(UNHAPPINESS_PER_POPULATION_FLOAT)));

		if(pCity->isCapital() && GetCapitalUnhappinessMod() != 0)
		{
			iPopulationUnhappinessTimes100 *= (100 + GetCapitalUnhappinessMod());
			iPopulationUnhappinessTimes100 /= 100;
		}
#if defined(MOD_BALANCE_CORE)
		if(pCity->GetLocalUnhappinessMod() != 0)
		{
			iPopulationUnhappinessTimes100 *= (100 + pCity->GetLocalUnhappinessMod());
			iPopulationUnhappinessTimes100 /= 100;
		}
#endif

		iPopulationUnhappinessTimes100 *= (100 + GetUnhappinessMod());
		iPopulationUnhappinessTimes100 /= 100;

		iPopulationUnhappinessTimes100 *= 100 + GetPlayerTraits()->GetPopulationUnhappinessModifier();
		iPopulationUnhappinessTimes100 /= 100;
	}

	if (!MOD_BALANCE_CORE_HAPPINESS)
	{
		// Population Handicap mod
		iPopulationUnhappinessTimes100 *= getHandicapInfo().getPopulationUnhappinessMod();
		iPopulationUnhappinessTimes100 /= 100;
	}

	// City Count Player mod
	int iMod = 0;
	iMod += GetCityCountUnhappinessMod();
	iMod += GetPlayerTraits()->GetCityUnhappinessModifier();

	iNumCitiesUnhappinessTimes100 *= (100 + iMod);
	iNumCitiesUnhappinessTimes100 /= 100;

	// City Count Handicap mod
	iNumCitiesUnhappinessTimes100 *= getHandicapInfo().getNumCitiesUnhappinessMod();
	iNumCitiesUnhappinessTimes100 /= 100;

	// City Count Map size mod
	iNumCitiesUnhappinessTimes100 *= GC.getMap().getWorldInfo().getNumCitiesUnhappinessPercent();
	iNumCitiesUnhappinessTimes100 /= 100;

	return iNumCitiesUnhappinessTimes100 + (int)iPopulationUnhappinessTimes100;
}

//	--------------------------------------------------------------------------------
/// Unhappiness from number of Cities
int CvPlayer::GetUnhappinessFromCityCount(CvCity* pAssumeCityAnnexed, CvCity* pAssumeCityPuppeted) const
{
	int iUnhappiness = 0;
	int iUnhappinessPerCity = /*3*/ GD_INT_GET(UNHAPPINESS_PER_CITY) * 100;

	bool bCityValid;

	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		bCityValid = false;

		// Assume city is puppeted, and counts
		if(pLoopCity == pAssumeCityPuppeted)
			bCityValid = true;
		// Assume city is annexed, and does NOT count
		else if(pLoopCity == pAssumeCityAnnexed)
			bCityValid = false;
		// Assume city doesn't exist, and does NOT count
		else if(pLoopCity->IsIgnoreCityForHappiness())
			bCityValid = false;
		// Normal city
		else if(!pLoopCity->IsOccupied() || pLoopCity->IsNoOccupiedUnhappiness())
			bCityValid = true;
#if defined(MOD_BALANCE_CORE_HAPPINESS)
		if(MOD_BALANCE_CORE_HAPPINESS)
		{
			//Tradition policy bonus - Capital grants no founding unhappiness.
			if(pLoopCity->isCapital() && GetCapitalUnhappinessMod() != 0)
			{
				bCityValid = false;
			}
		}
#endif
#if defined(MOD_BALANCE_CORE_POLICIES)
		if(MOD_BALANCE_CORE_POLICIES)
		{
			//Expansion policy bonus - Cities grant no unhappiness from expansion.
			if(IsNoUnhappinessExpansion())
			{
				bCityValid = false;
			}
		}
#endif
		if(bCityValid)
			iUnhappiness += iUnhappinessPerCity;
	}

	// Player count mod
	int iMod = 0;
	iMod += GetCityCountUnhappinessMod();
	iMod += GetPlayerTraits()->GetCityUnhappinessModifier();

	iUnhappiness *= (100 + iMod);
	iUnhappiness /= 100;

	// Handicap mod
	iUnhappiness *= getHandicapInfo().getNumCitiesUnhappinessMod();
	iUnhappiness /= 100;

	// Map size mod
	iUnhappiness *= GC.getMap().getWorldInfo().getNumCitiesUnhappinessPercent();
	iUnhappiness /= 100;

	return iUnhappiness;
}

//	--------------------------------------------------------------------------------
/// Unhappiness from number of Captured Cities
int CvPlayer::GetUnhappinessFromCapturedCityCount(CvCity* pAssumeCityAnnexed, CvCity* pAssumeCityPuppeted) const
{
	int iUnhappiness = 0;
	int iUnhappinessPerCapturedCity = /*5*/ GD_INT_GET(UNHAPPINESS_PER_CAPTURED_CITY) * 100;

	bool bCityValid;

	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		bCityValid = false;

		// Assume city is puppeted, and does NOT count
		if(pLoopCity == pAssumeCityPuppeted)
			bCityValid = false;
		// Assume city is annexed, and counts
		else if(pLoopCity == pAssumeCityAnnexed)
			bCityValid = true;
		// Assume city doesn't exist, and does NOT count
		else if(pLoopCity->IsIgnoreCityForHappiness())
			bCityValid = false;
		// Occupied city
		else if(pLoopCity->IsOccupied() && !pLoopCity->IsNoOccupiedUnhappiness())
			bCityValid = true;

		// Extra Unhappiness from Occupied Cities
		if(bCityValid)
			iUnhappiness += iUnhappinessPerCapturedCity;
	}

	// Player count mod
	int iMod = 0;
	iMod += GetCityCountUnhappinessMod();
	iMod += GetPlayerTraits()->GetCityUnhappinessModifier();

	iUnhappiness *= (100 + iMod);
	iUnhappiness /= 100;

	// Handicap mod
	iUnhappiness *= getHandicapInfo().getNumCitiesUnhappinessMod();
	iUnhappiness /= 100;

	// Map size mod
	iUnhappiness *= GC.getMap().getWorldInfo().getNumCitiesUnhappinessPercent();
	iUnhappiness /= 100;

	return iUnhappiness;
}

//	--------------------------------------------------------------------------------
/// Unhappiness from City Population
int CvPlayer::GetUnhappinessFromCityPopulation(CvCity* pAssumeCityAnnexed, CvCity* pAssumeCityPuppeted) const
{

#if defined(MOD_BALANCE_CORE_HAPPINESS)
	if(MOD_BALANCE_CORE_HAPPINESS)
	{
		return 0;
	}
#endif
	float iUnhappiness = 0;
	float iUnhappinessFromThisCity;

	float iUnhappinessPerPop = (/*1*/ GD_INT_GET(UNHAPPINESS_PER_POPULATION) + GD_FLOAT_GET(UNHAPPINESS_PER_POPULATION_FLOAT)) * 100;
	int iPopulation;
	int iSpecialistCount;

	bool bCityValid;

	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		bCityValid = false;

		// Assume pLoopCity is Annexed, and does NOT count
		if(pLoopCity == pAssumeCityAnnexed)
			bCityValid = false;
		// Assume that pLoopCity is a Puppet and IS counted here
		else if(pLoopCity == pAssumeCityPuppeted)
			bCityValid = true;
		// Assume city doesn't exist, and does NOT count
		else if(pLoopCity->IsIgnoreCityForHappiness())
			bCityValid = false;
		// Occupied Cities don't get counted here (see the next function)
		else if(!pLoopCity->IsOccupied() || pLoopCity->IsNoOccupiedUnhappiness())
			bCityValid = true;

		if(bCityValid)
		{
			iPopulation = pLoopCity->getPopulation();

			// No Unhappiness from Specialist Pop? (Policies, etc.)
			if(isHalfSpecialistUnhappiness())
			{
				iSpecialistCount = pLoopCity->GetCityCitizens()->GetTotalSpecialistCount();
				iSpecialistCount++; // Round up
				iPopulation -= (iSpecialistCount / 2);
			}

			iUnhappinessFromThisCity = iPopulation * iUnhappinessPerPop;

			if(pLoopCity->isCapital() && GetCapitalUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + GetCapitalUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#if defined(MOD_BALANCE_CORE)
			if(pLoopCity->GetLocalUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + pLoopCity->GetLocalUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#endif

			iUnhappiness += iUnhappinessFromThisCity;
		}
	}

	iUnhappiness *= (100 + GetUnhappinessMod());
	iUnhappiness /= 100;

	iUnhappiness *= 100 + GetPlayerTraits()->GetPopulationUnhappinessModifier();
	iUnhappiness /= 100;

	if (!MOD_BALANCE_CORE_HAPPINESS)
	{
		// Handicap mod
		iUnhappiness *= getHandicapInfo().getPopulationUnhappinessMod();
		iUnhappiness /= 100;
	}

	return (int)iUnhappiness;
}

//	--------------------------------------------------------------------------------
/// Unhappiness from Puppet City Population
int CvPlayer::GetUnhappinessFromPuppetCityPopulation() const
{
	int iLoop = 0;
	if (MOD_BALANCE_CORE_PUPPET_CHANGES)
	{
		int iTotal = 0;
		for (const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if (pLoopCity->IsRazing() || pLoopCity->IsResistance())
				continue;
			if (!pLoopCity->IsPuppet())
				continue;
			else
				iTotal += pLoopCity->getPopulation() / max(1, /*4*/ GD_INT_GET(BALANCE_HAPPINESS_PUPPET_THRESHOLD_MOD));
		}
		return iTotal;
	}

	int iUnhappiness = 0;
	float iUnhappinessPerPop = (/*1*/ GD_INT_GET(UNHAPPINESS_PER_POPULATION) + GD_FLOAT_GET(UNHAPPINESS_PER_POPULATION_FLOAT)) * 100;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		bool bCityValid = false;

		if(pLoopCity->IsPuppet())
			bCityValid = true;

		// Assume city doesn't exist, and does NOT count
		if(pLoopCity->IsIgnoreCityForHappiness())
			bCityValid = false;

		if(bCityValid)
		{
			int iPopulation = pLoopCity->getPopulation();

			// No Unhappiness from Specialist Pop? (Policies, etc.)
			// slewis - 2013.5.7 
			// This function, along with GetUnhappinessFromCitySpecialists, is only called through the UI to reflect 
			// to the player what's going on with their happiness. So I removed the effect that specialists have on 
			// puppeted cities and let the GetUnhappinessFromCitySpecialists correct that problem.

			/*if(isHalfSpecialistUnhappiness())
			{
				int iSpecialistCount = pLoopCity->GetCityCitizens()->GetTotalSpecialistCount();
				iSpecialistCount++; // Round up
				iPopulation -= (iSpecialistCount / 2);
			}*/
			iPopulation -= pLoopCity->GetCityCitizens()->GetTotalSpecialistCount();

			float iUnhappinessFromThisCity = iPopulation * iUnhappinessPerPop;

			if(pLoopCity->isCapital() && GetCapitalUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + GetCapitalUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#if defined(MOD_BALANCE_CORE)
			if(pLoopCity->GetLocalUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + pLoopCity->GetLocalUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#endif

			iUnhappiness += (int)iUnhappinessFromThisCity;
		}
	}

	iUnhappiness *= (100 + GetUnhappinessMod());
	iUnhappiness /= 100;

	iUnhappiness *= 100 + GetPlayerTraits()->GetPopulationUnhappinessModifier();
	iUnhappiness /= 100;

	if (!MOD_BALANCE_CORE_HAPPINESS)
	{
		// Handicap mod
		iUnhappiness *= getHandicapInfo().getPopulationUnhappinessMod();
		iUnhappiness /= 100;
	}

	return iUnhappiness;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetUnhappinessFromCitySpecialists(CvCity* pAssumeCityAnnexed, CvCity* pAssumeCityPuppeted) const
{
	float iUnhappiness = 0;
	float iUnhappinessFromThisCity;
	float iUnhappinessPerPop = /*1*/ (/*1*/ GD_INT_GET(UNHAPPINESS_PER_POPULATION) + GD_FLOAT_GET(UNHAPPINESS_PER_POPULATION_FLOAT)) * 100;
	int iPopulation;

	bool bCityValid;

	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		bCityValid = false;

		// Assume pLoopCity is Annexed, and does NOT count
		if(pLoopCity == pAssumeCityAnnexed)
			bCityValid = false;
		// Assume that pLoopCity is a Puppet and IS counted here
		else if(pLoopCity == pAssumeCityPuppeted)
			bCityValid = true;
		// Assume city doesn't exist, and does NOT count
		else if(pLoopCity->IsIgnoreCityForHappiness())
			bCityValid = false;
		// Occupied Cities don't get counted here (see the next function)
		else if(!pLoopCity->IsOccupied() || pLoopCity->IsNoOccupiedUnhappiness())
			bCityValid = true;

		if (pLoopCity->IsPuppet() && MOD_BALANCE_CORE_PUPPET_CHANGES)
			bCityValid = false;

		if(bCityValid)
		{
			iPopulation = pLoopCity->GetCityCitizens()->GetTotalSpecialistCount();

#if defined(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS)
			//Less unhappiness from specialists....
			if (MOD_BALANCE_CORE_HAPPINESS_MODIFIERS || MOD_BALANCE_CORE_JFD)
			{
				iUnhappinessPerPop = (float)/*100*/ GD_INT_GET(BALANCE_UNHAPPINESS_PER_SPECIALIST);
				int iNoHappinessSpecialists = 0;
				if (iPopulation > 0)
				{
					//...in capital?
					if (pLoopCity->isCapital())
					{
						iNoHappinessSpecialists += GetNoUnhappfromXSpecialistsCapital();
					}
					//...elsewhere?	
					iNoHappinessSpecialists += GetNoUnhappfromXSpecialists();

					iNoHappinessSpecialists += pLoopCity->GetNoUnhappfromXSpecialists();
				}
				//Can't give more free happiness than specialists.
				if (iNoHappinessSpecialists > iPopulation)
				{
					iNoHappinessSpecialists = iPopulation;
				}
				if (iNoHappinessSpecialists > 0)
				{
					iPopulation -= iNoHappinessSpecialists;
				}
			}
#endif

			// No Unhappiness from Specialist Pop? (Policies, etc.)
			if(isHalfSpecialistUnhappiness())
			{
				iPopulation++; // Round up
				iPopulation /= 2;
			}

			iUnhappinessFromThisCity = iPopulation * iUnhappinessPerPop;

#if defined(MOD_BALANCE_CORE_HAPPINESS)
			if(MOD_BALANCE_CORE_HAPPINESS || MOD_BALANCE_CORE_JFD)
			{
				iUnhappiness += iUnhappinessFromThisCity;
			}
			if(!MOD_BALANCE_CORE_HAPPINESS)
			{
//Took these away as they were making specialists do weird things.
#endif
			if(pLoopCity->isCapital() && GetCapitalUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + GetCapitalUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#if defined(MOD_BALANCE_CORE)
			if(pLoopCity->GetLocalUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + pLoopCity->GetLocalUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#endif

			iUnhappiness += iUnhappinessFromThisCity;
#if defined(MOD_BALANCE_CORE_HAPPINESS)
			}
#endif
		}
	}
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	if(!MOD_BALANCE_CORE_HAPPINESS)
	{
#endif
	iUnhappiness *= (100 + GetUnhappinessMod());
	iUnhappiness /= 100;

	iUnhappiness *= 100 + GetPlayerTraits()->GetPopulationUnhappinessModifier();
	iUnhappiness /= 100;

	// Handicap mod
	iUnhappiness *= getHandicapInfo().getPopulationUnhappinessMod();
	iUnhappiness /= 100;

#if defined(MOD_BALANCE_CORE_HAPPINESS)
	}
#endif
	return (int)iUnhappiness;
}

//	--------------------------------------------------------------------------------
/// Unhappiness from City Population in Occupied Cities
int CvPlayer::GetUnhappinessFromOccupiedCities(CvCity* pAssumeCityAnnexed, CvCity* pAssumeCityPuppeted) const
{
	int iUnhappiness = 0;
	int iUnhappinessFromThisCity;

	double fUnhappinessPerPop = /*1.34f in CP, 1.00f in VP*/ GD_FLOAT_GET(UNHAPPINESS_PER_OCCUPIED_POPULATION) * 100;
	int iPopulation;
	int iSpecialistCount;

	bool bCityValid;
	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		bCityValid = false;

		// Assume pLoopCity is Annexed, and counts
		if(pLoopCity == pAssumeCityAnnexed)
			bCityValid = true;
		// Assume that pLoopCity is a Puppet and does NOT count
		else if(pLoopCity == pAssumeCityPuppeted)
			bCityValid = false;
		// Assume city doesn't exist, and does NOT count
		else if(pLoopCity->IsIgnoreCityForHappiness())
			bCityValid = false;
		// Occupied Cities
		else if(pLoopCity->IsOccupied() && !pLoopCity->IsNoOccupiedUnhappiness())
			bCityValid = true;
#if defined(MOD_BALANCE_CORE_HAPPINESS)
		if(MOD_BALANCE_CORE_HAPPINESS && (pLoopCity->IsResistance() || pLoopCity->IsRazing()))
		{
			bCityValid = true;
		}
#endif

		if(bCityValid)
		{
			iPopulation = pLoopCity->getPopulation();

			// No Unhappiness from Specialist Pop? (Policies, etc.)
			if(isHalfSpecialistUnhappiness())
			{
				iSpecialistCount = pLoopCity->GetCityCitizens()->GetTotalSpecialistCount();
				iSpecialistCount++; // Round up
				iPopulation -= (iSpecialistCount / 2);
			}

			iUnhappinessFromThisCity = int(double(iPopulation) * fUnhappinessPerPop);

			// Mod (Policies, etc.)
			if(GetOccupiedPopulationUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + GetOccupiedPopulationUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#if defined(MOD_BALANCE_CORE_POLICIES)
			if(MOD_BALANCE_CORE_POLICIES && GetGarrisonsOccupiedUnhapppinessMod() != 0)
			{
				if(pLoopCity->HasGarrison())
				{
					iUnhappinessFromThisCity *= (100 + GetGarrisonsOccupiedUnhapppinessMod());
					iUnhappinessFromThisCity /= 100;
				}
			}
#endif

			iUnhappiness += iUnhappinessFromThisCity;
		}
	}

	if (!MOD_BALANCE_CORE_HAPPINESS)
	{
		// Handicap mod
		iUnhappiness *= getHandicapInfo().getPopulationUnhappinessMod();
		iUnhappiness /= 100;
	}

	return iUnhappiness;
}

//	--------------------------------------------------------------------------------
/// Unhappiness from Units Percent (50 = 50% of normal)
int CvPlayer::GetUnhappinessFromUnitsMod() const
{
	return m_iUnhappinessFromUnitsMod;
}

//	--------------------------------------------------------------------------------
/// Change Unhappiness from Units Percent (50 = 50% of normal)
void CvPlayer::ChangeUnhappinessFromUnitsMod(int iChange)
{
	if(iChange != 0)
	{
		m_iUnhappinessFromUnitsMod += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Unhappiness Mod (-50 = 50% of normal)
int CvPlayer::GetUnhappinessMod() const
{
	return m_iUnhappinessMod;
}

//	--------------------------------------------------------------------------------
/// Change Unhappiness Mod (-50 = 50% of normal)
void CvPlayer::ChangeUnhappinessMod(int iChange)
{
	if(iChange != 0)
	{
		m_iUnhappinessMod += iChange;
	}
}

int CvPlayer::GetHappinessFromCitizenNeeds() const
{
	int iHappiness = 0;
	int iLoop = 0;
	for (const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iHappiness += pLoopCity->GetLocalHappiness();
	}
	return iHappiness;
}
int CvPlayer::GetUnhappinessFromCitizenNeeds() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iUnhappiness += pLoopCity->GetUnhappinessAggregated();
	}
	return iUnhappiness;
}

int CvPlayer::GetUnhappinessFromCityCulture() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iUnhappiness += pLoopCity->GetBoredom(false);
	}
	return iUnhappiness;
}
int CvPlayer::GetUnhappinessFromCityScience() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iUnhappiness += pLoopCity->GetIlliteracy(false);
	}
	return iUnhappiness;
}
int CvPlayer::GetUnhappinessFromCityDefense() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iUnhappiness += pLoopCity->GetDistress(false);
	}
	return iUnhappiness;
}
int CvPlayer::GetUnhappinessFromCityGold() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iUnhappiness += pLoopCity->GetPoverty(false);
	}
	return iUnhappiness;
}
int CvPlayer::GetUnhappinessFromCityConnection() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iUnhappiness += pLoopCity->GetUnhappinessFromIsolation();
	}
	return iUnhappiness;
}
int CvPlayer::GetUnhappinessFromCityPillaged() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iUnhappiness += pLoopCity->GetUnhappinessFromPillagedTiles();
	}
	return iUnhappiness;
}
int CvPlayer::GetUnhappinessFromCityStarving() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iUnhappiness += pLoopCity->GetUnhappinessFromFamine();
	}
	return iUnhappiness;
}
int CvPlayer::GetUnhappinessFromCityMinority() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iUnhappiness += pLoopCity->GetUnhappinessFromReligiousUnrest();
	}
	return iUnhappiness;
}

int CvPlayer::GetUnhappinessFromCityJFDSpecial() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for (const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iUnhappiness += pLoopCity->getJFDSpecialUnhappinessSources();
	}

	iUnhappiness += (GetUnhappinessFromCitySpecialists(NULL, NULL) / 100);
	return iUnhappiness;
}

//	--------------------------------------------------------------------------------
/// City Count Unhappiness Mod (-50 = 50% of normal)
int CvPlayer::GetCityCountUnhappinessMod() const
{
	return m_iCityCountUnhappinessMod;
}

//	--------------------------------------------------------------------------------
/// Change City Count Unhappiness Mod (-50 = 50% of normal)
void CvPlayer::ChangeCityCountUnhappinessMod(int iChange)
{
	if(iChange != 0)
	{
		m_iCityCountUnhappinessMod += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Occupied Population Unhappiness Mod (-50 = 50% of normal)
int CvPlayer::GetOccupiedPopulationUnhappinessMod() const
{
	return m_iOccupiedPopulationUnhappinessMod;
}

//	--------------------------------------------------------------------------------
/// Occupied Population Count Unhappiness Mod (-50 = 50% of normal)
void CvPlayer::ChangeOccupiedPopulationUnhappinessMod(int iChange)
{
	if(iChange != 0)
	{
		m_iOccupiedPopulationUnhappinessMod += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Unhappiness from Capital Mod (-50 = 50% of normal)
int CvPlayer::GetCapitalUnhappinessMod() const
{
	return m_iCapitalUnhappinessMod;
}

//	--------------------------------------------------------------------------------
/// Change Unhappiness from Capital Mod (-50 = 50% of normal)
void CvPlayer::ChangeCapitalUnhappinessMod(int iChange)
{
	if(iChange != 0)
	{
		m_iCapitalUnhappinessMod += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// How much Happiness are we getting from Units being Garrisoned in Cities?
int CvPlayer::GetHappinessPerGarrisonedUnit() const
{
	return m_iHappinessPerGarrisonedUnitCount;
}

//	--------------------------------------------------------------------------------
/// Set the amount of Happiness we're getting from Units being Garrisoned in Cities
void CvPlayer::SetHappinessPerGarrisonedUnit(int iValue)
{
	m_iHappinessPerGarrisonedUnitCount = iValue;
}

//	--------------------------------------------------------------------------------
/// Change the amount of Happiness we're getting from Units being Garrisoned in Cities
void CvPlayer::ChangeHappinessPerGarrisonedUnit(int iChange)
{
	SetHappinessPerGarrisonedUnit(m_iHappinessPerGarrisonedUnitCount + iChange);
}

//	--------------------------------------------------------------------------------
/// Returns cached amount of Happiness being brought in for having Cities connected via a City Connection
int CvPlayer::GetHappinessFromTradeRoutes() const
{
	return m_iCityConnectionHappiness;
}

//	--------------------------------------------------------------------------------
/// How much Happiness coming from Trade Routes?
void CvPlayer::DoUpdateCityConnectionHappiness()
{
	int iHappinessPerTradeRoute = GetHappinessPerTradeRoute();

	int iNumCities = 0;
	if(iHappinessPerTradeRoute != 0)
	{
		CvCity* pCapitalCity = getCapitalCity();

		// Must have a capital before we can check if other Cities are connected to it!
		if(pCapitalCity != NULL && getNumCities() > 1)
		{
			int iLoop;
			for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				if(pLoopCity != pCapitalCity)
				{
					if(pLoopCity->IsConnectedToCapital())
					{
						iNumCities++;
					}
				}
			}
		}
	}
	m_iCityConnectionHappiness = iHappinessPerTradeRoute * iNumCities / 100;	// Bring it out of hundreds
}

bool CvPlayer::UpdateCityConnection(const CvPlot * pPlot, bool bActive)
{
	if (bActive)
	{
		if (IsCityConnectionPlot(pPlot))
			return false; //no update

		//insert and sort
		m_vCityConnectionPlots.push_back(pPlot->GetPlotIndex());
		std::sort(m_vCityConnectionPlots.begin(), m_vCityConnectionPlots.end());
		return true;
	}
	else
	{
		if (!IsCityConnectionPlot(pPlot))
			return false; //no update

		//just delete, no need to re-sort
		m_vCityConnectionPlots.erase(std::remove(m_vCityConnectionPlots.begin(), m_vCityConnectionPlots.end(), pPlot->GetPlotIndex()), m_vCityConnectionPlots.end());
		return true;
	}
}

bool CvPlayer::IsCityConnectionPlot(const CvPlot * pPlot) const
{
	return std::binary_search(m_vCityConnectionPlots.begin(), m_vCityConnectionPlots.end(), pPlot->GetPlotIndex());
}

//	--------------------------------------------------------------------------------
/// How muchHappiness are we getting from Trade Routes?
int CvPlayer::GetHappinessPerTradeRoute() const
{
	return m_iHappinessPerTradeRouteCount;
}

//	--------------------------------------------------------------------------------
/// Set the amont of Happiness we're getting from Trade Routes
void CvPlayer::SetHappinessPerTradeRoute(int iValue)
{
	m_iHappinessPerTradeRouteCount = iValue;
}

//	--------------------------------------------------------------------------------
/// Change the amont of Happiness we're getting from Trade Routes
void CvPlayer::ChangeHappinessPerTradeRoute(int iChange)
{
	SetHappinessPerTradeRoute(m_iHappinessPerTradeRouteCount + iChange);
}

//	--------------------------------------------------------------------------------
/// How much Happiness are we getting from large cities?
int CvPlayer::GetHappinessPerXPopulation() const
{
	return m_iHappinessPerXPopulation;
}

//	--------------------------------------------------------------------------------
/// Set the amount of Happiness we're getting from large cities
void CvPlayer::SetHappinessPerXPopulation(int iValue)
{
	m_iHappinessPerXPopulation = iValue;
}

//	--------------------------------------------------------------------------------
/// Change the amount of Happiness we're getting from large cities
void CvPlayer::ChangeHappinessPerXPopulation(int iChange)
{
	SetHappinessPerXPopulation(m_iHappinessPerXPopulation + iChange);
}

//	--------------------------------------------------------------------------------
/// How much Happiness are we getting from large empires?
int CvPlayer::GetHappinessPerXPopulationGlobal() const
{
	return m_iHappinessPerXPopulationGlobal;
}

//	--------------------------------------------------------------------------------
/// Set the amount of Happiness we're getting from large empires
void CvPlayer::SetHappinessPerXPopulationGlobal(int iValue)
{
	m_iHappinessPerXPopulationGlobal = iValue;
}

//	--------------------------------------------------------------------------------
/// Change the amount of Happiness we're getting from large empires
void CvPlayer::ChangeHappinessPerXPopulationGlobal(int iChange)
{
	SetHappinessPerXPopulationGlobal(m_iHappinessPerXPopulationGlobal + iChange);
}
/// How much Happiness are we getting from large empires?
int CvPlayer::GetIdeologyPoint() const
{
	return m_iIdeologyPoint;
}

//	--------------------------------------------------------------------------------
/// Set the amount of Happiness we're getting from large empires
void CvPlayer::SetIdeologyPoint(int iValue)
{
	m_iIdeologyPoint = iValue;
}

//	--------------------------------------------------------------------------------

void CvPlayer::ChangeIdeologyPoint(int iChange)
{
	SetIdeologyPoint(m_iIdeologyPoint + iChange);
}



/// How much Happiness are we getting from large empires?
int CvPlayer::GetNoXPLossUnitPurchase() const
{
	return m_iNoXPLossUnitPurchase;
}

//	--------------------------------------------------------------------------------

void CvPlayer::SetNoXPLossUnitPurchase(int iValue)
{
	m_iNoXPLossUnitPurchase = iValue;
}

//	
void CvPlayer::ChangeNoXPLossUnitPurchase(int iChange)
{
	SetNoXPLossUnitPurchase(m_iNoXPLossUnitPurchase + iChange);
}


/// How much Happiness are we getting from large empires?
int CvPlayer::GetCSAlliesLowersPolicyNeedWonders() const
{
	return m_iXCSAlliesLowersPolicyNeedWonders;
}

void CvPlayer::ChangePositiveWarScoreTourismMod(int iChange)
{
	m_iPositiveWarScoreTourismMod += iChange;
}
int CvPlayer::GetPositiveWarScoreTourismMod() const
{
	return m_iPositiveWarScoreTourismMod;
}

void CvPlayer::ChangeIsNoCSDecayAtWar(int iValue)
{
	m_iIsNoCSDecayAtWar += iValue;
}
bool CvPlayer::IsNoCSDecayAtWar() const
{
	return m_iIsNoCSDecayAtWar > 0;
}
void CvPlayer::ChangeCanBullyFriendlyCS(int iValue)
{
	m_iCanBullyFriendlyCS += iValue;
}
bool CvPlayer::IsCanBullyFriendlyCS() const
{
	return m_iCanBullyFriendlyCS > 0;
}
void CvPlayer::ChangeBullyGlobalCSReduction(int iValue)
{
	m_iBullyGlobalCSReduction += iValue;
}
int CvPlayer::GetBullyGlobalCSReduction() const
{
	return m_iBullyGlobalCSReduction;
}

void CvPlayer::ChangeIsVassalsNoRebel(int iValue)
{
	m_iIsVassalsNoRebel += iValue;
}
bool CvPlayer::IsVassalsNoRebel() const
{
	return m_iIsVassalsNoRebel > 0;
}

void CvPlayer::ChangeVassalYieldBonusModifier(int iValue)
{
	m_iVassalYieldBonusModifier += iValue;
}
int CvPlayer::GetVassalYieldBonusModifier() const
{
	return m_iVassalYieldBonusModifier;
}

void CvPlayer::ChangeCSYieldBonusModifier(int iValue)
{
	m_iCSYieldBonusModifier += iValue;
}
int CvPlayer::GetCSYieldBonusModifier() const
{
	return m_iCSYieldBonusModifier;
}

//	--------------------------------------------------------------------------------
/// Change the amount of Happiness we're getting from large empires
void CvPlayer::ChangeCSAlliesLowersPolicyNeedWonders(int iChange)
{
	m_iXCSAlliesLowersPolicyNeedWonders += iChange;
}

//	--------------------------------------------------------------------------------
/// Happiness from Minors
int CvPlayer::GetHappinessFromMinorCivs() const
{
	return m_iHappinessFromMinorCivs;
}

void CvPlayer::UpdateHappinessFromMinorCivs()
{
	int iHappiness = 0;
	PlayerTypes eMinor;
	for (int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		eMinor = (PlayerTypes)iMinorLoop;
		iHappiness += GetHappinessFromMinor(eMinor);
	}
	m_iHappinessFromMinorCivs = iHappiness;
}

//	--------------------------------------------------------------------------------
/// Happiness from a Minor
int CvPlayer::GetHappinessFromMinor(PlayerTypes eMinor) const
{
	int iAmount = 0;

	if(GET_PLAYER(eMinor).isAlive())
	{
		// Includes flat bonus and any per luxury bonus
		iAmount += GET_PLAYER(eMinor).GetMinorCivAI()->GetCurrentHappinessBonus(GetID());
	}

	return iAmount;
}

//	--------------------------------------------------------------------------------
/// Happiness from Leagues
int CvPlayer::GetHappinessFromLeagues() const
{
	return m_iHappinessFromLeagues;
}

//	--------------------------------------------------------------------------------
/// Happiness from Leagues
void CvPlayer::SetHappinessFromLeagues(int iValue)
{
	m_iHappinessFromLeagues = iValue;
}

//	--------------------------------------------------------------------------------
/// Happiness from Leagues
void CvPlayer::ChangeHappinessFromLeagues(int iChange)
{
	SetHappinessFromLeagues(GetHappinessFromLeagues() + iChange);
}

//	--------------------------------------------------------------------------------
/// Get the global modifier on the espionage progress rate
int CvPlayer::GetEspionageModifier() const
{
	return m_iEspionageModifier;
}

//	--------------------------------------------------------------------------------
/// Change the global modifier on the espionage progress rate
void CvPlayer::ChangeEspionageModifier(int iChange)
{
	m_iEspionageModifier = (m_iEspionageModifier + iChange);
}

//	--------------------------------------------------------------------------------
/// At what rank do spies start the game at?
int CvPlayer::GetStartingSpyRank() const
{
	if(m_iSpyStartingRank > SPY_RANK_SPECIAL_AGENT)
	{
		return SPY_RANK_SPECIAL_AGENT;
	}
	return m_iSpyStartingRank;
}

//	--------------------------------------------------------------------------------
/// Change the rank that spies start the game at
void CvPlayer::ChangeStartingSpyRank(int iChange)
{
	m_iSpyStartingRank = (m_iSpyStartingRank + iChange);
}

#if defined(MOD_RELIGION_CONVERSION_MODIFIERS)
//	--------------------------------------------------------------------------------
/// Get the global modifier on the conversion progress rate
int CvPlayer::GetConversionModifier() const
{
	return m_iConversionModifier;
}

//	--------------------------------------------------------------------------------
/// Change the global modifier on the conversion progress rate
void CvPlayer::ChangeConversionModifier(int iChange)
{
	m_iConversionModifier = (m_iConversionModifier + iChange);
}
#endif

//	--------------------------------------------------------------------------------
/// Extra league votes
int CvPlayer::GetExtraLeagueVotes() const
{
	return m_iExtraLeagueVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from faith
int CvPlayer::GetFaithToVotes() const
{
	return m_iFaithToVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from faith
void CvPlayer::ChangeFaithToVotes(int iChange)
{
	m_iFaithToVotes = iChange;
	CvAssert(m_iFaithToVotes >= 0);
	if (m_iFaithToVotes < 0)
	{
		m_iFaithToVotes = 0;
	}
}

//	--------------------------------------------------------------------------------
/// Extra league votes from faith
int CvPlayer::TestFaithToVotes(int iChange)
{
	if (iChange <= 0)
		return 0;

	ReligionTypes eOwnedReligion = GetReligions()->GetOwnedReligion();
	if (eOwnedReligion == NO_RELIGION)
		return 0;

	CvGameReligions* pReligions = GC.getGame().GetGameReligions();
	return pReligions->GetNumCitiesFollowing(eOwnedReligion) / iChange;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from conquered capitals
int CvPlayer::GetCapitalsToVotes() const
{
	return m_iCapitalsToVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from conquered capitals
void CvPlayer::ChangeCapitalsToVotes(int iChange)
{
	m_iCapitalsToVotes = iChange;
	CvAssert(m_iCapitalsToVotes >= 0);
	if (m_iCapitalsToVotes < 0)
	{
		m_iCapitalsToVotes = 0;
	}
}

//	--------------------------------------------------------------------------------
/// Extra league votes from conquered capitals
int CvPlayer::TestCapitalsToVotes(int iChange)
{
	int iCapitalVotes = 0;

	if(iChange > 0)
	{
		iCapitalVotes = (GetNumCapitalCities() * iChange);
	}
	return iCapitalVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from Declarations of Friendship
int CvPlayer::GetDoFToVotes() const
{
	return m_iDoFToVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from Declarations of Friendship
void CvPlayer::ChangeDoFToVotes(int iChange)
{
	m_iDoFToVotes = iChange;
	CvAssert(m_iDoFToVotes >= 0);
	if (m_iDoFToVotes < 0)
	{
		m_iDoFToVotes = 0;
	}
}

//	--------------------------------------------------------------------------------
/// Extra league votes from Declarations of Friendship
int CvPlayer::TestDoFToVotes(int iChange)
{
	int iDoFToVotes = 0;
	
	if(iChange > 0)
	{
		iDoFToVotes = ((GetDiplomacyAI()->GetNumDoF() / 2) * iChange);
	}
	
	return iDoFToVotes;

}

//	--------------------------------------------------------------------------------
/// Extra league votes from Research Agreements
int CvPlayer::GetRAToVotes() const
{
	return m_iRAToVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from Research Agreements
void CvPlayer::ChangeRAToVotes(int iChange)
{
	m_iRAToVotes = iChange;
	CvAssert(m_iRAToVotes >= 0);
	if (m_iRAToVotes < 0)
	{
		m_iRAToVotes = 0;
	}
}

//	--------------------------------------------------------------------------------
/// Extra league votes from Research Agreements
int CvPlayer::TestRAToVotes(int iChange)
{
	int iRAToVotes = 0;
	
	if(iChange > 0)
	{
		iRAToVotes = (GetDiplomacyAI()->GetNumRA() * iChange);
	}
	
	return iRAToVotes;
}
//	--------------------------------------------------------------------------------
/// Extra league votes from Defense Pacts
int CvPlayer::GetDefensePactsToVotes() const
{
	return m_iDefensePactsToVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from Defense Pacts
void CvPlayer::ChangeDefensePactsToVotes(int iChange)
{
	m_iDefensePactsToVotes = iChange;
	CvAssert(m_iDefensePactsToVotes >= 0);
	if (m_iDefensePactsToVotes < 0)
	{
		m_iDefensePactsToVotes = 0;
	}
}
//	--------------------------------------------------------------------------------
/// Extra league votes from Defense Pacts
int CvPlayer::TestDefensePactsToVotes(int iChange)
{
	int iDefensePactsToVotes = 0;
	
	if(iChange > 0)
	{
		iDefensePactsToVotes = (GetDiplomacyAI()->GetNumDefensePacts() * iChange);

		if (MOD_BALANCE_VP)
		{
			iDefensePactsToVotes += GetNumVassals();
		}
	}
	
	return iDefensePactsToVotes;
}

/// Extra league votes from Religion
int CvPlayer::GetReligionVotes() const
{
	int iVotes = 0;
	const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(GetReligions()->GetStateReligion(false), m_eID);
	if (pReligion)
	{
		iVotes += CalculateReligionExtraVotes(pReligion);

		iVotes += CalculateReligionVotesFromImprovements(pReligion);
	}
	return iVotes;
}
// Religion gives extra votes based on the number of Minor Civs
int CvPlayer::CalculateReligionExtraVotes(const CvReligion *pReligion) const
{
	int iExtraVotes = pReligion->m_Beliefs.GetExtraVotes(m_eID);
	if (iExtraVotes > 0)
	{
		int iNumMinor = (GC.getGame().GetNumMinorCivsEver(true) / 8);
		if (iNumMinor > 0)
		{
			return (iExtraVotes * iNumMinor);
		}
	}
	return 0;
}

// Religion gives extra votes based on the number of certain improvements
int CvPlayer::CalculateReligionVotesFromImprovements(const CvReligion *pReligion) const
{
	int iNumImprovementInfos = GC.getNumImprovementInfos();
	
	std::pair<int, int> fTotalVotes = std::make_pair(0, 1);
	
	for (int jJ = 0; jJ < iNumImprovementInfos; jJ++)
	{
		int iNumImprovements = getImprovementCount((ImprovementTypes)jJ); // less expensive function call
		if (iNumImprovements > 0)
		{
			// number of votes per improvement (a fraction less than one)
			std::pair<int, int> fPotentialVotes = pReligion->m_Beliefs.GetVoteFromOwnedImprovement((ImprovementTypes)jJ, m_eID); // more likely to be zero
			if (fPotentialVotes.first > 0)
			{
				AddFractionToReference(fTotalVotes, std::make_pair(iNumImprovements * fPotentialVotes.first, fPotentialVotes.second));
			}
		}
	}
	return fTotalVotes.first / fTotalVotes.second;
}

//	--------------------------------------------------------------------------------
/// Extra influence from GPs
int CvPlayer::GetGPExpendInfluence() const
{
	return m_iGPExpendInfluence;
}

//	--------------------------------------------------------------------------------
/// Extra influence from GPs
void CvPlayer::ChangeGPExpendInfluence(int iChange)
{
	m_iGPExpendInfluence += iChange;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from embassy
int CvPlayer::GetImprovementLeagueVotes() const
{
	return m_iImprovementLeagueVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from embassy
void CvPlayer::ChangeImprovementLeagueVotes(int iChange)
{
	m_iImprovementLeagueVotes += iChange;
	CvAssert(m_iImprovementLeagueVotes >= 0);
	if (m_iImprovementLeagueVotes < 0)
	{
		m_iImprovementLeagueVotes = 0;
	}
}

/// League Bonuses for Poor Players
void CvPlayer::SetLeagueArt(bool bValue)
{
	if(m_bIsLeagueArt != bValue)
	{
		m_bIsLeagueArt = bValue;
	}
}

bool CvPlayer::IsLeagueArt() const
{
	return m_bIsLeagueArt;
}

/// League Bonuses for Poor Players
void CvPlayer::SetLeagueScholar(bool bValue)
{
	if(m_bIsLeagueScholar != bValue)
	{
		m_bIsLeagueScholar = bValue;
	}
}

bool CvPlayer::IsLeagueScholar() const
{
	return m_bIsLeagueScholar;
}


/// League Bonuses for Poor Players
void CvPlayer::SetLeagueAid(bool bValue)
{
	if(m_bIsLeagueAid != bValue)
	{
		m_bIsLeagueAid = bValue;
	}
}

bool CvPlayer::IsLeagueAid() const
{
	return m_bIsLeagueAid;
}

/// Process League Bonuses for Poor Players
void CvPlayer::ProcessLeagueResolutions()
{
	CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
	if(pLeague == NULL)
	{
		return;
	}
	if(IsLeagueAid())
	{
		if ( pLeague->GetArtsyGreatPersonRateModifier() > 0)
		{
			//Production and Culture
			if(AidRankGeneric(1) == GetID()) // calculate only Culture related score
			{
				// calculate modifier that is actually related to Resolution's ArtsyGreatPersonRateMod parameter
				int iScoreMod = pLeague->GetArtsyGreatPersonRateModifier() * ScoreDifferencePercent(1) / 100;
				int iLoop;
				int iAid = 0;
				for(CvCity* pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
				{
					int iAid = (iScoreMod - pLoopCity->GetTotalArtsyAid());
					if(iAid != 0)
					{
						pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_PRODUCTION, iAid);

						pLoopCity->ChangeTotalArtsyAid(iAid);
					}

				}
				iAid = iScoreMod - GetLeagueCultureCityModifier();
				if(iAid != 0)
				{
					ChangeLeagueCultureCityModifier(iAid);
				}
			}
			//Remove bonuses from filty first-worlders.
			if(AidRankGeneric(1) != GetID()) // calculate only Culture related score
			{
				int iLoop;
				for(CvCity* pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
				{
					if(pLoopCity->GetTotalArtsyAid() != 0)
					{

						pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_PRODUCTION, pLoopCity->GetTotalArtsyAid() * -1);

						pLoopCity->SetTotalArtsyAid(0);
					}
				}
				if(GetLeagueCultureCityModifier() != 0)
				{
					ChangeLeagueCultureCityModifier(GetLeagueCultureCityModifier() * -1);
				}
			}
		}
		else if (pLeague && pLeague->GetScienceyGreatPersonRateModifier() > 0)
		{
			//Food and Research
			if(AidRankGeneric(2) == GetID()) // calculate only Research related score
			{
				// calculate modifier that is actually related to Resolution's ScienceyGreatPersonRateMod parameter
				int iScoreMod = pLeague->GetScienceyGreatPersonRateModifier() * ScoreDifferencePercent(2) / 100;
				int iLoop;
				int iAid = 0;
				for(CvCity* pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
				{
					iAid = (iScoreMod - pLoopCity->GetTotalScienceyAid());
					if(iAid != 0)
					{
						pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_FOOD, iAid);

						pLoopCity->ChangeTotalScienceyAid(iAid);
					}
				}
				//Global
				iAid = (iScoreMod - GetScienceRateFromLeagueAid());
				if(iAid != 0)
				{
					ChangeScienceRateFromLeagueAid(iAid);
				}
			}
			//Remove bonuses from filty first-worlders.
			if(AidRankGeneric(2) != GetID()) // calculate only Research related score
			{
				int iLoop;
				for(CvCity* pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
				{
					if(pLoopCity->GetTotalScienceyAid() != 0)
					{	
						pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_FOOD, (pLoopCity->GetTotalScienceyAid() * -1));

						pLoopCity->SetTotalScienceyAid(0);
					}
				}
				//Global
				if(GetScienceRateFromLeagueAid() != 0)
				{
					ChangeScienceRateFromLeagueAid(GetScienceRateFromLeagueAid() * -1);
				}
			}
		}
	}
	else if(!IsLeagueAid())
	{
		int iLoop;
		for(CvCity* pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
		{
			if(pLoopCity->GetTotalScienceyAid() != 0)
			{	
				pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_FOOD, (pLoopCity->GetTotalScienceyAid() * -1));

				pLoopCity->SetTotalScienceyAid(0);
			}
			if(pLoopCity->GetTotalArtsyAid() != 0)
			{
				pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_PRODUCTION, pLoopCity->GetTotalArtsyAid() * -1);

				pLoopCity->SetTotalArtsyAid(0);
			}
		}
		//Global
		if(GetScienceRateFromLeagueAid() != 0)
		{
			ChangeScienceRateFromLeagueAid(GetScienceRateFromLeagueAid() * -1);
		}
		if(GetLeagueCultureCityModifier() != 0)
		{
			ChangeLeagueCultureCityModifier(GetLeagueCultureCityModifier() * -1);
		}
	}
	if(IsLeagueArt())
	{
		//Extra Science From League (Art)
		if(pLeague->GetWorldWonderYieldChange(YIELD_CULTURE) > 0)
		{
			int iLoop;
			for(CvCity* pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
			{
				int iSciencePerWork = GET_PLAYER(GetID()).GetGreatWorkYieldChange(YIELD_SCIENCE);
				int iTotalScienceFromArt = (pLoopCity->GetCityCulture()->GetNumGreatWorks() * iSciencePerWork);
				int iAid = iTotalScienceFromArt - pLoopCity->GetBaseYieldRateFromLeague(YIELD_SCIENCE);
				if(iAid != 0)
				{
					pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_SCIENCE, iAid);
				}
			}
		}
	}
	else if(!IsLeagueArt())
	{
		int iLoop;
		for(CvCity* pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
		{
			if(pLoopCity->GetBaseYieldRateFromLeague(YIELD_SCIENCE) != 0)
			{
				pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_SCIENCE, (pLoopCity->GetBaseYieldRateFromLeague(YIELD_SCIENCE) * -1));
			}
		}
	}
}

//	League Bonuses for Poor Players - modified version of CvPlayer::AidRank()
//	Calculates if the player is below median score depending on type of score
//	eType 0 total score, 1 art, 2 science
PlayerTypes CvPlayer::AidRankGeneric(int eType)
{
	int iRank = 0;
	int iMajorCivs = 0;
	CvWeightedVector<PlayerTypes> veMajorRankings;
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		CvPlayer* pMajorLoop = &GET_PLAYER(eLoopPlayer);
	
		if(pMajorLoop->isAlive() && !pMajorLoop->isMinorCiv())
		{
			switch(eType)
			{
			case 1:
				iRank = pMajorLoop->GetScoreFromPolicies() + pMajorLoop->GetScoreFromGreatWorks();
				break;
			case 2:
				iRank = pMajorLoop->GetScoreFromTechs() + pMajorLoop->GetScoreFromFutureTech();
				break;
			default:
				iRank = pMajorLoop->GetScore();
			}
			if(iRank > 0)
			{
				veMajorRankings.push_back(eLoopPlayer, iRank);
				iMajorCivs++;
			}
		}
	}

	//Find the median of the Civs.
	int iTopTier = (iMajorCivs / 2);
	if(iTopTier <= 0)
	{
		iTopTier = 1;
	}

	veMajorRankings.SortItems();
	if(veMajorRankings.size() != 0)
	{
		for(int iRanking = 0; iRanking < veMajorRankings.size(); iRanking++)
		{
			if(veMajorRankings.GetElement(iRanking) == GetID())
			{
				//Are we in the bottom 50% of Civs? If so, we need aid!
				if(iRanking >= iTopTier)
				{
					return GetID();
				}
			}
		}
	}
	return NO_PLAYER;
}

/// League Bonuses for Poor Players
PlayerTypes CvPlayer::AidRank()
{
	return AidRankGeneric();
}

//	League Bonuses for Poor Players - modified version of CvPlayer::ScoreDifference()
//	Calculates difference between player's score and best score using percentage scale
//	0% - best score, 100% - worst score
int CvPlayer::ScoreDifferencePercent(int eType)
{
	int iScore = 0;
	int iBestScore = 0;
	int iWorstScore = INT_MAX;
	int iPlayerScore = 0;
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		CvPlayer* pMajorLoop = &GET_PLAYER(eLoopPlayer);
		if(pMajorLoop->isAlive() && !pMajorLoop->isMinorCiv())
		{
			switch(eType)
			{
			case 1:
				iScore = pMajorLoop->GetScoreFromPolicies() + pMajorLoop->GetScoreFromGreatWorks();
				break;
			case 2:
				iScore = pMajorLoop->GetScoreFromTechs() + pMajorLoop->GetScoreFromFutureTech();
				break;
			default:
				iScore = pMajorLoop->GetScore();
			}
			if(iScore > iBestScore) iBestScore = iScore;
			if(iScore < iWorstScore) iWorstScore = iScore;
			if(GetID() == eLoopPlayer) iPlayerScore = iScore;
		}
	}
	if(iBestScore == 0) return 0; // nothing to scale
	// rescale to 0..100
	return MapToPercent(iPlayerScore, iBestScore, iWorstScore);
}

/// League Bonuses for Poor Players
int CvPlayer::ScoreDifference()
{
	int iScore = 0;
	int iBestScore = 0;
	int iMajors = 0;
	int iPlayerScore = 0;
	int iDifference = 0;
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		CvPlayer* pMajorLoop = &GET_PLAYER(eLoopPlayer);

		if(pMajorLoop->isAlive() && !pMajorLoop->isMinorCiv())
		{
			iScore = pMajorLoop->GetScore();
			iMajors++;

			if(iScore > iBestScore)
			{
				iBestScore = iScore;
			}
		}
	}
	if(iBestScore > 0)
	{
		iPlayerScore = GET_PLAYER(GetID()).GetScore();
		iDifference = iBestScore - iPlayerScore;
		int iMax = /*30*/ GD_INT_GET(LEAGUE_AID_MAX);
		int iMin = iMax/3;

		//Bring down to % value.
		iDifference /= 50;
		//Never lower than 10%
		if(iDifference < iMin)
		{
			iDifference = iMin;
		}
		//Never higher than 30%
		if(iDifference > iMax)
		{
			iDifference = iMax;
		}
	}
	return iDifference;
}

//	--------------------------------------------------------------------------------
/// Extra science from CS
int CvPlayer::GetScienceRateFromMinorAllies() const
{
	return m_iScienceRateFromLeague;
}

//	--------------------------------------------------------------------------------
/// Extra science from CS
void CvPlayer::ChangeScienceRateFromMinorAllies(int iChange)
{
	SetScienceRateFromMinorAllies(GetScienceRateFromMinorAllies() + iChange);
}

/// Extra science from CS
void CvPlayer::SetScienceRateFromMinorAllies(int iValue)
{
	if(GetScienceRateFromMinorAllies() != iValue)
		m_iScienceRateFromLeague = iValue;
}

//	--------------------------------------------------------------------------------
/// Extra science from aid
int CvPlayer::GetScienceRateFromLeagueAid() const
{
	return m_iScienceRateFromLeagueAid;
}

//	--------------------------------------------------------------------------------
/// Extra science from aid
void CvPlayer::ChangeScienceRateFromLeagueAid(int iChange)
{
	SetScienceRateFromLeagueAid(GetScienceRateFromLeagueAid() + iChange);
}
//	--------------------------------------------------------------------------------
/// Extra science from aid
void CvPlayer::SetScienceRateFromLeagueAid(int iValue)
{
	if(GetScienceRateFromLeagueAid() != iValue)
		m_iScienceRateFromLeagueAid = iValue;
}

//	--------------------------------------------------------------------------------
/// Extra league votes
void CvPlayer::ChangeExtraLeagueVotes(int iChange)
{
	m_iExtraLeagueVotes += iChange;
	CvAssert(m_iExtraLeagueVotes >= 0);
	if (m_iExtraLeagueVotes < 0)
	{
		m_iExtraLeagueVotes = 0;
	}
}

//	--------------------------------------------------------------------------------
/// How much weaker do Units get when wounded?
int CvPlayer::GetWoundedUnitDamageMod() const
{
	return m_iWoundedUnitDamageMod;
}

//	--------------------------------------------------------------------------------
/// How much weaker do Units get when wounded?
void CvPlayer::SetWoundedUnitDamageMod(int iValue)
{
	m_iWoundedUnitDamageMod = iValue;

	if (m_iWoundedUnitDamageMod < /*-33*/ -GD_INT_GET(WOUNDED_DAMAGE_MULTIPLIER))
	{
		m_iWoundedUnitDamageMod = -GD_INT_GET(WOUNDED_DAMAGE_MULTIPLIER);
	}
}

//	--------------------------------------------------------------------------------
/// How much weaker do Units get when wounded?
void CvPlayer::ChangeWoundedUnitDamageMod(int iChange)
{
	SetWoundedUnitDamageMod(m_iWoundedUnitDamageMod + iChange);
}

//	--------------------------------------------------------------------------------
/// Unit upgrade cost mod
int CvPlayer::GetUnitUpgradeCostMod() const
{
	return m_iUnitUpgradeCostMod;
}

//	--------------------------------------------------------------------------------
/// Unit upgrade cost mod
void CvPlayer::SetUnitUpgradeCostMod(int iValue)
{
	m_iUnitUpgradeCostMod = iValue;

	if (m_iUnitUpgradeCostMod < /*-75 in CP, -99 in VP*/ GD_INT_GET(UNIT_UPGRADE_COST_DISCOUNT_MAX))
		m_iUnitUpgradeCostMod = GD_INT_GET(UNIT_UPGRADE_COST_DISCOUNT_MAX);
}

//	--------------------------------------------------------------------------------
/// Unit upgrade cost mod
void CvPlayer::ChangeUnitUpgradeCostMod(int iChange)
{
	SetUnitUpgradeCostMod(m_iUnitUpgradeCostMod + iChange);
}

//	--------------------------------------------------------------------------------
/// How much of a combat bonus do we get VS Barbarian Units?
int CvPlayer::GetBarbarianCombatBonus(bool bIgnoreHandicap) const
{
	int iRtnValue = m_iBarbarianCombatBonus;

	// Hacky solution for human handicap bonus since LUA is annoying
	if (!bIgnoreHandicap && isHuman())
	{
		iRtnValue += getHandicapInfo().getBarbarianCombatModifier();
	}

	return iRtnValue;
}

//	--------------------------------------------------------------------------------
/// Sets how much of a combat bonus we get VS Barbarian Units
void CvPlayer::SetBarbarianCombatBonus(int iValue)
{
	m_iBarbarianCombatBonus = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes how much of a combat bonus we get VS Barbarian Units
void CvPlayer::ChangeBarbarianCombatBonus(int iChange)
{
	SetBarbarianCombatBonus(m_iBarbarianCombatBonus + iChange);
}

//	--------------------------------------------------------------------------------
/// Do we always see where Barb Camps appear?
bool CvPlayer::IsAlwaysSeeBarbCamps() const
{
	return m_iAlwaysSeeBarbCampsCount > 0;
}

//	--------------------------------------------------------------------------------
/// Sets if we always see where Barb Camps appear
void CvPlayer::SetAlwaysSeeBarbCampsCount(int iValue)
{
	m_iAlwaysSeeBarbCampsCount = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes if we always see where Barb Camps appear
void CvPlayer::ChangeAlwaysSeeBarbCampsCount(int iChange)
{
	SetAlwaysSeeBarbCampsCount(m_iAlwaysSeeBarbCampsCount + iChange);
}

//	--------------------------------------------------------------------------------
CvPlayerTechs* CvPlayer::GetPlayerTechs() const
{
	return m_pPlayerTechs;
}

//	--------------------------------------------------------------------------------
CvPlayerPolicies* CvPlayer::GetPlayerPolicies() const
{
	return m_pPlayerPolicies;
}

//	--------------------------------------------------------------------------------
CvPlayerTraits* CvPlayer::GetPlayerTraits() const
{
	return m_pTraits;
}

//	--------------------------------------------------------------------------------
CvFlavorManager* CvPlayer::GetFlavorManager() const
{
	return m_pFlavorManager;
}

//	--------------------------------------------------------------------------------
CvTacticalAI* CvPlayer::GetTacticalAI() const
{
	return m_pTacticalAI;
}

//	--------------------------------------------------------------------------------
CvHomelandAI* CvPlayer::GetHomelandAI() const
{
	return m_pHomelandAI;
}

bool CvPlayer::grantPolicy(PolicyTypes iPolicy, bool bFree)
{
	if (!HasPolicy(iPolicy)) {
		setHasPolicy(iPolicy, true, bFree);
		
		return true;
	}
	
	return false;
}

bool CvPlayer::revokePolicy(PolicyTypes iPolicy)
{
	if (HasPolicy(iPolicy)) {
		setHasPolicy(iPolicy, false, m_pPlayerPolicies->IsFreePolicy(iPolicy));
		
		return true;
	}
	
	return false;
}

bool CvPlayer::swapPolicy(PolicyTypes iNewPolicy, PolicyTypes iOldPolicy)
{
	bool bWasFree = m_pPlayerPolicies->IsFreePolicy(iOldPolicy);
	
	if (!HasPolicy(iNewPolicy) && revokePolicy(iOldPolicy)) {
		return grantPolicy(iNewPolicy, bWasFree);
	}
	
	return false;
}

//	--------------------------------------------------------------------------------
void CvPlayer::setHasPolicy(PolicyTypes eIndex, bool bNewValue, bool bFree)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumPolicyInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	
	if(m_pPlayerPolicies->HasPolicy(eIndex) != bNewValue)
	{
		m_pPlayerPolicies->SetPolicy(eIndex, bNewValue, bFree);
		processPolicies(eIndex, bNewValue ? 1 : -1);
		GetPlayerPolicies()->ClearCache();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNextPolicyCost() const
{
	return m_iCostNextPolicy;
}

//	--------------------------------------------------------------------------------
void CvPlayer::DoUpdateNextPolicyCost()
{
	m_iCostNextPolicy = GetPlayerPolicies()->GetNextPolicyCost();
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canAdoptPolicy(PolicyTypes eIndex) const
{
	return GetPlayerPolicies()->CanAdoptPolicy(eIndex);
}

//	--------------------------------------------------------------------------------
void CvPlayer::doAdoptPolicy(PolicyTypes ePolicy)
{
	CvPolicyEntry* pkPolicyInfo = GC.getPolicyInfo(ePolicy);
	CvAssert(pkPolicyInfo != NULL);
	if(pkPolicyInfo == NULL)
		return;

	// Can we actually adopt this?
	if(!canAdoptPolicy(ePolicy))
		return;

	bool bTenet = pkPolicyInfo->GetLevel() > 0;

	// Pay Culture cost - if applicable
	if (bTenet && GetNumFreeTenets() > 0)
	{
		ChangeNumFreeTenets(-1, false);
	}
	else if (GetNumFreePolicies() > 0)
	{
		ChangeNumFreePolicies(-1);
	}
	else
	{
		changeJONSCulture(-getNextPolicyCost());
	}

	setHasPolicy(ePolicy, true);

	// Update cost if trying to buy another policy this turn
	DoUpdateNextPolicyCost();

	// Branch unlocked
	PolicyBranchTypes ePolicyBranch = (PolicyBranchTypes) pkPolicyInfo->GetPolicyBranchType();
	GetPlayerPolicies()->SetPolicyBranchUnlocked(ePolicyBranch, true, false);

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	// This Dirty bit must only be set when changing something for the active player
	if(GC.getGame().getActivePlayer() == GetID())
	{
		GC.GetEngineUserInterface()->setDirty(Policies_DIRTY_BIT, true);
	}
#if defined(MOD_BALANCE_CORE)
	CvCity* pCapital = getCapitalCity();
	int iPolicyGEorGM = GetPlayerTraits()->GetPolicyGEorGM();
	if (iPolicyGEorGM > 0 && pCapital != NULL)
	{
		doPolicyGEorGM(iPolicyGEorGM);
	}
	int iLoop;
	doInstantYield(INSTANT_YIELD_TYPE_POLICY_UNLOCK, false, NO_GREATPERSON, NO_BUILDING, 0, false);
	doInstantGreatPersonProgress(INSTANT_YIELD_TYPE_POLICY_UNLOCK);

	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) 
	{
		pLoopCity->GetCityCitizens()->SetDirty(true);
	}
#endif

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(ePolicy);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		LuaSupport::CallHook(pkScriptSystem, "PlayerAdoptPolicy", args.get(), bResult);
	}

	updateYield();		// Policies can change the yield
}

//	--------------------------------------------------------------------------------
/// Empire in Anarchy?
bool CvPlayer::IsAnarchy() const
{
	return GetAnarchyNumTurns() > 0;
}

//	--------------------------------------------------------------------------------
/// Empire in Anarchy?
int CvPlayer::GetAnarchyNumTurns() const
{
	return m_iAnarchyNumTurns;
}

//	--------------------------------------------------------------------------------
/// Empire in Anarchy?
void CvPlayer::SetAnarchyNumTurns(int iValue)
{
	if(iValue != GetAnarchyNumTurns())
	{
		if (iValue > 0 && m_iAnarchyNumTurns <= 0)
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerAnarchy, GetID(), true, iValue);
		else if (iValue <= 0 && GetAnarchyNumTurns() > 0)
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerAnarchy, GetID(), false, 0);

		m_iAnarchyNumTurns = iValue;

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Empire in Anarchy?
void CvPlayer::ChangeAnarchyNumTurns(int iChange)
{
	SetAnarchyNumTurns(GetAnarchyNumTurns() + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getAdvancedStartPoints() const
{
	return m_iAdvancedStartPoints;
}

//	--------------------------------------------------------------------------------
void CvPlayer::setAdvancedStartPoints(int iNewValue)
{
	if(getAdvancedStartPoints() != iNewValue)
	{
		m_iAdvancedStartPoints = iNewValue;

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(MiscButtons_DIRTY_BIT, true);
			GC.GetEngineUserInterface()->setDirty(SelectionButtons_DIRTY_BIT, true);
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeAdvancedStartPoints(int iChange)
{
	setAdvancedStartPoints(getAdvancedStartPoints() + iChange);
}


//	--------------------------------------------------------------------------------
// Get Attack Bonus for a certain period of time
int CvPlayer::GetAttackBonusTurns() const
{
	return m_iAttackBonusTurns;
}

//	--------------------------------------------------------------------------------
// Set Attack Bonus for a certain period of time
void CvPlayer::ChangeAttackBonusTurns(int iChange)
{
	if(iChange != 0)
	{
		m_iAttackBonusTurns += iChange;
	}
}

//	--------------------------------------------------------------------------------
// Get Culture Bonus for a certain period of time
int CvPlayer::GetCultureBonusTurns() const
{
	return m_iCultureBonusTurns;
}

//	--------------------------------------------------------------------------------
// Set Culture Bonus for a certain period of time
void CvPlayer::ChangeCultureBonusTurns(int iChange)
{
	if (iChange != 0)
	{
		m_iCultureBonusTurns += iChange;
	}
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
// Get Culture Bonus for a certain period of time
int CvPlayer::GetCultureBonusTurnsConquest() const
{
	return m_iCultureBonusTurnsConquest;
}

//	--------------------------------------------------------------------------------
// Set Culture Bonus for a certain period of time
void CvPlayer::ChangeCultureBonusTurnsConquest(int iChange)
{
	if (iChange != 0)
	{
		m_iCultureBonusTurnsConquest += iChange;
	}
}

//	--------------------------------------------------------------------------------
// Get Culture Bonus for a certain period of time
int CvPlayer::GetProductionBonusTurnsConquest() const
{
	return m_iProductionBonusTurnsConquest;
}

//	--------------------------------------------------------------------------------
// Set Culture Bonus for a certain period of time
void CvPlayer::ChangeProductionBonusTurnsConquest(int iChange)
{
	if (iChange != 0)
	{
		m_iProductionBonusTurnsConquest += iChange;
	}
}
#endif
//	--------------------------------------------------------------------------------
// Get Tourism Bonus for a certain period of time
int CvPlayer::GetTourismBonusTurns() const
{
	return m_iTourismBonusTurns;
}

//	--------------------------------------------------------------------------------
// Set Tourism Bonus for a certain period of time
void CvPlayer::ChangeTourismBonusTurns(int iChange)
{
	if (iChange != 0)
	{
		m_iTourismBonusTurns += iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getTourismBonusTurnsPlayer(PlayerTypes eWithPlayer) const
{
	CvAssertMsg(eWithPlayer >= 0, "eFromPlayer is expected to be non-negative (invalid Index)");
	CvAssertMsg(eWithPlayer < MAX_PLAYERS, "eFromPlayer is expected to be within maximum bounds (invalid Index)");

	return m_aiTourismBonusTurnsPlayer[eWithPlayer];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeTourismBonusTurnsPlayer(PlayerTypes eWithPlayer, int iChange)
{
	CvAssertMsg(eWithPlayer >= 0, "eFromPlayer is expected to be non-negative (invalid Index)");
	CvAssertMsg(eWithPlayer < MAX_PLAYERS, "eFromPlayer is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiTourismBonusTurnsPlayer[eWithPlayer] = m_aiTourismBonusTurnsPlayer[eWithPlayer] + iChange;
		CvAssert(getTourismBonusTurnsPlayer(eWithPlayer) >= 0);
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::DoProcessVotes()
{
	if(GC.getGame().isOption(GAMEOPTION_NO_LEAGUES))
	{
		return;
	}
	ChangeFaithToVotes(0);
	ChangeCapitalsToVotes(0);
	ChangeDoFToVotes(0);
	ChangeRAToVotes(0);
	ChangeDefensePactsToVotes(0);

	// Minors and Barbs don't matter
	if(!isMinorCiv() && !isBarbarian())
	{
		// Loop through Cities
		int iLoop;
		for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
			{
				const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
				CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
			
				// Has this Building
				if(pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
				{
					if(pkBuildingInfo->GetFaithToVotes() > 0)
					{
						int iTestFaith = TestFaithToVotes(pkBuildingInfo->GetFaithToVotes());
						ChangeFaithToVotes(iTestFaith);
					}
					if(pkBuildingInfo->GetCapitalsToVotes() > 0)
					{
						int iTestCapital = TestCapitalsToVotes(pkBuildingInfo->GetCapitalsToVotes());
						ChangeCapitalsToVotes(iTestCapital);	
					}
					if(pkBuildingInfo->GetDoFToVotes() > 0)
					{
						int iTestDoF = TestDoFToVotes(pkBuildingInfo->GetDoFToVotes());
						ChangeDoFToVotes(iTestDoF);
					}
					if(pkBuildingInfo->GetRAToVotes() > 0)
					{
						int iTestRA = TestRAToVotes(pkBuildingInfo->GetRAToVotes());
						ChangeRAToVotes(iTestRA);
					}
					if(pkBuildingInfo->GetDPToVotes() > 0)
					{
						int iTestDP = TestDefensePactsToVotes(pkBuildingInfo->GetDPToVotes());
						ChangeDefensePactsToVotes(iTestDP);
					}
				}
			}
		}
	}
}

#if defined(MOD_BALANCE_CORE_YIELDS)
void CvPlayer::DoChangeGreatGeneralRate()
{
	//Check for buildings and beliefs that add Great General points.
	int iLoop;
	int iGreatGeneralPoints = 0;

	UnitClassTypes eUnitClassGeneral = (UnitClassTypes)GC.getInfoTypeForString("UNITCLASS_GREAT_GENERAL");
	GreatPersonTypes eGreatPerson = GetGreatPersonFromUnitClass(eUnitClassGeneral);
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			iGreatGeneralPoints += pLoopCity->getYieldRate(YIELD_GREAT_GENERAL_POINTS, false);

			const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(pLoopCity->GetCityReligions()->GetReligiousMajority(), pLoopCity->getOwner());
			BeliefTypes eSecondaryPantheon = NO_BELIEF;
			if(pReligion)
			{
				int iReligionYieldChange = pReligion->m_Beliefs.GetCityYieldChange(pLoopCity->getPopulation(), YIELD_GREAT_GENERAL_POINTS, GetID(), pLoopCity);
				if(iReligionYieldChange > 0)
				{
					iGreatGeneralPoints += iReligionYieldChange;
				}
				eSecondaryPantheon = pLoopCity->GetCityReligions()->GetSecondaryReligionPantheonBelief();
				if (eSecondaryPantheon != NO_BELIEF && pLoopCity->getPopulation() >= GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetMinPopulation())
				{
					iReligionYieldChange = GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetCityYieldChange(YIELD_GREAT_GENERAL_POINTS);
					if(iReligionYieldChange > 0)
					{
						iGreatGeneralPoints += iReligionYieldChange;
					}
				}
				if (eGreatPerson != NO_GREATPERSON)
				{
					iGreatGeneralPoints += pReligion->m_Beliefs.GetGreatPersonPoints(eGreatPerson, pLoopCity->getOwner(), pLoopCity, true);
				}
			}

#if defined(MOD_RELIGION_PERMANENT_PANTHEON)
			// mod for civs keeping their pantheon belief forever
			if (MOD_RELIGION_PERMANENT_PANTHEON)
			{
				if (GC.getGame().GetGameReligions()->HasCreatedPantheon(pLoopCity->getOwner()))
				{
					const CvReligion* pPantheon = GC.getGame().GetGameReligions()->GetReligion(RELIGION_PANTHEON, pLoopCity->getOwner());
					BeliefTypes ePantheon = GC.getGame().GetGameReligions()->GetBeliefInPantheon(pLoopCity->getOwner());
					if (pPantheon != NULL && ePantheon != NO_BELIEF && ePantheon != eSecondaryPantheon)
					{
						if (pReligion == NULL || (pReligion != NULL && !pReligion->m_Beliefs.IsPantheonBeliefInReligion(ePantheon, pLoopCity->GetCityReligions()->GetReligiousMajority(), pLoopCity->getOwner()))) // check that the our religion does not have our belief, to prevent double counting
						{
							iGreatGeneralPoints += MAX(0, pPantheon->m_Beliefs.GetCityYieldChange(pLoopCity->getPopulation(), YIELD_GREAT_GENERAL_POINTS, GetID(), pLoopCity));

							if (eGreatPerson != NO_GREATPERSON)
							{
								iGreatGeneralPoints += pPantheon->m_Beliefs.GetGreatPersonPoints(eGreatPerson, pLoopCity->getOwner(), pLoopCity, true);
							}
						}
					}
				}
			}
#endif
		}
	}
	//Check for policies that add Great General points.
	for(int iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)
	{
		PolicyTypes pPolicy = (PolicyTypes)iPolicyLoop;
		CvPolicyEntry* pkPolicyInfo = GC.getPolicyInfo(pPolicy);
		if(pkPolicyInfo)
		{
			if(GetPlayerPolicies()->HasPolicy(pPolicy) && !GetPlayerPolicies()->IsPolicyBlocked(pPolicy))
			{
				if(pkPolicyInfo->GetCityYieldChange(YIELD_GREAT_GENERAL_POINTS) > 0)
				{
					for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if(pLoopCity != NULL)
						{
							iGreatGeneralPoints += pkPolicyInfo->GetCityYieldChange(YIELD_GREAT_GENERAL_POINTS);
						}
					}
				}
			}
		}
	}

	changeCombatExperienceTimes100(iGreatGeneralPoints * 100);
}
void CvPlayer::DoChangeGreatAdmiralRate()
{
	//Check for buildings and beliefs that add Great General points.
	int iLoop;
	int iGreatAdmiralPoints = 0;

	UnitClassTypes eUnitClassAdmiral = (UnitClassTypes)GC.getInfoTypeForString("UNITCLASS_GREAT_ADMIRAL");
	GreatPersonTypes eGreatPerson = GetGreatPersonFromUnitClass(eUnitClassAdmiral);

	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			iGreatAdmiralPoints += pLoopCity->getYieldRate(YIELD_GREAT_ADMIRAL_POINTS, false);
			
			const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(pLoopCity->GetCityReligions()->GetReligiousMajority(), pLoopCity->getOwner());
			BeliefTypes eSecondaryPantheon = NO_BELIEF;
			if(pReligion)
			{
				int iReligionYieldChange = pReligion->m_Beliefs.GetCityYieldChange(pLoopCity->getPopulation(), YIELD_GREAT_ADMIRAL_POINTS, GetID(), pLoopCity);
				if(iReligionYieldChange > 0)
				{
					iGreatAdmiralPoints += iReligionYieldChange;
				}
				eSecondaryPantheon = pLoopCity->GetCityReligions()->GetSecondaryReligionPantheonBelief();
				if (eSecondaryPantheon != NO_BELIEF && pLoopCity->getPopulation() >= GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetMinPopulation())
				{
					iReligionYieldChange = GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetCityYieldChange(YIELD_GREAT_ADMIRAL_POINTS);
					if(iReligionYieldChange > 0)
					{
						iGreatAdmiralPoints += iReligionYieldChange;
					}
				}

				if (eGreatPerson != NO_GREATPERSON)
				{
					iGreatAdmiralPoints += pReligion->m_Beliefs.GetGreatPersonPoints(eGreatPerson, pLoopCity->getOwner(), pLoopCity, true);
				}
			}

#if defined(MOD_RELIGION_PERMANENT_PANTHEON)
			// mod for civs keeping their pantheon belief forever
			if (MOD_RELIGION_PERMANENT_PANTHEON)
			{
				if (GC.getGame().GetGameReligions()->HasCreatedPantheon(pLoopCity->getOwner()))
				{
					const CvReligion* pPantheon = GC.getGame().GetGameReligions()->GetReligion(RELIGION_PANTHEON, pLoopCity->getOwner());
					BeliefTypes ePantheon = GC.getGame().GetGameReligions()->GetBeliefInPantheon(pLoopCity->getOwner());
					if (pPantheon != NULL && ePantheon != NO_BELIEF && ePantheon != eSecondaryPantheon)
					{
						if (pReligion == NULL || (pReligion != NULL && !pReligion->m_Beliefs.IsPantheonBeliefInReligion(ePantheon, pLoopCity->GetCityReligions()->GetReligiousMajority(), pLoopCity->getOwner()))) // check that the our religion does not have our belief, to prevent double counting
						{
							iGreatAdmiralPoints += MAX(0, pPantheon->m_Beliefs.GetCityYieldChange(pLoopCity->getPopulation(), YIELD_GREAT_ADMIRAL_POINTS, GetID(), pLoopCity));

							if (eGreatPerson != NO_GREATPERSON)
							{
								iGreatAdmiralPoints += pPantheon->m_Beliefs.GetGreatPersonPoints(eGreatPerson, pLoopCity->getOwner(), pLoopCity, true);
							}
						}
					}
				}
			}
#endif
		}
	}
	//Check for policies that add Great Admiral points.
	for(int iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)
	{
		PolicyTypes pPolicy = (PolicyTypes)iPolicyLoop;
		CvPolicyEntry* pkPolicyInfo = GC.getPolicyInfo(pPolicy);
		if(pkPolicyInfo)
		{
			if(GetPlayerPolicies()->HasPolicy(pPolicy) && !GetPlayerPolicies()->IsPolicyBlocked(pPolicy))
			{
				if (pkPolicyInfo->GetCityYieldChange(YIELD_GREAT_ADMIRAL_POINTS) > 0)
				{
					for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if(pLoopCity != NULL)
						{
							iGreatAdmiralPoints += pkPolicyInfo->GetCityYieldChange(YIELD_GREAT_ADMIRAL_POINTS);
						}
					}
				}
			}
		}
	}

	changeNavalCombatExperienceTimes100(iGreatAdmiralPoints * 100);
}
#endif
//	--------------------------------------------------------------------------------
/// Update all Golden-Age related stuff
void CvPlayer::DoProcessGoldenAge()
{
	if(GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS))
	{
		return;
	}

	// Minors and Barbs can't get GAs
	if(!isMinorCiv() && !isBarbarian())
	{
		// Already in a GA - don't decrement counter while in Anarchy
		if(getGoldenAgeTurns() > 0)
		{
			if(!IsAnarchy())
			{
				changeGoldenAgeTurns(-1);
			}
		}
#if defined(MOD_BALANCE_CORE)
		if (MOD_BALANCE_CORE_HAPPINESS_NATIONAL || getGoldenAgeTurns() <= 0)
#else
		// Not in GA
		else
		{
#endif
			// Note: This will actually REDUCE the GA meter if the player is running in the red
			ChangeGoldenAgeProgressMeter(GetHappinessForGAP());
			ChangeGoldenAgeProgressMeter(GetGoldenAgePointsFromEmpire());
#if defined(MOD_BALANCE_CORE)
			if(getGoldenAgeTurns() <= 0)
			{
#endif
			// Enough GA Progress to trigger new GA?
			if(GetGoldenAgeProgressMeter() >= GetGoldenAgeProgressThreshold())
			{
				int iOverflow = GetGoldenAgeProgressMeter() - GetGoldenAgeProgressThreshold();
#if defined(MOD_BALANCE_CORE)
#endif
				SetGoldenAgeProgressMeter(iOverflow);
				
				changeGoldenAgeTurns(getGoldenAgeLength());

				// If it's the active player then show the popup
				if(GetID() == GC.getGame().getActivePlayer())
				{
					// Don't show in MP
					if(!GC.getGame().isNetworkMultiPlayer())	// KWG: Candidate for !GC.getGame().isOption(GAMEOPTION_SIMULTANEOUS_TURNS)
					{
						CvPopupInfo kPopupInfo(BUTTONPOPUP_GOLDEN_AGE_REWARD);
						GC.GetEngineUserInterface()->AddPopup(kPopupInfo);
					}
				}
			}
#if defined(MOD_BALANCE_CORE)
			}
#endif
#if !defined(MOD_BALANCE_CORE)
		}
#endif
	}
}
#if defined(MOD_BALANCE_CORE)
int CvPlayer::GetGoldenAgePointsFromEmpire()
{
	int iGAPoints = 0;
	// GA points from religion
	iGAPoints += GetYieldPerTurnFromReligion(YIELD_GOLDEN_AGE_POINTS);

	// Trait bonus which adds GA points for trade partners? 
	iGAPoints +=  GetYieldPerTurnFromTraits(YIELD_GOLDEN_AGE_POINTS);

	iGAPoints += GetGoldenAgePointsFromCities();

	if (MOD_BALANCE_CORE_JFD)
	{
		iGAPoints += GetYieldPerTurnFromMinors(YIELD_GOLDEN_AGE_POINTS);
	}

	return iGAPoints;
}

int CvPlayer::GetGoldenAgePointsFromCities()
{
	int iGAPoints = 0;
	// Add in all the GA points from city yields
	int iLoop;
	int iYield = 0;
	int iCityYield = 0;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iGAPoints += pLoopCity->getYieldRate(YIELD_GOLDEN_AGE_POINTS, false);
		if (GetPlayerTraits()->GetTourismToGAP() > 0)
		{
			iCityYield += pLoopCity->GetBaseTourism();
		}
	}

	iCityYield /= 100;
	iYield += iCityYield;
	if (GetPlayerTraits()->GetGoldToGAP() > 0)
	{
		iYield += GetTreasury()->CalculateBaseNetGold();
	}
	iYield *= (GetPlayerTraits()->GetTourismToGAP() + GetPlayerTraits()->GetGoldToGAP());
	iYield /= 100;
	if (iYield > 0)
	{
		iGAPoints += iYield;
	}
	
	return iGAPoints;
}
#endif
//	--------------------------------------------------------------------------------
/// How much do we need in the GA meter to trigger the next one?
int CvPlayer::GetGoldenAgeProgressThreshold() const
{
	int iThreshold = /*500 in CP, 400 in VP*/ GD_INT_GET(GOLDEN_AGE_BASE_THRESHOLD_HAPPINESS);
	iThreshold += GetNumGoldenAges() * /*250 in CP, 2000 in VP*/ GD_INT_GET(GOLDEN_AGE_EACH_GA_ADDITIONAL_HAPPINESS);

	// Increase cost based on the # of cities in the empire
	int iCostExtra = int(iThreshold * (getNumCities() - 1) * /*0.01f*/ GD_FLOAT_GET(GOLDEN_AGE_THRESHOLD_CITY_MULTIPLIER));
	iThreshold += iCostExtra;

	if(GetGoldenAgeMeterMod() != 0)
	{
		iThreshold *= (100 + GetGoldenAgeMeterMod());
		iThreshold /= 100;
	}

	// Game Speed Mod
	iThreshold *= GC.getGame().getGameSpeedInfo().getGreatPeoplePercent();
	iThreshold /= 100;

	// Make the number nice to look at
	int iVisibleDivisor = /*5*/ GD_INT_GET(GOLDEN_AGE_VISIBLE_THRESHOLD_DIVISOR);
	iThreshold /= iVisibleDivisor;
	iThreshold *= iVisibleDivisor;

	if (MOD_ALTERNATIVE_DIFFICULTY && !isHuman())
	{
		iThreshold *= GC.getGame().getHandicapInfo().getAIGoldenAgePercent();
		iThreshold /= 100;
	}

	return iThreshold;
}

//	--------------------------------------------------------------------------------
/// What is our progress towards the next GA?
int CvPlayer::GetGoldenAgeProgressMeter() const
{
	return m_iGoldenAgeProgressMeter;
}

//	--------------------------------------------------------------------------------
/// Sets what is our progress towards the next GA
void CvPlayer::SetGoldenAgeProgressMeter(int iValue)
{
	m_iGoldenAgeProgressMeter = iValue;

	if(m_iGoldenAgeProgressMeter < 0)
	{
		m_iGoldenAgeProgressMeter = 0;
	}

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
}

//	--------------------------------------------------------------------------------
/// Changes what is our progress towards the next GA
void CvPlayer::ChangeGoldenAgeProgressMeter(int iChange)
{
	if (GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS))
		return;

	if (MOD_BALANCE_NO_GAP_DURING_GA && isGoldenAge())
	{
		return;
	}
	SetGoldenAgeProgressMeter(GetGoldenAgeProgressMeter() + iChange);
	if (MOD_ISKA_GOLDENAGEPOINTS_TO_PRESTIGE)
	{
		if (iChange > 0)
		{
			ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
			if (pkScriptSystem)
			{
				CvLuaArgsHandle args;
				args->Push(GetID());
				args->Push(iChange);

				// Attempt to execute the game events.
				// Will return false if there are no registered listeners.
				bool bResult = false;
				LuaSupport::CallHook(pkScriptSystem, "ChangeGoldenAgeProgressMeter", args.get(), bResult);
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Modifier for how big the GA meter is (-50 = 50% of normal)
int CvPlayer::GetGoldenAgeMeterMod() const
{
	return m_iGoldenAgeMeterMod;
}

//	--------------------------------------------------------------------------------
/// Sets Modifier for how big the GA meter is (-50 = 50% of normal)
void CvPlayer::SetGoldenAgeMeterMod(int iValue)
{
	m_iGoldenAgeMeterMod = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes Modifier for how big the GA meter is (-50 = 50% of normal)
void CvPlayer::ChangeGoldenAgeMeterMod(int iChange)
{
	SetGoldenAgeMeterMod(GetGoldenAgeMeterMod() + iChange);
}

//	--------------------------------------------------------------------------------
/// How many GAs have we had in this game?
int CvPlayer::GetNumGoldenAges() const
{
	return m_iNumGoldenAges;
}

//	--------------------------------------------------------------------------------
/// Sets how many GAs have we had in this game
void CvPlayer::SetNumGoldenAges(int iValue)
{
	m_iNumGoldenAges = iValue;

#if defined(MOD_API_ACHIEVEMENTS)
	if(iValue > 0 && isHuman() && !GC.getGame().isGameMultiPlayer()&& GET_PLAYER(GC.getGame().getActivePlayer()).isLocalPlayer())
	{
		gDLL->UnlockAchievement(ACHIEVEMENT_GOLDEN_AGE);

		const char* strLeader = getLeaderTypeKey();
		if(m_iNumGoldenAges >=5 && NULL != strLeader && strcmp(strLeader, "LEADER_DARIUS") == 0)
		{
			gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_ARCHAEMENNID);
		}
	}
#endif
}

//	--------------------------------------------------------------------------------
/// Changes how many GAs have we had in this game
void CvPlayer::ChangeNumGoldenAges(int iChange)
{
	SetNumGoldenAges(GetNumGoldenAges() + iChange);
}

//	--------------------------------------------------------------------------------
/// How many turns left in GA? (0 if not in GA)
int CvPlayer::getGoldenAgeTurns() const
{
	return m_iGoldenAgeTurns;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isGoldenAge() const
{
	return (getGoldenAgeTurns() > 0);
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGoldenAgeTurns(int iChange, bool bFree)
{
	Localization::String locString;
	Localization::String locSummaryString;

	if(iChange != 0)
	{
		bool bOldGoldenAge = isGoldenAge();
		int iThreshold = GetGoldenAgeProgressThreshold();

		m_iGoldenAgeTurns = (m_iGoldenAgeTurns + iChange);
		CvAssert(getGoldenAgeTurns() >= 0);

		if(bOldGoldenAge != isGoldenAge())
		{
			GC.getMap().updateYield();	// Do the entire map, so that any potential golden age bonus is reflected in the yield icons.

			if(!isGoldenAge())
			{
				gDLL->GameplayGoldenAgeEnded();

				if (MOD_EVENTS_GOLDEN_AGE) {
					GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerGoldenAge, GetID(), false, 0);
				}
#if defined(MOD_BALANCE_CORE)
				int iLoop;
				for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					pLoopCity->GetCityCulture()->CalculateBaseTourismBeforeModifiers();
					pLoopCity->GetCityCulture()->CalculateBaseTourism();
				}
				ChangeGarrisonedCityRangeStrikeModifier(GetPlayerTraits()->GetGoldenAgeGarrisonedCityRangeStrikeModifier() * -1);
#endif
			}

			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				NotificationTypes eNotification = NO_NOTIFICATION_TYPE;

				if(isGoldenAge())
				{
					eNotification = NOTIFICATION_GOLDEN_AGE_BEGUN_ACTIVE_PLAYER;
					locString = Localization::Lookup("TXT_KEY_NOTIFICATION_GOLDEN_AGE_BEGUN_ACTIVE_PLAYER");
					locSummaryString = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_GOLDEN_AGE_BEGUN_ACTIVE_PLAYER");
				}
				else
				{
					eNotification = NOTIFICATION_GOLDEN_AGE_ENDED_ACTIVE_PLAYER;
					locString = Localization::Lookup("TXT_KEY_NOTIFICATION_GOLDEN_AGE_ENDED_ACTIVE_PLAYER");
					locSummaryString = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_GOLDEN_AGE_ENDED_ACTIVE_PLAYER");
				}

				pNotifications->Add(eNotification, locString.toUTF8(), locSummaryString.toUTF8(), -1, -1, -1);
			}
		}

		if (iChange > 0)
		{
			if (!(bFree && MOD_BALANCE_CORE))
			{
				ChangeNumGoldenAges(1);
			}
#if defined(MOD_BALANCE_CORE)
			//Instant Boost
			CvCity* pCapitalCity = getCapitalCity();
			if (pCapitalCity != NULL)
			{
				doInstantYield(INSTANT_YIELD_TYPE_INSTANT, false, NO_GREATPERSON, NO_BUILDING, iThreshold, false, NO_PLAYER, NULL, false, pCapitalCity);
			}
			
			if (GetGoldenAgeTourism() > 0)
			{
				int iTourism = GetHistoricEventTourism(HISTORIC_EVENT_GA);
				ChangeNumHistoricEvents(HISTORIC_EVENT_GA, 1);
				// Culture boost based on previous turns
				if (iTourism > 0)
				{
					GetCulture()->AddTourismAllKnownCivsWithModifiers(iTourism);
					CvCity* pCapitalCity = getCapitalCity();

					if (GetID() == GC.getGame().getActivePlayer())
					{
						if (pCapitalCity != NULL)
						{
							char text[256] = { 0 };
							sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_TOURISM]", iTourism);
							SHOW_PLOT_POPUP(pCapitalCity->plot(), GetID(), text);

							CvNotifications* pNotification = GetNotifications();
							if (pNotification)
							{
								CvString strMessage;
								CvString strSummary;
								strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GOLDEN_AGE", iTourism);
								strSummary = GetLocalizedText("TXT_KEY_TOURISM_EVENT_SUMMARY");
								pNotification->Add(NOTIFICATION_CULTURE_VICTORY_SOMEONE_INFLUENTIAL, strMessage, strSummary, pCapitalCity->getX(), pCapitalCity->getY(), GetID());
							}
						}
					}
				}
			}
			else if (!MOD_ABC_TRIGGER_CHANGE && MOD_BALANCE_CORE_DIFFICULTY && !isHuman() && isMajorCiv() && getNumCities() > 0)
			{
				DoDifficultyBonus(HISTORIC_EVENT_GA);
			}

			if (GetPlayerTraits()->GetWLTKDGATimer() > 0)
			{
				int iValue = GetPlayerTraits()->GetWLTKDGATimer();
				iValue *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iValue /= 100;
				int iLoop;
				for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if (pLoopCity != NULL)
					{
						pLoopCity->ChangeWeLoveTheKingDayCounter(iValue);
					}
				}
				CvNotifications* pNotification = GetNotifications();
				if (pNotification)
				{
					CvString strMessage;
					CvString strSummary;
					strMessage = GetLocalizedText("TXT_KEY_CARNAVAL_WLTKD", iValue);
					strSummary = GetLocalizedText("TXT_KEY_CARNAVAL_WLTKD_S");
					pNotification->Add(NOTIFICATION_GENERIC, strMessage, strSummary, -1, -1, GetID());
				}
			}
			if (GetPlayerTraits()->GetGoldenAgeGarrisonedCityRangeStrikeModifier() > 0)
			{
				ChangeGarrisonedCityRangeStrikeModifier(GetPlayerTraits()->GetGoldenAgeGarrisonedCityRangeStrikeModifier() * 1);
			}
#endif

			locString = Localization::Lookup("TXT_KEY_NOTIFICATION_GOLDEN_AGE_BEGUN");
			locString << getCivilizationAdjectiveKey();
			GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, GetID(), locString.toUTF8(), -1, -1);

			gDLL->GameplayGoldenAgeStarted();

			if (MOD_EVENTS_GOLDEN_AGE) {
				GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerGoldenAge, GetID(), true, iChange);
			}
#if defined(MOD_BALANCE_CORE)
			int iLoop;
			for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				pLoopCity->GetCityCulture()->CalculateBaseTourismBeforeModifiers();
				pLoopCity->GetCityCulture()->CalculateBaseTourism();
			}
#endif
		}

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
// get the number of turns this Golden Age will occur over
// (optional input allows manually sets the length with included length modifiers)
int CvPlayer::getGoldenAgeLength(int iManualLength) const
{
	int iTurns = GC.getGame().goldenAgeLength(iManualLength);

	// Player modifier
	int iLengthModifier = getGoldenAgeModifier();

	if(iLengthModifier != 0)
	{
		iTurns = iTurns * (100 + iLengthModifier) / 100;
	}

	return iTurns;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNumUnitGoldenAges() const
{
	return m_iNumUnitGoldenAges;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeNumUnitGoldenAges(int iChange)
{
	m_iNumUnitGoldenAges = (m_iNumUnitGoldenAges + iChange);
	CvAssert(getNumUnitGoldenAges() >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getStrikeTurns() const
{
	return m_iStrikeTurns;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeStrikeTurns(int iChange)
{
	m_iStrikeTurns = (m_iStrikeTurns + iChange);
	CvAssert(getStrikeTurns() >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getGoldenAgeModifier(bool bCheckMonopolies) const
{
	// Player modifier, eg policies and buildings
	int iModifier = m_iGoldenAgeModifier; 

	// Trait modifier
	iModifier += GetPlayerTraits()->GetGoldenAgeDurationModifier();

#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	// Resource monopolies (not cached, so give an option to skip this check)
	if (MOD_BALANCE_CORE_RESOURCE_MONOPOLIES && bCheckMonopolies)
	{
		for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
		{
			ResourceTypes eResourceLoop = (ResourceTypes)iResourceLoop;
			if (eResourceLoop != NO_RESOURCE)
			{
				CvResourceInfo* pInfo = GC.getResourceInfo(eResourceLoop);
				if (pInfo && pInfo->isMonopoly())
				{
					if (HasGlobalMonopoly(eResourceLoop) && pInfo->getMonopolyGALength() > 0)
					{
						int iTemp = pInfo->getMonopolyGALength();
						iTemp += GetMonopolyModPercent();
						iModifier += iTemp;
					}
				}
			}
		}
	}
#endif

	return iModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGoldenAgeModifier(int iChange)
{
	m_iGoldenAgeModifier += iChange;
}

#if defined(MOD_GLOBAL_TRULY_FREE_GP)
//	--------------------------------------------------------------------------------
int CvPlayer::getGreatPeopleCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatPeopleCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatPeopleCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatPeopleCreated(bool bIsFree)
{
	m_iGreatPeopleCreated++;
	if (bIsFree) m_iFreeGreatPeopleCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatGeneralsCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatGeneralsCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatGeneralsCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatGeneralsCreated(bool bIsFree)
{
	m_iGreatGeneralsCreated++;
	if (bIsFree) m_iFreeGreatGeneralsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatAdmiralsCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatAdmiralsCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatAdmiralsCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatAdmiralsCreated(bool bIsFree)
{
	m_iGreatAdmiralsCreated++;
	if (bIsFree) m_iFreeGreatAdmiralsCreated++;
}

#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
//	--------------------------------------------------------------------------------
int CvPlayer::getGreatMerchantsCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatMerchantsCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatMerchantsCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatMerchantsCreated(bool bIsFree)
{
	m_iGreatMerchantsCreated++;
	if (bIsFree) m_iFreeGreatMerchantsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatScientistsCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatScientistsCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatScientistsCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatScientistsCreated(bool bIsFree)
{
	m_iGreatScientistsCreated++;
	if (bIsFree) m_iFreeGreatScientistsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatEngineersCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatEngineersCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatEngineersCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatEngineersCreated(bool bIsFree)
{
	m_iGreatEngineersCreated++;
	if (bIsFree) m_iFreeGreatEngineersCreated++;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatWritersCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatWritersCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatWritersCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatWritersCreated(bool bIsFree)
{
	m_iGreatWritersCreated++;
	if (bIsFree) m_iFreeGreatWritersCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatArtistsCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatArtistsCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatArtistsCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatArtistsCreated(bool bIsFree)
{
	m_iGreatArtistsCreated++;
	if (bIsFree) m_iFreeGreatArtistsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatMusiciansCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatMusiciansCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatMusiciansCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatMusiciansCreated(bool bIsFree)
{
	m_iGreatMusiciansCreated++;
	if (bIsFree) m_iFreeGreatMusiciansCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatDiplomatsCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatDiplomatsCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatDiplomatsCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatDiplomatsCreated(bool bIsFree)
{
	m_iGreatDiplomatsCreated++;
	if (bIsFree) m_iFreeGreatDiplomatsCreated++;
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra1Created(bool bExcludeFree) const
{
	int iCount = m_iGPExtra1Created;
	if (bExcludeFree) iCount -= m_iFreeGPExtra1Created;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra1Created(bool bIsFree)
{
	m_iGPExtra1Created++;
	if (bIsFree) m_iFreeGPExtra1Created++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra2Created(bool bExcludeFree) const
{
	int iCount = m_iGPExtra2Created;
	if (bExcludeFree) iCount -= m_iFreeGPExtra2Created;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra2Created(bool bIsFree)
{
	m_iGPExtra2Created++;
	if (bIsFree) m_iFreeGPExtra2Created++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra3Created(bool bExcludeFree) const
{
	int iCount = m_iGPExtra3Created;
	if (bExcludeFree) iCount -= m_iFreeGPExtra3Created;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra3Created(bool bIsFree)
{
	m_iGPExtra3Created++;
	if (bIsFree) m_iFreeGPExtra3Created++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra4Created(bool bExcludeFree) const
{
	int iCount = m_iGPExtra4Created;
	if (bExcludeFree) iCount -= m_iFreeGPExtra4Created;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra4Created(bool bIsFree)
{
	m_iGPExtra4Created++;
	if (bIsFree) m_iFreeGPExtra4Created++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra5Created(bool bExcludeFree) const
{
	int iCount = m_iGPExtra5Created;
	if (bExcludeFree) iCount -= m_iFreeGPExtra5Created;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra5Created(bool bIsFree)
{
	m_iGPExtra5Created++;
	if (bIsFree) m_iFreeGPExtra5Created++;
}
#endif
#else
//	--------------------------------------------------------------------------------
int CvPlayer::getGreatPeopleCreated() const
{
	return m_iGreatPeopleCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatPeopleCreated()
{
	m_iGreatPeopleCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatGeneralsCreated() const
{
	return m_iGreatGeneralsCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatGeneralsCreated()
{
	m_iGreatGeneralsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatAdmiralsCreated() const
{
	return m_iGreatAdmiralsCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatAdmiralsCreated()
{
	m_iGreatAdmiralsCreated++;
}

#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
//	--------------------------------------------------------------------------------
int CvPlayer::getGreatMerchantsCreated() const
{
	return m_iGreatMerchantsCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatMerchantsCreated()
{
	m_iGreatMerchantsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatScientistsCreated() const
{
	return m_iGreatScientistsCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatScientistsCreated()
{
	m_iGreatScientistsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatEngineersCreated() const
{
	return m_iGreatEngineersCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatEngineersCreated()
{
	m_iGreatEngineersCreated++;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatWritersCreated() const
{
	return m_iGreatWritersCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatWritersCreated()
{
	m_iGreatWritersCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatArtistsCreated() const
{
	return m_iGreatArtistsCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatArtistsCreated()
{
	m_iGreatArtistsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatMusiciansCreated() const
{
	return m_iGreatMusiciansCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatMusiciansCreated()
{
	m_iGreatMusiciansCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatDiplomatsCreated() const
{
	return m_iGreatDiplomatsCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatDiplomatsCreated()
{
	m_iGreatDiplomatsCreated++;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getMerchantsFromFaith() const
{
	return m_iMerchantsFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementMerchantsFromFaith()
{
	m_iMerchantsFromFaith++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getScientistsFromFaith() const
{
	return m_iScientistsFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementScientistsFromFaith()
{
	m_iScientistsFromFaith++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getWritersFromFaith() const
{
	return m_iWritersFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementWritersFromFaith()
{
	m_iWritersFromFaith++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getArtistsFromFaith() const
{
	return m_iArtistsFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementArtistsFromFaith()
{
	m_iArtistsFromFaith++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getMusiciansFromFaith() const
{
	return m_iMusiciansFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementMusiciansFromFaith()
{
	m_iMusiciansFromFaith++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGeneralsFromFaith() const
{
	return m_iGeneralsFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGeneralsFromFaith()
{
	m_iGeneralsFromFaith++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getAdmiralsFromFaith() const
{
	return m_iAdmiralsFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementAdmiralsFromFaith()
{
	m_iAdmiralsFromFaith++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getDiplomatsFromFaith() const
{
	return m_iDiplomatsFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementDiplomatsFromFaith()
{
	m_iDiplomatsFromFaith++;
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra1FromFaith() const
{
	return m_iGPExtra1FromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra1FromFaith()
{
	m_iGPExtra1FromFaith++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra2FromFaith() const
{
	return m_iGPExtra2FromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra2FromFaith()
{
	m_iGPExtra2FromFaith++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra3FromFaith() const
{
	return m_iGPExtra3FromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra3FromFaith()
{
	m_iGPExtra3FromFaith++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra4FromFaith() const
{
	return m_iGPExtra4FromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra4FromFaith()
{
	m_iGPExtra4FromFaith++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra5FromFaith() const
{
	return m_iGPExtra5FromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra5FromFaith()
{
	m_iGPExtra5FromFaith++;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getEngineersFromFaith() const
{
	return m_iEngineersFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementEngineersFromFaith()
{
	m_iEngineersFromFaith++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatPeopleThresholdModifier() const
{
	return m_iGreatPeopleThresholdModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGreatPeopleThresholdModifier(int iChange)
{
	m_iGreatPeopleThresholdModifier = (m_iGreatPeopleThresholdModifier + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatGeneralsThresholdModifier() const
{
	return m_iGreatGeneralsThresholdModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGreatGeneralsThresholdModifier(int iChange)
{
	m_iGreatGeneralsThresholdModifier += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatAdmiralsThresholdModifier() const
{
	return m_iGreatAdmiralsThresholdModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGreatAdmiralsThresholdModifier(int iChange)
{
	m_iGreatAdmiralsThresholdModifier += iChange;
}


//	--------------------------------------------------------------------------------
int CvPlayer::getPolicyCostModifier() const
{
	return m_iPolicyCostModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::recomputePolicyCostModifier()
{
	int iCost = m_pPlayerPolicies->GetNumericModifier(POLICYMOD_POLICY_COST_MODIFIER);
	iCost += GetPolicyCostBuildingModifier();
	iCost += GetPolicyCostMinorCivModifier();
	iCost += GetPlayerTraits()->GetPolicyCostModifier();

	if(iCost < /*-75*/ GD_INT_GET(POLICY_COST_DISCOUNT_MAX))
		iCost = GD_INT_GET(POLICY_COST_DISCOUNT_MAX);

	m_iPolicyCostModifier = iCost;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatPeopleRateModifier() const
{
	return m_iGreatPeopleRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatGeneralRateModifier() const
{
	return m_iGreatGeneralRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatAdmiralRateModifier() const
{
	return m_iGreatAdmiralRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatWriterRateModifier() const
{
	return m_iGreatWriterRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatArtistRateModifier() const
{
	return m_iGreatArtistRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatMusicianRateModifier() const
{
	return m_iGreatMusicianRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatMerchantRateModifier() const
{
	return m_iGreatMerchantRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatScientistRateModifier() const
{
	return m_iGreatScientistRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatEngineerRateModifier() const
{
	return m_iGreatEngineerRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatDiplomatRateModifier() const
{
	return m_iGreatDiplomatRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getDomesticGreatGeneralRateModifier() const
{
	return m_iDomesticGreatGeneralRateModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGreatPeopleRateModFromBldgs(int ichange)
{
	m_iGreatPeopleRateModFromBldgs += ichange;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGreatGeneralRateModFromBldgs(int ichange)
{
	m_iGreatGeneralRateModFromBldgs += ichange;
}

//	--------------------------------------------------------------------------------
/// Do effects when a unit is killed in combat
void CvPlayer::DoUnitKilledCombat(CvUnit* pKillingUnit, PlayerTypes eKilledPlayer, UnitTypes eUnitType)
{
	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(eKilledPlayer);
		args->Push(eUnitType);
		args->Push(pKillingUnit ? pKillingUnit->GetID() : -1);

		bool bResult;
		LuaSupport::CallHook(pkScriptSystem, "UnitKilledInCombat", args.get(), bResult);
	}
}
#if defined(MOD_BALANCE_CORE)
void CvPlayer::doInstantYield(InstantYieldType iType, bool bCityFaith, GreatPersonTypes eGreatPerson, BuildingTypes ePassBuilding, int iPassYield, bool bEraScale, PlayerTypes ePlayer, CvPlot* pPlot, bool bSuppress, CvCity* pCity, bool bDomainSea, bool bInternational, bool bEvent, YieldTypes ePassYield, CvUnit* pUnit, TerrainTypes ePassTerrain, CvMinorCivQuest* pQuestData, CvCity* pOtherCity, CvUnit* pAttackingUnit)
{
	//No minors or barbs here, please!
	if(isMinorCiv() || isBarbarian())
		return;

	ReligionTypes eStateReligion = GetReligions()->GetStateReligion();
	int iEra = max<int>(1, GetCurrentEra());

	CvString totalyieldString = "";
	//Let's loop through all cities for this.
	int iLoop;
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		//If we passed in a city, only check that city.
		if (pCity != NULL && pLoopCity != pCity)
			continue;

		CvString yieldString = "";
		CvString cityyieldString = "";
		CvString citynameString = "";

		int iNumFollowerCities = 0;
		int iNumFollowers = 0;
		ReligionTypes eReligion = NO_RELIGION;
		const CvReligion* pReligion = NULL;

		//Get local faith if needed.
		ReligionTypes eLocalReligion = pCity ? pCity->GetCityReligions()->GetReligiousMajority() : NO_RELIGION;
		//Different faiths at national and local levels? We should check both, because one might be a founder bonus, and the other a follower bonus. Blegh!
		if(bCityFaith && eLocalReligion != eStateReligion)
		{
			pReligion = GC.getGame().GetGameReligions()->GetReligion(eLocalReligion, GetID());
			eReligion = eLocalReligion;
		}
		else
		{
			pReligion = GC.getGame().GetGameReligions()->GetReligion(eStateReligion, GetID());
			eReligion = eStateReligion;
		}

		if (eReligion > RELIGION_PANTHEON)
		{
			iNumFollowerCities = GC.getGame().GetGameReligions()->GetNumCitiesFollowing(eReligion);
			iNumFollowers = GC.getGame().GetGameReligions()->GetNumFollowers(eReligion);
		}
		else if (eReligion == RELIGION_PANTHEON)
		{
			iNumFollowerCities = GC.getGame().GetGameReligions()->GetNumDomesticCitiesFollowing(eReligion, GetID());
			iNumFollowers = GC.getGame().GetGameReligions()->GetNumFollowers(eReligion, GetID());
		}
		
		for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
		{
			YieldTypes eYield = (YieldTypes) iI;

			if (!MOD_BALANCE_CORE_JFD && eYield >= YIELD_JFD_HEALTH && eYield != ePassYield)
				continue;
		
			CvYieldInfo* pYieldInfo = GC.getYieldInfo(eYield);
		
			//First let's get our values...
			//Note that many beliefs pass in a city - that's because only holy cities (or capitals for pantheons) should get those bonuses!
			int iValue = 0;
			switch(iType)
			{
				case INSTANT_YIELD_TYPE_MINOR_QUEST_REWARD:
				{
					if (eYield != ePassYield)
						continue;

					iValue += iPassYield;
					break;
				}
				case INSTANT_YIELD_TYPE_BIRTH:
				{
					iValue += ((pLoopCity->GetYieldFromBirth(eYield) + getYieldFromBirth(eYield)) * max(1, iPassYield));
					if (pReligion)
					{
						iValue += pReligion->m_Beliefs.GetYieldPerBirth(eYield, GetID(), pLoopCity) * max(1, iPassYield);
					}
					if (pLoopCity->isCapital())
					{
						iValue += getYieldFromBirthCapital(eYield) * max(1, iPassYield);
					}
					//Scale it here to avoid scaling the growth yield below.
					if (MOD_BALANCE_CORE_NEW_GP_ATTRIBUTES && bEraScale)
					{
						iValue *= iEra;
					}

					//And now on growth % bonuses.
					int iCurrentYield = 0;

					if(eYield == YIELD_CULTURE)
					{
						iCurrentYield = pLoopCity->getJONSCulturePerTurn();
					}
					else if (eYield == YIELD_FAITH)
					{
						iCurrentYield = pLoopCity->GetFaithPerTurn();
					}
					else
					{
						iCurrentYield = pLoopCity->getYieldRate(eYield, false);
					}
					if(iCurrentYield != 0)
					{
						iValue += (((iCurrentYield * pLoopCity->GetGrowthExtraYield(eYield)) / 100) * max(1, iPassYield));
						if(iValue <= 0 && pLoopCity->GetGrowthExtraYield(eYield) > 0)
						{
							iValue = 1;
						}
					}
					break;
				}
				case INSTANT_YIELD_TYPE_BIRTH_HOLY_CITY:
				{
					if (pReligion)
					{
						iValue = pReligion->m_Beliefs.GetYieldPerHolyCityBirth(eYield, GetID(), pLoopCity, true) * pReligion->m_Beliefs.GetCityScalerLimiter(iNumFollowerCities);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_BIRTH_RETROACTIVE:
				{
					if (eYield != ePassYield)
						continue;

					iValue = iPassYield;
					break;
				}
				case INSTANT_YIELD_TYPE_TECH_RETROACTIVE:
				{
					if (eYield != ePassYield)
						continue;

					iValue = iPassYield;
					break;
				}

				case INSTANT_YIELD_TYPE_REFUND:
				{
					if (eYield != YIELD_PRODUCTION)
						continue;

					iValue = iPassYield;
					break;
				}
				
				case INSTANT_YIELD_TYPE_ERA_UNLOCK:
				{
					if(pReligion)
					{
						iValue += pReligion->m_Beliefs.GetYieldFromEraUnlock(eYield, GetID(), pLoopCity, true) * pReligion->m_Beliefs.GetCityScalerLimiter(iNumFollowerCities);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_POLICY_UNLOCK:
				{
					int iScaleValue = pLoopCity->GetYieldFromPolicyUnlock(eYield);
					//Scale it here to avoid scaling the growth yield below.
					if (MOD_BALANCE_CORE_NEW_GP_ATTRIBUTES)
					{
						iScaleValue *= iEra;
					}
					iValue += iScaleValue;

					if(pReligion)
					{
						iValue += pReligion->m_Beliefs.GetYieldFromPolicyUnlock(eYield, GetID(), pLoopCity, true) * pReligion->m_Beliefs.GetFollowerScalerLimiter(iNumFollowers);
					}
					
					break;
				}
				case INSTANT_YIELD_TYPE_INSTANT:
				{
					if (ePassBuilding != NO_BUILDING)
					{
						CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(ePassBuilding);
						if(pkBuildingInfo)
						{
							iValue += pkBuildingInfo->GetInstantYield(eYield);
							if(GetPlayerTraits()->IsTechBoostFromCapitalScienceBuildings() && iPassYield > 0 && eYield == YIELD_SCIENCE)
							{
								iValue += iPassYield;
							}
						}
					}
					else 
					{
						if(iPassYield != 0 && !bEvent)
						{
							int iTemp = iPassYield;
							int iPercent = GetPlayerTraits()->GetGAPToYield(eYield);
							if(iPercent != 0)
							{
								iTemp *= iPercent;
								iTemp /= 100;
						
								iValue += iTemp;
							}
						}
						if(bEvent && ePassYield == eYield)
						{
							iValue += iPassYield;
						}
					}
					break;
				}
				case INSTANT_YIELD_TYPE_TECH:
				{
					// the following instant yield sources have no non era scaling options
					if (bEraScale)
					{
						iValue += pLoopCity->GetYieldFromTech(eYield);
						if (pLoopCity->isCapital())
						{
							iValue += getYieldFromTech(eYield);
						}
					}

#if defined(MOD_BALANCE_CORE_BELIEFS)
					if (pReligion)
					{
						iValue += pReligion->m_Beliefs.GetYieldFromTechUnlock(eYield, bEraScale, GetID(), pLoopCity, true) * pReligion->m_Beliefs.GetFollowerScalerLimiter(iNumFollowers);
					}
#endif
					break;
				}

				case INSTANT_YIELD_TYPE_SPY_ATTACK:
				{
					iValue += pLoopCity->GetYieldFromSpyAttack(eYield);
					if (iValue != 0)
					{
						if (iPassYield == 0)
							iValue /= 4;
						else
							iValue *= iPassYield;
					}
					break;
				}
				case INSTANT_YIELD_TYPE_SPY_DEFENSE:
				{
					iValue += pLoopCity->GetYieldFromSpyDefense(eYield);
					if (iValue != 0)
					{
						if (iPassYield == 0)
							iValue /= 4;
						else
							iValue *= iPassYield;
					}
					break;
				}
				case INSTANT_YIELD_TYPE_DELEGATES:
				{
					if (pLoopCity->isCapital())
					{
						iValue += (getYieldFromDelegateCount(eYield) * iPassYield);
					}
					break;
				}			
				
				case INSTANT_YIELD_TYPE_CONSTRUCTION:
				{
					iValue += pLoopCity->GetYieldFromConstruction(eYield) + getYieldFromConstruction(eYield);
					if (pReligion)
					{
						iValue += pReligion->m_Beliefs.GetYieldPerConstruction(eYield, GetID(), pLoopCity);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_CONSTRUCTION_WONDER:
				{
					iValue += GetYieldFromWorldWonderConstruction(eYield);
					if (pReligion)
					{
						iValue += pReligion->m_Beliefs.GetYieldPerWorldWonderConstruction(eYield, GetID(), pLoopCity, true) * pReligion->m_Beliefs.GetCityScalerLimiter(iNumFollowerCities);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_BORDERS:
				{
					int iScaleValue = pLoopCity->GetYieldFromBorderGrowth(eYield) + getYieldFromBorderGrowth(eYield) + GetPlayerTraits()->GetYieldFromTileEarn(eYield);

					iScaleValue *= iEra;

					iValue += iScaleValue;

					if(pReligion)
					{
						iScaleValue = pReligion->m_Beliefs.GetYieldPerBorderGrowth(eYield, true, GetID(), pLoopCity);
						iScaleValue *= iEra;
						iValue += iScaleValue;

						iValue += pReligion->m_Beliefs.GetYieldPerBorderGrowth(eYield, false, GetID(), pLoopCity);
					}
					if(ePassTerrain != NO_TERRAIN)
					{
						iScaleValue = GetPlayerTraits()->GetYieldChangeFromTileEarnTerrainType(ePassTerrain, eYield);
						iScaleValue *= iEra;
						iValue += iScaleValue;
					}
					break;
				}
				case INSTANT_YIELD_TYPE_PROPOSAL:
				{
					if(pReligion)
					{
						iValue += pReligion->m_Beliefs.GetYieldFromProposal(eYield, GetID(), pLoopCity, true);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_GP_USE:
				{
					if(pLoopCity->isCapital())
					{
						iValue += getYieldGPExpend(eYield);
						if(eYield == YIELD_GOLD)
						{
							iValue += GetGreatPersonExpendGold();
						}
					}
					if(eGreatPerson != NO_GREATPERSON)
					{
						if(pLoopCity->isCapital())
						{
							iValue += getGreatPersonExpendedYield(eGreatPerson, eYield);
							//Scale it here to avoid scaling the growth yield below.
							if (bEraScale)
							{
								iValue *= iEra;
							}
						}
						if(pReligion)
						{
							iValue += (pReligion->m_Beliefs.GetYieldFromGPUse(eYield, GetID(), pLoopCity, true) + pReligion->m_Beliefs.GetGreatPersonExpendedYield(eGreatPerson, eYield, GetID(), pLoopCity, true)) * pReligion->m_Beliefs.GetCityScalerLimiter(iNumFollowerCities);
				
							//Scale it here to avoid scaling the growth yield below.
							if (eYield == YIELD_CULTURE && bEraScale)
							{
								iValue *= iEra;
							}
						}
					}
					if(eYield == YIELD_FAITH)
					{
						if(pReligion)
						{
							iValue += pReligion->m_Beliefs.GetGreatPersonExpendedFaith(GetID(), pLoopCity, true);
							//Scale it here to avoid scaling the growth yield below.
							if (bEraScale)
							{
								iValue *= iEra;
							}
						}
					}
					break;
				}
				case INSTANT_YIELD_TYPE_GP_BORN:
				{
					if(eGreatPerson != NO_GREATPERSON)
					{
						iValue += GetPlayerTraits()->GetGreatPersonBornYield(eGreatPerson, eYield);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_F_CONQUEST:
				{
					if (pLoopCity->isCapital())
					{
						iValue += (getConquerorYield(eYield) + GetPlayerTraits()->GetYieldFromConquest(eYield));
					}
					if (pReligion)
					{
						if (pReligion->m_Beliefs.GetYieldFromConquest(eYield, GetID(), pLoopCity, true) > 0)
						{
							if (eYield == YIELD_GREAT_ADMIRAL_POINTS && bDomainSea)
							{
								iValue += pReligion->m_Beliefs.GetYieldFromConquest(eYield, GetID(), pLoopCity, true);
							}
							else if (eYield == YIELD_GREAT_GENERAL_POINTS && !bDomainSea)
							{
								iValue += pReligion->m_Beliefs.GetYieldFromConquest(eYield, GetID(), pLoopCity, true);
							}
							else if (eYield != YIELD_GREAT_ADMIRAL_POINTS && eYield != YIELD_GREAT_GENERAL_POINTS)
							{
								iValue += pReligion->m_Beliefs.GetYieldFromConquest(eYield, GetID(), pLoopCity, true);
							}
						}
					}
					if (iPassYield != 0 && iValue != 0)
					{
						iValue *= iPassYield;
					}

					if (pLoopCity->isCapital() && pOtherCity != NULL)
					{
						for (int iI = 0; iI < GC.getNumTerrainInfos(); iI++)
						{
							TerrainTypes eTerrain = (TerrainTypes)iI;
							int iTraitValue = GetPlayerTraits()->GetYieldChangeFromTileConquest(eTerrain, eYield);

							if (iTraitValue <= 0)
								continue;

							iValue += (iTraitValue * pOtherCity->CountAllOwnedTerrain(eTerrain));
						}
					}
					break;
				}
				case INSTANT_YIELD_TYPE_VICTORY:
				{
					if(eYield == YIELD_GREAT_ADMIRAL_POINTS && !bDomainSea)
					{
						continue;
					}
					if(eYield == YIELD_GREAT_GENERAL_POINTS && bDomainSea)
					{
						continue;
					}

					if (eYield == YIELD_SCIENCE)
					{
						int iPercent = GetPlayerTraits()->GetUnresearchedTechBonusFromKills();

						if (iPercent > 0)
						{
							int iTechValue = 0;

							CvUnitEntry* pkUnitInfo = GC.getUnitInfo(pUnit->getUnitType());
							if (pkUnitInfo)
							{
								TechTypes ePrereq = (TechTypes)pkUnitInfo->GetPrereqAndTech();
								if (ePrereq != NO_TECH)
								{
									CvTechEntry* pkTechInfo = GC.getTechInfo(ePrereq);
									if (pkTechInfo && !GET_TEAM(getTeam()).GetTeamTechs()->HasTech(ePrereq))
									{
										int iCombatStrength = pUnit != NULL ? max(pUnit->GetBaseCombatStrength(), pUnit->GetBaseRangedCombatStrength()) : max(pkUnitInfo->GetCombat(), pkUnitInfo->GetRangedCombat());
										if (iCombatStrength > 0)
										{
											int iTechCost = GetPlayerTechs()->GetResearchCost(ePrereq);
											iTechValue = (iTechCost * iPercent) / 100;

											// Cannot be greater than the tech's cost
											int iRemainingCost = iTechCost - GetPlayerTechs()->GetResearchProgress(ePrereq);
											if (iTechValue > iRemainingCost)
											{
												iTechValue = iRemainingCost;
											}

											if (iTechValue > 0)
											{
												iValue += iTechValue;
											}
										}
									}
								}
							}
						}
					}

					CvUnitEntry* pkKilledUnitInfo = GC.getUnitInfo(pUnit->getUnitType());
					if (pkKilledUnitInfo)
					{
						int iCombatStrength = pUnit != NULL ? max(pUnit->GetBaseCombatStrength(), pUnit->GetBaseRangedCombatStrength()) : max(pkKilledUnitInfo->GetCombat(), pkKilledUnitInfo->GetRangedCombat());
						int iKillYield = 0;
						if (iCombatStrength > 0)
						{
							// Apply special case yields.
							switch (eYield)
							{
							case YIELD_GOLD:
								iKillYield += GetPlayerPolicies()->GetNumericModifier(POLICYMOD_GOLD_FROM_KILLS);
								break;

							case YIELD_CULTURE:
								iKillYield += GetPlayerTraits()->GetCultureFromKills();
								iKillYield += GetPlayerPolicies()->GetNumericModifier(POLICYMOD_CULTURE_FROM_KILLS);

								// Do we get it for barbarians?
								if (pUnit->getOwner() == BARBARIAN_PLAYER)
								{
									iKillYield += GetPlayerPolicies()->GetNumericModifier(POLICYMOD_CULTURE_FROM_BARBARIAN_KILLS);
								}
								break;

							case YIELD_FAITH:
								iKillYield += GetPlayerTraits()->GetFaithFromKills();

								if (eYield == YIELD_FAITH && (GC.getGame().isOption(GAMEOPTION_NO_RELIGION)))
								{
									return;
								}
								break;

							default:
								break; // No special cases for this yield.
							}

							iKillYield += GetYieldFromKills(eYield);
							iKillYield += GetPlayerTraits()->GetYieldFromKills(eYield);

							if (pUnit->getOwner() == BARBARIAN_PLAYER) {
								iKillYield += GetYieldFromBarbarianKills(eYield);
								iKillYield += GetPlayerTraits()->GetYieldFromBarbarianKills(eYield);
							}

							ReligionTypes eReligion = GetReligions()->GetStateReligion();
							if (eReligion != NO_RELIGION)
							{
								const CvReligion* pMyReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, GetID());
								if (pMyReligion)
								{
									CvCity* pHolyCity = pMyReligion->GetHolyCity();
									if (pHolyCity == NULL)
									{
										pHolyCity = getCapitalCity();
									}

									iKillYield += pMyReligion->m_Beliefs.GetYieldFromKills(eYield, GetID(), pHolyCity, true);

									if (pUnit->getOwner() == BARBARIAN_PLAYER)
									{
										iKillYield += pMyReligion->m_Beliefs.GetYieldFromBarbarianKills(eYield, GetID(), pHolyCity, true);
									}
								}
							}
							if (pAttackingUnit != NULL)
							{
								iKillYield += GC.getGame().GetGameReligions()->GetBeliefYieldForKill(eYield, pAttackingUnit->getX(), pAttackingUnit->getY(), GetID());

								UnitTypes eAttackingUnitType = pAttackingUnit->getUnitType();

								CvUnitEntry* pkAttackingUnitInfo = GC.getUnitInfo(eAttackingUnitType);
								if (pkAttackingUnitInfo)
								{
									iKillYield += pkAttackingUnitInfo->GetYieldFromKills(eYield);

									iKillYield += pAttackingUnit->getYieldFromKills(eYield);

									// Do we get it for barbarians?
									if (pUnit != NULL && pUnit->getOwner() == BARBARIAN_PLAYER)
									{
										iKillYield += pkAttackingUnitInfo->GetYieldFromBarbarianKills(eYield);
										iKillYield += pAttackingUnit->getYieldFromBarbarianKills(eYield);
									}
								}
							}
							iKillYield = (iKillYield * iCombatStrength) / 100;

							if (iKillYield > 0)
								iValue += iKillYield;
						}
					}
					int iTempYield = pLoopCity->GetYieldFromVictory(eYield);
					if (bEraScale)
					{
						iTempYield *= iEra;
					}
					iValue += iTempYield;
					break;
				}
				case INSTANT_YIELD_TYPE_VICTORY_GLOBAL:
				{
					if (eYield == YIELD_GREAT_ADMIRAL_POINTS && !bDomainSea)
					{
						continue;
					}
					if (eYield == YIELD_GREAT_GENERAL_POINTS && bDomainSea)
					{
						continue;
					}
					iValue += GetYieldFromVictory(eYield) + pLoopCity->GetYieldFromVictoryGlobal(eYield);
					break;
				}
				case INSTANT_YIELD_TYPE_PILLAGE:
				{
					iValue += pLoopCity->GetYieldFromPillage(eYield);
					break;
				}
				case INSTANT_YIELD_TYPE_RESEARCH_AGREMEENT:
				{
					if (eYield == ePassYield)
						iValue += iPassYield;
				}
				case INSTANT_YIELD_TYPE_PILLAGE_GLOBAL:
				{
					// The building versions of the YieldFromPillage are hardcoded to be era scaling due to no additional column in the tables to denote era scaling or not.
					if (bEraScale)
					{
						iValue += GetYieldFromPillage(eYield) + pLoopCity->GetYieldFromPillageGlobal(eYield);
					}
#if defined(MOD_BALANCE_CORE_BELIEFS)
					if (MOD_RELIGION_EXTENSIONS && pReligion)
					{
						iValue += pReligion->m_Beliefs.GetYieldFromPillageGlobal(eYield, bEraScale, GetID(), pLoopCity, true);
					}
#endif
					break;
				}
				
				case INSTANT_YIELD_TYPE_U_PROD:
				{
					if (pLoopCity->GetYieldFromUnitProduction(eYield) > 0)
					{
						int iBonus = iPassYield;
						iBonus *= pLoopCity->GetYieldFromUnitProduction(eYield);
						iBonus /= 100;

						iValue += iBonus;
					}
					break;
				}
				case INSTANT_YIELD_TYPE_PURCHASE:
				{
					if(iPassYield != 0)
					{
						iValue += ((iPassYield * pLoopCity->GetYieldFromPurchase(eYield)) / 100);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_TILE_PURCHASE:
				{
					iValue += GetPlayerTraits()->GetYieldFromTilePurchase(eYield);
					if (ePassTerrain!=NO_TERRAIN)
						iValue += GetPlayerTraits()->GetYieldChangeFromTilePurchaseTerrainType(ePassTerrain, eYield);
					break;
				}
				case INSTANT_YIELD_TYPE_FOUND:
				{
					iValue += GetPlayerTraits()->GetYieldFromSettle(eYield);
					iValue += getFounderYield(eYield);
					for (int iI = 0; pCity != NULL && iI < GC.getNumTerrainInfos(); iI++)
					{
						TerrainTypes eTerrain = (TerrainTypes)iI;
						int iTraitValue = GetPlayerTraits()->GetYieldChangeFromTileSettle(eTerrain, eYield);
						if (iTraitValue <= 0)
							continue;

						iValue += (iTraitValue * pCity->CountTerrain(eTerrain));
					}
					break;
				}
				case INSTANT_YIELD_TYPE_TR_END:
				{
					iValue += bInternational ? GetPlayerTraits()->GetTradeRouteEndYieldInternational(eYield) : GetPlayerTraits()->GetTradeRouteEndYieldDomestic(eYield);
					if (!bInternational)
					{
						iValue += pLoopCity->GetYieldFromInternalTREnd(eYield);
						if (pOtherCity != NULL)
						{
							iValue += pOtherCity->GetYieldFromInternalTREnd(eYield);
						}
					}
					break;
				}
				case INSTANT_YIELD_TYPE_CONVERSION:
				{
					if (pReligion)
					{
						int iBaseValue = pReligion->m_Beliefs.GetYieldFromConversion(eYield, GetID(), pLoopCity, true);
						if (iBaseValue != 0)
						{
							int iTempValue = iBaseValue;
							iTempValue *= (100 + pReligion->m_Beliefs.GetCityScalerLimiter(iNumFollowerCities) * pReligion->m_Beliefs.GetCityScalerLimiter(iNumFollowerCities));
							iTempValue /= 100;

							iBaseValue = iTempValue;
						}
						iValue += iBaseValue;
					}

					break;
				}
				case INSTANT_YIELD_TYPE_CONVERSION_EXPO:
				{
					if (pReligion)
						iValue += pReligion->m_Beliefs.GetYieldFromConversionExpo(eYield, GetID(), pLoopCity, true) * iNumFollowerCities;
					break;
				}
				case INSTANT_YIELD_TYPE_DEATH:
				{
					if(pLoopCity->isCapital())
					{
						iValue += getYieldFromDeath(eYield);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_BULLY:
				{
					if (eYield != ePassYield && ePassYield != NO_YIELD)
						continue;

					if (iPassYield == 0)
						iValue += GetYieldFromMinorDemand(eYield);
					else if (ePassYield != NO_YIELD)
						iValue += iPassYield;
					else
					{
						int iTemp = GetYieldFromMinorDemand(eYield) * iPassYield;
						iTemp /= 100;
						iValue += iTemp;
					}
					break;
				}
				case INSTANT_YIELD_TYPE_SPREAD:
				{
					if(pReligion && pPlot != NULL)
					{
						CvCity* pCity = pPlot->getPlotCity();
						if(pCity == NULL)
						{
							pCity = pPlot->GetAdjacentCity();
						}
						if(pCity != NULL)
						{
							if(!pCity->GetCityReligions()->IsHolyCityForReligion(eReligion))
							{
								iValue += pReligion->m_Beliefs.GetYieldFromSpread(eYield, GetID(), pLoopCity, true) * max(1, iPassYield+1);
							}
						}
					}
					if (eYield == YIELD_JFD_LOYALTY && eYield == ePassYield)
						iValue += iPassYield;
					break;
				}
				case INSTANT_YIELD_TYPE_F_SPREAD:
				{
					if(ePlayer != NO_PLAYER && ePlayer != GetID())
					{
						if(GET_PLAYER(ePlayer).isMinorCiv() && eYield == YIELD_TOURISM)
						{
							continue;
						}
						if(pReligion)
						{
							int iTempValue = pReligion->m_Beliefs.GetYieldFromForeignSpread(eYield, GetID(), pLoopCity, true);
							iTempValue *= max(1, iPassYield+1);

							iValue += iTempValue;

							CvCity* pCity = pPlot->getPlotCity();
							if (pCity == NULL)
							{
								pCity = pPlot->GetAdjacentCity();
							}
							if (pCity != NULL)
							{
								if (eYield == YIELD_SCIENCE && iPassYield > 0)
								{
									ReligionTypes eCurrentReligion = pCity->GetCityReligions()->GetReligiousMajority();
									if (eCurrentReligion != eReligion)
									{
										iValue += (iPassYield * pReligion->m_Beliefs.GetSciencePerOtherReligionFollower(GetID(), pLoopCity, true));
									}
								}
							}
						}
					}
					
					break;
				}	
				case INSTANT_YIELD_TYPE_TR_MOVEMENT:
				{
					if(eYield == YIELD_GREAT_ADMIRAL_POINTS && !bDomainSea)
					{
						continue;
					}
					if(eYield == YIELD_GREAT_GENERAL_POINTS && bDomainSea)
					{
						continue;
					}
					iValue += GetPlayerTraits()->GetYieldFromRouteMovement(eYield);
					break;
				}
				case INSTANT_YIELD_TYPE_SCOUTING:
				{
					if(pUnit == NULL)
						continue;

					if(eYield == YIELD_GREAT_ADMIRAL_POINTS && !bDomainSea)
					{
						continue;
					}
					if(eYield == YIELD_GREAT_GENERAL_POINTS && bDomainSea)
					{
						continue;
					}
					iValue += (pUnit->getYieldFromScouting(eYield) * pUnit->GetNumTilesRevealedThisTurn());
					break;
				}
				case INSTANT_YIELD_TYPE_LEVEL_UP:
				{
					if(pUnit == NULL)
						continue;

					if(eYield == YIELD_GREAT_ADMIRAL_POINTS && !bDomainSea)
					{
						continue;
					}
					if(eYield == YIELD_GREAT_GENERAL_POINTS && bDomainSea)
					{
						continue;
					}

					int iLevelUpYield = pLoopCity->GetYieldFromUnitLevelUp(eYield) + GetPlayerTraits()->GetYieldFromLevelUp(eYield);

					if (iPassYield != 0 && iLevelUpYield > 0)
					{
						int iMetric = ((((iPassYield * iPassYield) - (2 * iPassYield) + 1)) * iLevelUpYield);
						if (iMetric <= 0)
							iMetric = 1;

						iValue += iMetric;
					}
					break;
				}
				case INSTANT_YIELD_TYPE_CULTURE_BOMB:
				{
					if (eYield != ePassYield)
						continue;

					iValue += iPassYield;

					break;
				}

				case INSTANT_YIELD_TYPE_REMOVE_HERESY:
				{
					if (pReligion)
					{
						int iTempVal = pReligion->m_Beliefs.GetYieldFromRemoveHeresy(eYield, GetID(), pLoopCity, true);
						iTempVal *= iPassYield;
						if (iTempVal > 0)
							iValue += iTempVal;
					}

					break;
				}

				case INSTANT_YIELD_TYPE_FAITH_PURCHASE:
				{
					if (pReligion)
					{
						int iTempVal = pReligion->m_Beliefs.GetYieldFromFaithPurchase(eYield, GetID(), pLoopCity, true);
						iTempVal *= iPassYield;
						iTempVal /= 100;
						iValue += iTempVal;
					}

					int iTempVal = pLoopCity->GetYieldFromFaithPurchase(eYield);
					iTempVal *= iPassYield;
					iTempVal /= 100;
					iValue += iTempVal;

					break;
				}
				case INSTANT_YIELD_TYPE_PROMOTION_OBTAINED:
				{
					if (eYield != ePassYield)
						continue;

					if (pCity == NULL && pLoopCity == getCapitalCity())
					{
						iValue += iPassYield;
					}

					else if (pLoopCity == pCity)
					{
						iValue += iPassYield;
					}

					break;
				}
				case INSTANT_YIELD_TYPE_BARBARIAN_CAMP_CLEARED:
				{
					if (eYield != ePassYield && ePassYield != NO_YIELD)
						continue;

					if (eYield == YIELD_GOLD)
					{
						iPassYield *= (100 + GetPlayerTraits()->GetPlunderModifier());
						iPassYield /= 100;
					}
					if (iPassYield > 0)
					{
						// Normal way to handle it
						if (ePlayer == GC.getGame().getActivePlayer())
						{
							DLLUI->AddUnitMessage(0, pUnit->GetIDInfo(), pUnit->getOwner(), true, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), GetLocalizedText("TXT_KEY_MISC_DESTROYED_BARBARIAN_CAMP", iPassYield));
						}
					}

					if (iPassYield <= 0)
					{
						iValue += MAX(GetPlayerTraits()->GetYieldFromBarbarianCampClear(eYield, bEraScale), 0);
					}

					iValue += iPassYield;

					break;
				}
				case INSTANT_YIELD_TYPE_TR_PRODUCTION_SIPHON:
				{
					if (eYield != ePassYield)
						continue;

					iValue += iPassYield;

					break;
				}
				case INSTANT_YIELD_TYPE_TR_MOVEMENT_IN_FOREIGN:
				{
					if (pUnit == NULL)
						continue;
					if (eYield == YIELD_GREAT_ADMIRAL_POINTS && !bDomainSea)
					{
						continue;
					}
					if (eYield == YIELD_GREAT_GENERAL_POINTS && bDomainSea)
					{
						continue;
					}
					if (pUnit->IsInForeignOwnedTerritory())
					{
						iValue += GetPlayerTraits()->GetYieldFromRouteMovementInForeignTerritory(eYield, false);
						iValue += GetPlayerTraits()->GetYieldFromRouteMovementInForeignTerritory(eYield, true);

						PlayerTypes eOtherPlayer = pUnit->plot()->getOwner();

						if (eOtherPlayer != NO_PLAYER && GET_PLAYER(eOtherPlayer).isBarbarian() == false && eOtherPlayer != GetID())
						{
							iValue += GET_PLAYER(eOtherPlayer).GetPlayerTraits()->GetYieldFromRouteMovementInForeignTerritory(eYield, true);
						}
					}

					break;
				}
				case INSTANT_YIELD_TYPE_IMPROVEMENT_BUILD:
				{
					if (MOD_RELIGION_EXTENSIONS)
					{
						if (pReligion)
						{
							iValue += MAX(pReligion->m_Beliefs.GetYieldFromImprovementBuild(eYield, bEraScale, GetID(), pLoopCity), 0);
						}
					}

					break;
				}
				case INSTANT_YIELD_TYPE_LUA:
				{
					if (ePassYield == eYield)
					{
						iValue += iPassYield;
					}

					break;
				}
				case INSTANT_YIELD_TYPE_PILLAGE_UNIT:
				{
					// Unit pointer must be valid for unit specific pillage yields.
					// Not passing a unit pointer is a logic error.
					ASSERT(pUnit != NULL);

					// This yield shoud never have scale with era passed as true.
					// This would be another logic error since we split the value and scale it ourself.
					ASSERT(!bEraScale);

					const std::pair<int, int> unitPillageYield = pUnit->getYieldFromPillage(eYield);
					iValue += unitPillageYield.first;
					iValue += unitPillageYield.second * iEra;
				}
			}
			//Now, let's apply these yields here as total yields.
			if(iValue != 0)
			{
				//Exclusions
				if(eYield != YIELD_POPULATION)
				{
					if (iType != INSTANT_YIELD_TYPE_TR_MOVEMENT && iType != INSTANT_YIELD_TYPE_PURCHASE && iType != INSTANT_YIELD_TYPE_FAITH_PURCHASE && iType != INSTANT_YIELD_TYPE_U_PROD && iType != INSTANT_YIELD_TYPE_MINOR_QUEST_REWARD && iType != INSTANT_YIELD_TYPE_TR_MOVEMENT_IN_FOREIGN && iType != INSTANT_YIELD_TYPE_BULLY)
					{
						if (ePlayer == NO_PLAYER && eYield == YIELD_TOURISM)
						{
							//nothing
						}
						else
						{
							iValue *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
							iValue /= 100;
						}
					}

					//Exclusion for birth yields and GP expense and policy unlocks (as we do it up above to avoid % growth and religion bonuses from being scaled).
					if (bEraScale && iType != INSTANT_YIELD_TYPE_BIRTH && iType != INSTANT_YIELD_TYPE_GP_USE && iType != INSTANT_YIELD_TYPE_POLICY_UNLOCK && iType != INSTANT_YIELD_TYPE_BORDERS && iType != INSTANT_YIELD_TYPE_REMOVE_HERESY && iType != INSTANT_YIELD_TYPE_VICTORY)
					{
						iValue *= iEra;
					}
				}

				switch(eYield)
				{
					case NO_YIELD:
					UNREACHABLE();
					case YIELD_FOOD:
					{
						pLoopCity->changeFood(iValue);
						if(pLoopCity->getFood() <= 0)
						{
							pLoopCity->setFood(0);
						}
						// keep track of local yields in city
						pLoopCity->ChangeInstantYieldTotal(eYield, iValue);
					}
					break;
					case YIELD_PRODUCTION:
					{
						if ((pLoopCity->getProduction() < pLoopCity->getProductionNeeded()) && pLoopCity->isProduction())
						{
							pLoopCity->changeProduction(iValue);
						}
						else
						{
							pLoopCity->changeOverflowProduction(iValue);
						}
						if (pLoopCity->getProduction() <= 0)
						{
							pLoopCity->setProduction(0);
						}
						// keep track of local yields in city
						pLoopCity->ChangeInstantYieldTotal(eYield, iValue);
					}
					break;
					case YIELD_GOLD:
					{
						GetTreasury()->ChangeGold(iValue);
						if(GetTreasury()->GetGold() <= 0)
						{
							GetTreasury()->SetGold(0);
						}
					}
					break;
					case YIELD_SCIENCE:
					{
						TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
						if(eCurrentTech == NO_TECH)
						{
							changeOverflowResearch(iValue);
							if(getOverflowResearch() <= 0)
							{
								setOverflowResearch(0);
							}
						}
						else
						{
							GET_TEAM(getTeam()).GetTeamTechs()->ChangeResearchProgress(eCurrentTech, iValue, GetID());
							if(GET_TEAM(getTeam()).GetTeamTechs()->GetResearchProgress(eCurrentTech) <= 0)
							{
								GET_TEAM(getTeam()).GetTeamTechs()->SetResearchProgress(eCurrentTech, 0, GetID());
							}
						}
					}
					break;
					case YIELD_CULTURE:
					{
						changeJONSCulture(iValue);
						pLoopCity->ChangeJONSCultureStored(iValue);
						if(pLoopCity->GetJONSCultureStored() <= 0)
						{
							pLoopCity->SetJONSCultureStored(0);
						}
					}
					break;
					case YIELD_FAITH:
					{
						ChangeFaith(iValue);
						if(GetFaith() <= 0)
						{
							SetFaith(0);
						}
					}
					break;
					case YIELD_TOURISM:
					{
						if(ePlayer != NO_PLAYER)
						{
							int iRealInfluence = GetCulture()->ChangeInfluenceOn(ePlayer, iValue, true, true);
							iValue = iRealInfluence;

							if(pPlot != NULL && pPlot->getOwner() != NO_PLAYER && GET_PLAYER(pPlot->getOwner()).isMajorCiv())
							{
								// Show tourism spread
								if (pPlot->GetActiveFogOfWarMode() == FOGOFWARMODE_OFF)
								{
									CvString strInfluenceText;
									InfluenceLevelTypes eLevel = GetCulture()->GetInfluenceLevel(pPlot->getOwner());

									switch (eLevel)
									{
									case NO_INFLUENCE_LEVEL:
									case INFLUENCE_LEVEL_UNKNOWN:
										strInfluenceText = GetLocalizedText("TXT_KEY_CO_UNKNOWN");
										break;
									case INFLUENCE_LEVEL_EXOTIC:
										strInfluenceText = GetLocalizedText("TXT_KEY_CO_EXOTIC");
										break;
									case INFLUENCE_LEVEL_FAMILIAR:
										strInfluenceText = GetLocalizedText("TXT_KEY_CO_FAMILIAR");
										break;
									case INFLUENCE_LEVEL_POPULAR:
										strInfluenceText = GetLocalizedText("TXT_KEY_CO_POPULAR");
										break;
									case INFLUENCE_LEVEL_INFLUENTIAL:
										strInfluenceText = GetLocalizedText("TXT_KEY_CO_INFLUENTIAL");
										break;
									case INFLUENCE_LEVEL_DOMINANT:
										strInfluenceText = GetLocalizedText("TXT_KEY_CO_DOMINANT");
										break;
									}

									char text[256] = {0};
									sprintf_s(text, "[COLOR_WHITE]+%d [ICON_TOURISM][ENDCOLOR]   %s", iValue, strInfluenceText.c_str());
									SHOW_PLOT_POPUP(pPlot, GetID(), text);
								}
							}
						}
						else
						{
							GetCulture()->AddTourismAllKnownCivsWithModifiers(iValue);
						}
					}
					break;
					case YIELD_GOLDEN_AGE_POINTS:
					{
						ChangeGoldenAgeProgressMeter(iValue);
						if(GetGoldenAgeProgressMeter() <= 0)
						{
							SetGoldenAgeProgressMeter(0);
						}
					}
					break;
					case YIELD_GREAT_GENERAL_POINTS:
					{
						changeCombatExperienceTimes100(iValue * 100);
						if(getCombatExperienceTimes100() <= 0)
						{
							setCombatExperienceTimes100(0);
						}
					}
					break;
					case YIELD_GREAT_ADMIRAL_POINTS:
					{
						changeNavalCombatExperienceTimes100(iValue * 100);
						if(getNavalCombatExperienceTimes100() <= 0)
						{
							setNavalCombatExperienceTimes100(0);
						}
					}
					break;
					case YIELD_POPULATION:
					{
						if(iValue < 0 && pLoopCity->getPopulation() <= iValue)
						{
							pLoopCity->setPopulation(1);
						}
						else
						{
							pLoopCity->changePopulation(iValue, true, true);
						}
					}
					break;
					case YIELD_CULTURE_LOCAL:
					{
						if (iType == INSTANT_YIELD_TYPE_MINOR_QUEST_REWARD)
						{
							getCapitalCity()->ChangeUnmoddedHappinessFromBuildings(iValue);
						}
						else
						{
							pLoopCity->ChangeJONSCultureStored(iValue);
							if (pLoopCity->GetJONSCultureStored() <= 0)
							{
								pLoopCity->SetJONSCultureStored(0);
							}
						}
						// keep track of local yields in city
						pLoopCity->ChangeInstantYieldTotal(eYield, iValue);
					}
					break;
					case YIELD_JFD_HEALTH:
					case YIELD_JFD_DISEASE:
					case YIELD_JFD_CRIME:
					case YIELD_JFD_LOYALTY:
					case YIELD_JFD_SOVEREIGNTY:
					// JFD have no special behavior, but they are still tracked.
					// Lua scripts can access the tracked information though it
					// would probably be better to have a Lua hook instead.
					break; 
				}

				//keep track of what we're doing
				m_viInstantYieldsTotal[eYield] += iValue;


				//And now notifications.
				if(GetID() == GC.getGame().getActivePlayer() && iValue > 0)
				{
					char text[256] = {0};
					
					yieldString.Format("%s+%%d[ENDCOLOR] %s", pYieldInfo->getColorString(), pYieldInfo->getIconString());
					sprintf_s(text, yieldString, iValue);
					SHOW_PLOT_POPUP(pLoopCity->plot(), GetID(), text);

					if(citynameString == "")
					{
						citynameString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_CITY", pLoopCity->getNameKey());
					}
					if(cityyieldString != "")
					{
						cityyieldString += ", ";
					}
					if (iType == INSTANT_YIELD_TYPE_MINOR_QUEST_REWARD)
					{
						if (eYield == YIELD_CULTURE_LOCAL)
						{
							cityyieldString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_DETAILS_HAPPINESS", iValue);
						}
						else if (eYield == YIELD_JFD_LOYALTY)
						{
							cityyieldString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_DETAILS_INFLUENCE", iValue);
						}
						else if (eYield == YIELD_JFD_SOVEREIGNTY)
						{
							cityyieldString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_DETAILS_EXPERIENCE", iValue);
						}
						else if (eYield == YIELD_JFD_HEALTH && pCity == NULL)
						{
							cityyieldString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_DETAILS_GPP_GLOBAL", iValue);
						}
						else if (eYield == YIELD_JFD_HEALTH)
						{
							cityyieldString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_DETAILS_GPP", iValue);
						}
						else
						{
							cityyieldString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_DETAILS", pYieldInfo->GetDescriptionKey(), pYieldInfo->getIconString(), iValue);
						}
					}
					else if (iType == INSTANT_YIELD_TYPE_SPREAD && eYield == YIELD_JFD_LOYALTY)
					{
						cityyieldString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_DETAILS_INFLUENCE", iValue);
					}
					else
					{
						cityyieldString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_DETAILS", pYieldInfo->GetDescriptionKey(), pYieldInfo->getIconString(), iValue);
					}
 				}

				//store off this data
				if (eYield != YIELD_TOURISM)
				{
					changeInstantYieldValue(eYield, iValue);
				}
				LogInstantYield(eYield, iValue, iType, pLoopCity);
			}
		}
		if(citynameString != "" && cityyieldString != "")
		{
			citynameString += cityyieldString;
		}
		if(totalyieldString != "" && citynameString != "")
		{
			totalyieldString += "[NEWLINE]";
		}
		totalyieldString += citynameString;
	}
	CvNotifications* pNotifications = GetNotifications();
	if(!bSuppress && GetID() == GC.getGame().getActivePlayer() && pNotifications && totalyieldString != "")
	{
		Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_INSTANT_YIELD");
		if(pCity != NULL)
		{
			strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_INSTANT_YIELD_IN_CITY");
			strSummary << pCity->getNameKey();
		}
		Localization::String localizedText;
		switch(iType)
		{
			case INSTANT_YIELD_TYPE_MINOR_QUEST_REWARD:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					CvString MoreData = NULL;
					if (pQuestData != NULL)
					{
						const char* MinorName = GET_PLAYER(pQuestData->GetMinor()).getNameKey();
						switch (pQuestData->GetType())
						{
						case NO_MINOR_CIV_QUEST_TYPE:
							UNREACHABLE();
						case MINOR_CIV_QUEST_ROUTE:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_ROUTE_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_KILL_CAMP:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_KILL_CAMP_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_CONNECT_RESOURCE:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_CONNECT_RESOURCE_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_CONSTRUCT_WONDER:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_CONSTRUCT_WONDER_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_GREAT_PERSON:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_GREAT_PERSON_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_KILL_CITY_STATE:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_KILL_CITY_STATE_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_FIND_PLAYER:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_FIND_PLAYER_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_FIND_NATURAL_WONDER:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_FIND_NATURAL_WONDER_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_GIVE_GOLD:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_GIVE_GOLD_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_PLEDGE_TO_PROTECT:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_PLEDGE_TO_PROTECT_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_CONTEST_CULTURE:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_CONTEST_CULTURE_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_CONTEST_FAITH:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_CONTEST_FAITH_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_CONTEST_TECHS:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_CONTEST_TECHS_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_INVEST:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_INVEST_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_BULLY_CITY_STATE:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_BULLY_CITY_STATE_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_DENOUNCE_MAJOR:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_DENOUNCE_MAJOR_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_SPREAD_RELIGION:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_SPREAD_RELIGION_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_TRADE_ROUTE:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_TRADE_ROUTE_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_WAR:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_WAR_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_CONSTRUCT_NATIONAL_WONDER:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_CONSTRUCT_NATIONAL_WONDER_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_GIFT_SPECIFIC_UNIT:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_GIFT_SPECIFIC_UNIT_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_FIND_CITY_STATE:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_FIND_CITY_STATE_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_INFLUENCE:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_INFLUENCE_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_CONTEST_TOURISM:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_CONTEST_TOURISM_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_ARCHAEOLOGY:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_ARCHAEOLOGY_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_CIRCUMNAVIGATION:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_CIRCUMNAVIGATION_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_LIBERATION:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_LIBERATION_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_HORDE:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_HORDE_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_REBELLION:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_REBELLION_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_DISCOVER_PLOT:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_DISCOVER_PLOT_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_BUILD_X_BUILDINGS:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_BUILD_X_BUILDINGS_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_UNIT_STEAL_FROM:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_UNIT_STEAL_FROM_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_UNIT_COUP_CITY:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_UNIT_COUP_CITY_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_UNIT_GET_CITY:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_UNIT_GET_CITY_NAME", MinorName);
							break;
						}
					}

					if (MoreData != NULL)
					{
						localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_MINOR_QUEST");
						localizedText << MoreData;
						localizedText << totalyieldString;
						//We do this at the player level once per turn.
						addInstantYieldText(iType, localizedText.toUTF8());
					}
					else
					{
						localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_MINOR_QUEST");
						localizedText << "";
						localizedText << totalyieldString;
						//We do this at the player level once per turn.
						addInstantYieldText(iType, localizedText.toUTF8());
					}
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_BIRTH:
			case INSTANT_YIELD_TYPE_BIRTH_HOLY_CITY:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_BIRTH");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_BIRTH_RETROACTIVE:
			{
				if (getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_BIRTH_RETROACTIVE");
					localizedText << totalyieldString;
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
				}
				break;
			}

			case INSTANT_YIELD_TYPE_TECH_RETROACTIVE:
			{
				if (getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_TECH_RETROACTIVE");
					localizedText << totalyieldString;
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
				}
				break;
			}

			case INSTANT_YIELD_TYPE_REFUND:
			{
				if (getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_REFUND");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			
			case INSTANT_YIELD_TYPE_ERA_UNLOCK:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_ERA");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_POLICY_UNLOCK:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_POLICY");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_INSTANT:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_INSTANT");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_TECH:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_TECH");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_CONSTRUCTION:
			case INSTANT_YIELD_TYPE_CONSTRUCTION_WONDER:
			{
				if (ePassBuilding != NO_BUILDING)
				{
					CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(ePassBuilding);
					if(pkBuildingInfo)
					{
						if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
						{
							localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_CONSTRUCTION");
							localizedText << totalyieldString;
							localizedText << pkBuildingInfo->GetDescriptionKey();
							//We do this at the player level once per turn.
							addInstantYieldText(iType, localizedText.toUTF8());
						}
						else
						{
							localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
							localizedText << totalyieldString << pkBuildingInfo->GetDescriptionKey();
							//We do this at the player level once per turn.
							addInstantYieldText(iType, localizedText.toUTF8());
						}
					}
				}
				return;
			}
			case INSTANT_YIELD_TYPE_BORDERS:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_BORDERS");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_PROPOSAL:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_PROPOSAL");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_GP_USE:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_GP_USE");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_GP_BORN:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_GP_BORN");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_F_CONQUEST:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_CONQUEST");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_VICTORY:
			case INSTANT_YIELD_TYPE_VICTORY_GLOBAL:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_VICTORY");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_PILLAGE:
			case INSTANT_YIELD_TYPE_PILLAGE_GLOBAL:
			case INSTANT_YIELD_TYPE_PILLAGE_UNIT:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_PILLAGE");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_U_PROD:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_UNIT_PRODUCTION");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_PURCHASE:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_PURCHASE");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_TILE_PURCHASE:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_TILE_PURCHASE");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_FOUND:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_FOUND");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_TR_END:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_TRADE_ROUTE");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_CONVERSION:
			case INSTANT_YIELD_TYPE_CONVERSION_EXPO:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_CONVERSION");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_DEATH:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_DEATH");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_BULLY:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_BULLY");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_SPREAD:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_SPREAD");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_F_SPREAD:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_FOREIGN_SPREAD");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_DELEGATES:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_DELEGATES");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_SPY_DEFENSE:
			case INSTANT_YIELD_TYPE_SPY_ATTACK:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_SPIES");
				localizedText << totalyieldString;
				break;
			}
			
			case INSTANT_YIELD_TYPE_TR_MOVEMENT:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_TR_MOVEMENT");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_SCOUTING:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_SCOUTING");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_LEVEL_UP:
			{
				if(pUnit != NULL)
				{
					CvUnitEntry* pkUnitInfo = GC.getUnitInfo(pUnit->getUnitType());
					if(pkUnitInfo)
					{
						localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_LEVEL_UP");
						localizedText << totalyieldString;
						localizedText << pkUnitInfo->GetDescriptionKey();
						break;
					}
				}
			}	
			case INSTANT_YIELD_TYPE_CULTURE_BOMB:
			{
				if (getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_CULTURE_BOMB");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_REMOVE_HERESY:
			{
				if (getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_REMOVE_HERESY");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_FAITH_PURCHASE:
			{
				if (getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_FAITH_PURCHASE");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_PROMOTION_OBTAINED:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_PROMOTION_OBTAINED");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_BARBARIAN_CAMP_CLEARED:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_BARBARIAN_CAMP_CLEARED");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_TR_PRODUCTION_SIPHON:
			{
				if (getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_TR_PRODUCTION_SIPHON");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_TR_MOVEMENT_IN_FOREIGN:
			{
				if (getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_TR_MOVEMENT_IN_FOREIGN");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_IMPROVEMENT_BUILD:
			{
				if (getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_IMPROVEMENT_BUILD");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_LUA:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_INSTANT");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_RESEARCH_AGREMEENT:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_RESEARCH_AGREEMENT");
				localizedText << totalyieldString;
				break;
			}
		}
		if(pCity == NULL)
		{
			CvCity* pCapitalCity = getCapitalCity();
			if(pCapitalCity != NULL)
			{
				pNotifications->Add((NotificationTypes)FString::Hash("NOTIFICATION_INSTANT_YIELD"), localizedText.toUTF8(), strSummary.toUTF8(), pCapitalCity->getX(), pCapitalCity->getY(), pCapitalCity->GetID());
			}
		}
		else
		{
			pNotifications->Add((NotificationTypes)FString::Hash("NOTIFICATION_INSTANT_YIELD"), localizedText.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), pCity->GetID());
		}
	}
}
void CvPlayer::addInstantYieldText(InstantYieldType iType, const CvString& strInstantYield)
{
	VALIDATE_OBJECT
	CvAssertMsg(iType >= 0, "iType expected to be >= 0");
	CvAssertMsg(iType < NUM_INSTANT_YIELD_TYPES, "iType expected to be < NUM_INSTANT_YIELD_TYPES");

	m_aistrInstantYield[iType] = m_aistrInstantYield[iType] + strInstantYield;
}
void CvPlayer::setInstantYieldText(InstantYieldType iType, const CvString& strInstantYield)
{
	VALIDATE_OBJECT
	CvAssertMsg(iType >= 0, "iType expected to be >= 0");
	CvAssertMsg(iType < NUM_INSTANT_YIELD_TYPES, "iType expected to be < NUM_INSTANT_YIELD_TYPES");
	m_aistrInstantYield[iType] = strInstantYield;
}
CvString CvPlayer::getInstantYieldText(InstantYieldType iType) const
{
	VALIDATE_OBJECT
	CvAssertMsg(iType >= 0, "iType expected to be >= 0");
	CvAssertMsg(iType < NUM_INSTANT_YIELD_TYPES, "iType expected to be < NUM_INSTANT_YIELD_TYPES");
	return m_aistrInstantYield[iType];
}
void CvPlayer::doInstantGWAM(GreatPersonTypes eGreatPerson, const CvString& strName, bool bConquest)
{
	CvCity* pCapital = getCapitalCity();
	int iEventGP = 0;
	if (bConquest)
		iEventGP += GetPlayerTraits()->GetCityConquestGWAM();
	else
		iEventGP += GetPlayerTraits()->GetGreatPersonGWAM(eGreatPerson);

	if (pCapital != NULL && iEventGP > 0)
	{
		int iGPWriter = 0;
		int iGPArtist = 0;
		int iGPMusician = 0;
		for (int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
		{
			const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iSpecialistLoop);
			CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
			if (pkSpecialistInfo)
			{
				if ((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_WRITER"))
				{
					iGPWriter = pCapital->GetCityCitizens()->GetSpecialistUpgradeThreshold((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass());
					iGPWriter *= 100;
					//Get % of threshold for test.
					iGPWriter *= iEventGP;
					iGPWriter /= 100;

					pCapital->GetCityCitizens()->ChangeSpecialistGreatPersonProgressTimes100(eSpecialist, iGPWriter, true);
				}
				if ((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_ARTIST"))
				{
					iGPArtist = pCapital->GetCityCitizens()->GetSpecialistUpgradeThreshold((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass());
					iGPArtist *= 100;
					//Get % of threshold for test.
					iGPArtist *= iEventGP;
					iGPArtist /= 100;

					pCapital->GetCityCitizens()->ChangeSpecialistGreatPersonProgressTimes100(eSpecialist, iGPArtist, true);

				}
				if ((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_MUSICIAN"))
				{
					iGPMusician = pCapital->GetCityCitizens()->GetSpecialistUpgradeThreshold((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass());
					iGPMusician *= 100;
					//Get % of threshold for test.
					iGPMusician *= iEventGP;
					iGPMusician /= 100;

					pCapital->GetCityCitizens()->ChangeSpecialistGreatPersonProgressTimes100(eSpecialist, iGPMusician, true);
				}
			}
		}
		if (GetID() == GC.getGame().getActivePlayer())
		{
			iGPWriter /= 100;
			iGPArtist /= 100;
			iGPMusician /= 100;
			CvNotifications* pNotification = GetNotifications();
			if (pNotification)
			{
				Localization::String strMessage = "";
				if (bConquest)
				{
					strMessage = Localization::Lookup("TXT_KEY_TOURISM_EVENT_GWAM_BONUS_CONQUEST");
					strMessage << iGPWriter;
					strMessage << iGPArtist;
					strMessage << iGPMusician;
					strMessage << strName.c_str();
				}
				else
				{
					strMessage = Localization::Lookup("TXT_KEY_TOURISM_EVENT_GWAM_BONUS_SAKOKU");
					strMessage << iGPWriter;
					strMessage << iGPArtist;
					strMessage << iGPMusician;
					strMessage << strName.c_str();
				}
				
				Localization::String strSummary = "";
				if (bConquest)
					strSummary = Localization::Lookup("TXT_KEY_TOURISM_EVENT_GWAM_BONUS_CONQUEST_S");
				else
					strSummary = Localization::Lookup("TXT_KEY_TOURISM_EVENT_GWAM_BONUS_SAKOKU_S");

				pNotification->Add(NOTIFICATION_GOLDEN_AGE_BEGUN_ACTIVE_PLAYER, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, -1);
			}
		}
	}
}
//	--------------------------------------------------------------------------------
void CvPlayer::doPolicyGEorGM(int iPolicyGEorGM)
{
	CvCity* pLoopCity;
	CvCity* pCapital = getCapitalCity();
	int iLoop;
	int iEra = GetCurrentEra();
	if (iEra < 1)
	{
		iEra = 1;
	}
	int iValue = iPolicyGEorGM * iEra * GC.getGame().getGameSpeedInfo().getInstantYieldPercent(); // Game speed mod (note that TrainPercent is a percentage value, will need to divide by 100)

	SpecialistTypes eBestSpecialist = NO_SPECIALIST;
	int iRandom = GC.getGame().getSmallFakeRandNum(100, GetPseudoRandomSeed()+iPolicyGEorGM);
	if (iRandom <= 33)
	{
		eBestSpecialist = (SpecialistTypes)GC.getInfoTypeForString("SPECIALIST_ENGINEER");
	}
	else if (iRandom > 34 && iRandom <= 66)
	{
		eBestSpecialist = (SpecialistTypes)GC.getInfoTypeForString("SPECIALIST_SCIENTIST");
	}
	else if (iRandom > 66)
	{
		eBestSpecialist = (SpecialistTypes)GC.getInfoTypeForString("SPECIALIST_MERCHANT");
	}
	if (eBestSpecialist != NO_SPECIALIST && pCapital != NULL)
	{
		CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eBestSpecialist);
		if (pkSpecialistInfo)
		{
			int iGPThreshold = pCapital->GetCityCitizens()->GetSpecialistUpgradeThreshold((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass());
			iGPThreshold *= 100;
			//Get % of threshold for test.
			iGPThreshold *= iPolicyGEorGM;
			iGPThreshold /= 100;
			int iGPThresholdString = iGPThreshold / 100;

			for (pLoopCity = this->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = this->nextCity(&iLoop))
			{
				if (eBestSpecialist == (SpecialistTypes)GC.getInfoTypeForString("SPECIALIST_ENGINEER"))
				{
					pLoopCity->changeProduction((iValue * 2) / 100); // Production yield is 2x of science. Dividing by 100 here to minimise rounding error.
				}
				else if (eBestSpecialist == (SpecialistTypes)GC.getInfoTypeForString("SPECIALIST_MERCHANT"))
				{
					this->GetTreasury()->ChangeGold((iValue * 4) / 100); // Gold yield is 4x of science, 2x of production. Dividing by 100 here to minimise rounding error.
				}
				else if (eBestSpecialist == (SpecialistTypes)GC.getInfoTypeForString("SPECIALIST_SCIENTIST"))
				{
					TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
					if (eCurrentTech == NO_TECH)
					{
						changeOverflowResearch(iValue / 100); // Dividing by 100 here to minimise rounding error.
						if (getOverflowResearch() <= 0)
						{
							setOverflowResearch(0);
						}
					}
					else
					{
						GET_TEAM(getTeam()).GetTeamTechs()->ChangeResearchProgress(eCurrentTech, (iValue / 100), GetID()); // Dividing by 100 here to minimise rounding error.
						if (GET_TEAM(getTeam()).GetTeamTechs()->GetResearchProgress(eCurrentTech) <= 0)
						{
							GET_TEAM(getTeam()).GetTeamTechs()->SetResearchProgress(eCurrentTech, 0, GetID());
						}
					}
				}
				pLoopCity->GetCityCitizens()->ChangeSpecialistGreatPersonProgressTimes100(eBestSpecialist, iGPThreshold, true);
				if (GetID() == GC.getGame().getActivePlayer()) // The popup shows the specific great person type's icon
				{
					if (eBestSpecialist == (SpecialistTypes)GC.getInfoTypeForString("SPECIALIST_ENGINEER"))
					{
						char text[256] = { 0 };

						sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_GREAT_ENGINEER]", iGPThresholdString);
						SHOW_PLOT_POPUP(pLoopCity->plot(), GetID(),  text);
						char text2[256] = { 0 };
						sprintf_s(text2, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_PRODUCTION]", (iValue * 2 / 100));
						SHOW_PLOT_POPUP(pLoopCity->plot(), GetID(),  text2);
					}
					else if (eBestSpecialist == (SpecialistTypes)GC.getInfoTypeForString("SPECIALIST_MERCHANT"))
					{
						char text[256] = { 0 };

						sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_GREAT_MERCHANT]", iGPThresholdString);
						SHOW_PLOT_POPUP(pLoopCity->plot(), GetID(),  text);
						char text2[256] = { 0 };
						sprintf_s(text2, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_GOLD]", (iValue * 4 / 100));
						SHOW_PLOT_POPUP(pLoopCity->plot(), GetID(),  text2);
					}
					else if (eBestSpecialist == (SpecialistTypes)GC.getInfoTypeForString("SPECIALIST_SCIENTIST"))
					{
						char text[256] = { 0 };

						sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_GREAT_SCIENTIST]", iGPThresholdString);
						SHOW_PLOT_POPUP(pLoopCity->plot(), GetID(),  text);
						char text2[256] = { 0 };
						sprintf_s(text2, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_RESEARCH]", (iValue / 100));
						SHOW_PLOT_POPUP(pLoopCity->plot(), GetID(),  text2);
					}
				}
			} //end of for loop
			if (GetID() == GC.getGame().getActivePlayer()) // Moved notification outside of for loop as it was flooding the screen
			{
				CvNotifications* pNotification = GetNotifications();
				if (pNotification)
				{
					CvString strMessage = GetLocalizedText("TXT_KEY_POLICY_ADOPT_GP_BONUS", iGPThresholdString);
					CvString strSummary;
					// Class specific specialist message
					if ((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_MERCHANT"))
					{
						strMessage = GetLocalizedText("TXT_KEY_POLICY_ADOPT_GP_BONUS_MERCHANT", iGPThresholdString, (iValue * 4 / 100));
					}
					else if ((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_ENGINEER"))
					{
						strMessage = GetLocalizedText("TXT_KEY_POLICY_ADOPT_GP_BONUS_ENGINEER", iGPThresholdString, (iValue * 2 / 100));
					}
					else if ((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_SCIENTIST"))
					{
						strMessage = GetLocalizedText("TXT_KEY_POLICY_ADOPT_GP_BONUS_SCIENTIST", iGPThresholdString, (iValue / 100));
					}
					strSummary = GetLocalizedText("TXT_KEY_POLICY_ADOPT_SUMMARY_GP_BONUS");
					pNotification->Add(NOTIFICATION_GOLDEN_AGE_BEGUN_ACTIVE_PLAYER, strMessage, strSummary, -1, -1, -1);
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::doInstantGreatPersonProgress(InstantYieldType iType, bool bSuppress, CvCity* pCity, BuildingTypes eBuilding, int iPassValue, GreatPersonTypes ePassGreatPerson)
{
	CvCity* pLoopCity;
	CvCity* pCapital = getCapitalCity();
	int iLoop;
	CvString totalgpString = "";

	for (pLoopCity = this->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = this->nextCity(&iLoop))
	{
		if (pLoopCity == NULL)
			continue;

		//If we passed in a city, only check that city.
		if (pCity != NULL && pLoopCity != pCity)
			continue;

		// Puppets are not supposed to get GP points
		if (MOD_BALANCE_CORE_PUPPET_CHANGES && pLoopCity->IsPuppet())
			continue;

		CvString gpString = "";
		CvString citygpString = "";
		CvString citynameString = "";

		SpecialistTypes eSpecialist;

		for (int iGreatPersonTypes = 0; iGreatPersonTypes < GC.getNumGreatPersonInfos(); iGreatPersonTypes++)
		{
			GreatPersonTypes eGreatPerson = (GreatPersonTypes)iGreatPersonTypes;
			if (eGreatPerson == NO_GREATPERSON || pCapital == NULL)
				continue;

			if (ePassGreatPerson != NO_GREATPERSON && ePassGreatPerson != eGreatPerson)
				continue;

			eSpecialist = (SpecialistTypes)GC.getGreatPersonInfo(eGreatPerson)->GetSpecialistType();
			if (eSpecialist == NO_SPECIALIST)
				continue;

			// 1st step: Get the percent to progress towards the next GP
			int iValue = 0;
			switch (iType)
			{
				case INSTANT_YIELD_TYPE_POLICY_UNLOCK:
				{
					if (pLoopCity->isCapital() == true)
					{
						iValue += GetPlayerTraits()->GetGreatPersonProgressFromPolicyUnlock(eGreatPerson);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_CONSTRUCTION:
				{
					if (eBuilding != NO_BUILDING)
					{
						TechTypes eTech = (TechTypes)GC.getBuildingInfo(eBuilding)->GetPrereqAndTech();
						int iEra;
						if (eTech == NO_TECH)
						{
							iEra = 0;
						}
						else
						{
							iEra = GC.getTechInfo(eTech)->GetEra();
						}
						for (int iLoopEra = 0; iLoopEra <= iEra; ++iLoopEra)
						{
							iValue += pLoopCity->GetGreatPersonProgressFromConstruction(eGreatPerson, (EraTypes)iLoopEra);
						}
					}
					break;
				}
				case INSTANT_YIELD_TYPE_VICTORY:
				{
					// if nothing was passed in, we just take from the Trait_GreatPersonProgressFromKills table
					if (iPassValue == 0 && ePassGreatPerson == NO_GREATPERSON)
					{
						iValue += GetPlayerTraits()->GetGreatPersonProgressFromKills(eGreatPerson);
					}
					// if there is a great person passed in, we use the Trait_RandomGreatPersonProgressFromKills table (called by the caller already)
					else if (ePassGreatPerson == eGreatPerson)
					{
						iValue += iPassValue;
					}
					break;
				}
				default:
				UNREACHABLE(); // Other types should never be passed into this function.
			}

			// 2nd step: Apply the desired amount of GP points to the loop city
			if (iValue != 0)
			{
				CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
				if (pkSpecialistInfo)
				{
					int iGPThreshold = pCapital->GetCityCitizens()->GetSpecialistUpgradeThreshold((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass());
					iGPThreshold *= 100;
					//Get % of threshold for test.
					iGPThreshold *= iValue;
					iGPThreshold /= 100;
					int iGPThresholdString = iGPThreshold / 100;
					CvGreatPersonInfo* pGreatPerson = GC.getGreatPersonInfo(eGreatPerson);
					pLoopCity->GetCityCitizens()->ChangeSpecialistGreatPersonProgressTimes100(eSpecialist, iGPThreshold, false); // Dont spawn the GP yet, so the points given to all cities remain the same
					// 3rd step: Notifications
					if (GetID() == GC.getGame().getActivePlayer() && iValue > 0)
					{
						char text[256] = { 0 };
						
						gpString.Format("%s+%%d[ENDCOLOR] %s", "[COLOR_WHITE]", pGreatPerson->GetIconString());
						sprintf_s(text, gpString, iGPThresholdString);
						SHOW_PLOT_POPUP(pLoopCity->plot(), GetID(),  text);
					}
					if (citynameString == "")
					{
						citynameString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_CITY", pLoopCity->getNameKey());
					}
					if (citygpString != "")
					{
						citygpString += ", ";
					}
					citygpString += GetLocalizedText("TXT_KEY_INSTANT_GREAT_PERSON_PROGRESS_DETAILS", pGreatPerson->GetDescriptionKey(), pGreatPerson->GetIconString(), iGPThresholdString);
				}
			}
		}
		if (citynameString != "" && citygpString != "")
		{
			citynameString += citygpString;
		}
		if (totalgpString != "" && citynameString != "")
		{
			totalgpString += "[NEWLINE]";
		}
		totalgpString += citynameString;
	}
	CvNotifications* pNotifications = GetNotifications();
	if (!bSuppress && GetID() == GC.getGame().getActivePlayer() && pNotifications && totalgpString != "")
	{
		Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_GREAT_PERSON_PROGRESS");
		if (pCity != NULL)
		{
			strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_GREAT_PERSON_PROGRESS_IN_CITY");
			strSummary << pCity->getNameKey();
		}
		Localization::String localizedText;
		bool bImmediate = false;
		switch (iType)
		{
			case INSTANT_YIELD_TYPE_POLICY_UNLOCK:
			{
				if (getInstantGreatPersonProgressText(iType) == "" || getInstantGreatPersonProgressText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_POLICY");
					localizedText << totalgpString;
					//We do this at the player level once per turn.
					addInstantGreatPersonProgressText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalgpString;
					//We do this at the player level once per turn.
					addInstantGreatPersonProgressText(iType, localizedText.toUTF8());
				}
				break;
			}
			case INSTANT_YIELD_TYPE_CONSTRUCTION:
			{
				if (eBuilding != NO_BUILDING)
				{
					CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
					if (pkBuildingInfo)
					{
						if (getInstantGreatPersonProgressText(iType) == "" || getInstantGreatPersonProgressText(iType) == NULL)
						{
							localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_CONSTRUCTION");
							localizedText << totalgpString << pkBuildingInfo->GetDescriptionKey();
							//We do this at the player level once per turn.
							addInstantGreatPersonProgressText(iType, localizedText.toUTF8());
						}
						else
						{
							localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
							localizedText << totalgpString << pkBuildingInfo->GetDescriptionKey();
							//We do this at the player level once per turn.
							addInstantGreatPersonProgressText(iType, localizedText.toUTF8());
						}
					}
				}
				break;
			}
			case INSTANT_YIELD_TYPE_VICTORY:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_VICTORY");
				localizedText << totalgpString;
				bImmediate = true;
				break;
			}
			default:
			UNREACHABLE(); // Other types should never be passed into this function.
		}
		if (bImmediate)
		{
			if (pCity == NULL)
			{
				if (pCapital != NULL)
				{
					pNotifications->Add((NotificationTypes)FString::Hash("NOTIFICATION_INSTANT_YIELD"), localizedText.toUTF8(), strSummary.toUTF8(), pCapital->getX(), pCapital->getY(), pCapital->GetID());
				}
			}
			else
			{
				pNotifications->Add((NotificationTypes)FString::Hash("NOTIFICATION_INSTANT_YIELD"), localizedText.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), pCity->GetID());
			}
		}
	}
	// 4th step: Loop through all cities again to check for GP spawns
	for (pLoopCity = this->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = this->nextCity(&iLoop))
	{
		if (pLoopCity == NULL)
			continue;
		for (int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
		{
			const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iSpecialistLoop);
			CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
			if (pkSpecialistInfo)
			{
				int iCheckGPThreshold = pLoopCity->GetCityCitizens()->GetSpecialistUpgradeThreshold((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass());
				// Enough to spawn a GP?
				if (pLoopCity->GetCityCitizens()->GetSpecialistGreatPersonProgress(eSpecialist) >= iCheckGPThreshold)
				{
					// No Minors
					if (!GET_PLAYER(pLoopCity->getOwner()).isMinorCiv())
					{
						// Reset progress on this Specialist
						pLoopCity->GetCityCitizens()->DoResetSpecialistGreatPersonProgressTimes100(eSpecialist, (iCheckGPThreshold * 100));

						// Now... actually create the GP!
						const UnitClassTypes eUnitClass = (UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass();
						if (eUnitClass != NO_UNITCLASS)
						{
							UnitTypes eUnit = GetSpecificUnitType(eUnitClass);

#if defined(MOD_GLOBAL_TRULY_FREE_GP)
							pLoopCity->GetCityCitizens()->DoSpawnGreatPerson(eUnit, true, false, false);
#else
							pLoopCity->GetCityCitizens()->DoSpawnGreatPerson(eUnit, true, false);
#endif
						}
					}
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::addInstantGreatPersonProgressText(InstantYieldType iType, const CvString& strInstantYield)
{
	VALIDATE_OBJECT
	CvAssertMsg(iType >= 0, "iType expected to be >= 0");
	CvAssertMsg(iType < NUM_INSTANT_YIELD_TYPES, "iType expected to be < NUM_INSTANT_YIELD_TYPES");

	std::map<int, CvString>::iterator it = m_aistrInstantGreatPersonProgress.find((int)iType);
	if (it != m_aistrInstantGreatPersonProgress.end())
	{
		it->second += strInstantYield;
	}
	else
	{
		m_aistrInstantGreatPersonProgress.insert(std::make_pair((int)iType, strInstantYield));
	}
}
void CvPlayer::setInstantGreatPersonProgressText(InstantYieldType iType, const CvString& strInstantYield)
{
	VALIDATE_OBJECT
	CvAssertMsg(iType >= 0, "iType expected to be >= 0");
	CvAssertMsg(iType < NUM_INSTANT_YIELD_TYPES, "iType expected to be < NUM_INSTANT_YIELD_TYPES");

	std::map<int, CvString>::iterator it = m_aistrInstantGreatPersonProgress.find((int)iType);
	if (it != m_aistrInstantGreatPersonProgress.end())
	{
		it->second = strInstantYield;
	}
	else
	{
		m_aistrInstantGreatPersonProgress.insert(std::make_pair((int)iType, strInstantYield));
	}
}
CvString CvPlayer::getInstantGreatPersonProgressText(InstantYieldType iType) const
{
	VALIDATE_OBJECT
	CvAssertMsg(iType >= 0, "iType expected to be >= 0");
	CvAssertMsg(iType < NUM_INSTANT_YIELD_TYPES, "iType expected to be < NUM_INSTANT_YIELD_TYPES");

	std::map<int, CvString>::const_iterator it = m_aistrInstantGreatPersonProgress.find((int)iType);
	if (it != m_aistrInstantGreatPersonProgress.end())
	{
		return it->second;
	}
	else
	{
		return "";
	}
}
#endif
//	--------------------------------------------------------------------------------
/// Do effects when a GP is consumed
#if defined(MOD_EVENTS_GREAT_PEOPLE)
void CvPlayer::DoGreatPersonExpended(UnitTypes eGreatPersonUnit, CvUnit* pGreatPersonUnit)
#else
void CvPlayer::DoGreatPersonExpended(UnitTypes eGreatPersonUnit)
#endif
{
	// Gold gained
	int iExpendGold = GetGreatPersonExpendGold();
	if(iExpendGold > 0)
	{
#if defined(MOD_BALANCE_CORE)
		iExpendGold *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
		iExpendGold /= 100;
#endif
		GetTreasury()->ChangeGold(iExpendGold);

#if defined(MOD_API_ACHIEVEMENTS)
		if(isHuman() && !GC.getGame().isGameMultiPlayer() && GET_PLAYER(GC.getGame().getActivePlayer()).isLocalPlayer())
		{
			// Update Steam stat and check achievement
			const int HALICARNASSUS_ACHIEVEMENT_GOLD = 1000;
			int iHalicarnassus = GC.getInfoTypeForString("BUILDINGCLASS_MAUSOLEUM_HALICARNASSUS");
			// Does player have DLC_06, and if so, do they have the Mausoleum of Halicarnassus?
			if(iHalicarnassus != -1 && getBuildingClassCount((BuildingClassTypes)iHalicarnassus) >= 1)
			{
				BuildingTypes eHalicarnassus = (BuildingTypes)GC.getInfoTypeForString("BUILDING_MAUSOLEUM_HALICARNASSUS");
				CvBuildingEntry* pHalicarnassusInfo = GC.getBuildingInfo(eHalicarnassus);
				int iHalicarnassusGold = pHalicarnassusInfo->GetGreatPersonExpendGold();

				int32 iTotalHalicarnassusGold = 0;
				if(gDLL->GetSteamStat(ESTEAMSTAT_HALICARNASSUSGOLDEARNED, &iTotalHalicarnassusGold))
				{
					iTotalHalicarnassusGold += iHalicarnassusGold;
					gDLL->SetSteamStat(ESTEAMSTAT_HALICARNASSUSGOLDEARNED, iTotalHalicarnassusGold);
					if(iTotalHalicarnassusGold >= HALICARNASSUS_ACHIEVEMENT_GOLD)
					{
						gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_HALICARNASSUS_GOLD);
					}
				}
			}
		}
#endif
	}

	if (pGreatPersonUnit)
	{
		//great diplomat grants a paper resource - admiral code is handled in CvUnit::createFreeLuxury()
		for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
		{
			int Gained = pGreatPersonUnit->getUnitInfo().GetResourceQuantityExpended((ResourceTypes)iResourceLoop);
			if (Gained != 0)
			{
				changeResourceFromGP((ResourceTypes)iResourceLoop, Gained);
			}
		}

		//general grants supply points
		int iSupply = pGreatPersonUnit->getUnitInfo().GetSupplyCapBoost() + pGreatPersonUnit->GetMilitaryCapChange();
		if (iSupply > 0)
		{
			ChangeUnitSupplyFromExpendedGreatPeople(iSupply);
			m_iNumUnitsSuppliedCached = -1; //force recalculation

			if (GetID() == GC.getGame().getActivePlayer())
			{
				char text[256] = { 0 };

				sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_WAR]", iSupply);
				SHOW_PLOT_POPUP( pGreatPersonUnit->plot(), GetID(), text);

				CvNotifications* pNotification = GetNotifications();
				if (pNotification)
				{
					CvString strMessage;
					CvString strSummary;
					strMessage = GetLocalizedText("TXT_KEY_UNIT_EXPENDED_SUPPLY", pGreatPersonUnit->getName().c_str(), iSupply);
					strSummary = GetLocalizedText("TXT_KEY_UNIT_EXPENDED_SUPPLY_S");
					pNotification->Add(NOTIFICATION_GENERIC, strMessage, strSummary, pGreatPersonUnit->getX(), pGreatPersonUnit->getY(), GetID());
				}
			}
		}
	}

#if defined(MOD_BALANCE_CORE_POLICIES)
	//Influence Gained with all CS per expend
	int iExpendInfluence = GetInfluenceGPExpend() + GetGPExpendInfluence(); 
	if(iExpendInfluence > 0)
	{
		for (int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
		{
			PlayerTypes eMinorLoop = (PlayerTypes) iMinorLoop;
			if(eMinorLoop != NO_PLAYER)
			{
				CvPlayer* pMinorLoop = &GET_PLAYER(eMinorLoop);
				if(pMinorLoop->isMinorCiv() && pMinorLoop->isAlive())
				{
					if(GET_TEAM(pMinorLoop->getTeam()).isHasMet(getTeam()))
					{
						pMinorLoop->GetMinorCivAI()->ChangeFriendshipWithMajor(GetID(), iExpendInfluence, false);
					}
				}
			}
		}
	}
	GreatPersonTypes eGreatPerson = GetGreatPersonFromUnitClass(pGreatPersonUnit->getUnitClassType());
	doInstantYield(INSTANT_YIELD_TYPE_GP_USE, false, eGreatPerson);
#endif

#if defined(MOD_EVENTS_GREAT_PEOPLE)
	if (MOD_EVENTS_GREAT_PEOPLE) {
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_GreatPersonExpended, GetID(), pGreatPersonUnit->GetID(), eGreatPersonUnit, pGreatPersonUnit->getX(), pGreatPersonUnit->getY());
	} else {
#endif
	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if (pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(eGreatPersonUnit);

		bool bResult;
		LuaSupport::CallHook(pkScriptSystem, "GreatPersonExpended", args.get(), bResult);
	}
#if defined(MOD_EVENTS_GREAT_PEOPLE)
	}
#endif
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetGreatPersonExpendGold() const
{
	return m_iGreatPersonExpendGold;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeGreatPersonExpendGold(int ichange)
{
	m_iGreatPersonExpendGold += ichange;
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
//	Calculate score-scaled ArtsyGreatPersonRateModifier
int CvPlayer::getArtsyGreatPersonRateModifier()
{
	return GC.getGame().GetGameLeagues()->GetArtsyGreatPersonRateModifier(GetID());
}
//	Calculate score-scaled ScienceyGreatPersonRateModifier
int CvPlayer::getScienceyGreatPersonRateModifier()
{
	return GC.getGame().GetGameLeagues()->GetScienceyGreatPersonRateModifier(GetID());
}
#endif

//	--------------------------------------------------------------------------------
void CvPlayer::recomputeGreatPeopleModifiers()
{
	//=============
	// Initialize
	//=============
	m_iGreatPeopleRateModifier = 0;
	m_iGreatGeneralRateModifier = 0;
	m_iGreatAdmiralRateModifier = 0;
	m_iGreatWriterRateModifier = 0;
	m_iGreatArtistRateModifier = 0;
	m_iGreatMusicianRateModifier = 0;
	m_iGreatMerchantRateModifier = 0;
	m_iGreatDiplomatRateModifier = 0;
	m_iGreatScientistRateModifier = 0;
	m_iGreatEngineerRateModifier = 0;
	m_iDomesticGreatGeneralRateModifier = 0;

	// Get from traits first
	m_iGreatPeopleRateModifier += m_pTraits->GetGreatPeopleRateModifier();
	m_iGreatGeneralRateModifier += m_pTraits->GetGreatGeneralRateModifier();
	m_iGreatScientistRateModifier += m_pTraits->GetGreatScientistRateModifier();
#if defined(MOD_BALANCE_CORE)
	m_iGreatGeneralRateModifier += (m_pTraits->GetGGGARateFromDenunciationsAndWars()) * (GetDiplomacyAI()->GetNumDenouncements() + GET_TEAM(getTeam()).getAtWarCount(true));
	m_iGreatAdmiralRateModifier += (m_pTraits->GetGGGARateFromDenunciationsAndWars()) * (GetDiplomacyAI()->GetNumDenouncements() + GET_TEAM(getTeam()).getAtWarCount(true));
#endif

	// Then get from current policies
	m_iGreatPeopleRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_PERSON_RATE);
	m_iGreatGeneralRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_GENERAL_RATE);
	m_iGreatAdmiralRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_ADMIRAL_RATE);
	m_iGreatWriterRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_WRITER_RATE);
	m_iGreatArtistRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_ARTIST_RATE);
	m_iGreatMusicianRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_MUSICIAN_RATE);
	m_iGreatMerchantRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_MERCHANT_RATE);
#if defined(MOD_BALANCE_CORE)
	m_iGreatEngineerRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_ENGINEER_RATE);
#endif
	m_iGreatDiplomatRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_DIPLOMAT_RATE);
	m_iGreatScientistRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_SCIENTIST_RATE);
	m_iDomesticGreatGeneralRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_DOMESTIC_GREAT_GENERAL_RATE);

	// Next add in buildings
	m_iGreatPeopleRateModifier += m_iGreatPeopleRateModFromBldgs;
	m_iGreatGeneralRateModifier += m_iGreatGeneralRateModFromBldgs;

	// Finally anything from friendships
	m_iGreatPeopleRateModifier += GetGreatPeopleRateModFromFriendships();

	// And effects from Leagues
	int iArtsyMod = GC.getGame().GetGameLeagues()->GetArtsyGreatPersonRateModifier(GetID());
	int iScienceyMod = GC.getGame().GetGameLeagues()->GetScienceyGreatPersonRateModifier(GetID());
	if (iArtsyMod != 0)
	{
		m_iGreatWriterRateModifier += iArtsyMod;
		m_iGreatArtistRateModifier += iArtsyMod;
		m_iGreatMusicianRateModifier += iArtsyMod;
	}
	if (iScienceyMod != 0)
	{
		m_iGreatScientistRateModifier += iScienceyMod;
		m_iGreatEngineerRateModifier += iScienceyMod;
		m_iGreatMerchantRateModifier += iScienceyMod;
	}

	// Finally boost domestic general from combat experience
	m_iDomesticGreatGeneralRateModifier += /*100*/ GD_INT_GET(COMBAT_EXPERIENCE_IN_BORDERS_PERCENT);
}

//	--------------------------------------------------------------------------------
// Do we have a trait that rewards friendships (or have a friend that does)?
int CvPlayer::GetGreatPeopleRateModFromFriendships() const
{
	int iRtnValue = 0;
	int iTraitMod = GetPlayerTraits()->GetDOFGreatPersonModifier();

	// Have the trait, one for each friend
	if(iTraitMod > 0)
	{
		iRtnValue = GetDiplomacyAI()->GetNumDoF() * iTraitMod;
	}

	// Don't have the trait, just get bonus once if friends with a player that does
	else
	{
		PlayerTypes eLoopPlayer;
		for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			eLoopPlayer = (PlayerTypes) iPlayerLoop;

			if(GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))
			{
				if(GetDiplomacyAI()->IsDoFAccepted(eLoopPlayer))
				{
					int iOthersTraitMod = GET_PLAYER(eLoopPlayer).GetPlayerTraits()->GetDOFGreatPersonModifier();
					if(iOthersTraitMod > 0)
					{
						iRtnValue += iOthersTraitMod;
					}
				}
			}
		}
	}

	return iRtnValue;
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
int CvPlayer::GetGreatScientistBeakerMod() const
{
	return m_iGreatScientistBeakerModifier;
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
void CvPlayer::SetGreatScientistBeakerMod(int iValue)
{
	m_iGreatScientistBeakerModifier = iValue;
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
void CvPlayer::ChangeGreatScientistBeakerMod(int iChange)
{
	SetGreatScientistBeakerMod(GetGreatScientistBeakerMod() + iChange);
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
int CvPlayer::GetGreatEngineerHurryMod() const
{
	return m_iGreatEngineerHurryMod;
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
void CvPlayer::SetGreatEngineerHurryMod(int iValue)
{
	m_iGreatEngineerHurryMod = iValue;
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
void CvPlayer::ChangeGreatEngineerHurryMod(int iChange)
{
	SetGreatEngineerHurryMod(GetGreatEngineerHurryMod() + iChange);
}


//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
int CvPlayer::GetTechCostXCitiesModifier() const
{
	return m_iTechCostXCitiesModifier;
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
void CvPlayer::SetTechCostXCitiesModifier(int iValue)
{
	m_iTechCostXCitiesModifier = iValue;
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
void CvPlayer::ChangeTechCostXCitiesModifier(int iChange)
{
	SetTechCostXCitiesModifier(GetTechCostXCitiesModifier() + iChange);
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
int CvPlayer::GetTourismCostXCitiesMod() const
{
	return m_iTourismCostXCitiesMod;
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
void CvPlayer::ChangeTourismCostXCitiesMod(int iChange)
{
	m_iTourismCostXCitiesMod += iChange;
}



//////////////////////////////////////////////////////////////////////////
int CvPlayer::GetGreatGeneralCombatBonus() const
{
	return m_iGreatGeneralCombatBonus;
}

//////////////////////////////////////////////////////////////////////////
void CvPlayer::SetGreatGeneralCombatBonus(int iValue)
{
	m_iGreatGeneralCombatBonus = iValue;
}

void CvPlayer::ChangeGreatGeneralCombatBonus(int iValue)
{
	m_iGreatGeneralCombatBonus += iValue;
}


//////////////////////////////////////////////////////////////////////////
// ***** Great People Spawning *****
//////////////////////////////////////////////////////////////////////////

//	--------------------------------------------------------------------------------
// Figures out how long before we spawn a free Great Person for ePlayer
void CvPlayer::DoSeedGreatPeopleSpawnCounter()
{
	bool bBias = GetGreatPeopleSpawnCounter() == -1;
	int iNumTurns = /*37*/ GD_INT_GET(MINOR_TURNS_GREAT_PEOPLE_SPAWN_BASE);

	// Start at -1 since if we only have one ally we don't want to add any more
	int iExtraAllies = -1;

	for (int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		PlayerTypes eMinor = (PlayerTypes) iMinorLoop;

		// Not alive
		if (!GET_PLAYER(eMinor).isAlive())
			continue;

		if (GET_PLAYER(eMinor).GetMinorCivAI()->GetAlly() == GetID())
			iExtraAllies++;
	}

	if (iExtraAllies > 0)
	{
		int iExtraAlliesChange = iExtraAllies * /*-1*/ GD_INT_GET(MINOR_ADDITIONAL_ALLIES_GP_CHANGE);
		iExtraAlliesChange = max(/*-10*/ GD_INT_GET(MAX_MINOR_ADDITIONAL_ALLIES_GP_CHANGE), iExtraAlliesChange);
		iNumTurns += iExtraAlliesChange;
	}

	int iRand = /*7*/ GD_INT_GET(MINOR_TURNS_GREAT_PEOPLE_SPAWN_RAND);
	iNumTurns += GC.getGame().getSmallFakeRandNum(iRand, GetPseudoRandomSeed());

	// If we're biasing the result then decrease the number of turns
	if (bBias)
	{
		iNumTurns *= /*50*/ GD_INT_GET(MINOR_TURNS_GREAT_PEOPLE_SPAWN_BIAS_MULTIPLY);
		iNumTurns /= 100;
	}

	// Modify for Game Speed
	iNumTurns *= GC.getGame().getGameSpeedInfo().getGreatPeoplePercent();
	iNumTurns /= 100;

	if (iNumTurns < 1)
		iNumTurns = 1;

	SetGreatPeopleSpawnCounter(iNumTurns);
}

//	--------------------------------------------------------------------------------
/// We're now allies with someone, what happens with the GP bonus?
void CvPlayer::DoApplyNewAllyGPBonus()
{
	int iChange = /*-1*/ GD_INT_GET(MINOR_ADDITIONAL_ALLIES_GP_CHANGE);
	ChangeGreatPeopleSpawnCounter(iChange);

	if (GetGreatPeopleSpawnCounter() < 1)
		SetGreatPeopleSpawnCounter(1);
}

//	--------------------------------------------------------------------------------
// How long before we spawn a free GreatPeople for ePlayer?
int CvPlayer::GetGreatPeopleSpawnCounter()
{
	return m_iGreatPeopleSpawnCounter;
}

//	--------------------------------------------------------------------------------
// Sets how long before we spawn a free GreatPeople for ePlayer
void CvPlayer::SetGreatPeopleSpawnCounter(int iValue)
{
	m_iGreatPeopleSpawnCounter = iValue;
}

//	--------------------------------------------------------------------------------
// Changes how long before we spawn a free GreatPeople for ePlayer
void CvPlayer::ChangeGreatPeopleSpawnCounter(int iChange)
{
	SetGreatPeopleSpawnCounter(GetGreatPeopleSpawnCounter() + iChange);
}

//	--------------------------------------------------------------------------------
/// Create a GreatPeople
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
void CvPlayer::DoSpawnGreatPerson(PlayerTypes eMinor, bool bIsFree)
#else
void CvPlayer::DoSpawnGreatPerson(PlayerTypes eMinor)
#endif
{
	CvAssertMsg(eMinor >= MAX_MAJOR_CIVS, "eMinor is expected to be non-negative (invalid Index)");
	CvAssertMsg(eMinor < MAX_CIV_PLAYERS, "eMinor is expected to be within maximum bounds (invalid Index)");

	// Minor must have Capital
	CvCity* pMinorCapital = GET_PLAYER(eMinor).getCapitalCity();
	if(pMinorCapital == NULL)
	{
		FAssertMsg(false, "MINOR CIV AI: Trying to spawn a GreatPeople for a major civ but the minor has no capital. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
		return;
	}
	// Capital must have a plot
	CvPlot* pMinorPlot = pMinorCapital->plot();
	if(pMinorPlot == NULL)
	{
		CvAssertMsg(false, "Plot for minor civ's capital not found! Please send Anton your save file and version.");
		return;
	}

	// Note: this is the same transport method (though without a delay) as a Militaristic city-state gifting a unit
	CvCity* pMajorCity = GetClosestCityByPathLength(pMinorPlot);
	if (pMajorCity == NULL && getCapitalCity() != NULL)
	{
		pMajorCity = getCapitalCity();
	}
	int iX = pMinorCapital->getX();
	int iY = pMinorCapital->getY();
	if(pMajorCity != NULL)
	{
		iX = pMajorCity->getX();
		iY = pMajorCity->getY();
	}

	// Pick Great Person type
	UnitTypes eBestUnit = NO_UNIT;
	int iBestScore = -1;
	SpecialUnitTypes eSpecialUnitGreatPerson = (SpecialUnitTypes) GC.getInfoTypeForString("SPECIALUNIT_PEOPLE");

	for(int iUnitLoop = 0; iUnitLoop < GC.getNumUnitInfos(); iUnitLoop++)
	{
		UnitTypes eLoopUnit = (UnitTypes)iUnitLoop;
		CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eLoopUnit);

		if(pkUnitEntry && pkUnitEntry->GetSpecialUnitType() == eSpecialUnitGreatPerson)
		{
			// No prophets
			if(!pkUnitEntry->IsFoundReligion())
			{
				int iScore = GC.getGame().getSmallFakeRandNum(100, GetPseudoRandomSeed() + iX + iY);

				if(iScore > iBestScore)
				{
					iBestScore = iScore;
					eBestUnit = eLoopUnit;
				}
			}
		}
	}

	// Spawn GreatPeople
	if(eBestUnit != NO_UNIT)
	{
		CvUnit* pNewGreatPeople = initUnit(eBestUnit, iX, iY);
		CvAssert(pNewGreatPeople);

		if (pNewGreatPeople)
		{
#if defined(MOD_BALANCE_CORE)
			if (GetPlayerTraits()->IsGPWLTKD())
			{
				CvCity* pCity = pNewGreatPeople->plot()->getOwningCity();
				if (pCity != NULL && pCity->getOwner() == GetID())
				{
					int iWLTKD = /*6*/ GD_INT_GET(CITY_RESOURCE_WLTKD_TURNS) / 3;
					iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
					iWLTKD /= 100;

					if (iWLTKD > 0)
					{
						pCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
						CvNotifications* pNotifications = GetNotifications();
						if (pNotifications)
						{
							Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UA");
							strText << pNewGreatPeople->getNameKey() << pCity->getNameKey();
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UA");
							strSummary << pCity->getNameKey();
							pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), -1);
						}
					}
				}
			}
			if(pNewGreatPeople->isWLKTKDOnBirth())
			{
				CvCity* pLoopCity;
				int iLoop;
				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if(pLoopCity != NULL && pLoopCity->getOwner() == GetID())
					{
						int iWLTKD = /*6*/ GD_INT_GET(CITY_RESOURCE_WLTKD_TURNS) / 3;
						iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
						iWLTKD /= 100;

						if (iWLTKD > 0)
						{
							pLoopCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
							CvNotifications* pNotifications = GetNotifications();
							if (pNotifications)
							{
								Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UNIT");
								strText << pNewGreatPeople->getNameKey() << pLoopCity->getNameKey();
								Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UNIT");
								strSummary << pLoopCity->getNameKey();
								pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pLoopCity->getX(), pLoopCity->getY(), -1);
							}
						}
					}
				}
			}
			if(pNewGreatPeople->isGoldenAgeOnBirth())
			{
				changeGoldenAgeTurns(getGoldenAgeLength());
			}
			if(pNewGreatPeople->isCultureBoost())
			{
				int iValue = GetTotalJONSCulturePerTurn() * 4;
				changeJONSCulture(iValue);
				if(getCapitalCity() != NULL)
				{
					getCapitalCity()->ChangeJONSCultureStored(iValue);
				}
				CvNotifications* pNotifications = GetNotifications();
				if (pNotifications)
				{
					Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CULTURE_UNIT");
					strText << pNewGreatPeople->getNameKey();
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CULTURE_UNIT");
					strSummary << pNewGreatPeople->getNameKey();
					pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pNewGreatPeople->getX(), pNewGreatPeople->getY(), -1);
				}
			}
#endif
			// Bump up the count
			if(pNewGreatPeople->IsGreatGeneral())
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGreatGeneralsCreated(bIsFree);
#else
				incrementGreatGeneralsCreated();
#endif
			}
			else if(pNewGreatPeople->IsGreatAdmiral())
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGreatAdmiralsCreated(bIsFree);
#else
				incrementGreatAdmiralsCreated();
#endif
			}
			else if (pNewGreatPeople->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_WRITER"))
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGreatWritersCreated(bIsFree);
#else
				incrementGreatWritersCreated();
#endif
			}							
			else if (pNewGreatPeople->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_ARTIST"))
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGreatArtistsCreated(bIsFree);
#else
				incrementGreatArtistsCreated();
#endif
			}							
			else if (pNewGreatPeople->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_MUSICIAN"))
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGreatMusiciansCreated(bIsFree);
#else
				incrementGreatMusiciansCreated();
#endif
			}
			else if (MOD_BALANCE_VP && pNewGreatPeople->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_GREAT_DIPLOMAT"))
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGreatDiplomatsCreated(bIsFree);
#else
				incrementGreatDiplomatsCreated();
#endif
			}
#if defined(MOD_BALANCE_CORE)
			else if (pNewGreatPeople->getUnitInfo().IsGPExtra() == 1)
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGPExtra1Created(bIsFree);
#else
				incrementGPExtra1Created();
#endif
			}
			else if (pNewGreatPeople->getUnitInfo().IsGPExtra() == 2)
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGPExtra2Created(bIsFree);
#else
				incrementGPExtra2Created();
#endif
			}
			else if (pNewGreatPeople->getUnitInfo().IsGPExtra() == 3)
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGPExtra3Created(bIsFree);
#else
				incrementGPExtra3Created();
#endif
			}
			else if (pNewGreatPeople->getUnitInfo().IsGPExtra() == 4)
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGPExtra4Created(bIsFree);
#else
				incrementGPExtra4Created();
#endif
			}
			else if (pNewGreatPeople->getUnitInfo().IsGPExtra() == 5)
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGPExtra5Created(bIsFree);
#else
				incrementGPExtra5Created();
#endif
			}
#endif
			else
			{
#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
				if (MOD_GLOBAL_SEPARATE_GP_COUNTERS)
				{
					if (pNewGreatPeople->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_MERCHANT"))
					{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
						incrementGreatMerchantsCreated(bIsFree);
#else
						incrementGreatMerchantsCreated();
#endif
					}
					else if (pNewGreatPeople->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_SCIENTIST"))
					{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
						incrementGreatScientistsCreated(bIsFree);
#else
						incrementGreatScientistsCreated();
#endif
					}
					else
					{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
						incrementGreatEngineersCreated(bIsFree);
#else
						incrementGreatEngineersCreated();
#endif
					}
				}
				else
#endif
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
					incrementGreatPeopleCreated(bIsFree);
#else
					incrementGreatPeopleCreated();
#endif
			}

			if (pNewGreatPeople->IsGreatAdmiral())
			{
				CvPlot* pSpawnPlot = GetBestCoastalSpawnPlot(pNewGreatPeople);
				if (pNewGreatPeople->plot() != pSpawnPlot && pSpawnPlot != NULL)
				{
					pNewGreatPeople->setXY(pSpawnPlot->getX(), pSpawnPlot->getY());
				}
			}
			else
			{
				if (!pNewGreatPeople->jumpToNearestValidPlot())
					pNewGreatPeople->kill(false);	// Could not find a spot!
			}

			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_STATE_UNIT_SPAWN");
				strMessage << GET_PLAYER(eMinor).getNameKey();
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_STATE_UNIT_SPAWN");
				strSummary << GET_PLAYER(eMinor).getNameKey();
				pNotifications->Add(NOTIFICATION_MINOR, strMessage.toUTF8(), strSummary.toUTF8(), iX, iY, eMinor);
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Time to spawn a GreatPeople?
void CvPlayer::DoGreatPeopleSpawnTurn()
{
	// Tick down
	if(GetGreatPeopleSpawnCounter() > 0)
	{
		ChangeGreatPeopleSpawnCounter(-1);

		// Time to spawn! - Pick a random allied minor
		if(GetGreatPeopleSpawnCounter() == 0)
		{
			PlayerTypes eBestMinor = NO_PLAYER;
			int iBestScore = -1;
			int iScore;

			PlayerTypes eMinor;
			for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
			{
				eMinor = (PlayerTypes) iMinorLoop;

				// Not alive
				if(!GET_PLAYER(eMinor).isAlive())
					continue;

				// Not an ally
				if(GET_PLAYER(eMinor).GetMinorCivAI()->GetAlly() != GetID())
					continue;

				iScore = GC.getGame().getSmallFakeRandNum(100, GetPseudoRandomSeed() + iMinorLoop);

				// Best ally yet?
				if(eBestMinor == NO_PLAYER || iScore > iBestScore)
				{
					eBestMinor = eMinor;
					iBestScore = iScore;
				}
			}

			if(eBestMinor != NO_PLAYER)
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				DoSpawnGreatPerson(eBestMinor, MOD_GLOBAL_TRULY_FREE_GP);
#else
				DoSpawnGreatPerson(eBestMinor);
#endif

			// Reseed counter
			DoSeedGreatPeopleSpawnCounter();
		}
	}
}

//	--------------------------------------------------------------------------------
CvCity* CvPlayer::GetGreatPersonSpawnCity(UnitTypes eUnit)
{
	CvCity* pBestCity = getCapitalCity();
	CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eUnit);

	if(pkUnitEntry && pkUnitEntry->GetDomainType() == DOMAIN_SEA)
	{
		int iBestValue = INT_MAX;
		int iLoop;
		for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(!pLoopCity->isCoastal())
			{
				continue;
			}

			int iValue = 4 * GC.getGame().getSmallFakeRandNum(getNumCities(), GetPseudoRandomSeed() + iLoop);

			for(int i = 0; i < NUM_YIELD_TYPES; i++)
			{
				iValue += pLoopCity->findYieldRateRank((YieldTypes)i);
			}
			iValue += pLoopCity->findPopulationRank();

			if(iValue < iBestValue)
			{
				pBestCity = pLoopCity;
				iBestValue = iValue;
			}
		}
	}

	return pBestCity;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getMaxGlobalBuildingProductionModifier() const
{
	return m_iMaxGlobalBuildingProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMaxGlobalBuildingProductionModifier(int iChange)
{
	m_iMaxGlobalBuildingProductionModifier = (m_iMaxGlobalBuildingProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getMaxTeamBuildingProductionModifier() const
{
	return m_iMaxTeamBuildingProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMaxTeamBuildingProductionModifier(int iChange)
{
	m_iMaxTeamBuildingProductionModifier = (m_iMaxTeamBuildingProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getMaxPlayerBuildingProductionModifier() const
{
	return m_iMaxPlayerBuildingProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMaxPlayerBuildingProductionModifier(int iChange)
{
	m_iMaxPlayerBuildingProductionModifier = (m_iMaxPlayerBuildingProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getFreeExperience() const
{
	return m_iFreeExperience;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeFreeExperienceFromBldgs(int iChange)
{
	m_iFreeExperienceFromBldgs += iChange;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeFreeExperienceFromMinors(int iChange)
{
	m_iFreeExperienceFromMinors += iChange;
}

//	--------------------------------------------------------------------------------
void CvPlayer::recomputeFreeExperience()
{
	m_iFreeExperience = m_iFreeExperienceFromBldgs;
	m_iFreeExperience = m_iFreeExperienceFromMinors;
	m_iFreeExperience += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_FREE_EXPERIENCE);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getFeatureProductionModifier() const
{
	return m_iFeatureProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeFeatureProductionModifier(int iChange)
{
	m_iFeatureProductionModifier = (m_iFeatureProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getWorkerSpeedModifier() const
{
	return m_iWorkerSpeedModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeWorkerSpeedModifier(int iChange)
{
	m_iWorkerSpeedModifier = (m_iWorkerSpeedModifier + iChange);
}

#if defined(MOD_CIV6_WORKER)
//	--------------------------------------------------------------------------------
int  CvPlayer::GetImprovementBuilderCost(BuildTypes iBuild) const
{
	//get the build
	if (iBuild >= 0 && iBuild < GC.getNumBuildInfos())
	{
		CvBuildInfo* pkBuildInfo = GC.getBuildInfo((BuildTypes)iBuild);
		int buildercost = pkBuildInfo->getBuilderCost();

		//if road, use RouteBuilderCostMod
		if (pkBuildInfo->getRoute() != NO_ROUTE)
		{
			buildercost *= 100 + GetRouteBuilderCostMod();
			buildercost /= 100;
		}

		return buildercost;
	}
	return 0;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getImprovementCostModifier() const
{
	return m_iImprovementCostModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeImprovementCostModifier(int iChange)
{
	m_iImprovementCostModifier = (m_iImprovementCostModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getImprovementUpgradeRateModifier() const
{
	return m_iImprovementUpgradeRateModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeImprovementUpgradeRateModifier(int iChange)
{
	m_iImprovementUpgradeRateModifier = (m_iImprovementUpgradeRateModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getSpecialistProductionModifier() const
{
	return m_iSpecialistProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeSpecialistProductionModifier(int iChange)
{
	m_iSpecialistProductionModifier = (m_iSpecialistProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getMilitaryProductionModifier() const
{
	return m_iMilitaryProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMilitaryProductionModifier(int iChange)
{
	m_iMilitaryProductionModifier = (m_iMilitaryProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getSpaceProductionModifier() const
{
	return m_iSpaceProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeSpaceProductionModifier(int iChange)
{
	m_iSpaceProductionModifier = (m_iSpaceProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getCityDefenseModifier() const
{
	return m_iCityDefenseModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeCityDefenseModifier(int iChange)
{
	m_iCityDefenseModifier = (m_iCityDefenseModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getUnitFortificationModifier() const
{
	return m_iUnitFortificationModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeUnitFortificationModifier(int iChange)
{
	m_iUnitFortificationModifier = (m_iUnitFortificationModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getUnitBaseHealModifier() const
{
	return m_iUnitBaseHealModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeUnitBaseHealModifier(int iChange)
{
	m_iUnitBaseHealModifier = (m_iUnitBaseHealModifier + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getWonderProductionModifier() const
{
	return m_iWonderProductionModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeWonderProductionModifier(int iChange)
{
	m_iWonderProductionModifier = (m_iWonderProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getSettlerProductionModifier() const
{
	return m_iSettlerProductionModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeSettlerProductionModifier(int iChange)
{
	m_iSettlerProductionModifier = (m_iSettlerProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getCapitalSettlerProductionModifier() const
{
	return m_iCapitalSettlerProductionModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeCapitalSettlerProductionModifier(int iChange)
{
	m_iCapitalSettlerProductionModifier = (m_iCapitalSettlerProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::GetPolicyCostBuildingModifier() const
{
	return m_iPolicyCostBuildingModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangePolicyCostBuildingModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iPolicyCostBuildingModifier = (m_iPolicyCostBuildingModifier + iChange);

		recomputePolicyCostModifier();
		DoUpdateNextPolicyCost();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetPolicyCostMinorCivModifier() const
{
	return m_iPolicyCostMinorCivModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangePolicyCostMinorCivModifier(int iChange)
{
	m_iPolicyCostMinorCivModifier = (m_iPolicyCostMinorCivModifier + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetInfluenceSpreadModifier() const
{
	return m_iInfluenceSpreadModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeInfluenceSpreadModifier(int iChange)
{
	m_iInfluenceSpreadModifier = (m_iInfluenceSpreadModifier + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetExtraVotesPerDiplomat() const
{
	return m_iExtraVotesPerDiplomat;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeExtraVotesPerDiplomat(int iChange)
{
	m_iExtraVotesPerDiplomat += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNumNukeUnits() const
{
	return m_iNumNukeUnits;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeNumNukeUnits(int iChange)
{
	m_iNumNukeUnits = (m_iNumNukeUnits + iChange);
	CvAssert(getNumNukeUnits() >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getNumOutsideUnits()
{
	int iOutsideUnitCount = 0;

	CvUnit* pLoopUnit;
	int iLoop;
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->plot() != NULL)
		{
			if(pLoopUnit->plot()->getOwner() != pLoopUnit->getOwner())
			{
				iOutsideUnitCount++;
			}
		}
	}

	return iOutsideUnitCount;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeNumOutsideUnits(int iChange)
{
	if(iChange != 0)
	{
		m_iNumOutsideUnits += iChange;
		CvAssert(getNumOutsideUnits() >= 0);

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getBaseFreeUnits() const
{
	return m_iBaseFreeUnits;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeBaseFreeUnits(int iChange)
{
	if(iChange != 0)
	{
		m_iBaseFreeUnits = (m_iBaseFreeUnits + iChange);

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetVerifiedOutsideUnitCount()
{
	int iOutsideUnitCount = 0;

	CvUnit* pLoopUnit;
	int iLoop;
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->plot() != NULL)
		{
			if(pLoopUnit->plot()->getOwner() != pLoopUnit->getOwner())
			{
				iOutsideUnitCount++;
			}
		}
	}

	return iOutsideUnitCount;
}


//	--------------------------------------------------------------------------------
int CvPlayer::getGoldPerUnit() const
{
	return getGoldPerUnitTimes100() / 100;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeGoldPerUnit(int iChange)
{
	if(iChange != 0)
	{
		changeGoldPerUnitTimes100(iChange * 100);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGoldPerUnitTimes100() const
{
	return m_iGoldPerUnit;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeGoldPerUnitTimes100(int iChange)
{
	if(iChange != 0)
	{
		m_iGoldPerUnit = (m_iGoldPerUnit + iChange);

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getGoldPerMilitaryUnit() const
{
	return m_iGoldPerMilitaryUnit;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeGoldPerMilitaryUnit(int iChange)
{
	if(iChange != 0)
	{
		m_iGoldPerMilitaryUnit = (m_iGoldPerMilitaryUnit + iChange);

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetImprovementGoldMaintenanceMod() const
{
	return m_iImprovementGoldMaintenanceMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeImprovementGoldMaintenanceMod(int iChange)
{
	if(iChange != 0)
	{
		m_iImprovementGoldMaintenanceMod = (m_iImprovementGoldMaintenanceMod + iChange);
	}
}

#if defined(MOD_CIV6_WORKER)
//	--------------------------------------------------------------------------------
int CvPlayer::GetRouteBuilderCostMod() const
{
	return m_iRouteBuilderCostMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeRouteBuilderCostMod(int iChange)
{
	if (iChange != 0)
	{
		m_iRouteBuilderCostMod = (m_iRouteBuilderCostMod + iChange);
	}
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::GetBuildingGoldMaintenanceMod() const
{
	return m_iBuildingGoldMaintenanceMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeBuildingGoldMaintenanceMod(int iChange)
{
	if(iChange != 0)
	{
		m_iBuildingGoldMaintenanceMod = (m_iBuildingGoldMaintenanceMod + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetUnitGoldMaintenanceMod() const
{
	return m_iUnitGoldMaintenanceMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeUnitGoldMaintenanceMod(int iChange)
{
	if(iChange != 0)
	{
		m_iUnitGoldMaintenanceMod = (m_iUnitGoldMaintenanceMod + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetUnitSupplyMod() const
{
	return m_iUnitSupplyMod;
}


//	--------------------------------------------------------------------------------
void CvPlayer::ChangeUnitSupplyMod(int iChange)
{
	if(iChange != 0)
	{
		m_iUnitSupplyMod = (m_iUnitSupplyMod + iChange);
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getExtraUnitCost() const
{
	return m_iExtraUnitCost;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeExtraUnitCost(int iChange)
{
	if(iChange != 0)
	{
		m_iExtraUnitCost = (m_iExtraUnitCost + iChange);

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumMaintenanceFreeUnits(DomainTypes eDomain, bool bOnlyCombatUnits) const
{
	int iNumFreeUnits = 0;

	// Loop through all units to see if any of them are free!
	const CvUnit* pLoopUnit;
	int iLoop;
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if (eDomain != NO_DOMAIN)
		{
			if (pLoopUnit->getDomainType() != eDomain)
			{
				continue;
			}
		}

		if (bOnlyCombatUnits)
		{
			if (!pLoopUnit->IsCombatUnit())
			{
				continue;
			}
		}

		if(pLoopUnit->IsNoMaintenance())
		{
			iNumFreeUnits++;
		}
		else if(IsGarrisonFreeMaintenance() && pLoopUnit->IsGarrisoned())
		{
			iNumFreeUnits++;
		}

		if(MOD_BALANCE_CORE_JFD && pLoopUnit->isContractUnit())
		{
			iNumFreeUnits++;
		}
	}

	return iNumFreeUnits;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNumMilitaryUnits() const
{
	return m_iNumMilitaryUnits;
}
#if defined(MOD_BATTLE_ROYALE)
//  ----------------------------------------------------------------------------------
int CvPlayer::getNumMilitarySeaUnits() const
{
	return m_iNumMilitarySeaUnits;
}

int CvPlayer::getNumMilitaryAirUnits() const
{
	return m_iNumMilitaryAirUnits;
}

int CvPlayer::getNumMilitaryLandUnits() const
{
	return m_iNumMilitaryLandUnits;
}
#endif


//	--------------------------------------------------------------------------------
#if defined(MOD_BATTLE_ROYALE)
void CvPlayer::changeNumMilitaryUnits(int iChange, DomainTypes eDomain)
#else
void CvPlayer::changeNumMilitaryUnits(int iChange)
#endif
{
	if(iChange != 0)
	{
		m_iNumMilitaryUnits = (m_iNumMilitaryUnits + iChange);
		CvAssert(getNumMilitaryUnits() >= 0);

#if defined(MOD_BATTLE_ROYALE)
		switch (eDomain)
		{
		case NO_DOMAIN:
			break;
		case DOMAIN_SEA:
			m_iNumMilitarySeaUnits = (m_iNumMilitarySeaUnits + iChange);
			CvAssert(getNumMilitarySeaUnits() >= 0);
			break;
		case DOMAIN_AIR:
			m_iNumMilitaryAirUnits = (m_iNumMilitaryAirUnits + iChange);
			CvAssert(getNumMilitaryAirUnits() >= 0);
			break;
		case DOMAIN_LAND:
			m_iNumMilitaryLandUnits = (m_iNumMilitaryLandUnits + iChange);
			CvAssert(getNumMilitarySeaUnits() >= 0);
			break;
		case DOMAIN_IMMOBILE:
			break;
		case DOMAIN_HOVER:
			break;
		default:
			break;
		}
#endif
		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getHappyPerMilitaryUnit() const
{
	return m_iHappyPerMilitaryUnit;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeHappyPerMilitaryUnit(int iChange)
{
	if(iChange != 0)
	{
		m_iHappyPerMilitaryUnit = (m_iHappyPerMilitaryUnit + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getHappinessToCulture() const
{
	return m_iHappinessToCulture;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeHappinessToCulture(int iChange)
{
	if(iChange != 0)
	{
		m_iHappinessToCulture = (m_iHappinessToCulture + iChange);
		CvAssert(getHappinessToCulture() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getHappinessToScience() const
{
	return m_iHappinessToScience;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeHappinessToScience(int iChange)
{
	if(iChange != 0)
	{
		m_iHappinessToScience = (m_iHappinessToScience + iChange);
		CvAssert(getHappinessToScience() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getHalfSpecialistUnhappinessCount() const
{
	return m_iHalfSpecialistUnhappinessCount;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isHalfSpecialistUnhappiness() const
{
	return (getHalfSpecialistUnhappinessCount() > 0);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeHalfSpecialistUnhappinessCount(int iChange)
{
	if(iChange != 0)
	{
		m_iHalfSpecialistUnhappinessCount = (m_iHalfSpecialistUnhappinessCount + iChange);
		CvAssert(getHalfSpecialistUnhappinessCount() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getHalfSpecialistFoodCount() const
{
	return m_iHalfSpecialistFoodCount;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isHalfSpecialistFood() const
{
	return (getHalfSpecialistFoodCount() > 0);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeHalfSpecialistFoodCount(int iChange)
{
	if(iChange != 0)
	{
		m_iHalfSpecialistFoodCount = (m_iHalfSpecialistFoodCount + iChange);
		CvAssert(getHalfSpecialistFoodCount() >= 0);
	}
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvPlayer::getHalfSpecialistFoodCapitalCount() const
{
	return m_iHalfSpecialistFoodCapitalCount;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isHalfSpecialistFoodCapital() const
{
	return (getHalfSpecialistFoodCapitalCount() > 0);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeHalfSpecialistFoodCapitalCount(int iChange)
{
	if(iChange != 0)
	{
		m_iHalfSpecialistFoodCapitalCount = (m_iHalfSpecialistFoodCapitalCount + iChange);
		CvAssert(getHalfSpecialistFoodCapitalCount() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getTradeRouteLandDistanceModifier() const
{
	return m_iTradeRouteLandDistanceModifier;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeTradeRouteLandDistanceModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iTradeRouteLandDistanceModifier = (m_iTradeRouteLandDistanceModifier + iChange);
		CvAssert(getTradeRouteLandDistanceModifier() >= 0);
	}
}
int CvPlayer::getTradeRouteSeaDistanceModifier() const
{
	return m_iTradeRouteSeaDistanceModifier;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeTradeRouteSeaDistanceModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iTradeRouteSeaDistanceModifier = (m_iTradeRouteSeaDistanceModifier + iChange);
		CvAssert(getTradeRouteSeaDistanceModifier() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetDomainFreeExperiencePerGreatWorkGlobal(DomainTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_DOMAIN_TYPES, "eIndex expected to be < NUM_DOMAIN_TYPES");
	return m_aiDomainFreeExperiencePerGreatWorkGlobal[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::ChangeDomainFreeExperiencePerGreatWorkGlobal(DomainTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_DOMAIN_TYPES, "eIndex expected to be < NUM_DOMAIN_TYPES");
	m_aiDomainFreeExperiencePerGreatWorkGlobal[eIndex] = m_aiDomainFreeExperiencePerGreatWorkGlobal[eIndex] + iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetDomainFreeExperience(DomainTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_DOMAIN_TYPES, "eIndex expected to be < NUM_DOMAIN_TYPES");

	std::map<int, int>::const_iterator it = m_piDomainFreeExperience.find((int)eIndex);
	if (it != m_piDomainFreeExperience.end()) // find returns the iterator to map::end if the key i is not present in the map
	{
		return it->second;
	}

	return 0;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeDomainFreeExperience(DomainTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_DOMAIN_TYPES, "eIndex expected to be < NUM_DOMAIN_TYPES");

	m_piDomainFreeExperience[(int)eIndex] += iChange;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNullifyInfluenceModifier(bool bValue)
{
	if (bValue != m_bNullifyInfluenceModifier)
		m_bNullifyInfluenceModifier = bValue;
}
bool CvPlayer::IsNullifyInfluenceModifier() const
{
	return m_bNullifyInfluenceModifier;
}
#endif
//	--------------------------------------------------------------------------------
#if defined(MOD_TRAITS_TRADE_ROUTE_PRODUCTION_SIPHON)
int CvPlayer::GetTradeRouteProductionSiphonPercent(bool bInternationalOnly, CvPlayer* pOtherPlayer) const
{
	if (GetPlayerTraits()->IsTradeRouteProductionSiphon() == false || MOD_TRAITS_TRADE_ROUTE_PRODUCTION_SIPHON == false)
	{
		return 0;
	}
	
	int iSiphonPercent;
	int iOpenBorderPercentIncrease;
	int iReturn;

	iSiphonPercent = GetPlayerTraits()->GetTradeRouteProductionSiphon(bInternationalOnly).m_iSiphonPercent;
	iOpenBorderPercentIncrease = GetPlayerTraits()->GetTradeRouteProductionSiphon(bInternationalOnly).m_iPercentIncreaseWithOpenBorders;

	iReturn = iSiphonPercent;
	TeamTypes eTeam = getTeam();
	TeamTypes eOtherTeam = pOtherPlayer->getTeam();

	if (eTeam != NO_TEAM && eOtherTeam != NO_TEAM && eTeam != eOtherTeam)
	{
		CvTeam* pTeam = &GET_TEAM(eTeam);
		CvTeam* pOtherTeam = &GET_TEAM(eOtherTeam);
		if (pTeam->IsAllowsOpenBordersToTeam(pOtherTeam->GetID()))
		{
			iReturn += iOpenBorderPercentIncrease;
		}
		if (pOtherTeam->IsAllowsOpenBordersToTeam(pTeam->GetID()))
		{
			iReturn += iOpenBorderPercentIncrease;
		}
	}

	return iReturn;
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::getMilitaryFoodProductionCount() const
{
	return m_iMilitaryFoodProductionCount;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isMilitaryFoodProduction() const
{
	return (getMilitaryFoodProductionCount() > 0);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMilitaryFoodProductionCount(int iChange)
{
	if(iChange != 0)
	{
		m_iMilitaryFoodProductionCount = (m_iMilitaryFoodProductionCount + iChange);
		CvAssert(getMilitaryFoodProductionCount() >= 0);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetGoldenAgeCultureBonusDisabledCount() const
{
	return m_iGoldenAgeCultureBonusDisabledCount;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsGoldenAgeCultureBonusDisabled() const
{
	return (GetGoldenAgeCultureBonusDisabledCount() > 0);
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeGoldenAgeCultureBonusDisabledCount(int iChange)
{
	if (iChange != 0)
	{
		m_iGoldenAgeCultureBonusDisabledCount = m_iGoldenAgeCultureBonusDisabledCount + iChange;
		CvAssert(GetGoldenAgeCultureBonusDisabledCount() >= 0);
	}
}

void CvPlayer::ChangeNumMissionarySpreads(int iChange)
{
	m_iNumMissionarySpreads += iChange;
}

int CvPlayer::GetNumMissionarySpreads() const
{
	return m_iNumMissionarySpreads;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetSecondReligionPantheonCount() const
{
	return m_iSecondReligionPantheonCount;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsSecondReligionPantheon() const
{
	return (GetSecondReligionPantheonCount() > 0);
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeSecondReligionPantheonCount(int iChange)
{
	if (iChange != 0)
	{
		m_iSecondReligionPantheonCount = m_iSecondReligionPantheonCount + iChange;
		CvAssert(GetSecondReligionPantheonCount() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetEnablesSSPartHurryCount() const
{
	return m_iEnablesSSPartHurryCount;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsEnablesSSPartHurry() const
{
	return (GetEnablesSSPartHurryCount() > 0);
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeEnablesSSPartHurryCount(int iChange)
{
	if (iChange != 0)
	{
		m_iEnablesSSPartHurryCount = m_iEnablesSSPartHurryCount + iChange;
		CvAssert(GetEnablesSSPartHurryCount() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetEnablesSSPartPurchaseCount() const
{
	return m_iEnablesSSPartPurchaseCount;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsEnablesSSPartPurchase() const
{
	return (GetEnablesSSPartPurchaseCount() > 0);
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeEnablesSSPartPurchaseCount(int iChange)
{
	if (iChange != 0)
	{
		m_iEnablesSSPartPurchaseCount = m_iEnablesSSPartPurchaseCount + iChange;
		CvAssert(GetEnablesSSPartPurchaseCount() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getHighestUnitLevel()	const
{
	return m_iHighestUnitLevel;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setHighestUnitLevel(int iNewValue)
{
	m_iHighestUnitLevel = iNewValue;
	CvAssert(getHighestUnitLevel() >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getMaxConscript() const
{
	return m_iMaxConscript;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMaxConscript(int iChange)
{
	m_iMaxConscript = (m_iMaxConscript + iChange);
	CvAssert(getMaxConscript() >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getConscriptCount() const
{
	return m_iConscriptCount;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setConscriptCount(int iNewValue)
{
	m_iConscriptCount = iNewValue;
	CvAssert(getConscriptCount() >= 0);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeConscriptCount(int iChange)
{
	setConscriptCount(getConscriptCount() + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getOverflowResearch() const
{
	return getOverflowResearchTimes100() / 100;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setOverflowResearch(int iNewValue)
{
	setOverflowResearchTimes100(iNewValue*100);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeOverflowResearch(int iChange)
{
	changeOverflowResearchTimes100(iChange*100);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getOverflowResearchTimes100() const
{
	return m_iOverflowResearch;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setOverflowResearchTimes100(int iNewValue)
{
	m_iOverflowResearch = iNewValue;
	CvAssert(getOverflowResearchTimes100() >= 0);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeOverflowResearchTimes100(int iChange)
{
	if (GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))
		return;

	setOverflowResearchTimes100(getOverflowResearchTimes100() + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getExpModifier() const
{
	return m_iExpModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeExpModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iExpModifier += iChange;
		CvAssert(getExpModifier() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getExpInBorderModifier() const
{
	return m_iExpInBorderModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeExpInBorderModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iExpInBorderModifier += iChange;
		CvAssert(getExpInBorderModifier() >= 0);
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getLevelExperienceModifier() const
{
	return m_iLevelExperienceModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeLevelExperienceModifier(int iChange)
{
	m_iLevelExperienceModifier += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getMinorQuestFriendshipMod() const
{
	return m_iMinorQuestFriendshipMod;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMinorQuestFriendshipMod(int iChange)
{
	if(iChange != 0)
	{
		m_iMinorQuestFriendshipMod += iChange;
		CvAssert(getMinorQuestFriendshipMod() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getMinorGoldFriendshipMod() const
{
	return m_iMinorGoldFriendshipMod;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMinorGoldFriendshipMod(int iChange)
{
	if(iChange != 0)
	{
		m_iMinorGoldFriendshipMod += iChange;
		CvAssert(getMinorGoldFriendshipMod() >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// What is the general modifier we get towards the resting Influence point with a city-state? (ex. Social Policies)
/// NOTE: This does not include situation-dependent modifiers (ex. religion or warmongering), which are handled in CvMinorCivAI
int CvPlayer::GetMinorFriendshipAnchorMod() const
{
	return m_iMinorFriendshipMinimum;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetMinorFriendshipAnchorMod(int iValue)
{
	m_iMinorFriendshipMinimum = max(iValue, /*-60*/ GD_INT_GET(MINOR_FRIENDSHIP_AT_WAR));
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMinorFriendshipAnchorMod(int iChange)
{
	SetMinorFriendshipAnchorMod(GetMinorFriendshipAnchorMod() + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::GetMinorFriendshipDecayMod() const
{
	return m_iMinorFriendshipDecayMod;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeGetMinorFriendshipDecayMod(int iChange)
{
	if(iChange != 0)
	{
		m_iMinorFriendshipDecayMod += iChange;
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsMinorScienceAllies() const
{
	return GetMinorScienceAlliesCount() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetMinorScienceAlliesCount() const
{
	return m_iMinorScienceAlliesCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMinorScienceAlliesCount(int iChange)
{
	if(iChange != 0)
	{
		m_iMinorScienceAlliesCount += iChange;
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsMinorResourceBonus() const
{
	return GetMinorResourceBonusCount() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetMinorResourceBonusCount() const
{
	return m_iMinorResourceBonusCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMinorResourceBonusCount(int iChange)
{
	if(iChange != 0)
	{
		m_iMinorResourceBonusCount += iChange;
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsAbleToAnnexCityStates() const
{
	if (GetAbleToAnnexCityStatesCount() > 0)
		return true;

	if (GetPlayerTraits()->IsAbleToAnnexCityStates())
		return true;

	return false;
}
#if defined(MOD_BALANCE_CORE)
	//JFD
void CvPlayer::SetPiety(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_PietyChanged, GetID(), GetPiety(), iValue);
	if(m_iJFDPiety != iValue)
	{
		m_iJFDPiety = iValue;
	}
}
void CvPlayer::ChangePiety(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_PietyChanged, GetID(), GetPiety(), iValue);
	m_iJFDPiety += iValue;
	if(m_iJFDPiety > GC.getGame().getGameSpeedInfo().getPietyMax())
	{
		m_iJFDPiety = GC.getGame().getGameSpeedInfo().getPietyMax();
	}
	if(m_iJFDPiety < GC.getGame().getGameSpeedInfo().getPietyMin())
	{
		m_iJFDPiety = GC.getGame().getGameSpeedInfo().getPietyMin();
	}
}
int CvPlayer::GetPiety() const
{
	return m_iJFDPiety;
}
int CvPlayer::GetPietyRate() const
{
	return m_iJFDPietyRate;
}
void CvPlayer::SetPietyRate(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_PietyRateChanged, GetID(), GetPietyRate(), iValue);
	if(m_iJFDPietyRate != iValue)
	{
		m_iJFDPietyRate = iValue;
	}
}
void CvPlayer::ChangePietyRate(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_PietyRateChanged, GetID(), GetPietyRate(), iValue);
	m_iJFDPietyRate += iValue;
}
int CvPlayer::GetTurnsSinceConversion() const
{
	return m_iJFDConversionTurn;
}
void CvPlayer::SetTurnsSinceConversion(int iValue)
{
	if(m_iJFDConversionTurn != iValue)
	{
		m_iJFDConversionTurn = iValue;
	}
}
void CvPlayer::DoPiety()
{
	ReligionTypes eReligion = GetReligions()->GetStateReligion();
	if(eReligion == NO_RELIGION)
	{
		return;
	}
	else
	{
		int iRate = GetPietyRate();
		if(iRate != 0)
		{
			ChangePiety(iRate);
		}
	}
}
bool CvPlayer::HasStateReligion()
{
	if(GetReligions()->GetStateReligion() != NO_RELIGION)
	{
		return true;
	}
	return false;
}
bool CvPlayer::HasSecularized() const
{
	return m_bJFDSecularized;
}
void CvPlayer::SetHasSecularized(bool bValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerSecularizes, GetID(), GetReligions()->GetStateReligion(), bValue);
	m_bJFDSecularized = bValue;
}
bool CvPlayer::IsPagan()
{
	if(GetReligions()->HasCreatedPantheon() && !HasStateReligion() && !HasSecularized())
	{
		return true;
	}
	return false;
}

void CvPlayer::ChangeSovereignty(int iValue)
{
	m_iJFDSovereignty += iValue;
}
int CvPlayer::GetSovereignty() const
{
	return m_iJFDSovereignty;
}
void CvPlayer::SetSovereignty(int iValue)
{
	if(m_iJFDSovereignty != iValue)
	{
		m_iJFDSovereignty = iValue;
	}
}

void CvPlayer::SetGovernment(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerAdoptsGovernment, GetID(), iValue);
	if(m_iJFDGovernment != iValue)
	{
		m_iJFDGovernment = iValue;
	}
}
int CvPlayer::GetGovernment() const
{
	return m_iJFDGovernment;
}
bool CvPlayer::HasGovernment()
{
	if(GetGovernment() > -1)
	{
		return true;
	}
	return false;
}

void CvPlayer::ChangeReformCooldown(int iValue)
{
	m_iJFDReformCooldown += iValue;
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_ReformCooldownChanges, GetID(), GetReformCooldown());
}
int CvPlayer::GetReformCooldown() const
{
	return m_iJFDReformCooldown;
}
void CvPlayer::SetReformCooldown(int iValue, bool bNoEvent)
{
	if(m_iJFDReformCooldown != iValue)
	{
		m_iJFDReformCooldown = iValue;
	}
	if(!bNoEvent)
	{
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_ReformCooldownChanges, GetID(), GetReformCooldown());
	}
}

void CvPlayer::ChangeReformCooldownRate(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_ReformCooldownRateChanges, GetID(), iValue);
	m_iJFDReformCooldownRate += iValue;
}
int CvPlayer::GetReformCooldownRate() const
{
	return m_iJFDReformCooldownRate;
}
void CvPlayer::SetReformCooldownRate(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_ReformCooldownRateChanges, GetID(), iValue);
	if(m_iJFDReformCooldownRate != iValue)
	{
		m_iJFDReformCooldownRate = iValue;
	}
}

void CvPlayer::ChangeGovernmentCooldown(int iValue)
{
	m_iJFDGovernmentCooldown += iValue;
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_GovernmentCooldownChanges, GetID(), GetGovernmentCooldown());
}
int CvPlayer::GetGovernmentCooldown() const
{
	return m_iJFDGovernmentCooldown;
}
void CvPlayer::SetGovernmentCooldown(int iValue, bool bNoEvent)
{
	if(m_iJFDGovernmentCooldown != iValue)
	{
		m_iJFDGovernmentCooldown = iValue;
	}
	if(!bNoEvent)
	{
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_GovernmentCooldownChanges, GetID(), GetGovernmentCooldown());
	}
}

void CvPlayer::ChangeGovernmentCooldownRate(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_GovernmentCooldownRateChanges, GetID(), iValue);
	m_iJFDGovernmentCooldownRate += iValue;
}
int CvPlayer::GetGovernmentCooldownRate() const
{
	return m_iJFDGovernmentCooldownRate;
}
void CvPlayer::SetGovernmentCooldownRate(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_GovernmentCooldownRateChanges, GetID(), iValue);
	if(m_iJFDGovernmentCooldownRate != iValue)
	{
		m_iJFDGovernmentCooldownRate = iValue;
	}
}

int CvPlayer::GetPoliticLeader() const
{
	return m_iJFDPoliticLeader;
}
void CvPlayer::SetPoliticLeader(int iID)
{
	m_iJFDPoliticLeader = iID;
}

CvString CvPlayer::GetPoliticLeaderKey() const
{
	return m_strJFDPoliticKey;
}
void CvPlayer::SetPoliticLeaderKey(const char* strKey)
{
	m_strJFDPoliticKey = strKey;
}

CvString CvPlayer::GetLegislatureName() const
{
	return m_strJFDLegislatureName;
}
void CvPlayer::SetLegislatureName(const char* strKey)
{
	m_strJFDLegislatureName = strKey;
}

int CvPlayer::GetPoliticPercent(int iID) const
{
	return m_paiJFDPoliticPercent[iID];
}
void CvPlayer::SetPoliticPercent(int iID, int iValue)
{
	m_paiJFDPoliticPercent[iID] = iValue;
}

void CvPlayer::DoGovernmentCooldown()
{
	if(GetGovernmentCooldown() <= 0)
	{
		return;
	}
	int iRate = GetGovernmentCooldownRate();
	if(iRate != 0)
	{
		ChangeGovernmentCooldown(-iRate);
		if(GetGovernmentCooldown() <= 0)
		{
			SetGovernmentCooldown(0, true);
		}
	}
}
void CvPlayer::DoReformCooldown()
{
	if(GetReformCooldown() <= 0)
	{
		return;
	}
	int iRate = GetReformCooldownRate();
	if(iRate != 0)
	{
		ChangeReformCooldown(-iRate);
		if(GetReformCooldown() <= 0)
		{
			SetReformCooldown(0, true);
		}
	}
}
void CvPlayer::SetCurrency(int iValue)
{
	if(!HasCurrency())
	{
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerAdoptsCurrency, GetID(), iValue, -1);
	}
	else
	{
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerAdoptsCurrency, GetID(), iValue, GetCurrency());
	}
	if(m_iJFDCurrency != iValue)
	{
		m_iJFDCurrency = iValue;
	}
}
int CvPlayer::GetCurrency() const
{
	return m_iJFDCurrency;
}
bool CvPlayer::HasCurrency()
{
	if(GetCurrency() > -1)
	{
		return true;
	}
	return false;
}

CvString CvPlayer::GetCurrencyName() const
{
	return m_strJFDCurrencyName;
}
void CvPlayer::SetCurrencyName(const char* strKey)
{
	m_strJFDCurrencyName = strKey;
}

void CvPlayer::SetProsperityScore(int iValue)
{
	if(m_iJFDProsperity != iValue)
	{
		m_iJFDProsperity = iValue;
	}
}
int CvPlayer::GetProsperityScore() const
{
	return m_iJFDProsperity;
}

bool CvPlayer::PlayerHasContract(ContractTypes eContract) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eContract >= 0, "eContract expected to be >= 0");
	CvAssertMsg(eContract < GC.getNumContractInfos(), "eContract expected to be < GC.GetNumContractInfos()");
	return m_abActiveContract[eContract];
}
void CvPlayer::SetActiveContract(ContractTypes eContract, bool bValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eContract >= 0, "eContract expected to be >= 0");
	CvAssertMsg(eContract < GC.getNumContractInfos(), "eContract expected to be < GC.GetNumContractInfos()");
	if (m_abActiveContract[eContract] != bValue)
	{
		m_abActiveContract[eContract] = bValue;
	}
}

void CvPlayer::DoUnitDiversity()
{
	//find out which types we can build
	map<DomainTypes, map<UnitAITypes, int>> countByType;
	for (int iI = 0; iI < GC.getNumUnitInfos(); iI++)
	{
		const UnitTypes eLoopUnit = static_cast<UnitTypes>(iI);
		CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eLoopUnit);
		if (pkUnitInfo)
		{
			//must be a combat unit
			if (pkUnitInfo->GetCombat() <= 0 && pkUnitInfo->GetRangedCombat() <= 0)
				continue;

			if (!canTrainUnit(eLoopUnit))
				continue;

			switch (pkUnitInfo->GetDefaultUnitAIType())
			{
			case UNITAI_EXPLORE:
			case UNITAI_EXPLORE_SEA:
			case UNITAI_CARRIER_SEA:
				//ignore these types, they are handled separately
				break;
			default:
				//for now straight count, no fancy type dependent logic
				countByType[pkUnitInfo->GetDomainType()][pkUnitInfo->GetDefaultUnitAIType()] += GetNumUnitsOfType(eLoopUnit, true);
			}
		}
	}

	m_neededUnitAITypes.clear();
	for (map<DomainTypes, map<UnitAITypes, int>>::iterator itDomain = countByType.begin(); itDomain != countByType.end(); ++itDomain)
	{
		int minCount = INT_MAX;
		int maxCount = 0;
		for (map<UnitAITypes, int>::iterator itType = itDomain->second.begin(); itType != itDomain->second.end(); ++itType)
		{
			minCount = min(minCount, itType->second);
			maxCount = max(maxCount, itType->second);
		}

		for (map<UnitAITypes, int>::iterator itType = itDomain->second.begin(); itType != itDomain->second.end(); ++itType)
		{
			if (itType->second == minCount && itType->second != maxCount)
			{
				m_neededUnitAITypes.push_back(itType->first);
				CvString strLogString;
				CvString strAI;
				getUnitAIString(strAI, itType->first);
				strLogString.Format("UNIT DIVERSITY - WE NEED ");
				GetHomelandAI()->LogHomelandMessage(strLogString + strAI);
			}
		}
	}
}

bool CvPlayer::IsUnderrepresentedUnitType(UnitAITypes eType) const
{
	return std::find(m_neededUnitAITypes.begin(),m_neededUnitAITypes.end(),eType) != m_neededUnitAITypes.end();
}

int CvPlayer::GetDominationResistance(PlayerTypes ePlayer)
{
	if (!isMajorCiv() || !GET_PLAYER(ePlayer).isMajorCiv())
		return 0;

	int iResistance = GetDiplomacyAI()->GetOtherPlayerWarmongerAmount(ePlayer);
	if (iResistance == 0)
		return 0;

	int iHandicapCap = max(0, GET_PLAYER(ePlayer).getHandicapInfo().getResistanceCap());

	return min(iHandicapCap, iResistance/25);
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetArchaeologicalDigTourism() const
{
	return m_iArchaeologicalDigTourism;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeArchaeologicalDigTourism(int iChange)
{
	m_iArchaeologicalDigTourism += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetGoldenAgeTourism() const
{
	return m_iGoldenAgeTourism;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeGoldenAgeTourism(int iChange)
{
	m_iGoldenAgeTourism += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetExtraCultureandScienceTradeRoutes() const
{
	return m_iExtraCultureandScienceTradeRoutes;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeExtraCultureandScienceTradeRoutes(int iChange)
{
	m_iExtraCultureandScienceTradeRoutes += iChange;
}



//	--------------------------------------------------------------------------------
bool CvPlayer::CanUpgradeCSVassalTerritory() const
{
	if (GetUpgradeCSVassalTerritory() > 0)
	{
		return true;
	}

	return false;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetUpgradeCSVassalTerritory() const
{
	return m_iUpgradeCSVassalTerritory;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeUpgradeCSVassalTerritory(int iChange)
{
	m_iUpgradeCSVassalTerritory += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetRazingSpeedBonus() const
{
	return m_iRazingSpeedBonus;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeRazingSpeedBonus(int iChange)
{
	m_iRazingSpeedBonus += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetNoPartisans() const
{
	return m_iNoPartisans;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNoPartisans(int iChange)
{
	m_iNoPartisans += iChange;
}
//	--------------------------------------------------------------------------------
bool CvPlayer::IsNoPartisans() const
{
	if (GetNoPartisans() > 0)
	{
		return true;
	}

	return false;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetSpawnCooldown() const
{
	return m_iSpawnCooldown;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetSpawnCooldown(int iValue)
{
	m_iSpawnCooldown = iValue;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeSpawnCooldown(int iChange)
{
	m_iSpawnCooldown += iChange;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeTRSpeedBoost(int iChange)
{
	m_iTRSpeedBoost += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetTRSpeedBoost(int iChange)
{
	m_iTRSpeedBoost = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetTRSpeedBoost() const
{
	return m_iTRSpeedBoost;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeVotesPerGPT(int iChange)
{
	m_iVotesPerGPT += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetVotesPerGPT() const
{
	return m_iVotesPerGPT;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeTRVisionBoost(int iChange)
{
	m_iTRVisionBoost += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetTRVisionBoost(int iChange)
{
	m_iTRVisionBoost = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetTRVisionBoost() const
{
	return m_iTRVisionBoost;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeEventTourism(int iChange)
{
	m_iEventTourism += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetEventTourism(int iChange)
{
	m_iEventTourism = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetEventTourism() const
{
	return m_iEventTourism;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetGlobalTourismAlreadyReceived(MinorCivQuestTypes eQuest, int iValue)
{
	CvAssertMsg(eQuest >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eQuest < NUM_MINOR_CIV_QUEST_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	if(iValue != 0)
	{
		m_aiGlobalTourismAlreadyReceived[eQuest] = iValue;
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::GlobalTourismAlreadyReceived(MinorCivQuestTypes eQuest) const
{
	CvAssertMsg(eQuest >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eQuest < NUM_MINOR_CIV_QUEST_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	return m_aiGlobalTourismAlreadyReceived[eQuest];
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeEventTourismCS(int iChange)
{
	m_iEventTourismCS += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetEventTourismCS(int iChange)
{
	m_iEventTourismCS = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetEventTourismCS() const
{
	return m_iEventTourismCS;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumHistoricEvents(HistoricEventTypes eHistoricEvent, int iChange)
{
	if (!isMajorCiv())
	{
		return;
	}
	m_iNumHistoricEvent += iChange;

	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->GetCityCulture()->CalculateBaseTourismBeforeModifiers();
		pLoopCity->GetCityCulture()->CalculateBaseTourism();
	}
	CvCity* pCapital = getCapitalCity();
	int iEventGP = GetPlayerTraits()->GetEventGP();
	if (pCapital != NULL && iEventGP > 0)
	{
		vector<SpecialistTypes> vPossibleSpecialists;
		for (int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
		{
			const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iSpecialistLoop);
			CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
			if (pkSpecialistInfo)
			{
				// Does this Specialist spawn a GP?
				if (pkSpecialistInfo->getGreatPeopleUnitClass() != NO_UNITCLASS)
				{
					vPossibleSpecialists.push_back(eSpecialist);

					//boost the chance if we have a slot for the corresponding great work
					if ((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_WRITER"))
					{ 
						if (GetCulture()->GetNumAvailableGreatWorkSlots(CvTypes::getGREAT_WORK_SLOT_LITERATURE()) > 0)
						{
							vPossibleSpecialists.push_back(eSpecialist);
						}
					}
					else if ((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_ARTIST"))
					{
						if (GetCulture()->GetNumAvailableGreatWorkSlots(CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT()) > 0)
						{
							vPossibleSpecialists.push_back(eSpecialist);
						}
					}
					else if ((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_MUSICIAN"))
					{
						if (GetCulture()->GetNumAvailableGreatWorkSlots(CvTypes::getGREAT_WORK_SLOT_MUSIC()) > 0)
						{
							vPossibleSpecialists.push_back(eSpecialist);
						}
					}
				}
			}
		}

		//choose one
		int iChoice = GC.getGame().getSmallFakeRandNum(vPossibleSpecialists.size(), GetPseudoRandomSeed() + GC.getGame().getNumCities() + m_iNumHistoricEvent);
		SpecialistTypes eBestSpecialist = vPossibleSpecialists.empty() ? NO_SPECIALIST : vPossibleSpecialists[iChoice];
		if (eBestSpecialist != NO_SPECIALIST)
		{
			CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eBestSpecialist);
			if (pkSpecialistInfo)
			{
				int iGPThreshold = pCapital->GetCityCitizens()->GetSpecialistUpgradeThreshold((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass());
				iGPThreshold *= 100;
				//Get % of threshold for test.
				iGPThreshold *= iEventGP;
				iGPThreshold /= 100;
				
				pCapital->GetCityCitizens()->ChangeSpecialistGreatPersonProgressTimes100(eBestSpecialist, iGPThreshold, true);
				if (GetID() == GC.getGame().getActivePlayer())
				{
					iGPThreshold /= 100;
					char text[256] = {0};
					sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_GREAT_PEOPLE]", iGPThreshold);
					SHOW_PLOT_POPUP(pCapital->plot(), GetID(), text);
					CvNotifications* pNotification = GetNotifications();
					if (pNotification)
					{
						CvString strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS", iGPThreshold);
						CvString strSummary;
						// Class specific specialist message.
						if ((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_SCIENTIST"))
						{
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS_SCIENTIST", iGPThreshold);
						}
						else if ((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_WRITER"))
						{ 
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS_WRITER", iGPThreshold);
						}
						else if ((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_ARTIST"))
						{
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS_ARTIST", iGPThreshold);
						}
						else if ((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_MUSICIAN"))
						{
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS_MUSICIAN", iGPThreshold);
						}
						else if ((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_MERCHANT"))
						{
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS_MERCHANT", iGPThreshold);
						}
						else if ((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_ENGINEER"))
						{
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS_ENGINEER", iGPThreshold);
						}
						else if (MOD_BALANCE_VP && (UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_GREAT_DIPLOMAT"))
						{
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS_DIPLOMAT", iGPThreshold);
						}

						strSummary = GetLocalizedText("TXT_KEY_TOURISM_EVENT_SUMMARY_GP_BONUS");
						pNotification->Add(NOTIFICATION_GOLDEN_AGE_BEGUN_ACTIVE_PLAYER, strMessage, strSummary, -1, -1, -1);
					}
				}
			}
		}
	}
#if defined(MOD_BALANCE_CORE_DIFFICULTY)
	if (MOD_BALANCE_CORE_DIFFICULTY && !isHuman() && getNumCities() > 0)
	{
		DoDifficultyBonus(eHistoricEvent);
	}
#endif
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetNumHistoricEvents(int iChange)
{
	m_iNumHistoricEvent = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetNumHistoricEvents() const
{
	return m_iNumHistoricEvent;
}
int CvPlayer::GetHistoricEventTourism(HistoricEventTypes eHistoricEvent, CvCity* pCity)
{

	int iTourism = 0;

	CvString strLogString; 
	
	switch (eHistoricEvent)
	{
	case HISTORIC_EVENT_GP:
		if (GC.getLogging() && GC.getAILogging())
		{
			strLogString.Format("Great Person Historic Event triggered.");
		}
		iTourism = GetEventTourism();
		break;
	case HISTORIC_EVENT_ERA:
		if (GC.getLogging() && GC.getAILogging())
		{
			strLogString.Format("Era Change Historic Event triggered.");
		}
		iTourism = GetEventTourism();
		break;
	case HISTORIC_EVENT_WAR:
		if (GC.getLogging() && GC.getAILogging())
		{
			strLogString.Format("War Historic Event triggered.");
		}
		iTourism = GetEventTourism();
		break;
	case HISTORIC_EVENT_WONDER:
		if (GC.getLogging() && GC.getAILogging())
		{
			strLogString.Format("Wonder Historic Event triggered.");
		}
		iTourism = GetEventTourism();
		break;
	case HISTORIC_EVENT_DIG:
		if (GC.getLogging() && GC.getAILogging())
		{
			strLogString.Format("Archaeological Dig Historic Event triggered.");
		}
		iTourism = GetArchaeologicalDigTourism();
		break;
	case HISTORIC_EVENT_TRADE_CS:
		if (GC.getLogging() && GC.getAILogging())
		{
			strLogString.Format("City-State Trade Historic Event triggered.");
		}
		iTourism = GetEventTourismCS();
		break;
	case HISTORIC_EVENT_GA:
		if (GC.getLogging() && GC.getAILogging())
		{
			strLogString.Format("Golden Age Historic Event triggered.");
		}
		iTourism = GetGoldenAgeTourism();
		break;
	case HISTORIC_EVENT_TRADE_LAND:
		if (GC.getLogging() && GC.getAILogging())
		{
			strLogString.Format("Land Trade Specific Event triggered.");
		}
		if (pCity != NULL)
		{
			iTourism = pCity->GetLandTourismBonus();
		}
		break;
	case HISTORIC_EVENT_TRADE_SEA:
		if (GC.getLogging() && GC.getAILogging())
		{
			strLogString.Format("Sea Trade Specific Event triggered.");
		}
		if (pCity != NULL)
		{
			iTourism = pCity->GetSeaTourismBonus();
		}
		break;
	case HISTORIC_EVENT_CITY_FOUND_CAPITAL:
	case HISTORIC_EVENT_CITY_FOUND:
		break; // These events offer no tourism bonus.
	}

	if (iTourism <= 0)
		return 0;

	int iPreviousTurnsToCount = iTourism;

	// Calculate boost
	int iTotalBonus = getYieldPerTurnHistory(YIELD_CULTURE, iPreviousTurnsToCount / 3);
	iTotalBonus += getYieldPerTurnHistory(YIELD_TOURISM, iPreviousTurnsToCount);

	// Mod for City Count
	int iMod = (GC.getMap().getWorldInfo().GetNumCitiesPolicyCostMod() / 2);	// Default is 5, gets smaller on larger maps

	int iNumCities = GetNumEffectiveCities();

	iMod *= (iNumCities - 1);

	if (iMod <= 0)
		iMod = 1;
	else if (iMod >= 75)
		iMod = 75;

	int iSubtraction = (iTotalBonus * iMod);
	iSubtraction /= 100;

	iTotalBonus -= iSubtraction;

	switch (eHistoricEvent)
	{
	case HISTORIC_EVENT_GP:
		iTotalBonus /= 15;
		break;
	case HISTORIC_EVENT_ERA:
		iTotalBonus /= 10;
		break;
	case HISTORIC_EVENT_WAR:
		iTotalBonus /= 5;
		break;
	case HISTORIC_EVENT_WONDER:
		iTotalBonus /= 5;
		break;
	case HISTORIC_EVENT_DIG:
		iTotalBonus /= 10;
		break;
	case HISTORIC_EVENT_TRADE_CS:
		iTotalBonus /= 5;
		break;
	case HISTORIC_EVENT_GA:
		iTotalBonus /= 5;
		break;
	case HISTORIC_EVENT_TRADE_LAND:
		iTotalBonus /= 15;
		break;
	case HISTORIC_EVENT_TRADE_SEA:
		iTotalBonus /= 15;
		break;
	case HISTORIC_EVENT_CITY_FOUND_CAPITAL:
	case HISTORIC_EVENT_CITY_FOUND:
		UNREACHABLE();
	}

	if (GC.getLogging() && GC.getAILogging())
	{
		CvString strTemp;

		CvString strFileName = "HistoricEventLog.csv";
		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

		CvString strPlayerName;
		strPlayerName = getCivilizationShortDescription();
		strTemp += strPlayerName;
		strTemp += ", ";

		CvString strTurn;
 
		strTurn.Format("%d, ", GC.getGame().getGameTurn()); // turn
		strTemp += strTurn;

		strTemp += strLogString;

		CvString strData;
		strData.Format(" --- Total Events: %d. Tourism bonus with all civs (before modifiers): %d", GetNumHistoricEvents(), iTotalBonus);
		strTemp += strData;
		
		pLog->Msg(strTemp);
	}

	return iTotalBonus;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeSingleVotes(int iChange)
{
	m_iSingleVotes += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetSingleVotes(int iChange)
{
	m_iSingleVotes = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetSingleVotes() const
{
	return m_iSingleVotes;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMonopolyModFlat(int iChange)
{
	m_iMonopolyModFlat += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetMonopolyModFlat(int iChange)
{
	m_iMonopolyModFlat = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetMonopolyModFlat() const
{
	return (m_iMonopolyModFlat + GetPlayerTraits()->GetMonopolyModFlat());
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMonopolyModPercent(int iChange)
{
	m_iMonopolyModPercent += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetMonopolyModPercent(int iChange)
{
	m_iMonopolyModPercent = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetMonopolyModPercent() const
{
	return (m_iMonopolyModPercent + GetPlayerTraits()->GetMonopolyModPercent());
}

/// What are we willing to give/receive for peace with the active human player?
int CvPlayer::GetCachedValueOfPeaceWithHuman() const
{
	return m_iCachedValueOfPeaceWithHuman;
}

/// Sets what are we willing to give/receive for peace with the active human player
void CvPlayer::SetCachedValueOfPeaceWithHuman(int iValue)
{
	m_iCachedValueOfPeaceWithHuman = iValue;
}

/// What are we willing to give/receive for peace with the active human player?
int CvPlayer::GetFaithPurchaseCooldown() const
{
	return m_iFaithPurchaseCooldown;
}

/// Sets what are we willing to give/receive for peace with the active human player
void CvPlayer::ChangeFaithPurchaseCooldown(int iValue)
{
	m_iFaithPurchaseCooldown += iValue;
}

int CvPlayer::GetNumCSAllies() const
{
	return m_iCSAllies;
}
void CvPlayer::SetNumCSAllies(int iChange)
{
	if (m_iCSAllies != iChange)
	{
		m_iCSAllies = iChange;
	}
}

int CvPlayer::GetNumCSFriends() const
{
	return m_iCSFriends;
}
void CvPlayer::SetNumCSFriends(int iChange)
{
	if (m_iCSFriends != iChange)
	{
		m_iCSFriends = iChange;
	}
}

void CvPlayer::RefreshCSAlliesFriends()
{
	int iFriends = 0;
	int iAllies = 0;
	// Loop through all minors and get the total number we've met.
	for (int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		PlayerTypes eMinor = (PlayerTypes)iMinorLoop;

		if (GET_PLAYER(eMinor).isAlive() && GET_PLAYER(eMinor).isMinorCiv())
		{
			if (GET_PLAYER(eMinor).GetMinorCivAI()->IsAllies(GetID()))
			{
				iAllies++;
			}
			else if (GET_PLAYER(eMinor).GetMinorCivAI()->IsFriends(GetID()))
			{
				iFriends++;
			}
		}
	}
	SetNumCSAllies(iAllies);
	SetNumCSFriends(iFriends);
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::GetAbleToAnnexCityStatesCount() const
{
	return m_iAbleToAnnexCityStatesCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeAbleToAnnexCityStatesCount(int iChange)
{
	m_iAbleToAnnexCityStatesCount += iChange;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsOnlyTradeSameIdeology() const
{
	return m_iOnlyTradeSameIdeology > 0;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeOnlyTradeSameIdeology(int iChange)
{
	m_iOnlyTradeSameIdeology += iChange;
}

#if defined(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS)
//	--------------------------------------------------------------------------------
int CvPlayer::GetPovertyUnhappinessMod() const
{
	return m_iPovertyUnhappinessMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangePovertyUnhappinessMod(int iChange)
{
	m_iPovertyUnhappinessMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetDefenseUnhappinessMod() const
{
	return m_iDefenseUnhappinessMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeDefenseUnhappinessMod(int iChange)
{
	m_iDefenseUnhappinessMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetUnculturedUnhappinessMod() const
{
	return m_iUnculturedUnhappinessMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeUnculturedUnhappinessMod(int iChange)
{
	m_iUnculturedUnhappinessMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetIlliteracyUnhappinessMod() const
{
	return m_iIlliteracyUnhappinessMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeIlliteracyUnhappinessMod(int iChange)
{
	m_iIlliteracyUnhappinessMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetMinorityUnhappinessMod() const
{
	return m_iMinorityUnhappinessMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMinorityUnhappinessMod(int iChange)
{
	m_iMinorityUnhappinessMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetPovertyUnhappinessModCapital() const
{
	return m_iPovertyUnhappinessModCapital;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangePovertyUnhappinessModCapital(int iChange)
{
	m_iPovertyUnhappinessModCapital += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetDefenseUnhappinessModCapital() const
{
	return m_iDefenseUnhappinessModCapital;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeDefenseUnhappinessModCapital(int iChange)
{
	m_iDefenseUnhappinessModCapital += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetUnculturedUnhappinessModCapital() const
{
	return m_iUnculturedUnhappinessModCapital;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeUnculturedUnhappinessModCapital(int iChange)
{
	m_iUnculturedUnhappinessModCapital += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetIlliteracyUnhappinessModCapital() const
{
	return m_iIlliteracyUnhappinessModCapital;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeIlliteracyUnhappinessModCapital(int iChange)
{
	m_iIlliteracyUnhappinessModCapital += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetMinorityUnhappinessModCapital() const
{
	return m_iMinorityUnhappinessModCapital;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMinorityUnhappinessModCapital(int iChange)
{
	m_iMinorityUnhappinessModCapital += iChange;
}
// Specialists
//	--------------------------------------------------------------------------------
int CvPlayer::GetNoUnhappfromXSpecialists() const
{
	return m_iNoUnhappfromXSpecialists;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNoUnhappfromXSpecialists(int iChange)
{
	m_iNoUnhappfromXSpecialists += iChange;
}

int CvPlayer::GetTechNeedModifier() const
{
	int iOurTech = GET_TEAM(getTeam()).GetTeamTechs()->GetNumTechsKnown();
	int iNumTechs = GC.getNumTechInfos();

	int iPercentResearched = iOurTech * 100;
	iPercentResearched /= max(1, iNumTechs);

	iPercentResearched *= /*160*/ GD_INT_GET(BALANCE_HAPPINESS_TECH_BASE_MODIFIER);
	iPercentResearched /= 100;

	return iPercentResearched;
}


//	--------------------------------------------------------------------------------
int CvPlayer::GetHappfromXSpecialists() const
{
	return m_iHappfromXSpecialists;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeHappfromXSpecialists(int iChange)
{
	m_iHappfromXSpecialists += iChange;
}



//	--------------------------------------------------------------------------------
int CvPlayer::GetNoUnhappfromXSpecialistsCapital() const
{
	return m_iNoUnhappfromXSpecialistsCapital;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNoUnhappfromXSpecialistsCapital(int iChange)
{
	m_iNoUnhappfromXSpecialistsCapital += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetSpecialistFoodChange() const
{
	return m_iSpecialistFoodChange;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeSpecialistFoodChange(int iChange)
{
	m_iSpecialistFoodChange += iChange;
}



//	--------------------------------------------------------------------------------
int CvPlayer::GetWarWearinessModifier() const
{
	return m_iWarWearinessModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeWarWearinessModifier(int iChange)
{
	m_iWarWearinessModifier += iChange;
}

int CvPlayer::GetWarScoreModifier() const
{
	return m_iWarScoreModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeWarScoreModifier(int iChange)
{
	m_iWarScoreModifier += iChange;
}

void CvPlayer::SetProductionRoutesAllCities(bool bValue)
{
	if (m_bAllowsProductionTradeRoutesGlobal != bValue)
	{
		m_bAllowsProductionTradeRoutesGlobal = bValue;
	}
}
bool CvPlayer::IsProductionRoutesAllCities() const
{
	return m_bAllowsProductionTradeRoutesGlobal;
}

void CvPlayer::SetFoodRoutesAllCities(bool bValue)
{
	if (m_bAllowsFoodTradeRoutesGlobal != bValue)
	{
		m_bAllowsFoodTradeRoutesGlobal = bValue;
	}
}
bool CvPlayer::IsFoodRoutesAllCities() const
{
	return m_bAllowsFoodTradeRoutesGlobal;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getCultureBombTimer() const
{
	return m_iCultureBombTimer;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setCultureBombTimer(int iNewValue)
{
	if(getCultureBombTimer() != iNewValue)
	{
		m_iCultureBombTimer = iNewValue;
		CvAssert(getCultureBombTimer() >= 0);
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeCultureBombTimer(int iChange)
{
	setCultureBombTimer(getCultureBombTimer() + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getConversionTimer() const
{
	return m_iConversionTimer;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setConversionTimer(int iNewValue)
{
	if(getConversionTimer() != iNewValue)
	{
		m_iConversionTimer = iNewValue;
		CvAssert(getConversionTimer() >= 0);

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(MiscButtons_DIRTY_BIT, true);
		}
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeConversionTimer(int iChange)
{
	setConversionTimer(getConversionTimer() + iChange);
}

//	--------------------------------------------------------------------------------
CvCity* CvPlayer::getCapitalCity() const
{
	return getCity(m_iCapitalCityID);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getCapitalCityID() const
{
	return m_iCapitalCityID;
}
//	--------------------------------------------------------------------------------
void CvPlayer::setCapitalCity(CvCity* pNewCapitalCity)
{
	CvCity* pOldCapitalCity = getCapitalCity();

	if (pOldCapitalCity != pNewCapitalCity)
	{
		if (pNewCapitalCity != NULL)
		{
			// Need to set our original capital x,y?
			if (GetOriginalCapitalX() == -1 || GetOriginalCapitalY() == -1)
			{
				m_iOriginalCapitalX = pNewCapitalCity->getX();
				m_iOriginalCapitalY = pNewCapitalCity->getY();
			}

			m_iCapitalCityID = pNewCapitalCity->GetID();
		}
		else
		{
			m_iCapitalCityID = -1;
		}
	}
}

//	--------------------------------------------------------------------------------
/// Where was our original capital located?
int CvPlayer::GetOriginalCapitalX() const
{
	return m_iOriginalCapitalX;
}

int CvPlayer::GetOriginalCapitalY() const
{
	return m_iOriginalCapitalY;
}
//	--------------------------------------------------------------------------------
void CvPlayer::setOriginalCapitalXY(CvCity* pCapitalCity)
{
	if (pCapitalCity != NULL)
	{
		m_iOriginalCapitalX = pCapitalCity->getX();
		m_iOriginalCapitalY = pCapitalCity->getY();
	}
}

//	--------------------------------------------------------------------------------
/// Have we lost our holy city in war?
bool CvPlayer::IsHasLostHolyCity() const
{
	return m_bLostHolyCity;
}

void CvPlayer::SetHasLostHolyCity(bool bValue, PlayerTypes eConqueror)
{
	if (bValue != m_bLostHolyCity)
	{
		m_bLostHolyCity = bValue;
		m_eHolyCityConqueror = eConqueror;
	}
}

void CvPlayer::SetLostHolyCityXY(int iX, int iY)
{
	m_iHolyCityX = iX;
	m_iHolyCityY = iY;
}

int CvPlayer::GetLostHolyCityX()
{
	return m_iHolyCityX;
}
int CvPlayer::GetLostHolyCityY()
{
	return m_iHolyCityY;
}

PlayerTypes CvPlayer::GetHolyCityConqueror()
{
	return m_eHolyCityConqueror;
}


//	--------------------------------------------------------------------------------
/// Have we lost our capital in war?
bool CvPlayer::IsHasLostCapital() const
{
	return m_bLostCapital;
}

//	--------------------------------------------------------------------------------
/// Sets us to having lost our capital in war
void CvPlayer::SetHasLostCapital(bool bValue, PlayerTypes eConqueror)
{
	if (bValue == m_bLostCapital)
		return;

	m_bLostCapital = bValue;
	m_eConqueror = eConqueror;

	// Don't really care if a City-State lost its capital
	if (!isMajorCiv())
		return;

	// Calculate who owns the most original capitals by iterating through all civs 
	// and finding out who owns their original capital.
	std::vector<CvCity*> OriginalCapitals;
	CvMap& kMap = GC.getMap();

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iPlayerLoop);

		if (!kLoopPlayer.isEverAlive())
			continue;

		const int iOriginalCapitalX = kLoopPlayer.GetOriginalCapitalX();
		const int iOriginalCapitalY = kLoopPlayer.GetOriginalCapitalY();

		if (iOriginalCapitalX == -1 || iOriginalCapitalY == -1)
			continue;

		CvPlot* pCapitalPlot = kMap.plot(iOriginalCapitalX, iOriginalCapitalY);
		if (pCapitalPlot)
		{
			CvCity* pCapital = pCapitalPlot->getPlotCity();
			if (pCapital)
			{
				OriginalCapitals.push_back(pCapital);
			}
		}
	}

	map<TeamTypes, int> numOriginalCapitals;
	int iMostOriginalCapitals = 0;
	TeamTypes eWinningTeam = NO_TEAM;
	PlayerTypes eWinningPlayer = NO_PLAYER;

	for (size_t i = 0; i < OriginalCapitals.size(); i++)
	{
		// Note: For Domination Victories, City-States' allies control their capitals, and vassals' masters control their capitals.
		PlayerTypes eCapitalOwner = OriginalCapitals[i]->GetOwnerForDominationVictory();
		CvPlayer& kCapitalOwnerPlayer = GET_PLAYER(eCapitalOwner);

		// If effectively owned by Barbarians or City-States, ignore.
		if (!kCapitalOwnerPlayer.isMajorCiv())
			continue;

		++numOriginalCapitals[kCapitalOwnerPlayer.getTeam()];
		if (numOriginalCapitals[kCapitalOwnerPlayer.getTeam()] > iMostOriginalCapitals)
		{
			iMostOriginalCapitals = numOriginalCapitals[kCapitalOwnerPlayer.getTeam()];
			eWinningTeam = kCapitalOwnerPlayer.getTeam();
			eWinningPlayer = GET_TEAM(eWinningTeam).getLeaderID();
		}
	}

	// Someone just lost their capital, test to see if someone wins
	if (bValue)
	{
		Localization::String localizedBuffer;
		Localization::String localizedSummary;
		NotificationTypes eNotificationType = NOTIFICATION_CAPITAL_LOST;

		for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
		{
			PlayerTypes ePlayer = (PlayerTypes)ui;
			CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();
			if(!pNotifications)
			{
				continue;
			}

			// Notify Player lost their capital
			if(ePlayer == GetID())
			{
				eNotificationType = NOTIFICATION_CAPITAL_LOST_ACTIVE_PLAYER;
				localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_YOU_LOST_CAPITAL");
				if (eWinningPlayer == ePlayer)
				{
					localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_LOST_CAPITAL_YOU_WINNING");
					localizedBuffer << iMostOriginalCapitals;
				}
				else if (eWinningTeam != NO_TEAM)
				{
					if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(eWinningTeam))
					{
						if (eWinningPlayer != NO_PLAYER) // there is a winning player
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_LOST_CAPITAL_OTHER_PLAYER_WINNING");
							if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
							{
								localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
							}
							else
							{
								localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
							}
							localizedBuffer << iMostOriginalCapitals;
						}
						else
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_LOST_CAPITAL_TEAM_WINNING");
							localizedBuffer << (int)eWinningTeam;
							localizedBuffer << iMostOriginalCapitals;
						}
					}
					else // if someone is winning
					{
						localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_LOST_CAPITAL_UNMET_WINNING");
						localizedBuffer << iMostOriginalCapitals;
					}
				}
				else // if no one is winning
				{
					localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_LOST_CAPITAL");
				}
			}
			// Known player
			else if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(getTeam()) || GET_PLAYER(ePlayer).isObserver())
			{
				eNotificationType = NOTIFICATION_CAPITAL_LOST;
				localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_PLAYER_LOST_CAPITAL");
				localizedSummary << getCivilizationShortDescriptionKey();

				if (eWinningTeam != NO_TEAM)
				{
					if (GET_TEAM(eWinningTeam).isHasMet(GET_PLAYER(ePlayer).getTeam()) || GET_PLAYER(ePlayer).isObserver())
					{
						if (eWinningPlayer == GetID())
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL_YOU_WINNING");

							if (GC.getGame().isGameMultiPlayer() && isHuman())
							{
								localizedBuffer << getNickName();
							}
							else
							{
								localizedBuffer << getNameKey();
							}
							localizedBuffer << iMostOriginalCapitals;
						}
						else if (eWinningPlayer != NO_PLAYER)
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL_OTHER_WINNING");
							if (GC.getGame().isGameMultiPlayer() && isHuman())
							{
								localizedBuffer << getNickName();
							}
							else
							{
								localizedBuffer << getNameKey();
							}

							if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
							{
								localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
							}
							else
							{
								localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
							}
							localizedBuffer << iMostOriginalCapitals;
						}
						else // if (eWinningTeam != NO_TEAM)
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL_TEAM_WINNING");
							if (GC.getGame().isGameMultiPlayer() && isHuman())
							{
								localizedBuffer << getNickName();
							}
							else
							{
								localizedBuffer << getNameKey();
							}

							localizedBuffer << (int)eWinningTeam;
							localizedBuffer << iMostOriginalCapitals;
						}
					}
					else
					{
						localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL_UNMET_WINNING");
						if (GC.getGame().isGameMultiPlayer() && isHuman())
						{
							localizedBuffer << getNickName();
						}
						else
						{
							localizedBuffer << getNameKey();
						}
						localizedBuffer << iMostOriginalCapitals;
					}
				}
				else
				{
					localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL");
					if (GC.getGame().isGameMultiPlayer() && isHuman())
					{
						localizedBuffer << getNickName();
					}
					else
					{
						localizedBuffer << getNameKey();
					}
				}
			}
			else // unmet player
			{
				eNotificationType = NOTIFICATION_CAPITAL_LOST;
				localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_SOMEONE_LOST_CAPITAL");

				if (eWinningTeam != NO_TEAM)
				{
					if (GET_TEAM(eWinningTeam).isHasMet(GET_PLAYER(ePlayer).getTeam()))
					{
						if (eWinningPlayer == GetID())
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_LOST_CAPITAL_YOU_WINNING");
							localizedBuffer << iMostOriginalCapitals;
						}
						else if (eWinningPlayer != NO_PLAYER)
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_LOST_CAPITAL_OTHER_WINNING");
							if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
							{
								localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
							}
							else
							{
								localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
							}
							localizedBuffer << iMostOriginalCapitals;
						}
						else // if (eWinningTeam != NO_TEAM)
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_LOST_CAPITAL_TEAM_WINNING");
							localizedBuffer << (int)eWinningTeam;
							localizedBuffer << iMostOriginalCapitals;
						}
					}
					else
					{
						localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_LOST_CAPITAL_UNMET_WINNING");
						localizedBuffer << iMostOriginalCapitals;
					}
				}
				else
				{
					localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_LOST_CAPITAL");
				}
			}

			pNotifications->Add(eNotificationType, localizedBuffer.toUTF8(), localizedSummary.toUTF8(), -1, -1, -1);
		}

		//replay message
		{
			Localization::String message;
			if (eWinningPlayer != NO_PLAYER)
			{
				message = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL_OTHER_WINNING");
				if (GC.getGame().isGameMultiPlayer() && isHuman())
				{
					message << getNickName();
				}
				else
				{
					message << getNameKey();
				}

				if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
				{
					message << GET_PLAYER(eWinningPlayer).getNickName();
				}
				else
				{
					message << GET_PLAYER(eWinningPlayer).getNameKey();
				}

				message << iMostOriginalCapitals;
			}
			else if (eWinningTeam != NO_TEAM)
			{
				message = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL_TEAM_WINNING");
				if (GC.getGame().isGameMultiPlayer() && isHuman())
				{
					message << getNickName();
				}
				else
				{
					message << getNameKey();
				}

				message << (int)eWinningTeam;
				message << iMostOriginalCapitals;
			}
			else
			{
				message = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL");
				if (GC.getGame().isGameMultiPlayer() && isHuman())
				{
					message << getNickName();
				}
				else
				{
					message << getNameKey();
				}
			}

			CvString translatedMessage = message.toUTF8();
			GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, GetID(), translatedMessage, GetOriginalCapitalX(), GetOriginalCapitalY());
		}
	}
	// Player recovered capital!
	else
	{
		Localization::String localizedBuffer;
		Localization::String localizedSummary;

		for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
		{
			PlayerTypes ePlayer = (PlayerTypes)ui;
			CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();
			if(!pNotifications)
			{
				continue;
			}

			// Notify Player lost their capital
			if(ePlayer == GetID())
			{
				localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_RECOVERED_CAPITAL");
				if (eWinningPlayer == ePlayer)
				{
					localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_REGAINED_CAPITAL_YOU_WINNING");
					localizedBuffer << iMostOriginalCapitals;
				}
				else if (GET_TEAM(getTeam()).isHasMet(eWinningTeam))
				{
					if (eWinningPlayer != NO_PLAYER) // there is a winning player
					{
						localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_REGAINED_CAPITAL_OTHER_PLAYER_WINNING");
						if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
						{
							localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
						}
						else
						{
							localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
						}
						localizedBuffer << iMostOriginalCapitals;
					}
					else
					{
						localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_REGAINED_CAPITAL_TEAM_WINNING");
						localizedBuffer << (int)eWinningTeam;
						localizedBuffer << iMostOriginalCapitals;
					}
				}
				else if (eWinningTeam != NO_TEAM) // if someone is winning
				{
					localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_REGAINED_CAPITAL_UNMET_WINNING");
					localizedBuffer << iMostOriginalCapitals;
				}
				else // if no one is winning
				{
					localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_RECOVERED_CAPITAL");
				}
			}
			// Known player
			else if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(getTeam()) || GET_PLAYER(ePlayer).isObserver())
			{
				localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_PLAYER_RECOVERED_CAPITAL");
				localizedSummary << getCivilizationShortDescriptionKey();

				if (eWinningTeam != NO_TEAM)
				{
					if (GET_TEAM(eWinningTeam).isHasMet(GET_PLAYER(ePlayer).getTeam()) || GET_PLAYER(ePlayer).isObserver())
					{
						if (eWinningPlayer == ePlayer)
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL_YOU_WINNING");
							localizedBuffer << iMostOriginalCapitals;
						}
						else if (eWinningPlayer != NO_PLAYER)
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL_OTHER_WINNING");
							if (GC.getGame().isGameMultiPlayer() && isHuman())
							{
								localizedBuffer << getNickName();
							}
							else
							{
								localizedBuffer << getNameKey();
							}

							if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
							{
								localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
							}
							else
							{
								localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
							}
							localizedBuffer << iMostOriginalCapitals;
						}
						else // if (eWinningTeam != NO_TEAM)
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL_TEAM_WINNING");
							if (GC.getGame().isGameMultiPlayer() && isHuman())
							{
								localizedBuffer << getNickName();
							}
							else
							{
								localizedBuffer << getNameKey();
							}

							localizedBuffer << (int)eWinningTeam;
							localizedBuffer << iMostOriginalCapitals;
						}
					}
					else
					{
						localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL_UNMET_WINNING");
						if (GC.getGame().isGameMultiPlayer() && isHuman())
						{
							localizedBuffer << getNickName();
						}
						else
						{
							localizedBuffer << getNameKey();
						}
						localizedBuffer << iMostOriginalCapitals;
					}
				}
				else
				{
					localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL");
					if (GC.getGame().isGameMultiPlayer() && isHuman())
					{
						localizedBuffer << getNickName();
					}
					else
					{
						localizedBuffer << getNameKey();
					}
				}
			}
			else // unmet player
			{
				localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_SOMEONE_RECOVERED_CAPITAL");

				if (eWinningTeam != NO_TEAM)
				{
					if (GET_TEAM(eWinningTeam).isHasMet(GET_PLAYER(ePlayer).getTeam()))
					{
						if (eWinningPlayer == ePlayer)
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_REGAINED_CAPITAL_YOU_WINNING");
							localizedBuffer << iMostOriginalCapitals;
						}
						else if (eWinningPlayer != NO_PLAYER)
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_REGAINED_CAPITAL_OTHER_WINNING");
							if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
							{
								localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
							}
							else
							{
								localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
							}
							localizedBuffer << iMostOriginalCapitals;
						}
						else // if (eWinningTeam != NO_TEAM)
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_REGAINED_CAPITAL_TEAM_WINNING");
							localizedBuffer << (int)eWinningTeam;
							localizedBuffer << iMostOriginalCapitals;
						}
					}
					else
					{
						localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_REGAINED_CAPITAL_UNMET_WINNING");
						localizedBuffer << iMostOriginalCapitals;
					}
				}
				else
				{
					localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_REGAINED_CAPITAL");
				}
			}

			pNotifications->Add(NOTIFICATION_CAPITAL_RECOVERED, localizedBuffer.toUTF8(), localizedSummary.toUTF8(), -1, -1, -1);
		}

		//replay message
		{
			Localization::String message;
			if (eWinningPlayer != NO_PLAYER)
			{
				message = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL_OTHER_WINNING");
				if (GC.getGame().isGameMultiPlayer() && isHuman())
				{
					message << getNickName();
				}
				else
				{
					message << getNameKey();
				}

				if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
				{
					message << GET_PLAYER(eWinningPlayer).getNickName();
				}
				else
				{
					message << GET_PLAYER(eWinningPlayer).getNameKey();
				}

				message << iMostOriginalCapitals;
			}
			else if (eWinningTeam != NO_TEAM)
			{
				message = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL_TEAM_WINNING");
				if (GC.getGame().isGameMultiPlayer() && isHuman())
				{
					message << getNickName();
				}
				else
				{
					message << getNameKey();
				}

				message << (int)eWinningTeam;
				message << iMostOriginalCapitals;
			}
			else
			{
				message = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL");
				if (GC.getGame().isGameMultiPlayer() && isHuman())
				{
					message << getNickName();
				}
				else
				{
					message << getNameKey();
				}
			}

			CvString translatedMessage = message.toUTF8();
			GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, GetID(), translatedMessage, GetOriginalCapitalX(), GetOriginalCapitalY());
		}					
	}
}


//	--------------------------------------------------------------------------------
/// Player who first captured our capital
PlayerTypes CvPlayer::GetCapitalConqueror() const
{
	return m_eConqueror;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getCitiesLost() const
{
	return m_iCitiesLost;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeCitiesLost(int iChange)
{
	m_iCitiesLost = (m_iCitiesLost + iChange);
}

//	--------------------------------------------------------------------------------
bool CvPlayer::OwnsOurCity(PlayerTypes ePlayer)
{
	int iLoop;
	for (CvCity* pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))
	{
		if (pLoopCity->getOriginalOwner() == m_eID)
			return true;
	}

	return false;
}

int CvPlayer::GetNumOurCitiesOwnedBy(PlayerTypes ePlayer)
{
	int iLoop;
	int iCount = 0;
	for (CvCity* pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))
	{
		if (pLoopCity->getOriginalOwner() == m_eID)
			iCount++;
	}

	return iCount;
}

//	--------------------------------------------------------------------------------
int CvPlayer::CalculateDefensivePactLimit(bool bIsAITradeWithHumanPossible /* = false */) const
{
	if (!isMajorCiv() || !isAlive() || GC.getGame().isOption(GAMEOPTION_ALWAYS_WAR) || GC.getGame().isOption(GAMEOPTION_ALWAYS_PEACE) || GC.getGame().isOption(GAMEOPTION_NO_CHANGING_WAR_PEACE))
		return 0;

	int iBaseLimit = isHuman() || bIsAITradeWithHumanPossible ? /*99 in CP, 2 in VP*/ GD_INT_GET(DEFENSIVE_PACT_LIMIT_BASE) : /*2*/ min(GD_INT_GET(DEFENSIVE_PACT_LIMIT_BASE), GD_INT_GET(AI_DEFENSIVE_PACT_LIMIT_BASE));
	int iLimitScaler = isHuman() || bIsAITradeWithHumanPossible ? /*0 in CP, 10 in VP*/ GD_INT_GET(DEFENSIVE_PACT_LIMIT_SCALER) : /*10*/ min(GD_INT_GET(DEFENSIVE_PACT_LIMIT_SCALER), GD_INT_GET(AI_DEFENSIVE_PACT_LIMIT_SCALER));
	if (iBaseLimit <= -1)
		return 0;

	int iTotalOtherMajors = 0;
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes)iPlayerLoop;
		if (getTeam() == GET_PLAYER(eLoopPlayer).getTeam())
			continue;
		if (!GET_PLAYER(eLoopPlayer).isAlive())
			continue;
		if (GET_PLAYER(eLoopPlayer).IsVassalOfSomeone())
			continue;

		iTotalOtherMajors++;
	}

	if (iTotalOtherMajors < 2)
		return 0;

	if (IsIgnoreDefensivePactLimit())
		return iTotalOtherMajors;

	int iLimit = iBaseLimit;
	if (iLimitScaler > 0)
		iLimit += (iTotalOtherMajors / iLimitScaler);

	return min(iLimit, iTotalOtherMajors);
}

bool CvPlayer::IsIgnoreDefensivePactLimit() const
{
	std::vector<BuildingTypes> ValidBuildings;
	for (int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

		if (pkBuildingInfo && pkBuildingInfo->IsIgnoreDefensivePactLimit())
			ValidBuildings.push_back(eBuilding);
	}

	if (ValidBuildings.empty())
		return false;

	int iLoop;
	for (const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		for (std::vector<BuildingTypes>::iterator it = ValidBuildings.begin(); it != ValidBuildings.end(); it++)
		{
			if (pLoopCity->GetCityBuildings()->GetNumBuilding(*it) > 0)
				return true;
		}
	}

	return false;
}


//	--------------------------------------------------------------------------------

int CvPlayer::GetMilitaryRating() const
{
	return m_iMilitaryRating;
}

//	--------------------------------------------------------------------------------

void CvPlayer::SetMilitaryRating(int iValue)
{
	m_iMilitaryRating = max(iValue, 0);
}

//	--------------------------------------------------------------------------------

void CvPlayer::ChangeMilitaryRating(int iChange)
{
	SetMilitaryRating(GetMilitaryRating() + iChange);
}

//	--------------------------------------------------------------------------------

void CvPlayer::DoMilitaryRatingDecay()
{
	int iStartingRating = (GC.getGame().getStartEra() > 0) ? (/*1000*/ GD_INT_GET(MILITARY_RATING_STARTING_VALUE) * GC.getGame().getStartEra()) : /*1000*/ GD_INT_GET(MILITARY_RATING_STARTING_VALUE);
	int iCurrentRating = GetMilitaryRating();
	int iDecayRate = GC.getGame().getGameSpeedInfo().getMilitaryRatingDecayPercent(); // 10 = 1%, default is 20 (2%) on Standard

	if (iCurrentRating < iStartingRating)
	{
		int iDifference = iStartingRating - iCurrentRating;
		int iReduction = max(1, ((iDifference * iDecayRate) / 1000));
		ChangeMilitaryRating(iReduction);
	}
	else if (iCurrentRating > iStartingRating)
	{
		int iDifference = iCurrentRating - iStartingRating;
		int iReduction = max(1, ((iDifference * iDecayRate) / 1000));
		ChangeMilitaryRating(-iReduction);
	}
}

//	--------------------------------------------------------------------------------

void CvPlayer::updateMightStatistics()
{
	m_iTurnSliceMightRecomputed = GC.getGame().getGameTurn();
	m_iMilitaryMight = calculateMilitaryMight();
	m_iEconomicMight = calculateEconomicMight();
	m_iProductionMight = calculateProductionMight();

	if (MOD_BATTLE_ROYALE)
	{
		m_iMilitarySeaMight = calculateMilitaryMight(DOMAIN_SEA);
		m_iMilitaryAirMight = calculateMilitaryMight(DOMAIN_AIR);
		m_iMilitaryLandMight = calculateMilitaryMight(DOMAIN_LAND);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getPower() const
{
	// more lazy evaluation
	if (m_iTurnSliceMightRecomputed < GC.getGame().getGameTurn())
		const_cast<CvPlayer*>(this)->updateMightStatistics();

	return m_iMilitaryMight + m_iEconomicMight;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetMilitaryMight(bool bForMinor) const
{
	// more lazy evaluation
	if (m_iTurnSliceMightRecomputed < GC.getGame().getGameTurn())
		const_cast<CvPlayer*>(this)->updateMightStatistics();

	if (bForMinor && GetPlayerTraits()->GetBullyMilitaryStrengthModifier() != 0)
	{
		int iBonus = m_iMilitaryMight;
		iBonus *= (100 + GetPlayerTraits()->GetBullyMilitaryStrengthModifier());
		iBonus /= 100;
		return iBonus;
	}

	return m_iMilitaryMight;
}
#if defined(MOD_BATTLE_ROYALE)
//	--------------------------------------------------------------------------------
int CvPlayer::GetMilitarySeaMight() const
{
	if (m_iTurnSliceMightRecomputed < GC.getGame().getGameTurn())
	{
		const_cast<CvPlayer*>(this)->updateMightStatistics();
	}
	return m_iMilitarySeaMight;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetMilitaryAirMight() const
{
	if (m_iTurnSliceMightRecomputed < GC.getGame().getGameTurn())
	{
		const_cast<CvPlayer*>(this)->updateMightStatistics();
	}
	return m_iMilitaryAirMight;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetMilitaryLandMight() const
{
	if (m_iTurnSliceMightRecomputed < GC.getGame().getGameTurn())
	{
		const_cast<CvPlayer*>(this)->updateMightStatistics();
	}
	return m_iMilitaryLandMight;
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::GetEconomicMight() const
{
	// more lazy evaluation
	if (m_iTurnSliceMightRecomputed < GC.getGame().getGameTurn())
		const_cast<CvPlayer*>(this)->updateMightStatistics();

	return m_iEconomicMight;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetProductionMight() const
{
	// more lazy evaluation
	if (m_iTurnSliceMightRecomputed < GC.getGame().getGameTurn())
		const_cast<CvPlayer*>(this)->updateMightStatistics();

	return m_iProductionMight;
}

void CvPlayer::ResetMightCalcTurn()
{
	m_iTurnSliceMightRecomputed = -1;
}

//	--------------------------------------------------------------------------------
int CvPlayer::calculateMilitaryMight(DomainTypes eDomain) const
{
	int iSum = 0;
	int iLoop;
	for(const CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(!pLoopUnit->IsCombatUnit())
			continue;

		if (eDomain != NO_DOMAIN && pLoopUnit->getDomainType() != eDomain)
			continue;

		//we are interested in the offensive capabilities of the player
		int iPower = pLoopUnit->GetBestAttackStrength() / 100;

		//some promotions already influence the combat strength so to prevent double counting only consider the advanced promotions
		int iPromotionFactor = 100;
		if (pLoopUnit->getLevel()>3)
			iPromotionFactor += pLoopUnit->getLevel() * 10 - 30;

		//assume garrisons won't take part in offensive action
		if (pLoopUnit->IsGarrisoned())
			iPower /= 2;

		iSum += (iPower*iPromotionFactor)/100;
	}
	
	return iSum;
}

//	--------------------------------------------------------------------------------
int CvPlayer::calculateEconomicMight() const
{
	int iEconomicMight = 5;
	iEconomicMight += getTotalPopulation();

	iEconomicMight += calculateTotalYield(YIELD_FOOD);
	iEconomicMight += calculateTotalYield(YIELD_PRODUCTION);
	iEconomicMight += calculateTotalYield(YIELD_SCIENCE);
	iEconomicMight += calculateTotalYield(YIELD_GOLD);
	iEconomicMight += calculateTotalYield(YIELD_CULTURE);

	//Finally, divide our power by the number of cities we own - the more we have, the less we can defend.
	int iNumCities = (getNumCities() * 10) + 100;
	if (iNumCities > 0)
	{
		iEconomicMight *= 100;
		iEconomicMight /= min(300, iNumCities);
	}

	//Finally, divide our power by the number of cities we own - the more we have, the more our upkeep.
	return iEconomicMight;
}

//	--------------------------------------------------------------------------------
int CvPlayer::calculateProductionMight() const
{
	int iMight = 0;
	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iMight += pLoopCity->getRawProductionDifference(/*bIgnoreFood*/ true, /*bOverflow*/ false);
	}

	return iMight;
}

int CvPlayer::getCombatExperienceTimes100() const
{
	return m_iCombatExperienceTimes100;
}

//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
void CvPlayer::setCombatExperienceTimes100(int iExperienceTimes100, CvUnit* pFromUnit)
#else
void CvPlayer::setCombatExperienceTimes100(int iExperienceTimes100)
#endif
{

	CvAssert(iExperienceTimes100 >= 0);
	
	if (iExperienceTimes100 != getCombatExperienceTimes100())
	{
		m_iCombatExperienceTimes100 = iExperienceTimes100;

		// Enough XP for a Great General to appear?
		if(!isBarbarian())
		{
			int iExperienceThresholdTimes100 = greatGeneralThreshold() * 100;
			if (m_iCombatExperienceTimes100 >= iExperienceThresholdTimes100 && iExperienceThresholdTimes100 > 0)
			{
				// create great person
				CvCity* pBestCity = NULL;
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
				if(pFromUnit == NULL)
				{
#endif
					int iBestValue = INT_MAX;
					int iLoop;
					for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						int iValue = 4 * GC.getGame().getSmallFakeRandNum(getNumCities(), GetPseudoRandomSeed() + iLoop);

						for(int i = 0; i < NUM_YIELD_TYPES; i++)
						{
							iValue += pLoopCity->findYieldRateRank((YieldTypes)i);
						}
						iValue += pLoopCity->findPopulationRank();

						if(iValue < iBestValue)
						{
							pBestCity = pLoopCity;
							iBestValue = iValue;
						}
					}
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
				}
#endif

#if defined(MOD_GLOBAL_LOCAL_GENERALS)
				if(pBestCity || pFromUnit)
#else
				if(pBestCity)
#endif
				{
					// Figure out which Promotion is the one which makes a unit a Great General
					for(int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
					{
						const PromotionTypes eLoopPromotion = static_cast<PromotionTypes>(iI);
						CvPromotionEntry* pkPromotionInfo = GC.getPromotionInfo(eLoopPromotion);
						if(pkPromotionInfo)
						{
							if(pkPromotionInfo->IsGreatGeneral())
							{
								for(int iI = 0; iI < GC.getNumUnitInfos(); iI++)
								{
									const UnitTypes eLoopUnit = static_cast<UnitTypes>(iI);
									CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eLoopUnit);
									if(pkUnitInfo)
									{
										if(pkUnitInfo->GetFreePromotions(eLoopPromotion))
										{
											// Is this the right unit of this class for this civ?
											const UnitTypes eUnit = GetSpecificUnitType((UnitClassTypes)pkUnitInfo->GetUnitClassType());

											if(eUnit == eLoopUnit)
											{
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
												if (pFromUnit && !MOD_LOCAL_GENERALS_NEAREST_CITY)
												{

													CUSTOMLOG("Create Great General at (%d, %d) from unit %s", pFromUnit->plot()->getX(), pFromUnit->plot()->getY(), pFromUnit->getName().GetCString());
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
													createGreatGeneral(eUnit, pFromUnit->plot()->getX(), pFromUnit->plot()->getY(), false);
#else
													createGreatGeneral(eUnit, pFromUnit->plot()->getX(), pFromUnit->plot()->getY());
#endif												
												}
												else if (pFromUnit && MOD_LOCAL_GENERALS_NEAREST_CITY)
												{ 
													CvCity* pNearestCity = GetClosestCityByPathLength(pFromUnit->plot());

													CUSTOMLOG("Create Great General at (%d, %d) from unit %s", pNearestCity->plot()->getX(), pNearestCity->plot()->getY(), pFromUnit->getName().GetCString());
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
													createGreatGeneral(eUnit, pNearestCity->plot()->getX(), pNearestCity->plot()->getY(), false);
#else
													createGreatGeneral(eUnit, pNearestCity->plot()->getX(), pNearestCity->plot()->getY());
#endif												
												}
												else
												{
#endif
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
													pBestCity->createGreatGeneral(eUnit, false);
#else
													pBestCity->createGreatGeneral(eUnit);
#endif
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
												}
#endif
												setCombatExperienceTimes100(getCombatExperienceTimes100() - iExperienceThresholdTimes100);
												break;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
void CvPlayer::changeCombatExperienceTimes100(int iChangeTimes100, CvUnit* pFromUnit)
#else
void CvPlayer::changeCombatExperienceTimes100(int iChangeTimes100)
#endif
{
	if (getCombatExperienceTimes100() + iChangeTimes100 < 0)
	{
		setCombatExperienceTimes100(0);
	}
	else
	{
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
		setCombatExperienceTimes100(getCombatExperienceTimes100() + iChangeTimes100, pFromUnit);
#else
		setCombatExperienceTimes100(getCombatExperienceTimes100() + iChangeTimes100);
#endif
	}

	m_iLifetimeCombatExperienceTimes100 += iChangeTimes100;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNavalCombatExperienceTimes100() const
{
	return m_iNavalCombatExperienceTimes100;
}

//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
void CvPlayer::setNavalCombatExperienceTimes100(int iExperienceTimes100, CvUnit* pFromUnit)
#else
void CvPlayer::setNavalCombatExperienceTimes100(int iExperienceTimes100)
#endif
{
	CvAssert(iExperienceTimes100 >= 0);

	if (iExperienceTimes100 != getNavalCombatExperienceTimes100())
	{
		m_iNavalCombatExperienceTimes100 = iExperienceTimes100;

		// Enough XP for a Great Admiral to appear?
		if(!isBarbarian())
		{
			int iExperienceThresholdTimes100 = greatAdmiralThreshold() * 100;
			if (m_iNavalCombatExperienceTimes100 >= iExperienceThresholdTimes100 && iExperienceThresholdTimes100 > 0)
			{
				// create great person
				CvCity* pBestCity = NULL;
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
				if(pFromUnit == NULL)
				{
#endif
					int iBestValue = INT_MAX;
					int iLoop;
					for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if(!pLoopCity->isCoastal())
						{
							continue;
						}

						int iValue = 4 * GC.getGame().getSmallFakeRandNum(getNumCities(), GetPseudoRandomSeed() + iLoop);

						for(int i = 0; i < NUM_YIELD_TYPES; i++)
						{
							iValue += pLoopCity->findYieldRateRank((YieldTypes)i);
						}
						iValue += pLoopCity->findPopulationRank();

						if(iValue < iBestValue)
						{
							pBestCity = pLoopCity;
							iBestValue = iValue;
						}
					}
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
				}
#endif

#if defined(MOD_GLOBAL_LOCAL_GENERALS)
				if(pBestCity || pFromUnit)
#else
				if(pBestCity)
#endif
				{
					for(int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
					{
						const PromotionTypes eLoopPromotion = static_cast<PromotionTypes>(iI);
						CvPromotionEntry* pkPromotionInfo = GC.getPromotionInfo(eLoopPromotion);
						if(pkPromotionInfo)
						{
							if(pkPromotionInfo->IsGreatAdmiral())
							{
								for(int iI = 0; iI < GC.getNumUnitInfos(); iI++)
								{
									const UnitTypes eLoopUnit = static_cast<UnitTypes>(iI);
									CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eLoopUnit);
									if(pkUnitInfo)
									{
										if(pkUnitInfo->GetFreePromotions(eLoopPromotion))
										{
											// Is this the right unit of this class for this civ?
											const UnitTypes eUnit = GetSpecificUnitType((UnitClassTypes)pkUnitInfo->GetUnitClassType());

											if(eUnit == eLoopUnit)
											{
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
												if (pFromUnit && !MOD_LOCAL_GENERALS_NEAREST_CITY)
												{

													CUSTOMLOG("Create Great Admiral at (%d, %d) from unit %s", pFromUnit->plot()->getX(), pFromUnit->plot()->getY(), pFromUnit->getName().GetCString());
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
													createGreatAdmiral(eUnit, pFromUnit->plot()->getX(), pFromUnit->plot()->getY(), false);
#else
													createGreatAdmiral(eUnit, pFromUnit->plot()->getX(), pFromUnit->plot()->getY());
#endif
#if defined(MOD_PROMOTIONS_FLAGSHIP)
													if (MOD_PROMOTIONS_FLAGSHIP)
													{
														pFromUnit->setHasPromotion((PromotionTypes)GD_INT_GET(PROMOTION_FLAGSHIP), true);
													}
#endif
												}
												else if (pFromUnit && MOD_LOCAL_GENERALS_NEAREST_CITY)
												{
													CvCity* pNearestCity = OperationalAIHelpers::GetClosestFriendlyCoastalCity(pFromUnit->getOwner(), pFromUnit->plot());

													if (pNearestCity != NULL)
													{
														CUSTOMLOG("Create Great Admiral at the city (%d, %d) from unit %s", pNearestCity->plot()->getX(), pNearestCity->plot()->getY(), pFromUnit->getName().GetCString());
														createGreatAdmiral(eUnit, pNearestCity->plot()->getX(), pNearestCity->plot()->getY(), false);
													}
													else
													{
														CUSTOMLOG("Create Great Admiral at plot (%d, %d) from unit %s", pFromUnit->plot()->getX(), pFromUnit->plot()->getY(), pFromUnit->getName().GetCString());
														createGreatAdmiral(eUnit, pFromUnit->plot()->getX(), pFromUnit->plot()->getY(), false);
													}
													if (MOD_PROMOTIONS_FLAGSHIP)
													{
														pFromUnit->setHasPromotion((PromotionTypes)GD_INT_GET(PROMOTION_FLAGSHIP), true);
													}
												}
												else
												{
#endif
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
													pBestCity->createGreatAdmiral(eUnit, false);
#else
													pBestCity->createGreatAdmiral(eUnit);
#endif
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
												}
#endif
												setNavalCombatExperienceTimes100(getNavalCombatExperienceTimes100() - iExperienceThresholdTimes100);
												break;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
void CvPlayer::changeNavalCombatExperienceTimes100(int iChangeTimes100, CvUnit* pFromUnit)
#else
void CvPlayer::changeNavalCombatExperienceTimes100(int iChangeTimes100)
#endif
{
	if (getNavalCombatExperienceTimes100() + iChangeTimes100 < 0)
	{
		setNavalCombatExperienceTimes100(0);
	}
	else
	{
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
		setNavalCombatExperienceTimes100(getNavalCombatExperienceTimes100() + iChangeTimes100, pFromUnit);
#else
		setNavalCombatExperienceTimes100(getNavalCombatExperienceTimes100() + iChangeTimes100);
#endif
	}

	m_iLifetimeCombatExperienceTimes100 += iChangeTimes100;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getLifetimeCombatExperienceTimes100() const
{
	return m_iLifetimeCombatExperienceTimes100;
}

#if defined(MOD_GLOBAL_NO_CONQUERED_SPACESHIPS)
//	--------------------------------------------------------------------------------
// Remove all the parts of the spaceship that this player has assembled
void CvPlayer::disassembleSpaceship(CvPlot* pPlot) {
	if (MOD_GLOBAL_NO_CONQUERED_SPACESHIPS && !isMinorCiv() && !isBarbarian()) {
		CUSTOMLOG("Disassemble spaceship for player %i", GetID());
		CvTeam& thisTeam = GET_TEAM(getTeam());

		if (thisTeam.getProjectCount((ProjectTypes) GD_INT_GET(SPACE_RACE_TRIGGER_PROJECT)) == 1) {
			thisTeam.changeProjectCount((ProjectTypes) GD_INT_GET(SPACESHIP_CAPSULE), -1 * thisTeam.getProjectCount((ProjectTypes) GD_INT_GET(SPACESHIP_CAPSULE)));
			thisTeam.changeProjectCount((ProjectTypes) GD_INT_GET(SPACESHIP_BOOSTER), -1 * thisTeam.getProjectCount((ProjectTypes) GD_INT_GET(SPACESHIP_BOOSTER)));
			thisTeam.changeProjectCount((ProjectTypes) GD_INT_GET(SPACESHIP_STASIS), -1 * thisTeam.getProjectCount((ProjectTypes) GD_INT_GET(SPACESHIP_STASIS)));
			thisTeam.changeProjectCount((ProjectTypes) GD_INT_GET(SPACESHIP_ENGINE), -1 * thisTeam.getProjectCount((ProjectTypes) GD_INT_GET(SPACESHIP_ENGINE)));

			if (pPlot) {
				CUSTOMLOG("Removing launch pad at (%i, %i)", pPlot->getX(), pPlot->getY());
				CvInterfacePtr<ICvPlot1> pDllPlot(new CvDllPlot(pPlot));
				gDLL->GameplaySpaceshipEdited(pDllPlot.get(), 0x0000); // Remove the launch pad
			}
		}
	}
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::getBorderObstacleCount() const
{
	return m_iBorderObstacleCount;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isBorderObstacle() const
{
	return (getBorderObstacleCount() > 0);
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeBorderObstacleCount(int iChange)
{
	if(iChange != 0)
	{
		m_iBorderObstacleCount = (m_iBorderObstacleCount + iChange);
		CvAssert(getBorderObstacleCount() >= 0);
	}
}

#if defined(HH_MOD_BUILDINGS_FRUITLESS_PILLAGE)
//	--------------------------------------------------------------------------------
bool CvPlayer::isBorderGainlessPillage() const
{
	return (m_iBorderGainlessPillageCount > 0);
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeBorderGainlessPillageCount(int iChange)
{
	if(iChange != 0)
	{
		m_iBorderGainlessPillageCount = m_iBorderGainlessPillageCount + iChange;
	}
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::getNetID() const
{
	return CvPreGame::netID(GetID());
}

//	--------------------------------------------------------------------------------
void CvPlayer::setNetID(int iNetID)
{
	CvPreGame::setNetID(GetID(), iNetID);
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isConnected() const
{
	return gDLL->IsPlayerConnected(GetID());
}

//	--------------------------------------------------------------------------------
void CvPlayer::sendTurnReminder()
{
	//Send a game invite to the player if they aren't currently connected to the game.
	gDLL->sendTurnReminder(GetID());

	/* email notifications not implimented.
	if(!getPbemEmailAddress().empty() &&
	        !gDLL->GetPitbossSmtpHost().empty())
	{

	}
	*/
}

//	--------------------------------------------------------------------------------
uint CvPlayer::getStartTime() const
{
	return m_uiStartTime;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setStartTime(uint uiStartTime)
{
	m_uiStartTime = uiStartTime;
}


//	--------------------------------------------------------------------------------
uint CvPlayer::getTotalTimePlayed() const
{
	return ((timeGetTime() - m_uiStartTime)/1000);
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isMinorCiv() const
{
	return GET_TEAM(getTeam()).isMinorCiv();
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isMajorCiv() const
{
	return GET_TEAM(getTeam()).isMajorCiv();
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsVassalOfSomeone() const
{
	return GET_TEAM(getTeam()).IsVassalOfSomeone();
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumVassals() const
{
	return GET_TEAM(getTeam()).GetNumVassals();
}

//	--------------------------------------------------------------------------------
/// How many (valid) major civs has this player met?
int CvPlayer::GetNumValidMajorsMet(bool bJustMetBuffer) const
{
	int iJustMetBuffer = /*10*/ GD_INT_GET(JUST_MET_TURN_BUFFER);
	int iNumPlayers = 0;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (getTeam() != GET_PLAYER(eLoopPlayer).getTeam() && GET_TEAM(getTeam()).isHasMet(GET_PLAYER(eLoopPlayer).getTeam()) && GET_PLAYER(eLoopPlayer).isMajorCiv() && GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).getNumCities() > 0)
		{
			if (GetDiplomacyAI()->IsAlwaysAtWar(eLoopPlayer))
				continue;

			if (bJustMetBuffer && GET_TEAM(getTeam()).GetTurnsSinceMeetingTeam(GET_PLAYER(eLoopPlayer).getTeam()) < iJustMetBuffer)
				continue;
		
			iNumPlayers++;
		}
	}

	return iNumPlayers;
}

//	--------------------------------------------------------------------------------
/// Has this player met any (valid) minor civs?
bool CvPlayer::HasMetValidMinorCiv() const
{
	for (int iPlayerLoop = MAX_MAJOR_CIVS; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		
		if (GET_TEAM(getTeam()).isHasMet(GET_PLAYER(eLoopPlayer).getTeam()) && GET_PLAYER(eLoopPlayer).isMinorCiv() && GET_PLAYER(eLoopPlayer).isAlive() && GET_PLAYER(eLoopPlayer).getNumCities() > 0 && !IsAtWarWith(eLoopPlayer))
			return true;
	}
	
	return false;
}

//	--------------------------------------------------------------------------------
/// Has this player betrayed a Minor Civ he was bullying by declaring war on him?
bool CvPlayer::IsHasBetrayedMinorCiv() const
{
	return m_bHasBetrayedMinorCiv;
}

//	--------------------------------------------------------------------------------
/// Sets this player to have betrayed a Minor Civ he was bullying by declaring war on him
void CvPlayer::SetHasBetrayedMinorCiv(bool bValue)
{
	if(IsHasBetrayedMinorCiv() != bValue)
	{
		m_bHasBetrayedMinorCiv = bValue;
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::setAlive(bool bNewValue, bool bNotify)
{
	// No state change - ignore
	if (isAlive() == bNewValue)
		return;

	// Can't kill Barbarians
	if (!bNewValue && isBarbarian())
		return;

	// Update memory values
	m_bAlive = bNewValue;
	if (bNewValue)
	{
		GET_TEAM(getTeam()).changeAliveCount(1);

		if (!isEverAlive() && !isObserver())
		{
			m_bEverAlive = true;
			GET_TEAM(getTeam()).changeEverAliveCount(1);
		}

		if (getNumCities() == 0)
			setFoundedFirstCity(false);

		GET_TEAM(getTeam()).SetKilledByTeam(NO_TEAM);
	}
	else
	{
		GET_TEAM(getTeam()).changeAliveCount(-1);
	}

	// Update the World Congress
	GC.getGame().GetGameLeagues()->DoPlayerAliveStatusChanged(GetID());

	// Update Minor Civ AI
	if (isMinorCiv())
	{
		GetMinorCivAI()->DoChangeAliveStatus(bNewValue);
	}

	// Update turns/slot status if the player is now alive
	if (bNewValue)
	{
		if (isSimultaneousTurns() || (GC.getGame().getNumGameTurnActive() == 0) || (GC.getGame().isSimultaneousTeamTurns() && GET_TEAM(getTeam()).isTurnActive()))
		{
			setTurnActive(true);
		}

		gDLL->openSlot(GetID());
	}
	// Player is now dead
	else
	{
		// Reset war value lost
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
			if (getTeam() == GET_PLAYER(eLoopPlayer).getTeam())
				continue;

			SetWarValueLost(eLoopPlayer, 0);
			SetWarDamageValue(eLoopPlayer, 0);
			GET_PLAYER(eLoopPlayer).SetWarValueLost(GetID(), 0);
			GET_PLAYER(eLoopPlayer).SetWarDamageValue(GetID(), 0);
		}

		// Wipe out everything involving this player
		GC.getGame().GetGameDeals().DoCancelAllDealsWithPlayer(GetID());
		clearResearchQueue();
		ResetWarPeaceTurnCounters();
		killUnits();
		killCities();

		// Update Player Proximity
		DoUpdateProximityToPlayers();

		// Entire team is dead
		if (!GET_TEAM(getTeam()).isAlive())
		{
			for (int i = 0; i < MAX_TEAMS; i++)
			{
				TeamTypes eTheirTeam = (TeamTypes)i;
				if (getTeam() != eTheirTeam)
				{
					// close both embassies (also cancels Defensive Pacts / Open Borders)
					GET_TEAM(getTeam()).CloseEmbassyAtTeam(eTheirTeam);
					GET_TEAM(eTheirTeam).CloseEmbassyAtTeam(getTeam());

					// cancel any research agreements
					GET_TEAM(getTeam()).CancelResearchAgreement(eTheirTeam);
					GET_TEAM(eTheirTeam).CancelResearchAgreement(getTeam());

					// end vassalage
					GET_TEAM(getTeam()).DoEndVassal(eTheirTeam, true, true);
					GET_TEAM(eTheirTeam).DoEndVassal(getTeam(), true, true);

					// put both teams at peace	
					GET_TEAM(getTeam()).setAtWar(eTheirTeam, false, false);
					GET_TEAM(eTheirTeam).setAtWar(getTeam(), false, false);

					// set locked war turns to 0
					GET_TEAM(getTeam()).SetNumTurnsLockedIntoWar(eTheirTeam, 0);
					GET_TEAM(eTheirTeam).SetNumTurnsLockedIntoWar(getTeam(), 0);
				}
			}
		}

		if (isMajorCiv())
		{
			// Military rating drops to 0
			SetMilitaryRating(0);

			// Reset war weariness
			if (MOD_BALANCE_CORE_HAPPINESS)
				GetCulture()->SetWarWeariness(0);

			// Reset relationships with minor civs
			for (int iPlayerLoop = MAX_MAJOR_CIVS; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
			{
				PlayerTypes eLoopMinor = (PlayerTypes) iPlayerLoop;
				GET_PLAYER(eLoopMinor).GetMinorCivAI()->ResetFriendshipWithMajor(GetID());
				if (GET_PLAYER(eLoopMinor).GetMinorCivAI()->IsAllies(GetID()))
				{
					CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
					if (pLeague)
					{
						ActiveResolutionList vActiveResolutions = pLeague->GetActiveResolutions();
						for (ActiveResolutionList::iterator it = vActiveResolutions.begin(); it != vActiveResolutions.end(); it++)
						{
							if (it->GetEffects()->bSphereOfInfluence && it->GetProposerDecision()->GetProposer() == GetID())
							{
								PlayerTypes eMinor = (PlayerTypes)it->GetProposerDecision()->GetDecision();
								if(eMinor != NO_PLAYER)
									it->RemoveEffects(eMinor);
							}
						}

					}
				}
			}

			// Update Diplomacy AI
			GetDiplomacyAI()->SlotStateChange();
		}

		if (bNotify)
		{
			Localization::String strMessage = Localization::Lookup("TXT_KEY_MISC_CIV_DESTROYED");
			strMessage << getCivilizationAdjectiveKey();
			Localization::String strSummary = Localization::Lookup("TXT_KEY_MISC_CIV_DESTROYED_SHORT");
			strSummary << getCivilizationShortDescriptionKey();

			for (int iI = 0; iI < MAX_PLAYERS; iI++)
			{
				CvPlayerAI& kOtherPlayer = GET_PLAYER((PlayerTypes)iI);
				if (!kOtherPlayer.GetNotifications())
					continue;

				if ((kOtherPlayer.isAlive() && GET_TEAM(kOtherPlayer.getTeam()).isHasMet(getTeam())) || kOtherPlayer.isObserver())
				{
					kOtherPlayer.GetNotifications()->Add(NOTIFICATION_PLAYER_KILLED, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, -1);
				}
			}

			GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, GetID(), strMessage.toUTF8(), -1, -1);
		}

		// Disconnect this player from the game
		if (CvPreGame::isNetworkMultiplayerGame() && m_eID == GC.getGame().getActivePlayer())
			gDLL->netDisconnect();

		// Close this player's slot
		setTurnActive(false);
		gDLL->closeSlot(GetID());

		// Was the game won?
		GC.getGame().testVictory();
	}

	GC.getGame().setScoreDirty(true);
}

//	--------------------------------------------------------------------------------
void CvPlayer::verifyAlive(PlayerTypes eKiller /* = NO_PLAYER */)
{
	// Player was alive last time we checked
	if (isAlive())
	{
		// Barbarians are always alive
		if (isBarbarian())
			return;

		if (getNumCities() == 0 && getAdvancedStartPoints() < 0)
		{
			if ((GC.getGame().getMaxCityElimination() > 0 && getCitiesLost() >= GC.getGame().getMaxCityElimination()) ||
				(getNumUnits() == 0 || ((isFoundedFirstCity() || !HasActiveSettler()) && !GC.getGame().isOption(GAMEOPTION_COMPLETE_KILLS) && !GetPlayerTraits()->IsStaysAliveZeroCities())))
			{
				if (eKiller != NO_PLAYER)
				{
					GET_TEAM(getTeam()).SetKilledByTeam(GET_PLAYER(eKiller).getTeam());
					SetEverConqueredBy(eKiller, true);

					if (GET_PLAYER(eKiller).isMajorCiv())
					{
						// Apply a backstabbing mark for the killed major civ
						if (isMajorCiv())
							GetDiplomacyAI()->SetBackstabbedBy(eKiller, true, true);

						// Check for killing protected City-States
						if (isMinorCiv())
						{
							for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
							{
								PlayerTypes eLoopPlayer = (PlayerTypes)iPlayerLoop;
								if (GET_PLAYER(eLoopPlayer).getTeam() == GET_PLAYER(eKiller).getTeam() || !GET_PLAYER(eLoopPlayer).isAlive())
									continue;

								if (GetMinorCivAI()->IsProtectedByMajor(eLoopPlayer))
								{
									GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetOtherPlayerKilledProtectedMinorTurn(eKiller, GC.getGame().getGameTurn());
									GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetOtherPlayerProtectedMinorKilled(eKiller, GetID());
									GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeOtherPlayerNumProtectedMinorsKilled(eKiller, 1);

									// Player broke a promise that he wasn't going to kill the Minor
									if (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->IsPlayerMadeAttackCityStatePromise(eKiller))
									{
										GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetPlayerAttackCityStatePromiseState(eKiller, PROMISE_STATE_BROKEN);
									}
								}
							}
						}
					}
				}

				// Kill the player
				setAlive(false);
			}
		}
	}
	// Player was dead last time we checked
	else
	{
		// Do they now have units or cities?
		if (getNumCities() > 0 || getNumUnits() > 0)
		{
			setAlive(true);
		}
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isTurnActive() const
{
	return m_bTurnActive;
}

//	--------------------------------------------------------------------------------
void CvPlayer::setTurnActiveForPbem(bool bActive)
{
	CvAssertMsg(GC.getGame().isPbem(), "You are using setTurnActiveForPbem. Are you sure you know what you're doing?");

	// does nothing more than to set the member variable before saving the game
	// the rest of the turn will be performed upon loading the game
	// This allows the player to browse the game in paused mode after he has generated the save
	if(isTurnActive() != bActive)
	{
		m_bTurnActive = bActive;
		GC.getGame().changeNumGameTurnActive(isTurnActive() ? 1 : -1, "setTurnActiveForPlayByEmail");
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::setTurnActive(bool bNewValue, bool bDoTurn) // R: bDoTurn default is true (CvPlayer.h)
{
	//experiment for debugging. in single player mode create autosaves after the human turn for easier reproduction of observed AI problems
#if defined(VPDEBUG)
	if(!GC.getGame().isGameMultiPlayer() && isHuman() && bNewValue==false)
		gDLL->AutoSave(false, true);
#endif

	if(isTurnActive() != bNewValue)
	{
		CvGame& kGame = GC.getGame();
		CvMap& theMap = GC.getMap();
		m_bTurnActive = bNewValue; // R: this is causing the AI playing twice in one turn bug

		// DN: There is a strange issue with players missing their turns after loading a game, with the AI getting two turns in a row.
		// It seems *to me* that Civ is incorrectly thinking telling us that the players have already indicated they have finished their turns
		// A hacky solution to this is to tell Civ to cancel the player turn complete state.
		// Otherwise they get their turn ended in the next call to updateMoves after the condition (!player.isEndTurn() && gDLL->HasReceivedTurnComplete(player.GetID()) && player.isHuman())
		// R: the function CancelActivePlayerEndTurn() does not help with this issue, because player.isEndTurn() == False, only gDLL->HasReceivedTurnComplete(player.GetID()) seems to catch this issue, was there a wrong gDLL->sendTurnComplete() somewhere?
		// in addition, this bug does not advance the turn count
		// also, the players do not really miss their turns, what actually happens is that the AI plays twice in one turn
		if(bNewValue)
			if(kGame.isFirstActivationOfPlayersAfterLoad())
				if(isHuman() && isAlive() && isSimultaneousTurns() && isLocalPlayer())
					if(gDLL->HasReceivedTurnComplete(GetID()))
						gDLL->sendTurnUnready();

		DLLUI->PublishEndTurnDirty();

		/////////////////////////////////////////////
		// TURN IS BEGINNING
		/////////////////////////////////////////////

		if(isTurnActive())
		{
			CvAssertMsg(isAlive(), "isAlive is expected to be true");

			setEndTurn(false);

			DoUnitAttrition();

#if defined(MOD_CORE_DELAYED_VISIBILITY)
			//force update in case one of our units was killed or moved
			for (int iI = 0; iI < theMap.numPlots(); iI++)
				theMap.plotByIndexUnchecked(iI)->flipVisibility(getTeam());
#endif

			if(kGame.getActivePlayer() == m_eID)
				theMap.updateDeferredFog();

			if((kGame.isHotSeat() || kGame.isPbem()) && isHuman() && bDoTurn)
			{
				DLLUI->clearEventMessages();

				kGame.setActivePlayer(GetID());
			}

			if(CvPreGame::isPitBoss() && kGame.getActivePlayer() != m_eID && isHuman() && gDLL->IsHost() && !isConnected())
			{//send turn reminder if the player isn't actively connected to the game.
				sendTurnReminder();
			}

			/*
			std::ostringstream infoStream;
			infoStream << "setTurnActive(true) for player ";
			infoStream << (int)GetID();	infoStream << " ";
			infoStream << getName();
			kGame.changeNumGameTurnActive(1, infoStream.str());
			infoStream << std::endl;
			if (isMajorCiv() || isBarbarian()) 
				OutputDebugString(infoStream.str().c_str());
			*/

			DLLUI->PublishPlayerTurnStatus(DLLUIClass::TURN_START, GetID());

			if(bDoTurn)
			{
				SetAllUnitsUnprocessed();

				//important! this sets the city connection flag for all our plots
				//we cannot rely on a lazy update when accessing them because we would need to do it for all players, creating overhead
				GetCityConnections()->Update();
				GetTreasury()->DoUpdateCityConnectionGold();

				//no tactical AI for human, only make sure we have current postures in case we want the AI to take over (debugging)
				if (isHuman())
					GetTacticalAI()->GetTacticalAnalysisMap()->Invalidate();

				if(kGame.isFinalInitialized())
				{
					if(isAlive())
					{
						if(GetDiplomacyRequests())
						{
							GetDiplomacyRequests()->BeginTurn();
						}

						//this is misleading - actual turn processing now happens in CvGame::updateMoves()
						doTurn();
						doTurnUnits();
					}
				}

				if((GetID() == kGame.getActivePlayer()) && (kGame.getElapsedGameTurns() > 0))
				{
					if(kGame.isNetworkMultiPlayer())
					{
						DLLUI->AddMessage(0, GetID(), true, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), GetLocalizedText("TXT_KEY_MISC_TURN_BEGINS").GetCString(), "AS2D_NEWTURN", MESSAGE_TYPE_DISPLAY_ONLY);
					}
				}

				doWarnings();
			}

#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				if (isHuman())
				{
					// JdH: we just activated a human
					// later the AI players need to try to contact the player
					CvDiplomacyRequests::s_aDiploHumans.push_back(GetID());
				}
			}
#endif

			if(GetID() == kGame.getActivePlayer())
			{
				if(DLLUI->GetLengthSelectionList() == 0)
				{
					DLLUI->setCycleSelectionCounter(1);
				}

				DLLUI->setDirty(SelectionCamera_DIRTY_BIT, true);

				// slewis - added this so the tutorial knows when a turn begins
				DLLUI->PublishActivePlayerTurnStart();
			}
			else if(isHuman() && kGame.isGameMultiPlayer())
			{
				DLLUI->PublishRemotePlayerTurnStart();
			}
		}

		/////////////////////////////////////////////
		// TURN IS ENDING
		/////////////////////////////////////////////

		else
		{
#if defined(MOD_CORE_DELAYED_VISIBILITY)
			//visibility expires now!
			for (int iI = 0; iI < theMap.numPlots(); iI++)
				theMap.plotByIndexUnchecked(iI)->flipVisibility(getTeam());
#endif

#if defined(MOD_EVENTS_RED_TURN)
			if (MOD_EVENTS_RED_TURN)
			// RED <<<<<
			{
				ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
				if(pkScriptSystem)
				{	
					CvLuaArgsHandle args;

					args->Push(GetID());

					bool bResult;
					LuaSupport::CallHook(pkScriptSystem, "PlayerEndTurnInitiated", args.get(), bResult);
				}
			}
			// RED >>>>>
#endif
#if defined(MOD_EVENTS_PLAYER_TURN)
			if (MOD_EVENTS_PLAYER_TURN) {
				GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerDoneTurn, GetID());
			}
#endif
			CvAssertFmt(GetEndTurnBlockingType() == NO_ENDTURN_BLOCKING_TYPE, "Expecting the end-turn blocking to be NO_ENDTURN_BLOCKING_TYPE, got %d", GetEndTurnBlockingType());
			SetEndTurnBlocking(NO_ENDTURN_BLOCKING_TYPE, -1);	// Make sure this is clear so the UI doesn't block when it is not our turn.

			//important: healing and restoration of movement points
			DoUnitReset();

			if(!isHuman())
			{
				RepositionInvalidUnits();
			}

			if(GetNotifications())
			{
				GetNotifications()->EndOfTurnCleanup();
			}

			if(GetDiplomacyRequests())
			{
				GetDiplomacyRequests()->EndTurn();
			}

			if(GetID() == kGame.getActivePlayer())
			{
				DLLUI->PublishActivePlayerTurnEnd();
			}

			/*
			if (!isHuman() || (isHuman() && !isAlive()) || (isHuman() && gDLL->HasReceivedTurnAllComplete(GetID())) || kGame.getAIAutoPlay())
			{
				std::ostringstream infoStream;
				infoStream << "setTurnActive(false) for player ";
				infoStream << (int)GetID(); infoStream << " ";
				infoStream << getName();
				kGame.changeNumGameTurnActive(-1, infoStream.str());
				infoStream << std::endl;
				if (isMajorCiv() || isBarbarian()) 
					OutputDebugString(infoStream.str().c_str());
			}
			*/

#if defined(MOD_EVENTS_RED_TURN)
			if (MOD_EVENTS_RED_TURN)
			// RED <<<<<
			{
				ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
				if(pkScriptSystem)
				{	
					CvLuaArgsHandle args;

					args->Push(GetID());

					bool bResult;
					LuaSupport::CallHook(pkScriptSystem, "PlayerEndTurnCompleted", args.get(), bResult);
				}
			}
			// RED >>>>>
#endif

			DLLUI->PublishPlayerTurnStatus(DLLUIClass::TURN_END, GetID());
		}
	}
	else
	{
		CvString logOutput;
		logOutput.Format("SetTurnActive() called without changing the end turn status. Player(%i) OldTurnActive(%i) NewTurnActive(%i)", GetID(), isTurnActive(), bNewValue);
		gDLL->netMessageDebugLog(logOutput);
	}
}

//	----------------------------------------------------------------------------
bool CvPlayer::isSimultaneousTurns() const
{
	if(GC.getGame().isOption(GAMEOPTION_DYNAMIC_TURNS))
	{//in dynamic turns mode, our turn mode varies
		return m_bDynamicTurnsSimultMode;
	}
	else if(GC.getGame().isOption(GAMEOPTION_SIMULTANEOUS_TURNS))
	{
		return true;
	}

	return false;
}


//	----------------------------------------------------------------------------
void CvPlayer::setDynamicTurnsSimultMode(bool simultaneousTurns)
{
	if(simultaneousTurns != m_bDynamicTurnsSimultMode)
	{
		CvNotifications* pNotifications = GetNotifications();
		if (pNotifications)
		{
			NotificationTypes notifyType = NOTIFICATION_TURN_MODE_SEQUENTIAL;
			Localization::String localizedText = Localization::Lookup("TXT_KEY_NOTIFICATION_TURN_MODE_SEQUENTIAL");
			Localization::String localizedTextSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_TURN_MODE_SEQUENTIAL_SUMMARY");
			if(simultaneousTurns)
			{
				notifyType = NOTIFICATION_TURN_MODE_SIMULTANEOUS;
				localizedText = Localization::Lookup("TXT_KEY_NOTIFICATION_TURN_MODE_SIMULTANEOUS");
				localizedTextSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_TURN_MODE_SIMULTANEOUS_SUMMARY");
			}

			pNotifications->Add(notifyType, localizedText.toUTF8(), localizedTextSummary.toUTF8(), -1, -1, -1);
		}

		m_bDynamicTurnsSimultMode = simultaneousTurns;
	}
	
}

//	----------------------------------------------------------------------------
bool CvPlayer::isAutoMoves() const
{
	return m_bAutoMoves;
}

//	----------------------------------------------------------------------------
void CvPlayer::setAutoMoves(bool bNewValue)
{
	if(isAutoMoves() != bNewValue)
	{
		m_bAutoMoves = bNewValue;
		m_bProcessedAutoMoves = false;
	}
}

//	----------------------------------------------------------------------------
bool CvPlayer::hasProcessedAutoMoves() const
{
	return m_bProcessedAutoMoves;
}

//	----------------------------------------------------------------------------
void CvPlayer::setProcessedAutoMoves(bool bNewValue)
{
	if(hasProcessedAutoMoves() != bNewValue)
	{
		m_bProcessedAutoMoves = bNewValue;
	}
}

//	----------------------------------------------------------------------------
bool CvPlayer::isEndTurn() const
{
	return m_bEndTurn;
}

//	------------------------------------------------------------------------------------------------
void CvPlayer::setEndTurn(bool bNewValue)
{
	CvGame& game = GC.getGame();

	if(isSimultaneousTurns()
		&& bNewValue 
		&& game.isNetworkMultiPlayer() 
		&& !gDLL->HasReceivedTurnAllCompleteFromAllPlayers())
	{//When doing simultaneous turns in multiplayer, we don't want anyone to end their turn until everyone has signalled TurnAllComplete.
		// No setting end turn to true until all the players have sent the TurnComplete network message
		return;
	}

	// If this is a remote player in an MP match, don't
	// honor the end of turn request if the player still
	// has units to run the simulation for the turn
	if(!isEndTurn() && isHuman() && GetID() != game.getActivePlayer())
	{
		if(hasBusyUnitOrCity() || (!gDLL->HasReceivedTurnComplete(GetID()) && hasReadyUnit()))
		{
			return;
		}
	}
	else if(!isHuman())
	{
		if(hasBusyUnitOrCity())
		{
			return;
		}
	}

	if(isEndTurn() != bNewValue)
	{
		//  If the game isn't MP and the player has queued popups force him to deal with them first
		if(!GC.getGame().isGameMultiPlayer())
		{
			//if (GC.GetEngineUserInterface()->isPopupQueued())
			//{
			//	GC.GetEngineUserInterface()->setForcePopup(true);
			//	return;
			//}
			//if (GC.GetEngineUserInterface()->isDiploOrPopupWaiting())
			//{
			//	return;
			//}
		}

		CvAssertMsg(isTurnActive(), "isTurnActive is expected to be true");

		m_bEndTurn = bNewValue;

		if(isEndTurn())
		{
			if(!GC.getGame().isOption(GAMEOPTION_DYNAMIC_TURNS) && GC.getGame().isOption(GAMEOPTION_SIMULTANEOUS_TURNS))
			{//fully simultaneous turns only run automoves after every human has moved.
				checkRunAutoMovesForEveryone();
			}
			else
			{
				setAutoMoves(true);
			}
		}
		else
			setAutoMoves(false);
	}
	else
	{
		// This check is here for the AI.  Currently, the setEndTurn(true) never seems to get called for AI players, the automoves are just set directly
		// Why is this?  It would be great if all players were processed the same.
		if(!bNewValue && isAutoMoves())
			setAutoMoves(false);
	}
}

//	---------------------------------------------------------------------------
void CvPlayer::checkRunAutoMovesForEveryone()
{
	bool runAutoMovesForEveryone = true;
	int i = 0;
	for(i = 0; i < MAX_PLAYERS; ++i)
	{
		CvPlayer& p = CvPlayerAI::getPlayer((PlayerTypes)i);
		if(p.isHuman() && !p.isObserver() 
			// Check to see if this human player hasn't gotten to the end turn phase of their turn.  
			// This gets tricky because hot joiners can hop into an ai civ that already finished their turn.
			// When this occurs, the hot joiner will not be turn active, will have already run their automoves,
			// and not have end turn set. (AIs do not set end turn) *sigh*
			// To handle that case, we assume that human players who are not endturn and turn inactive after TurnAllComplete
			// are ready for the human automoves phase.
			&& (!p.isEndTurn()
			&& (!gDLL->HasReceivedTurnAllCompleteFromAllPlayers() || p.isTurnActive()))) 
		{
			runAutoMovesForEveryone = false;
			break;
		}
	}

	if(runAutoMovesForEveryone)
	{
		for(i = 0; i < MAX_PLAYERS; ++i)
		{
			CvPlayer& p = CvPlayerAI::getPlayer((PlayerTypes)i);
			if(p.isHuman())
			{
				p.setAutoMoves(true);
			}
		}
	}
}

//	---------------------------------------------------------------------------
EndTurnBlockingTypes CvPlayer::GetEndTurnBlockingType(void) const
{
	return m_eEndTurnBlockingType;
}

//	---------------------------------------------------------------------------
int CvPlayer::GetEndTurnBlockingNotificationIndex(void) const
{
	return m_iEndTurnBlockingNotificationIndex;
}

//	---------------------------------------------------------------------------
void CvPlayer::SetEndTurnBlocking(EndTurnBlockingTypes eBlockingType, int iNotificationIndex)
{
	bool bFireEvent = false;
	if(m_eEndTurnBlockingType != eBlockingType || m_iEndTurnBlockingNotificationIndex != iNotificationIndex)
	{
		bFireEvent = true;
	}

	EndTurnBlockingTypes ePrevBlockingType = m_eEndTurnBlockingType;
	m_eEndTurnBlockingType = eBlockingType;
	m_iEndTurnBlockingNotificationIndex = iNotificationIndex;

	if(bFireEvent)
	{
		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->SetEndTurnBlockingChanged( ePrevBlockingType, m_eEndTurnBlockingType );
			GC.GetEngineUserInterface()->UpdateEndTurn();
		}
	}
}

//	---------------------------------------------------------------------------
bool CvPlayer::isTurnDone() const
{
	// if this returns true, popups and diplomacy will wait to appear until next turn
	if(!GC.getGame().isPbem() && !GC.getGame().isHotSeat())
	{
		return false;
	}
	if(!isHuman())
	{
		return true;
	}
	if(!isEndTurn())
	{
		return false;
	}
	return (!isAutoMoves());
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isExtendedGame() const
{
	return m_bExtendedGame;
}


//	--------------------------------------------------------------------------------
void CvPlayer::makeExtendedGame()
{
	m_bExtendedGame = true;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isFoundedFirstCity() const
{
	return m_bFoundedFirstCity;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setFoundedFirstCity(bool bNewValue)
{
	if(isFoundedFirstCity() != bNewValue)
	{
		m_bFoundedFirstCity = bNewValue;

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(PercentButtons_DIRTY_BIT, true);
			GC.GetEngineUserInterface()->setDirty(ResearchButtons_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumCitiesFounded() const
{
	return m_iNumCitiesFounded;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumCitiesFounded(int iValue)
{
	m_iNumCitiesFounded += iValue;
}

//	--------------------------------------------------------------------------------
// check to see if we defeated this other player
void CvPlayer::CheckForMurder(PlayerTypes ePossibleVictimPlayer)
{
	// Cache whether the player is human or not.  If the player is killed, the CvPreGame::slotStatus is changed to SS_CLOSED
	// but the slot status is used to determine if the player is human or not, so it looks like it is an AI!
	// This should be fixed, but might have unforeseen ramifications so...
	CvPlayer& kPossibleVictimPlayer = GET_PLAYER(ePossibleVictimPlayer);

	// Trigger war victory bonuses for all majors at war if a major was killed
	vector<PlayerTypes> vAtWarWithPossibleVictim;
	if (kPossibleVictimPlayer.isMajorCiv())
	{
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			if (!GET_PLAYER(eLoopPlayer).isAlive() || GET_PLAYER(eLoopPlayer).getTeam() == GET_PLAYER(ePossibleVictimPlayer).getTeam())
				continue;

			if (GET_PLAYER(eLoopPlayer).isMajorCiv() && GET_PLAYER(eLoopPlayer).IsAtWarWith(ePossibleVictimPlayer))
				vAtWarWithPossibleVictim.push_back(eLoopPlayer);
		}
	}

	// This may 'kill' the player if it is deemed that he does not have the proper cities/units to stay alive
	kPossibleVictimPlayer.verifyAlive(GetID());

	// You... you killed him!
	if (!kPossibleVictimPlayer.isAlive() && kPossibleVictimPlayer.isMajorCiv())
	{
		// Leader pops up and whines
		if (isMajorCiv() && !CvPreGame::isNetworkMultiplayerGame() && !kPossibleVictimPlayer.isHuman()) // Not humans or in MP
		{
			kPossibleVictimPlayer.GetDiplomacyAI()->DoKilledByPlayer(GetID());
		}

		for (vector<PlayerTypes>::iterator it = vAtWarWithPossibleVictim.begin(); it != vAtWarWithPossibleVictim.end(); it++)
		{
			GET_PLAYER(*it).DoWarVictoryBonuses();
		}
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isStrike() const
{
	return m_bStrike;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setStrike(bool bNewValue)
{
	if(m_bStrike != bNewValue)
	{
		m_bStrike = bNewValue;

		if(m_bStrike)
		{
			if(GetID() == GC.getGame().getActivePlayer())
			{
				GC.GetEngineUserInterface()->AddMessage(0, GetID(), false, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), GetLocalizedText("TXT_KEY_MISC_UNITS_ON_STRIKE").GetCString(), "AS2D_STRIKE", MESSAGE_TYPE_MINOR_EVENT, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_WARNING_TEXT"));

				GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
			}
		}
	}
}


//	--------------------------------------------------------------------------------
/// Is the player is cramped in his current area?
bool CvPlayer::IsCramped() const
{
	return m_bCramped;
}

//	--------------------------------------------------------------------------------
/// Determines if the player is cramped in his current area.  Not a perfect algorithm, as it will double-count Plots shared by different Cities, but it should be good enough
void CvPlayer::DoUpdateCramped()
{
	m_bCramped = false;

	int iTotalPlotsNearby = 0;
	int iUsablePlotsNearby = 0;

	int iRange = /*5*/ GD_INT_GET(CRAMPED_RANGE_FROM_CITY);

	int iLoop;
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		for(int iX = -iRange; iX <= iRange; iX++)
		{
			for(int iY = -iRange; iY <= iRange; iY++)
			{
				CvPlot* pPlot = plotXYWithRangeCheck(pLoopCity->getX(), pLoopCity->getY(), iX, iY, iRange);
				if(pPlot != NULL)
				{
					// Plot not owned by me
					if(!pPlot->isOwned() || pPlot->getOwner() != GetID())
					{
						iTotalPlotsNearby++;

						// A "good" unowned Plot
						if(!pPlot->isOwned() && pPlot->isValidMovePlot(GetID()) && !pPlot->isWater())
						{
							iUsablePlotsNearby++;
						}
					}
				}
			}
		}
	}

	if (iTotalPlotsNearby > 0 && (100 * iUsablePlotsNearby) / iTotalPlotsNearby <= /*25*/ GD_INT_GET(CRAMPED_USABLE_PLOT_PERCENT))
		m_bCramped = true;
}

//	--------------------------------------------------------------------------------
const CvHandicapInfo& CvPlayer::getHandicapInfo() const
{
	static CvHandicapInfo emptyResult;

	CvHandicapInfo* pkHandicapInfo = GC.getHandicapInfo(getHandicapType());
	if (pkHandicapInfo == NULL)
	{
		const char* szError = "ERROR: Player does not contain valid handicap!!";
		GC.LogMessage(szError);
		CvAssertMsg(false, szError);

		return emptyResult;
	}
	else
		return *pkHandicapInfo;
}

//	--------------------------------------------------------------------------------
HandicapTypes CvPlayer::getHandicapType() const
{
	return CvPreGame::handicap(GetID());
}

//	--------------------------------------------------------------------------------
const CvCivilizationInfo& CvPlayer::getCivilizationInfo() const
{
	static CvCivilizationInfo emptyResult;

	CvCivilizationInfo* pkCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
	if(pkCivilizationInfo == NULL)
	{
		const char* szError = "ERROR: Player does not contain valid civilization type!!";
		GC.LogMessage(szError);
		CvAssertMsg(false, szError);

		return emptyResult;
	}
	else
		return *pkCivilizationInfo;
}

//	--------------------------------------------------------------------------------
CivilizationTypes CvPlayer::getCivilizationType() const
{
	return CvPreGame::civilization(GetID());
}


//	--------------------------------------------------------------------------------
const CvLeaderHeadInfo& CvPlayer::getLeaderInfo() const
{
	static CvLeaderHeadInfo emptyResult;

	CvLeaderHeadInfo* pkLeaderInfo = GC.getLeaderHeadInfo(getLeaderType());
	if(pkLeaderInfo == NULL)
	{
		const char* szError = "ERROR: Player does not contain valid leader type!!";
		GC.LogMessage(szError);
		CvAssertMsg(false, szError);

		return emptyResult;
	}
	else
		return *pkLeaderInfo;
}

//	--------------------------------------------------------------------------------
LeaderHeadTypes CvPlayer::getLeaderType() const
{
	return CvPreGame::leaderHead(GetID());
}

//	--------------------------------------------------------------------------------
void CvPlayer::setLeaderType(LeaderHeadTypes eNewLeader)
{
    if (isMajorCiv())
	{
		LeaderHeadTypes eOldLeader = getLeaderType();
		
		// Set the new leader type
		CvPreGame::setLeaderHead(GetID(), eNewLeader);
	
		// Update the player's personality
		setPersonalityType(eNewLeader);
	
		// Update the player's traits (Leader_Traits)
		GetPlayerTraits()->Reset();
		GetPlayerTraits()->InitPlayerTraits();
		recomputePolicyCostModifier();
		
		if (!isHuman()) 
		{
			// Update the player's biases (Leader_MajorCivApproachBiases)
			// Nothing to do as they are not cached in CvPlayer
	
			// Update the player's flavours (Leader_Flavors)
			GetFlavorManager()->ChangeLeader(eOldLeader, eNewLeader);
			
			// Update the player's strategies
			// Nothing to do as these will auto-update based on the new flavours at the end of the player's turn
		}
	}
}

//	--------------------------------------------------------------------------------
LeaderHeadTypes CvPlayer::getPersonalityType() const
{
	return m_ePersonalityType;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setPersonalityType(LeaderHeadTypes eNewValue)
{
	m_ePersonalityType = eNewValue;
}


//	--------------------------------------------------------------------------------
EraTypes CvPlayer::GetCurrentEra() const
{
	return GET_TEAM(getTeam()).GetCurrentEra();
}

//	--------------------------------------------------------------------------------
void CvPlayer::setTeam(TeamTypes eTeam)
{
	CvAssert(eTeam != NO_TEAM);
	CvAssert(getTeam() != NO_TEAM);
	if(isAlive())
	{
		GET_TEAM(getTeam()).changeAliveCount(-1);
	}
	if(isEverAlive())
	{
		GET_TEAM(getTeam()).changeEverAliveCount(-1);
	}
	GET_TEAM(getTeam()).changeNumCities(-(getNumCities()));
	GET_TEAM(getTeam()).changeTotalPopulation(-(getTotalPopulation()));
	GET_TEAM(getTeam()).changeTotalLand(-(getTotalLand()));

	GET_TEAM(getTeam()).removePlayer(GetID());

	CvPreGame::setTeamType(GetID(), eTeam);

	GET_TEAM(getTeam()).addPlayer(GetID());

	if(isAlive())
	{
		GET_TEAM(getTeam()).changeAliveCount(1);
	}
	if(isEverAlive())
	{
		GET_TEAM(getTeam()).changeEverAliveCount(1);
	}
	GET_TEAM(getTeam()).changeNumCities(getNumCities());
	GET_TEAM(getTeam()).changeTotalPopulation(getTotalPopulation());
	GET_TEAM(getTeam()).changeTotalLand(getTotalLand());
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsAITeammateOfHuman() const
{
	if (isHuman())
		return false;

	const std::vector<PlayerTypes>& teammates = GET_TEAM(getTeam()).getPlayers();
	for (size_t i = 0; i < teammates.size(); ++i)
	{
		CvPlayer& player = GET_PLAYER(teammates[i]);

		if (player.isHuman() && player.isAlive())
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
PlayerColorTypes CvPlayer::getPlayerColor() const
{
	return CvPreGame::playerColor(GetID());
}

//	--------------------------------------------------------------------------------
const CvColorA& CvPlayer::getPlayerTextColor() const
{
	CvAssertMsg(getPlayerColor() != NO_PLAYERCOLOR, "getPlayerColor() is not expected to be equal with NO_PLAYERCOLOR");
	CvPlayerColorInfo* pkPlayerColorInfo = GC.GetPlayerColorInfo(getPlayerColor());
	CvColorInfo* pkColorInfo = NULL;
	if(pkPlayerColorInfo)
	{
		ColorTypes eTextColor = static_cast<ColorTypes>(pkPlayerColorInfo->GetColorTypeText());
		pkColorInfo = GC.GetColorInfo(eTextColor);
		if(pkColorInfo)
			return pkColorInfo->GetColor();
	}

	//Default to black text if no color exists.
	static CvColorA black(0,0,0,1.0f);
	return black;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getSeaPlotYield(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiSeaPlotYield[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeSeaPlotYield(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiSeaPlotYield[eIndex] = m_aiSeaPlotYield[eIndex] + iChange;

		updateYield();
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getYieldRateModifier(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldRateModifier[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldRateModifier(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldRateModifier[eIndex] = m_aiYieldRateModifier[eIndex] + iChange;

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
#if defined(MOD_BALANCE_CORE_POLICIES)
//	--------------------------------------------------------------------------------
int CvPlayer::GetTradeReligionModifier() const
{
	return m_iTradeReligionModifier;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeTradeReligionModifier(int iChange)
{
	m_iTradeReligionModifier += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromBirth(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldFromBirth[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromBirth(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldFromBirth[eIndex] = m_aiYieldFromBirth[eIndex] + iChange;

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromBirthCapital(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldFromBirthCapital[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromBirthCapital(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldFromBirthCapital[eIndex] = m_aiYieldFromBirthCapital[eIndex] + iChange;

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromDeath(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldFromDeath[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromDeath(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldFromDeath[eIndex] = m_aiYieldFromDeath[eIndex] + iChange;

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

int CvPlayer::GetYieldFromPillage(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromPillage[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangeYieldFromPillage(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiYieldFromPillage[eIndex] = m_aiYieldFromPillage[eIndex] + iChange;

		invalidateYieldRankCache(eIndex);

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

int CvPlayer::GetYieldFromVictory(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
		CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromVictory[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangeYieldFromVictory(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiYieldFromVictory[eIndex] = m_aiYieldFromVictory[eIndex] + iChange;

		invalidateYieldRankCache(eIndex);

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromConstruction(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldFromConstruction[eIndex];
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromConstruction(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldFromConstruction[eIndex] = m_aiYieldFromConstruction[eIndex] + iChange;

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetYieldFromWorldWonderConstruction(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldFromWorldWonderConstruction[eIndex];
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeYieldFromWorldWonderConstruction(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiYieldFromWorldWonderConstruction[eIndex] = m_aiYieldFromWorldWonderConstruction[eIndex] + iChange;

		invalidateYieldRankCache(eIndex);

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromTech(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldFromTech[eIndex];
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromTech(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldFromTech[eIndex] = m_aiYieldFromTech[eIndex] + iChange;

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromBorderGrowth(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldFromBorderGrowth[eIndex];
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromBorderGrowth(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldFromBorderGrowth[eIndex] = m_aiYieldFromBorderGrowth[eIndex] + iChange;

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::getYieldGPExpend(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldGPExpend[eIndex];
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldGPExpend(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldGPExpend[eIndex] = m_aiYieldGPExpend[eIndex] + iChange;

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::getConquerorYield(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiConquerorYield[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeConquerorYield(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiConquerorYield[eIndex] = m_aiConquerorYield[eIndex] + iChange;

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::getFounderYield(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiFounderYield[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeFounderYield(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiFounderYield[eIndex] = m_aiFounderYield[eIndex] + iChange;

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getArtifactYieldBonus(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiArtifactYieldBonus[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeArtifactYieldBonus(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiArtifactYieldBonus[eIndex] = m_aiArtifactYieldBonus[eIndex] + iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getArtYieldBonus(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiArtYieldBonus[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeArtYieldBonus(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiArtYieldBonus[eIndex] = m_aiArtYieldBonus[eIndex] + iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getMusicYieldBonus(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiMusicYieldBonus[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeMusicYieldBonus(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiMusicYieldBonus[eIndex] = m_aiMusicYieldBonus[eIndex] + iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getLitYieldBonus(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiLitYieldBonus[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeLitYieldBonus(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiLitYieldBonus[eIndex] = m_aiLitYieldBonus[eIndex] + iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getFilmYieldBonus(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiFilmYieldBonus[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeFilmYieldBonus(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiFilmYieldBonus[eIndex] = m_aiFilmYieldBonus[eIndex] + iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getRelicYieldBonus(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiRelicYieldBonus[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeRelicYieldBonus(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiRelicYieldBonus[eIndex] = m_aiRelicYieldBonus[eIndex] + iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGoldenAgeYieldMod(YieldTypes eIndex)	const
{
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiGoldenAgeYieldMod[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeGoldenAgeYieldMod(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiGoldenAgeYieldMod[eIndex] = m_aiGoldenAgeYieldMod[eIndex] + iChange;

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromNonSpecialistCitizens(YieldTypes eIndex)	const
{
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromNonSpecialistCitizens[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromNonSpecialistCitizens(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiYieldFromNonSpecialistCitizens[eIndex] = m_aiYieldFromNonSpecialistCitizens[eIndex] + iChange;

		invalidateYieldRankCache(eIndex);

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getYieldModifierFromGreatWorks(YieldTypes eIndex)	const
{
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldModifierFromGreatWorks[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldModifierFromGreatWorks(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiYieldModifierFromGreatWorks[eIndex] = m_aiYieldModifierFromGreatWorks[eIndex] + iChange;

		invalidateYieldRankCache(eIndex);

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getYieldModifierFromActiveSpies(YieldTypes eIndex)	const
{
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldModifierFromActiveSpies[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldModifierFromActiveSpies(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiYieldModifierFromActiveSpies[eIndex] = m_aiYieldModifierFromActiveSpies[eIndex] + iChange;

		invalidateYieldRankCache(eIndex);

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromDelegateCount(YieldTypes eIndex)	const
{
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromDelegateCount[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromDelegateCount(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiYieldFromDelegateCount[eIndex] = m_aiYieldFromDelegateCount[eIndex] + iChange;

		invalidateYieldRankCache(eIndex);

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
#if defined(MOD_BALANCE_CORE_POLICIES)
//	--------------------------------------------------------------------------------
int CvPlayer::getYieldForLiberation(YieldTypes eIndex)	const
{
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldForLiberation[eIndex];
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldForLiberation(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
		m_aiYieldForLiberation[eIndex] = m_aiYieldForLiberation[eIndex] + iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getInfluenceForLiberation()	const
{
	return m_iInfluenceForLiberation;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeInfluenceForLiberation(int iChange)
{
	m_iInfluenceForLiberation += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getExperienceForLiberation()	const
{
	return m_iExperienceForLiberation;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeExperienceForLiberation(int iChange)
{
	m_iExperienceForLiberation += iChange;
}

int CvPlayer::getCityCaptureHealGlobal() const
{
	return m_iCityCaptureHealGlobal;
}

void CvPlayer::changeCityCaptureHealGlobal(int iChange)
{
	m_iCityCaptureHealGlobal += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNumBuildingClassInLiberatedCities(BuildingClassTypes eIndex)	const
{
	return m_aiBuildingClassInLiberatedCities[eIndex];
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeNumBuildingClassInLiberatedCities(BuildingClassTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex expected to be < GC.getNumBuildingClassInfos()");
	if (iChange != 0)
		m_aiBuildingClassInLiberatedCities[eIndex] = m_aiBuildingClassInLiberatedCities[eIndex] + iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getUnitsInLiberatedCities()	const
{
	return m_iUnitsInLiberatedCities;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeUnitsInLiberatedCities(int iChange)
{
	m_iUnitsInLiberatedCities += iChange;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getReligionYieldRateModifier(YieldTypes eIndex)	const
{
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiReligionYieldRateModifier[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeReligionYieldRateModifier(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiReligionYieldRateModifier[eIndex] = m_aiReligionYieldRateModifier[eIndex] + iChange;

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetGarrisonsOccupiedUnhapppinessMod() const
{
	return m_iGarrisonsOccupiedUnhapppinessMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGarrisonsOccupiedUnhapppinessMod(int iChange)
{
	m_iGarrisonsOccupiedUnhapppinessMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetXPopulationConscription() const
{
	return m_iXPopulationConscription;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeXPopulationConscription(int iChange)
{
	m_iXPopulationConscription += iChange;
}
void CvPlayer::DoXPopulationConscription(CvCity* pCity)
{
	UnitTypes eBestUnit = NO_UNIT;
	int iStrengthBest = 0;
	// Loop through adding the available units
	for (int iUnitLoop = 0; iUnitLoop < GC.getNumUnitInfos(); iUnitLoop++)
	{
		UnitTypes eLoopUnit = (UnitTypes)iUnitLoop;
		if (eLoopUnit != NO_UNIT)
		{
			CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eLoopUnit);
			if (pkUnitEntry)
			{
				if (!pCity->canTrain(eLoopUnit))
				{
					continue;
				}

				if (pkUnitEntry->GetCombat() <= 0 && pkUnitEntry->GetRangedCombat() <= 0)
					continue;

				if (pkUnitEntry->GetDefaultUnitAIType() == UNITAI_EXPLORE)
					continue;

				if (pkUnitEntry->GetDomainType() != DOMAIN_LAND)
					continue;

				bool bBad = false;
				ResourceTypes eResource;
				for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
				{
					eResource = (ResourceTypes)iResourceLoop;
					int iNumResource = pkUnitEntry->GetResourceQuantityRequirement(eResource);
					if (iNumResource > 0)
					{
						bBad = true;
						break;
					}
					if (pkUnitEntry->GetResourceType() == eResource)
					{
						bBad = true;
						break;
					}
#if defined(MOD_UNITS_RESOURCE_QUANTITY_TOTALS)
					if (MOD_UNITS_RESOURCE_QUANTITY_TOTALS && pkUnitEntry->GetResourceQuantityTotal(eResource) > 0)
					{
						bBad = true;
						break;
					}
#endif
				}

				if (bBad)
				{
					continue;
				}

				int iCombatStrength = (pkUnitEntry->GetPower() + GC.getGame().getSmallFakeRandNum(pkUnitEntry->GetPower(), pCity->plot()->GetPlotIndex() + getTotalPopulation()));
				if (pkUnitEntry->GetRange() > 0)
				{
					iCombatStrength *= 50;
					iCombatStrength /= 100;
				}

				if (iCombatStrength <= 0)
					iCombatStrength = 1;
				
				if (iCombatStrength > iStrengthBest)
				{
					iStrengthBest = iCombatStrength;
					eBestUnit = eLoopUnit;
				}
			}
		}
	}
	if (eBestUnit != NO_UNIT)
	{
		CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eBestUnit);
		if (pkUnitEntry)
		{
			UnitAITypes eUnitAI = pkUnitEntry->GetDefaultUnitAIType();
			CvUnit* pUnit = pCity->CreateUnit(eBestUnit, eUnitAI, REASON_GIFT);
			if (pUnit)
			{
				changeNumUnitsSupplyFree(1);
				pUnit->changeNoSupply(1);
				PromotionTypes ePromotionConscript = (PromotionTypes)GC.getInfoTypeForString("PROMOTION_CONSCRIPT");
				if (ePromotionConscript != NO_PROMOTION)
					pUnit->setHasPromotion(ePromotionConscript, true);

				if (!pUnit->jumpToNearestValidPlot())
				{
					pUnit->kill(false);	// Could not find a valid spot!
				}
				else
				{
					pUnit->finishMoves();
					pUnit->SetTurnProcessed(true);
					CvNotifications* pNotifications = GetNotifications();
					if (pUnit && pNotifications)
					{
						Localization::String localizedText = Localization::Lookup("TXT_KEY_NOTIFICATION_CONSCRIPTION_SPAWN");
						localizedText << pCity->getNameKey() << pCity->getPopulation() << pUnit->getNameKey();
						Localization::String localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CONSCRIPTION_SPAWN_SUMMARY");
						localizedSummary << getNameKey() << pUnit->getNameKey();
						pNotifications->Add(NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER, localizedText.toUTF8(), localizedSummary.toUTF8(), pUnit->getX(), pUnit->getY(), eBestUnit);
					}
					if (GC.getLogging() && GC.getAILogging())
					{
						CvString strLogString;
						strLogString.Format("Conscripted %s spawned at %s. Population: %d", pUnit->getName().GetCString(), pCity->getName().GetCString(), pCity->getPopulation());
						GetHomelandAI()->LogHomelandMessage(strLogString);
					}
				}
			}
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetExtraMoves() const
{
	return m_iExtraMoves;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeExtraMoves(int iChange)
{
	m_iExtraMoves += iChange;
}
//	--------------------------------------------------------------------------------
bool CvPlayer::IsNoUnhappinessExpansion() const
{
	return GetNoUnhappinessExpansion() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNoUnhappinessExpansion() const
{
	return m_iNoUnhappinessExpansion;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNoUnhappinessExpansion(int iChange)
{
	if(iChange != 0)
	{
		m_iNoUnhappinessExpansion += iChange;
	}
}
//	--------------------------------------------------------------------------------
bool CvPlayer::IsNoUnhappyIsolation() const
{
	return GetNoUnhappyIsolation() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNoUnhappyIsolation() const
{
	return m_iNoUnhappyIsolation;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNoUnhappyIsolation(int iChange)
{
	if(iChange != 0)
	{
		m_iNoUnhappyIsolation += iChange;
	}
}
//	--------------------------------------------------------------------------------
bool CvPlayer::IsDoubleBorderGrowthGA() const
{
	return GetDoubleBorderGrowthGA() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetDoubleBorderGrowthGA() const
{
	return m_iDoubleBorderGrowthGA;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeDoubleBorderGrowthGA(int iChange)
{
	m_iDoubleBorderGrowthGA += iChange;
}
//	--------------------------------------------------------------------------------
bool CvPlayer::IsDoubleBorderGrowthWLTKD() const
{
	return GetDoubleBorderGrowthWLTKD() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetDoubleBorderGrowthWLTKD() const
{
	return m_iDoubleBorderGrowthWLTKD;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeDoubleBorderGrowthWLTKD(int iChange)
{
	m_iDoubleBorderGrowthWLTKD += iChange;
}
//Increased influence from CS quests
//	--------------------------------------------------------------------------------
bool CvPlayer::IsIncreasedQuestInfluence() const
{
	return GetIncreasedQuestInfluence() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetIncreasedQuestInfluence() const
{
	return m_iIncreasedQuestInfluence;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeIncreasedQuestInfluence(int iChange)
{
	if(iChange != 0)
	{
		m_iIncreasedQuestInfluence += iChange;
	}
}
//Citadel Boost
//	--------------------------------------------------------------------------------
bool CvPlayer::IsCultureBombBoost() const
{
	return GetCultureBombBoost() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetCultureBombBoost() const
{
	return m_iCultureBombBoost;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeCultureBombBoost(int iChange)
{
	if(iChange != 0)
	{
		m_iCultureBombBoost += iChange;
	}
}

//Puppet Prod Boost
//	--------------------------------------------------------------------------------
bool CvPlayer::IsPuppetProdMod() const
{
	return GetPuppetProdMod() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetPuppetProdMod() const
{
	return m_iPuppetProdMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changePuppetProdMod(int iChange)
{
	if(iChange != 0)
	{
		m_iPuppetProdMod += iChange;
	}
}

//Occupied Prod Boost
//	--------------------------------------------------------------------------------
bool CvPlayer::IsOccupiedProdMod() const
{
	return GetOccupiedProdMod() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetOccupiedProdMod() const
{
	return m_iOccupiedProdMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeOccupiedProdMod(int iChange)
{
	if(iChange != 0)
	{
		m_iOccupiedProdMod += iChange;
	}
}

//Free Gold from Internal Trade Routes
//	--------------------------------------------------------------------------------
bool CvPlayer::IsGoldInternalTrade() const
{
	return GetGoldInternalTrade() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetGoldInternalTrade() const
{
	return m_iGoldInternalTrade;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGoldInternalTrade(int iChange)
{
	if(iChange != 0)
	{
		m_iGoldInternalTrade += iChange;
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetFreeWCVotes() const
{
	return m_iFreeWCVotes;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeFreeWCVotes(int iChange)
{
	m_iFreeWCVotes += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetInfluenceGPExpend() const
{
	return m_iInfluenceGPExpend;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeInfluenceGPExpend(int iChange)
{
	m_iInfluenceGPExpend += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetFreeTradeRoute() const
{
	return m_iFreeTradeRoute;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeFreeTradeRoute(int iChange)
{
	m_iFreeTradeRoute += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetFreeSpy() const
{
	return m_iFreeSpy;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeFreeSpy(int iChange)
{
	m_iFreeSpy += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetReligionDistance() const
{
	return m_iReligionDistance;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeReligionDistance(int iChange)
{
	m_iReligionDistance += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetPressureMod() const
{
	return m_iPressureMod;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changePressureMod(int iChange)
{
	m_iPressureMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetCityStateCombatModifier() const
{
	return m_iCityStateCombatModifier;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeCityStateCombatModifier(int iChange)
{
	m_iCityStateCombatModifier += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getBuildingClassCultureChange(BuildingClassTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiBuildingClassCulture[eIndex];
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeBuildingClassCultureChange(BuildingClassTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	m_paiBuildingClassCulture[eIndex] = m_paiBuildingClassCulture[eIndex] + iChange;
	CvAssert(getBuildingClassCultureChange(eIndex) >= 0);
}
#endif
#if defined(MOD_BALANCE_CORE_SPIES)
void CvPlayer::changeMaxAirUnits(int iChange)
{
	if (iChange != 0)
	{
		m_iMaxAirUnits += iChange;
	}
}
int CvPlayer::getMaxAirUnits() const
{
	return m_iMaxAirUnits;
}

//	--------------------------------------------------------------------------------
/// Extra yield for a improvement this city is working?
int CvPlayer::GetImprovementExtraYield(ImprovementTypes eImprovement, YieldTypes eYield) const
{
	CvAssertMsg(eImprovement >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eImprovement < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eYield >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiImprovementYieldChange[eImprovement][eYield];
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeImprovementExtraYield(ImprovementTypes eImprovement, YieldTypes eYield, int iChange)
{
	CvAssertMsg(eImprovement >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eImprovement < GC.getNumImprovementInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eYield >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiImprovementYieldChange[eImprovement];
		yields[eYield] = (m_ppiImprovementYieldChange[eImprovement][eYield] + iChange);
		m_ppiImprovementYieldChange[eImprovement] = yields;
		CvAssert(GetImprovementExtraYield(eImprovement, eYield) >= 0);

		updateYield();
	}
}
#endif
#if defined(MOD_BALANCE_CORE_BUILDING_INVESTMENTS)
//	--------------------------------------------------------------------------------
int CvPlayer::GetInvestmentModifier() const
{
	return m_iInvestmentModifier;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeInvestmentModifier(int iChange)
{
	m_iInvestmentModifier += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetMissionInfluenceModifier() const
{
	return m_iMissionInfluenceModifier;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeMissionInfluenceModifier(int iChange)
{
	m_iMissionInfluenceModifier += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetHappinessPerActiveTradeRoute() const
{
	return m_iHappinessPerActiveTradeRoute;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeHappinessPerActiveTradeRoute(int iChange)
{
	m_iHappinessPerActiveTradeRoute += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNeedsModifierFromAirUnits() const
{
	return m_iNeedsModifierFromAirUnits;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeNeedsModifierFromAirUnits(int iChange)
{
	m_iNeedsModifierFromAirUnits += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetFlatDefenseFromAirUnits() const
{
	return m_iFlatDefenseFromAirUnits;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeFlatDefenseFromAirUnits(int iChange)
{
	if (iChange != 0)
	{
		m_iFlatDefenseFromAirUnits += iChange;

		CvCity* pLoopCity;

		int iLoop;
		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			pLoopCity->updateStrengthValue();
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetPuppetYieldPenaltyMod() const
{
	return m_iPuppetYieldPenaltyMod;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changePuppetYieldPenaltyMod(int iChange)
{
	m_iPuppetYieldPenaltyMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetConquestPerEraBuildingProductionMod() const
{
	return m_iConquestPerEraBuildingProductionMod;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeConquestPerEraBuildingProductionMod(int iChange)
{
	m_iConquestPerEraBuildingProductionMod += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetAdmiralLuxuryBonus() const
{
	return m_iAdmiralLuxuryBonus;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeAdmiralLuxuryBonus(int iChange)
{
	m_iAdmiralLuxuryBonus += iChange;
}

#if defined(MOD_POLICIES_UNIT_CLASS_REPLACEMENTS)
//	--------------------------------------------------------------------------------
UnitClassTypes CvPlayer::GetUnitClassReplacement(UnitClassTypes eUnitClass) const
{
	CvAssertMsg((int)eUnitClass >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg((int)eUnitClass < GC.getNumUnitClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	std::map<UnitClassTypes, UnitClassTypes>::const_iterator it = m_piUnitClassReplacements.find(eUnitClass);
	if (it != m_piUnitClassReplacements.end()) // find returns the iterator to map::end if the key i is not present in the map
	{
		if (it->second != eUnitClass) // replacing yourself makes no sense
		{
			return it->second;
		}
	}

	return NO_UNITCLASS;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetUnitClassReplacement(UnitClassTypes eReplacedUnitClass, UnitClassTypes eReplacementUnitClass)
{
	CvAssertMsg((int)eReplacedUnitClass >= 0, "eReplacedUnitClass is expected to be non-negative (invalid Index)");
	CvAssertMsg((int)eReplacedUnitClass < GC.getNumUnitClassInfos(), "eReplacedUnitClass is expected to be within maximum bounds (invalid Index)");

	CvAssertMsg((int)eReplacementUnitClass >= 0, "eReplacementUnitClass is expected to be non-negative (invalid Index)");
	CvAssertMsg((int)eReplacementUnitClass < GC.getNumUnitClassInfos(), "eReplacementUnitClass is expected to be within maximum bounds (invalid Index)");

	if (eReplacedUnitClass != NO_UNITCLASS)
	{
		if (eReplacementUnitClass != NO_UNITCLASS)
		{
			// store into memory
			m_piUnitClassReplacements[eReplacedUnitClass] = eReplacementUnitClass;

			// replace all current units with the replaced class with the replacement class (unless the unit is a unique unit)
			UnitTypes eReplacedClassDefault = (UnitTypes)GC.getUnitClassInfo(eReplacedUnitClass)->getDefaultUnitIndex();
			UnitTypes eReplacementUnit = (UnitTypes)getCivilizationInfo().getCivilizationUnits((int)eReplacementUnitClass);
			int iLoop;

			for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
			{
				if (pLoopUnit->getUnitClassType() == eReplacedUnitClass && pLoopUnit->getUnitType() == eReplacedClassDefault)
				{
#if defined(MOD_BALANCE_CORE)
					CvUnit* pNewUnit = initUnit(eReplacementUnit, pLoopUnit->getX(), pLoopUnit->getY(), NO_UNITAI, REASON_UPGRADE, false, false, 0, 0, NO_CONTRACT, true, pLoopUnit);
#else
					CvUnit* pNewUnit = initUnit(eReplacementUnit, pLoopUnit->getX(), pLoopUnit->getY(), NO_UNITAI, REASON_UPGRADE, false, false);
#endif
					if (pNewUnit != NULL)
					{
						pNewUnit->convert(pLoopUnit, true);
						pNewUnit->setupGraphical();
						pLoopUnit->kill(true);
					}
				}
			}
		}
		else
		{
			// erase from memory
			m_piUnitClassReplacements.erase(eReplacedUnitClass);
		}
	}
}
#endif

//	--------------------------------------------------------------------------------
bool CvPlayer::IsCSResourcesCountMonopolies() const
{
	return (m_iCSResourcesCountMonopolies > 0);
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeCSResourcesCountMonopolies(int iChange)
{
	m_iCSResourcesCountMonopolies += iChange;
}


int CvPlayer::GetScalingNationalPopulationRequrired(BuildingTypes eBuilding) const
{
	if(eBuilding != NO_BUILDING)
	{
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
		if(pkBuildingInfo)
		{
			int iNationalPop = pkBuildingInfo->GetNationalPopulationRequired();
			if(iNationalPop > 0)
			{
				int iScaler = (getNumCities() * pkBuildingInfo->GetNumCityCostMod());
				iNationalPop *= (100 + iScaler);
				iNationalPop /= 100;

				int iModifier = 100 - GetPlayerTraits()->GetNationalPopReqModifier();

				//If OCC... 1/2 the value
				if (GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE))
					iModifier -= 50;

				iNationalPop *= iModifier;
				iNationalPop /= 100;
				
				return max(0, iNationalPop);
			}
		}
	}
	return 0;
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::getCapitalYieldRateModifier(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiCapitalYieldRateModifier[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeCapitalYieldRateModifier(YieldTypes eIndex, int iChange)
{
	CvCity* pCapitalCity;

	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiCapitalYieldRateModifier[eIndex] = m_aiCapitalYieldRateModifier[eIndex] + iChange;

		invalidateYieldRankCache(eIndex);

		pCapitalCity = getCapitalCity();
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getExtraYieldThreshold(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiExtraYieldThreshold[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::updateExtraYieldThreshold(YieldTypes eIndex)
{
	int iBestValue;

	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	iBestValue = GetPlayerTraits()->GetExtraYieldThreshold(eIndex);

	if(getExtraYieldThreshold(eIndex) != iBestValue)
	{
		m_aiExtraYieldThreshold[eIndex] = iBestValue;
		CvAssert(getExtraYieldThreshold(eIndex) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetScience() const
{
	return GetScienceTimes100() / 100;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetScienceTimes100() const
{
	// If we're in anarchy, then no Research is done!
	if(IsAnarchy())
		return 0;

	int iValue = 0;

	// Science from our Cities
	iValue += GetScienceFromCitiesTimes100(false);

	// Science from religion
	iValue += GetYieldPerTurnFromReligion(YIELD_SCIENCE) * 100;

	// Trait bonus which adds Science for trade partners? 
	iValue += GetYieldPerTurnFromTraits(YIELD_SCIENCE) * 100;

	// Science from other players!
	if (isMajorCiv())
		iValue += GetScienceFromOtherPlayersTimes100();

	// Happiness converted to Science? (Policies, etc.)
	iValue += GetScienceFromHappinessTimes100();

	// Research Agreement bonuses
	iValue += GetScienceFromResearchAgreementsTimes100();

	// If we have a negative Treasury + GPT then it gets removed from Science
	iValue += GetScienceFromBudgetDeficitTimes100();

	// We have vassals, we get x% of their science
	iValue += (GetYieldPerTurnFromVassals(YIELD_SCIENCE) * 100);

	if (MOD_BALANCE_CORE_JFD)
	{
		iValue += GetYieldPerTurnFromMinors(YIELD_FAITH) * 100;
	}

	if (MOD_BALANCE_CORE_MINOR_CIV_GIFT)
	{
		iValue += GetSciencePerTurnFromMinorCivs() * 100;
	}

	//Science Funding Rate Boost
	if (MOD_BALANCE_VP && IsLeagueAid())
	{
		int iFreeScience = GetScienceFromCitiesTimes100(false) * GetScienceRateFromLeagueAid();
		iFreeScience /= 100;
		iValue += iFreeScience;
	}

	return max(iValue, 0);
}

//	--------------------------------------------------------------------------------
/// Where is our Science coming from?
int CvPlayer::GetScienceFromCitiesTimes100(bool bIgnoreTrade) const
{
	int iScience = 0;

	const CvCity* pLoopCity;

	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iScience += pLoopCity->getYieldRateTimes100(YIELD_SCIENCE, bIgnoreTrade);
	}

	return iScience;
}

//	--------------------------------------------------------------------------------
/// Where is our Science coming from?
int CvPlayer::GetScienceFromOtherPlayersTimes100() const
{
	int iScience = 0;

	PlayerTypes ePlayer;
	int iScienceFromPlayer;
	for(int iPlayerLoop = MAX_MAJOR_CIVS; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		ePlayer = (PlayerTypes) iPlayerLoop;

		iScienceFromPlayer = 0;

		if(IsGetsScienceFromPlayer(ePlayer))
		{
			iScienceFromPlayer = GET_PLAYER(ePlayer).GetMinorCivAI()->GetScienceFriendshipBonusTimes100();

			iScience += iScienceFromPlayer;
		}
	}
	return iScience;
}

//	--------------------------------------------------------------------------------
/// Where is our Science coming from?
int CvPlayer::GetScienceFromHappinessTimes100() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS))
	{
		return 0;
	}
	if (MOD_BALANCE_CORE_HAPPINESS)
		return 0;

	int iScience = 0;

	if(getHappinessToScience() != 0)
	{
		if(GetExcessHappiness() >= 0)
		{
			int iFreeScience = GetScienceFromCitiesTimes100(false) * getHappinessToScience();
			iFreeScience /= 100;

			iScience += iFreeScience;
		}
	}

	return iScience;
}

//	--------------------------------------------------------------------------------
/// Where is our Science coming from?
int CvPlayer::GetScienceFromResearchAgreementsTimes100() const
{
	int iScience = GetScienceFromCitiesTimes100(false);

	int iResearchAgreementBonus = /*0*/ GD_INT_GET(RESEARCH_AGREEMENT_MOD) * GET_TEAM(getTeam()).GetTotalNumResearchAgreements(); // RAs currently do not have this effect
	iScience *= iResearchAgreementBonus;	// Apply to the % to the current value
	iScience /= 100;

	return iScience;
}

//	--------------------------------------------------------------------------------
/// Where is our Science coming from?
int CvPlayer::GetScienceFromBudgetDeficitTimes100() const
{
	int iScience = 0;
	int iGoldPerTurn = calculateGoldRateTimes100();
	if(GetTreasury()->GetGoldTimes100() + iGoldPerTurn < 0)
	{
		iScience += (GetTreasury()->GetGoldTimes100() + iGoldPerTurn);
	}

	return iScience;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsGetsScienceFromPlayer(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= MAX_MAJOR_CIVS, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");

	// Might have global modifier
	if(IsMinorScienceAllies() && GET_PLAYER(ePlayer).GetMinorCivAI()->IsAllies(GetID()))
	{
		return true;
	}

	return m_pabGetsScienceFromPlayer[ePlayer];
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetGetsScienceFromPlayer(PlayerTypes ePlayer, bool bNewValue)
{
	CvAssertMsg(ePlayer >= MAX_MAJOR_CIVS, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(bNewValue != m_pabGetsScienceFromPlayer[ePlayer])
	{
		m_pabGetsScienceFromPlayer[ePlayer] = bNewValue;
	}
}

//	--------------------------------------------------------------------------------
/// Player spending too much cash?
void CvPlayer::DoBankruptcy()
{
	if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_PlayerCanDisband, GetID()) == GAMEEVENTRETURN_FALSE)
		return;

	if (!isMajorCiv())
		return;

	// If the player has more units than cities, start disbanding things
	if (getNumMilitaryUnits() > 3 + GetCurrentEra() + getNumCities())
	{
		int iLandScore = MAX_INT;
		int iNavalScore = MAX_INT;
		CvUnit* pLandUnit = GetMilitaryAI()->FindUnitToScrap(DOMAIN_LAND, false, iLandScore, false, true);
		CvUnit* pNavalUnit = GetMilitaryAI()->FindUnitToScrap(DOMAIN_SEA, false, iNavalScore, false, true);

		//keep the more useful one
		CvUnit *pScrapUnit = (iLandScore < iNavalScore) ? pLandUnit : pNavalUnit;

		//unless we need one kind much more urgently
		if (pLandUnit && GetMilitaryAI()->GetLandDefenseState() < GetMilitaryAI()->GetNavalDefenseState())
			pScrapUnit = pLandUnit;
		else if (pNavalUnit && GetMilitaryAI()->GetLandDefenseState() > GetMilitaryAI()->GetNavalDefenseState())
			pScrapUnit = pNavalUnit;

		//AI players try to gift their units away
		if (pScrapUnit && !isHuman())
		{
			PlayerTypes eMinor = GetBestGiftTarget(pScrapUnit->getDomainType());
			if (eMinor != NO_PLAYER)
			{
				GetMilitaryAI()->LogDeficitScrapUnit(pScrapUnit,true);
				GET_PLAYER(eMinor).AddIncomingUnit(GetID(), pScrapUnit);
				pScrapUnit = NULL;
			}
		}

		//get rid of it
		if (pScrapUnit)
		{
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				Localization::String locString = Localization::Lookup("TXT_KEY_NTFN_UNIT_DISBANDED");
				Localization::String locSummary = Localization::Lookup("TXT_KEY_NTFN_UNIT_DISBANDED_S");
				pNotifications->Add(NOTIFICATION_UNIT_DIED, locString.toUTF8(), locSummary.toUTF8(), pScrapUnit->getX(), pScrapUnit->getY(), pScrapUnit->getUnitType(), GetID());
			}

			GetMilitaryAI()->LogDeficitScrapUnit(pScrapUnit,false);
			pScrapUnit->scrap();
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getSpecialistExtraYield(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiSpecialistExtraYield[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeSpecialistExtraYield(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		// Have to handle Specialists yield update manually here because the "updateYield()" below only accounts for land Yield!

		CvCity* pLoopCity;
		int iLoop;
		int iNumTotalSpecialists = 0;

		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			for(int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
			{
				iNumTotalSpecialists = pLoopCity->GetCityCitizens()->GetSpecialistCount((SpecialistTypes) iSpecialistLoop);

				for(int iTempLoop = 0; iTempLoop < iNumTotalSpecialists; iTempLoop++)
				{
					pLoopCity->processSpecialist((SpecialistTypes) iSpecialistLoop, -1, CvCity::YIELD_UPDATE_GLOBAL);
				}
			}
		}

		m_aiSpecialistExtraYield[eIndex ] = m_aiSpecialistExtraYield[eIndex] + iChange;
		CvAssert(getSpecialistExtraYield(eIndex) >= 0);

		updateYield();

		// Reprocess Specialist AFTER yield change
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			for(int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
			{
				iNumTotalSpecialists = pLoopCity->GetCityCitizens()->GetSpecialistCount((SpecialistTypes) iSpecialistLoop);

				for(int iTempLoop = 0; iTempLoop < iNumTotalSpecialists; iTempLoop++)
				{
					pLoopCity->processSpecialist((SpecialistTypes) iSpecialistLoop, 1, CvCity::YIELD_UPDATE_GLOBAL);
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
// WAR/PEACE COUNTERS

int CvPlayer::GetPlayerNumTurnsAtPeace(PlayerTypes ePlayer) const
{
	return m_aiPlayerNumTurnsAtPeace[ePlayer];
}

void CvPlayer::SetPlayerNumTurnsAtPeace(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_PLAYERS) return;
	m_aiPlayerNumTurnsAtPeace[ePlayer] = iValue;
}

void CvPlayer::ChangePlayerNumTurnsAtPeace(PlayerTypes ePlayer, int iChange)
{
	SetPlayerNumTurnsAtPeace(ePlayer, GetPlayerNumTurnsAtPeace(ePlayer) + iChange);
}

int CvPlayer::GetPlayerNumTurnsAtWar(PlayerTypes ePlayer) const
{
	return m_aiPlayerNumTurnsAtWar[ePlayer];
}

void CvPlayer::SetPlayerNumTurnsAtWar(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_PLAYERS) return;
	m_aiPlayerNumTurnsAtWar[ePlayer] = iValue;
}

void CvPlayer::ChangePlayerNumTurnsAtWar(PlayerTypes ePlayer, int iChange)
{
	SetPlayerNumTurnsAtWar(ePlayer, GetPlayerNumTurnsAtWar(ePlayer) + iChange);
}

int CvPlayer::GetTeamNumTurnsAtWar(TeamTypes eTeam) const
{
	if (eTeam < 0 || eTeam >= MAX_CIV_TEAMS) return 0;

	int iMaxTurns = 0;

	vector<PlayerTypes> vTeamPlayers = GET_TEAM(eTeam).getPlayers();
	for (size_t i = 0; i < vTeamPlayers.size(); i++)
	{
		PlayerTypes ePlayer = (PlayerTypes) vTeamPlayers[i];
		if (GET_PLAYER(ePlayer).isAlive() && GetPlayerNumTurnsAtWar(ePlayer) > iMaxTurns)
		{
			iMaxTurns = GetPlayerNumTurnsAtWar(ePlayer);
		}
	}
	
	return iMaxTurns;
}

int CvPlayer::GetPlayerNumTurnsSinceCityCapture(PlayerTypes ePlayer) const
{
	return m_aiPlayerNumTurnsSinceCityCapture[ePlayer];
}

void CvPlayer::SetPlayerNumTurnsSinceCityCapture(PlayerTypes ePlayer, int iValue)
{
	if (ePlayer < 0 || ePlayer >= MAX_PLAYERS) return;
	m_aiPlayerNumTurnsSinceCityCapture[ePlayer] = iValue;
}

void CvPlayer::ChangePlayerNumTurnsSinceCityCapture(PlayerTypes ePlayer, int iChange)
{
	SetPlayerNumTurnsSinceCityCapture(ePlayer, GetPlayerNumTurnsSinceCityCapture(ePlayer) + iChange);
}

void CvPlayer::DoUpdateWarPeaceTurnCounters()
{
	for (int iI = 0; iI < MAX_PLAYERS; iI++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iI;

		if (GET_PLAYER(ePlayer).isAlive() && getTeam() != GET_PLAYER(ePlayer).getTeam())
		{
			if (IsAtWarWith(ePlayer))
			{
				ChangePlayerNumTurnsAtWar(ePlayer, 1);
				ChangePlayerNumTurnsSinceCityCapture(ePlayer, 1);
				SetPlayerNumTurnsAtPeace(ePlayer, 0);
			}
			else
			{
				ChangePlayerNumTurnsAtPeace(ePlayer, 1);
				SetPlayerNumTurnsAtWar(ePlayer, 0);
				SetPlayerNumTurnsSinceCityCapture(ePlayer, 0);
			}
		}
	}
}

void CvPlayer::ResetWarPeaceTurnCounters() // called when a player is killed
{
	for (int iI = 0; iI < MAX_PLAYERS; iI++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iI;

		SetPlayerNumTurnsAtWar(ePlayer, 0);
		SetPlayerNumTurnsSinceCityCapture(ePlayer, 0);

		GET_PLAYER(ePlayer).SetPlayerNumTurnsAtWar(ePlayer, 0);
		GET_PLAYER(ePlayer).SetPlayerNumTurnsSinceCityCapture(ePlayer, 0);
	}
}

//	--------------------------------------------------------------------------------

/// What is the value of stuff (Units & Cities) lost in a war against a particular player?
int CvPlayer::GetWarValueLost(PlayerTypes ePlayer) const
{
	if (isBarbarian()) return 0;
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return 0;
	return m_aiWarValueLost[ePlayer];
}

void CvPlayer::SetWarValueLost(PlayerTypes ePlayer, int iValue)
{
	if (isBarbarian()) return;
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return;
	m_aiWarValueLost[ePlayer] = max(iValue, 0);
}

void CvPlayer::ChangeWarValueLost(PlayerTypes ePlayer, int iChange)
{
	SetWarValueLost(ePlayer, GetWarValueLost(ePlayer) + iChange);

	if (iChange > 0 && isMajorCiv() && GET_PLAYER(ePlayer).isMajorCiv())
	{
		// Loop through all the other major civs that we've met
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			if (GetDiplomacyAI()->IsPlayerValid(eLoopPlayer) && GET_PLAYER(eLoopPlayer).isMajorCiv())
			{
				// Are they at war with me too? Then they're happy that this player damaged us!
				if (IsAtWarWith(eLoopPlayer))
				{
					// How much they're happy about it depends on how strong we are compared to them.
					switch (GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(GetID()))
					{
					case STRENGTH_IMMENSE:
						iChange *= 300;
						break;
					case STRENGTH_POWERFUL:
						iChange *= 200;
						break;
					case STRENGTH_STRONG:
						iChange *= 150;
						break;
					case STRENGTH_AVERAGE:
						iChange *= 100;
						break;
					case STRENGTH_POOR:
						iChange *= 75;
						break;
					case STRENGTH_WEAK:
						iChange *= 50;
						break;
					case STRENGTH_PATHETIC:
						iChange *= 25;
						break;
					default:
						iChange *= 100;
						break;
					}

					GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->ChangeCommonFoeValue(ePlayer, iChange/100);
				}
			}
		}
	}
}

/// Every turn we're at peace war damage goes down a bit
void CvPlayer::DoWarValueLostDecay()
{
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (!GET_PLAYER(eLoopPlayer).isAlive())
			continue;

		int iValue = GetWarValueLost(eLoopPlayer);

		// War damage we've suffered goes down by 1/50th every turn while at war (slower, but necessary to bring chance of white peace)
		if (IsAtWarWith(eLoopPlayer))
		{
			if (iValue > 0)
			{
				int iChange = max((iValue/50), 1); // Must go down by at least 1
				ChangeWarValueLost(eLoopPlayer, -iChange);
			}
		}
		// Goes down by 1/10th every turn while at peace
		else
		{
			if (iValue > 0)
			{
				int iChange = max((iValue/10), 1); // Must go down by at least 1
				ChangeWarValueLost(eLoopPlayer, -iChange);
			}
		}
	}
}

/// Updates how much damage we have taken in wars against all players
void CvPlayer::DoUpdateWarDamage()
{
	// Calculate the value of what we have currently - this is invariant so we will just do it once
	int iCurrentValue = 0;
	int iTypicalLandPower = GetMilitaryAI()->GetPowerOfStrongestBuildableUnit(DOMAIN_LAND);
	int iTypicalNavalPower = GetMilitaryAI()->GetPowerOfStrongestBuildableUnit(DOMAIN_SEA);
	int iTypicalAirPower = GetMilitaryAI()->GetPowerOfStrongestBuildableUnit(DOMAIN_AIR);
	int iValueLoop;

	// City value
	for (CvCity* pLoopCity = firstCity(&iValueLoop); pLoopCity != NULL; pLoopCity = nextCity(&iValueLoop))
	{
		int iCityValue = /*175*/ GD_INT_GET(WAR_DAMAGE_LEVEL_CITY_WEIGHT);
		iCityValue += (pLoopCity->getPopulation() * /*150*/ GD_INT_GET(WAR_DAMAGE_LEVEL_INVOLVED_CITY_POP_MULTIPLIER));
		iCityValue += (pLoopCity->getNumWorldWonders() * /*200*/ GD_INT_GET(WAR_DAMAGE_LEVEL_WORLD_WONDER_MULTIPLIER));

		// Multipliers
		// Our original capital!
		if (pLoopCity->IsOriginalCapitalForPlayer(GetID()))
		{
			iCityValue *= 200;
			iCityValue /= 100;
		}
		// Another major's original capital, or our Holy City
		else if (pLoopCity->IsOriginalMajorCapital() || (isMajorCiv() && pLoopCity->GetCityReligions()->IsHolyCityForReligion(GetReligions()->GetOriginalReligionCreatedByPlayer())))
		{
			iCityValue *= 150;
			iCityValue /= 100;
		}
		// A City-State's capital
		else if (pLoopCity->IsOriginalMinorCapital())
		{
			iCityValue *= 115;
			iCityValue /= 100;
		}

		iCurrentValue += iCityValue;
	}

	// Unit value
	for (CvUnit* pLoopUnit = firstUnit(&iValueLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iValueLoop))
	{
		CvUnitEntry* pkUnitInfo = GC.getUnitInfo(pLoopUnit->getUnitType());
		if (pkUnitInfo)
		{
			int iUnitValue = pkUnitInfo->GetPower() * 100;

			if (iUnitValue > 0)
			{
				// Compare to strongest unit we can build in that domain, for an apples to apples comparison
				// Best unit that can be currently built in a domain is given a value of 100
				DomainTypes eDomain = (DomainTypes) pkUnitInfo->GetDomainType();

				if (eDomain == DOMAIN_AIR)
				{
					if (iTypicalAirPower > 0)
					{
						iUnitValue /= iTypicalAirPower;
					}
					else
					{
						iUnitValue = /*100*/ GD_INT_GET(DEFAULT_WAR_VALUE_FOR_UNIT);
					}
				}
				else if (eDomain == DOMAIN_SEA)
				{
					if (iTypicalNavalPower > 0)
					{
						iUnitValue /= iTypicalNavalPower;
					}
					else
					{
						iUnitValue = /*100*/ GD_INT_GET(DEFAULT_WAR_VALUE_FOR_UNIT);
					}
				}
				else
				{
					if (iTypicalLandPower > 0)
					{
						iUnitValue /= iTypicalLandPower;
					}
					else
					{
						iUnitValue = /*100*/ GD_INT_GET(DEFAULT_WAR_VALUE_FOR_UNIT);
					}
				}

				iCurrentValue += iUnitValue;
			}
		}
	}

	// Loop through all (known) Players
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		TeamTypes eLoopTeam = GET_PLAYER(eLoopPlayer).getTeam();

		if (!GET_PLAYER(eLoopPlayer).isAlive())
			continue;

		if (eLoopTeam == getTeam() || !GET_TEAM(getTeam()).isHasMet(eLoopTeam))
			continue;

		int iWarValueLost = GetWarValueLost(eLoopPlayer);
		int iValueLostRatio = 0;

		if (iWarValueLost > 0)
		{
			if (iCurrentValue > 0)
			{
				iValueLostRatio = (iWarValueLost * 100) / iCurrentValue;
			}
			else
			{
				iValueLostRatio = iWarValueLost;
			}
		}

		SetWarDamageValue(eLoopPlayer, iValueLostRatio);
	}
}

//	--------------------------------------------------------------------------------

/// How much damage have we taken in a war against a particular player?
int CvPlayer::GetWarDamageValue(PlayerTypes ePlayer) const
{
	if (isBarbarian()) return 0;
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return 0;
	return m_aiWarDamageValue[ePlayer];
}

void CvPlayer::SetWarDamageValue(PlayerTypes ePlayer, int iValue)
{
	if (isBarbarian()) return;
	if (ePlayer < 0 || ePlayer >= MAX_CIV_PLAYERS) return;
	m_aiWarDamageValue[ePlayer] = max(iValue, 0);
}

//	--------------------------------------------------------------------------------
/// Returns how "close" we are to another player (useful for diplomacy, war planning, etc.)
PlayerProximityTypes CvPlayer::GetProximityToPlayer(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePlayer < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
	return (PlayerProximityTypes) m_aiProximityToPlayer[ePlayer];
}

//	--------------------------------------------------------------------------------
/// Sets how "close" we are to another player (useful for diplomacy, war planning, etc.)
void CvPlayer::SetProximityToPlayer(PlayerTypes ePlayer, PlayerProximityTypes eProximity)
{
	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePlayer < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");

	CvAssertMsg(GetID() != ePlayer, "Trying to calculate proximity to oneself. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	CvAssertMsg(eProximity >= NO_PLAYER_PROXIMITY, "eIndex is expected to be non-negative (invalid Index)");	// NO_PLAYER_PROXIMITY is valid because some players may have no Cities (e.g. on the first turn)
	CvAssertMsg(eProximity < NUM_PLAYER_PROXIMITIES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if((GC.getLogging() && GC.getAILogging()))
	{
		if(eProximity != m_aiProximityToPlayer[ePlayer])
		{
			// Open the log file
			CvString strFileName = "PlayerProximityLog.csv";
			FILogFile* pLog;
			pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
			CvString strLog, strTemp;

			CvString strPlayerName;
			strPlayerName = getCivilizationShortDescription();
			strLog += strPlayerName;
			strLog += ",";

			strTemp.Format("%d,", GC.getGame().getGameTurn()); // turn
			strLog += strTemp;
			CvString strOtherPlayerName;
			strOtherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
			strLog += strOtherPlayerName;
			strLog += ",";

			switch(m_aiProximityToPlayer[ePlayer])
			{
			case NO_PLAYER_PROXIMITY:
				strLog += "No player proximity,";
				break;
			case PLAYER_PROXIMITY_NEIGHBORS:
				strLog += "Neighbors,";
				break;
			case PLAYER_PROXIMITY_CLOSE:
				strLog += "Close,";
				break;
			case PLAYER_PROXIMITY_FAR:
				strLog += "Far,";
				break;
			case PLAYER_PROXIMITY_DISTANT:
				strLog += "Distant,";
				break;
			}

			strLog += "-->,";

			switch(eProximity)
			{
			case NO_PLAYER_PROXIMITY:
				strLog += "No player proximity,";
				break;
			case PLAYER_PROXIMITY_NEIGHBORS:
				strLog += "Neighbors,";
				break;
			case PLAYER_PROXIMITY_CLOSE:
				strLog += "Close,";
				break;
			case PLAYER_PROXIMITY_FAR:
				strLog += "Far,";
				break;
			case PLAYER_PROXIMITY_DISTANT:
				strLog += "Distant,";
				break;
			}

			pLog->Msg(strLog);
		}
	}

	m_aiProximityToPlayer[ePlayer] = eProximity;
}

//	--------------------------------------------------------------------------------
/// Returns plot indices!
pair<int,int> CvPlayer::GetClosestCityPair(PlayerTypes ePlayer)
{
	int iCityLoop = 0;
	int iMinDistance = INT_MAX;
	pair<int, int> result(-1,-1);
	for (CvCity* pOtherCity = GET_PLAYER(ePlayer).firstCity(&iCityLoop); pOtherCity != NULL; pOtherCity = GET_PLAYER(ePlayer).nextCity(&iCityLoop))
	{
		CvCity* pOurClosestCity = GetClosestCityByPlots(pOtherCity->plot()); //use estimated turns here?
		if (!pOurClosestCity)
			continue;

		int iDistance = plotDistance(*pOtherCity->plot(), *pOurClosestCity->plot());
		if (iDistance < iMinDistance)
		{
			iMinDistance = iDistance;
			result = make_pair( pOurClosestCity->plot()->GetPlotIndex(),pOtherCity->plot()->GetPlotIndex() );
		}
	}

	return result;
}

/// Figure out how "close" we are to another player (useful for diplomacy, war planning, etc.)
void CvPlayer::DoUpdateProximityToPlayers()
{
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (!isAlive() || !GET_PLAYER(eLoopPlayer).isAlive())
		{
			SetProximityToPlayer(eLoopPlayer, NO_PLAYER_PROXIMITY);
			GET_PLAYER(eLoopPlayer).SetProximityToPlayer(m_eID, NO_PLAYER_PROXIMITY);
			continue;
		}

		//default
		PlayerProximityTypes eProximity = PLAYER_PROXIMITY_DISTANT;

		//the current pair for comparison
		pair<int, int> closestCities = GetClosestCityPair(eLoopPlayer);
		if (closestCities.first < 0 || closestCities.second < 0)
		{
			SetProximityToPlayer(eLoopPlayer, eProximity);
			GET_PLAYER(eLoopPlayer).SetProximityToPlayer(m_eID, eProximity);
			continue;
		}

		// Closest Cities must be within a certain range
		int iDistance = plotDistance(closestCities.first,closestCities.second);
		if (iDistance < /*8*/ GD_INT_GET(PROXIMITY_NEIGHBORS_CLOSEST_CITY_REQUIREMENT))
		{
			eProximity = PLAYER_PROXIMITY_NEIGHBORS;
		}
		// If our closest Cities are pretty near one another and our average is less than the max then we can be considered CLOSE
		else if (iDistance < /*16*/ GD_INT_GET(PROXIMITY_CLOSE_CLOSEST_CITY_POSSIBILITY))
		{
			eProximity = PLAYER_PROXIMITY_CLOSE;
		}
		// If our closest Cities are far away from one another and our average is less than the max then we can be considered FAR
		else if (iDistance < /*24*/ GD_INT_GET(PROXIMITY_FAR_DISTANCE_MAX))
		{
			eProximity = PLAYER_PROXIMITY_FAR;
		}

		//can't embark? non-continent members are distant.
		if (!GET_PLAYER(eLoopPlayer).CanEmbark())
		{
			CvPlot* pA = GC.getMap().plotByIndex(closestCities.first);
			CvPlot* pB = GC.getMap().plotByIndex(closestCities.second);
			if (pA->getLandmass() != pB->getLandmass())
			{
				GET_PLAYER(eLoopPlayer).SetProximityToPlayer(m_eID, PLAYER_PROXIMITY_DISTANT);
			}
			else
				GET_PLAYER(eLoopPlayer).SetProximityToPlayer(m_eID, eProximity);
		}
		//can embark, but not oceanic? non-continent members are one pip less.
		else if (!GET_PLAYER(eLoopPlayer).CanCrossOcean())
		{
			CvPlot* pA = GC.getMap().plotByIndex(closestCities.first);
			CvPlot* pB = GC.getMap().plotByIndex(closestCities.second);
			if (pA->getLandmass() != pB->getLandmass())
			{
				switch (eProximity)
				{
				case PLAYER_PROXIMITY_NEIGHBORS:
					GET_PLAYER(eLoopPlayer).SetProximityToPlayer(m_eID, PLAYER_PROXIMITY_CLOSE);
					break;
				case PLAYER_PROXIMITY_CLOSE:
					GET_PLAYER(eLoopPlayer).SetProximityToPlayer(m_eID, PLAYER_PROXIMITY_FAR);
					break;
				default:
					GET_PLAYER(eLoopPlayer).SetProximityToPlayer(m_eID, PLAYER_PROXIMITY_DISTANT);
					break;
				}
			}
			else
				GET_PLAYER(eLoopPlayer).SetProximityToPlayer(m_eID, eProximity);
		}
		else
		{
			GET_PLAYER(eLoopPlayer).SetProximityToPlayer(m_eID, eProximity);
		}

		//can't embark? non-continent members are distant.
		if (!CanEmbark())
		{
			CvPlot* pA = GC.getMap().plotByIndex(closestCities.first);
			CvPlot* pB = GC.getMap().plotByIndex(closestCities.second);
			if (pA->getLandmass() != pB->getLandmass())
			{
				eProximity = PLAYER_PROXIMITY_DISTANT;
			}
		}
		//can embark, but not oceanic? non-continent members are one pip less.
		else if (!CanCrossOcean())
		{
			CvPlot* pA = GC.getMap().plotByIndex(closestCities.first);
			CvPlot* pB = GC.getMap().plotByIndex(closestCities.second);
			if (pA->getLandmass() != pB->getLandmass())
			{
				if (eProximity == PLAYER_PROXIMITY_FAR)
					eProximity = PLAYER_PROXIMITY_DISTANT;
				else if (eProximity == PLAYER_PROXIMITY_CLOSE)
					eProximity = PLAYER_PROXIMITY_FAR;
				else if (eProximity == PLAYER_PROXIMITY_NEIGHBORS)
					eProximity = PLAYER_PROXIMITY_CLOSE;
			}
		}

		SetProximityToPlayer(eLoopPlayer, eProximity);
	}
}

//	--------------------------------------------------------------------------------
/// Update the beakers accumulated during the term of RAs
void CvPlayer::UpdateResearchAgreements(int iValue)
{
	PlayerTypes ePlayerLoop;
	TeamTypes eTeamLoop;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		ePlayerLoop = (PlayerTypes) iPlayerLoop;
		eTeamLoop = GET_PLAYER(ePlayerLoop).getTeam();
		if(ePlayerLoop == GetID())
			continue;
		if(eTeamLoop == getTeam())
			continue;

		if(GET_TEAM(getTeam()).IsHasResearchAgreement(eTeamLoop))
		{
			// Note that this increases the counter for all players on the other team,
			// even though the RA was only made with one of them.  This is because
			// RAs, though made with players, are restricted and tracked by 1 per team.
			// This must change if future implementations allow for multiple RAs to be
			// made with a particular team.
			ChangeResearchAgreementCounter(ePlayerLoop, iValue);
		}
		else if(GetResearchAgreementCounter(ePlayerLoop) != 0)
		{
			SetResearchAgreementCounter(ePlayerLoop, 0);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Get the beakers accumulated during the RA with a player
int CvPlayer::GetResearchAgreementCounter(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePlayer < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiResearchAgreementCounter[ePlayer];
}

//	--------------------------------------------------------------------------------
/// Set the beakers accumulated during the RA with a player
void CvPlayer::SetResearchAgreementCounter(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePlayer < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");

	CvAssertMsg(GetID() != ePlayer, "Trying to make a RA Agreement with oneself. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_aiResearchAgreementCounter[ePlayer] = iValue;
}

//	--------------------------------------------------------------------------------
/// Change the beakers accumulated during the RA with a player
void CvPlayer::ChangeResearchAgreementCounter(PlayerTypes ePlayer, int iChange)
{
	SetResearchAgreementCounter(ePlayer, GetResearchAgreementCounter(ePlayer) + iChange);
}

//	--------------------------------------------------------------------------------
/// Someone sent us a present!
void CvPlayer::DoCivilianReturnLogic(bool bReturn, PlayerTypes eToPlayer, int iUnitID)
{
	CvUnit* pUnit = getUnit(iUnitID);
	if(!pUnit)
	{
		return;
	}

	CvPlot* pPlot = pUnit->plot();
	if(!pPlot)
	{
		return;
	}

	// Kill any units this guy is transporting
	IDInfo* pUnitNode = pPlot->headUnitNode();
	while(pUnitNode != NULL)
	{
		CvUnit* pLoopUnit = ::GetPlayerUnit(*pUnitNode);
		pUnitNode = pPlot->nextUnitNode(pUnitNode);

		if(NULL != pLoopUnit && pLoopUnit->getTransportUnit() == pUnit)
			pLoopUnit->kill(true);
	}

	// What are the details for the new unit?
	UnitTypes eNewUnitType = pUnit->getUnitType();

	if(!bReturn)
		eNewUnitType = pUnit->getCaptureUnitType(getCivilizationType());

	int iX = pUnit->getX();
	int iY = pUnit->getY();

	// Returns to the previous owner
	if(bReturn)
	{
		pUnit->kill(true);
		CvUnit* pNewUnit = GET_PLAYER(eToPlayer).initUnit(eNewUnitType, iX, iY);
		CvAssert(pNewUnit != NULL);
		if (pNewUnit)
		{
			if (!pNewUnit->jumpToNearestValidPlot())
				pNewUnit->kill(false);	// Could not find a spot!
		}

		// Returned to a city-state
		if(GET_PLAYER(eToPlayer).isMinorCiv())
		{
			int iInfluence = /*45 in CP, 50 in VP*/ GD_INT_GET(RETURN_CIVILIAN_FRIENDSHIP);

			if (MOD_BALANCE_CORE_MINORS)
			{
				int iEra = GetCurrentEra();
				if (iEra <= 0)
					iEra = 1;

				iInfluence *= iEra;
			}

			GET_PLAYER(eToPlayer).GetMinorCivAI()->ChangeFriendshipWithMajor(GetID(), iInfluence);
		}
		// Returned to major power
		else if(!GET_PLAYER(eToPlayer).isHuman())
		{
			// Additional diplo bonus for returning civilians in the early game, especially Settlers
			int iTheirEra = GET_PLAYER(eToPlayer).GetCurrentEra();
			if (iTheirEra <= 1)
			{
				if (pNewUnit->isFound())
				{
					if (iTheirEra == 0)
					{
						GET_PLAYER(eToPlayer).GetDiplomacyAI()->ChangeNumCiviliansReturnedToMe(GetID(), 5);
					}
					else if (iTheirEra == 1)
					{
						GET_PLAYER(eToPlayer).GetDiplomacyAI()->ChangeNumCiviliansReturnedToMe(GetID(), 4);
					}
				}
				else
				{
					if (iTheirEra == 0)
					{
						GET_PLAYER(eToPlayer).GetDiplomacyAI()->ChangeNumCiviliansReturnedToMe(GetID(), 3);
					}
					else if (iTheirEra == 1)
					{
						GET_PLAYER(eToPlayer).GetDiplomacyAI()->ChangeNumCiviliansReturnedToMe(GetID(), 2);
					}
				}
			}
			else
			{
				GET_PLAYER(eToPlayer).GetDiplomacyAI()->ChangeNumCiviliansReturnedToMe(GetID(), 1);
			}
		}
#if defined(MOD_BALANCE_CORE)
		else if(GET_PLAYER(eToPlayer).isHuman() && pNewUnit)
		{
			CvNotifications* pNotification = GET_PLAYER(eToPlayer).GetNotifications();
			if(pNotification)
			{
				Localization::String localizedText = Localization::Lookup("TXT_KEY_NOTIFICATION_UNIT_RETURNED_AI");
				localizedText << getNameKey() << pNewUnit->getUnitInfo().GetTextKey();
				Localization::String localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_UNIT_RETURNED_AI_SUMMARY");
				localizedSummary << getNameKey() << pNewUnit->getUnitInfo().GetTextKey();
				pNotification->Add(NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER, localizedText.toUTF8(), localizedSummary.toUTF8(), pNewUnit->getX(), pNewUnit->getY(), pNewUnit->getUnitType());
			}
		}
#endif
	}
	// Kept for oneself
	else
	{
		// Make a new unit because the kind we should capture doesn't match (e.g. Settler to Worker)
		if(eNewUnitType != pUnit->getUnitType())
		{
#if defined(MOD_GLOBAL_GRATEFUL_SETTLERS)
			// In OCC games, all captured settlers are converted
			if ((pUnit->isFound() || pUnit->IsFoundAbroad()) && MOD_GLOBAL_GRATEFUL_SETTLERS && !(GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && isHuman())) {
				int iDefectProb = gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_PERCENT", 20);
				int iPercent = 0;

				// Approach is very important
				switch (GetDiplomacyAI()->GetCivApproach(eToPlayer)) 
				{
					case CIV_APPROACH_WAR:
						iPercent = iDefectProb * gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_WAR_MULTIPLIER", 0) / gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DIVISOR", 8);
						break;
					case CIV_APPROACH_HOSTILE:
						iPercent = iDefectProb * gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_HOSTILE_MULTIPLIER", 2) / gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DIVISOR", 8);
						break;
					case CIV_APPROACH_GUARDED:
						iPercent = iDefectProb * gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_GUARDED_MULTIPLIER", 4) / gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DIVISOR", 8);
						break;
					case CIV_APPROACH_DECEPTIVE:
						iPercent = iDefectProb * gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DECEPTIVE_MULTIPLIER", 4) / gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DIVISOR", 8);
						break;
					case CIV_APPROACH_AFRAID:
						iPercent = iDefectProb * gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_AFRAID_MULTIPLIER", 4) / gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DIVISOR", 8);
						break;
					case CIV_APPROACH_NEUTRAL:
						iPercent = iDefectProb * gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_NEUTRAL_MULTIPLIER", 6) / gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DIVISOR", 8);
						break;
					case CIV_APPROACH_FRIENDLY:
						iPercent = iDefectProb * gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_FRIENDLY_MULTIPLIER", 10) / gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DIVISOR", 8);
						break;
					default:
						break;
				}

				// Opinion also matters
				switch (GetDiplomacyAI()->GetCivOpinion(eToPlayer)) 
				{
				case CIV_OPINION_ALLY:
					iPercent += iDefectProb * 5 / 4;
					break;
				case CIV_OPINION_FRIEND:
					iPercent += iDefectProb * 1;
					break;
				case CIV_OPINION_FAVORABLE:
					iPercent += iDefectProb * 3 / 4;
					break;
				case CIV_OPINION_NEUTRAL:
					iPercent += iDefectProb * 1 / 2;
					break;
				case CIV_OPINION_COMPETITOR:
					iPercent += iDefectProb * 0;
					break;
				case CIV_OPINION_ENEMY:
					iPercent += iDefectProb * -1;
					break;
				case CIV_OPINION_UNFORGIVABLE:
					iPercent += iDefectProb * -1;
					break;
				default:
					break;
				}

				// Limit the outcome
				iPercent = std::min(50, std::max(5, iPercent));

				// Our masters sent us into a war-zone, we'll stick where we are!
				if (GetDiplomacyAI()->GetNumOurEnemiesPlayerAtWarWith(eToPlayer) > 0) {
					iPercent *= 2;
				}

				// If they will found the second city (ie kudos) multiply by 1.5
				if (getNumCities() == 1) {
					iPercent *= 3;
					iPercent /= 2;
				}

#if defined(MOD_GLOBAL_RELIGIOUS_SETTLERS)
				if (MOD_GLOBAL_RELIGIOUS_SETTLERS)
				{
					ReligionTypes eReligion = pUnit->GetReligionData()->GetReligion();
					if (eReligion > RELIGION_PANTHEON)
					{
						const CvReligion* pkReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, NO_PLAYER);
						if (pkReligion)
						{
							CvCity* pHolyCity = pkReligion->GetHolyCity();
							if (pHolyCity)
							{
								if (pHolyCity->getOriginalOwner() == GetID())
									// Bonus if the liberator founded their holy city
									iPercent += gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_HOLYCITY_FOUNDER", 20);
								else if (pHolyCity->getOwner() == GetID())
									// Serious bad karma if the liberator has captured their holy city
									iPercent += gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_HOLYCITY_OCCUPIER", -20);
							}
						}
					}
				}
#endif

				// Limit the outcome
				iPercent = std::min(80, iPercent);
				
				// Use the popularity difference between the players to skew the probability
				int iSmileRatio = (GetExcessHappiness() * 100) / (std::max(0, GET_PLAYER(eToPlayer).GetExcessHappiness()) + 10);
				iPercent = iPercent * std::min(150, std::max(75, iSmileRatio)) / 100;
				CUSTOMLOG("Settler defect percent: %i (Approach=%i, Opinion=%i)", iPercent, GetDiplomacyAI()->GetCivApproach(eToPlayer), GetDiplomacyAI()->GetCivOpinion(eToPlayer));

				if (GC.getGame().getSmallFakeRandNum(100, GetPseudoRandomSeed()) < iPercent) {
					if (GC.getGame().getActivePlayer() == GetID()) {
						CvPopupInfo kPopupInfo(BUTTONPOPUP_TEXT);
						strcpy_s(kPopupInfo.szText, "TXT_KEY_GRATEFUL_SETTLERS");
						GC.GetEngineUserInterface()->AddPopup(kPopupInfo);
					}
				} else {
					pUnit->kill(true);
					CvUnit* pNewUnit = initUnit(eNewUnitType, iX, iY);
					CvAssert(pNewUnit != NULL);
					if (pNewUnit)
						pNewUnit->finishMoves();
				}
			} else {
#endif
				pUnit->kill(true);
				CvUnit* pNewUnit = initUnit(eNewUnitType, iX, iY);
				CvAssert(pNewUnit != NULL);
				if (pNewUnit)
					pNewUnit->finishMoves();
#if defined(MOD_GLOBAL_GRATEFUL_SETTLERS)
			}
#endif
		}
	}
}
#if defined(MOD_BALANCE_CORE)
void CvPlayer::DoTradeInfluenceAP()
{
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();
	int iOwner = GetID();
	if(GetPlayerTraits()->IsTradeRouteMinorInfluenceAdmiralPoints())
	{
		for (uint ui = 0; ui < pTrade->GetNumTradeConnections(); ui++)
		{
			if (pTrade->IsTradeRouteIndexEmpty(ui))
			{
				continue;
			}

			const TradeConnection* pConnection = &(pTrade->GetTradeConnection(ui));

			if (pConnection->m_eOriginOwner == iOwner && pConnection->m_eDestOwner != iOwner)
			{
				bool bMinorCiv = GET_PLAYER(pConnection->m_eDestOwner).isMinorCiv();
				if(bMinorCiv)
				{
					int iInfluence = GC.getGame().getGameSpeedInfo().getGoldGiftMod() / 100;
					if (pConnection->m_eDomain == DOMAIN_LAND)
					{
						GET_PLAYER(pConnection->m_eDestOwner).GetMinorCivAI()->ChangeFriendshipWithMajor((PlayerTypes)iOwner, iInfluence);
						changeNavalCombatExperienceTimes100(iInfluence * 100);
					}
					else if (pConnection->m_eDomain == DOMAIN_SEA)
					{
						iInfluence *= 2;
						GET_PLAYER(pConnection->m_eDestOwner).GetMinorCivAI()->ChangeFriendshipWithMajor((PlayerTypes)iOwner, iInfluence);
						changeNavalCombatExperienceTimes100(iInfluence * 100);
					}
				}
			}
		}
	}
}
#endif

//	--------------------------------------------------------------------------------
/// Someone sent us a present!
void CvPlayer::DoDistanceGift(PlayerTypes eFromPlayer, CvUnit* pUnit)
{
	if(!pUnit)
	{
		return;
	}

	CvPlot* pPlot = pUnit->plot();
	if(!pPlot)
	{
		return;
	}

	// Also add any units this guy is transporting
	IDInfo* pUnitNode = pPlot->headUnitNode();
	while(pUnitNode != NULL)
	{
		CvUnit* pLoopUnit = ::GetPlayerUnit(*pUnitNode);
		pUnitNode = pPlot->nextUnitNode(pUnitNode);

		if(NULL != pLoopUnit && pLoopUnit->getTransportUnit() == pUnit)
			AddIncomingUnit(eFromPlayer, pLoopUnit);
	}

	AddIncomingUnit(eFromPlayer, pUnit);
}
//	--------------------------------------------------------------------------------
/// Someone sent us a present!
void CvPlayer::AddIncomingUnit(PlayerTypes eFromPlayer, CvUnit* pUnit)
{
	CvAssert(pUnit);
	if (!pUnit) { return; }

	// Gift to a minor civ for friendship
	if(isMinorCiv() && GET_PLAYER(eFromPlayer).isMajorCiv())
	{
		CvMinorCivAI* pMinorCivAI = GetMinorCivAI();
		CvAssert(pMinorCivAI);
		if (pMinorCivAI)
		{
			CvMinorCivIncomingUnitGift& unitGift = pMinorCivAI->getIncomingUnitGift(eFromPlayer);
			CvAssertMsg(!unitGift.hasIncomingUnit(), "Adding incoming unit when one is already on its way. Please send Anton your save file and version.");
			if (!unitGift.hasIncomingUnit())
			{
				unitGift.init(*pUnit, /*3*/ GD_INT_GET(MINOR_UNIT_GIFT_TRAVEL_TURNS), eFromPlayer);
			}
		}

		// Get rid of the old unit
		pUnit->kill(true);
	}
	// Gift from minor civ to this major civ (ex. Austria UA, but NOT Militaristic unit spawning, that is handled elsewhere)
	else if(!isMinorCiv() && GET_PLAYER(eFromPlayer).isMinorCiv())
	{
		int iX = pUnit->getX();
		int iY = pUnit->getY();
		UnitTypes eType = pUnit->getUnitType();

		// Get rid of the old unit
		pUnit->kill(true);

		// Add the new unit in its place
		if(eType != NO_UNIT)
		{
			CvUnit* pNewUnit = initUnit(eType, iX, iY);
			CvAssert(pNewUnit);
			if (pNewUnit)
			{
				if (!pUnit->getUnitInfo().CanMoveAfterPurchase())
				{
					pNewUnit->finishMoves();
				}
				if (getCapitalCity() != NULL)
				{
					pNewUnit->setOriginCity(getCapitalCity()->GetID());
				}
			}
		}
	}
	else
	{
		CvAssertMsg(false, "Unexpected case for adding an incoming unit for this player. Please send Anton your save file and version.");
	}
}
//AI Routine for Gifting
PlayerTypes CvPlayer::GetBestGiftTarget(DomainTypes eUnitDomain)
{
	int iBestValue = 0;
	PlayerTypes eBestMinor = NO_PLAYER;
	bool bIsGermany = GetPlayerTraits()->GetMinorInfluencePerGiftedUnit() > 0;

	for (int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		PlayerTypes eLoopMinor = (PlayerTypes)iMinorLoop;
		if (eLoopMinor != NO_PLAYER)
		{
			CvPlayer* eMinor = &GET_PLAYER(eLoopMinor);
			if (eMinor && eMinor->isAlive())
			{
				CvCity* pCity = eMinor->getCapitalCity();
				if (pCity == NULL)
					continue;

				// Is there a distance gift from us waiting to be delivered?
				CvMinorCivAI* pMinorCivAI = eMinor->GetMinorCivAI();
				if (pMinorCivAI->getIncomingUnitGift(m_eID).getArrivalCountdown() != -1)
					continue;

				//No ships for landlocked players
				if (eUnitDomain == DOMAIN_SEA && !pCity->isCoastal())
					continue;

				// Skip if not revealed.
				if (!pCity->isRevealed(getTeam(),false,false))
					continue;
				
				int iFriendship = pMinorCivAI->GetFriendshipFromUnitGift(GetID(), false, true);

				if (!GET_TEAM(eMinor->getTeam()).isHasMet(getTeam()))
					continue;

				if (pMinorCivAI->IsNoAlly() && pMinorCivAI->IsFriends(GetID()))
				{
					continue;
				}
				if (pMinorCivAI->GetPermanentAlly() != NO_PLAYER)
				{
					continue;
				}
				//If we are at war with target minor, let's not send diplomatic lambs to slaughter.
				if (eMinor->GetMinorCivAI()->IsAtWarWithPlayersTeam(GetID()))
				{
					continue;
				}

				if (eMinor->GetMinorCivAI()->IsActiveQuestForPlayer(GetID(), MINOR_CIV_QUEST_HORDE) || eMinor->GetMinorCivAI()->IsActiveQuestForPlayer(GetID(), MINOR_CIV_QUEST_REBELLION))
				{
					continue;
				}

				// Did we bully you recently?  If so, being friendly now would be very odd.
				if (pMinorCivAI->IsRecentlyBulliedByMajor(GetID()))
				{
					continue;
				}

				EconomicAIStrategyTypes eNeedHappiness = (EconomicAIStrategyTypes)GC.getInfoTypeForString("ECONOMICAISTRATEGY_NEED_HAPPINESS");
				EconomicAIStrategyTypes eNeedHappinessCritical = (EconomicAIStrategyTypes)GC.getInfoTypeForString("ECONOMICAISTRATEGY_NEED_HAPPINESS_CRITICAL");
				bool bNeedHappiness = (eNeedHappiness != NO_ECONOMICAISTRATEGY) ? GetEconomicAI()->IsUsingStrategy(eNeedHappiness) : false;
				bool bNeedHappinessCritical = (eNeedHappinessCritical != NO_ECONOMICAISTRATEGY) ? GetEconomicAI()->IsUsingStrategy(eNeedHappinessCritical) : false;

				// **************************
				// Approaches
				// **************************

				CivApproachTypes eApproach = GetDiplomacyAI()->GetCivApproach(eLoopMinor);

				if (eApproach == CIV_APPROACH_WAR || eApproach == CIV_APPROACH_HOSTILE)
					continue;

				int iScore = eApproach == CIV_APPROACH_FRIENDLY ? 100 : 50;

				// **************************
				// Benefits to Us!
				// **************************

				//DIPLOMACY - We want all of them the same!
				if (GetDiplomacyAI()->IsGoingForDiploVictory())
				{
					iScore *= 2;
				}

				//MILITARY - We want units and happiness!!
				else if (GetDiplomacyAI()->IsGoingForWorldConquest())
				{
					if (pMinorCivAI->GetTrait() == MINOR_CIV_TRAIT_MILITARISTIC)
					{
						iScore *= 2;
					}
				}

				//SCIENCE - We want happiness and growth!!
				else if (GetDiplomacyAI()->IsGoingForSpaceshipVictory())
				{
					if (pMinorCivAI->GetTrait() == MINOR_CIV_TRAIT_MARITIME)
					{
						iScore *= 2;
					}
					if (pMinorCivAI->GetTrait() == MINOR_CIV_TRAIT_MERCANTILE)
					{
						iScore *= 2;
					}
				}

				//CULTURE - We want culture and religion!!
				else if (GetDiplomacyAI()->IsGoingForCultureVictory())
				{
					if (pMinorCivAI->GetTrait() == MINOR_CIV_TRAIT_CULTURED)
					{
						iScore *= 2;
					}
					if (pMinorCivAI->GetTrait() == MINOR_CIV_TRAIT_RELIGIOUS)
					{
						iScore *= 2;
					}
				}

				// Is Our Influence worth more here? Definitely take advantage of this.
				if (pMinorCivAI->IsActiveQuestForPlayer(GetID(), MINOR_CIV_QUEST_INFLUENCE))
				{
					iScore *= 5;
				}

				// Do they have a resource we lack?
				int iResourcesWeLack = pMinorCivAI->GetNumResourcesMajorLacks(GetID());
				if (iResourcesWeLack > 0)
				{
					if (bNeedHappiness)
					{
						iScore *= 3;
					}
					else if (bNeedHappinessCritical)
					{
						iScore *= 4;
					}
					else
					{
						iScore *= 2;
					}
				}

				//Will they give us a WLTKD for their resource?
				int iCityLoop;
				for (CvCity* pLoopCity = GET_PLAYER(GetID()).firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iCityLoop))
				{
					if (pLoopCity != NULL)
					{
						ResourceTypes eResourceDemanded = pLoopCity->GetResourceDemanded();
						if (eResourceDemanded != NO_RESOURCE)
						{
							//Will we get a WLTKD from this? We want it a bit more, please.
							if (eMinor->getResourceInOwnedPlots(eResourceDemanded) > 0)
							{
								iScore *= 3;
								iScore /= 2;
							}
						}
					}
				}

				//Nobody likes hostile city-states.
				if (!bIsGermany && pMinorCivAI->GetPersonality() == MINOR_CIV_PERSONALITY_HOSTILE)
				{
					iScore /= 2;
				}
				//If our friendship is under 0, we've probably done something bad to this City-State. Let's not look at them!
				if (eMinor->GetMinorCivAI()->GetEffectiveFriendshipWithMajor(GetID()) < 0)
				{
					iScore /= 2;
				}

				// **************************
				// Other Relationships!
				// **************************

				PlayerTypes eAlliedPlayer = pMinorCivAI->GetAlly();
				int iFriendshipWithMinor = pMinorCivAI->GetEffectiveFriendshipWithMajor(GetID());

				if (eAlliedPlayer != NO_PLAYER)
				{
					int iHighestInfluence = 0;
					// Loop through other players to see if we can pass them in influence
					for (int iOtherMajorLoop = 0; iOtherMajorLoop < MAX_MAJOR_CIVS; iOtherMajorLoop++)
					{
						PlayerTypes eOtherMajor = (PlayerTypes)iOtherMajorLoop;
						int iOtherPlayerFriendshipWithMinor = pMinorCivAI->GetEffectiveFriendshipWithMajor(eOtherMajor);

						if (iOtherPlayerFriendshipWithMinor > iHighestInfluence)
						{
							iHighestInfluence = iOtherPlayerFriendshipWithMinor;
						}
						if (eOtherMajor != NO_PLAYER && eOtherMajor != GetID() && GET_TEAM(GET_PLAYER(GetID()).getTeam()).isHasMet(GET_PLAYER(eOtherMajor).getTeam()))
						{
							CivApproachTypes eApproachType = GetDiplomacyAI()->GetCivApproach(eOtherMajor);
							CivOpinionTypes eOpinion = GetDiplomacyAI()->GetCivOpinion(eOtherMajor);

							// If another player is allied, let's evaluate that.
							// Only care if they are allies
							if (pMinorCivAI->IsAllies(eOtherMajor))
							{
								//Are they not on our team?
								if (GET_PLAYER(eOtherMajor).getTeam() != getTeam())
								{
									//If their influence is way higher than ours, let's tune this down...
									if (iOtherPlayerFriendshipWithMinor >= (60 + iFriendship + iFriendshipWithMinor))
									{
										iScore /= 4;
									}
									//If we can pass them, ramp it up!
									else if (iOtherPlayerFriendshipWithMinor < (iFriendship + iFriendshipWithMinor))
									{
										iScore *= 4;
									}
								}
								// If a teammate is allied, let's discourage going there.
								else
								{
									iScore /= 5;
								}
								// If a friendly player is allied, let's discourage going there.
								if (eApproachType == CIV_APPROACH_FRIENDLY)
								{
									iScore /= 2;
								}
								// If an enemy is allied, let's take their stuff!
								else if (eApproachType == CIV_APPROACH_HOSTILE)
								{
									iScore *= 2;
								}
								// If an ally is allied, let's leave it alone!
								if (eOpinion == CIV_OPINION_ALLY)
								{
									iScore /= 2;
								}
								// If an competitor is allied, let's fight for it!
								else if (eOpinion == CIV_OPINION_COMPETITOR)
								{
									iScore *= 2;
								}
							}
							// Is another player really close to us? If so, let's keep an eye on things.
							else if (iOtherPlayerFriendshipWithMinor >= (iFriendshipWithMinor - 30))
							{
								iScore *= 2;
							}
						}
					}
					int iDifference = (iFriendshipWithMinor - iHighestInfluence);
					// Are we allied? Yay! But let's be careful.
					if (pMinorCivAI->IsAllies(GetID()))
					{
						// Are WE allies by a wide margin (over 100)? If so, let's find someone new to love.
						if (iDifference >= 60)
						{
							iScore /= 5;
						}
						// Are we close to losing our status? If so, obsess away!
						else if (iDifference <= 30 || pMinorCivAI->IsCloseToNotBeingAllies(GetID()))
						{
							iScore *= 5;
						}
					}
				}
				else
				{
					// Are we close to becoming an normal (60) ally and no one else ? If so, obsess away!
					if ((iFriendshipWithMinor + iFriendship) >= pMinorCivAI->GetAlliesThreshold(GetID()))
					{
						iScore *= 4;
					}

					// Are we already Friends? If so, let's stay the course.
					if (pMinorCivAI->IsFriends(GetID()))
					{
						iScore *= 4;
					}
				}

				// If we're Germany, don't concentrate our unit gifts too much
				if (bIsGermany)
				{
					int iCurrentShift = pMinorCivAI->GetFriendshipChangePerTurnTimes100(GetID());

					// Don't count any natural recovery in this anti-concentration modifier
					if (pMinorCivAI->GetEffectiveFriendshipWithMajor(GetID()) < pMinorCivAI->GetFriendshipAnchorWithMajor(GetID()))
					{
						int iReduction = /*100*/ GD_INT_GET(MINOR_FRIENDSHIP_NEGATIVE_INCREASE_PER_TURN);
						int iReligionBonus = pMinorCivAI->IsSameReligionAsMajor(GetID()) ? /*50*/ GD_INT_GET(MINOR_FRIENDSHIP_RATE_MOD_SHARED_RELIGION) : 0;
						if (iReduction > 0)
						{
							iReduction *= (100 + iReligionBonus + GetPlayerTraits()->GetCityStateFriendshipModifier());
							iReduction /= 100;
							iCurrentShift -= iReduction;
						}
					}

					iCurrentShift /= 100;
					if (iCurrentShift > 1)
						iScore /= iCurrentShift;
				}

				//All CSs should theoretically be valuable if we've gotten this far.
				if (iScore <= 0)
				{
					iScore = 1;
				}
				if (iScore > iBestValue)
				{
					iBestValue = iScore;
					eBestMinor = eLoopMinor;
				}
			}
		}
	}
	return eBestMinor;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isOption(PlayerOptionTypes eID) const
{
	for (PlayerOptionsVector::const_iterator itr = m_aOptions.begin(); itr != m_aOptions.end(); ++itr )
	{
		if ((*itr).first == eID)
			return (*itr).second != 0;
	}
	return false;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setOption(PlayerOptionTypes eID, bool bNewValue)
{
	int iIndex = 0;
	for (PlayerOptionsVector::const_iterator itr = m_aOptions.begin(); itr != m_aOptions.end(); ++itr )
	{
		if ((*itr).first == eID)
		{
			m_aOptions[iIndex] = PlayerOptionEntry((uint)eID, bNewValue ? 1 : 0);
			return;
		}
		++iIndex;
	}

	m_aOptions.push_back(PlayerOptionEntry((uint)eID, bNewValue?1:0));
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isPlayable() const
{
	return CvPreGame::isPlayable(GetID());
}

//	--------------------------------------------------------------------------------
void CvPlayer::setPlayable(bool bNewValue)
{
	CvPreGame::setPlayable(GetID(), bNewValue);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNumResourceUsed(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiNumResourceUsed[eIndex];
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeNumResourceUsed(ResourceTypes eIndex, int iChange)
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumResourceInfos());

	if(iChange != 0)
	{
		m_paiNumResourceUsed[eIndex] = m_paiNumResourceUsed[eIndex] + iChange;
	}

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	CvAssert(m_paiNumResourceUsed[eIndex] >= 0);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNumResourcesFromOther(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	
	CvResourceInfo *pkResource = GC.getResourceInfo(eIndex);

	// exists?
	if (pkResource == NULL) { return 0;}

	int iTotalNumResource = m_paiNumResourceTotal[eIndex];

#if defined(MOD_BALANCE_CORE)
	// Additional resources from Corporation
	CorporationTypes eCorporation = GetCorporations()->GetFoundedCorporation();
	if (eCorporation != NO_CORPORATION)
	{
		CvCorporationEntry* pkCorporationInfo = GC.getCorporationInfo(eCorporation);
		if (pkCorporationInfo)
		{
			int iFreeResource = pkCorporationInfo->GetNumFreeResource(eIndex);
			if (iFreeResource > 0)
			{
				iTotalNumResource += iFreeResource;
			}
		}
	}

	int iCSResource = getResourceFromCSAlliances(eIndex);
	if (iCSResource != 0)
	{
		if (IsResourceRevealed(eIndex))
		{
			iCSResource *= GetNumCSAllies();
			iCSResource /= 100;
			iTotalNumResource += iCSResource;
		}
	}

	//GP resources? ie. Admiral, Diplomat
	iTotalNumResource += getResourceFromGP(eIndex);
#endif

	if (pkResource->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)
	{
#if defined(MOD_BALANCE_CORE)
		const CvCity* pLoopCity;
		int iLoop;
		int iCityPOPResource = 0;
		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if (pLoopCity != NULL)
			{
				if (pLoopCity->GetResourceQuantityPerXFranchises(eIndex) > 0)
				{
					int iFranchises = GetCorporations()->GetNumFranchises();
					if (iFranchises > 0)
					{
						iTotalNumResource += (iFranchises / pLoopCity->GetResourceQuantityPerXFranchises(eIndex));
					}
				}
				
				if (pLoopCity->GetResourceQuantityFromPOP(eIndex) > 0)
				{
					iCityPOPResource += (pLoopCity->getPopulation() * pLoopCity->GetResourceQuantityFromPOP(eIndex));
				}
			}
		}

		iTotalNumResource += iCityPOPResource / 100;
#endif
		if (GetStrategicResourceMod() != 0)
		{
			iTotalNumResource *= GetStrategicResourceMod();
			iTotalNumResource /= 100;
		}
	}

#if defined(MOD_BALANCE_CORE)
	iTotalNumResource *= 100 + getResourceModFromReligion(eIndex);
	iTotalNumResource /= 100;
#endif

	//And remove the starter. Added in beginning to factor in multiplicative modifiers.
	iTotalNumResource -= m_paiNumResourceTotal[eIndex];

	return iTotalNumResource;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNumResourceTotal(ResourceTypes eIndex, bool bIncludeImport) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	CvResourceInfo *pkResource = GC.getResourceInfo(eIndex);

	// exists?
	if (pkResource == NULL) { return 0;}

	int iTotalNumResource = m_paiNumResourceTotal[eIndex];

	//add resources from other sources, ex Corporations, Policies, Religion
	iTotalNumResource += getNumResourcesFromOther(eIndex);

	if(bIncludeImport)
	{
		iTotalNumResource += getResourceFromMinors(eIndex);
		iTotalNumResource += getResourceImportFromMajor(eIndex);
		iTotalNumResource += getResourceSiphoned(eIndex);
	}

	iTotalNumResource -= getResourceExport(eIndex);

	return iTotalNumResource;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeNumResourceTotal(ResourceTypes eIndex, int iChange, bool /*bIgnoreResourceWarning*/)
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumResourceInfos());

	if(iChange != 0)
	{
		m_paiNumResourceTotal[eIndex] = m_paiNumResourceTotal[eIndex] + iChange;

#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
		if(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
		{
			CheckForMonopoly(eIndex);
		}
#endif

		// Minors with an Ally give their Resources to their friend (awww)
		if(isMinorCiv())
		{
			PlayerTypes eBestRelationsPlayer = GetMinorCivAI()->GetAlly();

			if(eBestRelationsPlayer != NO_PLAYER)
			{
				ResourceUsageTypes eUsage = GC.getResourceInfo(eIndex)->getResourceUsage();

				if(eUsage == RESOURCEUSAGE_STRATEGIC || eUsage == RESOURCEUSAGE_LUXURY)
				{
					GET_PLAYER(eBestRelationsPlayer).changeResourceFromMinors(eIndex, iChange);
					changeResourceExport(eIndex, iChange);

					// Someone new is getting the bonus - but do they have the tech to see it?
					CvResourceInfo* pResource = GC.getResourceInfo(eIndex);
					if (pResource)
					{
						if (IsResourceRevealed(eIndex))
						{
							CvNotifications* pNotifications = GET_PLAYER(eBestRelationsPlayer).GetNotifications();
							if (pNotifications && !GetMinorCivAI()->IsDisableNotifications())
							{
								Localization::String strMessage;
								Localization::String strSummary;

								// Adding Resources
								if (iChange > 0)
								{
									strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_BFF_NEW_RESOURCE");
									strMessage << getNameKey() << GC.getResourceInfo(eIndex)->GetDescriptionKey();
									strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MINOR_BFF_NEW_RESOURCE");
									strSummary << getNameKey() << GC.getResourceInfo(eIndex)->GetDescriptionKey();
								}
								// Lost Resources
								else
								{
									strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_BFF_LOST_RESOURCE");
									strMessage << getNameKey() << GC.getResourceInfo(eIndex)->GetDescriptionKey();
									strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MINOR_BFF_LOST_RESOURCE");
									strSummary << getNameKey() << GC.getResourceInfo(eIndex)->GetDescriptionKey();
								}

								int iX = -1;
								int iY = -1;

								CvCity* capCity = getCapitalCity();

								if (capCity != NULL)
								{
									iX = capCity->getX();
									iY = capCity->getY();
								}

								pNotifications->Add(NOTIFICATION_MINOR, strMessage.toUTF8(), strSummary.toUTF8(), iX, iY, -1);
							}
						}
					}
				}
			}
		}

		// Any players siphoning resources from us need to be updated as well
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_PLAYERS; iPlayerLoop++)
		{
			GET_PLAYER((PlayerTypes)iPlayerLoop).UpdateResourcesSiphoned();
		}
	}

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	CvAssert(m_paiNumResourceTotal[eIndex] >= 0);
}

#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
//	--------------------------------------------------------------------------------
int CvPlayer::getResourceShortageValue(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiResourceShortageValue[eIndex];
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceShortageValue(ResourceTypes eIndex, int iChange)
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumResourceInfos());

	if(iChange != 0)
	{
		m_paiResourceShortageValue[eIndex] = m_paiResourceShortageValue[eIndex] + iChange;
	}

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	CvAssert(m_paiResourceShortageValue[eIndex] >= 0);
}
//	--------------------------------------------------------------------------------
void CvPlayer::setResourceShortageValue(ResourceTypes eIndex, int iChange)
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumResourceInfos());

	m_paiResourceShortageValue[eIndex] = iChange;

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	CvAssert(m_paiResourceShortageValue[eIndex] >= 0);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getResourceFromCSAlliances(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiResourceFromCSAlliances[eIndex];
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceFromCSAlliances(ResourceTypes eIndex, int iChange)
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumResourceInfos());

	if (iChange != 0)
	{
		m_paiResourceFromCSAlliances[eIndex] = m_paiResourceFromCSAlliances[eIndex] + iChange;
	}

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	CvAssert(m_paiResourceFromCSAlliances[eIndex] >= 0);
}
//	--------------------------------------------------------------------------------
void CvPlayer::setResourceFromCSAlliances(ResourceTypes eIndex, int iChange)
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumResourceInfos());

	m_paiResourceFromCSAlliances[eIndex] = iChange;

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	CvAssert(m_paiResourceFromCSAlliances[eIndex] >= 0);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getResourceModFromReligion(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	int iQuantityMod = 0;

	ReligionTypes eReligion = GetReligions()->GetStateReligion(true);
	const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, GetID());
	if (pReligion)
	{
		CvCity* pHolyCity = pReligion->GetHolyCity();
		if (pHolyCity == NULL)
		{
			pHolyCity = GET_PLAYER(GetID()).getCapitalCity();
		}
		iQuantityMod = pReligion->m_Beliefs.GetResourceQuantityModifier(eIndex, GetID(), pHolyCity, true);
		if (iQuantityMod != 0)
		{
			iQuantityMod *= GC.getGame().GetGameReligions()->GetNumCitiesFollowing(eReligion);
			iQuantityMod = std::min(25, iQuantityMod);
		}
	}

	return iQuantityMod;
}


void CvPlayer::UpdateMonopolyCache()
{
	m_vResourcesWStrategicMonopoly.clear();
	m_vResourcesWGlobalMonopoly.clear();
	m_iCombatAttackBonusFromMonopolies = 0;
	m_iCombatDefenseBonusFromMonopolies = 0;

#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	if (!MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
		return;
#endif

	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		if (m_pabHasGlobalMonopoly[iResourceLoop])
			m_vResourcesWGlobalMonopoly.push_back((ResourceTypes)iResourceLoop);
		if (m_pabHasStrategicMonopoly[iResourceLoop])
			m_vResourcesWStrategicMonopoly.push_back((ResourceTypes)iResourceLoop);
	}

	// Strategic monopoly of resources
	const std::vector<ResourceTypes>& vStrategicMonopolies = GetStrategicMonopolies();
	for (size_t iResourceLoop = 0; iResourceLoop < vStrategicMonopolies.size(); iResourceLoop++)
	{
		ResourceTypes eResourceLoop = vStrategicMonopolies[iResourceLoop];
		CvResourceInfo* pInfo = GC.getResourceInfo(eResourceLoop);
		if (!pInfo)
			continue;
		
		m_iCombatAttackBonusFromMonopolies += pInfo->getMonopolyAttackBonus();
		m_iCombatAttackBonusFromMonopolies += pInfo->getMonopolyAttackBonus(MONOPOLY_STRATEGIC);
		m_iCombatDefenseBonusFromMonopolies += pInfo->getMonopolyDefenseBonus();
		m_iCombatDefenseBonusFromMonopolies += pInfo->getMonopolyDefenseBonus(MONOPOLY_STRATEGIC);
	}

	// Global monopoly of resources
	const std::vector<ResourceTypes>& vGlobalMonopolies = GetGlobalMonopolies();
	for (size_t iResourceLoop = 0; iResourceLoop < vGlobalMonopolies.size(); iResourceLoop++)
	{
		ResourceTypes eResourceLoop = vGlobalMonopolies[iResourceLoop];
		CvResourceInfo* pInfo = GC.getResourceInfo(eResourceLoop);
		if (!pInfo)
			continue;

		m_iCombatAttackBonusFromMonopolies += pInfo->getMonopolyAttackBonus();
		m_iCombatAttackBonusFromMonopolies += pInfo->getMonopolyAttackBonus(MONOPOLY_GLOBAL);
		//m_iCombatAttackBonusFromMonopolies += GetMonopolyModPercent(); // Global monopolies get the mod percent boost from policies.
		m_iCombatDefenseBonusFromMonopolies += pInfo->getMonopolyDefenseBonus();
		m_iCombatDefenseBonusFromMonopolies += pInfo->getMonopolyDefenseBonus(MONOPOLY_GLOBAL);
	}
}

void CvPlayer::UpdatePlotBlockades()
{
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		pLoopCity->GetCityCitizens()->DoVerifyWorkingPlots();
}

int CvPlayer::GetCombatAttackBonusFromMonopolies() const
{
	return m_iCombatAttackBonusFromMonopolies;
}

int CvPlayer::GetCombatDefenseBonusFromMonopolies() const
{
	return m_iCombatDefenseBonusFromMonopolies;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::HasGlobalMonopoly(ResourceTypes eResource) const
{
	return m_pabHasGlobalMonopoly[eResource];
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetHasGlobalMonopoly(ResourceTypes eResource, bool bNewValue)
{
	if(!MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
		return;

	if (bNewValue != m_pabHasGlobalMonopoly[eResource])
	{
		m_pabHasGlobalMonopoly[eResource] = bNewValue;

		YieldTypes eYield;
		CvResourceInfo* pResource = GC.getResourceInfo(eResource);
		if (pResource)
		{
			for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				eYield = (YieldTypes)iI;

				if (eYield == NO_YIELD)
					continue;

				int iModValue = pResource->getCityYieldModFromMonopoly(eYield);
				if (iModValue != 0)
				{
					if (bNewValue)
					{
						changeCityYieldModFromMonopoly(eYield, iModValue);
					}
					else
					{
						changeCityYieldModFromMonopoly(eYield, (iModValue * -1));
					}
				}
			}

			for (int iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
			{
				SpecialistTypes eSpecialist = (SpecialistTypes)iI;
				GreatPersonTypes eGreatPerson = GetGreatPersonFromSpecialist(eSpecialist);
				if (eSpecialist != NO_SPECIALIST && eGreatPerson != NO_GREATPERSON)
				{
					int iModValue = pResource->getMonopolyGreatPersonRateModifier(eSpecialist, MONOPOLY_GLOBAL);
					if (iModValue > 0)
					{
						if (bNewValue)
						{
							changeSpecificGreatPersonRateModifierFromMonopoly(eGreatPerson, MONOPOLY_GLOBAL, iModValue);
						}
						else
						{
							changeSpecificGreatPersonRateModifierFromMonopoly(eGreatPerson, MONOPOLY_GLOBAL, iModValue * -1);
						}
					}
					iModValue = pResource->getMonopolyGreatPersonRateChange(eSpecialist, MONOPOLY_GLOBAL);
					if (iModValue > 0)
					{
						if (bNewValue)
						{
							changeSpecificGreatPersonRateChangeFromMonopoly(eGreatPerson, MONOPOLY_GLOBAL, iModValue);
						}
						else
						{
							changeSpecificGreatPersonRateChangeFromMonopoly(eGreatPerson, MONOPOLY_GLOBAL, iModValue * -1);
						}
					}
				}
			}
		}

		UpdateMonopolyCache();
	}
}
//	--------------------------------------------------------------------------------
bool CvPlayer::HasStrategicMonopoly(ResourceTypes eResource) const
{
	return m_pabHasStrategicMonopoly[eResource];
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetHasStrategicMonopoly(ResourceTypes eResource, bool bNewValue)
{
	if(!MOD_BALANCE_CORE_RESOURCE_MONOPOLIES_STRATEGIC)
		return;

	if(bNewValue != m_pabHasStrategicMonopoly[eResource])
	{
		m_pabHasStrategicMonopoly[eResource] = bNewValue;

		CvResourceInfo* pResource = GC.getResourceInfo(eResource);
		if (pResource)
		{
			for (int iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
			{
				SpecialistTypes eSpecialist = (SpecialistTypes)iI;
				GreatPersonTypes eGreatPerson = GetGreatPersonFromSpecialist(eSpecialist);
				if (eSpecialist != NO_SPECIALIST && eGreatPerson != NO_GREATPERSON)
				{
					int iModValue = pResource->getMonopolyGreatPersonRateModifier(eSpecialist, MONOPOLY_STRATEGIC);
					if (iModValue > 0)
					{
						if (bNewValue)
						{
							changeSpecificGreatPersonRateModifierFromMonopoly(eGreatPerson, MONOPOLY_STRATEGIC, iModValue);
						}
						else
						{
							changeSpecificGreatPersonRateModifierFromMonopoly(eGreatPerson, MONOPOLY_STRATEGIC, iModValue * -1);
						}
					}
					iModValue = pResource->getMonopolyGreatPersonRateChange(eSpecialist, MONOPOLY_STRATEGIC);
					if (iModValue > 0)
					{
						if (bNewValue)
						{
							changeSpecificGreatPersonRateChangeFromMonopoly(eGreatPerson, MONOPOLY_STRATEGIC, iModValue);
						}
						else
						{
							changeSpecificGreatPersonRateChangeFromMonopoly(eGreatPerson, MONOPOLY_STRATEGIC, iModValue * -1);
						}
					}
				}
			}
		}

		UpdateMonopolyCache();
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::CheckForMonopoly(ResourceTypes eResource)
{
	const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);
	if(pkResourceInfo != NULL)
	{
		if (pkResourceInfo->isMonopoly() && (IsResourceRevealed(eResource)))
		{
			bool bGainingBonus = false;
			bool bGainingStrategicBonus = false;
			bool bLosingBonus = false;
			bool bLosingStrategicBonus = false;
			int iTotalNumResource = GC.getMap().getNumResources(eResource);
			if (iTotalNumResource > 0)
			{
				int iOwnedNumResource = getNumResourceTotal(eResource, false) + getResourceExport(eResource);
				if (IsCSResourcesCountMonopolies())
				{
					iOwnedNumResource += getResourceFromMinors(eResource);
				}

				if (GetPlayerTraits()->IsImportsCountTowardsMonopolies())
				{
					iOwnedNumResource += getResourceImportFromMajor(eResource);
				}
				
				if (pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_LUXURY && !GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(GetID(), eResource))
				{
					int iThreshold = max(GC.getGame().GetGreatestPlayerResourceMonopolyValue(eResource), /*50*/ GD_INT_GET(GLOBAL_RESOURCE_MONOPOLY_THRESHOLD));
					//Do we have >50% of this resource under our control?
					bool bValid = false;
					if (GC.getGame().GetGreatestPlayerResourceMonopoly(eResource) == GetID())
					{
						if (((iOwnedNumResource * 100) / iTotalNumResource) >= iThreshold && ((iOwnedNumResource * 100) / iTotalNumResource) > GD_INT_GET(GLOBAL_RESOURCE_MONOPOLY_THRESHOLD))
							bValid = true;
					}
					else
					{
						if (((iOwnedNumResource * 100) / iTotalNumResource) > iThreshold)
							bValid = true;
					}
					if (bValid)
					{
						if(m_pabHasGlobalMonopoly[eResource] == false)
						{
							bGainingBonus = true;
							GC.getGame().UpdateGreatestPlayerResourceMonopoly(eResource);
						}
						SetHasGlobalMonopoly(eResource, true);						
					}
					else
					{
						if(m_pabHasGlobalMonopoly[eResource] == true)
						{
							bLosingBonus = true;
							GC.getGame().UpdateGreatestPlayerResourceMonopoly(eResource);
						}
						SetHasGlobalMonopoly(eResource, false);
					}
				}
				else if(pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)
				{
					//Do we have >25% of this resource under our control?
					if(((iOwnedNumResource * 100) / iTotalNumResource) > GD_INT_GET(STRATEGIC_RESOURCE_MONOPOLY_THRESHOLD))
					{
						if(m_pabHasStrategicMonopoly[eResource] == false)
						{
							bGainingStrategicBonus = true;
							GC.getGame().UpdateGreatestPlayerResourceMonopoly(eResource);
						}
						SetHasStrategicMonopoly(eResource, true);
					}
					else
					{
						if(m_pabHasStrategicMonopoly[eResource] == true)
						{
							bLosingStrategicBonus = true;
							GC.getGame().UpdateGreatestPlayerResourceMonopoly(eResource);
						}
						SetHasStrategicMonopoly(eResource, false);
					}
					//Do we also have >50% of this resource under our control?
					int iThreshold = max(GC.getGame().GetGreatestPlayerResourceMonopolyValue(eResource), GD_INT_GET(GLOBAL_RESOURCE_MONOPOLY_THRESHOLD));

					bool bValid = false;
					if (GC.getGame().GetGreatestPlayerResourceMonopoly(eResource) == GetID())
					{
						if (((iOwnedNumResource * 100) / iTotalNumResource) >= iThreshold && ((iOwnedNumResource * 100) / iTotalNumResource) > GD_INT_GET(GLOBAL_RESOURCE_MONOPOLY_THRESHOLD))
							bValid = true;
					}
					else
					{
						if (((iOwnedNumResource * 100) / iTotalNumResource) > iThreshold)
							bValid = true;
					}

					if (bValid)
					{
						if(m_pabHasGlobalMonopoly[eResource] == false)
						{
							bGainingBonus = true;
							GC.getGame().UpdateGreatestPlayerResourceMonopoly(eResource);
						}
						SetHasGlobalMonopoly(eResource, true);
						
					}
					else
					{
						if(m_pabHasGlobalMonopoly[eResource] == true)
						{
							bLosingBonus = true;
							GC.getGame().UpdateGreatestPlayerResourceMonopoly(eResource);
						}
						SetHasGlobalMonopoly(eResource, false);
					}
				}
				CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
				if(pLeague != NULL)
				{
					if (GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(GetID(), eResource))
					{
						if(m_pabHasGlobalMonopoly[eResource] == true)
						{
							bLosingBonus = true;
							GC.getGame().UpdateGreatestPlayerResourceMonopoly(eResource);
						}
						SetHasGlobalMonopoly(eResource, false);
					}
				}
			}
			else
			{
				SetHasGlobalMonopoly(eResource, false);
			}
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications && MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
			{
				const char* strResourceHelp = pkResourceInfo->GetHelp();

				// Adding Resources
				if(bGainingBonus)
				{
					Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MONOPOLY_GAINED");
					strMessage << pkResourceInfo->GetTextKey();
					strMessage << strResourceHelp;
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MONOPOLY_GAINED");
					strSummary << pkResourceInfo->GetTextKey();

					pNotifications->Add(NOTIFICATION_DISCOVERED_BONUS_RESOURCE, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, eResource);
					updateYield();
					for(int iPlayer = 0; iPlayer < MAX_PLAYERS; ++iPlayer)
					{
						//Notify human players of this, as they'll care.
						CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iPlayer);
						if(GET_TEAM(kLoopPlayer.getTeam()).isHasMet(getTeam()) && kLoopPlayer.isHuman() && (kLoopPlayer.GetID() != GetID()))
						{
							Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_PLAYER_MONOPOLY_GAINED");
							strMessage << pkResourceInfo->GetTextKey();
							strMessage << strResourceHelp;
							strMessage << getCivilizationInfo().getShortDescriptionKey();
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_OTHER_PLAYER_MONOPOLY_GAINED");
							strSummary << pkResourceInfo->GetTextKey();
							strSummary << getCivilizationInfo().getShortDescriptionKey();

							kLoopPlayer.GetNotifications()->Add(NOTIFICATION_DISCOVERED_BONUS_RESOURCE, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, eResource);
						}
					}
				}
				// Lost Resources
				else if(bLosingBonus && MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
				{
					Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MONOPOLY_LOST");
					strMessage << pkResourceInfo->GetTextKey();
					strMessage << strResourceHelp;
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MONOPOLY_LOST");
					strSummary << pkResourceInfo->GetTextKey();

					pNotifications->Add(NOTIFICATION_DISCOVERED_BONUS_RESOURCE, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, eResource);
					updateYield();
				}
				// Adding Resources
				if(bGainingStrategicBonus && MOD_BALANCE_CORE_RESOURCE_MONOPOLIES_STRATEGIC)
				{
					Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_STRATEGIC_MONOPOLY_GAINED");
					strMessage << pkResourceInfo->GetTextKey();
					strMessage << strResourceHelp;
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_STRATEGIC_MONOPOLY_GAINED");
					strSummary << pkResourceInfo->GetTextKey();

					pNotifications->Add(NOTIFICATION_DISCOVERED_BONUS_RESOURCE, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, eResource);
					updateYield();
					for(int iPlayer = 0; iPlayer < MAX_PLAYERS; ++iPlayer)
					{
						//Notify human players of this, as they'll care.
						CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iPlayer);
						if(GET_TEAM(kLoopPlayer.getTeam()).isHasMet(getTeam()) && kLoopPlayer.isHuman() && (kLoopPlayer.GetID() != GetID()))
						{
							Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_PLAYER_STRATEGIC_MONOPOLY_GAINED");
							strMessage << pkResourceInfo->GetTextKey();
							strMessage << strResourceHelp;
							strMessage << getCivilizationInfo().getShortDescriptionKey();
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_OTHER_PLAYER_STRATEGIC_MONOPOLY_GAINED");
							strSummary << pkResourceInfo->GetTextKey();
							strSummary << getCivilizationInfo().getShortDescriptionKey();

							kLoopPlayer.GetNotifications()->Add(NOTIFICATION_DISCOVERED_BONUS_RESOURCE, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, eResource);
						}
					}
				}
				// Lost Resources
				else if(bLosingStrategicBonus && MOD_BALANCE_CORE_RESOURCE_MONOPOLIES_STRATEGIC)
				{
					Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_STRATEGIC_MONOPOLY_LOST");
					strMessage << pkResourceInfo->GetTextKey();
					strMessage << strResourceHelp;
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_STRATEGIC_MONOPOLY_LOST");
					strSummary << pkResourceInfo->GetTextKey();

					pNotifications->Add(NOTIFICATION_DISCOVERED_BONUS_RESOURCE, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, eResource);
					updateYield();
				}
			}
		}
	}
}
#endif

//	--------------------------------------------------------------------------------
/// Get the monopoly percentage owned for eResource.
int CvPlayer::GetMonopolyPercent(ResourceTypes eResource) const
{
	int iOwnedNumResource = getNumResourceTotal(eResource, false) + getResourceExport(eResource);
	if (IsCSResourcesCountMonopolies())
	{
		iOwnedNumResource += getResourceFromMinors(eResource);
	}

	if (GetPlayerTraits()->IsImportsCountTowardsMonopolies())
	{
		iOwnedNumResource += getResourceImportFromMajor(eResource);
	}
	int iTotalNumResource = GC.getMap().getNumResources(eResource);

	if (iTotalNumResource <= 0)
	{
		// if we own a resource, but it's not on the map at all, it is 100%
		// todo: what about other players?
		return iOwnedNumResource > 0 ? 100 : 0;
	}

	return (iOwnedNumResource * 100) / iTotalNumResource;
}

bool CvPlayer::WouldGainMonopoly(ResourceTypes eResource, int iExtraResource) const
{
	if (iExtraResource <= 0)
		return false;

	int iCurrent = GetMonopolyPercent(eResource);
	int iExtra = (iExtraResource * 100) / max(1,GC.getMap().getNumResources(eResource));

	const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);
	if (pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_LUXURY && !GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(GetID(), eResource))
	{
		return (iCurrent + iExtra) > /*50*/ GD_INT_GET(GLOBAL_RESOURCE_MONOPOLY_THRESHOLD);
	}
	else if (pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)
	{
		return (iCurrent + iExtra) > /*25*/ GD_INT_GET(STRATEGIC_RESOURCE_MONOPOLY_THRESHOLD);
	}

	return false;
}

int CvPlayer::getCityYieldModFromMonopoly(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	return m_aiCityYieldModFromMonopoly[eIndex];
}

void CvPlayer::changeCityYieldModFromMonopoly(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiCityYieldModFromMonopoly[eIndex] = m_aiCityYieldModFromMonopoly[eIndex] + iChange;
	}
}

//	--------------------------------------------------------------------------------
//	--------------------------------------------------------------------------------
/// Does this player, or his/her team, have the city trade tech for eResource?
bool CvPlayer::IsResourceCityTradeable(ResourceTypes eResource, bool bCheckTeam) const
{
	CvResourceInfo* pResource = GC.getResourceInfo(eResource);

	if (pResource)
	{
		// First, check for the player
		TechTypes eDefaultTech = (TechTypes)pResource->getTechCityTrade();
		TechTypes eTech = eDefaultTech;

		if (GetPlayerTraits()->IsAlternateResourceTechs())
		{
			TechTypes eAltTech = GetPlayerTraits()->GetAlternateResourceTechs(eResource).m_eTechCityTrade;
			if (eAltTech != NO_TECH)
			{
				eTech = eAltTech;
			}
		}

		if (eTech == NO_TECH || HasTech(eTech))
		{
			return true;
		}

		// Lastly, check for the team
		CvTeam* pTeam = &GET_TEAM(getTeam());
		if (bCheckTeam && pTeam && pTeam->getNumMembers() > 1)
		{
			return pTeam->IsResourceCityTradeable(eResource);
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
//	--------------------------------------------------------------------------------
/// Does this player, or his/her team, have the reveal tech or policy for eResource?
bool CvPlayer::IsResourceRevealed(ResourceTypes eResource, bool bCheckTeam) const
{
	CvResourceInfo* pResource = GC.getResourceInfo(eResource);

	if (pResource)
	{
		// First, check for the player's tech
		TechTypes eDefaultTech = (TechTypes)pResource->getTechReveal();
		TechTypes eTech = eDefaultTech;

#if defined(MOD_BALANCE_CORE)
		if (GetPlayerTraits()->IsAlternateResourceTechs())
		{
			TechTypes eAltTech = GetPlayerTraits()->GetAlternateResourceTechs(eResource).m_eTechReveal;
			if (eAltTech != NO_TECH)
			{
				eTech = eAltTech;
			}
		}
#endif
		// Then, check for the player's policy
		PolicyTypes ePolicy = (PolicyTypes)pResource->getPolicyReveal();

		if ((eTech == NO_TECH || HasTech(eTech)) && (ePolicy == NO_POLICY || HasPolicy(ePolicy)))
		{
			return true;
		}

		// Lastly, check for the team
		CvTeam* pTeam = &GET_TEAM(getTeam());
		if (bCheckTeam && pTeam && pTeam->getNumMembers() > 1)
		{
			return pTeam->IsResourceRevealed(eResource);
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
//	--------------------------------------------------------------------------------
/// What is the best improvement that connects eResource for this player (does it need to be Civ-Specific)?
CvImprovementEntry* CvPlayer::GetResourceImprovement(ResourceTypes eResource, bool bCivSpecific) const
{
	CvImprovementEntry* pBestImprovement = NULL;
	for (int iJ = 0; iJ < GC.getNumBuildInfos(); iJ++)
	{
		BuildTypes eBuild = ((BuildTypes)iJ);
		if (eBuild == NO_BUILD)
			continue;

		CvBuildInfo* pkBuildInfo = GC.getBuildInfo(eBuild);
		if (!pkBuildInfo)
			continue;

		ImprovementTypes eUniqueImprovement = (ImprovementTypes)pkBuildInfo->getImprovement();
		if (eUniqueImprovement == NO_IMPROVEMENT)
			continue;

		CvImprovementEntry* pkImprovementInfo = GC.getImprovementInfo(eUniqueImprovement);
		if (pkImprovementInfo->IsConnectsResource(eResource))
		{
			// immediately return a civ-specific resource improvement
			if (pkImprovementInfo->IsSpecificCivRequired() && IsCivilization(pkImprovementInfo->GetRequiredCivilization()))
			{
				return pkImprovementInfo;
			}
			// store current improvement to be used later if we don't find a civ-specific improvement
			else if (!bCivSpecific)
			{
				pBestImprovement = pkImprovementInfo;
			}
		}
	}

	return pBestImprovement;
}

//	--------------------------------------------------------------------------------
//	--------------------------------------------------------------------------------
/// Do we get copies of each type of luxury connected by eFromPlayer?
int CvPlayer::getSiphonLuxuryCount(PlayerTypes eFromPlayer) const
{
	CvAssertMsg(eFromPlayer >= 0, "eFromPlayer is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFromPlayer < MAX_PLAYERS, "eFromPlayer is expected to be within maximum bounds (invalid Index)");

	return m_aiSiphonLuxuryCount[eFromPlayer];
}

//	--------------------------------------------------------------------------------
/// Change number of copies we get of luxury types connected by eFromPlayer
void CvPlayer::changeSiphonLuxuryCount(PlayerTypes eFromPlayer, int iChange)
{
	CvAssertMsg(eFromPlayer >= 0, "eFromPlayer is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFromPlayer < MAX_PLAYERS, "eFromPlayer is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiSiphonLuxuryCount[eFromPlayer] = m_aiSiphonLuxuryCount[eFromPlayer] + iChange;
		CvAssert(getSiphonLuxuryCount(eFromPlayer) >= 0);

		UpdateResourcesSiphoned();
	}
}


//	--------------------------------------------------------------------------------
/// Count up the number of resources we have been siphoning from others and compare it to how many 
/// we are now allowed to siphon.  Change our resource count if there is a discrepancy.
void CvPlayer::UpdateResourcesSiphoned()
{
	vector<int> vDeltas;
	
	// Subtract all currently siphoned resources
	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
		vDeltas.push_back(-1 * getResourceSiphoned(eResourceLoop));
	}

	// Add back in valid siphoned resources
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes ePlayerLoop = (PlayerTypes) iPlayerLoop;
		int iSiphonLuxuryCount = getSiphonLuxuryCount(ePlayerLoop);
		if (iSiphonLuxuryCount > 0)
		{
			for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
			{
				ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
				CvResourceInfo* pInfo = GC.getResourceInfo(eResourceLoop);
				// Is it a luxury?
				if (pInfo && pInfo->getResourceUsage() == RESOURCEUSAGE_LUXURY)
				{
					// Do they have at least one of this type, even if it was exported?
					if (GET_PLAYER(ePlayerLoop).getNumResourceTotal(eResourceLoop, /*bIncludeImport*/ false) > 0 || GET_PLAYER(ePlayerLoop).getResourceExport(eResourceLoop) > 0)
					{
						vDeltas[eResourceLoop] += iSiphonLuxuryCount;
					}
				}
			}
		}
	}

	// Propagate any actual changes
	for (uint i = 0; i < vDeltas.size(); i++)
	{
		if (vDeltas[i] != 0)
		{
			ResourceTypes eResource = (ResourceTypes) i;
			changeResourceSiphoned(eResource, vDeltas[i]);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Are we over our resource limit? If so, give out a notification
void CvPlayer::DoTestOverResourceNotification(ResourceTypes eIndex)
{
	if((getNumResourceAvailable(eIndex, true) < 0) && (getNumResourceUsed(eIndex) > 0))
	{
		//Flip the amount available as our drain pool - helper for cities to prevent empire wide drop.
		setResourceShortageValue(eIndex, (getNumResourceAvailable(eIndex, true) * -1));
		int iUnitLoop;
		CvUnit* pLoopUnit = NULL;

		// Test
		bool bTest = false;
		for(pLoopUnit = firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iUnitLoop))
		{
			if(!pLoopUnit)
			{
				continue;
			}
			CvUnitEntry* pkUnitInfo = GC.getUnitInfo(pLoopUnit->getUnitType());
			if(pkUnitInfo)
			{
				if(pkUnitInfo->GetResourceQuantityRequirement(eIndex) > 0)
				{
					bTest = true;
					break;
				}
			}
		}
		if(!bTest)
			return;

		const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eIndex);
		if(pkResourceInfo != NULL && pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)
		{
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_OVER_RESOURCE_LIMIT");
				strText << pkResourceInfo->GetTextKey();
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_OVER_RESOURCE_LIMIT");
				strSummary << pkResourceInfo->GetTextKey();
				pNotifications->Add(NOTIFICATION_DISCOVERED_STRATEGIC_RESOURCE, strText.toUTF8(), strSummary.toUTF8(), -1, -1, eIndex);
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Is our collection of Strategic Resources modified?
int CvPlayer::GetStrategicResourceMod() const
{
	return m_iStrategicResourceMod;
}

//	--------------------------------------------------------------------------------
/// Is our collection of Strategic Resources modified?
void CvPlayer::ChangeStrategicResourceMod(int iChange)
{
	m_iStrategicResourceMod += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNumResourceAvailable(ResourceTypes eIndex, bool bIncludeImport) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return getNumResourceTotal(eIndex, bIncludeImport) - getNumResourceUsed(eIndex);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getResourceGiftedToMinors(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiResourceGiftedToMinors[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceGiftedToMinors(ResourceTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiResourceGiftedToMinors[eIndex] = m_paiResourceGiftedToMinors[eIndex] + iChange;
		CvAssert(getResourceGiftedToMinors(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getResourceExport(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiResourceExport[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceExport(ResourceTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiResourceExport[eIndex] = m_paiResourceExport[eIndex] + iChange;

		if (m_paiResourceExport[eIndex] <= 0)
			m_paiResourceExport[eIndex] = 0;

		CvAssert(getResourceExport(eIndex) >= 0);

		CalculateNetHappiness();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getResourceImportFromMajor(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiResourceImportFromMajor[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceImportFromMajor(ResourceTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiResourceImportFromMajor[eIndex] = m_paiResourceImportFromMajor[eIndex] + iChange;

		if (m_paiResourceImportFromMajor[eIndex] <= 0)
			m_paiResourceImportFromMajor[eIndex] = 0;

		CvAssert(getResourceImportFromMajor(eIndex) >= 0);

		CalculateNetHappiness();

		if (GetPlayerTraits()->IsImportsCountTowardsMonopolies())
		{
			CheckForMonopoly(eIndex);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getResourceFromMinors(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	int iNumResourceFromMinors = m_paiResourceFromMinors[eIndex];

	// Resource bonus doubles quantity of Resources from Minors (Policies, etc.)
	if (IsMinorResourceBonus())
	{
		iNumResourceFromMinors *= /*200*/ GD_INT_GET(MINOR_POLICY_RESOURCE_MULTIPLIER);
		iNumResourceFromMinors /= 100;
	}

	return iNumResourceFromMinors;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceFromMinors(ResourceTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiResourceFromMinors[eIndex] = m_paiResourceFromMinors[eIndex] + iChange;
		CvAssert(getResourceFromMinors(eIndex) >= 0);

		CalculateNetHappiness();

		if (IsCSResourcesCountMonopolies())
			CheckForMonopoly(eIndex);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getResourceSiphoned(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	int iNumResourceSiphoned = m_paiResourcesSiphoned[eIndex];

	return iNumResourceSiphoned;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceSiphoned(ResourceTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_paiResourcesSiphoned[eIndex] = m_paiResourcesSiphoned[eIndex] + iChange;
		CvAssert(getResourceSiphoned(eIndex) >= 0);

		CalculateNetHappiness();
	}
}

//	--------------------------------------------------------------------------------
byte CvPlayer::getResourceFromGP(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	return m_aiNumResourceFromGP[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceFromGP(ResourceTypes eIndex, byte iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiNumResourceFromGP[eIndex] = m_aiNumResourceFromGP[eIndex] + iChange;
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getResourceInOwnedPlots(ResourceTypes eIndex)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	int iCount = 0;

	// go through all the plots the player has under their control
	for (PlotIndexContainer::const_iterator it = m_aiPlots.begin(); it != m_aiPlots.end(); ++it)
	{
		CvPlot* pPlot = GC.getMap().plotByIndex(*it);
		if (pPlot && pPlot->getResourceType(getTeam()) == eIndex)
		{
			iCount++;
		}
	}

	return iCount;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getTotalImprovementsBuilt() const
{
	return m_iTotalImprovementsBuilt;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeTotalImprovementsBuilt(int iChange)
{
	m_iTotalImprovementsBuilt = (m_iTotalImprovementsBuilt + iChange);
	CvAssert(getTotalImprovementsBuilt() >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getImprovementCount(ImprovementTypes eIndex, bool bBuiltOnly) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumImprovementInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	if (bBuiltOnly)
		return m_paiImprovementBuiltCount[eIndex];
	else
		return m_paiImprovementCount[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeImprovementCount(ImprovementTypes eIndex, int iChange, bool bBuilt)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumImprovementInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	
	m_paiImprovementCount[eIndex] += iChange;
	CvAssert(getImprovementCount(eIndex) >= 0);

	if (bBuilt)
	{
		m_paiImprovementBuiltCount[eIndex] += iChange;
		CvAssert(getImprovementCount(eIndex, true) >= 0);
	}
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvPlayer::getTotalImprovementsBuilt(ImprovementTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumImprovementInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiTotalImprovementsBuilt[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeTotalImprovementsBuilt(ImprovementTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumImprovementInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	m_paiTotalImprovementsBuilt[eIndex] = m_paiTotalImprovementsBuilt[eIndex] + iChange;
	CvAssert(getTotalImprovementsBuilt(eIndex) >= 0);
}
#endif

#if defined(MOD_IMPROVEMENTS_EXTENSIONS)
//	--------------------------------------------------------------------------------
int CvPlayer::getResponsibleForRouteCount(RouteTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumRouteInfos() , "eIndex is expected to be within maximum bounds (invalid Index)");

	std::map<RouteTypes, int>::const_iterator it = m_piResponsibleForRouteCount.find(eIndex);
	if (it != m_piResponsibleForRouteCount.end()) // find returns the iterator to map::end if the key eIndex is not present in the map
	{
		return it->second;
	}

	return 0;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeResponsibleForRouteCount(RouteTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumRouteInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	
	m_piResponsibleForRouteCount[eIndex] += iChange;

	if (m_piResponsibleForRouteCount[eIndex] == 0) // no point allocating memory since we assume 0 by default
	{
		m_piResponsibleForRouteCount.erase(eIndex);
	}

	CvAssert(getResponsibleForRouteCount(eIndex) >= 0);
}
//	--------------------------------------------------------------------------------
int CvPlayer::getResponsibleForImprovementCount(ImprovementTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumImprovementInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	std::map<ImprovementTypes, int>::const_iterator it = m_piResponsibleForImprovementCount.find(eIndex);
	if (it != m_piResponsibleForImprovementCount.end()) // find returns the iterator to map::end if the key eIndex is not present in the map
	{
		return it->second;
	}

	return 0;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeResponsibleForImprovementCount(ImprovementTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumImprovementInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	m_piResponsibleForImprovementCount[eIndex] += iChange;

	if (m_piResponsibleForImprovementCount[eIndex] == 0) // no point allocating memory since we assume 0 by default
	{
		m_piResponsibleForImprovementCount.erase(eIndex);
	}

	CvAssert(getResponsibleForImprovementCount(eIndex) >= 0);
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatPersonImprovementCount()
{
	int iCount = 0;
	for (int i = 0; i < GC.getNumImprovementInfos(); i++)
	{
		ImprovementTypes e = (ImprovementTypes)i;
		CvImprovementEntry* pInfo = GC.getImprovementInfo(e);
		if (pInfo && pInfo->IsCreatedByGreatPerson())
		{
			iCount += getImprovementCount(e);
		}
	}
	return iCount;
}


//	--------------------------------------------------------------------------------
int CvPlayer::getFreeBuildingCount(BuildingTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiFreeBuildingCount[eIndex];
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isBuildingFree(BuildingTypes eIndex)	const
{
	return (getFreeBuildingCount(eIndex) > 0);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeFreeBuildingCount(BuildingTypes eIndex, int iChange)
{
	CvCity* pLoopCity;
	int iOldFreeBuildingCount;
	int iLoop;

	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		iOldFreeBuildingCount = getFreeBuildingCount(eIndex);

		m_paiFreeBuildingCount[eIndex] = m_paiFreeBuildingCount[eIndex] + iChange;
		CvAssert(getFreeBuildingCount(eIndex) >= 0);

		if(iOldFreeBuildingCount == 0)
		{
			CvAssertMsg(getFreeBuildingCount(eIndex) > 0, "getFreeBuildingCount(eIndex) is expected to be greater than 0");

			for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				pLoopCity->GetCityBuildings()->SetNumFreeBuilding(eIndex, 1);
			}
		}
		else if(getFreeBuildingCount(eIndex) == 0)
		{
			CvAssertMsg(iOldFreeBuildingCount > 0, "iOldFreeBuildingCount is expected to be greater than 0");

			for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				pLoopCity->GetCityBuildings()->SetNumFreeBuilding(eIndex, 0);
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// How many sources have added ePromotion as a free promotion?
int CvPlayer::GetFreePromotionCount(PromotionTypes ePromotion) const
{
	CvAssertMsg(ePromotion >= 0, "ePromotion is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePromotion < GC.getNumPromotionInfos(), "ePromotion is expected to be within maximum bounds (invalid Index)");
	return m_paiFreePromotionCount[ePromotion];
}

//	--------------------------------------------------------------------------------
/// Is ePromotion a free promotion?
bool CvPlayer::IsFreePromotion(PromotionTypes ePromotion)	const
{
	return (GetFreePromotionCount(ePromotion) > 0);
}

//	--------------------------------------------------------------------------------
/// Add another source of ePromotion to the free promotion list
void CvPlayer::ChangeFreePromotionCount(PromotionTypes ePromotion, int iChange)
{
	CvAssertMsg(ePromotion >= 0, "ePromotion is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePromotion < GC.getNumPromotionInfos(), "ePromotion is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		bool bWasFree = IsFreePromotion(ePromotion);

		m_paiFreePromotionCount[ePromotion] = m_paiFreePromotionCount[ePromotion] + iChange;

		CvAssert(GetFreePromotionCount(ePromotion) >= 0);

		// This promotion is now set to be free, but wasn't before we called this function
		if(IsFreePromotion(ePromotion) && !bWasFree)
		{
			// Loop through Units
			CvUnit* pLoopUnit;

			int iLoop;
			for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
			{
				// Valid Promotion for this Unit?
				if(::IsPromotionValidForUnitCombatType(ePromotion, pLoopUnit->getUnitType()))
				{
					pLoopUnit->setHasPromotion(ePromotion, true);
				}

				else if(::IsPromotionValidForCivilianUnitType(ePromotion, pLoopUnit->getUnitType()))
				{
					pLoopUnit->setHasPromotion(ePromotion, true);
				}
			}
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getUnitCombatProductionModifiers(UnitCombatTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitCombatClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiUnitCombatProductionModifiers[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeUnitCombatProductionModifiers(UnitCombatTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitCombatClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiUnitCombatProductionModifiers[eIndex] = m_paiUnitCombatProductionModifiers[eIndex] + iChange;
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getUnitCombatFreeExperiences(UnitCombatTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitCombatClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiUnitCombatFreeExperiences[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeUnitCombatFreeExperiences(UnitCombatTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitCombatClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiUnitCombatFreeExperiences[eIndex] = m_paiUnitCombatFreeExperiences[eIndex] + iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getUnitClassCount(UnitClassTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiUnitClassCount[eIndex];
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isUnitClassMaxedOut(UnitClassTypes eIndex, int iExtra) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eIndex);
	if(pkUnitClassInfo == NULL)
	{
		return false;
	}

#if defined(MOD_BALANCE_CORE)
	if(isUnitLimitPerCity(eIndex))
	{
		CvAssertMsg(getUnitClassCount(eIndex) <= (getNumCities() * pkUnitClassInfo->getUnitInstancePerCity()), "getUnitInstancePerCity is expected to be less than maximum bound of UnitInstancePerCity (invalid index)");
		return ((getUnitClassCount(eIndex) + iExtra) >= (getNumCities() * pkUnitClassInfo->getUnitInstancePerCity()));
	}
	else if(isNationalUnitClass(eIndex))
	{
		CvAssertMsg(getUnitClassCount(eIndex) <= pkUnitClassInfo->getMaxPlayerInstances(), "getUnitClassCount is expected to be less than maximum bound of MaxPlayerInstances (invalid index)");
		return ((getUnitClassCount(eIndex) + iExtra) >= pkUnitClassInfo->getMaxPlayerInstances());
	}
	else
	{
		return false;
	}
#else
	if(!isNationalUnitClass(eIndex))
	{
		return false;
	}

	CvAssertMsg(getUnitClassCount(eIndex) <= pkUnitClassInfo->getMaxPlayerInstances(), "getUnitClassCount is expected to be less than maximum bound of MaxPlayerInstances (invalid index)");

	return ((getUnitClassCount(eIndex) + iExtra) >= pkUnitClassInfo->getMaxPlayerInstances());
#endif
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeUnitClassCount(UnitClassTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	m_paiUnitClassCount[eIndex] = m_paiUnitClassCount[eIndex] + iChange;
	CvAssert(getUnitClassCount(eIndex) >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getUnitClassMaking(UnitClassTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiUnitClassMaking[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeUnitClassMaking(UnitClassTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiUnitClassMaking[eIndex] = m_paiUnitClassMaking[eIndex] + iChange;
		CvAssert(getUnitClassMaking(eIndex) >= 0);

		const CvCivilizationInfo& playerCivilizationInfo = getCivilizationInfo();
		UnitTypes eUnit = static_cast<UnitTypes>(playerCivilizationInfo.getCivilizationUnits(eIndex));
		CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
		if(pkUnitInfo)
		{
			// Builder Limit
			if(pkUnitInfo->GetWorkRate() > 0 && pkUnitInfo->GetDomainType() == DOMAIN_LAND)
			{
				ChangeNumBuilders(iChange);
			}

			// Update the amount of a Resource used up by Units in Production
			for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
			{
				ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);
				CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
				if(pkResource)
				{
					if(pkUnitInfo->GetResourceQuantityRequirement(iResourceLoop) > 0)
					{
						changeNumResourceUsed(eResource, iChange * pkUnitInfo->GetResourceQuantityRequirement(iResourceLoop));
					}
				}
			}

			if(GetID() == GC.getGame().getActivePlayer())
			{
				GC.GetEngineUserInterface()->setDirty(Help_DIRTY_BIT, true);
			}
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getUnitClassCountPlusMaking(UnitClassTypes eIndex) const
{
	return (getUnitClassCount(eIndex) + getUnitClassMaking(eIndex));
}


//	--------------------------------------------------------------------------------
int CvPlayer::getBuildingClassCount(BuildingClassTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiBuildingClassCount[eIndex];
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isBuildingClassMaxedOut(BuildingClassTypes eIndex, int iExtra) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eIndex);
	if(pkBuildingClassInfo == NULL)
	{
		CvAssertMsg(false, "This should never happen...");
		return false;
	}

	if(!isNationalWonderClass(*pkBuildingClassInfo))
	{
		return false;
	}

	CvAssertMsg(getBuildingClassCount(eIndex) <= (pkBuildingClassInfo->getMaxPlayerInstances() + pkBuildingClassInfo->getExtraPlayerInstances()), "BuildingClassCount is expected to be less than or match the number of max player instances plus extra player instances");

	return ((getBuildingClassCount(eIndex) + iExtra) >= (pkBuildingClassInfo->getMaxPlayerInstances() + pkBuildingClassInfo->getExtraPlayerInstances()));
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeBuildingClassCount(BuildingClassTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	m_paiBuildingClassCount[eIndex] = m_paiBuildingClassCount[eIndex] + iChange;
	CvAssert(getBuildingClassCount(eIndex) >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getBuildingClassMaking(BuildingClassTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiBuildingClassMaking[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeBuildingClassMaking(BuildingClassTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiBuildingClassMaking[eIndex] = m_paiBuildingClassMaking[eIndex] + iChange;
		CvAssert(getBuildingClassMaking(eIndex) >= 0);

		const BuildingTypes eBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eIndex);
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
		if(pkBuildingInfo)
		{
			// Update the amount of a Resource used up by Buildings in Production
			for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
			{
				const ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);
				CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);
				if(pkResourceInfo)
				{
					if(pkBuildingInfo->GetResourceQuantityRequirement(iResourceLoop) > 0)
					{
						changeNumResourceUsed(eResource, iChange * pkBuildingInfo->GetResourceQuantityRequirement(iResourceLoop));
					}
				}

			}
		}


		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Help_DIRTY_BIT, true);
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getBuildingClassCountPlusMaking(BuildingClassTypes eIndex) const
{
	return (getBuildingClassCount(eIndex) + getBuildingClassMaking(eIndex));
}


//	--------------------------------------------------------------------------------
// The following two functions are only used to keep track of how many Projects are in progress so we know what each player's Resource situation is
// Check out CvTeam::getProjectMaking() for something used more
int CvPlayer::getProjectMaking(ProjectTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiProjectMaking[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeProjectMaking(ProjectTypes eIndex, int iChange, CvCity* pCity)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiProjectMaking[eIndex] = m_paiProjectMaking[eIndex] + iChange;
		CvAssert(getProjectMaking(eIndex) >= 0);

		// Update the amount of a Resource used up by Projects in Production
		for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
		{
			if(GC.getProjectInfo(eIndex)->GetResourceQuantityRequirement(iResourceLoop) > 0)
			{
				changeNumResourceUsed((ResourceTypes) iResourceLoop, iChange * GC.getProjectInfo(eIndex)->GetResourceQuantityRequirement(iResourceLoop));
			}
		}

		if (iChange > 0)
		{
			ProjectTypes eUtopia = (ProjectTypes)GC.getInfoTypeForString("PROJECT_UTOPIA_PROJECT", true);
			if (eUtopia == eIndex)
			{
				int iNumTurns = pCity != NULL ? pCity->getProductionTurnsLeft() : -1;
				PlayerTypes ePlayer;
				for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
				{
					ePlayer = (PlayerTypes)iPlayerLoop;

					if (GC.getGame().getActivePlayer() != ePlayer)
					{
						CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();
						if (pNotifications)
						{
							Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_PROJECT_STARTED");
							strText << getNameKey();
							strText << GC.getProjectInfo(eIndex)->GetDescription();
							strText << iNumTurns;
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_PROJECT_STARTED_S");
							strSummary << GC.getProjectInfo(eIndex)->GetDescription();
							pNotifications->Add(NOTIFICATION_CULTURE_VICTORY_WITHIN_ONE, strText.toUTF8(), strSummary.toUTF8(), -1, -1, ePlayer);
						}
					}
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getHurryCount(HurryTypes eIndex) const
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumHurryInfos());
	return m_paiHurryCount[eIndex];
}


//	--------------------------------------------------------------------------------
// Do we have access to this Hurry type?
bool CvPlayer::IsHasAccessToHurry(HurryTypes eIndex) const
{
	return (getHurryCount(eIndex) > 0);
}

//	--------------------------------------------------------------------------------
/// Can we use this Hurry RIGHT NOW?
bool CvPlayer::IsCanHurry(HurryTypes eIndex) const
{
	CvHurryInfo* pkHurryInfo = GC.getHurryInfo(eIndex);
	if(pkHurryInfo == NULL)
		return false;

	int iCost = GetHurryGoldCost(eIndex);

	// Can we pay for this Hurry?
	if(iCost < 0 || GetTreasury()->GetGold() < iCost)
	{
		return false;
	}

	// Science Rushing
	if(pkHurryInfo->getGoldPerBeaker() > 0)
	{
		return true;
	}

	// Culture Rushing
	if(pkHurryInfo->getGoldPerCulture() > 0)
	{
		// If we already have enough Culture for the next Policy, there's nothing to rush!
		if(getNextPolicyCost() > getJONSCulture())
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
/// How much Gold does it cost us to Hurry? (whatever the applicable item is)
int CvPlayer::GetHurryGoldCost(HurryTypes eHurry) const
{
	int iGold = -1;

	CvHurryInfo* pkHurryInfo = GC.getHurryInfo(eHurry);
	if(pkHurryInfo == NULL)
	{
		//This should never happen.
		return -1;
	}

	// Science Rushing
	if(pkHurryInfo->getGoldPerBeaker() > 0)
	{
		TechTypes eTech = GetPlayerTechs()->GetCurrentResearch();

		if(eTech != NO_TECH)
		{
			int iTotalCost = GET_TEAM(getTeam()).GetTeamTechs()->GetResearchCost(eTech);
			int iResearchLeft = GET_TEAM(getTeam()).GetTeamTechs()->GetResearchLeft(eTech);

			// Cost of Gold rushing based on the ORIGINAL Research price
			int iGoldForFullPrice = iTotalCost * pkHurryInfo->getGoldPerBeaker();
			iGoldForFullPrice = (int) pow((double) iGoldForFullPrice, (double) /*1.10f*/ GD_FLOAT_GET(HURRY_GOLD_TECH_EXPONENT));

			// Figure out the actual cost by comparing what's left to the original Research cost, and multiplying that by the amount to Gold rush the original cost
			iGold = (iGoldForFullPrice * iResearchLeft / iTotalCost);
		}
	}

	// Culture Rushing
	if(pkHurryInfo->getGoldPerCulture() > 0)
	{
		int iCurrentPolicyCost = getNextPolicyCost();

		if(iCurrentPolicyCost > 0)
		{
			int iCultureLeft = iCurrentPolicyCost - getJONSCulture();

			// Cost of Gold rushing based on the ORIGINAL Culture price
			int iGoldForFullPrice = iCurrentPolicyCost * pkHurryInfo->getGoldPerCulture();
			iGoldForFullPrice = (int) pow((double) iGoldForFullPrice, (double) /*1.10f*/ GD_FLOAT_GET(HURRY_GOLD_CULTURE_EXPONENT));

			// Figure out the actual cost by comparing what's left to the original Culture cost, and multiplying that by the amount to Gold rush the original cost
			iGold = (iGoldForFullPrice * iCultureLeft / iCurrentPolicyCost);
		}
	}

	return iGold;
}

//	--------------------------------------------------------------------------------
/// Hurry something!
void CvPlayer::DoHurry(HurryTypes eIndex)
{
	CvHurryInfo* pkHurryInfo = GC.getHurryInfo(eIndex);
	if(pkHurryInfo)
	{
		if(IsCanHurry(eIndex))
		{
			int iGoldCost = GetHurryGoldCost(eIndex);
			GetTreasury()->ChangeGold(-iGoldCost);

			// Science Rushing
			if(pkHurryInfo->getGoldPerBeaker() > 0)
			{
				TechTypes eTech = GetPlayerTechs()->GetCurrentResearch();

				GET_TEAM(getTeam()).setHasTech(eTech, true, GetID(), false, false);
			}

			// Culture Rushing
			if(pkHurryInfo->getGoldPerCulture() > 0)
			{
				setJONSCulture(getNextPolicyCost());
			}
		}
	}
}


//	--------------------------------------------------------------------------------
bool CvPlayer::canPopRush()
{
	return (m_iPopRushHurryCount > 0);
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeHurryCount(HurryTypes eIndex, int iChange)
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumHurryInfos());

	int oldHurryCount = m_paiHurryCount[eIndex];
	m_paiHurryCount[eIndex] = m_paiHurryCount[eIndex] + iChange;
	CvAssert(getHurryCount(eIndex) >= 0);

	CvHurryInfo* pkHurryInfo = GC.getHurryInfo(eIndex);
	if(pkHurryInfo == NULL)
		return;

	// if we just went from 0 to 1 (or the reverse)
	if((oldHurryCount > 0) != (m_paiHurryCount[eIndex] > 0))
	{
		// does this hurry reduce population?
		if(pkHurryInfo->getProductionPerPopulation() > 0)
		{
			m_iPopRushHurryCount += iChange;
			CvAssert(m_iPopRushHurryCount >= 0);
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getHurryModifier(HurryTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumHurryInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiHurryModifier[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeHurryModifier(HurryTypes eIndex, int iChange)
{
	if(iChange != 0)
	{
		CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
		CvAssertMsg(eIndex < GC.getNumHurryInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
		m_paiHurryModifier[eIndex] = m_paiHurryModifier[eIndex] + iChange;
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::setResearchingTech(TechTypes eIndex, bool bNewValue)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(m_pPlayerTechs->IsResearchingTech(eIndex) != bNewValue)
	{
		GetPlayerTechs()->SetResearchingTech(eIndex, bNewValue);

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Popup_DIRTY_BIT, true); // to check whether we still need the tech chooser popup
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getSpecialistExtraYield(SpecialistTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 expected to be >= 0");
	CvAssertMsg(eIndex1 < GC.getNumSpecialistInfos(), "eIndex1 expected to be < GC.getNumSpecialistInfos()");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 expected to be >= 0");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 expected to be < NUM_YIELD_TYPES");
	return m_ppaaiSpecialistExtraYield[eIndex1][eIndex2];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeSpecialistExtraYield(SpecialistTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 expected to be >= 0");
	CvAssertMsg(eIndex1 < GC.getNumSpecialistInfos(), "eIndex1 expected to be < GC.getNumSpecialistInfos()");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 expected to be >= 0");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 expected to be < NUM_YIELD_TYPES");

	if(iChange != 0)
	{
		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppaaiSpecialistExtraYield[eIndex1];
		yields[eIndex2] = (m_ppaaiSpecialistExtraYield[eIndex1][eIndex2] + iChange);
		m_ppaaiSpecialistExtraYield[eIndex1] = yields;
		CvAssert(getSpecialistExtraYield(eIndex1, eIndex2) >= 0);

		updateExtraSpecialistYield();
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromYieldGlobal(YieldTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 expected to be >= 0");
	CvAssertMsg(eIndex1 < NUM_YIELD_TYPES, "eIndex1 expected to be < NUM_YIELD_TYPES");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 expected to be >= 0");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 expected to be < NUM_YIELD_TYPES");
	return m_ppiYieldFromYieldGlobal[eIndex1][eIndex2];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromYieldGlobal(YieldTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 expected to be >= 0");
	CvAssertMsg(eIndex1 < NUM_YIELD_TYPES, "eIndex1 expected to be < NUM_YIELD_TYPES");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 expected to be >= 0");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiYieldFromYieldGlobal[eIndex1];
		yields[eIndex2] = (m_ppiYieldFromYieldGlobal[eIndex1][eIndex2] + iChange);
		m_ppiYieldFromYieldGlobal[eIndex1] = yields;
		CvAssert(getYieldFromYieldGlobal(eIndex1, eIndex2) >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getPlotYieldChange(PlotTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumPlotInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiPlotYieldChange[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changePlotYieldChange(PlotTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumPlotInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiPlotYieldChange[eIndex1];
		yields[eIndex2] = (m_ppiPlotYieldChange[eIndex1][eIndex2] + iChange);
		m_ppiPlotYieldChange[eIndex1] = yields;
		CvAssert(getPlotYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getFeatureYieldChange(FeatureTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiFeatureYieldChange[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeFeatureYieldChange(FeatureTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiFeatureYieldChange[eIndex1];
		yields[eIndex2] = (m_ppiFeatureYieldChange[eIndex1][eIndex2] + iChange);
		m_ppiFeatureYieldChange[eIndex1] = yields;
		CvAssert(getFeatureYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getCityYieldFromUnimprovedFeature(FeatureTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiCityYieldFromUnimprovedFeature[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeCityYieldFromUnimprovedFeature(FeatureTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number.");

		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiCityYieldFromUnimprovedFeature[eIndex1];
		yields[eIndex2] = (m_ppiCityYieldFromUnimprovedFeature[eIndex1][eIndex2] + iChange);
		m_ppiCityYieldFromUnimprovedFeature[eIndex1] = yields;
		CvAssert(getCityYieldFromUnimprovedFeature(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getUnimprovedFeatureYieldChange(FeatureTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiUnimprovedFeatureYieldChange[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeUnimprovedFeatureYieldChange(FeatureTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number.");

		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiUnimprovedFeatureYieldChange[eIndex1];
		yields[eIndex2] = (m_ppiUnimprovedFeatureYieldChange[eIndex1][eIndex2] + iChange);
		m_ppiUnimprovedFeatureYieldChange[eIndex1] = yields;
		CvAssert(getUnimprovedFeatureYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getResourceYieldChange(ResourceTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumResourceInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiResourceYieldChange[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceYieldChange(ResourceTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumResourceInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiResourceYieldChange[eIndex1];
		yields[eIndex2] = (m_ppiResourceYieldChange[eIndex1][eIndex2] + iChange);
		m_ppiResourceYieldChange[eIndex1] = yields;
		CvAssert(getResourceYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getTerrainYieldChange(TerrainTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumTerrainInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiTerrainYieldChange[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeTerrainYieldChange(TerrainTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumTerrainInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiTerrainYieldChange[eIndex1];
		yields[eIndex2] = (m_ppiTerrainYieldChange[eIndex1][eIndex2] + iChange);
		m_ppiTerrainYieldChange[eIndex1] = yields;
		CvAssert(getTerrainYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getTradeRouteYieldChange(DomainTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < NUM_DOMAIN_TYPES, "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiTradeRouteYieldChange[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeTradeRouteYieldChange(DomainTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < NUM_DOMAIN_TYPES, "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiTradeRouteYieldChange[eIndex1];
		yields[eIndex2] = (m_ppiTradeRouteYieldChange[eIndex1][eIndex2] + iChange);
		m_ppiTradeRouteYieldChange[eIndex1] = yields;
		CvAssert(getTradeRouteYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getSpecialistYieldChange(SpecialistTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumSpecialistInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiSpecialistYieldChange[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeSpecialistYieldChange(SpecialistTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumSpecialistInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiSpecialistYieldChange[eIndex1];
		yields[eIndex2] = (m_ppiSpecialistYieldChange[eIndex1][eIndex2] + iChange);
		m_ppiSpecialistYieldChange[eIndex1] = yields;
		CvAssert(getSpecialistYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatPersonExpendedYield(GreatPersonTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumGreatPersonInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiGreatPersonExpendedYield[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGreatPersonExpendedYield(GreatPersonTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumGreatPersonInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiGreatPersonExpendedYield[eIndex1];
		yields[eIndex2] = (m_ppiGreatPersonExpendedYield[eIndex1][eIndex2] + iChange);
		m_ppiGreatPersonExpendedYield[eIndex1] = yields;
		CvAssert(getGreatPersonExpendedYield(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGoldenAgeGreatPersonRateModifier(GreatPersonTypes eGreatPerson) const
{
	CvAssertMsg(eGreatPerson >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eGreatPerson < GC.getNumGreatPersonInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piGoldenAgeGreatPersonRateModifier[eGreatPerson];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGoldenAgeGreatPersonRateModifier(GreatPersonTypes eGreatPerson, int iChange)
{
	CvAssertMsg(eGreatPerson >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eGreatPerson < GC.getNumGreatPersonInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_piGoldenAgeGreatPersonRateModifier[eGreatPerson] += iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetYieldFromKills(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piYieldFromKills[eYield];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromKills(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_piYieldFromKills[eYield] += iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetYieldFromBarbarianKills(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piYieldFromBarbarianKills[eYield];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromBarbarianKills(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_piYieldFromBarbarianKills[eYield] += iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetYieldChangeTradeRoute(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piYieldChangeTradeRoute[eYield];
}

void CvPlayer::ChangeYieldChangeTradeRoute(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_piYieldChangeTradeRoute[eYield] += iChange;

		updateYield();
	}
}

int CvPlayer::GetYieldChangesNaturalWonder(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piYieldChangesNaturalWonder[eYield];
}

void CvPlayer::ChangeYieldChangesNaturalWonder(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_piYieldChangesNaturalWonder[eYield] += iChange;

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetYieldChangesPerReligionTimes100(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	return m_piYieldChangesPerReligion[eYield];
}

void CvPlayer::ChangeYieldChangesPerReligionTimes100(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_piYieldChangesPerReligion[eYield] += iChange;

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetYieldChangeWorldWonder(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piYieldChangeWorldWonder[eYield];
}

void CvPlayer::ChangeYieldChangeWorldWonder(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_piYieldChangeWorldWonder[eYield] += iChange;

		updateYield();
	}
}

int CvPlayer::GetYieldFromMinorDemand(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piYieldFromMinorDemand[eYield];
}

void CvPlayer::ChangeYieldFromMinorDemand(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_piYieldFromMinorDemand[eYield] += iChange;
	}
}

int CvPlayer::GetYieldFromWLTKD(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piYieldFromWLTKD[eYield];
}

void CvPlayer::ChangeYieldFromWLTKD(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_piYieldFromWLTKD[eYield] += iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getBuildingClassYieldChange(BuildingClassTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumBuildingClassInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiBuildingClassYieldChange[eIndex1][eIndex2];
}

// (Corp) Note to future modders: if you think this works as you expect, you're wrong. just ignore it. Use ::GetBuildingClassYieldChange() instead (note the capital), or fix this so it's functional.
// grrrr....
//	--------------------------------------------------------------------------------
void CvPlayer::changeBuildingClassYieldChange(BuildingClassTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumBuildingClassInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiBuildingClassYieldChange[eIndex1];
		yields[eIndex2] = (m_ppiBuildingClassYieldChange[eIndex1][eIndex2] + iChange);
		m_ppiBuildingClassYieldChange[eIndex1] = yields;
		CvAssert(getBuildingClassYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
/// Does the player get a great person rate modifier from having a monopoly?
//	--------------------------------------------------------------------------------
int CvPlayer::getSpecificGreatPersonRateModifierFromMonopoly(GreatPersonTypes eGreatPerson, MonopolyTypes eMonopoly) const
{
	CvAssertMsg(eGreatPerson >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eGreatPerson < GC.getNumGreatPersonInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	CvAssertMsg(eMonopoly >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eMonopoly < NUM_MONOPOLY_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (eGreatPerson != NO_GREATPERSON && eMonopoly != NO_MONOPOLY)
	{
		std::map<GreatPersonTypes, std::map<MonopolyTypes, int>>::const_iterator itGreatPerson = m_ppiSpecificGreatPersonRateModifierFromMonopoly.find(eGreatPerson);
		if (itGreatPerson != m_ppiSpecificGreatPersonRateModifierFromMonopoly.end())
		{
			std::map<MonopolyTypes, int>::const_iterator itMonopoly = itGreatPerson->second.find(eMonopoly);
			if (itMonopoly != itGreatPerson->second.end())
			{
				return itMonopoly->second;
			}
		}
	}

	return 0;
}

/// Overload to sum up modifiers from both global (including global monopoly mod percent) and strategic monopolies, for convenience
//	--------------------------------------------------------------------------------
int CvPlayer::getSpecificGreatPersonRateModifierFromMonopoly(GreatPersonTypes eGreatPerson) const
{
	CvAssertMsg(eGreatPerson >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eGreatPerson < GC.getNumGreatPersonInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	int iMod = 0;
	int iTemp = 0;
	if (eGreatPerson != NO_GREATPERSON)
	{
		for (int iI = 0; iI < NUM_MONOPOLY_TYPES; iI++)
		{
			MonopolyTypes eMonopoly = (MonopolyTypes)iI;
			if (eMonopoly != NO_MONOPOLY)
			{
				iTemp = getSpecificGreatPersonRateModifierFromMonopoly(eGreatPerson, eMonopoly);
				if (eMonopoly == MONOPOLY_GLOBAL && iTemp > 0)
				{
					iTemp += GetMonopolyModPercent();
				}
				iMod += iTemp;
			}
		}
	}

	return iMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeSpecificGreatPersonRateModifierFromMonopoly(GreatPersonTypes eGreatPerson, MonopolyTypes eMonopoly, int iChange)
{
	CvAssertMsg(eGreatPerson >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eGreatPerson < GC.getNumGreatPersonInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	CvAssertMsg(eMonopoly >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eMonopoly < NUM_MONOPOLY_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0 && eGreatPerson != NO_GREATPERSON && eMonopoly != NO_MONOPOLY)
	{
		m_ppiSpecificGreatPersonRateModifierFromMonopoly[eGreatPerson][eMonopoly] += iChange;
	}
}

/// Does the player get a great person rate modifier from having a monopoly?
//	--------------------------------------------------------------------------------
int CvPlayer::getSpecificGreatPersonRateChangeFromMonopoly(GreatPersonTypes eGreatPerson, MonopolyTypes eMonopoly) const
{
	CvAssertMsg(eGreatPerson >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eGreatPerson < GC.getNumGreatPersonInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	CvAssertMsg(eMonopoly >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eMonopoly < NUM_MONOPOLY_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (eGreatPerson != NO_GREATPERSON && eMonopoly != NO_MONOPOLY)
	{
		std::map<GreatPersonTypes, std::map<MonopolyTypes, int>>::const_iterator itGreatPerson = m_ppiSpecificGreatPersonRateChangeFromMonopoly.find(eGreatPerson);
		if (itGreatPerson != m_ppiSpecificGreatPersonRateChangeFromMonopoly.end())
		{
			std::map<MonopolyTypes, int>::const_iterator itMonopoly = itGreatPerson->second.find(eMonopoly);
			if (itMonopoly != itGreatPerson->second.end())
			{
				return itMonopoly->second;
			}
		}
	}

	return 0;
}

/// Overload to sum up modifiers from both global (including global monopoly mod flat) and strategic monopolies, for convenience
//	--------------------------------------------------------------------------------
int CvPlayer::getSpecificGreatPersonRateChangeFromMonopoly(GreatPersonTypes eGreatPerson) const
{
	CvAssertMsg(eGreatPerson >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eGreatPerson < GC.getNumGreatPersonInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	int iChange = 0;
	int iTemp = 0;
	if (eGreatPerson != NO_GREATPERSON)
	{
		for (int iI = 0; iI < NUM_MONOPOLY_TYPES; iI++)
		{
			MonopolyTypes eMonopoly = (MonopolyTypes)iI;
			if (eMonopoly != NO_MONOPOLY)
			{
				iTemp = getSpecificGreatPersonRateChangeFromMonopoly(eGreatPerson, eMonopoly);
				if (eMonopoly == MONOPOLY_GLOBAL && iTemp > 0)
				{
					iTemp += GetMonopolyModFlat();
				}
				iChange += iTemp;
			}
		}
	}

	return iChange;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeSpecificGreatPersonRateChangeFromMonopoly(GreatPersonTypes eGreatPerson, MonopolyTypes eMonopoly, int iChange)
{
	CvAssertMsg(eGreatPerson >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eGreatPerson < GC.getNumGreatPersonInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	CvAssertMsg(eMonopoly >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eMonopoly < NUM_MONOPOLY_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0 && eGreatPerson != NO_GREATPERSON && eMonopoly != NO_MONOPOLY)
	{
		m_ppiSpecificGreatPersonRateChangeFromMonopoly[eGreatPerson][eMonopoly] += iChange;
	}
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getImprovementYieldChange(ImprovementTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumImprovementInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppaaiImprovementYieldChange[eIndex1][eIndex2];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeImprovementYieldChange(ImprovementTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumImprovementInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppaaiImprovementYieldChange[eIndex1];
		yields[eIndex2] = (m_ppaaiImprovementYieldChange[eIndex1][eIndex2] + iChange);
		m_ppaaiImprovementYieldChange[eIndex1] = yields;
		CvAssert(getImprovementYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::removeFromArmy(int iArmyID, int iID)
{
	CvArmyAI* pThisArmyAI = getArmyAI(iArmyID);
	if(pThisArmyAI)
		return pThisArmyAI->RemoveUnit(iID, false) != -1;

	return false;
}

//	---------------------------------------------------------------------------
//	Finds the path length from this tech type to one you already know (FIXED)
//	This one doesn't count technologies multiple times during recursive calls!
//	A temporary buffer is used to mark techs already visited, so they can be 
//	counted only once when the recursive calls end.
int CvPlayer::findPathLengthNew(TechTypes eTech, int pTechs[]) const
{
	CvAssertMsg(eTech != NO_TECH, "Tech is not assigned a valid value");
	int i;

	// if buffer is empty then initialize, start recursive calls and count techs at the end
	if (pTechs == NULL)
	{
		int pTechBuffer[200]; // ideally need to count all techs and allocate a dynamic array
		std::fill(pTechBuffer, pTechBuffer+200, 0);
		(void) findPathLengthNew(eTech, pTechBuffer);
		int iNumTechs = 0;
		for (i=0; i<200; i++) iNumTechs += pTechBuffer[i]; // count all techs that we visited during recursive calls
		return iNumTechs;
	}

	// if buffer is not empty then mark the tech as required and analyze prerequisite techs
	CvTechEntry* pkTechInfo = GC.getTechInfo(eTech);
	if(pkTechInfo == NULL)
		return 0;
	if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech(eTech)) // We have this tech
		return 0;
	
	// this tech is not yet FULLY researched, so mark it; always 1, so they won't be counted multiple times!
	pTechs[(int) eTech] = 1;
	//	Cycle through the AND paths and mark their techs
	for(i = 0; i < /*6*/ GD_INT_GET(NUM_AND_TECH_PREREQS); i++)
	{
		TechTypes ePreReq = (TechTypes)pkTechInfo->GetPrereqAndTechs(i);
		if(ePreReq != NO_TECH)
			(void) findPathLengthNew(ePreReq, pTechs);
	}

	// OR paths omitted as of now, not used

	return 0;
}

//	---------------------------------------------------------------------------
//	Finds the path length from this tech type to one you already know
//	If bCost is false, then it returns number of techs that need to be researched to acquire eTech
//	If bCost is true, then it returns the cost of a currently researched tech
int CvPlayer::findPathLength(TechTypes eTech, bool bCost) const
{
	CvTechEntry* pkTechInfo = GC.getTechInfo(eTech);
	if (pkTechInfo == NULL)
		return 0;

	if (GET_TEAM(getTeam()).GetTeamTechs()->HasTech(eTech)) // We have this tech
		return 0;

	int iNumSteps = 0;
	int iShortestPath = 0;
	int iPathLength = findPathLengthNew(eTech, NULL);

	TechTypes eShortestOr = NO_TECH;
	iShortestPath = INT_MAX;
	//	Find the shortest OR tech
	for (int i = 0; i < /*3*/ GD_INT_GET(NUM_OR_TECH_PREREQS); i++)
	{
		//	Grab the tech
		TechTypes ePreReq = (TechTypes)pkTechInfo->GetPrereqOrTechs(i);

		//	If this is a valid tech
		if (ePreReq != NO_TECH)
		{
			iNumSteps = findPathLengthNew(ePreReq, NULL);

			//	If the prereq is a valid tech and its the current shortest, mark it as such
			if (iNumSteps < iShortestPath)
			{
				eShortestOr = ePreReq;
				iShortestPath = iNumSteps;
			}
		}
	}

	// If the shortest OR is a valid tech, add the steps to it...
	if(eShortestOr != NO_TECH)
	{
		iPathLength += iShortestPath;
	}

	return bCost ? (GET_TEAM(getTeam()).GetTeamTechs()->GetResearchCost(eTech)) : iPathLength;
}


//	--------------------------------------------------------------------------------
//	Function specifically for python/tech chooser screen
int CvPlayer::getQueuePosition(TechTypes eTech) const
{
	int i = 1;
	const CLLNode<TechTypes>* pResearchNode;

	for(pResearchNode = headResearchQueueNode(); pResearchNode; pResearchNode = nextResearchQueueNode(pResearchNode))
	{
		if(pResearchNode->m_data == eTech)
		{
			return i;
		}
		i++;
	}

	return -1;
}


//	--------------------------------------------------------------------------------
void CvPlayer::clearResearchQueue()
{
	int iI;

	m_researchQueue.clear();

	for(iI = 0; iI < GC.getNumTechInfos(); iI++)
	{
		setResearchingTech(((TechTypes)iI), false);
	}

	if(getTeam() == GC.getGame().getActiveTeam())
	{
		GC.GetEngineUserInterface()->setDirty(ResearchButtons_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(Score_DIRTY_BIT, true);
	}
}


//	--------------------------------------------------------------------------------
//	Pushes research onto the queue.  If it is an append if will put it
//	and its pre-reqs into the queue.  If it is not an append it will change
//	research immediately and should be used with clear.  Clear will clear the entire queue.
bool CvPlayer::pushResearch(TechTypes eTech, bool bClear)
{
	int i;
	int iNumSteps;
	int iShortestPath;
	bool bOrPrereqFound;
	TechTypes ePreReq;
	TechTypes eShortestOr;

	CvAssertMsg(eTech != NO_TECH, "Tech is not assigned a valid value");

	CvTechEntry* pkTechInfo = GC.getTechInfo(eTech);
	if(pkTechInfo == NULL)
		return false;


	if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech(eTech) || m_pPlayerTechs->IsResearchingTech(eTech))
	{
		//	We have this tech, no reason to add this to the pre-reqs
		return true;
	}

	if(!GetPlayerTechs()->CanEverResearch(eTech))
	{
		return false;
	}

	//	Pop the entire queue...
	if(bClear)
	{
		clearResearchQueue();
	}

	//	Add in all the pre-reqs for the and techs...
	for(i = 0; i < /*6*/ GD_INT_GET(NUM_AND_TECH_PREREQS); i++)
	{
		ePreReq = (TechTypes)pkTechInfo->GetPrereqAndTechs(i);

		if(ePreReq != NO_TECH)
		{
			if(!pushResearch(ePreReq))
			{
				return false;
			}
		}
	}

	// Will return the shortest path of all the or techs.  Tie breaker goes to the first one...
	eShortestOr = NO_TECH;
	iShortestPath = INT_MAX;
	bOrPrereqFound = false;
	//	Cycle through all the OR techs
	for(i = 0; i < /*3*/ GD_INT_GET(NUM_OR_TECH_PREREQS); i++)
	{
		ePreReq = (TechTypes)pkTechInfo->GetPrereqOrTechs(i);

		if(ePreReq != NO_TECH)
		{
			bOrPrereqFound = true;

			//	If the pre-req exists, and we have it, it is the shortest path, get out, we're done
			if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech(ePreReq))
			{
				eShortestOr = ePreReq;
				break;
			}

			if(GetPlayerTechs()->CanEverResearch(ePreReq))
			{
				//	Find the length of the path to this pre-req
				iNumSteps = findPathLength(ePreReq);

				//	If this pre-req is a valid tech, and its the shortest current path, set it as such
				if(iNumSteps < iShortestPath)
				{
					eShortestOr = ePreReq;
					iShortestPath = iNumSteps;
				}
			}
		}
	}

	//	If the shortest path tech is valid, push it (and its children) on to the research queue recursively
	if(eShortestOr != NO_TECH)
	{
		if(!pushResearch(eShortestOr))
		{
			return false;
		}
	}
	else if(bOrPrereqFound)
	{
		return false;
	}

	//	Insert this tech at the end of the queue
	m_researchQueue.insertAtEnd(eTech);

	setResearchingTech(eTech, true);

	//	Set the dirty bits
	if(getTeam() == GC.getGame().getActiveTeam())
	{
		GC.GetEngineUserInterface()->setDirty(ResearchButtons_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(Score_DIRTY_BIT, true);
	}
	return true;
}


//	--------------------------------------------------------------------------------
//	If bHead is true we delete the entire queue...
void CvPlayer::popResearch(TechTypes eTech)
{
	CLLNode<TechTypes>* pResearchNode;

	for(pResearchNode = headResearchQueueNode(); pResearchNode; pResearchNode = nextResearchQueueNode(pResearchNode))
	{
		if(pResearchNode->m_data == eTech)
		{
			m_researchQueue.deleteNode(pResearchNode);
			break;
		}
	}

	setResearchingTech(eTech, false);

	if(getTeam() == GC.getGame().getActiveTeam())
	{
		GC.GetEngineUserInterface()->setDirty(ResearchButtons_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(Score_DIRTY_BIT, true);
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getLengthResearchQueue() const
{
	return m_researchQueue.getLength();
}


//	--------------------------------------------------------------------------------
CLLNode<TechTypes>* CvPlayer::nextResearchQueueNode(CLLNode<TechTypes>* pNode)
{
	return m_researchQueue.next(pNode);
}

//	--------------------------------------------------------------------------------
const CLLNode<TechTypes>* CvPlayer::nextResearchQueueNode(const CLLNode<TechTypes>* pNode) const
{
	return m_researchQueue.next(pNode);
}

//	--------------------------------------------------------------------------------
CLLNode<TechTypes>* CvPlayer::headResearchQueueNode()
{
	return m_researchQueue.head();
}

//	--------------------------------------------------------------------------------
const CLLNode<TechTypes>* CvPlayer::headResearchQueueNode() const
{
	return m_researchQueue.head();
}

//	--------------------------------------------------------------------------------
CLLNode<TechTypes>* CvPlayer::tailResearchQueueNode()
{
	return m_researchQueue.tail();
}


//	--------------------------------------------------------------------------------
void CvPlayer::addCityName(const CvString& szName)
{
	m_cityNames.insertAtEnd(szName);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getNumCityNames() const
{
	return m_cityNames.getLength();
}


//	--------------------------------------------------------------------------------
CvString CvPlayer::getCityName(int iIndex) const
{
	CLLNode<CvString>* pCityNameNode;

	pCityNameNode = m_cityNames.nodeNum(iIndex);

	if(pCityNameNode != NULL)
	{
		return pCityNameNode->m_data;
	}
	else
	{
		return "";
	}
}

//	--------------------------------------------------------------------------------
CLLNode<CvString>* CvPlayer::nextCityNameNode(CLLNode<CvString>* pNode)
{
	return m_cityNames.next(pNode);
}

//	--------------------------------------------------------------------------------
const CLLNode<CvString>* CvPlayer::nextCityNameNode(const CLLNode<CvString>* pNode) const
{
	return m_cityNames.next(pNode);
}

//	--------------------------------------------------------------------------------
CLLNode<CvString>* CvPlayer::headCityNameNode()
{
	return m_cityNames.head();
}

//	--------------------------------------------------------------------------------
const CLLNode<CvString>* CvPlayer::headCityNameNode() const
{
	return m_cityNames.head();
}

//	--------------------------------------------------------------------------------
CvCity* CvPlayer::firstCity(int* pIterIdx, bool bRev)
{
	if (bRev)
		*pIterIdx = m_cities.GetCount()-1;
	else
		*pIterIdx = 0;
	return m_cities.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
const CvCity* CvPlayer::firstCity(int* pIterIdx, bool bRev) const
{
	if (bRev)
		*pIterIdx = m_cities.GetCount()-1;
	else
		*pIterIdx = 0;
	return m_cities.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
CvCity* CvPlayer::nextCity(int* pIterIdx, bool bRev)
{
	if (bRev)
		(*pIterIdx)--;
	else
		(*pIterIdx)++;

	return m_cities.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
const CvCity* CvPlayer::nextCity(int* pIterIdx, bool bRev) const
{
	if (bRev)
		(*pIterIdx)--;
	else
		(*pIterIdx)++;

	return m_cities.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
#if defined(MOD_BALANCE_CORE)
CvCity* CvPlayer::nextCity(const CvCity* pCurrent, bool bRev)
{
	int iIdx = m_cities.GetIndexForID(pCurrent->GetID());

	if (iIdx<0)
		return NULL;

	if (bRev)
		iIdx--;
	else
		iIdx++;

	return m_cities.GetAt(iIdx);
}

//	--------------------------------------------------------------------------------
const CvCity* CvPlayer::nextCity(const CvCity* pCurrent, bool bRev) const
{
	int iIdx = m_cities.GetIndexForID(pCurrent->GetID());

	if (iIdx<0)
		return NULL;

	if (bRev)
	{
		if (iIdx > 0)
			iIdx--;
		else
			iIdx = m_cities.GetCount() - 1;
	}
	else
	{
		if (iIdx == m_cities.GetCount() - 1)
			iIdx = 0;
		else
			iIdx++;
	}

	return m_cities.GetAt(iIdx);
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getNumCities() const
{
	return m_cities.GetCount();
}

//	--------------------------------------------------------------------------------
CvCity* CvPlayer::getCity(int iID) const
{
	return(m_cities.Get(iID));
}

//	--------------------------------------------------------------------------------
CvCity* CvPlayer::addCity()
{
	m_iNumUnitsSuppliedCached = -1;
	return(m_cities.Add());
}

//	--------------------------------------------------------------------------------
void CvPlayer::deleteCity(int iID)
{
	m_cities.Remove(iID);
	m_iNumUnitsSuppliedCached = -1;

	GC.getGame().SetClosestCityMapDirty();

#if defined(MOD_BALANCE_CORE)
	int iLoop=0;
	for (CvCity* pCity=firstCity(&iLoop); pCity!=NULL; pCity=nextCity(&iLoop))
		pCity->UpdateClosestFriendlyNeighbors();
#endif
}

int CvPlayer::GetCityDistancePathLength( const CvPlot* pPlot ) const
{
	if ( isMajorCiv() )
		return GC.getGame().GetClosestCityDistancePathLength( pPlot, GetID() );

	//for minors we fake it
	CvCity* pCapital = getCapitalCity();
	if (pCapital && pPlot)
		return plotDistance(*pPlot, *pCapital->plot()) / 2;

	return INT_MAX;
}

CvCity* CvPlayer::GetClosestCityByPathLength( const CvPlot* pPlot ) const
{
	//careful, player-specific GetClosestCity only works for majors (because of performance)
	if ( isMajorCiv() )
		return GC.getGame().GetClosestCityByPathLength( pPlot, GetID() );

	//for minors just assume they have only one city (99% correct)
	return getCapitalCity();
}

int CvPlayer::GetCityDistanceInPlots(const CvPlot* pPlot) const
{
	if ( isMajorCiv() )
		return GC.getGame().GetClosestCityDistanceInPlots( pPlot, GetID() );

	//for minors we fake it
	CvCity* pCapital = getCapitalCity();
	if (pCapital && pPlot)
		return plotDistance(*pPlot, *pCapital->plot()) / 2;

	return INT_MAX;
}

CvCity* CvPlayer::GetClosestCityByPlots(const CvPlot* pPlot) const
{
	// Optimization for players with only one city.
	// `CvPlayer::firstCity` does not work here because it will return a const city pointer.
	if (m_cities.GetCount() == 1)
	{
		return m_cities.GetAt(0);
	}
	else
	{
		return GC.getGame().GetClosestCityByPlots(pPlot, GetID());
	}
}

CvCity* CvPlayer::GetClosestCityToUsByPlots(PlayerTypes eOtherPlayer) const
{
	int iCityLoop = 0;
	int iMinDistance = INT_MAX;
	CvCity* pTheirClosestCity = NULL;

	for (CvCity* pOtherCity = GET_PLAYER(eOtherPlayer).firstCity(&iCityLoop); pOtherCity != NULL; pOtherCity = GET_PLAYER(eOtherPlayer).nextCity(&iCityLoop))
	{
		CvCity* pOurClosestCity = GetClosestCityByPlots(pOtherCity->plot());
		if (!pOurClosestCity)
			continue;

		int iDistance = plotDistance(*pOtherCity->plot(), *pOurClosestCity->plot());
		if (iDistance < iMinDistance)
		{
			iMinDistance = iDistance;
			pTheirClosestCity = pOtherCity;
		}
	}

	return pTheirClosestCity;
}

CvCity* CvPlayer::GetClosestCityToCity(const CvCity * pRefCity)
{
	if (!pRefCity)
		return NULL;

	CvCity* pNeighborCity = NULL;
	int iRefDist = INT_MAX;
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		//important ...
		if (pLoopCity == pRefCity)
			continue;

		int iDist = plotDistance(*pLoopCity->plot(),*pRefCity->plot());
		if (iDist < iRefDist)
		{
			iRefDist = iDist;
			pNeighborCity = pLoopCity;
		}
	}

	return pNeighborCity;
}

void CvPlayer::setUnlockedGrowthAnywhereThisTurn(bool bValue)
{
	m_bUnlockedGrowthAnywhereThisTurn = bValue;
}

bool CvPlayer::unlockedGrowthAnywhereThisTurn() const
{
	return m_bUnlockedGrowthAnywhereThisTurn;
}

//	--------------------------------------------------------------------------------
CvCity* CvPlayer::GetFirstCityWithBuildingClass(BuildingClassTypes eBuildingClass)
{
	int iLoop;
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (pLoopCity->HasBuildingClass(eBuildingClass))
			return pLoopCity;
	}
	return NULL;
}

//	--------------------------------------------------------------------------------
const CvUnit* CvPlayer::firstUnit(int* pIterIdx, bool bRev) const
{
	if (bRev)
		*pIterIdx = m_units.GetCount()-1;
	else
		*pIterIdx = 0;
	return m_units.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
CvUnit* CvPlayer::firstUnit(int* pIterIdx, bool bRev)
{
	if (bRev)
		*pIterIdx = m_units.GetCount()-1;
	else
		*pIterIdx = 0;
	return m_units.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
const CvUnit* CvPlayer::nextUnit(int* pIterIdx, bool bRev) const
{
	if (bRev)
		(*pIterIdx)--;
	else
		(*pIterIdx)++;
	return m_units.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
CvUnit* CvPlayer::nextUnit(int* pIterIdx, bool bRev)
{
	if (bRev)
		(*pIterIdx)--;
	else
		(*pIterIdx)++;
	return m_units.GetAt(*pIterIdx);
}

#if defined(MOD_BALANCE_CORE)
CvUnit* CvPlayer::nextUnit(const CvUnit* pCurrent, bool bRev)
{
	int iIdx = m_units.GetIndexForID(pCurrent->GetID());

	if (iIdx<0)
		return NULL;

	if (bRev)
		iIdx--;
	else
		iIdx++;

	return m_units.GetAt(iIdx);
}

//	--------------------------------------------------------------------------------
const CvUnit* CvPlayer::nextUnit(const CvUnit* pCurrent, bool bRev) const
{
	int iIdx = m_units.GetIndexForID(pCurrent->GetID());

	if (iIdx<0)
		return NULL;

	if (bRev)
	{
		if (iIdx > 0)
			iIdx--;
		else
			iIdx = m_cities.GetCount() - 1;
	}
	else
	{
		if (iIdx == m_cities.GetCount() - 1)
			iIdx = 0;
		else
			iIdx++;
	}

	return m_units.GetAt(iIdx);
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::getNumUnits() const
{
	return m_units.GetCount();
}


//	--------------------------------------------------------------------------------
CvUnit* CvPlayer::getUnit(int iID) const
{
#if defined(MOD_BALANCE_CORE)
	//spread it out a little for an easy breakpoint
	CvUnit* pUnit = m_units.Get(iID);
	return pUnit;
#else
	return (m_units.GetAt(iID));
#endif
}

//	--------------------------------------------------------------------------------
CvUnit* CvPlayer::addUnit()
{
	CvUnit* pResult = m_units.Add();

	//debugging ...
	for (int iIdx = 0; iIdx < m_units.GetCount()-1; iIdx++)
	{
		if (m_units.GetAt(iIdx)==pResult)
			OutputDebugString("inconsistent state: double unit pointer!\n");
	}

	return pResult;
}


//	--------------------------------------------------------------------------------
void CvPlayer::deleteUnit(int iID)
{
	m_units.Remove(iID);
}


//	--------------------------------------------------------------------------------
const CvArmyAI* CvPlayer::firstArmyAI(int* pIterIdx, bool bRev) const
{
	if (bRev)
		*pIterIdx = m_armyAIs.GetCount()-1;
	else
		*pIterIdx = 0;
	return m_armyAIs.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
CvArmyAI* CvPlayer::firstArmyAI(int* pIterIdx, bool bRev)
{
	if (bRev)
		*pIterIdx = m_armyAIs.GetCount()-1;
	else
		*pIterIdx = 0;	
	return m_armyAIs.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
const CvArmyAI* CvPlayer::nextArmyAI(int* pIterIdx, bool bRev) const
{
	if (bRev)
		(*pIterIdx)--;
	else
		(*pIterIdx)++;
	return m_armyAIs.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
CvArmyAI* CvPlayer::nextArmyAI(int* pIterIdx, bool bRev)
{
	if (bRev)
		(*pIterIdx)--;
	else
		(*pIterIdx)++;
	return m_armyAIs.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNumArmyAIs() const
{
	return m_armyAIs.GetCount();
}


//	--------------------------------------------------------------------------------
const CvArmyAI* CvPlayer::getArmyAI(int iID) const
{
	return ((CvArmyAI*)(m_armyAIs.Get(iID)));
}

//	--------------------------------------------------------------------------------
CvArmyAI* CvPlayer::getArmyAI(int iID)
{
	return ((CvArmyAI*)(m_armyAIs.Get(iID)));
}


//	--------------------------------------------------------------------------------
CvArmyAI* CvPlayer::addArmyAI()
{
	CvArmyAI* pArmy = m_armyAIs.Add();
	if (pArmy)
		pArmy->SetOwner(m_eID);
	return pArmy;
}


//	--------------------------------------------------------------------------------
void CvPlayer::deleteArmyAI(int iID)
{
	bool bRemoved = m_armyAIs.Remove(iID);
	DEBUG_VARIABLE(bRemoved);
	CvAssertMsg(bRemoved, "could not find army, delete failed");
}

//	--------------------------------------------------------------------------------
const CvAIOperation* CvPlayer::getAIOperation(int iID) const
{
	for (size_t i = 0; i < m_AIOperations.size(); i++)
		if (m_AIOperations[i].first == iID)
			return m_AIOperations[i].second;

	return NULL;
}

//	--------------------------------------------------------------------------------
size_t CvPlayer::getNumAIOperations() const
{
	return m_AIOperations.size();
}

//	--------------------------------------------------------------------------------
CvAIOperation* CvPlayer::getAIOperationByIndex(size_t iIndex) const
{
	if (iIndex<m_AIOperations.size())
		return m_AIOperations[iIndex].second;

	return NULL;
}

//	--------------------------------------------------------------------------------
CvAIOperation* CvPlayer::getAIOperation(int iID)
{
	for (size_t i = 0; i < m_AIOperations.size(); i++)
		if (m_AIOperations[i].first == iID)
			return m_AIOperations[i].second;

	return NULL;
}

//	--------------------------------------------------------------------------------
CvAIOperation* CvPlayer::addAIOperation(AIOperationTypes eOperationType, size_t iMaxMissingUnits, PlayerTypes eEnemy, CvCity* pTarget, CvCity* pMuster)
{
	//no AI operations for human players
	if (isHuman())
	{
		CUSTOMLOG("warning: trying to create an AI operation for a human player!");
		return NULL;
	}

	CvAIOperation* pNewOperation = CreateAIOperation(eOperationType,GC.getGame().GetNextGlobalID(),GetID(),eEnemy);
	if (!pNewOperation)
		return NULL;

	//bail early if impossible (just to avoid spamming the logs)
	//note that for performance reasons we don't do real pathfinding here
	if (!pNewOperation->PreconditionsAreMet(pMuster ? pMuster->plot() : NULL, pTarget ? pTarget->plot() : NULL, iMaxMissingUnits))
	{
		delete pNewOperation;
		return NULL;
	}

	//because of stupidity, we need to enable CvPlayer::getOperation() before initializing the operation
	m_AIOperations.push_back(std::make_pair(pNewOperation->GetID(), pNewOperation));

	//check if initialization works out
	pNewOperation->Init(pTarget, pMuster);

	//check number of units again
	if (pNewOperation->GetNumUnitsNeededToBeBuilt() > iMaxMissingUnits)
		pNewOperation->SetToAbort(AI_ABORT_NO_UNITS);

	//undo if necessary
	if (pNewOperation->GetOperationState() == AI_OPERATION_STATE_ABORTED || pNewOperation->GetOperationState() == AI_OPERATION_STATE_INVALID)
	{
		pNewOperation->LogOperationEnd();
		deleteAIOperation(pNewOperation->GetID());
		return NULL;
	}

	return pNewOperation;
}

//	--------------------------------------------------------------------------------
void CvPlayer::deleteAIOperation(int iID)
{
	for (size_t i = 0; i < m_AIOperations.size(); i++)
	{
		if (m_AIOperations[i].first == iID)
		{
			delete(m_AIOperations[i].second);
			m_AIOperations.erase(m_AIOperations.begin() + i);
			return;
		}
	}
}

CvAIOperation* CvPlayer::getFirstOffensiveAIOperation(PlayerTypes eTargetPlayer)
{
	// loop through all entries looking for match
	for (size_t i = 0; i < m_AIOperations.size(); i++)
	{
		CvAIOperation* pThisOperation = m_AIOperations[i].second;
		if (pThisOperation->IsCivilianOperation())
			continue;

		if (pThisOperation->GetOperationState() == AI_OPERATION_STATE_SUCCESSFUL_FINISH || pThisOperation->GetOperationState() == AI_OPERATION_STATE_ABORTED)
			continue;

		if (pThisOperation->IsOffensive() && (pThisOperation->GetEnemy() == eTargetPlayer || eTargetPlayer == NO_PLAYER))
			return pThisOperation;
	}

	return NULL;
}

bool CvPlayer::HasAnyOffensiveOperationsAgainstPlayer(PlayerTypes ePlayer)
{
	return getFirstOffensiveAIOperation(ePlayer) != NULL;
}

bool CvPlayer::StopAllLandOffensiveOperationsAgainstPlayer(PlayerTypes ePlayer, AIOperationAbortReason eReason)
{
	bool bFoundOne = false;

	// loop through all entries looking for match
	for (size_t i = 0; i < m_AIOperations.size(); i++)
	{
		CvAIOperation* pThisOperation = m_AIOperations[i].second;
		if (pThisOperation->IsCivilianOperation())
			continue;

		if (pThisOperation->GetOperationState() == AI_OPERATION_STATE_SUCCESSFUL_FINISH || pThisOperation->GetOperationState() == AI_OPERATION_STATE_ABORTED)
			continue;

		if (pThisOperation->IsOffensive() && !pThisOperation->IsNavalOperation() && (ePlayer==NO_PLAYER || pThisOperation->GetEnemy() == ePlayer))
		{
			bFoundOne = true;
			pThisOperation->SetToAbort(eReason);
		}
	}

	return bFoundOne;
}

int CvPlayer::GetNumOffensiveOperations(DomainTypes eDomain)
{
	int iNum = 0;
	// loop through all entries looking for match
	for (size_t i = 0; i < m_AIOperations.size(); i++)
	{
		CvAIOperation* pThisOperation = m_AIOperations[i].second;
		if (pThisOperation->IsCivilianOperation())
			continue;

		if (pThisOperation->IsOffensive() && pThisOperation->GetOperationState() != AI_OPERATION_STATE_ABORTED)
		{
			if (eDomain == DOMAIN_SEA && pThisOperation->IsNavalOperation())
				iNum++;
			else if (eDomain == DOMAIN_LAND && !pThisOperation->IsNavalOperation())
				iNum++;
		}
	}

	return iNum;
}

bool CvPlayer::StopAllLandDefensiveOperationsAgainstPlayer(PlayerTypes ePlayer, AIOperationAbortReason eReason)
{
	bool bFoundOne = false;

	// loop through all entries looking for match
	for (size_t i = 0; i < m_AIOperations.size(); i++)
	{
		CvAIOperation* pThisOperation = m_AIOperations[i].second;
		if (pThisOperation->IsCivilianOperation())
			continue;

		if (pThisOperation->GetOperationState() == AI_OPERATION_STATE_SUCCESSFUL_FINISH || pThisOperation->GetOperationState() == AI_OPERATION_STATE_ABORTED)
			continue;

		if (!pThisOperation->IsOffensive() && !pThisOperation->IsNavalOperation() && (ePlayer==NO_PLAYER || pThisOperation->GetEnemy() == ePlayer))
		{
			bFoundOne = true;
			pThisOperation->SetToAbort(eReason);
		}
	}

	return bFoundOne;
}

bool CvPlayer::StopAllSeaOffensiveOperationsAgainstPlayer(PlayerTypes ePlayer, AIOperationAbortReason eReason)
{
	bool bFoundOne = false;

	// loop through all entries looking for match
	for (size_t i = 0; i < m_AIOperations.size(); i++)
	{
		CvAIOperation* pThisOperation = m_AIOperations[i].second;
		if (pThisOperation->IsCivilianOperation())
			continue;

		if (pThisOperation->GetOperationState() == AI_OPERATION_STATE_SUCCESSFUL_FINISH || pThisOperation->GetOperationState() == AI_OPERATION_STATE_ABORTED)
			continue;

		if (pThisOperation->IsOffensive() && pThisOperation->IsNavalOperation() && (ePlayer==NO_PLAYER || pThisOperation->GetEnemy() == ePlayer))
		{
			bFoundOne = true;
			pThisOperation->SetToAbort(eReason);
		}
	}

	return bFoundOne;
}

bool CvPlayer::StopAllSeaDefensiveOperationsAgainstPlayer(PlayerTypes ePlayer, AIOperationAbortReason eReason)
{
	bool bFoundOne = false;

	// loop through all entries looking for match
	for (size_t i = 0; i < m_AIOperations.size(); i++)
	{
		CvAIOperation* pThisOperation = m_AIOperations[i].second;
		if (pThisOperation->IsCivilianOperation())
			continue;

		if (pThisOperation->GetOperationState() == AI_OPERATION_STATE_SUCCESSFUL_FINISH || pThisOperation->GetOperationState() == AI_OPERATION_STATE_ABORTED)
			continue;

		if (!pThisOperation->IsOffensive() && pThisOperation->IsNavalOperation() && (ePlayer==NO_PLAYER || pThisOperation->GetEnemy() == ePlayer))
		{
			bFoundOne = true;
			pThisOperation->SetToAbort(eReason);
		}
	}

	return bFoundOne;
}

//	--------------------------------------------------------------------------------
CvAIOperation* CvPlayer::getFirstAIOperationOfType(AIOperationTypes eOperationType, PlayerTypes eTargetPlayer /* optional */, CvPlot* pTarget /* optional */)
{
	int iMaxTargetDistance = 3;
	
	// loop through all entries looking for match
	for (size_t i = 0; i < m_AIOperations.size(); i++)
	{
		CvAIOperation* pThisOperation = m_AIOperations[i].second;
		if(pThisOperation->GetOperationType() == eOperationType && pThisOperation->GetOperationState() != AI_OPERATION_STATE_ABORTED)
		{
			if(eTargetPlayer == NO_PLAYER || eTargetPlayer == pThisOperation->GetEnemy())
			{
				if(pTarget == NULL || plotDistance(*pTarget,*pThisOperation->GetTargetPlot())<iMaxTargetDistance)
				{
					return pThisOperation;
				}
			}
		}
	}
	return NULL;
}

//	--------------------------------------------------------------------------------
/// Is an existing operation already going after this city?
bool CvPlayer::IsTargetCityForOperation(CvCity* pCity, bool bNaval) const
{
	if (!pCity)
		return false;

	for (size_t i = 0; i < m_AIOperations.size(); i++)
	{
		CvAIOperation* pThisOperation = m_AIOperations[i].second;
		CvPlot* pTarget = pThisOperation->GetTargetPlot();
		if (pTarget && plotDistance(*pTarget,*pCity->plot())<3)
		{
			return (bNaval == pThisOperation->IsNavalOperation());
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
/// Is an existing operation already starting from this city?
bool CvPlayer::IsMusterCityForOperation(CvCity* pCity, bool bNaval) const
{
	if (!pCity)
		return false;

	for (size_t i = 0; i < m_AIOperations.size(); i++)
	{
		CvAIOperation* pThisOperation = m_AIOperations[i].second;
		if (plotDistance(*pThisOperation->GetMusterPlot(),*pCity->plot())<3)
		{
			return (bNaval == pThisOperation->IsNavalOperation());
		}
	}

	return false;
}

vector<int> CvPlayer::GetPlotsTargetedByExplorers(const CvUnit* pIgnoreUnit) const
{
	vector<int> result;

	// Loop through our units
	int iLoop = 0;
	for(const CvUnit* pUnit = firstUnit(&iLoop); pUnit; pUnit = nextUnit(&iLoop))
	{
		if (pUnit==pIgnoreUnit)
			continue;

		if(pUnit->AI_getUnitAIType() == UNITAI_EXPLORE || (pUnit->IsAutomated() && pUnit->GetAutomateType() == AUTOMATE_EXPLORE) )
		{
			CvPlot* pMissionPlot = pUnit->GetMissionAIPlot();
			if (pMissionPlot)
				result.push_back(pMissionPlot->GetPlotIndex());
		}
	}

	return result;
}

//	--------------------------------------------------------------------------------
/// Are we already sending a settler to this plot (or any plot within 3)
bool CvPlayer::IsPlotTargetedForCity(CvPlot *pPlot, CvAIOperation* pOpToIgnore) const
{
	for (size_t i = 0; i < m_AIOperations.size(); i++)
	{
		CvAIOperation* pOperation = m_AIOperations[i].second;
		if(pOperation && pOperation != pOpToIgnore && pOperation->HasTargetPlot())
		{
			if (pOperation->GetOperationType() == AI_OPERATION_FOUND_CITY && plotDistance(*pPlot, *pOperation->GetTargetPlot()) <= 3)
			{
				return true;
			}
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
const std::map<CvString,CvPlayer::TurnData>& CvPlayer::getReplayData() const
{
	return m_ReplayData;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getReplayDataValue(const CvString& strDataset, unsigned int uiTurn) const
{
	std::map<CvString, TurnData>::const_iterator it = m_ReplayData.find(strDataset);
	if (it!=m_ReplayData.end())
	{
		TurnData::const_iterator entry = it->second.find(uiTurn);
		if(entry != it->second.end())
			return entry->second;
	}

	return -1;
}

//	--------------------------------------------------------------------------------
void CvPlayer::setReplayDataValue(const CvString& strDataset, unsigned int uiTurn, int iValue)
{
	std::map<CvString, TurnData>::iterator it = m_ReplayData.find(strDataset);
	if (it == m_ReplayData.end())
	{
		if (m_eID == 0) //do not spam the log, assume all players are equal
			CUSTOMLOG("Adding replay dataset %s for player %d", strDataset.c_str(), m_eID);

		//old ms stl is stupid, do it this way
		m_ReplayData[strDataset] = TurnData();
		it = m_ReplayData.find(strDataset);
	}

	it->second[uiTurn] = iValue;
}

int CvPlayer::getYieldPerTurnHistory(YieldTypes eYield, int iNumTurns, bool bIgnoreInstant)
{
	if (iNumTurns == 0)
		return 0;

	if (iNumTurns > GC.getGame().getElapsedGameTurns())
		iNumTurns = GC.getGame().getElapsedGameTurns();

	int iYield = 0;
	int iLoop = 0;

	// Average over X turns unles iNumTurns is larger
	int iNumHistory = /*10*/ GD_INT_GET(HISTORY_NUM_TURNS_TO_AVERAGE);
	if (!MOD_BALANCE_VP || iNumTurns > iNumHistory)
		iNumHistory = iNumTurns;

	std::vector<int>& viYieldHistory = m_aiYieldHistory[eYield];

	for (int i = viYieldHistory.size()-1; i >= 0; i--)
	{
		iYield += viYieldHistory[i];
		if (++iLoop >= iNumHistory)
			break;
	}

	if (iNumHistory != iNumTurns)
		iYield = iNumTurns * iYield / iNumHistory;

	// Include average accumulated instant yields over elapsed turns
	if (!bIgnoreInstant)
	{
		switch (eYield)
		{

			case YIELD_PRODUCTION:
			case YIELD_FOOD:
			{
				iYield += iNumTurns * m_miLocalInstantYieldsTotal[eYield] / (GC.getGame().getElapsedGameTurns() + 1);
				break;
			}
			default:
				iYield += iNumTurns * m_viInstantYieldsTotal[eYield] / (GC.getGame().getElapsedGameTurns() + 1);
		}
	}

	return iYield;
}

void CvPlayer::updateYieldPerTurnHistory()
{
	m_aiYieldHistory[YIELD_PRODUCTION].push_back(GetAverageProduction());
	m_aiYieldHistory[YIELD_GOLD].push_back(calculateGoldRate());
	m_aiYieldHistory[YIELD_SCIENCE].push_back(GetScience());
	m_aiYieldHistory[YIELD_CULTURE].push_back(GetTotalJONSCulturePerTurn());
	m_aiYieldHistory[YIELD_TOURISM].push_back(GetCulture()->GetTourism() / 100);
	m_aiYieldHistory[YIELD_GOLDEN_AGE_POINTS].push_back(GetGoldenAgePointsFromEmpire());
	
	m_miLocalInstantYieldsTotal[YIELD_PRODUCTION] += GetAverageInstantProduction();
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeInstantYieldValue(YieldTypes eYield, int iValue)
{
	if (iValue == 0 || eYield >= NUM_YIELD_TYPES || eYield == NO_YIELD)
		return;

	int iTurn = GC.getGame().getGameTurn();
	if (m_ppiInstantYieldHistoryValues.empty() || m_ppiInstantYieldHistoryValues.back().first < iTurn)
	{
		if (m_ppiInstantYieldHistoryValues.size() == INSTANT_YIELD_HISTORY_LENGTH)
			m_ppiInstantYieldHistoryValues.pop_front();

		m_ppiInstantYieldHistoryValues.push_back( make_pair(iTurn, vector<int>(NUM_YIELD_TYPES, 0)));
		m_ppiInstantYieldHistoryValues.back().second[eYield] += iValue;
	}
	else if (m_ppiInstantYieldHistoryValues.back().first == iTurn)
	{
		m_ppiInstantYieldHistoryValues.back().second[eYield] += iValue;
	}
}

int CvPlayer::getInstantYieldValue(YieldTypes eYield, int iTurn) const
{
	return getInstantYieldAvg(eYield, iTurn, iTurn);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getInstantYieldAvg(YieldTypes eYield, int iTurnA, int iTurnB) const
{
	if (eYield >= NUM_YIELD_TYPES || eYield == NO_YIELD || m_ppiInstantYieldHistoryValues.empty())
		return 0;

	//we typically want the latest value only
	if (m_ppiInstantYieldHistoryValues.back().first == iTurnA && iTurnA == iTurnB)
		return m_ppiInstantYieldHistoryValues.back().second[eYield];

	//do it the slow way
	int iSum = 0;
	for (size_t i = 0; i < m_ppiInstantYieldHistoryValues.size(); i++)
		if (m_ppiInstantYieldHistoryValues[i].first >= iTurnA && m_ppiInstantYieldHistoryValues[i].first <= iTurnB)
			iSum += m_ppiInstantYieldHistoryValues[i].second[eYield];

	return iSum / (1+abs(iTurnA-iTurnB));
}

CvString CvPlayer::getInstantYieldHistoryTooltip(int iGameTurn, int iNumPreviousTurnsToCount)
{
	CvString yieldtooltip = "";
	int MaxTurnsBack = 0;

	bool bShowPlayerTourism = false;
	vector<int> tourismVal(MAX_MAJOR_CIVS, 0);
	for (int i = 0; i < NUM_YIELD_TYPES; i++)
	{
		int TurnsBack = 0;
		YieldTypes eYield = (YieldTypes)i;
		if (eYield == NO_YIELD)
			continue;

		if (eYield == YIELD_POPULATION)
			continue;

		if (eYield > YIELD_CULTURE_LOCAL)
			continue;

		if (GC.getYieldInfo(eYield) == NULL)
			continue;

		//current turn
		int iSum = 0;

		//and x turns back
		for (int iI = iNumPreviousTurnsToCount; iI >= 0; iI--)
		{
			int iTurn = iGameTurn - iI;
			if (iTurn < 0)
			{
				continue;
			}

			iSum += getInstantYieldValue(eYield, iTurn);
			int iTempSum = 0;
			int iNumPlayers = 0;
			if (eYield == YIELD_TOURISM)
			{
				for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
				{
					PlayerTypes ePlayer = (PlayerTypes)iPlayerLoop;
					int iTempTourism = getInstantTourismPerPlayerValue(ePlayer, iTurn);
					if (iTempTourism != 0)
					{
						iNumPlayers++;
						bShowPlayerTourism = true;
					}

					iTempSum += iTempTourism;
					tourismVal[iPlayerLoop] += iTempTourism;
				}
				iTempSum /= max(1, iNumPlayers);
				iSum += iTempSum;
			}
			TurnsBack++;
		}

		if (TurnsBack > MaxTurnsBack)
			MaxTurnsBack = TurnsBack;

		if (iSum > 0)
		{
			if (yieldtooltip != "")
			{
				yieldtooltip += "[NEWLINE]";
			}

			Localization::String localizedIYText;
			localizedIYText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_TOTAL");

			localizedIYText << GC.getYieldInfo(eYield)->GetDescription();
			localizedIYText << GC.getYieldInfo(eYield)->getIconString();
			localizedIYText << GC.getYieldInfo(eYield)->getColorString();
			localizedIYText << iSum;

			yieldtooltip += localizedIYText.toUTF8();
			yieldtooltip += " " + GetLocalizedText("TXT_KEY_INSTANT_YIELD_THIS_TURN", getInstantYieldValue(eYield, iGameTurn));

			if (eYield == YIELD_FOOD || eYield == YIELD_PRODUCTION)
			{
				int iAverage = max(1, (iSum / max(1, TurnsBack)));
				iAverage /= max(1, getNumCities());
				yieldtooltip += " " + GetLocalizedText("TXT_KEY_INSTANT_YIELD_AVERAGE_CITIES", iAverage);
			}
		}
	}

	if (bShowPlayerTourism)
	{
		yieldtooltip += " " + GetLocalizedText("TXT_KEY_INSTANT_YIELD_PER_PLAYER_TOURISM");
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes ePlayer = (PlayerTypes)iPlayerLoop;
			if (tourismVal[iPlayerLoop] == 0)
				continue;

			int iTourismAverage = max(1, (tourismVal[iPlayerLoop] / max(1, MaxTurnsBack)));

			yieldtooltip += " " + GetLocalizedText("TXT_KEY_INSTANT_YIELD_PER_PLAYER_TOURISM_NAME", GET_PLAYER(ePlayer).getCivilizationShortDescription(), tourismVal[iPlayerLoop], iTourismAverage);
		}
	}

	CvString tooltip = GetLocalizedText("TXT_KEY_YIELD_PER_TURN_HEADER", min(iNumPreviousTurnsToCount, MaxTurnsBack)) + "[NEWLINE]";

	if (yieldtooltip != "")
	{
		tooltip += yieldtooltip;
	}
	else
	{
		tooltip = GetLocalizedText("TXT_KEY_YIELD_PER_TURN_HEADER_EMPTY");
	}

	return tooltip;
}

void CvPlayer::LogInstantYield(YieldTypes eYield, int iValue, InstantYieldType eInstantYield, CvCity* pCity)
{
	CvString playerName = getCivilizationShortDescription();
	CvString cityName = pCity != NULL ? pCity->getName().GetCString() : "No City";
	FILogFile* pLog;
	CvString strBaseString;
	CvString strOutBuf;

	CvString instantYieldName;
	switch (eInstantYield)
	{
	case INSTANT_YIELD_TYPE_BIRTH:
	{
		instantYieldName = "Birth";
		break;
	}
	case INSTANT_YIELD_TYPE_DEATH:
			{
				instantYieldName = "Death";
				break;
			}
	case INSTANT_YIELD_TYPE_PROPOSAL:
			{
				instantYieldName = "WC Proposal";
				break;
			}

	case INSTANT_YIELD_TYPE_ERA_UNLOCK:
			{
				instantYieldName = "New Era";
				break;
			}
	case INSTANT_YIELD_TYPE_POLICY_UNLOCK:
			{
				instantYieldName = "Policy Unlock";
				break;
			}
	case INSTANT_YIELD_TYPE_INSTANT:
			{
				instantYieldName = "Instant";
				break;
			}
	case INSTANT_YIELD_TYPE_TECH:
			{
				instantYieldName = "Tech";
				break;
			}
	case INSTANT_YIELD_TYPE_CONSTRUCTION:
			{
				instantYieldName = "Construction";
				break;
			}
	case INSTANT_YIELD_TYPE_BORDERS:
			{
				instantYieldName = "Border Growth";
				break;
			}
	case INSTANT_YIELD_TYPE_GP_USE:
			{
				instantYieldName = "GP Use";
				break;
			}
	case INSTANT_YIELD_TYPE_GP_BORN:
			{
				instantYieldName = "GP Born";
				break;
			}
	case INSTANT_YIELD_TYPE_F_SPREAD:
			{
				instantYieldName = "Spread Foreign";
				break;
			}
	case INSTANT_YIELD_TYPE_F_CONQUEST:
			{
				instantYieldName = "Conquest";
				break;
			}
	case INSTANT_YIELD_TYPE_VICTORY:
			{
				instantYieldName = "Won Battle";
				break;
			}
	case INSTANT_YIELD_TYPE_U_PROD:
			{
				instantYieldName = "Produced Unit";
				break;
			}
	case INSTANT_YIELD_TYPE_PURCHASE:
			{
				instantYieldName = "Bought Something";
				break;
			}
	case INSTANT_YIELD_TYPE_TILE_PURCHASE:
			{
				instantYieldName = "Tile Purchase";
				break;
			}
	case INSTANT_YIELD_TYPE_FOUND:
			{
				instantYieldName = "Founded City";
				break;
			}
	case INSTANT_YIELD_TYPE_TR_END:
			{
				instantYieldName = "End TR";
				break;
			}
	case INSTANT_YIELD_TYPE_CONVERSION:
			{
				instantYieldName = "Converted City";
				break;
			}
	case INSTANT_YIELD_TYPE_SPREAD:
			{
				instantYieldName = "Spread Religion";
				break;
			}
	case INSTANT_YIELD_TYPE_BULLY:
			{
				instantYieldName = "Bully CS";
				break;
			}
	case INSTANT_YIELD_TYPE_TR_MOVEMENT:
			{
				instantYieldName = "TR Moved";
				break;
			}
	case INSTANT_YIELD_TYPE_SCOUTING:
			{
				instantYieldName = "Scouting";
				break;
			}
	case INSTANT_YIELD_TYPE_LEVEL_UP:
			{
				instantYieldName = "Unit Leveled";
				break;
			}
	case INSTANT_YIELD_TYPE_PILLAGE :
			{
				instantYieldName = "Pillaging";
				break;
			}
	case INSTANT_YIELD_TYPE_BIRTH_RETROACTIVE :
			{
				instantYieldName = "Birth Retro";
				break;
			}
	case INSTANT_YIELD_TYPE_TECH_RETROACTIVE:
		{
			instantYieldName = "Tech Retro";
			break;
		}
	case INSTANT_YIELD_TYPE_SPY_ATTACK:
			{
				instantYieldName = "Spy Attack";
				break;
			}
	case INSTANT_YIELD_TYPE_SPY_DEFENSE:
			{
				instantYieldName = "Spy Defense";
				break;
			}
	case INSTANT_YIELD_TYPE_DELEGATES:
			{
				instantYieldName = "WC Delegates";
				break;
			}
	case INSTANT_YIELD_TYPE_CONSTRUCTION_WONDER:
			{
				instantYieldName = "Wonder Const";
				break;
			}
	case INSTANT_YIELD_TYPE_MINOR_QUEST_REWARD:
			{
				instantYieldName = "Quest Minor";
				break;
			}
	case INSTANT_YIELD_TYPE_CULTURE_BOMB:
			{
				instantYieldName = "Culture Bomb";
				break;
			}
	case INSTANT_YIELD_TYPE_REMOVE_HERESY:
			{
				instantYieldName = "Remove Heresy";
				break;
			}
	case INSTANT_YIELD_TYPE_FAITH_PURCHASE:
			{
				instantYieldName = "Faith Purchase";
				break;
			}
	case INSTANT_YIELD_TYPE_VICTORY_GLOBAL:
			{
				instantYieldName = "Unit Won Battle (Anywhere)";
				break;
			}
	case INSTANT_YIELD_TYPE_PILLAGE_GLOBAL:
			{
				instantYieldName = "Pillage (Anywhere)";
				break;
			}
	case INSTANT_YIELD_TYPE_CONVERSION_EXPO:
			{
				instantYieldName = "Conversion Expo.";
				break;
			}
	case INSTANT_YIELD_TYPE_PROMOTION_OBTAINED:
			{
				instantYieldName = "Promotion";
				break;
			}
	case INSTANT_YIELD_TYPE_BARBARIAN_CAMP_CLEARED:
			{
				instantYieldName = "Barb Camp";
				break;
			}
	case INSTANT_YIELD_TYPE_TR_PRODUCTION_SIPHON:
			{
				instantYieldName = "Siphon";
				break;
			}
	case INSTANT_YIELD_TYPE_TR_MOVEMENT_IN_FOREIGN:
			{
				instantYieldName = "TR Foreign";
				break;
			}
	case INSTANT_YIELD_TYPE_IMPROVEMENT_BUILD:
			{
				instantYieldName = "Build Improvement";
				break;
			}
	case INSTANT_YIELD_TYPE_LUA:
			{
				instantYieldName = "LUA";
				break;
			}
	case INSTANT_YIELD_TYPE_RESEARCH_AGREMEENT:
			{
				instantYieldName = "RA";
				break;
			}
	case INSTANT_YIELD_TYPE_REFUND:
			{
				instantYieldName = "Refund";
				break;
			}
	case INSTANT_YIELD_TYPE_BIRTH_HOLY_CITY:
			{
				instantYieldName = "Holy City Birth";
				break;
			}
	case INSTANT_YIELD_TYPE_PILLAGE_UNIT:
			{
				instantYieldName = "Pillage (Unit)";
				break;
			}
	}

	CvString strFileName = "InstantYieldSummary.csv";
	pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
	strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
	strBaseString += playerName + ", ";
	strBaseString += cityName + ", ";
	strOutBuf.Format("Instant Yield Type: %s, Yield Type: %s, Value: %d", instantYieldName.c_str(), GC.getYieldInfo(eYield)->GetDescription(), iValue);
	strBaseString += strOutBuf;
	pLog->Msg(strBaseString);
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeInstantTourismPerPlayerValue(PlayerTypes ePlayer, int iValue)
{
	if (iValue == 0 || ePlayer >= MAX_MAJOR_CIVS || ePlayer == NO_PLAYER)
		return;

	int iTurn = GC.getGame().getGameTurn();
	if (m_ppiInstantTourismPerPlayerHistoryValues.empty() || m_ppiInstantTourismPerPlayerHistoryValues.back().first < iTurn)
	{
		if (m_ppiInstantTourismPerPlayerHistoryValues.size() == INSTANT_YIELD_HISTORY_LENGTH)
			m_ppiInstantTourismPerPlayerHistoryValues.pop_front();

		m_ppiInstantTourismPerPlayerHistoryValues.push_back( make_pair(iTurn, vector<int>(MAX_MAJOR_CIVS, 0)));
		m_ppiInstantTourismPerPlayerHistoryValues.back().second[ePlayer] += iValue;
	}
	else if (m_ppiInstantTourismPerPlayerHistoryValues.back().first == iTurn)
	{
		m_ppiInstantTourismPerPlayerHistoryValues.back().second[ePlayer] += iValue;
	}
}

int CvPlayer::getInstantTourismPerPlayerValue(PlayerTypes ePlayer, int iTurn) const
{
	return getInstantTourismPerPlayerAvg(ePlayer, iTurn, iTurn);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getInstantTourismPerPlayerAvg(PlayerTypes ePlayer, int iTurnA, int iTurnB) const
{
	if (ePlayer >= MAX_MAJOR_CIVS || ePlayer == NO_PLAYER || m_ppiInstantTourismPerPlayerHistoryValues.empty())
		return 0;

	//we typically want the latest value only
	if (m_ppiInstantTourismPerPlayerHistoryValues.back().first == iTurnA && iTurnA == iTurnB)
		return m_ppiInstantTourismPerPlayerHistoryValues.back().second[ePlayer];

	//do it the slow way
	int iSum = 0;
	for (size_t i = 0; i < m_ppiInstantTourismPerPlayerHistoryValues.size(); i++)
		if (m_ppiInstantTourismPerPlayerHistoryValues[i].first >= iTurnA && m_ppiInstantTourismPerPlayerHistoryValues[i].first <= iTurnB)
			iSum += m_ppiInstantTourismPerPlayerHistoryValues[i].second[ePlayer];

	return iSum / (1+abs(iTurnA-iTurnB));
}


//	--------------------------------------------------------------------------------
std::string CvPlayer::getScriptData() const
{
	return m_strScriptData;
}

//	--------------------------------------------------------------------------------
void CvPlayer::setScriptData(const std::string& strNewValue)
{
	m_strScriptData = strNewValue;
}

//	--------------------------------------------------------------------------------
const CvString& CvPlayer::getPbemEmailAddress() const
{
	return CvPreGame::emailAddress(GetID());
}

//	--------------------------------------------------------------------------------
void CvPlayer::setPbemEmailAddress(const char* szAddress)
{
	CvPreGame::setEmailAddress(GetID(), szAddress);
}

// Protected Functions...

//	--------------------------------------------------------------------------------
void CvPlayer::doResearch()
{
	if(GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))
	{
		return;
	}
	bool bForceResearchChoice;
	int iOverflowResearch;

	if(GetPlayerTechs()->IsResearch())
	{
		bForceResearchChoice = false;

		// Force player to pick Research if he doesn't have anything assigned
		if(GetPlayerTechs()->GetCurrentResearch() == NO_TECH)
		{
			if(GetID() == GC.getGame().getActivePlayer() && GetScienceTimes100() > 0)
			{
				chooseTech();
			}

			if(GC.getGame().getElapsedGameTurns() > 4)
			{
				AI_chooseResearch();

				bForceResearchChoice = true;
			}
		}

		TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
		if(eCurrentTech == NO_TECH)
		{
			int iOverflow = (GetScienceTimes100()) / 100;
			changeOverflowResearchTimes100(iOverflow);
		}
		else
		{
			iOverflowResearch = getOverflowResearchTimes100();
			setOverflowResearch(0);
			if(GET_TEAM(getTeam()).GetTeamTechs())
			{
				int iBeakersTowardsTechTimes100 = GetScienceTimes100() + iOverflowResearch;
				GET_TEAM(getTeam()).GetTeamTechs()->ChangeResearchProgressTimes100(eCurrentTech, iBeakersTowardsTechTimes100, GetID(), iOverflowResearch, 100);
				UpdateResearchAgreements(GetScienceTimes100() / 100);
			}
		}

		if(bForceResearchChoice)
		{
			clearResearchQueue();
		}
	}
	GetPlayerTechs()->CheckForTechAchievement();

}

//	--------------------------------------------------------------------------------
void CvPlayer::doAdvancedStartAction(AdvancedStartActionTypes eAction, int iX, int iY, int iData, bool bAdd)
{
	CvPlot* pPlot = GC.getMap().plot(iX, iY);

	if(0 == getNumCities())
	{
		switch(eAction)
		{
		case ADVANCEDSTARTACTION_EXIT:
			//Try to build this player's empire
			if(GetID() == GC.getGame().getActivePlayer())
			{
				GC.GetEngineUserInterface()->setBusy(true);
			}
			if(GetID() == GC.getGame().getActivePlayer())
			{
				GC.GetEngineUserInterface()->setBusy(false);
			}
			break;
		case ADVANCEDSTARTACTION_AUTOMATE:
		case ADVANCEDSTARTACTION_CITY:
			break;
		default:
			// The first action must be to place a city
			// so players can lose by spending everything
			return;
		}
	}

	switch(eAction)
	{
	case ADVANCEDSTARTACTION_EXIT:
		GetTreasury()->ChangeGold(getAdvancedStartPoints());
		setAdvancedStartPoints(-1);
		if(GC.getGame().getActivePlayer() == GetID())
		{
			GC.GetEngineUserInterface()->setInAdvancedStart(false);
		}

		if(isHuman())
		{
			int iLoop;
			for(CvCity* pCity = firstCity(&iLoop); NULL != pCity; pCity = nextCity(&iLoop))
			{
				pCity->chooseProduction();
			}

			chooseTech();
		}
		break;
	case ADVANCEDSTARTACTION_AUTOMATE:
		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setBusy(true);
		}
		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setBusy(false);
		}
		break;
	case ADVANCEDSTARTACTION_UNIT:
	{
		if(pPlot == NULL)
			return;

		UnitTypes eUnit = (UnitTypes) iData;
		int iCost = getAdvancedStartUnitCost(eUnit, bAdd, pPlot);

		if(bAdd && iCost < 0)
		{
			return;
		}

		// Add unit to the map
		if(bAdd)
		{
			if(getAdvancedStartPoints() >= iCost)
			{
				CvUnit* pUnit = initUnit(eUnit, iX, iY);
				if(NULL != pUnit)
				{
					pUnit->finishMoves();
					changeAdvancedStartPoints(-iCost);
				}
			}
		}

		// Remove unit from the map
		else
		{
			// If cost is -1 we already know this unit isn't present
			if(iCost != -1)
			{
				IDInfo* pUnitNode = pPlot->headUnitNode();
				while(pUnitNode != NULL)
				{
					CvUnit* pLoopUnit = ::GetPlayerUnit(*pUnitNode);
					pUnitNode = pPlot->nextUnitNode(pUnitNode);

					if(NULL != pLoopUnit && pLoopUnit->getUnitType() == eUnit)
					{
						pLoopUnit->kill(false);
						changeAdvancedStartPoints(iCost);
						return;
					}
				}
			}

			// Proper unit not found above, delete first found
			IDInfo* pUnitNode = pPlot->headUnitNode();
			if(pUnitNode != NULL)
			{
				CvUnit* pUnit = ::GetPlayerUnit(*pUnitNode);

				iCost = getAdvancedStartUnitCost(pUnit->getUnitType(), false);
				CvAssertMsg(iCost != -1, "If this is -1 then that means it's going to try to delete a unit which shouldn't exist");
				pUnit->kill(false);
				changeAdvancedStartPoints(iCost);
			}
		}

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Advanced_Start_DIRTY_BIT, true);
		}
	}
	break;
	case ADVANCEDSTARTACTION_CITY:
	{
		if(pPlot == NULL)
			return;

		int iCost = getAdvancedStartCityCost(bAdd, pPlot);

		if(iCost < 0)
		{
			return;
		}

		// Add City to the map
		if(bAdd)
		{
			if(0 == getNumCities())
			{
				PlayerTypes eClosestPlayer = NO_PLAYER;
				int iMinDistance = INT_MAX;
				for(int iPlayer = 0; iPlayer < MAX_CIV_PLAYERS; iPlayer++)
				{
					CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iPlayer);
					if(kPlayer.isAlive())
					{
						if(kPlayer.getTeam() == getTeam())
						{
							if(0 == kPlayer.getNumCities())
							{
								CvAssert(kPlayer.getStartingPlot() != NULL);
								int iDistance = plotDistance(iX, iY, kPlayer.getStartingPlot()->getX(), kPlayer.getStartingPlot()->getY());
								if(iDistance < iMinDistance)
								{
									eClosestPlayer = kPlayer.GetID();
									iMinDistance = iDistance;
								}
							}
						}
					}
				}
				CvAssertMsg(eClosestPlayer != NO_PLAYER, "Self at a minimum should always be valid");
				if(eClosestPlayer != GetID())
				{
					CvPlot* pTempPlot = GET_PLAYER(eClosestPlayer).getStartingPlot();
					GET_PLAYER(eClosestPlayer).setStartingPlot(getStartingPlot());
					setStartingPlot(pTempPlot);
				}
			}
			if(getAdvancedStartPoints() >= iCost || 0 == getNumCities())
			{
				foundCity(iX, iY);
				changeAdvancedStartPoints(-iCost);
				CvCity* pCity = pPlot->getPlotCity();
				if(pCity != NULL)
				{
					if(pCity->getPopulation() > 1)
					{
						pCity->setFood(pCity->growthThreshold() / 2);
					}
				}
			}
		}

		// Remove City from the map
		else
		{
			pPlot->setRouteType(NO_ROUTE);
			pPlot->getPlotCity()->kill();
			pPlot->setImprovementType(NO_IMPROVEMENT);
			changeAdvancedStartPoints(iCost);
		}

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Advanced_Start_DIRTY_BIT, true);
		}
	}
	break;
	case ADVANCEDSTARTACTION_POP:
	{
		if(pPlot == NULL)
			return;

		CvCity* pCity = pPlot->getPlotCity();

		if(pCity != NULL)
		{
			int iCost = getAdvancedStartPopCost(bAdd, pCity);

			if(iCost < 0)
			{
				return;
			}

			// Add Pop to the City
			if(bAdd)
			{
				if(getAdvancedStartPoints() >= iCost)
				{
					pCity->changePopulation(1);
					changeAdvancedStartPoints(-iCost);
					if(pCity->getPopulation() > 1)
					{
						pCity->setFood(pCity->growthThreshold() / 2);
					}
				}
			}

			// Remove Pop from the city
			else
			{
				pCity->changePopulation(-1);
				changeAdvancedStartPoints(iCost);
				if(pCity->getPopulation() == 1)
				{
					pCity->setFood(0);
				}
			}
		}
	}
	break;
	case ADVANCEDSTARTACTION_BUILDING:
	{
		if(pPlot == NULL)
			return;

		CvCity* pCity = pPlot->getPlotCity();

		if(pCity != NULL)
		{
			BuildingTypes eBuilding = (BuildingTypes) iData;

			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
			if(pkBuildingInfo == NULL)
			{
				return;
			}

			int iCost = getAdvancedStartBuildingCost(eBuilding, bAdd, pCity);
			if(iCost < 0)
			{
				return;
			}

			// Add Building to the City
			if(bAdd)
			{
				if(getAdvancedStartPoints() >= iCost)
				{
					pCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, pCity->GetCityBuildings()->GetNumRealBuilding(eBuilding)+1);
					changeAdvancedStartPoints(-iCost);
				}
			}

			// Remove Building from the map
			else
			{
				pCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, pCity->GetCityBuildings()->GetNumRealBuilding(eBuilding)-1);
				changeAdvancedStartPoints(iCost);
			}
		}

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Advanced_Start_DIRTY_BIT, true);
		}
	}
	break;
	case ADVANCEDSTARTACTION_ROUTE:
	{
		if(pPlot == NULL)
			return;

		RouteTypes eRoute = (RouteTypes) iData;
		int iCost = getAdvancedStartRouteCost(eRoute, bAdd, pPlot);

		if(bAdd && iCost < 0)
		{
			return;
		}

		// Add Route to the plot
		if(bAdd)
		{
			if(getAdvancedStartPoints() >= iCost)
			{
				pPlot->setRouteType(eRoute);
				changeAdvancedStartPoints(-iCost);
			}
		}

		// Remove Route from the Plot
		else
		{
			if(pPlot->getRouteType() != eRoute)
			{
				eRoute = pPlot->getRouteType();
				iCost = getAdvancedStartRouteCost(eRoute, bAdd);
			}

			if(iCost < 0)
			{
				return;
			}

			pPlot->setRouteType(NO_ROUTE);
			changeAdvancedStartPoints(iCost);
		}

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Advanced_Start_DIRTY_BIT, true);
		}
	}
	break;
	case ADVANCEDSTARTACTION_IMPROVEMENT:
	{
		if(pPlot == NULL)
			return;

		ImprovementTypes eImprovement = (ImprovementTypes) iData;
		int iCost = getAdvancedStartImprovementCost(eImprovement, bAdd, pPlot);

		if(bAdd && iCost < 0)
		{
			return;
		}

		// Add Improvement to the plot
		if(bAdd)
		{
			if(getAdvancedStartPoints() >= iCost)
			{
				if(pPlot->getFeatureType() != NO_FEATURE)
				{
					for(int iI = 0; iI < GC.getNumBuildInfos(); ++iI)
					{
						CvBuildInfo* pkBuildInfo = GC.getBuildInfo((BuildTypes) iI);
						if(!pkBuildInfo)
						{
							continue;
						}

						ImprovementTypes eLoopImprovement = ((ImprovementTypes)(pkBuildInfo->getImprovement()));

						if(eImprovement == eLoopImprovement)
						{
							if(pkBuildInfo->isFeatureRemove(pPlot->getFeatureType()) && canBuild(pPlot, (BuildTypes)iI))
							{
								pPlot->setFeatureType(NO_FEATURE);
								break;
							}
						}
					}
				}

				pPlot->setImprovementType(eImprovement, GetID());

				changeAdvancedStartPoints(-iCost);
			}
		}

		// Remove Improvement from the Plot
		else
		{
			if(pPlot->getImprovementType() != eImprovement)
			{
				eImprovement = pPlot->getImprovementType();
				iCost = getAdvancedStartImprovementCost(eImprovement, bAdd, pPlot);
			}

			if(iCost < 0)
			{
				return;
			}

			pPlot->setImprovementType(NO_IMPROVEMENT);
			changeAdvancedStartPoints(iCost);
		}

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Advanced_Start_DIRTY_BIT, true);
		}
	}
	break;
	case ADVANCEDSTARTACTION_TECH:
	{
		TechTypes eTech = (TechTypes) iData;
		int iCost = getAdvancedStartTechCost(eTech, bAdd);

		if(iCost < 0)
		{
			return;
		}

		// Add Tech to team
		if(bAdd)
		{
			if(getAdvancedStartPoints() >= iCost)
			{
				GET_TEAM(getTeam()).setHasTech(eTech, true, GetID(), false, false);
				changeAdvancedStartPoints(-iCost);
			}
		}

		// Remove Tech from the Team
		else
		{
			GET_TEAM(getTeam()).setHasTech(eTech, false, GetID(), false, false);
			changeAdvancedStartPoints(iCost);
		}

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Advanced_Start_DIRTY_BIT, true);
		}
	}
	break;
	case ADVANCEDSTARTACTION_VISIBILITY:
	{
		if(pPlot == NULL)
			return;

		int iCost = getAdvancedStartVisibilityCost(bAdd, pPlot);

		if(iCost < 0)
		{
			return;
		}

		// Add Visibility to the plot
		if(bAdd)
		{
			if(getAdvancedStartPoints() >= iCost)
			{
				pPlot->setRevealed(getTeam(), true, NULL, true);
				changeAdvancedStartPoints(-iCost);
			}
		}

		// Remove Visibility from the Plot
		else
		{
			pPlot->setRevealed(getTeam(), false, NULL, true);
			changeAdvancedStartPoints(iCost);
		}
	}
	break;
	default:
		CvAssert(false);
		break;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing a unit
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartUnitCost(UnitTypes eUnit, bool bAdd, CvPlot* pPlot)
{
	if(0 == getNumCities())
	{
		return -1;
	}

	CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
	if(pkUnitInfo == NULL)
	{
		return -1;
	}

	int iCost = (getProductionNeeded(eUnit) * pkUnitInfo->GetAdvancedStartCost()) / 100;
	if(iCost < 0)
	{
		return -1;
	}

	if(NULL == pPlot)
	{
		if(bAdd)
		{
			bool bValid = false;
			int iLoop;
			for(CvCity* pLoopCity = firstCity(&iLoop); NULL != pLoopCity; pLoopCity = nextCity(&iLoop))
			{
				if(pLoopCity->canTrain(eUnit))
				{
					bValid = true;
					break;
				}
			}

			if(!bValid)
			{
				return -1;
			}
		}
	}
	else
	{
		CvCity* pCity = NULL;

		if(/*0*/ GD_INT_GET(ADVANCED_START_ALLOW_UNITS_OUTSIDE_CITIES) == 0)
		{
			pCity = pPlot->getPlotCity();

			if(NULL == pCity || pCity->getOwner() != GetID())
			{
				return -1;
			}

			iCost *= 100;
			iCost /= std::max(1, 100 + pCity->getProductionModifier(eUnit));
		}
		else
		{
			if(pPlot->getOwner() != GetID())
			{
				return -1;
			}

			iCost *= 100;
			iCost /= std::max(1, 100 + getProductionModifier(eUnit));
		}


		if(bAdd)
		{
			int iMaxUnitsPerCity = /*2*/ GD_INT_GET(ADVANCED_START_MAX_UNITS_PER_CITY);
			if(iMaxUnitsPerCity >= 0)
			{
				if(pkUnitInfo->IsMilitarySupport() && getNumMilitaryUnits() >= iMaxUnitsPerCity * getNumCities())
				{
					return -1;
				}
			}

			if(NULL != pCity)
			{
				if(!pCity->canTrain(eUnit))
				{
					return -1;
				}
			}
			else
			{
				if(!pPlot->canTrain(eUnit))
				{
					return -1;
				}
				if(!pPlot->isValidMovePlot(GetID()))
				{
					return -1;
				}
			}
		}
		// Must be this unit at plot in order to remove
		else
		{
			bool bUnitFound = false;

			IDInfo* pUnitNode = pPlot->headUnitNode();
			while(pUnitNode != NULL)
			{
				CvUnit* pLoopUnit = ::GetPlayerUnit(*pUnitNode);
				pUnitNode = pPlot->nextUnitNode(pUnitNode);

				if(NULL != pLoopUnit && pLoopUnit->getUnitType() == eUnit)
				{
					bUnitFound = true;
				}
			}

			if(!bUnitFound)
			{
				return -1;
			}
		}
	}

	return iCost;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing a City
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartCityCost(bool bAdd, CvPlot* pPlot)
{
	int iNumCities = getNumCities();

	int iCost = getNewCityProductionValue();

	if(iCost < 0)
	{
		return -1;
	}

	// Valid plot?
	if(pPlot != NULL)
	{
		// Need valid plot to found on if adding
		if(bAdd)
		{
			if(!canFoundCity(pPlot->getX(), pPlot->getY()))
			{
				return -1;
			}
		}
		// Need your own city present to remove
		else
		{
			if(pPlot->isCity())
			{
				if(pPlot->getPlotCity()->getOwner() != GetID())
				{
					return -1;
				}
			}
			else
			{
				return -1;
			}
		}

		// Is there a distance limit on how far a city can be placed from a player's start/another city?
		if (/*6*/ GD_INT_GET(ADVANCED_START_CITY_PLACEMENT_MAX_RANGE) > 0)
		{
			PlayerTypes eClosestPlayer = NO_PLAYER;
			int iClosestDistance = INT_MAX;

			for(int iPlayer = 0; iPlayer < MAX_CIV_PLAYERS; ++iPlayer)
			{
				CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iPlayer);

				if(kPlayer.isAlive())
				{
					CvPlot* pStartingPlot = kPlayer.getStartingPlot();

					if(NULL != pStartingPlot)
					{
						int iDistance = ::plotDistance(pPlot->getX(), pPlot->getY(), pStartingPlot->getX(), pStartingPlot->getY());
						if (iDistance <= /*6*/ GD_INT_GET(ADVANCED_START_CITY_PLACEMENT_MAX_RANGE))
						{
							if(iDistance < iClosestDistance || (iDistance == iClosestDistance && getTeam() != kPlayer.getTeam()))
							{
								iClosestDistance = iDistance;
								eClosestPlayer = kPlayer.GetID();
							}
						}
					}
				}
			}

			if(NO_PLAYER == eClosestPlayer || GET_PLAYER(eClosestPlayer).getTeam() != getTeam())
			{
				return -1;
			}
			//Only allow founding a city at someone elses start point if
			//We have no cities and they have no cities.
			if((GetID() != eClosestPlayer) && ((getNumCities() > 0) || (GET_PLAYER(eClosestPlayer).getNumCities() > 0)))
			{
				return -1;
			}
		}
	}

	// Increase cost if the XML defines that additional units will cost more
	if (/*0*/ GD_INT_GET(ADVANCED_START_CITY_COST_INCREASE) != 0)
	{
		if (!bAdd)
			iNumCities--;

		if (iNumCities > 0)
		{
			iCost *= 100 + GD_INT_GET(ADVANCED_START_CITY_COST_INCREASE) * iNumCities;
			iCost /= 100;
		}
	}

	return iCost;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing Population
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartPopCost(bool bAdd, CvCity* pCity)
{
	if (getNumCities() == 0)
		return -1;

	int iCost = (getGrowthThreshold(1) * /*150*/ GD_INT_GET(ADVANCED_START_POPULATION_COST)) / 100;

	if (pCity)
	{
		if(pCity->getOwner() != GetID())
		{
			return -1;
		}

		int iPopulation = pCity->getPopulation();

		// Need to have Population to remove it
		if(!bAdd)
		{
			--iPopulation;

			if(iPopulation < /*1*/ GD_INT_GET(INITIAL_CITY_POPULATION) + GC.getGame().getStartEraInfo().getFreePopulation())
			{
				return -1;
			}
		}

		iCost = (getGrowthThreshold(iPopulation) * /*150*/ GD_INT_GET(ADVANCED_START_POPULATION_COST)) / 100;

		// Increase cost if the XML defines that additional Pop will cost more
		if (/*0*/ GD_INT_GET(ADVANCED_START_POPULATION_COST_INCREASE) != 0)
		{
			iPopulation--;

			if (iPopulation > 0)
			{
				iCost *= 100 + GD_INT_GET(ADVANCED_START_POPULATION_COST_INCREASE) * iPopulation;
				iCost /= 100;
			}
		}
	}

	return iCost;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing a Building from a city
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartBuildingCost(BuildingTypes eBuilding, bool bAdd, CvCity* pCity)
{
	if (getNumCities() == 0)
		return -1;

	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if (!pkBuildingInfo)
		return -1;

	int iCost = getProductionNeeded(eBuilding);

	if (iCost < 0)
		return -1;

	if(pkBuildingInfo->GetFreeStartEra() != NO_ERA && GC.getGame().getStartEra() >=  pkBuildingInfo->GetFreeStartEra())
	{
		// you get this building for free
		return -1;
	}

	if(NULL == pCity)
	{
		if(bAdd)
		{
			bool bValid = false;
			int iLoop;
			for(CvCity* pLoopCity = firstCity(&iLoop); NULL != pLoopCity; pLoopCity = nextCity(&iLoop))
			{
				if(pLoopCity->canConstruct(eBuilding))
				{
					bValid = true;
					break;
				}
			}

			if(!bValid)
			{
				return -1;
			}
		}
	}
	if(NULL != pCity)
	{
		if(pCity->getOwner() != GetID())
		{
			return -1;
		}

		iCost *= 100;
		iCost /= std::max(1, 100 + pCity->getProductionModifier(eBuilding));

		if(bAdd)
		{
			if(!pCity->canConstruct(eBuilding, true, false, false))
			{
				return -1;
			}
		}
		else
		{
			if(pCity->GetCityBuildings()->GetNumRealBuilding(eBuilding) <= 0)
			{
				return -1;
			}

			// Check other buildings in this city and make sure none of them require this one

			// Loop through Buildings to see which are present
			for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
			{
				const BuildingTypes eBuildingLoop = static_cast<BuildingTypes>(iBuildingLoop);
				CvBuildingEntry* pkBuildingLoopInfo = GC.getBuildingInfo(eBuildingLoop);
				if(pkBuildingLoopInfo)
				{
					if(pCity->GetCityBuildings()->GetNumBuilding(eBuildingLoop) > 0)
					{
						// Loop through present Building's requirements
						for(int iBuildingClassPrereqLoop = 0; iBuildingClassPrereqLoop < GC.getNumBuildingClassInfos(); iBuildingClassPrereqLoop++)
						{
							const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iBuildingClassPrereqLoop);
							CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
							if(pkBuildingClassInfo)
							{
								if(pkBuildingLoopInfo->IsBuildingClassNeededInCity(iBuildingClassPrereqLoop))
								{
									if((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(iBuildingClassPrereqLoop)) == eBuilding)
									{
										return -1;
									}
								}
#if defined(MOD_BALANCE_CORE)
								// Does this city have prereq buildings?
								if(MOD_BALANCE_CORE && pkBuildingLoopInfo->IsBuildingClassNeededAnywhere(iBuildingClassPrereqLoop))
								{
									int iNumBuildings = 0;
									BuildingTypes ePrereqBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(iBuildingClassPrereqLoop)));
									bool bRome = GetPlayerTraits()->IsKeepConqueredBuildings();

									if(ePrereqBuilding != NO_BUILDING || MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome)
									{
										CvCity* pLoopCity;
										int iLoop;
										for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
										{
											if(pLoopCity->GetCityBuildings()->GetNumBuilding(ePrereqBuilding) > 0 || ((MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome) && pLoopCity->HasBuildingClass(eBuildingClass)))
											{
												iNumBuildings++;
											}
										}
										if(iNumBuildings == 0)
										{
											return -1;
										}
									}
								}
								// Does this city have prereq buildings?
								if(MOD_BALANCE_CORE && pkBuildingLoopInfo->IsBuildingClassNeededNowhere(iBuildingClassPrereqLoop))
								{
									BuildingTypes ePrereqBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(iBuildingClassPrereqLoop)));
									bool bRome = GetPlayerTraits()->IsKeepConqueredBuildings();

									if(ePrereqBuilding != NO_BUILDING || MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome)
									{
										int iLoop;
										for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
										{
											if(pLoopCity->GetCityBuildings()->GetNumBuilding(ePrereqBuilding) > 0 || ((MOD_BUILDINGS_THOROUGH_PREREQUISITES || bRome) && pLoopCity->HasBuildingClass(eBuildingClass)))
											{
												return -1;
											}
										}
									}
								}
#endif
							}
						}
					}
				}
			}
		}
	}

	return iCost;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing Route
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartRouteCost(RouteTypes eRoute, bool bAdd, CvPlot* pPlot)
{
	if(0 == getNumCities())
	{
		return -1;
	}

	if(eRoute == NO_ROUTE)
	{
		return -1;
	}

	CvRouteInfo* pkRouteInfo = GC.getRouteInfo(eRoute);
	if(pkRouteInfo == NULL)
	{
		return -1;
	}

	int iCost = pkRouteInfo->getAdvancedStartCost();

	// This denotes cities may not be purchased through Advanced Start
	if(iCost < 0)
	{
		return -1;
	}

	iCost *= GC.getGame().getGameSpeedInfo().getBuildPercent();
	iCost /= 100;

	// No invalid plots!
	if(pPlot != NULL)
	{
		if(pPlot->isCity())
		{
			return -1;
		}

		if(bAdd)
		{
			if(!pPlot->isValidMovePlot(GetID()) || pPlot->isWater())
			{
				return -1;
			}
			// Can't place twice
			if(pPlot->getRouteType() == eRoute)
			{
				return -1;
			}
		}
		else
		{
			// Need Route to remove it
			if(pPlot->getRouteType() != eRoute)
			{
				return -1;
			}
		}

		// Must be owned by me
		if(pPlot->getOwner() != GetID())
		{
			return -1;
		}
	}

	// Tech requirement
	for(int iBuildLoop = 0; iBuildLoop < GC.getNumBuildInfos(); iBuildLoop++)
	{
		const BuildTypes eBuild = static_cast<BuildTypes>(iBuildLoop);
		CvBuildInfo* pkBuildInfo = GC.getBuildInfo(eBuild);
		if(pkBuildInfo)
		{
			if(pkBuildInfo->getRoute() == eRoute)
			{
				if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkBuildInfo->getTechPrereq())))
				{
					return -1;
				}
#if defined(MOD_BALANCE_CORE)
				else if(MOD_BALANCE_CORE && pkBuildInfo->getTechObsolete() != NO_TECH && (GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkBuildInfo->getTechObsolete())))
				{
					return -1;
				}
#endif
			}
		}
	}

	return iCost;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing Improvement
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartImprovementCost(ImprovementTypes eImprovement, bool bAdd, CvPlot* pPlot)
{
	if(eImprovement == NO_IMPROVEMENT)
	{
		return -1;
	}

	if(0 == getNumCities())
	{
		return -1;
	}

	int iCost = 0; //GC.getImprovementInfo(eImprovement)->GetAdvancedStartCost();

	// This denotes cities may not be purchased through Advanced Start
	if(iCost < 0)
	{
		return -1;
	}

	iCost *= GC.getGame().getGameSpeedInfo().getBuildPercent();
	iCost /= 100;

	// Can this Improvement be on our plot?
	if(pPlot != NULL)
	{
		if(bAdd)
		{
			// Valid Plot
			if(!pPlot->canHaveImprovement(eImprovement, GetID(), false))
			{
				return -1;
			}

			bool bValid = false;

			for(int iI = 0; iI < GC.getNumBuildInfos(); ++iI)
			{
				CvBuildInfo* pkBuildInfo = GC.getBuildInfo((BuildTypes) iI);
				if(!pkBuildInfo)
				{
					continue;
				}
				ImprovementTypes eLoopImprovement = ((ImprovementTypes)(pkBuildInfo->getImprovement()));

				if(eImprovement == eLoopImprovement && canBuild(pPlot, (BuildTypes)iI))
				{
					bValid = true;

					FeatureTypes eFeature = pPlot->getFeatureType();
					if(NO_FEATURE != eFeature && pkBuildInfo->isFeatureRemove(eFeature))
					{
						iCost += GC.getFeatureInfo(eFeature)->getAdvancedStartRemoveCost();
					}

					break;
				}
			}

			if(!bValid)
			{
				return -1;
			}

			// Can't place twice
			if(pPlot->getImprovementType() == eImprovement)
			{
				return -1;
			}
		}
		else
		{
			// Need this improvement in order to remove it
			if(pPlot->getImprovementType() != eImprovement)
			{
				return -1;
			}
		}

		// Must be owned by me
		if(pPlot->getOwner() != GetID())
		{
			return -1;
		}
	}

	// Tech requirement
	for(int iBuildLoop = 0; iBuildLoop < GC.getNumBuildInfos(); iBuildLoop++)
	{
		CvBuildInfo* pkBuildInfo = GC.getBuildInfo((BuildTypes) iBuildLoop);
		if(!pkBuildInfo)
		{
			continue;
		}

		if(pkBuildInfo->getImprovement() == eImprovement)
		{
			if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkBuildInfo->getTechPrereq())))
			{
				return -1;
			}
#if defined(MOD_BALANCE_CORE)
			else if(MOD_BALANCE_CORE && pkBuildInfo->getTechObsolete() != NO_TECH && (GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkBuildInfo->getTechObsolete())))
			{
				return -1;
			}
#endif
		}
	}

	return iCost;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing Tech
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartTechCost(TechTypes eTech, bool bAdd)
{
	if(eTech == NO_TECH)
	{
		return -1;
	}

	if(0 == getNumCities())
	{
		return -1;
	}

	int iCost = (GET_TEAM(getTeam()).GetTeamTechs()->GetResearchCost(eTech) * GC.getTechInfo(eTech)->GetAdvancedStartCost()) / 100;
	if(iCost < 0)
	{
		return -1;
	}

	if(bAdd)
	{
		if(!GetPlayerTechs()->CanResearch(eTech, false))
		{
			return -1;
		}
	}
	else if(!bAdd)
	{
		if(!GET_TEAM(getTeam()).GetTeamTechs()->HasTech(eTech))
		{
			return -1;
		}

		// Search through all techs to see if any of the currently owned ones requires this tech
		for(int iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)
		{
			TechTypes eTechLoop = (TechTypes) iTechLoop;

			if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech(eTechLoop))
			{
				int iPrereqLoop;

				// Or Prereqs
				for(iPrereqLoop = 0; iPrereqLoop < /*3*/ GD_INT_GET(NUM_OR_TECH_PREREQS); iPrereqLoop++)
				{
					if(GC.getTechInfo(eTechLoop)->GetPrereqOrTechs(iPrereqLoop) == eTech)
					{
						return -1;
					}
				}

				// And Prereqs
				for(iPrereqLoop = 0; iPrereqLoop < /*6*/ GD_INT_GET(NUM_AND_TECH_PREREQS); iPrereqLoop++)
				{
					if(GC.getTechInfo(eTechLoop)->GetPrereqAndTechs(iPrereqLoop) == eTech)
					{
						return -1;
					}
				}
			}
		}

		// If player has placed anything on the map which uses this tech then you cannot remove it
		int iLoop;

		// Units
		CvUnit* pLoopUnit;
		for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		{
			if(pLoopUnit->getUnitInfo().GetPrereqAndTech() == eTech)
			{
				return -1;
			}

			for(int iI = 0; iI < /*3*/ GD_INT_GET(NUM_UNIT_AND_TECH_PREREQS); iI++)
			{
				if(pLoopUnit->getUnitInfo().GetPrereqAndTechs(iI) == eTech)
				{
					return -1;
				}
			}
		}

		// Cities
		CvCity* pLoopCity;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			// All Buildings
			for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
			{
				const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
				CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
				if(pkBuildingInfo)
				{
					if(pLoopCity->GetCityBuildings()->GetNumRealBuilding(eBuilding) > 0)
					{
						if(pkBuildingInfo->GetPrereqAndTech() == eTech)
						{
							return -1;
						}

						for(int iI = 0; iI < /*3*/ GD_INT_GET(NUM_BUILDING_AND_TECH_PREREQS); iI++)
						{
							if(pkBuildingInfo->GetPrereqAndTechs(iI) == eTech)
							{
								return -1;
							}
						}
					}
				}
			}
		}

	}

	return iCost;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing Visibility
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartVisibilityCost(bool bAdd, CvPlot* pPlot)
{
	if (getNumCities() == 0)
		return -1;

	int iCost = /*2*/ GD_INT_GET(ADVANCED_START_VISIBILITY_COST);

	// This denotes Visibility may not be purchased through Advanced Start
	if (iCost == -1)
		return -1;

	// Valid Plot?
	if (pPlot)
	{
		if (bAdd)
		{
			if (pPlot->isRevealed(getTeam()))
			{
				return -1;
			}
			if (!pPlot->isAdjacentRevealed(getTeam()))
			{
				return -1;
			}
		}
		else
		{
			if (!pPlot->isRevealed(getTeam()))
			{
				return -1;
			}
		}
	}

	// Increase cost if the XML defines that additional units will cost more
	if (/*3*/ GD_INT_GET(ADVANCED_START_VISIBILITY_COST_INCREASE) != 0)
	{
		const int nPlots = GC.getMap().numPlots();
		int iNumVisiblePlots = 0;
		for (int iPlotLoop = 0; iPlotLoop < nPlots; iPlotLoop++)
		{
			CvPlot* pMapPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);

			if (pMapPlot->isRevealed(getTeam()))
			{
				iNumVisiblePlots++;
			}
		}

		if (!bAdd)
			iNumVisiblePlots--;

		if (iNumVisiblePlots > 0)
		{
			iCost *= 100 + /*3*/ GD_INT_GET(ADVANCED_START_VISIBILITY_COST_INCREASE) * iNumVisiblePlots;
			iCost /= 100;
		}
	}

	return iCost;
}

//	--------------------------------------------------------------------------------
void CvPlayer::doWarnings()
{
	if(m_eID == GC.getGame().getActivePlayer())
	{
		//update enemy units close to your territory
		int iMaxCount = range(((getNumCities() + 4) / 7), 2, 5);
		for(int iI = 0; iI < GC.getMap().numPlots(); iI++)
		{
			if(iMaxCount == 0)
			{
				break;
			}

			CvPlot* pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

			if(pLoopPlot->isAdjacentPlayer(GetID()))
			{
				if(!(pLoopPlot->isCity()))
				{
					if(pLoopPlot->isVisible(getTeam()))
					{
						CvUnit* pUnit = pLoopPlot->getVisibleEnemyDefender(GetID());
						if(pUnit != NULL)
						{
							CvCity* pNearestCity = GC.getMap().findCity(pLoopPlot->getX(), pLoopPlot->getY(), GetID(), NO_TEAM, !(pLoopPlot->isWater()));

							if(pNearestCity != NULL)
							{
								CvString message = GetLocalizedText("TXT_KEY_MISC_ENEMY_TROOPS_SPOTTED", pNearestCity->getNameKey());
								GC.GetEngineUserInterface()->AddPlotMessage(0, pLoopPlot->GetPlotIndex(), GetID(), true, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), message);

								iMaxCount--;
							}
						}
					}
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::processPolicies(PolicyTypes ePolicy, int iChange)
{
	int iI, iJ;

	CvPolicyEntry* pPolicy = GC.getPolicyInfo(ePolicy);
	if(pPolicy == NULL)
		return;

#if defined(MOD_TRAITS_OTHER_PREREQS)
	if (MOD_TRAITS_OTHER_PREREQS) {
		GetPlayerTraits()->InitPlayerTraits();
	}
#endif

	const CvPolicyEntry& kPolicy = (*pPolicy);

	ChangeCulturePerWonder(pPolicy->GetCulturePerWonder() * iChange);
	ChangeCultureWonderMultiplier(pPolicy->GetCultureWonderMultiplier() * iChange);
	ChangeCulturePerTechResearched(pPolicy->GetCulturePerTechResearched() * iChange);
	ChangeGoldenAgeMeterMod(pPolicy->GetGoldenAgeMeterMod() * iChange);
	changeGoldenAgeModifier(pPolicy->GetGoldenAgeDurationMod() * iChange);
	changeWorkerSpeedModifier(pPolicy->GetWorkerSpeedModifier() * iChange);
	changeImprovementCostModifier(pPolicy->GetImprovementCostModifier() * iChange);
	changeImprovementUpgradeRateModifier(pPolicy->GetImprovementUpgradeRateModifier() * iChange);
	changeSpecialistProductionModifier(pPolicy->GetSpecialistProductionModifier() * iChange);
	changeMilitaryProductionModifier(pPolicy->GetMilitaryProductionModifier() * iChange);
	changeBaseFreeUnits(pPolicy->GetBaseFreeUnits() * iChange);
	ChangeHappinessPerGarrisonedUnit(pPolicy->GetHappinessPerGarrisonedUnit() * iChange);
	ChangeHappinessPerTradeRoute(pPolicy->GetHappinessPerTradeRoute() * iChange);
	ChangeHappinessPerXPopulation(pPolicy->GetHappinessPerXPopulation() * iChange);
#if defined(MOD_BALANCE_CORE_POLICIES)
	ChangeGreatGeneralCombatBonus(pPolicy->GetGreatGeneralExtraBonus() * iChange);
	ChangeExtraSupplyPerPopulation(pPolicy->GetExtraSupplyPerPopulation() * iChange);
	ChangeCSAlliesLowersPolicyNeedWonders(pPolicy->GetXCSAlliesLowersPolicyNeedWonders() * iChange);
	ChangeHappinessPerXPopulationGlobal(pPolicy->GetHappinessPerXPopulationGlobal() * iChange);
	ChangeIdeologyPoint(pPolicy->GetIdeologyPoint() * iChange);
	ChangeNoXPLossUnitPurchase(pPolicy->IsNoXPLossUnitPurchase() * iChange);
	ChangeEventTourism(pPolicy->GetEventTourism() * iChange);
	ChangeEventTourismCS(pPolicy->GetEventTourismCS() * iChange);
	ChangeMonopolyModFlat(pPolicy->GetMonopolyModFlat() * iChange);
	ChangeMonopolyModPercent(pPolicy->GetMonopolyModPercent() * iChange);
	ChangeTRVisionBoost(pPolicy->GetTRVisionBoost() * iChange);
	ChangeTRSpeedBoost(pPolicy->GetTRSpeedBoost() * iChange);
	ChangeExtraHappinessPerXPoliciesFromPolicies(pPolicy->GetHappinessPerXPolicies() * iChange);
	ChangeHappinessPerXGreatWorks(pPolicy->GetHappinessPerXGreatWorks() * iChange);
	ChangeMissionaryExtraStrength(pPolicy->GetExtraMissionaryStrength() * iChange);
	ChangeNumMissionarySpreads(pPolicy->GetExtraMissionarySpreads() * iChange);

	ChangePositiveWarScoreTourismMod(pPolicy->GetPositiveWarScoreTourismMod() * iChange);

	ChangeIsNoCSDecayAtWar(pPolicy->IsNoCSDecayAtWar() * iChange);
	ChangeCanBullyFriendlyCS(pPolicy->CanBullyFriendlyCS() * iChange);
	ChangeBullyGlobalCSReduction(pPolicy->GetBullyGlobalCSReduction() * iChange);
	changeInfluenceForLiberation(pPolicy->GetInfluenceForLiberation() * iChange);
	changeExperienceForLiberation(pPolicy->GetExperienceForLiberation() * iChange);
	changeUnitsInLiberatedCities(pPolicy->GetUnitsInLiberatedCities() * iChange);
	changeMaxAirUnits(pPolicy->GetMaxAirUnitsChange() * iChange);
	changeCityCaptureHealGlobal(pPolicy->GetCityCaptureHealGlobal() * iChange);
	ChangeIsVassalsNoRebel(pPolicy->IsVassalsNoRebel() * iChange);
	ChangeVassalYieldBonusModifier(pPolicy->GetVassalYieldBonusModifier() * iChange);
	ChangeCSYieldBonusModifier(pPolicy->GetCSYieldBonusModifier() * iChange);

	if(pPolicy->GetCorporationOfficesAsFranchises() != 0)
	{
		GetCorporations()->SetCorporationOfficesAsFranchises(pPolicy->GetCorporationOfficesAsFranchises() * iChange);
		GetCorporations()->RecalculateNumFranchises();
	}
	if(pPolicy->GetCorporationRandomForeignFranchiseMod() != 0)
	{
		GetCorporations()->SetCorporationRandomForeignFranchiseMod(pPolicy->GetCorporationRandomForeignFranchiseMod());
		GetCorporations()->RecalculateNumFranchises();
	}
	if(pPolicy->GetCorporationFreeFranchiseAbovePopular() != 0)
	{
		GetCorporations()->SetCorporationFreeFranchiseAbovePopular(pPolicy->GetCorporationFreeFranchiseAbovePopular() * iChange);
		GetCorporations()->RecalculateNumFranchises();
	}
	if (pPolicy->GetAdditionalNumFranchisesMod() > 0)
	{
		GetCorporations()->ChangeAdditionalNumFranchisesMod(pPolicy->GetAdditionalNumFranchisesMod() * iChange);
	}
	if (pPolicy->GetAdditionalNumFranchises() > 0)
	{
		GetCorporations()->ChangeAdditionalNumFranchises(pPolicy->GetAdditionalNumFranchises() * iChange);
	}

	if (pPolicy->IsNoForeignCorpsInCities())
	{
		GetCorporations()->SetNoForeignCorpsInCities(pPolicy->IsNoForeignCorpsInCities() * iChange > 0);
	}
	if (pPolicy->IsNoFranchisesInForeignCities())
	{
		GetCorporations()->SetNoFranchisesInForeignCities(pPolicy->IsNoForeignCorpsInCities() * iChange > 0);
	}

	if(pPolicy->IsUpgradeCSVassalTerritory())
	{
		ChangeUpgradeCSVassalTerritory(pPolicy->IsUpgradeCSVassalTerritory() * iChange);
	}
	if(pPolicy->GetArchaeologicalDigTourism() != 0)
	{
		ChangeArchaeologicalDigTourism(pPolicy->GetArchaeologicalDigTourism() * iChange);
	}
	if(pPolicy->GetGoldenAgeTourism() != 0)
	{
		ChangeGoldenAgeTourism(pPolicy->GetGoldenAgeTourism() * iChange);
	}
	if (pPolicy->GetExtraCultureandScienceTradeRoutes() != 0)
	{
		ChangeExtraCultureandScienceTradeRoutes(pPolicy->GetExtraCultureandScienceTradeRoutes() * iChange);
	}
	ChangeRazingSpeedBonus(pPolicy->GetRazingSpeedBonus() * iChange);
	ChangeNoPartisans(pPolicy->IsNoPartisans() * iChange);

	if(pPolicy->GetTradeRouteLandDistanceModifier() != 0)
	{
		changeTradeRouteLandDistanceModifier(pPolicy->GetTradeRouteLandDistanceModifier() * iChange);
	}
	if(pPolicy->GetTradeRouteSeaDistanceModifier() != 0)
	{
		changeTradeRouteSeaDistanceModifier(pPolicy->GetTradeRouteSeaDistanceModifier() * iChange);
	}
	if(pPolicy->GetEspionageModifier() != 0)
	{
		ChangeEspionageModifier(pPolicy->GetEspionageModifier() * iChange);
	}
	ChangeGreatScientistBeakerMod(pPolicy->GetGreatScientistBeakerModifier() * iChange);
	ChangeGreatEngineerHurryMod(pPolicy->GetGreatEngineerHurryModifier() * iChange);
	ChangeTechCostXCitiesModifier(pPolicy->GetTechCostXCitiesMod() * iChange);
	ChangeTourismCostXCitiesMod(pPolicy->GetTourismCostXCitiesMod() * iChange);
#endif
	ChangeExtraHappinessPerLuxury(pPolicy->GetExtraHappinessPerLuxury() * iChange);
	ChangeUnhappinessFromUnitsMod(pPolicy->GetUnhappinessFromUnitsMod() * iChange);
	ChangeUnhappinessMod(pPolicy->GetUnhappinessMod() * iChange);
	ChangeCityCountUnhappinessMod(pPolicy->GetCityCountUnhappinessMod() * iChange);
	ChangeOccupiedPopulationUnhappinessMod(pPolicy->GetOccupiedPopulationUnhappinessMod() * iChange);
	ChangeCapitalUnhappinessMod(pPolicy->GetCapitalUnhappinessMod() * iChange);
	ChangeWoundedUnitDamageMod(pPolicy->GetWoundedUnitDamageMod() * iChange);
	ChangeUnitUpgradeCostMod(pPolicy->GetUnitUpgradeCostMod() * iChange);
	ChangeBarbarianCombatBonus(pPolicy->GetBarbarianCombatBonus() * iChange);
	ChangeAlwaysSeeBarbCampsCount(pPolicy->IsAlwaysSeeBarbCamps() * iChange);
	ChangeMaxNumBuilders(pPolicy->GetNumExtraBuilders() * iChange);
	ChangePlotGoldCostMod(pPolicy->GetPlotGoldCostMod() * iChange);
#if defined(MOD_POLICIES_CITY_WORKING)
	ChangeCityWorkingChange(pPolicy->GetCityWorkingChange() * iChange);
#endif
#if defined(MOD_POLICIES_CITY_AUTOMATON_WORKERS)
	ChangeCityAutomatonWorkersChange(pPolicy->GetCityAutomatonWorkersChange() * iChange);
#endif
	ChangePlotCultureCostModifier(pPolicy->GetPlotCultureCostModifier() * iChange);
	ChangePlotCultureExponentModifier(pPolicy->GetPlotCultureExponentModifier() * iChange);
	ChangeNumCitiesPolicyCostDiscount(pPolicy->GetNumCitiesPolicyCostDiscount() * iChange);
	ChangeGarrisonFreeMaintenanceCount(pPolicy->IsGarrisonFreeMaintenance() * iChange);
	ChangeGarrisonedCityRangeStrikeModifier(pPolicy->GetGarrisonedCityRangeStrikeModifier() * iChange);
	ChangeUnitPurchaseCostModifier(pPolicy->GetUnitPurchaseCostModifier() * iChange);
	GetTreasury()->ChangeCityConnectionTradeRouteGoldModifier(pPolicy->GetCityConnectionTradeRouteGoldModifier() * iChange);
	changeGoldPerUnit(pPolicy->GetGoldPerUnit() * iChange);
	changeGoldPerMilitaryUnit(pPolicy->GetGoldPerMilitaryUnit() * iChange);
	ChangeCityStrengthMod(pPolicy->GetCityStrengthMod() * iChange);
	ChangeCityGrowthMod(pPolicy->GetCityGrowthMod() * iChange);
	ChangeCapitalGrowthMod(pPolicy->GetCapitalGrowthMod() * iChange);
	changeSettlerProductionModifier(pPolicy->GetSettlerProductionModifier() * iChange);
	changeCapitalSettlerProductionModifier(pPolicy->GetCapitalSettlerProductionModifier() * iChange);
	ChangeImprovementGoldMaintenanceMod(pPolicy->GetImprovementGoldMaintenanceMod() * iChange);
#if defined(MOD_CIV6_WORKER)
	ChangeRouteBuilderCostMod(pPolicy->GetRouteBuilderCostMod() * iChange);
#endif
	ChangeBuildingGoldMaintenanceMod(pPolicy->GetBuildingGoldMaintenanceMod() * iChange);
	ChangeUnitGoldMaintenanceMod(pPolicy->GetUnitGoldMaintenanceMod() * iChange);
	ChangeUnitSupplyMod(pPolicy->GetUnitSupplyMod() * iChange);
	changeHappyPerMilitaryUnit(pPolicy->GetHappyPerMilitaryUnit() * iChange);
	changeHappinessToCulture(pPolicy->GetHappinessToCulture() * iChange);
	changeHappinessToScience(pPolicy->GetHappinessToScience() * iChange);
	changeHalfSpecialistUnhappinessCount((pPolicy->IsHalfSpecialistUnhappiness()) ? iChange : 0);
	changeHalfSpecialistFoodCount((pPolicy->IsHalfSpecialistFood()) ? iChange : 0);
#if defined(MOD_BALANCE_CORE)
	changeHalfSpecialistFoodCapitalCount((pPolicy->IsHalfSpecialistFoodCapital()) ? iChange : 0);
#endif
	changeMilitaryFoodProductionCount((pPolicy->IsMilitaryFoodProduction()) ? iChange : 0);
	ChangeGoldenAgeCultureBonusDisabledCount((pPolicy->IsGoldenAgeCultureBonusDisabled()) ? iChange : 0);
	ChangeSecondReligionPantheonCount((pPolicy->IsSecondReligionPantheon()) ? iChange : 0);
	ChangeEnablesSSPartHurryCount((pPolicy->IsEnablesSSPartHurry()) ? iChange : 0);
	ChangeEnablesSSPartPurchaseCount((pPolicy->IsEnablesSSPartPurchase()) ? iChange : 0);
	changeMaxConscript(getWorldSizeMaxConscript(kPolicy) * iChange);
	changeExpModifier(pPolicy->GetExpModifier() * iChange);
	changeExpInBorderModifier(pPolicy->GetExpInBorderModifier() * iChange);
	changeMinorQuestFriendshipMod(pPolicy->GetMinorQuestFriendshipMod() * iChange);
	changeMinorGoldFriendshipMod(pPolicy->GetMinorGoldFriendshipMod() * iChange);
	ChangeMinorFriendshipAnchorMod(pPolicy->GetMinorFriendshipMinimum() * iChange);
	changeGetMinorFriendshipDecayMod(pPolicy->GetMinorFriendshipDecayMod() * iChange);
	ChangeMinorScienceAlliesCount(pPolicy->IsMinorScienceAllies() * iChange);
	ChangeMinorResourceBonusCount(pPolicy->IsMinorResourceBonus() * iChange);
	ChangeNewCityExtraPopulation(pPolicy->GetNewCityExtraPopulation() * iChange);
	ChangeFreeFoodBox(pPolicy->GetFreeFoodBox() * iChange);
	ChangeStrategicResourceMod(pPolicy->GetStrategicResourceMod() * iChange);

#if defined(MOD_BALANCE_CORE)
	if(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES_STRATEGIC && pPolicy->GetStrategicResourceMod() > 0)
	{
		for(int iLoop = 0; iLoop < GC.getNumResourceInfos(); iLoop++)
		{
			const ResourceTypes eResource = static_cast<ResourceTypes>(iLoop);
			CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
			if(pkResource && pkResource->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)
			{
				CheckForMonopoly(eResource);
			}
		}
	}
	for (iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
	{
		const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
		CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
		if (pkUnitClassInfo && pPolicy->GetUnitClassProductionModifiers(iI) != 0)
		{
			ChangeUnitClassProductionModifier(eUnitClass, (pPolicy->GetUnitClassProductionModifiers(iI) * iChange));
		}
	}
	
#endif
	ChangeAbleToAnnexCityStatesCount((pPolicy->IsAbleToAnnexCityStates()) ? iChange : 0);
	ChangeOnlyTradeSameIdeology((pPolicy->IsOnlyTradeSameIdeology()) ? iChange : 0);
	if (pPolicy->IsOnlyTradeSameIdeology())
	{
		for (int i = 0; i < MAX_CIV_PLAYERS; i++)
		{
			PlayerTypes eOtherPlayer = (PlayerTypes)i;
			if (eOtherPlayer != GetID() && GET_PLAYER(eOtherPlayer).isAlive() && !GET_PLAYER(eOtherPlayer).isMinorCiv())
			{
				if(GET_PLAYER(eOtherPlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE)
				{
					if (GET_PLAYER(eOtherPlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != GetPlayerPolicies()->GetLateGamePolicyTree())
					{
						GC.getGame().GetGameTrade()->CancelTradeBetweenTeams(GET_PLAYER(eOtherPlayer).getTeam(), getTeam());
					}
				}
			}
		}
	}

	if(MOD_BALANCE_CORE_HAPPINESS)
	{
		ChangePovertyUnhappinessMod(pPolicy->GetPovertyHappinessChangePolicy() * iChange);
		ChangeDefenseUnhappinessMod(pPolicy->GetDefenseHappinessChangePolicy() * iChange);
		ChangeUnculturedUnhappinessMod(pPolicy->GetUnculturedHappinessChangePolicy() * iChange);
		ChangeIlliteracyUnhappinessMod(pPolicy->GetIlliteracyHappinessChangePolicy() * iChange);
		ChangeMinorityUnhappinessMod(pPolicy->GetMinorityHappinessChangePolicy() * iChange);
		ChangePovertyUnhappinessModCapital(pPolicy->GetPovertyHappinessChangePolicyCapital() * iChange);
		ChangeDefenseUnhappinessModCapital(pPolicy->GetDefenseHappinessChangePolicyCapital() * iChange);
		ChangeUnculturedUnhappinessModCapital(pPolicy->GetUnculturedHappinessChangePolicyCapital() * iChange);
		ChangeIlliteracyUnhappinessModCapital(pPolicy->GetIlliteracyHappinessChangePolicyCapital() * iChange);
		ChangeMinorityUnhappinessModCapital(pPolicy->GetMinorityHappinessChangePolicyCapital() * iChange);
		ChangeNoUnhappfromXSpecialists(pPolicy->GetNoUnhappfromXSpecialists() * iChange);
		ChangeHappfromXSpecialists(pPolicy->GetHappfromXSpecialists() * iChange);
		ChangeNoUnhappfromXSpecialistsCapital(pPolicy->GetNoUnhappfromXSpecialistsCapital() * iChange);
		ChangeSpecialistFoodChange(pPolicy->GetSpecialistFoodChange() * iChange);
		ChangeWarWearinessModifier(pPolicy->GetWarWearinessModifier() * iChange);
		ChangeWarScoreModifier(pPolicy->GetWarScoreModifier() * iChange);
	}

	if(MOD_BALANCE_CORE_POLICIES)
	{
		if (pPolicy->GetDefenseBoost() != 0)
		{
			int iLoop;
			CvCity* pLoopCity;
			for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				pLoopCity->updateStrengthValue();
			}
		}
		for (iI = 0; iI < GC.getNumResourceInfos(); iI++)
		{
			changeResourceFromCSAlliances((ResourceTypes)iI, (pPolicy->GetResourceFromCSAlly(iI) * iChange));
		}
		ChangeNoUnhappinessExpansion(pPolicy->GetNoUnhappinessExpansion() * iChange);
		ChangeNoUnhappyIsolation(pPolicy->GetNoUnhappyIsolation() * iChange);
		ChangeDoubleBorderGrowthGA(pPolicy->GetDoubleBorderGrowthGA() * iChange);
		ChangeDoubleBorderGrowthWLTKD(pPolicy->GetDoubleBorderGrowthWLTKD() * iChange);
		changeGarrisonsOccupiedUnhapppinessMod(pPolicy->GetGarrisonsOccupiedUnhapppinessMod() * iChange);
		changeTradeReligionModifier(pPolicy->GetTradeReligionModifier() * iChange);
		changeFreeWCVotes(pPolicy->GetFreeWCVotes() * iChange);
		if (pPolicy->GetIncreasedQuestInfluence() != 0)
		{
			ChangeIncreasedQuestInfluence(pPolicy->GetIncreasedQuestInfluence() * iChange);
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
			{
				PlayerTypes ePlayer = (PlayerTypes)iPlayerLoop;
				CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);
				if (ePlayer != NO_PLAYER && kPlayer.isMinorCiv() && kPlayer.isAlive())
				{
					kPlayer.GetMinorCivAI()->RecalculateRewards(GetID());				
				}
			}
		}
		changeCultureBombBoost(pPolicy->GetCultureBombBoost() * iChange);
		changePuppetProdMod(pPolicy->GetPuppetProdMod() * iChange);
		changeOccupiedProdMod(pPolicy->GetOccupiedProdMod() * iChange);
		changeGoldInternalTrade(pPolicy->GetInternalTradeGold() * iChange);
		changeInfluenceGPExpend(pPolicy->GetInfluenceGPExpend() * iChange);
		changeFreeTradeRoute(pPolicy->GetFreeTradeRoute() * iChange);
		changeFreeSpy(pPolicy->GetFreeSpy() * iChange);

		changeReligionDistance(pPolicy->GetReligionDistance() * iChange);
		changePressureMod(pPolicy->GetPressureMod() * iChange);

		changeCityStateCombatModifier(pPolicy->GetCityStateCombatModifier() * iChange);

		if(GetFreeSpy() > 0)
		{
			CvPlayerEspionage* pEspionage = GetEspionage();
			CvAssertMsg(pEspionage, "pEspionage is null! What's up with that?!");
			if(pEspionage)
			{
				int iNumSpies = GetFreeSpy();

				if (MOD_BALANCE_CORE_SPIES) 
				{
					//Optional: Spies scaled for the number of City-States in the game.
					int iNumMinor = ((GC.getGame().GetNumMinorCivsEver(true) * /*10*/ GD_INT_GET(BALANCE_SPY_TO_MINOR_RATIO)) / 100);
					if(iNumMinor > 1)
					{
						iNumSpies += iNumMinor;
					}
				}

				for(int i = 0; i < iNumSpies; i++)
				{
					pEspionage->CreateSpy();
				}
				changeFreeSpy(GetFreeSpy() * -1);
			}
		}
		
		int iLoop;
		CvCity* pLoopCity;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pPolicy->GetFreePopulation() > 0)
			{
				pLoopCity->changePopulation(pPolicy->GetFreePopulation(), true, true);
			}
			if (pPolicy->GetFreePopulationCapital() > 0 && pLoopCity->isCapital())
			{
				pLoopCity->changePopulation(pPolicy->GetFreePopulationCapital(), true, true);
			}
		}
		changeExtraMoves(pPolicy->GetExtraMoves() * iChange);

		if(pPolicy->GetXPopulationConscription() > 0)
		{
			changeXPopulationConscription(pPolicy->GetXPopulationConscription() * iChange);
			int iLoop;
			for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				if(pLoopCity == NULL)
				{
					continue;
				}
				if(pLoopCity->getPopulation() < GetXPopulationConscription())
				{
					continue;
				}
				if(pLoopCity->IsRazing())
				{
					continue;
				}
				if (GetNumUnitsOutOfSupply() > 0)
				{
					continue;
				}
				DoXPopulationConscription(pLoopCity);
			}
		}
	}

#if defined(MOD_BALANCE_CORE_BUILDING_INVESTMENTS)
	changeInvestmentModifier(pPolicy->GetInvestmentModifier() * iChange);

	changeMissionInfluenceModifier(pPolicy->GetMissionInfluenceModifier() * iChange);
	changeHappinessPerActiveTradeRoute(pPolicy->GetHappinessPerActiveTradeRoute() * iChange);
	changeCSResourcesCountMonopolies(pPolicy->IsCSResourcesForMonopolies() ? iChange : 0);

	changeNeedsModifierFromAirUnits(pPolicy->GetNeedsModifierFromAirUnits() * iChange);
	changeFlatDefenseFromAirUnits(pPolicy->GetFlatDefenseFromAirUnits() * iChange);
	changePuppetYieldPenaltyMod(pPolicy->GetPuppetYieldPenaltyMod() * iChange);
	changeConquestPerEraBuildingProductionMod(pPolicy->GetConquestPerEraBuildingProductionMod() * iChange);
	changeAdmiralLuxuryBonus(pPolicy->GetAdmiralLuxuryBonus() * iChange);

#endif

	if (MOD_POLICIES_UNIT_CLASS_REPLACEMENTS && pPolicy->IsUnitClassReplacements() && iChange != 0) // let's not execute the loop unless we need it
	{
		std::map<UnitClassTypes, UnitClassTypes> piUnitClassReplacements = pPolicy->GetUnitClassReplacements();
		for (std::map<UnitClassTypes, UnitClassTypes>::const_iterator it = piUnitClassReplacements.begin(); it != piUnitClassReplacements.end(); it++)
		{
			UnitClassTypes eReplacedUnitClass = it->first;
			UnitClassTypes eReplacementUnitClass = it->second;

			if (iChange > 0)
			{
				SetUnitClassReplacement(eReplacedUnitClass, eReplacementUnitClass);
			}
			else
			{
				SetUnitClassReplacement(eReplacedUnitClass, NO_UNITCLASS);
			}
		}
	}

	if(pPolicy->IsOneShot())
	{
		if(m_pPlayerPolicies->HasOneShotPolicyFired(ePolicy))
		{
			return;
		}
		else
		{
			m_pPlayerPolicies->SetOneShotPolicyFired(ePolicy,true);
		}
	}

	GetPlayerPolicies()->ChangeNumExtraBranches(pPolicy->GetNumExtraBranches() * iChange);

	ChangeAllFeatureProduction(pPolicy->GetAllFeatureProduction());

	int iMod;
	YieldTypes eYield;

	for(iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		eYield = (YieldTypes) iI;

#if defined(MOD_BALANCE_CORE_POLICIES)
		changeYieldFromBirth(eYield, (pPolicy->GetYieldFromBirth(iI) * iChange));
		changeYieldFromBirthCapital(eYield, (pPolicy->GetYieldFromBirthCapital(iI) * iChange));

		changeYieldFromConstruction(eYield, (pPolicy->GetYieldFromConstruction(iI) * iChange));
		ChangeYieldFromWorldWonderConstruction(eYield, (pPolicy->GetYieldFromWorldWonderConstruction(iI) * iChange));

		changeYieldFromTech(eYield, (pPolicy->GetYieldFromTech(iI) * iChange));
		if (pPolicy->GetYieldFromTechRetroactive(eYield) != 0)
		{
			int iTechValue = (GET_TEAM(getTeam() ).GetTeamTechs()->GetNumTechsKnown()-1) * pPolicy->GetYieldFromTechRetroactive(iI);

			if (iTechValue > 0)
				doInstantYield(INSTANT_YIELD_TYPE_TECH_RETROACTIVE, false, NO_GREATPERSON, NO_BUILDING, iTechValue, false, NO_PLAYER, NULL, false, getCapitalCity(), false, true, true, eYield);
		}
		changeYieldFromBorderGrowth(eYield, (pPolicy->GetYieldFromBorderGrowth(iI) * iChange));
		changeYieldGPExpend(eYield, (pPolicy->GetYieldGPExpend(iI) * iChange));
		changeConquerorYield(eYield, (pPolicy->GetConquerorYield(iI) * iChange));
		changeReligionYieldRateModifier(eYield, (pPolicy->GetReligionYieldMod(iI) * iChange));
		changeGoldenAgeYieldMod(eYield, (pPolicy->GetGoldenAgeYieldMod(iI) * iChange));
		changeFounderYield(eYield, (pPolicy->GetFounderYield(iI) * iChange));

		changeArtifactYieldBonus(eYield, (pPolicy->GetArtifactYieldChanges(iI) * iChange));
		changeArtYieldBonus(eYield, (pPolicy->GetArtYieldChanges(iI) * iChange));
		changeMusicYieldBonus(eYield, (pPolicy->GetMusicYieldChanges(iI) * iChange));
		changeLitYieldBonus(eYield, (pPolicy->GetLitYieldChanges(iI) * iChange));
		changeFilmYieldBonus(eYield, (pPolicy->GetFilmYieldChanges(iI) * iChange));
		changeRelicYieldBonus(eYield, (pPolicy->GetRelicYieldChanges(iI) * iChange));

		changeYieldFromNonSpecialistCitizens(eYield, (pPolicy->GetYieldFromNonSpecialistCitizens(iI) * iChange));
		changeYieldModifierFromGreatWorks(eYield, (pPolicy->GetYieldModifierFromGreatWorks(iI) * iChange));
		changeYieldModifierFromActiveSpies(eYield, (pPolicy->GetYieldModifierFromActiveSpies(iI) * iChange));
		changeYieldFromDelegateCount(eYield, (pPolicy->GetYieldFromDelegateCount(iI) * iChange));

		changeYieldForLiberation(eYield, (pPolicy->GetYieldForLiberation(iI) * iChange));

		if (pPolicy->GetYieldFromBirthRetroactive(eYield) != 0)
		{
			int iLoop;
			for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				int iVal = pLoopCity->getPopulation() * pPolicy->GetYieldFromBirthRetroactive(eYield);
				doInstantYield(INSTANT_YIELD_TYPE_BIRTH_RETROACTIVE, false, NO_GREATPERSON, NO_BUILDING, iVal, true, NO_PLAYER, NULL, false, pLoopCity, false, true, false, eYield);
			}
		}

		if (pPolicy->GetYieldFromBirthCapitalRetroactive(eYield) != 0)
		{
			if (getCapitalCity() != NULL)
			{
				int iVal = getCapitalCity()->getPopulation() * pPolicy->GetYieldFromBirthCapitalRetroactive(eYield);
				doInstantYield(INSTANT_YIELD_TYPE_BIRTH_RETROACTIVE, false, NO_GREATPERSON, NO_BUILDING, iVal, true, NO_PLAYER, NULL, false, getCapitalCity(), false, true, false, eYield);
			}
		}
#endif

		iMod = pPolicy->GetYieldModifier(iI) * iChange;
		if(iMod != 0)
			changeYieldRateModifier(eYield, iMod);

		iMod = pPolicy->GetCityYieldChange(iI) * iChange;
		if(iMod != 0)
			ChangeCityYieldChangeTimes100(eYield, iMod * 100);

		iMod = pPolicy->GetCoastalCityYieldChange(iI) * iChange;
		if(iMod != 0)
			ChangeCoastalCityYieldChange(eYield, iMod);

		iMod = pPolicy->GetCapitalYieldChange(iI) * iChange;
		if(iMod != 0)
			ChangeCapitalYieldChangeTimes100(eYield, iMod * 100);

		iMod = pPolicy->GetCapitalYieldPerPopChange(iI) * iChange;
		if(iMod != 0)
			ChangeCapitalYieldPerPopChange(eYield, iMod);

		iMod = pPolicy->GetCapitalYieldPerPopChangeEmpire(iI) * iChange;
		if (iMod != 0)
			ChangeCapitalYieldPerPopChangeEmpire(eYield, iMod);

		iMod = pPolicy->GetCapitalYieldModifier(iI) * iChange;
		if(iMod != 0)
			changeCapitalYieldRateModifier(eYield, iMod);

		iMod = pPolicy->GetGreatWorkYieldChange(iI) * iChange;
		if(iMod != 0)
			ChangeGreatWorkYieldChange(eYield, iMod);

		iMod = pPolicy->GetSpecialistExtraYield(iI) * iChange;
		if(iMod != 0)
			changeSpecialistExtraYield(eYield, iMod);

		iMod = pPolicy->GetYieldFromKills(iI) * iChange;
		if(iMod != 0)
			changeYieldFromKills(eYield, iMod);

		iMod = pPolicy->GetYieldFromBarbarianKills(iI) * iChange;
		if(iMod != 0)
			changeYieldFromBarbarianKills(eYield, iMod);

		iMod = pPolicy->GetYieldChangeTradeRoute(iI) * iChange;
		if(iMod != 0)
			ChangeYieldChangeTradeRoute(eYield, iMod);

		iMod = pPolicy->GetYieldChangesNaturalWonder(iI) * iChange;
		if(iMod != 0)
			ChangeYieldChangesNaturalWonder(eYield, iMod);

		iMod = pPolicy->GetYieldChangesPerReligionTimes100(iI) * iChange;
		if (iMod != 0)
			ChangeYieldChangesPerReligionTimes100(eYield, iMod);

		iMod = pPolicy->GetYieldChangeWorldWonder(iI) * iChange;
		if(iMod != 0)
			ChangeYieldChangeWorldWonder(eYield, iMod);

		iMod = pPolicy->GetYieldFromMinorDemand(iI) * iChange;
		if(iMod != 0)
			ChangeYieldFromMinorDemand(eYield, iMod);

		iMod = pPolicy->GetYieldFromWLTKD(iI) * iChange;
		if (iMod != 0)
			ChangeYieldFromWLTKD(eYield, iMod);
	}

	for(iI = 0; iI < GC.getNumUnitCombatClassInfos(); iI++)
	{
		changeUnitCombatProductionModifiers((UnitCombatTypes)iI, (pPolicy->GetUnitCombatProductionModifiers(iI) * iChange));
		changeUnitCombatFreeExperiences((UnitCombatTypes)iI, (pPolicy->GetUnitCombatFreeExperiences(iI) * iChange));
	}

	for(iI = 0; iI < GC.getNumHurryInfos(); iI++)
	{
		if(GC.getHurryInfo((HurryTypes) iI)->getPolicyPrereq() == ePolicy)
		{
			changeHurryCount(((HurryTypes)iI), iChange);
		}
		{
			changeHurryModifier((HurryTypes) iI, (pPolicy->GetHurryModifier(iI) * iChange));
		}
	}

	for(iI = 0; iI < GC.getNumPlotInfos(); iI++)
	{
		for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
		{
			changePlotYieldChange(((PlotTypes)iI), ((YieldTypes)iJ), (pPolicy->GetPlotYieldChanges(iI, iJ) * iChange));
		}
	}

	for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
	{
		for(iI = 0; iI < GC.getNumFeatureInfos(); iI++)
		{
			changeFeatureYieldChange(((FeatureTypes)iI), ((YieldTypes)iJ), (pPolicy->GetFeatureYieldChanges(iI, iJ) * iChange));
		}

		for(iI = 0; iI < GC.getNumFeatureInfos(); iI++)
		{
			changeCityYieldFromUnimprovedFeature(((FeatureTypes)iI), ((YieldTypes)iJ), (pPolicy->GetCityYieldFromUnimprovedFeature(iI, iJ) * iChange));
			changeUnimprovedFeatureYieldChange(((FeatureTypes)iI), ((YieldTypes)iJ), (pPolicy->GetUnimprovedFeatureYieldChanges(iI, iJ) * iChange));
		}

		for(iI = 0; iI < GC.getNumResourceInfos(); iI++)
		{
			changeResourceYieldChange(((ResourceTypes)iI), ((YieldTypes)iJ), (pPolicy->GetResourceYieldChanges(iI, iJ) * iChange));
		}

		for(iI = 0; iI < GC.getNumTerrainInfos(); iI++)
		{
			changeTerrainYieldChange(((TerrainTypes)iI), ((YieldTypes)iJ), (pPolicy->GetTerrainYieldChanges(iI, iJ) * iChange));
		}

		for(iI = 0; iI < NUM_DOMAIN_TYPES; iI++)
		{
			changeTradeRouteYieldChange(((DomainTypes)iI), ((YieldTypes)iJ), (pPolicy->GetTradeRouteYieldChange(iI, iJ) * iChange));
		}

		for(iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
		{
			changeSpecialistYieldChange(((SpecialistTypes)iI), ((YieldTypes)iJ), (pPolicy->GetSpecialistYieldChanges(iI, iJ) * iChange));
		}

		for(iI = 0; iI < GC.getNumGreatPersonInfos(); iI++)
		{
			changeGreatPersonExpendedYield(((GreatPersonTypes)iI), ((YieldTypes)iJ), (pPolicy->GetGreatPersonExpendedYield(iI, iJ) * iChange));
		}
	}

	for(iI = 0; iI < GC.getNumGreatPersonInfos(); iI++)
	{
		iMod = pPolicy->GetGoldenAgeGreatPersonRateModifier(iI) * iChange;
		if(iMod != 0)
			changeGoldenAgeGreatPersonRateModifier((GreatPersonTypes)iI, iMod);
	}

	for(iI = 0; iI < GC.getNumImprovementInfos(); iI++)
	{
		for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
		{
			changeImprovementYieldChange(((ImprovementTypes)iI), ((YieldTypes)iJ), (pPolicy->GetImprovementYieldChanges(iI, iJ) * iChange));
		}
	
		if (pPolicy->getFranchisesPerImprovement(iI) != 0)
		{
			GetCorporations()->ChangeFranchisesPerImprovement((ImprovementTypes)iI, pPolicy->getFranchisesPerImprovement(iI) * iChange);
			GetCorporations()->RecalculateNumFranchises();
		}
	}

	for (iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
	{
		if (pPolicy->GetBuildingClassInLiberatedCities(iI) > 0)
		{
			changeNumBuildingClassInLiberatedCities((BuildingClassTypes)iI, pPolicy->GetBuildingClassInLiberatedCities(iI) * iChange);
		}
	}

	// Free Promotions
	PromotionTypes ePromotion;
	for(iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		ePromotion = (PromotionTypes) iI;

		if(pPolicy->IsFreePromotion(ePromotion))
			ChangeFreePromotionCount(ePromotion, iChange);
	}

	CvCity* pLoopCity;
	PlayerTypes ePlayer;

	// All player Capital Locations Revealed
	if(pPolicy->IsRevealAllCapitals())
	{
		for(iI = 0; iI < MAX_CIV_PLAYERS; iI++)
		{
			ePlayer = (PlayerTypes) iI;

			if(GET_PLAYER(ePlayer).isAlive())
			{
				pLoopCity = GET_PLAYER(ePlayer).getCapitalCity();

				if(pLoopCity != NULL)
				{
					pLoopCity->plot()->setRevealed(getTeam(), true);
				}
			}
		}
	}

	// Friendship Decay for OTHER PLAYERS
	CvNotifications* pNotifications;
	Localization::String locString;
	Localization::String locSummary;

	int iOtherPlayersDecay = pPolicy->GetOtherPlayersMinorFriendshipDecayMod();
	if(iOtherPlayersDecay != 0)
	{
		for(iI = 0; iI < MAX_MAJOR_CIVS; iI++)
		{
			ePlayer = (PlayerTypes) iI;

			if(GET_PLAYER(ePlayer).isEverAlive())
			{
				// Don't hurt us or teammates
				if(GET_PLAYER(ePlayer).getTeam() != getTeam())
				{
#if defined(MOD_BALANCE_CORE)
					if(GET_PLAYER(ePlayer).GetMinorFriendshipDecayMod() <= 0)
					{
						// Send notification to affected players
						locString = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_FRIENDSHIP_DECAY");
						locString << getNameKey();
						locSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MINOR_FRIENDSHIP_DECAY");

						pNotifications = GET_PLAYER(ePlayer).GetNotifications();
						if(pNotifications)
						{
							pNotifications->Add(NOTIFICATION_DIPLOMACY_DECLARATION, locString.toUTF8(), locSummary.toUTF8(), -1, -1, -1);
						}
					}
#endif
					GET_PLAYER(ePlayer).changeGetMinorFriendshipDecayMod(iOtherPlayersDecay * iChange);
				}
			}
		}
	}

	BuildingClassTypes eBuildingClass;
	BuildingTypes eBuilding;
	int iBuildingCount;
	int iYieldMod;
	int iYieldChange;

	// How many cities get free culture buildings?
	int iNumCitiesFreeCultureBuilding = pPolicy->GetNumCitiesFreeCultureBuilding();
	int iNumCitiesFreeFoodBuilding = pPolicy->GetNumCitiesFreeFoodBuilding();

	// Loop through Cities
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(iNumCitiesFreeCultureBuilding > 0)
		{
			BuildingTypes eCultureBuilding = pLoopCity->ChooseFreeCultureBuilding();
			if(eCultureBuilding != NO_BUILDING)
			{
				pLoopCity->GetCityBuildings()->SetNumFreeBuilding(eCultureBuilding, 1);

				if(pLoopCity->getFirstBuildingOrder(eCultureBuilding) == 0)
				{
					pLoopCity->clearOrderQueue();
					pLoopCity->chooseProduction();		// Send a notification to the user that what they were building was given to them, and they need to produce something else.
				}
			}
			else
			{
				pLoopCity->SetOwedCultureBuilding(true);
			}

			// Decrement cities left to get free culture building (at end of loop we'll set the remainder)
			iNumCitiesFreeCultureBuilding--;
		}

		if(iNumCitiesFreeFoodBuilding > 0)
		{
			BuildingTypes eFoodBuilding = pLoopCity->ChooseFreeFoodBuilding();
			if(eFoodBuilding != NO_BUILDING)
			{
				pLoopCity->GetCityBuildings()->SetNumFreeBuilding(eFoodBuilding, 1);

				if(pLoopCity->getFirstBuildingOrder(eFoodBuilding) == 0)
				{
					pLoopCity->clearOrderQueue();
					pLoopCity->chooseProduction();		// Send a notification to the user that what they were building was given to them, and they need to produce something else.
				}
			}
			else
			{
				pLoopCity->SetOwedFoodBuilding(true);
			}

			// Decrement cities left to get free food building (at end of loop we'll set the remainder)
			iNumCitiesFreeFoodBuilding--;
		}

		// Free Culture-per-turn in every City
		int iCityCultureChange = pPolicy->GetCulturePerCity() * iChange;
		if(pLoopCity->HasGarrison())
		{
			iCityCultureChange += (pPolicy->GetCulturePerGarrisonedUnit() * iChange);
		}

		pLoopCity->ChangeJONSCulturePerTurnFromPolicies(iCityCultureChange);

		int iTotalWonders = 0;

		// Building modifiers
		for(iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
		{
			eBuildingClass = (BuildingClassTypes) iI;

			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
			if(!pkBuildingClassInfo)
			{
				continue;
			}

			eBuilding = NO_BUILDING;
			if (MOD_BUILDINGS_THOROUGH_PREREQUISITES || GetPlayerTraits()->IsKeepConqueredBuildings())
			{
				eBuilding = pLoopCity->GetCityBuildings()->GetBuildingTypeFromClass(eBuildingClass);
			}
			else
			{
				eBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(eBuildingClass);
			}

			if(eBuilding != NO_BUILDING)
			{
				CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
				if(pkBuilding)
				{
					iBuildingCount = pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding);

					if(iBuildingCount > 0)
					{
						if (::isWorldWonderClass(pkBuilding->GetBuildingClassInfo())) 
						{
							iTotalWonders += iBuildingCount;
						}

						iYieldMod = pPolicy->GetBuildingClassYieldModifiers(eBuildingClass, YIELD_CULTURE);
						if (iYieldMod != 0)
						{
							pLoopCity->changeYieldRateModifier(YIELD_CULTURE, iYieldMod * iBuildingCount * iChange);
						}
						iYieldChange = pPolicy->GetBuildingClassCultureChange(eBuildingClass);
						iYieldChange += pPolicy->GetBuildingClassYieldChanges(eBuildingClass, YIELD_CULTURE);
						if (iYieldChange != 0)
						{
							pLoopCity->ChangeJONSCulturePerTurnFromPolicies(iYieldChange * iBuildingCount * iChange);
#if defined(MOD_BALANCE_CORE_POLICIES)
							pLoopCity->changeBuildingClassCultureChange(eBuildingClass, (iYieldChange * iBuildingCount * iChange));
						}
						//Policy-Religion Fusion Yield Changes
						iYieldChange = pPolicy->GetReligionBuildingYieldMod(eBuildingClass, YIELD_CULTURE);
						if (MOD_BALANCE_CORE_POLICIES && iYieldChange != 0)
						{
							pLoopCity->changeReligionBuildingYieldRateModifier(eBuildingClass, YIELD_CULTURE, (iYieldChange * iBuildingCount * iChange));
#endif
						}

						// Building Class Yield Stuff
						for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
						{
							switch(iJ)
							{
							case YIELD_CULTURE:
								// Skip, handled above
								break;
							case YIELD_FAITH:
								{
									eYield = (YieldTypes) iJ;
									iYieldMod = pPolicy->GetBuildingClassYieldModifiers(eBuildingClass, eYield);
									if (iYieldMod != 0)
									{
										pLoopCity->changeYieldRateModifier(eYield, iYieldMod * iBuildingCount * iChange);
									}
									iYieldChange = pPolicy->GetBuildingClassYieldChanges(eBuildingClass, eYield);
									if (iYieldChange != 0)
									{
										pLoopCity->ChangeFaithPerTurnFromPolicies(iYieldChange * iBuildingCount * iChange);
									}
#if defined(MOD_BALANCE_CORE_POLICIES)
									//Policy-Religion Fusion Yield Changes
									iYieldChange = pPolicy->GetReligionBuildingYieldMod(eBuildingClass, eYield);
									if (MOD_BALANCE_CORE_POLICIES && iYieldChange != 0)
									{
										pLoopCity->changeReligionBuildingYieldRateModifier(eBuildingClass, eYield, (iYieldChange * iBuildingCount * iChange));
									}
#endif
								}
								break;
							default:
								{
									eYield = (YieldTypes) iJ;
									iYieldMod = pPolicy->GetBuildingClassYieldModifiers(eBuildingClass, eYield);
#if defined(MOD_BALANCE_CORE)
									if (iYieldMod != 0)
#else
									if (iYieldMod > 0)
#endif
									{
										pLoopCity->changeYieldRateModifier(eYield, iYieldMod * iBuildingCount * iChange);
									}
									iYieldChange = pPolicy->GetBuildingClassYieldChanges(eBuildingClass, eYield);
									if (iYieldChange != 0)
									{
										pLoopCity->ChangeBaseYieldRateFromBuildings(eYield, iYieldChange * iBuildingCount * iChange);
									}
#if defined(MOD_BALANCE_CORE_POLICIES)
									//Policy-Religion Fusion Yield Changes
									iYieldChange = pPolicy->GetReligionBuildingYieldMod(eBuildingClass, eYield);
									if (MOD_BALANCE_CORE_POLICIES && iYieldChange != 0)
									{
										pLoopCity->changeReligionBuildingYieldRateModifier(eBuildingClass, eYield, (iYieldChange * iBuildingCount * iChange));
									}
#endif
								}
							}
						}
					}
				}
			}
		}

		if (iTotalWonders > 0) {
			for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				YieldTypes eYield = (YieldTypes) iI;
				int iYield = pPolicy->GetYieldChangeWorldWonder(iI);
				pLoopCity->ChangeBaseYieldRateFromBuildings(eYield, iYield * iTotalWonders * iChange);
			}
		}
	}

	for (iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
	{
		const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iI);
		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
		if (pkBuildingClassInfo)
		{
			int iNumFreeBuildings = pPolicy->GetFreeChosenBuilding(eBuildingClass);
			if (iNumFreeBuildings > 0 || (pPolicy->GetAllCityFreeBuilding() == eBuildingClass))
			{
				BuildingTypes eBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(pkBuildingClassInfo->GetID())));
				if (NO_BUILDING != eBuilding || (MOD_BUILDINGS_THOROUGH_PREREQUISITES || GetPlayerTraits()->IsKeepConqueredBuildings()))
				{
					CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
					if (pkBuildingInfo)
					{
						ChangeNumCitiesFreeChosenBuilding(eBuildingClass, iNumFreeBuildings);
						ChangeAllCityFreeBuilding(eBuildingClass, (pPolicy->GetAllCityFreeBuilding() == eBuildingClass) * iChange > 0);
						int iLoopTwo;
						for (pLoopCity = firstCity(&iLoopTwo); pLoopCity != NULL; pLoopCity = nextCity(&iLoopTwo))
						{
							if (MOD_BUILDINGS_THOROUGH_PREREQUISITES || GetPlayerTraits()->IsKeepConqueredBuildings())
							{
								if (pLoopCity->HasBuildingClass(eBuildingClass))
								{
									eBuilding = pLoopCity->GetCityBuildings()->GetBuildingTypeFromClass(eBuildingClass);
									if (eBuilding == NO_BUILDING)
									{
										continue;
									}
								}
							}
							if (pLoopCity->isValidBuildingLocation(eBuilding))
							{
								if (GetNumCitiesFreeChosenBuilding(eBuildingClass) > 0 || IsFreeBuildingAllCity(eBuildingClass))
								{
									if (pLoopCity->GetCityBuildings()->GetNumRealBuilding(eBuilding) > 0)
									{
										int iProductionValue = pLoopCity->getProductionNeeded(eBuilding);
										doInstantYield(INSTANT_YIELD_TYPE_REFUND, false, NO_GREATPERSON, NO_BUILDING, iProductionValue, false, NO_PLAYER, NULL, false, pLoopCity);
										pLoopCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, 0);
									}

									// Already have this building for free in this city? Skip!
									if (pLoopCity->GetCityBuildings()->GetNumFreeBuilding(eBuilding) > 0)
										continue;

									pLoopCity->GetCityBuildings()->SetNumFreeBuilding(eBuilding, 1);

									if (pLoopCity->GetCityBuildings()->GetNumFreeBuilding(eBuilding) > 0)
									{
										ChangeNumCitiesFreeChosenBuilding(eBuildingClass, -1);
									}
									if (pLoopCity->getFirstBuildingOrder(eBuilding) == 0)
									{
										pLoopCity->clearOrderQueue();
										pLoopCity->chooseProduction();
										// Send a notification to the user that what they were building was given to them, and they need to produce something else.
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if (pPolicy->GetNewCityFreeBuilding() != NO_BUILDINGCLASS)
	{
		ChangeFreeChosenBuildingNewCity(pPolicy->GetNewCityFreeBuilding(), iChange > 0);
	}
	if (pPolicy->GetNewFoundCityFreeBuilding() != NO_BUILDINGCLASS)
	{
		ChangeNewFoundCityFreeBuilding(pPolicy->GetNewFoundCityFreeBuilding(), iChange > 0);
	}
	if (pPolicy->GetNewFoundCityFreeUnit() != NO_UNITCLASS)
	{
		ChangeNewFoundCityFreeUnit(pPolicy->GetNewFoundCityFreeUnit(), iChange > 0);
	}

	// Store off number of newly built cities that will get a free building
	ChangeNumCitiesFreeCultureBuilding(iNumCitiesFreeCultureBuilding);
	ChangeNumCitiesFreeFoodBuilding(iNumCitiesFreeFoodBuilding);

	// Not really techs but this is what we use (for now)
	for(iI = 0; iI < /*6*/ GD_INT_GET(NUM_AND_TECH_PREREQS); iI++)
	{
		if(pPolicy->GetPolicyDisables(iI) != NO_POLICY)
		{
			if(m_pPlayerPolicies->HasPolicy((PolicyTypes) pPolicy->GetPolicyDisables(iI)))
			{
				setHasPolicy((PolicyTypes) pPolicy->GetPolicyDisables(iI), false);
			}
		}
	}

	// Attack bonus for a period of time
	int iTurns = pPolicy->GetAttackBonusTurns() * iChange;
	if(iTurns > 0)
	{
		if (MOD_BALANCE_CORE_MILITARY_PROMOTION_ADVANCED)
		{
			iTurns *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iTurns /= 100;
		}
		ChangeAttackBonusTurns(iTurns);
	}

	// Golden Age!
	int iGoldenAgeTurns = pPolicy->GetGoldenAgeTurns() * iChange;
	if(iGoldenAgeTurns > 0)
	{
		changeGoldenAgeTurns(getGoldenAgeLength(iGoldenAgeTurns));
	}

	// Free Techs
	int iNumFreeTechs = pPolicy->GetNumFreeTechs() * iChange;
	if(iNumFreeTechs > 0)
	{
		if(!isHuman())
		{
			for(iI = 0; iI < iNumFreeTechs; iI++)
			{
				AI_chooseFreeTech();
			}
		}
		else
		{
			CvString strBuffer = GetLocalizedText("TXT_KEY_MISC_COMPLETED_WONDER_CHOOSE_TECH", pPolicy->GetTextKey());
			chooseTech(iNumFreeTechs, strBuffer.GetCString());
		}
	}

	ChangeMedianTechPercentage(pPolicy->GetMedianTechPercentChange());

	// Free Policies
	int iNumFreePolicies = pPolicy->GetNumFreePolicies() * iChange;
	if(iNumFreePolicies > 0)
	{
		ChangeNumFreePolicies(iNumFreePolicies);
	}

	if(pPolicy->IncludesOneShotFreeUnits())
	{
		if(!m_pPlayerPolicies->HaveOneShotFreeUnitsFired(ePolicy))
		{
			m_pPlayerPolicies->SetOneShotFreeUnitsFired(ePolicy,true);

			int iNumFreeGreatPeople = pPolicy->GetNumFreeGreatPeople() * iChange;
			if(iNumFreeGreatPeople > 0)
			{
				ChangeNumFreeGreatPeople(iNumFreeGreatPeople);
			}

			if(getCapitalCity() != NULL)
			{
				int iX = getCapitalCity()->getX();
				int iY = getCapitalCity()->getY();

				for(iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
				{
					const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
					CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
					if(pkUnitClassInfo)
					{
						int iNumFreeUnits = pPolicy->GetNumFreeUnitsByClass(eUnitClass);
						if(iNumFreeUnits > 0)
						{
							const UnitTypes eUnit = GetSpecificUnitType(eUnitClass);
							CvUnitEntry* pUnitEntry = GC.getUnitInfo(eUnit);
							if (isHuman() && pUnitEntry != NULL && pUnitEntry->IsFound() && GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE))
							{
								continue;
							}

							for(int iUnitLoop = 0; iUnitLoop < iNumFreeUnits; iUnitLoop++)
							{
								CvUnit* pNewUnit = NULL;
								// for venice
								if (pUnitEntry->IsFound() && GetPlayerTraits()->IsNoAnnexing())
								{
									// drop a merchant of venice instead
									// find the eUnit replacement that's the merchant of venice
									for(int iVeniceSearch = 0; iVeniceSearch < GC.getNumUnitClassInfos(); iVeniceSearch++)
									{
										const UnitClassTypes eVeniceUnitClass = static_cast<UnitClassTypes>(iVeniceSearch);
										CvUnitClassInfo* pkVeniceUnitClassInfo = GC.getUnitClassInfo(eVeniceUnitClass);
										if(pkVeniceUnitClassInfo)
										{
											const UnitTypes eMerchantOfVeniceUnit = GetSpecificUnitType(eVeniceUnitClass);
											if (eMerchantOfVeniceUnit != NO_UNIT)
											{
												CvUnitEntry* pVeniceUnitEntry = GC.getUnitInfo(eMerchantOfVeniceUnit);
												if (pVeniceUnitEntry->IsCanBuyCityState())
												{
													pNewUnit = initUnit(eMerchantOfVeniceUnit, iX, iY);				
													break;
												}
											}
										}
									}
								}
								else
								{
									pNewUnit = initUnit(eUnit, iX, iY);
								}

								if (pNewUnit)
								{
#if defined(MOD_BALANCE_CORE)
									if(pNewUnit->isWLKTKDOnBirth())
									{
										CvCity* pLoopCity;
										int iLoop;
										for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
										{
											if(pLoopCity != NULL && pLoopCity->getOwner() == GetID())
											{
												int iWLTKD = /*6*/ GD_INT_GET(CITY_RESOURCE_WLTKD_TURNS) / 3;
												iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
												iWLTKD /= 100;

												if (iWLTKD > 0)
												{
													pLoopCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
													CvNotifications* pNotifications = GetNotifications();
													if (pNotifications)
													{
														Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UNIT");
														strText << pNewUnit->getNameKey() << pLoopCity->getNameKey();
														Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UNIT");
														strSummary << pLoopCity->getNameKey();
														pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pLoopCity->getX(), pLoopCity->getY(), -1);
													}
												}
											}
										}
									}
									if(pNewUnit->isGoldenAgeOnBirth())
									{
										changeGoldenAgeTurns(getGoldenAgeLength());
									}
									if(pNewUnit->isCultureBoost())
									{
										int iValue = GetTotalJONSCulturePerTurn() * 4;
										changeJONSCulture(iValue);
										if(getCapitalCity() != NULL)
										{
											getCapitalCity()->ChangeJONSCultureStored(iValue);
										}
										CvNotifications* pNotifications = GetNotifications();
										if (pNotifications)
										{
											Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CULTURE_UNIT");
											strText << pNewUnit->getNameKey();
											Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CULTURE_UNIT");
											strSummary << pNewUnit->getNameKey();
											pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pNewUnit->getX(), pNewUnit->getY(), -1);
										}
									}
#endif
									if(pNewUnit->IsGreatGeneral())
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGreatGeneralsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGreatGeneralsCreated();
#endif
										bool bJumpSuccess = pNewUnit->jumpToNearestValidPlot();
										if (bJumpSuccess)
										{
											getCapitalCity()->addProductionExperience(pNewUnit);
										}
										else
										{
											pNewUnit->kill(false);
										}
									}
									else if(pNewUnit->IsGreatAdmiral())
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGreatAdmiralsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGreatAdmiralsCreated();
#endif
										CvPlot *pSpawnPlot = GetBestCoastalSpawnPlot(pNewUnit);
										if (pNewUnit->plot() != pSpawnPlot)
										{
											pNewUnit->setXY(pSpawnPlot->getX(), pSpawnPlot->getY());
											getCapitalCity()->addProductionExperience(pNewUnit);
										}
									}
									else if(pNewUnit->getUnitInfo().IsFoundReligion())
									{
										ReligionTypes eReligion = GetReligions()->GetStateReligion();

										if (GetHolyCity() && GetHolyCity()->getOwner() == GetID())
											pNewUnit->GetReligionDataMutable()->SetFullStrength(GetID(),pNewUnit->getUnitInfo(),eReligion,GetHolyCity());
										else if (getCapitalCity())
											pNewUnit->GetReligionDataMutable()->SetFullStrength(GetID(),pNewUnit->getUnitInfo(),eReligion,getCapitalCity());
										else
											pNewUnit->GetReligionDataMutable()->SetFullStrength(GetID(),pNewUnit->getUnitInfo(),eReligion,NULL);
									}
									else if (pNewUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_WRITER"))
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGreatWritersCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGreatWritersCreated();
#endif
#if !defined(MOD_BALANCE_CORE)
										if (pNewUnit->getUnitInfo().GetOneShotTourism() > 0)
										{
											pNewUnit->SetTourismBlastStrength(GetCulture()->GetTourismBlastStrength(pNewUnit->getUnitInfo().GetOneShotTourism()));
										}
#endif

										pNewUnit->jumpToNearestValidPlot();
									}							
									else if (pNewUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_ARTIST"))
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGreatArtistsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGreatArtistsCreated();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}							
									else if (pNewUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_MUSICIAN"))
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGreatMusiciansCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGreatMusiciansCreated();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
									else if (MOD_BALANCE_VP && pNewUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_GREAT_DIPLOMAT"))
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGreatDiplomatsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGreatDiplomatsCreated();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
#if defined(MOD_BALANCE_CORE)
									else if (pNewUnit->getUnitInfo().IsGPExtra() == 1)
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGPExtra1Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGPExtra1Created();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
									else if (pNewUnit->getUnitInfo().IsGPExtra() == 2)
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGPExtra2Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGPExtra2Created();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
									else if (pNewUnit->getUnitInfo().IsGPExtra() == 3)
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGPExtra3Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGPExtra3Created();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
									else if (pNewUnit->getUnitInfo().IsGPExtra() == 4)
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGPExtra4Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGPExtra4Created();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
									else if (pNewUnit->getUnitInfo().IsGPExtra() == 5)
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGPExtra5Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGPExtra5Created();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
#endif
									else if(pNewUnit->IsGreatPerson())
									{
#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
										if (MOD_GLOBAL_SEPARATE_GP_COUNTERS) 
										{
											if (pNewUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_MERCHANT"))
											{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
												incrementGreatMerchantsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
												incrementGreatMerchantsCreated();
#endif
											}
											else if (pNewUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_SCIENTIST"))
											{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
												incrementGreatScientistsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
												incrementGreatScientistsCreated();
#endif
											}
											else
											{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
												incrementGreatEngineersCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
												incrementGreatEngineersCreated();
#endif
											}
										}
										else
#endif
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
											incrementGreatPeopleCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
											incrementGreatPeopleCreated();
#endif
											pNewUnit->jumpToNearestValidPlot();
									}
									else
									{
										pNewUnit->jumpToNearestValidPlot();
										if (pNewUnit && getCapitalCity() != NULL)
										{
											getCapitalCity()->addProductionExperience(pNewUnit);
										}
									}
								}
							}
						}
					}
				}
				int iNumFreeCombatLandUnits = pPolicy->GetBestNumberLandCombatUnitClass();
				CvCity* pCapital = getCapitalCity();
				if(iNumFreeCombatLandUnits > 0)
				{
					UnitTypes eBestLandUnit = NO_UNIT;
					int iStrengthBestLandCombat = 0;
					for(iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
					{
						const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
						CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
						if(pkUnitClassInfo)
						{
							const UnitTypes eUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eUnitClass);
							CvUnitEntry* pUnitEntry = GC.getUnitInfo(eUnit);
							if(pUnitEntry)
							{
								if(!pCapital->canTrain(eUnit))
								{
									continue;
								}
								if(pUnitEntry->GetRangedCombat() > 0)
								{
									continue;
								}
								if(pUnitEntry->GetDomainType() == DOMAIN_LAND)
								{
									bool bBad = false;
									ResourceTypes eResource;
									for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
									{
										eResource = (ResourceTypes) iResourceLoop;
										int iNumResource = pUnitEntry->GetResourceQuantityRequirement(eResource);
										if (iNumResource > 0)
										{
											if(getNumResourceAvailable(eResource, true) < iNumResource)
											{
												bBad = true;
												break;
											}
										}

#if defined(MOD_UNITS_RESOURCE_QUANTITY_TOTALS)
										if (MOD_UNITS_RESOURCE_QUANTITY_TOTALS)
										{
											iNumResource = pUnitEntry->GetResourceQuantityTotal(eResource);
											if (iNumResource > 0)
											{
												if (getNumResourceTotal(eResource, true) < iNumResource || getNumResourceAvailable(eResource, true) < 0)
												{
													bBad = true;
													break;
												}
											}
										}
#endif
									}
									if(bBad)
									{
										continue;
									}
									int iCombatLandStrength = (std::max(1, pUnitEntry->GetCombat()));
									if(iCombatLandStrength > iStrengthBestLandCombat)
									{
										iStrengthBestLandCombat = iCombatLandStrength;
										eBestLandUnit = eUnit;
									}
								}
							}
						}
					}
					if(eBestLandUnit != NO_UNIT)
					{
						for(int iUnitLoop = 0; iUnitLoop < iNumFreeCombatLandUnits; iUnitLoop++)
						{
							CvUnitEntry* pkbUnitEntry = GC.getUnitInfo(eBestLandUnit);
							if(pkbUnitEntry)
							{
								UnitAITypes eUnitAI = pkbUnitEntry->GetDefaultUnitAIType();
								CvUnit* pUnit = pCapital->CreateUnit(eBestLandUnit, eUnitAI, REASON_GIFT);
								if (pUnit)
								{
									if (!pUnit->jumpToNearestValidPlot())
									{
										pUnit->kill(false);	// Could not find a valid spot!
									}
								}
							}
						}
					}
					else
					{
						for(int iUnitLoop = 0; iUnitLoop < iNumFreeCombatLandUnits; iUnitLoop++)
						{
							UnitTypes eWarrior = (UnitTypes)GC.getInfoTypeForString("UNIT_WARRIOR");
							CvUnitEntry* pkbUnitEntry = GC.getUnitInfo(eWarrior);
							if(pkbUnitEntry)
							{
								UnitAITypes eUnitAI = pkbUnitEntry->GetDefaultUnitAIType();
								CvUnit* pUnit = pCapital->CreateUnit(eWarrior, eUnitAI, REASON_GIFT);
								if (pUnit)
								{
									if (!pUnit->jumpToNearestValidPlot())
									{
										pUnit->kill(false);	// Could not find a valid spot!
									}
								}
							}
						}
					}
				}
				int iNumFreeRangedLandUnits = pPolicy->GetBestNumberLandRangedUnitClass();
				if(iNumFreeRangedLandUnits > 0)
				{
					UnitTypes eBestLandRangedUnit = NO_UNIT;
					int iStrengthBestLandRanged = 0;
					for(iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
					{
						const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
						CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
						if(pkUnitClassInfo)
						{
							const UnitTypes eUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eUnitClass);
							CvUnitEntry* pUnitEntry = GC.getUnitInfo(eUnit);
							if(pUnitEntry)
							{
								if(!pCapital->canTrain(eUnit))
								{
									continue;
								}
								if(pUnitEntry->GetDomainType() == DOMAIN_LAND && pUnitEntry->GetRangedCombat() > 0)
								{
									bool bBad = false;
									ResourceTypes eResource;
									for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
									{
										eResource = (ResourceTypes) iResourceLoop;
										int iNumResource = pUnitEntry->GetResourceQuantityRequirement(eResource);
										if (iNumResource > 0)
										{
											if(getNumResourceAvailable(eResource, true) < iNumResource)
											{
												bBad = true;
												break;
											}
										}
									}
									if(bBad)
									{
										continue;
									}
									int iCombatLandRangedStrength = (std::max(1, pUnitEntry->GetRangedCombat()));
									if(iCombatLandRangedStrength > iStrengthBestLandRanged)
									{
										iStrengthBestLandRanged = iCombatLandRangedStrength;
										eBestLandRangedUnit = eUnit;
									}
								}
							}
						}
					}
					if(eBestLandRangedUnit != NO_UNIT)
					{
						for(int iUnitLoop = 0; iUnitLoop < iNumFreeRangedLandUnits; iUnitLoop++)
						{
							CvUnitEntry* pkbUnitEntry = GC.getUnitInfo(eBestLandRangedUnit);
							if(pkbUnitEntry)
							{
								UnitAITypes eUnitAI = pkbUnitEntry->GetDefaultUnitAIType();
								CvUnit* pUnit = pCapital->CreateUnit(eBestLandRangedUnit, eUnitAI, REASON_GIFT);
								if (pUnit)
								{
									if (!pUnit->jumpToNearestValidPlot())
									{
										pUnit->kill(false);	// Could not find a valid spot!
									}
								}
							}
						}
					}
					else
					{
						for(int iUnitLoop = 0; iUnitLoop < iNumFreeRangedLandUnits; iUnitLoop++)
						{
							UnitTypes eArcher = (UnitTypes)GC.getInfoTypeForString("UNIT_ARCHER");
							CvUnitEntry* pkbUnitEntry = GC.getUnitInfo(eArcher);
							if(pkbUnitEntry)
							{
								UnitAITypes eUnitAI = pkbUnitEntry->GetDefaultUnitAIType();
								CvUnit* pUnit = pCapital->CreateUnit(eArcher, eUnitAI, REASON_GIFT);
								if (pUnit)
								{
									if (!pUnit->jumpToNearestValidPlot())
									{
										pUnit->kill(false);	// Could not find a valid spot!
									}
								}
							}
						}
					}
				}
				int iNumFreeCombatSeaUnits = pPolicy->GetBestNumberSeaCombatUnitClass();
				if(iNumFreeCombatSeaUnits > 0 && pCapital->isCoastal())
				{
					UnitTypes eBestSeaUnit = NO_UNIT;
					int iStrengthBestSeaCombat = 0;
					for(iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
					{
						const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
						CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
						if(pkUnitClassInfo)
						{
							const UnitTypes eUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eUnitClass);
							CvUnitEntry* pUnitEntry = GC.getUnitInfo(eUnit);
							if(pUnitEntry)
							{
								if(!pCapital->canTrain(eUnit))
								{
									continue;
								}
								if(pUnitEntry->GetRangedCombat() > 0)
								{
									continue;
								}
								if(pUnitEntry->GetDomainType() == DOMAIN_SEA)
								{
									bool bBad = false;
									ResourceTypes eResource;
									for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
									{
										eResource = (ResourceTypes) iResourceLoop;
										int iNumResource = pUnitEntry->GetResourceQuantityRequirement(eResource);
										if (iNumResource > 0)
										{
											if(getNumResourceAvailable(eResource, true) < iNumResource)
											{
												bBad = true;
												break;
											}
										}
									}
									if(bBad)
									{
										continue;
									}
									int iCombatSeaStrength = (std::max(1, pUnitEntry->GetCombat()));
									if(iCombatSeaStrength > iStrengthBestSeaCombat)
									{
										iStrengthBestSeaCombat = iCombatSeaStrength;
										eBestSeaUnit = eUnit;
									}
								}
							}
						}
					}
					if(eBestSeaUnit != NO_UNIT)
					{
						for(int iUnitLoop = 0; iUnitLoop < iNumFreeCombatSeaUnits; iUnitLoop++)
						{
							CvUnitEntry* pkbUnitEntry = GC.getUnitInfo(eBestSeaUnit);
							if(pkbUnitEntry)
							{
								UnitAITypes eUnitAI = pkbUnitEntry->GetDefaultUnitAIType();
								CvUnit* pUnit = pCapital->CreateUnit(eBestSeaUnit, eUnitAI, REASON_GIFT);
								if (pUnit)
								{
									if (!pUnit->jumpToNearestValidPlot())
									{
										pUnit->kill(false);	// Could not find a valid spot!
									}
								}
							}
						}
					}
					else
					{
						for(int iUnitLoop = 0; iUnitLoop < iNumFreeCombatSeaUnits; iUnitLoop++)
						{
							UnitTypes eCaravel = (UnitTypes)GC.getInfoTypeForString("UNIT_CARAVEL");
							CvUnitEntry* pkbUnitEntry = GC.getUnitInfo(eCaravel);
							if(pkbUnitEntry)
							{
								UnitAITypes eUnitAI = pkbUnitEntry->GetDefaultUnitAIType();
								CvUnit* pUnit = pCapital->CreateUnit(eCaravel, eUnitAI, REASON_GIFT);
								if (pUnit)
								{
									if (!pUnit->jumpToNearestValidPlot())
									{
										pUnit->kill(false);	// Could not find a valid spot!
									}
								}
							}
						}
					}
				}
				int iNumFreeRangedSeaUnits = pPolicy->GetBestNumberSeaRangedUnitClass();
				if(iNumFreeRangedSeaUnits > 0 && pCapital->isCoastal())
				{
					UnitTypes eBestSeaRangedUnit = NO_UNIT;
					int iStrengthBestSeaRanged = 0;
					for(iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
					{
						const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
						CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
						if(pkUnitClassInfo)
						{
							const UnitTypes eUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eUnitClass);
							CvUnitEntry* pUnitEntry = GC.getUnitInfo(eUnit);
							if(pUnitEntry)
							{
								if(!pCapital->canTrain(eUnit))
								{
									continue;
								}
								if(pUnitEntry->GetDomainType() == DOMAIN_SEA && pUnitEntry->GetRangedCombat() > 0)
								{
									bool bBad = false;
									ResourceTypes eResource;
									for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
									{
										eResource = (ResourceTypes) iResourceLoop;
										int iNumResource = pUnitEntry->GetResourceQuantityRequirement(eResource);
										if (iNumResource > 0)
										{
											if(getNumResourceAvailable(eResource, true) < iNumResource)
											{
												bBad = true;
												break;
											}
										}
									}
									if(bBad)
									{
										continue;
									}
									int iCombatSeaRangedStrength = (std::max(1, pUnitEntry->GetRangedCombat()));
									if(iCombatSeaRangedStrength > iStrengthBestSeaRanged)
									{
										iStrengthBestSeaRanged = iCombatSeaRangedStrength;
										eBestSeaRangedUnit = eUnit;
									}
								}
							}
						}
					}
					if(eBestSeaRangedUnit != NO_UNIT)
					{
						for(int iUnitLoop = 0; iUnitLoop < iNumFreeRangedSeaUnits; iUnitLoop++)
						{
							CvUnitEntry* pkbUnitEntry = GC.getUnitInfo(eBestSeaRangedUnit);
							if(pkbUnitEntry)
							{
								UnitAITypes eUnitAI = pkbUnitEntry->GetDefaultUnitAIType();
								CvUnit* pUnit = pCapital->CreateUnit(eBestSeaRangedUnit, eUnitAI, REASON_GIFT);
								if (pUnit)
								{
									if (!pUnit->jumpToNearestValidPlot())
									{
										pUnit->kill(false);	// Could not find a valid spot!
									}
								}
							}
						}
					}
					else
					{
						for(int iUnitLoop = 0; iUnitLoop < iNumFreeRangedSeaUnits; iUnitLoop++)
						{
							UnitTypes eGalleass = (UnitTypes)GC.getInfoTypeForString("UNIT_GALLEASS");
							CvUnitEntry* pkbUnitEntry = GC.getUnitInfo(eGalleass);
							if(pkbUnitEntry)
							{
								UnitAITypes eUnitAI = pkbUnitEntry->GetDefaultUnitAIType();
								CvUnit* pUnit = pCapital->CreateUnit(eGalleass, eUnitAI, REASON_GIFT);
								if (pUnit)
								{
									if (!pUnit->jumpToNearestValidPlot())
									{
										pUnit->kill(false);	// Could not find a valid spot!
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// Great People bonus from Allied city-states
	if(pPolicy->IsMinorGreatPeopleAllies())
	{
		DoAdoptedGreatPersonCityStatePolicy();
	}

	// Add a Reformation belief if eligible
#if defined(MOD_RELIGION_LOCAL_RELIGIONS)
	if (isHuman() && pPolicy->IsAddReformationBelief() && GetReligions()->HasCreatedReligion(true) && !GetReligions()->HasAddedReformationBelief())
#else
	if (isHuman() && pPolicy->IsAddReformationBelief() && GetReligions()->HasCreatedReligion() && !GetReligions()->HasAddedReformationBelief())
#endif
	{
		pNotifications = GetNotifications();
		if(pNotifications)
		{
			CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_ADD_REFORMATION_BELIEF");
			CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_ADD_REFORMATION_BELIEF");
			pNotifications->Add(NOTIFICATION_ADD_REFORMATION_BELIEF, strBuffer, strSummary, -1, -1, -1);
		}
	}

	// if the steal tech faster amount is modified, then update the progress of all spies
	if (pPolicy->GetStealTechFasterModifier() != 0)
	{
		GetEspionage()->UpdateSpies();
	}
#if defined(MOD_BALANCE_CORE)
	if (pPolicy->GetStealGWFasterModifier() != 0)
	{
		GetEspionage()->UpdateSpies();
	}
#endif

	CvPlot *pLoopPlot;
	ResourceTypes eResource;
	for(iI = 0; iI < GC.getMap().numPlots(); iI++)
	{
		pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);
		eResource = pLoopPlot->getResourceType();
		if(eResource != NO_RESOURCE)
		{
			if(GC.getResourceInfo(eResource)->getPolicyReveal() == (int)ePolicy)
			{
				pLoopPlot->updateYield();
				if (pLoopPlot->isRevealed(getTeam()))
				{
					pLoopPlot->setLayoutDirty(true);
				}
			}
		}
	}

	GetTrade()->UpdateTradeConnectionValues();
	recomputeGreatPeopleModifiers();
	recomputePolicyCostModifier();
	recomputeFreeExperience();
#if defined(MOD_BALANCE_CORE)
	CvCity* pLoopCity2;
	int iLoop2;
	for(pLoopCity2 = firstCity(&iLoop2); pLoopCity2 != NULL; pLoopCity2 = nextCity(&iLoop2))
	{
		if(pLoopCity2 != NULL)
		{
			pLoopCity2->UpdateReligion(pLoopCity2->GetCityReligions()->GetReligiousMajority());		
			pLoopCity2->UpdateHappinessFromBuildingClasses();
		}
	}
#endif
	CalculateNetHappiness();

	doUpdateBarbarianCampVisibility();

	GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
}

#if defined(MOD_BALANCE_CORE)
void CvPlayer::processCorporations(CorporationTypes eCorporation, int iChange)
{
	CvCorporationEntry* pkCorporationEntry = GC.getCorporationInfo(eCorporation);
	if(pkCorporationEntry == NULL)
		return;

	int iI, jJ;

	for (iI = 0; iI < GC.getNUM_YIELD_TYPES(); iI++)
	{
		for (jJ = 0; jJ < GC.getNumSpecialistInfos(); jJ++)
		{
			changeSpecialistYieldChange((SpecialistTypes)jJ, (YieldTypes)iI, pkCorporationEntry->GetSpecialistYieldChange(jJ, iI) * iChange);
		}
	}
	// Loop through Cities
	int iLoop;
	CvCity* pLoopCity;
	int iBuildingCount;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		// Building modifiers
		BuildingClassTypes eBuildingClass;
		for(iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
		{
			eBuildingClass = (BuildingClassTypes) iI;

			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
			if(!pkBuildingClassInfo)
			{
				continue;
			}

			BuildingTypes eTestBuilding = NO_BUILDING;
			if (MOD_BUILDINGS_THOROUGH_PREREQUISITES || GetPlayerTraits()->IsKeepConqueredBuildings())
			{
				eTestBuilding = pLoopCity->GetCityBuildings()->GetBuildingTypeFromClass(eBuildingClass);
			}
			else
			{
				eTestBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(eBuildingClass);
			}

			if(eTestBuilding != NO_BUILDING)
			{
				CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eTestBuilding);
				if(pkBuilding)
				{
					iBuildingCount = pLoopCity->GetCityBuildings()->GetNumBuilding(eTestBuilding);
					if(iBuildingCount > 0)
					{
						// Building Class Yield Stuff
						for(int iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
						{
							YieldTypes eYield = (YieldTypes)iJ;
								
							int iYieldChange = pkCorporationEntry->GetBuildingClassYieldChange(eBuildingClass, eYield);
							if(iYieldChange <= 0)
								continue;

							pLoopCity->ChangeBaseYieldRateFromBuildings(eYield, iYieldChange * iBuildingCount * iChange);
						}
					}
				}
			}
		}
	}
}
#endif

//	--------------------------------------------------------------------------------
/// If we should see where the locations of all current Barb Camps are, do it
void CvPlayer::doUpdateBarbarianCampVisibility()
{
	if(IsAlwaysSeeBarbCamps())
	{
		CvPlot* pPlot;

		ImprovementTypes eImprovement;

		for(int iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); ++iPlotLoop)
		{
			pPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);

			if(pPlot->isRevealed(getTeam()))
			{
				eImprovement = pPlot->getImprovementType();

				// Camp here
				if(eImprovement == GD_INT_GET(BARBARIAN_CAMP_IMPROVEMENT))
				{
					// We don't see Camp
					if(pPlot->getRevealedImprovementType(getTeam()) != eImprovement)
					{
						pPlot->setRevealedImprovementType(getTeam(), eImprovement);
					}
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isPbemNewTurn() const
{
	return m_bPbemNewTurn;
}

//	--------------------------------------------------------------------------------
void CvPlayer::setPbemNewTurn(bool bNew)
{
	m_bPbemNewTurn = bNew;
}

//	--------------------------------------------------------------------------------
CvEconomicAI* CvPlayer::GetEconomicAI() const
{
	return m_pEconomicAI;
}

//	--------------------------------------------------------------------------------
CvMilitaryAI* CvPlayer::GetMilitaryAI() const
{
	return m_pMilitaryAI;
}

//	--------------------------------------------------------------------------------
CvCitySpecializationAI* CvPlayer::GetCitySpecializationAI() const
{
	return m_pCitySpecializationAI;
}

//	--------------------------------------------------------------------------------
CvWonderProductionAI* CvPlayer::GetWonderProductionAI() const
{
	return m_pWonderProductionAI;
}

//	--------------------------------------------------------------------------------
CvGrandStrategyAI* CvPlayer::GetGrandStrategyAI() const
{
	return m_pGrandStrategyAI;
}

//	--------------------------------------------------------------------------------
CvDiplomacyAI* CvPlayer::GetDiplomacyAI() const
{
	return m_pDiplomacyAI;
}

//	--------------------------------------------------------------------------------
CvPlayerReligions* CvPlayer::GetReligions() const
{
	return m_pReligions;
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
CvPlayerCorporations* CvPlayer::GetCorporations() const
{
	return m_pCorporations;
}
//	--------------------------------------------------------------------------------
CvPlayerContracts* CvPlayer::GetContracts() const
{
	return m_pContracts;
}
#endif

//	--------------------------------------------------------------------------------
CvReligionAI* CvPlayer::GetReligionAI() const
{
	return m_pReligionAI;
}

//	--------------------------------------------------------------------------------
CvMinorCivAI* CvPlayer::GetMinorCivAI() const
{
	return m_pMinorCivAI;
}

//	--------------------------------------------------------------------------------
CvDealAI* CvPlayer::GetDealAI() const
{
	return m_pDealAI;
}

//	--------------------------------------------------------------------------------
/// Get the object that decides what task the builders should perform
CvBuilderTaskingAI* CvPlayer::GetBuilderTaskingAI() const
{
	return m_pBuilderTaskingAI;
}

//	--------------------------------------------------------------------------------
/// Get the city connection that gives you information about the route connections between cities
CvCityConnections* CvPlayer::GetCityConnections() const
{
	return m_pCityConnections;
}

//	--------------------------------------------------------------------------------
/// Get the player's information about their espionage
CvPlayerEspionage* CvPlayer::GetEspionage() const
{
	return m_pEspionage;
}

//	--------------------------------------------------------------------------------
/// Get the player's espionage AI version
CvEspionageAI* CvPlayer::GetEspionageAI() const
{
	return m_pEspionageAI;
}

//	--------------------------------------------------------------------------------
/// Get the player's information about their trade
CvPlayerTrade* CvPlayer::GetTrade() const
{
	return m_pTrade;
}

//	--------------------------------------------------------------------------------
/// Get the player's trade AI version
CvTradeAI* CvPlayer::GetTradeAI() const
{
	return m_pTradeAI;
}

//	--------------------------------------------------------------------------------
/// Get the player's League AI
CvLeagueAI* CvPlayer::GetLeagueAI() const
{
	return m_pLeagueAI;
}

//	--------------------------------------------------------------------------------
CvPlayerCulture* CvPlayer::GetCulture() const
{
	return m_pCulture;
}

//	--------------------------------------------------------------------------------
CvNotifications* CvPlayer::GetNotifications() const
{
	return m_pNotifications;
}

//	--------------------------------------------------------------------------------
int CvPlayer::AddNotification(NotificationTypes eNotificationType, const char* sMessage, const char* sSummary, int iGameDataIndex, int iExtraGameData)
{
  return AddNotification(eNotificationType, sMessage, sSummary, NULL, iGameDataIndex, iExtraGameData);
}

int CvPlayer::AddNotification(NotificationTypes eNotificationType, const char* sMessage, const char* sSummary, CvPlot* pPlot, int iGameDataIndex, int iExtraGameData)
{
  int iNotification = -1;
  
  CvNotifications* pNotifications = GetNotifications();

  if (pNotifications) {
    const int iPlotX = pPlot ? pPlot->getX() : -1;
    const int iPlotY = pPlot ? pPlot->getY() : -1;
	
    iNotification = pNotifications->Add(eNotificationType, sMessage, sSummary, iPlotX, iPlotY, iGameDataIndex, iExtraGameData);
  }
  
  return iNotification;
}

// ---------------------------------------------------------------------------------
#if defined(MOD_WH_MILITARY_LOG)
CvEventLog* CvPlayer::GetMilitaryLog() const
{
	return m_pMilitaryLog;
}

bool CvPlayer::AddMilitaryEvent(const char* sMessage, CvPlot* pPlot, PlayerTypes eOtherPlayer, int iData1 /* = -1 */, int iData2 /* = -1 */, int iData3 /* = -1 */, int iData4 /* = -1 */)
{
	if (MOD_WH_MILITARY_LOG)
	{
		if (m_pMilitaryLog) {
			return m_pMilitaryLog->Add(sMessage, eOtherPlayer, pPlot ? pPlot->getX() : -1, pPlot ? pPlot->getY() : -1, iData1, iData2, iData3, iData4);
		}
	}

	return false;
}
#endif


//	--------------------------------------------------------------------------------
CvTreasury* CvPlayer::GetTreasury() const
{
	return m_pTreasury;
}

int CvPlayer::GetPseudoRandomSeed() const
{
	//this should return a different number for each turn (each call would be even better ...)
	return (static_cast<int>(GetID()) * getNumUnits()) + GC.getGame().getGameTurn() + (m_pTreasury ? m_pTreasury->GetLifetimeGrossGold() : GC.getGame().GetCultureMedian());
}

//	--------------------------------------------------------------------------------
CvDiplomacyRequests* CvPlayer::GetDiplomacyRequests() const
{
	return m_pDiplomacyRequests;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::HasActiveDiplomacyRequests() const
{
	PlayerTypes ePlayer = GetID();

	// Do I have any?
	CvDiplomacyRequests* pkDiploRequests = GetDiplomacyRequests();
	if(pkDiploRequests && pkDiploRequests->HasActiveRequest())
		return true;
#if defined(MOD_ACTIVE_DIPLOMACY)
	if (!MOD_ACTIVE_DIPLOMACY || !GC.getGame().isReallyNetworkMultiPlayer())
	{
#endif
		// Do I have any for others?
		for (int i = 0; i < MAX_PLAYERS; ++i)
		{
			const CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)i);
			if (kPlayer.isAlive())
			{
				pkDiploRequests = kPlayer.GetDiplomacyRequests();
				if (pkDiploRequests)
				{
					if (pkDiploRequests->HasActiveRequestFrom(ePlayer))
						return true;
				}
			}
		}
#if defined(MOD_ACTIVE_DIPLOMACY)
	}
#endif
	return false;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ConqueredByBoolField::read(FDataStream& kStream)
{
	for (uint32 i = 0; i < eCount; ++i)
	{
		kStream >> m_bits[i];
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::ConqueredByBoolField::write(FDataStream& kStream) const
{
	for (uint32 i = 0; i < eCount; ++i)
	{
		kStream << m_bits[i];
	}
}

//	--------------------------------------------------------------------------------
template<typename Player, typename Visitor>
void CvPlayer::Serialize(Player& player, Visitor& visitor)
{
	const bool bLoading = visitor.isLoading();
	const bool bSaving = visitor.isSaving();

	// FIXME - Values in this chunk were formerly FAutoVariables. Remove any that shouldn't be saved.
	visitor(player.m_eID);
	visitor(player.m_ePersonalityType);
	visitor(player.m_iStartingX);
	visitor(player.m_iStartingY);
	visitor(player.m_iTotalPopulation);
	visitor(player.m_iTotalLand);
	visitor(player.m_iTotalLandScored);
	visitor(player.m_iJONSCulturePerTurnForFree);
	visitor(player.m_iJONSCultureCityModifier);
	visitor(player.m_iJONSCulture);
	visitor(player.m_iJONSCultureEverGenerated);
	visitor(player.m_iWondersConstructed);
	visitor(player.m_iCulturePerWonder);
	visitor(player.m_iCultureWonderMultiplier);
	visitor(player.m_iCulturePerTechResearched);
	visitor(player.m_iFaith);
	visitor(player.m_iFaithEverGenerated);
	visitor(player.m_iHappiness);
	visitor(player.m_iUnhappiness);
	visitor(player.m_iHappinessTotal);
	visitor(player.m_iEmpireNeedsModifierGlobal);
	visitor(player.m_iChangePovertyUnhappinessGlobal);
	visitor(player.m_iChangeDefenseUnhappinessGlobal);
	visitor(player.m_iChangeUnculturedUnhappinessGlobal);
	visitor(player.m_iChangeIlliteracyUnhappinessGlobal);
	visitor(player.m_iChangeMinorityUnhappinessGlobal);
	visitor(player.m_iLandmarksTourismPercentGlobal);
	visitor(player.m_iGreatWorksTourismModifierGlobal);
	visitor(player.m_iCenterOfMassX);
	visitor(player.m_iCenterOfMassY);
	visitor(player.m_iReferenceFoundValue);
	visitor(player.m_iReformationFollowerReduction);
	visitor(player.m_bIsReformation);
	visitor(player.m_viInstantYieldsTotal);
	visitor(player.m_miLocalInstantYieldsTotal);
	visitor(player.m_aiYieldHistory);
	visitor(player.m_iUprisingCounter);
	visitor(player.m_iExtraHappinessPerLuxury);
	visitor(player.m_iUnhappinessFromUnits);
	visitor(player.m_iUnhappinessFromUnitsMod);
	visitor(player.m_iUnhappinessMod);
	visitor(player.m_iCityCountUnhappinessMod);
	visitor(player.m_iOccupiedPopulationUnhappinessMod);
	visitor(player.m_iCapitalUnhappinessMod);
	visitor(player.m_iCityRevoltCounter);
	visitor(player.m_iHappinessPerGarrisonedUnitCount);
	visitor(player.m_iHappinessPerTradeRouteCount);
	visitor(player.m_iHappinessPerXPopulation);
	visitor(player.m_iHappinessPerXPopulationGlobal);
	visitor(player.m_iIdeologyPoint);
	visitor(player.m_iNoXPLossUnitPurchase);
	visitor(player.m_iXCSAlliesLowersPolicyNeedWonders);
	visitor(player.m_iHappinessFromMinorCivs);
	visitor(player.m_iPositiveWarScoreTourismMod);
	visitor(player.m_iIsNoCSDecayAtWar);
	visitor(player.m_iCanBullyFriendlyCS);
	visitor(player.m_iBullyGlobalCSReduction);
	visitor(player.m_iIsVassalsNoRebel);
	visitor(player.m_iVassalYieldBonusModifier);
	visitor(player.m_iCSYieldBonusModifier);
	visitor(player.m_iHappinessFromLeagues);
	visitor(player.m_iWoundedUnitDamageMod);
	visitor(player.m_iUnitUpgradeCostMod);
	visitor(player.m_iBarbarianCombatBonus);
	visitor(player.m_iAlwaysSeeBarbCampsCount);
	visitor(player.m_iHappinessPerCity);
	visitor(player.m_iHappinessPerXPolicies);
	visitor(player.m_iExtraHappinessPerXPoliciesFromPolicies);
	visitor(player.m_iHappinessPerXGreatWorks);
	visitor(player.m_iEspionageModifier);
	visitor(player.m_iSpyStartingRank);
	visitor(player.m_iConversionModifier);
	visitor(player.m_iExtraLeagueVotes);
	visitor(player.m_iImprovementLeagueVotes);
	visitor(player.m_iFaithToVotes);
	visitor(player.m_iCapitalsToVotes);
	visitor(player.m_iDoFToVotes);
	visitor(player.m_iRAToVotes);
	visitor(player.m_iDefensePactsToVotes);
	visitor(player.m_iGPExpendInfluence);
	visitor(player.m_bIsLeagueAid);
	visitor(player.m_bIsLeagueScholar);
	visitor(player.m_bIsLeagueArt);
	visitor(player.m_iScienceRateFromLeague);
	visitor(player.m_iScienceRateFromLeagueAid);
	visitor(player.m_iLeagueCultureCityModifier);
	visitor(player.m_iAdvancedStartPoints);
	visitor(player.m_iAttackBonusTurns);
	visitor(player.m_iCultureBonusTurns);
	visitor(player.m_iTourismBonusTurns);
	visitor(player.m_iGoldenAgeProgressMeter);
	visitor(player.m_iGoldenAgeMeterMod);
	visitor(player.m_iNumGoldenAges);
	visitor(player.m_iGoldenAgeTurns);
	visitor(player.m_iNumUnitGoldenAges);
	visitor(player.m_iStrikeTurns);
	visitor(player.m_iGoldenAgeModifier);
	visitor(player.m_iProductionBonusTurnsConquest);
	visitor(player.m_iCultureBonusTurnsConquest);
	visitor(player.m_iFreeGreatPeopleCreated);
	visitor(player.m_iFreeGreatGeneralsCreated);
	visitor(player.m_iFreeGreatAdmiralsCreated);
	visitor(player.m_iFreeGreatMerchantsCreated);
	visitor(player.m_iFreeGreatScientistsCreated);
	visitor(player.m_iFreeGreatEngineersCreated);
	visitor(player.m_iFreeGreatWritersCreated);
	visitor(player.m_iFreeGreatArtistsCreated);
	visitor(player.m_iFreeGreatMusiciansCreated);
	visitor(player.m_iFreeGreatDiplomatsCreated);
	visitor(player.m_iGPExtra1Created);
	visitor(player.m_iGPExtra2Created);
	visitor(player.m_iGPExtra3Created);
	visitor(player.m_iGPExtra4Created);
	visitor(player.m_iGPExtra5Created);
	visitor(player.m_iFreeGPExtra1Created);
	visitor(player.m_iFreeGPExtra2Created);
	visitor(player.m_iFreeGPExtra3Created);
	visitor(player.m_iFreeGPExtra4Created);
	visitor(player.m_iFreeGPExtra5Created);
	visitor(player.m_iGreatPeopleCreated);
	visitor(player.m_iGreatGeneralsCreated);
	visitor(player.m_iGreatAdmiralsCreated);
	visitor(player.m_iGreatMerchantsCreated);
	visitor(player.m_iGreatScientistsCreated);
	visitor(player.m_iGreatEngineersCreated);
	visitor(player.m_iGreatWritersCreated);
	visitor(player.m_iGreatArtistsCreated);
	visitor(player.m_iGreatMusiciansCreated);
	visitor(player.m_iGreatDiplomatsCreated);
	visitor(player.m_iDiplomatsFromFaith);
	visitor(player.m_iGPExtra1FromFaith);
	visitor(player.m_iGPExtra2FromFaith);
	visitor(player.m_iGPExtra3FromFaith);
	visitor(player.m_iGPExtra4FromFaith);
	visitor(player.m_iGPExtra5FromFaith);
	visitor(player.m_iMerchantsFromFaith);
	visitor(player.m_iScientistsFromFaith);
	visitor(player.m_iWritersFromFaith);
	visitor(player.m_iArtistsFromFaith);
	visitor(player.m_iMusiciansFromFaith);
	visitor(player.m_iGeneralsFromFaith);
	visitor(player.m_iAdmiralsFromFaith);
	visitor(player.m_iEngineersFromFaith);
	visitor(player.m_iGreatPeopleThresholdModifier);
	visitor(player.m_iGreatGeneralsThresholdModifier);
	visitor(player.m_iGreatAdmiralsThresholdModifier);
	visitor(player.m_iGreatGeneralCombatBonus);
	visitor(player.m_iAnarchyNumTurns);
	visitor(player.m_iPolicyCostModifier);
	visitor(player.m_iGreatPeopleRateModifier);
	visitor(player.m_iGreatPeopleRateModFromBldgs);
	visitor(player.m_iGreatGeneralRateModifier);
	visitor(player.m_iGreatGeneralRateModFromBldgs);
	visitor(player.m_iDomesticGreatGeneralRateModifier);
	visitor(player.m_iGreatAdmiralRateModifier);
	visitor(player.m_iGreatWriterRateModifier);
	visitor(player.m_iGreatArtistRateModifier);
	visitor(player.m_iGreatMusicianRateModifier);
	visitor(player.m_iGreatMerchantRateModifier);
	visitor(player.m_iGreatDiplomatRateModifier);
	visitor(player.m_iGreatScientistRateModifier);
	visitor(player.m_iGreatScientistBeakerModifier);
	visitor(player.m_iGreatEngineerHurryMod);
	visitor(player.m_iTechCostXCitiesModifier);
	visitor(player.m_iTourismCostXCitiesMod);
	visitor(player.m_iGreatEngineerRateModifier);
	visitor(player.m_iGreatPersonExpendGold);
	visitor(player.m_iPovertyUnhappinessMod);
	visitor(player.m_iDefenseUnhappinessMod);
	visitor(player.m_iUnculturedUnhappinessMod);
	visitor(player.m_iIlliteracyUnhappinessMod);
	visitor(player.m_iMinorityUnhappinessMod);
	visitor(player.m_iPovertyUnhappinessModCapital);
	visitor(player.m_iDefenseUnhappinessModCapital);
	visitor(player.m_iUnculturedUnhappinessModCapital);
	visitor(player.m_iIlliteracyUnhappinessModCapital);
	visitor(player.m_iMinorityUnhappinessModCapital);
	visitor(player.m_iNoUnhappfromXSpecialists);
	visitor(player.m_iHappfromXSpecialists);
	visitor(player.m_iNoUnhappfromXSpecialistsCapital);
	visitor(player.m_iSpecialistFoodChange);
	visitor(player.m_iWarWearinessModifier);
	visitor(player.m_iWarScoreModifier);
	visitor(player.m_iGarrisonsOccupiedUnhapppinessMod);
	visitor(player.m_iXPopulationConscription);
	visitor(player.m_iExtraMoves);
	visitor(player.m_iNoUnhappinessExpansion);
	visitor(player.m_iNoUnhappyIsolation);
	visitor(player.m_iDoubleBorderGrowthGA);
	visitor(player.m_iDoubleBorderGrowthWLTKD);
	visitor(player.m_iIncreasedQuestInfluence);
	visitor(player.m_iCultureBombBoost);
	visitor(player.m_iPuppetProdMod);
	visitor(player.m_iOccupiedProdMod);
	visitor(player.m_iGoldInternalTrade);
	visitor(player.m_iFreeWCVotes);
	visitor(player.m_iInfluenceGPExpend);
	visitor(player.m_iFreeTradeRoute);
	visitor(player.m_iFreeSpy);
	visitor(player.m_iReligionDistance);
	visitor(player.m_iPressureMod);
	visitor(player.m_iTradeReligionModifier);
	visitor(player.m_iCityStateCombatModifier);
	visitor(player.m_iMaxAirUnits);
	visitor(player.m_iInvestmentModifier);
	visitor(player.m_iMissionInfluenceModifier);
	visitor(player.m_iHappinessPerActiveTradeRoute);
	visitor(player.m_iCSResourcesCountMonopolies);
	visitor(player.m_iConquestPerEraBuildingProductionMod);
	visitor(player.m_iAdmiralLuxuryBonus);
	visitor(player.m_iPuppetYieldPenaltyMod);
	visitor(player.m_iNeedsModifierFromAirUnits);
	visitor(player.m_iFlatDefenseFromAirUnits);
	visitor(player.m_iMaxGlobalBuildingProductionModifier);
	visitor(player.m_iMaxTeamBuildingProductionModifier);
	visitor(player.m_iMaxPlayerBuildingProductionModifier);
	visitor(player.m_iFreeExperience);
	visitor(player.m_iFreeExperienceFromBldgs);
	visitor(player.m_iFreeExperienceFromMinors);
	visitor(player.m_iFeatureProductionModifier);
	visitor(player.m_iWorkerSpeedModifier);
	visitor(player.m_iImprovementCostModifier);
	visitor(player.m_iImprovementUpgradeRateModifier);
	visitor(player.m_iSpecialistProductionModifier);
	visitor(player.m_iMilitaryProductionModifier);
	visitor(player.m_iSpaceProductionModifier);
	visitor(player.m_iCityDefenseModifier);
	visitor(player.m_iUnitFortificationModifier);
	visitor(player.m_iUnitBaseHealModifier);
	visitor(player.m_iWonderProductionModifier);
	visitor(player.m_iSettlerProductionModifier);
	visitor(player.m_iCapitalSettlerProductionModifier);
	visitor(player.m_iUnitProductionMaintenanceMod);
	visitor(player.m_iUnitGrowthMaintenanceMod);
	visitor(player.m_iPolicyCostBuildingModifier);
	visitor(player.m_iPolicyCostMinorCivModifier);
	visitor(player.m_iInfluenceSpreadModifier);
	visitor(player.m_iExtraVotesPerDiplomat);
	visitor(player.m_iNumNukeUnits);
	visitor(player.m_iNumOutsideUnits);
	visitor(player.m_iBaseFreeUnits);
	visitor(player.m_iBaseFreeMilitaryUnits);
	visitor(player.m_iFreeUnitsPopulationPercent);
	visitor(player.m_iFreeMilitaryUnitsPopulationPercent);
	visitor(player.m_iGoldPerUnit);
	visitor(player.m_iGoldPerMilitaryUnit);
	visitor(player.m_iImprovementGoldMaintenanceMod);
	visitor(player.m_iRouteBuilderCostMod);
	visitor(player.m_iBuildingGoldMaintenanceMod);
	visitor(player.m_iUnitGoldMaintenanceMod);
	visitor(player.m_iUnitSupplyMod);
	visitor(player.m_iExtraUnitCost);
	visitor(player.m_iNumMilitaryUnits);
	visitor(player.m_iHappyPerMilitaryUnit);
	visitor(player.m_iHappinessToCulture);
	visitor(player.m_iHappinessToScience);
	visitor(player.m_iHalfSpecialistUnhappinessCount);
	visitor(player.m_iHalfSpecialistFoodCount);
	visitor(player.m_iHalfSpecialistFoodCapitalCount);
	visitor(player.m_iTradeRouteLandDistanceModifier);
	visitor(player.m_iTradeRouteSeaDistanceModifier);
	visitor(player.m_bNullifyInfluenceModifier);
	visitor(player.m_iMilitaryFoodProductionCount);
	visitor(player.m_iGoldenAgeCultureBonusDisabledCount);
	visitor(player.m_iNumMissionarySpreads);
	visitor(player.m_iSecondReligionPantheonCount);
	visitor(player.m_iEnablesSSPartHurryCount);
	visitor(player.m_iEnablesSSPartPurchaseCount);
	visitor(player.m_iConscriptCount);
	visitor(player.m_iMaxConscript);
	visitor(player.m_iHighestUnitLevel);
	visitor(player.m_iOverflowResearch);
	visitor(player.m_iExpModifier);
	visitor(player.m_iExpInBorderModifier);
	visitor(player.m_iLevelExperienceModifier);
	visitor(player.m_iMinorQuestFriendshipMod);
	visitor(player.m_iMinorGoldFriendshipMod);
	visitor(player.m_iMinorFriendshipMinimum);
	visitor(player.m_iMinorFriendshipDecayMod);
	visitor(player.m_iMinorScienceAlliesCount);
	visitor(player.m_iMinorResourceBonusCount);
	visitor(player.m_iAbleToAnnexCityStatesCount);
	visitor(player.m_iOnlyTradeSameIdeology);
	visitor(player.m_iSupplyFreeUnits);
	visitor(player.m_aistrInstantYield);
	visitor(player.m_abActiveContract);
	visitor(player.m_iJFDReformCooldownRate);
	visitor(player.m_iJFDGovernmentCooldownRate);
	visitor(player.m_strJFDPoliticKey);
	visitor(player.m_strJFDLegislatureName);
	visitor(player.m_iJFDPoliticLeader);
	visitor(player.m_iJFDSovereignty);
	visitor(player.m_iJFDGovernment);
	visitor(player.m_iJFDReformCooldown);
	visitor(player.m_iJFDGovernmentCooldown);
	visitor(player.m_iJFDPiety);
	visitor(player.m_iJFDPietyRate);
	visitor(player.m_iJFDConversionTurn);
	visitor(player.m_bJFDSecularized);
	visitor(player.m_strJFDCurrencyName);
	visitor(player.m_iJFDProsperity);
	visitor(player.m_iJFDCurrency);
	visitor(player.m_iGoldenAgeTourism);
	visitor(player.m_iExtraCultureandScienceTradeRoutes);
	visitor(player.m_iArchaeologicalDigTourism);
	visitor(player.m_iUpgradeCSVassalTerritory);
	visitor(player.m_iRazingSpeedBonus);
	visitor(player.m_iNoPartisans);
	visitor(player.m_iSpawnCooldown);
	visitor(player.m_bTradeRoutesInvulnerable);
	visitor(player.m_iTRSpeedBoost);
	visitor(player.m_iVotesPerGPT);
	visitor(player.m_iTRVisionBoost);
	visitor(player.m_iEventTourism);
	visitor(player.m_aiGlobalTourismAlreadyReceived);
	visitor(player.m_iEventTourismCS);
	visitor(player.m_iNumHistoricEvent);
	visitor(player.m_iSingleVotes);
	visitor(player.m_iMonopolyModFlat);
	visitor(player.m_iMonopolyModPercent);
	visitor(player.m_iCachedValueOfPeaceWithHuman);
	visitor(player.m_iFaithPurchaseCooldown);
	visitor(player.m_iCSAllies);
	visitor(player.m_iCSFriends);
	visitor(player.m_iCitiesNeedingTerrainImprovements);
	visitor(player.m_aiBestMilitaryCombatClassCity);
	visitor(player.m_aiBestMilitaryDomainCity);
	visitor(player.m_aiEventChoiceDuration);
	visitor(player.m_aiEventIncrement);
	visitor(player.m_aiEventCooldown);
	visitor(player.m_abEventActive);
	visitor(player.m_abEventChoiceActive);
	visitor(player.m_abEventChoiceFired);
	visitor(player.m_abEventFired);
	visitor(player.m_iPlayerEventCooldown);
	visitor(player.m_ownedNaturalWonders);
	visitor(player.m_paiUnitClassProductionModifiers);
	visitor(player.m_iExtraSupplyPerPopulation);
	visitor(player.m_iCitySupplyFlatGlobal);
	visitor(player.m_iUnitSupplyFromExpendedGP);
	visitor(player.m_iMissionaryExtraStrength);
	visitor(player.m_iFreeSpecialist);
	visitor(player.m_iCultureBombTimer);
	visitor(player.m_iConversionTimer);
	visitor(player.m_iCapitalCityID);
	visitor(player.m_iCitiesLost);
	visitor(player.m_iMilitaryRating);
	visitor(player.m_iMilitaryMight);
	visitor(player.m_iEconomicMight);
	visitor(player.m_iProductionMight);
	visitor(player.m_iTurnSliceMightRecomputed);
	visitor(player.m_iNewCityExtraPopulation);
	visitor(player.m_iFreeFoodBox);
	visitor(player.m_iScenarioScore1);
	visitor(player.m_iScenarioScore2);
	visitor(player.m_iScenarioScore3);
	visitor(player.m_iScenarioScore4);
	visitor(player.m_iScoreFromFutureTech);
	visitor(player.m_iTurnLastAttackedMinorCiv);
	visitor(player.m_iCombatExperienceTimes100);
	visitor(player.m_iLifetimeCombatExperienceTimes100);
	visitor(player.m_iNavalCombatExperienceTimes100);
	visitor(player.m_iBorderObstacleCount);
	visitor(player.m_iBorderGainlessPillageCount);
	visitor(player.m_iPopRushHurryCount);
	visitor(player.m_iTotalImprovementsBuilt);
	visitor(player.m_iCostNextPolicy);
	visitor(player.m_iNumBuilders);
	visitor(player.m_iMaxNumBuilders);
	visitor(player.m_iCityStrengthMod);
	visitor(player.m_iCityGrowthMod);
	visitor(player.m_iCapitalGrowthMod);
	visitor(player.m_iNumPlotsBought);
	visitor(player.m_iPlotGoldCostMod);
	visitor(player.m_iCityWorkingChange);
	visitor(player.m_iCityAutomatonWorkersChange);
	visitor(player.m_iCachedGoldRate);
	visitor(player.m_iPlotCultureCostModifier);
	visitor(player.m_iPlotCultureExponentModifier);
	visitor(player.m_iNumCitiesPolicyCostDiscount);
	visitor(player.m_iGarrisonedCityRangeStrikeModifier);
	visitor(player.m_iGarrisonFreeMaintenanceCount);
	visitor(player.m_iNumCitiesFreeCultureBuilding);
	visitor(player.m_iNumCitiesFreeFoodBuilding);
	visitor(player.m_iUnitPurchaseCostModifier);
	visitor(player.m_iAllFeatureProduction);
	visitor(player.m_iCityDistanceHighwaterMark);
	visitor(player.m_iOriginalCapitalX);
	visitor(player.m_iOriginalCapitalY);
	visitor(player.m_iHolyCityX);
	visitor(player.m_iHolyCityY);
	visitor(player.m_iNumWonders);
	visitor(player.m_iNumPolicies);
	visitor(player.m_iNumGreatPeople);
	visitor(player.m_iCityConnectionHappiness);
	visitor(player.m_iHolyCityID);
	visitor(player.m_iTurnsSinceSettledLastCity);
	visitor(player.m_iNumNaturalWondersDiscoveredInArea);
	visitor(player.m_iStrategicResourceMod);
	visitor(player.m_iSpecialistCultureChange);
	visitor(player.m_iGreatPeopleSpawnCounter);
	visitor(player.m_iFreeTechCount);
	visitor(player.m_iMedianTechPercentage);
	visitor(player.m_iNumFreePolicies);
	visitor(player.m_iNumFreePoliciesEver);
	visitor(player.m_iNumFreeTenets);
	visitor(player.m_iLastSliceMoved);
	visitor(player.m_uiStartTime);
	visitor(player.m_bHasUUPeriod);
	visitor(player.m_bNoNewWars);
	visitor(player.m_bTerribleShapeForWar);
	visitor(player.m_bHasBetrayedMinorCiv);
	visitor(player.m_bAlive);
	visitor(player.m_bEverAlive);
	visitor(player.m_bPotentiallyAlive);
	visitor(player.m_bTurnActive);
	visitor(player.m_bAutoMoves);
	visitor(player.m_bEndTurn);
	visitor(player.m_bDynamicTurnsSimultMode);
	visitor(player.m_bPbemNewTurn);
	visitor(player.m_bExtendedGame);
	visitor(player.m_bFoundedFirstCity);
	visitor(player.m_iNumCitiesFounded);
	visitor(player.m_bStrike);
	visitor(player.m_bCramped);
	visitor(player.m_bLostCapital);
	visitor(player.m_eConqueror);
	visitor(player.m_bLostHolyCity);
	visitor(player.m_eHolyCityConqueror);
	visitor(player.m_bHasAdoptedStateReligion);
	visitor(player.m_aiCityYieldChange);
	visitor(player.m_aiCoastalCityYieldChange);
	visitor(player.m_aiCapitalYieldChange);
	visitor(player.m_aiCapitalYieldPerPopChange);
	visitor(player.m_aiCapitalYieldPerPopChangeEmpire);
	visitor(player.m_aiSeaPlotYield);
	visitor(player.m_aiYieldRateModifier);
	visitor(player.m_paiJFDPoliticPercent);
	visitor(player.m_aiYieldFromMinors);
	visitor(player.m_paiResourceFromCSAlliances);
	visitor(player.m_paiResourceShortageValue);
	visitor(player.m_aiYieldFromBirth);
	visitor(player.m_aiYieldFromBirthCapital);
	visitor(player.m_aiYieldFromDeath);
	visitor(player.m_aiYieldFromPillage);
	visitor(player.m_aiYieldFromVictory);
	visitor(player.m_aiYieldFromConstruction);
	visitor(player.m_aiYieldFromWorldWonderConstruction);
	visitor(player.m_aiYieldFromTech);
	visitor(player.m_aiYieldFromBorderGrowth);
	visitor(player.m_aiYieldGPExpend);
	visitor(player.m_aiConquerorYield);
	visitor(player.m_aiFounderYield);
	visitor(player.m_aiArtifactYieldBonus);
	visitor(player.m_aiArtYieldBonus);
	visitor(player.m_aiMusicYieldBonus);
	visitor(player.m_aiLitYieldBonus);
	visitor(player.m_aiFilmYieldBonus);
	visitor(player.m_aiRelicYieldBonus);
	visitor(player.m_aiReligionYieldRateModifier);
	visitor(player.m_aiGoldenAgeYieldMod);
	visitor(player.m_aiYieldFromNonSpecialistCitizens);
	visitor(player.m_aiYieldModifierFromGreatWorks);
	visitor(player.m_aiYieldModifierFromActiveSpies);
	visitor(player.m_aiYieldFromDelegateCount);
	visitor(player.m_aiYieldForLiberation);
	visitor(player.m_iInfluenceForLiberation);
	visitor(player.m_iExperienceForLiberation);
	visitor(player.m_iCityCaptureHealGlobal);
	visitor(player.m_aiBuildingClassInLiberatedCities);
	visitor(player.m_iUnitsInLiberatedCities);
	visitor(player.m_paiBuildingClassCulture);
	visitor(player.m_aiDomainFreeExperiencePerGreatWorkGlobal);
	visitor(player.m_aiCityYieldModFromMonopoly);
	visitor(player.m_neededUnitAITypes);
	visitor(player.m_bAllowsProductionTradeRoutesGlobal);
	visitor(player.m_bAllowsFoodTradeRoutesGlobal);
	visitor(player.m_aiCapitalYieldRateModifier);
	visitor(player.m_aiExtraYieldThreshold);
	visitor(player.m_aiSpecialistExtraYield);
	visitor(player.m_aiPlayerNumTurnsAtPeace);
	visitor(player.m_aiPlayerNumTurnsAtWar);
	visitor(player.m_aiPlayerNumTurnsSinceCityCapture);
	visitor(player.m_aiWarValueLost);
	visitor(player.m_aiWarDamageValue);
	visitor(player.m_aiNumUnitsBuilt);
	visitor(player.m_aiProximityToPlayer);
	visitor(player.m_aiResearchAgreementCounter);
	visitor(player.m_aiSiphonLuxuryCount);
	visitor(player.m_aiGreatWorkYieldChange);
	visitor(player.m_aiTourismBonusTurnsPlayer);
	visitor(player.m_aOptions);
	visitor(player.m_strReligionKey);
	visitor(player.m_strScriptData);
	visitor(player.m_paiNumResourceUsed);
	visitor(player.m_paiNumResourceTotal);
	visitor(player.m_paiResourceGiftedToMinors);
	visitor(player.m_paiResourceExport);
	visitor(player.m_paiResourceImportFromMajor);
	visitor(player.m_paiResourceFromMinors);
	visitor(player.m_paiResourcesSiphoned);
	visitor(player.m_aiNumResourceFromGP);
	visitor(player.m_paiImprovementCount);
	visitor(player.m_paiImprovementBuiltCount);
	visitor(player.m_paiTotalImprovementsBuilt);
	visitor(player.m_paiBuildingChainSteps);
	visitor(player.m_paiFreeBuildingCount);
	visitor(player.m_paiFreePromotionCount);
	visitor(player.m_paiUnitCombatProductionModifiers);
	visitor(player.m_paiUnitCombatFreeExperiences);
	visitor(player.m_paiUnitClassCount);
	visitor(player.m_paiUnitClassMaking);
	visitor(player.m_paiBuildingClassCount);
	visitor(player.m_paiBuildingClassMaking);
	visitor(player.m_paiProjectMaking);
	visitor(player.m_paiHurryCount);
	visitor(player.m_paiHurryModifier);
	visitor(player.m_bVassalLevy);
	visitor(player.m_iVassalGoldMaintenanceMod);
	visitor(player.m_paiNumCitiesFreeChosenBuilding);
	visitor(player.m_pabFreeChosenBuildingNewCity);
	visitor(player.m_pabAllCityFreeBuilding);
	visitor(player.m_pabNewFoundCityFreeUnit);
	visitor(player.m_pabNewFoundCityFreeBuilding);
	visitor(player.m_pabLoyalMember);
	visitor(player.m_pabHasGlobalMonopoly);
	visitor(player.m_pabHasStrategicMonopoly);
	visitor(player.m_pabGetsScienceFromPlayer);
	visitor(player.m_ppaaiSpecialistExtraYield);
	visitor(player.m_ppiYieldFromYieldGlobal);
	visitor(player.m_ppiBuildingClassYieldChange);
	visitor(player.m_ppaaiImprovementYieldChange);
	visitor(player.m_bEverPoppedGoody);
	visitor(player.m_bEverTrainedBuilder);
	visitor(player.m_iPreviousBestSettlePlot);
	visitor(player.m_iFoundValueOfCapital);
	visitor(player.m_iNumFreeGreatPeople);
	visitor(player.m_iNumMayaBoosts);
	visitor(player.m_iNumFaithGreatPeople);
	visitor(player.m_iNumArchaeologyChoices);
	visitor(player.m_eFaithPurchaseType);
	visitor(player.m_iFaithPurchaseIndex);
	visitor(player.m_iFractionOriginalCapitalsUnderControl);
	visitor(player.m_iAvgUnitExp100);
	visitor(player.m_iNumMilitarySeaUnits);
	visitor(player.m_iNumMilitaryAirUnits);
	visitor(player.m_iNumMilitaryLandUnits);
	visitor(player.m_iMilitarySeaMight);
	visitor(player.m_iMilitaryAirMight);
	visitor(player.m_iMilitaryLandMight);

	visitor(*player.m_pPlayerPolicies);
	visitor(*player.m_pEconomicAI);
	visitor(*player.m_pCitySpecializationAI);
	visitor(*player.m_pWonderProductionAI);
	visitor(*player.m_pMilitaryAI);
	visitor(*player.m_pGrandStrategyAI);
	visitor(*player.m_pDiplomacyAI);
	visitor(*player.m_pReligions);
	visitor(*player.m_pReligionAI);
	visitor(*player.m_pCorporations);
	visitor(*player.m_pPlayerTechs);
	visitor(*player.m_pFlavorManager);
	visitor(*player.m_pTacticalAI);
	visitor(*player.m_pHomelandAI);
	visitor(*player.m_pMinorCivAI);
	visitor(*player.m_pDealAI);
	visitor(*player.m_pBuilderTaskingAI);
	visitor(*player.m_pCityConnections);
	visitor(*player.m_pDangerPlots);
	visitor(*player.m_pTraits);
	visitor(*player.m_pEspionage);
	visitor(*player.m_pEspionageAI);
	visitor(*player.m_pTrade);
	visitor(*player.m_pTradeAI);
	visitor(*player.m_pLeagueAI);
	visitor(*player.m_pCulture);

	// Notifications
	{
		bool bHasNotifications;
		if (bSaving)
			bHasNotifications = player.m_pNotifications != NULL;

		visitor(bHasNotifications);
		if (bHasNotifications)
		{
			if (bLoading)
			{
				FAssert(player.m_pNotifications == NULL);
				CvNotifications* pNotifications = FNEW(CvNotifications, c_eCiv5GameplayDLL, 0);
				visitor.loadAssign(player.m_pNotifications, pNotifications);
				pNotifications->Init(player.GetID());
			}
			visitor(*player.m_pNotifications);
		}
	}

	visitor(*player.m_pTreasury);

	// If this is a real player, hook up the player-level flavor recipients
	// This can happen anywhere after the related fields are loaded so feel free to move this
	if (bLoading && player.GetID() != NO_PLAYER)
	{
		SlotStatus s = CvPreGame::slotStatus(player.GetID());
		if ((s == SS_TAKEN || s == SS_COMPUTER) && !player.isBarbarian())
		{
			player.m_pFlavorManager->AddFlavorRecipient(player.m_pPlayerTechs, false /*bPropogateFlavors*/);
			player.m_pFlavorManager->AddFlavorRecipient(player.m_pPlayerPolicies, false /*bPropogateFlavors*/);
			player.m_pFlavorManager->AddFlavorRecipient(player.m_pWonderProductionAI, false /*bPropogateFlavors*/);
		}
	}

	visitor(player.m_researchQueue);
	visitor(player.m_eEndTurnBlockingType);
	visitor(player.m_iEndTurnBlockingNotificationIndex);

	visitor(player.m_cityNames);
	visitor(player.m_cities);

	if (bLoading)
		GC.getGame().SetClosestCityMapDirty();

	visitor(player.m_units);
	visitor(player.m_armyAIs);

	// AI operations
	{
		// const_cast because no constexpr if to force the loading path to be discarded during save compilation
		// The optimizer does discard this during release builds though!
		std::vector< std::pair<int, CvAIOperation*> >& mutAIOperations = const_cast<std::vector< std::pair<int, CvAIOperation*> >&>(player.m_AIOperations);

		if (bLoading)
			mutAIOperations.clear();
		
		uint32 operationCount;
		if (bSaving)
			operationCount = player.m_AIOperations.size();
		visitor(operationCount);

		for (uint i = 0; i < operationCount; ++i)
		{
			int iOperationType;
			if (bSaving)
				iOperationType = player.m_AIOperations[i].second->GetOperationType();
			visitor(iOperationType);

			if (bLoading)
			{
				//ok to pass dummy parameters, they will be overwritten ... only the type must be right
				CvAIOperation* pThisOperation = CreateAIOperation(AIOperationTypes(iOperationType), 0, NO_PLAYER, NO_PLAYER);
				visitor >> *pThisOperation;
				mutAIOperations.push_back(std::make_pair(pThisOperation->GetID(), pThisOperation));
			}
			if (bSaving)
				visitor << *player.m_AIOperations[i].second;
		}
	}

	/*
	if (bSaving && player.m_eID==0) //don't spam the log, assume all players are equal
	{
		for (std::map<CvString,TurnData>::const_iterator in = player.m_ReplayData.begin(); in != player.m_ReplayData.end(); in++)
			CUSTOMLOG("storing replay data %s", in->first.c_str());
	}
	*/
	visitor(player.m_ReplayData);
	/*
	if (bLoading && player.m_eID==0) //don't spam the log, assume all players are equal
	{
		for (std::map<CvString,TurnData>::const_iterator in = player.m_ReplayData.begin(); in != player.m_ReplayData.end(); in++)
			CUSTOMLOG("loading replay data %s", in->first.c_str());
	}
	*/

	visitor(player.m_ppiInstantYieldHistoryValues);
	visitor(player.m_ppiInstantTourismPerPlayerHistoryValues);

	visitor(player.m_aUnitExtraCosts);

	visitor(player.m_aiPlots);

	visitor(player.m_bfEverConqueredBy);

	visitor(player.m_strEmbarkedGraphicOverride);
	visitor(player.m_kPlayerAchievements);

	// Diplomacy requests
	if (player.GetID() < MAX_MAJOR_CIVS)
	{
		if (bLoading)
		{
			if (player.m_pDiplomacyRequests == NULL)
				visitor.loadAssign(player.m_pDiplomacyRequests, FNEW(CvDiplomacyRequests, c_eCiv5GameplayDLL, 0));
			else
				player.m_pDiplomacyRequests->Uninit();
			player.m_pDiplomacyRequests->Init(player.GetID());
		}
		if (bSaving)
		{
			FAssert(player.m_pDiplomacyRequests != NULL);
		}
		visitor(*player.m_pDiplomacyRequests);
	}

	visitor(player.m_ppiPlotYieldChange);
	visitor(player.m_ppiImprovementYieldChange);
	visitor(player.m_ppiFeatureYieldChange);
	visitor(player.m_ppiResourceYieldChange);
	visitor(player.m_ppiTerrainYieldChange);
	visitor(player.m_ppiTradeRouteYieldChange);
	visitor(player.m_ppiSpecialistYieldChange);
	visitor(player.m_ppiGreatPersonExpendedYield);
	visitor(player.m_piGoldenAgeGreatPersonRateModifier);
	visitor(player.m_ppiUnimprovedFeatureYieldChange);
	visitor(player.m_ppiCityYieldFromUnimprovedFeature);
	visitor(player.m_piYieldFromKills);
	visitor(player.m_piYieldFromBarbarianKills);
	visitor(player.m_piYieldChangeTradeRoute);
	visitor(player.m_piYieldChangesNaturalWonder);
	visitor(player.m_piYieldChangesPerReligion);
	visitor(player.m_piYieldChangeWorldWonder);
	visitor(player.m_piYieldFromMinorDemand);
	visitor(player.m_piYieldFromWLTKD);
	visitor(player.m_ppiBuildingClassYieldChange);
	visitor(player.m_piCityFeatures);
	visitor(player.m_piNumBuildings);
	visitor(player.m_piNumBuildingsInPuppets);
	visitor(player.m_piResponsibleForRouteCount);
	visitor(player.m_piResponsibleForImprovementCount);

	visitor(player.m_ppiSpecificGreatPersonRateModifierFromMonopoly);
	visitor(player.m_ppiSpecificGreatPersonRateChangeFromMonopoly);

	visitor(player.m_aistrInstantGreatPersonProgress);
	visitor(player.m_piDomainFreeExperience);

	visitor(player.m_piUnitClassReplacements);

	visitor(player.m_pabHasGlobalMonopoly);
	visitor(player.m_pabHasStrategicMonopoly);

	visitor(player.m_vCityConnectionPlots);
}

//	--------------------------------------------------------------------------------
//
// read object from a stream
// used during load
//
void CvPlayer::Read(FDataStream& kStream)
{
	// Init data before load
	reset();

	// Perform shared serialize
	CvStreamLoadVisitor serialVisitor(kStream);
	Serialize(*this, serialVisitor);

	if (MOD_WH_MILITARY_LOG && isHuman()) //Not serialized so shouldn't have any effect on savegames
	{
		m_pMilitaryLog = FNEW(CvEventLog, c_eCiv5GameplayDLL, 0);
		m_pMilitaryLog->Init(GetID());
	}

	if(!isBarbarian())
	{
		// Get the NetID from the initialization structure
		setNetID(gDLL->getAssignedNetworkID(GetID()));
	}

	if(m_bTurnActive)
		GC.getGame().changeNumGameTurnActive(1, std::string("setTurnActive() [loading save game] for player ") + getName());

	UpdateAreaEffectUnits();
	UpdateAreaEffectPlots();
	GET_TEAM(getTeam()).updateTeamStatus();
	UpdateCurrentAndFutureWars();
	int iLoop=0;
	for (CvCity* pCity=firstCity(&iLoop); pCity!=NULL; pCity=nextCity(&iLoop))
		pCity->UpdateClosestFriendlyNeighbors();
}

//	--------------------------------------------------------------------------------
//
// save object to a stream
// used during save
//
void CvPlayer::Write(FDataStream& kStream) const
{
	// Perform shared serialize
	CvStreamSaveVisitor serialVisitor(kStream);
	Serialize(*this, serialVisitor);
}

//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
void CvPlayer::createGreatGeneral(UnitTypes eGreatPersonUnit, int iX, int iY, bool bIsFree)
#else
void CvPlayer::createGreatGeneral(UnitTypes eGreatPersonUnit, int iX, int iY)
#endif
{
	CvUnit* pGreatPeopleUnit = initUnit(eGreatPersonUnit, iX, iY);
	if(NULL == pGreatPeopleUnit)
	{
		CvAssert(false);
		return;
	}
#if defined(MOD_BALANCE_CORE)
	if(GetPlayerTraits()->IsGPWLTKD() && pGreatPeopleUnit != NULL)
	{
		CvCity* pCity = pGreatPeopleUnit->plot()->getOwningCity();
		if (pCity != NULL && pCity->getOwner() == GetID())
		{
			int iWLTKD = /*6*/ GD_INT_GET(CITY_RESOURCE_WLTKD_TURNS) / 3;
			iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iWLTKD /= 100;

			if (iWLTKD > 0)
			{
				pCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
				CvNotifications* pNotifications = GetNotifications();
				if (pNotifications)
				{
					Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UA");
					strText << pGreatPeopleUnit->getNameKey() << pCity->getNameKey();
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UA");
					strSummary << pCity->getNameKey();
					pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), -1);
				}
			}
		}
	}
	if(pGreatPeopleUnit->isWLKTKDOnBirth())
	{
		CvCity* pLoopCity;
		int iLoop;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity != NULL && pLoopCity->getOwner() == GetID())
			{
				int iWLTKD = /*6*/ GD_INT_GET(CITY_RESOURCE_WLTKD_TURNS) / 3;
				iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iWLTKD /= 100;

				if (iWLTKD > 0)
				{
					pLoopCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
					CvNotifications* pNotifications = GetNotifications();
					if (pNotifications)
					{
						Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UNIT");
						strText << pGreatPeopleUnit->getNameKey() << pLoopCity->getNameKey();
						Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UNIT");
						strSummary << pLoopCity->getNameKey();
						pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pLoopCity->getX(), pLoopCity->getY(), -1);
					}
				}
			}
		}
	}
	if(pGreatPeopleUnit->getUnitInfo().IsFoundReligion())
	{
		ReligionTypes eReligion = GetReligions()->GetOwnedReligion();
		CvCity* pCity = pGreatPeopleUnit->plot()->getOwningCity();
		pGreatPeopleUnit->GetReligionDataMutable()->SetFullStrength(GetID(),pGreatPeopleUnit->getUnitInfo(),eReligion,pCity);
	}
	if(pGreatPeopleUnit->isGoldenAgeOnBirth())
	{
		changeGoldenAgeTurns(getGoldenAgeLength());
	}
	if(pGreatPeopleUnit->isCultureBoost())
	{
		int iValue = GetTotalJONSCulturePerTurn() * 4;
		changeJONSCulture(iValue);
		if(getCapitalCity() != NULL)
		{
			getCapitalCity()->ChangeJONSCultureStored(iValue);
		}
		CvNotifications* pNotifications = GetNotifications();
		if (pNotifications)
		{
			Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CULTURE_UNIT");
			strText << pGreatPeopleUnit->getNameKey();
			Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CULTURE_UNIT");
			strSummary << pGreatPeopleUnit->getNameKey();
			pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pGreatPeopleUnit->getX(), pGreatPeopleUnit->getY(), -1);
		}
	}
	if(pGreatPeopleUnit->IsCombatUnit() && getCapitalCity() != NULL)
	{
		getCapitalCity()->addProductionExperience(pGreatPeopleUnit);
		pGreatPeopleUnit->setOriginCity(getCapitalCity()->GetID());
	}
#endif
	ChangeNumGreatPeople(1);

#if defined(MOD_GLOBAL_TRULY_FREE_GP)
	incrementGreatGeneralsCreated(bIsFree);
#else
	incrementGreatGeneralsCreated();
#endif

#if defined(MOD_GLOBAL_TRULY_FREE_GP)
	changeGreatGeneralsThresholdModifier(/*50*/ GD_INT_GET(GREAT_GENERALS_THRESHOLD_INCREASE) * ((getGreatGeneralsCreated(bIsFree) / 10) + 1));
#else
	changeGreatGeneralsThresholdModifier(/*50*/ GD_INT_GET(GREAT_GENERALS_THRESHOLD_INCREASE) * ((getGreatGeneralsCreated() / 10) + 1));
#endif

	for(int iI = 0; iI < MAX_PLAYERS; iI++)
	{
		if(GET_PLAYER((PlayerTypes)iI).getTeam() == getTeam())
		{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
			GET_PLAYER((PlayerTypes)iI).changeGreatGeneralsThresholdModifier(/*50*/ GD_INT_GET(GREAT_GENERALS_THRESHOLD_INCREASE_TEAM) * ((getGreatGeneralsCreated(bIsFree) / 10) + 1));
#else
			GET_PLAYER((PlayerTypes)iI).changeGreatGeneralsThresholdModifier(/*50*/ GD_INT_GET(GREAT_GENERALS_THRESHOLD_INCREASE_TEAM) * ((getGreatGeneralsCreated() / 10) + 1));
#endif
		}
	}

#if defined(MOD_GLOBAL_LOCAL_GENERALS)
	CvPlot* pPlot = pGreatPeopleUnit->plot();

	// In rare cases we can gain the general from an embarked unit being attacked, or from a hovering unit over coast
	// so if this plot is water, relocate the Great General
	if (pPlot->isWater() || pGreatPeopleUnit->IsCombatUnit()) {
		pGreatPeopleUnit->jumpToNearestValidPlot();
	}
#else
	CvPlot* pPlot = GC.getMap().plot(iX, iY);
#endif

#if defined(MOD_API_ACHIEVEMENTS)
	//Achievements and Stats
	if(pGreatPeopleUnit->isHuman() && !GC.getGame().isGameMultiPlayer())
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_GREATGENERALS);
		const char* strLeader = GET_PLAYER(pGreatPeopleUnit->getOwner()).getLeaderTypeKey();
		if(strLeader && strcmp(strLeader, "LEADER_WU_ZETIAN") == 0)
		{
			gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_SUNTZU);
		}

		CvAchievementUnlocker::Check_PSG();
	}
#endif
	// Notification
	if(GetNotifications())
	{
		Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER");
		Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_GREAT_PERSON");
		GetNotifications()->Add(NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER, strText.toUTF8(), strSummary.toUTF8(), pPlot->getX(), pPlot->getY(), eGreatPersonUnit);
	}
}

//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
void CvPlayer::createGreatAdmiral(UnitTypes eGreatPersonUnit, int iX, int iY, bool bIsFree)
#else
void CvPlayer::createGreatAdmiral(UnitTypes eGreatPersonUnit, int iX, int iY)
#endif
{
	CvUnit* pGreatPeopleUnit = initUnit(eGreatPersonUnit, iX, iY);
	if(NULL == pGreatPeopleUnit)
	{
		CvAssert(false);
		return;
	}
#if defined(MOD_BALANCE_CORE)
	if(GetPlayerTraits()->IsGPWLTKD() && pGreatPeopleUnit != NULL)
	{
		CvCity* pCity = pGreatPeopleUnit->plot()->getOwningCity();
		if (pCity != NULL && pCity->getOwner() == GetID())
		{
			int iWLTKD = /*6*/ GD_INT_GET(CITY_RESOURCE_WLTKD_TURNS) / 3;
			iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iWLTKD /= 100;

			if (iWLTKD > 0)
			{
				pCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
				CvNotifications* pNotifications = GetNotifications();
				if (pNotifications)
				{
					Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UA");
					strText << pGreatPeopleUnit->getNameKey() << pCity->getNameKey();
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UA");
					strSummary << pCity->getNameKey();
					pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), -1);
				}
			}
		}
	}
	if(pGreatPeopleUnit->isWLKTKDOnBirth())
	{
		CvCity* pLoopCity;
		int iLoop;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity != NULL && pLoopCity->getOwner() == GetID())
			{
				int iWLTKD = /*6*/ GD_INT_GET(CITY_RESOURCE_WLTKD_TURNS) / 3;
				iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iWLTKD /= 100;

				if (iWLTKD > 0)
				{
					pLoopCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
					CvNotifications* pNotifications = GetNotifications();
					if (pNotifications)
					{
						Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UNIT");
						strText << pGreatPeopleUnit->getNameKey() << pLoopCity->getNameKey();
						Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UNIT");
						strSummary << pLoopCity->getNameKey();
						pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pLoopCity->getX(), pLoopCity->getY(), -1);
					}
				}
			}
		}
	}
	if(pGreatPeopleUnit->isGoldenAgeOnBirth())
	{
		changeGoldenAgeTurns(getGoldenAgeLength());
	}
	if(pGreatPeopleUnit->isCultureBoost())
	{
		int iValue = GetTotalJONSCulturePerTurn() * 4;
		changeJONSCulture(iValue);
		if(getCapitalCity() != NULL)
		{
			getCapitalCity()->ChangeJONSCultureStored(iValue);
		}
		CvNotifications* pNotifications = GetNotifications();
		if (pNotifications)
		{
			Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CULTURE_UNIT");
			strText << pGreatPeopleUnit->getNameKey();
			Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CULTURE_UNIT");
			strSummary << pGreatPeopleUnit->getNameKey();
			pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pGreatPeopleUnit->getX(), pGreatPeopleUnit->getY(), -1);
		}
	}
	if(pGreatPeopleUnit->IsCombatUnit())
	{
		getCapitalCity()->addProductionExperience(pGreatPeopleUnit);
	}
#endif
	ChangeNumGreatPeople(1);
#if !defined(MOD_GLOBAL_LOCAL_GENERALS)
	CvPlot *pSpawnPlot = GetBestCoastalSpawnPlot(pGreatPeopleUnit);
	if (pGreatPeopleUnit->plot() != pSpawnPlot)
	{
		pGreatPeopleUnit->setXY(pSpawnPlot->getX(), pSpawnPlot->getY());
	}
#endif

#if defined(MOD_GLOBAL_TRULY_FREE_GP)
	incrementGreatAdmiralsCreated(bIsFree);
#else
	incrementGreatAdmiralsCreated();
#endif
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
	changeGreatAdmiralsThresholdModifier(/*50*/ GD_INT_GET(GREAT_GENERALS_THRESHOLD_INCREASE) * ((getGreatAdmiralsCreated(bIsFree) / 10) + 1));
#else
	changeGreatAdmiralsThresholdModifier(/*50*/ GD_INT_GET(GREAT_GENERALS_THRESHOLD_INCREASE) * ((getGreatAdmiralsCreated() / 10) + 1));
#endif

	for(int iI = 0; iI < MAX_PLAYERS; iI++)
	{
		if(GET_PLAYER((PlayerTypes)iI).getTeam() == getTeam())
		{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
			GET_PLAYER((PlayerTypes)iI).changeGreatAdmiralsThresholdModifier(/*50*/ GD_INT_GET(GREAT_GENERALS_THRESHOLD_INCREASE_TEAM) * ((getGreatAdmiralsCreated(bIsFree) / 10) + 1));
#else
			GET_PLAYER((PlayerTypes)iI).changeGreatAdmiralsThresholdModifier(/*50*/ GD_INT_GET(GREAT_GENERALS_THRESHOLD_INCREASE_TEAM) * ((getGreatAdmiralsCreated() / 10) + 1));
#endif
		}
	}

	CvPlot* pPlot = GC.getMap().plot(iX, iY);

	// Notification
	if(GetNotifications())
	{
		Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER");
		Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_GREAT_PERSON");
		GetNotifications()->Add(NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER, strText.toUTF8(), strSummary.toUTF8(), pPlot->getX(), pPlot->getY(), eGreatPersonUnit);
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::launch(VictoryTypes eVictory)
{
	CvTeam& kTeam = GET_TEAM(getTeam());

	if(!kTeam.canLaunch(eVictory))
	{
		return;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getUnitExtraCost(UnitClassTypes eUnitClass) const
{
	for(std::vector< std::pair<UnitClassTypes, int> >::const_iterator it = m_aUnitExtraCosts.begin(); it != m_aUnitExtraCosts.end(); ++it)
	{
		if((*it).first == eUnitClass)
		{
			return ((*it).second);
		}
	}

	return 0;
}

//	--------------------------------------------------------------------------------
void CvPlayer::setUnitExtraCost(UnitClassTypes eUnitClass, int iCost)
{
	for(std::vector< std::pair<UnitClassTypes, int> >::iterator it = m_aUnitExtraCosts.begin(); it != m_aUnitExtraCosts.end(); ++it)
	{
		if((*it).first == eUnitClass)
		{
			if(0 == iCost)
			{
				m_aUnitExtraCosts.erase(it);
			}
			else
			{
				(*it).second = iCost;
			}
			return;
		}
	}

	if(0 != iCost)
	{
		m_aUnitExtraCosts.push_back(std::make_pair(eUnitClass, iCost));
	}
}

// CACHE: cache frequently used values
///////////////////////////////////////

//	--------------------------------------------------------------------------------
void CvPlayer::invalidatePopulationRankCache()
{
	int iLoop;
	CvCity* pLoopCity;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->invalidatePopulationRankCache();
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::invalidateYieldRankCache(YieldTypes)
{
	int iLoop;
	CvCity* pLoopCity;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->invalidateYieldRankCache();
	}
}

//	--------------------------------------------------------------------------------
PlayerTypes CvPlayer::pickConqueredCityOwner(const CvCity& kCity) const
{
	PlayerTypes eBestPlayer = kCity.getOriginalOwner();

	if(NO_PLAYER != eBestPlayer)
	{
		CvPlayer& kBestPlayer = GET_PLAYER(eBestPlayer);

		if(kBestPlayer.getTeam() == getTeam())
		{
			return eBestPlayer;
		}
	}

	return GetID();
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canStealTech(PlayerTypes eTarget, TechTypes eTech) const
{
	if(GET_TEAM(GET_PLAYER(eTarget).getTeam()).GetTeamTechs()->HasTech(eTech))
	{
		if(GetPlayerTechs()->CanResearch(eTech))
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canSpyDestroyUnit(PlayerTypes, CvUnit& kUnit) const
{
	if(kUnit.getTeam() == getTeam())
	{
		return false;
	}

	if(kUnit.getUnitInfo().GetProductionCost() <= 0)
	{
		return false;
	}

	if(!kUnit.plot()->isVisible(getTeam()))
	{
		return false;
	}

	return true;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canSpyBribeUnit(PlayerTypes eTarget, CvUnit& kUnit) const
{
	if(!canSpyDestroyUnit(eTarget, kUnit))
	{
		return false;
	}

	// Can't buy units when at war
	if(kUnit.isEnemy(getTeam()))
	{
		return false;
	}

	IDInfo* pUnitNode = kUnit.plot()->headUnitNode();

	while(pUnitNode != NULL)
	{
		CvUnit* pLoopUnit = ::GetPlayerUnit(*pUnitNode);
		pUnitNode = kUnit.plot()->nextUnitNode(pUnitNode);

		if(NULL != pLoopUnit && pLoopUnit != &kUnit)
		{
			if(pLoopUnit->isEnemy(getTeam()))
			{
				// If we buy the unit, we will be on the same plot as an enemy unit! Not good.
				return false;
			}
		}
	}

	return true;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canSpyDestroyBuilding(PlayerTypes, BuildingTypes eBuilding) const
{
	CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
	if(pkBuilding)
	{
		if(pkBuilding->GetProductionCost() <= 0)
		{
			return false;
		}

		if(::isLimitedWonderClass(pkBuilding->GetBuildingClassInfo()))
		{
			return false;
		}
	}

	return true;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canSpyDestroyProject(PlayerTypes eTarget, ProjectTypes eProject) const
{
	CvProjectEntry& kProject = *GC.getProjectInfo(eProject);
	if(kProject.GetProductionCost() <= 0)
	{
		return false;
	}

	if(GET_TEAM(GET_PLAYER(eTarget).getTeam()).getProjectCount(eProject) <= 0)
	{
		return false;
	}

	if(::isWorldProject(eProject))
	{
		return false;
	}

	if(!kProject.IsSpaceship())
	{
		return false;
	}
	else
	{
		VictoryTypes eVictory = (VictoryTypes)kProject.GetVictoryPrereq();
		if(NO_VICTORY != eVictory)
		{
			// Can't destroy spaceship components if we have already launched
			if(GET_TEAM(GET_PLAYER(eTarget).getTeam()).getVictoryCountdown(eVictory) >= 0)
			{
				return false;
			}
		}
	}

	return true;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNewCityProductionValue() const
{
	if (/*0*/ GD_INT_GET(SETTLER_PRODUCTION_SPEED) != 0)
	{
		return GD_INT_GET(SETTLER_PRODUCTION_SPEED);
	}

	int iValue = 0;
	for (int iJ = 0; iJ < GC.getNumBuildingClassInfos(); iJ++)
	{
		const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iJ);
		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
		if (pkBuildingClassInfo)
		{
			const BuildingTypes eBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(iJ)));
			if (NO_BUILDING != eBuilding)
			{
				CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
				if (pkBuildingInfo)
				{
					if (pkBuildingInfo->GetFreeStartEra() != NO_ERA)
					{
						if (GC.getGame().getStartEra() >= pkBuildingInfo->GetFreeStartEra())
						{
							iValue += (100 * getProductionNeeded(eBuilding)) / std::max(1, 100 + getProductionModifier(eBuilding));
						}
					}
				}
			}
		}
	}

	iValue *= 100 + /*-60*/ GD_INT_GET(NEW_CITY_BUILDING_VALUE_MODIFIER);
	iValue /= 100;

	CvGame& kGame = GC.getGame();

	iValue += (/*84*/ GD_INT_GET(ADVANCED_START_CITY_COST) * kGame.getGameSpeedInfo().getGrowthPercent()) / 100;

	if (MOD_ALTERNATIVE_DIFFICULTY && !isHuman() && !isBarbarian() && GetNumCitiesFounded() > 1)
	{
		iValue *= GC.getGame().getHandicapInfo().getAIGrowthPercent();
		iValue /= 100;
	}

	int iPopulation = /*1*/ GD_INT_GET(INITIAL_CITY_POPULATION) + kGame.getStartEraInfo().getFreePopulation();
	for (int i = 1; i <= iPopulation; ++i)
	{
		iValue += (getGrowthThreshold(i) * /*150*/ GD_INT_GET(ADVANCED_START_POPULATION_COST)) / 100;
	}

	if (MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	{
		iValue *= (100 + (getNumCities() * /*10*/ GD_INT_GET(BALANCE_HAPPINESS_EMPIRE_MULTIPLIER)));
		iValue /= 100;
	}

	return iValue;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGrowthThreshold(int iPopulation) const
{
	CvAssertMsg(iPopulation > 0, "Population of city should be at least 1. Please show Jon this and send your last 5 autosaves.");

	int iBaseThreshold = /*15*/ GD_INT_GET(BASE_CITY_GROWTH_THRESHOLD);
	int iExtraPopThreshold = int((iPopulation-1) * /*8.0f in CP, 12.0f in VP*/ GD_FLOAT_GET(CITY_GROWTH_MULTIPLIER));

	iBaseThreshold += iExtraPopThreshold;
	iExtraPopThreshold = (int) pow(double(iPopulation-1), (double) /*1.5f in CP, 2.22f in VP*/ GD_FLOAT_GET(CITY_GROWTH_EXPONENT));

	int iThreshold = iBaseThreshold + iExtraPopThreshold;

	if (isMinorCiv())
	{
		iThreshold *= /*80 in CP, 75 in VP*/ GD_INT_GET(MINOR_CIV_GROWTH_PERCENT);
		iThreshold /= 100;
	}

	iThreshold *= GC.getGame().getGameSpeedInfo().getGrowthPercent();
	iThreshold /= 100;

	iThreshold *= GC.getGame().getStartEraInfo().getGrowthPercent();
	iThreshold /= 100;

	if (!isBarbarian())
	{
		if (isHuman())
		{
			if (MOD_ALTERNATIVE_DIFFICULTY)
			{
				iThreshold *= std::max(0, ((GC.getGame().getHandicapInfo().getHumanPerEraMod() * GC.getGame().getCurrentEra()) + 100));
				iThreshold /= 100;
			}
		}
		else
		{
			iThreshold *= GC.getGame().getHandicapInfo().getAIGrowthPercent();
			iThreshold /= 100;

			if (MOD_ALTERNATIVE_DIFFICULTY)
			{
				iThreshold *= std::max(0, ((GC.getGame().getHandicapInfo().getAIGrowthPerEraMod() * GC.getGame().getCurrentEra()) + 100));
				iThreshold /= 100;
			}

			if (!MOD_BALANCE_CORE_DIFFICULTY)
			{
				iThreshold *= std::max(0, ((GC.getGame().getHandicapInfo().getAIPerEraModifier() * GetCurrentEra()) + 100));
				iThreshold /= 100;
			}
		}
	}

	return std::max(1, iThreshold);
}

//	--------------------------------------------------------------------------------
/// This determines what plots the player has under control
void CvPlayer::UpdatePlots(void)
{
	m_aiPlots.clear();

	int iNumPlotsInEntireWorld = GC.getMap().numPlots();
	for(int iI = 0; iI < iNumPlotsInEntireWorld; iI++)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);
		if(pLoopPlot->getOwner() != m_eID)
			continue;

		//somebody might have plundered an improvement
		pLoopPlot->updateWaterFlags();

		m_aiPlots.push_back(iI);
	}
}

//	--------------------------------------------------------------------------------
/// Adds a plot at the end of the list
void CvPlayer::AddAPlot(CvPlot* pPlot)
{
	if(!pPlot)
		return;

	m_aiPlots.push_back(pPlot->GetPlotIndex());
}

//	--------------------------------------------------------------------------------
/// Returns the list of the plots the player owns
const PlotIndexContainer& CvPlayer::GetPlots(void) const
{
	return m_aiPlots;
}

//	--------------------------------------------------------------------------------
/// How many plots does this player own?
int CvPlayer::GetNumPlots() const
{
	return m_aiPlots.size();
}


//	--------------------------------------------------------------------------------
/// City strength mod (i.e. 100 = strength doubled)
int CvPlayer::GetCityStrengthMod() const
{
	return m_iCityStrengthMod;
}

//	--------------------------------------------------------------------------------
/// Sets City strength mod (i.e. 100 = strength doubled)
void CvPlayer::SetCityStrengthMod(int iValue)
{
	CvAssert(iValue >= 0);
	m_iCityStrengthMod = iValue;

	// Loop through all Cities and update their strength
	CvCity* pLoopCity;
	int iLoop;

	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->updateStrengthValue();
	}
}

//	--------------------------------------------------------------------------------
/// Changes City strength mod (i.e. 100 = strength doubled)
void CvPlayer::ChangeCityStrengthMod(int iChange)
{
	if(iChange != 0)
	{
		SetCityStrengthMod(GetCityStrengthMod() + iChange);
	}
}

//	--------------------------------------------------------------------------------
/// City growth percent mod (i.e. 100 = foodDifference doubled)
int CvPlayer::GetCityGrowthMod() const
{
	return m_iCityGrowthMod;
}

//	--------------------------------------------------------------------------------
/// Sets City growth percent mod (i.e. 100 = foodDifference doubled)
void CvPlayer::SetCityGrowthMod(int iValue)
{
	CvAssert(iValue >= 0);
	m_iCityGrowthMod = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes City growth percent mod (i.e. 100 = foodDifference doubled)
void CvPlayer::ChangeCityGrowthMod(int iChange)
{
	if(iChange != 0)
	{
		SetCityGrowthMod(GetCityGrowthMod() + iChange);
	}
}


//	--------------------------------------------------------------------------------
/// Capital growth percent mod (i.e. 100 = foodDifference doubled)
int CvPlayer::GetCapitalGrowthMod() const
{
	return m_iCapitalGrowthMod;
}

//	--------------------------------------------------------------------------------
/// Sets Capital growth percent mod (i.e. 100 = foodDifference doubled)
void CvPlayer::SetCapitalGrowthMod(int iValue)
{
	CvAssert(iValue >= 0);
	m_iCapitalGrowthMod = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes Capital growth percent mod (i.e. 100 = foodDifference doubled)
void CvPlayer::ChangeCapitalGrowthMod(int iChange)
{
	if(iChange != 0)
	{
		SetCapitalGrowthMod(GetCapitalGrowthMod() + iChange);
	}
}

//	--------------------------------------------------------------------------------
/// How many Plot has this player bought (costs should ramp up as more are purchased)
int CvPlayer::GetNumPlotsBought() const
{
	return m_iNumPlotsBought;
}

//	--------------------------------------------------------------------------------
/// Sets how many Plot has this player bought (costs should ramp up as more are purchased)
void CvPlayer::SetNumPlotsBought(int iValue)
{
	CvAssert(iValue >= 0);
	m_iNumPlotsBought = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes how many Plot has this player bought (costs should ramp up as more are purchased)
void CvPlayer::ChangeNumPlotsBought(int iChange)
{
	if(iChange != 0)
	{
		SetNumPlotsBought(GetNumPlotsBought() + iChange);
	}
}

//	--------------------------------------------------------------------------------
/// Gold cost of buying a new Plot
int CvPlayer::GetBuyPlotCost() const
{
	int iCost = /*50*/ GD_INT_GET(PLOT_BASE_COST);
	iCost += (/*5*/ GD_INT_GET(PLOT_ADDITIONAL_COST_PER_PLOT) * GetNumPlotsBought());

	// Cost Mod (Policies, etc.)
	if (GetPlotGoldCostMod() != 0)
	{
		iCost *= (100 + GetPlotGoldCostMod());
		iCost /= 100;
	}

	if (isMinorCiv())
	{
		iCost *= /*120*/ GD_INT_GET(MINOR_CIV_GOLD_PERCENT);
		iCost /= 100;
	}

	return iCost;
}

//	--------------------------------------------------------------------------------
/// How much of a discount do we have for Plot buying
int CvPlayer::GetPlotGoldCostMod() const
{
	return m_iPlotGoldCostMod;
}

//	--------------------------------------------------------------------------------
/// Changes how much of a discount we have for Plot buying
void CvPlayer::ChangePlotGoldCostMod(int iChange)
{
	if(iChange != 0)
	{
		m_iPlotGoldCostMod += iChange;
	}
}

#if defined(MOD_TRAITS_CITY_WORKING) || defined(MOD_BUILDINGS_CITY_WORKING) || defined(MOD_POLICIES_CITY_WORKING) || defined(MOD_TECHS_CITY_WORKING)
//	--------------------------------------------------------------------------------
/// How many more city rings can we work
int CvPlayer::GetCityWorkingChange() const
{
	return m_iCityWorkingChange;
}

//	--------------------------------------------------------------------------------
/// Changes how many more city rings we can work
void CvPlayer::ChangeCityWorkingChange(int iChange)
{
	if(iChange != 0)
	{
		CvCity* pLoopCity;
		int iLoop;
		
		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
			int iOldPlots = pLoopCity->GetNumWorkablePlots();
			int iNewPlots = pLoopCity->GetNumWorkablePlots(iChange);
			
			for (int iI = std::min(iOldPlots, iNewPlots); iI < std::max(iOldPlots, iNewPlots); ++iI) {
				CvPlot* pLoopPlot = iterateRingPlots(pLoopCity->getX(), pLoopCity->getY(), iI);

				if (pLoopPlot) {
					pLoopPlot->changeCityRadiusCount(iChange);
					pLoopPlot->changePlayerCityRadiusCount(GetID(), iChange);
				}
			}
		}

		m_iCityWorkingChange += iChange;
	}
}
#endif

#if defined(MOD_TRAITS_CITY_AUTOMATON_WORKERS) || defined(MOD_BUILDINGS_CITY_AUTOMATON_WORKERS) || defined(MOD_POLICIES_CITY_AUTOMATON_WORKERS) || defined(MOD_TECHS_CITY_AUTOMATON_WORKERS)
//	--------------------------------------------------------------------------------
/// How many more automatons does each city have?
int CvPlayer::GetCityAutomatonWorkersChange() const
{
	return m_iCityAutomatonWorkersChange;
}

//	--------------------------------------------------------------------------------
/// Changes how many more automatons each city has
void CvPlayer::ChangeCityAutomatonWorkersChange(int iChange)
{
	if (iChange != 0)
	{
		CvCity* pLoopCity;
		int iLoop;

		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
			pLoopCity->changeCityAutomatonWorkersChange(iChange);
		}

		m_iCityAutomatonWorkersChange += iChange;
	}
}
#endif

//	--------------------------------------------------------------------------------
/// How much Culture is required for this City to acquire a new Plot
int CvPlayer::GetPlotCultureCostModifier() const
{
	return m_iPlotCultureCostModifier;
}

//	--------------------------------------------------------------------------------
/// Changes how much Culture is required for this City to acquire a new Plot
void CvPlayer::ChangePlotCultureCostModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iPlotCultureCostModifier += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// How much do we dampen the exponent used to determine Culture needed for a City to acquire a new Plot?
int CvPlayer::GetPlotCultureExponentModifier() const
{
	return m_iPlotCultureExponentModifier;
}

//	--------------------------------------------------------------------------------
/// Changes how much we dampen the exponent used to determine Culture needed for a City to acquire a new Plot?
void CvPlayer::ChangePlotCultureExponentModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iPlotCultureExponentModifier += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// How much do we dampen the growth of policy costs based on number of cities?
int CvPlayer::GetNumCitiesPolicyCostDiscount() const
{
	return m_iNumCitiesPolicyCostDiscount;
}

//	--------------------------------------------------------------------------------
/// Changes how much we dampen the growth of policy costs based on number of cities
void CvPlayer::ChangeNumCitiesPolicyCostDiscount(int iChange)
{
	if(iChange != 0)
	{
		m_iNumCitiesPolicyCostDiscount += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Do we save on unit maintenance for garrisons?
bool CvPlayer::IsGarrisonFreeMaintenance() const
{
	return m_iGarrisonFreeMaintenanceCount > 0;
}

//	--------------------------------------------------------------------------------
/// Changes setting on unit maintenance for garrisons
void CvPlayer::ChangeGarrisonFreeMaintenanceCount(int iChange)
{
	if(iChange != 0)
	{
		m_iGarrisonFreeMaintenanceCount += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Increase in city range strike due to garrison
int CvPlayer::GetGarrisonedCityRangeStrikeModifier() const
{
	return m_iGarrisonedCityRangeStrikeModifier;
}

//	--------------------------------------------------------------------------------
/// Changes increase in city range strike due to garrison
void CvPlayer::ChangeGarrisonedCityRangeStrikeModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iGarrisonedCityRangeStrikeModifier += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Cost of purchasing units modified?
int CvPlayer::GetUnitPurchaseCostModifier() const
{
	return m_iUnitPurchaseCostModifier;
}

//	--------------------------------------------------------------------------------
/// Cost of purchasing units modified?
void CvPlayer::ChangeUnitPurchaseCostModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iUnitPurchaseCostModifier += iChange;
	}
}

int CvPlayer::GetPlotDanger(const CvPlot& pPlot, const CvUnit* pUnit, const UnitIdContainer& unitsToIgnore, int iExtraDamage, AirActionType iAirAction)
{
	if (m_pDangerPlots->IsDirty())
		m_pDangerPlots->UpdateDanger();

	return m_pDangerPlots->GetDanger(pPlot, pUnit, unitsToIgnore, iExtraDamage, iAirAction);
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetPlotDanger(const CvCity* pCity, const CvUnit* pPretendGarrison)
{
	if (m_pDangerPlots->IsDirty())
		m_pDangerPlots->UpdateDanger();

	return m_pDangerPlots->GetDanger(pCity, pPretendGarrison);
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetPlotDanger(const CvPlot& pPlot, bool bFixedDamageOnly)
{
	if (m_pDangerPlots->IsDirty())
		m_pDangerPlots->UpdateDanger();

	return m_pDangerPlots->GetDanger(pPlot, bFixedDamageOnly);
}

void CvPlayer::ResetDangerCache(const CvPlot & Plot, int iRange)
{
	m_pDangerPlots->ResetDangerCache(&Plot, iRange);
}

int CvPlayer::GetDangerPlotAge() const
{
	return m_pDangerPlots->GetTurnSliceBuilt();
}

std::vector<CvUnit*> CvPlayer::GetPossibleAttackers(const CvPlot& Plot, TeamTypes eTeamForVisibilityCheck)
{
	if (m_pDangerPlots->IsDirty())
		m_pDangerPlots->UpdateDanger();

	return m_pDangerPlots->GetPossibleAttackers(Plot, eTeamForVisibilityCheck);
}

bool CvPlayer::IsKnownAttacker(const CvUnit* pAttacker)
{
	if (m_pDangerPlots->IsDirty())
		m_pDangerPlots->UpdateDanger();

	return m_pDangerPlots->IsKnownAttacker(pAttacker);
}

bool CvPlayer::AddKnownAttacker(const CvUnit* pAttacker)
{
	if (m_pDangerPlots->IsDirty())
		m_pDangerPlots->UpdateDanger();

	return m_pDangerPlots->AddKnownAttacker(pAttacker);
}

//	--------------------------------------------------------------------------------
/// Find closest city to a plot (within specified search radius)
CvCity* CvPlayer::GetClosestCity(const CvPlot* pPlot, int iSearchRadius, bool bSameLandmass)
{
	if (!pPlot)
		return NULL;

	CvCity* pClosestCity = NULL;
	int iBestDistance = INT_MAX;

	int iLoop;
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		//need to check area
		if (bSameLandmass && !pLoopCity->HasAccessToLandmass(pPlot->getLandmass()))
			continue;

		int iDistance = plotDistance(pPlot->getX(), pPlot->getY(), pLoopCity->getX(), pLoopCity->getY());
		if(iDistance < iBestDistance && iDistance <= iSearchRadius)
		{
			pClosestCity = pLoopCity;
			iBestDistance = iDistance;
		}
	}

	return pClosestCity;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumRealCities() const
{
	int iNum = 0;

	const CvCity* pLoopCity;
	int iLoop;
	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (CityStrategyAIHelpers::IsTestCityStrategy_IsPuppetAndAnnexable(pLoopCity))
			continue;

		if (pLoopCity->IsOccupied() && !pLoopCity->IsNoOccupiedUnhappiness())
			continue;

		iNum++;
	}

	return iNum;
}

// How many Puppet Cities does this player own
int CvPlayer::GetNumPuppetCities() const
{
	int iNum = 0;

	const CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity->IsPuppet())
		{
			iNum++;
		}
	}

	return iNum;
}

//	--------------------------------------------------------------------------------
// How many other Capital Cities does this player own
int CvPlayer::GetNumCapitalCities() const
{
	int iNum = 0;
	int iLoop;

	for (const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (pLoopCity->IsOriginalMajorCapital() && !pLoopCity->IsOriginalCapitalForPlayer(m_eID))
		{
			iNum++;
		}
	}

	return iNum;
}

int CvPlayer::GetNumMinorsControlled() const
{
	int iNum = 0;
	int iLoop;

	for (const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (pLoopCity->IsOriginalMinorCapital() && !pLoopCity->IsOriginalCapitalForPlayer(m_eID))
		{
			iNum++;
		}
	}

	return iNum;
}

#if defined(MOD_BALANCE_CORE_MILITARY)
int CvPlayer::GetFractionOriginalCapitalsUnderControl() const
{
	return m_iFractionOriginalCapitalsUnderControl;
}

void CvPlayer::UpdateMilitaryStats()
{
	m_iFractionOriginalCapitalsUnderControl = 0;
	m_iAvgUnitExp100 = 0;

	int iLoop;
	int iOCCount = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		//don't count our own capital!
		if(pLoopCity->IsOriginalMajorCapital() && !pLoopCity->isCapital())
			iOCCount++;

	if(iOCCount > 0)
	{
		int iCivCount = 0;
		for (int iLoopPlayer = 0; iLoopPlayer < MAX_PLAYERS; iLoopPlayer++)
		{
			CvPlayer &kPlayer = GET_PLAYER((PlayerTypes)iLoopPlayer);
			if (kPlayer.isEverAlive() && kPlayer.isMajorCiv() && !kPlayer.isObserver())
				iCivCount++;
		}

		m_iFractionOriginalCapitalsUnderControl = iOCCount * 100 / max(1, (iCivCount-1));
	}

	int iExpCount = 0, iExpSum = 0;
	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if (pLoopUnit->IsCombatUnit() && pLoopUnit->AI_getUnitAIType() != UNITAI_EXPLORE)
		{
			iExpCount++;
			iExpSum += pLoopUnit->getExperienceTimes100();
		}
	}

	m_iAvgUnitExp100 = iExpSum / max(1,iExpCount);
}

void CvPlayer::UpdateAreaEffectUnit(CvUnit* pUnit)
{
	if (!pUnit || pUnit->isDelayedDeath())
		return;

	CvPlot* pPlot = pUnit->plot();

	if (!pPlot)
		return;

	if (pUnit->IsCombatSupportUnit())
	{
		bool bFound = false;
		for ( size_t i=0; i<m_unitsAreaEffectPositive.size(); i++ )
		{
			if ( m_unitsAreaEffectPositive[i].first == pUnit->GetID() )
			{
				m_unitsAreaEffectPositive[i].second = pPlot->GetPlotIndex();
				bFound = true;
				break;
			}
		}

		if (!bFound)
			m_unitsAreaEffectPositive.push_back(std::make_pair(pUnit->GetID(), pPlot->GetPlotIndex()));
	}

	if (pUnit->getNearbyEnemyCombatMod() < 0)
	{
		bool bFound = false;
		for ( size_t i=0; i<m_unitsAreaEffectNegative.size(); i++ )
		{
			if ( m_unitsAreaEffectNegative[i].first == pUnit->GetID() )
			{
				m_unitsAreaEffectNegative[i].second = pPlot->GetPlotIndex();
				bFound = true;
				break;
			}
		}

		if (!bFound)
			m_unitsAreaEffectNegative.push_back(std::make_pair(pUnit->GetID(), pPlot->GetPlotIndex()));
	}

	//do not include medics here, it kills performance
	//medics are range 1, they can easily be found by iterating the 6 neighbor plots
	if (pUnit->isNearbyPromotion())
	{
		bool bFound = false;
		for (size_t i = 0; i<m_unitsAreaEffectPromotion.size(); i++)
		{
			if (m_unitsAreaEffectPromotion[i].first == pUnit->GetID())
			{
				m_unitsAreaEffectPromotion[i].second = pPlot->GetPlotIndex();
				bFound = true;
				break;
			}
		}

		if (!bFound)
			m_unitsAreaEffectPromotion.push_back(std::make_pair(pUnit->GetID(), pPlot->GetPlotIndex()));
	}

	// Must be able to intercept
	if (pUnit->canIntercept())
	{
		bool bFound = false;
		for (size_t i = 0; i < m_unitsWhichCanIntercept.size(); i++)
		{
			if (m_unitsWhichCanIntercept[i].first == pUnit->GetID())
			{
				m_unitsWhichCanIntercept[i].second = pPlot->GetPlotIndex();
				bFound = true;
				break;
			}
		}

		if (!bFound)
			m_unitsWhichCanIntercept.push_back(std::make_pair(pUnit->GetID(), pPlot->GetPlotIndex()));
	}

	//might need to update the UI
	UpdateCityStrength();
}

void CvPlayer::UpdateAreaEffectUnits()
{
	//great generals/admirals
	m_unitsAreaEffectPositive.clear();
	//maori warrior et al
	m_unitsAreaEffectNegative.clear();
	//interceptors
	m_unitsWhichCanIntercept.clear();
	//special promotions
	m_unitsAreaEffectPromotion.clear();

	// Loop through our units
	int iLoop;
	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		CvPlot* pPlot = pLoopUnit->plot();

		if (!pPlot)
		{
			continue;
		}

		if (pLoopUnit->IsCombatSupportUnit())
			m_unitsAreaEffectPositive.push_back(std::make_pair(pLoopUnit->GetID(), pPlot->GetPlotIndex()));

		if (pLoopUnit->getNearbyEnemyCombatMod() < 0)
			m_unitsAreaEffectNegative.push_back(std::make_pair(pLoopUnit->GetID(), pPlot->GetPlotIndex()));

		//do not include medics here, it kills performance
		//medics are range 1, they can easily be found by iterating the 6 neighbor plots
		if (pLoopUnit->isNearbyPromotion())
			m_unitsAreaEffectPromotion.push_back(std::make_pair(pLoopUnit->GetID(), pPlot->GetPlotIndex()));

		if (pLoopUnit->canIntercept())
			m_unitsWhichCanIntercept.push_back(std::make_pair(pLoopUnit->GetID(), pPlot->GetPlotIndex()));
	}

	//might need to update the UI
	UpdateCityStrength();
}

void CvPlayer::UpdateAreaEffectPlots()
{
	//moai et al
	m_plotsAreaEffectPositiveFromTraits.clear();

	// Loop through our plots
	ImprovementTypes iTraitImprovement = GetPlayerTraits()->GetCombatBonusImprovementType();
	if (iTraitImprovement!=NO_IMPROVEMENT)
	{
		for(int iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)
		{
			CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);
			if (pPlot && pPlot->getOwner()==GetID() && pPlot->getImprovementType()==iTraitImprovement )
				m_plotsAreaEffectPositiveFromTraits.push_back( iPlotLoop );
		}
	}

	//Looks for Natural Wonders
	if(GetPlayerTraits()->IsCombatBoostNearNaturalWonder())
	{
		for(int iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)
		{
			CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);
			if (pPlot && pPlot->IsNaturalWonder())
				m_plotsAreaEffectPositiveFromTraits.push_back( iPlotLoop );
		}
	}
}
const std::vector<std::pair<int, int>>& CvPlayer::GetAreaEffectPromotionUnits() const
{
	return m_unitsAreaEffectPromotion;
}
const std::vector<std::pair<int,int>>& CvPlayer::GetAreaEffectPositiveUnits() const
{
	return m_unitsAreaEffectPositive;
}

const std::vector<std::pair<int,int>>& CvPlayer::GetAreaEffectNegativeUnits() const
{
	return m_unitsAreaEffectNegative;
}

const std::vector<std::pair<int, int>>& CvPlayer::GetPossibleInterceptors() const
{
	return m_unitsWhichCanIntercept;
}

const std::vector<int>& CvPlayer::GetAreaEffectPositiveFromTraitsPlots() const
{
	return m_plotsAreaEffectPositiveFromTraits;
}

int CvPlayer::GetAreaEffectModifier(AreaEffectType eType, DomainTypes eDomain, const CvPlot* pTestPlot, const CvUnit* pIgnoreThisUnit) const
{
	int iResult = 0;
	if (pTestPlot == NULL)
		return 0;

	const std::vector<std::pair<int, int>>& possibleUnits = GetAreaEffectPositiveUnits();
	for (std::vector<std::pair<int, int>>::const_iterator it = possibleUnits.begin(); it != possibleUnits.end(); ++it)
	{
		//performance: very rough distance check first without looking up the unit pointer ...
		//do not reuse the plot below
		{
			CvPlot* pUnitPlot = GC.getMap().plotByIndexUnchecked(it->second);
			if (plotDistance(*pUnitPlot, *pTestPlot) > 8)
				continue;
		}

		CvUnit* pUnit = getUnit(it->first);
		//catch all sorts of weird problems (this may be called while a general is being killed!)
		if (pUnit == NULL || pUnit->isDelayedDeath() || pUnit->plot()==NULL || pUnit == pIgnoreThisUnit)
			continue;

		//domain check
		if (eDomain != NO_DOMAIN && pUnit->getDomainType() != eDomain)
			continue;

		int iEffectRange = pUnit->GetAuraRangeChange() + /*2*/ GD_INT_GET(GREAT_GENERAL_RANGE);

		//actual distance check
		int iDistance = plotDistance(*pUnit->plot(),*pTestPlot);
		if (iDistance > iEffectRange)
			continue;

		switch (eType)
		{
			case AE_GREAT_GENERAL:
			{
				if (pUnit->IsGreatGeneral() || pUnit->IsGreatAdmiral())
					iResult = max(iResult, GetGreatGeneralCombatBonus() + GetPlayerTraits()->GetGreatGeneralExtraBonus() + pUnit->GetAuraEffectChange());
				break;
			}
			case AE_SAPPER:
			{
				if (pUnit->IsSapper() && IsAtWarWith(pTestPlot->getOwner()))
				{
					if (iDistance < iEffectRange)
					{
						iResult = max(iResult, /*50 in CP, 40 in VP*/ GD_INT_GET(SAPPED_CITY_ATTACK_MODIFIER));
					}
					else if (iDistance == iEffectRange)
					{
						iResult = max(iResult, /*25 in CP, 20 in VP*/ GD_INT_GET(SAPPED_CITY_ATTACK_MODIFIER)/2);
					}
				}
				break;
			}
			case AE_SIEGETOWER:
			{
				if (pUnit->IsCityAttackSupport())
					return 1; //just used as a boolean flag
				break;
			}
		}
	}

	return iResult;
}

void CvPlayer::UpdateCityStrength()
{
	//support unit might have moved close to the city or away from it, so just update the value for all cities without further logic
	int iCityLoop;
	for (CvCity* pLoopCity = firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = nextCity(&iCityLoop))
		pLoopCity->updateStrengthValue();
}


void CvPlayer::UpdateCurrentAndFutureWars()
{
	//cache the wars we have going - ignore barbarians
	m_playersWeAreAtWarWith.clear();
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		if(GET_PLAYER(eLoopPlayer).isAlive() && GET_TEAM(getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
			m_playersWeAreAtWarWith.push_back( eLoopPlayer );
	}

	//see if we're not at war yet but war is coming
	m_playersAtWarWithInFuture.clear();
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		if(GET_PLAYER(eLoopPlayer).isAlive() && !GET_PLAYER(eLoopPlayer).isBarbarian() && !IsAtWarWith(eLoopPlayer) )
		{
			bool bWarMayBeComing = false;

			//do we want to start a war?
			if(GetDiplomacyAI()->IsArmyInPlaceForAttack(eLoopPlayer) || HasAnyOffensiveOperationsAgainstPlayer(eLoopPlayer))
				bWarMayBeComing = true;

			//do they want to start a war?
			AggressivePostureTypes eMilitaryPosture = GetDiplomacyAI()->GetMilitaryAggressivePosture(eLoopPlayer);
			ThreatTypes eWarmongerThreat = GetDiplomacyAI()->GetWarmongerThreat(eLoopPlayer);
			if (eMilitaryPosture == AGGRESSIVE_POSTURE_INCREDIBLE || eWarmongerThreat == THREAT_SEVERE || eWarmongerThreat == THREAT_CRITICAL)
				bWarMayBeComing = true;

			//how is the general diplomatic climate?
			CivApproachTypes eApproach = GetDiplomacyAI()->GetCivApproach(eLoopPlayer);
			CivApproachTypes eTheirApproach = GetDiplomacyAI()->GetVisibleApproachTowardsUs(eLoopPlayer);
			CivOpinionTypes eOpinion = GetDiplomacyAI()->GetCivOpinion(eLoopPlayer);
			if (eApproach <= CIV_APPROACH_AFRAID || eTheirApproach <= CIV_APPROACH_GUARDED || eOpinion == CIV_OPINION_ENEMY)
				bWarMayBeComing = true;

			if (bWarMayBeComing)
				m_playersAtWarWithInFuture.push_back(eLoopPlayer);
		}
	}

}

bool CvPlayer::HasCityInDanger(bool bAboutToFall, int iMinDanger) const
{
	int iLoop;
	for (const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (bAboutToFall && pLoopCity->isInDangerOfFalling())
			return true;

		if (!bAboutToFall && GET_PLAYER(m_eID).GetPlotDanger(pLoopCity) >= iMinDanger)
			return true;
	}

	return false;
}

bool CvPlayer::IsPlotUnsafe(CvPlot * pPlot)
{
	CvTacticalDominanceZone* pZone = GetTacticalAI()->GetTacticalAnalysisMap()->GetZoneByPlot(pPlot);
	if (!pZone)
		return false;
	
	if (pZone->GetTerritoryType() == TACTICAL_TERRITORY_ENEMY || pZone->GetTerritoryType() == TACTICAL_TERRITORY_FRIENDLY)
		return pZone->GetOverallDominanceFlag() != TACTICAL_DOMINANCE_FRIENDLY;
	else //neutral zone, even dominance is ok (few units)
		return pZone->GetOverallDominanceFlag() == TACTICAL_DOMINANCE_ENEMY;
}
#endif

//	--------------------------------------------------------------------------------
// How many Cities does this player have for policy/tech cost purposes?
int CvPlayer::GetNumEffectiveCities(bool bIncludePuppets)
{
	int iNumCities = getNumCities();

	if (!bIncludePuppets)
		iNumCities -= GetNumPuppetCities();

	// Don't count cities where the player hasn't decided yet what to do with them or ones that are currently being razed
	int iLoop;
	for (const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (pLoopCity->IsIgnoreCityForHappiness() || (!MOD_BALANCE_CORE && pLoopCity->IsRazing()))
		{
			iNumCities--;
		}
	}

	//always at least one ...
	return max(1, iNumCities);
}

// How many Coastal Cities does this player own
int CvPlayer::GetNumEffectiveCoastalCities() const
{
	int iNum = 0;

	int iLoop;
	for (const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (pLoopCity->IsIgnoreCityForHappiness() || pLoopCity->IsRazing())
			continue;

		if (CityStrategyAIHelpers::IsTestCityStrategy_IsPuppetAndAnnexable(pLoopCity))
			continue;

		if (pLoopCity->IsOccupied() && !pLoopCity->IsNoOccupiedUnhappiness())
			continue;

		if (pLoopCity->isCoastal())
			iNum++;
	}

	return iNum++;
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvPlayer::GetExtraSupplyPerPopulation() const
{
	return m_iExtraSupplyPerPopulation;
}

void CvPlayer::ChangeExtraSupplyPerPopulation(int iChange)
{
	m_iExtraSupplyPerPopulation += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getCitySupplyFlatGlobal() const
{
	return m_iCitySupplyFlatGlobal;
}
void CvPlayer::changeCitySupplyFlatGlobal(int iChange)
{
	m_iCitySupplyFlatGlobal += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetUnitSupplyFromExpendedGreatPeople() const
{
	return m_iUnitSupplyFromExpendedGP;
}
void CvPlayer::ChangeUnitSupplyFromExpendedGreatPeople(int iChange)
{
	m_iUnitSupplyFromExpendedGP += iChange;
}
#endif
//	--------------------------------------------------------------------------------
/// How many Natural Wonders has this player found in its area?
int CvPlayer::GetNumNaturalWondersDiscoveredInArea() const
{
	return m_iNumNaturalWondersDiscoveredInArea;
}

//	--------------------------------------------------------------------------------
/// Sets how many Natural Wonders has this player found in its area
void CvPlayer::SetNumNaturalWondersDiscoveredInArea(int iValue)
{
	m_iNumNaturalWondersDiscoveredInArea = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes many Natural Wonders has this player found in its area
void CvPlayer::ChangeNumNaturalWondersDiscoveredInArea(int iChange)
{
	SetNumNaturalWondersDiscoveredInArea(GetNumNaturalWondersDiscoveredInArea() + iChange);
}

//	--------------------------------------------------------------------------------
/// Calculates how many Natural Wonders are in plots this player owns
int CvPlayer::GetNumNaturalWondersInOwnedPlots()
{
	int iValue = 0;
	// go through all the plots the player has under their control
	for (PlotIndexContainer::const_iterator it = m_aiPlots.begin(); it != m_aiPlots.end(); ++it)
	{
		CvPlot* pPlot = GC.getMap().plotByIndex(*it);

		if (pPlot && pPlot->IsNaturalWonder())
			iValue++;
	}
	return iValue;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::HaveGoodSettlePlot(int iAreaID)
{
	updatePlotFoundValues();

	for (int iI = 0; iI < GC.getMap().numPlots(); iI++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iI);
		int iCurrentValue = m_viPlotFoundValues[iI];
		if (iCurrentValue > 0)
		{
			if (iAreaID == -1 || pPlot->getArea() == iAreaID)
				return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
/// How long ago did this guy last settle a city?
int CvPlayer::GetTurnsSinceSettledLastCity() const
{
	return m_iTurnsSinceSettledLastCity;
}

//	--------------------------------------------------------------------------------
/// How long ago did this guy last settle a city?
void CvPlayer::SetTurnsSinceSettledLastCity(int iValue)
{
	if(m_iTurnsSinceSettledLastCity != iValue)
		m_iTurnsSinceSettledLastCity = iValue;
}

//	--------------------------------------------------------------------------------
/// How long ago did this guy last settle a city?
void CvPlayer::ChangeTurnsSinceSettledLastCity(int iChange)
{
	if(iChange != 0)
		SetTurnsSinceSettledLastCity(GetTurnsSinceSettledLastCity() + iChange);
}

//	--------------------------------------------------------------------------------
/// Find the best spot in the entire world for this unit to settle
ostream& operator<<(ostream& os, const CvPlot* pPlot)
{
	if (pPlot)
	    os << pPlot->getX() << "," << pPlot->getY() << "," << pPlot->getTerrainType() << "," << pPlot->getPlotType() << "," \
			<< pPlot->getFeatureType() << "," << pPlot->getOwner() << "," << pPlot->getArea();
    return os;
}

CvPlot* CvPlayer::GetBestSettlePlot(const CvUnit* pUnit, CvAIOperation* pOpToIgnore, bool bForceLogging) const
{
	std::vector<SPlotWithScore> vSettlePlots;

	//--------
	bool bLogging = (GC.getLogging() && GC.getAILogging()) || bForceLogging; 
	std::stringstream dump;
	int iDanger=0, iFertility=0;

#if defined(MOD_BALANCE_CORE_MILITARY_LOGGING)
	bLogging &= MOD_BALANCE_CORE_MILITARY_LOGGING;
#endif
	//--------

	PlayerTypes eOwner = pUnit ? pUnit->getOwner() : GetID();
	TeamTypes eTeam = pUnit ? pUnit->getTeam() : getTeam();

	//in case we're not getting the cached data, we need to prepare some things
	vector<int> ignorePlots(GC.getMap().numPlots(), 0); //these are the plots whose yield we ignore
	if (bLogging)
	{
		GC.getGame().GetSettlerSiteEvaluator()->ComputeFlavorMultipliers(this);
		for (int iI = 0; iI < GC.getMap().numPlots(); iI++)
		{
			CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iI);
			if (pPlot->isOwned() && pPlot->getOwner() != m_eID)
				ignorePlots[iI] = 1;
			else if (pPlot->IsAdjacentOwnedByTeamOtherThan(getTeam()) && GC.getGame().GetClosestCityDistanceInPlots(pPlot) < /*3*/ GD_INT_GET(MIN_CITY_RANGE))
				ignorePlots[iI] = 1;
		}
	}

	//prefer settling close in the beginning
	int iTimeOffset = (12 * GC.getGame().getElapsedGameTurns()) / max(512, GC.getGame().getMaxTurns());

	//basic search area around existing cities. 
	int iMaxSettleDistance = /*8*/ GD_INT_GET(SETTLER_EVALUATION_DISTANCE) + iTimeOffset; //plot value at max distance or greater is scaled to zero
	if(IsCramped())
		iMaxSettleDistance += iTimeOffset;
	int iSettleDropoffThreshold = min(iMaxSettleDistance,/*4*/ GD_INT_GET(SETTLER_DISTANCE_DROPOFF_MODIFIER));

	//if we want to go to other continents, we need a very large search radius
	EconomicAIStrategyTypes eStrategyExpandToOtherContinents = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_EXPAND_TO_OTHER_CONTINENTS");
	bool bWantOffshore = GetEconomicAI()->IsUsingStrategy(eStrategyExpandToOtherContinents);
	bool bCanEmbark = CanEmbark();

	CvMap& kMap = GC.getMap();
	int iNumPlots = kMap.numPlots();
	for(int iPlotLoop = 0; iPlotLoop < iNumPlots; iPlotLoop++)
	{
		CvPlot* pPlot = kMap.plotByIndexUnchecked(iPlotLoop);

		if(!pPlot)
		{
			continue;
		}

		if (bLogging)
		{
			iDanger = pUnit ? pUnit->GetDanger(pPlot) : 0;
			iFertility = GC.getGame().GetSettlerSiteEvaluator()->PlotFertilityValue(pPlot,true);
		}

		if(!pPlot->isRevealed(eTeam))
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",0," << iDanger << "," << iFertility << ",-1" << ",0" << std::endl;
			//--------------
			continue;
		}

		if ((pPlot->isOwned() && pPlot->getOwner() != eOwner) || (pPlot->getRevealedImprovementType(eTeam) == (ImprovementTypes)GD_INT_GET(BARBARIAN_CAMP_IMPROVEMENT)))
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",1," << iDanger << "," << iFertility << ",-1" << ",-2" << std::endl;
			//--------------
			continue;
		}

		CvTacticalDominanceZone* pZone = GetTacticalAI()->GetTacticalAnalysisMap()->GetZoneByPlot(pPlot);
		if (pZone && pZone->GetOverallDominanceFlag() == TACTICAL_DOMINANCE_ENEMY)
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",1," << iDanger << "," << iFertility << ",-1" << ",-2" << std::endl;
			//--------------
			continue;
		}

		for (std::vector<PlayerTypes>::const_iterator it = m_playersWeAreAtWarWith.begin(); it != m_playersWeAreAtWarWith.end(); ++it)
		{
			if(pPlot->IsCloseToCity(*it))
			{
				//--------------
				if (bLogging) 
				dump << pPlot << ",1," << iDanger << "," << iFertility << ",-1" << ",-2" << std::endl;
				//--------------
				continue;
			}
		}

		if(pUnit && (!pUnit->canFoundCity(pPlot) || !pUnit->canMoveInto(*pPlot)))
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",1," << iDanger << "," << iFertility << ",-1" << ",-1" << std::endl;
			//--------------
			continue;
		}

		if (IsPlotTargetedForCity(pPlot,pOpToIgnore))
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",1," << iDanger << "," << iFertility << ",-1" << ",-3" << std::endl;
			//--------------
			continue;
		}

		if(pUnit && pPlot->getLandmass() != pUnit->plot()->getLandmass() && !bCanEmbark)
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",1," << iDanger << "," << iFertility << ",-1" << ",-4" << std::endl;
			//--------------
			continue;
		}

		//important: take into account distance from existing cities!
		//no pathfinder yet, that is done later ...
		int iRelevantDistance = GetCityDistanceInPlots(pPlot);
		int iScale = MapToPercent( iRelevantDistance, iMaxSettleDistance, iSettleDropoffThreshold );

		//check for new continent
		const CvLandmass* pLandmass = GC.getMap().getLandmass(pPlot->getLandmass());
		const CvCity* pCapital = getCapitalCity();

		//if we want offshore expansion, manipulate the distance scaler
		bool bOffshore = (pLandmass && pCapital && pLandmass->GetID() != pCapital->plot()->getLandmass());
		if (bWantOffshore && bOffshore)
			iScale = max(42, iScale);

		//on a new continent we want to settle along the coast
		bool bNewContinent = (pLandmass && pLandmass->getCitiesPerPlayer(GetID()) == 0);
		if (bNewContinent && getNumCities()>0)
		{
			//there may already be other players here, also minors ... 
			//but this is complex to check, so simply force a coastal plot to avoid isolated cities
			if (!pPlot->isCoastalLand())
				iScale = 0;
		}

		if (iScale==0)
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",1," << iDanger << "," << iFertility << ",0" << ",-5" << std::endl;
			//--------------
			continue;
		}

		//finally no more obstacles
		int iValue = 0;
		if (bLogging) 
		{
			CvString strDebug;
			iValue = GC.getGame().GetSettlerSiteEvaluator()->PlotFoundValue(pPlot, this, ignorePlots, bNewContinent, &strDebug);
			//--------------
			dump << pPlot << ",1," << iDanger << "," << iFertility << "," << iScale << "," << iValue << "," << strDebug.c_str() << std::endl;
			//--------------
		}
		else
		{
			//with caching - is set to -1 if not possible / not good enough
			iValue = pPlot->getFoundValue(eOwner);
		}

		if (iValue<=0)
			continue;

		//factor in the distance
		iValue = (iValue*iScale)/100;

		vSettlePlots.push_back( SPlotWithScore(pPlot,iValue) );
	}

#if defined(MOD_BALANCE_CORE_MILITARY_LOGGING)
	if (bLogging) 
	{
		std::stringstream ss;
		ss << "CitySites_" << getCivilizationAdjective() << "_" << std::setfill('0') << std::setw(3) << GC.getGame().getGameTurn() << ".txt";
		FILogFile* pLog=LOGFILEMGR.GetLog( ss.str().c_str(), FILogFile::kDontTimeStamp );
		pLog->Msg( "#x,y,terrain,plotype,feature,owner,area,revealed,danger,fertility,distancescale,value,comments\n" );
		pLog->Msg( dump.str().c_str() );
		pLog->Close();
	}
#endif

	if (vSettlePlots.empty())
		return 0;

	//order by increasing score
	std::stable_sort( vSettlePlots.begin(), vSettlePlots.end() );
	std::reverse( vSettlePlots.begin(), vSettlePlots.end() );

	CvPlot* pTestPlot = vSettlePlots[0].pPlot;
	//look at the best two and see if maybe the second one is much closer ...
	if (pUnit && vSettlePlots.size() > 1)
	{
		//see where our settler can go
		//worst case in jungle one turn equals one plot ...
		SPathFinderUserData data(pUnit,0,iMaxSettleDistance);
		ReachablePlots reachablePlots = GC.GetPathFinder().GetPlotsInReach(pUnit->plot(), data);

		CvPlot* pTestPlotA = vSettlePlots[0].pPlot;
		CvPlot* pTestPlotB = vSettlePlots[1].pPlot;
		int iScoreA = vSettlePlots[0].score;
		int iScoreB = vSettlePlots[1].score;
		ReachablePlots::iterator itA = reachablePlots.find(pTestPlotA->GetPlotIndex());
		ReachablePlots::iterator itB = reachablePlots.find(pTestPlotB->GetPlotIndex());

		if (itA != reachablePlots.end() && itB != reachablePlots.end())
		{
			//if B is at least 80% as good but less than 80% of the distance
			if (iScoreB * 10 > iScoreA * 8 && itB->iNormalizedDistanceRaw * 10 < itA->iNormalizedDistanceRaw * 8)
				pTestPlot = pTestPlotB;
		}
	}

	return pTestPlot;
}

PlayerTypes CvPlayer::GetPlayerWhoStoleMyFavoriteCitySite()
{
	//only check this if we want to found new cities
	static EconomicAIStrategyTypes eEnoughExpansion = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_ENOUGH_EXPANSION");
	if (GetEconomicAI()->IsUsingStrategy(eEnoughExpansion))
	{
		m_iPreviousBestSettlePlot = -1;
		return NO_PLAYER;
	}

	//maybe our old favorite is no longer available?
	CvPlot* pPreviousFavorite = GC.getMap().plotByIndex(m_iPreviousBestSettlePlot);

	//did somebody else settle close?
	PlayerTypes eStressor = NO_PLAYER;
	if (pPreviousFavorite)
	{
		//search from the inside out
		//don't use GetClosestCityByPlots() because that might trigger lots of updates
		for (int i = 0; i < RING5_PLOTS; i++)
		{
			CvPlot* pTestPlot = iterateRingPlots(pPreviousFavorite,i);
			if (pTestPlot && pTestPlot->isCity() && pTestPlot->getOwner() != GetID())
			{
				eStressor = pTestPlot->getOwner();
				break;
			}
		}

		//assume our favorite is still good
		if (eStressor == NO_PLAYER)
			return NO_PLAYER;
	}

	//looking up the best settle plot is expensive so do this only if we really need it
	CvPlot* pCurrentFavorite = GetBestSettlePlot(NULL);

	//no problem, spot is still the best
	if (pCurrentFavorite == pPreviousFavorite)
		return NO_PLAYER;

	//update
	m_iPreviousBestSettlePlot = pCurrentFavorite ? pCurrentFavorite->GetPlotIndex() : -1;

	//did somebody else settle close?
	if (pPreviousFavorite && eStressor != NO_PLAYER)
	{
		//get triggered if the settle spot was close to one of our cities
		int iTriggerDistance = GetDiplomacyAI()->GetBoldness() + /*5*/ GD_INT_GET(AI_DIPLO_PLOT_RANGE_FROM_CITY_HOME_FRONT);
		if (GET_PLAYER(eStressor).getTeam() != getTeam() && GetCityDistancePathLength(pPreviousFavorite) < iTriggerDistance)
			return eStressor;
	}

	return NO_PLAYER;
}

// range is -50 to +50
int CvPlayer::GetSettlePlotQualityMeasure(CvPlot * pPlot)
{
	int iReference = (67 * m_iFoundValueOfCapital) / 100;

	if (pPlot && iReference > 0)
	{
		int iRawPercent = (100 * getPlotFoundValue(pPlot->getX(), pPlot->getY())) / iReference;
		return range(iRawPercent, 50, 150) - 100;
	}

	return 0;
}

//	--------------------------------------------------------------------------------
/// How many Wonders has this Player constructed?
int CvPlayer::GetNumWonders() const
{
	return m_iNumWonders;
}

//	--------------------------------------------------------------------------------
/// Changes how many Wonders this Player has constructed
void CvPlayer::ChangeNumWonders(int iValue)
{
	if(iValue != 0)
	{
		m_iNumWonders += iValue;
	}
}

//	--------------------------------------------------------------------------------
/// How many Policies has this Player constructed?
int CvPlayer::GetNumPolicies() const
{
	return m_iNumPolicies;
}

//	--------------------------------------------------------------------------------
/// Changes how many Policies this Player has constructed
void CvPlayer::ChangeNumPolicies(int iValue)
{
	if(iValue != 0)
	{
		m_iNumPolicies += iValue;
	}
}

//	--------------------------------------------------------------------------------
/// How many GreatPeople has this Player constructed?
int CvPlayer::GetNumGreatPeople() const
{
	return m_iNumGreatPeople;
}

//	--------------------------------------------------------------------------------
/// Changes how many GreatPeople this Player has constructed
void CvPlayer::ChangeNumGreatPeople(int iValue)
{
	if(iValue != 0)
	{
		m_iNumGreatPeople += iValue;
	}
}

#if defined(MOD_BALANCE_CORE)
std::vector<int> CvPlayer::GetTotalBuildingCount(bool bIncludePuppets) const
{
	std::vector<int> vTotalBuildingCount(GC.getNumBuildingInfos(), 0);
	int iLoop;
	for (const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (bIncludePuppets || CityStrategyAIHelpers::IsTestCityStrategy_IsPuppetAndAnnexable(pLoopCity))
		{
			const std::vector<BuildingTypes>& vBuildings = pLoopCity->GetCityBuildings()->GetAllBuildingsHere();
			for (size_t i = 0; i < vBuildings.size(); i++)
				vTotalBuildingCount[vBuildings[i]]++;
		}
	}

	return vTotalBuildingCount;
}

void CvPlayer::SetBestWonderCities()
{
	struct sct
	{
		int score;
		CvCity* city;
		bool isForWorldWonder;

		sct(int s, CvCity* c, bool w) : score(s), city(c), isForWorldWonder(w) {}
		bool operator<(const sct& rhs) const { return score < rhs.score; }
	};

	map<BuildingClassTypes,vector<sct>> allScores;
	std::vector<int> allBuildingCount = GetTotalBuildingCount();

	for (int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
		CvBuildingEntry* pkeBuildingInfo = GC.getBuildingInfo(eBuilding);

		//Not wonder? Skip
		if (!pkeBuildingInfo)
			continue;

		BuildingClassTypes eClass = (BuildingClassTypes)pkeBuildingInfo->GetBuildingClassType();
		const CvBuildingClassInfo& kBuildingClassInfo = pkeBuildingInfo->GetBuildingClassInfo();
		if (!::isWorldWonderClass(kBuildingClassInfo) && !::isNationalWonderClass(kBuildingClassInfo))
			continue;

		//is this a unique wonder that we can't build? Ignore it.
		bool bCivUnique = kBuildingClassInfo.getDefaultBuildingIndex() != eBuilding;
		if (bCivUnique && !getCivilizationInfo().isCivilizationBuildingOverridden(eClass))
			continue;

		int iLoopCity;
		for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity))
		{
			// No wonders in non-venetian puppets
			if (CityStrategyAIHelpers::IsTestCityStrategy_IsPuppetAndAnnexable(pLoopCity))
				continue;

			if (!pLoopCity->canConstruct(eBuilding, allBuildingCount))
				continue;

			//get a score
			int iValue = pLoopCity->GetCityStrategyAI()->GetBuildingProductionAI()->CheckBuildingBuildSanity(eBuilding, 1000, true, false, true);
			if (iValue < 0)
				continue;
			
			// We've already started? Massive bonus!
			bool bAlreadyStarted = pLoopCity->GetCityBuildings()->GetBuildingProduction(eBuilding) > 0;
			if (pLoopCity->getProductionBuilding() == eBuilding || bAlreadyStarted)
				iValue *= 10;

			//duration is also important
			iValue -= 50 * pLoopCity->getProductionTurnsLeft(eBuilding, 0);

			// we don't necessarily want to one city to be best for all wonders
			// we could set the bestForWonder flag for all cities with score above a certain threshold, turning it into a goodForWonder flag
			//	(but there seems to be an assumption that only one city can have the flag for a given wonder, eg in FindBestWonderCity()
			// alternatively we check if the city already is best for something and downgrade it for other wonders
			//	but this needs some bookkeeping if we don't want to depend on the order of wonders in the database

			allScores[eClass].push_back(sct(iValue,pLoopCity,::isWorldWonderClass(kBuildingClassInfo)));
		}

		//pairs are sorted by their first element by default (ascending)
		vector<pair<int, BuildingClassTypes>> bestScorePerClass;
		for (map<BuildingClassTypes,vector<sct>>::iterator it = allScores.begin(); it != allScores.end(); ++it)
		{
			ASSERT(!it->second.empty());
			sort(it->second.begin(), it->second.end());
			bestScorePerClass.push_back(make_pair(it->second.back().score, it->first));
		}
		sort(bestScorePerClass.begin(), bestScorePerClass.end());

		//now we starting with the best overall score, find the best city for the type of wonder
		for (vector<pair<int, BuildingClassTypes>>::reverse_iterator it = bestScorePerClass.rbegin(); it != bestScorePerClass.rend(); ++it)
		{
			bool bIsWorldWonderClass = allScores[it->second].back().isForWorldWonder;
			CvCity* pBestCity = allScores[it->second].back().city;

			// Remember the result after all this effort
			pBestCity->SetBestForWonder(it->second, true);

			// Reset the flag everywhere else
			for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity))
				if (pBestCity != pLoopCity)
					pLoopCity->SetBestForWonder(eClass, false);

			if ((GC.getLogging() && GC.getAILogging()))
			{
				CvString playerName = getCivilizationShortDescription();
				CvString strBaseString;
				CvString strOutBuf;
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				strBaseString += playerName + ", ";
				strOutBuf.Format("%s is best to construct %s", pBestCity->getName().GetCString(), pkeBuildingInfo->GetDescription());
				strBaseString += strOutBuf;
				GetCitySpecializationAI()->LogMsg(strBaseString);
			}

			//done with this type
			allScores.erase(it->second);

			//reduce the best city's score for other wonders - don't want to lose time in the race with other players
			if (bIsWorldWonderClass)
			{
				for (map<BuildingClassTypes, vector<sct>>::iterator it = allScores.begin(); it != allScores.end(); ++it)
				{
					for (vector<sct>::iterator it2 = it->second.begin(); it2 != it->second.end(); ++it2)
						if (it2->city == pBestCity && it2->isForWorldWonder)
							it2->score -= it2->score / 4; //reduce by 25% for every other world wonder

					//need to sort again ...
					sort(it->second.begin(), it->second.end());
				}
			}
		}
	}
}

//to avoid hardcoding any hammers per pop values, we look at hammers per pop for all other capitals
//however, we don't look at the total hammers, because that would be cheating :)
bool CvPlayer::isCapitalCompetitive()
{
	if (!getCapitalCity())
		return false;

	int iSum = 0;
	int iCount = 0;
	int iOurThreshold = 0;
	for (int iPlayer = 0; iPlayer < MAX_MAJOR_CIVS; iPlayer++)
	{
		CvPlayer& kPlayer = GET_PLAYER( (PlayerTypes)iPlayer );
		if (!kPlayer.isAlive() || !kPlayer.getCapitalCity())
			continue;

		if (iPlayer == GetID())
		{
			iOurThreshold = kPlayer.getCapitalCity()->getYieldRateTimes100(YIELD_PRODUCTION, false) / kPlayer.getCapitalCity()->getPopulation();
		}
		else
		{
			iSum += kPlayer.getCapitalCity()->getYieldRateTimes100(YIELD_PRODUCTION, false) / kPlayer.getCapitalCity()->getPopulation();
			iCount++;
		}
	}

	int iThreshold = iSum / max(1, iCount);
	//venice exception
	if (GetPlayerTraits()->IsNoAnnexing())
		iThreshold -= iThreshold / 3;

	return iOurThreshold >= iThreshold;
}

CvCity* CvPlayer::GetBestProductionCity(BuildingTypes eBuilding, ProjectTypes eProject)
{
	int iBestProduction = 0;
	CvCity* pBestProductionCity = NULL;
	// Look at all of our Cities to see which is the best.
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity))
	{
		if (pLoopCity->IsPuppet())
			continue;

		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
		if (!pkBuildingInfo)
			return NULL;

		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(pkBuildingInfo->GetBuildingClassType());
		if (!pkBuildingClassInfo)
			return NULL;

		int iProduction = 0;

		if (eBuilding != NO_BUILDING)
		{
			//limited buildings need to be controlled against.
			if (pkBuildingClassInfo->getMaxGlobalInstances() == 1 || pkBuildingClassInfo->getMaxPlayerInstances() == 1 || pkBuildingClassInfo->getMaxTeamInstances() == 1)
			{
				if (pLoopCity->GetCityBuildings()->GetBuildingProduction(eBuilding) > 0)
					return pLoopCity;
			}
			else
			{
				iProduction += pLoopCity->GetCityBuildings()->GetBuildingProductionTimes100(eBuilding);
			}
		}
		else if (eProject != NO_PROJECT)
		{
			CvProjectEntry* pkProjectInfo = GC.getProjectInfo(eProject);
			if (!pkProjectInfo)
				return NULL;

			int iProduction = 0;
			//limited projects need to be controlled against.
			if (pkProjectInfo->GetMaxGlobalInstances() == 1 || pkProjectInfo->GetMaxTeamInstances() == 1)
			{
				if (pLoopCity->getProjectProduction(eProject) > 0)
					return pLoopCity;
			}
			else
			{
				iProduction += pLoopCity->getProjectProduction(eProject) * 100;
			}
		}
		
		iProduction += pLoopCity->getYieldRateTimes100(YIELD_PRODUCTION, false, true);
		if (iProduction > iBestProduction)
		{
			iBestProduction = iProduction;
			pBestProductionCity = pLoopCity;
		}
	}
	return pBestProductionCity != NULL ? pBestProductionCity : getCapitalCity();
}

bool CvPlayer::IsCityCompetitive(CvCity* pCity, BuildingTypes eBuilding, ProjectTypes eProject)
{
	int iOurProduction = 0;
	int iSumProduction = 0;
	int iNumCities = 0;
	// Look at all of our Cities to see which is the best.
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity))
	{
		if (pLoopCity->IsPuppet())
			continue;

		if (pCity == pLoopCity)
		{
			if (eBuilding != NO_BUILDING)
			{
				iOurProduction += pLoopCity->GetCityBuildings()->GetBuildingProductionTimes100(eBuilding);
			}
			else if (eProject != NO_PROJECT)
			{
				iOurProduction += pLoopCity->getProjectProduction(eProject) * 100;
			}
			iOurProduction += pLoopCity->getYieldRateTimes100(YIELD_PRODUCTION, false, true);
		}
		else
		{
			if (eBuilding != NO_BUILDING)
			{
				iSumProduction += pLoopCity->GetCityBuildings()->GetBuildingProductionTimes100(eBuilding);
			}
			else if (eProject != NO_PROJECT)
			{
				iSumProduction += pLoopCity->getProjectProduction(eProject) * 100;
			}
			iSumProduction += pLoopCity->getYieldRateTimes100(YIELD_PRODUCTION, false, true);
			iNumCities++;
		}
	}

	int iThreshold = iSumProduction / max(1, iNumCities);
	return iOurProduction >= iThreshold;
}

#endif
//	--------------------------------------------------------------------------------
/// Special ability where city-states gift great people
void CvPlayer::DoAdoptedGreatPersonCityStatePolicy()
{
	// Loop through all minors and if they're allies, seed the GP counter
	for (int iPlayerLoop = MAX_MAJOR_CIVS; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes eMinor = (PlayerTypes) iPlayerLoop;

		if (GET_PLAYER(eMinor).isAlive() && GET_PLAYER(eMinor).GetMinorCivAI()->GetAlly() == GetID())
		{
			DoSeedGreatPeopleSpawnCounter();
			break;
		}
	}
}

//	--------------------------------------------------------------------------------
/// Has this player picked up a Religion yet
bool CvPlayer::IsHasAdoptedStateReligion() const
{
	return m_bHasAdoptedStateReligion;
}

//	--------------------------------------------------------------------------------
/// Sets this player picked up a Religion yet
void CvPlayer::SetHasAdoptedStateReligion(bool bValue)
{
	if(m_bHasAdoptedStateReligion != bValue)
	{
		m_bHasAdoptedStateReligion = bValue;
	}
}

//	--------------------------------------------------------------------------------
/// Number of Cities in the empire with our State Religion
int CvPlayer::GetNumCitiesWithStateReligion()
{
	int iNumCitiesWithStateReligion = 0;

	int iLoopCity;
	CvCity* pLoopCity = NULL;
	// Look at all of our Cities to see if they have our Religion
	for(pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity))
	{
		if(pLoopCity->GetPlayersReligion() == GetID())
		{
			iNumCitiesWithStateReligion++;
		}
	}

	return iNumCitiesWithStateReligion;
}

//	--------------------------------------------------------------------------------
/// Where was this player's Religion adopted
CvCity* CvPlayer::GetHolyCity()
{
	return getCity(m_iHolyCityID);
}

//	--------------------------------------------------------------------------------
/// Sets where this player's Religion adopted
void CvPlayer::SetHolyCity(int iCityID)
{
	// This should only be set once under normal circumstances
	CvAssert(m_iHolyCityID == -1);

	m_iHolyCityID = iCityID;
}

//	--------------------------------------------------------------------------------
PromotionTypes CvPlayer::GetEmbarkationPromotion() const
{
	if(GET_TEAM(getTeam()).canDefensiveEmbark())
	{
		return (PromotionTypes)GD_INT_GET(PROMOTION_DEFENSIVE_EMBARKATION);
	}

	if(m_pTraits)
	{
		if(m_pTraits->IsEmbarkedAllWater())
		{
			return (PromotionTypes)GD_INT_GET(PROMOTION_ALLWATER_EMBARKATION);
		}
	}

	return (PromotionTypes)GD_INT_GET(PROMOTION_EMBARKATION);
}

#if defined(MOD_PROMOTIONS_DEEP_WATER_EMBARKATION)
//	--------------------------------------------------------------------------------
PromotionTypes CvPlayer::GetDeepWaterEmbarkationPromotion() const
{
	if (MOD_PROMOTIONS_DEEP_WATER_EMBARKATION) {
		if(GET_TEAM(getTeam()).canDefensiveEmbark())
		{
			return (PromotionTypes)GD_INT_GET(PROMOTION_DEFENSIVE_DEEPWATER_EMBARKATION);
		}

		return (PromotionTypes)GD_INT_GET(PROMOTION_DEEPWATER_EMBARKATION);
	} else {
		return GetEmbarkationPromotion();
	}
}
#endif

//	--------------------------------------------------------------------------------
/// Provide Notification about someone adopting a new Religon
void CvPlayer::DoAnnounceReligionAdoption()
{
	CvCity* pHolyCity = GetHolyCity();

	for(int iI = 0; iI < MAX_PLAYERS; iI++)
	{
		CvPlayerAI& thisPlayer = GET_PLAYER((PlayerTypes)iI);
		if(thisPlayer.isHuman() && thisPlayer.isAlive() && thisPlayer.GetNotifications())
		{
			int iX = -1;
			int iY = -1;

			Localization::String localizedText;

			// Active Player
			if(GC.getGame().getActivePlayer() == GetID())
			{
				iX = pHolyCity->getX();
				iY = pHolyCity->getY();
				localizedText = Localization::Lookup("TXT_KEY_MISC_RELIGION_ADOPTED_YOU");
				localizedText << pHolyCity->getNameKey() << GetStateReligionKey();
			}
			// Met Player
			else if(GET_TEAM(GC.getGame().getActiveTeam()).isHasMet(thisPlayer.getTeam()))
			{
				localizedText = Localization::Lookup("TXT_KEY_MISC_RELIGION_ADOPTED_ANOTHER_PLAYER");
				localizedText << GET_PLAYER(pHolyCity->getOwner()).getNameKey() << GetStateReligionKey();

				// We've seen this player's City
				if(pHolyCity->isRevealed(thisPlayer.getTeam(), false, false))
				{
					iX = pHolyCity->getX();
					iY = pHolyCity->getY();
				}
			}
			// Unmet Player
			else
			{
				localizedText = Localization::Lookup("TXT_KEY_MISC_RELIGION_ADOPTED_UNKNOWN");
			}

			thisPlayer.GetNotifications()->Add(NOTIFICATION_RELIGION_RACE, localizedText.toUTF8(), localizedText.toUTF8(), iX, iY, GetReligions()->GetReligionCreatedByPlayer(), -1);
		}
	}
}

bool CvPlayer::IsAllowedToTradeWith(PlayerTypes eOtherPlayer)
{
	CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
	if (pLeague != NULL && pLeague->IsTradeEmbargoed(GetID(), eOtherPlayer) && eOtherPlayer != m_eID)
	{
		return false;
	}

	if (GC.getGame().GetGameLeagues()->IsIdeologyEmbargoed(GetID(), eOtherPlayer) && eOtherPlayer != m_eID)
	{
		return false;
	}

	if (eOtherPlayer != m_eID && GET_PLAYER(eOtherPlayer).isMajorCiv() && GET_PLAYER(eOtherPlayer).GetPlayerTraits()->IsNoOpenTrade())
	{
		if (!GC.getGame().GetGameTrade()->IsPlayerConnectedToPlayer(eOtherPlayer, GetID(), true))
			return false;
	}
	if (IsOnlyTradeSameIdeology() && GET_PLAYER(eOtherPlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE)
	{
		if (GET_PLAYER(eOtherPlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != GetPlayerPolicies()->GetLateGamePolicyTree())
		{
			return false;
		}
	}

	return true;
}

bool CvPlayer::CanEmbark() const
{
	return GET_TEAM(getTeam()).canEmbark() || GetPlayerTraits()->IsEmbarkedAllWater();
}
bool CvPlayer::CanCrossOcean() const
{
	return GET_TEAM(getTeam()).canEmbarkAllWaterPassage() || GetPlayerTraits()->IsEmbarkedAllWater();
}
bool CvPlayer::CanCrossMountain() const
{
	return GetPlayerTraits()->IsAbleToCrossMountainsWithGreatGeneral() || GetPlayerTraits()->IsMountainPass();
}
bool CvPlayer::CanCrossIce() const
{
	return GetPlayerTraits()->IsAbleToCrossIce();
}

//////////////////////////////////////////////////////////////////////////
// Tutorial Stuff...
//////////////////////////////////////////////////////////////////////////

//	--------------------------------------------------------------------------------
bool CvPlayer::GetEverPoppedGoody()
{
	return m_bEverPoppedGoody;
}

//	--------------------------------------------------------------------------------
CvPlot* CvPlayer::GetClosestGoodyPlot(bool bStopAfterFindingFirst)
{
	CvPlot* pResultPlot = NULL;
	int iShortestPath = INT_MAX;

	// cycle through goodies
	for(int i = 0; i < GC.getMap().numPlots(); i++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(i);
		if(!pPlot || !pPlot->isGoody(getTeam()))
		{
			continue;
		}

		// cycle through units
		int iUnitLoop;
		CvUnit* pLoopUnit = NULL;

		// Setup m_units
		for(pLoopUnit = firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iUnitLoop))
		{
			if(!pLoopUnit)
			{
				continue;
			}

			if(pPlot->getArea() != pLoopUnit->plot()->getArea() && !pLoopUnit->CanEverEmbark())
			{
				continue;
			}

			int iReturnValue = INT_MAX;
			bool bResult = pLoopUnit->GeneratePath(pPlot, CvUnit::MOVEFLAG_IGNORE_DANGER, iShortestPath, &iReturnValue);

			if(bResult)
			{
				if(iReturnValue < iShortestPath)
				{
					pResultPlot = pPlot;
					iShortestPath = iReturnValue;
				}

				if(bStopAfterFindingFirst)
				{
					return pPlot;
				}
			}
		}
	}

	return pResultPlot;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::GetPlotHasOrder(CvPlot* pPlot)
{
	if(!pPlot)
	{
		return false;
	}

	int iLoopUnit;
	for(CvUnit* pLoopUnit = firstUnit(&iLoopUnit); pLoopUnit; pLoopUnit = nextUnit(&iLoopUnit))
	{
		CvPlot* pMissionPlot = pLoopUnit->GetMissionAIPlot();
		if(NULL != pMissionPlot && pMissionPlot->getX() == pPlot->getX() && pMissionPlot->getY() == pPlot->getY())
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::GetAnyUnitHasOrderToGoody()
{
	// cycle through goodies
	for(int i = 0; i < GC.getMap().numPlots(); i++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(i);
		if(!pPlot)
		{
			continue;
		}

		if(!pPlot->isGoody(getTeam()))
		{
			continue;
		}

		if(GetPlotHasOrder(pPlot))
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::GetEverTrainedBuilder()
{
	return m_bEverTrainedBuilder;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumFreeTechs() const
{
	return m_iFreeTechCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumFreeTechs(int iValue)
{
	m_iFreeTechCount = iValue;
	if(GetID() == GC.getGame().getActivePlayer())
	{
		GC.GetEngineUserInterface()->setDirty(ResearchButtons_DIRTY_BIT, true);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetMedianTechPercentage() const
{
	return m_iMedianTechPercentage;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMedianTechPercentage(int iValue)
{
	m_iMedianTechPercentage += iValue;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumFreePolicies() const
{
	return m_iNumFreePolicies;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumFreePolicies(int iValue)
{
	// Increase count of free Policies we've ever had
	int iDifference = iValue - m_iNumFreePolicies;
	if(iDifference > 0)
	{
		ChangeNumFreePoliciesEver(iDifference);
	}

	m_iNumFreePolicies = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumFreePolicies(int iChange)
{
	SetNumFreePolicies(GetNumFreePolicies() + iChange);

	if(iChange > 0 && getNumCities() > 0)
	{
		CvNotifications* pNotifications = GetNotifications();
		if(pNotifications)
		{
			CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_FREE_POLICY");
			CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_FREE_POLICY_SUMMARY");
			pNotifications->Add(NOTIFICATION_FREE_POLICY, strBuffer, strSummary, -1, -1, -1);
		}

	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumFreeTenets() const
{
	return m_iNumFreeTenets;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumFreeTenets(int iValue, bool bCountAsFreePolicies)
{
	// Increase count of free Policies we've ever had
	int iDifference = iValue - m_iNumFreeTenets;
	if (bCountAsFreePolicies && iDifference > 0)
	{
		ChangeNumFreePoliciesEver(iDifference);
	}

	m_iNumFreeTenets = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumFreeTenets(int iChange, bool bCountAsFreePolicies)
{
	SetNumFreeTenets(GetNumFreeTenets() + iChange, bCountAsFreePolicies);

	if(iChange > 0 && getNumCities() > 0)
	{
		CvNotifications* pNotifications = GetNotifications();
		if(pNotifications)
		{
			CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_FREE_POLICY");
			CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_FREE_POLICY_SUMMARY");
			pNotifications->Add(NOTIFICATION_FREE_POLICY, strBuffer, strSummary, -1, -1, -1);
		}

	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumFreeGreatPeople() const
{
	return m_iNumFreeGreatPeople;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumFreeGreatPeople(int iValue)
{
	m_iNumFreeGreatPeople = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumFreeGreatPeople(int iChange)
{
	m_iNumFreeGreatPeople = GetNumFreeGreatPeople() + iChange;
	if(iChange > 0)
	{
		if(isHuman())
		{
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				CvString strBuffer = GetLocalizedText("TXT_KEY_CHOOSE_FREE_GREAT_PERSON");
				CvString strSummary = GetLocalizedText("TXT_KEY_CHOOSE_FREE_GREAT_PERSON_TT");
				pNotifications->Add(NOTIFICATION_FREE_GREAT_PERSON, strSummary.c_str(), strBuffer.c_str(), -1, -1, -1);
			}
		}
		else
		{
			for(int iI = 0; iI < iChange; iI++)
			{
				AI_chooseFreeGreatPerson();
			}
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumMayaBoosts() const
{
	return m_iNumMayaBoosts;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumMayaBoosts(int iValue)
{
	m_iNumMayaBoosts = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumMayaBoosts(int iChange)
{
	m_iNumMayaBoosts = GetNumMayaBoosts() + iChange;
	if(iChange > 0)
	{
		if(isHuman())
		{
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_MAYA_LONG_COUNT");
				CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_MAYA_LONG_COUNT_TT");
				pNotifications->Add(NOTIFICATION_MAYA_LONG_COUNT, strSummary.c_str(), strBuffer.c_str(), -1, -1, -1);
			}
		}
		else
		{
			for(int iI = 0; iI < iChange; iI++)
			{
				GetPlayerTraits()->ChooseMayaBoost();
			}
		}
	}
}


/// Accessor: Get extra times to spread religion for missionaries from this city
int CvPlayer::GetMissionaryExtraStrength() const
{
	return m_iMissionaryExtraStrength;
}

/// Accessor: Change extra times to spread religion for missionaries from this city
void CvPlayer::ChangeMissionaryExtraStrength(int iChange)
{
	if (iChange != 0)
	{
		m_iMissionaryExtraStrength = (m_iMissionaryExtraStrength + iChange);
		CvAssert(m_iMissionaryExtraStrength >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumFaithGreatPeople() const
{
	return m_iNumFaithGreatPeople;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumFaithGreatPeople(int iValue)
{
	m_iNumFaithGreatPeople = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumFaithGreatPeople(int iChange)
{
	m_iNumFaithGreatPeople = GetNumFaithGreatPeople() + iChange;
	if(iChange > 0)
	{
		if(isHuman())
		{
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_FAITH_GREAT_PERSON");
				CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_FAITH_GREAT_PERSON_TT");
				pNotifications->Add(NOTIFICATION_FAITH_GREAT_PERSON, strSummary.c_str(), strBuffer.c_str(), -1, -1, -1);
			}
		}
		else
		{
			for(int iI = 0; iI < iChange; iI++)
			{
				AI_chooseFreeGreatPerson();
			}
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetNumArchaeologyChoices() const
{
	return m_iNumArchaeologyChoices;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumArchaeologyChoices(int iValue)
{
	m_iNumArchaeologyChoices = iValue;
}

//	--------------------------------------------------------------------------------
FaithPurchaseTypes CvPlayer::GetFaithPurchaseType() const
{
	return m_eFaithPurchaseType;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetFaithPurchaseType(FaithPurchaseTypes eType)
{
	m_eFaithPurchaseType = eType;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetFaithPurchaseIndex() const
{
	return m_iFaithPurchaseIndex;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetFaithPurchaseIndex(int iIndex)
{
	m_iFaithPurchaseIndex = iIndex;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumFreePoliciesEver() const
{
	return m_iNumFreePoliciesEver;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumFreePoliciesEver(int iValue)
{
	m_iNumFreePoliciesEver = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumFreePoliciesEver(int iChange)
{
	SetNumFreePoliciesEver(GetNumFreePoliciesEver() + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetLastSliceMoved() const
{
	return m_iLastSliceMoved;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetLastSliceMoved(int iValue)
{
	m_iLastSliceMoved = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetEverConqueredBy(PlayerTypes ePlayer, bool bValue)
{
	if(bValue)
	{
		m_bfEverConqueredBy.SetBit(ePlayer);
	}
	else
	{
		m_bfEverConqueredBy.ClearBit(ePlayer);
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsEverConqueredBy(PlayerTypes ePlayer)
{
	return m_bfEverConqueredBy.GetBit(ePlayer);
}

//	------------------------------------------------------------------------------------------------
const CvSyncArchive<CvPlayer>& CvPlayer::getSyncArchive() const
{
	return m_syncArchive;
}

//	--------------------------------------------------------------------------------
CvSyncArchive<CvPlayer>& CvPlayer::getSyncArchive()
{
	return m_syncArchive;
}

//	-----------------------------------------------------------------------------------------------
bool CvPlayer::isLocalPlayer() const
{
	return (GC.getGame().getActivePlayer() == GetID());
}

//	-----------------------------------------------------------------------------------------------
void CvPlayer::disconnected()
{
	bool isMultiplayer = GC.getGame().isGameMultiPlayer();
	if(isMultiplayer && isHuman() && !isLocalPlayer())
	{
			//log message for debugging the occasional lack of disconnect notification when Steam p2p connections timeout. - bolson 1/10/13
			FILogFile* logFile = LOGFILEMGR.GetLog("net_message_debug.log", 0);
			if(logFile)
			{
				logFile->DebugMsg("Attempted to post notification for player disconnect event.  Player(%i)", GetID());
			}

			CvNotifications* pNotifications = GET_PLAYER(GC.getGame().getActivePlayer()).GetNotifications();
			if(pNotifications){
				if(gDLL->IsPlayerKicked(GetID())){
					Localization::String kickedMsg = Localization::Lookup("TXT_KEY_PLAYER_KICKED");
					kickedMsg << getNameKey();
					pNotifications->Add(NOTIFICATION_PLAYER_KICKED, kickedMsg.toUTF8(), kickedMsg.toUTF8(), -1, -1, GetID());
				}
				else{
					Localization::String disconnectString = Localization::Lookup("TXT_KEY_PLAYER_DISCONNECTED");
					disconnectString << getNameKey();

					if(CvPreGame::isPitBoss()){
						disconnectString = Localization::Lookup("TXT_KEY_PLAYER_DISCONNECTED_PITBOSS");
						disconnectString << getNameKey();	
					}

					pNotifications->Add(NOTIFICATION_PLAYER_DISCONNECTED, disconnectString.toUTF8(), disconnectString.toUTF8(), -1, -1, GetID());
				}
			}

		if(!isObserver() && (!CvPreGame::isPitBoss() || gDLL->IsPlayerKicked(GetID())))
		{
			// JAR : First pass, automatically fall back to CPU so the
			// game can continue. Todo : add popup on host asking whether
			// the AI should take over or everyone should wait for the
			// player to reconnect
			CvPreGame::setSlotStatus(GetID(), SS_COMPUTER);
			CvPreGame::VerifyHandicap(GetID());	//Changing the handicap because we're switching to AI

			// Load leaderhead for this new AI player
			gDLL->NotifySpecificAILeaderInGame(GetID());
			
			if(!GC.getGame().isOption(GAMEOPTION_DYNAMIC_TURNS) && GC.getGame().isOption(GAMEOPTION_SIMULTANEOUS_TURNS))
			{//When in fully simultaneous turn mode, having a player disconnect might trigger the automove phase for all human players.
				checkRunAutoMovesForEveryone();
			}
		}
	}
}
//	-----------------------------------------------------------------------------------------------
void CvPlayer::reconnected()
{
	//Preserve observer status for the connecting human player's slot.
	if(CvPreGame::slotStatus(GetID()) != SS_OBSERVER){
		CvPreGame::setSlotStatus(GetID(), SS_TAKEN);
	}

	CvPreGame::VerifyHandicap(GetID()); //verify the handicap because we might have replaced an ai.

	CvGame& kGame = GC.getGame();
	bool isMultiplayer = kGame.isGameMultiPlayer();

	if(isMultiplayer && !isLocalPlayer())
	{
		FAutoArchive& archive = getSyncArchive();
		archive.clearDelta();

		Localization::String connectString = Localization::Lookup("TXT_KEY_PLAYER_CONNECTING");
		connectString << getNameKey();

		CvNotifications* pNotifications = GET_PLAYER(kGame.getActivePlayer()).GetNotifications();
		if(pNotifications)
		{
			pNotifications->Add(NOTIFICATION_PLAYER_CONNECTING, connectString.toUTF8(), connectString.toUTF8(), -1, -1, GetID());
		}
	}
}
//	-----------------------------------------------------------------------------------------------
bool CvPlayer::hasBusyUnitUpdatesRemaining() const
{
	return m_endTurnBusyUnitUpdatesLeft > 0;
}

//	-----------------------------------------------------------------------------------------------
void CvPlayer::setBusyUnitUpdatesRemaining(int iUpdateCount)
{
	m_endTurnBusyUnitUpdatesLeft = iUpdateCount;
}

//	-----------------------------------------------------------------------------------------------
const char* const CvPlayer::getNickName() const
{
	return CvPreGame::nicknameDisplayed(GetID()).c_str();
}

//	-----------------------------------------------------------------------------------------------
bool CvPlayer::hasUnitsThatNeedAIUpdate() const
{
	const CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(!pLoopUnit->TurnProcessed() &&
		        (pLoopUnit->IsAutomated() &&
		         pLoopUnit->AI_getUnitAIType() != UNITAI_UNKNOWN &&
		         pLoopUnit->canMove()))
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
std::string CvPlayer::debugDump(const FAutoVariableBase&) const
{
	std::string result = "Game Turn : ";
	char gameTurnBuffer[8] = {0};
	int gameTurn = GC.getGame().getGameTurn();
	sprintf_s(gameTurnBuffer, "%d\0", gameTurn);
	result += gameTurnBuffer;
	return result;
}

//	--------------------------------------------------------------------------------
std::string CvPlayer::stackTraceRemark(const FAutoVariableBase& /*var*/) const
{
	return EmptyString;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::hasTurnTimerExpired()
{//Indicates if this player's turn time has elapsed.
	return GC.getGame().hasTurnTimerExpired(GetID());
}

//	--------------------------------------------------------------------------------
void CvPlayer::checkArmySizeAchievement()
{
	if (!MOD_API_ACHIEVEMENTS)
		return;

	int numUnits = 0;
	int32 nLargestArmy = 0;
	int iI;

	for(iI = 0; iI < NUM_UNITAI_TYPES; iI++)
	{
		if ((UnitAITypes)iI == UNITAI_ARTIST ||(UnitAITypes)iI == UNITAI_ENGINEER || (UnitAITypes)iI == UNITAI_UNKNOWN ||
		        (UnitAITypes)iI == UNITAI_GENERAL || (UnitAITypes)iI == UNITAI_SETTLE || (UnitAITypes)iI == UNITAI_WORKER ||
		        (UnitAITypes)iI == UNITAI_SCIENTIST || (UnitAITypes)iI == UNITAI_MERCHANT || (UnitAITypes)iI == UNITAI_WORKER_SEA ||
		        (UnitAITypes)iI == UNITAI_SPACESHIP_PART || (UnitAITypes)iI == UNITAI_TREASURE || (UnitAITypes)iI == UNITAI_PROPHET ||
		        (UnitAITypes)iI == UNITAI_MISSIONARY || (UnitAITypes)iI == UNITAI_INQUISITOR || (UnitAITypes)iI == UNITAI_ADMIRAL ||
				(UnitAITypes)iI == UNITAI_DIPLOMAT || (UnitAITypes)iI == UNITAI_MESSENGER ||
				(UnitAITypes)iI == UNITAI_WRITER || (UnitAITypes)iI == UNITAI_MUSICIAN)
		{
			continue;
		}
		else
		{
			numUnits += GetNumUnitsWithUnitAI((UnitAITypes)iI, false, true);
		}
	}
	gDLL->GetSteamStat(ESTEAMSTAT_STANDINGARMY, &nLargestArmy);

	if(nLargestArmy < numUnits)
	{
		gDLL->SetSteamStat(ESTEAMSTAT_STANDINGARMY, numUnits);

		CvAchievementUnlocker::Check_PSG();
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::checkInitialTurnAIProcessed()
{
	int turn = GC.getGame().getGameTurn();
	if(m_lastGameTurnInitialAIProcessed != turn)
	{
		//Note: Players that are not turn active at the beginning of the game turn will 
		//process their AI when they are turn active.  However, they should still 
		//act like their initial AI has been processed.
		if(!isTurnActive() || !hasUnitsThatNeedAIUpdate())
		{
			m_lastGameTurnInitialAIProcessed = turn;
			if(GC.getGame().getActivePlayer() == GetID())
				gDLL->sendPlayerInitialAIProcessed();
		}
	}
}

//------------------------------------------------------------------------------
void CvPlayer::GatherPerTurnReplayStats(int iGameTurn)
{
#if !defined(FINAL_RELEASE)
	cvStopWatch watch("Replay Stat Recording");
#endif
	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());

		bool bResult;
		LuaSupport::CallHook(pkScriptSystem, "GatherPerTurnReplayStats", args.get(), bResult);
	}

	//Only record the following statistics if the player is alive.
	if(isAlive())
	{
		//	Production Per Turn
		setReplayDataValue("REPLAYDATASET_PRODUCTIONPERTURN", iGameTurn, calculateTotalYield(YIELD_PRODUCTION));
		// 	Gold
		setReplayDataValue("REPLAYDATASET_TOTALGOLD", iGameTurn, GetTreasury()->GetGold());
		// 	Gold per Turn
		setReplayDataValue("REPLAYDATASET_GOLDPERTURN", iGameTurn, calculateTotalYield(YIELD_GOLD));
		// 	Num Cities
		setReplayDataValue("REPLAYDATASET_CITYCOUNT", iGameTurn, getNumCities());

		//	Number of Techs known
		CvTeam& team = GET_TEAM(getTeam());
		setReplayDataValue("REPLAYDATASET_TECHSKNOWN", iGameTurn, team.GetTeamTechs()->GetNumTechsKnown());

		// 	Science per Turn
		setReplayDataValue("REPLAYDATASET_SCIENCEPERTURN", iGameTurn, calculateTotalYield(YIELD_SCIENCE));
		// antonjs: This data is also used to calculate Great Scientist and Research Agreement beaker bonuses. If replay data changes

		// 	Total Culture
		setReplayDataValue("REPLAYDATASET_TOTALCULTURE", iGameTurn, getJONSCulture());

		// 	Culture per turn
		setReplayDataValue("REPLAYDATASET_CULTUREPERTURN", iGameTurn, GetTotalJONSCulturePerTurn());
		
#if defined(MOD_BALANCE_CORE)
		setReplayDataValue("REPLAYDATASET_TOURISMPERTURN", iGameTurn, GetCulture()->GetTourism() / 100);
		setReplayDataValue("REPLAYDATASET_GAPPERTURN", iGameTurn, GetGoldenAgePointsFromEmpire() + GetHappinessForGAP());
#endif

		// 	Happiness
		setReplayDataValue("REPLAYDATASET_EXCESSHAPINESS", iGameTurn, GetExcessHappiness());
		setReplayDataValue("REPLAYDATASET_HAPPINESS", iGameTurn, GetHappiness());
		setReplayDataValue("REPLAYDATASET_UNHAPPINESS", iGameTurn, GetUnhappiness());

		// 	Golden Age turns
		setReplayDataValue("REPLAYDATASET_GOLDENAGETURNS", iGameTurn, getGoldenAgeTurns());

		// 	Population
		setReplayDataValue("REPLAYDATASET_POPULATION", iGameTurn, getTotalPopulation());

		// 	Food Per Turn
		setReplayDataValue("REPLAYDATASET_FOODPERTURN", iGameTurn, calculateTotalYield(YIELD_FOOD));

		//	Total Land
		setReplayDataValue("REPLAYDATASET_TOTALLAND", iGameTurn, getTotalLand());

		CvTreasury* pkTreasury = GetTreasury();
		setReplayDataValue("REPLAYDATASET_GPTCITYCONNECTIONS", iGameTurn, pkTreasury->GetCityConnectionGold());
		setReplayDataValue("REPLAYDATASET_GPTINTERNATIONALTRADE", iGameTurn, pkTreasury->GetGoldPerTurnFromTradeRoutes());
		setReplayDataValue("REPLAYDATASET_GPTDEALS", iGameTurn, pkTreasury->GetGoldPerTurnFromDiplomacy());
		setReplayDataValue("REPLAYDATASET_UNITMAINTENANCE", iGameTurn, pkTreasury->GetExpensePerTurnUnitMaintenance());
		setReplayDataValue("REPLAYDATASET_BUILDINGMAINTENANCE", iGameTurn, pkTreasury->GetBuildingGoldMaintenance());
		setReplayDataValue("REPLAYDATASET_IMPROVEMENTMAINTENANCE", iGameTurn, pkTreasury->GetImprovementGoldMaintenance());
		setReplayDataValue("REPLAYDATASET_NUMBEROFPOLICIES", iGameTurn, GetPlayerPolicies()->GetNumPoliciesOwned());

		// workers
		int iWorkerCount = 0;
		CvUnit* pLoopUnit;
		int iLoopUnit;
		for(pLoopUnit = firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoopUnit))
		{
			if(pLoopUnit->AI_getUnitAIType() == UNITAI_WORKER)
			{
				iWorkerCount++;
			}
		}
		setReplayDataValue("REPLAYDATASET_NUMBEROFWORKERS", iGameTurn, iWorkerCount);

		// worked tiles
		int iWorkedTiles = 0;
		int iImprovedTiles = 0;
		// go through all the plots the player has under their control
		for (PlotIndexContainer::const_iterator it = m_aiPlots.begin(); it != m_aiPlots.end(); ++it)
		{
			CvPlot* pPlot = GC.getMap().plotByIndex(*it);
			if (!pPlot)
			{
				continue;
			}

			// plot has city in it, don't count
			if(pPlot->getPlotCity())
			{
				continue;
			}

			if(pPlot->isBeingWorked())
			{
				iWorkedTiles++;
			}

			if(pPlot->getImprovementType() != NO_IMPROVEMENT)
			{
				iImprovedTiles++;
			}
		}

		setReplayDataValue("REPLAYDATASET_IMPROVEDTILES", iGameTurn, iImprovedTiles);
		setReplayDataValue("REPLAYDATASET_WORKEDTILES", iGameTurn, iWorkedTiles);
		setReplayDataValue("REPLAYDATASET_NUMBEROFWORKERS", iGameTurn, iWorkerCount);
		setReplayDataValue("REPLAYDATASET_MILITARYMIGHT", iGameTurn, GetMilitaryMight());
	}
}

//	---------------------------------------------------------------------------
//	If the active player is in the end-turn processing phase, attempt to cancel that.
//	This should be called when something occurs that could happen during the end-turn
//	that may need the players attention this turn.
//	Ex.  A player's unit auto-moves into a goody hut plot.
bool CancelActivePlayerEndTurn()
{
	CvPlayer& kActivePlayer = GET_PLAYER(GC.getGame().getActivePlayer());

	if(kActivePlayer.isLocalPlayer() && kActivePlayer.isEndTurn())
	{
		if (gDLL->sendTurnUnready())	// This will see if we can actually do the unready, sometimes you can't in MP games.
		{
			kActivePlayer.setEndTurn(false);
			return true;
		}
		return false;
	}
	return true;
}

//	--------------------------------------------------------------------------------
///	Get the amount of Happiness we're getting from our vassals
int CvPlayer::GetHappinessFromVassals() const
{
	int iHappiness = 0;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;
		if (GetID() != ePlayer && GET_PLAYER(ePlayer).isAlive() && GET_PLAYER(ePlayer).isMajorCiv() && GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassal(getTeam()))
		{
			iHappiness += GetHappinessFromVassal(ePlayer);
		}
	}

	return max(0, iHappiness);
}
//	--------------------------------------------------------------------------------
/// Happiness from a Vassal
int CvPlayer::GetHappinessFromVassal(PlayerTypes ePlayer) const
{
	int iAmount = 0;

	if (MOD_BALANCE_CORE_HAPPINESS)
	{
		iAmount = (GET_PLAYER(ePlayer).GetExcessHappiness() - /*50*/ GD_INT_GET(UNHAPPY_THRESHOLD)) * (/*20*/ GD_INT_GET(VASSAL_HAPPINESS_PERCENT) + GetVassalYieldBonusModifier());
		iAmount /= 200;
	}
	else
	{
		iAmount = GET_PLAYER(ePlayer).GetExcessHappiness() * (/*20*/ GD_INT_GET(VASSAL_HAPPINESS_PERCENT) + GetVassalYieldBonusModifier());
		iAmount /= 100;
	}

	return iAmount;
}
//	--------------------------------------------------------------------------------
/// Special bonus for having a vassal
int CvPlayer::GetYieldPerTurnFromVassals(YieldTypes eYield) const
{
	switch (eYield)
	{
	case YIELD_SCIENCE:
		if (GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))
			return 0;
		break;
	case YIELD_CULTURE:
		if (GC.getGame().isOption(GAMEOPTION_NO_POLICIES))
			return 0;
		break;
	case YIELD_FAITH:
		if (GC.getGame().isOption(GAMEOPTION_NO_RELIGION))
			return 0;
		break;
	default:
		return 0; // Other yields cannot be recieved from vassals.
	}

	int iYield = 0;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;
		
		// ePlayer vassal of ours?
		if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassal(getTeam()))
		{
			int iFreeYield = 0;

			switch (eYield)
			{
			case YIELD_CULTURE:
				iFreeYield = GET_PLAYER(ePlayer).GetTotalJONSCulturePerTurn();
				iFreeYield *= (/*20*/ GD_INT_GET(VASSALAGE_FREE_YIELD_FROM_VASSAL_PERCENT) + GetVassalYieldBonusModifier());
				iFreeYield /= 100;
				break;
			case YIELD_FAITH:
				iFreeYield = GET_PLAYER(ePlayer).GetTotalFaithPerTurn();
				iFreeYield *= (/*20*/ GD_INT_GET(VASSALAGE_FREE_YIELD_FROM_VASSAL_PERCENT) + GetVassalYieldBonusModifier());
				iFreeYield /= 100;
				break;
			case YIELD_SCIENCE:
				iFreeYield = GET_PLAYER(ePlayer).GetScience();
				iFreeYield *= (/*20*/ GD_INT_GET(VASSALAGE_FREE_YIELD_FROM_VASSAL_PERCENT) + GetVassalYieldBonusModifier());
				iFreeYield /= 100;
				break;
			default:
				UNREACHABLE();
			}

			iYield += iFreeYield;
		}
	}

	return iYield;
}
//	--------------------------------------------------------------------------------
// Score from Vassals: 50% percent
int CvPlayer::GetScoreFromVassals() const
{
	int iScore = 0;

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;
		iScore += GetScoreFromVassal(ePlayer);
	}

	return iScore;
}
//	--------------------------------------------------------------------------------
// Score from vassal
int CvPlayer::GetScoreFromVassal(PlayerTypes ePlayer) const
{
	int iScore = 0;

	if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassal(getTeam()))
	{
		iScore = GET_PLAYER(ePlayer).GetScoreFromLand() + GET_PLAYER(ePlayer).GetScoreFromPopulation();
		iScore *= /*50*/ GD_INT_GET(VASSAL_SCORE_PERCENT);
		iScore /= 100;
	}

	return iScore;
}
// ------------------------

//	--------------------------------------------------------------------------------
int CvPlayer::GetVassalGoldMaintenanceMod() const
{
	return m_iVassalGoldMaintenanceMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetVassalGoldMaintenanceMod(int iValue)
{
	m_iVassalGoldMaintenanceMod = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeVassalGoldMaintenanceMod(int iChange)
{
	if(iChange != 0)
	{
		m_iVassalGoldMaintenanceMod = (m_iVassalGoldMaintenanceMod + iChange);
	}
}

void CvPlayer::DoVassalLevy()
{
	if (!m_bVassalLevy)
		return;

	// Look at all Cities
	bool bMaster = false;
	CvCity* pMasterCity = NULL;
	int iSum = 0;
	CvCity* pLoopCity;
	int iLoop;
	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		for (int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
		{
			const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

			if (pkBuildingInfo)
			{
				// Has this Building
				if (pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
				{
					if (pkBuildingInfo->IsVassalLevyEra())
					{
						bMaster = true;
						pMasterCity = pLoopCity;
						break;
					}
				}
			}
		}
	}
	if (bMaster && pMasterCity != NULL)
	{
		std::vector<UnitTypes> aExtraUnits;
		std::vector<UnitAITypes> aExtraUnitAITypes;
		CvUnit* pLoopUnit = NULL;
		int iLoop = 0;
		for (pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		{
			if (pLoopUnit->getDomainType() == DOMAIN_LAND && pLoopUnit->IsCombatUnit())
			{
				UnitTypes eCurrentUnitType = pLoopUnit->getUnitType();
				UnitAITypes eCurrentUnitAIType = pLoopUnit->AI_getUnitAIType();

				// check for duplicate unit
				bool bAddUnit = true;
				for (uint ui = 0; ui < aExtraUnits.size(); ui++)
				{
					if (aExtraUnits[ui] == eCurrentUnitType)
					{
						bAddUnit = false;
					}
				}

				if (bAddUnit)
				{
					aExtraUnits.push_back(eCurrentUnitType);
					aExtraUnitAITypes.push_back(eCurrentUnitAIType);
				}
			}
		}
		if (aExtraUnits.size() > 0)
		{
			int iTotal = GetNumVassals() * 2;
			for (int iK = 0; iK < iTotal; iK++)
			{
				int iUnit = GC.getGame().getSmallFakeRandNum(aExtraUnits.size(), GetPseudoRandomSeed() + GC.getGame().GetCultureMedian() + iK);
				CvUnit* pNewUnit = initUnit(aExtraUnits[iUnit], pMasterCity->getX(), pMasterCity->getY(), aExtraUnitAITypes[iUnit]);
				bool bJumpSuccess = pNewUnit->jumpToNearestValidPlot();
				if (bJumpSuccess)
				{
					pMasterCity->addProductionExperience(pNewUnit);
					iSum++;
				}
				if (!bJumpSuccess)
				{
					pNewUnit->kill(false);
					break;
				}
			}
			if (iSum > 0)
			{
				CvNotifications* pNotifications = GetNotifications();
				if (pNotifications && GetID() == GC.getGame().getActivePlayer())
				{
					Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_VASSAL_LEVY");
					strText << iSum;
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_VASSAL_LEVY_SUMMARY");
					strSummary << iSum;
					pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pMasterCity->getX(), pMasterCity->getY(), -1);
				}
			}
		}
	}

	m_bVassalLevy = false;
}

void CvPlayer::SetVassalLevy(bool bValue)
{
	if (m_bVassalLevy != bValue)
		m_bVassalLevy = bValue;
}

//	--------------------------------------------------------------------------------
// Generate tooltip displayed for whether or not our vassal can declare independence from us
CvString CvPlayer::GetVassalIndependenceTooltipAsMaster(PlayerTypes ePlayer) const
{
	CvTeam& kVassalTeam = GET_TEAM(GET_PLAYER(ePlayer).getTeam());

	TeamTypes eMaster = kVassalTeam.GetMaster();
	if(eMaster != getTeam())
		return "";

	CvTeam& kMasterTeam = GET_TEAM(eMaster);
	
	CvString szTooltip = "";
	
	szTooltip += GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_TT") + "[NEWLINE][NEWLINE]";

	bool bVoluntary = kVassalTeam.IsVoluntaryVassal(getTeam());
	bool bSatisfied = false;

	int iMinimumVassalTurns = bVoluntary ? GC.getGame().getGameSpeedInfo().getMinimumVoluntaryVassalTurns() : GC.getGame().getGameSpeedInfo().getMinimumVassalTurns();

	int iNumTurnsIsVassal = kVassalTeam.GetNumTurnsIsVassal();

	bSatisfied = (iNumTurnsIsVassal >= iMinimumVassalTurns);
	szTooltip += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_TURNS_TT", iMinimumVassalTurns) + "[ENDCOLOR][NEWLINE]";
	
	// Rules only for capitulated vassals
	if(!bVoluntary)
	{
		CvString szTemp = "";

		int iNumCitiesWhenVassalMade = kVassalTeam.getNumCitiesWhenVassalMade();
		int iPopulationWhenVassalMade = kVassalTeam.getTotalPopulationWhenVassalMade();

		int iCityPercent = 0;
		int iPopPercent = 0;

		iCityPercent = kVassalTeam.getNumCities() * 100 / std::max(1, iNumCitiesWhenVassalMade);
		iPopPercent = kVassalTeam.getTotalPopulation() * 100 / std::max(1, iPopulationWhenVassalMade);

		bSatisfied = iCityPercent <= /*75*/ GD_INT_GET(VASSALAGE_VASSAL_LOST_CITIES_THRESHOLD);
		bool bAnySatisfied = bSatisfied;
		szTemp += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_CITY_PERCENT_TT", GD_INT_GET(VASSALAGE_VASSAL_LOST_CITIES_THRESHOLD),iCityPercent) + "[ENDCOLOR][NEWLINE]";

		bSatisfied = iPopPercent >= /*300*/ GD_INT_GET(VASSALAGE_VASSAL_POPULATION_THRESHOLD);
		bAnySatisfied |= bSatisfied;
		szTemp += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_POP_PERCENT_TT", GD_INT_GET(VASSALAGE_VASSAL_POPULATION_THRESHOLD), iPopPercent) + "[ENDCOLOR][NEWLINE]";
		
		int iMasterCityPercent = 0;
		int iMasterPopPercent = 0;

		iMasterCityPercent = kVassalTeam.getNumCities() * 100 / std::max(1, kMasterTeam.getNumCities());
		iMasterPopPercent = kVassalTeam.getTotalPopulation() * 100 / std::max(1, kMasterTeam.getTotalPopulation());

		bSatisfied = iMasterCityPercent >= /*60*/ GD_INT_GET(VASSALAGE_VASSAL_MASTER_CITY_PERCENT_THRESHOLD) && iMasterPopPercent >= /*60*/ GD_INT_GET(VASSALAGE_VASSAL_MASTER_POP_PERCENT_THRESHOLD);
		bAnySatisfied |= bSatisfied;
		szTemp += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_MASTER_PERCENT_TT", GD_INT_GET(VASSALAGE_VASSAL_MASTER_CITY_PERCENT_THRESHOLD), GD_INT_GET(VASSALAGE_VASSAL_MASTER_POP_PERCENT_THRESHOLD), iMasterCityPercent, iMasterPopPercent) + "[ENDCOLOR][NEWLINE]";

		szTooltip += (bAnySatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_OR_HEADER_TT") + "[NEWLINE]";
		szTooltip += szTemp;
	}

	return szTooltip;
}

// Generate tooltip displayed for whether or not we can declare independence from master
CvString CvPlayer::GetVassalIndependenceTooltipAsVassal() const
{
	CvTeam& kVassalTeam = GET_TEAM(getTeam());

	TeamTypes eMaster = kVassalTeam.GetMaster();
	if(eMaster == NO_TEAM)
		return "";

	CvTeam& kMasterTeam = GET_TEAM(eMaster);
	
	CvString szTooltip = "";
	
	szTooltip += GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_MASTER_TT") + "[NEWLINE][NEWLINE]";

	bool bVoluntary = kVassalTeam.IsVoluntaryVassal(getTeam());
	bool bSatisfied = false;

	int iMinimumVassalTurns = bVoluntary ? GC.getGame().getGameSpeedInfo().getMinimumVoluntaryVassalTurns() : GC.getGame().getGameSpeedInfo().getMinimumVassalTurns();

	int iNumTurnsIsVassal = kVassalTeam.GetNumTurnsIsVassal();

	bSatisfied = (iNumTurnsIsVassal >= iMinimumVassalTurns);
	szTooltip += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_TURNS_TT", iMinimumVassalTurns) + "[ENDCOLOR][NEWLINE]";
	
	// Rules only for capitulated vassals
	if(!bVoluntary)
	{
		CvString szTemp = "";

		int iNumCitiesWhenVassalMade = kVassalTeam.getNumCitiesWhenVassalMade();
		int iPopulationWhenVassalMade = kVassalTeam.getTotalPopulationWhenVassalMade();

		int iCityPercent = 0;
		int iPopPercent = 0;

		iCityPercent = kVassalTeam.getNumCities() * 100 / std::max(1, iNumCitiesWhenVassalMade);
		iPopPercent = kVassalTeam.getTotalPopulation() * 100 / std::max(1, iPopulationWhenVassalMade);

		bSatisfied = iCityPercent <= /*75*/ GD_INT_GET(VASSALAGE_VASSAL_LOST_CITIES_THRESHOLD);
		bool bAnySatisfied = bSatisfied;
		szTemp += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_CITY_PERCENT_TT", GD_INT_GET(VASSALAGE_VASSAL_LOST_CITIES_THRESHOLD),iCityPercent) + "[ENDCOLOR][NEWLINE]";

		bSatisfied = iPopPercent >= /*300*/ GD_INT_GET(VASSALAGE_VASSAL_POPULATION_THRESHOLD);
		bAnySatisfied |= bSatisfied;
		szTemp += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_CITY_PERCENT_TT", GD_INT_GET(VASSALAGE_VASSAL_POPULATION_THRESHOLD), iPopPercent) + "[ENDCOLOR][NEWLINE]";
		
		int iMasterCityPercent = 0;
		int iMasterPopPercent = 0;

		iMasterCityPercent = kVassalTeam.getNumCities() * 100 / std::max(1, kMasterTeam.getNumCities());
		iMasterPopPercent = kVassalTeam.getTotalPopulation() * 100 / std::max(1, kMasterTeam.getTotalPopulation());

		bSatisfied = iMasterCityPercent >= /*60*/ GD_INT_GET(VASSALAGE_VASSAL_MASTER_CITY_PERCENT_THRESHOLD) && iMasterPopPercent >= /*60*/ GD_INT_GET(VASSALAGE_VASSAL_MASTER_POP_PERCENT_THRESHOLD);
		bAnySatisfied |= bSatisfied;
		szTemp += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_MASTER_PERCENT_TT", GD_INT_GET(VASSALAGE_VASSAL_MASTER_CITY_PERCENT_THRESHOLD), GD_INT_GET(VASSALAGE_VASSAL_MASTER_POP_PERCENT_THRESHOLD), iMasterCityPercent, iMasterPopPercent) + "[ENDCOLOR][NEWLINE]";

		szTooltip += (bAnySatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_OR_HEADER_TT") + "[NEWLINE]";
		szTooltip += szTemp;
	}

	return szTooltip;
}

#if defined(MOD_BALANCE_CORE)
int CvPlayer::GetScoreFromMinorAllies() const
{
	int iScore = (GC.getGame().GetNumMinorCivsEver() * 25);
	int iMaxMinorCivs = 0;
	int iMinorAllies = 0;
	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		PlayerTypes eMinor = (PlayerTypes) iMinorLoop;
		if(GET_PLAYER(eMinor).isAlive())
		{
			iMaxMinorCivs++;
		}
		if(GET_PLAYER(eMinor).GetMinorCivAI()->IsAllies(GetID()))
		{
			iMinorAllies++;
		}
	}
	if(iMaxMinorCivs > 0)
	{
		int iPercentage = ((iMinorAllies * 100) / iMaxMinorCivs);
		iScore = ((iPercentage * iScore) / 100);
		return iScore;
	}
	return 0;
}
int CvPlayer::GetScoreFromMilitarySize() const
{
	return (GetMilitaryMight() / (10 + getNumCities()));
}
#endif

//	----------------------------------------------------------------------------
bool CvPlayer::HasBelief(BeliefTypes iBeliefType) const
{
	ReligionTypes iReligion = GetReligions()->GetOwnedReligion();
	if (iReligion == NO_RELIGION)
		iReligion = GetReligions()->GetReligionCreatedByPlayer(true);

	const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(iReligion, GetID());

	return (pReligion && pReligion->m_Beliefs.HasBelief(iBeliefType));
}

bool CvPlayer::HasBuilding(BuildingTypes iBuildingType)
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasBuilding(iBuildingType)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasBuildingClass(BuildingClassTypes iBuildingClassType)
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasBuildingClass(iBuildingClassType)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasAnyWonder()
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasAnyWonder()) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasWonder(BuildingTypes iBuildingType)
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasWonder(iBuildingType)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::IsCivilization(CivilizationTypes iCivilizationType) const
{
	return (getCivilizationType() == iCivilizationType);
}

bool CvPlayer::IsInEra(EraTypes iEraType) const
{
	return (GET_TEAM(getTeam()).GetCurrentEra() == iEraType);
}

bool CvPlayer::HasReachedEra(EraTypes iEraType) const
{
	return (GET_TEAM(getTeam()).GetCurrentEra() >= iEraType);
}

bool CvPlayer::HasAnyNaturalWonder()
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasAnyNaturalWonder()) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasNaturalWonder(FeatureTypes iFeatureType)
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasNaturalWonder(iFeatureType)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasPolicy(PolicyTypes iPolicyType) const
{
	return GetPlayerPolicies()->HasPolicy(iPolicyType);
}

bool CvPlayer::HasTenet(PolicyTypes iPolicyType) const
{
	return HasPolicy(iPolicyType);
}

bool CvPlayer::HasPolicyBranch(PolicyBranchTypes iPolicyBranchType) const
{
	return GetPlayerPolicies()->IsPolicyBranchUnlocked(iPolicyBranchType);
}

bool CvPlayer::HasIdeology(PolicyBranchTypes iPolicyBranchType) const
{
	return HasPolicyBranch(iPolicyBranchType);
}
bool CvPlayer::HasSameIdeology(PlayerTypes ePlayer) const
{
	CvPlayer &kPlayer = GET_PLAYER(ePlayer);
	PolicyBranchTypes eMyIdeology = GetPlayerPolicies()->GetLateGamePolicyTree();
	PolicyBranchTypes eTheirIdeology = kPlayer.GetPlayerPolicies()->GetLateGamePolicyTree();
	if (eMyIdeology != NO_POLICY_BRANCH_TYPE && eTheirIdeology != NO_POLICY_BRANCH_TYPE && eMyIdeology == eTheirIdeology)
	{
		return true;
	}
	return false;
}
bool CvPlayer::HasProject(ProjectTypes iProjectType) const
{
	return (GET_TEAM(getTeam()).getProjectCount(iProjectType) > 0);
}

bool CvPlayer::IsAtPeace() const
{
	return GetPlayersAtWarWith().empty();
}

bool CvPlayer::IsAtPeaceAllMajors() const
{
	return !IsAtWarAnyMajor();
}

bool CvPlayer::IsAtPeaceAllMinors() const
{
	return !IsAtWarAnyMinor();
}

bool CvPlayer::IsAtPeaceWith(PlayerTypes iPlayer) const
{
	return !IsAtWarWith(iPlayer);
}

bool CvPlayer::IsAtWar() const
{
	return !IsAtPeace();
}

bool CvPlayer::IsAtWarAnyMajor() const
{
	for (std::vector<PlayerTypes>::const_iterator it = m_playersWeAreAtWarWith.begin(); it != m_playersWeAreAtWarWith.end(); ++it)
		if (GET_PLAYER(*it).isMajorCiv())
			return true;

	return false;
}

bool CvPlayer::IsAtWarAnyMinor() const
{
	for (std::vector<PlayerTypes>::const_iterator it = m_playersWeAreAtWarWith.begin(); it != m_playersWeAreAtWarWith.end(); ++it)
		if (GET_PLAYER(*it).isMinorCiv())
			return true;

	return false;
}

bool CvPlayer::IsAtWarWith(PlayerTypes iPlayer) const
{
	if (iPlayer==NO_PLAYER)
		return false;

	return GET_TEAM(getTeam()).isAtWar(GET_PLAYER(iPlayer).getTeam());
}

/// Returns a vector containing pointers to all civs helping us in war against a major civ AND ourselves (used for city danger/peace evaluations)
vector<PlayerTypes> CvPlayer::GetWarAllies(PlayerTypes ePlayer) const
{
	vector<PlayerTypes> result;
	if (!IsAtWarWith(ePlayer))
		return result;

	vector<PlayerTypes> vMinorsToCheck;
	PlayerTypes eAlly = isMinorCiv() ? GetMinorCivAI()->GetAlly() : NO_PLAYER;
	result.push_back(GetID());

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (GET_PLAYER(eLoopPlayer).GetID() == GetID())
			continue;

		if (!GET_PLAYER(eLoopPlayer).IsAtWarWith(ePlayer))
			continue;

		if (getTeam() == GET_PLAYER(eLoopPlayer).getTeam())
		{
			result.push_back(eLoopPlayer);
			continue;
		}

		if (!GET_TEAM(getTeam()).isHasMet(GET_PLAYER(eLoopPlayer).getTeam()))
			continue;

		if (isMinorCiv())
		{
			if (eAlly != NO_PLAYER && GET_PLAYER(eLoopPlayer).getTeam() == GET_PLAYER(eAlly).getTeam())
			{
				result.push_back(eLoopPlayer);
			}
		}
		else if (isMajorCiv())
		{
			if (GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				if (GET_PLAYER(eLoopPlayer).GetMinorCivAI()->GetAlly() != NO_PLAYER)
					vMinorsToCheck.push_back(eLoopPlayer);
			}
			else if (GET_PLAYER(eLoopPlayer).isMajorCiv())
			{
				if (GetDiplomacyAI()->GetCoopWarState(eLoopPlayer, ePlayer) >= COOP_WAR_STATE_PREPARING)
				{
					result.push_back(eLoopPlayer);
				}
				else if (!GetDiplomacyAI()->IsDenouncedPlayer(eLoopPlayer) && !GetDiplomacyAI()->IsDenouncedByPlayer(eLoopPlayer) && !GetDiplomacyAI()->IsUntrustworthy(eLoopPlayer))
				{
					if (GetDiplomacyAI()->IsHasDefensivePact(eLoopPlayer) && (GetDiplomacyAI()->IsDoFAccepted(eLoopPlayer) || GetDiplomacyAI()->GetDoFType(eLoopPlayer) >= DOF_TYPE_ALLIES || GetDiplomacyAI()->GetCivOpinion(eLoopPlayer) >= CIV_OPINION_FRIEND))
					{
						result.push_back(eLoopPlayer);
					}
					else if (GetDiplomacyAI()->GetNumCitiesLiberatedBy(eLoopPlayer) > 0 && GetDiplomacyAI()->GetNumCitiesLiberatedBy(eLoopPlayer) > GetDiplomacyAI()->GetNumCitiesCapturedBy(eLoopPlayer))
					{
						result.push_back(eLoopPlayer);
					}
					else if (GetDiplomacyAI()->GetNumCitiesCapturedBy(eLoopPlayer) <= 0 && GET_PLAYER(ePlayer).GetDiplomacyAI()->GetNumCitiesCapturedBy(eLoopPlayer) > 0)
					{
						if (GetDiplomacyAI()->IsDoFAccepted(eLoopPlayer) || GetDiplomacyAI()->GetDoFType(eLoopPlayer) >= DOF_TYPE_ALLIES || GetDiplomacyAI()->GetCivOpinion(eLoopPlayer) == CIV_OPINION_ALLY)
							result.push_back(eLoopPlayer);
					}
				}
			}
		}
	}
	if (isMajorCiv())
	{
		for (std::vector<PlayerTypes>::iterator it = vMinorsToCheck.begin(); it != vMinorsToCheck.end(); it++)
		{
			eAlly = GET_PLAYER(*it).GetMinorCivAI()->GetAlly();

			if (std::find(result.begin(), result.end(), eAlly) != result.end())
				result.push_back(*it);
		}
	}

	return result;
}

int CvPlayer::CountNumDangerousMajorsAtWarWith(bool bExcludePhonyWars, bool bExcludeIfNoTarget) const
{
	int iCount = 0;

	if (isMinorCiv())
	{
		for (std::vector<PlayerTypes>::const_iterator it = m_playersWeAreAtWarWith.begin(); it != m_playersWeAreAtWarWith.end(); ++it)
		{
			if (GET_PLAYER(*it).isMajorCiv())
				iCount++;
		}
		return iCount;
	}

	for (std::vector<PlayerTypes>::const_iterator it = m_playersWeAreAtWarWith.begin(); it != m_playersWeAreAtWarWith.end(); ++it)
	{
		if (GET_PLAYER(*it).isMajorCiv() && GET_PLAYER(*it).isAlive() && GET_PLAYER(*it).getNumCities() > 0)
		{
			if (bExcludePhonyWars && GetDiplomacyAI()->IsPhonyWar(*it))
				continue;
			else if (bExcludeIfNoTarget && !GetMilitaryAI()->IsExposedToEnemy(NULL, *it) && GetDiplomacyAI()->GetNumberOfThreatenedCities(*it) <= 0)
				continue;

			iCount++;
		}
	}

	return iCount;
}

bool CvPlayer::HasPantheon() const
{
	return GetReligions()->HasCreatedPantheon();
}

bool CvPlayer::HasAnyReligion() const
{
	return GetReligions()->HasCreatedReligion();
}

bool CvPlayer::HasReligion(ReligionTypes iReligionType) const
{
	return (GetReligions()->GetOwnedReligion() == iReligionType);
}

bool CvPlayer::HasEnhancedReligion() const
{
	const ReligionTypes eReligion = GetReligions()->GetOwnedReligion();
	const CvReligion* pMyReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, GetID());

	return (pMyReligion && pMyReligion->m_bEnhanced);
}

bool CvPlayer::IsConnectedTo(PlayerTypes iPlayer)
{
	return IsCapitalConnectedToPlayer(iPlayer);
}

bool CvPlayer::HasSpecialistSlot(SpecialistTypes iSpecialistType)
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasSpecialistSlot(iSpecialistType)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasSpecialist(SpecialistTypes iSpecialistType)
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasSpecialist(iSpecialistType)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasTech(TechTypes iTechType) const
{
	return GET_TEAM(getTeam()).GetTeamTechs()->HasTech(iTechType);
}

bool CvPlayer::HasAnyDomesticTradeRoute() const
{
	int iOwner = GetID();
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute)) {
			continue;
		}

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));

		if (pConnection->m_eOriginOwner == iOwner && pConnection->m_eDestOwner == iOwner) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasAnyInternationalTradeRoute() const
{
	int iOwner = GetID();
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute)) {
			continue;
		}

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));

		if ((pConnection->m_eOriginOwner == iOwner && pConnection->m_eDestOwner   != iOwner) ||
		    (pConnection->m_eDestOwner   == iOwner && pConnection->m_eOriginOwner != iOwner)) {
			return true;
		}
	}

	return false;
}
int CvPlayer::GetNumInternalRoutes() const
{
	int iOwner = GetID();
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();
	int iNum = 0;
	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute)) {
			continue;
		}

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));

		if (pConnection->m_eOriginOwner == iOwner && pConnection->m_eDestOwner == iOwner) {
			iNum++;
		}
	}

	return iNum;
}

int CvPlayer::GetNumInternationalRoutes() const
{
	int iOwner = GetID();
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();
	int iNum = 0;
	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute)) {
			continue;
		}

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));

		if (pConnection->m_eOriginOwner == iOwner && pConnection->m_eDestOwner != iOwner)
		{
			iNum++;
		}
	}

	return iNum;
}
bool CvPlayer::HasAnyTradeRoute() const
{
	int iOwner = GetID();
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute)) {
			continue;
		}

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));

		if (pConnection->m_eOriginOwner == iOwner || pConnection->m_eDestOwner == iOwner) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasAnyTradeRouteWith(PlayerTypes iPlayer) const
{
	int iOwner = GetID();
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute)) {
			continue;
		}

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));

		if ((pConnection->m_eOriginOwner == iOwner && pConnection->m_eDestOwner   == iPlayer) ||
		    (pConnection->m_eDestOwner   == iOwner && pConnection->m_eOriginOwner == iPlayer)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasUnit(UnitTypes iUnitType)
{
	int iLoopUnit;

	for (CvUnit* pLoopUnit = firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoopUnit)) {
		if (!pLoopUnit->isDelayedDeath()) {
			if (pLoopUnit->IsUnit(iUnitType)) {
				return true;
			}
		}
	}

	return false;
}

bool CvPlayer::HasUnitClass(UnitClassTypes iUnitClassType)
{
	int iLoopUnit;

	for (CvUnit* pLoopUnit = firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoopUnit)) {
		if (!pLoopUnit->isDelayedDeath()) {
			if (pLoopUnit->IsUnitClass(iUnitClassType)) {
				return true;
			}
		}
	}

	return false;
}

bool CvPlayer::HasUUActive()
{
	if (!HasUUPeriod())
		return false;

	int iLoop;
	CvCivilizationInfo* pkInfo = GC.getCivilizationInfo(getCivilizationType());

	if (pkInfo)
	{
		for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop)) 
		{
			if (pkInfo->isCivilizationUnitOverridden(pLoopUnit->getUnitClassType()))
			{
				// Can't be an exploration unit
				if (pLoopUnit->getUnitInfo().GetDefaultUnitAIType() == UNITAI_EXPLORE || pLoopUnit->getUnitInfo().GetDefaultUnitAIType() == UNITAI_EXPLORE_SEA)
					continue;

				// Ignore zombies and units about to die
				if (!pLoopUnit->isDelayedDeath() && !pLoopUnit->isProjectedToDieNextTurn())
				{
					return true;
				}
			}
		}
	}

	return false;
}

bool CvPlayer::HasUUPeriod() const
{
	return m_bHasUUPeriod;
}

void CvPlayer::SetHasUUPeriod()
{
	CvCivilizationInfo* pkInfo = GC.getCivilizationInfo(getCivilizationType());
	if (pkInfo)
	{
		// Loop through all units
		for (int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
		{
			// Is this one overridden for our civ?
			if (pkInfo->isCivilizationUnitOverridden(iI))
			{
				UnitTypes eCivilizationUnit = static_cast<UnitTypes>(pkInfo->getCivilizationUnits(iI));
				if (eCivilizationUnit != NO_UNIT)
				{
					CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eCivilizationUnit);
					if (pkUnitEntry)
					{
						// No recon units!
						if (pkUnitEntry->GetDefaultUnitAIType() == UNITAI_EXPLORE || pkUnitEntry->GetDefaultUnitAIType() == UNITAI_EXPLORE_SEA)
							continue;

						// Must be a combat or combat support unit
						if (pkUnitEntry->GetCombat() > 0 || pkUnitEntry->GetRangedCombat() > 0 || pkUnitEntry->GetCultureBombRadius() > 0 || pkUnitEntry->IsCanRepairFleet() || pkUnitEntry->IsCityAttackSupport() || pkUnitEntry->GetNukeDamageLevel() != -1)
						{
							//obsolete? This no longer applies.
							if (pkUnitEntry->GetObsoleteTech() != NO_TECH && HasTech((TechTypes)pkUnitEntry->GetObsoleteTech()))
							{
								m_bHasUUPeriod = false;
							}
							else
							{
								m_bHasUUPeriod = true;
								return;
							}
						}
					}
				}
			}
		}
	}

	m_bHasUUPeriod = false;
}

bool CvPlayer::HasTrait(TraitTypes eTrait) const
{
	return GetPlayerTraits()->HasTrait(eTrait);
}

bool CvPlayer::HasAnyHolyCity()
{
	int iLoop;

	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		if (pLoopCity->GetCityReligions()->IsHolyCityAnyReligion()) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasHolyCity(ReligionTypes eReligion)
{
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		if (pLoopCity->GetCityReligions()->IsHolyCityForReligion(eReligion)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasCapturedHolyCity(ReligionTypes eReligion)
{
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		if (pLoopCity->GetCityReligions()->IsHolyCityForReligion(eReligion)) {
			return (pLoopCity->getOriginalOwner() != GetID());
		}
	}

	return false;
}

bool CvPlayer::HasEmbassyWith(PlayerTypes eOtherPlayer) const
{
	if (eOtherPlayer >= 0 && eOtherPlayer < MAX_MAJOR_CIVS) {
		CvPlayer& kOtherPlayer = GET_PLAYER(eOtherPlayer);

		return (kOtherPlayer.isAlive() && GET_TEAM(getTeam()).HasEmbassyAtTeam(kOtherPlayer.getTeam()));
	}

	return false;
}

void CvPlayer::DoForceDefPact(PlayerTypes eOtherPlayer)
{
	CvTeam& pOtherTeam = GET_TEAM(GET_PLAYER(eOtherPlayer).getTeam());

	GET_TEAM(getTeam()).SetHasDefensivePact(pOtherTeam.GetID(), true);
	pOtherTeam.SetHasDefensivePact(getTeam(), true);
}
int CvPlayer::CountAllFeature(FeatureTypes iFeatureType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountFeature(iFeatureType);
	}
	
	return iCount;
}

int CvPlayer::CountAllWorkedFeature(FeatureTypes iFeatureType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountWorkedFeature(iFeatureType);
	}
	
	return iCount;
}

int CvPlayer::CountAllImprovement(ImprovementTypes iImprovementType, bool bOnlyCreated)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountImprovement(iImprovementType, bOnlyCreated);
	}
	
	return iCount;
}

int CvPlayer::CountAllWorkedImprovement(ImprovementTypes iImprovementType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountWorkedImprovement(iImprovementType);
	}
	
	return iCount;
}

int CvPlayer::CountAllPlotType(PlotTypes iPlotType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountPlotType(iPlotType);
	}
	
	return iCount;
}

int CvPlayer::CountAllWorkedPlotType(PlotTypes iPlotType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountWorkedPlotType(iPlotType);
	}
	
	return iCount;
}

int CvPlayer::CountAllResource(ResourceTypes iResourceType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountResource(iResourceType);
	}
	
	return iCount;
}

int CvPlayer::CountAllWorkedResource(ResourceTypes iResourceType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountWorkedResource(iResourceType);
	}
	
	return iCount;
}

int CvPlayer::CountAllTerrain(TerrainTypes iTerrainType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountTerrain(iTerrainType);
	}
	
	return iCount;
}

int CvPlayer::CountAllWorkedTerrain(TerrainTypes iTerrainType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountWorkedTerrain(iTerrainType);
	}
	
	return iCount;
}

void CvPlayer::invalidatePlotFoundValues()
{
	m_iPlotFoundValuesUpdateTurn = -1;
}

void CvPlayer::computeFoundValueThreshold()
{
	m_iReferenceFoundValue = 0;

	//minors are not so discriminating ...
	//should they ever have a settler, just take the best available spot
	if (!isMajorCiv())
		return;

	// important preparation
	GC.getGame().GetSettlerSiteEvaluator()->ComputeFlavorMultipliers(this);
	vector<int> vValues = GC.getGame().GetSettlerSiteEvaluator()->GetAllCitySiteValues(this);
	if (vValues.empty())
		return;

	std::sort(vValues.begin(), vValues.end());

	//set our threshold halfway between the worst plot and the median
	m_iReferenceFoundValue = (vValues[0] + vValues[vValues.size()/2])/2;

	//some flavor adjustment
	int iFlavorExpansion = GetFlavorManager()->GetPersonalityIndividualFlavor((FlavorTypes)GC.getInfoTypeForString("FLAVOR_EXPANSION"));
	//clamp it to a sensible range
	iFlavorExpansion = min(max(0, iFlavorExpansion), 12);
	m_iReferenceFoundValue = (m_iReferenceFoundValue * (100 - 2 * iFlavorExpansion)) / 100;

	if (GC.getLogging() && GC.getAILogging())
	{
		CvString strMsg;
		strMsg.Format("Median city site value for player %d is %d, flavor adjusted limit is %d\n", m_eID, vValues[vValues.size()/2], m_iReferenceFoundValue);
		GetHomelandAI()->LogHomelandMessage(strMsg);
	}
}


void CvPlayer::updatePlotFoundValues()
{
	if (m_iPlotFoundValuesUpdateTurn==GC.getGame().getGameTurn())
		return;

	//OutputDebugString(CvString::format("updating plot found values for player %d in turn %d\n",GetID(),GC.getGame().getGameTurn()).c_str());
	m_viPlotFoundValues = std::vector<int>(GC.getMap().numPlots(), -1);

	//don't need to update if not going to settle
	if (isBarbarian())
		return;

	//in some mods minors can have settlers ... and they should be able to use them
	if (isMinorCiv() && GetNumUnitsWithUnitAI(UNITAI_SETTLE)==0)
		return;

	// important preparation
	GC.getGame().GetSettlerSiteEvaluator()->ComputeFlavorMultipliers(this);
	//these are the plots whose yield we ignore
	vector<int> ignoreYieldPlots(GC.getMap().numPlots(), 0); 

	for (int iI = 0; iI < GC.getMap().numPlots(); iI++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iI);
		if (pPlot->isOwned())
		{
			if (pPlot->getOwner() != m_eID) //if we own it ourselves it's fine
				ignoreYieldPlots[iI] = 1;
		}
		else if (pPlot->IsAdjacentOwnedByTeamOtherThan(getTeam()) && GC.getGame().GetClosestCityDistanceInPlots(pPlot) < /*3*/ GD_INT_GET(MIN_CITY_RANGE))
		{
			ignoreYieldPlots[iI] = 1;
		}
	}

	//calculate new values and apply our threshold
	CvSiteEvaluatorForSettler* pCalc = GC.getGame().GetSettlerSiteEvaluator();
	for (int iI = 0; iI < GC.getMap().numPlots(); iI++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iI);
		if (!pPlot->isRevealed(getTeam()))
			continue;

		//this does not check CvPlayer::CanFound() because it would be recursion, therefore we do basic checks before
		m_viPlotFoundValues[iI] = pCalc->PlotFoundValue(pPlot, this, ignoreYieldPlots) - m_iReferenceFoundValue;
	}

	m_iPlotFoundValuesUpdateTurn = GC.getGame().getGameTurn();
}

int CvPlayer::getPlotFoundValue(int iX, int iY)
{
	//lazy update
	updatePlotFoundValues();

	size_t iIndex = (size_t)GC.getMap().plotNum(iX,iY);

	if (iIndex<m_viPlotFoundValues.size())
		return m_viPlotFoundValues[iIndex];
	else
		return 0;
}

void CvPlayer::setPlotFoundValue(int iX, int iY, int iValue)
{
	//if setting the values manually, make sure the size is right
	if (m_viPlotFoundValues.size() != GC.getMap().numPlots())
		m_viPlotFoundValues.resize(GC.getMap().numPlots(), -1);

	size_t iIndex = (size_t)GC.getMap().plotNum(iX, iY);
	if (iIndex<m_viPlotFoundValues.size())
		m_viPlotFoundValues[iIndex] = iValue;

	//prevent lazy update from overwriting this
	m_iPlotFoundValuesUpdateTurn = GC.getGame().getGameTurn();
}

int CvPlayer::GetAvgUnitExp100() const
{
	return m_iAvgUnitExp100;
}
