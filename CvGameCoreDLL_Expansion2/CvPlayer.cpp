/*	-------------------------------------------------------------------------------------------------------
	© 1991-2012 Take-Two Interactive Software and its subsidiaries.  Developed by Firaxis Games.  
	Sid Meier's Civilization V, Civ, Civilization, 2K Games, Firaxis Games, Take-Two Interactive Software 
	and their respective logos are all trademarks of Take-Two interactive Software, Inc.  
	All other marks and trademarks are the property of their respective owners.  
	All rights reserved. 
	------------------------------------------------------------------------------------------------------- */

#include "CvGameCoreDLLPCH.h"
#include "CvGlobals.h"
#include "CvArea.h"
#include "CvMap.h"
#include "CvPlot.h"
#include "CvRandom.h"
#include "CvTeam.h"
#include "CvGameCoreUtils.h"
#include "CvPlayerAI.h"
#include "CvPlayer.h"
#include "CvInfos.h"
#include "CvAStar.h"
#include "CvGameTextMgr.h"
#include "CvDiplomacyAI.h"
#include "CvEconomicAI.h"
#include "CvMilitaryAI.h"
#include "CvCitySpecializationAI.h"
#include "CvWonderProductionAI.h"
#include "CvGrandStrategyAI.h"
#include "CvDiplomacyAI.h"
#include "CvTechAI.h"
#include "CvFlavorManager.h"
#include "CvHomelandAI.h"
#include "CvMinorCivAI.h"
#include "CvDealAI.h"
#include "CvImprovementClasses.h"
#include "CvBuilderTaskingAI.h"
#include "CvDangerPlots.h"
#if defined(MOD_BALANCE_CORE)
#include "CvDistanceMap.h"
#include "CvBarbarians.h"
#endif
#include "CvGoodyHuts.h"
#include "CvCityConnections.h"
#include "CvNotifications.h"
#include "CvDiplomacyRequests.h"
#include "cvStopWatch.h"
#include "CvTypes.h"
#if defined(MOD_BUGFIX_NO_PUPPET_CAPITALS)
#include "CvEnums.h"
#endif

#include "ICvDLLUserInterface.h"
#include "CvEnumSerialization.h"
#include "FStlContainerSerialization.h"
#include <sstream>
#if defined(MOD_BALANCE_CORE)
#include <iomanip>
#endif

#include "CvInternalGameCoreUtils.h"
#include "CvAchievementUnlocker.h"
#include "CvInfosSerializationHelper.h"

#include "CvDllCity.h"
#if defined(MOD_GLOBAL_NO_CONQUERED_SPACESHIPS)
#include "CvDllPlot.h"
#endif
#include "CvGoodyHuts.h"

#include "CvDllNetMessageExt.h"
// Include this after all other headers.
#define LINT_WARNINGS_ONLY
#include "LintFree.h"

//------------------------------------------------------------------------------
// CvPlayer Version History
// Version 1 
//	 * CvPlayer save version reset for expansion pack 2.
//------------------------------------------------------------------------------
const int g_CurrentCvPlayerVersion = 16;

//Simply empty check utility.
bool isEmpty(const char* szString)
{
	return szString == NULL || szString[0] == '\0';
}

//	--------------------------------------------------------------------------------
// Public Functions...
namespace FSerialization
{
void SyncPlayer()
{
	if(GC.getGame().isNetworkMultiPlayer())
	{
		PlayerTypes eAuthoritativePlayerID = GC.getGame().getActivePlayer();
		CvPlayer& authoritativePlayer = GET_PLAYER(eAuthoritativePlayerID);
		const FAutoArchive& archive = authoritativePlayer.getSyncArchive();
		if(archive.hasDeltas())
		{
			FMemoryStream ms;
			std::vector<std::pair<std::string, std::string> > callStacks;
			archive.saveDelta(ms, callStacks);
			gDLL->sendPlayerSyncCheck(eAuthoritativePlayerID, ms, callStacks);
		}

		// host is authoritative for AI players

		if(gDLL->IsHost())
		{
			for(int i = 0; i < MAX_PLAYERS; ++i)
			{
				CvPlayer& player = GET_PLAYER(static_cast<PlayerTypes>(i));
				if(!player.isHuman() && player.isAlive())
				{
					const FAutoArchive& aiArchive = player.getSyncArchive();
					FMemoryStream ms;
					std::vector<std::pair<std::string, std::string> > callStacks;
					aiArchive.saveDelta(ms, callStacks);
					gDLL->sendPlayerSyncCheck(static_cast<PlayerTypes>(i), ms, callStacks);
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
// clears ALL deltas for ALL players
void ClearPlayerDeltas()
{
	int i = 0;
	for(i = 0; i < MAX_PLAYERS; ++i)
	{
		CvPlayer& player = GET_PLAYER(static_cast<PlayerTypes>(i));
		FAutoArchive& archive = player.getSyncArchive();
		archive.clearDelta();
	}
}
}

//	--------------------------------------------------------------------------------
CvPlayer::CvPlayer() :
	m_syncArchive(*this)
	, m_iStartingX("CvPlayer::m_iStartingX", m_syncArchive)
	, m_iStartingY("CvPlayer::m_iStartingY", m_syncArchive)
	, m_iTotalPopulation("CvPlayer::m_iTotalPopulation", m_syncArchive, true)
	, m_iTotalLand("CvPlayer::m_iTotalLand", m_syncArchive)
	, m_iTotalLandScored("CvPlayer::m_iTotalLandScored", m_syncArchive)
	, m_iJONSCulturePerTurnForFree("CvPlayer::m_iJONSCulturePerTurnForFree", m_syncArchive)
	, m_iJONSCulturePerTurnFromMinorCivs("CvPlayer::m_iJONSCulturePerTurnFromMinorCivs", m_syncArchive)
	, m_iJONSCultureCityModifier("CvPlayer::m_iJONSCultureCityModifier", m_syncArchive)
	, m_iJONSCulture("CvPlayer::m_iJONSCulture", m_syncArchive, true)
	, m_iJONSCultureEverGenerated("CvPlayer::m_iJONSCultureEverGenerated", m_syncArchive)
	, m_iWondersConstructed("CvPlayer::m_iWondersConstructed", m_syncArchive)
	, m_iCulturePerWonder("CvPlayer::m_iCulturePerWonder", m_syncArchive)
	, m_iCultureWonderMultiplier("CvPlayer::m_iCultureWonderMultiplier", m_syncArchive)
	, m_iCulturePerTechResearched("CvPlayer::m_iCulturePerTechResearched", m_syncArchive)
	, m_iFaith("CvPlayer::m_iFaith", m_syncArchive)
	, m_iFaithEverGenerated("CvPlayer::m_iFaithEverGenerated", m_syncArchive)
	, m_iHappiness("CvPlayer::m_iHappiness", m_syncArchive)
	, m_iUprisingCounter("CvPlayer::m_iUprisingCounter", m_syncArchive)
	, m_iExtraHappinessPerLuxury("CvPlayer::m_iExtraHappinessPerLuxury", m_syncArchive)
	, m_iUnhappinessFromUnits("CvPlayer::m_iUnhappinessFromUnits", m_syncArchive)
	, m_iUnhappinessFromUnitsMod("CvPlayer::m_iUnhappinessFromUnitsMod", m_syncArchive)
	, m_iUnhappinessMod("CvPlayer::m_iUnhappinessMod", m_syncArchive)
	, m_iCityCountUnhappinessMod("CvPlayer::m_iCityCountUnhappinessMod", m_syncArchive)
	, m_iOccupiedPopulationUnhappinessMod("CvPlayer::m_iOccupiedPopulationUnhappinessMod", m_syncArchive)
	, m_iCapitalUnhappinessMod("CvPlayer::m_iCapitalUnhappinessMod", m_syncArchive)
	, m_iCityRevoltCounter("CvPlayer::m_iCityRevoltCounter", m_syncArchive)
	, m_iHappinessPerGarrisonedUnitCount("CvPlayer::m_iHappinessPerGarrisonedUnitCount", m_syncArchive)
	, m_iHappinessPerTradeRouteCount("CvPlayer::m_iHappinessPerTradeRouteCount", m_syncArchive)
	, m_iHappinessPerXPopulation("CvPlayer::m_iHappinessPerXPopulation", m_syncArchive)
	, m_iHappinessFromLeagues("CvPlayer::m_iHappinessFromLeagues", m_syncArchive)
	, m_iEspionageModifier("CvPlayer::m_iEspionageModifier", m_syncArchive)
	, m_iSpyStartingRank("CvPlayer::m_iSpyStartingRank", m_syncArchive)
	, m_iExtraLeagueVotes("CvPlayer::m_iExtraLeagueVotes", m_syncArchive)
	, m_iSpecialPolicyBuildingHappiness("CvPlayer::m_iSpecialPolicyBuildingHappiness", m_syncArchive)
	, m_iWoundedUnitDamageMod("CvPlayer::m_iWoundedUnitDamageMod", m_syncArchive)
	, m_iUnitUpgradeCostMod("CvPlayer::m_iUnitUpgradeCostMod", m_syncArchive)
	, m_iBarbarianCombatBonus("CvPlayer::m_iBarbarianCombatBonus", m_syncArchive)
	, m_iAlwaysSeeBarbCampsCount("CvPlayer::m_iAlwaysSeeBarbCampsCount", m_syncArchive)
	, m_iHappinessPerCity("CvPlayer::m_iHappinessPerCity", m_syncArchive)
	, m_iHappinessPerXPolicies("CvPlayer::m_iHappinessPerXPolicies", m_syncArchive)
	, m_iExtraHappinessPerXPoliciesFromPolicies("CvPlayer::m_iExtraHappinessPerXPoliciesFromPolicies", m_syncArchive)
	, m_iHappinessPerXGreatWorks("CvPlayer::m_iHappinessPerXGreatWorks", m_syncArchive)
	, m_iAdvancedStartPoints("CvPlayer::m_iAdvancedStartPoints", m_syncArchive)
	, m_iAttackBonusTurns("CvPlayer::m_iAttackBonusTurns", m_syncArchive)
	, m_iCultureBonusTurns("CvPlayer::m_iCultureBonusTurns", m_syncArchive)
	, m_iTourismBonusTurns("CvPlayer::m_iTourismBonusTurns", m_syncArchive)
	, m_iGoldenAgeProgressMeter("CvPlayer::m_iGoldenAgeProgressMeter", m_syncArchive, true)
	, m_iGoldenAgeMeterMod("CvPlayer::m_iGoldenAgeMeterMod", m_syncArchive)
	, m_iNumGoldenAges("CvPlayer::m_iNumGoldenAges", m_syncArchive)
	, m_iGoldenAgeTurns("CvPlayer::m_iGoldenAgeTurns", m_syncArchive)
	, m_iNumUnitGoldenAges("CvPlayer::m_iNumUnitGoldenAges", m_syncArchive)
	, m_iStrikeTurns("CvPlayer::m_iStrikeTurns", m_syncArchive)
	, m_iGoldenAgeModifier("CvPlayer::m_iGoldenAgeModifier", m_syncArchive)
	, m_iGreatPeopleCreated("CvPlayer::m_iGreatPeopleCreated", m_syncArchive)
	, m_iGreatGeneralsCreated("CvPlayer::m_iGreatGeneralsCreated", m_syncArchive)
	, m_iGreatAdmiralsCreated("CvPlayer::m_iGreatAdmiralsCreated", m_syncArchive)
	, m_iGreatWritersCreated("CvPlayer::m_iGreatWritersCreated", m_syncArchive)
	, m_iGreatArtistsCreated("CvPlayer::m_iGreatArtistsCreated", m_syncArchive)
	, m_iGreatMusiciansCreated("CvPlayer::m_iGreatMusiciansCreated", m_syncArchive)
	, m_iMerchantsFromFaith("CvPlayer::m_iMerchantsFromFaith", m_syncArchive)
	, m_iScientistsFromFaith("CvPlayer::m_iScientistsFromFaith", m_syncArchive)
	, m_iWritersFromFaith("CvPlayer::m_iWritersFromFaith", m_syncArchive)
	, m_iArtistsFromFaith("CvPlayer::m_iArtistsFromFaith", m_syncArchive)
	, m_iMusiciansFromFaith("CvPlayer::m_iMusiciansFromFaith", m_syncArchive)
	, m_iGeneralsFromFaith("CvPlayer::m_iGeneralsFromFaith", m_syncArchive)
	, m_iAdmiralsFromFaith("CvPlayer::m_iAdmiralsFromFaith", m_syncArchive)
	, m_iEngineersFromFaith("CvPlayer::m_iEngineersFromFaith", m_syncArchive)
	, m_iGreatPeopleThresholdModifier("CvPlayer::m_iGreatPeopleThresholdModifier", m_syncArchive)
	, m_iGreatGeneralsThresholdModifier("CvPlayer::m_iGreatGeneralsThresholdModifier", m_syncArchive)
	, m_iGreatAdmiralsThresholdModifier("CvPlayer::m_iGreatAdmiralsThresholdModifier", m_syncArchive)
	, m_iGreatGeneralCombatBonus("CvPlayer::m_iGreatGeneralCombatBonus", m_syncArchive)
	, m_iAnarchyNumTurns("CvPlayer::m_iAnarchyNumTurns", m_syncArchive)
	, m_iPolicyCostModifier("CvPlayer::m_iPolicyCostModifier", m_syncArchive)
	, m_iGreatPeopleRateModifier("CvPlayer::m_iGreatPeopleRateModifier", m_syncArchive)
	, m_iGreatPeopleRateModFromBldgs("CvPlayer::m_iGreatPeopleRateModFromBldgs", m_syncArchive)
	, m_iGreatGeneralRateModifier("CvPlayer::m_iGreatGeneralRateModifier", m_syncArchive)
	, m_iGreatGeneralRateModFromBldgs("CvPlayer::m_iGreatGeneralRateModFromBldgs", m_syncArchive)
	, m_iDomesticGreatGeneralRateModifier("CvPlayer::m_iDomesticGreatGeneralRateModifier", m_syncArchive)
	, m_iDomesticGreatGeneralRateModFromBldgs("CvPlayer::m_iDomesticGreatGeneralRateModFromBldgs", m_syncArchive)
	, m_iGreatAdmiralRateModifier("CvPlayer::m_iGreatAdmiralRateModifier", m_syncArchive)
	, m_iGreatWriterRateModifier("CvPlayer::m_iGreatWriterRateModifier", m_syncArchive)
	, m_iGreatArtistRateModifier("CvPlayer::m_iGreatArtistRateModifier", m_syncArchive)
	, m_iGreatMusicianRateModifier("CvPlayer::m_iGreatMusicianRateModifier", m_syncArchive)
	, m_iGreatMerchantRateModifier("CvPlayer::m_iGreatMerchantRateModifier", m_syncArchive)
	, m_iGreatDiplomatRateModifier("CvPlayer::m_iGreatDiplomatRateModifier", m_syncArchive)
	, m_iGreatScientistRateModifier("CvPlayer::m_iGreatScientistRateModifier", m_syncArchive)
	, m_iGreatScientistBeakerModifier("CvPlayer::m_iGreatScientistBeakerModifier", m_syncArchive)
	, m_iGreatEngineerHurryMod("CvPlayer::m_iGreatEngineerHurryMod", m_syncArchive)
	, m_iTechCostXCitiesModifier("CvPlayer::m_iTechCostXCitiesModifier", m_syncArchive)
	, m_iTourismCostXCitiesMod("CvPlayer::m_iTourismCostXCitiesMod", m_syncArchive)
	, m_iGreatEngineerRateModifier("CvPlayer::m_iGreatEngineerRateModifier", m_syncArchive)
	, m_iGreatPersonExpendGold("CvPlayer::m_iGreatPersonExpendGold", m_syncArchive)
	, m_iMaxGlobalBuildingProductionModifier("CvPlayer::m_iMaxGlobalBuildingProductionModifier", m_syncArchive)
	, m_iMaxTeamBuildingProductionModifier("CvPlayer::m_iMaxTeamBuildingProductionModifier", m_syncArchive)
	, m_iMaxPlayerBuildingProductionModifier("CvPlayer::m_iMaxPlayerBuildingProductionModifier", m_syncArchive)
	, m_iFreeExperience("CvPlayer::m_iFreeExperience", m_syncArchive)
	, m_iFreeExperienceFromBldgs("CvPlayer::m_iFreeExperienceFromBldgs", m_syncArchive)
	, m_iFreeExperienceFromMinors("CvPlayer::m_iFreeExperienceFromMinors", m_syncArchive)
	, m_iFeatureProductionModifier("CvPlayer::m_iFeatureProductionModifier", m_syncArchive)
	, m_iWorkerSpeedModifier("CvPlayer::m_iWorkerSpeedModifier", m_syncArchive)
	, m_iImprovementCostModifier("CvPlayer::m_iImprovementCostModifier", m_syncArchive)
	, m_iImprovementUpgradeRateModifier("CvPlayer::m_iImprovementUpgradeRateModifier", m_syncArchive)
	, m_iSpecialistProductionModifier("CvPlayer::m_iSpecialistProductionModifier", m_syncArchive)
	, m_iMilitaryProductionModifier("CvPlayer::m_iMilitaryProductionModifier", m_syncArchive)
	, m_iSpaceProductionModifier("CvPlayer::m_iSpaceProductionModifier", m_syncArchive)
	, m_iCityDefenseModifier("CvPlayer::m_iCityDefenseModifier", m_syncArchive)
	, m_iUnitFortificationModifier("CvPlayer::m_iUnitFortificationModifier", m_syncArchive)
	, m_iUnitBaseHealModifier("CvPlayer::m_iUnitBaseHealModifier", m_syncArchive)
	, m_iWonderProductionModifier("CvPlayer::m_iWonderProductionModifier", m_syncArchive)
	, m_iSettlerProductionModifier("CvPlayer::m_iSettlerProductionModifier", m_syncArchive)
	, m_iCapitalSettlerProductionModifier("CvPlayer::m_iCapitalSettlerProductionModifier", m_syncArchive)
	, m_iUnitProductionMaintenanceMod("CvPlayer::m_iUnitProductionMaintenanceMod", m_syncArchive)
	, m_iUnitGrowthMaintenanceMod("CvPlayer::m_iUnitGrowthMaintenanceMod", m_syncArchive)
	, m_iPolicyCostBuildingModifier("CvPlayer::m_iPolicyCostBuildingModifier", m_syncArchive)
	, m_iPolicyCostMinorCivModifier("CvPlayer::m_iPolicyCostMinorCivModifier", m_syncArchive)
	, m_iInfluenceSpreadModifier("CvPlayer::m_iInfluenceSpreadModifier", m_syncArchive)
	, m_iExtraVotesPerDiplomat("CvPlayer::m_iExtraVotesPerDiplomat", m_syncArchive)
	, m_iNumNukeUnits("CvPlayer::m_iNumNukeUnits", m_syncArchive)
	, m_iNumOutsideUnits("CvPlayer::m_iNumOutsideUnits", m_syncArchive, true)
	, m_iBaseFreeUnits("CvPlayer::m_iBaseFreeUnits", m_syncArchive)
	, m_iBaseFreeMilitaryUnits("CvPlayer::m_iBaseFreeMilitaryUnits", m_syncArchive)
	, m_iFreeUnitsPopulationPercent("CvPlayer::m_iFreeUnitsPopulationPercent", m_syncArchive)
	, m_iFreeMilitaryUnitsPopulationPercent("CvPlayer::m_iFreeMilitaryUnitsPopulationPercent", m_syncArchive)
	, m_iGoldPerUnit("CvPlayer::m_iGoldPerUnit", m_syncArchive)
	, m_iGoldPerMilitaryUnit("CvPlayer::m_iGoldPerMilitaryUnit", m_syncArchive)
	, m_iImprovementGoldMaintenanceMod("CvPlayer::m_iImprovementGoldMaintenanceMod", m_syncArchive)
#if defined(MOD_CIV6_WORKER)
	, m_iRouteBuilderCostMod("CvPlayer::m_iRouteBuilderCostMod", m_syncArchive)
#endif
	, m_iBuildingGoldMaintenanceMod("CvPlayer::m_iBuildingGoldMaintenanceMod", m_syncArchive)
	, m_iUnitGoldMaintenanceMod("CvPlayer::m_iUnitGoldMaintenanceMod", m_syncArchive)
	, m_iUnitSupplyMod("CvPlayer::m_iUnitSupplyMod", m_syncArchive)
	, m_iExtraUnitCost("CvPlayer::m_iExtraUnitCost", m_syncArchive)
	, m_iNumMilitaryUnits("CvPlayer::m_iNumMilitaryUnits", m_syncArchive)
	, m_iHappyPerMilitaryUnit("CvPlayer::m_iHappyPerMilitaryUnit", m_syncArchive)
	, m_iHappinessToCulture("CvPlayer::m_iHappinessToCulture", m_syncArchive)
	, m_iHappinessToScience("CvPlayer::m_iHappinessToScience", m_syncArchive)
	, m_iHalfSpecialistUnhappinessCount("CvPlayer::m_iHalfSpecialistUnhappinessCount", m_syncArchive)
	, m_iHalfSpecialistFoodCount("CvPlayer::m_iHalfSpecialistFoodCount", m_syncArchive)
	, m_iMilitaryFoodProductionCount("CvPlayer::m_iMilitaryFoodProductionCount", m_syncArchive)
	, m_iGoldenAgeCultureBonusDisabledCount("CvPlayer::m_iGoldenAgeCultureBonusDisabledCount", m_syncArchive)
	, m_iNumMissionarySpreads("CvPlayer::m_iNumMissionarySpreads", m_syncArchive)
	, m_iSecondReligionPantheonCount("CvPlayer::m_iSecondReligionPantheonCount", m_syncArchive)
	, m_iEnablesSSPartHurryCount("CvPlayer::m_iEnablesSSPartHurryCount", m_syncArchive)
	, m_iEnablesSSPartPurchaseCount("CvPlayer::m_iEnablesSSPartPurchaseCount", m_syncArchive)
	, m_iConscriptCount("CvPlayer::m_iConscriptCount", m_syncArchive)
	, m_iMaxConscript("CvPlayer::m_iMaxConscript", m_syncArchive)
	, m_iHighestUnitLevel("CvPlayer::m_iHighestUnitLevel", m_syncArchive)
	, m_iOverflowResearch("CvPlayer::m_iOverflowResearch", m_syncArchive, true)
	, m_iExpModifier("CvPlayer::m_iExpModifier", m_syncArchive)
	, m_iExpInBorderModifier("CvPlayer::m_iExpInBorderModifier", m_syncArchive)
	, m_iLevelExperienceModifier("CvPlayer::m_iLevelExperienceModifier", m_syncArchive)
	, m_iMinorQuestFriendshipMod("CvPlayer::m_iMinorQuestFriendshipMod", m_syncArchive)
	, m_iMinorGoldFriendshipMod("CvPlayer::m_iMinorGoldFriendshipMod", m_syncArchive)
	, m_iMinorFriendshipMinimum("CvPlayer::m_iMinorFriendshipMinimum", m_syncArchive)
	, m_iMinorFriendshipDecayMod("CvPlayer::m_iMinorFriendshipDecayMod", m_syncArchive)
	, m_iMinorScienceAlliesCount("CvPlayer::m_iMinorScienceAlliesCount", m_syncArchive)
	, m_iMinorResourceBonusCount("CvPlayer::m_iMinorResourceBonusCount", m_syncArchive)
	, m_iAbleToAnnexCityStatesCount("CvPlayer::m_iAbleToAnnexCityStatesCount", m_syncArchive)
	, m_iOnlyTradeSameIdeology("CvPlayer::m_iOnlyTradeSameIdeology", m_syncArchive)
	, m_iFreeSpecialist("CvPlayer::m_iFreeSpecialist", m_syncArchive)
	, m_iCultureBombTimer("CvPlayer::m_iCultureBombTimer", m_syncArchive)
	, m_iConversionTimer("CvPlayer::m_iConversionTimer", m_syncArchive)
	, m_iCapitalCityID("CvPlayer::m_iCapitalCityID", m_syncArchive)
	, m_iCitiesLost("CvPlayer::m_iCitiesLost", m_syncArchive)
	, m_iMilitaryRating("CvPlayer::m_iMilitaryRating", m_syncArchive)
	, m_iMilitaryMight("CvPlayer::m_iMilitaryMight", m_syncArchive)
	, m_iEconomicMight("CvPlayer::m_iEconomicMight", m_syncArchive)
	, m_iProductionMight("CvPlayer::m_iProductionMight", m_syncArchive)
	, m_iTurnSliceMightRecomputed("CvPlayer::m_iTurnSliceMightRecomputed", m_syncArchive)
	, m_iNewCityExtraPopulation("CvPlayer::m_iNewCityExtraPopulation", m_syncArchive)
	, m_iFreeFoodBox("CvPlayer::m_iFreeFoodBox", m_syncArchive)
	, m_iScenarioScore1("CvPlayer::m_iScenarioScore1", m_syncArchive)
	, m_iScenarioScore2("CvPlayer::m_iScenarioScore2", m_syncArchive)
	, m_iScenarioScore3("CvPlayer::m_iScenarioScore3", m_syncArchive)
	, m_iScenarioScore4("CvPlayer::m_iScenarioScore4", m_syncArchive)
	, m_iScoreFromFutureTech("CvPlayer::m_iScoreFromFutureTech", m_syncArchive)
	, m_iCombatExperience("CvPlayer::m_iCombatExperience", m_syncArchive)
	, m_iLifetimeCombatExperience("CvPlayer::m_iLifetimeCombatExperience", m_syncArchive)
	, m_iNavalCombatExperience("CvPlayer::m_iNavalCombatExperience", m_syncArchive)
#if defined(MOD_UNITS_XP_TIMES_100)
	, m_iCombatExperienceTimes100("CvPlayer::m_iCombatExperienceTimes100", m_syncArchive)
	, m_iLifetimeCombatExperienceTimes100("CvPlayer::m_iLifetimeCombatExperienceTimes100", m_syncArchive)
	, m_iNavalCombatExperienceTimes100("CvPlayer::m_iNavalCombatExperienceTimes100", m_syncArchive)
#endif
	, m_iBorderObstacleCount("CvPlayer::m_iBorderObstacleCount", m_syncArchive)
#if defined(HH_MOD_BUILDINGS_FRUITLESS_PILLAGE)
	, m_iBorderGainlessPillageCount("CvPlayer::m_iBorderGainlessPillageCount", m_syncArchive)
#endif
	, m_iPopRushHurryCount("CvPlayer::m_iPopRushHurryCount", m_syncArchive)
	, m_iTotalImprovementsBuilt("CvPlayer::m_iTotalImprovementsBuilt", m_syncArchive)
	, m_iNextOperationID("CvPlayer::m_iNextOperationID", m_syncArchive)
	, m_iCostNextPolicy("CvPlayer::m_iCostNextPolicy", m_syncArchive)
	, m_iNumBuilders("CvPlayer::m_iNumBuilders", m_syncArchive, true)
	, m_iMaxNumBuilders("CvPlayer::m_iMaxNumBuilders", m_syncArchive)
	, m_iCityStrengthMod("CvPlayer::m_iCityStrengthMod", m_syncArchive)
	, m_iCityGrowthMod("CvPlayer::m_iCityGrowthMod", m_syncArchive)
	, m_iCapitalGrowthMod("CvPlayer::m_iCapitalGrowthMod", m_syncArchive)
	, m_iNumPlotsBought("CvPlayer::m_iNumPlotsBought", m_syncArchive)
	, m_iPlotGoldCostMod("CvPlayer::m_iPlotGoldCostMod", m_syncArchive)
	, m_iPlotCultureCostModifier("CvPlayer::m_iPlotCultureCostModifier", m_syncArchive)
	, m_iPlotCultureExponentModifier("CvPlayer::m_iPlotCultureExponentModifier", m_syncArchive)
	, m_iNumCitiesPolicyCostDiscount("CvPlayer::m_iNumCitiesPolicyCostDiscount", m_syncArchive)
	, m_iGarrisonedCityRangeStrikeModifier("CvPlayer::m_iGarrisonedCityRangeStrikeModifier", m_syncArchive)
	, m_iGarrisonFreeMaintenanceCount("CvPlayer::m_iGarrisonFreeMaintenanceCount", m_syncArchive)
	, m_iNumCitiesFreeCultureBuilding("CvPlayer::m_iNumCitiesFreeCultureBuilding", m_syncArchive)
	, m_iNumCitiesFreeFoodBuilding("CvPlayer::m_iNumCitiesFreeFoodBuilding", m_syncArchive)
	, m_iUnitPurchaseCostModifier("CvPlayer::m_iUnitPurchaseCostModifier", m_syncArchive)
	, m_iAllFeatureProduction("CvPlayer::m_iAllFeatureProduction", m_syncArchive)
	, m_iCityDistanceHighwaterMark("CvPlayer::m_iCityDistanceHighwaterMark", m_syncArchive)
	, m_iOriginalCapitalX("CvPlayer::m_iOriginalCapitalX", m_syncArchive)
	, m_iOriginalCapitalY("CvPlayer::m_iOriginalCapitalY", m_syncArchive)
	, m_iHolyCityX("CvPlayer::m_iHolyCityX", m_syncArchive)
	, m_iHolyCityY("CvPlayer::m_iHolyCityY", m_syncArchive)
	, m_iNumWonders("CvPlayer::m_iNumWonders", m_syncArchive)
	, m_iNumPolicies("CvPlayer::m_iNumPolicies", m_syncArchive)
	, m_iNumGreatPeople("CvPlayer::m_iNumGreatPeople", m_syncArchive)
	, m_uiStartTime("CvPlayer::m_uiStartTime", m_syncArchive)  // XXX save these?
	, m_bHasUUPeriod("CvPlayer::m_bHasUUPeriod", m_syncArchive)
	, m_bHasBetrayedMinorCiv("CvPlayer::m_bHasBetrayedMinorCiv", m_syncArchive)
	, m_bAlive("CvPlayer::m_bAlive", m_syncArchive)
	, m_bEverAlive("CvPlayer::m_bEverAlive", m_syncArchive)
	, m_bPotentiallyAlive("CvPlayer::m_bPotentiallyAlive", m_syncArchive)
	, m_bBeingResurrected("CvPlayer::m_bBeingResurrected", m_syncArchive, false, false)
	, m_bTurnActive("CvPlayer::m_bTurnActive", m_syncArchive, false, true)
	, m_bAutoMoves("CvPlayer::m_bAutoMoves", m_syncArchive, false, true)
	, m_bEndTurn("CvPlayer::m_bEndTurn", m_syncArchive, false, true)
	, m_bDynamicTurnsSimultMode("CvPlayer::m_bDynamicTurnsSimultMode", m_syncArchive, true, false)
	, m_bPbemNewTurn("CvPlayer::m_bPbemNewTurn", m_syncArchive)
	, m_bExtendedGame("CvPlayer::m_bExtendedGame", m_syncArchive)
	, m_bFoundedFirstCity("CvPlayer::m_bFoundedFirstCity", m_syncArchive)
	, m_iNumCitiesFounded("CvPlayer::m_iNumCitiesFounded", m_syncArchive)
	, m_bStrike("CvPlayer::m_bStrike", m_syncArchive)
	, m_bCramped("CvPlayer::m_bCramped", m_syncArchive)
	, m_bLostCapital("CvPlayer::m_bLostCapital", m_syncArchive)
	, m_eConqueror("CvPlayer::m_eConqueror", m_syncArchive, NO_PLAYER)
	, m_bLostHolyCity("CvPlayer::m_bLostHolyCity", m_syncArchive)
	, m_eHolyCityConqueror("CvPlayer::m_eHolyCityConqueror", m_syncArchive, NO_PLAYER)
	, m_bHasAdoptedStateReligion("CvPlayer::m_bHasAdoptedStateReligion", m_syncArchive)
	, m_bAlliesGreatPersonBiasApplied("CvPlayer::m_bAlliesGreatPersonBiasApplied", m_syncArchive)
	, m_eID("CvPlayer::m_eID", m_syncArchive)
	, m_ePersonalityType("CvPlayer::m_ePersonalityType", m_syncArchive)
	, m_aiCityYieldChange("CvPlayer::m_aiCityYieldChange", m_syncArchive)
	, m_aiCoastalCityYieldChange("CvPlayer::m_aiCoastalCityYieldChange", m_syncArchive)
	, m_aiCapitalYieldChange("CvPlayer::m_aiCapitalYieldChange", m_syncArchive)
	, m_aiCapitalYieldPerPopChange("CvPlayer::m_aiCapitalYieldPerPopChange", m_syncArchive)
	, m_aiCapitalYieldPerPopChangeEmpire("CvPlayer::m_aiCapitalYieldPerPopChangeEmpire", m_syncArchive)
	, m_aiSeaPlotYield("CvPlayer::m_aiSeaPlotYield", m_syncArchive)
	, m_aiYieldRateModifier("CvPlayer::m_aiYieldRateModifier", m_syncArchive)
	, m_aiCapitalYieldRateModifier("CvPlayer::m_aiCapitalYieldRateModifier", m_syncArchive)
	, m_aiExtraYieldThreshold("CvPlayer::m_aiExtraYieldThreshold", m_syncArchive)
	, m_aiSpecialistExtraYield("CvPlayer::m_aiSpecialistExtraYield", m_syncArchive)
	, m_aiProximityToPlayer("CvPlayer::m_aiProximityToPlayer", m_syncArchive, true)
	, m_aiResearchAgreementCounter("CvPlayer::m_aiResearchAgreementCounter", m_syncArchive)
	, m_aiIncomingUnitTypes("CvPlayer::m_aiIncomingUnitTypes", m_syncArchive, true)
	, m_aiIncomingUnitCountdowns("CvPlayer::m_aiIncomingUnitCountdowns", m_syncArchive, true)
	, m_aiMinorFriendshipAnchors("CvPlayer::m_aiMinorFriendshipAnchors", m_syncArchive, true)
	, m_aiSiphonLuxuryCount("CvPlayer::m_aiSiphonLuxuryCount", m_syncArchive)
	, m_aiGreatWorkYieldChange("CvPlayer::m_aiGreatWorkYieldChange", m_syncArchive)
	, m_aOptions("CvPlayer::m_aOptions", m_syncArchive, true)
	, m_strReligionKey("CvPlayer::m_strReligionKey", m_syncArchive)
	, m_strScriptData("CvPlayer::m_strScriptData", m_syncArchive)
	, m_paiNumResourceUsed("CvPlayer::m_paiNumResourceUsed", m_syncArchive)
	, m_paiNumResourceTotal("CvPlayer::m_paiNumResourceTotal", m_syncArchive)
	, m_paiResourceGiftedToMinors("CvPlayer::m_paiResourceGiftedToMinors", m_syncArchive)
	, m_paiResourceExport("CvPlayer::m_paiResourceExport", m_syncArchive)
	, m_paiResourceImport("CvPlayer::m_paiResourceImport", m_syncArchive)
	, m_paiResourceFromMinors("CvPlayer::m_paiResourceFromMinors", m_syncArchive)
	, m_paiResourcesSiphoned("CvPlayer::m_paiResourcesSiphoned", m_syncArchive)
	, m_paiImprovementCount("CvPlayer::m_paiImprovementCount", m_syncArchive)
#if defined(MOD_BALANCE_CORE)
	, m_paiTotalImprovementsBuilt("CvPlayer::m_paiTotalImprovementsBuilt", m_syncArchive)
#endif
	, m_paiFreeBuildingCount("CvPlayer::m_paiFreeBuildingCount", m_syncArchive)
	, m_paiFreePromotionCount("CvPlayer::m_paiFreePromotionCount", m_syncArchive)
	, m_paiUnitCombatProductionModifiers("CvPlayer::m_paiUnitCombatProductionModifiers", m_syncArchive)
	, m_paiUnitCombatFreeExperiences("CvPlayer::m_paiUnitCombatFreeExperiences", m_syncArchive)
	, m_paiUnitClassCount("CvPlayer::m_paiUnitClassCount", m_syncArchive, true)
	, m_paiUnitClassMaking("CvPlayer::m_paiUnitClassMaking", m_syncArchive, true)
	, m_paiBuildingClassCount("CvPlayer::m_paiBuildingClassCount", m_syncArchive)
	, m_paiBuildingClassMaking("CvPlayer::m_paiBuildingClassMaking", m_syncArchive, true)
	, m_paiProjectMaking("CvPlayer::m_paiProjectMaking", m_syncArchive)
	, m_paiHurryCount("CvPlayer::m_paiHurryCount", m_syncArchive)
	, m_paiHurryModifier("CvPlayer::m_paiHurryModifier", m_syncArchive)
	, m_pabLoyalMember("CvPlayer::m_pabLoyalMember", m_syncArchive)
	, m_pabGetsScienceFromPlayer("CvPlayer::m_pabGetsScienceFromPlayer", m_syncArchive)
	, m_ppaaiSpecialistExtraYield("CvPlayer::m_ppaaiSpecialistExtraYield", m_syncArchive)
	, m_ppaaiImprovementYieldChange("CvPlayer::m_ppaaiImprovementYieldChange", m_syncArchive)
	, m_ppaaiBuildingClassYieldMod("CvPlayer::m_ppaaiBuildingClassYieldMod", m_syncArchive)
	, m_bEverPoppedGoody("CvPlayer::m_bEverPoppedGoody", m_syncArchive)
	, m_bEverTrainedBuilder("CvPlayer::m_bEverTrainedBuilder", m_syncArchive)
	, m_iCityConnectionHappiness("CvPlayer::m_iCityConnectionHappiness", m_syncArchive)
	, m_iHolyCityID("CvPlayer::m_iHolyCityID", m_syncArchive)
	, m_iTurnsSinceSettledLastCity("CvPlayer::m_iTurnsSinceSettledLastCity", m_syncArchive)
	, m_iNumNaturalWondersDiscoveredInArea("CvPlayer::m_iNumNaturalWondersDiscoveredInArea", m_syncArchive)
	, m_iStrategicResourceMod("CvPlayer::m_iStrategicResourceMod", m_syncArchive)
	, m_iSpecialistCultureChange("CvPlayer::m_iSpecialistCultureChange", m_syncArchive)
	, m_iGreatPeopleSpawnCounter("CvPlayer::m_iGreatPeopleSpawnCounter", m_syncArchive)
	, m_iFreeTechCount("CvPlayer::m_iFreeTechCount", m_syncArchive, true)
	, m_iMedianTechPercentage("CvPlayer::m_iMedianTechPercentage", m_syncArchive, 50)
	, m_iNumFreePolicies("CvPlayer::m_iNumFreePolicies", m_syncArchive)
	, m_iNumFreePoliciesEver("CvPlayer::m_iNumFreePoliciesEver", m_syncArchive)
	, m_iNumFreeTenets("CvPlayer::m_iNumFreeTenets", m_syncArchive)
	, m_iMaxEffectiveCities("CvPlayer::m_iMaxEffectiveCities", m_syncArchive, 1)
	, m_iLastSliceMoved("CvPlayer::m_iLastSliceMoved", m_syncArchive)
	, m_eEndTurnBlockingType(NO_ENDTURN_BLOCKING_TYPE)
	, m_iEndTurnBlockingNotificationIndex(0)
	, m_activeWaitingForEndTurnMessage(false)
	, m_endTurnBusyUnitUpdatesLeft(0)
	, m_lastGameTurnInitialAIProcessed(-1)
	, m_iNumFreeGreatPeople("CvPlayer::m_iNumFreeGreatPeople", m_syncArchive)
	, m_iNumMayaBoosts("CvPlayer::m_iNumMayaBoosts", m_syncArchive)
	, m_iNumFaithGreatPeople("CvPlayer::m_iNumFaithGreatPeople", m_syncArchive)
	, m_iNumArchaeologyChoices("CvPlayer::m_iNumArchaeologyChoices", m_syncArchive)
	, m_eFaithPurchaseType(NO_AUTOMATIC_FAITH_PURCHASE)
	, m_iFaithPurchaseIndex("CvPlayer::m_iFaithPurchaseIndex", m_syncArchive)
	, m_bProcessedAutoMoves(false)
	, m_kPlayerAchievements(*this)
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	, m_aiDomainDiversity("CvPlayer::m_aiDomainDiversity", m_syncArchive)
	, m_aiCityYieldModFromMonopoly("CvPlayer::m_aiCityYieldModFromMonopoly", m_syncArchive)
	, m_iUnhappiness("CvPlayer::m_iUnhappiness", m_syncArchive)
	, m_iHappinessTotal("CvPlayer::m_iHappinessTotal", m_syncArchive)
	, m_iEmpireNeedsModifierGlobal("CvPlayer::m_iEmpireNeedsModifierGlobal", m_syncArchive)
	, m_iChangePovertyUnhappinessGlobal("CvPlayer::m_iChangePovertyUnhappinessGlobal", m_syncArchive)
	, m_iChangeDefenseUnhappinessGlobal("CvPlayer::m_iChangeDefenseUnhappinessGlobal", m_syncArchive)
	, m_iChangeUnculturedUnhappinessGlobal("CvPlayer::m_iChangeUnculturedUnhappinessGlobal", m_syncArchive)
	, m_iChangeIlliteracyUnhappinessGlobal("CvPlayer::m_iChangeIlliteracyUnhappinessGlobal", m_syncArchive)
	, m_iChangeMinorityUnhappinessGlobal("CvPlayer::m_iChangeMinorityUnhappinessGlobal", m_syncArchive)
	, m_iLandmarksTourismPercentGlobal("CvPlayer::m_iLandmarksTourismPercentGlobal", m_syncArchive)
	, m_iGreatWorksTourismModifierGlobal("CvPlayer::m_iGreatWorksTourismModifierGlobal", m_syncArchive)
	, m_bAllowsProductionTradeRoutesGlobal("CvPlayer::m_bAllowsProductionTradeRoutesGlobal", m_syncArchive)
	, m_bAllowsFoodTradeRoutesGlobal("CvPlayer::m_bAllowsFoodTradeRoutesGlobal", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE)
	, m_iCenterOfMassX("CvPlayer::m_iCenterOfMassX", m_syncArchive)
	, m_iCenterOfMassY("CvPlayer::m_iCenterOfMassY", m_syncArchive)
	, m_iReferenceFoundValue("CvPlayer::m_iReferenceFoundValue", m_syncArchive)
	, m_iReformationFollowerReduction("CvPlayer::m_iReformationFollowerReduction", m_syncArchive)
	, m_bIsReformation("CvPlayer::m_bIsReformation", m_syncArchive)
	, m_iSupplyFreeUnits("CvPlayer::m_iFreeUnits", m_syncArchive)
	, m_viInstantYieldsTotal("CvPlayer::m_viInstantYieldsTotal", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE_POLICIES)
	, m_iHappinessPerXPopulationGlobal("CvPlayer::m_iHappinessPerXPopulationGlobal", m_syncArchive)
	, m_iIdeologyPoint("CvPlayer::m_iIdeologyPoint", m_syncArchive)
	, m_iNoXPLossUnitPurchase("CvPlayer::m_iNoXPLossUnitPurchase", m_syncArchive)
	, m_iXCSAlliesLowersPolicyNeedWonders("CvPlayer::m_iXCSAlliesLowersPolicyNeedWonders", m_syncArchive)
	, m_iHappinessFromMinorCivs("CvPlayer::m_iHappinessFromMinorCivs", m_syncArchive)
	, m_iPositiveWarScoreTourismMod("CvPlayer::m_iPositiveWarScoreTourismMod", m_syncArchive)
	, m_iIsNoCSDecayAtWar("CvPlayer::m_iIsNoCSDecayAtWar", m_syncArchive)
	, m_iCanBullyFriendlyCS("CvPlayer::m_iCanBullyFriendlyCS", m_syncArchive)
	, m_iBullyGlobalCSReduction("CvPlayer::m_iBullyGlobalCSReduction", m_syncArchive)
#endif
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	, m_iIsVassalsNoRebel("CvPlayer::m_iIsVassalsNoRebel", m_syncArchive)
	, m_iVassalCSBonusModifier("CvPlayer::m_iVassalCSBonusModifier", m_syncArchive)
#endif
#if defined(MOD_RELIGION_CONVERSION_MODIFIERS)
	, m_iConversionModifier("CvPlayer::m_iConversionModifier", m_syncArchive)
#endif
#if defined(MOD_DIPLOMACY_CITYSTATES)
	, m_iImprovementLeagueVotes("CvPlayer::m_iImprovementLeagueVotes", m_syncArchive)
	, m_iFaithToVotes("CvPlayer::m_iFaithToVotes", m_syncArchive)
	, m_iCapitalsToVotes("CvPlayer::m_iCapitalsToVotes", m_syncArchive)
	, m_iDoFToVotes("CvPlayer::m_iDoFToVotes", m_syncArchive)
	, m_iRAToVotes("CvPlayer::m_iRAToVotes", m_syncArchive)
	, m_iDefensePactsToVotes("CvPlayer::m_iDefensePactsToVotes", m_syncArchive)
	, m_iGPExpendInfluence("CvPlayer::m_iGPExpendInfluence", m_syncArchive)
	, m_bIsLeagueAid("CvPlayer::m_bIsLeagueAid", m_syncArchive)
	, m_bIsLeagueScholar("CvPlayer::m_bIsLeagueScholar", m_syncArchive)
	, m_bIsLeagueArt("CvPlayer::m_bIsLeagueArt", m_syncArchive)
	, m_iScienceRateFromLeague("CvPlayer::m_iScienceRateFromLeague", m_syncArchive)
	, m_iScienceRateFromLeagueAid("CvPlayer::m_iScienceRateFromLeagueAid", m_syncArchive)
	, m_iLeagueCultureCityModifier("CvPlayer::m_iLeagueCultureCityModifier", m_syncArchive)
#endif
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
	, m_iProductionBonusTurnsConquest("CvPlayer::m_iProductionBonusTurnsConquest", m_syncArchive)
	, m_iCultureBonusTurnsConquest("CvPlayer::m_iCultureBonusTurnsConquest", m_syncArchive)
	, m_iFreeGreatPeopleCreated("CvPlayer::m_iFreeGreatPeopleCreated", m_syncArchive)
	, m_iFreeGreatGeneralsCreated("CvPlayer::m_iFreeGreatGeneralsCreated", m_syncArchive)
	, m_iFreeGreatAdmiralsCreated("CvPlayer::m_iFreeGreatAdmiralsCreated", m_syncArchive)
#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
	, m_iFreeGreatMerchantsCreated("CvPlayer::m_iFreeGreatMerchantsCreated", m_syncArchive)
	, m_iFreeGreatScientistsCreated("CvPlayer::m_iFreeGreatScientistsCreated", m_syncArchive)
	, m_iFreeGreatEngineersCreated("CvPlayer::m_iFreeGreatEngineersCreated", m_syncArchive)
#endif
	, m_iFreeGreatWritersCreated("CvPlayer::m_iFreeGreatWritersCreated", m_syncArchive)
	, m_iFreeGreatArtistsCreated("CvPlayer::m_iFreeGreatArtistsCreated", m_syncArchive)
	, m_iFreeGreatMusiciansCreated("CvPlayer::m_iFreeGreatMusiciansCreated", m_syncArchive)
#if defined(MOD_DIPLOMACY_CITYSTATES)
	, m_iFreeGreatDiplomatsCreated("CvPlayer::m_iFreeGreatDiplomatsCreated", m_syncArchive)
#endif
#endif
#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
	, m_iGPExtra1Created("CvPlayer::m_iGPExtra1Created", m_syncArchive)
	, m_iGPExtra2Created("CvPlayer::m_iGPExtra2Created", m_syncArchive)
	, m_iGPExtra3Created("CvPlayer::m_iGPExtra3Created", m_syncArchive)
	, m_iGPExtra4Created("CvPlayer::m_iGPExtra4Created", m_syncArchive)
	, m_iGPExtra5Created("CvPlayer::m_iGPExtra5Created", m_syncArchive)
	, m_iGPExtra1FromFaith("CvPlayer::m_iGPExtra1FromFaith", m_syncArchive)
	, m_iGPExtra2FromFaith("CvPlayer::m_iGPExtra2FromFaith", m_syncArchive)
	, m_iGPExtra3FromFaith("CvPlayer::m_iGPExtra3FromFaith", m_syncArchive)
	, m_iGPExtra4FromFaith("CvPlayer::m_iGPExtra4FromFaith", m_syncArchive)
	, m_iGPExtra5FromFaith("CvPlayer::m_iGPExtra5FromFaith", m_syncArchive)
	, m_iFreeGPExtra1Created("CvPlayer::m_iFreeGPExtra1Created", m_syncArchive)
	, m_iFreeGPExtra2Created("CvPlayer::m_iFreeGPExtra2Created", m_syncArchive)
	, m_iFreeGPExtra3Created("CvPlayer::m_iFreeGPExtra3Created", m_syncArchive)
	, m_iFreeGPExtra4Created("CvPlayer::m_iFreeGPExtra4Created", m_syncArchive)
	, m_iFreeGPExtra5Created("CvPlayer::m_iFreeGPExtra5Created", m_syncArchive)
	, m_iGreatMerchantsCreated("CvPlayer::m_iGreatMerchantsCreated", m_syncArchive)
	, m_iGreatScientistsCreated("CvPlayer::m_iGreatScientistsCreated", m_syncArchive)
	, m_iGreatEngineersCreated("CvPlayer::m_iGreatEngineersCreated", m_syncArchive)
#endif
#if defined(MOD_DIPLOMACY_CITYSTATES)
	, m_iGreatDiplomatsCreated("CvPlayer::m_iGreatDiplomatsCreated", m_syncArchive)
	, m_iDiplomatsFromFaith("CvPlayer::m_iDiplomatsFromFaith", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE)
	, m_iHalfSpecialistFoodCapitalCount("CvPlayer::m_iHalfSpecialistFoodCapitalCount", m_syncArchive)
	, m_iTradeRouteLandDistanceModifier("CvPlayer::m_iTradeRouteLandDistanceModifier", m_syncArchive)
	, m_iTradeRouteSeaDistanceModifier("CvPlayer::m_iTradeRouteSeaDistanceModifier", m_syncArchive)
	, m_bNullifyInfluenceModifier("CvPlayer::m_bNullifyInfluenceModifier", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE)
	, m_aistrInstantYield("CvPlayer::m_aistrInstantYield", m_syncArchive)
	, m_aistrInstantGreatPersonProgress()
	, m_iJFDCurrency("CvPlayer::m_iJFDCurrency", m_syncArchive)
	, m_iJFDProsperity("CvPlayer::m_iJFDProsperity", m_syncArchive)
	, m_strJFDCurrencyName("CvPlayer::m_strJFDCurrencyName", m_syncArchive)
	, m_strJFDLegislatureName("CvPlayer::m_strJFDLegislatureName", m_syncArchive)
	, m_strJFDPoliticKey("CvPlayer::m_strJFDPoliticKey", m_syncArchive)
	, m_iJFDPoliticLeader("CvPlayer::m_iJFDPoliticLeader", m_syncArchive)
	, m_iJFDSovereignty("CvPlayer::m_iJFDSovereignty", m_syncArchive)
	, m_iJFDGovernment("CvPlayer::m_iJFDGovernment", m_syncArchive)
	, m_iJFDReformCooldown("CvPlayer::m_iJFDReformCooldown", m_syncArchive)
	, m_iJFDGovernmentCooldown("CvPlayer::m_iJFDGovernmentCooldown", m_syncArchive)
	, m_iJFDReformCooldownRate("CvPlayer::m_iJFDReformCooldownRate", m_syncArchive)
	, m_iJFDGovernmentCooldownRate("CvPlayer::m_iJFDGovernmentCooldownRate", m_syncArchive)
	, m_iJFDPiety("CvPlayer::m_iJFDPiety", m_syncArchive)
	, m_iJFDPietyRate("CvPlayer::m_iJFDPietyRate", m_syncArchive)
	, m_iJFDConversionTurn("CvPlayer::m_iJFDConversionTurn", m_syncArchive)
	, m_bJFDSecularized("CvPlayer::m_bJFDSecularized", m_syncArchive)
	, m_abActiveContract("CvPlayer::m_abActiveContract", m_syncArchive)
	, m_iUpgradeCSVassalTerritory("CvPlayer::m_iUpgradeCSVassalTerritory", m_syncArchive)
	, m_iArchaeologicalDigTourism("CvPlayer::m_iArchaeologicalDigTourism", m_syncArchive)
	, m_iGoldenAgeTourism("CvPlayer::m_iGoldenAgeTourism", m_syncArchive)
	, m_iExtraCultureandScienceTradeRoutes("CvPlayer::m_iExtraCultureandScienceTradeRoutes", m_syncArchive)
	, m_iRazingSpeedBonus("CvPlayer::m_iRazingSpeedBonus", m_syncArchive)
	, m_iNoPartisans("CvPlayer::m_iNoPartisans", m_syncArchive)
	, m_iSpawnCooldown("CvPlayer::m_iSpawnCooldown", m_syncArchive)
	, m_iAbleToMarryCityStatesCount("CvPlayer::m_iAbleToMarryCityStatesCount", m_syncArchive)
	, m_bTradeRoutesInvulnerable("CvPlayer::m_bTradeRoutesInvulnerable", m_syncArchive)
	, m_iTRSpeedBoost("CvPlayer::m_iTRSpeedBoost", m_syncArchive)
	, m_iVotesPerGPT("CvPlayer::m_iVotesPerGPT", m_syncArchive)
	, m_iTRVisionBoost("CvPlayer::m_iTRVisionBoost", m_syncArchive)
	, m_iEventTourism("CvPlayer::m_iEventTourism", m_syncArchive)
	, m_iEventTourismCS("CvPlayer::m_iEventTourismCS", m_syncArchive)
	, m_iNumHistoricEvent("CvPlayer::m_iNumHistoricEvent", m_syncArchive)
	, m_iSingleVotes("CvPlayer::m_iSingleVotes", m_syncArchive)
	, m_iMonopolyModFlat("CvPlayer::m_iMonopolyModFlat", m_syncArchive)
	, m_iMonopolyModPercent("CvPlayer::m_iMonopolyModPercent", m_syncArchive)
	, m_iCachedValueOfPeaceWithHuman("CvPlayer::m_iCachedValueOfPeaceWithHuman", m_syncArchive)
	, m_iFaithPurchaseCooldown("CvPlayer::m_iFaithPurchaseCooldown", m_syncArchive)
	, m_iCSAllies("CvPlayer::m_iCSAllies", m_syncArchive)
	, m_iCSFriends("CvPlayer::m_iCSFriends", m_syncArchive)
	, m_iCitiesNeedingTerrainImprovements("CvPlayer::m_iCitiesNeedingTerrainImprovements", m_syncArchive)
	, m_aiBestMilitaryCombatClassCity("CvPlayer::m_aiBestMilitaryCombatClassCity", m_syncArchive)
	, m_aiBestMilitaryDomainCity("CvPlayer::m_aiBestMilitaryDomainCity", m_syncArchive)
	, m_aiEventChoiceDuration("CvPlayer::m_aiEventChoiceDuration", m_syncArchive)
	, m_aiEventIncrement("CvPlayer::m_aiEventIncrement", m_syncArchive)
	, m_abEventActive("CvPlayer::m_abEventActive", m_syncArchive)
	, m_abEventChoiceActive("CvPlayer::m_abEventChoiceActive", m_syncArchive)
	, m_aiEventCooldown("CvPlayer::m_aiEventCooldown", m_syncArchive)
	, m_abEventChoiceFired("CvPlayer::m_abEventChoiceFired", m_syncArchive)
	, m_abEventFired("CvPlayer::m_abEventFired", m_syncArchive)
	, m_iPlayerEventCooldown("CvPlayer::m_iPlayerEventCooldown", m_syncArchive)
	, m_abNWOwned("CvPlayer::m_abNWOwned", m_syncArchive)
	, m_paiUnitClassProductionModifiers("CvPlayer::m_paiUnitClassProductionModifiers", m_syncArchive)
	, m_iExtraSupplyPerPopulation("CvPlayer::m_iExtraSupplyPerPopulation", m_syncArchive)
	, m_iCitySupplyFlatGlobal("CvPlayer::m_iCitySupplyFlatGlobal", m_syncArchive)
	, m_iMissionaryExtraStrength("CvPlayer::m_iMissionaryExtraStrength", m_syncArchive)
	, m_piDomainFreeExperience()
#endif
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	, m_iPovertyUnhappinessMod("CvPlayer::m_iPovertyUnhappinessMod", m_syncArchive)
	, m_iDefenseUnhappinessMod("CvPlayer::m_iDefenseUnhappinessMod", m_syncArchive)
	, m_iUnculturedUnhappinessMod("CvPlayer::m_iUnculturedUnhappinessMod", m_syncArchive)
	, m_iIlliteracyUnhappinessMod("CvPlayer::m_iIlliteracyUnhappinessMod", m_syncArchive)
	, m_iMinorityUnhappinessMod("CvPlayer::m_iMinorityUnhappinessMod", m_syncArchive)
	, m_iPovertyUnhappinessModCapital("CvPlayer::m_iPovertyUnhappinessModCapital", m_syncArchive)
	, m_iDefenseUnhappinessModCapital("CvPlayer::m_iDefenseUnhappinessModCapital", m_syncArchive)
	, m_iUnculturedUnhappinessModCapital("CvPlayer::m_iUnculturedUnhappinessModCapital", m_syncArchive)
	, m_iIlliteracyUnhappinessModCapital("CvPlayer::m_iIlliteracyUnhappinessModCapital", m_syncArchive)
	, m_iMinorityUnhappinessModCapital("CvPlayer::m_iMinorityUnhappinessModCapital", m_syncArchive)
	, m_iPuppetUnhappinessMod("CvPlayer::m_iPuppetUnhappinessMod", m_syncArchive)
	, m_iNoUnhappfromXSpecialists("CvPlayer::m_iNoUnhappfromXSpecialists", m_syncArchive)
	, m_iHappfromXSpecialists("CvPlayer::m_iHappfromXSpecialists", m_syncArchive)
	, m_iNoUnhappfromXSpecialistsCapital("CvPlayer::m_iNoUnhappfromXSpecialistsCapital", m_syncArchive)
	, m_iSpecialistFoodChange("CvPlayer::m_iSpecialistFoodChange", m_syncArchive)
	, m_iWarWearinessModifier("CvPlayer::m_iWarWearinessModifier", m_syncArchive)
	, m_iWarScoreModifier("CvPlayer::m_iWarScoreModifier", m_syncArchive)
#endif
#if defined(MOD_TRAITS_CITY_WORKING) || defined(MOD_BUILDINGS_CITY_WORKING) || defined(MOD_POLICIES_CITY_WORKING) || defined(MOD_TECHS_CITY_WORKING)
	, m_iCityWorkingChange("CvPlayer::m_iCityWorkingChange", m_syncArchive)
#endif
#if defined(MOD_TRAITS_CITY_AUTOMATON_WORKERS) || defined(MOD_BUILDINGS_CITY_AUTOMATON_WORKERS) || defined(MOD_POLICIES_CITY_AUTOMATON_WORKERS) || defined(MOD_TECHS_CITY_AUTOMATON_WORKERS)
	, m_iCityAutomatonWorkersChange("CvPlayer::m_iCityAutomatonWorkersChange", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE_POLICIES)
	, m_paiJFDPoliticPercent("CvPlayer::m_paiJFDPoliticPercent", m_syncArchive)
	, m_paiResourceFromCSAlliances("CvPlayer::m_paiResourceFromCSAlliances", m_syncArchive)
	, m_paiResourceOverValue("CvPlayer::m_paiResourceOverValue", m_syncArchive)
	, m_aiGlobalTourismAlreadyReceived("CvPlayer::m_aiGlobalTourismAlreadyReceived", m_syncArchive)
	, m_aiYieldFromMinors("CvPlayer::m_aiYieldFromMinors", m_syncArchive)
	, m_aiYieldFromBirth("CvPlayer::m_aiYieldFromBirth", m_syncArchive)
	, m_aiYieldFromBirthCapital("CvPlayer::m_aiYieldFromBirthCapital", m_syncArchive)
	, m_aiYieldFromDeath("CvPlayer::m_aiYieldFromDeath", m_syncArchive)
	, m_aiYieldFromPillage("CvPlayer::m_aiYieldFromPillage", m_syncArchive)
	, m_aiYieldFromVictory("CvPlayer::m_aiYieldFromVictory", m_syncArchive)
	, m_aiYieldFromConstruction("CvPlayer::m_aiYieldFromConstruction", m_syncArchive)
	, m_aiYieldFromwonderConstruction("CvPlayer::m_aiYieldFromwonderConstruction", m_syncArchive)
	, m_aiYieldFromTech("CvPlayer::m_aiYieldFromTech", m_syncArchive)
	, m_aiYieldFromBorderGrowth("CvPlayer::m_aiYieldFromBorderGrowth", m_syncArchive)
	, m_aiYieldGPExpend("CvPlayer::m_aiYieldGPExpend", m_syncArchive)
	, m_aiConquerorYield("CvPlayer::m_aiConquerorYield", m_syncArchive)
	, m_aiFounderYield("CvPlayer::m_aiFounderYield", m_syncArchive)
	, m_aiArtifactYieldBonus("CvPlayer::m_aiArtifactYieldBonus", m_syncArchive)
	, m_aiArtYieldBonus("CvPlayer::m_aiArtYieldBonus", m_syncArchive)
	, m_aiMusicYieldBonus("CvPlayer::m_aiMusicYieldBonus", m_syncArchive)
	, m_aiLitYieldBonus("CvPlayer::m_aiLitYieldBonus", m_syncArchive)
	, m_aiFilmYieldBonus("CvPlayer::m_aiFilmYieldBonus", m_syncArchive)
	, m_aiRelicYieldBonus("CvPlayer::m_aiRelicYieldBonus", m_syncArchive)
	, m_aiReligionYieldRateModifier("CvPlayer::m_aiReligionYieldRateModifier", m_syncArchive)
	, m_aiGoldenAgeYieldMod("CvPlayer::m_aiGoldenAgeYieldMod", m_syncArchive)
	, m_aiYieldFromNonSpecialistCitizens("CvPlayer::m_aiYieldFromNonSpecialistCitizens", m_syncArchive)
	, m_aiYieldModifierFromGreatWorks("CvPlayer::m_aiYieldModifierFromGreatWorks", m_syncArchive)
	, m_aiYieldModifierFromActiveSpies("CvPlayer::m_aiYieldModifierFromActiveSpies", m_syncArchive)
	, m_aiYieldFromDelegateCount("CvPlayer::m_aiYieldFromDelegateCount", m_syncArchive)
	, m_paiBuildingClassCulture("CvPlayer::m_paiBuildingClassCulture", m_syncArchive)
	, m_aiDomainFreeExperiencePerGreatWorkGlobal("CvPlayer::m_aiDomainFreeExperiencePerGreatWorkGlobal", m_syncArchive)
	, m_iGarrisonsOccupiedUnhapppinessMod("CvPlayer::m_iGarrisonsOccupiedUnhapppinessMod", m_syncArchive)
	, m_iXPopulationConscription("CvPlayer::m_iXPopulationConscription", m_syncArchive)
	, m_iExtraMoves("CvPlayer::m_iExtraMoves", m_syncArchive)
	, m_iNoUnhappinessExpansion("CvPlayer::m_iNoUnhappinessExpansion", m_syncArchive)
	, m_iNoUnhappyIsolation("CvPlayer::m_iNoUnhappyIsolation", m_syncArchive)
	, m_iDoubleBorderGA("CvPlayer::m_iDoubleBorderGA", m_syncArchive)
	, m_iIncreasedQuestInfluence("CvPlayer::m_iIncreasedQuestInfluence", m_syncArchive)
	, m_iCultureBombBoost("CvPlayer::m_iCultureBombBoost", m_syncArchive)
	, m_iPuppetProdMod("CvPlayer::m_iPuppetProdMod", m_syncArchive)
	, m_iOccupiedProdMod("CvPlayer::m_iOccupiedProdMod", m_syncArchive)
	, m_iGoldInternalTrade("CvPlayer::m_iGoldInternalTrade", m_syncArchive)
	, m_iFreeWCVotes("CvPlayer::m_iFreeWCVotes", m_syncArchive)
	, m_iInfluenceGPExpend("CvPlayer::m_iInfluenceGPExpend", m_syncArchive)
	, m_iFreeTradeRoute("CvPlayer::m_iFreeTradeRoute", m_syncArchive)
	, m_iFreeSpy("CvPlayer::m_iFreeSpy", m_syncArchive)
	, m_iReligionDistance("CvPlayer::m_iReligionDistance", m_syncArchive)
	, m_iPressureMod("CvPlayer::m_iPressureMod", m_syncArchive)
	, m_iTradeReligionModifier("CvPlayer::m_iTradeReligionModifier", m_syncArchive)
	, m_iCityStateCombatModifier("CvPlayer::m_iCityStateCombatModifier", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE_SPIES)
	, m_bAdvancedActionsEnabled("CvPlayer::m_bAdvancedActionsEnabled", m_syncArchive)
	, m_iAdvancedActionGold("CvPlayer::m_iAdvancedActionGold", m_syncArchive)
	, m_iAdvancedActionScience("CvPlayer::m_iAdvancedActionScience", m_syncArchive)
	, m_iAdvancedActionUnrest("CvPlayer::m_iAdvancedActionUnrest", m_syncArchive)
	, m_iAdvancedActionRebellion("CvPlayer::m_iAdvancedActionRebellion", m_syncArchive)
	, m_iAdvancedActionGP("CvPlayer::m_iAdvancedActionGP", m_syncArchive)
	, m_iAdvancedActionUnit("CvPlayer::m_iAdvancedActionUnit", m_syncArchive)
	, m_iAdvancedActionWonder("CvPlayer::m_iAdvancedActionWonder", m_syncArchive)
	, m_iAdvancedActionBuilding("CvPlayer::m_iAdvancedActionBuilding", m_syncArchive)
	, m_iCannotFailSpies("CvPlayer::m_iCannotFailSpies", m_syncArchive)
	, m_iMaxAirUnits("CvPlayer::m_iMaxAirUnits", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE_BUILDING_INVESTMENTS)
	, m_iInvestmentModifier("CvPlayer::m_iInvestmentModifier", m_syncArchive)
	, m_iMissionInfluenceModifier("CvPlayer::m_iMissionInfluenceModifier", m_syncArchive)
	, m_iHappinessPerActiveTradeRoute("CvPlayer::m_iHappinessPerActiveTradeRoute", m_syncArchive)
	, m_iCSResourcesCountMonopolies("CvPlayer::m_iCSResourcesCountMonopolies", m_syncArchive)
	, m_iConquestPerEraBuildingProductionMod("CvPlayer::m_iConquestPerEraBuildingProductionMod", m_syncArchive)
	, m_iAdmiralLuxuryBonus("CvPlayer::m_iAdmiralLuxuryBonus", m_syncArchive)
	, m_iPuppetYieldPenaltyMod("CvPlayer::m_iPuppetYieldPenaltyMod", m_syncArchive)
	, m_iNeedsModifierFromAirUnits("CvPlayer::m_iNeedsModifierFromAirUnits", m_syncArchive)
	, m_iFlatDefenseFromAirUnits("CvPlayer::m_iFlatDefenseFromAirUnits", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE)
	, m_paiNumCitiesFreeChosenBuilding("CvPlayer::m_paiNumCitiesFreeChosenBuilding", m_syncArchive)
	, m_pabFreeChosenBuildingNewCity("CvPlayer::m_pabFreeChosenBuildingNewCity", m_syncArchive)
	, m_pabAllCityFreeBuilding("CvPlayer::m_pabAllCityFreeBuilding", m_syncArchive)
	, m_pabNewFoundCityFreeUnit("CvPlayer::m_pabNewFoundCityFreeUnit", m_syncArchive)
	, m_pabNewFoundCityFreeBuilding("CvPlayer::m_pabNewFoundCityFreeBuilding", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	, m_pabHasGlobalMonopoly("CvPlayer::m_pabHasGlobalMonopoly", m_syncArchive)
	, m_pabHasStrategicMonopoly("CvPlayer::m_pabHasStrategicMonopoly", m_syncArchive)
#endif
#if defined(MOD_API_UNIFIED_YIELDS)
	, m_piGoldenAgeGreatPersonRateModifier(NULL)
	, m_piYieldFromKills(NULL)
	, m_piYieldFromBarbarianKills(NULL)
	, m_piYieldChangeTradeRoute(NULL)
	, m_piYieldChangesNaturalWonder(NULL)
	, m_piYieldChangesPerReligion(NULL)
	, m_piYieldChangeWorldWonder(NULL)
	, m_piYieldFromMinorDemand(NULL)
	, m_piYieldFromWLTKD(NULL)
	, m_piCityFeatures(NULL)
	, m_piNumBuildings(NULL)
	, m_piNumBuildingsInPuppets(NULL)
	, m_ppiBuildingClassYieldChange("CvPlayer::m_ppiBuildingClassYieldChange", m_syncArchive)
#endif
#if defined(MOD_API_UNIFIED_YIELDS) && defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	, m_ppiSpecificGreatPersonRateModifierFromMonopoly()
#endif
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	, m_bVassalLevy("CvPlayer::m_bVassalLevy", m_syncArchive)
	, m_iVassalGoldMaintenanceMod("CvPlayer::m_iVassalGoldMaintenanceMod", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE_SETTLER)
	, m_iFoundValueOfCapital("CvPlayer::m_iFoundValueOfCapital", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE_MILITARY)
	, m_iFractionOriginalCapitalsUnderControl("CvPlayer::m_iFractionOriginalCapitalsUnderControl", m_syncArchive)
	, m_iAvgUnitExp100("CvPlayer::m_iAvgUnitExp100", m_syncArchive)
#endif
#if defined(MOD_BATTLE_ROYALE)
	, m_iNumMilitarySeaUnits("CvPlayer::m_iNumMilitarySeaUnits", m_syncArchive)
	, m_iNumMilitaryAirUnits("CvPlayer::m_iNumMilitaryAirUnits", m_syncArchive)
	, m_iNumMilitaryLandUnits("CvPlayer::m_iNumMilitaryLandUnits", m_syncArchive)
	, m_iMilitarySeaMight("CvPlayer::m_iMilitarySeaMight", m_syncArchive)
	, m_iMilitaryAirMight("CvPlayer::m_iMilitaryAirMight", m_syncArchive)
	, m_iMilitaryLandMight("CvPlayer::m_iMilitaryLandMight", m_syncArchive)
#endif
{
	m_pPlayerPolicies = FNEW(CvPlayerPolicies, c_eCiv5GameplayDLL, 0);
	m_pEconomicAI = FNEW(CvEconomicAI, c_eCiv5GameplayDLL, 0);
	m_pMilitaryAI = FNEW(CvMilitaryAI, c_eCiv5GameplayDLL, 0);
	m_pCitySpecializationAI = FNEW(CvCitySpecializationAI, c_eCiv5GameplayDLL, 0);
	m_pWonderProductionAI = FNEW(CvWonderProductionAI(this, GC.GetGameBuildings()), c_eCiv5GameplayDLL, 0);
	m_pGrandStrategyAI = FNEW(CvGrandStrategyAI, c_eCiv5GameplayDLL, 0);
	m_pDiplomacyAI = FNEW(CvDiplomacyAI, c_eCiv5GameplayDLL, 0);
	m_pReligions = FNEW(CvPlayerReligions, c_eCiv5GameplayDLL, 0);
	m_pReligionAI = FNEW(CvReligionAI, c_eCiv5GameplayDLL, 0);
#if defined(MOD_BALANCE_CORE)
	m_pCorporations = FNEW(CvPlayerCorporations, c_eCiv5GameplayDLL, 0);
	m_pContracts = FNEW(CvPlayerContracts, c_eCiv5GameplayDLL, 0);
#endif
	m_pPlayerTechs = FNEW(CvPlayerTechs, c_eCiv5GameplayDLL, 0);
	m_pFlavorManager = FNEW(CvFlavorManager, c_eCiv5GameplayDLL, 0);
	m_pTacticalAI = FNEW(CvTacticalAI, c_eCiv5GameplayDLL, 0);
	m_pHomelandAI = FNEW(CvHomelandAI, c_eCiv5GameplayDLL, 0);
	m_pMinorCivAI = FNEW(CvMinorCivAI, c_eCiv5GameplayDLL, 0);
	m_pDealAI = FNEW(CvDealAI, c_eCiv5GameplayDLL, 0);
	m_pBuilderTaskingAI = FNEW(CvBuilderTaskingAI, c_eCiv5GameplayDLL, 0);
	m_pDangerPlots = FNEW(CvDangerPlots, c_eCiv5GameplayDLL, 0);
	m_pCityConnections = FNEW(CvCityConnections, c_eCiv5GameplayDLL, 0);
	m_pTreasury = FNEW(CvTreasury, c_eCiv5GameplayDLL, 0);
	m_pTraits = FNEW(CvPlayerTraits, c_eCiv5GameplayDLL, 0);
	m_pEspionage = FNEW(CvPlayerEspionage, c_eCiv5GameplayDLL, 0);
	m_pEspionageAI = FNEW(CvEspionageAI, c_eCiv5GameplayDLL, 0);
	m_pTrade = FNEW(CvPlayerTrade, c_eCiv5GameplayDLL, 0);
	m_pTradeAI = FNEW(CvTradeAI, c_eCiv5GameplayDLL, 0);
	m_pLeagueAI = FNEW(CvLeagueAI, c_eCiv5GameplayDLL, 0);
	m_pCulture = FNEW(CvPlayerCulture, c_eCiv5GameplayDLL, 0);

	m_pNotifications = NULL;
	m_pDiplomacyRequests = NULL;

	m_iNextOperationID = 0;

	m_aiPlots.clear();
	m_bfEverConqueredBy.ClearAll();

	m_aiGreatWorkYieldChange.clear();
	m_aiSiphonLuxuryCount.clear();

	reset(NO_PLAYER, true);
}
//	--------------------------------------------------------------------------------
CvPlayer::~CvPlayer()
{
#if defined(MOD_BALANCE_CORE) && defined(MOD_UNIT_KILL_STATS)
	if (isMajorCiv() && GC.getAILogging())
		GC.getMap().ExportUnitKillCount(GetID());
#endif

	uninit();

	SAFE_DELETE(m_pDangerPlots);
	SAFE_DELETE(m_pPlayerPolicies);
	SAFE_DELETE(m_pEconomicAI);
	SAFE_DELETE(m_pMilitaryAI);
	SAFE_DELETE(m_pCitySpecializationAI);
	SAFE_DELETE(m_pWonderProductionAI);
	SAFE_DELETE(m_pGrandStrategyAI);
	SAFE_DELETE(m_pDiplomacyAI);
	SAFE_DELETE(m_pReligions);
	SAFE_DELETE(m_pReligionAI);
	SAFE_DELETE(m_pPlayerTechs);
	SAFE_DELETE(m_pFlavorManager);
	SAFE_DELETE(m_pTacticalAI);
	SAFE_DELETE(m_pHomelandAI);
	SAFE_DELETE(m_pMinorCivAI);
	SAFE_DELETE(m_pDealAI);
	SAFE_DELETE(m_pBuilderTaskingAI);
	SAFE_DELETE(m_pCityConnections);
	SAFE_DELETE(m_pNotifications);
	SAFE_DELETE(m_pDiplomacyRequests);
	SAFE_DELETE(m_pTreasury);
	SAFE_DELETE(m_pTraits);
	SAFE_DELETE(m_pEspionage);
	SAFE_DELETE(m_pEspionageAI);
	SAFE_DELETE(m_pTrade);
	SAFE_DELETE(m_pTradeAI);
	SAFE_DELETE(m_pLeagueAI);
#if defined(MOD_BALANCE_CORE)
	SAFE_DELETE(m_pCorporations);
	SAFE_DELETE(m_pContracts);
#endif
}


//	--------------------------------------------------------------------------------
void CvPlayer::init(PlayerTypes eID)
{
	LeaderHeadTypes eBestPersonality;
	int iValue;
	int iBestValue;
	int iI, iJ;

	// only allocate notifications for civs that players can play as
	if(eID < MAX_MAJOR_CIVS)
	{
		if (!m_pNotifications)
			m_pNotifications = FNEW(CvNotifications, c_eCiv5GameplayDLL, 0);
		if (!m_pDiplomacyRequests)
			m_pDiplomacyRequests = FNEW(CvDiplomacyRequests, c_eCiv5GameplayDLL, 0);
	}

	//--------------------------------
	// Init saved data
	reset(eID);

	//--------------------------------
	// Init containers
	m_cities.RemoveAll();

	m_units.RemoveAll();

	m_armyAIs.RemoveAll();

	m_AIOperations.clear();

	//--------------------------------
	// Init non-saved data
	setupGraphical();

	//--------------------------------
	// Init other game data
	CvAssert(getTeam() != NO_TEAM);
	GET_TEAM(getTeam()).changeNumMembers(1);

	PlayerTypes p = GetID();
	SlotStatus s = CvPreGame::slotStatus(p);

#if defined(MOD_BALANCE_CORE)
	if (!GET_TEAM(getTeam()).addPlayer( GetID() ))
		GET_TEAM(getTeam()).changeNumMembers(-1);

	//minors can become free cities...but we have to make sure the UI can know this.
	if (eID >= MAX_MAJOR_CIVS && eID < MAX_CIV_PLAYERS && s == SS_CLOSED && CvPreGame::isMinorCiv(eID))
	{
		m_bPotentiallyAlive = true;
	}
#endif

	
	if((s == SS_TAKEN) || (s == SS_COMPUTER))
	{
		setAlive(true);

		if(GC.getGame().isOption(GAMEOPTION_RANDOM_PERSONALITIES))
		{
			if(!isBarbarian() && !isMinorCiv())
			{
				iBestValue = 0;
				eBestPersonality = NO_LEADER;

				for(iI = 0; iI < GC.getNumLeaderHeadInfos(); iI++)
				{
					if(iI != GC.getBARBARIAN_LEADER() && iI != GC.getMINOR_CIVILIZATION())
					{
						iValue = (1 + GC.getGame().getJonRandNum(10000, "Choosing Personality"));

						for(iJ = 0; iJ < MAX_CIV_PLAYERS; iJ++)
						{
							if(GET_PLAYER((PlayerTypes)iJ).isAlive())
							{
								if(GET_PLAYER((PlayerTypes)iJ).getPersonalityType() == ((LeaderHeadTypes)iI))
								{
									iValue /= 2;
								}
							}
						}

						if(iValue > iBestValue)
						{
							iBestValue = iValue;
							eBestPersonality = ((LeaderHeadTypes)iI);
						}
					}
				}

				if(eBestPersonality != NO_LEADER)
				{
					setPersonalityType(eBestPersonality);
				}
			}
		}

		CvAssert(m_pTraits);
		m_pTraits->InitPlayerTraits();

		// Special handling for the Polynesian trait's overriding of embarked unit graphics
		if(m_pTraits->IsEmbarkedAllWater())
		{
			SetEmbarkedGraphicOverride("ART_DEF_UNIT_U_POLYNESIAN_WAR_CANOE");
		}
		else if(m_pTraits->IsEmbarkedToLandFlatCost())
		{
			SetEmbarkedGraphicOverride("ART_DEF_UNIT_U_DANISH_LONGBOAT");
		}

		changeGoldPerUnitTimes100(GC.getINITIAL_GOLD_PER_UNIT_TIMES_100());

		ChangeMaxNumBuilders(GC.getDEFAULT_MAX_NUM_BUILDERS());

		changeLevelExperienceModifier(GetPlayerTraits()->GetLevelExperienceModifier());
		changeMaxGlobalBuildingProductionModifier(GetPlayerTraits()->GetMaxGlobalBuildingProductionModifier());
		changeMaxTeamBuildingProductionModifier(GetPlayerTraits()->GetMaxTeamBuildingProductionModifier());
		changeMaxPlayerBuildingProductionModifier(GetPlayerTraits()->GetMaxPlayerBuildingProductionModifier());
		ChangePlotGoldCostMod(GetPlayerTraits()->GetPlotBuyCostModifier());
#if defined(MOD_TRAITS_CITY_WORKING)
		ChangeCityWorkingChange(GetPlayerTraits()->GetCityWorkingChange());
#endif
#if defined(MOD_TRAITS_CITY_AUTOMATON_WORKERS)
		ChangeCityAutomatonWorkersChange(GetPlayerTraits()->GetCityAutomatonWorkersChange());
#endif
		ChangePlotCultureCostModifier(GetPlayerTraits()->GetPlotCultureCostModifier());
		GetTreasury()->ChangeCityConnectionTradeRouteGoldChange(GetPlayerTraits()->GetCityConnectionTradeRouteChange());
		changeWonderProductionModifier(GetPlayerTraits()->GetWonderProductionModifier());
		ChangeImprovementGoldMaintenanceMod(GetPlayerTraits()->GetImprovementMaintenanceModifier());

		for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
		{
#if defined(MOD_BUGFIX_MINOR)
			ChangeCityYieldChangeTimes100((YieldTypes)iJ, 100 * GetPlayerTraits()->GetFreeCityYield((YieldTypes)iJ));
#else
			ChangeCityYieldChange((YieldTypes)iJ, 100 * GetPlayerTraits()->GetFreeCityYield((YieldTypes)iJ));
#endif
			changeYieldRateModifier((YieldTypes)iJ, GetPlayerTraits()->GetYieldRateModifier((YieldTypes)iJ));
		}

		recomputeGreatPeopleModifiers();

		for(iI = 0; iI < NUM_YIELD_TYPES; iI++)
		{
			updateExtraYieldThreshold((YieldTypes)iI);
		}
#if defined(MOD_BALANCE_CORE)
		if (GetPlayerTraits()->GetEspionageModifier() != 0)
		{
			ChangeEspionageModifier(GetPlayerTraits()->GetEspionageModifier());
		}
		if(GetPlayerTraits()->GetEventTourismBoost() > 0)
		{
			ChangeEventTourism(GetPlayerTraits()->GetEventTourismBoost());
		}
		if(GetPlayerTraits()->GetStartingSpyRank() > 0)
		{
			ChangeStartingSpyRank(GetPlayerTraits()->GetStartingSpyRank());
		}
		if(GetPlayerTraits()->GetQuestYieldModifier() > 0)
		{
			ChangeIncreasedQuestInfluence(GetPlayerTraits()->GetQuestYieldModifier());
		}
#endif
		const CvCivilizationInfo& playerCivilizationInfo = getCivilizationInfo();
		for(iI = 0; iI < GC.getNumUnitClassInfos(); ++iI)
		{
			const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
			CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
			if(pkUnitClassInfo != NULL)
			{
				const UnitTypes eUnit = ((UnitTypes)(playerCivilizationInfo.getCivilizationUnits(iI)));
				if(NO_UNIT != eUnit)
				{
					CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
#if defined(MOD_BALANCE_CORE_SETTLER_ADVANCED)
					if (pkUnitInfo != NULL && pkUnitInfo->IsFoundLate())
					{
						if (pkUnitInfo->IsFoodProduction())
						{
							setUnitExtraCost(eUnitClass, getNewCityProductionValue());
						}
					}
					else if (pkUnitInfo != NULL && pkUnitInfo->IsFoundMid())
					{
						if (pkUnitInfo->IsFoodProduction())
						{
							setUnitExtraCost(eUnitClass, getNewCityProductionValue());
						}
					}
#endif
					else if(NULL != pkUnitInfo && pkUnitInfo->IsFound())
					{
						setUnitExtraCost(eUnitClass, getNewCityProductionValue());
					}
				}
			}
		}

		BuildingTypes eFreeBuilding = GetPlayerTraits()->GetFreeBuilding();
		if(eFreeBuilding != NO_BUILDING)
		{
#if defined(MOD_BALANCE_CORE)
			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eFreeBuilding);
			if(pkBuildingInfo)
			{
				int iNumBuilding = GetPlayerTraits()->GetNumFreeBuildings();
				if(iNumBuilding > 0)
				{
					ChangeNumCitiesFreeChosenBuilding((BuildingClassTypes)pkBuildingInfo->GetBuildingClassType(), iNumBuilding);
				}
				else
				{
					changeFreeBuildingCount(eFreeBuilding, 1);
				}
			}
#else
					changeFreeBuildingCount(eFreeBuilding, 1);
#endif
		}

		SetGreatGeneralCombatBonus(GC.getGREAT_GENERAL_STRENGTH_MOD());
	}
#if defined(MOD_BALANCE_CORE)
	if(MOD_BALANCE_CORE_SPIES_ADVANCED)
	{
		setAdvancedActionGold(16);
		setAdvancedActionScience(14);
		setAdvancedActionUnrest(6);
		setAdvancedActionRebellion(4);
		setAdvancedActionGP(8);
		setAdvancedActionUnit(10);
		setAdvancedActionWonder(2);
		setAdvancedActionBuilding(12);
	}
	GET_TEAM(getTeam()).DoUpdateBestRoute();
#endif

	m_aiPlots.clear();
	m_bfEverConqueredBy.ClearAll();

	AI_init();
}


//	--------------------------------------------------------------------------------
void CvPlayer::uninit()
{
	m_units.RemoveAll();
	m_cities.RemoveAll();

	m_paiNumResourceUsed.clear();
	m_paiNumResourceTotal.clear();
	m_paiResourceGiftedToMinors.clear();
	m_paiResourceExport.clear();
	m_paiResourceImport.clear();
	m_paiResourceFromMinors.clear();
	m_paiResourcesSiphoned.clear();
	m_paiImprovementCount.clear();
#if defined(MOD_BALANCE_CORE)
	m_paiTotalImprovementsBuilt.clear();
#endif
	m_paiFreeBuildingCount.clear();
	m_paiFreePromotionCount.clear();
	m_paiUnitCombatProductionModifiers.clear();
	m_paiUnitCombatFreeExperiences.clear();
	m_paiUnitClassCount.clear();
	m_paiUnitClassMaking.clear();
	m_paiBuildingClassCount.clear();
	m_paiBuildingClassMaking.clear();
	m_paiProjectMaking.clear();
	m_paiHurryCount.clear();
	m_paiHurryModifier.clear();
#if defined(MOD_BALANCE_CORE)
	m_paiNumCitiesFreeChosenBuilding.clear();
	m_aistrInstantYield.clear();
	m_aistrInstantGreatPersonProgress.clear();
	m_pabFreeChosenBuildingNewCity.clear();
	m_pabAllCityFreeBuilding.clear();
	m_pabNewFoundCityFreeUnit.clear();
	m_pabNewFoundCityFreeBuilding.clear();
#endif
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	m_pabHasGlobalMonopoly.clear();
	m_pabHasStrategicMonopoly.clear();
	m_vResourcesWGlobalMonopoly.clear();
	m_vResourcesWStrategicMonopoly.clear();
#endif
	m_pabLoyalMember.clear();
	m_pabGetsScienceFromPlayer.clear();

	m_pPlayerPolicies->Uninit();
	m_pEconomicAI->Uninit();
	m_pMilitaryAI->Uninit();
	m_pCitySpecializationAI->Uninit();
	m_pWonderProductionAI->Uninit();
	m_pGrandStrategyAI->Uninit();
	m_pDiplomacyAI->Uninit();
	m_pReligions->Uninit();
	m_pReligionAI->Uninit();
#if defined(MOD_BALANCE_CORE)
	m_pCorporations->Uninit();
	m_pContracts->Uninit();
#endif
	m_pEspionage->Uninit();
	m_pEspionageAI->Uninit();
	m_pTrade->Uninit();
	m_pTradeAI->Uninit();
	m_pLeagueAI->Uninit();
	m_pPlayerTechs->Uninit();
	m_pFlavorManager->Uninit();
	m_pTacticalAI->Uninit();
	m_pHomelandAI->Uninit();
	m_pMinorCivAI->Uninit();
	m_pDealAI->Uninit();
	m_pBuilderTaskingAI->Uninit();
	m_pCityConnections->Reset();
	if(m_pNotifications)
	{
		m_pNotifications->Uninit();
	}
	if(m_pDiplomacyRequests)
	{
		m_pDiplomacyRequests->Uninit();
	}
	m_pTreasury->Uninit();
	m_pTraits->Uninit();

	if(m_pDangerPlots)
	{
		m_pDangerPlots->Uninit();
	}

	m_ppaaiSpecialistExtraYield.clear();
#if defined(MOD_API_UNIFIED_YIELDS) && defined(MOD_API_PLOT_YIELDS)
	m_ppiPlotYieldChange.clear();
#endif
#if defined(MOD_API_UNIFIED_YIELDS)
	m_ppiInstantYieldHistoryValues.clear();
	m_ppiInstantTourismHistoryValues.clear();
	m_ppiImprovementYieldChange.clear();
	m_ppiFeatureYieldChange.clear();
	m_ppiResourceYieldChange.clear();
	m_ppiTerrainYieldChange.clear();
	m_ppiTradeRouteYieldChange.clear();
	m_ppiSpecialistYieldChange.clear();
	m_ppiGreatPersonExpendedYield.clear();
	m_piGoldenAgeGreatPersonRateModifier.clear();
	m_ppiUnimprovedFeatureYieldChange.clear();
	m_ppiCityYieldFromUnimprovedFeature.clear();
	m_piYieldFromKills.clear();
	m_piYieldFromBarbarianKills.clear();
	m_ppiBuildingClassYieldChange.clear();
	m_ppiApproachScratchValue.clear();
#endif
#if defined(MOD_API_UNIFIED_YIELDS) && defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	m_ppiSpecificGreatPersonRateModifierFromMonopoly.clear();
#endif
	m_ppaaiImprovementYieldChange.clear();
	m_ppaaiBuildingClassYieldMod.clear();

	m_researchQueue.clear();
	m_cityNames.clear();

	// loop through all entries freeing them up
	std::map<int , CvAIOperation*>::iterator iter;
	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
	{
		delete(iter->second);
	}
	m_AIOperations.clear();

	m_aiPlots.clear();
	m_bfEverConqueredBy.ClearAll();

	FAutoArchive& archive = getSyncArchive();
	archive.clearDelta();

	m_iStartingX = INVALID_PLOT_COORD;
	m_iStartingY = INVALID_PLOT_COORD;
	m_iTotalPopulation = 0;
	m_iTotalLand = 0;
	m_iTotalLandScored = 0;
	m_iCityConnectionHappiness = 0;
	m_iJONSCulturePerTurnForFree = 0;
	m_iJONSCulturePerTurnFromMinorCivs = 0;
	m_iJONSCultureCityModifier = 0;
	m_iJONSCulture = 0;
	m_iJONSCultureEverGenerated = 0;
	m_iWondersConstructed = 0;
	m_iCulturePerWonder = 0;
	m_iCultureWonderMultiplier = 0;
	m_iCulturePerTechResearched = 0;
	m_iFaith = 0;
	m_iFaithEverGenerated = 0;
	m_iHappiness = 0;
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	m_iUnhappiness = 0;
	m_iHappinessTotal = 0;
	m_iEmpireNeedsModifierGlobal = 0;
	m_iChangePovertyUnhappinessGlobal = 0;
	m_iChangeDefenseUnhappinessGlobal = 0;
	m_iChangeUnculturedUnhappinessGlobal = 0;
	m_iChangeIlliteracyUnhappinessGlobal = 0;
	m_iChangeMinorityUnhappinessGlobal = 0;
	m_iLandmarksTourismPercentGlobal = 0;
	m_iGreatWorksTourismModifierGlobal = 0;
#endif
#if defined(MOD_BALANCE_CORE)
	m_iCenterOfMassX = 0;
	m_iCenterOfMassY = 0;
	m_iReferenceFoundValue = 50000;
	m_iReformationFollowerReduction = 0;
	m_bIsReformation = false;
#endif
	m_iUprisingCounter = 0;
	m_iExtraHappinessPerLuxury = 0;
	m_iUnhappinessFromUnits = 0;
	m_iUnhappinessFromUnitsMod = 0;
	m_iUnhappinessMod = 0;
	m_iCityCountUnhappinessMod = 0;
	m_iOccupiedPopulationUnhappinessMod = 0;
	m_iCapitalUnhappinessMod = 0;
	m_iCityRevoltCounter = 0;
	m_iHappinessPerGarrisonedUnitCount = 0;
	m_iHappinessPerTradeRouteCount = 0;
	m_iHappinessPerXPopulation = 0;
#if defined(MOD_BALANCE_CORE_POLICIES)
	m_iHappinessPerXPopulationGlobal = 0;
	m_iIdeologyPoint = 0;
	m_iNoXPLossUnitPurchase = 0;
	m_iXCSAlliesLowersPolicyNeedWonders = 0;
	m_iHappinessFromMinorCivs = 0;
	m_iPositiveWarScoreTourismMod = 0;
	m_iIsNoCSDecayAtWar = 0;
	m_iCanBullyFriendlyCS = 0;
	m_iBullyGlobalCSReduction = 0;
#endif
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	m_iIsVassalsNoRebel = 0;
	m_iVassalCSBonusModifier = 0;
#endif
	m_iHappinessFromLeagues = 0;
	m_iEspionageModifier = 0;
	m_iSpyStartingRank = 0;
#if defined(MOD_RELIGION_CONVERSION_MODIFIERS)
	m_iConversionModifier = 0;
#endif
	m_iExtraLeagueVotes = 0;
#if defined(MOD_DIPLOMACY_CITYSTATES)
	m_iImprovementLeagueVotes = 0;
	m_iFaithToVotes = 0;
	m_iCapitalsToVotes = 0;
	m_iDoFToVotes = 0;
	m_iRAToVotes = 0;
	m_iDefensePactsToVotes = 0;
	m_iGPExpendInfluence = 0;
	m_bIsLeagueAid = false;
	m_bIsLeagueScholar = false;
	m_bIsLeagueArt = false;
	m_iScienceRateFromLeague = 0;
	m_iScienceRateFromLeagueAid = 0;
	m_iLeagueCultureCityModifier = 0;
#endif
	m_iSpecialPolicyBuildingHappiness = 0;
	m_iWoundedUnitDamageMod = 0;
	m_iUnitUpgradeCostMod = 0;
	m_iBarbarianCombatBonus = 0;
	m_iAlwaysSeeBarbCampsCount = 0;
	m_iHappinessPerCity = 0;
	m_iHappinessPerXPolicies = 0;
	m_iExtraHappinessPerXPoliciesFromPolicies = 0;
	m_iHappinessPerXGreatWorks = 0;
	m_iAdvancedStartPoints = -1;
	m_iAttackBonusTurns = 0;
	m_iCultureBonusTurns = 0;
	m_iTourismBonusTurns = 0;
	m_iGoldenAgeProgressMeter = 0;
	m_iGoldenAgeMeterMod = 0;
	m_iNumGoldenAges = 0;
	m_iGoldenAgeTurns = 0;
	m_iNumUnitGoldenAges = 0;
	m_iStrikeTurns = 0;
	m_iGoldenAgeModifier = 0;
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
	m_iProductionBonusTurnsConquest = 0;
	m_iCultureBonusTurnsConquest = 0;
	m_iFreeGreatPeopleCreated = 0;
	m_iFreeGreatGeneralsCreated = 0;
	m_iFreeGreatAdmiralsCreated = 0;
#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
	m_iFreeGreatMerchantsCreated = 0;
	m_iFreeGreatScientistsCreated = 0;
	m_iFreeGreatEngineersCreated = 0;
#endif
	m_iFreeGreatWritersCreated = 0;
	m_iFreeGreatArtistsCreated = 0;
	m_iFreeGreatMusiciansCreated = 0;
#if defined(MOD_DIPLOMACY_CITYSTATES)
	m_iFreeGreatDiplomatsCreated = 0;
#endif
#endif
	m_iGreatPeopleCreated = 0;
	m_iGreatGeneralsCreated = 0;
	m_iGreatAdmiralsCreated = 0;
#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
	m_iGPExtra1Created = 0;
	m_iGPExtra2Created = 0;
	m_iGPExtra3Created = 0;
	m_iGPExtra4Created = 0;
	m_iGPExtra5Created = 0;
	m_iFreeGPExtra1Created = 0;
	m_iFreeGPExtra2Created = 0;
	m_iFreeGPExtra3Created = 0;
	m_iFreeGPExtra4Created = 0;
	m_iFreeGPExtra5Created = 0;
	m_iGPExtra1FromFaith = 0;
	m_iGPExtra2FromFaith = 0;
	m_iGPExtra3FromFaith = 0;
	m_iGPExtra4FromFaith = 0;
	m_iGPExtra5FromFaith = 0;
	m_iGreatMerchantsCreated = 0;
	m_iGreatScientistsCreated = 0;
	m_iGreatEngineersCreated = 0;
#endif
	m_iGreatWritersCreated = 0;
	m_iGreatArtistsCreated = 0;
	m_iGreatMusiciansCreated = 0;
#if defined(MOD_DIPLOMACY_CITYSTATES)
	m_iGreatDiplomatsCreated = 0;
	m_iDiplomatsFromFaith = 0;
#endif
	m_iMerchantsFromFaith = 0;
	m_iScientistsFromFaith = 0;
	m_iWritersFromFaith = 0;
	m_iArtistsFromFaith = 0;
	m_iMusiciansFromFaith = 0;
	m_iGeneralsFromFaith = 0;
	m_iAdmiralsFromFaith = 0;
	m_iEngineersFromFaith = 0;
	m_iGreatPeopleThresholdModifier = 0;
	m_iGreatGeneralsThresholdModifier = 0;
	m_iGreatAdmiralsThresholdModifier = 0;
	m_iGreatGeneralCombatBonus = 0;
	m_iAnarchyNumTurns = 0;
	m_iPolicyCostModifier = 0;
	m_iGreatPeopleRateModifier = 0;
	m_iGreatPeopleRateModFromBldgs = 0;
	m_iGreatGeneralRateModifier = 0;
	m_iGreatGeneralRateModFromBldgs = 0;
	m_iDomesticGreatGeneralRateModifier = 0;
	m_iDomesticGreatGeneralRateModFromBldgs = 0;
	m_iGreatAdmiralRateModifier = 0;
	m_iGreatWriterRateModifier = 0;
	m_iGreatArtistRateModifier = 0;
	m_iGreatMusicianRateModifier = 0;
	m_iGreatMerchantRateModifier = 0;
#if defined(MOD_DIPLOMACY_CITYSTATES)
	m_iGreatDiplomatRateModifier = 0;
#endif
	m_iGreatScientistRateModifier = 0;
	m_iGreatScientistBeakerModifier = 0;
	m_iGreatEngineerHurryMod = 0;
	m_iTechCostXCitiesModifier = 0;
	m_iTourismCostXCitiesMod = 0;
	m_iGreatEngineerRateModifier = 0;
	m_iGreatPersonExpendGold = 0;
	m_iMaxGlobalBuildingProductionModifier = 0;
	m_iMaxTeamBuildingProductionModifier = 0;
	m_iMaxPlayerBuildingProductionModifier = 0;
	m_iFreeExperience = 0;
	m_iFreeExperienceFromBldgs = 0;
	m_iFreeExperienceFromMinors = 0;
	m_iFeatureProductionModifier = 0;
	m_iWorkerSpeedModifier = 0;
	m_iImprovementCostModifier = 0;
	m_iImprovementUpgradeRateModifier = 0;
	m_iSpecialistProductionModifier = 0;
	m_iMilitaryProductionModifier = 0;
	m_iSpaceProductionModifier = 0;
	m_iCityDefenseModifier = 0;
	m_iUnitFortificationModifier = 0;
	m_iUnitBaseHealModifier = 0;
	m_iWonderProductionModifier = 0;
	m_iSettlerProductionModifier = 0;
	m_iCapitalSettlerProductionModifier = 0;
	m_iUnitProductionMaintenanceMod = 0;
	m_iUnitGrowthMaintenanceMod = 0;
	m_iPolicyCostBuildingModifier = 0;
	m_iPolicyCostMinorCivModifier = 0;
	m_iInfluenceSpreadModifier = 0;
	m_iExtraVotesPerDiplomat = 0;
	m_iNumNukeUnits = 0;
	m_iNumOutsideUnits = 0;
	m_iBaseFreeUnits = 0;
	m_iBaseFreeMilitaryUnits = 0;
	m_iFreeUnitsPopulationPercent = 0;
	m_iFreeMilitaryUnitsPopulationPercent = 0;
	m_iGoldPerUnit = 0;
	m_iGoldPerMilitaryUnit = 0;
	m_iImprovementGoldMaintenanceMod = 0;
#if defined(MOD_CIV6_WORKER)
	m_iRouteBuilderCostMod = 0;
#endif
	m_iBuildingGoldMaintenanceMod = 0;
	m_iUnitGoldMaintenanceMod = 0;
	m_iUnitSupplyMod = 0;
	m_iExtraUnitCost = 0;
	m_iNumMilitaryUnits = 0;
	m_iHappyPerMilitaryUnit = 0;
	m_iHappinessToCulture = 0;
	m_iHappinessToScience = 0;
	m_iHalfSpecialistUnhappinessCount = 0;
	m_iHalfSpecialistFoodCount = 0;
#if defined(MOD_BALANCE_CORE)
	m_iHalfSpecialistFoodCapitalCount = 0;
	m_iTradeRouteLandDistanceModifier = 0;
	m_iTradeRouteSeaDistanceModifier = 0;
	m_bNullifyInfluenceModifier = false;
#endif
	m_iMilitaryFoodProductionCount = 0;
	m_iGoldenAgeCultureBonusDisabledCount = 0;
	m_iNumMissionarySpreads = 0;
	m_iSecondReligionPantheonCount = 0;
	m_iEnablesSSPartHurryCount = 0;
	m_iEnablesSSPartPurchaseCount = 0;
	m_iConscriptCount = 0;
	m_iMaxConscript = 0;
	m_iHighestUnitLevel = 1;
	m_iOverflowResearch = 0;
	m_iExpModifier = 0;
	m_iExpInBorderModifier = 0;
	m_iLevelExperienceModifier = 0;
	m_iMinorQuestFriendshipMod = 0;
	m_iMinorGoldFriendshipMod = 0;
	m_iMinorFriendshipMinimum = 0;
	m_iMinorFriendshipDecayMod = 0;
	m_iMinorScienceAlliesCount = 0;
	m_iMinorResourceBonusCount = 0;
	m_iAbleToAnnexCityStatesCount = 0;
	m_iOnlyTradeSameIdeology = 0;
#if defined(MOD_BALANCE_CORE)
	m_iSupplyFreeUnits = 0;
	m_strJFDCurrencyName = "";
	m_iJFDCurrency = -1;
	m_iJFDProsperity = 0;
	m_strJFDLegislatureName = "";
	m_strJFDPoliticKey = "";
	m_iJFDPoliticLeader = 0;
	m_iJFDSovereignty = 0;
	m_iJFDGovernment = -1;
	m_iJFDReformCooldown = 0;
	m_iJFDGovernmentCooldown = 0;
	m_iJFDGovernmentCooldownRate = 0;
	m_iJFDReformCooldownRate = 0;
	m_iJFDPiety = 0;
	m_iJFDPietyRate = 0;
	m_iJFDConversionTurn = 0;
	m_bJFDSecularized = false;
	m_iUpgradeCSVassalTerritory = 0;
	m_iArchaeologicalDigTourism = 0;
	m_iGoldenAgeTourism = 0;
	m_iExtraCultureandScienceTradeRoutes = 0;
	m_iRazingSpeedBonus = 0;
	m_iNoPartisans = 0;
	m_iSpawnCooldown = 0;
	m_iAbleToMarryCityStatesCount = 0;
	m_bTradeRoutesInvulnerable = false;
	m_iTRSpeedBoost = 0;
	m_iVotesPerGPT = 0;
	m_iTRVisionBoost = 0;
	m_iEventTourism = 0;
	m_iEventTourismCS = 0;
	m_iNumHistoricEvent = 0;
	m_iSingleVotes = 0;
	m_iMonopolyModFlat = 0;
	m_iMonopolyModPercent = 0;
	m_iCachedValueOfPeaceWithHuman = 0;
	m_iFaithPurchaseCooldown = 0;
	m_iCSAllies = 0;
	m_iCSFriends = 0;
	m_iCitiesNeedingTerrainImprovements = 0;
	m_piDomainFreeExperience.clear();
#endif
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	m_iPovertyUnhappinessMod = 0;
	m_iDefenseUnhappinessMod = 0;
	m_iUnculturedUnhappinessMod = 0;
	m_iIlliteracyUnhappinessMod = 0;
	m_iMinorityUnhappinessMod = 0;
	m_iPovertyUnhappinessModCapital = 0;
	m_iDefenseUnhappinessModCapital = 0;
	m_iUnculturedUnhappinessModCapital = 0;
	m_iIlliteracyUnhappinessModCapital = 0;
	m_iMinorityUnhappinessModCapital = 0;
	m_iPuppetUnhappinessMod = 0;
	m_iNoUnhappfromXSpecialists = 0;
	m_iHappfromXSpecialists = 0;
	m_iNoUnhappfromXSpecialistsCapital = 0;
	m_iSpecialistFoodChange = 0;
	m_iWarWearinessModifier = 0;
	m_iWarScoreModifier = 0;
	m_iPlayerEventCooldown = 0;
	m_iExtraSupplyPerPopulation = 0;
	m_iCitySupplyFlatGlobal = 0;
	m_iMissionaryExtraStrength = 0;
#endif
#if defined(MOD_BALANCE_CORE_POLICIES)
	m_iGarrisonsOccupiedUnhapppinessMod = 0;
	m_iXPopulationConscription = 0;
	m_iExtraMoves = 0;
	m_iNoUnhappinessExpansion = 0;
	m_iNoUnhappyIsolation = 0;
	m_iDoubleBorderGA = 0;
	m_iIncreasedQuestInfluence = 0;
	m_iCultureBombBoost = 0;
	m_iPuppetProdMod = 0;
	m_iOccupiedProdMod = 0;
	m_iGoldInternalTrade = 0;
	m_iFreeWCVotes = 0;
	m_iInfluenceGPExpend = 0;
	m_iFreeTradeRoute = 0;
	m_iFreeSpy = 0;
	m_iReligionDistance = 0;
	m_iPressureMod = 0;
	m_iTradeReligionModifier = 0;
	m_iCityStateCombatModifier = 0;
#endif
#if defined(MOD_BALANCE_CORE_SPIES)
	m_bAdvancedActionsEnabled = false;
	m_iAdvancedActionGold = 0;
	m_iAdvancedActionScience = 0;
	m_iAdvancedActionUnrest = 0;
	m_iAdvancedActionRebellion = 0;
	m_iAdvancedActionGP = 0;
	m_iAdvancedActionUnit = 0;
	m_iAdvancedActionWonder = 0;
	m_iAdvancedActionBuilding = 0;
	m_iCannotFailSpies = 0;
	m_iMaxAirUnits = 0;
#endif
#if defined(MOD_BALANCE_CORE_BUILDING_INVESTMENTS)
	m_iInvestmentModifier = 0;
	m_bAllowsProductionTradeRoutesGlobal = false;
	m_bAllowsFoodTradeRoutesGlobal = false;
	m_iMissionInfluenceModifier = 0;
	m_iHappinessPerActiveTradeRoute = 0;
	m_iCSResourcesCountMonopolies = 0;
	m_iConquestPerEraBuildingProductionMod = 0;
	m_iAdmiralLuxuryBonus = 0;
	m_iPuppetYieldPenaltyMod = 0;
	m_iNeedsModifierFromAirUnits = 0;
	m_iFlatDefenseFromAirUnits = 0;
#endif
	m_iCultureBombTimer = 0;
	m_iConversionTimer = 0;
	m_iCapitalCityID = -1;
	m_iCitiesLost = 0;
	m_iMilitaryRating = 0;
	m_iMilitaryMight = 0;
	m_iEconomicMight = 0;
	m_iProductionMight = 0;
	m_iTurnSliceMightRecomputed = -1;
	m_iNewCityExtraPopulation = 0;
	m_iFreeFoodBox = 0;
	m_iScenarioScore1 = 0;
	m_iScenarioScore2 = 0;
	m_iScenarioScore3 = 0;
	m_iScenarioScore4 = 0;
	m_iScoreFromFutureTech = 0;
	m_iCombatExperience = 0;
	m_iLifetimeCombatExperience = 0;
	m_iNavalCombatExperience = 0;
#if defined(MOD_UNITS_XP_TIMES_100)
	m_iCombatExperienceTimes100 = 0;
	m_iLifetimeCombatExperienceTimes100 = 0;
	m_iNavalCombatExperienceTimes100 = 0;
#endif
	m_iBorderObstacleCount = 0;
#if defined(HH_MOD_BUILDINGS_FRUITLESS_PILLAGE)
	m_iBorderGainlessPillageCount = 0;
#endif
	m_iPopRushHurryCount = 0;
	m_uiStartTime = 0;
	m_bHasUUPeriod = false;
	m_iTotalImprovementsBuilt = 0;
	m_iNextOperationID = 0;
	m_iCostNextPolicy = 0;
	m_iNumBuilders = 0;
	m_iMaxNumBuilders = 0;
	m_iCityStrengthMod = 0;
	m_iCityGrowthMod = 0;
	m_iCapitalGrowthMod = 0;
	m_iNumPlotsBought = 0;
	m_iPlotGoldCostMod = 0;
#if defined(MOD_TRAITS_CITY_WORKING) || defined(MOD_BUILDINGS_CITY_WORKING) || defined(MOD_POLICIES_CITY_WORKING) || defined(MOD_TECHS_CITY_WORKING)
	m_iCityWorkingChange = 0;
#endif
#if defined(MOD_TRAITS_CITY_AUTOMATON_WORKERS) || defined(MOD_BUILDINGS_CITY_AUTOMATON_WORKERS) || defined(MOD_POLICIES_CITY_AUTOMATON_WORKERS) || defined(MOD_TECHS_CITY_AUTOMATON_WORKERS)
	m_iCityAutomatonWorkersChange = 0;
#endif
	m_iPlotCultureCostModifier = 0;
	m_iPlotCultureExponentModifier = 0;
	m_iNumCitiesPolicyCostDiscount = 0;
	m_iGarrisonedCityRangeStrikeModifier = 0;
	m_iGarrisonFreeMaintenanceCount = 0;
	m_iNumCitiesFreeCultureBuilding = 0;
	m_iNumCitiesFreeFoodBuilding = 0;
	m_iUnitPurchaseCostModifier = 0;
	m_iAllFeatureProduction = 0;
	m_iCityDistanceHighwaterMark = 1;
	m_iOriginalCapitalX = -1;
	m_iOriginalCapitalY = -1;
	m_iHolyCityX = -1;
	m_iHolyCityY = -1;
	m_iNumWonders = 0;
	m_iNumPolicies = 0;
	m_iNumGreatPeople = 0;
	m_iHolyCityID = -1;
	m_iTurnsSinceSettledLastCity = -1;
	m_iNumNaturalWondersDiscoveredInArea = 0;
	m_iStrategicResourceMod = 0;
	m_iSpecialistCultureChange = 0;
	m_iGreatPeopleSpawnCounter = 0;
	m_iFreeTechCount = 0;
	m_iMedianTechPercentage = 50;
	m_iNumFreePolicies = 0;
	m_iNumFreePoliciesEver = 0;
	m_iNumFreeTenets = 0;
	m_iNumFreeGreatPeople = 0;
	m_iNumMayaBoosts = 0;
	m_iNumFaithGreatPeople = 0;
	m_iNumArchaeologyChoices = 0;
	m_eFaithPurchaseType = NO_AUTOMATIC_FAITH_PURCHASE;
	m_iFaithPurchaseIndex = 0;
	m_iMaxEffectiveCities = 1;
	m_iLastSliceMoved = 0;

	m_bHasBetrayedMinorCiv = false;
	m_bAlive = false;
	m_bEverAlive = false;
	m_bPotentiallyAlive = false;
	m_bBeingResurrected = false;
	m_bTurnActive = false;
	m_bAutoMoves = false;
	m_bProcessedAutoMoves = false;
	m_bEndTurn = false;
	m_bDynamicTurnsSimultMode = true;
	m_bPbemNewTurn = false;
	m_bExtendedGame = false;
	m_bFoundedFirstCity = false;
	m_iNumCitiesFounded = 0;
	m_bStrike = false;
	m_bCramped = false;
	m_bLostCapital = false;
	m_eConqueror = NO_PLAYER;
	m_bLostHolyCity = false;
	m_eHolyCityConqueror = NO_PLAYER;
	m_bHasAdoptedStateReligion = false;
	m_bAlliesGreatPersonBiasApplied = false;
	m_lastGameTurnInitialAIProcessed = -1;

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	m_bVassalLevy = false;
	m_iVassalGoldMaintenanceMod = 0;
#endif
#if defined(MOD_BATTLE_ROYALE)
	m_iNumMilitarySeaUnits = 0;
	m_iNumMilitaryAirUnits = 0; 
	m_iNumMilitaryLandUnits = 0;
	m_iMilitarySeaMight = 0;
	m_iMilitaryAirMight = 0;
	m_iMilitaryLandMight = 0;
#endif

	m_eID = NO_PLAYER;
}


//	--------------------------------------------------------------------------------
// FUNCTION: reset()
// Initializes data members that are serialized.
void CvPlayer::reset(PlayerTypes eID, bool bConstructorCall)
{
	m_syncArchive.reset();
	//--------------------------------
	// Uninit class
	uninit();

	m_eID = eID;
	if(m_eID != NO_PLAYER)
	{
		m_ePersonalityType = CvPreGame::leaderHead(m_eID); //??? Is this repeated data???
	}
	else
	{
		m_ePersonalityType = NO_LEADER;
	}

	// tutorial info
	m_bEverPoppedGoody = false;

	// lazy update scheme ...
	m_iPlotFoundValuesUpdateTurn = -1;

	m_aiCityYieldChange.clear();
	m_aiCityYieldChange.resize(NUM_YIELD_TYPES, 0);

	m_aiCoastalCityYieldChange.clear();
	m_aiCoastalCityYieldChange.resize(NUM_YIELD_TYPES, 0);

	m_aiCapitalYieldChange.clear();
	m_aiCapitalYieldChange.resize(NUM_YIELD_TYPES, 0);

	m_aiCapitalYieldPerPopChange.clear();
	m_aiCapitalYieldPerPopChange.resize(NUM_YIELD_TYPES, 0);

	m_aiCapitalYieldPerPopChangeEmpire.clear();
	m_aiCapitalYieldPerPopChangeEmpire.resize(NUM_YIELD_TYPES, 0);

	m_aiSeaPlotYield.clear();
	m_aiSeaPlotYield.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldRateModifier.clear();
	m_aiYieldRateModifier.resize(NUM_YIELD_TYPES, 0);

#if defined(MOD_BALANCE_CORE_POLICIES)
	m_aiGlobalTourismAlreadyReceived.clear();
	m_aiGlobalTourismAlreadyReceived.resize(NUM_MINOR_CIV_QUEST_TYPES, 0);

	m_aiYieldFromMinors.clear();
	m_aiYieldFromMinors.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromBirth.clear();
	m_aiYieldFromBirth.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromBirthCapital.clear();
	m_aiYieldFromBirthCapital.resize(NUM_YIELD_TYPES, 0);
	
	m_aiYieldFromDeath.clear();
	m_aiYieldFromDeath.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromPillage.clear();
	m_aiYieldFromPillage.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromVictory.clear();
	m_aiYieldFromVictory.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromConstruction.clear();
	m_aiYieldFromConstruction.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromwonderConstruction.clear();
	m_aiYieldFromwonderConstruction.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromTech.clear();
	m_aiYieldFromTech.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromBorderGrowth.clear();
	m_aiYieldFromBorderGrowth.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldGPExpend.clear();
	m_aiYieldGPExpend.resize(NUM_YIELD_TYPES, 0);

	m_aiConquerorYield.clear();
	m_aiConquerorYield.resize(NUM_YIELD_TYPES, 0);

	m_aiFounderYield.clear();
	m_aiFounderYield.resize(NUM_YIELD_TYPES, 0);

	m_aiArtifactYieldBonus.clear();
	m_aiArtifactYieldBonus.resize(NUM_YIELD_TYPES, 0);

	m_aiArtYieldBonus.clear();
	m_aiArtYieldBonus.resize(NUM_YIELD_TYPES, 0);

	m_aiMusicYieldBonus.clear();
	m_aiMusicYieldBonus.resize(NUM_YIELD_TYPES, 0);

	m_aiLitYieldBonus.clear();
	m_aiLitYieldBonus.resize(NUM_YIELD_TYPES, 0);	

	m_aiFilmYieldBonus.clear();
	m_aiFilmYieldBonus.resize(NUM_YIELD_TYPES, 0);

	m_aiRelicYieldBonus.clear();
	m_aiRelicYieldBonus.resize(NUM_YIELD_TYPES, 0);

	m_aiReligionYieldRateModifier.clear();
	m_aiReligionYieldRateModifier.resize(NUM_YIELD_TYPES, 0);

	m_aiGoldenAgeYieldMod.clear();
	m_aiGoldenAgeYieldMod.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromNonSpecialistCitizens.clear();
	m_aiYieldFromNonSpecialistCitizens.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldModifierFromGreatWorks.clear();
	m_aiYieldModifierFromGreatWorks.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldModifierFromActiveSpies.clear();
	m_aiYieldModifierFromActiveSpies.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromDelegateCount.clear();
	m_aiYieldFromDelegateCount.resize(NUM_YIELD_TYPES, 0);

	m_aiDomainFreeExperiencePerGreatWorkGlobal.clear();
	m_aiDomainFreeExperiencePerGreatWorkGlobal.resize(NUM_DOMAIN_TYPES, 0);

	m_aiBestMilitaryCombatClassCity.clear();
	m_aiBestMilitaryCombatClassCity.resize(GC.getNumUnitCombatClassInfos(), 0);

	m_aiBestMilitaryDomainCity.clear();
	m_aiBestMilitaryDomainCity.resize(NUM_DOMAIN_TYPES, 0);

	m_aiEventChoiceDuration.clear();
	m_aiEventChoiceDuration.resize(GC.getNumEventChoiceInfos(), 0);

	m_aiEventIncrement.clear();
	m_aiEventIncrement.resize(GC.getNumEventInfos(), 0);

	m_aiEventCooldown.clear();
	m_aiEventCooldown.resize(GC.getNumEventInfos(), 0);

	m_abEventActive.clear();
	m_abEventActive.resize(GC.getNumEventInfos(), false);

	m_abEventChoiceActive.clear();
	m_abEventChoiceActive.resize(GC.getNumEventChoiceInfos(), false);

	m_abEventFired.clear();
	m_abEventFired.resize(GC.getNumEventInfos(), false);

	m_abEventChoiceFired.clear();
	m_abEventChoiceFired.resize(GC.getNumEventChoiceInfos(), false);

	m_abNWOwned.clear();
	m_abNWOwned.resize(GC.getNumFeatureInfos(), false);

	m_paiUnitClassProductionModifiers.clear();
	m_paiUnitClassProductionModifiers.resize(GC.getNumUnitClassInfos(), 0);

	m_aiCityYieldModFromMonopoly.clear();
	m_aiCityYieldModFromMonopoly.resize(NUM_YIELD_TYPES, 0);

	m_aiDomainDiversity.clear();
	m_aiDomainDiversity.resize(NUM_DOMAIN_TYPES, -1);

	m_abActiveContract.clear();
	m_abActiveContract.resize(GC.getNumContractInfos(), false);

	m_aistrInstantYield.clear();
	m_aistrInstantYield.resize(NUM_INSTANT_YIELD_TYPES);

	m_aistrInstantGreatPersonProgress.clear();

	m_viInstantYieldsTotal.clear();
	m_viInstantYieldsTotal.resize(NUM_YIELD_TYPES, 0);

#endif
#if defined(MOD_BALANCE_CORE)
	m_piDomainFreeExperience.clear();
#endif

	m_aiCapitalYieldRateModifier.clear();
	m_aiCapitalYieldRateModifier.resize(NUM_YIELD_TYPES, 0);

	m_aiGreatWorkYieldChange.clear();
	m_aiGreatWorkYieldChange.resize(NUM_YIELD_TYPES, 0);

	m_aiExtraYieldThreshold.clear();
	m_aiExtraYieldThreshold.resize(NUM_YIELD_TYPES, 0);

	m_aiSpecialistExtraYield.clear();
	m_aiSpecialistExtraYield.resize(NUM_YIELD_TYPES, 0);

	m_aiProximityToPlayer.clear();
	m_aiProximityToPlayer.resize(MAX_PLAYERS, 0);

	m_aiResearchAgreementCounter.clear();
	m_aiResearchAgreementCounter.resize(MAX_PLAYERS, 0);

	m_aiIncomingUnitTypes.clear();
	m_aiIncomingUnitTypes.resize(MAX_PLAYERS, NO_UNIT);

	m_aiIncomingUnitCountdowns.clear();
	m_aiIncomingUnitCountdowns.resize(MAX_PLAYERS, -1);

	m_aiMinorFriendshipAnchors.clear();
	m_aiMinorFriendshipAnchors.resize(MAX_PLAYERS, 0);

	m_aiSiphonLuxuryCount.clear();
	m_aiSiphonLuxuryCount.resize(MAX_PLAYERS, 0);

	m_aOptions.clear();

	m_strReligionKey = "";
	m_strScriptData = "";
	m_strEmbarkedGraphicOverride = "";

	if(!bConstructorCall)
	{
		//important, do this first
		m_cities.RemoveAll();
		m_units.RemoveAll();
		m_armyAIs.RemoveAll();

		// loop through all entries freeing them up
		std::map<int , CvAIOperation*>::iterator iter;
		for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
			delete(iter->second);
		m_AIOperations.clear();

		CvAssertMsg(0 < GC.getNumResourceInfos(), "GC.getNumResourceInfos() is not greater than zero but it is used to allocate memory in CvPlayer::reset");
		m_paiNumResourceUsed.clear();
		m_paiNumResourceUsed.resize(GC.getNumResourceInfos(), 0);

		m_paiNumResourceTotal.clear();
		m_paiNumResourceTotal.resize(GC.getNumResourceInfos(), 0);

		m_paiResourceGiftedToMinors.clear();
		m_paiResourceGiftedToMinors.resize(GC.getNumResourceInfos(), 0);

		m_paiResourceExport.clear();
		m_paiResourceExport.resize(GC.getNumResourceInfos(), 0);

		m_paiResourceImport.clear();
		m_paiResourceImport.resize(GC.getNumResourceInfos(), 0);

		m_paiResourceFromMinors.clear();
		m_paiResourceFromMinors.resize(GC.getNumResourceInfos(), 0);

		m_paiResourcesSiphoned.clear();
		m_paiResourcesSiphoned.resize(GC.getNumResourceInfos(), 0);

		CvAssertMsg(0 < GC.getNumImprovementInfos(), "GC.getNumImprovementInfos() is not greater than zero but it is used to allocate memory in CvPlayer::reset");
		m_paiImprovementCount.clear();
		m_paiImprovementCount.resize(GC.getNumImprovementInfos(), 0);

#if defined(MOD_BALANCE_CORE)
		CvAssertMsg(0 < GC.getNumImprovementInfos(), "GC.getNumImprovementInfos() is not greater than zero but it is used to allocate memory in CvPlayer::reset");
		m_paiTotalImprovementsBuilt.clear();
		m_paiTotalImprovementsBuilt.resize(GC.getNumImprovementInfos(), 0);
#endif

		m_paiUnitCombatProductionModifiers.clear();
		m_paiUnitCombatProductionModifiers.resize(GC.getNumUnitCombatClassInfos(), 0);

		m_paiUnitCombatFreeExperiences.clear();
		m_paiUnitCombatFreeExperiences.resize(GC.getNumUnitCombatClassInfos(), 0);

		m_paiFreeBuildingCount.clear();
		m_paiFreeBuildingCount.resize(GC.getNumBuildingInfos(), 0);

		m_paiFreePromotionCount.clear();
		m_paiFreePromotionCount.resize(GC.getNumPromotionInfos(), 0);

		m_paiUnitClassCount.clear();
		m_paiUnitClassCount.resize(GC.getNumUnitClassInfos(), 0);

		m_paiUnitClassMaking.clear();
		m_paiUnitClassMaking.resize(GC.getNumUnitClassInfos(), 0);

		m_paiBuildingClassCount.clear();
		m_paiBuildingClassCount.resize(GC.getNumBuildingClassInfos(), 0);

		m_paiBuildingClassMaking.clear();
		m_paiBuildingClassMaking.resize(GC.getNumBuildingClassInfos(), 0);

		m_paiProjectMaking.clear();
		m_paiProjectMaking.resize(GC.getNumProjectInfos(), 0);

		m_paiHurryCount.clear();
		m_paiHurryCount.resize(GC.getNumHurryInfos(), 0);

		m_paiHurryModifier.clear();
		m_paiHurryModifier.resize(GC.getNumHurryInfos(), 0);
#if defined(MOD_BALANCE_CORE)
		m_paiJFDPoliticPercent.clear();
		m_paiJFDPoliticPercent.resize(MAX_CIV_PLAYERS, 0);

		m_paiResourceFromCSAlliances.clear();
		m_paiResourceFromCSAlliances.resize(GC.getNumResourceInfos(), 0);

		m_paiResourceOverValue.clear();
		m_paiResourceOverValue.resize(GC.getNumResourceInfos(), 0);

		m_paiNumCitiesFreeChosenBuilding.clear();
		m_paiNumCitiesFreeChosenBuilding.resize(GC.getNumBuildingClassInfos(), 0);

		m_pabFreeChosenBuildingNewCity.clear();
		m_pabFreeChosenBuildingNewCity.resize(GC.getNumBuildingClassInfos(), false);

		m_pabAllCityFreeBuilding.clear();
		m_pabAllCityFreeBuilding.resize(GC.getNumBuildingClassInfos(), false);

		m_pabNewFoundCityFreeUnit.clear();
		m_pabNewFoundCityFreeUnit.resize(GC.getNumUnitClassInfos(), false);

		m_pabNewFoundCityFreeBuilding.clear();
		m_pabNewFoundCityFreeBuilding.resize(GC.getNumBuildingClassInfos(), false);


		m_paiBuildingClassCulture.clear();
		m_paiBuildingClassCulture.resize(GC.getNumBuildingClassInfos(), 0);
#endif
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
		m_pabHasGlobalMonopoly.clear();
		m_pabHasGlobalMonopoly.resize(GC.getNumResourceInfos(), false);
		m_pabHasStrategicMonopoly.clear();
		m_pabHasStrategicMonopoly.resize(GC.getNumResourceInfos(), false);
		m_vResourcesWGlobalMonopoly.clear();
		m_vResourcesWStrategicMonopoly.clear();
#endif
		m_pabLoyalMember.clear();
		m_pabLoyalMember.resize(GC.getNumVoteSourceInfos(), true);

		m_pabGetsScienceFromPlayer.clear();
		m_pabGetsScienceFromPlayer.resize(MAX_CIV_PLAYERS, false);

		m_pEconomicAI->Init(GC.GetGameEconomicAIStrategies(), this);
		m_pMilitaryAI->Init(GC.GetGameMilitaryAIStrategies(), this, GetDiplomacyAI());
		m_pCitySpecializationAI->Init(GC.GetGameCitySpecializations(), this);
		m_pWonderProductionAI->Init(GC.GetGameBuildings(), this, false);
		m_pGrandStrategyAI->Init(GC.GetGameAIGrandStrategies(), this);
		m_pDiplomacyAI->Init(this);
		m_pReligions->Init(this);
		m_pReligionAI->Init(GC.GetGameBeliefs(), this);
#if defined(MOD_BALANCE_CORE)
		m_pCorporations->Init(this);
		m_pContracts->Init(this);
#endif
		m_pPlayerTechs->Init(GC.GetGameTechs(), this, false);
		m_pPlayerPolicies->Init(GC.GetGamePolicies(), this, false);
		m_pTacticalAI->Init(this);
		m_pHomelandAI->Init(this);
		m_pMinorCivAI->Init(this);
		m_pDealAI->Init(this);
		m_pBuilderTaskingAI->Init(this);
		m_pCityConnections->Init(this);
		if(m_pNotifications)
		{
			m_pNotifications->Init(eID);
		}
		if(m_pDiplomacyRequests)
		{
			m_pDiplomacyRequests->Init(eID);
		}
		m_pDangerPlots->Init(eID, false /*bAllocate*/);
		m_pTreasury->Init(this);
		m_pTraits->Init(GC.GetGameTraits(), this);
		m_pEspionage->Init(this);
		m_pEspionageAI->Init(this);
		m_pTrade->Init(this);
		m_pTradeAI->Init(this);
		m_pLeagueAI->Init(this);
		m_pCulture->Init(this);

		// Set up flavor manager
		m_pFlavorManager->Init(this);

		// And if this is a real player, hook up the player-level flavor recipients
		PlayerTypes p = GetID();
		if(p != NO_PLAYER)
		{
			SlotStatus s = CvPreGame::slotStatus(p);
			if((s == SS_TAKEN || s == SS_COMPUTER) && !isBarbarian())
			{
				m_pFlavorManager->AddFlavorRecipient(m_pPlayerTechs);
				m_pFlavorManager->AddFlavorRecipient(m_pPlayerPolicies);
				m_pFlavorManager->AddFlavorRecipient(m_pWonderProductionAI);
			}
		}

		Firaxis::Array< int, NUM_YIELD_TYPES > yield;
		for(unsigned int j = 0; j < NUM_YIELD_TYPES; ++j)
		{
			yield[j] = 0;
		}

		m_ppaaiSpecialistExtraYield.clear();
		m_ppaaiSpecialistExtraYield.resize(GC.getNumSpecialistInfos());
		for(unsigned int i = 0; i < m_ppaaiSpecialistExtraYield.size(); ++i)
		{
			m_ppaaiSpecialistExtraYield.setAt(i, yield);
		}

#if defined(MOD_API_UNIFIED_YIELDS) && defined(MOD_API_PLOT_YIELDS)
		m_ppiPlotYieldChange.clear();
		m_ppiPlotYieldChange.resize(GC.getNumPlotInfos());
		for(unsigned int i = 0; i < m_ppiPlotYieldChange.size(); ++i)
		{
			m_ppiPlotYieldChange[i] = yield;
		}
#endif

#if defined(MOD_API_UNIFIED_YIELDS)
		m_ppiInstantYieldHistoryValues.clear();
		m_ppiInstantYieldHistoryValues.resize(GC.getGame().getEstimateEndTurn());
		for (unsigned int i = 0; i < m_ppiInstantYieldHistoryValues.size(); ++i)
		{
			m_ppiInstantYieldHistoryValues[i] = yield;
		}

		Firaxis::Array< int, MAX_MAJOR_CIVS > players;
		for (unsigned int j = 0; j < MAX_MAJOR_CIVS; ++j)
		{
			players[j] = 0;
		}
		m_ppiInstantTourismHistoryValues.clear();
		m_ppiInstantTourismHistoryValues.resize(GC.getGame().getEstimateEndTurn());
		for (unsigned int i = 0; i < m_ppiInstantTourismHistoryValues.size(); ++i)
		{
			m_ppiInstantTourismHistoryValues[i] = players;
		}

		m_ppiImprovementYieldChange.clear();
		m_ppiImprovementYieldChange.resize(GC.getNumImprovementInfos());
		for(unsigned int i = 0; i < m_ppiImprovementYieldChange.size(); ++i)
		{
			m_ppiImprovementYieldChange[i] = yield;
		}

		m_ppiFeatureYieldChange.clear();
		m_ppiFeatureYieldChange.resize(GC.getNumFeatureInfos());
		for(unsigned int i = 0; i < m_ppiFeatureYieldChange.size(); ++i)
		{
			m_ppiFeatureYieldChange[i] = yield;
		}
		
		m_ppiResourceYieldChange.clear();
		m_ppiResourceYieldChange.resize(GC.getNumResourceInfos());
		for(unsigned int i = 0; i < m_ppiResourceYieldChange.size(); ++i)
		{
			m_ppiResourceYieldChange[i] = yield;
		}
		
		m_ppiTerrainYieldChange.clear();
		m_ppiTerrainYieldChange.resize(GC.getNumTerrainInfos());
		for(unsigned int i = 0; i < m_ppiTerrainYieldChange.size(); ++i)
		{
			m_ppiTerrainYieldChange[i] = yield;
		}
		
		m_ppiTradeRouteYieldChange.clear();
		m_ppiTradeRouteYieldChange.resize(NUM_DOMAIN_TYPES);
		for(unsigned int i = 0; i < m_ppiTradeRouteYieldChange.size(); ++i)
		{
			m_ppiTradeRouteYieldChange[i] = yield;
		}
		
		m_ppiSpecialistYieldChange.clear();
		m_ppiSpecialistYieldChange.resize(GC.getNumSpecialistInfos());
		for(unsigned int i = 0; i < m_ppiSpecialistYieldChange.size(); ++i)
		{
			m_ppiSpecialistYieldChange[i] = yield;
		}
		
		m_ppiGreatPersonExpendedYield.clear();
		m_ppiGreatPersonExpendedYield.resize(GC.getNumGreatPersonInfos());
		for(unsigned int i = 0; i < m_ppiGreatPersonExpendedYield.size(); ++i)
		{
			m_ppiGreatPersonExpendedYield[i] = yield;
		}
		
		m_piGoldenAgeGreatPersonRateModifier.clear();
		m_piGoldenAgeGreatPersonRateModifier.resize(GC.getNumGreatPersonInfos(), 0);

		m_ppiUnimprovedFeatureYieldChange.clear();
		m_ppiUnimprovedFeatureYieldChange.resize(GC.getNumFeatureInfos());
		for(unsigned int i = 0; i < m_ppiUnimprovedFeatureYieldChange.size(); ++i)
		{
			m_ppiUnimprovedFeatureYieldChange[i] = yield;
		}
		
		m_ppiCityYieldFromUnimprovedFeature.clear();
		m_ppiCityYieldFromUnimprovedFeature.resize(GC.getNumFeatureInfos());
		for(unsigned int i = 0; i < m_ppiCityYieldFromUnimprovedFeature.size(); ++i)
		{
			m_ppiCityYieldFromUnimprovedFeature[i] = yield;
		}
		
		m_piYieldFromKills.clear();
		m_piYieldFromKills.resize(NUM_YIELD_TYPES, 0);

		m_piYieldFromBarbarianKills.clear();
		m_piYieldFromBarbarianKills.resize(NUM_YIELD_TYPES, 0);

		m_piYieldChangeTradeRoute.clear();
		m_piYieldChangeTradeRoute.resize(NUM_YIELD_TYPES, 0);

		m_piYieldChangesNaturalWonder.clear();
		m_piYieldChangesNaturalWonder.resize(NUM_YIELD_TYPES, 0);

		m_piYieldChangesPerReligion.clear();
		m_piYieldChangesPerReligion.resize(NUM_YIELD_TYPES, 0);

		m_piYieldChangeWorldWonder.clear();
		m_piYieldChangeWorldWonder.resize(NUM_YIELD_TYPES, 0);

		m_piYieldFromMinorDemand.clear();
		m_piYieldFromMinorDemand.resize(NUM_YIELD_TYPES, 0);

		m_piYieldFromWLTKD.clear();
		m_piYieldFromWLTKD.resize(NUM_YIELD_TYPES, 0);

		m_piCityFeatures.clear();
		m_piCityFeatures.resize(GC.getNumFeatureInfos(), 0);

		m_piNumBuildings.clear();
		m_piNumBuildings.resize(GC.getNumBuildingInfos(), 0);

		m_piNumBuildingsInPuppets.clear();
		m_piNumBuildingsInPuppets.resize(GC.getNumBuildingInfos(), 0);

		m_ppiBuildingClassYieldChange.clear();
		m_ppiBuildingClassYieldChange.resize(GC.getNumBuildingClassInfos());
		for(unsigned int i = 0; i < m_ppiBuildingClassYieldChange.size(); ++i)
		{
			m_ppiBuildingClassYieldChange.setAt(i, yield);
		}
#endif

#if defined(MOD_API_UNIFIED_YIELDS) && defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
		m_ppiSpecificGreatPersonRateModifierFromMonopoly.clear();
#endif

		m_ppaaiImprovementYieldChange.clear();
		m_ppaaiImprovementYieldChange.resize(GC.getNumImprovementInfos());
		for(unsigned int i = 0; i < m_ppaaiImprovementYieldChange.size(); ++i)
		{
			m_ppaaiImprovementYieldChange.setAt(i, yield);
		}

		m_ppaaiBuildingClassYieldMod.clear();
		m_ppaaiBuildingClassYieldMod.resize(GC.getNumBuildingClassInfos());
		for(unsigned int i = 0; i < m_ppaaiBuildingClassYieldMod.size(); ++i)
		{
			m_ppaaiBuildingClassYieldMod.setAt(i, yield);
		}
#if defined(MOD_BALANCE_CORE)
		m_ppiApproachScratchValue.clear();
		m_ppiApproachScratchValue.resize(MAX_MAJOR_CIVS);
		for(unsigned int i = 0; i < m_ppiApproachScratchValue.size(); ++i)
		{
			for(int iJ = 0; iJ < NUM_MAJOR_CIV_APPROACHES; ++iJ)
			{
				m_ppiApproachScratchValue[i][iJ] = 0;
			}
		}
#endif

		m_aVote.clear();
		m_aUnitExtraCosts.clear();

		AI_reset();
	}

	m_iNumUnitsSuppliedCached = -1;
}

//	--------------------------------------------------------------------------------
/// This is called after the map and other game constructs have been setup and just before the game starts.
void CvPlayer::gameStartInit()
{
#if defined(MOD_BALANCE_CORE)
	//make sure the non-serialized infos are up to date
	m_pDangerPlots->Init(GetID(), true);
#else
	// if the game is loaded, don't init the danger plots. This was already done in the serialization process.
	if(CvPreGame::gameStartType() != GAME_LOADED)
	{
		if(!GC.GetEngineUserInterface()->IsLoadedGame())
		{
			InitDangerPlots(); // moved this up because everyone should have danger plots inited. This is bad because saved games get much bigger for no reason.
		}
	}
#endif
	verifyAlive();
	if(!isAlive())
	{
		return;
	}

	if(!GC.GetEngineUserInterface()->IsLoadedGame())
	{
		UpdatePlots();
	}
}


//////////////////////////////////////
// graphical only setup
//////////////////////////////////////
void CvPlayer::setupGraphical()
{
	CvCity* pLoopCity;
	CvUnit* pLoopUnit;

	// Setup m_cities
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->setupGraphical();
	}

	// Setup m_units
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		pLoopUnit->setupGraphical();
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::initFreeState(CvGameInitialItemsOverrides& kOverrides)
{
	const CvHandicapInfo& kHandicapInfo = getHandicapInfo();

	// Starting Gold
	if(kOverrides.GrantInitialGoldPerPlayer[GetID()])
	{
		int iInitialGold = kHandicapInfo.getStartingGold() + GC.getGame().getStartEraInfo().getStartingGold();
		iInitialGold *= GC.getGame().getGameSpeedInfo().getTrainPercent();
		iInitialGold /= 100;
		GetTreasury()->SetGold(iInitialGold);
	}

	// Free Culture
	if(kOverrides.GrantInitialCulturePerPlayer[GetID()])
	{
		int iInitialCulture = kHandicapInfo.getStartingPolicyPoints() + GC.getGame().getStartEraInfo().getStartingCulture();
		iInitialCulture *= GC.getGame().getGameSpeedInfo().getTrainPercent();
		iInitialCulture /= 100;
		setJONSCulture(iInitialCulture);

		 // I think policy points is a better name than Jon's Culture, don't you?
		ChangeJONSCulturePerTurnForFree(kHandicapInfo.getFreeCulturePerTurn()); // No, IMNSHO ;P
	}
	// Extra Happiness from Luxuries
	ChangeExtraHappinessPerLuxury(kHandicapInfo.getExtraHappinessPerLuxury());

	// Free starting Resources
	for(int iLoop = 0; iLoop < GC.getNumResourceInfos(); iLoop++)
	{
		const ResourceTypes eResource = static_cast<ResourceTypes>(iLoop);
		CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
		if(pkResource)
		{
			if(pkResource->getStartingResourceQuantity() != 0)
			{
				changeNumResourceTotal(eResource, pkResource->getStartingResourceQuantity());
			}
		}

	}

	CalculateNetHappiness();

	clearResearchQueue();
}

//	--------------------------------------------------------------------------------
void CvPlayer::initFreeUnits(CvGameInitialItemsOverrides& /*kOverrides*/)
{
	UnitTypes eLoopUnit;
	int iFreeCount;
	int iDefaultAI;
	int iI, iJ;

	const CvEraInfo& gameStartEra = GC.getGame().getStartEraInfo();
	const CvHandicapInfo& gameHandicap = GC.getGame().getHandicapInfo();
	const CvHandicapInfo& playerHandicap = getHandicapInfo();
	const CvCivilizationInfo& playerCivilization = getCivilizationInfo();
#if defined(MOD_BALANCE_CORE)
	int iFree = 0;
#endif
	for(iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
	{
		const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
		CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
		if(pkUnitClassInfo)
		{
			eLoopUnit = (UnitTypes)playerCivilization.getCivilizationUnits(iI);

			if(eLoopUnit != NO_UNIT)
			{
				iFreeCount = playerCivilization.getCivilizationFreeUnitsClass(iI);
				iDefaultAI = playerCivilization.getCivilizationFreeUnitsDefaultUnitAI(iI);
#if defined(MOD_BALANCE_CORE)
				if(!canTrain(eLoopUnit) && iDefaultAI != UNITAI_SETTLE) 
				{
					// Loop through adding the available units
					for(int iUnitLoop = 0; iUnitLoop < GC.GetGameUnits()->GetNumUnits(); iUnitLoop++)
					{
						const UnitTypes eUnit = static_cast<UnitTypes>(iUnitLoop);
						CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
						if(pkUnitInfo)
						{
							// Make sure this unit can be built now
							if(canTrain(eUnit))
							{
								// Make sure it matches the requested unit AI type
								if(pkUnitInfo->GetDefaultUnitAIType() == iDefaultAI)
								{
									eLoopUnit = eUnit;
									break;
								}
							}
						}
					}
				}
#endif
				iFreeCount *= (gameStartEra.getStartingUnitMultiplier() + ((!isHuman()) ? gameHandicap.getAIStartingUnitMultiplier() : 0));

				// City states only get 1 of something
				if(isMinorCiv() && iFreeCount > 1)
					iFreeCount = 1;

				for(iJ = 0; iJ < iFreeCount; iJ++)
				{
					addFreeUnit(eLoopUnit,(UnitAITypes)iDefaultAI);
#if defined(MOD_BALANCE_CORE)
					if(iDefaultAI != UNITAI_SETTLE)
					{
						iFree++;
					}
#endif
				}
			}
		}
	}

	// Trait units
	int iUnitClass = GetPlayerTraits()->GetFirstFreeUnit(NO_TECH);
	while(iUnitClass != NO_UNITCLASS)
	{
		eLoopUnit = (UnitTypes)playerCivilization.getCivilizationUnits(iUnitClass);
		iDefaultAI = GC.GetGameUnits()->GetEntry(eLoopUnit)->GetDefaultUnitAIType();
		addFreeUnit(eLoopUnit,(UnitAITypes)iDefaultAI);

		// Another?
		iUnitClass = GetPlayerTraits()->GetNextFreeUnit();
	}

	// Defensive units
	iFreeCount = gameStartEra.getStartingDefenseUnits();
	iFreeCount += playerHandicap.getStartingDefenseUnits();
	if(!isHuman())
		iFreeCount += gameHandicap.getAIStartingDefenseUnits();
#if defined(MOD_BALANCE_CORE)
	iFreeCount -= iFree;
#endif
	if(iFreeCount > 0 && !isMinorCiv())
		addFreeUnitAI(UNITAI_DEFENSE, iFreeCount);

	// Worker units
	iFreeCount = gameStartEra.getStartingWorkerUnits();
	iFreeCount += playerHandicap.getStartingWorkerUnits();

	if(!isHuman())
		iFreeCount += gameHandicap.getAIStartingWorkerUnits();

	if(iFreeCount > 0 && !isMinorCiv())
		addFreeUnitAI(UNITAI_WORKER, iFreeCount);

	// Explore units
	iFreeCount = gameStartEra.getStartingExploreUnits();
	iFreeCount += playerHandicap.getStartingExploreUnits();

	if(!isHuman())
		iFreeCount += gameHandicap.getAIStartingExploreUnits();

	if(iFreeCount > 0 && !isMinorCiv())
		addFreeUnitAI(UNITAI_EXPLORE, iFreeCount);

#if defined(MOD_BALANCE_CORE)
	//Minor Civ Units
	if(isMinorCiv())
	{
		iFreeCount = gameStartEra.getStartingMinorDefenseUnits();
		iFreeCount += gameHandicap.getStartingMinorDefenseUnits();
		if(iFreeCount > 0)
		{
			addFreeUnitAI(UNITAI_DEFENSE, iFreeCount);
		}
	}
#endif
	// If we only have one military unit and it's on defense then change its AI to explore
	if(GetNumUnitsWithUnitAI(UNITAI_EXPLORE) == 0)
	{
#if defined(MOD_BALANCE_CORE)
		if(!isMinorCiv())
		{
#endif
		int iLoop;
		CvUnit* pLoopUnit;
		for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		{
			if(pLoopUnit->AI_getUnitAIType() == UNITAI_DEFENSE)
			{
				pLoopUnit->AI_setUnitAIType(UNITAI_EXPLORE);
				break;
			}
		}
#if defined(MOD_BALANCE_CORE)
		}
#endif
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::addFreeUnitAI(UnitAITypes eUnitAI, int iCount)
{
	int iI;

	UnitTypes eBestUnit = NO_UNIT;
	int iBestValue = 0;

	const CvCivilizationInfo& playerCivilzationInfo = getCivilizationInfo();
	for(iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
	{
		const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
		CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
		if(pkUnitClassInfo)
		{
			UnitTypes eLoopUnit = (UnitTypes)playerCivilzationInfo.getCivilizationUnits(iI);
			if(eLoopUnit != NO_UNIT)
			{
				CvUnitEntry* pUnitInfo = GC.getUnitInfo(eLoopUnit);
				if(pUnitInfo != NULL)
				{
					if(canTrain(eLoopUnit))
					{
						bool bValid = true;
						for(int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
						{
							const ResourceTypes eResource = static_cast<ResourceTypes>(iJ);
							CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
							if(pkResource)
							{
								if(pUnitInfo->GetResourceQuantityRequirement(iJ) > 0)
								{
									bValid = false;
								}
							}
						}

						if(bValid)
						{
							int iValue = 0;

							// Default unit AI matches
							if(pUnitInfo->GetDefaultUnitAIType() == eUnitAI)
								iValue += (pUnitInfo->GetProductionCost() * 2);
							// Not default, but still possible
							else if(pUnitInfo->GetUnitAIType(eUnitAI))
								iValue += (pUnitInfo->GetProductionCost());

							if(iValue > iBestValue)
							{
								eBestUnit = eLoopUnit;
								iBestValue = iValue;
							}
						}
					}
				}
			}
		}

	}

	if(eBestUnit != NO_UNIT)
	{
		for(iI = 0; iI < iCount; iI++)
		{
			addFreeUnit(eBestUnit, eUnitAI);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Returns plot where new unit was created
CvPlot* CvPlayer::addFreeUnit(UnitTypes eUnit, UnitAITypes eUnitAI)
{
	CvPlot* pStartingPlot;
#if defined(MOD_BUGFIX_FREE_RELIGIOUS_UNITS)
	CvPlot* pBestPlot = NULL;
#else
	CvPlot* pBestPlot;
#endif
	CvPlot* pLoopPlot;
	CvPlot* pReturnValuePlot = NULL;

	CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
	if(pkUnitInfo == NULL)
		return pReturnValuePlot;

#if defined(MOD_BUGFIX_FREE_RELIGIOUS_UNITS)
	// If pkUnitInfo is a religious unit AND the player has founded a religion, it MUST be dropped in the player's holy city
	if ((pkUnitInfo->IsSpreadReligion() || pkUnitInfo->IsRemoveHeresy()) && GetReligions()->HasCreatedReligion()) {
		CvCity* pHolyCity = GetHolyCity();
		if (pHolyCity && pHolyCity->getOwner() == GetID()) {
			// We have a holy city and we still own it
			pBestPlot = pHolyCity->plot();
		} else {
			// Ummm, our holy city either doesn't exist (maybe a mod razed it), or it belongs to someone else, better just drop this dude in the capital
			pBestPlot = getCapitalCity()->plot();
		}
	}
#endif

	if (isHuman() && GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE))
	{
		if((eUnitAI == UNITAI_SETTLE) || (pkUnitInfo->GetDefaultUnitAIType() == UNITAI_SETTLE))
		{
			if(GetNumUnitsWithUnitAI(UNITAI_SETTLE) >= 1)
			{
				return pReturnValuePlot;
			}
		}
	}

	// Venice can receive settlers but not build any ...
	if (GetPlayerTraits()->IsNoAnnexing())
	{
		// if we're trying to drop a settler
		if((eUnitAI == UNITAI_SETTLE) || (pkUnitInfo->GetDefaultUnitAIType() == UNITAI_SETTLE))
		{
			// if we already have a settler
			if(GetNumUnitsWithUnitAI(UNITAI_SETTLE) >= 1)
			{
				// drop a merchant of venice instead
				// find the eUnit replacement that's the merchant of venice
				for(int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
				{
					const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
					CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
					if(pkUnitClassInfo)
					{
						const UnitTypes eLocalUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eUnitClass);
						if (eLocalUnit != NO_UNIT)
						{
							CvUnitEntry* pUnitEntry = GC.getUnitInfo(eLocalUnit);
							if (pUnitEntry->IsCanBuyCityState())
							{
								// replacing the parameters
								eUnit = eLocalUnit;
								eUnitAI = (UnitAITypes)pkUnitInfo->GetDefaultUnitAIType();
								break;
							}
						}
					}
				}
			}
		}	
	}

	CvCity* pCapital = getCapitalCity();

	if(pCapital)
	{
		pStartingPlot = pCapital->plot();
	}
	else
	{
		pStartingPlot = getStartingPlot();
	}

	if(pStartingPlot != NULL)
	{
#if defined(MOD_BUGFIX_FREE_RELIGIOUS_UNITS)
		// If pBestPlot is not NULL, don't do any of this, as we have already determined the best plot
		if (pBestPlot == NULL) {
#else
			pBestPlot = NULL;
#endif

			if (true) //isHuman())
			{
				if (!(pkUnitInfo->IsFound()))
				{
					DirectionTypes eDirection;

					bool bDirectionValid;

					int iCount = 0;

					// Find a random direction
					do
					{
						bDirectionValid = true;

						eDirection = (DirectionTypes)GC.getGame().getJonRandNum(NUM_DIRECTION_TYPES, "Placing Starting Units");

						if (bDirectionValid)
						{
							pLoopPlot = plotDirection(pStartingPlot->getX(), pStartingPlot->getY(), eDirection);

#if defined(MOD_BUGFIX_NAVAL_FREE_UNITS)
							if (pkUnitInfo->GetDomainType() == DOMAIN_SEA) {
								if (pLoopPlot != NULL && pLoopPlot->isWater()) {
									if (!pLoopPlot->isImpassable()) {
										if (!(pLoopPlot->isUnit())) {
											pBestPlot = pLoopPlot;
											break;
										}
									}
								}
							}
							else {
#endif
								if (pLoopPlot != NULL && pLoopPlot->getArea() == pStartingPlot->getArea())
								{
									if (!pLoopPlot->isImpassable() && !pLoopPlot->isMountain())
									{
										if (!(pLoopPlot->isUnit()))
										{
											if (!(pLoopPlot->isGoody()))
											{
												pBestPlot = pLoopPlot;
												break;
											}
										}
									}
								}
#if defined(MOD_BUGFIX_NAVAL_FREE_UNITS)
							}
#endif
						}

						// Emergency escape.  Should only really break on Debug Micro map or something really funky
						iCount++;
					} while (iCount < 1000);
				}
			}

			if (pBestPlot == NULL)
			{
				pBestPlot = pStartingPlot;
			}
#if defined(MOD_BUGFIX_FREE_RELIGIOUS_UNITS)
		}
#endif

		CvUnit* pNewUnit = initUnit(eUnit, pBestPlot->getX(), pBestPlot->getY(), eUnitAI);
		if(getCapitalCity())
		{
			getCapitalCity()->addProductionExperience(pNewUnit);
		}
		CvAssert(pNewUnit != NULL);
		if (pNewUnit == NULL)
			return NULL;
#if defined(MOD_BALANCE_CORE)
		if(pNewUnit->isWLKTKDOnBirth())
		{
			CvCity* pLoopCity;
			int iLoop;
			for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				if(pLoopCity != NULL && pLoopCity->getOwner() == GetID())
				{
					int iWLTKD = (GC.getCITY_RESOURCE_WLTKD_TURNS() / 3);

					iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
					iWLTKD /= 100;

					if (iWLTKD > 0)
					{
						pLoopCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
						CvNotifications* pNotifications = GetNotifications();
						if (pNotifications)
						{
							Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UNIT");
							strText << pNewUnit->getNameKey() << pLoopCity->getNameKey();
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UNIT");
							strSummary << pLoopCity->getNameKey();
							pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pLoopCity->getX(), pLoopCity->getY(), -1);
						}
					}
				}
			}
		}
		if(pNewUnit->isGoldenAgeOnBirth())
		{
			int iGoldenAgeTurns = getGoldenAgeLength();
			int iValue = GetGoldenAgeProgressMeter();
			changeGoldenAgeTurns(iGoldenAgeTurns, iValue);
		}
		if(pNewUnit->isCultureBoost())
		{
			int iValue = GetTotalJONSCulturePerTurn() * 4;
			changeJONSCulture(iValue);
			if(getCapitalCity() != NULL)
			{
				getCapitalCity()->ChangeJONSCultureStored(iValue);
			}
			CvNotifications* pNotifications = GetNotifications();
			if (pNotifications)
			{
				Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CULTURE_UNIT");
				strText << pNewUnit->getNameKey();
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CULTURE_UNIT");
				strSummary << pNewUnit->getNameKey();
				pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pNewUnit->getX(), pNewUnit->getY(), -1);
			}
		}
		if(pNewUnit->getUnitInfo().IsSpreadReligion())
		{
			ReligionTypes eReligion = GetReligions()->GetReligionCreatedByPlayer();
			if(eReligion == NO_RELIGION)
			{
				eReligion = GetReligions()->GetReligionInMostCities();
			}
			int iReligionSpreads = pNewUnit->getUnitInfo().GetReligionSpreads();
			int iReligiousStrength = pNewUnit->getUnitInfo().GetReligiousStrength();
#if defined(MOD_BALANCE_CORE)
			iReligiousStrength *= (100 + GetPlayerTraits()->GetExtraMissionaryStrength());
			iReligiousStrength /= 100;
#endif
			if(iReligionSpreads > 0 && eReligion > RELIGION_PANTHEON)
			{
#if defined(MOD_BUGFIX_EXTRA_MISSIONARY_SPREADS)
				if (MOD_BUGFIX_EXTRA_MISSIONARY_SPREADS)
				{
					if (GetHolyCity() && GetHolyCity()->getOwner() == GetID())
					{
						pNewUnit->GetReligionData()->SetSpreadsLeft(iReligionSpreads + GetHolyCity()->GetCityBuildings()->GetMissionaryExtraSpreads() + GetNumMissionarySpreads());
					}
					else if (getCapitalCity())
					{
						pNewUnit->GetReligionData()->SetSpreadsLeft(iReligionSpreads + getCapitalCity()->GetCityBuildings()->GetMissionaryExtraSpreads() + GetNumMissionarySpreads());
					}
					else
					{
						pNewUnit->GetReligionData()->SetSpreadsLeft(iReligionSpreads);
					}
				}
				else
				{
					pNewUnit->GetReligionData()->SetSpreadsLeft(iReligionSpreads);
				}
#else
				pNewUnit->GetReligionData()->SetSpreadsLeft(iReligionSpreads);
#endif
				pNewUnit->GetReligionData()->SetReligiousStrength(iReligiousStrength);
				pNewUnit->GetReligionData()->SetReligion(eReligion);
			}
		}
#endif
		// Don't stack any units
		if(pBestPlot->getNumUnits() > 1)
		{
			if (!pNewUnit->jumpToNearestValidPlot())
			{
				// Could not find a spot for the unit
				pNewUnit->kill(false);		
				return NULL;
			}
		}
		pReturnValuePlot = pNewUnit->plot();
	}

	return pReturnValuePlot;
}


//	--------------------------------------------------------------------------------
#if defined(MOD_API_EXTENSIONS) && defined(MOD_BALANCE_CORE)
CvCity* CvPlayer::initCity(int iX, int iY, bool bBumpUnits, bool bInitialFounding, ReligionTypes eInitialReligion, const char* szName, CvUnitEntry* pkSettlerUnitEntry)
#elif defined(MOD_API_EXTENSIONS)
CvCity* CvPlayer::initCity(int iX, int iY, bool bBumpUnits, bool bInitialFounding, ReligionTypes eInitialReligion, const char* szName)
#elif defined(MOD_BALANCE_CORE)
CvCity* CvPlayer::initCity(int iX, int iY, bool bBumpUnits, bool bInitialFounding, CvUnitEntry* pkSettlerUnitEntry)
#else
CvCity* CvPlayer::initCity(int iX, int iY, bool bBumpUnits, bool bInitialFounding)
#endif
{
	CvCity* pNewCity = addCity();

	CvAssertMsg(pNewCity != NULL, "City is not assigned a valid value");
	if(pNewCity != NULL)
	{
		CvAssertMsg(!(GC.getMap().plot(iX, iY)->isCity()), "No city is expected at this plot when initializing new city");
#if defined(MOD_API_EXTENSIONS) && defined(MOD_BALANCE_CORE)
		pNewCity->init(pNewCity->GetID(), GetID(), iX, iY, bBumpUnits, bInitialFounding, eInitialReligion, szName, pkSettlerUnitEntry);
#elif defined(MOD_API_EXTENSIONS)
		pNewCity->init(pNewCity->GetID(), GetID(), iX, iY, bBumpUnits, bInitialFounding, eInitialReligion, szName);
#elif defined(MOD_BALANCE_CORE)
		pNewCity->init(pNewCity->GetID(), GetID(), iX, iY, bBumpUnits, bInitialFounding, pkSettlerUnitEntry);
#else
		pNewCity->init(pNewCity->GetID(), GetID(), iX, iY, bBumpUnits, bInitialFounding);
#endif
		pNewCity->GetCityStrategyAI()->UpdateFlavorsForNewCity();
		pNewCity->DoUpdateCheapestPlotInfluenceDistance();

		GC.getGame().SetClosestCityMapDirty();

#if defined(MOD_BALANCE_CORE)
		int iLoop=0;
		for (CvCity* pCity=firstCity(&iLoop); pCity!=NULL; pCity=nextCity(&iLoop))
			pCity->UpdateClosestFriendlyNeighbors();
#endif
	}

	return pNewCity;
}

//	--------------------------------------------------------------------------------
// NOTE: bGift set to true if the city is given as a gift, as in the case for trades and Austria UA of annexing city-states
#if defined(MOD_API_EXTENSIONS)
#if defined(MOD_GLOBAL_VENICE_KEEPS_RESOURCES)
CvCity* CvPlayer::acquireCity(CvCity* pOldCity, bool bConquest, bool bGift, bool bVenice)
#else
CvCity* CvPlayer::acquireCity(CvCity* pOldCity, bool bConquest, bool bGift)
#endif
#else
#if defined(MOD_GLOBAL_VENICE_KEEPS_RESOURCES)
void CvPlayer::acquireCity(CvCity* pOldCity, bool bConquest, bool bGift, bool bVenice)
#else
void CvPlayer::acquireCity(CvCity* pOldCity, bool bConquest, bool bGift)
#endif
#endif
{
	if(pOldCity == NULL)
#if defined(MOD_API_EXTENSIONS)
		return NULL;
#else
		return;
#endif

	IDInfo* pUnitNode;
	CvCity* pNewCity;
	CvUnit* pLoopUnit;
	CvPlot* pCityPlot;

	CvString strBuffer;
	CvString strName;
	bool abEverOwned[MAX_PLAYERS];
	PlayerTypes eOldOwner;
	PlayerTypes eOriginalOwner;
	BuildingTypes eBuilding;
	bool bRecapture;
	int iCaptureGold;
	int iCaptureCulture;
	int iCaptureGreatWorks;
	int iGameTurnFounded;
	int iPopulation;
	int iHighestPopulation;
	int iOldPopulation;
	int iBattleDamage;
	int iI;
	FFastSmallFixedList<IDInfo, 25, true, c_eCiv5GameplayDLL > oldUnits;
	CvCityReligions tempReligions;
	bool bIsMinorCivBuyout = (pOldCity->GetPlayer()->isMinorCiv() && bGift && (IsAbleToAnnexCityStates() || GetPlayerTraits()->IsNoAnnexing())); // Austria and Venice UA

	pCityPlot = pOldCity->plot();

	pUnitNode = pCityPlot->headUnitNode();

	while(pUnitNode != NULL)
	{
		oldUnits.insertAtEnd(pUnitNode);
		pUnitNode = pCityPlot->nextUnitNode((IDInfo*)pUnitNode);
	}

	pUnitNode = oldUnits.head();

	while(pUnitNode != NULL)
	{
		pLoopUnit = ::getUnit(*pUnitNode);
		pUnitNode = oldUnits.next(pUnitNode);

		if(pLoopUnit && pLoopUnit->getTeam() != getTeam())
		{
			if(pLoopUnit->IsImmobile() && !pLoopUnit->isCargo())
			{
				pLoopUnit->kill(false, GetID());
#if defined(MOD_API_EXTENSIONS)
				DoUnitKilledCombat(NULL, pLoopUnit->getOwner(), pLoopUnit->getUnitType());
#else
				DoUnitKilledCombat(pLoopUnit->getOwner(), pLoopUnit->getUnitType());
#endif
			}
		}
	}
	if(bConquest)
	{
#if defined(MOD_BALANCE_CORE)
		if(!isHuman())
		{
			GetDiplomacyAI()->SetPlayerNumTurnsSinceCityCapture(pOldCity->getOwner(), 0);
		}
		GET_PLAYER(pOldCity->getOwner()).GetDiplomacyAI()->SetPlayerNumTurnsSinceCityCapture(GetID(), 0);
#endif
#if defined(MOD_BALANCE_CORE)
		if (pOldCity->GetCityReligions()->IsHolyCityAnyReligion())
		{
			UpdateReligion();
		}

#endif
		CvNotifications* pNotifications = GET_PLAYER(pOldCity->getOwner()).GetNotifications();
		if(pNotifications)
		{
			Localization::String locString = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_LOST");
			locString << pOldCity->getNameKey() << getNameKey();
			Localization::String locSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_LOST");
			locSummary << pOldCity->getNameKey();

#if defined(MOD_BALANCE_CORE)
			if(pOldCity->GetCityReligions()->IsHolyCityAnyReligion())
			{
				ReligionTypes eReligion = pOldCity->GetCityReligions()->GetReligionForHolyCity();
				const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, NO_PLAYER);
				if(pReligion)
				{
					CvString szReligionName = pReligion->GetName();
					locString = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_LOST_HOLY");
					locString << pOldCity->getNameKey() << getNameKey() << szReligionName;
					locSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_LOST_HOLY");
					locSummary << pOldCity->getNameKey();
				}
			}

#endif
			pNotifications->Add(NOTIFICATION_CITY_LOST, locString.toUTF8(), locSummary.toUTF8(), pOldCity->getX(), pOldCity->getY(), -1);
		}
#if defined(MOD_DIPLOMACY_CITYSTATES_QUESTS)
		if(MOD_DIPLOMACY_CITYSTATES_QUESTS && pOldCity->isBarbarian())
		{
			CvBarbarians::DoBarbCityCleared(pOldCity->plot());
		}
#endif

		if(!isBarbarian() && !pOldCity->isBarbarian())
		{
			int iDefaultCityValue = /*150*/ GC.getWAR_DAMAGE_LEVEL_CITY_WEIGHT();

			// Notify Diplo AI that damage has been done
			int iValue = iDefaultCityValue;
			iValue += pOldCity->getPopulation() * /*100*/ GC.getWAR_DAMAGE_LEVEL_INVOLVED_CITY_POP_MULTIPLIER();
			if (pOldCity->IsOriginalCapital())
			{
				iValue *= 3;
				iValue /= 2;
			}
#if defined(MOD_BALANCE_CORE)
			if(pOldCity->getNumWorldWonders() > 0)
			{
				iValue += (pOldCity->getNumWorldWonders() * /*100*/ GC.getWAR_DAMAGE_LEVEL_INVOLVED_CITY_POP_MULTIPLIER());
			}

			int iNumTimesOwned(pOldCity->GetNumTimesOwned(GetID()));
			if (iNumTimesOwned > 1)
			{
				iValue /= (iNumTimesOwned * 3);
			}
#endif

			int iWarscoremod = GetWarScoreModifier();
			if (iWarscoremod != 0)
			{
				iValue *= (iWarscoremod + 100);
				iValue /= 100;
			}

			// My viewpoint
			GetDiplomacyAI()->ChangeOtherPlayerWarValueLost(pOldCity->getOwner(), GetID(), iValue);
			// Bad guy's viewpoint
			GET_PLAYER(pOldCity->getOwner()).GetDiplomacyAI()->ChangeWarValueLost(GetID(), iValue);

			// zero out any liberation credit since we just captured a city from them
			PlayerTypes ePlayer;
			CvDiplomacyAI* pOldOwnerDiploAI = GET_PLAYER(pOldCity->getOwner()).GetDiplomacyAI();
			pOldOwnerDiploAI->SetPlayerLiberatedCapital(GetID(), false);
			pOldOwnerDiploAI->SetNumCitiesLiberatedBy(GetID(), 0);
			pOldOwnerDiploAI->SetMasterLiberatedMeFromVassalage(GetID(), false);
			pOldOwnerDiploAI->SetTurnsSinceVassalagePeacefullyRevoked(GetID(), -1);
			
			// clear positive diplomatic values
			pOldOwnerDiploAI->SetNumCiviliansReturnedToMe(GetID(), 0);
			pOldOwnerDiploAI->SetNumLandmarksBuiltForMe(GetID(), 0);
			pOldOwnerDiploAI->SetNumTimesIntrigueSharedBy(GetID(), 0);
			pOldOwnerDiploAI->SetCommonFoeValue(GetID(), 0);
			if (pOldOwnerDiploAI->GetRecentAssistValue(GetID()) < 0)
				pOldOwnerDiploAI->SetRecentAssistValue(GetID(), 0);
			
			// increment captured city counter
			pOldOwnerDiploAI->ChangeNumCitiesCapturedBy(GetID(), 1);

			iValue = iDefaultCityValue;
			iValue += pOldCity->getPopulation() * /*120*/ GC.getWAR_DAMAGE_LEVEL_UNINVOLVED_CITY_POP_MULTIPLIER();

			// Now update everyone else in the world, but use a different multiplier (since they don't have complete info on the situation - they don't know when Units are killed)
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
			{
				ePlayer = (PlayerTypes) iPlayerLoop;

				// Not us and not the player we acquired City from
				if(ePlayer != GetID() && ePlayer != pOldCity->getOwner())
				{
					GET_PLAYER(ePlayer).GetDiplomacyAI()->ChangeOtherPlayerWarValueLost(pOldCity->getOwner(), GetID(), iValue);
				}
			}

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
			if (MOD_DIPLOMACY_CIV4_FEATURES) {
				// Only on conquest
				if(bConquest) {
					// Vassalage stuff
					TeamTypes eMaster = GET_TEAM(GET_PLAYER(pOldCity->getOwner()).getTeam()).GetMaster();
					if(eMaster != NO_TEAM) {
						for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
						{
							ePlayer = (PlayerTypes) iPlayerLoop;
						
							if(GET_PLAYER(ePlayer).getTeam() == eMaster) {
								// This team was the master of the loser's team
								if(GET_PLAYER(pOldCity->getOwner()).getTeam() == eMaster)
								{
									// Master's failed protect score goes up for Vassal
									GET_PLAYER(pOldCity->getOwner()).GetDiplomacyAI()->ChangeVassalFailedProtectValue(ePlayer, iValue);
								}

								// Notify Diplo AI that our master has killed a city in a civ near our empire
								// Conquering team is the master
								if(getTeam() == eMaster)
								{
									// Old city was neighbors to us
									if(GET_PLAYER(ePlayer).GetProximityToPlayer(pOldCity->getOwner()) <= PLAYER_PROXIMITY_CLOSE)
									{
										// Master protected us against our enemy!
										GET_PLAYER(ePlayer).GetDiplomacyAI()->ChangeVassalProtectValue(GetID(), iValue);
									}
								}
							}
						}
					}
				}
			}
#endif
		}

		GetMilitaryAI()->LogCityCaptured(pOldCity, pOldCity->getOwner());
	}

#if defined(MOD_BALANCE_CORE)
	// Check if we want to keep this city - compare yields with our capital
	bool bAllowRaze = true;
	CvCity* pCapital = getCapitalCity();
	if (pCapital)
	{
		int iGoodCategories = 0;
		for (int i = 0; i < 6; i++)
			if (pOldCity->getYieldRateTimes100((YieldTypes)i, true) * 2 > pCapital->getYieldRateTimes100((YieldTypes)i, true))
				iGoodCategories++;

		bAllowRaze = (iGoodCategories < 3);
	}

	// Remove Corporation from this city if acquired to another player by any means
	if (pOldCity->getOwner() != NO_PLAYER && pOldCity->getOwner() != GetID())
	{
		GET_PLAYER(pOldCity->getOwner()).GetCorporations()->ClearAllCorporationsFromCity(pOldCity);
	}
	if (GET_PLAYER(pOldCity->getOwner()).isMinorCiv())
	{
		GET_PLAYER(pOldCity->getOwner()).GetMinorCivAI()->DoUpdateAlliesResourceBonus(GET_PLAYER(pOldCity->getOwner()).GetMinorCivAI()->GetAlly(), GET_PLAYER(pOldCity->getOwner()).GetMinorCivAI()->GetAlly());
	}
#endif

	if(pOldCity->getOriginalOwner() == pOldCity->getOwner())
	{
		GET_PLAYER(pOldCity->getOriginalOwner()).changeCitiesLost(1);
	}
	else if(pOldCity->getOriginalOwner() == GetID())
	{
		GET_PLAYER(pOldCity->getOriginalOwner()).changeCitiesLost(-1);
	}

	if(bConquest)
	{
		if(GetID() == GC.getGame().getActivePlayer())
		{
			strBuffer = GetLocalizedText("TXT_KEY_MISC_CAPTURED_CITY", pOldCity->getNameKey()).GetCString();
			GC.GetEngineUserInterface()->AddCityMessage(0, pOldCity->GetIDInfo(), GetID(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_CITYCAPTURE", MESSAGE_TYPE_MAJOR_EVENT, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pOldCity->getX(), pOldCity->getY(), true, true*/);
		}

		strName.Format("%s (%s)", pOldCity->getName().GetCString(), GET_PLAYER(pOldCity->getOwner()).getName());

		for(iI = 0; iI < MAX_PLAYERS; iI++)
		{
			if((PlayerTypes)iI == GC.getGame().getActivePlayer())
			{
				if(GET_PLAYER((PlayerTypes)iI).isAlive())
				{
					if(iI != GetID())
					{
						if(pOldCity->isRevealed(GET_PLAYER((PlayerTypes)iI).getTeam(), false))
						{
							strBuffer = GetLocalizedText("TXT_KEY_MISC_CITY_CAPTURED_BY", strName.GetCString(), getCivilizationShortDescriptionKey());
							GC.GetEngineUserInterface()->AddCityMessage(0, pOldCity->GetIDInfo(), ((PlayerTypes)iI), false, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_CITYCAPTURED", MESSAGE_TYPE_MAJOR_EVENT, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pOldCity->getX(), pOldCity->getY(), true, true*/);
						}
					}
				}
			}
		}

		strBuffer = GetLocalizedText("TXT_KEY_MISC_CITY_WAS_CAPTURED_BY", strName.GetCString(), getCivilizationShortDescriptionKey());
		GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, GetID(), strBuffer, pOldCity->getX(), pOldCity->getY());

#ifndef FINAL_RELEASE
		OutputDebugString("\n"); OutputDebugString(strBuffer); OutputDebugString("\n\n");
#endif
#if defined(MOD_BALANCE_CORE)
		CvNotifications* pNotifications2 = GetNotifications();
		if(pNotifications2)
		{
			if(pOldCity->GetCityReligions()->IsHolyCityAnyReligion())
			{
				ReligionTypes eReligion = pOldCity->GetCityReligions()->GetReligionForHolyCity();
				const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, NO_PLAYER);
				if(pReligion)
				{
					CvString szReligionName = pReligion->GetName();
					Localization::String locString = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_GAINED_HOLY");
					locString << pOldCity->getNameKey() << szReligionName;
					Localization::String locSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_GAINED_HOLY");
					locSummary << pOldCity->getNameKey();

					pNotifications2->Add(NOTIFICATION_CAPITAL_RECOVERED, locString.toUTF8(), locSummary.toUTF8(), pOldCity->getX(), pOldCity->getY(), -1);
				}
			}
		}
#endif
	}

	iCaptureGold = 0;
	iCaptureCulture = 0;
	iCaptureGreatWorks = 0;

	if(bConquest)
	{
		iCaptureGold = 0;

		iCaptureGold += GC.getBASE_CAPTURE_GOLD();
		iCaptureGold += (pOldCity->getPopulation() * GC.getCAPTURE_GOLD_PER_POPULATION());
		iCaptureGold += GC.getGame().getSmallFakeRandNum(GC.getCAPTURE_GOLD_RAND1(), pOldCity->plot()->GetPlotIndex()) * 2;
		iCaptureGold += GC.getGame().getSmallFakeRandNum(GC.getCAPTURE_GOLD_RAND2(), GET_PLAYER(pOldCity->getOwner()).GetPseudoRandomSeed()) * 2;

		if(GC.getCAPTURE_GOLD_MAX_TURNS() > 0)
		{
			iCaptureGold *= range((GC.getGame().getGameTurn() - pOldCity->getGameTurnAcquired()), 0, GC.getCAPTURE_GOLD_MAX_TURNS());
			iCaptureGold /= GC.getCAPTURE_GOLD_MAX_TURNS();
		}

		iCaptureGold *= (100 + pOldCity->getCapturePlunderModifier()) / 100;
		iCaptureGold *= (100 + GetPlayerTraits()->GetPlunderModifier()) / 100;
	}

	GetTreasury()->ChangeGold(iCaptureGold);

	if(bConquest)
	{
		iCaptureCulture = pOldCity->getJONSCulturePerTurn();
		iCaptureCulture *= GetPlayerPolicies()->GetNumericModifier(POLICYMOD_CULTURAL_PLUNDER_MULTIPLIER);

		if(iCaptureCulture > 0)
		{
			changeJONSCulture(iCaptureCulture);
		}
	}

	if(bConquest)
	{
		if (GetPlayerTraits()->IsTechFromCityConquer())
		{
			// Will this be the first time we have owned this city?
			if (!pOldCity->isEverOwned(GetID()))
			{
#if defined(MOD_ALTERNATE_ASSYRIA_TRAIT)
				if(MOD_ALTERNATE_ASSYRIA_TRAIT)
				{
					if(!isHuman())
					{
						AI_chooseFreeTech();
					}
					else
					{
						const char* strTargetNameKey = pOldCity->getNameKey();
						Localization::String localizedText = Localization::Lookup("TXT_KEY_SCIENCE_BOOST_CONQUEST_ASSYRIA");
						localizedText << strTargetNameKey;
						chooseTech(1, localizedText.toUTF8());
					}
				}
				else
					DoTechFromCityConquer(pOldCity);
#else
				DoTechFromCityConquer(pOldCity);
#endif
			}
		}
#if defined(MOD_BALANCE_CORE)
		if(GetPlayerTraits()->IsConquestOfTheWorld())
		{
			if (!pOldCity->isEverOwned(GetID()))
			{
				int iValue = GetGoldenAgeProgressMeter();
				if(isGoldenAge())
				{
					changeGoldenAgeTurns(3, iValue);
				}
				else
				{
					changeGoldenAgeTurns(5, iValue);
				}
			}
		}
#endif
	}
#if defined(MOD_BALANCE_CORE)
	if (!pOldCity->isEverOwned(GetID()))
	{
		int iExtraTerritoryClaim = GetPlayerTraits()->GetExtraConqueredCityTerritoryClaimRange();
		for (int i = 0; i < iExtraTerritoryClaim; i++)
		{
			CvPlot* pPlotToAcquire = pOldCity->GetNextBuyablePlot(false);

			// maybe the player owns ALL of the plots or there are none available?
			if(pPlotToAcquire)
			{
				pOldCity->DoAcquirePlot(pPlotToAcquire->getX(), pPlotToAcquire->getY());
			}
		}
	}
#endif
#if defined(MOD_BALANCE_CORE)
	if(bConquest && MOD_BALANCE_CORE)
	{
		// Will this be the first time we have owned this city?
		if (!pOldCity->isEverOwned(GetID()))
		{
			if (GetPlayerTraits()->GetCultureBonusModifierConquest() > 0)
			{
				int iValue = (pOldCity->getPopulation() / 2);
				iValue *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
				iValue /= 100;
				if (iValue > 0)
				{
					ChangeCultureBonusTurnsConquest(iValue);
					if (GetID() == GC.getGame().getActivePlayer())
					{
						Localization::String strMessage;
						Localization::String strSummary;
						strMessage = Localization::Lookup("TXT_KEY_CULTURE_BOOST_ART");
						strMessage << iValue;
						strMessage << pOldCity->getNameKey();
						strMessage << GetPlayerTraits()->GetCultureBonusModifierConquest();
						strSummary = Localization::Lookup("TXT_KEY_CULTURE_BOOST_ART_SUMMARY");

						CvNotifications* pNotification = GetNotifications();
						if (pNotification)
						{
							pNotification->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), pOldCity->getX(), pOldCity->getY(), (int)pOldCity->GetID(), GetID());
						}
					}
					if ((GC.getLogging() && GC.getAILogging()))
					{
						CvGameCulture *pCulture = GC.getGame().GetGameCulture();
						if (pCulture)
						{
							CvString strLogString;
							strLogString.Format("Conquest culture boost: %d", (pOldCity->getPopulation() / 2));
							GetHomelandAI()->LogHomelandMessage(strLogString);
						}
					}
				}
			}
			if (GetPlayerTraits()->GetProductionBonusModifierConquest() > 0)
			{
				int iValue = (pOldCity->getPopulation() / 2);
				iValue *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
				iValue /= 100;
				if (iValue > 0)
				{
					ChangeProductionBonusTurnsConquest(iValue);
					if (GetID() == GC.getGame().getActivePlayer())
					{
						Localization::String strMessage;
						Localization::String strSummary;
						strMessage = Localization::Lookup("TXT_KEY_PRODUCTION_BOOST_ART");
						strMessage << (pOldCity->getPopulation() / 2);
						strMessage << pOldCity->getNameKey();
						strMessage << GetPlayerTraits()->GetProductionBonusModifierConquest();
						strSummary = Localization::Lookup("TXT_KEY_PRODUCTION_BOOST_ART_SUMMARY");

						CvNotifications* pNotification = GetNotifications();
						if (pNotification)
						{
							pNotification->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), pOldCity->getX(), pOldCity->getY(), (int)pOldCity->GetID(), GetID());
						}
					}
					if ((GC.getLogging() && GC.getAILogging()))
					{
						CvGameCulture *pCulture = GC.getGame().GetGameCulture();
						if (pCulture)
						{
							CvString strLogString;
							strLogString.Format("Conquest production boost: %d", (pOldCity->getPopulation() / 2));
							GetHomelandAI()->LogHomelandMessage(strLogString);
						}
					}
				}
			}
			if (GetPlayerTraits()->IsFreeGreatWorkOnConquest())
			{
				DoFreeGreatWorkOnConquest(pOldCity->getOwner(), pOldCity);
			}
			if (GetPlayerTraits()->GetCityConquestGWAM() > 0)
			{
				doInstantGWAM(NO_GREATPERSON, pOldCity->getName(), true);
			}
#if defined(MOD_BALANCE_CORE)
			if (GetPlayerTraits()->IsExpansionWLTKD())
			{
				int iWLTKD = (GC.getCITY_RESOURCE_WLTKD_TURNS() / 3);

				iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iWLTKD /= 100;

				if (iWLTKD > 0)
				{
					CvCity* pLoopCity;
					int iCityLoop;

					// Loop through owner's cities.
					for (pLoopCity = firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = nextCity(&iCityLoop))
					{
						if (pLoopCity != NULL)
						{
							pLoopCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
						}
					}
					CvNotifications* pNotifications = GetNotifications();
					if (pNotifications)
					{
						Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UA_CITY_CONQUEST");
						strText << iWLTKD << GetPlayerTraits()->GetGrowthBoon();
						Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UA_CITY_CONQUEST");
						pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pOldCity->getX(), pOldCity->getY(), -1);
					}
				}
			}
#endif
		}
	}
#endif
#if defined(MOD_BALANCE_CORE_BELIEFS)
	if(bConquest)
	{
		if (!pOldCity->isEverOwned(GetID()))
		{
			int iScaler = pOldCity->getPopulation() / 2;
			iScaler -= GetCurrentEra();
			if(iScaler <= 0)
			{
				iScaler = 1;
			}
			doInstantYield(INSTANT_YIELD_TYPE_F_CONQUEST, false, NO_GREATPERSON, NO_BUILDING, iScaler, true, NO_PLAYER, NULL, false, NULL, pOldCity->isCoastal(), true, false, NO_YIELD, NULL, NO_TERRAIN, NULL, pOldCity);

			if(MOD_BALANCE_CORE_LUXURIES_TRAIT && !isMinorCiv() && !isBarbarian() && (GetPlayerTraits()->GetUniqueLuxuryQuantity() > 0))
			{
				GetPlayerTraits()->AddUniqueLuxuriesAround(pOldCity, GetPlayerTraits()->GetUniqueLuxuryQuantity());
			}
		}
		if(MOD_BALANCE_CORE_AFRAID_ANNEX)
		{
			if(GetPlayerTraits()->IsBullyAnnex() && !bGift)
			{
				if(pOldCity->GetPlayer()->isMinorCiv() && !pOldCity->isEverOwned(GetID()))
				{
					//int iGoldenAge = pOldCity->getPopulation() * 20;
					//ChangeGoldenAgeProgressMeter(iGoldenAge);
					//do we get a lump some of yields from this?
					if (GetPlayerTraits()->GetBullyYieldMultiplierAnnex() != 0)
					{
						MinorCivTraitTypes eTrait = pOldCity->GetPlayer()->GetMinorCivAI()->GetTrait();

						switch (eTrait)
						{
						case(MINOR_CIV_TRAIT_CULTURED) :
						{
							int iYield = pOldCity->GetPlayer()->GetMinorCivAI()->GetYieldTheftAmount(GetID(), YIELD_CULTURE);
							iYield *= GetPlayerTraits()->GetBullyYieldMultiplierAnnex();
							iYield /= 100;
							doInstantYield(INSTANT_YIELD_TYPE_BULLY, true, NO_GREATPERSON, NO_BUILDING, iYield, true, NO_PLAYER, NULL, false, getCapitalCity(), false, true, false, YIELD_CULTURE);
							break;
						}
						case(MINOR_CIV_TRAIT_MARITIME) :
						{
							int iYield = pOldCity->GetPlayer()->GetMinorCivAI()->GetYieldTheftAmount(GetID(), YIELD_FOOD);
							iYield *= GetPlayerTraits()->GetBullyYieldMultiplierAnnex();
							iYield /= 100;
							doInstantYield(INSTANT_YIELD_TYPE_BULLY, true, NO_GREATPERSON, NO_BUILDING, iYield, true, NO_PLAYER, NULL, false, getCapitalCity(), false, true, false, YIELD_FOOD);
							break;
						}
						case(MINOR_CIV_TRAIT_MERCANTILE) :
						{
							int iYield = pOldCity->GetPlayer()->GetMinorCivAI()->GetYieldTheftAmount(GetID(), YIELD_GOLD);
							iYield *= GetPlayerTraits()->GetBullyYieldMultiplierAnnex();
							iYield /= 100;
							doInstantYield(INSTANT_YIELD_TYPE_BULLY, true, NO_GREATPERSON, NO_BUILDING, iYield, true, NO_PLAYER, NULL, false, getCapitalCity(), false, true, false, YIELD_GOLD);
							break;
						}
						case(MINOR_CIV_TRAIT_MILITARISTIC) :
						{
							int iYield = pOldCity->GetPlayer()->GetMinorCivAI()->GetYieldTheftAmount(GetID(), YIELD_SCIENCE);
							iYield *= GetPlayerTraits()->GetBullyYieldMultiplierAnnex();
							iYield /= 100;
							doInstantYield(INSTANT_YIELD_TYPE_BULLY, true, NO_GREATPERSON, NO_BUILDING, iYield, true, NO_PLAYER, NULL, false, getCapitalCity(), false, true, false, YIELD_SCIENCE);
							break;
						}
						case(MINOR_CIV_TRAIT_RELIGIOUS) :
						{
							int iYield = pOldCity->GetPlayer()->GetMinorCivAI()->GetYieldTheftAmount(GetID(), YIELD_FAITH);
							iYield *= GetPlayerTraits()->GetBullyYieldMultiplierAnnex();
							iYield /= 100;
							doInstantYield(INSTANT_YIELD_TYPE_BULLY, true, NO_GREATPERSON, NO_BUILDING, iYield, true, NO_PLAYER, NULL, false, getCapitalCity(), false, true, false, YIELD_FAITH);
							break;
						}
						}
					}
				}
			}
		}
	}
#endif

	// slewis - warmonger calculations
	if (bConquest)
	{
#if defined(MOD_DIPLOMACY_CITYSTATES_QUESTS)
		if(!isMinorCiv() && !isBarbarian())
#else
		if(!isMinorCiv())
#endif
		{
			bool bDoWarmonger = true;

			// Don't award warmongering if you're conquering a city you owned back
			if (pOldCity->getOriginalOwner() == GetID())
			{
				bDoWarmonger = false;
			}
#if defined(MOD_BALANCE_CORE)
			// Don't award warmongering if you're conquering a city that you were the last to own.
			if (pOldCity->getPreviousOwner() == GetID())
			{
				bDoWarmonger = false;
			}
			//Captured a city from barbs? Everyone likes that!
			if(GET_PLAYER(pOldCity->getOwner()).isBarbarian())
			{
				bDoWarmonger = false;
			}
			PlayerTypes eLiberatedPlayer = NO_PLAYER;

			// Captured someone's city that didn't originally belong to us - Liberate a player?
			eOldOwner = pOldCity->getOwner();
			if(pOldCity->getOriginalOwner() != eOldOwner && pOldCity->getOriginalOwner() != GetID())
			{
				eLiberatedPlayer = pOldCity->getOriginalOwner();
				if (IsAtWarWith(eLiberatedPlayer) && pOldCity->getOriginalOwner() != pOldCity->getPreviousOwner() && pOldCity->getPreviousOwner() != NO_PLAYER)
				{
					if (GET_PLAYER(pOldCity->getPreviousOwner()).isMinorCiv())
					{
						eLiberatedPlayer = pOldCity->getPreviousOwner();
					}
				}
				if(eLiberatedPlayer != NO_PLAYER)
				{
					if (CanLiberatePlayerCity(eLiberatedPlayer))
					{
						bDoWarmonger = false;
						pOldCity->SetNoWarmonger(true);
					}
				}
			}
#endif

			if (bDoWarmonger)
			{
				CvDiplomacyAIHelpers::ApplyWarmongerPenalties(GetID(), pOldCity->getOwner(), pOldCity);
#if defined(MOD_BALANCE_CORE)
				pOldCity->SetNoWarmonger(false);
#endif
			}
		}
	}
#if defined(MOD_BALANCE_CORE)
	//Let's not slaughter citizens in a city we've owned before.
	bool bSlaughter = true;
	if(bConquest)
	{
		//Our city originally? Don't slaughter.
		if(pOldCity->getOriginalOwner() == GetID())
		{
			bSlaughter = false;
		}
		//We are liberators, so don't slaughter.
		if(pOldCity->isBarbarian())
		{
			bSlaughter = false;
		}
		//Recently captured and still in resistance? Don't slaughter.
		if(pOldCity->IsResistance() || pOldCity->IsRazing())
		{
			bSlaughter = false;
		}
	}
#endif
	int iNumBuildingInfos = GC.getNumBuildingInfos();
	std::vector<int> paiNumRealBuilding(iNumBuildingInfos, 0);
	std::vector<int> paiNumFreeBuilding(iNumBuildingInfos, 0);
	std::vector<int> paiBuildingOriginalOwner(iNumBuildingInfos, 0);
	std::vector<int> paiBuildingOriginalTime(iNumBuildingInfos, 0);
#if defined(MOD_BALANCE_CORE)
	int iNumReligions = GC.getNumReligionInfos();
	std::vector<bool> pabAdoptionBonus(iNumReligions, false);
#endif
	struct CopyGreatWorkData
	{
		int m_iGreatWork;
		BuildingTypes m_eBuildingType;
		int m_iSlot;
		bool m_bTransferred;
	};
	std::vector<CopyGreatWorkData> paGreatWorkData;
	int iOldCityX = pOldCity->getX();
	int iOldCityY = pOldCity->getY();
	eOldOwner = pOldCity->getOwner();
	eOriginalOwner = pOldCity->getOriginalOwner();
	iGameTurnFounded = pOldCity->getGameTurnFounded();
	iPopulation = pOldCity->getPopulation();
	iOldPopulation = iPopulation;
	iHighestPopulation = pOldCity->getHighestPopulation();
	strName = pOldCity->getNameKey();
	int iOldCultureLevel = pOldCity->GetJONSCultureLevel();
	bool bHasMadeAttack = pOldCity->isMadeAttack();
#if defined(MOD_BALANCE_CORE)
	bool bNeedsWarmonger = pOldCity->IsNoWarmongerYet();
#endif

	tempReligions.Init(pOldCity);
	tempReligions.Copy(pOldCity->GetCityReligions());

	iBattleDamage = pOldCity->getDamage();

	bool bReduce = true;
	// Traded cities between humans don't heal (an exploit would be to trade a city back and forth between teammates to get an instant heal.)
	if (bGift || GET_PLAYER(pOldCity->getOwner()).getTeam() != getTeam())
		bReduce = false;

	int iBattleDamageThreshold = GC.getMAX_CITY_HIT_POINTS() * /*50*/ (bReduce ? GC.getCITY_CAPTURE_DAMAGE_PERCENT() : 90);
	iBattleDamageThreshold /= 100;

	if(iBattleDamage > iBattleDamageThreshold)
	{
		iBattleDamage = iBattleDamageThreshold;
	}

	for(iI = 0; iI < MAX_PLAYERS; iI++)
	{
		abEverOwned[iI] = pOldCity->isEverOwned((PlayerTypes)iI);
	}

	abEverOwned[GetID()] = true;
#if defined(MOD_BALANCE_CORE)
	bool abTraded[MAX_PLAYERS];
	int aiNumTimesOwned[MAX_PLAYERS];
	for(iI = 0; iI < MAX_PLAYERS; iI++)
	{
		abTraded[iI] = pOldCity->IsTraded((PlayerTypes)iI);
		aiNumTimesOwned[iI] = pOldCity->GetNumTimesOwned((PlayerTypes)iI);
	}
	for(iI = 0; iI < GC.getNumReligionInfos(); iI++)
	{
		ReligionTypes eReligion = (ReligionTypes)iI;
		CvReligionEntry* pEntry = GC.getReligionInfo(eReligion);
		if(!pEntry)
		{
			continue;
		}
		if(eReligion == RELIGION_PANTHEON)
			continue;

		pabAdoptionBonus[eReligion] = pOldCity->HasPaidAdoptionBonus(eReligion);
	}
#endif

	for(iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		paiNumRealBuilding[iI] = pOldCity->GetCityBuildings()->GetNumRealBuilding((BuildingTypes)iI);
		paiNumFreeBuilding[iI] = pOldCity->GetCityBuildings()->GetNumFreeBuilding((BuildingTypes)iI);
		paiBuildingOriginalOwner[iI] = pOldCity->GetCityBuildings()->GetBuildingOriginalOwner((BuildingTypes)iI);
		paiBuildingOriginalTime[iI] = pOldCity->GetCityBuildings()->GetBuildingOriginalTime((BuildingTypes)iI);

		if (pOldCity->GetCityBuildings()->GetNumBuilding((BuildingTypes)iI) > 0)
		{
			CvBuildingEntry *pkBuilding = GC.getBuildingInfo((BuildingTypes)iI);
			if (pkBuilding)
			{
				for (int jJ = 0; jJ < pkBuilding->GetGreatWorkCount(); jJ++)
				{
					int iGreatWork = pOldCity->GetCityBuildings()->GetBuildingGreatWork((BuildingClassTypes)pkBuilding->GetBuildingClassType(), jJ);
					if (iGreatWork != NO_GREAT_WORK)
					{
						CopyGreatWorkData kData;
						kData.m_iGreatWork = iGreatWork;
						kData.m_eBuildingType = (BuildingTypes)iI;
						kData.m_iSlot = jJ;
						kData.m_bTransferred = false;
						paGreatWorkData.push_back(kData);

						CvPlayer &kOldCityPlayer = GET_PLAYER(pOldCity->getOriginalOwner());
						if (kOldCityPlayer.GetCulture()->GetSwappableWritingIndex() == iGreatWork)
						{
							kOldCityPlayer.GetCulture()->SetSwappableWritingIndex(-1);
						}
						if (kOldCityPlayer.GetCulture()->GetSwappableArtifactIndex() == iGreatWork)
						{
							kOldCityPlayer.GetCulture()->SetSwappableArtifactIndex(-1);
						}
						if (kOldCityPlayer.GetCulture()->GetSwappableArtIndex() == iGreatWork)
						{
							kOldCityPlayer.GetCulture()->SetSwappableArtIndex(-1);
						}
						if (kOldCityPlayer.GetCulture()->GetSwappableMusicIndex() == iGreatWork)
						{
							kOldCityPlayer.GetCulture()->SetSwappableMusicIndex(-1);
						}
					}
				}
			}
		}
	}

	std::vector<BuildingYieldChange> aBuildingYieldChange;
	for(iI = 0; iI < GC.getNumBuildingClassInfos(); ++iI)
	{
		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo((BuildingClassTypes)iI);
		if(!pkBuildingClassInfo)
		{
			continue;
		}

		for(int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
		{
			BuildingYieldChange kChange;
			kChange.eBuildingClass = (BuildingClassTypes)iI;
			kChange.eYield = (YieldTypes)iYield;
			kChange.iChange = pOldCity->GetCityBuildings()->GetBuildingYieldChange((BuildingClassTypes)iI, (YieldTypes)iYield);
			if(0 != kChange.iChange)
			{
				aBuildingYieldChange.push_back(kChange);
			}
		}
	}

	bRecapture = false; //((eHighestCulturePlayer != NO_PLAYER) ? (GET_PLAYER(eHighestCulturePlayer).getTeam() == getTeam()) : false);

	// Returning spies back to pool
	CvCityEspionage* pOldCityEspionage = pOldCity->GetCityEspionage();
	if(pOldCityEspionage)
	{
		for(int i = 0; i < MAX_MAJOR_CIVS; i++)
		{
			int iAssignedSpy = pOldCityEspionage->m_aiSpyAssignment[i];
			// if there is a spy in the city
			if(iAssignedSpy != -1)
			{
				CvNotifications* pNotifications = GET_PLAYER((PlayerTypes)i).GetNotifications();
				if(pNotifications)
				{
					CvPlayerEspionage* pEspionage = GET_PLAYER((PlayerTypes)i).GetEspionage();
					CvEspionageSpy* pSpy = &(pEspionage->m_aSpyList[iAssignedSpy]);

					Localization::String strSummary;
					Localization::String strNotification;
					if(bConquest)
					{
						strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SPY_EVICTED_CONQUEST_S");
						if(((PlayerTypes)i) == GetID())
						{
							strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_EVICTED_CONQUEST_YOU");
							strNotification << pEspionage->GetSpyRankName(pSpy->m_eRank);
#if defined(MOD_BUGFIX_SPY_NAMES)
							strNotification << pSpy->GetSpyName(&GET_PLAYER((PlayerTypes)i));
#else
							strNotification << GET_PLAYER((PlayerTypes)i).getCivilizationInfo().getSpyNames(pSpy->m_iName);
#endif
							strNotification << pOldCity->getNameKey();
						}
						else
						{
							strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_EVICTED_CONQUEST");
							strNotification << pEspionage->GetSpyRankName(pSpy->m_eRank);
#if defined(MOD_BUGFIX_SPY_NAMES)
							strNotification << pSpy->GetSpyName(&GET_PLAYER((PlayerTypes)i));
#else
							strNotification << GET_PLAYER((PlayerTypes)i).getCivilizationInfo().getSpyNames(pSpy->m_iName);
#endif
							strNotification << pOldCity->getNameKey();
							strNotification << getCivilizationInfo().getShortDescriptionKey();
						}
					}
					else
					{
						strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SPY_EVICTED_TRADE_S");
						if(((PlayerTypes)i) == GetID())
						{
							strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_EVICTED_TRADE_YOU");
							strNotification << pEspionage->GetSpyRankName(pSpy->m_eRank);
#if defined(MOD_BUGFIX_SPY_NAMES)
							strNotification << pSpy->GetSpyName(&GET_PLAYER((PlayerTypes)i));
#else
							strNotification << GET_PLAYER((PlayerTypes)i).getCivilizationInfo().getSpyNames(pSpy->m_iName);
#endif
							strNotification << pOldCity->getNameKey();
						}
						else
						{
							strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_EVICTED_TRADE");
							strNotification << pEspionage->GetSpyRankName(pSpy->m_eRank);
#if defined(MOD_BUGFIX_SPY_NAMES)
							strNotification << pSpy->GetSpyName(&GET_PLAYER((PlayerTypes)i));
#else
							strNotification << GET_PLAYER((PlayerTypes)i).getCivilizationInfo().getSpyNames(pSpy->m_iName);
#endif
							strNotification << pOldCity->getNameKey();
							strNotification << getCivilizationInfo().getShortDescriptionKey();
						}
					}

					pNotifications->Add(NOTIFICATION_SPY_EVICTED, strNotification.toUTF8(), strSummary.toUTF8(), -1, -1, pOldCity->getOwner());
				}

				GET_PLAYER((PlayerTypes)i).GetEspionage()->ExtractSpyFromCity(iAssignedSpy);
				// create notifications indicating what has happened with the spy
			}
		}
	}

	GC.getGame().GetGameTrade()->ClearAllCityTradeRoutes(pCityPlot);

	bool bCapital = pOldCity->isCapital();

	// find the plot
	FStaticVector<int, 121, true, c_eCiv5GameplayDLL, 0> aiPurchasedPlotX;
	FStaticVector<int, 121, true, c_eCiv5GameplayDLL, 0> aiPurchasedPlotY;
	const int iMaxRange = /*5*/ GC.getMAXIMUM_ACQUIRE_PLOT_DISTANCE();

	for(int iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);
		if(pLoopPlot && pLoopPlot->GetCityPurchaseOwner() == eOldOwner && pLoopPlot->GetCityPurchaseID() == pOldCity->GetID())
		{
			aiPurchasedPlotX.push_back(pLoopPlot->getX());
			aiPurchasedPlotY.push_back(pLoopPlot->getY());
			pLoopPlot->ClearCityPurchaseInfo();
		}
	}

	int iOldCityRings = pOldCity->getWorkPlotDistance();

#if defined(MOD_GLOBAL_VENICE_KEEPS_RESOURCES)
	pOldCity->PreKill(bVenice);
#else
	pOldCity->PreKill();
#endif

	{
		auto_ptr<ICvCity1> pkDllOldCity(new CvDllCity(pOldCity));
		gDLL->GameplayCityCaptured(pkDllOldCity.get(), GetID());
	}

	GET_PLAYER(eOldOwner).deleteCity(pOldCity->GetID());
	// adapted from PostKill()

	GC.getGame().addReplayMessage(REPLAY_MESSAGE_CITY_CAPTURED, m_eID, "", pCityPlot->getX(), pCityPlot->getY());

	// Update Proximity between this Player and all others
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;

		if(ePlayer != m_eID)
		{
			if(GET_PLAYER(ePlayer).isAlive())
			{
				GET_PLAYER(m_eID).DoUpdateProximityToPlayer(ePlayer);
				GET_PLAYER(ePlayer).DoUpdateProximityToPlayer(m_eID);
			}
		}
	}

	GC.getMap().updateOwningCity(pCityPlot,iOldCityRings*2);
	// Lost the capital!
	if(bCapital)
	{
#if defined(MOD_GLOBAL_NO_CONQUERED_SPACESHIPS)
		GET_PLAYER(eOldOwner).disassembleSpaceship(pCityPlot);
#endif
		GET_PLAYER(eOldOwner).findNewCapital();
		GET_TEAM(getTeam()).resetVictoryProgress();
	}

	GC.GetEngineUserInterface()->setDirty(NationalBorders_DIRTY_BIT, true);
	// end adapted from PostKill()

#if defined(MOD_API_EXTENSIONS)
	pNewCity = initCity(pCityPlot->getX(), pCityPlot->getY(), !bConquest, (!bConquest && !bGift), NO_RELIGION, strName.c_str());
#else
	pNewCity = initCity(pCityPlot->getX(), pCityPlot->getY(), !bConquest, (!bConquest && !bGift));
#endif

	CvAssertMsg(pNewCity != NULL, "NewCity is not assigned a valid value");

#ifdef _MSC_VER
#pragma warning ( push )
#pragma warning ( disable : 6011 ) 
#endif

	// For buyouts, set it up like a new city founded by this player, to avoid liberation later on etc.
	if(bIsMinorCivBuyout)
	{
#if defined(MOD_GLOBAL_CS_LIBERATE_AFTER_BUYOUT)
		if (MOD_GLOBAL_CS_LIBERATE_AFTER_BUYOUT)
		{
			pNewCity->setPreviousOwner(eOldOwner);
			pNewCity->setOriginalOwner(eOriginalOwner);
			pNewCity->setGameTurnFounded(iGameTurnFounded);
		}
		else
		{
#endif
			pNewCity->setPreviousOwner(NO_PLAYER);
			pNewCity->setOriginalOwner(m_eID);
			pNewCity->setGameTurnFounded(GC.getGame().getGameTurn());
#if defined(MOD_GLOBAL_CS_LIBERATE_AFTER_BUYOUT)
		}
#endif

		AwardFreeBuildings(pNewCity);
	}
	// Otherwise, set it up using the data from the old city
	else
	{
		pNewCity->setPreviousOwner(eOldOwner);
		pNewCity->setOriginalOwner(eOriginalOwner);
		pNewCity->setGameTurnFounded(iGameTurnFounded);
	}

	// Population change for capturing a city
#if defined(MOD_BALANCE_CORE)
	if(!bRecapture && bConquest && bSlaughter)	
#else
	if(!bRecapture && bConquest)	// Don't drop it if we're recapturing our own City
#endif
	{
		int iPercentPopulationRetained = /*50*/ GC.getCITY_CAPTURE_POPULATION_PERCENT();
		int iInfluenceReduction = GetCulture()->GetInfluenceCityConquestReduction(eOldOwner);
		iPercentPopulationRetained += (iInfluenceReduction * (100 - iPercentPopulationRetained) / 100);

		iPopulation = max(1, iPopulation * iPercentPopulationRetained / 100);
	}
#if defined(MOD_BALANCE_CORE)
	pNewCity->setPopulation(iPopulation, true, true);
#else
	pNewCity->setPopulation(iPopulation);
#endif
	pNewCity->setHighestPopulation(iHighestPopulation);
	pNewCity->setName(strName);
	pNewCity->setNeverLost(false);
	pNewCity->setDamage(iBattleDamage,true);
	pNewCity->setMadeAttack(bHasMadeAttack);
#if defined(MOD_BALANCE_CORE)
	pNewCity->SetNoWarmonger(bNeedsWarmonger);
#endif
	GetCorporations()->ClearAllCorporationsFromCity(pNewCity);
	for(iI = 0; iI < MAX_PLAYERS; iI++)
	{
		pNewCity->setEverOwned(((PlayerTypes)iI), abEverOwned[iI]);
#if defined(MOD_BALANCE_CORE)
		pNewCity->SetTraded(((PlayerTypes)iI), abTraded[iI]);
		pNewCity->SetNumTimesOwned(((PlayerTypes)iI), aiNumTimesOwned[iI]);
#endif
	}
#if defined(MOD_BALANCE_CORE)
	for (iI = 0; iI < GC.getNumReligionInfos(); iI++)
	{
		ReligionTypes eReligion = (ReligionTypes)iI;
		CvReligionEntry* pEntry = GC.getReligionInfo(eReligion);
		if (!pEntry)
		{
			continue;
		}
		if (eReligion == RELIGION_PANTHEON)
			continue;

		pNewCity->SetPaidAdoptionBonus(eReligion, pabAdoptionBonus[eReligion]);
	}
#endif
	//I've traded for this? I don't want to give away again
	if (bGift)
		pNewCity->SetTraded( GetID(), true);

	pNewCity->SetJONSCultureLevel(iOldCultureLevel);
	pNewCity->GetCityReligions()->Copy(&tempReligions);
	pNewCity->GetCityReligions()->RemoveFormerPantheon();

	if(bCapital)
	{
		GET_PLAYER(eOldOwner).SetHasLostCapital(true, m_eID);
		
		if (isMajorCiv())
		GET_PLAYER(eOldOwner).GetDiplomacyAI()->SetEverBackstabbedBy(m_eID, true);
	}


	if (pNewCity->GetCityReligions()->IsHolyCityAnyReligion())
	{
		ReligionTypes eReligion = pNewCity->GetCityReligions()->GetReligionForHolyCity();
		const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, NO_PLAYER);
		if (pReligion && pReligion->m_eFounder == eOldOwner)
		{
			GET_PLAYER(eOldOwner).SetHasLostHolyCity(true, m_eID);
			GET_PLAYER(eOldOwner).SetLostHolyCityXY(pNewCity->getX(), pNewCity->getY());
			
			if (isMajorCiv())
			GET_PLAYER(eOldOwner).GetDiplomacyAI()->SetEverBackstabbedBy(m_eID, true);
		}
	}

	const CvCivilizationInfo& playerCivilizationInfo = getCivilizationInfo();
#if defined(MOD_BALANCE_CORE)
	if(GetPlayerTraits()->IsReconquista())
	{
		ReligionTypes eReligion = GetReligions()->GetReligionCreatedByPlayer(false);
		if(eReligion != NO_RELIGION)
		{
			pNewCity->GetCityReligions()->AdoptReligionFully(eReligion);
		}
		else
		{
			eReligion = GetReligions()->GetReligionInMostCities();
			if(eReligion != NO_RELIGION)
			{
				pNewCity->GetCityReligions()->AdoptReligionFully(eReligion);
			}
		}
	}
#endif
#if !defined(NO_ACHIEVEMENTS)
	if(bConquest && !GC.getGame().isGameMultiPlayer() && isHuman())
	{
		const char* szCivKey = getCivilizationTypeKey();

		// Check for Kris Swordsman achievement
		if(strcmp(szCivKey, "CIVILIZATION_INDONESIA") == 0)
		{
			CvUnit *pConqueringUnit = pCityPlot->getUnitByIndex(0);
			if (pConqueringUnit->getUnitType() == (UnitTypes)GC.getInfoTypeForString("UNIT_KRIS_SWORDSMAN", true))
			{
				PromotionTypes ePromotion = (PromotionTypes)GC.getInfoTypeForString("PROMOTION_ENEMY_BLADE", true);
				if (pConqueringUnit->isHasPromotion(ePromotion))
				{
					gDLL->UnlockAchievement(ACHIEVEMENT_XP2_21);
				}
			}
		}

		// Check for Rome conquering Statue of Zeus Achievement
		bool bUsingXP1Scenario1 = gDLL->IsModActivated(CIV5_XP1_SCENARIO1_MODID);
		bool bUsingXP1Scenario2 = gDLL->IsModActivated(CIV5_XP1_SCENARIO2_MODID);
		bool bUsingXP2Scenario1 = gDLL->IsModActivated(CIV5_XP2_SCENARIO1_MODID);

		const char* szNameKey = pNewCity->getNameKey();
		if(bUsingXP2Scenario1)
		{
			if(strcmp(szCivKey, "CIVILIZATION_ENGLAND") == 0)
			{
				if(strcmp(szNameKey, "TXT_KEY_CIVIL_WAR_SCENARIO_CITY_NAME_GETTYSBURG") == 0)
				{
					CvUnit *pConqueringUnit = pCityPlot->getUnitByIndex(0);
					PromotionTypes ePromotion = (PromotionTypes)GC.getInfoTypeForString("PROMOTION_PICKETT", true);
					if (pConqueringUnit->isHasPromotion(ePromotion))
					{
						gDLL->UnlockAchievement(ACHIEVEMENT_XP2_59);
					}
				}
			}
		}

		if(bUsingXP1Scenario1)
		{
			const HandicapTypes eCurrentHandicap = GC.getGame().getHandicapType();
			HandicapTypes eEmporerHandicap = NO_HANDICAP;
			HandicapTypes eDeityHandicap = NO_HANDICAP;

			const int numHandicapInfos = GC.getNumHandicapInfos();
			for(int i = 0; i < numHandicapInfos; ++i)
			{
				const HandicapTypes eHandicap = static_cast<HandicapTypes>(i);
				CvHandicapInfo* pkInfo = GC.getHandicapInfo(eHandicap);
				if(pkInfo != NULL)
				{
					if(strcmp(pkInfo->GetType(), "HANDICAP_EMPEROR") == 0)
					{
						eEmporerHandicap = eHandicap;
					}
					else if(strcmp(pkInfo->GetType(), "HANDICAP_DEITY") == 0)
					{
						eDeityHandicap = eHandicap;
					}
				}
			}

			if(szCivKey && szNameKey)
			{
				if(strcmp(szCivKey, "CIVILIZATION_ENGLAND") == 0)
				{
					if(strcmp(szNameKey, "TXT_KEY_CITYSTATE_JERUSALEM") == 0)
					{
						if(eCurrentHandicap >= eEmporerHandicap)
						{
							gDLL->UnlockAchievement(ACHIEVEMENT_XP1_39);
						}
					}
				}
				else if(strcmp(szCivKey, "CIVILIZATION_OTTOMAN") == 0)
				{
					if(strcmp(szNameKey, "TXT_KEY_CITY_NAME_CONSTANTINOPLE") == 0)
					{
						if(eCurrentHandicap >= eDeityHandicap)
						{
							gDLL->UnlockAchievement(ACHIEVEMENT_XP1_40);
						}
					}
				}
			}	
		}

		if(bUsingXP1Scenario2)
		{
			bool bHasConstantinople = false;
			bool bHasRome = false;

			if(strcmp(szNameKey, "TXT_KEY_CITY_NAME_CONSTANTINOPLE") == 0)
			{
				bHasConstantinople = true;

				if(pNewCity->getOriginalOwner() != GetID())
				{
					gDLL->UnlockAchievement(ACHIEVEMENT_XP1_47);
				}
			}
			else if(strcmp(szNameKey, "TXT_KEY_CITY_NAME_ROME") == 0)
			{
				bHasRome = true;
			}

			if(bHasConstantinople || bHasRome)
			{
				int iLoop = 0;
				for(CvCity* pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
				{
					const char* szOtherNameKey = pCity->getNameKey();
					if(strcmp(szOtherNameKey, "TXT_KEY_CITY_NAME_CONSTANTINOPLE") == 0)
					{
						bHasConstantinople = true;
					}
					else if(strcmp(szOtherNameKey, "TXT_KEY_CITY_NAME_ROME") == 0)
					{
						bHasRome = true;
					}
				}
			}

			if(bHasRome && bHasConstantinople)
			{
				gDLL->UnlockAchievement(ACHIEVEMENT_XP1_48);
			}

			if(strcmp(getCivilizationTypeKey(), "CIVILIZATION_CELTS") == 0)
			{
				//Did we cap what was originally a sassinid city?
				typedef std::pair<int,int> Location;
				typedef std::tr1::array<Location, 7> SassanidCityArray;
				SassanidCityArray SassanidCities = {
					Location(87,17), //Ctesiphon
					Location(85,20), //Singara
					Location(81,21), //Nisibis
					Location(79,24), //Amida
					Location(82,28), //Thospia
					Location(81,33), //Anium
					Location(87,33), //Artaxata
				};
				
				int iNewPlotX = pNewCity->getX();
				int iNewPlotY = pNewCity->getY();

				//Test if we still own each city.
				for(SassanidCityArray::iterator it = SassanidCities.begin(); it != SassanidCities.end(); ++it)
				{
					if(it->first == iNewPlotX && it->second == iNewPlotY)
					{
						gDLL->UnlockAchievement(ACHIEVEMENT_XP1_51);

					}
				}
			}

		}
	}
#endif
#if defined(MOD_BALANCE_CORE)
	if(bConquest && !bGift)
	{
#endif
	std::vector<BuildingTypes> freeConquestBuildings = m_pPlayerPolicies->GetFreeBuildingsOnConquest();
	for(iI = 0; iI < (int)freeConquestBuildings.size(); iI++)
	{
		const BuildingTypes eLoopBuilding = freeConquestBuildings[iI];
		if (eLoopBuilding != NO_BUILDING)
		{
			CvBuildingEntry* pkLoopBuildingInfo = GC.getBuildingInfo(eLoopBuilding);
			if(pkLoopBuildingInfo)
			{
				if (eLoopBuilding == pkLoopBuildingInfo->GetID())
				{
#if defined(MOD_BUGFIX_BUILDINGCLASS_NOT_BUILDING)
					BuildingTypes eFreeBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(pkLoopBuildingInfo->GetBuildingClassType());
					pNewCity->GetCityBuildings()->SetNumRealBuilding(eFreeBuilding, 0);
					pNewCity->GetCityBuildings()->SetNumFreeBuilding(eFreeBuilding, 1);
#else
					pNewCity->GetCityBuildings()->SetNumFreeBuilding(eLoopBuilding, 1);
#endif
				}
			}
		}
	}
#if defined(MOD_BALANCE_CORE)
	}
	// Free Buildings from Policies
	if(MOD_BALANCE_CORE)
	{
		for(iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
		{
			const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iI);
			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
			if(pkBuildingClassInfo)
			{
				int iNumFreeBuildings = GetNumCitiesFreeChosenBuilding(eBuildingClass);
				if (iNumFreeBuildings > 0 || IsFreeChosenBuildingNewCity(eBuildingClass) || IsFreeBuildingAllCity(eBuildingClass))
				{
					const BuildingTypes eBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(pkBuildingClassInfo->GetID())));
					if(NO_BUILDING != eBuilding)
					{
						CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
						if(pkBuildingInfo)
						{
							if(pNewCity->isValidBuildingLocation(eBuilding))
							{
								if(pNewCity->GetCityBuildings()->GetNumRealBuilding(eBuilding) > 0)
								{
									pNewCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, 0);
								}

								pNewCity->GetCityBuildings()->SetNumFreeBuilding(eBuilding, 1);

								if(pNewCity->GetCityBuildings()->GetNumFreeBuilding(eBuilding) > 0)
								{
									ChangeNumCitiesFreeChosenBuilding(eBuildingClass, -1);
								}
							}
						}
					}
				}
			}
		}
	}
#endif
	bool bKeepBuildings = GetPlayerTraits()->IsKeepConqueredBuildings() || bVenice;
	BuildingTypes eTraitFreeBuilding = GetPlayerTraits()->GetFreeBuildingOnConquest();
	for(iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		const BuildingTypes eLoopBuilding = static_cast<BuildingTypes>(iI);
		CvBuildingEntry* pkLoopBuildingInfo = GC.getBuildingInfo(eLoopBuilding);
		if(pkLoopBuildingInfo)
		{
			const CvBuildingClassInfo& kLoopBuildingClassInfo = pkLoopBuildingInfo->GetBuildingClassInfo();

			int iNum = 0;

			if(eTraitFreeBuilding == pkLoopBuildingInfo->GetID())
			{
				pNewCity->GetCityBuildings()->SetNumFreeBuilding(eTraitFreeBuilding, 1);
			}

			if (bKeepBuildings && paiNumFreeBuilding[iI] > 0)
			{
				const BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkLoopBuildingInfo->GetBuildingClassType();
				if (::isWorldWonderClass(kLoopBuildingClassInfo))
				{
					eBuilding = eLoopBuilding;
				}
#if defined(MOD_BALANCE_CORE)
				else if (bKeepBuildings)
				{
					//If we keep buildings, but we have a replacement, grab the replacement instead.
					if (playerCivilizationInfo.isCivilizationBuildingOverridden(eBuildingClass))
					{
						eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings(eBuildingClass);
					}
					else
					{
						eBuilding = eLoopBuilding;
					}
				}
#endif
				else
				{
					eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings(eBuildingClass);
				}

				if (eBuilding != NO_BUILDING)
				{
					if (!IsValidBuildingForPlayer(pNewCity, eBuilding, bGift, bRecapture))
						continue;

					CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
					if (pkBuildingInfo)
					{
						iNum += paiNumFreeBuilding[iI];

						pNewCity->GetCityBuildings()->SetNumFreeBuilding(eBuilding, iNum);

						if (pkBuildingInfo->GetGreatWorkCount() > 0)
						{
							for (unsigned int jJ = 0; jJ < paGreatWorkData.size(); jJ++)
							{
								if (paGreatWorkData[jJ].m_eBuildingType == iI)
								{
									pNewCity->GetCityBuildings()->SetBuildingGreatWork(eBuildingClass, paGreatWorkData[jJ].m_iSlot, paGreatWorkData[jJ].m_iGreatWork);
									paGreatWorkData[jJ].m_bTransferred = true;
									iCaptureGreatWorks++;
								}
							}
						}
					}
				}
			}

			else if(paiNumRealBuilding[iI] > 0)
			{
				const BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkLoopBuildingInfo->GetBuildingClassType();
				if(::isWorldWonderClass(kLoopBuildingClassInfo))
				{
					eBuilding = eLoopBuilding;
				}
#if defined(MOD_BALANCE_CORE)
				else if(bKeepBuildings)
				{
					//If we keep buildings, but we have a replacement, grab the replacement instead.
					if (playerCivilizationInfo.isCivilizationBuildingOverridden(eBuildingClass))
					{
						eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings(eBuildingClass);
					}
					else
					{
						eBuilding = eLoopBuilding;
					}
				}
#endif
				else
				{
					eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings(eBuildingClass);
				}

				if(eBuilding != NO_BUILDING)
				{
					if (!IsValidBuildingForPlayer(pNewCity, eBuilding, bGift, bRecapture))
						continue;

					CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
					if(pkBuildingInfo)
					{
						iNum += paiNumRealBuilding[iI];

#if !defined(NO_ACHIEVEMENTS)
						// Check for Tomb Raider Achievement
						if(bConquest && !GC.getGame().isGameMultiPlayer() && pkLoopBuildingInfo->GetType() && _stricmp(pkLoopBuildingInfo->GetType(), "BUILDING_BURIAL_TOMB") == 0 && isHuman())
						{
							if(iCaptureGold > 0)  //Need to actually pillage something from the 'tomb'
							{
								gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_TOMBRAIDER);
							}
						}
#endif

#if !defined(NO_ACHIEVEMENTS)
						// Check for Rome conquering Statue of Zeus Achievement
						if(bConquest && !GC.getGame().isGameMultiPlayer() && pkLoopBuildingInfo->GetType() && _stricmp(pkLoopBuildingInfo->GetType(), "BUILDING_STATUE_ZEUS") == 0 && isHuman())
						{
							const char* pkCivKey = getCivilizationTypeKey();
							if(pkCivKey && strcmp(pkCivKey, "CIVILIZATION_ROME") == 0)
							{
								gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_ROME_GETS_ZEUS);
							}
						}
#endif

						pNewCity->GetCityBuildings()->SetNumRealBuildingTimed(eBuilding, iNum, false, ((PlayerTypes)(paiBuildingOriginalOwner[iI])), paiBuildingOriginalTime[iI]);

						if (iNum > 0)
						{
							if (pkBuildingInfo->GetGreatWorkCount() > 0)
							{
								for (unsigned int jJ=0; jJ < paGreatWorkData.size(); jJ++)
								{
									if (paGreatWorkData[jJ].m_eBuildingType == iI)
									{
										pNewCity->GetCityBuildings()->SetBuildingGreatWork(eBuildingClass, paGreatWorkData[jJ].m_iSlot, paGreatWorkData[jJ].m_iGreatWork);
										paGreatWorkData[jJ].m_bTransferred = true;
										iCaptureGreatWorks++;
									}
								}
							}
						}
					}
				}
			}
		}
	}
	for(std::vector<BuildingYieldChange>::iterator it = aBuildingYieldChange.begin(); it != aBuildingYieldChange.end(); ++it)
	{
		pNewCity->GetCityBuildings()->SetBuildingYieldChange((*it).eBuildingClass, (*it).eYield, (*it).iChange);
	}

	// Distribute any remaining Great Works to other buildings
	for (unsigned int jJ=0; jJ < paGreatWorkData.size(); jJ++)
	{
		if (!paGreatWorkData[jJ].m_bTransferred)
		{
			BuildingClassTypes eBuildingClass = NO_BUILDINGCLASS; // Passed by reference below
			int iSlot = -1; // Passed by reference below
			GreatWorkType eType = GC.getGame().GetGameCulture()->m_CurrentGreatWorks[paGreatWorkData[jJ].m_iGreatWork].m_eType;
			GreatWorkSlotType eGreatWorkSlot = CultureHelpers::GetGreatWorkSlot(eType);
			if (pNewCity->GetCityBuildings()->GetNextAvailableGreatWorkSlot(eGreatWorkSlot, &eBuildingClass, &iSlot))
			{
				pNewCity->GetCityBuildings()->SetBuildingGreatWork(eBuildingClass, iSlot, paGreatWorkData[jJ].m_iGreatWork);
				paGreatWorkData[jJ].m_bTransferred = true;
				iCaptureGreatWorks++;
			}
			else
			{
				BuildingClassTypes eGWBuildingClass;
				int iGWSlot;
				CvCity *pGWCity = GetCulture()->GetClosestAvailableGreatWorkSlot(pCityPlot->getX(), pCityPlot->getY(), eGreatWorkSlot, &eGWBuildingClass, &iGWSlot);
				if (pGWCity)
				{
					pGWCity->GetCityBuildings()->SetBuildingGreatWork(eGWBuildingClass, iGWSlot, paGreatWorkData[jJ].m_iGreatWork);
					paGreatWorkData[jJ].m_bTransferred = true;
					iCaptureGreatWorks++;
				}
			}
		}
	}

	// Did we re-acquire our Capital?
	if(pCityPlot->getX() == GetOriginalCapitalX() && pCityPlot->getY() == GetOriginalCapitalY())
	{
		SetHasLostCapital(false, NO_PLAYER);

		const BuildingTypes eCapitalBuilding = (BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(GC.getCAPITAL_BUILDINGCLASS()));
		if(eCapitalBuilding != NO_BUILDING)
		{
#if defined(MOD_EVENTS_CITY_CAPITAL)
			CvCity* pOldCapital = getCapitalCity();
			if (pOldCapital != NULL)
#else
			if (getCapitalCity() != NULL)
#endif
			{
				pOldCapital->GetCityBuildings()->SetNumRealBuilding(eCapitalBuilding, 0);
#if defined(MOD_BALANCE_CORE)
				if (GetPlayerTraits()->IsNoAnnexing())
				{
					pOldCapital->SetPuppet(true);
				}
#endif
			}
			CvAssertMsg(!(pNewCity->GetCityBuildings()->GetNumRealBuilding(eCapitalBuilding)), "(pBestCity->getNumRealBuilding(eCapitalBuilding)) did not return false as expected");
			pNewCity->GetCityBuildings()->SetNumRealBuilding(eCapitalBuilding, 1);

#if defined(MOD_BALANCE_CORE)
			//Check for policies that add capital buildings and move them over.
			for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
			{
				const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iI);
				CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
				if (pkBuildingClassInfo)
				{
					int iNumFreeBuildings = GetNumCitiesFreeChosenBuilding(eBuildingClass);
					if (iNumFreeBuildings > 0 || IsFreeChosenBuildingNewCity(eBuildingClass) || IsFreeBuildingAllCity(eBuildingClass))
					{
						const BuildingTypes eBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(pkBuildingClassInfo->GetID())));
						if (NO_BUILDING != eBuilding)
						{
							CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
							if (pkBuildingInfo && pkBuildingInfo->IsCapitalOnly())
							{
								pNewCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, 1);
								if (pOldCapital != NULL)
								{
									pOldCapital->GetCityBuildings()->SetNumRealBuilding(eBuilding, 0);
								}
							}
						}
					}
				}
			}
#endif

#if defined(MOD_EVENTS_CITY_CAPITAL)
			if (MOD_EVENTS_CITY_CAPITAL) {
				GAMEEVENTINVOKE_HOOK(GAMEEVENT_CapitalChanged, GetID(), pNewCity->GetID(), (pOldCapital ? pOldCapital->GetID() : -1));
			}
#endif
		}
	}
#if defined(MOD_BALANCE_CORE_EVENTS)
	if (MOD_BALANCE_CORE_EVENTS)
	{
		CheckActivePlayerEvents(pNewCity);
	}
#endif
	if (pNewCity->getX() == GET_PLAYER(eOldOwner).GetLostHolyCityX() && pNewCity->getY() == GET_PLAYER(eOldOwner).GetLostHolyCityY())
	{
		GET_PLAYER(eOldOwner).SetHasLostHolyCity(false, NO_PLAYER);
		GET_PLAYER(eOldOwner).SetLostHolyCityXY(-1, -1);
	}

	// slewis - moved this here so that conquest victory is tested with each city capture
	GC.getGame().DoTestConquestVictory();

	GC.getMap().updateOwningCity(pCityPlot,pNewCity->getWorkPlotDistance()*2);
	if(bConquest)
	{
		for(int iDX = -iMaxRange; iDX <= iMaxRange; iDX++)
		{
			for(int iDY = -iMaxRange; iDY <= iMaxRange; iDY++)
			{
				CvPlot* pLoopPlot = plotXYWithRangeCheck(iOldCityX, iOldCityY, iDX, iDY, iMaxRange);
				if(pLoopPlot)
				{
					pLoopPlot->verifyUnitValidPlot();
				}
			}
		}

#if !defined(NO_ACHIEVEMENTS)
		// Check for Askia Achievement
		if(isHuman() && !CvPreGame::isNetworkMultiplayerGame())
		{
			const char* pkLeaderKey = getLeaderTypeKey();
			if(pkLeaderKey && strcmp(pkLeaderKey, "LEADER_ASKIA") == 0)
			{
				CvCity* pkCaptialCity = getCapitalCity();
				if(pkCaptialCity != NULL)	// Shouldn't be NULL, but...
				{
					CvPlot* pkCapitalPlot = pkCaptialCity->plot();
					CvPlot* pkNewCityPlot = pNewCity->plot();
					if(pkCapitalPlot && pkNewCityPlot)
					{
						// Get the area each plot is located in.
						CvArea* pkCapitalArea = pkCapitalPlot->area();
						CvArea* pkNewCityArea = pkNewCityPlot->area();

						if(pkCapitalArea && pkNewCityArea)
						{
							// The area the new city is locate on has to be of a certain size to qualify so that tiny islands are not included
#define ACHIEVEMENT_MIN_CONTINENT_SIZE	8
							if(pkNewCityArea->GetID() != pkCapitalArea->GetID() && pkNewCityArea->getNumTiles() >= ACHIEVEMENT_MIN_CONTINENT_SIZE)
							{
								gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_WARCANOE);
							}
						}
					}
				}
			}
		}
#endif
	}

	pCityPlot->setRevealed(GET_PLAYER(eOldOwner).getTeam(), true);

	// If the old owner is "killed," then notify everyone's Grand Strategy AI
	if(GET_PLAYER(eOldOwner).getNumCities() == 0 && !GET_PLAYER(eOldOwner).GetPlayerTraits()->IsStaysAliveZeroCities() && !bIsMinorCivBuyout)
	{
		if(!isMinorCiv() && !isBarbarian())
		{
			for(int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)
			{
				if(GetID() != iMajorLoop && GET_PLAYER((PlayerTypes) iMajorLoop).isAlive())
				{
					// Have I met the player who killed the guy?
					if(GET_TEAM(GET_PLAYER((PlayerTypes) iMajorLoop).getTeam()).isHasMet(getTeam()))
					{
						GET_PLAYER((PlayerTypes) iMajorLoop).GetDiplomacyAI()->DoPlayerKilledSomeone(GetID(), eOldOwner);
					}
				}
			}

#if defined(MOD_DIPLOMACY_CITYSTATES)
			//Let's give the Embassies of the defeated player to the new player
			if(MOD_DIPLOMACY_CITYSTATES && GET_PLAYER(eOldOwner).GetImprovementLeagueVotes() > 0)
			{
				int iEmbassyVotes = GET_PLAYER(eOldOwner).GetImprovementLeagueVotes();
				ChangeImprovementLeagueVotes(iEmbassyVotes);
			}
#endif
		}
	}
#if defined(MOD_DIPLOMACY_CITYSTATES)
	if(GET_PLAYER(eOldOwner).isMinorCiv() && GET_PLAYER(eOldOwner).getNumCities() == 0)
	{
		for(int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)
		{
			PlayerTypes ePlayer = (PlayerTypes)iMajorLoop;
			if(ePlayer != NO_PLAYER && !GET_PLAYER(ePlayer).isMinorCiv())
			{
				if(GET_PLAYER(eOldOwner).GetIncomingUnitCountdown(ePlayer) > 0)
				{
					// Must have capital to actually spawn unit
					CvCity* pCapital = GET_PLAYER(ePlayer).getCapitalCity();
					if(pCapital)
					{
						if(GET_PLAYER(eOldOwner).GetIncomingUnitType(ePlayer) != NO_UNIT)
						{
							CvUnit* pNewUnit = GET_PLAYER(ePlayer).initUnit(GET_PLAYER(eOldOwner).GetIncomingUnitType(ePlayer), pCapital->getX(), pCapital->getY());
							CvAssert(pNewUnit);
							if (pNewUnit)
							{
								if(pNewUnit->getDomainType() != DOMAIN_AIR)
								{
									if (!pNewUnit->jumpToNearestValidPlot())
									{
										pNewUnit->kill(false);
									}
								}
								CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();
								if(pNotifications && ePlayer == GC.getGame().getActivePlayer())
								{
									Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CS_GIFT_RETURNED_SUMMARY");
									strSummary <<  GET_PLAYER(eOldOwner).getCivilizationShortDescriptionKey();
									Localization::String strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_CS_GIFT_RETURNED");
									strNotification <<  GET_PLAYER(eOldOwner).getNameKey();
									strNotification <<  pNewUnit->getNameKey();
									pNotifications->Add(NOTIFICATION_GENERIC, strNotification.toUTF8(), strSummary.toUTF8(), pCapital->getX(), pCapital->getY(), -1);
								}
							}
						}
					}
				}
				GET_PLAYER(eOldOwner).GetMinorCivAI()->SetJerk(GET_PLAYER((PlayerTypes) iMajorLoop).getTeam(), 0);
			}
		}
	}			
#endif
	// If not, old owner should look at city specializations
	else
	{
		GET_PLAYER(eOldOwner).GetCitySpecializationAI()->SetSpecializationsDirty(SPECIALIZATION_UPDATE_MY_CITY_CAPTURED);
	}

	// Do the same for the new owner
	GetCitySpecializationAI()->SetSpecializationsDirty(SPECIALIZATION_UPDATE_ENEMY_CITY_CAPTURED);

	bool bDisbanded = false;

	// In OCC games, all captured cities are toast
	if (isHuman() && GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE))
	{
		bDisbanded = true;
		disband(pNewCity);
		// disband will delete the city
		pNewCity = NULL;

		// Set the plots to no owner
		for(uint ui = 0; ui < aiPurchasedPlotX.size(); ui++)
		{
			CvPlot* pPlot = GC.getMap().plot(aiPurchasedPlotX[ui], aiPurchasedPlotY[ui]);
			pPlot->setOwner(NO_PLAYER, -1, /*bCheckUnits*/ true, /*bUpdateResources*/ true);
		}

	}
	else //if (bConquest)
	{
		// Set the plots to the new owner, now, we may be flipping it to a liberated player and we need to pass on the information.
		for(uint ui = 0; ui < aiPurchasedPlotX.size(); ui++)
		{
			CvPlot* pPlot = GC.getMap().plot(aiPurchasedPlotX[ui], aiPurchasedPlotY[ui]);
			if(pPlot->getOwner() != pNewCity->getOwner())
				pPlot->setOwner(pNewCity->getOwner(), /*iAcquireCityID*/ pNewCity->GetID(), /*bCheckUnits*/ true, /*bUpdateResources*/ true);
		}

		// Is this City being Occupied?
		if(pNewCity->getOriginalOwner() != GetID())
		{
			pNewCity->SetOccupied(true);

			if (!bGift)
			{
				int iInfluenceReduction = GetCulture()->GetInfluenceCityConquestReduction(eOldOwner);
#if defined(MOD_BALANCE_CORE)
				int iResistanceTurns = (((pNewCity->getPopulation() * 2) / 3) * (100 - iInfluenceReduction)) / 100;
				if (iResistanceTurns <= 0)
				{
					iResistanceTurns = 1;
				}
#else
				int iResistanceTurns = pNewCity->getPopulation() * (100 - iInfluenceReduction) / 100;
#endif

				if (iResistanceTurns > 0)
				{
					pNewCity->ChangeResistanceTurns(iResistanceTurns);
				}
			}
		}

		long lResult = 0;

		if(lResult == 0)
		{
			PlayerTypes eLiberatedPlayer = NO_PLAYER;

			// Captured someone's city that didn't originally belong to us - Liberate a player?
			if(pNewCity->getOriginalOwner() != eOldOwner && pNewCity->getOriginalOwner() != GetID())
			{
				eLiberatedPlayer = pNewCity->getOriginalOwner();
				if(!CanLiberatePlayerCity(eLiberatedPlayer))
				{
					eLiberatedPlayer = NO_PLAYER;
				}
			}

#if defined(MOD_BUGFIX_VENICE_PUPPETS_CAPITAL)
			// Venice MUST liberate their own capital
			if (GetPlayerTraits()->IsNoAnnexing() && pNewCity->getX() == GetOriginalCapitalX() && pNewCity->getY() == GetOriginalCapitalY())
			{
				if (iCaptureGold > 0 || iCaptureCulture > 0 || iCaptureGreatWorks > 0) {
					if (iCaptureCulture == 0 && iCaptureGreatWorks == 0) {
						strBuffer = GetLocalizedText("TXT_KEY_POPUP_GOLD_CITY_CAPTURE", iCaptureGold, pNewCity->getNameKey());
					} else {
						strBuffer = GetLocalizedText("TXT_KEY_POPUP_GOLD_AND_CULTURE_CITY_CAPTURE", iCaptureGold, iCaptureCulture, iCaptureGreatWorks, pNewCity->getNameKey());
					}
					GC.GetEngineUserInterface()->AddCityMessage(0, pNewCity->GetIDInfo(), GetID(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer);
				}
			}
			else
#endif
			// AI decides what to do with a City
			if(!isHuman())
			{
#if defined(MOD_BALANCE_CORE)
				AI_conquerCity(pNewCity, eOldOwner, bGift, bAllowRaze); // could delete the pointer...
#else
				AI_conquerCity(pNewCity, eOldOwner); // could delete the pointer...
#endif
				// So we will check to see if the plot still contains the city.
				CvCity* pkCurrentCity = pCityPlot->getPlotCity();
				if (pkCurrentCity == NULL || pNewCity != pkCurrentCity || pkCurrentCity->getOwner() != GetID())
				{
					// The city is gone or is not ours anymore (we gave it away)
					pNewCity = NULL;
				}
			}

			// Human decides what to do with a City
			else if(!GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS))
			{
				// Used to display info for annex/puppet/raze popup - turned off in DoPuppet and DoAnnex
				pNewCity->SetIgnoreCityForHappiness(true);
				if (GetPlayerTraits()->IsNoAnnexing() && bIsMinorCivBuyout)
				{
					pNewCity->DoCreatePuppet();
				}
				else if (pNewCity->getOriginalOwner() != GetID() || GetPlayerTraits()->IsNoAnnexing() || bIsMinorCivBuyout)
				{
					if(GC.getGame().getActivePlayer() == GetID())
					{
						int iTemp[5] = { pNewCity->GetID(), iCaptureGold, iCaptureCulture, iCaptureGreatWorks, eLiberatedPlayer };
						bool bTemp[2] = { bIsMinorCivBuyout, bConquest };
						GC.GetEngineUserInterface()->AddPopup(BUTTONPOPUP_CITY_CAPTURED, POPUP_PARAM_INT_ARRAY(iTemp), POPUP_PARAM_BOOL_ARRAY(bTemp));
						// We are adding a popup that the player must make a choice in, make sure they are not in the end-turn phase.
						CancelActivePlayerEndTurn();
					}
				}
				else
				{
					pNewCity->SetIgnoreCityForHappiness(false);
				}
			}

			// No choice but to capture it, tell about pillage gold (if any)
			else if(iCaptureGold > 0 || iCaptureCulture > 0 || iCaptureGreatWorks > 0)
			{
				if (iCaptureCulture == 0 && iCaptureGreatWorks == 0)
				{
					strBuffer = GetLocalizedText("TXT_KEY_POPUP_GOLD_CITY_CAPTURE", iCaptureGold, pNewCity->getNameKey());
					GC.GetEngineUserInterface()->AddCityMessage(0, pNewCity->GetIDInfo(), GetID(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer);
				}
				else
				{
					strBuffer = GetLocalizedText("TXT_KEY_POPUP_GOLD_AND_CULTURE_CITY_CAPTURE", iCaptureGold, iCaptureCulture, iCaptureGreatWorks, pNewCity->getNameKey());
					GC.GetEngineUserInterface()->AddCityMessage(0, pNewCity->GetIDInfo(), GetID(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer);

				}
			}
		}
	}
	// Be careful below here, pNewCity can be NULL.
	CheckForMurder(eOldOwner);

	if(GC.getGame().getActiveTeam() == GET_PLAYER(eOldOwner).getTeam())
	{
		CvMap& theMap = GC.getMap();
		theMap.updateDeferredFog();
	}
#if defined(MOD_DIPLOMACY_CITYSTATES_QUESTS)
	if(pNewCity != NULL && pNewCity->getOwner() == BARBARIAN_PLAYER)
	{
		CvBarbarians::DoCityActivationNotice(pNewCity->plot());
		
		// Spawn a Barbarian unit to garrison the acquired city
		CvBarbarians::DoSpawnBarbarianUnit(pNewCity->plot(), true, true);
	}
#endif
#if defined(MOD_BALANCE_CORE)
	UnitTypes eFreeUnitConquest = GetPlayerTraits()->GetFreeUnitOnConquest();
	if(eFreeUnitConquest != NO_UNIT)
	{
		if(pNewCity != NULL)
		{
			if(pNewCity->GetNumTimesOwned(GetID()) <= 1 && canTrain(eFreeUnitConquest))
			{
				CvUnit* pkUnit = initUnit(eFreeUnitConquest, pNewCity->getX(), pNewCity->getY());
				CvCity* pCapital = getCapitalCity();
				bool bJumpSuccess = pkUnit->jumpToNearestValidPlot();
				if (bJumpSuccess && pCapital != NULL)
				{
					pCapital->addProductionExperience(pkUnit);
				}
				else
				{
					pkUnit->kill(false);
				}
			}
		}
	}
#endif
	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem && pNewCity != NULL)
	{
		CvLuaArgsHandle args;
		args->Push(eOldOwner);
		args->Push(bCapital);
		args->Push(pNewCity->getX());
		args->Push(pNewCity->getY());
		args->Push(GetID());
		args->Push(iOldPopulation);
		args->Push(bConquest);
		args->Push((int)paGreatWorkData.size());
		args->Push(iCaptureGreatWorks);

		bool bResult;
		LuaSupport::CallHook(pkScriptSystem, "CityCaptureComplete", args.get(), bResult);
	}

#if defined(MOD_API_EXTENSIONS)
		return pNewCity;
#endif
#ifdef _MSC_VER
#pragma warning ( pop ) // restore warning level suppressed for pNewCity null check
#endif// _MSC_VER
}
bool CvPlayer::IsValidBuildingForPlayer(CvCity* pCity, BuildingTypes eBuilding, bool bGift, bool bRecapture)
{
	CvBuildingEntry* pkLoopBuildingInfo = GC.getBuildingInfo(eBuilding);
	if (!pkLoopBuildingInfo)
		return false;

	if (pkLoopBuildingInfo->IsDummy())
		return false;

	if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_ConquerorValidBuilding, pCity->getOwner(), pCity->GetID(), GetID(), eBuilding) == GAMEEVENTRETURN_FALSE) {
		return false;
	}

	const CvBuildingClassInfo& pkClassInfo = pkLoopBuildingInfo->GetBuildingClassInfo();

	bool bIsNationalWonder = ::isNationalWonderClass(pkClassInfo);
	bool bCivUnique = pkClassInfo.getDefaultBuildingIndex() != eBuilding;
	bool bProductionMaxed = isProductionMaxedBuildingClass((BuildingClassTypes)pkLoopBuildingInfo->GetBuildingClassType(), true);

	if (GetPlayerTraits()->IsKeepConqueredBuildings())
	{
		if (!bCivUnique)
		{
			if (bIsNationalWonder || bProductionMaxed)
				return false;
		}
		else
		{
			if (bIsNationalWonder && getNumBuildings(eBuilding) > 0)
				return false;
			else if (bProductionMaxed)
				return false;
		}
	}
	else
	{
		if (pkLoopBuildingInfo->IsNeverCapture() || bProductionMaxed || bIsNationalWonder)
			return false;

		if (bGift || bRecapture)
			return true;

		int iConquestChance = GC.getGame().getSmallFakeRandNum(34, *pCity->plot()) + GC.getGame().getSmallFakeRandNum(34, pkLoopBuildingInfo->GetID()) + GC.getGame().getSmallFakeRandNum(32, GC.getGame().GetCultureAverage());

		return iConquestChance <= pkLoopBuildingInfo->GetConquestProbability();
	}

	return true;
}

//	--------------------------------------------------------------------------------
void CvPlayer::killCities()
{
	//can't kill the cities directly because that invalidates the iterator
	std::vector<int> citiesToKill;

	int iLoop;
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		citiesToKill.push_back(pLoopCity->GetID());
	}

	for (std::vector<int>::iterator it=citiesToKill.begin(); it!=citiesToKill.end(); ++it)
	{
		CvCity* pLoopCity = getCity(*it);
		pLoopCity->kill(false);
	}
}

const int RESERVE_TOP_X_NAMES = 5;	/// Never steal one of the first 5 names

//	--------------------------------------------------------------------------------
CvString CvPlayer::getNewCityName() const
{
	const CLLNode<CvString>* pNode;
	CvString strName;

	for(pNode = headCityNameNode(); (pNode != NULL); pNode = nextCityNameNode(pNode))
	{
		strName = pNode->m_data;
		if(isCityNameValid(strName, true))
		{
			strName = pNode->m_data;
			break;
		}
	}

	if(strName.IsEmpty())
	{
		getCivilizationCityName(strName, getCivilizationType());
	}

	if(strName.IsEmpty())
	{
		// Pick a name from another civ in the game
		int iPlayersAlive = 0;
		for(int iI = 0; iI < MAX_PLAYERS; iI++)
		{
			const PlayerTypes ePlayer = static_cast<PlayerTypes>(iI);
			CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);
			if(ePlayer != GetID() && kPlayer.isAlive() && !kPlayer.isMinorCiv() && !kPlayer.isBarbarian())
			{
				iPlayersAlive++;
			}
		}

		int iChosenPlayer = GC.getGame().getJonRandNum(iPlayersAlive, "Random Player To Steal City Name");

		int iPlayersFound = 0;
		for(int iI = 0; iI < MAX_PLAYERS; iI++)
		{
			const PlayerTypes ePlayer = static_cast<PlayerTypes>(iI);
			CvPlayerAI &kPlayer = GET_PLAYER(ePlayer);
			if(ePlayer != GetID() && kPlayer.isAlive() && !kPlayer.isMinorCiv() && !kPlayer.isBarbarian())
			{
				if(iPlayersFound == iChosenPlayer)
				{
					strName = GetBorrowedCityName(kPlayer.getCivilizationType());			
					break;
				}
				else
				{
					iPlayersFound++;
				}
			}
		}
	}

	if(strName.IsEmpty())
	{
		// Pick a name from another civ in the DATABASE
		int iCivsInDB = 0;
		for(int iI = 0; iI < GC.getNumCivilizationInfos(); iI++)
		{
			const CivilizationTypes eCiv = static_cast<CivilizationTypes>(iI);

			CvCivilizationInfo* pkCivilizationInfo = GC.getCivilizationInfo(eCiv);
			if(pkCivilizationInfo != NULL && pkCivilizationInfo->getNumCityNames() > RESERVE_TOP_X_NAMES)
			{
				iCivsInDB++;
			}
		}

		int iChosenCiv = GC.getGame().getJonRandNum(iCivsInDB, "Random Civ To Steal City Name");

		int iCivsFound = 0;
		for(int iI = 0; iI < GC.getNumCivilizationInfos(); iI++)
		{
			const CivilizationTypes eCiv = static_cast<CivilizationTypes>(iI);

			CvCivilizationInfo* pkCivilizationInfo = GC.getCivilizationInfo(eCiv);
			if (pkCivilizationInfo != NULL && pkCivilizationInfo->getNumCityNames() > RESERVE_TOP_X_NAMES)
			{
				if (iCivsFound == iChosenCiv)
				{
					strName = GetBorrowedCityName(eCiv);
					break;
				}
				else
				{
					iCivsFound++;
				}
			}
		}
	}

	if(strName.IsEmpty())
	{
		strName = "TXT_KEY_CITY";
	}

	return strName;
}

//	--------------------------------------------------------------------------------
CvString CvPlayer::GetBorrowedCityName(CivilizationTypes eCivToBorrowFrom) const
{
	CvString szRtnValue;
	CvCivilizationInfo *pCivInfo = GC.getCivilizationInfo(eCivToBorrowFrom);

	if (pCivInfo)
	{
		int iRange = pCivInfo->getNumCityNames() - RESERVE_TOP_X_NAMES;
		int iRandOffset = GC.getGame().getJonRandNum(iRange, "Random City Name To Steal");
		for(int iI = 0; iI < iRange; iI++)     
		{
			CvString strCityName = pCivInfo->getCityNames(RESERVE_TOP_X_NAMES + ((iI + iRandOffset) % iRange));
			szRtnValue = GetLocalizedText(strCityName.c_str());

			if(isCityNameValid(szRtnValue, true))
			{
				break;
			}
		}
	}

	return szRtnValue;

}

//	--------------------------------------------------------------------------------
void CvPlayer::getCivilizationCityName(CvString& szBuffer, CivilizationTypes eCivilization) const
{
	int iRandOffset;
	int iLoopName;

	CvCivilizationInfo* pkCivilizationInfo = GC.getCivilizationInfo(eCivilization);
	if(pkCivilizationInfo == NULL)
	{
		//This should never happen.
		return;
	}

	if(isBarbarian())
	{
		iRandOffset = GC.getGame().getJonRandNum(pkCivilizationInfo->getNumCityNames(), "Random Barb Name");
	}
	else
	{
		iRandOffset = 0;
	}

	// Minor Civs use special lists
	if(isMinorCiv())
	{
		CvMinorCivInfo* pkMinorCivInfo = GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType());
		if(pkMinorCivInfo)
		{
			CvMinorCivInfo& kMinorCivInfo = *pkMinorCivInfo;
			for(int iI = 0; iI < kMinorCivInfo.getNumCityNames(); iI++)
			{
				iLoopName = ((iI + iRandOffset) % kMinorCivInfo.getNumCityNames());

				const CvString strCityName = kMinorCivInfo.getCityNames(iLoopName);
				CvString strName = GetLocalizedText(strCityName.c_str());

				if(isCityNameValid(strName, true))
				{
					szBuffer = strCityName;
					break;
				}
			}
		}
	}
	else
	{
		const CvCivilizationInfo& kCivInfo = *pkCivilizationInfo;
		for(int iI = 0; iI < kCivInfo.getNumCityNames(); iI++)
		{
			iLoopName = ((iI + iRandOffset) % kCivInfo.getNumCityNames());

			const CvString strCityName = kCivInfo.getCityNames(iLoopName);
			CvString strName = GetLocalizedText(strCityName.c_str());

			if(isCityNameValid(strName, true))
			{
				szBuffer = strCityName;
				break;
			}
		}
	}
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isCityNameValid(CvString& szName, bool bTestDestroyed, bool bForce) const
{
	if (bForce)
		return true;

	const CvCity* pLoopCity;
	int iLoop;

	if(bTestDestroyed)
	{
		if(GC.getGame().isDestroyedCityName(szName))
		{
			return false;
		}

		for(int iPlayer = 0; iPlayer < MAX_PLAYERS; ++iPlayer)
		{
			CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iPlayer);
			for(pLoopCity = kLoopPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kLoopPlayer.nextCity(&iLoop))
			{
				if(pLoopCity->getName() == szName)
				{
					return false;
				}
			}
		}
	}
	else
	{
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity->getName() == szName)
			{
				return false;
			}
		}
	}

	return true;
}

//	--------------------------------------------------------------------------------
/// How far out this player may buy plots
int CvPlayer::getBuyPlotDistance() const
{
	int iDistance = GC.getMAXIMUM_BUY_PLOT_DISTANCE();
	
	iDistance = std::min(MAX_CITY_RADIUS, std::max(getWorkPlotDistance(), iDistance));
	return iDistance;
}

//	--------------------------------------------------------------------------------
/// How far out this player may work plots
int CvPlayer::getWorkPlotDistance() const
{
	int iDistance = GC.getMAXIMUM_WORK_PLOT_DISTANCE();
	
#if defined(MOD_TRAITS_CITY_WORKING) || defined(MOD_BUILDINGS_CITY_WORKING) || defined(MOD_POLICIES_CITY_WORKING)
	// Change distance based on traits, policies, wonders, etc
	iDistance += GetCityWorkingChange();
#endif
#if defined(MOD_TECHS_CITY_WORKING)
	// Change distance based on techs, etc
	if (getTeam()!=NO_TEAM)
		iDistance += GET_TEAM(getTeam()).GetCityWorkingChange();
#endif
	
	iDistance = std::min(MAX_CITY_RADIUS, std::max(MIN_CITY_RADIUS, iDistance));
	return iDistance;
}

//	--------------------------------------------------------------------------------
/// How many plots a generic city may work
int CvPlayer::GetNumWorkablePlots() const
{
	return ((6 * (1+getWorkPlotDistance()) * getWorkPlotDistance() / 2) + 1);
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// This player liberates iOldCityID and gives it back to ePlayer
void CvPlayer::DoRevolutionPlayer(PlayerTypes ePlayer, int iOldCityID)
{
	CvCity* pCity = getCity(iOldCityID);
	CvAssert(pCity);
	if (!pCity)
		return;

	if(ePlayer == NO_PLAYER)
	{
		return;
	}

	if (GC.getLogging() && GC.getAILogging() && pCity != NULL)
	{
		CvString playerName;
		FILogFile* pLog;
		CvString strBaseString;
		CvString strOutBuf;
		CvString strFileName = "CityRevolutions.csv";
		playerName = getCivilizationShortDescription();
		pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";
		strOutBuf.Format("Revolution! Civ Liberated and %s restored to %s", pCity->getName().GetCString(), GET_PLAYER(ePlayer).getName());
		strBaseString += strOutBuf;
		pLog->Msg(strBaseString);
	}

	DoLiberatePlayer(ePlayer, pCity->GetID(), true);
}
CvPlot* CvPlayer::GetCenterOfMassEmpire() const
{
	if(m_iCenterOfMassX == -1 || m_iCenterOfMassY == -1)
	{
		return NULL;
	}
	//this handles wrapped coordinates
	CvPlot* pRtnValue = GC.getMap().plot(m_iCenterOfMassX, m_iCenterOfMassY);
	
	return pRtnValue;
}
void CvPlayer::SetCenterOfMassEmpire()
{
	int iTotalX = 0;
	int iTotalY = 0;
	int iNumCities = 0;

	int iLoop;
	CvCity* pCity = firstCity(&iLoop);

	if (!pCity)
		return;

	int iTotalX2 = 0;
	int iTotalY2 = 0;
	int iWorldWidth = GC.getMap().getGridWidth();
	int iWorldHeight = GC.getMap().getGridHeight();

	//the first unit is our reference ...
	int iRefX = pCity->getX();
	int iRefY = pCity->getY();
	iNumCities++;
	pCity = nextCity(&iLoop);

	while(pCity)
	{
		if(pCity->IsPuppet())
		{
			pCity = nextCity(&iLoop);
			continue;
		}

		int iDX = pCity->getX() - iRefX;
		int iDY = pCity->getY() - iRefY;

		if (GC.getMap().isWrapX())
		{
			if( iDX > +(iWorldWidth / 2))
				iDX -= iWorldWidth;
			if( iDX < -(iWorldWidth / 2))
				iDX += iWorldWidth;
		}
		if (GC.getMap().isWrapY())
		{
			if( iDY > +(iWorldHeight / 2))
				iDY -= iWorldHeight;
			if( iDY < -(iWorldHeight / 2))
				iDY += iWorldHeight;
		}

		iTotalX += iDX;
		iTotalY += iDY;
		iTotalX2 += iDX*iDX;
		iTotalY2 += iDY*iDY;
		iNumCities++;

		pCity = nextCity(&iLoop);
	}

	if (iNumCities==0)
		return;

	//finally, compute average (with rounding)
	int iAvgX = (iTotalX + (iNumCities / 2)) / iNumCities + iRefX;
	int iAvgY = (iTotalY + (iNumCities / 2)) / iNumCities + iRefY;

	m_iCenterOfMassX = iAvgX;
	m_iCenterOfMassY = iAvgY;
}

void CvPlayer::UpdateCityThreatCriteria()
{
	//What are you doing here? Get out!
	if(isMinorCiv() || isBarbarian() || isHuman())
		return;

	if(getNumCities() <= 1)
		return;

	//Reset the criteria.
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->SetThreatRank(-1);
		pLoopCity->SetCoastalThreatRank(-1);
	}

	//
	vector<CvCity*> threatenedCities = GetMilitaryAI()->GetThreatenedCities(true);
	for(int i = 0; i < (int)threatenedCities.size(); i++)
		threatenedCities[i]->SetThreatRank(i);

	vector<CvCity*> threatenedCoastalCities = GetMilitaryAI()->GetThreatenedCities(true, true);
	for (int i = 0; i < (int)threatenedCoastalCities.size(); i++)
		threatenedCoastalCities[i]->SetCoastalThreatRank(i);
}

CvCity* CvPlayer::GetThreatenedCityByRank(int iRank, bool bCoastalOnly)
{
	int iLoop;
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (bCoastalOnly)
		{
			if (pLoopCity->GetCoastalThreatRank() == iRank)
				return pLoopCity;
		}
		else if (pLoopCity->GetThreatRank() == iRank)
		{
			return pLoopCity;
		}
	}

	return NULL;
}

void CvPlayer::UpdateBestMilitaryCities()
{
	//What are you doing here? Get out!
	if(isMinorCiv() || isBarbarian())
		return;

	//First let's test domain, then we'll test combat class.
	CvCity* pLoopCity = NULL;
	int iLoop;

	//Unitcombat Value - let's find the best unitcombat class city (includes promotions for unit combat classes below).
	for(int iI = 0; iI < GC.getNumUnitCombatClassInfos(); iI++)
	{
		int iBestCombatClassValue = 0;
		const UnitCombatTypes eUnitCombatClass = static_cast<UnitCombatTypes>(iI);
		CvBaseInfo* pkUnitCombatClassInfo = GC.getUnitCombatClassInfo(eUnitCombatClass);
		if(pkUnitCombatClassInfo)
		{
			CvCity* pBestCombatClassCity = NULL;
			for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				//Production is king, and also our base value.
				int iCombatClassValue = (pLoopCity->getYieldRate(YIELD_PRODUCTION, false) / 5);

				//Also get our XP boosts local to this city.
				iCombatClassValue += pLoopCity->getFreeExperience();

				if(pLoopCity->getUnitCombatFreeExperience(eUnitCombatClass) > 0)
				{
					iCombatClassValue += max(1, pLoopCity->getUnitCombatFreeExperience(eUnitCombatClass));
				}
				if(pLoopCity->getUnitCombatProductionModifier(eUnitCombatClass) > 0)
				{
					iCombatClassValue += max(1, pLoopCity->getUnitCombatProductionModifier(eUnitCombatClass));
				}
				//Promotion Bonus
				for(int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
				{
					const PromotionTypes ePromotion = static_cast<PromotionTypes>(iI);
					CvPromotionEntry* pkPromotionInfo = GC.getPromotionInfo(ePromotion);
					if(pkPromotionInfo)
					{
						if(pLoopCity->isFreePromotion(ePromotion))
						{
							if(pkPromotionInfo->GetUnitCombatClass(eUnitCombatClass))
							{
								iCombatClassValue += 50;
							}
						}
					}
				}
				if(iCombatClassValue > iBestCombatClassValue)
				{
					iBestCombatClassValue = iCombatClassValue;
					pBestCombatClassCity = pLoopCity;
				}
			}
			if(pBestCombatClassCity != NULL && pBestCombatClassCity != GetBestMilitaryCity(eUnitCombatClass, NO_DOMAIN))
			{
				SetBestMilitaryCityCombatClass(pBestCombatClassCity->GetID(), eUnitCombatClass);
				if(GC.getLogging() && GC.getAILogging())
				{
					CvString strCity = pBestCombatClassCity->getName();
					CvString strLogString;
					strLogString.Format("***************** New Military Combat Class City Chosen for class %d: %s. ****************", eUnitCombatClass, strCity.c_str());
					GetHomelandAI()->LogHomelandMessage(strLogString);
				}
			}
		}
	}

	//Domain Value - let's get the city with the higher # of domain bonuses, and make it our best domain city.
	for (int iDomainLoop = 0; iDomainLoop < NUM_DOMAIN_TYPES; iDomainLoop++)
	{
		int iBestDomainValue = 0;
		DomainTypes eTestDomain = (DomainTypes)iDomainLoop;
		if (eTestDomain != NO_DOMAIN)
		{
			CvCity* pBestDomainCity = NULL;
			for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				//Production is king, and also our base value.
				int iDomainValue = (pLoopCity->getYieldRate(YIELD_PRODUCTION, false) / 5);

				//Also get our XP boosts local to this city.
				iDomainValue += pLoopCity->getFreeExperience();

				if (pLoopCity->getDomainFreeExperience(eTestDomain) > 0)
				{
					iDomainValue += max(1, pLoopCity->getDomainFreeExperience(eTestDomain));
				}
				if (pLoopCity->getDomainFreeExperienceFromGreatWorks(eTestDomain) > 0)
				{
					iDomainValue += max(1, pLoopCity->getDomainFreeExperienceFromGreatWorks(eTestDomain));
				}
				if (pLoopCity->getDomainFreeExperienceFromGreatWorksGlobal(eTestDomain) > 0)
				{
					iDomainValue += max(1, pLoopCity->getDomainFreeExperienceFromGreatWorksGlobal(eTestDomain));
				}
				if (pLoopCity->getDomainProductionModifier(eTestDomain) > 0)
				{
					iDomainValue += max(1, pLoopCity->getDomainProductionModifier(eTestDomain));
				}

				//Let's try to synergize our domain and combat class productions in the same cities.
				for (int iI = 0; iI < GC.getNumUnitCombatClassInfos(); iI++)
				{
					const UnitCombatTypes eUnitCombatClass = static_cast<UnitCombatTypes>(iI);
					CvBaseInfo* pkUnitCombatClassInfo = GC.getUnitCombatClassInfo(eUnitCombatClass);
					if (pkUnitCombatClassInfo)
					{
						if (GetBestMilitaryCity(eUnitCombatClass, NO_DOMAIN) == pLoopCity)
						{
							iDomainValue *= 2;
						}
					}
				}
				if (iDomainValue > iBestDomainValue)
				{
					iBestDomainValue = iDomainValue;
					pBestDomainCity = pLoopCity;
				}
			}
			if (pBestDomainCity != NULL && pBestDomainCity != GetBestMilitaryCity(NO_UNITCOMBAT, eTestDomain))
			{
				if (GC.getLogging() && GC.getAILogging())
				{
					CvString strCity = pBestDomainCity->getName();
					CvString strLogString;
					strLogString.Format("***************** New Military Domain City Chosen for domain %d: %s. ****************", eTestDomain, strCity.c_str());
					GetHomelandAI()->LogHomelandMessage(strLogString);
				}
				SetBestMilitaryCityDomain(pBestDomainCity->GetID(), eTestDomain);
			}
		}
	}
}
void CvPlayer::SetBestMilitaryCityDomain(int iValue, DomainTypes eDomain)
{
	VALIDATE_OBJECT
	CvAssertMsg(eDomain >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eDomain < NUM_DOMAIN_TYPES, "eIndex1 is expected to be within maximum bounds (invalid Index)");
	m_aiBestMilitaryDomainCity.setAt(eDomain, iValue);
}
void CvPlayer::SetBestMilitaryCityCombatClass(int iValue, UnitCombatTypes eUnitCombat)
{
	VALIDATE_OBJECT
	CvAssertMsg(eUnitCombat >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eUnitCombat < GC.getNumUnitCombatClassInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	m_aiBestMilitaryCombatClassCity.setAt(eUnitCombat, iValue);
}
CvCity* CvPlayer::GetBestMilitaryCity(UnitCombatTypes eUnitCombat, DomainTypes eDomain)
{
	if(eUnitCombat != NO_UNITCOMBAT)
	{
		return getCity(m_aiBestMilitaryCombatClassCity[eUnitCombat]);
	}
	else if(eDomain != NO_DOMAIN)
	{
		return getCity(m_aiBestMilitaryDomainCity[eDomain]);
	}
	else
	{
		return NULL;
	}
}
#endif
#if defined(MOD_BALANCE_CORE_EVENTS)
int CvPlayer::GetEventChoiceDuration(EventChoiceTypes eEventChoice) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEventChoice >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEventChoice < GC.getNumEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	return m_aiEventChoiceDuration[eEventChoice];
}
void CvPlayer::ChangeEventChoiceDuration(EventChoiceTypes eEventChoice,int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEventChoice >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEventChoice < GC.getNumEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	if(iValue != 0)
	{
		m_aiEventChoiceDuration.setAt(eEventChoice, m_aiEventChoiceDuration[eEventChoice] + iValue);
	}
}
void CvPlayer::SetEventChoiceDuration(EventChoiceTypes eEventChoice,int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEventChoice >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEventChoice < GC.getNumEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	m_aiEventChoiceDuration.setAt(eEventChoice, iValue);
}
int CvPlayer::GetEventIncrement(EventTypes eEvent) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	return m_aiEventIncrement[eEvent];
}
void CvPlayer::IncrementEvent(EventTypes eEvent, int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	if(iValue != 0)
	{
		m_aiEventIncrement.setAt(eEvent, m_aiEventIncrement[eEvent] + iValue);
	}
}
int CvPlayer::GetPlayerEventCooldown() const
{
	VALIDATE_OBJECT
	return m_iPlayerEventCooldown;
}
void CvPlayer::ChangePlayerEventCooldown(int iValue)
{
	VALIDATE_OBJECT
	if(iValue != 0)
	{
		m_iPlayerEventCooldown += iValue;
	}
}
int CvPlayer::GetEventCooldown(EventTypes eEvent) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	return m_aiEventCooldown[eEvent];
}
void CvPlayer::ChangeEventCooldown(EventTypes eEvent,int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	if(iValue != 0)
	{
		m_aiEventCooldown.setAt(eEvent, m_aiEventCooldown[eEvent] + iValue);
	}
}
void CvPlayer::SetEventCooldown(EventTypes eEvent,int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	m_aiEventCooldown.setAt(eEvent, iValue);
}

void CvPlayer::SetEventActive(EventTypes eEvent, bool bValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	m_abEventActive.setAt(eEvent, bValue);
}
bool CvPlayer::IsEventActive(EventTypes eEvent) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	return m_abEventActive[eEvent];
}
void CvPlayer::SetEventChoiceActive(EventChoiceTypes eEventChoice, bool bValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEventChoice >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEventChoice < GC.getNumEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	m_abEventChoiceActive.setAt(eEventChoice, bValue);
}
bool CvPlayer::IsEventChoiceActive(EventChoiceTypes eEventChoice) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEventChoice >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEventChoice < GC.getNumEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	return m_abEventChoiceActive[eEventChoice];
}
void CvPlayer::SetEventChoiceFired(EventChoiceTypes eEvent, bool bValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	m_abEventChoiceFired.setAt(eEvent, bValue);
}
bool CvPlayer::IsEventChoiceFired(EventChoiceTypes eEvent) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	return m_abEventChoiceFired[eEvent];
}
void CvPlayer::SetEventFired(EventTypes eEvent, bool bValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	m_abEventFired.setAt(eEvent, bValue);
}
bool CvPlayer::IsEventFired(EventTypes eEvent) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	return m_abEventFired[eEvent];
}
void CvPlayer::DoEvents()
{
	//Minors? Barbs? Get out!
	if(isMinorCiv() || isBarbarian())
		return;

	//Event Choice Duration First - if we're in one, let's do the countdown now.
	//We need to do this first so we can cancel the event(s).
	for(int iLoop = 0; iLoop < GC.getNumEventChoiceInfos(); iLoop++)
	{
		EventChoiceTypes eEventChoice = (EventChoiceTypes)iLoop;
		if(eEventChoice != NO_EVENT_CHOICE)
		{
			if(GetEventChoiceDuration(eEventChoice) > 0)
			{
				ChangeEventChoiceDuration(eEventChoice, -1);
				if(GC.getLogging())
				{
					CvModEventChoiceInfo* pkEventInfo = GC.getEventChoiceInfo(eEventChoice);
					if(pkEventInfo != NULL)
					{
						CvString playerName;
						FILogFile* pLog;
						CvString strBaseString;
						CvString strOutBuf;
						CvString strFileName = "EventLogging.csv";
						playerName = getCivilizationShortDescription();
						pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
						strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
						strBaseString += playerName + ", ";
						strOutBuf.Format("Event Choice Cooldown: %s Changing Value by -1. Cooldown Remaining: %d", pkEventInfo->GetDescription(), GetEventChoiceDuration(eEventChoice));
						strBaseString += strOutBuf;
						pLog->Msg(strBaseString);
					}
				}
				if(GetEventChoiceDuration(eEventChoice) == 0)
				{
					DoCancelEventChoice(eEventChoice);
				}
			}
		}
	}

	if (GetPlayerEventCooldown() > 0)
	{
		if (GC.getLogging())
		{
			CvString playerName;
			FILogFile* pLog;
			CvString strBaseString;
			CvString strOutBuf;
			CvString strFileName = "EventLogging.csv";
			playerName = getCivilizationShortDescription();
			pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			strBaseString += playerName + ", ";
			strOutBuf.Format("Player Event: Global Cooldown Active. Cooldown: %d", GetPlayerEventCooldown());
			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}
		ChangePlayerEventCooldown(-1);
	}

	//Let's loop through all events.
	CvWeightedVector<int> veValidEvents;

	for(int iLoop = 0; iLoop < GC.getNumEventInfos(); iLoop++)
	{
		EventTypes eEvent = (EventTypes)iLoop;
		if (eEvent != NO_EVENT)
		{
			CvModEventInfo* pkEventInfo = GC.getEventInfo(eEvent);
			if (pkEventInfo == NULL)
			{
				continue;
			}

			if (pkEventInfo->getRandomChance() == -1)
				continue;

			if (pkEventInfo->isOneShot() && IsEventFired(eEvent))
				continue;

			//Lua Hook
			if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_EventCanTake, GetID(), eEvent) == GAMEEVENTRETURN_FALSE)
			{
				continue;
			}

			//Global Cooldown Second - if we've had this event recently, let's check this.
			if (GetEventCooldown(eEvent) > 0)
			{
				if (GC.getLogging())
				{
					CvModEventInfo* pkEventInfo = GC.getEventInfo(eEvent);
					if (pkEventInfo != NULL)
					{
						CvString playerName;
						FILogFile* pLog;
						CvString strBaseString;
						CvString strOutBuf;
						CvString strFileName = "EventLogging.csv";
						playerName = getCivilizationShortDescription();
						pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
						strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
						strBaseString += playerName + ", ";
						strOutBuf.Format("Player Event: %s. Cooldown Active. Cooldown: %d", pkEventInfo->GetDescription(), GetEventCooldown(eEvent));
						strBaseString += strOutBuf;
						pLog->Msg(strBaseString);
					}
				}
				ChangeEventCooldown(eEvent, -1);
				continue;
			}

			if (GetPlayerEventCooldown() > 0 && !pkEventInfo->IgnoresGlobalCooldown())
			{
				continue;
			}

			//most expensive check last
			if (IsEventValid(eEvent))
			{
				veValidEvents.push_back(eEvent, (pkEventInfo->getRandomChance() + GetEventIncrement(eEvent)));
			}
		}
	}

	EventTypes eChosenEvent = NO_EVENT;

	if(veValidEvents.size() > 0)
	{
		veValidEvents.SortItems();
		if(GC.getLogging())
		{
			CvString strBaseString;
			CvString strOutBuf;
			CvString strFileName = "EventLogging.csv";
			CvString playerName = getCivilizationShortDescription();
			FILogFile* pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			strBaseString += playerName + ", ";
			strOutBuf.Format("Found %d Events for seeding", veValidEvents.size());
			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}

		int iRandIndex = GC.getGame().getJonRandNum(1000, "Picking random event for player.");

		//which one is it?
		int iWeight = 0;
		for (int iLoop = 0; iLoop < veValidEvents.size(); iLoop++)
		{
			EventTypes eEvent = (EventTypes)veValidEvents.GetElement(iLoop);
			CvModEventInfo* pkEventInfo = GC.getEventInfo(eEvent);
			if (!pkEventInfo)
				continue;

			iWeight = veValidEvents.GetWeight(iLoop);
			if (iRandIndex < iWeight)
			{
				eChosenEvent = eEvent;
				break;
			}
		}

		if (eChosenEvent != NO_EVENT)
		{
			CvModEventInfo* pkEventInfo = GC.getEventInfo(eChosenEvent);
			if (pkEventInfo != NULL)
			{
				for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
				{
					PlayerTypes ePlayer = (PlayerTypes)iPlayerLoop;
					if (ePlayer != NO_PLAYER && GET_PLAYER(ePlayer).isAlive())
					{
						//Not global?
						if (!pkEventInfo->isGlobal() && ePlayer != GetID())
							continue;

						GET_PLAYER(ePlayer).DoStartEvent(eChosenEvent);

						GET_PLAYER(ePlayer).ChangePlayerEventCooldown(GC.getEVENT_MIN_DURATION_BETWEEN());

						//reset probability
						IncrementEvent(eChosenEvent, -GetEventIncrement(eChosenEvent));
						if (GC.getLogging())
						{
							CvString strBaseString;
							CvString strOutBuf;
							CvString strFileName = "EventLogging.csv";
							CvString playerName = getCivilizationShortDescription();
							FILogFile* pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
							strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
							strBaseString += playerName + ", ";
							strOutBuf.Format("Resetting event chance for: %s", pkEventInfo->GetDescription());
							strBaseString += strOutBuf;
							pLog->Msg(strBaseString);
						}
					}
				}
			}
		}
	}

	for (int iLoop = 0; iLoop < veValidEvents.size(); iLoop++)
	{
		EventTypes eEvent = (EventTypes)veValidEvents.GetElement(iLoop);
		if (eEvent != NO_EVENT)
		{
			CvModEventInfo* pkEventInfo = GC.getEventInfo(eEvent);
			if (!pkEventInfo)
				continue;

			//But not for the one we just did!
			if (eChosenEvent == eEvent)
				continue;

			//make it more likely
			if (pkEventInfo->getRandomChanceDelta() > 0)
			{
				IncrementEvent(eEvent, pkEventInfo->getRandomChanceDelta());
				if (GC.getLogging())
				{
					CvString strBaseString;
					CvString strOutBuf;
					CvString strFileName = "EventLogging.csv";
					CvString playerName = getCivilizationShortDescription();
					FILogFile* pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
					strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
					strBaseString += playerName + ", ";
					strOutBuf.Format("Incrementing event chance for: %s, Increment: %d", pkEventInfo->GetDescription(), GetEventIncrement(eEvent));
					strBaseString += strOutBuf;
					pLog->Msg(strBaseString);
				}
			}
		}
	}
}

bool CvPlayer::IsEventValid(EventTypes eEvent)
{
	CvModEventInfo* pkEventInfo = GC.getEventInfo(eEvent);
	if(pkEventInfo == NULL)
	{
		return false;
	}

	//Lua Hook
	if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_EventCanActivate, GetID(), eEvent) == GAMEEVENTRETURN_FALSE) 
	{
		return false;
	}

	EventClassTypes eEventClass = (EventClassTypes)pkEventInfo->getEventClass();
	if (eEventClass != NO_EVENT_CLASS)
	{
		if (eEventClass == EVENT_CLASS_GOOD)
		{
			if (GC.getGame().isOption(GAMEOPTION_GOOD_EVENTS_OFF))
				return false;
		}
		else if (eEventClass == EVENT_CLASS_BAD)
		{
			if (GC.getGame().isOption(GAMEOPTION_BAD_EVENTS_OFF))
				return false;
		}
		else if (eEventClass == EVENT_CLASS_NEUTRAL)
		{
			if (GC.getGame().isOption(GAMEOPTION_NEUTRAL_EVENTS_OFF))
				return false;
		}
		else if (eEventClass == EVENT_CLASS_TRADE)
		{
			if (GC.getGame().isOption(GAMEOPTION_TRADE_EVENTS_OFF))
				return false;
		}
		else if (eEventClass == EVENT_CLASS_CIV_SPECIFIC)
		{
			if (GC.getGame().isOption(GAMEOPTION_CIV_SPECIFIC_EVENTS_OFF))
				return false;
		}
	}
		
	//Let's narrow down all events here!
	if(pkEventInfo->getPrereqTech() != -1 && !GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
		return false;

	if(pkEventInfo->getObsoleteTech() != -1 && GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
		return false;

	if(pkEventInfo->getRequiredEra() != -1 && GetCurrentEra() < (EraTypes)pkEventInfo->getRequiredEra())
		return false;

	if(pkEventInfo->getObsoleteEra() != -1 && GetCurrentEra() >= (EraTypes)pkEventInfo->getObsoleteEra())
		return false;

	if(pkEventInfo->getMinimumNationalPopulation() > 0 && getTotalPopulation() < pkEventInfo->getMinimumNationalPopulation())
		return false;

	if(pkEventInfo->getMinimumNumberCities() > 0 && getNumCities() < pkEventInfo->getMinimumNumberCities())
		return false;

	if(pkEventInfo->getRequiredCiv() != -1 && getCivilizationType() != (CivilizationTypes)pkEventInfo->getRequiredCiv())
		return false;

	if(pkEventInfo->getRequiredPolicy() != -1 && !GetPlayerPolicies()->HasPolicy((PolicyTypes)pkEventInfo->getRequiredPolicy()))
		return false;

	if(pkEventInfo->getRequiredIdeology() != -1 && GetPlayerPolicies()->GetLateGamePolicyTree() != (PolicyBranchTypes)pkEventInfo->getRequiredIdeology())
		return false;

	if(pkEventInfo->hasStateReligion() && GetReligions()->GetStateReligion() == NO_RELIGION)
		return false;

	if(pkEventInfo->hasPantheon() && GetReligions()->GetReligionCreatedByPlayer(true) != RELIGION_PANTHEON)
		return false;

	if (pkEventInfo->isUnhappy() && !IsEmpireUnhappy())
		return false;

	if(pkEventInfo->isSuperUnhappy() && !IsEmpireSuperUnhappy())
		return false;

	if(pkEventInfo->isRequiresIdeology() && GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
		return false;

	if(pkEventInfo->isRequiresWar() && GetMilitaryAI()->GetNumberCivsAtWarWith(false) <= 0)
		return false;

	//Let's do our linker checks here.
	for(int iI = 0; iI <= pkEventInfo->GetNumLinkers(); iI++)
	{
		CvEventLinkingInfo *pLinkerInfo = pkEventInfo->GetLinkerInfo(iI);
		if(pLinkerInfo)
		{
			EventTypes eLinkerEvent = (EventTypes)pLinkerInfo->GetLinkingEvent();
			EventChoiceTypes eLinkerEventChoice = (EventChoiceTypes)pLinkerInfo->GetLinkingEventChoice();
			CityEventTypes eLinkerCityEvent = (CityEventTypes)pLinkerInfo->GetCityLinkingEvent();
			CityEventChoiceTypes eLinkerCityEventChoice = (CityEventChoiceTypes)pLinkerInfo->GetCityLinkingEventChoice();

			PlayerTypes ePlayer;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				ePlayer = (PlayerTypes) iPlayerLoop;
				if(ePlayer == NO_PLAYER)
					continue;

				CvPlayer &kPlayer2 = GET_PLAYER(ePlayer);

				if(!pLinkerInfo->CheckOtherPlayers() && ePlayer != GetID())
					continue;

				if(eLinkerEvent != NO_EVENT)
				{
					bool bActive = (kPlayer2.GetEventCooldown(eLinkerEvent) > 0 || kPlayer2.IsEventFired(eLinkerEvent));
					if(bActive != pLinkerInfo->CheckForActive())
						return false;
				}

				if(eLinkerEventChoice != NO_EVENT_CHOICE)
				{
					bool bActive = (kPlayer2.GetEventChoiceDuration(eLinkerEventChoice) > 0 || kPlayer2.IsEventChoiceFired(eLinkerEventChoice));
					if(bActive != pLinkerInfo->CheckForActive())
						return false;
				}

				if(eLinkerCityEvent != NO_EVENT_CITY || eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
				{
					int iLoop;
					CvCity* pLoopCity;
					for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))
					{
						if(eLinkerCityEvent != NO_EVENT_CITY)
						{
							bool bActive = (pLoopCity->GetEventCooldown(eLinkerCityEvent) > 0 || pLoopCity->IsEventFired(eLinkerCityEvent));
							if(bActive != pLinkerInfo->CheckForActive())
								return false;
						}

						if(eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
						{
							bool bActive = (pLoopCity->GetEventChoiceDuration(eLinkerCityEventChoice) > 0 || pLoopCity->IsEventChoiceFired(eLinkerCityEventChoice));
							if(bActive != pLinkerInfo->CheckForActive())
								return false;
						}
					}
				}
			}
		}
	}

	if(pkEventInfo->getRequiredStateReligion() != -1)
	{
		if(GetReligions()->GetStateReligion() != pkEventInfo->getRequiredStateReligion())
			return false;
	}

	if(!pkEventInfo->isRequiresHolyCity() && pkEventInfo->getRequiredReligion() != -1)
	{
		if((GetReligions()->GetCurrentReligion(false) != (ReligionTypes)pkEventInfo->getRequiredReligion()) && (GetReligions()->GetReligionInMostCities() != (ReligionTypes)pkEventInfo->getRequiredReligion()))
			return false;
	}

	if(pkEventInfo->hasMetAnotherCiv())
	{
		if(GET_TEAM(getTeam()).getHasMetCivCount(true) <= 0)
			return false;
	}

	if(MOD_DIPLOMACY_CIV4_FEATURES && pkEventInfo->isMaster() && GET_TEAM(getTeam()).GetNumVassals() <= 0)
		return false;

	if(MOD_DIPLOMACY_CIV4_FEATURES && pkEventInfo->isVassal() && !GET_TEAM(getTeam()).IsVassalOfSomeone())
		return false;

	if(pkEventInfo->isTradeCapped() && GetTrade()->GetNumTradeUnitsRemaining(true) <= 0)
		return false;


	if(pkEventInfo->getUnitTypeRequired() != -1)
	{
		bool bHas = false;
		CvUnit* pLoopUnit;
		int iLoop;
		for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		{
			if(pLoopUnit != NULL && pLoopUnit->getUnitClassType() == (UnitClassTypes)pkEventInfo->getUnitTypeRequired())
			{
				bHas = true;
				break;
			}
		}
		if(!bHas)
		{
			return false;
		}
	}

	if(pkEventInfo->isRequiresHolyCity())
	{
		bool bHas = false;
		CvCity* pCity = NULL;
		int iLoop;
		for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
		{
			if(pkEventInfo->getRequiredReligion() != -1)
			{
				if(pCity != NULL && pCity->GetCityReligions()->IsHolyCityForReligion((ReligionTypes)pkEventInfo->getRequiredReligion()))
				{
					bHas = true;
					break;
				}
			}
			else
			{
				if(pCity != NULL && pCity->GetCityReligions()->IsHolyCityAnyReligion())
				{
					bHas = true;
					break;
				}
			}
		}
		if(!bHas)
		{
			return false;
		}
	}
	if(pkEventInfo->getNumCoastalRequired() > 0)
	{
		bool bHas = false;
		CvCity* pCity = NULL;
		int iLoop;
		int iNumCoastal = 0;
		for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
		{
			if(pCity != NULL && pCity->isCoastal())
			{
				iNumCoastal++;
			}
			if(iNumCoastal >= pkEventInfo->getNumCoastalRequired())
			{
				bHas = true;
				break;
			}
		}
		if(!bHas)
		{
			return false;
		}
	}

	if(pkEventInfo->isRequiresWarMinor())
	{
		bool bHas = false;
		for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			// Is this a player we have relations with?
			if(GET_PLAYER(eLoopPlayer).isBarbarian())
			{
				continue;
			}
			if(!GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				continue;
			}
			if(eLoopPlayer != GetID())
			{
				if(GET_TEAM(getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
				{
					bHas = true;
					break;
				}
			}
		}
		if(!bHas)
		{
			return false;
		}
	}
	bool bHas = true;
	for(int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
	{
		const ResourceTypes eResource = static_cast<ResourceTypes>(iJ);
		CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
		if(pkResource)
		{
			if(pkEventInfo->getResourceRequired(eResource) > 0)
			{
				if(getNumResourceTotal(eResource, false) < pkEventInfo->getResourceRequired(eResource))
				{
					bHas = false;
					break;
				}
			}
		}
	}
	if(!bHas)
	{
		return false;
	}
	for(int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
	{
		const FeatureTypes eFeature = static_cast<FeatureTypes>(iJ);
		CvFeatureInfo* pkFeature = GC.getFeatureInfo(eFeature);
		if(pkFeature)
		{
			if(pkEventInfo->getFeatureRequired(eFeature) > 0)
			{
				bool bHas = false;
				CvCity* pCity = NULL;
				int iLoop;
				int iNeeded = pkEventInfo->getFeatureRequired(eFeature);
				int iHave = 0;
				for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
				{

					if(pCity != NULL && pCity->HasFeature(eFeature))
					{
						iHave++;
					}
					if(iHave >= iNeeded)
					{
						bHas = true;
						break;
					}
				}
				if(!bHas)
				{
					return false;
				}
			}
		}
	}

	if(pkEventInfo->getBuildingRequired() != -1)
	{
		BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventInfo->getBuildingRequired();
		if(eBuildingClass != NO_BUILDINGCLASS)
		{
			bool bHas = false;
			CvCity* pCity = NULL;
			int iLoop;
			for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
			{
				if(pCity != NULL && pCity->GetCityBuildings()->GetNumBuildingClass(eBuildingClass) > 0)
				{
					bHas = true;
					break;
				}
			}
			if(!bHas)
			{
				return false;
			}
		}
	}
	if(pkEventInfo->getBuildingLimiter() != -1)
	{
		BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventInfo->getBuildingLimiter();
		if(eBuildingClass != NO_BUILDINGCLASS)
		{
			bool bHas = false;
			CvCity* pCity = NULL;
			int iLoop;
			for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
			{
				if(pCity != NULL && pCity->GetCityBuildings()->GetNumBuildingClass(eBuildingClass) > 0)
				{
					bHas = true;
					break;
				}
			}
			if(bHas)
			{
				return false;
			}
		}
	}
	if(pkEventInfo->getRequiredImprovement() != -1)
	{
		ImprovementTypes eImprovement = (ImprovementTypes)pkEventInfo->getRequiredImprovement();
		if(eImprovement != NO_IMPROVEMENT)
		{
			bool bHas = false;
			CvPlot* pLoopPlot;
			int iNumPlotsInEntireWorld = GC.getMap().numPlots();
			for(int iI = 0; iI < iNumPlotsInEntireWorld; iI++)
			{
				pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

				if(pLoopPlot == NULL)
					return false;

				if(pLoopPlot->getOwner() == GetID() && pLoopPlot->getImprovementType() == eImprovement)
				{
					bHas = true;
					break;
				}
			}
			if(!bHas)
			{
				return false;
			}
		}
	}
	//Check our minimum yields - this looks at stored values, not yields per turn.
	bHas = true;
	for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes)iI;
		if(eYield == NO_YIELD)
			return false;
							
		int iNeededYield = pkEventInfo->getYieldMinimum(eYield);
		iNeededYield *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
		iNeededYield /= 100;
		if(pkEventInfo->isEraScaling())
		{
			int iEra = GetCurrentEra();
			if(iEra <= 0)
			{
				iEra = 1;
			}
			iNeededYield *= iEra;
		}
		if(iNeededYield != 0)
		{
			if(eYield == YIELD_GOLD)
			{
				if(iNeededYield > GetTreasury()->GetGold())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_SCIENCE)
			{
				TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
				int iTech = 0;
				if(eCurrentTech != NO_TECH)
				{
					iTech = GetPlayerTechs()->GetResearchProgress(eCurrentTech);
				}
				if(iNeededYield > iTech)
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_FAITH)
			{
				if(iNeededYield > GetFaith())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_GOLDEN_AGE_POINTS)
			{
				if(iNeededYield > GetGoldenAgeProgressMeter())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_CULTURE)
			{
				if(iNeededYield > getJONSCulture())
				{
					bHas = false;
					break;
				}
			}
		}
	}
	if(!bHas)
	{
		return false;
	}

	if(pkEventInfo->isInDebt() && GetTreasury()->GetGold() > 0)
		return false;

	if(pkEventInfo->isLosingMoney() && GetTreasury()->CalculateBaseNetGold() > 0)
		return false;

	return true;
}
bool CvPlayer::IsEventChoiceValid(EventChoiceTypes eChosenEventChoice, EventTypes eParentEvent)
{
	if(eChosenEventChoice == NO_EVENT_CHOICE)
		return false;

	CvModEventChoiceInfo* pkEventInfo = GC.getEventChoiceInfo(eChosenEventChoice);
	if(pkEventInfo == NULL)
	{
		return false;
	}

	//Exploit checks.
	if (isEndTurn())
	{
		// Not sure what the exploits are in particular but global events are fired outside of human turns so we can't return here
		if(!GC.getGame().isNetworkMultiPlayer()) // check simul/hybrid turns instead maybe? not sure yet.
			return false;
	}

	if(!IsEventActive(eParentEvent))
		return false;

	//Lua Hook
	if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_EventChoiceCanTake, GetID(), eChosenEventChoice) == GAMEEVENTRETURN_FALSE) {
		return false;
	}

	if(!pkEventInfo->isParentEvent(eParentEvent))
		return false;

	if(pkEventInfo->isOneShot() && IsEventChoiceFired(eChosenEventChoice))
		return false;

	//Event Choice already active for this event? Abort!
	if(GetEventChoiceDuration(eChosenEventChoice) > 0)
	{
		if(GC.getLogging())
		{
			CvString playerName;
			FILogFile* pLog;
			CvString strBaseString;
			CvString strOutBuf;
			CvString strFileName = "EventLogging.csv";
			playerName = getCivilizationShortDescription();
			pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			strBaseString += playerName + ", ";
			strOutBuf.Format("Event choice already active for player, skipping: %s, Event: %s. Cooldown: %d", pkEventInfo->GetDescription(), pkEventInfo->GetDescription(), GetEventChoiceDuration(eChosenEventChoice));
			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}
		return false;
	}

	//Let's narrow down all events here!
	if(pkEventInfo->getPrereqTech() != -1 && !GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
		return false;

	if(pkEventInfo->getObsoleteTech() != -1 && GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
		return false;

	if(pkEventInfo->getRequiredEra() != -1 && GetCurrentEra() < (EraTypes)pkEventInfo->getRequiredEra())
		return false;

	if(pkEventInfo->getObsoleteEra() != -1 && GetCurrentEra() >= (EraTypes)pkEventInfo->getObsoleteEra())
		return false;

	if(pkEventInfo->getMinimumNationalPopulation() > 0 && getTotalPopulation() < pkEventInfo->getMinimumNationalPopulation())
		return false;

	if(pkEventInfo->getMinimumNumberCities() > 0 && getNumCities() < pkEventInfo->getMinimumNumberCities())
		return false;

	if(pkEventInfo->getRequiredCiv() != -1 && getCivilizationType() != (CivilizationTypes)pkEventInfo->getRequiredCiv())
		return false;

	if(pkEventInfo->getRequiredPolicy() != -1 && !GetPlayerPolicies()->HasPolicy((PolicyTypes)pkEventInfo->getRequiredPolicy()))
		return false;

	if(pkEventInfo->getRequiredIdeology() != -1 && GetPlayerPolicies()->GetLateGamePolicyTree() != (PolicyBranchTypes)pkEventInfo->getRequiredIdeology())
		return false;

	if(pkEventInfo->hasStateReligion() && GetReligions()->GetStateReligion() == NO_RELIGION)
		return false;

	if(pkEventInfo->hasPantheon() && GetReligions()->GetReligionCreatedByPlayer(true) != RELIGION_PANTHEON)
		return false;

	if(pkEventInfo->isUnhappy() && !IsEmpireUnhappy())
		return false;

	if(pkEventInfo->isSuperUnhappy() && !IsEmpireSuperUnhappy())
		return false;

	if(pkEventInfo->isRequiresIdeology() && GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
		return false;

	if(pkEventInfo->isRequiresWar() && GetMilitaryAI()->GetNumberCivsAtWarWith(false) <= 0)
		return false;

	if(pkEventInfo->getRequiredStateReligion() != -1)
	{
		if(GetReligions()->GetStateReligion() != pkEventInfo->getRequiredStateReligion())
			return false;
	}

	if(!pkEventInfo->isRequiresHolyCity() && pkEventInfo->getRequiredReligion() != -1)
	{
		if((GetReligions()->GetCurrentReligion(false) != (ReligionTypes)pkEventInfo->getRequiredReligion()) && (GetReligions()->GetReligionInMostCities() != (ReligionTypes)pkEventInfo->getRequiredReligion()))
			return false;
	}

	//Let's do our linker checks here.
	for(int iI = 0; iI <= pkEventInfo->GetNumLinkers(); iI++)
	{
		CvEventChoiceLinkingInfo *pLinkerInfo = pkEventInfo->GetLinkerInfo(iI);
		if(pLinkerInfo)
		{
			EventTypes eLinkerEvent = (EventTypes)pLinkerInfo->GetLinkingEvent();
			EventChoiceTypes eLinkerEventChoice = (EventChoiceTypes)pLinkerInfo->GetLinkingEventChoice();
			CityEventTypes eLinkerCityEvent = (CityEventTypes)pLinkerInfo->GetCityLinkingEvent();
			CityEventChoiceTypes eLinkerCityEventChoice = (CityEventChoiceTypes)pLinkerInfo->GetCityLinkingEventChoice();

			PlayerTypes ePlayer;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				ePlayer = (PlayerTypes) iPlayerLoop;
				if(ePlayer == NO_PLAYER)
					continue;

				CvPlayer &kPlayer2 = GET_PLAYER(ePlayer);

				if(!pLinkerInfo->CheckOtherPlayers() && ePlayer != GetID())
					continue;

				if(eLinkerEvent != NO_EVENT)
				{
					bool bActive = (kPlayer2.GetEventCooldown(eLinkerEvent) > 0 || kPlayer2.IsEventFired(eLinkerEvent));
					if(bActive != pLinkerInfo->CheckForActive())
						return false;
				}

				if(eLinkerEventChoice != NO_EVENT_CHOICE)
				{
					bool bActive = (kPlayer2.GetEventChoiceDuration(eLinkerEventChoice) > 0 || kPlayer2.IsEventChoiceFired(eLinkerEventChoice));
					if(bActive != pLinkerInfo->CheckForActive())
						return false;
				}

				if(eLinkerCityEvent != NO_EVENT_CITY || eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
				{
					int iLoop;
					CvCity* pLoopCity;
					for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))
					{
						if(eLinkerCityEvent != NO_EVENT_CITY)
						{
							bool bActive = (pLoopCity->GetEventCooldown(eLinkerCityEvent) > 0 || pLoopCity->IsEventFired(eLinkerCityEvent));
							if(bActive != pLinkerInfo->CheckForActive())
								return false;
						}

						if(eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
						{
							bool bActive = (pLoopCity->GetEventChoiceDuration(eLinkerCityEventChoice) > 0 || pLoopCity->IsEventChoiceFired(eLinkerCityEventChoice));
							if(bActive != pLinkerInfo->CheckForActive())
								return false;
						}
					}
				}
			}
		}
	}

	if(pkEventInfo->hasMetAnotherCiv())
	{
		if(GET_TEAM(getTeam()).getHasMetCivCount(true) <= 0)
			return false;
	}

	if(MOD_DIPLOMACY_CIV4_FEATURES && pkEventInfo->isMaster() && GET_TEAM(getTeam()).GetNumVassals() <= 0)
		return false;

	if(MOD_DIPLOMACY_CIV4_FEATURES && pkEventInfo->isVassal() && !GET_TEAM(getTeam()).IsVassalOfSomeone())
		return false;

	if(pkEventInfo->isTradeCapped() && GetTrade()->GetNumTradeUnitsRemaining(true) <= 0)
		return false;

	if(pkEventInfo->getUnitTypeRequired() != -1)
	{
		bool bHas = false;
		CvUnit* pLoopUnit;
		int iLoop;
		for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		{
			if(pLoopUnit != NULL && pLoopUnit->getUnitClassType() == (UnitClassTypes)pkEventInfo->getUnitTypeRequired())
			{
				bHas = true;
				break;
			}
		}
		if(!bHas)
		{
			return false;
		}
	}


	if(pkEventInfo->isRequiresHolyCity())
	{
		bool bHas = false;
		CvCity* pCity = NULL;
		int iLoop;
		for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
		{
			if(pkEventInfo->getRequiredReligion() != -1)
			{
				if(pCity != NULL && pCity->GetCityReligions()->IsHolyCityForReligion((ReligionTypes)pkEventInfo->getRequiredReligion()))
				{
					bHas = true;
					break;
				}
			}
			else
			{
				if(pCity != NULL && pCity->GetCityReligions()->IsHolyCityAnyReligion())
				{
					bHas = true;
					break;
				}
			}
		}
		if(!bHas)
		{
			return false;
		}
	}
	if(pkEventInfo->getNumCoastalRequired() > 0)
	{
		bool bHas = false;
		CvCity* pCity = NULL;
		int iLoop;
		int iNumCoastal = 0;
		for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
		{
			if(pCity != NULL && pCity->isCoastal())
			{
				iNumCoastal++;
			}
			if(iNumCoastal >= pkEventInfo->getNumCoastalRequired())
			{
				bHas = true;
				break;
			}
		}
		if(!bHas)
		{
			return false;
		}
	}

	if(pkEventInfo->isRequiresWarMinor())
	{
		bool bHas = false;
		for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			// Is this a player we have relations with?
			if(GET_PLAYER(eLoopPlayer).isBarbarian())
			{
				continue;
			}
			if(!GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				continue;
			}
			if(eLoopPlayer != GetID())
			{
				if(GET_TEAM(getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
				{
					bHas = true;
					break;
				}
			}
		}
		if(!bHas)
		{
			return false;
		}
	}
	bool bHas = true;
	for(int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
	{
		const ResourceTypes eResource = static_cast<ResourceTypes>(iJ);
		CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
		if(pkResource)
		{
			if(pkEventInfo->getResourceRequired(eResource) > 0)
			{
				if(getNumResourceTotal(eResource, false) < pkEventInfo->getResourceRequired(eResource))
				{
					bHas = false;
					break;
				}
			}
		}
	}
	if(!bHas)
	{
		return false;
	}
	for(int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
	{
		const FeatureTypes eFeature = static_cast<FeatureTypes>(iJ);
		CvFeatureInfo* pkFeature = GC.getFeatureInfo(eFeature);
		if(pkFeature)
		{
			if(pkEventInfo->getFeatureRequired(eFeature) > 0)
			{
				bool bHas = false;
				CvCity* pCity = NULL;
				int iLoop;
				int iNeeded = pkEventInfo->getFeatureRequired(eFeature);
				int iHave = 0;
				for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
				{

					if(pCity != NULL && pCity->HasFeature(eFeature))
					{
						iHave++;
					}
					if(iHave >= iNeeded)
					{
						bHas = true;
						break;
					}
				}
				if(!bHas)
				{
					return false;
				}
			}
		}
	}
	if(pkEventInfo->getBuildingRequired() != -1)
	{
		BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventInfo->getBuildingRequired();
		if(eBuildingClass != NO_BUILDINGCLASS)
		{
			bool bHas = false;
			CvCity* pCity = NULL;
			int iLoop;
			for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
			{
				if(pCity != NULL && pCity->GetCityBuildings()->GetNumBuildingClass(eBuildingClass) > 0)
				{
					bHas = true;
					break;
				}
			}
			if(!bHas)
			{
				return false;
			}
		}
	}
	if(pkEventInfo->getBuildingLimiter() != -1)
	{
		BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventInfo->getBuildingLimiter();
		if(eBuildingClass != NO_BUILDINGCLASS)
		{
			bool bHas = false;
			CvCity* pCity = NULL;
			int iLoop;
			for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
			{
				if(pCity != NULL && pCity->GetCityBuildings()->GetNumBuildingClass(eBuildingClass) > 0)
				{
					bHas = true;
					break;
				}
			}
			if(bHas)
			{
				return false;
			}
		}
	}
	if(pkEventInfo->getRequiredImprovement() != -1)
	{
		ImprovementTypes eImprovement = (ImprovementTypes)pkEventInfo->getRequiredImprovement();
		if(eImprovement != NO_IMPROVEMENT)
		{
			bool bHas = false;
			CvPlot* pLoopPlot;
			int iNumPlotsInEntireWorld = GC.getMap().numPlots();
			for(int iI = 0; iI < iNumPlotsInEntireWorld; iI++)
			{
				pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

				if(pLoopPlot == NULL)
					continue;

				if(pLoopPlot->getOwner() == GetID() && pLoopPlot->getImprovementType() == eImprovement)
				{
					bHas = true;
					break;
				}
			}
			if(!bHas)
			{
				return false;
			}
		}
	}
	//Check our minimum yields - this looks at stored values, not yields per turn.
	bHas = true;
	for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes)iI;
		if(eYield == NO_YIELD)
			continue;
							
		int iNeededYield = pkEventInfo->getYieldMinimum(eYield);
		if(pkEventInfo->getPreCheckEventYield(eYield) != 0)
		{
			if(iNeededYield < pkEventInfo->getPreCheckEventYield(eYield))
			{
				iNeededYield = pkEventInfo->getPreCheckEventYield(eYield);
			}
		}
		iNeededYield *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
		iNeededYield /= 100;
		if(pkEventInfo->IsEraScaling())
		{
			int iEra = GetCurrentEra();
			if(iEra <= 0)
			{
				iEra = 1;
			}
			iNeededYield *= iEra;
		}
		if(iNeededYield != 0)
		{
			if(eYield == YIELD_GOLD)
			{
				if(iNeededYield > GetTreasury()->GetGold())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_SCIENCE)
			{
				TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
				int iTech = 0;
				if(eCurrentTech != NO_TECH)
				{
					iTech = GetPlayerTechs()->GetResearchProgress(eCurrentTech);
				}
				if(iNeededYield > iTech)
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_FAITH)
			{
				if(iNeededYield > GetFaith())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_GOLDEN_AGE_POINTS)
			{
				if(iNeededYield > GetGoldenAgeProgressMeter())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_CULTURE)
			{
				if(iNeededYield > getJONSCulture())
				{
					bHas = false;
					break;
				}
			}
		}
	}
	if(!bHas)
	{
		return false;
	}

	if(pkEventInfo->isInDebt() && GetTreasury()->GetGold() > 0)
		return false;

	if(pkEventInfo->isLosingMoney() && GetTreasury()->CalculateBaseNetGold() > 0)
		return false;

	return true;
}
void CvPlayer::DoStartEvent(EventTypes eChosenEvent)
{
	if(eChosenEvent != NO_EVENT)
	{
		CvModEventInfo* pkEventInfo = GC.getEventInfo(eChosenEvent);
		if(pkEventInfo != NULL)
		{
			//Set true so we know we're doing an event right now.
			SetEventActive(eChosenEvent, true);
	
			//Set oneshot stuff so this event can't fire ever again.
			if(pkEventInfo->isOneShot())
			{
				SetEventFired(eChosenEvent, true);
			}

			//Lua Hook
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_EventActivated, GetID(), eChosenEvent);

			//Gamespeed.
			int iEventDuration = pkEventInfo->getCooldown();
			iEventDuration *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iEventDuration /= 100;
			ChangeEventCooldown(eChosenEvent, iEventDuration);
			if(GC.getLogging())
			{
				CvString playerName;
				FILogFile* pLog;
				CvString strBaseString;
				CvString strOutBuf;
				CvString strFileName = "EventLogging.csv";
				playerName = getCivilizationShortDescription();
				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				strBaseString += playerName + ", ";
				strOutBuf.Format("Event started for player: %s. Cooldown: %d", pkEventInfo->GetDescription(), iEventDuration);
				strBaseString += strOutBuf;
				pLog->Msg(strBaseString);
			}
			int iNumEvents = 0;
			EventChoiceTypes eEventChoice = NO_EVENT_CHOICE;
			for(int iLoop = 0; iLoop < GC.getNumEventChoiceInfos(); iLoop++)
			{
				eEventChoice = (EventChoiceTypes)iLoop;
				if(eEventChoice != NO_EVENT_CHOICE)
				{
					CvModEventChoiceInfo* pkEventChoiceInfo = GC.getEventChoiceInfo(eEventChoice);
					if(pkEventChoiceInfo != NULL)
					{
						if(IsEventChoiceValid(eEventChoice, eChosenEvent))
						{
							iNumEvents++;
							if(pkEventInfo->getNumChoices() == 1)
							{
								DoEventChoice(eEventChoice, eChosenEvent);
								if(isHuman())
								{
									CvPopupInfo kPopupInfo(BUTTONPOPUP_MODDER_9, eEventChoice, GetID());
									GC.GetEngineUserInterface()->AddPopup(kPopupInfo);
								}
								return;
							}
						}
					}
				}
			}
			if(iNumEvents > 0 && pkEventInfo->getNumChoices() > 1)
			{
				if(isHuman())
				{
					CvNotifications* pNotifications = GetNotifications();
					if(pNotifications)
					{
						CvString strBuffer = GetLocalizedText("TXT_KEY_CHOOSE_EVENT_CHOICE");
						CvString strSummary = GetLocalizedText("TXT_KEY_CHOOSE_EVENT_CHOICE_TT");
						pNotifications->Add((NotificationTypes)FString::Hash("NOTIFICATION_EVENT_CHOICE"), strSummary.c_str(), strBuffer.c_str(), -1, -1, eChosenEvent);
					}
				}
				else
				{
					//Lua Hook
					if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_OverrideAIEvent, GetID(), eChosenEvent) == GAMEEVENTRETURN_TRUE) 
					{
						return;
					}

					AI_DoEventChoice(eChosenEvent);
				}
			}
		}
	}
}
void CvPlayer::DoCancelEventChoice(EventChoiceTypes eChosenEventChoice)
{
	if(eChosenEventChoice == NO_EVENT_CHOICE)
		return;

	CvModEventChoiceInfo* pkEventChoiceInfo = GC.getEventChoiceInfo(eChosenEventChoice);
	if(pkEventChoiceInfo != NULL)
	{
		//Lua Hook
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_EventChoiceEnded, GetID(), eChosenEventChoice);

		bool bChanged = false;
		if(GC.getLogging())
		{
			CvString playerName;
			FILogFile* pLog;
			CvString strBaseString;
			CvString strOutBuf;
			CvString strFileName = "EventLogging.csv";
			playerName = getCivilizationShortDescription();
			pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			strBaseString += playerName + ", ";
			strOutBuf.Format("Event choice ended for player: %s", pkEventChoiceInfo->GetDescription());
			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}
		//Let's make sure this is at zero.
		ChangeEventChoiceDuration(eChosenEventChoice, -GetEventChoiceDuration(eChosenEventChoice));
					
		//Let's only deduct if we actually started this event and it expires.
		if(IsEventChoiceActive(eChosenEventChoice) && pkEventChoiceInfo->Expires())
		{
			if(pkEventChoiceInfo->getEventPolicy() != -1)
			{
				PolicyTypes ePolicy = (PolicyTypes)pkEventChoiceInfo->getEventPolicy();
				if(ePolicy != -1)
				{
					setHasPolicy(ePolicy, false, true);
					bChanged = true;
				}
			}
			if(pkEventChoiceInfo->getEventTech() != -1)
			{
				TechTypes eTech = (TechTypes)pkEventChoiceInfo->getEventTech();
				if(eTech != -1)
				{
					GET_TEAM(getTeam()).GetTeamTechs()->SetHasTech(eTech, false);
				}
			}
			if(pkEventChoiceInfo->getEventBuilding() != -1)
			{
				BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventChoiceInfo->getEventBuilding();
				if(eBuildingClass != -1)
				{
					const CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
	
					if (pkBuildingClassInfo)
					{
						CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
		
						if (pCivilizationInfo != NULL)
						{
							BuildingTypes eBuildingType = (BuildingTypes) pCivilizationInfo->getCivilizationBuildings(eBuildingClass);
							CvCity *pLoopCity;
							int iLoop;
							for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
								{
									continue;
								}
								if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
								{
									continue;
								}
								pLoopCity->GetCityBuildings()->SetNumRealBuilding(eBuildingType, 0);
								bChanged = true;
							}
						}
					}
				}
			}
			if(pkEventChoiceInfo->getEventPromotion() != -1)
			{
				PromotionTypes ePromotion = (PromotionTypes)pkEventChoiceInfo->getEventPromotion();
				if(ePromotion != -1)
				{
					CvUnit* pLoopUnit;
					int iLoop;
					for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
					{
						if(pLoopUnit->getUnitType() != NO_UNIT)
						{
							if(::IsPromotionValidForUnitCombatType(ePromotion, pLoopUnit->getUnitType()))
							{
								pLoopUnit->setHasPromotion(ePromotion, false);
								bChanged = true;
							}
						}
					}
					ChangeFreePromotionCount(ePromotion, -1);
				}
			}
			for(int iI = 0; iI < GC.getNumResourceInfos(); iI++)
			{
				ResourceTypes eResource = (ResourceTypes)iI;
				if(eResource != NO_RESOURCE)
				{
					int iBonus = pkEventChoiceInfo->getEventResourceChange(eResource);
					iBonus *= -1;
					if(iBonus != 0)
					{
						changeNumResourceTotal(eResource, iBonus);
						bChanged = true;
					}
				}
			}
			if(pkEventChoiceInfo->getPlayerHappiness() != 0)
			{
				if(getCapitalCity() != NULL)
				{
					getCapitalCity()->ChangeEventHappiness(pkEventChoiceInfo->getPlayerHappiness() * -1);
					bChanged = true;
				}
			}
			if(pkEventChoiceInfo->getCityHappinessGlobal() != 0)
			{
				CvCity *pLoopCity;
				int iLoop;
				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
					{
						continue;
					}
					if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
					{
						continue;
					}
					pLoopCity->ChangeEventHappiness(pkEventChoiceInfo->getCityHappinessGlobal() * -1);
					bChanged = true;
				}
			}
			for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				YieldTypes eYield = (YieldTypes)iI;
				if(eYield == NO_YIELD)
					continue;

				if(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS)
				{
					int iUnhappinessNeedMod = pkEventChoiceInfo->getCityUnhappinessNeedMod(eYield);
					if(iUnhappinessNeedMod != 0)
					{
						iUnhappinessNeedMod *= -1;
						if(eYield == YIELD_GOLD)
						{
							ChangePovertyUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_CULTURE)
						{
							ChangeUnculturedUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_PRODUCTION)
						{
							ChangeDefenseUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_SCIENCE)
						{
							ChangeIlliteracyUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_FAITH)
						{
							ChangeMinorityUnhappinessGlobal(iUnhappinessNeedMod);
						}
					}
				}

				int iYieldChange = pkEventChoiceInfo->getCityYield(eYield);
				if(iYieldChange != 0)
				{
					if(pkEventChoiceInfo->IsEraScaling())
					{
						int iEra = GetCurrentEra();
						if(iEra <= 0)
						{
							iEra = 1;
						}
						iYieldChange *= iEra;
					}
					CvCity *pLoopCity;
					int iLoop;
					for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
						{
							continue;
						}
						if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
						{
							continue;
						}
						pLoopCity->ChangeEventCityYield(eYield, iYieldChange * -1);
						bChanged = true;
					}
				}
				// Building modifiers
				for(int iJ = 0; iJ < GC.getNumBuildingClassInfos(); iJ++)
				{
					BuildingClassTypes eBuildingClass = (BuildingClassTypes) iJ;

					CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
					if(!pkBuildingClassInfo)
					{
						continue;
					}
					if(pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield) != 0)
					{
						BuildingTypes eBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

						if(eBuilding != NO_BUILDING)
						{
							CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
							if(pkBuilding)
							{
								CvCity *pLoopCity;
								int iLoop;
								for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
								{
									if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
									{
										continue;
									}
									if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
									{
										continue;
									}
									int iBuildingCount = pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding);

									pLoopCity->ChangeEventBuildingClassYield(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield) * -1);
									bChanged = true;
									if(iBuildingCount > 0)
									{
										pLoopCity->ChangeBaseYieldRateFromBuildings(eYield, pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield) * -1);
									}
								}
							}
						}
					}
					if(pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield) != 0)
					{
						BuildingTypes eBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

						if(eBuilding != NO_BUILDING)
						{
							CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
							if(pkBuilding)
							{
								CvCity *pLoopCity;
								int iLoop;
								for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
								{
									if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
									{
										continue;
									}
									if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
									{
										continue;
									}
									int iBuildingCount = pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding);
									pLoopCity->ChangeEventBuildingClassYieldModifier(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield) * -1);
									bChanged = true;
									if(iBuildingCount > 0)
									{
										pLoopCity->changeYieldRateModifier(eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield) * -1);
									}
								}
							}
						}
					}
				}
				for(int iJ = 0; iJ < GC.getNumImprovementInfos(); iJ++)
				{
					ImprovementTypes eImprovement = (ImprovementTypes)iJ;
					if(eImprovement != NO_IMPROVEMENT && pkEventChoiceInfo->getImprovementYield(eImprovement, eYield) != 0)
					{
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
							{
								continue;
							}
							if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
							{
								continue;
							}
							pLoopCity->ChangeEventImprovementYield(eImprovement, eYield, pkEventChoiceInfo->getImprovementYield(eImprovement, eYield) * -1);
						}
						bChanged = true;
					}
				}
				for(int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
				{
					FeatureTypes eFeature = (FeatureTypes)iJ;
					if(eFeature != NO_FEATURE && pkEventChoiceInfo->getFeatureYield(eFeature, eYield) != 0)
					{
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
							{
								continue;
							}
							if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
							{
								continue;
							}
							pLoopCity->ChangeEventFeatureYield(eFeature, eYield, pkEventChoiceInfo->getFeatureYield(eFeature, eYield) * -1);
						}
						bChanged = true;
					}
				}
				for(int iJ = 0; iJ < GC.getNumTerrainInfos(); iJ++)
				{
					TerrainTypes eTerrain = (TerrainTypes)iJ;
					if(eTerrain != NO_TERRAIN && pkEventChoiceInfo->getTerrainYield(eTerrain, eYield) != 0)
					{
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
							{
								continue;
							}
							if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
							{
								continue;
							}
							pLoopCity->ChangeEventTerrainYield(eTerrain, eYield, pkEventChoiceInfo->getTerrainYield(eTerrain, eYield) * -1);
						}
						bChanged = true;
					}
				}
				for(int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
				{
					ResourceTypes eResource = (ResourceTypes)iJ;
					if(eResource != NO_RESOURCE && pkEventChoiceInfo->getResourceYield(eResource, eYield) != 0)
					{
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
							{
								continue;
							}
							if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
							{
								continue;
							}
							pLoopCity->ChangeEventResourceYield(eResource, eYield, pkEventChoiceInfo->getResourceYield(eResource, eYield) * -1);
						}
						bChanged = true;
					}
				}
				for(int iJ = 0; iJ < GC.getNumSpecialistInfos(); iJ++)
				{
					const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iJ);
					CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
					if(pkSpecialistInfo)
					{
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
							{
								continue;
							}
							if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
							{
								continue;
							}
							pLoopCity->ChangeEventSpecialistYield(eSpecialist, eYield, pkEventChoiceInfo->getGlobalSpecialistYieldChange(eSpecialist, eYield) * -1);
						}
						bChanged = true;
					}
				}
			}
		}
		if(bChanged)
		{
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications && GC.getGame().getActivePlayer() == GetID())
			{
				Localization::String strMessage;
				Localization::String strSummary;
				strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_EVENT_HAS_ENDED");
				strMessage << GetScaledHelpText(eChosenEventChoice, true);
				strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_EVENT_HAS_ENDED_T");

				pNotifications->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, -1, GetID());
			}
			CvCity* pLoopCity;
			int iLoop;
			for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				if(pLoopCity != NULL)
				{
					if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
					{
						continue;
					}
					if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
					{
						continue;
					}
					for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
					{
						YieldTypes eYield = (YieldTypes) iI;
						if(eYield == NO_YIELD)
							continue;

						pLoopCity->UpdateSpecialReligionYields(eYield);
						pLoopCity->UpdateCityYields(eYield);
					}
					pLoopCity->UpdateReligion(pLoopCity->GetCityReligions()->GetReligiousMajority());
					CalculateNetHappiness();
					pLoopCity->GetCityCulture()->CalculateBaseTourismBeforeModifiers();
					pLoopCity->GetCityCulture()->CalculateBaseTourism();
				}
			}
		}
		if (!pkEventChoiceInfo->isOneShot())
		{
			//Set it false here so we know the event choice is over now.
			SetEventChoiceActive(eChosenEventChoice, false);
		}
	}
}
CvString CvPlayer::GetScaledHelpText(EventChoiceTypes eEventChoice, bool bYieldsOnly)
{
	CvString CoreYieldTip = "";
	CvModEventChoiceInfo* pkEventChoiceInfo = GC.getEventChoiceInfo(eEventChoice);
	if(pkEventChoiceInfo == NULL)
	{
		return "";
	}
	Localization::String localizedCoreText;
	if(bYieldsOnly)
	{
		localizedCoreText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION");
	}
	else
	{
		localizedCoreText = Localization::Lookup(pkEventChoiceInfo->GetHelp());
	}

	int iEra = GetCurrentEra();
	if(iEra <= 0)
	{
		iEra = 1;
	}
	CvString yieldCostTip = "";
	CvString yieldInstantTip = "";
	CvString yieldCityTip = "";
	CvString turnsTip = "";
				
	for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eIndex = (YieldTypes)iI;
		if(eIndex == NO_YIELD)
		{
			continue;
		}
		CvYieldInfo* pYield = GC.getYieldInfo(eIndex);
		if(pYield)
		{
			int iPreValue = pkEventChoiceInfo->getPreCheckEventYield(eIndex);
			if(pkEventChoiceInfo->IsEraScaling())
			{
				iPreValue *= iEra;
			}
			iPreValue *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
			iPreValue /= 100;
			if(iPreValue != 0)
			{
				iPreValue *= -1;
				if(yieldCostTip != "")
				{
					yieldCostTip += ", ";
				}
				Localization::String localizedCostText;
				if(bYieldsOnly)
				{
					localizedCostText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_SPENT");
				}
				else
				{
					localizedCostText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED");
				}
				localizedCostText << pYield->GetDescription();
				localizedCostText << pYield->getIconString();
				localizedCostText << iPreValue;

				const char* const localized = localizedCostText.toUTF8();
				if(localized)
				{
					yieldCostTip += localized;
				}
			}
			int iYieldValue = pkEventChoiceInfo->getEventYield(eIndex);
			if(pkEventChoiceInfo->IsEraScaling())
			{
				iYieldValue *= iEra;
			}
			iYieldValue *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
			iYieldValue /= 100;
			if(iYieldValue != 0)
			{
				if(yieldInstantTip != "")
				{
					yieldInstantTip += ", ";
				}
				Localization::String localizedEventText;
				if(bYieldsOnly)
				{
					localizedEventText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_INSTANT");
				}
				else
				{
					localizedEventText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED");
				}
				localizedEventText << pYield->GetDescription();
				localizedEventText << pYield->getIconString();
				localizedEventText << iYieldValue;

				const char* const localized = localizedEventText.toUTF8();
				if(localized)
				{
					yieldInstantTip += localized;
				}
			}
			int iCityValue = pkEventChoiceInfo->getCityYield(eIndex);
			if(pkEventChoiceInfo->IsEraScaling())
			{
				iCityValue *= iEra;
			}
			if(iCityValue != 0)
			{
				if(yieldCityTip != "")
				{
					yieldCityTip += ", ";
				}
				Localization::String localizedCityText;
				if(bYieldsOnly)
				{
					localizedCityText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_CITY");
				}
				else
				{
					localizedCityText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED");
				}
				localizedCityText << pYield->GetDescription();
				localizedCityText << pYield->getIconString();
				localizedCityText << iCityValue;

				const char* const localized = localizedCityText.toUTF8();
				if(localized)
				{
					yieldCityTip += localized;
				}
			}
		}
	}
	localizedCoreText << yieldCostTip;
	localizedCoreText << yieldInstantTip;
	localizedCoreText << yieldCityTip;

	//Duration
	int iDuration = pkEventChoiceInfo->getEventDuration();
	if(iDuration > 0)
	{
		iDuration *= GC.getGame().getGameSpeedInfo().getTrainPercent();
		iDuration /= 100;
		Localization::String localizedDurationText;
		if(bYieldsOnly)
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_TURNS");
		}
		else
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_YIELD_DURATION");
		}
		localizedDurationText << iDuration;
		const char* const localized = localizedDurationText.toUTF8();
		if(localized)
		{
			turnsTip += localized;
		}
	}
	localizedCoreText << turnsTip;

	const char* const finallocalized = localizedCoreText.toUTF8();
	if(finallocalized)
	{
		CoreYieldTip = finallocalized;
	}
	return CoreYieldTip.c_str();
}
CvString CvPlayer::GetDisabledTooltip(EventChoiceTypes eChosenEventChoice)
{
	CvString DisabledTT = Localization::Lookup("TXT_KEY_EVENT_DISABLED_REASONS_HEADER").toUTF8();
	Localization::String localizedDurationText;

	if(eChosenEventChoice == NO_EVENT_CHOICE)
		return "";

	CvModEventChoiceInfo* pkEventInfo = GC.getEventChoiceInfo(eChosenEventChoice);
	if(pkEventInfo == NULL)
	{
		return "";
	}

	CvString strOverrideText = GetLocalizedText(pkEventInfo->getDisabledTooltip());
	if(strOverrideText != "")
	{
		return strOverrideText.c_str();
	}

	//Lua Hook
	if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_EventChoiceCanTake, GetID(), eChosenEventChoice) == GAMEEVENTRETURN_FALSE) 
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_DISABLED_LUA");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->isOneShot() && IsEventChoiceFired(eChosenEventChoice))
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_ONESHOT");
		DisabledTT += localizedDurationText.toUTF8();
	}

	//Event Choice already active for this event? Abort!
	if(GetEventChoiceDuration(eChosenEventChoice) > 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_ACTIVE");
		DisabledTT += localizedDurationText.toUTF8();
	}

	//Let's narrow down all events here!
	if(pkEventInfo->getPrereqTech() != -1 && !GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_TECH");
		localizedDurationText << GC.getTechInfo((TechTypes)pkEventInfo->getPrereqTech())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->getObsoleteTech() != -1 && GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getObsoleteTech()))
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_OBSOLETE_TECH");
		localizedDurationText << GC.getTechInfo((TechTypes)pkEventInfo->getObsoleteTech())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->getRequiredEra() != -1 && GetCurrentEra() < (EraTypes)pkEventInfo->getRequiredEra())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ERA");
		localizedDurationText << GC.getEraInfo((EraTypes)pkEventInfo->getRequiredEra())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->getObsoleteEra() != -1 && GetCurrentEra() >= (EraTypes)pkEventInfo->getObsoleteEra())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_OBSOLETE_ERA");
		localizedDurationText << GC.getEraInfo((EraTypes)pkEventInfo->getObsoleteEra())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->getMinimumNationalPopulation() > 0 && getTotalPopulation() < pkEventInfo->getMinimumNationalPopulation())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_POP_NATIONAL");
		localizedDurationText << pkEventInfo->getMinimumNationalPopulation();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->getMinimumNumberCities() > 0 && getNumCities() < pkEventInfo->getMinimumNumberCities())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_CITIES");
		localizedDurationText << pkEventInfo->getMinimumNumberCities();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->getRequiredCiv() != -1 && getCivilizationType() != (CivilizationTypes)pkEventInfo->getRequiredCiv())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_CIV");
		localizedDurationText << GC.getCivilizationInfo((CivilizationTypes)pkEventInfo->getRequiredCiv())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->getRequiredPolicy() != -1 && !GetPlayerPolicies()->HasPolicy((PolicyTypes)pkEventInfo->getRequiredPolicy()))
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_POLICY");
		localizedDurationText << GC.getPolicyInfo((PolicyTypes)pkEventInfo->getRequiredPolicy())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->getRequiredIdeology() != -1 && GetPlayerPolicies()->GetLateGamePolicyTree() != (PolicyBranchTypes)pkEventInfo->getRequiredIdeology())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_IDEOLOGY");
		localizedDurationText << GC.getPolicyBranchInfo((PolicyBranchTypes)pkEventInfo->getRequiredIdeology())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->hasStateReligion() && GetReligions()->GetStateReligion() == NO_RELIGION)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ANY_STATE_RELIGION");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->hasPantheon() && GetReligions()->GetReligionCreatedByPlayer(true) != RELIGION_PANTHEON)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ANY_PANTHEON");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->isUnhappy() && !IsEmpireUnhappy())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_UNHAPPY");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->isSuperUnhappy() && !IsEmpireSuperUnhappy())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_SUPER_UNHAPPY");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->isRequiresIdeology() && GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ANY_IDEOLOGY");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->isRequiresWar() && GetMilitaryAI()->GetNumberCivsAtWarWith(false) <= 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_WAR_MAJOR");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->getRequiredStateReligion() != -1)
	{
		if(GetReligions()->GetStateReligion() != pkEventInfo->getRequiredStateReligion())
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_SPECIFIC_STATE_RELIGION");
			localizedDurationText << GC.getReligionInfo((ReligionTypes)pkEventInfo->getRequiredStateReligion())->GetDescription();
			DisabledTT += localizedDurationText.toUTF8();
		}
	}

	if(!pkEventInfo->isRequiresHolyCity() && pkEventInfo->getRequiredReligion() != -1)
	{
		if((GetReligions()->GetCurrentReligion(false) != (ReligionTypes)pkEventInfo->getRequiredReligion()) && (GetReligions()->GetReligionInMostCities() != (ReligionTypes)pkEventInfo->getRequiredReligion()))
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_SPECIFIC_RELIGION");
			localizedDurationText << GC.getReligionInfo((ReligionTypes)pkEventInfo->getRequiredReligion())->GetDescription();
			DisabledTT += localizedDurationText.toUTF8();
		}
	}

	//Let's do our linker checks here.
	for(int iI = 0; iI <= pkEventInfo->GetNumLinkers(); iI++)
	{
		CvEventChoiceLinkingInfo *pLinkerInfo = pkEventInfo->GetLinkerInfo(iI);
		if(pLinkerInfo)
		{
			EventTypes eLinkerEvent = (EventTypes)pLinkerInfo->GetLinkingEvent();
			EventChoiceTypes eLinkerEventChoice = (EventChoiceTypes)pLinkerInfo->GetLinkingEventChoice();
			CityEventTypes eLinkerCityEvent = (CityEventTypes)pLinkerInfo->GetCityLinkingEvent();
			CityEventChoiceTypes eLinkerCityEventChoice = (CityEventChoiceTypes)pLinkerInfo->GetCityLinkingEventChoice();

			PlayerTypes ePlayer;

			bool bEventFound = false;
			bool bEventChoiceFound = false;
			bool bCityEventFound = false;
			bool bCityEventChoiceFound = false;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				ePlayer = (PlayerTypes) iPlayerLoop;
				if(ePlayer == NO_PLAYER)
					continue;

				if(!pLinkerInfo->CheckOtherPlayers() && ePlayer != GetID())
					continue;

				if(eLinkerEvent != NO_EVENT && !bEventFound)
				{
					bool bActive = (GetEventCooldown(eLinkerEvent) > 0 || IsEventFired(eLinkerEvent));
					if(bActive != pLinkerInfo->CheckForActive())
					{
						if(bActive)
						{
							if(pLinkerInfo->CheckOtherPlayers())
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_EVENT_ACTIVE");
							}
							else
							{	
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ACTIVE_EVENT");
							}
						}
						else
						{
							if(pLinkerInfo->CheckOtherPlayers())
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_EVENT_NO_ACTIVE");
							}
							else
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NO_ACTIVE_PLAYER_EVENT");
								
							}
						}
						localizedDurationText << GC.getEventInfo(eLinkerEvent)->GetDescription();
						DisabledTT += localizedDurationText.toUTF8();
						bEventFound = true;
					}
				}

				if(eLinkerEventChoice != NO_EVENT_CHOICE && !bEventChoiceFound)
				{
					bool bActive = (GetEventChoiceDuration(eLinkerEventChoice) > 0 || IsEventChoiceFired(eLinkerEventChoice));
					if(bActive != pLinkerInfo->CheckForActive())
					{
						if(bActive)
						{
							if(pLinkerInfo->CheckOtherPlayers())
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_EVENT_CHOICE_ACTIVE");

							}
							else
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ACTIVE_EVENT_CHOICE");
							}
						}
						else
						{
							if(pLinkerInfo->CheckOtherPlayers())
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_NO_EVENT_CHOICE_ACTIVE");
							}
							else
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NO_ACTIVE_PLAYER_EVENT_CHOICE");
							}
						}
						localizedDurationText << GC.getEventChoiceInfo(eLinkerEventChoice)->GetDescription();
						DisabledTT += localizedDurationText.toUTF8();
						bEventChoiceFound = true;
						break;
					}
				}

				if(eLinkerCityEvent != NO_EVENT_CITY || eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
				{
					int iLoop;
					CvCity* pLoopCity;
					for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))
					{
						if(eLinkerCityEvent != NO_EVENT_CITY && !bCityEventFound)
						{
							bool bActive = (pLoopCity->GetEventCooldown(eLinkerCityEvent) > 0 || pLoopCity->IsEventFired(eLinkerCityEvent));
							if(bActive != pLinkerInfo->CheckForActive())
							{
								if(bActive)
								{
									if(pLinkerInfo->CheckOtherPlayers())
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_CITY_EVENT_ACTIVE");
									}
									else
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ACTIVE_CITY_EVENT");
									}
								}
								else
								{
									if(pLinkerInfo->CheckOtherPlayers())
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_NO_CITY_EVENT_ACTIVE");
									}
									else
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NO_ACTIVE_CITY_EVENT");
									}
								}
								localizedDurationText << GC.getCityEventInfo(eLinkerCityEvent)->GetDescription();
								DisabledTT += localizedDurationText.toUTF8();
								bCityEventFound = true;
								break;
							}
						}

						if(!bCityEventChoiceFound && eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
						{
							bool bActive = (pLoopCity->GetEventChoiceDuration(eLinkerCityEventChoice) > 0 || pLoopCity->IsEventChoiceFired(eLinkerCityEventChoice));
							if(bActive != pLinkerInfo->CheckForActive())
							{
								if(bActive)
								{
									if(pLinkerInfo->CheckOtherPlayers())
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_CITY_EVENT_CHOICE_ACTIVE");
									}
									else
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ACTIVE_CITY_EVENT_CHOICE");
									}
								}
								else
								{
									if(pLinkerInfo->CheckOtherPlayers())
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_CITY_EVENT_CHOICE_NO_ACTIVE");
									}
									else
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NO_ACTIVE_CITY_EVENT_CHOICE");
									}
								}
								localizedDurationText << GC.getCityEventChoiceInfo(eLinkerCityEventChoice)->GetDescription();
								DisabledTT += localizedDurationText.toUTF8();
								bCityEventChoiceFound = true;
								break;
							}
						}
					}
				}
			}
		}
	}

	if(pkEventInfo->hasMetAnotherCiv())
	{
		if(GET_TEAM(getTeam()).getHasMetCivCount(true) <= 0)
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_MET_OTHER_CIV");
			DisabledTT += localizedDurationText.toUTF8();
		}
	}

	if(MOD_DIPLOMACY_CIV4_FEATURES && pkEventInfo->isMaster() && GET_TEAM(getTeam()).GetNumVassals() <= 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_VASSAL");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(MOD_DIPLOMACY_CIV4_FEATURES && pkEventInfo->isVassal() && !GET_TEAM(getTeam()).IsVassalOfSomeone())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_BE_VASSAL");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->isTradeCapped() && GetTrade()->GetNumTradeUnitsRemaining(true) <= 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_TRADE_SLOT");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->getUnitTypeRequired() != -1)
	{
		bool bHas = false;
		CvUnit* pLoopUnit;
		int iLoop;
		for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		{
			if(pLoopUnit != NULL && pLoopUnit->getUnitClassType() == (UnitClassTypes)pkEventInfo->getUnitTypeRequired())
			{
				bHas = true;
				break;
			}
		}
		if(!bHas)
		{
			CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());

			if (pCivilizationInfo != NULL)
			{
				UnitTypes eUnitType = (UnitTypes)pCivilizationInfo->getCivilizationUnits((UnitClassTypes)pkEventInfo->getUnitTypeRequired());
				if (eUnitType != NO_UNIT)
				{
					localizedDurationText = Localization::Lookup("TXT_KEY_NEED_UNITCLASS_TYPE");
					localizedDurationText << GC.getUnitInfo(eUnitType)->GetDescription();
					DisabledTT += localizedDurationText.toUTF8();
				}
			}
		}
	}


	if(pkEventInfo->isRequiresHolyCity())
	{
		bool bHas = false;
		bool bSpecific = false;
		CvCity* pCity = NULL;
		int iLoop;
		for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
		{
			if(pkEventInfo->getRequiredReligion() != -1)
			{
				if(pCity != NULL && pCity->GetCityReligions()->IsHolyCityForReligion((ReligionTypes)pkEventInfo->getRequiredReligion()))
				{
					bHas = true;
					bSpecific = true;
					break;
				}
			}
			else
			{
				if(pCity != NULL && pCity->GetCityReligions()->IsHolyCityAnyReligion())
				{
					bHas = true;
					break;
				}
			}
		}
		if(!bHas && !bSpecific)
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_HOLY_CITY");
			DisabledTT += localizedDurationText.toUTF8();
		}
		if(!bHas && bSpecific)
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_HOLY_CITY_SPECIFIC");
			DisabledTT += localizedDurationText.toUTF8();
		}
	}
	if(pkEventInfo->getNumCoastalRequired() > 0)
	{
		bool bHas = false;
		CvCity* pCity = NULL;
		int iLoop;
		int iNumCoastal = 0;
		for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
		{
			if(pCity != NULL && pCity->isCoastal())
			{
				iNumCoastal++;
			}
			if(iNumCoastal >= pkEventInfo->getNumCoastalRequired())
			{
				bHas = true;
				break;
			}
		}
		if(!bHas)
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_COASTAL_CITIES");
			localizedDurationText << pkEventInfo->getNumCoastalRequired();
			DisabledTT += localizedDurationText.toUTF8();
		}
	}

	if(pkEventInfo->isRequiresWarMinor())
	{
		bool bHas = false;
		for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			// Is this a player we have relations with?
			if(GET_PLAYER(eLoopPlayer).isBarbarian())
			{
				continue;
			}
			if(!GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				continue;
			}
			if(eLoopPlayer != GetID())
			{
				if(GET_TEAM(getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
				{
					bHas = true;
					break;
				}
			}
		}
		if(!bHas)
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_WAR_MINOR");
			DisabledTT += localizedDurationText.toUTF8();
		}
	}
	for(int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
	{
		const ResourceTypes eResource = static_cast<ResourceTypes>(iJ);
		CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
		if(pkResource)
		{
			if(pkEventInfo->getResourceRequired(eResource) > 0)
			{
				if(getNumResourceTotal(eResource, false) < pkEventInfo->getResourceRequired(eResource))
				{
					localizedDurationText = Localization::Lookup("TXT_KEY_NEED_RESOURCE");
					localizedDurationText << pkResource->GetDescription();
					DisabledTT += localizedDurationText.toUTF8();
				}
			}
		}
	}
	bool bHas = true;
	for(int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
	{
		const FeatureTypes eFeature = static_cast<FeatureTypes>(iJ);
		CvFeatureInfo* pkFeature = GC.getFeatureInfo(eFeature);
		if(pkFeature)
		{
			if(pkEventInfo->getFeatureRequired(eFeature) > 0)
			{
				CvCity* pCity = NULL;
				int iLoop;
				int iNeeded = pkEventInfo->getFeatureRequired(eFeature);
				int iHave = 0;
				for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
				{

					if(pCity != NULL && pCity->HasFeature(eFeature))
					{
						iHave++;
					}
				}
				if(iHave < iNeeded)
				{
					localizedDurationText = Localization::Lookup("TXT_KEY_NEED_FEATURE");
					localizedDurationText << pkFeature->GetDescription();
					DisabledTT += localizedDurationText.toUTF8();
				}
			}
		}
	}
	if(pkEventInfo->getBuildingRequired() != -1)
	{
		BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventInfo->getBuildingRequired();
		if(eBuildingClass != NO_BUILDINGCLASS)
		{
			bool bHas = false;
			CvCity* pCity = NULL;
			int iLoop;
			for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
			{
				if(pCity != NULL && pCity->GetCityBuildings()->GetNumBuildingClass(eBuildingClass) > 0)
				{
					bHas = true;
					break;
				}
			}
			if(!bHas)
			{
				CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());

				if (pCivilizationInfo != NULL)
				{
					BuildingTypes eBuildingType = (BuildingTypes)pCivilizationInfo->getCivilizationBuildings((BuildingClassTypes)pkEventInfo->getBuildingRequired());
					if (eBuildingType != NO_BUILDING)
					{
						localizedDurationText = Localization::Lookup("TXT_KEY_NEED_BUILDING_CLASS");
						localizedDurationText << GC.getBuildingInfo(eBuildingType)->GetDescription();
						DisabledTT += localizedDurationText.toUTF8();
					}
				}
			}
		}
	}
	if(pkEventInfo->getBuildingLimiter() != -1)
	{
		BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventInfo->getBuildingLimiter();
		if(eBuildingClass != NO_BUILDINGCLASS)
		{
			bool bHas = false;
			CvCity* pCity = NULL;
			int iLoop;
			for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
			{
				if(pCity != NULL && pCity->GetCityBuildings()->GetNumBuildingClass(eBuildingClass) > 0)
				{
					bHas = true;
					break;
				}
			}
			if(bHas)
			{
				CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());

				if (pCivilizationInfo != NULL)
				{
					BuildingTypes eBuildingType = (BuildingTypes)pCivilizationInfo->getCivilizationBuildings((BuildingClassTypes)pkEventInfo->getBuildingLimiter());
					if (eBuildingType != NO_BUILDING)
					{
						localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NO_BUILDING_CLASS");
						localizedDurationText << GC.getBuildingInfo(eBuildingType)->GetDescription();
						DisabledTT += localizedDurationText.toUTF8();
					}
				}
			}
		}
	}
	if(pkEventInfo->getRequiredImprovement() != -1)
	{
		ImprovementTypes eImprovement = (ImprovementTypes)pkEventInfo->getRequiredImprovement();
		if(eImprovement != NO_IMPROVEMENT)
		{
			bool bHas = false;
			// go through all the plots the player has under their control
			for (PlotIndexContainer::const_iterator it = m_aiPlots.begin(); it != m_aiPlots.end(); ++it)
			{
				CvPlot* pPlot = GC.getMap().plotByIndex(*it);
				if (!pPlot)
				{
					continue;
				}

				if(pPlot->getOwner() == GetID() && pPlot->getImprovementType() == eImprovement)
				{
					bHas = true;
					break;
				}
			}
			if(!bHas)
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_NEED_IMPROVEMENT");
				localizedDurationText << GC.getImprovementInfo((ImprovementTypes)pkEventInfo->getRequiredImprovement())->GetDescription();
				DisabledTT += localizedDurationText.toUTF8();
			}
		}
	}
	//Check our minimum yields - this looks at stored values, not yields per turn.
	bHas = true;
	for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes)iI;
		if(eYield == NO_YIELD)
			continue;
							
		int iNeededYield = pkEventInfo->getYieldMinimum(eYield);
		if(pkEventInfo->getPreCheckEventYield(eYield) != 0)
		{
			if(iNeededYield < pkEventInfo->getPreCheckEventYield(eYield))
			{
				iNeededYield = pkEventInfo->getPreCheckEventYield(eYield);
			}
		}
		iNeededYield *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
		iNeededYield /= 100;
		if(pkEventInfo->IsEraScaling())
		{
			int iEra = GetCurrentEra();
			if(iEra <= 0)
			{
				iEra = 1;
			}
			iNeededYield *= iEra;
		}
		if(iNeededYield != 0)
		{
			if(eYield == YIELD_GOLD)
			{
				if(iNeededYield > GetTreasury()->GetGold())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_SCIENCE)
			{
				TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
				int iTech = 0;
				if(eCurrentTech != NO_TECH)
				{
					iTech = GetPlayerTechs()->GetResearchProgress(eCurrentTech);
				}
				if(iNeededYield > iTech)
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_FAITH)
			{
				if(iNeededYield > GetFaith())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_GOLDEN_AGE_POINTS)
			{
				if(iNeededYield > GetGoldenAgeProgressMeter())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_CULTURE)
			{
				if(iNeededYield > getJONSCulture())
				{
					bHas = false;
					break;
				}
			}
		}
	}
	if(!bHas)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_YIELDS");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->isInDebt() && GetTreasury()->GetGold() > 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_DEBT");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->isLosingMoney() && GetTreasury()->CalculateBaseNetGold() > 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NEGATIVE_GPT");
		DisabledTT += localizedDurationText.toUTF8();
	}

	return DisabledTT.c_str();
}
//Let's look for global events that affect a city being built/captured.
void CvPlayer::CheckActivePlayerEvents(CvCity* pCity)
{
	if(pCity == NULL)
		return;

	//Event Choice Duration First - if we're in one, let's do the countdown now.
	//We need to do this first so we can cancel the event(s).
	for(int iLoop = 0; iLoop < GC.getNumEventChoiceInfos(); iLoop++)
	{
		EventChoiceTypes eEventChoice = (EventChoiceTypes)iLoop;
		if(eEventChoice != NO_EVENT_CHOICE)
		{
			if(GetEventChoiceDuration(eEventChoice) > 0 || IsEventChoiceFired(eEventChoice))
			{
				DoEventSyncChoices(eEventChoice, pCity);
			}
		}
	}
}
//Let's grab all the global events that affect cities.
void CvPlayer::DoEventSyncChoices(EventChoiceTypes eEventChoice, CvCity* pCity)
{
	if(eEventChoice != NO_EVENT_CHOICE)
	{
		CvModEventChoiceInfo* pkEventChoiceInfo = GC.getEventChoiceInfo(eEventChoice);
		if(pkEventChoiceInfo != NULL)
		{
			if(pkEventChoiceInfo->getEventChance() <= 0)
			{
				if(pkEventChoiceInfo->getEventBuilding() != -1)
				{
					BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventChoiceInfo->getEventBuilding();
					if(eBuildingClass != NO_BUILDINGCLASS)
					{
						const CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
	
						if (pkBuildingClassInfo)
						{
							CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
		
							if (pCivilizationInfo != NULL)
							{
								BuildingTypes eBuildingType = (BuildingTypes) pCivilizationInfo->getCivilizationBuildings(eBuildingClass);
								if(eBuildingType != NO_BUILDING)
								{
									CvCity *pLoopCity;
									int iLoop;
									for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
									{
										if(pLoopCity != pCity)
											continue;

										if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
										{
											continue;
										}

										if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
										{
											continue;
										}

										pLoopCity->GetCityBuildings()->SetNumRealBuilding(eBuildingType, 1);
									}
								}
							}
						}
					}
				}
				for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
				{
					YieldTypes eYield = (YieldTypes)iI;
					if(eYield == NO_YIELD)
						continue;
					int iYieldChange = pkEventChoiceInfo->getCityYield(eYield);
					if(iYieldChange != 0)
					{
						if(pkEventChoiceInfo->IsEraScaling())
						{
							int iEra = GetCurrentEra();
							if(iEra <= 0)
							{
								iEra = 1;
							}
							iYieldChange *= iEra;
						}
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pLoopCity != pCity)
								continue;

							if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
							{
								continue;
							}
							if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
							{
								continue;
							}
							pLoopCity->ChangeEventCityYield(eYield, iYieldChange);
						}
					}
					// Building modifiers
					for(int iJ = 0; iJ < GC.getNumBuildingClassInfos(); iJ++)
					{
						BuildingClassTypes eBuildingClass = (BuildingClassTypes) iJ;

						CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
						if(!pkBuildingClassInfo)
						{
							continue;
						}
						if(pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield) != 0)
						{
							BuildingTypes eBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

							if(eBuilding != NO_BUILDING)
							{
								CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
								if(pkBuilding)
								{
									CvCity *pLoopCity;
									int iLoop;
									for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
									{
										if(pLoopCity != pCity)
											continue;

										if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
										{
											continue;
										}
										if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
										{
											continue;
										}
										int iBuildingCount = pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding);

										pLoopCity->ChangeEventBuildingClassYield(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield));
										if(iBuildingCount > 0)
										{
											pLoopCity->ChangeBaseYieldRateFromBuildings(eYield, pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield));
										}
									}
								}
							}
						}
						if(pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield) != 0)
						{
							BuildingTypes eBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

							if(eBuilding != NO_BUILDING)
							{
								CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
								if(pkBuilding)
								{
									CvCity *pLoopCity;
									int iLoop;
									for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
									{
										if(pLoopCity != pCity)
											continue;

										if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
										{
											continue;
										}
										if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
										{
											continue;
										}
										int iBuildingCount = pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding);

										pLoopCity->ChangeEventBuildingClassYieldModifier(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield));
										if(iBuildingCount > 0)
										{
											pLoopCity->changeYieldRateModifier(eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield));
										}
									}
								}
							}
						}
					}
					for(int iJ = 0; iJ < GC.getNumImprovementInfos(); iJ++)
					{
						ImprovementTypes eImprovement = (ImprovementTypes)iJ;
						if(eImprovement != NO_IMPROVEMENT && pkEventChoiceInfo->getImprovementYield(eImprovement, eYield) != 0)
						{
							CvCity *pLoopCity;
							int iLoop;
							for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								if(pLoopCity != pCity)
									continue;

								if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
								{
									continue;
								}
								if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
								{
									continue;
								}
								pLoopCity->ChangeEventImprovementYield(eImprovement, eYield, pkEventChoiceInfo->getImprovementYield(eImprovement, eYield));
							}
						}
					}
					for(int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
					{
						FeatureTypes eFeature = (FeatureTypes)iJ;
						if(eFeature != NO_FEATURE && pkEventChoiceInfo->getFeatureYield(eFeature, eYield) != 0)
						{
							CvCity *pLoopCity;
							int iLoop;
							for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								if(pLoopCity != pCity)
									continue;

								if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
								{
									continue;
								}
								if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
								{
									continue;
								}
								pLoopCity->ChangeEventFeatureYield(eFeature, eYield, pkEventChoiceInfo->getFeatureYield(eFeature, eYield));
							}
						}
					}
					for(int iJ = 0; iJ < GC.getNumTerrainInfos(); iJ++)
					{
						TerrainTypes eTerrain = (TerrainTypes)iJ;
						if(eTerrain != NO_TERRAIN && pkEventChoiceInfo->getTerrainYield(eTerrain, eYield) != 0)
						{
							CvCity *pLoopCity;
							int iLoop;
							for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								if(pLoopCity != pCity)
									continue;

								if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
								{
									continue;
								}
								if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
								{
									continue;
								}
								pLoopCity->ChangeEventTerrainYield(eTerrain, eYield, pkEventChoiceInfo->getTerrainYield(eTerrain, eYield));
							}
						}
					}
					for(int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
					{
						ResourceTypes eResource = (ResourceTypes)iJ;
						if(eResource != NO_RESOURCE && pkEventChoiceInfo->getResourceYield(eResource, eYield) != 0)
						{
							CvCity *pLoopCity;
							int iLoop;
							for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								if(pLoopCity != pCity)
									continue;

								if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
								{
									continue;
								}
								if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
								{
									continue;
								}
								pLoopCity->ChangeEventResourceYield(eResource, eYield, pkEventChoiceInfo->getResourceYield(eResource, eYield));
							}
						}
					}
					for(int iJ = 0; iJ < GC.getNumSpecialistInfos(); iJ++)
					{
						const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iJ);
						CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
						if(pkSpecialistInfo)
						{
							CvCity *pLoopCity;
							int iLoop;
							for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								if(pLoopCity != pCity)
									continue;

								if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
								{
									continue;
								}
								if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
								{
									continue;
								}
								pLoopCity->ChangeEventSpecialistYield(eSpecialist, eYield, pkEventChoiceInfo->getGlobalSpecialistYieldChange(eSpecialist, eYield));
							}
						}
					}
				}
				if(pkEventChoiceInfo->getCityHappinessGlobal() != 0)
				{
					CvCity *pLoopCity;
					int iLoop;
					for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if(pLoopCity != pCity)
							continue;

						if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
						{
							continue;
						}
						if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
						{
							continue;
						}
						pLoopCity->ChangeEventHappiness(pkEventChoiceInfo->getCityHappinessGlobal());
					}
				}
				CvCity* pLoopCity;
				int iLoop;
				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if(pLoopCity != NULL)
					{
						if(pLoopCity != pCity)
							continue;

						if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
						{
							continue;
						}
						if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
						{
							continue;
						}
						for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
						{
							YieldTypes eYield = (YieldTypes) iI;
							if(eYield == NO_YIELD)
								continue;

							pLoopCity->UpdateSpecialReligionYields(eYield);
							pLoopCity->UpdateCityYields(eYield);
						}
						pLoopCity->UpdateReligion(pLoopCity->GetCityReligions()->GetReligiousMajority());
						CalculateNetHappiness();
						pLoopCity->GetCityCulture()->CalculateBaseTourismBeforeModifiers();
						pLoopCity->GetCityCulture()->CalculateBaseTourism();
					}
				}
			}
		}
	}
}
void CvPlayer::DoEventChoice(EventChoiceTypes eEventChoice, EventTypes eEvent, bool bSendMsg)
{
	if (GC.getGame().isNetworkMultiPlayer() && bSendMsg && isHuman()) {
		NetMessageExt::Send::DoEventChoice(GetID(), eEventChoice, eEvent);
		return;
	}
	if(eEventChoice != NO_EVENT_CHOICE)
	{
		CvModEventChoiceInfo* pkEventChoiceInfo = GC.getEventChoiceInfo(eEventChoice);
		if(pkEventChoiceInfo != NULL)
		{
			//Set oneshot stuff so this event can't fire ever again.
			if(pkEventChoiceInfo->isOneShot())
			{
				SetEventChoiceFired(eEventChoice, true);
			}
			//Set false so we know we've completed the city event.
			//Loop through all city events and set any related to this to false, just to be sure.
			//This is purely for the notification system to keep the icon from disappearing until a choice has been made.
			if(eEvent == NO_EVENT)
			{
				for(int iLoop = 0; iLoop < GC.getNumEventInfos(); iLoop++)
				{
					EventTypes eEvent = (EventTypes)iLoop;
					if(eEvent != NO_EVENT)
					{
						if(pkEventChoiceInfo->isParentEvent(eEvent))
						{
							SetEventActive(eEvent, false);
						}
					}
				}
			}
			else
			{
				SetEventActive(eEvent, false);
			}

			if(GC.getLogging())
			{
				CvString playerName;
				FILogFile* pLog;
				CvString strBaseString;
				CvString strOutBuf;
				CvString strFileName = "EventLogging.csv";
				playerName = getCivilizationShortDescription();
				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				strBaseString += playerName + ", ";
				strOutBuf.Format("Event choice chosen by player: %s", pkEventChoiceInfo->GetDescription());
				strBaseString += strOutBuf;
				pLog->Msg(strBaseString);
			}
			//Set the cooldown for all events.
			if(pkEventChoiceInfo->getEventDuration() > 0)
			{
				//Gamespeed.
				int iEventDuration = pkEventChoiceInfo->getEventDuration();
				iEventDuration *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iEventDuration /= 100;
				ChangeEventChoiceDuration(eEventChoice, iEventDuration);
			}

			//Lua Hook
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_EventChoiceActivated, GetID(), eEventChoice);

			//Do the cost first, as that goes through whether or not the event succeeds!
			for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				YieldTypes eYield = (YieldTypes)iI;
				if(eYield == NO_YIELD)
					continue;
							
				int iPassYield = pkEventChoiceInfo->getPreCheckEventYield(eYield);
				if(iPassYield != 0)
				{
					iPassYield *= -1;
					CvCity* pCity = getCapitalCity();
					if(pCity != NULL)
					{
						doInstantYield(INSTANT_YIELD_TYPE_INSTANT, false, NO_GREATPERSON, NO_BUILDING, iPassYield, pkEventChoiceInfo->IsEraScaling(), NO_PLAYER, NULL, true, pCity, false, true, true, eYield);
					}
				}
			}
			//Let's see if it even happens.
			if(pkEventChoiceInfo->getEventChance() > 0)
			{
				int iRandom = GC.getGame().getJonRandNum(100, "Random Event Chance");
				int iLimit = pkEventChoiceInfo->getEventChance();
				if(iRandom < iLimit)
				{
					//Notify if it did not work.
					CvNotifications* pNotifications = GetNotifications();
					if(pNotifications && GC.getGame().getActivePlayer() == GetID())
					{
						for(int iLoop = 0; iLoop < GC.getNumCityEventInfos(); iLoop++)
						{
							EventTypes eEvent = (EventTypes)iLoop;
							if(eEvent != NO_EVENT)
							{
								if(pkEventChoiceInfo->isParentEvent(eEvent))
								{
									CvModEventInfo* pkEventInfo = GC.getEventInfo(eEvent);
									if(pkEventInfo != NULL)
									{
										Localization::String strMessage;
										Localization::String strSummary;
										strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_EVENT_FAILED");
										strMessage << pkEventChoiceInfo->GetDescription();
										strMessage << GetScaledHelpText(eEventChoice, false);
										strMessage << pkEventInfo->GetDescription();
										strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_EVENT_FAILED_T");
										strSummary << pkEventInfo->GetDescription();

										pNotifications->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, -1, GetID());
										break;
									}
								}
							}
						}
					}
					return;
				}
			}
			//Succeeded? Set event choice active here so we know to deduct it later.
			SetEventChoiceActive(eEventChoice, true);

			//Now on to the actions themselves.
			if (pkEventChoiceInfo->getEventPolicy() != -1)
			{
				PolicyTypes ePolicy = (PolicyTypes)pkEventChoiceInfo->getEventPolicy();
				if(ePolicy != -1)
				{
					setHasPolicy(ePolicy, true, true);
				}
			}
			if(pkEventChoiceInfo->getEventTech() != -1)
			{
				TechTypes eTech = (TechTypes)pkEventChoiceInfo->getEventTech();
				if(eTech != -1)
				{
					GET_TEAM(getTeam()).GetTeamTechs()->SetHasTech(eTech, true);
				}
			}
			if(pkEventChoiceInfo->getEventBuilding() != -1)
			{
				BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventChoiceInfo->getEventBuilding();
				if(eBuildingClass != NO_BUILDINGCLASS)
				{
					const CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
	
					if (pkBuildingClassInfo)
					{
						CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
		
						if (pCivilizationInfo != NULL)
						{
							BuildingTypes eBuildingType = (BuildingTypes) pCivilizationInfo->getCivilizationBuildings(eBuildingClass);
							if(eBuildingType != NO_BUILDING)
							{
								CvCity *pLoopCity;
								int iLoop;
								for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
								{
									if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
									{
										continue;
									}

									if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
									{
										continue;
									}

									pLoopCity->GetCityBuildings()->SetNumRealBuilding(eBuildingType, 1, true);
								}
							}
						}
					}
				}
			}
			if(pkEventChoiceInfo->getEventPromotion() != -1)
			{
				PromotionTypes ePromotion = (PromotionTypes)pkEventChoiceInfo->getEventPromotion();
				if(ePromotion != -1)
				{
					CvUnit* pLoopUnit;
					int iLoop;
					for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
					{
						if(pLoopUnit->getUnitType() != NO_UNIT)
						{
							if(::IsPromotionValidForUnitCombatType(ePromotion, pLoopUnit->getUnitType()))
							{
								if(pLoopUnit->HasPromotion(ePromotion))
								{
#if defined(MOD_UNITS_XP_TIMES_100)
									pLoopUnit->changeExperienceTimes100(15 * 100);
#else
									pLoopUnit->changeExperience(15);
#endif
								}
								else
								{
									pLoopUnit->setHasPromotion(ePromotion, true);
								}
							}
						}
					}
					ChangeFreePromotionCount(ePromotion, 1);
				}
			}
			for(int iI = 0; iI < GC.getNumResourceInfos(); iI++)
			{
				ResourceTypes eResource = (ResourceTypes)iI;
				if(eResource != NO_RESOURCE)
				{
					int iBonus = pkEventChoiceInfo->getEventResourceChange(eResource);
					if(iBonus != 0)
					{
						changeNumResourceTotal(eResource, iBonus);
					}
				}
			}
			for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				YieldTypes eYield = (YieldTypes)iI;
				if(eYield == NO_YIELD)
					continue;

				if(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS)
				{
					int iUnhappinessNeedMod = pkEventChoiceInfo->getCityUnhappinessNeedMod(eYield);
					if(iUnhappinessNeedMod != 0)
					{
						if(eYield == YIELD_GOLD)
						{
							ChangePovertyUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_CULTURE)
						{
							ChangeUnculturedUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_PRODUCTION)
						{
							ChangeDefenseUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_SCIENCE)
						{
							ChangeIlliteracyUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_FAITH)
						{
							ChangeMinorityUnhappinessGlobal(iUnhappinessNeedMod);
						}
					}
				}

				int iYieldChange = pkEventChoiceInfo->getCityYield(eYield);
				if(iYieldChange != 0)
				{
					if(pkEventChoiceInfo->IsEraScaling())
					{
						int iEra = GetCurrentEra();
						if(iEra <= 0)
						{
							iEra = 1;
						}
						iYieldChange *= iEra;
					}
					CvCity *pLoopCity;
					int iLoop;
					for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
						{
							continue;
						}
						if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
						{
							continue;
						}
						pLoopCity->ChangeEventCityYield(eYield, iYieldChange);
					}
				}
				// Building modifiers
				for(int iJ = 0; iJ < GC.getNumBuildingClassInfos(); iJ++)
				{
					BuildingClassTypes eBuildingClass = (BuildingClassTypes) iJ;

					CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
					if(!pkBuildingClassInfo)
					{
						continue;
					}
					if(pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield) != 0)
					{
						BuildingTypes eBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

						if(eBuilding != NO_BUILDING)
						{
							CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
							if(pkBuilding)
							{
								CvCity *pLoopCity;
								int iLoop;
								for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
								{
									if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
									{
										continue;
									}
									if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
									{
										continue;
									}
									int iBuildingCount = pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding);

									pLoopCity->ChangeEventBuildingClassYield(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield));
									if(iBuildingCount > 0)
									{
										pLoopCity->ChangeBaseYieldRateFromBuildings(eYield, pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield));
									}
								}
							}
						}
					}
					if(pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield) != 0)
					{
						BuildingTypes eBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

						if(eBuilding != NO_BUILDING)
						{
							CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
							if(pkBuilding)
							{
								CvCity *pLoopCity;
								int iLoop;
								for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
								{
									if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
									{
										continue;
									}
									if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
									{
										continue;
									}
									int iBuildingCount = pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding);

									pLoopCity->ChangeEventBuildingClassYieldModifier(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield));
									if(iBuildingCount > 0)
									{
										pLoopCity->changeYieldRateModifier(eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield));
									}
								}
							}
						}
					}
				}
							
				int iPassYield = pkEventChoiceInfo->getEventYield(eYield);
				if(iPassYield != 0)
				{
					CvCity *pLoopCity;
					int iLoop;
					for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if(!pkEventChoiceInfo->isInstantYieldAllCities() && !pLoopCity->isCapital())
							continue;

						doInstantYield(INSTANT_YIELD_TYPE_INSTANT, false, NO_GREATPERSON, NO_BUILDING, iPassYield, pkEventChoiceInfo->IsEraScaling(), NO_PLAYER, NULL, true, pLoopCity, false, true, true, eYield);
					}
				}
				for(int iJ = 0; iJ < GC.getNumImprovementInfos(); iJ++)
				{
					ImprovementTypes eImprovement = (ImprovementTypes)iJ;
					if(eImprovement != NO_IMPROVEMENT && pkEventChoiceInfo->getImprovementYield(eImprovement, eYield) != 0)
					{
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
							{
								continue;
							}
							if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
							{
								continue;
							}
							pLoopCity->ChangeEventImprovementYield(eImprovement, eYield, pkEventChoiceInfo->getImprovementYield(eImprovement, eYield));
						}
					}
				}
				for(int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
				{
					FeatureTypes eFeature = (FeatureTypes)iJ;
					if(eFeature != NO_FEATURE && pkEventChoiceInfo->getFeatureYield(eFeature, eYield) != 0)
					{
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
							{
								continue;
							}
							if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
							{
								continue;
							}
							pLoopCity->ChangeEventFeatureYield(eFeature, eYield, pkEventChoiceInfo->getFeatureYield(eFeature, eYield));
						}
					}
				}
				for(int iJ = 0; iJ < GC.getNumTerrainInfos(); iJ++)
				{
					TerrainTypes eTerrain = (TerrainTypes)iJ;
					if(eTerrain != NO_TERRAIN && pkEventChoiceInfo->getTerrainYield(eTerrain, eYield) != 0)
					{
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
							{
								continue;
							}
							if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
							{
								continue;
							}
							pLoopCity->ChangeEventTerrainYield(eTerrain, eYield, pkEventChoiceInfo->getTerrainYield(eTerrain, eYield));
						}
					}
				}
				for(int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
				{
					ResourceTypes eResource = (ResourceTypes)iJ;
					if(eResource != NO_RESOURCE && pkEventChoiceInfo->getResourceYield(eResource, eYield) != 0)
					{
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
							{
								continue;
							}
							if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
							{
								continue;
							}
							pLoopCity->ChangeEventResourceYield(eResource, eYield, pkEventChoiceInfo->getResourceYield(eResource, eYield));
						}
					}
				}
				for(int iJ = 0; iJ < GC.getNumSpecialistInfos(); iJ++)
				{
					const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iJ);
					CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
					if(pkSpecialistInfo)
					{
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
							{
								continue;
							}
							if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
							{
								continue;
							}
							pLoopCity->ChangeEventSpecialistYield(eSpecialist, eYield, pkEventChoiceInfo->getGlobalSpecialistYieldChange(eSpecialist, eYield));
						}
					}
				}
			}
			if(pkEventChoiceInfo->getGoldenAgeTurns() > 0)
			{
				int iTurns = pkEventChoiceInfo->getGoldenAgeTurns();
				iTurns *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iTurns /= 100;
				changeGoldenAgeTurns(max(1, iTurns), true);
			}
			if(pkEventChoiceInfo->getNumFreeGreatPeople() > 0)
			{
				ChangeNumFreeGreatPeople(pkEventChoiceInfo->getNumFreeGreatPeople());
			}
			if(pkEventChoiceInfo->getNumFreePolicies() > 0)
			{
				ChangeNumFreePolicies(pkEventChoiceInfo->getNumFreePolicies());
			}
			if(pkEventChoiceInfo->getNumFreeTechs() > 0)
			{
				SetNumFreeTechs(GetNumFreeTechs() + pkEventChoiceInfo->getNumFreeTechs());
			}
			if(pkEventChoiceInfo->getPlayerHappiness() != 0)
			{
				if(getCapitalCity() != NULL)
				{
					getCapitalCity()->ChangeEventHappiness(pkEventChoiceInfo->getPlayerHappiness());
				}
			}
			if(pkEventChoiceInfo->getCityHappinessGlobal() != 0)
			{
				CvCity *pLoopCity;
				int iLoop;
				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
					{
						continue;
					}
					if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
					{
						continue;
					}
					pLoopCity->ChangeEventHappiness(pkEventChoiceInfo->getCityHappinessGlobal());
				}
			}
			if(pkEventChoiceInfo->getRandomBarbs() > 0)
			{
				if (GC.getGame().isOption(GAMEOPTION_NO_BARBARIANS))
					return;
				
				// In hundreds
				int iNumRebels = pkEventChoiceInfo->getRandomBarbs();

				CvCity *pLoopCity;
				int iLoop;
				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					// Found a place to set up an uprising?
					if(pLoopCity != NULL)
					{
						if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
						{
							continue;
						}
						if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
						{
							continue;
						}
						GC.getGame().DoSpawnUnitsAroundTargetCity(BARBARIAN_PLAYER, pLoopCity, iNumRebels, false, false, false, false);
					}
				}
			}
			if(pkEventChoiceInfo->getFreeScaledUnits() > 0)
			{
				// In hundreds
				int iNumRecruits = pkEventChoiceInfo->getFreeScaledUnits();

				CvCity *pLoopCity;
				int iLoop;
				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					// Found a place to set up an uprising?
					if(pLoopCity != NULL)
					{
						if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
						{
							continue;
						}
						if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
						{
							continue;
						}

						GC.getGame().DoSpawnUnitsAroundTargetCity(GetID(), pLoopCity, iNumRecruits, false, pLoopCity->isCoastal(), false, true);
					}
				}
			}
			for(int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
			{
				const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
				CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
				if(pkUnitClassInfo)
				{
					if(pkEventChoiceInfo->getNumFreeUnits((UnitClassTypes)iI) <= 0)
						continue;

					CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
		
					if (pCivilizationInfo != NULL)
					{
						const UnitTypes eLoopUnit = (UnitTypes) pCivilizationInfo->getCivilizationUnits(iI);
						if(eLoopUnit != NO_UNIT)
						{
							CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eLoopUnit);
							if(pkUnitEntry)
							{
								CvCity *pLoopCity;
								int iLoop;
								for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
								{
									if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
									{
										continue;
									}
									if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
									{
										continue;
									}
									for(int iJ = 0; iJ < pkEventChoiceInfo->getNumFreeUnits((UnitClassTypes)iI); iJ++)
									{
										UnitAITypes eUnitAI = pkUnitEntry->GetDefaultUnitAIType();
										int iResult = pLoopCity->CreateUnit(eLoopUnit, eUnitAI, REASON_GIFT);

										CvAssertMsg(iResult != -1, "Unable to create unit");

										if (iResult != -1)
										{
											CvUnit* pUnit = getUnit(iResult);
											if (!pUnit->IsCivilianUnit() && !pUnit->jumpToNearestValidPlot())
											{
												pUnit->kill(false);	// Could not find a valid spot!
											}
											else
											{
												pUnit->finishMoves();
												//Lua Hook
												GAMEEVENTINVOKE_HOOK(GAMEEVENT_EventUnitCreated, GetID(), eEventChoice, pUnit);
											}
										}
									}
								}
							}
						}
					}
				}
			}
			for(int iI = 0; iI < GC.getNumUnitInfos(); iI++)
			{
				const UnitTypes eUnit = static_cast<UnitTypes>(iI);
				CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eUnit);
				if(pkUnitEntry)
				{
					if(pkEventChoiceInfo->getNumFreeSpecificUnits((UnitTypes)iI) <= 0)
						continue;
	
					for(int iJ = 0; iJ < pkEventChoiceInfo->getNumFreeSpecificUnits((UnitTypes)iI); iJ++)
					{
						UnitAITypes eUnitAI = pkUnitEntry->GetDefaultUnitAIType();
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pLoopCity != NULL)
							{
								if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
								{
									continue;
								}
								if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
								{
									continue;
								}
								int iResult = pLoopCity->CreateUnit(eUnit, eUnitAI, REASON_GIFT);

								CvAssertMsg(iResult != -1, "Unable to create unit");

								if (iResult != -1)
								{
									CvUnit* pUnit = getUnit(iResult);
									if (!pUnit->IsCivilianUnit() && !pUnit->jumpToNearestValidPlot())
									{
										pUnit->kill(false);	// Could not find a valid spot!
									}
									else
									{
										pUnit->finishMoves();
										//Lua Hook
										GAMEEVENTINVOKE_HOOK(GAMEEVENT_EventUnitCreated, GetID(), eEventChoice, pUnit);
									}
								}
							}
						}
					}
				}
			}
			for(int iI = 0; iI < GC.getNumReligionInfos(); iI++)
			{
				ReligionTypes eReligion = (ReligionTypes)iI;
				if(eReligion == NO_RELIGION)
					continue;

				int iPercent = (ReligionTypes)pkEventChoiceInfo->getEventConvertReligionPercent(iI);
				if(iPercent > 0)
				{
					CvCity *pLoopCity;
					int iLoop;
					for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
						{
							continue;
						}
						if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
						{
							continue;
						}
						pLoopCity->GetCityReligions()->ConvertPercentForcedFollowers(eReligion, iPercent);
					}
				}
				int iPop = (ReligionTypes)pkEventChoiceInfo->getEventConvertReligion(iI);
				if(iPop > 0)
				{
					CvCity *pLoopCity;
					int iLoop;
					for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
						{
							continue;
						}
						if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
						{
							continue;
						}
						pLoopCity->GetCityReligions()->ConvertNumberFollowers(eReligion, iPop);
					}
				}
			}
			if(pkEventChoiceInfo->getResistanceTurns() > 0)
			{
				int iTurns = pkEventChoiceInfo->getResistanceTurns();
				iTurns *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iTurns /= 100;
				CvCity *pLoopCity;
				int iLoop;
				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
					{
						continue;
					}
					if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
					{
						continue;
					}
					pLoopCity->ChangeResistanceTurns(max(1, iTurns));
				}
			}
			if(pkEventChoiceInfo->getWLTKD() > 0)
			{
				int iTurns = pkEventChoiceInfo->getWLTKD();
				iTurns *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iTurns /= 100;
				CvCity *pLoopCity;
				int iLoop;
				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
					{
						continue;
					}
					if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
					{
						continue;
					}
					pLoopCity->ChangeWeLoveTheKingDayCounter(max(1, iTurns));
				}
			}

			//Let's do our notification stuff here.
			for(int iI = 0; iI < pkEventChoiceInfo->GetNumNotifications(); iI++)
			{
				CvString strNotificationString = pkEventChoiceInfo->GetNotificationInfo(iI)->GetNotificationString();		
				if(strNotificationString != NULL && strNotificationString != "")
				{
					NotificationTypes eNotificationType = (NotificationTypes)FString::Hash(strNotificationString);
					
					if(eNotificationType != NO_NOTIFICATION_TYPE)
					{
						Localization::String strMessage;
						Localization::String strSummary;
						strSummary = Localization::Lookup(pkEventChoiceInfo->GetNotificationInfo(iI)->GetShortDescription());
						strSummary << getCivilizationShortDescriptionKey();
						strSummary << getCivilizationDescription();
						strSummary << getName();
						strMessage = Localization::Lookup(pkEventChoiceInfo->GetNotificationInfo(iI)->GetDescription());
						strMessage << getCivilizationShortDescriptionKey();
						strMessage << getCivilizationDescription();
						strMessage << getName();
						strMessage << GetScaledHelpText(eEventChoice, true);
						bool bGlobal = pkEventChoiceInfo->GetNotificationInfo(iI)->IsWorldEvent();
						for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
						{
							PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;
							if(ePlayer != NO_PLAYER && GET_PLAYER(ePlayer).isMajorCiv())
							{
								//Not global? Skip all but me.
								if(!bGlobal && ePlayer != GetID())
									continue;

								//Global? Seed only to known players.
								if(bGlobal && ePlayer != GetID() && !GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(getTeam()))
									continue;

								//Send out notifications!
								CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();
								if(pNotifications && GC.getGame().getActivePlayer() == ePlayer)
								{
									if(pkEventChoiceInfo->GetNotificationInfo(iI)->IsNeedPlayerID())
									{
										pNotifications->Add(eNotificationType, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, GetID(), pkEventChoiceInfo->GetNotificationInfo(iI)->GetVariable2());
									}
									else
									{
										pNotifications->Add(eNotificationType, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, pkEventChoiceInfo->GetNotificationInfo(iI)->GetVariable1(), pkEventChoiceInfo->GetNotificationInfo(iI)->GetVariable2());
									}
								}
							}
						}
					}
				}
			}
			CvCity* pLoopCity;
			int iLoop;
			for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				if(pLoopCity != NULL)
				{
					if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
					{
						continue;
					}
					if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
					{
						continue;
					}
					for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
					{
						YieldTypes eYield = (YieldTypes) iI;
						if(eYield == NO_YIELD)
							continue;

						pLoopCity->UpdateSpecialReligionYields(eYield);
						pLoopCity->UpdateCityYields(eYield);
					}
					pLoopCity->UpdateReligion(pLoopCity->GetCityReligions()->GetReligiousMajority());
					CalculateNetHappiness();
					pLoopCity->GetCityCulture()->CalculateBaseTourismBeforeModifiers();
					pLoopCity->GetCityCulture()->CalculateBaseTourism();
				}
			}
		}
	}
}
#endif
//	--------------------------------------------------------------------------------
/// This player liberates iOldCityID and gives it back to ePlayer
void CvPlayer::DoLiberatePlayer(PlayerTypes ePlayer, int iOldCityID, bool bForced)
{
	CvCity* pCity = getCity(iOldCityID);
	CvAssert(pCity);
	if (!pCity)
		return;

	PlayerTypes eOldOwner = pCity->getOwner();
	CvPlot* pPlot = pCity->plot();

#if defined(MOD_BALANCE_CORE)
	if(ePlayer == NO_PLAYER || GET_PLAYER(ePlayer).isBarbarian())
	{
		ePlayer = pCity->getOriginalOwner();
	}
	if(ePlayer == NO_PLAYER)
	{
		return;
	}
#endif

	// Set that this team has been liberated
	TeamTypes eTeam = getTeam();
	TeamTypes eLiberatedTeam = GET_PLAYER(ePlayer).getTeam();

	// Who originally took out this team?
	TeamTypes eConquerorTeam = GET_TEAM(eLiberatedTeam).GetKilledByTeam();

	if (!GET_PLAYER(ePlayer).isAlive())
	{
		GET_PLAYER(ePlayer).setBeingResurrected(true);
		if (!bForced)
		{
			GET_TEAM(eLiberatedTeam).SetLiberatedByTeam(eTeam);
		}

		// Put everyone at peace with this guy
		for (int iOtherTeamLoop = 0; iOtherTeamLoop < MAX_CIV_TEAMS; iOtherTeamLoop++)
		{
			if (eLiberatedTeam != iOtherTeamLoop)
			{
#if defined(MOD_EVENTS_WAR_AND_PEACE)
				GET_TEAM(eLiberatedTeam).makePeace((TeamTypes)iOtherTeamLoop, /*bBumpUnits*/false, /*bSuppressNotification*/true, GetID());
#else
				GET_TEAM(eLiberatedTeam).makePeace((TeamTypes) iOtherTeamLoop, /*bBumpUnits*/false, /*bSuppressNotification*/true);
#endif
			}
		}
	
		if (!GET_PLAYER(ePlayer).isMinorCiv())
		{
			// add notification
			Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_CIV_RESURRECTED");
			strMessage << getCivilizationShortDescriptionKey(); // LIBERATING CIV NAME
			strMessage << pCity->getNameKey(); // CITY NAME
			strMessage << GET_PLAYER(ePlayer).getCivilizationAdjectiveKey(); // LIBERATED CIV NAME
			strMessage << GET_PLAYER(ePlayer).getCivilizationDescriptionKey();// LIBERATED CIV NAME
			Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CIV_RESURRECTED_SHORT");
			if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(ePlayer).isHuman())
			{
				strSummary << GET_PLAYER(ePlayer).getNickName();
			}
			else
			{
				strSummary << GET_PLAYER(ePlayer).getNameKey();
			}
			if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(m_eID).isHuman())
			{
				strSummary << GET_PLAYER(m_eID).getNickName();
			}
			else
			{
				strSummary << GET_PLAYER(m_eID).getNameKey();
			}			

			for(int iI = 0; iI < MAX_PLAYERS; iI++)
			{
				const PlayerTypes eOtherPlayer = static_cast<PlayerTypes>(iI);
				CvPlayerAI& kOtherPlayer = GET_PLAYER(eOtherPlayer);
				if(kOtherPlayer.isAlive() && kOtherPlayer.GetNotifications() && iI != m_eID)
				{
					kOtherPlayer.GetNotifications()->Add(NOTIFICATION_RESURRECTED_MAJOR_CIV, strMessage.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), -1);
				}
			}

			CvString temp = strMessage.toUTF8();
			GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, m_eID, temp);
		}
	}
	else
	{
		if (!GET_PLAYER(ePlayer).isMinorCiv())
		{
			// add notification
			Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_LIBERATED");
			if(GC.getGame().isGameMultiPlayer() && isHuman())
			{
				strMessage << getNickName();
			}
			else
			{
				strMessage << getNameKey();
			}
			strMessage << pCity->getNameKey(); // CITY NAME
			strMessage << GET_PLAYER(ePlayer).getCivilizationShortDescriptionKey();// RESTORED CIV NAME
			Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CIV_LIBERATED_SHORT");
			strSummary << pCity->getNameKey();
			if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(ePlayer).isHuman())
			{
				strSummary << GET_PLAYER(ePlayer).getNickName();
			}
			else
			{
				strSummary << GET_PLAYER(ePlayer).getNameKey();
			}

			for(int iI = 0; iI < MAX_PLAYERS; iI++)
			{
				const PlayerTypes eOtherPlayer = static_cast<PlayerTypes>(iI);
				CvPlayerAI& kOtherPlayer = GET_PLAYER(eOtherPlayer);
				if(kOtherPlayer.isAlive() && kOtherPlayer.GetNotifications() && iI != m_eID)
				{
					kOtherPlayer.GetNotifications()->Add(NOTIFICATION_LIBERATED_MAJOR_CITY, strMessage.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), -1);
				}
			}
		}
	}

	// Give the city back to the liberated player
#if defined(MOD_API_EXTENSIONS)
	CvCity* pNewCity = GET_PLAYER(ePlayer).acquireCity(pCity, false, true);
#else
	GET_PLAYER(ePlayer).acquireCity(pCity, false, true);
#endif

	// Diplo bonus for returning the city
	if (!bForced)
	{
		// Liberated the capital - big diplo bonus!
		if (pCity->getX() == GET_PLAYER(ePlayer).GetOriginalCapitalX() && pCity->getY() == GET_PLAYER(ePlayer).GetOriginalCapitalY())
		{
			GET_PLAYER(ePlayer).GetDiplomacyAI()->SetPlayerLiberatedCapital(m_eID, true);
		}
				
		GET_PLAYER(ePlayer).GetDiplomacyAI()->ChangeNumCitiesLiberatedBy(m_eID, 1);
#if defined(MOD_BALANCE_CORE)
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetLiberatedCitiesTurn(m_eID, GC.getGame().getGameTurn());
#endif
	}

	if (!GET_PLAYER(ePlayer).isMinorCiv())
	{
		// slewis - if the player we're liberating the city for is dead, give the liberating player a resurrection mark in the once-defeated player's book
		if (!GET_PLAYER(ePlayer).isAlive())
		{
			CvDiplomacyAI* pDiploAI = GET_PLAYER(ePlayer).GetDiplomacyAI();
			PlayerTypes eMePlayer = GetID();
			if (!bForced)
			{
				pDiploAI->SetResurrectedBy(eMePlayer, true);
			}
			
			pDiploAI->SetLandDisputeLevel(eMePlayer, DISPUTE_LEVEL_NONE);
			pDiploAI->SetWonderDisputeLevel(eMePlayer, DISPUTE_LEVEL_NONE);
			pDiploAI->SetMinorCivDisputeLevel(eMePlayer, DISPUTE_LEVEL_NONE);
			pDiploAI->SetVictoryDisputeLevel(eMePlayer, DISPUTE_LEVEL_NONE);
			pDiploAI->SetWarmongerThreat(eMePlayer, THREAT_NONE);
			pDiploAI->SetOtherPlayerWarmongerAmountTimes100(eMePlayer, 0);

			pDiploAI->SetPlayerNoSettleRequestCounter(eMePlayer, -1);
			pDiploAI->SetPlayerStopSpyingRequestCounter(eMePlayer, -1);
#if defined(MOD_BALANCE_CORE)
			pDiploAI->SetVictoryBlockLevel(eMePlayer, BLOCK_LEVEL_NONE);
			
			pDiploAI->SetPlayerNoSettleRequestEverAsked(eMePlayer, false);
			pDiploAI->SetPlayerStopSpyingRequestEverAsked(eMePlayer, false);
			
			pDiploAI->SetNumDemandEverMade(eMePlayer, -pDiploAI->GetNumDemandEverMade(eMePlayer));
			
			if (pDiploAI->GetNumTimesCoopWarDenied(eMePlayer) > 0)
			{
				pDiploAI->SetNumTimesCoopWarDenied(eMePlayer, 0);
			}
			
			if (GetDiplomacyAI()->GetNumTimesCoopWarDenied(ePlayer) > 0)
			{
				GetDiplomacyAI()->SetNumTimesCoopWarDenied(ePlayer, 0);
			}
			
			if (pDiploAI->GetRecentAssistValue(eMePlayer) > 0)
			{
				pDiploAI->SetRecentAssistValue(eMePlayer, 0);
			}
			
			// Forget war history
			pDiploAI->SetNumWarsDeclaredOnUs(eMePlayer, 0);
			pDiploAI->SetNumCitiesCapturedBy(eMePlayer, 0);
			pDiploAI->SetNumTimesRazed(eMePlayer, 0);
			pDiploAI->SetNumTradeRoutesPlundered(eMePlayer, 0);
			GetDiplomacyAI()->SetNumWarsDeclaredOnUs(ePlayer, 0);
			GetDiplomacyAI()->SetNumCitiesCapturedBy(ePlayer, 0);
			GetDiplomacyAI()->SetNumTimesRazed(ePlayer, 0);
			GetDiplomacyAI()->SetNumTradeRoutesPlundered(ePlayer, 0);
			
			pDiploAI->SetNumArtifactsEverDugUp(eMePlayer, 0);
			pDiploAI->SetPlayerEverConvertedCity(eMePlayer, false);
			
			pDiploAI->SetNumTimesTheyPlottedAgainstUs(eMePlayer, 0);
			pDiploAI->SetNumTimesTheyLoweredOurInfluence(eMePlayer, 0);
			pDiploAI->SetNumTimesPerformedCoupAgainstUs(eMePlayer, 0);
#endif
			pDiploAI->SetDemandCounter(eMePlayer, -1);
			pDiploAI->SetNumTimesCultureBombed(eMePlayer, 0);
			pDiploAI->SetNegativeReligiousConversionPoints(eMePlayer, 0);
			pDiploAI->SetNegativeArchaeologyPoints(eMePlayer, 0);
			pDiploAI->SetNumTimesRobbedBy(eMePlayer, 0);
			
			// Reset all promises
			pDiploAI->SetPlayerMadeMilitaryPromise(eMePlayer, false);
			pDiploAI->SetPlayerMadeExpansionPromise(eMePlayer, false);
			pDiploAI->SetPlayerMadeBorderPromise(eMePlayer, false);
			pDiploAI->SetPlayerMadeAttackCityStatePromise(eMePlayer, false);
			pDiploAI->SetPlayerMadeBullyCityStatePromise(eMePlayer, false);
			pDiploAI->SetPlayerMadeNoConvertPromise(eMePlayer, false);
			pDiploAI->SetPlayerMadeNoDiggingPromise(eMePlayer, false);
			pDiploAI->SetPlayerMadeSpyPromise(eMePlayer, false);
			
			pDiploAI->SetPlayerBrokenMilitaryPromise(eMePlayer, false);
			pDiploAI->SetPlayerIgnoredMilitaryPromise(eMePlayer, false);
			pDiploAI->SetBrokenBorderPromiseValue(eMePlayer, 0);
			pDiploAI->SetIgnoredBorderPromiseValue(eMePlayer, 0);
			pDiploAI->SetBrokenExpansionPromiseValue(eMePlayer, 0);
			pDiploAI->SetIgnoredExpansionPromiseValue(eMePlayer, 0);

			pDiploAI->SetPlayerBrokenAttackCityStatePromise(eMePlayer, false);
			pDiploAI->SetPlayerIgnoredAttackCityStatePromise(eMePlayer, false);
			pDiploAI->SetPlayerBrokenBullyCityStatePromise(eMePlayer, false);
			pDiploAI->SetPlayerIgnoredBullyCityStatePromise(eMePlayer, false);

			pDiploAI->SetPlayerBrokenNoConvertPromise(eMePlayer, false);
			pDiploAI->SetPlayerIgnoredNoConvertPromise(eMePlayer, false);

			pDiploAI->SetPlayerBrokenNoDiggingPromise(eMePlayer, false);
			pDiploAI->SetPlayerIgnoredNoDiggingPromise(eMePlayer, false);

			pDiploAI->SetPlayerBrokenSpyPromise(eMePlayer, false);
			pDiploAI->SetPlayerIgnoredSpyPromise(eMePlayer, false);

			pDiploAI->SetPlayerBrokenCoopWarPromise(eMePlayer, false);

			pDiploAI->SetOtherPlayerNumProtectedMinorsKilled(eMePlayer, 0);
			pDiploAI->SetOtherPlayerNumProtectedMinorsAttacked(eMePlayer, 0);
			pDiploAI->SetOtherPlayerNumProtectedMinorsBullied(eMePlayer, 0);
			pDiploAI->SetOtherPlayerTurnsSinceSidedWithProtectedMinor(eMePlayer, -1);

			pDiploAI->SetFriendDenouncedUs(eMePlayer, false); // clear backstabbing penalties
			pDiploAI->SetFriendDeclaredWarOnUs(eMePlayer, false); // clear backstabbing penalties
			pDiploAI->SetDenouncedPlayer(eMePlayer, false); // forget any denouncing
			GetDiplomacyAI()->SetDenouncedPlayer(ePlayer, false); // forget any denouncing

			pDiploAI->SetNumTimesNuked(eMePlayer, 0);
			
			pDiploAI->SetTurnsSinceWeDislikedTheirProposal(eMePlayer, -1);
			pDiploAI->SetTurnsSinceTheyFoiledOurProposal(eMePlayer, -1);
			
			pDiploAI->SetTurnsSinceVassalageForcefullyRevoked(eMePlayer, -1);
			pDiploAI->SetPlayerBrokenVassalAgreement(eMePlayer, false);
			
			// Clear backstabbing mark
			pDiploAI->SetEverBackstabbedBy(eMePlayer, false);
			GetDiplomacyAI()->SetEverBackstabbedBy(ePlayer, false);
			
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
			// Clear certain penalties with third parties
			for (int iThirdPartyLoop = 0; iThirdPartyLoop < MAX_MAJOR_CIVS; iThirdPartyLoop++)
			{
				PlayerTypes eThirdParty = (PlayerTypes) iThirdPartyLoop;
				
				if (GET_PLAYER(eThirdParty).isMajorCiv())
				{
					// forget any denouncing
					pDiploAI->SetDenouncedPlayer(eThirdParty, false);
					GET_PLAYER(eThirdParty).GetDiplomacyAI()->SetDenouncedPlayer(ePlayer, false);
				}
			}
#endif
			// Update diplo stuff.
			pDiploAI->DoUpdateTrueApproachTowardsUsGuesses(true);
			pDiploAI->SetTrueApproachTowardsUsGuess(eMePlayer, MAJOR_CIV_APPROACH_FRIENDLY);
			pDiploAI->SetTrueApproachTowardsUsGuessCounter(eMePlayer, 0);
			pDiploAI->DoUpdateOpinions();
			pDiploAI->DoUpdateMajorCivApproaches();
			if (!isHuman())
			{
				GetDiplomacyAI()->DoUpdateTrueApproachTowardsUsGuesses(true);
				GetDiplomacyAI()->SetTrueApproachTowardsUsGuess(ePlayer, MAJOR_CIV_APPROACH_FRIENDLY);
				GetDiplomacyAI()->SetTrueApproachTowardsUsGuessCounter(ePlayer, 0);
				GetDiplomacyAI()->DoUpdateOpinions();
				GetDiplomacyAI()->DoUpdateMajorCivApproaches(/*bIgnoreApproachCurve*/ true);
			}
		}
	}

	// Now verify the player is alive
	if (!GET_TEAM(getTeam()).isHasMet(GET_PLAYER(ePlayer).getTeam()))
	{
		GET_TEAM(getTeam()).makeHasMet(GET_PLAYER(ePlayer).getTeam(), true);
	}
	GET_PLAYER(ePlayer).verifyAlive();
	GET_PLAYER(ePlayer).setBeingResurrected(false);

	if (!bForced)
	{
		// Is this a Minor we have liberated?
		if (GET_PLAYER(ePlayer).isMinorCiv() && !GET_PLAYER(ePlayer).isBarbarian())
		{
			GET_PLAYER(ePlayer).GetMinorCivAI()->DoLiberationByMajor(eOldOwner, eConquerorTeam);

			//give them a basic but state-of-the-art garrison
			UnitTypes eUnit = GC.getGame().GetCompetitiveSpawnUnitType(ePlayer, false, false, false, true, false);
			if (eUnit != NO_UNIT)
				GET_PLAYER(ePlayer).initUnit(eUnit, pNewCity->getX(), pNewCity->getY());
		}
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		else if (MOD_DIPLOMACY_CIV4_FEATURES && GET_PLAYER(ePlayer).isMajorCiv() && GET_TEAM(eLiberatedTeam).GetLiberatedByTeam() == getTeam())
		{
			if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassal(getTeam()))
			{
				GET_TEAM(GET_PLAYER(ePlayer).getTeam()).SetNumTurnsIsVassal(-1);
				GET_TEAM(GET_PLAYER(ePlayer).getTeam()).SetNumTurnsSinceVassalEnded(getTeam(), -1);
				GET_TEAM(GET_PLAYER(ePlayer).getTeam()).DoBecomeVassal(getTeam(), true);
			}
		}
#endif
	}

	// slewis
	// negate warmonger
	if (!bForced)
	{
		for (int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)
		{
			PlayerTypes eMajor = (PlayerTypes)iMajorLoop;
			if (GetID() != eMajor && GET_PLAYER(eMajor).isAlive())
			{
				// Have I met the player who conquered the city?
				if (GET_TEAM(GET_PLAYER(eMajor).getTeam()).isHasMet(getTeam()))
				{
#if defined(MOD_CONFIG_AI_IN_XML)
					int iWarmongerOffset = CvDiplomacyAIHelpers::GetPlayerCaresValue(GetID(), ePlayer, pNewCity, GetID(), true);
					GET_PLAYER(eMajor).GetDiplomacyAI()->ChangeOtherPlayerWarmongerAmountTimes100(GetID(), -iWarmongerOffset);
#else
					int iNumCities = max(GET_PLAYER(ePlayer).getNumCities(), 1);
					int iWarmongerOffset = CvDiplomacyAIHelpers::GetWarmongerOffset(iNumCities, GET_PLAYER(ePlayer).isMinorCiv());
					GET_PLAYER(eMajor).GetDiplomacyAI()->ChangeOtherPlayerWarmongerAmount(GetID(), -iWarmongerOffset);
#endif
				}
			}
		}

		GetCulture()->SetWarWeariness(GetCulture()->GetWarWeariness() / 4);
	}

	// Move Units from player that don't belong here
	if(pPlot->getNumUnits() > 0)
	{
		// Get the current list of units because we will possibly be moving them out of the plot's list
		IDInfoVector currentUnits;
		if (pPlot->getUnits(&currentUnits) > 0)
		{
			for(IDInfoVector::const_iterator itr = currentUnits.begin(); itr != currentUnits.end(); ++itr)
			{
				CvUnit* pLoopUnit = (CvUnit*)GetPlayerUnit(*itr);

				if(pLoopUnit && pLoopUnit->getOwner() == eOldOwner)
				{
					pLoopUnit->finishMoves();
					if (!pLoopUnit->jumpToNearestValidPlot())
						pLoopUnit->kill(false);
				}
			}
		}
	}

#if defined(MOD_EVENTS_LIBERATION)
	if (MOD_EVENTS_LIBERATION) {
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerLiberated, GetID(), ePlayer, pNewCity->GetID());
	}
#endif

#if defined(MOD_DIPLOMACY_CITYSTATES)
	//Let's give the Embassies of the defeated player back to the liberated player
	if(MOD_DIPLOMACY_CITYSTATES && GET_PLAYER(ePlayer).GetImprovementLeagueVotes() > 0)
	{
		for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			ePlayer = (PlayerTypes) iPlayerLoop;
			if(ePlayer != NO_PLAYER && GET_PLAYER(ePlayer).getTeam() == eConquerorTeam)
			{
				int iEmbassyVotes = GET_PLAYER(ePlayer).GetImprovementLeagueVotes();
				GET_PLAYER(ePlayer).ChangeImprovementLeagueVotes(-iEmbassyVotes);
			}
		}
	}
#endif
}

//	--------------------------------------------------------------------------------
bool CvPlayer::CanLiberatePlayer(PlayerTypes ePlayer)
{
	// Other Player must be dead now
	if(GET_PLAYER(ePlayer).isAlive())
	{
		return false;
	}

	if(GET_PLAYER(ePlayer).IsEverConqueredBy(m_eID))
	{
		return false;
	}

	if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetKilledByTeam() == getTeam())
	{
		return false;
	}
	
#if defined(MOD_EVENTS_LIBERATION)
	if (MOD_EVENTS_LIBERATION) {
		if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_PlayerCanLiberate, GetID(), ePlayer) == GAMEEVENTRETURN_FALSE) {
			return false;
		}
	}
#endif

	return true;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::CanLiberatePlayerCity(PlayerTypes ePlayer)
{
	if (!GET_PLAYER(ePlayer).isAlive())
	{
		return CanLiberatePlayer(ePlayer);
	}

	return IsAtPeaceWith(ePlayer);
}

//	--------------------------------------------------------------------------------
#if defined(MOD_BALANCE_CORE)
CvUnit* CvPlayer::initUnit(UnitTypes eUnit, int iX, int iY, UnitAITypes eUnitAI, UnitCreationReason eReason, bool bNoMove, bool bSetupGraphical, int iMapLayer /* = 0 */, int iNumGoodyHutsPopped, ContractTypes eContract, bool bHistoric, CvUnit* pPassUnit)
#else
CvUnit* CvPlayer::initUnit(UnitTypes eUnit, int iX, int iY, UnitAITypes eUnitAI, UnitCreationReason eReason, bool bNoMove, bool bSetupGraphical, int iMapLayer /* = 0 */, int iNumGoodyHutsPopped, ContractTypes eContract, bool bHistoric)
#endif
{
	CvAssertMsg(eUnit != NO_UNIT, "Unit is not assigned a valid value");
	if (eUnit == NO_UNIT)
		return NULL;

	CvUnitEntry* pkUnitDef = GC.getUnitInfo(eUnit);
	CvAssertFmt(pkUnitDef != NULL, "Trying to create unit of type %d, which does not exist", eUnit);
	if (pkUnitDef == NULL)
		return NULL;

	if (isMajorCiv() && pkUnitDef->IsMilitarySupport() && GetNumUnitsOutOfSupply() > 4 && eReason!=REASON_UPGRADE && eReason!=REASON_GIFT)
	{
		OutputDebugString("Creating unit over supply limit\n");
	}

	CvUnit* pUnit = addUnit();
	CvAssertMsg(pUnit != NULL, "Unit is not assigned a valid value");
	if(NULL != pUnit)
	{
#if defined(MOD_BALANCE_CORE)
		pUnit->init(pUnit->GetID(), eUnit, ((eUnitAI == NO_UNITAI) ? pkUnitDef->GetDefaultUnitAIType() : eUnitAI), GetID(), iX, iY, eReason, bNoMove, bSetupGraphical, iMapLayer, iNumGoodyHutsPopped, eContract, bHistoric, pPassUnit);
#else
		pUnit->init(pUnit->GetID(), eUnit, ((eUnitAI == NO_UNITAI) ? pkUnitDef->GetDefaultUnitAIType() : eUnitAI), GetID(), iX, iY, eReason, bNoMove, bSetupGraphical, iMapLayer, iNumGoodyHutsPopped, eContract, bHistoric);
#endif

#if !defined(NO_TUTORIALS)
		// slewis - added for the tutorial
		if(pUnit->getUnitInfo().GetWorkRate() > 0 && pUnit->getUnitInfo().GetDomainType() == DOMAIN_LAND)
		{
			m_bEverTrainedBuilder = true;
		}
		// end added for the tutorial
#endif
	}

	m_kPlayerAchievements.AddUnit(pUnit);
	return pUnit;
}

#if defined(MOD_BALANCE_CORE)
CvUnit* CvPlayer::initUnitWithNameOffset(UnitTypes eUnit, int nameOffset, int iX, int iY, UnitAITypes eUnitAI, UnitCreationReason eReason, bool bNoMove, bool bSetupGraphical, int iMapLayer /* = 0 */, int iNumGoodyHutsPopped, ContractTypes eContract, bool bHistoric, CvUnit* pPassUnit)
#else
CvUnit* CvPlayer::initUnitWithNameOffset(UnitTypes eUnit, int nameOffset, int iX, int iY, UnitAITypes eUnitAI, UnitCreationReason eReason, bool bNoMove, bool bSetupGraphical, int iMapLayer /* = 0 */, int iNumGoodyHutsPopped, ContractTypes eContract, bool bHistoric)
#endif
{
	CvAssertMsg(eUnit != NO_UNIT, "Unit is not assigned a valid value");
	if (eUnit == NO_UNIT)
		return NULL;

	CvUnitEntry* pkUnitDef = GC.getUnitInfo(eUnit);
	CvAssertFmt(pkUnitDef != NULL, "Trying to create unit of type %d, which does not exist", eUnit);
	if (pkUnitDef == NULL)
		return NULL;

	CvUnit* pUnit = addUnit();
	CvAssertMsg(pUnit != NULL, "Unit is not assigned a valid value");
	if(NULL != pUnit)
	{
#if defined(MOD_BALANCE_CORE)
		pUnit->initWithNameOffset(pUnit->GetID(), eUnit, nameOffset, ((eUnitAI == NO_UNITAI) ? pkUnitDef->GetDefaultUnitAIType() : eUnitAI), GetID(), iX, iY, eReason, bNoMove, bSetupGraphical, iMapLayer, iNumGoodyHutsPopped, eContract, bHistoric, pPassUnit);
#else
		pUnit->initWithNameOffset(pUnit->GetID(), eUnit, nameOffset, ((eUnitAI == NO_UNITAI) ? pkUnitDef->GetDefaultUnitAIType() : eUnitAI), GetID(), iX, iY, eReason, bNoMove, bSetupGraphical, iMapLayer, iNumGoodyHutsPopped, eContract, bHistoric);
#endif

#if !defined(NO_TUTORIALS)
		// slewis - added for the tutorial
		if(pUnit->getUnitInfo().GetWorkRate() > 0 && pUnit->getUnitInfo().GetDomainType() == DOMAIN_LAND)
		{
			m_bEverTrainedBuilder = true;
		}
		// end added for the tutorial
#endif
	}

	m_kPlayerAchievements.AddUnit(pUnit);

	return pUnit;
}

//	--------------------------------------------------------------------------------
CvUnit* CvPlayer::initNamedUnit(UnitTypes eUnit, const char* strKey, int iX, int iY, UnitAITypes eUnitAI, UnitCreationReason eReason, bool bNoMove, bool bSetupGraphical, int iMapLayer /* = 0 */, int iNumGoodyHutsPopped)
{
	CvAssertMsg(eUnit != NO_UNIT, "Unit is not assigned a valid value");
	if (eUnit == NO_UNIT)
		return NULL;

	CvUnitEntry* pkUnitDef = GC.getUnitInfo(eUnit);
	CvAssertFmt(pkUnitDef != NULL, "Trying to create unit of type %d, which does not exist", eUnit);
	if (pkUnitDef == NULL)
		return NULL;

	if(strKey == NULL)
		return NULL;

	CvString strName = strKey;
	if(GC.getGame().isGreatPersonBorn(strName))
	{
		return NULL;
	}

	CvUnit* pUnit = addUnit();
	CvAssertMsg(pUnit != NULL, "Unit is not assigned a valid value");
	if (NULL != pUnit)
	{
		pUnit->initWithNameOffset(pUnit->GetID(), eUnit, -1, ((eUnitAI == NO_UNITAI) ? pkUnitDef->GetDefaultUnitAIType() : eUnitAI), GetID(), iX, iY, eReason, bNoMove, bSetupGraphical, iMapLayer, iNumGoodyHutsPopped, NO_CONTRACT, true, true);

#if !defined(NO_TUTORIALS)
		// slewis - added for the tutorial
		if (pUnit->getUnitInfo().GetWorkRate() > 0 && pUnit->getUnitInfo().GetDomainType() == DOMAIN_LAND)
		{
			m_bEverTrainedBuilder = true;
		}
		// end added for the tutorial
#endif

		pUnit->SetGreatWork(NO_GREAT_WORK);
#if !defined(MOD_GLOBAL_NO_LOST_GREATWORKS)
		int iUnitName = GC.getGame().getUnitCreatedCount(getUnitType());
		int iNumNames = pUnit->getUnitInfo().GetNumUnitNames();
		if (iUnitName < iNumNames)
#endif
		{
			if (strKey != NULL)
			{
				CvString strName = strKey;
				int iNumNames = pUnit->getUnitInfo().GetNumUnitNames();
				for (int iI = 0; iI < iNumNames; iI++)
				{
					CvString strOtherName = pUnit->getUnitInfo().GetUnitNames(iI);
					if (strOtherName == strName)
					{
						pUnit->setName(strName);
						pUnit->SetGreatWork(pUnit->getUnitInfo().GetGreatWorks(iI));
						GC.getGame().addGreatPersonBornName(strName);
#if defined(MOD_GLOBAL_NO_LOST_GREATWORKS)
						if (MOD_GLOBAL_NO_LOST_GREATWORKS)
						{
							// setName strips undesirable characters, but we stored those into the list of GPs born, so we need to keep the original name
							pUnit->setGreatName(strName);
						}
#endif
						break;
					}
				}
			}
		}
	}

	m_kPlayerAchievements.AddUnit(pUnit);

	return pUnit;
}

//	--------------------------------------------------------------------------------
void CvPlayer::disbandUnit(bool)
{
	CvUnit* pLoopUnit;
	CvUnit* pBestUnit;
	char szBuffer[1024];
	const size_t lenBuffer = 1024;
	int iValue;
	int iBestValue;
	int iLoop;

	iBestValue = INT_MAX;
	pBestUnit = NULL;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(!(pLoopUnit->hasCargo()))
		{
			if(!(pLoopUnit->isGoldenAge()))
			{
				if(pLoopUnit->getUnitInfo().GetProductionCost() > 0)
				{
					{
						iValue = (10000 + GC.getGame().getSmallFakeRandNum(1000, pLoopUnit->GetID() + iLoop));

						iValue += (pLoopUnit->getUnitInfo().GetProductionCost() * 5);

#if defined(MOD_UNITS_XP_TIMES_100)
						iValue += (pLoopUnit->getExperienceTimes100() / 100 * 20);
#else
						iValue += (pLoopUnit->getExperience() * 20);
#endif
						iValue += (pLoopUnit->getLevel() * 100);

						if(pLoopUnit->IsGarrisoned())
						{
							iValue *= 2;
						}

						if(pLoopUnit->plot()->getTeam() == pLoopUnit->getTeam())
						{
							iValue *= 3;
						}

						switch(pLoopUnit->AI_getUnitAIType())
						{
						case UNITAI_UNKNOWN:
							break;

						case UNITAI_SETTLE:
							iValue *= 20;
							break;

						case UNITAI_WORKER:
							iValue *= 10;
							break;

						case UNITAI_ATTACK:
						case UNITAI_CITY_BOMBARD:
						case UNITAI_FAST_ATTACK:
						case UNITAI_DEFENSE:
						case UNITAI_COUNTER:
							iValue *= 2;
							break;

						case UNITAI_RANGED:
						case UNITAI_CITY_SPECIAL:
						case UNITAI_PARADROP:
							iValue *= 6;
							break;

						case UNITAI_EXPLORE:
							iValue *= 15;
							break;

						case UNITAI_ARTIST:
						case UNITAI_SCIENTIST:
						case UNITAI_GENERAL:
						case UNITAI_MERCHANT:
#if defined(MOD_DIPLOMACY_CITYSTATES)
						case UNITAI_DIPLOMAT:
						case UNITAI_MESSENGER:
#endif
						case UNITAI_ENGINEER:
						case UNITAI_SPACESHIP_PART:
						case UNITAI_TREASURE:
						case UNITAI_PROPHET:
						case UNITAI_MISSIONARY:
						case UNITAI_INQUISITOR:
						case UNITAI_ADMIRAL:
						case UNITAI_WRITER:
						case UNITAI_MUSICIAN:
							break;

						case UNITAI_ICBM:
							iValue *= 4;
							break;

						case UNITAI_WORKER_SEA:
							iValue *= 18;
							break;

						case UNITAI_ATTACK_SEA:
						case UNITAI_RESERVE_SEA:
						case UNITAI_ESCORT_SEA:
							break;

						case UNITAI_EXPLORE_SEA:
							iValue *= 25;
							break;

						case UNITAI_ASSAULT_SEA:
						case UNITAI_SETTLER_SEA:
						case UNITAI_CARRIER_SEA:
						case UNITAI_MISSILE_CARRIER_SEA:
							iValue *= 5;
							break;

						case UNITAI_PIRATE_SEA:
						case UNITAI_ATTACK_AIR:
							break;

						case UNITAI_DEFENSE_AIR:
						case UNITAI_CARRIER_AIR:
						case UNITAI_MISSILE_AIR:
							iValue *= 3;
							break;

						default:
							CvAssert(false);
							break;
						}

						if(pLoopUnit->getUnitInfo().GetExtraMaintenanceCost() > 0)
						{
							iValue /= (pLoopUnit->getUnitInfo().GetExtraMaintenanceCost() + 1);
						}

						if(iValue < iBestValue)
						{
							iBestValue = iValue;
							pBestUnit = pLoopUnit;
						}
					}
				}
			}
		}
	}

	if(pBestUnit != NULL)
	{
		if(GetID() == GC.getGame().getActivePlayer())
		{
			sprintf_s(szBuffer, lenBuffer, GetLocalizedText("TXT_KEY_MISC_UNIT_DISBANDED_NO_MONEY", pBestUnit->getNameKey()).GetCString());
			GC.GetEngineUserInterface()->AddUnitMessage(0, pBestUnit->GetIDInfo(), GetID(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer);//, "AS2D_UNITDISBANDED", MESSAGE_TYPE_MINOR_EVENT, pBestUnit->getUnitInfo().GetButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pBestUnit->getX(), pBestUnit->getY(), true, true);
		}

		CvAssert(!(pBestUnit->isGoldenAge()));

		pBestUnit->kill(false);
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::killUnits()
{
	//can't kill the units directly because that invalidates the iterator
	std::vector<int> unitsToKill;

	int iLoop;
	for(CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		unitsToKill.push_back(pLoopUnit->GetID());
	}

	//debugging ...
	for (std::vector<int>::iterator it = unitsToKill.begin(); it != unitsToKill.end(); ++it)
	{
		if (std::count(unitsToKill.begin(), unitsToKill.end(),*it)>1)
			OutputDebugString("inconsistent state: non-unique unit ID to kill!\n");
	}

	for (std::vector<int>::iterator it=unitsToKill.begin(); it!=unitsToKill.end(); ++it)
	{
		CvUnit* pLoopUnit = getUnit(*it);
		if (pLoopUnit)
			pLoopUnit->kill(false);
	}
}

#if defined(MOD_API_EXTENSIONS) || defined(MOD_BUGFIX_UNITCLASS_NOT_UNIT)
//	--------------------------------------------------------------------------------
// Given a unit class, get the players specific unit of that class
UnitTypes CvPlayer::GetSpecificUnitType(const char* szUnitClass, bool hideAssert)
{
	UnitTypes eUnitType = NO_UNIT;
	UnitClassTypes eUnitClassType = (UnitClassTypes) GC.getInfoTypeForString(szUnitClass, hideAssert);

	const CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClassType);
	
	if (pkUnitClassInfo)
	{
		CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
		
		if (pCivilizationInfo != NULL)
		{
			eUnitType = (UnitTypes) pCivilizationInfo->getCivilizationUnits(eUnitClassType);
		}
		else
		{
			eUnitType = (UnitTypes) pkUnitClassInfo->getDefaultUnitIndex();
		}
	}
	
	if (!isMinorCiv() && !isBarbarian()) {
		if (eUnitType == NO_UNIT) {
			CUSTOMLOG("GetSpecificUnitType for player %s: %s is UNKNOWN!!!", getName(), szUnitClass);
		} else {
			// CUSTOMLOG("GetSpecificUnitType for player %s: %s is %s", getName(), szUnitClass, GC.getUnitInfo(eUnitType)->GetType());
		}
	}

	return eUnitType;
}
#endif

#if defined(MOD_API_EXTENSIONS) || defined(MOD_BUGFIX_BUILDINGCLASS_NOT_BUILDING)
//	--------------------------------------------------------------------------------
// Given a building class, get the players specific building of that class
BuildingTypes CvPlayer::GetSpecificBuildingType(const char* szBuildingClass, bool hideAssert)
{
	BuildingTypes eBuildingType = NO_BUILDING;
	BuildingClassTypes eBuildingClassType = (BuildingClassTypes) GC.getInfoTypeForString(szBuildingClass, hideAssert);

	const CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClassType);
	
	if (pkBuildingClassInfo)
	{
		CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
		
		if (pCivilizationInfo != NULL)
		{
			eBuildingType = (BuildingTypes) pCivilizationInfo->getCivilizationBuildings(eBuildingClassType);
		}
		else
		{
			eBuildingType = (BuildingTypes) pkBuildingClassInfo->getDefaultBuildingIndex();
		}
	}
	
	if (!isMinorCiv() && !isBarbarian()) {
		if (eBuildingType == NO_BUILDING) {
			CUSTOMLOG("GetSpecificBuildingType for player %s: %s is UNKNOWN!!!", getName(), szBuildingClass);
		} else {
			// CUSTOMLOG("GetSpecificBuildingType for player %s: %s is %s", getName(), szBuildingClass, GC.getBuildingInfo(eBuildingType)->GetType());
		}
	}

	return eBuildingType;
}
#endif

//	--------------------------------------------------------------------------------
CvPlot *CvPlayer::GetGreatAdmiralSpawnPlot (CvUnit *pUnit)
{
	CvPlot *pInitialPlot = pUnit->plot();

	// Is this a friendly coastal city, if so we'll go with that
	CvCity *pInitialCity = pInitialPlot->getPlotCity();
	if (pInitialCity && pInitialCity->isCoastal())
	{
		// Equal okay checking this plot because this is where the unit is right now
		if (pInitialPlot->CanStackUnitHere(pUnit))
			return pInitialPlot;
	}

	// Otherwise let's look at all our other cities
	CvCity *pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (pLoopCity != pInitialCity && pLoopCity->isCoastal())
		{
			if (pLoopCity->plot()->CanStackUnitHere(pUnit))
			{
				return pLoopCity->plot();
			}
		}
	}

	// Don't have a coastal city, look for water plot THAT ISN'T A LAKE closest to our capital that isn't owned by an enemy
	CvCity *pCapital = getCapitalCity();
	if (pCapital)
	{
		int iCapitalX = pCapital->getX();
		int iCapitalY = pCapital->getY();

		CvPlot *pBestPlot = NULL;
		int iBestDistance = MAX_INT;

		for (int iI = 0; iI < GC.getMap().numPlots(); iI++)
		{
			CvPlot *pPlot = GC.getMap().plotByIndexUnchecked(iI);
			if (pPlot != NULL)
			{
				if (pPlot->isWater() && !pPlot->isLake())
				{
					if (pPlot->IsFriendlyTerritory(GetID()) || !pPlot->isOwned())
					{
						if (pPlot->CanStackUnitHere(pUnit))
						{
							int iDistance = plotDistance(iCapitalX, iCapitalY, pPlot->getX(), pPlot->getY());
							if (iDistance < iBestDistance)
							{
								pBestPlot = pPlot;
								iBestDistance = iDistance;
							}
						}
					}
				}
			}
		}

		if (pBestPlot)
		{
			return pBestPlot;
		}

		// Now we'll even accept a lake
		for (int iI = 0; iI < GC.getMap().numPlots(); iI++)
		{
			CvPlot *pPlot = GC.getMap().plotByIndexUnchecked(iI);
			if (pPlot != NULL)
			{
				if (pPlot->isWater())
				{
					if (pPlot->IsFriendlyTerritory(GetID()) || !pPlot->isOwned())
					{
						if (pPlot->CanStackUnitHere(pUnit))
						{
							int iDistance = plotDistance(iCapitalX, iCapitalY, pPlot->getX(), pPlot->getY());
							if (iDistance < iBestDistance)
							{
								pBestPlot = pPlot;
								iBestDistance = iDistance;
							}
						}
					}
				}
			}
		}
		if (pBestPlot)
		{
			return pBestPlot;
		}
	}

	CvAssertMsg (false, "Could not find valid plot for Great Admiral - placing on land");

	return pInitialPlot;
}


//	--------------------------------------------------------------------------------
/// The number of Builders a player has
int CvPlayer::GetNumBuilders() const
{
	return m_iNumBuilders;
}

//	--------------------------------------------------------------------------------
/// Sets the number of Builders a player has
void CvPlayer::SetNumBuilders(int iNum)
{
	if(GetNumBuilders() != iNum)
	{
		m_iNumBuilders = iNum;
	}
}

//	--------------------------------------------------------------------------------
/// Changes the number of Builders a player has
void CvPlayer::ChangeNumBuilders(int iChange)
{
	if(iChange != 0)
	{
		SetNumBuilders(GetNumBuilders() + iChange);
	}
}


//	--------------------------------------------------------------------------------
/// The maximum number of Builders a player can Train
int CvPlayer::GetMaxNumBuilders() const
{
	return m_iMaxNumBuilders;
}

//	--------------------------------------------------------------------------------
/// Sets the maximum number of Builders a player can Train
void CvPlayer::SetMaxNumBuilders(int iNum)
{
	if(GetMaxNumBuilders() != iNum)
	{
		m_iMaxNumBuilders = iNum;
	}
}

//	--------------------------------------------------------------------------------
/// Changes the maximum number of Builders a player can Train
void CvPlayer::ChangeMaxNumBuilders(int iChange)
{
	if(iChange != 0)
	{
		SetMaxNumBuilders(GetMaxNumBuilders() + iChange);
	}
}


//	--------------------------------------------------------------------------------
/// Returns number of Units a player has with a particular UnitAI.  The second argument allows you to check whether or not to include Units currently being trained in Cities.
int CvPlayer::GetNumUnitsWithUnitAI(UnitAITypes eUnitAIType, bool bIncludeBeingTrained, bool bIncludeWater)
{
	int iNumUnits = 0;

	CvUnit* pLoopUnit;
	CvCity* pLoopCity;
	int iLoop;

	// Current Units
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		// Don't include Water Units if we don't want them
		if(pLoopUnit->getDomainType() != DOMAIN_SEA || bIncludeWater)
		{
			if(pLoopUnit->AI_getUnitAIType() == eUnitAIType)
			{
				iNumUnits++;
			}
		}
	}

	// Units being trained now
	if(bIncludeBeingTrained)
	{
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity->isProductionUnit())
			{
				CvUnitEntry* pkUnitEntry = GC.getUnitInfo(pLoopCity->getProductionUnit());
				if(pkUnitEntry)
				{
					// Don't include Water Units if we don't want them
					if(pkUnitEntry->GetDomainType() != DOMAIN_SEA || bIncludeWater)
					{
						if(pkUnitEntry->GetDefaultUnitAIType() == eUnitAIType)
						{
							iNumUnits++;
						}
					}
				}
			}
		}
	}

	return iNumUnits;
}

//	--------------------------------------------------------------------------------
/// Returns number of Units a player has of a particular domain.  The second argument allows you to check whether or not to include civilians.
int CvPlayer::GetNumUnitsWithDomain(DomainTypes eDomain, bool bMilitaryOnly)
{
	int iNumUnits = 0;

	CvUnit* pLoopUnit;
	int iLoop;

	// Current Units
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->getDomainType() == eDomain)
		{
			if(!bMilitaryOnly || pLoopUnit->IsCombatUnit())
			{
				iNumUnits++;
			}
		}
	}

	return iNumUnits;
}

//	-----------------------------------------------------------------------------------------------
int CvPlayer::GetNumUnitsWithUnitCombat(UnitCombatTypes eUnitCombat)
{
	int iNumUnits = 0;

	CvUnit* pLoopUnit;
	int iLoop;

	// Current Units
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->getUnitCombatType() == eUnitCombat)
		{
			iNumUnits++;
		}
	}

	return iNumUnits;
}

//	-----------------------------------------------------------------------------------------------
int CvPlayer::GetNumUnitsOfType(UnitTypes eUnit, bool bIncludeBeingTrained)
{
	int iNumUnits = 0;

	CvUnit* pLoopUnit;
	int iLoop;

	// Current Units
	for (pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if (pLoopUnit->getUnitType() == eUnit)
		{
			iNumUnits++;
		}
	}

	// Units being trained now
	if (bIncludeBeingTrained)
	{
		CvCity* pLoopCity;
		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if (pLoopCity->isProductionUnit())
			{
				CvUnitEntry* pkUnitEntry = GC.getUnitInfo(pLoopCity->getProductionUnit());
				if (pkUnitEntry)
				{
					if (pLoopCity->getProductionUnit() == eUnit)
					{
						iNumUnits++;
					}
				}
			}
		}
	}

	return iNumUnits;
}

//	-----------------------------------------------------------------------------------------------
void CvPlayer::UpdateDangerPlots(bool bKeepKnownUnits)
{
	m_pDangerPlots->UpdateDanger(bKeepKnownUnits);
}

//	-----------------------------------------------------------------------------------------------
void CvPlayer::SetDangerPlotsDirty()
{
	m_pDangerPlots->SetDirty();
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isHuman() const
{
	if(GetID() == NO_PLAYER)
	{
		return false;
	}

	return CvPreGame::isHuman(GetID());
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isObserver() const
{
	if(GetID() == NO_PLAYER)
	{
		return false;
	}

	return CvPreGame::slotStatus(GetID()) == SS_OBSERVER;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isBarbarian() const
{
	return (GetID() == BARBARIAN_PLAYER);
}

//	--------------------------------------------------------------------------------
void CvPlayer::doBarbarianRansom(int iOption, int iUnitID)
{
	CvUnit* pUnit = getUnit(iUnitID);

	// Pay the Price
	if(iOption == 0)
	{
		int iNumGoldStolen = GC.getBARBARIAN_UNIT_GOLD_RANSOM();	// 100

		if(iNumGoldStolen > GetTreasury()->GetGold())
		{
			iNumGoldStolen = GetTreasury()->GetGold();
		}

		// Unit is ransomed for Gold
		GetTreasury()->ChangeGold(-iNumGoldStolen);
	}
	// Leave them to the Barbs
	else if(iOption == 1)
	{
		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->AddUnitMessage(0, pUnit->GetIDInfo(), GetID(), true, GC.getEVENT_MESSAGE_TIME(), 
				GetLocalizedText("TXT_KEY_MISC_YOU_UNIT_RANSOM_KILL_BY_BARBARIANS", pUnit->getNameKey()));
		}

		pUnit->kill(true, BARBARIAN_PLAYER);
	}
}

//	-----------------------------------------------------------------------------------------------
const char* CvPlayer::getName() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->GetDescription();
	}

	if(GC.getGame().isMPOption(MPOPTION_ANONYMOUS) && isAlive() && GC.getGame().getGameState() == GAMESTATE_ON)
	{
		return getLeaderInfo().GetDescription();
	}

	if(GC.getGame().isGameMultiPlayer() && isHuman())
	{
		const CvString& szDisplayName = CvPreGame::nicknameDisplayed(GetID());
		if(szDisplayName.GetLength())
			return szDisplayName.c_str();
	}
	
	const CvString& szPlayerName = CvPreGame::leaderName(GetID());
	if(szPlayerName.GetLength() == 0)
	{
		return getLeaderInfo().GetDescription();
	}

	return szPlayerName.c_str();
}

//	-----------------------------------------------------------------------------------------------
const char* CvPlayer::getNameKey() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->GetTextKey();
	}

	if(GC.getGame().isMPOption(MPOPTION_ANONYMOUS) && isAlive())
	{
		return getLeaderInfo().GetTextKey();
	}

	if(GC.getGame().isGameMultiPlayer() && isHuman())
	{
		// No, this won't be a 'key', but it should just pass through the lookup code and display as is.
		const CvString& szDisplayName = CvPreGame::nicknameDisplayed(GetID());
		if(szDisplayName.GetLength())
			return szDisplayName.c_str();
	}

	const CvString& szPlayerName = CvPreGame::leaderNameKey(GetID());
	if(szPlayerName.GetLength() == 0)
	{
		return getLeaderInfo().GetTextKey();
	}

	return szPlayerName.c_str();
}


//	--------------------------------------------------------------------------------
const char* CvPlayer::getCivilizationDescription() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->GetDescription();
	}
	else if(CvPreGame::civilizationDescription(GetID()).GetLength() == 0)
	{
		return GC.getCivilizationInfo(getCivilizationType()) ? getCivilizationInfo().GetDescription() : "unknown";
	}
	else
	{
		return CvPreGame::civilizationDescription(GetID()).c_str();
	}
}


//	--------------------------------------------------------------------------------
const char* CvPlayer::getCivilizationDescriptionKey() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->GetTextKey();
	}
	else if(CvPreGame::civilizationDescriptionKey(GetID()).GetLength() == 0)
	{
		return GC.getCivilizationInfo(getCivilizationType()) ? getCivilizationInfo().GetTextKey() : "TXT_UNKNOWN";
	}
	else
	{
		return CvPreGame::civilizationDescriptionKey(GetID()).c_str();
	}
}


//	--------------------------------------------------------------------------------
const char* CvPlayer::getCivilizationShortDescription() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->getShortDescription();
	}
	else if(CvPreGame::civilizationShortDescription(GetID()).GetLength() == 0)
	{
		return GC.getCivilizationInfo(getCivilizationType()) ? getCivilizationInfo().getShortDescription() : "unknown";
	}
	else
	{
		return CvPreGame::civilizationShortDescription(GetID()).c_str();
	}
}


//	--------------------------------------------------------------------------------
const char* CvPlayer::getCivilizationShortDescriptionKey() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->getShortDescriptionKey();
	}
	else if(CvPreGame::civilizationShortDescriptionKey(GetID()).GetLength() == 0)
	{
		return GC.getCivilizationInfo(getCivilizationType()) ? getCivilizationInfo().getShortDescriptionKey() : "TXT_UNKNOWN";
	}
	else
	{
		return CvPreGame::civilizationShortDescriptionKey(GetID()).c_str();
	}
}


//	--------------------------------------------------------------------------------
const char* CvPlayer::getCivilizationAdjective() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->getAdjective();
	}
	else if(CvPreGame::civilizationAdjective(GetID()).GetLength() == 0)
	{
		return GC.getCivilizationInfo(getCivilizationType()) ? getCivilizationInfo().getAdjective() : "unknown";
	}
	else
	{
		return CvPreGame::civilizationAdjective(GetID()).c_str();
	}
}

//	--------------------------------------------------------------------------------
const char* CvPlayer::getCivilizationAdjectiveKey() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->getAdjectiveKeyWide();
	}
	else if(CvPreGame::civilizationAdjectiveKey(GetID()).GetLength() == 0)
	{
		return GC.getCivilizationInfo(getCivilizationType()) ? getCivilizationInfo().getAdjectiveKey() : "TXT_UNKNOWN";
	}
	else
	{
		return CvPreGame::civilizationAdjectiveKey(GetID()).c_str();
	}
}

//	--------------------------------------------------------------------------------
const char* CvPlayer::getCivilizationTypeKey() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->GetType();
	}
	else
	{
		return getCivilizationInfo().GetType();
	}
}

//	--------------------------------------------------------------------------------
const char* CvPlayer::getLeaderTypeKey() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->GetType();
	}
	else
	{
		return getLeaderInfo().GetType();
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isWhiteFlag() const
{
	return CvPreGame::isWhiteFlag(GetID());
}


//	--------------------------------------------------------------------------------
const char* CvPlayer::GetStateReligionName() const
{
	return GetLocalizedText(m_strReligionKey.get());
}

//	--------------------------------------------------------------------------------
CvString CvPlayer::GetStateReligionKey() const
{
	return m_strReligionKey.get();
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetStateReligionKey(const char* strKey)
{
	m_strReligionKey = strKey;
}


//	--------------------------------------------------------------------------------
const CvString CvPlayer::getWorstEnemyName() const
{
	TeamTypes eWorstEnemy;

	eWorstEnemy = NO_TEAM;

	if(eWorstEnemy != NO_TEAM)
	{
		return GET_TEAM(eWorstEnemy).getName();
	}

	return "";
}


//	--------------------------------------------------------------------------------
ArtStyleTypes CvPlayer::getArtStyleType() const
{
	if(CvPreGame::artStyle(GetID()) == NO_ARTSTYLE)
	{
		return ((ArtStyleTypes)(getCivilizationInfo().getArtStyleType()));
	}
	else
	{
		return CvPreGame::artStyle(GetID());
	}
}

//	---------------------------------------------------------------------------
void CvPlayer::doTurn()
{
	// Time building of these maps
	AI_PERF_FORMAT("AI-perf.csv", ("CvPlayer::doTurn(), Turn %d, %s", GC.getGame().getGameTurn(), getCivilizationShortDescription()));

	CvAssertMsg(isAlive(), "isAlive is expected to be true");

	//cache reset
	m_iNumUnitsSuppliedCached = -1;

	AI_doTurnPre();

	if(getCultureBombTimer() > 0)
		changeCultureBombTimer(-1);

	if(getConversionTimer() > 0)
		changeConversionTimer(-1);

	if(GetTurnsSinceSettledLastCity() >= 0)
		ChangeTurnsSinceSettledLastCity(1);

	setConscriptCount(0);
#if defined(MOD_BALANCE_CORE)
	if (MOD_DIPLOMACY_CIV4_FEATURES)
		DoVassalLevy();

	SetHasUUPeriod();

	if(MOD_BALANCE_CORE_JFD)
	{
		GetContracts()->DoTurn();
	}
	GET_TEAM(getTeam()).updateTeamStatus();
	UpdateBestMilitaryCities();
	
	if(GetFaithPurchaseCooldown() > 0)
	{
		ChangeFaithPurchaseCooldown(-1);
	}
	if(MOD_BALANCE_CORE && !isMinorCiv() && !isBarbarian())
	{
		for (int i = 0; i < NUM_DOMAIN_TYPES; i++)
		{
			DoDiversity((DomainTypes)i);
		}

		RefreshCSAlliesFriends();
		UpdateHappinessFromMinorCivs();
#endif
		DoUpdateCramped();

		DoUpdateUprisings();
		DoUpdateCityRevolts();
		CalculateNetHappiness();
		SetBestWonderCities();

		const CvCivilizationInfo& playerCivilizationInfo = GET_PLAYER(GetID()).getCivilizationInfo();
		for (int iI = 0; iI < GC.getNumUnitClassInfos(); ++iI)
		{
			const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
			CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
			if (pkUnitClassInfo != NULL)
			{
				const UnitTypes eUnit = ((UnitTypes)(playerCivilizationInfo.getCivilizationUnits(iI)));
				if (NO_UNIT != eUnit)
				{
					CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
#if defined(MOD_BALANCE_CORE_SETTLER_ADVANCED)
					if (pkUnitInfo != NULL && pkUnitInfo->IsFoundLate())
					{
						if (pkUnitInfo->IsFoodProduction())
						{
							setUnitExtraCost(eUnitClass, getNewCityProductionValue() * (GetCurrentEra() + 2));
						}
					}
					else if (pkUnitInfo != NULL && pkUnitInfo->IsFoundMid())
					{
						if (pkUnitInfo->IsFoodProduction())
						{
							setUnitExtraCost(eUnitClass, getNewCityProductionValue() * (GetCurrentEra() + 1));
						}
					}
					else
					{
#endif
						if (NULL != pkUnitInfo && pkUnitInfo->IsFound())
						{
							setUnitExtraCost(eUnitClass, getNewCityProductionValue());
						}
					}
				}
			}
		}

#if defined(MOD_BALANCE_CORE_HAPPINESS)
		if(MOD_BALANCE_CORE_HAPPINESS)
		{
			if(GC.getLogging() && GC.getAILogging())
			{
				CvString playerName;
				FILogFile* pLog;
				CvString strBaseString;
				CvString strOutBuf;
				CvString strFileName = "PlayerHappinessStats.csv";
				playerName = getCivilizationShortDescription();
				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				strBaseString += playerName + ", ";
				strOutBuf.Format("Approval: %d, GoldU: %d, DefenseU: %d, ScienceU: %d, CultureU: %d, War Weariness: %d, Supply: %d, Use: %d", 
					GetExcessHappiness() , getUnhappinessFromCityGold(), getUnhappinessFromCityDefense(), getUnhappinessFromCityScience(), 
					getUnhappinessFromCityCulture(), GetUnhappinessFromWarWeariness(), GetNumUnitsSupplied(), GetNumUnitsToSupply());
				strBaseString += strOutBuf;
				pLog->Msg(strBaseString);
			}
		}
#endif
#if defined(MOD_BALANCE_CORE)
		//Reset every turn for CS events.
		for(int iQuestLoop = 0; iQuestLoop < NUM_MINOR_CIV_QUEST_TYPES; iQuestLoop++)
		{
			SetGlobalTourismAlreadyReceived((MinorCivQuestTypes)iQuestLoop, 0);
		}

		GetCorporations()->DoTurn();
	
		//Reset for reevaluation of citystrategy AI
		countCitiesNeedingTerrainImprovements(true);
#endif
#if defined(MOD_BALANCE_CORE_AFRAID_ANNEX)
		if(MOD_BALANCE_CORE_AFRAID_ANNEX)
		{
			if(GetPlayerTraits()->IsBullyAnnex() && !IsEmpireVeryUnhappy() && !isHuman())
			{
				for(int iPlayerLoop = MAX_MAJOR_CIVS; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
				{
					PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
					if(GET_PLAYER(eLoopPlayer).isMinorCiv() && GET_PLAYER(eLoopPlayer).isAlive())
					{
						if(GET_PLAYER(eLoopPlayer).GetMinorCivAI()->CanMajorBullyUnit(GetID()))
						{
							GC.getGame().DoMinorBullyUnit(GetID(), eLoopPlayer);
						}
					}
				}
			}
		}
#endif
		if(GetPlayerTraits()->IsEndOfMayaLongCount())
		{
			ChangeNumMayaBoosts(1);
		}
#if defined(MOD_BALANCE_CORE)
		if(GetPlayerTraits()->IsTradeRouteMinorInfluenceAdmiralPoints())
		{
			DoTradeInfluenceAP();
		}
	}
#endif
	bool bHasActiveDiploRequest = false;
	if(isAlive())
	{
		if(!isBarbarian())
		{
			if(!isMinorCiv())
			{
				GetTrade()->DoTurn();
				GetMilitaryAI()->ResetCounters();
				GetGrandStrategyAI()->DoTurn();
#if defined(MOD_ACTIVE_DIPLOMACY)
				if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
				{
					GetDiplomacyAI()->DoTurn(DIPLO_AI_PLAYERS);
				}
				else
				{
					if(GC.getGame().isHotSeat() && !isHuman())
					{
						// In Hotseat, AIs only do their diplomacy pass for other AIs on their turn
						// Diplomacy toward a human is done at the beginning of the humans turn.
						GetDiplomacyAI()->DoTurn(DIPLO_AI_PLAYERS);		// Do diplomacy for toward everyone
					}
					else
						GetDiplomacyAI()->DoTurn(DIPLO_ALL_PLAYERS);	// Do diplomacy for toward everyone

					if (!isHuman())
						bHasActiveDiploRequest = CvDiplomacyRequests::HasActiveDiploRequestWithHuman(GetID());
				}
#else
				if(GC.getGame().isHotSeat() && !isHuman())
				{
					// In Hotseat, AIs only do their diplomacy pass for other AIs on their turn
					// Diplomacy toward a human is done at the beginning of the humans turn.
					GetDiplomacyAI()->DoTurn(CvDiplomacyAI::DIPLO_AI_PLAYERS);		// Do diplomacy for toward everyone
				}
				else
					GetDiplomacyAI()->DoTurn(CvDiplomacyAI::DIPLO_ALL_PLAYERS);	// Do diplomacy for toward everyone

				if (!isHuman())
					bHasActiveDiploRequest = CvDiplomacyRequests::HasActiveDiploRequestWithHuman(GetID());
#endif
			}
		}
	}
#if defined(MOD_BALANCE_CORE)
	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
		if (eResourceLoop != NO_RESOURCE)
		{
			DoTestOverResourceNotification(eResourceLoop);
		}
	}
#endif

	if(isHuman() && !GC.getGame().isGameMultiPlayer())
		checkArmySizeAchievement();

	if( (bHasActiveDiploRequest || GC.GetEngineUserInterface()->isDiploActive()) && !GC.getGame().isGameMultiPlayer() && !isHuman())
	{
		GC.getGame().SetWaitingForBlockingInput(m_eID);
	}
	else
	{
#if defined(MOD_BALANCE_CORE)
		UpdateCityThreatCriteria();
#endif
		doTurnPostDiplomacy();
	}
#if defined(MOD_BALANCE_CORE)
	if(MOD_BALANCE_CORE_JFD)
	{
		DoPiety();
		DoReformCooldown();
		DoGovernmentCooldown();
	}
#endif
#if defined(MOD_BALANCE_CORE_EVENTS)
	if(MOD_BALANCE_CORE_EVENTS)
	{
		if(GC.getGame().isOption(GAMEOPTION_EVENTS))
		{
			DoEvents();
		}
	}
#endif
#if defined(MOD_BALANCE_CORE)
	for (int iInstantYield = 0; iInstantYield < NUM_INSTANT_YIELD_TYPES; iInstantYield++)
	{
		InstantYieldType eInstantYield = (InstantYieldType)iInstantYield;
		if(eInstantYield != NO_INSTANT_YIELD_TYPE && getInstantYieldText(eInstantYield) != "" && getInstantYieldText(eInstantYield) != NULL)
		{
			// Instant yield
			Localization::String strInstantYield = Localization::Lookup(getInstantYieldText(eInstantYield));
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_INSTANT_YIELD_EMPIRE");
				pNotifications->Add((NotificationTypes)FString::Hash("NOTIFICATION_INSTANT_YIELD"), strInstantYield.toUTF8(), strSummary.toUTF8(), -1, -1, GetID());
			}
			setInstantYieldText(eInstantYield, "");
			// Instant great person progress
			Localization::String strInstantGreatPersonProgress = Localization::Lookup(getInstantGreatPersonProgressText(eInstantYield));
			/*if (pNotifications) // Can't get this to work correctly for some reason
			{
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_GREAT_PERSON_PROGRESS_EMPIRE");
				pNotifications->Add((NotificationTypes)FString::Hash("NOTIFICATION_INSTANT_YIELD"), strInstantGreatPersonProgress.toUTF8(), strSummary.toUTF8(), -1, -1, GetID());
			}*/
			setInstantGreatPersonProgressText(eInstantYield, "");
		}
	}
#endif

	//note that this isn't actually the end of the turn - AI_unitUpdate is called later
	AI_doTurnPost();

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());

		bool bResult;
		LuaSupport::CallHook(pkScriptSystem, "PlayerDoTurn", args.get(), bResult);
	}

	m_kPlayerAchievements.StartTurn();
}

//	--------------------------------------------------------------------------------
void CvPlayer::doTurnPostDiplomacy()
{
	CvGame& kGame = GC.getGame();

	if(isAlive())
	{
		{
			AI_PERF_FORMAT("AI-perf.csv", ("Plots/Danger, Turn %03d, %s", kGame.getElapsedGameTurns(), getCivilizationShortDescription()) );

			UpdatePlots();
			UpdateDangerPlots(false);
			GetTacticalAI()->GetTacticalAnalysisMap()->Refresh(true);
			UpdateMilitaryStats();
			UpdateAreaEffectUnits();
			UpdateAreaEffectPlots();
			GET_TEAM(getTeam()).ClearWarDeclarationCache();
			UpdateCurrentAndFutureWars();
		}

		if(!isBarbarian())
		{
			GetEconomicAI()->DoTurn();
			GetMilitaryAI()->DoTurn();
#if defined(MOD_BALANCE_CORE)
			if(MOD_BALANCE_CORE && !isMinorCiv())
			{
#endif
			GetReligionAI()->DoTurn();
			GetTradeAI()->DoTurn();
			GetCitySpecializationAI()->DoTurn();
			GetLeagueAI()->DoTurn();
#if defined(MOD_BALANCE_CORE)
			}
#endif
		}
		else
		{
			CvBarbarians::DoCampSpawnCounter();
			CvBarbarians::DoCamps();
			CvBarbarians::DoUnits();
		}

		if(isMinorCiv())
		{
			GetMinorCivAI()->DoTurn();
		}
	}

	// Temporary boosts
	if(GetAttackBonusTurns() > 0)
	{
		ChangeAttackBonusTurns(-1);
	}
	if(GetCultureBonusTurns() > 0)
	{
		ChangeCultureBonusTurns(-1);
	}
	if(GetTourismBonusTurns() > 0)
	{
		ChangeTourismBonusTurns(-1);
	}
#if defined(MOD_BALANCE_CORE)
	if(GetCultureBonusTurnsConquest() > 0)
	{
		ChangeCultureBonusTurnsConquest(-1);
	}
	if (GetProductionBonusTurnsConquest() > 0)
	{
		ChangeProductionBonusTurnsConquest(-1);
	}
#endif

#if defined(MOD_DIPLOMACY_CITYSTATES)
	if(MOD_DIPLOMACY_CITYSTATES && (!isMinorCiv() && !isBarbarian()))
	{
		DoProcessVotes();
		ProcessLeagueResolutions();
	}
#endif
#if defined(MOD_BALANCE_CORE_YIELDS)
	if(MOD_BALANCE_CORE_YIELDS)
	{
		DoChangeGreatGeneralRate();
		DoChangeGreatAdmiralRate();
	}
#endif

	// Golden Age
	DoProcessGoldenAge();

	// Great People gifts from Allied City States (if we have that policy)
	DoGreatPeopleSpawnTurn();

	// Do turn for all Cities
	{
		AI_PERF_FORMAT("AI-perf.csv", ("Do City Turns, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), getCivilizationShortDescription()) );
		if(getNumCities() > 0)
		{
			int iLoop = 0;
			for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				pLoopCity->doTurn();
			}
		}
	}

	// Gold
	GetTreasury()->DoGold();

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	// Tax out from after we've calculated our gold for this turn
	GetTreasury()->CalculateExpensePerTurnFromVassalTaxes();
#endif
	// Culture

	// Prevent exploits in turn timed MP games - no accumulation of culture if player hasn't picked yet
	GetCulture()->SetLastTurnCPT(GetJONSCultureEverGenerated() - GetCulture()->GetLastTurnLifetimeCulture());
	GetCulture()->SetLastTurnLifetimeCulture(GetJONSCultureEverGenerated());
	if(kGame.isOption(GAMEOPTION_END_TURN_TIMER_ENABLED))
	{
		if(getJONSCulture() < getNextPolicyCost())
			changeJONSCulture(GetTotalJONSCulturePerTurn());
	}
	else
	{
		changeJONSCulture(GetTotalJONSCulturePerTurn());
	}

	// Compute the cost of policies for this turn
	DoUpdateNextPolicyCost();

	// if this is the human player, have the popup come up so that he can choose a new policy
	if(isAlive() && isHuman() && getNumCities() > 0)
	{
		if(!GC.GetEngineUserInterface()->IsPolicyNotificationSeen())
		{
			if(getNextPolicyCost() <= getJONSCulture() && GetPlayerPolicies()->GetNumPoliciesCanBeAdopted() > 0)
			{
				CvNotifications* pNotifications = GetNotifications();
				if(pNotifications)
				{
					CvString strBuffer;

					if(kGame.isOption(GAMEOPTION_POLICY_SAVING))
						strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_ENOUGH_CULTURE_FOR_POLICY_DISMISS");
					else
						strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_ENOUGH_CULTURE_FOR_POLICY");

					CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_ENOUGH_CULTURE_FOR_POLICY");
					pNotifications->Add(NOTIFICATION_POLICY, strBuffer, strSummary, -1, -1, -1);
				}
			}
		}

		if (GetPlayerPolicies()->IsTimeToChooseIdeology() && GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
		{
#if defined(MOD_BALANCE_CORE)
			if(GetPlayerTraits()->IsAdoptionFreeTech())
			{
				CvString strBuffer = GetLocalizedText("TXT_KEY_MISC_CHOSE_IDEOLOGY_UA_CHOOSE_TECH");
				chooseTech(1, strBuffer.GetCString());
			}
#endif
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				CvString strBuffer;
#if defined(MOD_CONFIG_GAME_IN_XML)
				if (GetCurrentEra() > GD_INT_GET(IDEOLOGY_START_ERA))
#else
				if (GetCurrentEra() > GC.getInfoTypeForString("ERA_INDUSTRIAL"))
#endif
				{
					strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_CHOOSE_IDEOLOGY_ERA");
				}
				else
				{
					strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_CHOOSE_IDEOLOGY_FACTORIES");
				}
				CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_CHOOSE_IDEOLOGY");
				pNotifications->Add(NOTIFICATION_CHOOSE_IDEOLOGY, strBuffer, strSummary, -1, -1, GetID());
			}
		}
	}

	if (isAlive() && getNumCities() > 0 && !isHuman() && !isMinorCiv())
	{
		if (GetPlayerPolicies()->IsTimeToChooseIdeology() && GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
		{
#if defined(MOD_BALANCE_CORE)
			if(GetPlayerTraits()->IsAdoptionFreeTech())
			{
				AI_chooseFreeTech();
			}
#endif
			AI_PERF_FORMAT("AI-perf.csv", ("DoChooseIdeology, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), getCivilizationShortDescription()) );
			GetPlayerPolicies()->DoChooseIdeology();
		}
	}

	if (!isBarbarian() && !isHuman() && !isMinorCiv())
	{
		AI_PERF_FORMAT("AI-perf.csv", ("DoPolicyAI, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), getCivilizationShortDescription()) );
		GetPlayerPolicies()->DoPolicyAI();
	}

	// Science
	doResearch();

	GetEspionage()->DoTurn();
#if defined(MOD_BALANCE_CORE)
	if(MOD_BALANCE_CORE && !isMinorCiv())
	{
#endif
	// Faith
	CvGameReligions* pGameReligions = kGame.GetGameReligions();
	pGameReligions->DoPlayerTurn(*this);

	// Leagues
	CvGameLeagues* pGameLeagues = kGame.GetGameLeagues();
	pGameLeagues->DoPlayerTurn(*this);

	// Anarchy counter
	if(GetAnarchyNumTurns() > 0)
		ChangeAnarchyNumTurns(-1);
#if defined(MOD_BALANCE_CORE)
	}
#endif
	DoIncomingUnits();

	const int iGameTurn = kGame.getGameTurn();

	GatherPerTurnReplayStats(iGameTurn);

	GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
}

//	--------------------------------------------------------------------------------
void CvPlayer::doTurnUnits()
{
	AI_doTurnUnitsPre();

	// Start: old unit AI processing
	for(int iPass = 0; iPass < 4; iPass++)
	{
		int iLoop;
		for(CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		{
			switch(pLoopUnit->getDomainType())
			{
			case DOMAIN_AIR:
				if(iPass == 1)
				{
					pLoopUnit->doTurn();
				}
				break;
			case DOMAIN_SEA:
				if(iPass == 2)
				{
					pLoopUnit->doTurn();
				}
				break;
			case DOMAIN_LAND:
				if(iPass == 3)
				{
					pLoopUnit->doTurn();
				}
				break;
			case DOMAIN_IMMOBILE:
				if(iPass == 0)
				{
					pLoopUnit->doTurn();
				}
				break;
			case NO_DOMAIN:
				CvAssertMsg(false, "Unit with no Domain");
				break;
			default:
				if(iPass == 3)
				{
					pLoopUnit->doTurn();
				}
				break;
			}
		}
	}

	if(GetID() == GC.getGame().getActivePlayer())
	{
		GC.GetEngineUserInterface()->setDirty(Waypoints_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(SelectionButtons_DIRTY_BIT, true);
	}

	GC.GetEngineUserInterface()->setDirty(UnitInfo_DIRTY_BIT, true);

	AI_doTurnUnitsPost();
}

//	--------------------------------------------------------------------------------
/// Indicate that the AI has not processed any units yet
void CvPlayer::SetAllUnitsUnprocessed()
{
	int iLoop;
	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		pLoopUnit->SetTurnProcessed(false);

#if defined(MOD_CORE_CACHE_REACHABLE_PLOTS)
		pLoopUnit->ClearReachablePlots();
#endif

#if defined(MOD_CORE_PER_TURN_DAMAGE)
		pLoopUnit->flipDamageReceivedPerTurn();
#endif
	}

#if defined(MOD_CORE_PER_TURN_DAMAGE)
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->flipDamageReceivedPerTurn();
	}
#endif
}

//	--------------------------------------------------------------------------------
/// Units heal and then get their movement back
void CvPlayer::DoUnitReset()
{
	//some statistics
	static int tactMovesCount[NUM_AI_TACTICAL_MOVES] = { 0 };
	static int homeMovesCount[NUM_AI_HOMELAND_MOVES] = { 0 };

	int iLoop;
	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		// First heal the unit
		pLoopUnit->doHeal();

		//collect some stats
		gTactMovesCount[pLoopUnit->getTacticalMove()]++;
		gHomeMovesCount[pLoopUnit->getHomelandMove()]++;

		// Sanity check
		if (pLoopUnit->IsGreatGeneral() && pLoopUnit->GetDanger() == INT_MAX && pLoopUnit->plot()->getNumUnits()==1)
			OutputDebugString( CvString::format("ouch, general about to be captured at %d:%d!\n",pLoopUnit->getX(),pLoopUnit->getY()).c_str());

		// then damage it again
		int iCitadelDamage = pLoopUnit->plot()->GetDamageFromAdjacentPlots(pLoopUnit->getOwner());
		if (iCitadelDamage != 0 && !pLoopUnit->isInvisible(NO_TEAM, false, false))
		{
			
			pLoopUnit->changeDamage(iCitadelDamage, NO_PLAYER, /*fAdditionalTextDelay*/ 0.5f);
#if defined(MOD_CORE_PER_TURN_DAMAGE)
			pLoopUnit->addDamageReceivedThisTurn(iCitadelDamage);
#endif
		}

		// Bonus for entrenched units
		if (!pLoopUnit->hasMoved() && pLoopUnit->canFortify(pLoopUnit->plot()))
			pLoopUnit->SetFortified(true);

		// Finally (now that healing is done), restore movement points
		pLoopUnit->restoreFullMoves();

		// Archaeologist can't move on turn he finishes a dig (while waiting for user to decide his next action)
		if (pLoopUnit->AI_getUnitAIType() == UNITAI_ARCHAEOLOGIST)
		{
			CvPlayer &kPlayer = GET_PLAYER(pLoopUnit->getOwner());
			if (kPlayer.GetCulture()->HasDigCompleteHere(pLoopUnit->plot()))
			{
				pLoopUnit->finishMoves();
			}
		}

		pLoopUnit->setMadeAttack(false);
		pLoopUnit->resetInterceptionCount();

		if(!isHuman())
		{
			const MissionData* pkMissionData = pLoopUnit->GetHeadMissionData();
			if(pkMissionData)
			{
				if(pkMissionData->eMissionType == CvTypes::getMISSION_RANGE_ATTACK() ||
				        pkMissionData->eMissionType == CvTypes::getMISSION_AIRSTRIKE() ||
				        pkMissionData->eMissionType == CvTypes::getMISSION_AIR_SWEEP() ||
				        pkMissionData->eMissionType == CvTypes::getMISSION_NUKE())
				{
					CvAssertMsg(0, "An AI unit has a combat mission queued at the end of its turn.");
					pLoopUnit->ClearMissionQueue();	// Clear the whole thing, the AI will re-evaluate next turn.
				}
			}
		}
	}
}

void CvPlayer::ResetReachablePlotsForAllUnits()
{
	int iLoop;
	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		pLoopUnit->ClearReachablePlots();
}


//	--------------------------------------------------------------------------------
/// Damage units from attrition (start of turn so we can get notifications)
void CvPlayer::DoUnitAttrition()
{
	int iLoop;
	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		pLoopUnit->DoAttrition();
}

//	--------------------------------------------------------------------------------
void CvPlayer::RepositionInvalidUnits()
{
	int iLoop;
	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->isDelayedDeath())
		{
			continue;
		}

		if(pLoopUnit->isCargo())
		{
			continue;
		}

		if(pLoopUnit->isInCombat())
		{
			continue;
		}

		CvPlot* pPlot = pLoopUnit->plot();
		if(!pPlot)
		{
			continue;
		}

		if (!pPlot->CanStackUnitHere(pLoopUnit))
		{
			if (!pLoopUnit->jumpToNearestValidPlot())
				pLoopUnit->kill(false);	// Could not find a valid location!
		}
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::updateYield()
{
	// This will go through all of the plots and update the yield if the player owns it.
	// The plot will not contribute to the player's yield unless it is worked by a city.
	// Previously this would just go through all the plots the city can work (3 rings around it)
	// but all plots have their yields updated on load and not updating them here could lead to 
	// a visual discrepancy.
	CvMap& kMap = GC.getMap();
	int iNumPlots = kMap.numPlots();
	PlayerTypes ePlayer = GetID();
	for (int iI = 0; iI < iNumPlots; iI++)
	{
		CvPlot* pkPlot = kMap.plotByIndexUnchecked(iI);
		if (pkPlot->getOwner() == ePlayer)
			pkPlot->updateYield();
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::updateExtraSpecialistYield()
{
	int iLoop;
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->updateExtraSpecialistYield();
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::updateCityPlotYield()
{
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->plot()->updateYield();
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::updateCitySight(bool bIncrement)
{
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->plot()->updateSight(bIncrement);
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::UpdateNotifications()
{
	if(GetNotifications())
	{
		GetNotifications()->Update();
	}

	if(GetDiplomacyRequests())
	{
		GetDiplomacyRequests()->Update();
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::UpdateReligion()
{
	CalculateNetHappiness();

#if defined(MOD_BALANCE_CORE)
	int iLoop;
	CvCity* pLoopCity;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
		{
			YieldTypes eYield = (YieldTypes)iI;
			if(eYield == NO_YIELD)
				continue;

			pLoopCity->UpdateSpecialReligionYields(eYield);
		}
	}
	GC.getGame().GetGameReligions()->DoUpdateReligion(GetID());
#endif
}

//	--------------------------------------------------------------------------------
void CvPlayer::updateTimers()
{
	int iLoop;
	m_endTurnBusyUnitUpdatesLeft--;

	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
		pLoopUnit->UpdateMission();

	//unit cleanup - this should probably also be done in a two-pass scheme like below
	//but since it's too involved to change that now, we do the ugly loop to make sure we didn't skip a unit
	bool bKilledAtLeastOne = false;
	bool bKilledOneThisPass = false;
	do
	{
		bKilledOneThisPass = false;
		for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
			bKilledOneThisPass |= pLoopUnit->doDelayedDeath();
		bKilledAtLeastOne |= bKilledOneThisPass;
	} while (bKilledOneThisPass);

#if defined(MOD_CORE_DELAYED_VISIBILITY)
	//force explicit visibility update for killed units (but not if the player is currently active) 
	if (bKilledAtLeastOne && GetID()!=GC.getGame().getActivePlayer())
		for (int iI = 0; iI < GC.getMap().numPlots(); iI++)
			GC.getMap().plotByIndexUnchecked(iI)->flipVisibility(getTeam());
#endif

	GetDiplomacyAI()->update();
}

//	--------------------------------------------------------------------------------
bool CvPlayer::hasPromotableUnit() const
{
	const CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->isPromotionReady() && !pLoopUnit->isDelayedDeath())
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::hasReadyUnit() const
{
	const CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->ReadyToMove() && !pLoopUnit->isDelayedDeath())
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetCountReadyUnits() const
{
	int iRtnValue = 0;
	const CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->ReadyToMove() && !pLoopUnit->isDelayedDeath() && !pLoopUnit->TurnProcessed())
		{
			iRtnValue++;
		}
	}

	return iRtnValue;
}

//	--------------------------------------------------------------------------------
const CvUnit* CvPlayer::GetFirstReadyUnit() const
{
	const CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->ReadyToMove() && !pLoopUnit->isDelayedDeath() && !pLoopUnit->TurnProcessed())
		{
			return pLoopUnit;
		}
	}

	return NULL;
}

//	--------------------------------------------------------------------------------
void CvPlayer::EndTurnsForReadyUnits()
{
	CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->ReadyToMove() && !pLoopUnit->isDelayedDeath() && !pLoopUnit->TurnProcessed())
		{
			pLoopUnit->PushMission(CvTypes::getMISSION_SKIP());
			pLoopUnit->SetTurnProcessed(true);
#if defined(MOD_BALANCE_CORE)
			if(GC.getLogging() && GC.getAILogging())
			{
				CvString strCiv = GET_PLAYER(pLoopUnit->getOwner()).getCivilizationAdjective();
				CvString strLogString;
				strLogString.Format("Warning: Forcing turn end for %s %s at %d,d", strCiv.c_str(), pLoopUnit->getName().c_str(), pLoopUnit->getX(), pLoopUnit->getY() );
				GetHomelandAI()->LogHomelandMessage(strLogString);
			}
#endif
		}
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::hasAutoUnit() const
{
	const CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->ReadyToAuto())
		{
			return true;
		}
	}

	return false;
}

//	----------------------------------------------------------------------------
bool CvPlayer::hasBusyUnit() const
{
	const CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->IsBusy())
		{
			return true;
		}
	}

	return false;
}

//	----------------------------------------------------------------------------
bool CvPlayer::hasBusyCity() const
{
	const CvCity* pLoopCity;
	int iLoop;

	for(pLoopCity = firstCity(&iLoop); pLoopCity; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity->IsBusy())
		{
			return true;
		}
	}

	return false;
}

//	----------------------------------------------------------------------------
const CvCity* CvPlayer::getBusyCity() const
{
	const CvCity* pLoopCity;
	int iLoop;

	for(pLoopCity = firstCity(&iLoop); pLoopCity; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity->IsBusy())
		{
			return pLoopCity;
		}
	}

	return false;
}

//	----------------------------------------------------------------------------
bool CvPlayer::hasBusyUnitOrCity() const
{
	if(hasBusyUnit())
		return true;
	return hasBusyCity();
}

//	--------------------------------------------------------------------------------
const CvUnit* CvPlayer::getBusyUnit() const
{
	const CvUnit* result = NULL;
	int iLoop;
	for(const CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->IsBusy())
		{
			result = pLoopUnit;
		}
	}
	return result;
}


//	--------------------------------------------------------------------------------
void CvPlayer::chooseTech(int iDiscover, const char* strText, TechTypes iTechJustDiscovered)
{
	if(GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))
	{
		return;
	}

	if(iDiscover > 0)
	{
		SetNumFreeTechs(GetNumFreeTechs()+iDiscover);
	}

	if(iDiscover > 0)
	{
		CvNotifications* pNotifications = GetNotifications();
		if(pNotifications)
		{
			pNotifications->Add(NOTIFICATION_FREE_TECH, strText, strText, -1, -1, iDiscover, iTechJustDiscovered);
		}
	}
	else if(strText == 0 || strText[0] == 0)
	{
		CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_NEW_RESEARCH");
		CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_NEW_RESEARCH");
		CvNotifications* pNotifications = GetNotifications();
		if(pNotifications)
		{
			pNotifications->Add(NOTIFICATION_TECH, strBuffer, strSummary, -1, -1, iDiscover, iTechJustDiscovered);
		}
	}
	else
	{
		CvNotifications* pNotifications = GetNotifications();
		if(pNotifications)
		{
			pNotifications->Add(NOTIFICATION_TECH, strText, strText, -1, -1, iDiscover, iTechJustDiscovered);
		}
	}
}

//////////////////////////////////////////////////////////////////////////
// Civ 5 Score
//////////////////////////////////////////////////////////////////////////

//	--------------------------------------------------------------------------------
/// What is this player's score?
int CvPlayer::GetScore(bool bFinal, bool bWinner) const
{
	if(!isAlive())
		return 0;

	if(GET_TEAM(getTeam()).getNumMembers() == 0)
		return 0;

	int iScore = 0;

	//iScore += GetScoreFromCities(); //ignore this, it's covered by pop and land
	iScore += GetScoreFromPopulation();
	iScore += GetScoreFromLand();
	iScore += GetScoreFromWonders();
	iScore += GetScoreFromPolicies();
	iScore += GetScoreFromGreatWorks();
	iScore += GetScoreFromReligion();
	iScore += GetScoreFromTechs();
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (MOD_DIPLOMACY_CIV4_FEATURES) {
		iScore += GetScoreFromVassals();
	}
#endif
#if defined(MOD_BALANCE_CORE)
	iScore += GetScoreFromMinorAllies();
	iScore += GetScoreFromMilitarySize();
#endif
	iScore += GetScoreFromFutureTech();
	iScore += GetScoreFromScenario1();
	iScore += GetScoreFromScenario2();
	iScore += GetScoreFromScenario3();
	iScore += GetScoreFromScenario4();

	// If the game is over, we apply a mod to the value, rewarding players who finish early
	if(bFinal && bWinner)
	{
		int iGameProgressPercent = 100 * GC.getGame().getGameTurn() / GC.getGame().getEstimateEndTurn();
		iGameProgressPercent = iGameProgressPercent < 1 ? 1 : iGameProgressPercent;
		iScore *= 100;
		iScore /= iGameProgressPercent;
	}

	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from Cities: 10 per city (with mod for map size)
int CvPlayer::GetScoreFromCities() const
{
	int iScore = getNumCities() * /*10*/ GC.getSCORE_CITY_MULTIPLIER();

	iScore *= GC.getGame().GetMapScoreMod();
	iScore /= 100;

	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from Population: 6 per pop (with mod for map size)
int CvPlayer::GetScoreFromPopulation() const
{
	int iScore = getTotalPopulation() * /*4*/ GC.getSCORE_POPULATION_MULTIPLIER();

	iScore *= GC.getGame().GetMapScoreMod();
	iScore /= 100;

	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from Land: 6 per plot (with mod for map size)
int CvPlayer::GetScoreFromLand() const
{
	int iScore = getTotalLand() * /*1*/ GC.getSCORE_LAND_MULTIPLIER();

	iScore *= GC.getGame().GetMapScoreMod();
	iScore /= 100;

	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from world wonders
int CvPlayer::GetScoreFromWonders() const
{
	int iScore = GetNumWonders() * /*25*/ GC.getSCORE_WONDER_MULTIPLIER();
	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from policies
int CvPlayer::GetScoreFromPolicies() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_POLICIES))
	{
		return 0;
	}
#if defined(MOD_BUGFIX_DUMMY_POLICIES)
	int iScore = GetPlayerPolicies()->GetNumPoliciesOwned(MOD_BUGFIX_DUMMY_POLICIES) * /*4*/ GC.getSCORE_POLICY_MULTIPLIER();
#else
	int iScore = GetPlayerPolicies()->GetNumPoliciesOwned() * /*4*/ GC.getSCORE_POLICY_MULTIPLIER();
#endif
	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from world wonders: 40 per
int CvPlayer::GetScoreFromGreatWorks() const
{
	int iScore = GetCulture()->GetNumGreatWorks() * /*4*/ GC.getSCORE_GREAT_WORK_MULTIPLIER();
	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from world wonders: 40 per
int CvPlayer::GetScoreFromReligion() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_RELIGION))
	{
		return 0;
	}
	int iScore = 0;
	CvGameReligions *pGameReligions = GC.getGame().GetGameReligions();
	ReligionTypes eReligion = GetReligions()->GetReligionCreatedByPlayer();
	if (eReligion > RELIGION_PANTHEON)
	{
		const CvReligion *pReligion = pGameReligions->GetReligion(eReligion, GetID());
		iScore += pReligion->m_Beliefs.GetNumBeliefs() * /*20*/ GC.getSCORE_BELIEF_MULTIPLIER();
		iScore += pGameReligions->GetNumCitiesFollowing(eReligion) * /*1*/ GC.getSCORE_RELIGION_CITIES_MULTIPLIER();
	}
	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from Tech: 4 per
int CvPlayer::GetScoreFromTechs() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))
	{
		return 0;
	}

	// Normally we recompute it each time
	int iScore = GET_TEAM(getTeam()).GetTeamTechs()->GetNumTechsKnown() * /*4*/ GC.getSCORE_TECH_MULTIPLIER();
	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from Future Tech: 10 per
int CvPlayer::GetScoreFromFutureTech() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))
	{
		return 0;
	}

	return m_iScoreFromFutureTech;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeScoreFromFutureTech(int iChange)
{
	if(iChange != 0)
		m_iScoreFromFutureTech += iChange;
}

//	--------------------------------------------------------------------------------
// Score from scenario-specific items
int CvPlayer::GetScoreFromScenario1() const
{
	return m_iScenarioScore1;
}
void CvPlayer::ChangeScoreFromScenario1(int iChange)
{
	if(iChange != 0)
		m_iScenarioScore1 += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetScoreFromScenario2() const
{
	return m_iScenarioScore2;
}
void CvPlayer::ChangeScoreFromScenario2(int iChange)
{
	if(iChange != 0)
		m_iScenarioScore2 += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetScoreFromScenario3() const
{
	return m_iScenarioScore3;
}
void CvPlayer::ChangeScoreFromScenario3(int iChange)
{
	if(iChange != 0)
		m_iScenarioScore3 += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetScoreFromScenario4() const
{
	return m_iScenarioScore4;
}
void CvPlayer::ChangeScoreFromScenario4(int iChange)
{
	if(iChange != 0)
		m_iScenarioScore4 += iChange;
}

//////////////////////////////////////////////////////////////////////////
// End Civ 5 Score
//////////////////////////////////////////////////////////////////////////

//	--------------------------------------------------------------------------------
int CvPlayer::countCityFeatures(FeatureTypes eFeature, bool bReset) const
{
	if (bReset)
	{
		int iCount = 0;
		int iLoop = 0;

		for (const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			for (int iI = 0; iI < pLoopCity->GetNumWorkablePlots(); iI++)
			{
				const CvPlot* pLoopPlot = iterateRingPlots(pLoopCity->getX(), pLoopCity->getY(), iI);

				if (pLoopPlot && pLoopPlot->getFeatureType() == eFeature)
					iCount++;
			}
		}

		//const call hack
		GET_PLAYER(GetID()).setCityFeatures(eFeature, iCount);
	}

	return getCityFeatures(eFeature);
}

//	--------------------------------------------------------------------------------
int CvPlayer::countNumBuildingsInPuppets(BuildingTypes eBuilding, bool bReset) const
{
	if (bReset)
	{
		int iCount = 0;
		int iLoop = 0;

		for (const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if (!pLoopCity->IsPuppet())
				continue;

			if (pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
				iCount += pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding);
		}

		//const call hack
		GET_PLAYER(GetID()).setNumBuildingsInPuppets(eBuilding, iCount);
	}

	return getNumBuildingsInPuppets(eBuilding);
}

int CvPlayer::countNumBuildings(BuildingTypes eBuilding, bool bReset) const
{
	if(bReset)
	{
		int iCount = 0;
		int iLoop = 0;

		for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
			{
				iCount += pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding);
			}
		}

		//const call hack
		GET_PLAYER(GetID()).setNumBuildings(eBuilding, iCount);
	}

	return getNumBuildings(eBuilding);
}

//	--------------------------------------------------------------------------------
/// How many cities in the empire surrounded by features?
int CvPlayer::countCitiesNeedingTerrainImprovements(bool bReset) const
{
	if (bReset)
	{
		int iCount = 0;
		int iLoop = 0;

		for (const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			//what is a sensible threshold here?
			if (pLoopCity->GetTerrainImprovementNeed()>0)
				iCount++;
		}

		GET_PLAYER(GetID()).setCitiesNeedingTerrainImprovements(iCount);
	}

	return getCitiesNeedingTerrainImprovements();
}

void CvPlayer::setCityFeatures(FeatureTypes eFeature, int iValue)
{
	CvAssertMsg(eFeature >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFeature < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	
	m_piCityFeatures[eFeature] = iValue;
}
int CvPlayer::getCityFeatures(FeatureTypes eFeature) const
{
	CvAssertMsg(eFeature >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFeature < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	return m_piCityFeatures[eFeature];
}
void CvPlayer::setNumBuildings(BuildingTypes eBuilding, int iValue)
{
	CvAssertMsg(eBuilding >= 0, "eBuilding is expected to be non-negative (invalid Index)");
	CvAssertMsg(eBuilding < GC.getNumBuildingInfos(), "eBuilding is expected to be within maximum bounds (invalid Index)");

	m_piNumBuildings[eBuilding] = iValue;
}
int CvPlayer::getNumBuildings(BuildingTypes eBuilding) const
{
	CvAssertMsg(eBuilding >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eBuilding < GC.getNumBuildingInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	return m_piNumBuildings[eBuilding];
}

void CvPlayer::setNumBuildingsInPuppets(BuildingTypes eBuilding, int iValue)
{
	CvAssertMsg(eBuilding >= 0, "eBuilding is expected to be non-negative (invalid Index)");
	CvAssertMsg(eBuilding < GC.getNumBuildingInfos(), "eBuilding is expected to be within maximum bounds (invalid Index)");

	m_piNumBuildingsInPuppets[eBuilding] = iValue;
}
int CvPlayer::getNumBuildingsInPuppets(BuildingTypes eBuilding) const
{
	CvAssertMsg(eBuilding >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eBuilding < GC.getNumBuildingInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	return m_piNumBuildingsInPuppets[eBuilding];
}

void CvPlayer::setCitiesNeedingTerrainImprovements(int iValue)
{
	m_iCitiesNeedingTerrainImprovements = iValue;
}
int CvPlayer::getCitiesNeedingTerrainImprovements() const
{
	return m_iCitiesNeedingTerrainImprovements;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsCityConnectedToCity(CvCity* pCity1, CvCity* pCity2, RouteTypes eRestrictRoute, bool bIgnoreHarbors, SPath* pPathOut)
{
	if (!pCity1 || !pCity2)
		return false;

	return IsPlotConnectedToPlot(m_eID, pCity1->plot(), pCity2->plot(), eRestrictRoute, bIgnoreHarbors, pPathOut);
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsCapitalConnectedToPlayer(PlayerTypes ePlayer)
{
	// everybody needs to be alive!
	if(!isAlive() || !(GET_PLAYER(ePlayer).isAlive()))
	{
		return false;
	}

	CvCity* pOtherPlayerCapital = GET_PLAYER(ePlayer).getCapitalCity();
	if(pOtherPlayerCapital == NULL)
	{
		return false;
	}

	CvCity* pPlayerCapital = getCapitalCity();
	if(pPlayerCapital == NULL)
	{
		return false;
	}

	return IsPlotConnectedToPlot(m_eID, pPlayerCapital->plot(), pOtherPlayerCapital->plot());
}

//	--------------------------------------------------------------------------------
void CvPlayer::findNewCapital()
{
	int iLoop;

	BuildingTypes eCapitalBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(GC.getCAPITAL_BUILDINGCLASS())));
	if(eCapitalBuilding == NO_BUILDING)
	{
		return;
	}

	CvCity* pOldCapital = getCapitalCity();
	int iBestValue = 0;
	CvCity* pBestCity = NULL;

	CvCity* pLoopCity;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != pOldCapital)
		{
			if(0 == pLoopCity->GetCityBuildings()->GetNumRealBuilding(eCapitalBuilding))
			{
#if defined(MOD_BUGFIX_NO_PUPPET_CAPITALS)
				// First pass, exclude cities in resistance, puppets, and those burning to the ground
				if (!(pLoopCity->IsResistance() || pLoopCity->IsPuppet() || pLoopCity->IsRazing()))
				{
#endif
					int iValue = (pLoopCity->getPopulation() * 4);

					int iYieldValueTimes100 = pLoopCity->getYieldRateTimes100(YIELD_FOOD, false);
					iYieldValueTimes100 += (pLoopCity->getYieldRateTimes100(YIELD_PRODUCTION, false) * 3);
					iYieldValueTimes100 += (pLoopCity->getYieldRateTimes100(YIELD_GOLD, false) * 2);
					iValue += (iYieldValueTimes100 / 100);

					iValue += (pLoopCity->getNumGreatPeople() * 2);

					if (iValue > iBestValue)
					{
						iBestValue = iValue;
						pBestCity = pLoopCity;
					}
#if defined(MOD_BUGFIX_NO_PUPPET_CAPITALS)
				}
#endif
			}
		}
	}

#if defined(MOD_BUGFIX_NO_PUPPET_CAPITALS)
	if (pBestCity == NULL)
	{
		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if (pLoopCity != pOldCapital)
			{
				if (0 == pLoopCity->GetCityBuildings()->GetNumRealBuilding(eCapitalBuilding))
				{
					int iValue = 0;

					// Second pass, consider only those we ignored first time
					if (pLoopCity->IsResistance())
					{
						// We'll take a city in resistance (ie one we have decided to assimilate) over all others
						iValue = pLoopCity->getPopulation() + 500;
					}
					else if (pLoopCity->IsPuppet())
					{
						// We'll take a puppet city next, at least we're not burning it to the ground!
						iValue = pLoopCity->getPopulation() + 250;
					}
					else if (pLoopCity->IsRazing())
					{
						// Might be an idea to stop the burning!
						iValue = pLoopCity->getPopulation();
					}

					if (iValue > iBestValue)
					{
						iBestValue = iValue;
						pBestCity = pLoopCity;
					}
				}
			}
		}
	}
#endif

	if (pBestCity != NULL)
	{
		if (pOldCapital != NULL)
		{
			pOldCapital->GetCityBuildings()->SetNumRealBuilding(eCapitalBuilding, 0);
		}
		CvAssertMsg(!(pBestCity->GetCityBuildings()->GetNumRealBuilding(eCapitalBuilding)), "(pBestCity->getNumRealBuilding(eCapitalBuilding)) did not return false as expected");
		pBestCity->GetCityBuildings()->SetNumRealBuilding(eCapitalBuilding, 1);

#if defined(MOD_BALANCE_CORE)
		for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
		{
			const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iI);
			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
			if (pkBuildingClassInfo)
			{
				int iNumFreeBuildings = GetNumCitiesFreeChosenBuilding(eBuildingClass);
				if (iNumFreeBuildings > 0 || IsFreeChosenBuildingNewCity(eBuildingClass) || IsFreeBuildingAllCity(eBuildingClass))
				{
					const BuildingTypes eBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(pkBuildingClassInfo->GetID())));
					if (NO_BUILDING != eBuilding)
					{
						CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
						if (pkBuildingInfo && pkBuildingInfo->IsCapitalOnly())
						{
							pBestCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, 1);
						}
					}
				}
			}
		}
#endif

#if defined(MOD_EVENTS_CITY_CAPITAL)
		if (MOD_EVENTS_CITY_CAPITAL) {
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_CapitalChanged, GetID(), pBestCity->GetID(), (pOldCapital ? pOldCapital->GetID() : -1));
		}
#endif

#if defined(MOD_BUGFIX_NO_PUPPET_CAPITALS)
		if (pBestCity->IsPuppet())
		{
			gDLL->sendDoTask(pBestCity->GetID(), TASK_ANNEX_PUPPET, -1, -1, false, false, false, false);
		}
		else if (pBestCity->IsRazing() && !isHuman())
		{
			// For the AI, we'll stop burining our new capital!
			gDLL->sendDoTask(pBestCity->GetID(), TASK_UNRAZE, -1, -1, false, false, false, false);
		}
#endif

#if defined(MOD_GLOBAL_NO_CONQUERED_SPACESHIPS)
		if (MOD_GLOBAL_NO_CONQUERED_SPACESHIPS && !isMinorCiv() && !isBarbarian()) {
			// Rebuild the spaceship launch pad
			CvTeam& thisTeam = GET_TEAM(getTeam());

			if (thisTeam.getProjectCount((ProjectTypes)GC.getSPACE_RACE_TRIGGER_PROJECT()) == 1) {
				if (isAlive()) {
					CUSTOMLOG("Rebuilding launch pad at (%i, %i)", pBestCity->getX(), pBestCity->getY());
					auto_ptr<ICvPlot1> pDllPlot(new CvDllPlot(pBestCity->plot()));
					gDLL->GameplaySpaceshipEdited(pDllPlot.get(), 0x0001); // Display just the launch pad
				}
			}
		}
#endif
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canRaze(CvCity* pCity, bool bIgnoreCapitals) const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_CITY_RAZING))
	{
		return false;
	}

	// If we don't own this city right now then we can't raze it!
	if(pCity->getOwner() != GetID())
	{
		return false;
	}

	// Can't raze a city that originally belonged to us
	if(pCity->getOriginalOwner() == GetID())
	{
		return false;
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(pCity->getOwner());
		args->Push(pCity->GetID());

		bool bResult = false;
		if(LuaSupport::CallTestAll(pkScriptSystem, "CanRazeOverride", args.get(), bResult))
		{
			// Check the result.
			if(bResult == true)
			{
				return true;
			}
		}
	}

#if defined(MOD_EVENTS_CITY_RAZING)
	if (MOD_EVENTS_CITY_RAZING) {
		// Note the subtle difference between CanRazeOverride and PlayerCanRaze, the former needs everyone to agree, the latter anyone
		if (GAMEEVENTINVOKE_TESTANY(GAMEEVENT_PlayerCanRaze, pCity->getOwner(), pCity->GetID()) == GAMEEVENTRETURN_TRUE) {
			return true;
		}
	}
#endif

	// No razing of capitals
	CvPlayer* pOriginalOwner = &GET_PLAYER(pCity->getOriginalOwner());
	bool bOriginalCapital =	pCity->getX() == pOriginalOwner->GetOriginalCapitalX() &&
	                        pCity->getY() == pOriginalOwner->GetOriginalCapitalY();

	if(!bIgnoreCapitals && bOriginalCapital)
	{
		return false;
	}

	// No razing of Holy Cities
	if (pCity->GetCityReligions()->IsHolyCityAnyReligion())
	{
		return false;
	}

	// No razing of cities with unique luxuries
	ResourceTypes eResource = pCity->plot()->getResourceType();
	if (eResource != NO_RESOURCE)
	{
		CvResourceInfo *pkResource = GC.getResourceInfo(eResource);
		if (pkResource && pkResource->GetRequiredCivilization() != NO_CIVILIZATION)
		{
			return false;
		}
	}

	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(pCity->getOwner());
		args->Push(pCity->GetID());

		bool bResult = false;
		if(LuaSupport::CallTestAll(pkScriptSystem, "CanRaze", args.get(), bResult))
		{
			// Check the result.
			if(bResult == false)
			{
				return false;
			}
		}
	}

	return true;
}


//	--------------------------------------------------------------------------------
void CvPlayer::raze(CvCity* pCity)
{
	char szBuffer[1024];
	const size_t lenBuffer = 1024;
	int iI;

	if(!canRaze(pCity))
	{
		return;
	}

	CvAssert(pCity->getOwner() == GetID());

	if(GetID() == GC.getGame().getActivePlayer())
	{
		sprintf_s(szBuffer, lenBuffer, GetLocalizedText("TXT_KEY_MISC_DESTROYED_CITY", pCity->getNameKey()).GetCString());
		GC.GetEngineUserInterface()->AddCityMessage(0, pCity->GetIDInfo(), GetID(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer/*, "AS2D_CITYRAZE", MESSAGE_TYPE_MAJOR_EVENT, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pCity->getX(), pCity->getY(), true, true*/);

	}

	for(iI = 0; iI < MAX_PLAYERS; iI++)
	{
		if(GET_PLAYER((PlayerTypes)iI).isAlive())
		{
			if(iI != GetID() && iI == GC.getGame().getActivePlayer())
			{
				if(pCity->isRevealed(GET_PLAYER((PlayerTypes)iI).getTeam(), false))
				{
					sprintf_s(szBuffer, lenBuffer, GetLocalizedText("TXT_KEY_MISC_CITY_HAS_BEEN_RAZED_BY", pCity->getNameKey(), getCivilizationDescriptionKey()).GetCString());
					GC.GetEngineUserInterface()->AddCityMessage(0, pCity->GetIDInfo(), ((PlayerTypes)iI), false, GC.getEVENT_MESSAGE_TIME(), szBuffer/*, "AS2D_CITYRAZED", MESSAGE_TYPE_MAJOR_EVENT, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pCity->getX(), pCity->getY(), true, true*/);
				}
			}
		}
	}

	sprintf_s(szBuffer, lenBuffer, GetLocalizedText("TXT_KEY_MISC_CITY_RAZED_BY", pCity->getNameKey(), getCivilizationShortDescriptionKey()).GetCString());
	GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, GetID(), szBuffer, pCity->getX(), pCity->getY());

	pCity->SetIgnoreCityForHappiness(false);

	CalculateNetHappiness();

#if defined(MOD_BALANCE_CORE)
	if(pCity->IsNoWarmongerYet())
	{
		PlayerTypes eFormerOwner = pCity->getPreviousOwner();
		if(eFormerOwner != NO_PLAYER)
		{
			CvDiplomacyAIHelpers::ApplyWarmongerPenalties(GetID(), eFormerOwner, pCity);
			pCity->SetNoWarmonger(false);
		}
	}
#endif
	int iPopulationDrop = 1;
	iPopulationDrop *= (100 + GetPlayerTraits()->GetRazeSpeedModifier() + GetRazingSpeedBonus());
	iPopulationDrop /= 100;

	int iTurnsToRaze = pCity->getPopulation();
	if(iPopulationDrop > 0)
	{
		iTurnsToRaze = (iTurnsToRaze + iPopulationDrop - 1) / iPopulationDrop;
	}

	pCity->ChangeRazingTurns(iTurnsToRaze);

	DoUpdateNextPolicyCost();

	// Update City UI
	if(GetID() == GC.getGame().getActivePlayer())
	{
		GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::unraze(CvCity* pCity)
{
	if (GetPlayerTraits()->IsUnableToCancelRazing() == false)
	{
		if (GetPlayerTraits()->IsNoAnnexing())
		{
			pCity->DoCreatePuppet();
		}
		else
		{
			pCity->DoAnnex();
		}

		pCity->ChangeRazingTurns(-pCity->GetRazingTurns());

		DoUpdateNextPolicyCost();

		// Update City UI
		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}



//	--------------------------------------------------------------------------------
void CvPlayer::disband(CvCity* pCity)
{
	CvPlot* pPlot = pCity->plot();

	if(getNumCities() == 1)
	{
		setFoundedFirstCity(false);
	}

	GC.getGame().addDestroyedCityName(pCity->getNameKey());

	for(int eBuildingType = 0; eBuildingType < GC.getNumBuildingInfos(); eBuildingType++)
	{
		CvBuildingEntry* buildingInfo = GC.getBuildingInfo((BuildingTypes) eBuildingType);
		if(buildingInfo)
		{
			// if this building exists
			int iExists = pCity->GetCityBuildings()->GetNumRealBuilding((BuildingTypes) eBuildingType);
			int iPreferredPosition = buildingInfo->GetPreferredDisplayPosition();
			if(iPreferredPosition > 0)
			{
				auto_ptr<ICvCity1> pDllCity(new CvDllCity(pCity));

				if(iExists > 0)
				{
					// kill the wonder
					GC.GetEngineUserInterface()->AddDeferredWonderCommand(WONDER_REMOVED, pDllCity.get(), (BuildingTypes) eBuildingType, 0);
				}
				else
				{
					// else if we are currently in the process of building this wonder
					if(pCity->getProductionBuilding() == eBuildingType)
					{
						// kill the half built wonder
						if(isWorldWonderClass(buildingInfo->GetBuildingClassInfo()))
						{
							GC.GetEngineUserInterface()->AddDeferredWonderCommand(WONDER_REMOVED, pDllCity.get(), (BuildingTypes) eBuildingType, 0);
						}
					}
				}
			}
		}
	}

	{
		auto_ptr<ICvCity1> pkDllCity(new CvDllCity(pCity));
		gDLL->GameplayCitySetDamage(pkDllCity.get(), 0, pCity->getDamage());
		gDLL->GameplayCityDestroyed(pkDllCity.get(), NO_PLAYER);
	}

	pCity->kill();

	if(pPlot)
	{
		IDInfoVector currentUnits;
		if (pPlot->getUnits(&currentUnits) > 0)
		{
			for (IDInfoVector::const_iterator itr = currentUnits.begin(); itr != currentUnits.end(); ++itr)
			{
				CvUnit* pUnit = ::getUnit(*itr);

				if(pUnit && !pPlot->isValidDomainForLocation(*pUnit))
				{
					if (!pUnit->jumpToNearestValidPlot())
						pUnit->kill(false);
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Is a Particular Goody ID a valid Goody for a certain plot?
bool CvPlayer::canReceiveGoody(CvPlot* pPlot, GoodyTypes eGoody, CvUnit* pUnit) const
{
	CvCity* pCity;
	UnitTypes eUnit;
	bool bTechFound;
	int iI;

	Database::SingleResult kResult;
	CvGoodyInfo kGoodyInfo;
	const bool bResult = DB.SelectAt(kResult, "GoodyHuts", eGoody);
	DEBUG_VARIABLE(bResult);
	CvAssertMsg(bResult, "Cannot find goody info.");
	kGoodyInfo.CacheResult(kResult);

#if defined(MOD_EVENTS_GOODY_CHOICE)
	if (MOD_EVENTS_GOODY_CHOICE) {
		bool bPick = (pUnit && pUnit->isHasPromotion((PromotionTypes)GC.getPROMOTION_GOODY_HUT_PICKER()));
		int iUnit = pUnit ? pUnit->GetID() : -1;
		if (GAMEEVENTINVOKE_TESTANY(GAMEEVENT_GoodyHutCanNotReceive, GetID(), iUnit, eGoody, bPick) == GAMEEVENTRETURN_TRUE) {
			return false;
		}
	}
#endif

	if(!CvGoodyHuts::IsCanPlayerReceiveGoody(GetID(), eGoody))
	{
		return false;
	}

	// No XP in first 10 turns
	if(kGoodyInfo.getExperience() > 0)
	{
		if((pUnit == NULL) || !(pUnit->canAcquirePromotionAny()) || (GC.getGame().getElapsedGameTurns() < 10))
		{
			return false;
		}

		if (MOD_BALANCE_CORE_MINOR_CIV_GIFT && pUnit->IsGainsXPFromScouting())
			return false;
	}

	// Unit Healing
	if(kGoodyInfo.getDamagePrereq() > 0)
	{
		if((pUnit == NULL) || (pUnit->getDamage() < ((pUnit->GetMaxHitPoints() * kGoodyInfo.getDamagePrereq()) / 100)))
		{
			return false;
		}
	}

	// Early pantheon
	if(kGoodyInfo.isPantheonFaith())
	{
		if(GC.getGame().getElapsedGameTurns() < 20)
		{
			return false;
		}
		else
		{
			return (!GetReligions()->HasCreatedPantheon() && !GetReligions()->HasCreatedReligion());
		}
	}

	// Faith toward Great Prophet
	if(kGoodyInfo.getProphetPercent() > 0)
	{
		if(GC.getGame().getElapsedGameTurns() < 20)
		{
			return false;
		}
		else
		{
			return (GetReligions()->HasCreatedPantheon() && !GetReligions()->HasCreatedReligion());
		}
	}

	// Population
	if(kGoodyInfo.getPopulation() > 0)
	{
		if(getNumCities() == 0)
		{
			return false;
		}

		// Don't give more Population if we're already over our Pop limit
		if(IsEmpireUnhappy())
		{
			return false;
		}
	}
#if defined(MOD_BALANCE_CORE)
	//Golden Age
	if(kGoodyInfo.getGoldenAge() > 0)
	{
		if(GetNumGoldenAges() <= 0)
		{
			return false;
		}
	}
	//Free Tiles
	if(kGoodyInfo.getFreeTiles() > 0 && pPlot != NULL)
	{
		int iDistance;
		int iBestCityDistance = -1;
		CvCity* pBestCity = NULL;

		CvCity* pLoopCity;
		int iLoop;
		// Find the closest City to us to add a Pop point to
		for(pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
		{
			iDistance = plotDistance(pPlot->getX(), pPlot->getY(), pLoopCity->getX(), pLoopCity->getY());

			if(iBestCityDistance == -1 || iDistance < iBestCityDistance)
			{
				iBestCityDistance = iDistance;
				pBestCity = pLoopCity;
			}
		}

		if(pBestCity == NULL)
		{
			return false;
		}
	}
	if (kGoodyInfo.getMapRange() > 0 && kGoodyInfo.getMapOffset() > 0)
	{
		if (pUnit == NULL)
			return false;

		if (MOD_BALANCE_CORE_MINOR_CIV_GIFT && !pUnit->IsGainsXPFromScouting())
			return false;
	}
	if(pPlot == NULL && kGoodyInfo.getMapRange() > 0 && kGoodyInfo.getMapOffset() > 0)
	{
		return false;
	}
	if (pPlot != NULL && kGoodyInfo.getMapRange() > 0 && kGoodyInfo.getMapOffset() > 0)
	{
		bool bGood = false;
		int iOffset = kGoodyInfo.getMapOffset();
		int iDX, iDY;
		for(iDX = -(iOffset); iDX <= iOffset; iDX++)
		{
			for(iDY = -(iOffset); iDY <= iOffset; iDY++)
			{
				CvPlot* pLoopPlot = plotXYWithRangeCheck(pPlot->getX(), pPlot->getY(), iDX, iDY, iOffset);

				if(pLoopPlot != NULL)
				{
					if(!(pLoopPlot->isRevealed(getTeam())))
					{
						if(pLoopPlot->isCity() && pLoopPlot->getOwner() != GetID() && pLoopPlot->getOwner() != NO_PLAYER)
						{
							bGood = true;
							break;
						}
					}
				}
			}
		}
		if(!bGood)
		{
			return false;
		}
	}
#endif

	// Reveal Nearby Barbs
	if(kGoodyInfo.getRevealNearbyBarbariansRange() > 0)
	{
		int iDX, iDY;
		int iBarbCampDistance = kGoodyInfo.getRevealNearbyBarbariansRange();
		CvPlot* pNearbyPlot;

		int iNumCampsFound = 0;

		ImprovementTypes barbCampType = (ImprovementTypes) GC.getBARBARIAN_CAMP_IMPROVEMENT();

		// Look at nearby Plots to make sure another camp isn't too close
		for(iDX = -(iBarbCampDistance); iDX <= iBarbCampDistance; iDX++)
		{
			for(iDY = -(iBarbCampDistance); iDY <= iBarbCampDistance; iDY++)
			{
				pNearbyPlot = plotXY(pPlot->getX(), pPlot->getY(), iDX, iDY);

				if(pNearbyPlot != NULL)
				{
					if(plotDistance(pNearbyPlot->getX(), pNearbyPlot->getY(), pPlot->getX(), pPlot->getY()) <= iBarbCampDistance)
					{
						if(pNearbyPlot->getImprovementType() == barbCampType)
						{
							iNumCampsFound++;
						}
					}
				}
			}
		}

		// Needs to be at least 2 nearby Camps
		if(iNumCampsFound < 2)
		{
			return false;
		}
	}

	// Reveal Unknown Resource
	if(kGoodyInfo.isRevealUnknownResource())
	{
		// Can't get this if you have no Capital City
		if(getCapitalCity() == NULL)
		{
			return false;
		}

		CvResourceInfo* pResource;
		ResourceClassTypes eResourceClassBonus = (ResourceClassTypes) GC.getInfoTypeForString("RESOURCECLASS_BONUS");

		bool bPlayerDoesntKnowOfResource = false;

		int iNumResourceInfos = GC.getNumResourceInfos();
		for(int iResourceLoop = 0; iResourceLoop < iNumResourceInfos; iResourceLoop++)
		{
			pResource = GC.getResourceInfo((ResourceTypes) iResourceLoop);

			// No "Bonus" Resources (that only give Yield), because those are lame to get from a Hut
			if(pResource != NULL && pResource->getResourceClassType() != eResourceClassBonus)
			{
				if(!GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes) pResource->getTechReveal()))
				{
					bPlayerDoesntKnowOfResource = true;
				}
			}
		}

		// If the player already knows where all the Resources are then there's no point in this Goody
		if(!bPlayerDoesntKnowOfResource)
		{
			return false;
		}
	}

	// Unit Upgrade
	if(kGoodyInfo.isUpgradeUnit())
	{
		if(pUnit == NULL)
		{
			return false;
		}

		if(pUnit->IsHasBeenPromotedFromGoody())
		{
			return false;
		}

		UnitClassTypes eUpgradeUnitClass = (UnitClassTypes) GC.getUnitInfo(pUnit->getUnitType())->GetGoodyHutUpgradeUnitClass();

		if(eUpgradeUnitClass == NO_UNITCLASS)
		{
			return false;
		}

		UnitTypes eUpgradeUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eUpgradeUnitClass);

		if(eUpgradeUnit == NO_UNIT)
		{
			return false;
		}
	}

	// Tech
	if(kGoodyInfo.isTech())
	{
		bTechFound = false;

		int iNumTechInfos = GC.getNumTechInfos();
		for(iI = 0; iI < iNumTechInfos; iI++)
		{
			const TechTypes eTech = static_cast<TechTypes>(iI);
			CvTechEntry* pkTech = GC.getTechInfo(eTech);
			if(pkTech != NULL && pkTech->IsGoodyTech())
			{
				if(GetPlayerTechs()->CanResearch(eTech))
				{
#if defined(MOD_BALANCE_CORE)
					if(MOD_BALANCE_CORE && GetPlayerTechs()->GetCurrentResearch() != eTech)
					{
#endif
					bool bUseTech = true;
					ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
					if (pkScriptSystem) 
					{
						CvLuaArgsHandle args;
						args->Push(GetID());
						args->Push(eTech);

						// Attempt to execute the game events.
						// Will return false if there are no registered listeners.
						bool bScriptResult = false;
						if (LuaSupport::CallTestAll(pkScriptSystem, "GoodyHutCanResearch", args.get(), bScriptResult)) 
						{
							bUseTech = bResult;
						}
					}

					if(bUseTech)
					{
						bTechFound = true;
					}
					break;
#if defined(MOD_BALANCE_CORE)
					}
#endif
				}
			}
		}

		if(!bTechFound)
		{
			return false;
		}
	}

	///////////////////////////////////////
	///////////////////////////////////////
	// Bad Goodies follow beneath this line
	///////////////////////////////////////
	///////////////////////////////////////

	if(kGoodyInfo.isBad())
	{
		if((pUnit == NULL) || pUnit->isNoBadGoodies())
		{
			return false;
		}
	}

	if(kGoodyInfo.getUnitClassType() != NO_UNITCLASS)
	{
		eUnit = ((UnitTypes)(getCivilizationInfo().getCivilizationUnits(kGoodyInfo.getUnitClassType())));

		if(eUnit == NO_UNIT)
		{
			return false;
		}

		CvUnitEntry* pUnitInfo = GC.getUnitInfo(eUnit);
		if(pUnitInfo == NULL)
		{
			return false;
		}

		// No combat units in MP in the first 20 turns
		if(pUnitInfo->GetCombat() > 0)
		{
			if(GC.getGame().isGameMultiPlayer() || (GC.getGame().getElapsedGameTurns() < 20))
			{
				return false;
			}
		}

		// Builders
		if(pUnitInfo->GetWorkRate() > 0)
		{
			// Max limit
			if(GetMaxNumBuilders() > -1 && GetNumBuilders() >= GetMaxNumBuilders())
			{
				return false;
			}

			bool bHasTechWhichUnlocksImprovement = false;

			// Need a tech which unlocks something to do
			int iNumTechInfos = GC.getNumTechInfos();
			int iNumBuildInfos = GC.getNumBuildInfos();
			for(int iTechLoop = 0; iTechLoop < iNumTechInfos; iTechLoop++)
			{
				if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes) iTechLoop))
				{
					// Look at Builds
					for(int iBuildLoop = 0; iBuildLoop < iNumBuildInfos; iBuildLoop++)
					{
						CvBuildInfo* pkBuildInfo = GC.getBuildInfo((BuildTypes) iBuildLoop);
						if(!pkBuildInfo)
						{
							continue;
						}
						if(pkBuildInfo->getTechPrereq() == (TechTypes) iTechLoop)
						{
							if(pkBuildInfo->getImprovement() != NO_IMPROVEMENT || pkBuildInfo->getRoute() != NO_ROUTE)
							{
								bHasTechWhichUnlocksImprovement = true;
								break;
							}
						}
					}
				}
				// Already found something
				if(bHasTechWhichUnlocksImprovement)
				{
					break;
				}
			}

			// Player doesn't have any Tech which allows Improvements
			if(!bHasTechWhichUnlocksImprovement)
			{
				return false;
			}
		}

		// OCC games - no Settlers
		if(GetPlayerTraits()->IsNoAnnexing() || (GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && isHuman()))
		{
			if(pUnitInfo->IsFound() || pUnitInfo->IsFoundAbroad())
			{
				return false;
			}
		}
	}

	// Barbarians
	if(kGoodyInfo.getBarbarianUnitClass() != NO_UNITCLASS)
	{
		if(GC.getGame().isOption(GAMEOPTION_NO_BARBARIANS))
		{
			return false;
		}

		if(getNumCities() == 0)
		{
			return false;
		}

		if(getNumCities() == 1)
		{
			pCity = GC.getMap().findCity(pPlot->getX(), pPlot->getY(), NO_PLAYER, getTeam());

			if(pCity != NULL)
			{
				if(plotDistance(pPlot->getX(), pPlot->getY(), pCity->getX(), pCity->getY()) <= (8 - getNumCities()))
				{
					return false;
				}
			}
		}
	}

	return true;
}


//	--------------------------------------------------------------------------------
void CvPlayer::receiveGoody(CvPlot* pPlot, GoodyTypes eGoody, CvUnit* pUnit)
{
	CvPlot* pLoopPlot;
	CvPlot* pBestPlot = NULL;
	CvString strBuffer;
	CvString strTempBuffer;
	TechTypes eBestTech;
	UnitTypes eUnit;
	int iGold = 0;
	int iOffset;
	int iRange;
	int iBarbCount;
	int iValue;
	int iBestValue;
	int iPass;
	int iDX, iDY;
	int iI;

	int iEra = MOD_BALANCE_CORE_DIPLOMACY_ADVANCED ? GetCurrentEra() : 1;
	if (iEra <= 0)
		iEra = 1;

	CvAssertMsg(canReceiveGoody(pPlot, eGoody, pUnit), "Instance is expected to be able to recieve goody");

	Database::SingleResult kResult;
	CvGoodyInfo kGoodyInfo;
	const bool bResult = DB.SelectAt(kResult, "GoodyHuts", eGoody);
	DEBUG_VARIABLE(bResult);
	CvAssertMsg(bResult, "Cannot find goody info.");
	kGoodyInfo.CacheResult(kResult);

	CvGoodyHuts::DoPlayerReceivedGoody(GetID(), eGoody);

	strBuffer = kGoodyInfo.GetDescription();

	// Gold
	if (kGoodyInfo.getNumGoldRandRolls() > 0 && kGoodyInfo.getGoldRandAmount() > 0)
	{
		iGold = kGoodyInfo.getGold() + (kGoodyInfo.getNumGoldRandRolls() * GC.getGame().getSmallFakeRandNum(kGoodyInfo.getGoldRandAmount(), *pPlot));
	}

	int iGoodyModifier = pUnit != NULL ? pUnit->getUnitInfo().GetGoodyModifier() + pUnit->GetGoodyHutYieldBonus() : 0;

	if (iGoodyModifier != 0)
	{
		iGold *= (100 + iGoodyModifier);
		iGold /= 100;
	}
	if(iGold != 0)
	{
		iGold *= iEra;
		GetTreasury()->ChangeGold(iGold);
		changeInstantYieldValue(YIELD_GOLD, iGold);
		strBuffer += " ";
		strBuffer += GetLocalizedText("TXT_KEY_MISC_RECEIVED_GOLD", iGold);
	}

	// Population
	if(kGoodyInfo.getPopulation() > 0)
	{
		int iDistance;
		int iBestCityDistance = -1;
		CvCity* pBestCity = NULL;

		CvCity* pLoopCity;
		int iLoop;
		// Find the closest City to us to add a Pop point to
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			iDistance = plotDistance(pPlot->getX(), pPlot->getY(), pLoopCity->getX(), pLoopCity->getY());

			if(iBestCityDistance == -1 || iDistance < iBestCityDistance)
			{
				iBestCityDistance = iDistance;
				pBestCity = pLoopCity;
			}
		}

		int iPop = kGoodyInfo.getPopulation() * iEra;

		if(pBestCity != NULL)
		{
			pBestCity->changePopulation(iPop, true, true);
		}
	}
#if defined(MOD_BALANCE_CORE)
	// Production
	int iProduction = 0;
	if(MOD_BALANCE_CORE && kGoodyInfo.getProduction() > 0)
	{
		iProduction = kGoodyInfo.getProduction();
		iProduction *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
		iProduction /= 100;

		if (pUnit != NULL && iGoodyModifier != 0)
		{
			iProduction *= (100 + iGoodyModifier);
			iProduction /= 100;
		}

		iProduction *= iEra;

		int iDistance;
		int iBestCityDistance = -1;
		CvCity* pBestCity = NULL;

		CvCity* pLoopCity;
		int iLoop;
		// Find the closest City to us to add a Pop point to
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			iDistance = plotDistance(pPlot->getX(), pPlot->getY(), pLoopCity->getX(), pLoopCity->getY());

			if(iBestCityDistance == -1 || iDistance < iBestCityDistance)
			{
				iBestCityDistance = iDistance;
				pBestCity = pLoopCity;
			}
		}

		if(pBestCity != NULL)
		{
			pBestCity->changeProduction(iProduction);
			changeInstantYieldValue(YIELD_PRODUCTION, iProduction);
#if defined(MOD_BUGFIX_GOODY_HUT_MESSAGES)
			strBuffer += GetLocalizedText("TXT_KEY_GOODY_PRODUCTION", iProduction);
#endif
		}
	}
	// Golden Age Points
	int iGoldenAge = kGoodyInfo.getGoldenAge();
	if(iGoldenAge > 0 && GetNumGoldenAges() > 0)
	{
		// Game Speed Mod
		iGoldenAge *= GC.getGame().getGameSpeedInfo().getCulturePercent();
		iGoldenAge /= 100;

		if (pUnit != NULL && iGoodyModifier != 0)
		{
			iGoldenAge *= (100 + iGoodyModifier);
			iGoldenAge /= 100;
		}

		iGoldenAge *= iEra;

		ChangeGoldenAgeProgressMeter(iGoldenAge);

		changeInstantYieldValue(YIELD_GOLDEN_AGE_POINTS, iGoldenAge);
	}
	//Free Tiles
	int iFreeTiles = kGoodyInfo.getFreeTiles();
	if(iFreeTiles > 0)
	{
		int iDistance;
		int iBestCityDistance = -1;
		CvCity* pBestCity = NULL;

		CvCity* pLoopCity;
		int iLoop;
		// Find the closest City to us to add a Pop point to
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			iDistance = plotDistance(pPlot->getX(), pPlot->getY(), pLoopCity->getX(), pLoopCity->getY());

			if(iBestCityDistance == -1 || iDistance < iBestCityDistance)
			{
				iBestCityDistance = iDistance;
				pBestCity = pLoopCity;
			}
		}

		if(pBestCity != NULL)
		{

			if (pUnit != NULL && iGoodyModifier != 0)
			{
				iFreeTiles *= (100 + iGoodyModifier);
				iFreeTiles /= 100;
			}

			if(iFreeTiles > 0)
			{
				for (int i = 0; i < iFreeTiles; i++)
				{
					CvPlot* pPlotToAcquire = pBestCity->GetNextBuyablePlot(false);
					// maybe the player owns ALL of the plots or there are none available?
					if(pPlotToAcquire)
					{
						// Instant yield from tiles gained by culture bombing
						for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
						{
							YieldTypes eYield = (YieldTypes)iI;

							int iPassYield = 0;

							if (eYield == NO_YIELD)
								continue;

							TerrainTypes eTerrain = pPlotToAcquire->getTerrainType();

							if (eTerrain == NO_TERRAIN)
								continue;

							// Stole foreign tiles
							if (pPlotToAcquire->getOwner() != NO_PLAYER)
							{
								iPassYield += GetPlayerTraits()->GetYieldChangeFromTileStealCultureBomb(eTerrain, eYield);
							}
							// Obtained neutral tiles
							else
							{
								iPassYield += GetPlayerTraits()->GetYieldChangeFromTileCultureBomb(eTerrain, eYield);
							}

							doInstantYield(INSTANT_YIELD_TYPE_CULTURE_BOMB, false, NO_GREATPERSON, NO_BUILDING, iPassYield, true, NO_PLAYER, NULL, false, pBestCity, false, true, false, eYield);
						}

						pBestCity->DoAcquirePlot(pPlotToAcquire->getX(), pPlotToAcquire->getY());
					}
				}
			}
		}
	}
#endif
	// Culture
	int iCulture = kGoodyInfo.getCulture();
	if(iCulture > 0)
	{
		// Game Speed Mod
		iCulture *= GC.getGame().getGameSpeedInfo().getCulturePercent();
		iCulture /= 100;

		if (pUnit != NULL && iGoodyModifier != 0)
		{
			iCulture *= (100 + iGoodyModifier);
			iCulture /= 100;
		}
#if defined(MOD_BALANCE_CORE_BARBARIAN_THEFT)
		if (MOD_BALANCE_CORE_BARBARIAN_THEFT)
		{
			iCulture *= max(1, (GetPlayerPolicies()->GetNumPoliciesOwned(true, true) / 2));
		}
#endif

		iCulture *= iEra;

		changeJONSCulture(iCulture);

#if defined(MOD_BUGFIX_GOODY_HUT_MESSAGES)
		strBuffer += " ";
		strBuffer += GetLocalizedText("TXT_KEY_MISC_RECEIVED_CULTURE", iCulture);
#endif

		changeInstantYieldValue(YIELD_CULTURE, iCulture);
	}

	// Faith
	int iFaith = kGoodyInfo.getFaith();
	if(iFaith > 0)
	{
		// Game Speed Mod
		iFaith *= GC.getGame().getGameSpeedInfo().getFaithPercent();
		iFaith /= 100;

		if (pUnit != NULL && iGoodyModifier != 0)
		{
			iFaith *= (100 + iGoodyModifier);
			iFaith /= 100;
		}

		iFaith *= iEra;

		ChangeFaith(iFaith);

		changeInstantYieldValue(YIELD_FAITH, iFaith);

#if defined(MOD_BUGFIX_GOODY_HUT_MESSAGES)
		strBuffer += " ";
		strBuffer += GetLocalizedText("TXT_KEY_MISC_RECEIVED_FAITH", iFaith);
#endif
	}

	// Faith for pantheon
	bool bPantheon = kGoodyInfo.isPantheonFaith();
	if(bPantheon)
	{
		// Enough so still get a pantheon if 3 civs pop this in same turn
		iFaith = GC.getGame().GetGameReligions()->GetMinimumFaithNextPantheon() + 2 * GC.getRELIGION_GAME_FAITH_DELTA_NEXT_PANTHEON();
		int iDivisor = /*10*/ GC.getGOLD_PURCHASE_VISIBLE_DIVISOR();
		iFaith /= iDivisor;
		iFaith *= iDivisor;

		if (pUnit != NULL && iGoodyModifier != 0)
		{
			iFaith *= (100 + iGoodyModifier);
			iFaith /= 100;
		}

		iFaith *= iEra;

		ChangeFaith(iFaith);

		changeInstantYieldValue(YIELD_FAITH, iFaith);

#if defined(MOD_BUGFIX_GOODY_HUT_MESSAGES)
		strBuffer += " ";
		strBuffer += GetLocalizedText("TXT_KEY_MISC_RECEIVED_FAITH", iFaith);
#endif
	}

	// Faith for percent of great prophet
	int iProphetPercent = kGoodyInfo.getProphetPercent();
	if(iProphetPercent > 0)
	{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
		iFaith = GetReligions()->GetCostNextProphet(false /*bIncludeBeliefDiscounts*/, true /*bAdjustForSpeedDifficulty*/, MOD_GLOBAL_TRULY_FREE_GP) * iProphetPercent / 100;
#else
		iFaith = GetReligions()->GetCostNextProphet(false /*bIncludeBeliefDiscounts*/, true /*bAdjustForSpeedDifficulty*/) * iProphetPercent / 100;
#endif
		int iDivisor = /*10*/ GC.getGOLD_PURCHASE_VISIBLE_DIVISOR();
		iFaith /= iDivisor;
		iFaith *= (iDivisor / 2);

		iFaith *= iEra;

		ChangeFaith(iFaith);

		changeInstantYieldValue(YIELD_FAITH, iFaith);

#if defined(MOD_BUGFIX_GOODY_HUT_MESSAGES)
		strBuffer += " ";
		strBuffer += GetLocalizedText("TXT_KEY_MISC_RECEIVED_FAITH", iFaith);
#endif
	}

	// Reveal Nearby Barbs
	if(kGoodyInfo.getRevealNearbyBarbariansRange() > 0)
	{
		// Look at nearby Plots to make sure another camp isn't too close
		const int iBarbCampDistance = kGoodyInfo.getRevealNearbyBarbariansRange();
		for(iDX = -(iBarbCampDistance); iDX <= iBarbCampDistance; iDX++)
		{
			for(iDY = -(iBarbCampDistance); iDY <= iBarbCampDistance; iDY++)
			{
				CvPlot* pNearbyBarbarianPlot = plotXY(pPlot->getX(), pPlot->getY(), iDX, iDY);
				if(pNearbyBarbarianPlot != NULL)
				{
					if(plotDistance(pNearbyBarbarianPlot->getX(), pNearbyBarbarianPlot->getY(), pPlot->getX(), pPlot->getY()) <= iBarbCampDistance)
					{
						if(pNearbyBarbarianPlot->getImprovementType() == GC.getBARBARIAN_CAMP_IMPROVEMENT())
						{
							// Reveal Plot
							pNearbyBarbarianPlot->setRevealed(getTeam(), true);
							// Reveal Barb Camp here
							pNearbyBarbarianPlot->setRevealedImprovementType(getTeam(), pNearbyBarbarianPlot->getImprovementType());
						}
					}
				}
			}
		}
	}

	// Map
	iRange = kGoodyInfo.getMapRange();

	if(iRange > 0)
	{
		iOffset = kGoodyInfo.getMapOffset();

		if(iOffset > 0)
		{
			iBestValue = 0;
			pBestPlot = NULL;

			int iRandLimit;

			for(iDX = -(iOffset); iDX <= iOffset; iDX++)
			{
				for(iDY = -(iOffset); iDY <= iOffset; iDY++)
				{
					pLoopPlot = plotXYWithRangeCheck(pPlot->getX(), pPlot->getY(), iDX, iDY, iOffset);

					if(pLoopPlot != NULL)
					{
						if(!(pLoopPlot->isRevealed(getTeam())))
						{
							// Avoid water plots!
#if defined(MOD_BALANCE_CORE)
							//Let's reveal cities instead.
							if(pLoopPlot->isCity() && pLoopPlot->getOwner() != GetID() && pLoopPlot->getOwner() != NO_PLAYER)
							{
								iRandLimit = 0;
								if(GET_PLAYER(pLoopPlot->getOwner()).isMajorCiv())
								{
									iRandLimit += 10000;
								}
								else if(GET_PLAYER(pLoopPlot->getOwner()).isMinorCiv())
								{
									iRandLimit += 1000;
								}

#else
							if(pPlot->isWater())
								iRandLimit = 10;
							else
								iRandLimit = 10000;
#endif
							iValue = (1 + GC.getGame().getSmallFakeRandNum(iRandLimit, *pLoopPlot));

							iValue *= plotDistance(pPlot->getX(), pPlot->getY(), pLoopPlot->getX(), pLoopPlot->getY());

							if(iValue > iBestValue)
							{
								iBestValue = iValue;
								pBestPlot = pLoopPlot;
							}
#if defined(MOD_BALANCE_CORE)
							}
#endif
						}
					}
				}
			}
		}

		if(pBestPlot == NULL)
		{
			pBestPlot = pPlot;
		}

		int iNumPlotsRevealed = 0;
		for(iDX = -(iRange); iDX <= iRange; iDX++)
		{
			for(iDY = -(iRange); iDY <= iRange; iDY++)
			{
				pLoopPlot = plotXY(pBestPlot->getX(), pBestPlot->getY(), iDX, iDY);

				if(pLoopPlot != NULL)
				{
					if(plotDistance(pBestPlot->getX(), pBestPlot->getY(), pLoopPlot->getX(), pLoopPlot->getY()) <= iRange)
					{
						if(GC.getGame().getSmallFakeRandNum(100, *pLoopPlot) < kGoodyInfo.getMapProb())
						{
							pLoopPlot->setRevealed(getTeam(), true);
							iNumPlotsRevealed++;
						}
					}
				}
			}
		}
		if (pUnit != NULL && pUnit->IsGainsXPFromScouting())
		{
#if defined(MOD_UNITS_XP_TIMES_100)
			pUnit->changeExperienceTimes100(iNumPlotsRevealed * 100);
#else
			pUnit->changeExperience(iNumPlotsRevealed);
#endif
		}
	}

	// Experience
	if(pUnit != NULL)
	{
#if defined(MOD_UNITS_XP_TIMES_100)
		int iExperience = kGoodyInfo.getExperience() * 100;
		if (pUnit != NULL && iGoodyModifier  != 0)
		{
			iExperience *= (100 + iGoodyModifier);
			iExperience /= 100;
		}
		pUnit->changeExperienceTimes100(iExperience);
#else
		int iExperience = kGoodyInfo.getExperience();
		if (pUnit != NULL && iGoodyModifier != 0)
		{
			iExperience *= (100 + iGoodyModifier);
			iExperience /= 100;
		}
		pUnit->changeExperience(iExperience;
#endif
	}

	// Unit Heal
	if(pUnit != NULL)
	{
		pUnit->changeDamage(-(kGoodyInfo.getHealing()));
	}

	// Reveal Unknown Resource
	if(kGoodyInfo.isRevealUnknownResource())
	{
		if(getCapitalCity() != NULL)
		{
			CvCity* pCapital = getCapitalCity();

			CvPlot* pResourcePlot;
			int iResourceDistance;
			TechTypes eRevealTech;
			int iResourceCost;
			int iBestResourceCost = -1;
			ResourceTypes eResource;
			ResourceTypes eBestResource = NO_RESOURCE;
			CvPlot* pBestResourcePlot = NULL;

			ResourceClassTypes eResourceClassBonus;

			// Look at Resources on all Plots
			for(int iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)
			{
				pResourcePlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);
				eResource = pResourcePlot->getResourceType();

				if(eResource != NO_RESOURCE)
				{
					CvResourceInfo& pResource = *GC.getResourceInfo(eResource);
					eResourceClassBonus = (ResourceClassTypes) GC.getInfoTypeForString("RESOURCECLASS_BONUS");

					// No "Bonus" Resources (that only give Yield), because those are lame to get from a Hut
					if(pResource.getResourceClassType() != eResourceClassBonus)
					{
						// Can't be on a Plot that we've already force-revealed!
						if(!pResourcePlot->IsResourceForceReveal(getTeam()))
						{
							// Must be a Resource we don't already see
							eRevealTech = (TechTypes) pResource.getTechReveal();
							if(!GET_TEAM(getTeam()).GetTeamTechs()->HasTech(eRevealTech))
							{
								iResourceDistance = plotDistance(pResourcePlot->getX(), pResourcePlot->getY(), pCapital->getX(), pCapital->getY());

								// Must be within 10 plots of our Capital
								if(iResourceDistance <= 10)
								{
									iResourceCost = GC.getTechInfo(eRevealTech)->GetResearchCost();

									// Find the one with the cheapest Tech (or pick one if we haven't identified one yet)
									if(iBestResourceCost == -1 || iResourceCost < iBestResourceCost)
									{
										iBestResourceCost = iResourceCost;
										eBestResource = eResource;
										pBestResourcePlot = pResourcePlot;
									}
								}
							}
						}
					}
				}
			}

			CvAssert(pBestResourcePlot);

			// Did we find something to show?
			if(pBestResourcePlot != NULL)
			{
				pBestResourcePlot->setRevealed(getTeam(), true);
				pBestResourcePlot->SetResourceForceReveal(getTeam(), true);
				//pBestPlot->updateFog();

				if(getTeam() == GC.getGame().getActiveTeam())
				{
					pBestResourcePlot->setLayoutDirty(true);
				}

				// Also reveal adjacent Plots
				CvPlot* pAdjacentPlot;
				for(int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; iDirectionLoop++)
				{
					pAdjacentPlot = plotDirection(pBestResourcePlot->getX(), pBestResourcePlot->getY(), ((DirectionTypes) iDirectionLoop));

					if(pAdjacentPlot != NULL)
					{
						pAdjacentPlot->setRevealed(getTeam(), true);
					}
				}

				CvString strTempString;
				strTempString.Format(" (%s)", GC.getResourceInfo(eBestResource)->GetDescription());
				strBuffer += strTempString;
			}
		}
	}

	// Unit Upgrade
	if(kGoodyInfo.isUpgradeUnit())
	{
		UnitClassTypes eUpgradeUnitClass = NO_UNITCLASS;
		UnitTypes eUpgradeUnit = NO_UNIT;

		if(pUnit != NULL)
		{
			eUpgradeUnitClass = (UnitClassTypes) pUnit->getUnitInfo().GetGoodyHutUpgradeUnitClass();
			eUpgradeUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eUpgradeUnitClass);
		}
		
		if(eUpgradeUnit != NO_UNIT)
		{
			// Add new upgrade Unit

			// if we promoted an scouting unit from a goody hut, turn him into whatever the new unit's default AI is if it is not a suitable explorer anymore
			UnitAITypes currentAIDefault = pUnit->AI_getUnitAIType();
			UnitAITypes newAIDefault = GC.getUnitInfo(eUpgradeUnit)->GetDefaultUnitAIType();
			if(currentAIDefault == UNITAI_EXPLORE)
			{
				if(newAIDefault == UNITAI_EXPLORE || newAIDefault == UNITAI_ATTACK || newAIDefault == UNITAI_DEFENSE || newAIDefault == UNITAI_FAST_ATTACK || newAIDefault == UNITAI_COUNTER)
				{
					newAIDefault = UNITAI_EXPLORE;
				}
			}

			CvUnit* pNewUnit = initUnit(eUpgradeUnit, pPlot->getX(), pPlot->getY(), newAIDefault, REASON_GIFT, false, false, 0, pUnit->GetNumGoodyHutsPopped());
			pUnit->finishMoves();
			pUnit->SetBeenPromotedFromGoody(true);

			CvAssert(pNewUnit);
			if (pNewUnit != NULL)
			{
#if defined(MOD_EVENTS_UNIT_UPGRADES)
			// MUST call the event before convert() as that kills the old unit
			if (MOD_EVENTS_UNIT_UPGRADES) {
				GAMEEVENTINVOKE_HOOK(GAMEEVENT_UnitUpgraded, GetID(), pUnit->GetID(), pNewUnit->GetID(), true);
			} else {
#endif
				ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
				if (pkScriptSystem)
				{
					CvLuaArgsHandle args;
					args->Push(GetID());
					args->Push(pUnit->GetID());
					args->Push(pNewUnit->GetID());
					args->Push(true); // bGoodyHut

					bool bScriptResult;
					LuaSupport::CallHook(pkScriptSystem, "UnitUpgraded", args.get(), bScriptResult);
				}
#if defined(MOD_EVENTS_UNIT_UPGRADES)
			}
#endif

				pNewUnit->convert(pUnit, true);
				pNewUnit->setupGraphical();
			}
			else
				pUnit->kill(false);

			// Since the old unit died, it will block the goody reward popup unless we call this
			GC.GetEngineUserInterface()->SetDontShowPopups(false);
		}
	}

	// Tech
	if(kGoodyInfo.isTech())
	{
		iBestValue = 0;
		eBestTech = NO_TECH;

		for(iI = 0; iI < GC.getNumTechInfos(); iI++)
		{
			const TechTypes eTech = static_cast<TechTypes>(iI);
			CvTechEntry* pkTech = GC.getTechInfo(eTech);
			if(pkTech != NULL && pkTech->IsGoodyTech())
			{
				if(GetPlayerTechs()->CanResearch(eTech))
				{
					bool bUseTech = true;

#if defined(MOD_EVENTS_GOODY_TECH)
					if (MOD_EVENTS_GOODY_TECH) {
						if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_GoodyHutCanResearch, GetID(), iI) == GAMEEVENTRETURN_FALSE) {
							bUseTech = false;
						}
					} else {
#endif
					ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
					if (pkScriptSystem)
					{
						CvLuaArgsHandle args;
						args->Push(GetID());
						args->Push(eTech);

						// Attempt to execute the game events.
						// Will return false if there are no registered listeners.
						bool bScriptResult = false;
						if (LuaSupport::CallTestAll(pkScriptSystem, "GoodyHutCanResearch", args.get(), bScriptResult))
						{
							bUseTech = bScriptResult;
						}
					}
#if defined(MOD_EVENTS_GOODY_TECH)
					}
#endif
#if defined(MOD_BALANCE_CORE)
					//Are we already researching a tech? No value here.
					if(MOD_BALANCE_CORE && GetPlayerTechs()->GetCurrentResearch() == eTech)
					{
						bUseTech = false;
					}
#endif
					if(bUseTech)
					{
						iValue = (1 + GC.getGame().getSmallFakeRandNum(10, iI));

						if(iValue > iBestValue)
						{
							iBestValue = iValue;
							eBestTech = eTech;
						}
					}
				}
			}
		}

		CvAssertMsg(eBestTech != NO_TECH, "BestTech is not assigned a valid value");

#if defined(MOD_EVENTS_GOODY_TECH)
		if (MOD_EVENTS_GOODY_TECH) {
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_GoodyHutTechResearched, GetID(), eBestTech);
		} else {
#endif
		ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
		if (pkScriptSystem) 
		{
			CvLuaArgsHandle args;
			args->Push(GetID());
			args->Push(eBestTech);

			bool bScriptResult;
			LuaSupport::CallHook(pkScriptSystem, "GoodyHutTechResearched", args.get(), bScriptResult);
		}
#if defined(MOD_EVENTS_GOODY_TECH)
		}
#endif

		GET_TEAM(getTeam()).setHasTech(eBestTech, true, GetID(), true, true);
		GET_TEAM(getTeam()).GetTeamTechs()->SetNoTradeTech(eBestTech, true);
	}

	// Units
	if(kGoodyInfo.getUnitClassType() != NO_UNITCLASS)
	{
		eUnit = (UnitTypes)getCivilizationInfo().getCivilizationUnits(kGoodyInfo.getUnitClassType());

		if(eUnit != NO_UNIT)
		{
			CvUnit* pNewUnit = initUnit(eUnit, pPlot->getX(), pPlot->getY());
			// see if there is an open spot to put him - no over-stacking allowed!
			if(pNewUnit && pUnit && pUnit->AreUnitsOfSameType(*pNewUnit))  // pUnit isn't in this plot yet (if it even exists) so we can't check on if we are over-stacked directly
			{
				pBestPlot = NULL;
				iBestValue = INT_MAX;
				const int iPopRange = 2;
				for(iDX = -(iPopRange); iDX <= iPopRange; iDX++)
				{
					for(iDY = -(iPopRange); iDY <= iPopRange; iDY++)
					{
						pLoopPlot	= plotXYWithRangeCheck(pPlot->getX(), pPlot->getY(), iDX, iDY, iPopRange);
						if(pLoopPlot != NULL)
						{
							if(pLoopPlot->isValidDomainForLocation(*pNewUnit) && pNewUnit->isMatchingDomain(pLoopPlot))
							{
								if(pNewUnit->canMoveInto(*pLoopPlot,CvUnit::MOVEFLAG_DESTINATION|CvUnit::MOVEFLAG_NO_ENEMY_TERRITORY))
								{
									if((pNewUnit->getDomainType() != DOMAIN_AIR) || pLoopPlot->isFriendlyCity(*pNewUnit))
									{
										if(pLoopPlot->isRevealed(getTeam()))
										{
											iValue = 1 + GC.getGame().getSmallFakeRandNum(6, *pLoopPlot); // okay, I'll admit it, not a great heuristic

											if(plotDistance(pPlot->getX(),pPlot->getY(),pLoopPlot->getX(),pLoopPlot->getY()) > 1)
											{
												iValue += 12;
											}

											if(pLoopPlot->area() != pPlot->area())  // jumped to a different land mass, cool
											{
												iValue *= 10;
											}

											if(iValue < iBestValue)
											{
												iBestValue = iValue;
												pBestPlot = pLoopPlot;
											}
										}
									}
								}
							}
						}
					}
				}
				if(pBestPlot != NULL)
				{
					bool bVis = pBestPlot->isVisibleToWatchingHuman();
					pNewUnit->setXY(pBestPlot->getX(), pBestPlot->getY(), false, true, true && bVis, true);
					pNewUnit->SetPosition(pBestPlot);	// Need this to put the unit in the right spot graphically
					pNewUnit->finishMoves();
				}
				else
				{
					pNewUnit->kill(false);
				}
			}
		}
	}

	// Barbarians
	if(kGoodyInfo.getBarbarianUnitClass() != NO_UNITCLASS)
	{
		iBarbCount = 0;

		eUnit = (UnitTypes)GET_PLAYER(BARBARIAN_PLAYER).getCivilizationInfo().getCivilizationUnits(kGoodyInfo.getBarbarianUnitClass());

		if(eUnit != NO_UNIT)
		{
			for(iPass = 0; iPass < 10; iPass++)
			{
				if(iBarbCount < kGoodyInfo.getMinBarbarians())
				{
					for(iI = 0; iI < NUM_DIRECTION_TYPES; iI++)
					{
						pLoopPlot = plotDirection(pPlot->getX(), pPlot->getY(), ((DirectionTypes)iI));

						if(pLoopPlot != NULL)
						{
							if(pLoopPlot->getArea() == pPlot->getArea())
							{
								if(pLoopPlot->isValidMovePlot(GetID()) && !pLoopPlot->isCity())
								{
									if(pLoopPlot->getNumUnits() == 0)
									{
										if((iPass > 0) || (GC.getGame().getSmallFakeRandNum(10, *pLoopPlot) * 10 < kGoodyInfo.getBarbarianUnitProb()))
										{
											GET_PLAYER(BARBARIAN_PLAYER).initUnit(eUnit, pLoopPlot->getX(), pLoopPlot->getY(), ((pLoopPlot->isWater()) ? UNITAI_ATTACK_SEA : UNITAI_ATTACK));
											iBarbCount++;

											if((iPass > 0) && (iBarbCount == kGoodyInfo.getMinBarbarians()))
											{
												break;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if(!strBuffer.empty() && GC.getGame().getActivePlayer() == GetID())
	{
		GC.GetEngineUserInterface()->AddPlotMessage(0, pPlot->GetPlotIndex(), GetID(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer);
	}

	// If it's the active player then show the popup
	if(GetID() == GC.getGame().getActivePlayer())
	{
		GC.getMap().updateDeferredFog();

		bool bDontShowRewardPopup = GC.GetEngineUserInterface()->IsOptionNoRewardPopups();

		// Don't show in MP, or if the player has turned it off
#if defined(MOD_API_EXTENSIONS)
		if(!GC.getGame().isReallyNetworkMultiPlayer() && !bDontShowRewardPopup)
#else
		if(!GC.getGame().isNetworkMultiPlayer() && !bDontShowRewardPopup)	// KWG: Candidate for !GC.getGame().isOption(GAMEOPTION_SIMULTANEOUS_TURNS)
#endif
		{
			int iSpecialValue = 0;

			if(iGold > 0)
				iSpecialValue = iGold;
			else if(iCulture > 0)
				iSpecialValue = iCulture;
			else if(iFaith > 0)
				iSpecialValue = iFaith;
#if defined(MOD_BALANCE_CORE)
			else if(iProduction > 0)
				iSpecialValue = iProduction;
#endif

			CvPopupInfo kPopupInfo(BUTTONPOPUP_GOODY_HUT_REWARD, eGoody, iSpecialValue);
			GC.GetEngineUserInterface()->AddPopup(kPopupInfo);
			// We are adding a popup that the player must make a choice in, make sure they are not in the end-turn phase.
			CancelActivePlayerEndTurn();
		}
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::doGoody(CvPlot* pPlot, CvUnit* pUnit)
{
	const CvHandicapInfo& playerHandicapInfo = getHandicapInfo();

	GoodyTypes eGoody;

	CvAssertMsg(pPlot->isGoody(), "pPlot->isGoody is expected to be true");

	if(!isBarbarian())
	{
		m_bEverPoppedGoody = true;
		pPlot->removeGoody();

		// Minors don't get Goodies :(
		if(isMinorCiv())
		{
			return;
		}

		// Need to have Goodies in the Handicap file to pick from
		if(playerHandicapInfo.getNumGoodies() > 0)
		{
			// Make a list of valid Goodies to pick randomly from
			int iValidGoodiesLoop;
			bool bValid;

			std::vector<GoodyTypes> avValidGoodies;
			for(int iGoodyLoop = 0; iGoodyLoop < playerHandicapInfo.getNumGoodies(); iGoodyLoop++)
			{
				eGoody = (GoodyTypes) playerHandicapInfo.getGoodies(iGoodyLoop);
				bValid = false;

				// Check to see if we've already verified this Goody is valid (since there can be multiples in the vector)
				for(iValidGoodiesLoop = 0; iValidGoodiesLoop < (int) avValidGoodies.size(); iValidGoodiesLoop++)
				{
					if(avValidGoodies[iValidGoodiesLoop] == eGoody)
					{
						avValidGoodies.push_back(eGoody);
						bValid = true;
						break;
					}
				}

				if(bValid)
					continue;

				if(canReceiveGoody(pPlot, eGoody, pUnit))
				{
					avValidGoodies.push_back(eGoody);
				}
			}

#if defined(MOD_GLOBAL_ANYTIME_GOODY_GOLD)
			// Any valid Goodies?  If not, add back the gold goody hut(s)
			if(MOD_GLOBAL_ANYTIME_GOODY_GOLD && avValidGoodies.size() == 0)
			{
				for(int iGoodyLoop = 0; iGoodyLoop < playerHandicapInfo.getNumGoodies(); iGoodyLoop++)
				{
					eGoody = (GoodyTypes) playerHandicapInfo.getGoodies(iGoodyLoop);

					Database::SingleResult kResult;
					const bool bResult = DB.SelectAt(kResult, "GoodyHuts", eGoody);
					DEBUG_VARIABLE(bResult);
					CvAssertMsg(bResult, "Cannot find goody info.");

					CvGoodyInfo kGoodyInfo;
					kGoodyInfo.CacheResult(kResult);

					if (kGoodyInfo.getGold() > 0)
					{
						avValidGoodies.push_back(eGoody);
					}
				}
			}
#endif

			// Any valid Goodies?
			if(avValidGoodies.size() > 0)
			{
#if defined(MOD_BUGFIX_MINOR)
				// Fix the bug where the AI won't get anything for Goody Hut pickers!!!
				if (pUnit && pUnit->isHasPromotion((PromotionTypes)GC.getPROMOTION_GOODY_HUT_PICKER()) && GET_PLAYER(pUnit->getOwner()).isHuman())
#else
				if (pUnit && pUnit->isHasPromotion((PromotionTypes)GC.getPROMOTION_GOODY_HUT_PICKER()))
#endif
				{
					if (GC.getGame().getActivePlayer() == GetID())

					{
						CvPopupInfo kPopupInfo(BUTTONPOPUP_CHOOSE_GOODY_HUT_REWARD, GetID(), pUnit->GetID());
						GC.GetEngineUserInterface()->AddPopup(kPopupInfo);
						// We are adding a popup that the player must make a choice in, make sure they are not in the end-turn phase.
#if defined(MOD_BUGFIX_MINOR)
						if (!GC.getGame().isReallyNetworkMultiPlayer())
						{
							CancelActivePlayerEndTurn();
						}
#else
						CancelActivePlayerEndTurn();
#endif
					}
				}
				else
				{
#if defined(MOD_CORE_REDUCE_RANDOMNESS)
					int iRand = GC.getGame().getSmallFakeRandNum(avValidGoodies.size(),*pPlot);
#else
					int iRand = GC.getGame().getJonRandNum(avValidGoodies.size(), "Picking a Goody result");
#endif
					eGoody = (GoodyTypes) avValidGoodies[iRand];
					receiveGoody(pPlot, eGoody, pUnit);
#if defined(MOD_EVENTS_GOODY_CHOICE)
					if (MOD_EVENTS_GOODY_CHOICE)
						//   GameEvents.GoodyHutReceivedBonus.Add(function(iPlayer, iUnit, eGoody, iX, iY) end)
						GAMEEVENTINVOKE_HOOK(GAMEEVENT_GoodyHutReceivedBonus, GetID(), pUnit ? pUnit->GetID() : -1, eGoody, pPlot->getX(), pPlot->getY());
#endif
				}
				
#if !defined(NO_ACHIEVEMENTS)
				if (pUnit && isHuman() && !GC.getGame().isGameMultiPlayer())
				{
					pUnit->ChangeNumGoodyHutsPopped(pUnit->GetNumGoodyHutsPopped() + 1);
					if (pUnit->isHasPromotion((PromotionTypes)GC.getPROMOTION_GOODY_HUT_PICKER()) && pUnit->GetNumGoodyHutsPopped() >= 5)
					{
						gDLL->UnlockAchievement(ACHIEVEMENT_XP2_25);
					}
				}
#endif
			}

			pPlot->AddArchaeologicalRecord(CvTypes::getARTIFACT_ANCIENT_RUIN(), m_eID, NO_PLAYER);
		}
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::AwardFreeBuildings(CvCity* pCity)
{
	int iNumFreeCultureBuildings = GetNumCitiesFreeCultureBuilding();
	if(iNumFreeCultureBuildings > 0)
	{
		BuildingTypes eBuilding = pCity->ChooseFreeCultureBuilding();
		if(eBuilding != NO_BUILDING)
		{
			pCity->GetCityBuildings()->SetNumFreeBuilding(eBuilding, 1);
		}
		else
		{
			pCity->SetOwedCultureBuilding(true);
		}

		ChangeNumCitiesFreeCultureBuilding(-1);
	}

	int iNumFreeFoodBuildings = GetNumCitiesFreeFoodBuilding();
	if(iNumFreeFoodBuildings > 0)
	{
		BuildingTypes eBuilding = pCity->ChooseFreeFoodBuilding();
		if(eBuilding != NO_BUILDING)
		{
			pCity->GetCityBuildings()->SetNumFreeBuilding(eBuilding, 1);
		}
#if defined(MOD_BUGFIX_FREE_FOOD_BUILDING)
		else
		{
			pCity->SetOwedFoodBuilding(true);
		}
#endif

		ChangeNumCitiesFreeFoodBuilding(-1);
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNoSettling(int iPlotIndex)
{
	m_noSettlingPlots.insert(iPlotIndex);
}
bool CvPlayer::IsNoSettling(int iPlotIndex) const
{
	return m_noSettlingPlots.find(iPlotIndex)!= m_noSettlingPlots.end();
}
void CvPlayer::ClearNoSettling()
{
	m_noSettlingPlots.clear();
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canFound(int iX, int iY) const
{
	return canFound(iX,iY,false,false,NULL);
}

bool CvPlayer::canFound(int iX, int iY, bool bIgnoreDistanceToExistingCities, bool bIgnoreHappiness, const CvUnit* pUnit) const
{
	CvPlot* pPlot = GC.getMap().plot(iX, iY);

#if defined(MOD_EVENTS_CITY_FOUNDING)
	if (MOD_EVENTS_CITY_FOUNDING) {
		if (GAMEEVENTINVOKE_TESTANY(GAMEEVENT_PlayerCanFoundCityRegardless, GetID(), iX, iY) == GAMEEVENTRETURN_TRUE) {
			return true;
		}
	}
#endif

#if defined(MOD_EVENTS_CITY_FOUNDING)
	if (MOD_EVENTS_CITY_FOUNDING) {
		if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_PlayerCanFoundCity, GetID(), iX, iY) == GAMEEVENTRETURN_FALSE) {
			return false;
		}
	}
#endif

	// Has the AI agreed to not settle here?
	if(IsNoSettling(pPlot->GetPlotIndex()))
		return false;

	// Settlers cannot found cities while empire is very unhappy
	if(!bIgnoreHappiness && IsEmpireVeryUnhappy())
		return false;

	return GC.getGame().GetSettlerSiteEvaluator()->CanFound(pPlot, this, bIgnoreDistanceToExistingCities, pUnit);
}

//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_RELIGIOUS_SETTLERS) && defined(MOD_BALANCE_CORE)
void CvPlayer::found(int iX, int iY, ReligionTypes eReligion, bool bForce, CvUnitEntry* pkSettlerUnitEntry)
#elif defined(MOD_GLOBAL_RELIGIOUS_SETTLERS)
void CvPlayer::found(int iX, int iY, ReligionTypes eReligion, bool bForce)
#elif defined(MOD_BALANCE_CORE)
void CvPlayer::found(int iX, int iY, CvUnitEntry* pkSettlerUnitEntry = NULL)
#else
void CvPlayer::found(int iX, int iY)
#endif
{
	if(!bForce && !canFound(iX, iY))
	{
		return;
	}

	SetTurnsSinceSettledLastCity(0);

#if defined(MOD_GLOBAL_RELIGIOUS_SETTLERS) && defined(MOD_API_EXTENSIONS) && defined(MOD_BALANCE_CORE)
	CvCity* pCity = initCity(iX, iY, true, true, eReligion, NULL, pkSettlerUnitEntry);
#elif defined(MOD_GLOBAL_RELIGIOUS_SETTLERS) && defined(MOD_API_EXTENSIONS)
	CvCity* pCity = initCity(iX, iY, true, true, eReligion);
#elif defined(MOD_BALANCE_CORE)
	CvCity* pCity = initCity(iX, iY, pkSettlerUnitEntry);
#else
	CvCity* pCity = initCity(iX, iY);
#endif
	CvAssertMsg(pCity != NULL, "City is not assigned a valid value");
	if(pCity == NULL)
		return;

	int iExtraTerritoryClaim = GetPlayerTraits()->GetExtraFoundedCityTerritoryClaimRange();
	for (int i = 0; i < iExtraTerritoryClaim; i++)
	{
		CvPlot* pPlotToAcquire = pCity->GetNextBuyablePlot(false);

		// maybe the player owns ALL of the plots or there are none available?
		if(pPlotToAcquire)
		{
			pCity->DoAcquirePlot(pPlotToAcquire->getX(), pPlotToAcquire->getY());
		}
	}
#if defined(MOD_BALANCE_CORE)
	if(MOD_BALANCE_CORE && !isMinorCiv() && (GetNumCitiesFounded() <= 1))
	{
		if(GetPlayerTraits()->IsPopulationBoostReligion())
		{
			int iFaith = GC.getGame().GetGameReligions()->GetMinimumFaithNextPantheon();
			SetFaith(iFaith);
			if(GC.getGame().GetGameReligions()->CanCreatePantheon(GetID(), true) == 0)
			{
				// Create the pantheon
				if(isHuman())
				{
					//If the player is human then a net message will be received which will pick the pantheon.
					CvNotifications* pNotifications = GetNotifications();
					if(pNotifications)
					{
						CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_ENOUGH_FAITH_FOR_PANTHEON");

						CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_ENOUGH_FAITH_FOR_PANTHEON");
						pNotifications->Add(NOTIFICATION_FOUND_PANTHEON, strBuffer, strSummary, -1, -1, -1);
					}
				}
				else
				{
	#if defined(MOD_EVENTS_ACQUIRE_BELIEFS)
					const BeliefTypes eBelief = GetReligionAI()->ChoosePantheonBelief(GetID());
	#else
					const BeliefTypes eBelief = owningPlayer.GetReligionAI()->ChoosePantheonBelief();
	#endif

					GC.getGame().GetGameReligions()->FoundPantheon(GetID(), eBelief);
				}
			}
		}
	}
#endif
	for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
	{
		const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iI);
		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
		if(pkBuildingClassInfo)
		{
			const BuildingTypes eLoopBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(iI)));
			if(eLoopBuilding != NO_BUILDING)
			{
				CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eLoopBuilding);
				if(pkBuildingInfo)
				{
					if(pkBuildingInfo->GetFreeStartEra() != NO_ERA)
					{
						if(GC.getGame().getStartEra() >= pkBuildingInfo->GetFreeStartEra())
						{
							if(pCity->canConstruct(eLoopBuilding))
							{
								pCity->GetCityBuildings()->SetNumRealBuilding(eLoopBuilding, 1);

#if defined(MOD_EVENTS_CITY)
								if (MOD_EVENTS_CITY)
								{
									GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityConstructed, pCity->getOwner(), pCity->GetID(), eLoopBuilding, false, false);
								}
#endif
							}
						}
					}
				}
			}
		}
	}

	AwardFreeBuildings(pCity);

	DoUpdateNextPolicyCost();

	if(isHuman() && getAdvancedStartPoints() < 0)
	{
		// Human player is prompted to choose production BEFORE the AI runs for the turn.
		// So we'll force the AI strategies on the city now, just after it is founded.
		// And if the very first turn, we haven't even run player strategies once yet, so do that too.
		if(GC.getGame().getGameTurn() == 0)
		{
			this->GetEconomicAI()->DoTurn();
			this->GetMilitaryAI()->DoTurn();
			this->GetReligionAI()->DoTurn();
			this->GetEspionageAI()->DoTurn();
			this->GetTradeAI()->DoTurn();
		}
		pCity->GetCityStrategyAI()->DoTurn();

		if (!pCity->IsPuppet())
			pCity->chooseProduction();

		pCity->doFoundMessage();

		// If this is the first city (or we still aren't getting tech for some other reason notify the player)
		if(GetPlayerTechs()->GetCurrentResearch() == NO_TECH && GetScienceTimes100() > 0)
		{
			if(GetID() == GC.getGame().getActivePlayer())
			{
				chooseTech();
			}
		}
	}
	else
	{
		pCity->doFoundMessage();

		// AI civ, may need to redo city specializations
		GetCitySpecializationAI()->SetSpecializationsDirty(SPECIALIZATION_UPDATE_CITY_FOUNDED);
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(pCity->getX());
		args->Push(pCity->getY());
		
		bool bResult;
		LuaSupport::CallHook(pkScriptSystem, "PlayerCityFounded", args.get(), bResult);
	}
}

#if defined(MOD_BALANCE_CORE_SETTLER)
void CvPlayer::cityBoost(int iX, int iY, CvUnitEntry* pkUnitEntry, int iExtraPlots, int iPopChange, int iFoodPercent)
{
	//Advanced Settler Buildings
	if(pkUnitEntry && !isMinorCiv() && !isBarbarian())
	{
		CvPlot* pPlot = GC.getMap().plot(iX, iY);
		CvCity* pCity = pPlot ? pPlot->getPlotCity() : NULL;

		if(!pCity)
			return;

		const int iNumBuildingClassInfos = GC.getNumBuildingClassInfos();
		const CvCivilizationInfo& thisCivilization = getCivilizationInfo();
		for(int iBuildingClassLoop = 0; iBuildingClassLoop < iNumBuildingClassInfos; iBuildingClassLoop++)
		{
			const BuildingClassTypes eBuildingClass = (BuildingClassTypes) iBuildingClassLoop;
			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
			if(!pkBuildingClassInfo)
			{
				continue;
			}
			if(pkUnitEntry->GetBuildOnFound(eBuildingClass))
			{
				const BuildingTypes eFreeBuilding = (BuildingTypes)(thisCivilization.getCivilizationBuildings(eBuildingClass));
				if(pCity->isValidBuildingLocation(eFreeBuilding))
				{
					pCity->GetCityBuildings()->SetNumRealBuilding(eFreeBuilding, 1, true);
				}
			}
		}

		pCity->setPopulation(GetNewCityExtraPopulation() + iPopChange, true, true);

		//25% food, to prevent instant-starvation
		pCity->changeFood((pCity->growthThreshold() * iFoodPercent / 100));

		//And a little territory to boot
		for (int i = 0; i < iExtraPlots; i++)
		{
			CvPlot* pPlotToAcquire = pCity->GetNextBuyablePlot(false);

			// maybe the player owns ALL of the plots or there are none available?
			if(pPlotToAcquire)
			{
				pCity->DoAcquirePlot(pPlotToAcquire->getX(), pPlotToAcquire->getY());
			}
		}
	}
}
#endif

//	--------------------------------------------------------------------------------
bool CvPlayer::canTrain(UnitTypes eUnit, bool bContinue, bool bTestVisible, bool bIgnoreCost, bool bIgnoreUniqueUnitStatus, CvString* toolTipSink) const
{
	CvUnitEntry* pUnitInfoPtr = GC.getUnitInfo(eUnit);
	if(pUnitInfoPtr == NULL)
		return false;

	CvUnitEntry& pUnitInfo = *pUnitInfoPtr;

	const UnitClassTypes eUnitClass = (UnitClassTypes) pUnitInfo.GetUnitClassType();
	if(eUnitClass == NO_UNITCLASS)
	{
		return false;
	}

	CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
	if(pkUnitClassInfo == NULL)
	{
		return false;
	}

	if (GetPlayerTraits()->NoTrain(eUnitClass))
	{
		return false;
	}
#if defined(MOD_BALANCE_CORE_MINOR_CIV_GIFT)
	if(MOD_BALANCE_CORE_MINOR_CIV_GIFT && pUnitInfo.IsMinorCivGift() && !isBarbarian())
	{
		return false;
	}
#endif
#if defined(MOD_BALANCE_CORE_MILITARY)
	if(MOD_BALANCE_CORE_MILITARY && !isHuman() && !pUnitInfo.IsNoSupply())
	{
		if (((pUnitInfo.GetCombat() > 0) || (pUnitInfo.GetRangedCombat() > 0)) && !isBarbarian() && GetNumUnitsOutOfSupply() > 15)
		{
			return false;
		}
	}
#endif
	// Should we check whether this Unit has been blocked out by the civ XML?
	if(!bIgnoreUniqueUnitStatus)
	{
		UnitTypes eThisPlayersUnitType = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eUnitClass);

		// If the player isn't allowed to train this Unit (via XML) then return false
		if(eThisPlayersUnitType != eUnit)
		{
			return false;
		}
	}

	if(!bIgnoreCost)
	{
		if(pUnitInfo.GetProductionCost() == -1)
		{
			return false;
		}
	}
#if defined(MOD_BALANCE_CORE)
	ResourceTypes eResource = (ResourceTypes)pUnitInfo.GetResourceType();
	if (MOD_BALANCE_CORE && eResource != NO_RESOURCE && !isBarbarian())
	{
		if (getNumResourceTotal(eResource, true) <= 0)
		{
			return false;
		}
	}

	if(pUnitInfo.IsWarOnly())
	{
		if(!IsAtWarAnyMajor())
		{
			return false;
		}
	}
#endif

	// One City Challenge
	if(pUnitInfo.IsFound() || pUnitInfo.IsFoundAbroad())
	{
		if(GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && isHuman())
		{
			return false;
		}
	}
	
	//Policy Requirement
	PolicyTypes ePolicy = (PolicyTypes)pUnitInfo.GetPolicyType();
	if (ePolicy != NO_POLICY)
	{
		if (!GetPlayerPolicies()->HasPolicy(ePolicy))
		{
			return false;
		}
	}


	if (GC.getGame().isOption(GAMEOPTION_NO_RELIGION))
	{
		if (pUnitInfo.IsFoundReligion() || pUnitInfo.IsSpreadReligion() || pUnitInfo.IsRemoveHeresy())
		{
			return false;
		}
	}

	if(!bContinue)
	{
		if(!bTestVisible)
		{
			// Builder Limit
			if(pUnitInfo.GetWorkRate() > 0 && pUnitInfo.GetDomainType() == DOMAIN_LAND)
			{
				if(GetMaxNumBuilders() > -1 && GetNumBuilders() >= GetMaxNumBuilders())
				{
					return false;
				}
			}
		}
	}

	// Tech requirements
	if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pUnitInfo.GetPrereqAndTech()))))
	{
		return false;
	}

	int iI;
	for(iI = 0; iI < GC.getNUM_UNIT_AND_TECH_PREREQS(); iI++)
	{
		if(pUnitInfo.GetPrereqAndTechs(iI) != NO_TECH)
		{
			if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pUnitInfo.GetPrereqAndTechs(iI)))))
			{
				return false;
			}
		}
	}

	// Obsolete Tech
	if((TechTypes)pUnitInfo.GetObsoleteTech() != NO_TECH)
	{
		if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pUnitInfo.GetObsoleteTech())))
		{
			return false;
		}
	}

	// Game Unit Class Max
	if(GC.getGame().isUnitClassMaxedOut(eUnitClass))
	{
		return false;
	}

	// Team Unit Class Max
	if(GET_TEAM(getTeam()).isUnitClassMaxedOut(eUnitClass))
	{
		return false;
	}

	// Player Unit Class Max
	if(isUnitClassMaxedOut(eUnitClass))
	{
		return false;
	}

	// Spaceship part we already have?
	ProjectTypes eProject = (ProjectTypes) pUnitInfo.GetSpaceshipProject();
	if(eProject != NO_PROJECT)
	{
		if(GET_TEAM(getTeam()).isProjectMaxedOut(eProject))
			return false;

		int iUnitAndProjectCount = GET_TEAM(getTeam()).getProjectCount(eProject) + getUnitClassCount(eUnitClass) + GET_TEAM(getTeam()).getUnitClassMaking(eUnitClass) + ((bContinue) ? -1 : 0);
		if(iUnitAndProjectCount >= pkUnitClassInfo->getMaxPlayerInstances())
		{
			return false;
		}
	}

	if(!bTestVisible)
	{
#if defined(MOD_BALANCE_CORE_MILITARY)
		if (MOD_BALANCE_CORE_MILITARY && !pUnitInfo.IsNoSupply() && (pUnitInfo.GetCombat() > 0 || pUnitInfo.GetRangedCombat() > 0) && !isBarbarian() && GetNumUnitsOutOfSupply() > 15)
		{
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_NO_SUPPLY");
			if(toolTipSink == NULL)
			return false;
		}
#endif
		// Settlers
		if(pUnitInfo.IsFound() || pUnitInfo.IsFoundAbroad())
		{
			if(IsEmpireVeryUnhappy() && GC.getVERY_UNHAPPY_CANT_TRAIN_SETTLERS() == 1)
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_VERY_UNHAPPY_SETTLERS");
				if(toolTipSink == NULL)
					return false;
			}
		}

		// Project required?
		ProjectTypes ePrereqProject = (ProjectTypes) pUnitInfo.GetProjectPrereq();
		if(ePrereqProject != NO_PROJECT)
		{
			CvProjectEntry* pkProjectInfo = GC.getProjectInfo(ePrereqProject);
			if(pkProjectInfo)
			{
				if(GET_TEAM(getTeam()).getProjectCount(ePrereqProject) == 0)
				{
					GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_UNIT_PROJECT_REQUIRED", pkProjectInfo->GetDescription());
					if(toolTipSink == NULL)
						return false;
				}
			}
		}

		// Resource Requirements
		for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
		{
			const ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);
			CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);
			if(pkResourceInfo)
			{
				const int iNumResource = pUnitInfo.GetResourceQuantityRequirement(eResource);

				if(iNumResource > 0)
				{
					// Starting project, need enough Resources plus some to start
					if(!bContinue && getNumResourceAvailable(eResource) < iNumResource)
					{
						GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_UNIT_LACKS_RESOURCES", pkResourceInfo->GetIconString(), pkResourceInfo->GetTextKey(), iNumResource);
						if(toolTipSink == NULL)
							return false;
					}
					// Continuing project, need enough Resources
					else if(bContinue && (getNumResourceAvailable(eResource) < 0))
					{
						GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_UNIT_LACKS_RESOURCES", pkResourceInfo->GetIconString(), pkResourceInfo->GetTextKey(), iNumResource);
						if(toolTipSink == NULL)
							return false;
					}
				}
			}

		}

		if(GC.getGame().isUnitClassMaxedOut(eUnitClass, (GET_TEAM(getTeam()).getUnitClassMaking(eUnitClass) + ((bContinue) ? -1 : 0))))
		{
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_GAME_COUNT_MAX", "", "", pkUnitClassInfo->getMaxTeamInstances());
			if(toolTipSink == NULL)
				return false;
		}

		if(GET_TEAM(getTeam()).isUnitClassMaxedOut(eUnitClass, (GET_TEAM(getTeam()).getUnitClassMaking(eUnitClass) + ((bContinue) ? -1 : 0))))
		{
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_TEAM_COUNT_MAX", "", "", pkUnitClassInfo->getMaxTeamInstances());
			if(toolTipSink == NULL)
				return false;
		}

		if(isUnitClassMaxedOut(eUnitClass, (getUnitClassMaking(eUnitClass) + ((bContinue) ? -1 : 0))))
		{
#if defined(MOD_BALANCE_CORE)
			if(isNationalUnitClass(eUnitClass))
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_PLAYER_COUNT_MAX", "", "", pkUnitClassInfo->getMaxPlayerInstances());
				if(toolTipSink == NULL)
					return false;
			}
			if(isUnitLimitPerCity(eUnitClass))
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_PLAYER_CITY_COUNT_MAX", "", "", (getNumCities() * pkUnitClassInfo->getUnitInstancePerCity()));
				if(toolTipSink == NULL)
					return false;
			}
#else
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_PLAYER_COUNT_MAX", "", "", pkUnitClassInfo->getMaxPlayerInstances());
			if(toolTipSink == NULL)
				return false;
#endif
		}

		if(GC.getGame().isNoNukes() || !GC.getGame().isNukesValid())
		{
			if(pUnitInfo.GetNukeDamageLevel() != -1)
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_NUKES");
				if(toolTipSink == NULL)
					return false;
			}
		}

		if(pUnitInfo.GetNukeDamageLevel() != -1)
		{
			if(GC.getGame().GetGameLeagues()->IsNoTrainingNuclearWeapons(GetID()))
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_NUKES_BY_RESOLUTION");
				if(toolTipSink == NULL)
					return false;
			}
		}

		if(pUnitInfo.GetSpecialUnitType() != NO_SPECIALUNIT)
		{
			if(!(GC.getGame().isSpecialUnitValid((SpecialUnitTypes)(pUnitInfo.GetSpecialUnitType()))))
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_SPECIAL_UNIT");
				if(toolTipSink == NULL)
					return false;
			}
		}

		if (pUnitInfo.IsTrade())
		{
			if (GetTrade()->GetNumTradeUnitsRemaining(!bContinue) <= 0)
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_TRADE_UNIT_CONSTRUCTION_NO_EXTRA_SLOTS");
				if (toolTipSink == NULL)
					return false;			
			}

			DomainTypes eDomain = (DomainTypes)pUnitInfo.GetDomainType();
			if (!GetTrade()->CanCreateTradeRoute(eDomain))
			{
				if (eDomain == DOMAIN_LAND)
				{
					GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_TRADE_UNIT_CONSTRUCTION_NONE_OF_TYPE_LAND");
				}
				else if (eDomain == DOMAIN_SEA)
				{
					GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_TRADE_UNIT_CONSTRUCTION_NONE_OF_TYPE_SEA");
				}
				if (toolTipSink == NULL)
					return false;
			}
		}
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(eUnit);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if(LuaSupport::CallTestAll(pkScriptSystem, "PlayerCanTrain", args.get(), bResult))
		{
			// Check the result.
			if(bResult == false)
			{
				return false;
			}
		}
	}

	return true;
}

#if defined(MOD_BALANCE_CORE)
bool CvPlayer::canBarbariansTrain(UnitTypes eUnit, bool bIgnoreUniqueUnitStatus, ResourceTypes eResourceNearby) const
{
	CvUnitEntry* pUnitInfoPtr = GC.getUnitInfo(eUnit);
	if (pUnitInfoPtr == NULL)
		return false;

	CvUnitEntry& pUnitInfo = *pUnitInfoPtr;

	const UnitClassTypes eUnitClass = (UnitClassTypes)pUnitInfo.GetUnitClassType();
	if (eUnitClass == NO_UNITCLASS)
	{
		return false;
	}

	CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
	if (pkUnitClassInfo == NULL)
	{
		return false;
	}

	if (GetPlayerTraits()->NoTrain(eUnitClass))
	{
		return false;
	}

	// Should we check whether this Unit has been blocked out by the civ XML?
	if (!bIgnoreUniqueUnitStatus)
	{
		UnitTypes eThisPlayersUnitType = (UnitTypes)getCivilizationInfo().getCivilizationUnits(eUnitClass);

		// If the player isn't allowed to train this Unit (via XML) then return false
		if (eThisPlayersUnitType != eUnit)
		{
			return false;
		}
	}

	if (pUnitInfo.GetProductionCost() == -1)
	{
		return false;
	}

	//Policy Requirement
	PolicyTypes ePolicy = (PolicyTypes)pUnitInfo.GetPolicyType();
	if (ePolicy != NO_POLICY)
	{
		if (!GetPlayerPolicies()->HasPolicy(ePolicy))
		{
			return false;
		}
	}

	if (pUnitInfo.IsFoundReligion() || pUnitInfo.IsSpreadReligion() || pUnitInfo.IsRemoveHeresy())
	{
		return false;
	}
	// Builder Limit
	if (pUnitInfo.GetWorkRate() > 0 && pUnitInfo.GetDomainType() == DOMAIN_LAND)
	{
		return false;
	}

	// Tech requirements
	if (!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pUnitInfo.GetPrereqAndTech()))))
	{
		return false;
	}

	int iI;
	for (iI = 0; iI < GC.getNUM_UNIT_AND_TECH_PREREQS(); iI++)
	{
		if (pUnitInfo.GetPrereqAndTechs(iI) != NO_TECH)
		{
			if (!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pUnitInfo.GetPrereqAndTechs(iI)))))
			{
				return false;
			}
		}
	}

	// Obsolete Tech
	if ((TechTypes)pUnitInfo.GetObsoleteTech() != NO_TECH)
	{
		if (GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pUnitInfo.GetObsoleteTech())))
		{
			return false;
		}
	}

	// Game Unit Class Max
	if (GC.getGame().isUnitClassMaxedOut(eUnitClass))
	{
		return false;
	}

	// Team Unit Class Max
	if (GET_TEAM(getTeam()).isUnitClassMaxedOut(eUnitClass))
	{
		return false;
	}

	// Player Unit Class Max
	if (isUnitClassMaxedOut(eUnitClass))
	{
		return false;
	}

	// Spaceship part we already have?
	ProjectTypes eProject = (ProjectTypes)pUnitInfo.GetSpaceshipProject();
	if (eProject != NO_PROJECT)
	{
		return false;
	}

	// Settlers
	if (pUnitInfo.IsFound() || pUnitInfo.IsFoundAbroad())
	{
		return false;
	}

	// Project required?
	ProjectTypes ePrereqProject = (ProjectTypes)pUnitInfo.GetProjectPrereq();
	if (ePrereqProject != NO_PROJECT)
	{
		return false;
	}

	// Resource Requirements
	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		const ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);
		CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);
		if (pkResourceInfo)
		{
			const int iNumResource = pUnitInfo.GetResourceQuantityRequirement(eResource);

			if (iNumResource > 0 && eResource != eResourceNearby)
			{
				return false;
			}
		}

	}

	if (pUnitInfo.GetNukeDamageLevel() != -1)
	{
		return false;
	}
	//Had to set it this way because Barbarian land units are "SPECIALUNIT_CARGO_ARMY" in MOD_CARGO_SHIPS. Need to be able to spawn them.
	SpecialUnitTypes eSpedcialPeople = (SpecialUnitTypes) GC.getInfoTypeForString("SPECIALUNIT_PEOPLE");
	SpecialUnitTypes eSpedcialFighter = (SpecialUnitTypes) GC.getInfoTypeForString("SPECIALUNIT_FIGHTER");
	SpecialUnitTypes eSpedcialStealth = (SpecialUnitTypes) GC.getInfoTypeForString("SPECIALUNIT_STEALTH");
	SpecialUnitTypes eSpedcialMissile = (SpecialUnitTypes) GC.getInfoTypeForString("SPECIALUNIT_MISSILE");
	if ((pUnitInfo.GetSpecialUnitType() == eSpedcialPeople) || (pUnitInfo.GetSpecialUnitType() == eSpedcialFighter) || (pUnitInfo.GetSpecialUnitType() == eSpedcialStealth) || (pUnitInfo.GetSpecialUnitType() == eSpedcialMissile))
	{
		return false;
	}

	if (pUnitInfo.IsTrade())
	{
		return false;
	}

	return true;
}
#endif
//	--------------------------------------------------------------------------------
bool CvPlayer::canConstruct(BuildingTypes eBuilding, bool bContinue, bool bTestVisible, bool bIgnoreCost, CvString* toolTipSink) const
{
	std::vector<int> vTotalBuildingCount( GC.getNumBuildingInfos(), 0);
	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity && !pLoopCity->IsPuppet())
		{
			const std::vector<BuildingTypes>& vBuildings = pLoopCity->GetCityBuildings()->GetAllBuildingsHere();
			for (size_t i=0; i<vBuildings.size(); i++)
				vTotalBuildingCount[ vBuildings[i] ]++;
		}
	}

	return canConstruct(eBuilding,vTotalBuildingCount,bContinue,bTestVisible,bIgnoreCost,toolTipSink);
}

bool CvPlayer::canConstruct(BuildingTypes eBuilding, const std::vector<int>& vPreExistingBuildings, bool bContinue, bool bTestVisible, bool bIgnoreCost, CvString* toolTipSink) const
{
	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if(pkBuildingInfo == NULL)
		return false;

	// Don't allow a city to consider an espionage building if they are playing a non-espionage game
	if (pkBuildingInfo->IsEspionage() && pkBuildingInfo->GetDefenseHappinessChangeBuilding() == 0 && pkBuildingInfo->GetDefenseHappinessChangeBuildingGlobal() == 0 && GC.getGame().isOption(GAMEOPTION_NO_ESPIONAGE))
	{
		return false;
	}

	CvBuildingEntry& pBuildingInfo = *pkBuildingInfo;

	int iI;
	CvTeam& currentTeam = GET_TEAM(getTeam());

	const BuildingClassTypes eBuildingClass = ((BuildingClassTypes)(pBuildingInfo.GetBuildingClassType()));
	const CvBuildingClassInfo& kBuildingClass = pkBuildingInfo->GetBuildingClassInfo();

	// Checks to make sure civilization doesn't have an override that prevents construction of this building
	if(getCivilizationInfo().getCivilizationBuildings(eBuildingClass) != eBuilding)
	{
		return false;
	}

	if(!bIgnoreCost)
	{
		if(pBuildingInfo.GetProductionCost() == -1)
		{
			return false;
		}
	}

	PolicyBranchTypes eBranch = (PolicyBranchTypes)pBuildingInfo.GetPolicyBranchType();
	if (eBranch != NO_POLICY_BRANCH_TYPE)
	{
		if (!GetPlayerPolicies()->IsPolicyBranchUnlocked(eBranch))
		{
			return false;
		}
	}
#if defined(MOD_BALANCE_CORE_POLICIES)
	PolicyTypes ePolicy = (PolicyTypes)pBuildingInfo.GetPolicyType();
	if (MOD_BALANCE_CORE_POLICIES && ePolicy != NO_POLICY)
	{
		if (!GetPlayerPolicies()->HasPolicy(ePolicy))
		{
			return false;
		}
	}
#endif
#if defined(MOD_BALANCE_CORE)
	ResourceTypes eResource = (ResourceTypes)pBuildingInfo.GetResourceType();
	if (MOD_BALANCE_CORE && eResource != NO_RESOURCE)
	{
		if (getNumResourceTotal(eResource, true) <= 0)
		{
			return false;
		}
	}
#endif
	if(!(currentTeam.GetTeamTechs()->HasTech((TechTypes)(pBuildingInfo.GetPrereqAndTech()))))
	{
		return false;
	}
	for(iI = 0; iI < GC.getNUM_BUILDING_AND_TECH_PREREQS(); iI++)
	{
		if(pBuildingInfo.GetPrereqAndTechs(iI) != NO_TECH)
		{
			if(!(currentTeam.GetTeamTechs()->HasTech((TechTypes)(pBuildingInfo.GetPrereqAndTechs(iI)))))
			{
				return false;
			}
		}
	}

	if(currentTeam.isObsoleteBuilding(eBuilding))
	{
		return false;
	}

	// Building upgrade to another type
	BuildingClassTypes eReplacementBuildingClass = (BuildingClassTypes) pBuildingInfo.GetReplacementBuildingClass();

	if(eReplacementBuildingClass != NO_BUILDINGCLASS)
	{
		BuildingTypes eUpgradeBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(eReplacementBuildingClass)));

		if(canConstruct(eUpgradeBuilding))
		{
			return false;
		}
	}

	if(pBuildingInfo.GetVictoryPrereq() != NO_VICTORY)
	{
		if(!(GC.getGame().isVictoryValid((VictoryTypes)(pBuildingInfo.GetVictoryPrereq()))))
		{
			return false;
		}

		if(isMinorCiv())
		{
			return false;
		}

		if(currentTeam.getVictoryCountdown((VictoryTypes)pBuildingInfo.GetVictoryPrereq()) >= 0)
		{
			return false;
		}
	}

	if(pBuildingInfo.GetMaxStartEra() != NO_ERA)
	{
		if(GC.getGame().getStartEra() > pBuildingInfo.GetMaxStartEra())
		{
			return false;
		}
	}

	if(GC.getGame().isBuildingClassMaxedOut(eBuildingClass))
	{
		return false;
	}

	if(currentTeam.isBuildingClassMaxedOut(eBuildingClass))
	{
		return false;
	}

	if(isBuildingClassMaxedOut(eBuildingClass))
	{
		return false;
	}

	if (pBuildingInfo.GetNumRequiredTier3Tenets() > 0)
	{
		PolicyBranchTypes eIdeology = GetPlayerPolicies()->GetLateGamePolicyTree();
		if (eIdeology == NO_POLICY_BRANCH_TYPE)
			return false;
	}
	

	///////////////////////////////////////////////////////////////////////////////////
	// Everything above this is what is checked to see if Building shows up in the list of construction items
	///////////////////////////////////////////////////////////////////////////////////

	if(!bTestVisible)
	{
		if (pBuildingInfo.GetNumRequiredTier3Tenets() > 0)
		{
			PolicyBranchTypes eIdeology = GetPlayerPolicies()->GetLateGamePolicyTree();

			int iNumTenets = GetPlayerPolicies()->GetNumTenetsOfLevel(eIdeology, 3);
			if (iNumTenets < pBuildingInfo.GetNumRequiredTier3Tenets())
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_TENETS_COUNT_NEEDED", pkBuildingInfo->GetTextKey(), "", pBuildingInfo.GetNumRequiredTier3Tenets() - iNumTenets);

				if (toolTipSink == NULL)
					return false;
			}
		}

		// Num buildings in the empire... uhhh, how is this different from the very last check in this function? (JON: It doesn't appear to be used, but I can't say for sure :)
		const CvCivilizationInfo& civilizationInfo = getCivilizationInfo();
		int numBuildingClassInfos = GC.getNumBuildingClassInfos();

		for(iI = 0; iI < numBuildingClassInfos; iI++)
		{
			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo((BuildingClassTypes)iI);
			if(!pkBuildingClassInfo)
			{
				continue;
			}

			BuildingTypes ePrereqBuilding = (BuildingTypes)civilizationInfo.getCivilizationBuildings(iI);

			if(NO_BUILDING != ePrereqBuilding && currentTeam.isObsoleteBuilding(ePrereqBuilding))
			{
				CvBuildingEntry* pkPrereqBuilding = GC.getBuildingInfo(ePrereqBuilding);
				if(pkPrereqBuilding)
				{
					int iNumHave = getBuildingClassCount((BuildingClassTypes)iI);

					int iNumNeeded = getBuildingClassPrereqBuilding(eBuilding, (BuildingClassTypes)iI, 0);

					if(iNumHave < iNumNeeded)
					{
						GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_COUNT_NEEDED", pkPrereqBuilding->GetTextKey(), "", iNumNeeded - iNumHave);

						if(toolTipSink == NULL)
							return false;
					}
				}
			}
		}

		// Resource Requirements
		for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
		{
			const ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);
			CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
			if(pkResource)
			{
				int iNumResource = pBuildingInfo.GetResourceQuantityRequirement(eResource);
				if(iNumResource > 0)
				{
					if(bContinue)
						iNumResource = 0;

					if(getNumResourceAvailable(eResource) < iNumResource)
					{
						GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_LACKS_RESOURCES", pkResource->GetIconString(), pkResource->GetTextKey(), iNumResource);
						if(toolTipSink == NULL)
							return false;
					}
				}
			}
		}

		if(GC.getGame().isBuildingClassMaxedOut(eBuildingClass, (currentTeam.getBuildingClassMaking(eBuildingClass) + ((bContinue) ? -1 : 0))))
		{
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_GAME_COUNT_MAX", "", "", kBuildingClass.getMaxGlobalInstances());
			if(toolTipSink == NULL)
				return false;
		}

		if(currentTeam.isBuildingClassMaxedOut(eBuildingClass, (currentTeam.getBuildingClassMaking(eBuildingClass) + ((bContinue) ? -1 : 0))))
		{
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_TEAM_COUNT_MAX", "", "", kBuildingClass.getMaxTeamInstances());
			if(toolTipSink == NULL)
				return false;
		}

		if(isBuildingClassMaxedOut(eBuildingClass, (getBuildingClassMaking(eBuildingClass) + ((bContinue) ? -1 : 0))))
		{
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_PLAYER_COUNT_MAX", "", "", kBuildingClass.getMaxPlayerInstances());
			if(toolTipSink == NULL)
				return false;
		}

		if(getNumCities() < pBuildingInfo.GetNumCitiesPrereq())
		{
			return false;
		}

		if(getHighestUnitLevel() < pBuildingInfo.GetUnitLevelPrereq())
		{
			return false;
		}
#if defined(MOD_BALANCE_CORE)
		if(GetPlayerPolicies() && !isMinorCiv() && !isBarbarian())
		{
			int iNumPoliciesNeeded = pBuildingInfo.GetNumPoliciesNeeded();
			if (iNumPoliciesNeeded > 0)
			{
				//If # of policies will do it, then we need to see the either/or here.
				int iNumPolicies = GetPlayerPolicies()->GetNumPoliciesOwned(true);

				int iCSPolicyReduction = GetCSAlliesLowersPolicyNeedWonders();
				if (iCSPolicyReduction > 0)
				{
					int iNumAllies = GetNumCSAllies();
					iNumPoliciesNeeded -= (iNumAllies / iCSPolicyReduction);
				}

				CvGameReligions* pReligions = GC.getGame().GetGameReligions();
				ReligionTypes eFoundedReligion = pReligions->GetFounderBenefitsReligion(GetID());
				if (eFoundedReligion == NO_RELIGION)
				{
					eFoundedReligion = GetReligions()->GetReligionInMostCities();
				}
				if (eFoundedReligion != NO_RELIGION)
				{
					const CvReligion* pReligion = pReligions->GetReligion(eFoundedReligion, GetID());
					if (pReligion)
					{
						CvCity* pHolyCity = NULL;
						CvPlot* pHolyCityPlot = GC.getMap().plot(pReligion->m_iHolyCityX, pReligion->m_iHolyCityY);
						if (pHolyCityPlot)
						{
							pHolyCity = pHolyCityPlot->getPlotCity();
						}
						if (pHolyCity == NULL)
						{
							pHolyCity = GET_PLAYER(GetID()).getCapitalCity();
						}
						int iReligionPolicyReduction = pReligion->m_Beliefs.GetPolicyReductionWonderXFollowerCities(GetID(), pHolyCity);
						if (iReligionPolicyReduction > 0)
						{
							int iNumFollowerCities = pReligions->GetNumCitiesFollowing(eFoundedReligion);
							if (iNumFollowerCities > 0)
							{
								iNumPoliciesNeeded -= (iNumFollowerCities / iReligionPolicyReduction);
							}
						}

						// Depends on era of wonder
						EraTypes eEra;
						TechTypes eTech = (TechTypes)pBuildingInfo.GetPrereqAndTech();
						if (eTech != NO_TECH)
						{
							CvTechEntry* pEntry = GC.GetGameTechs()->GetEntry(eTech);
							if (pEntry)
							{
								eEra = (EraTypes)pEntry->GetEra();
								if (eEra != NO_ERA)
								{
									CvCity* pHolyCity = NULL;
									CvPlot* pHolyCityPlot = GC.getMap().plot(pReligion->m_iHolyCityX, pReligion->m_iHolyCityY);
									if (pHolyCityPlot)
									{
										pHolyCity = pHolyCityPlot->getPlotCity();
									}
									if (pHolyCity == NULL)
									{
										pHolyCity = GET_PLAYER(GetID()).getCapitalCity();
									}
									iNumPoliciesNeeded -= pReligion->m_Beliefs.GetIgnorePolicyRequirementsAmount(eEra, GetID(), pHolyCity);
								}
							}
						}
					}
				}
				if (iNumPolicies < iNumPoliciesNeeded)
				{
					GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_NEED_POLICIES", pkBuildingInfo->GetTextKey(), "", iNumPoliciesNeeded - iNumPolicies);
					if (toolTipSink == NULL)
						return false;
				}
			}
		}
#endif

#if defined(MOD_BALANCE_CORE_POP_REQ_BUILDINGS)
		//Requires a certain population size, nationally.
		if(MOD_BALANCE_CORE_POP_REQ_BUILDINGS)
		{
			int iPopRequired = GetScalingNationalPopulationRequrired(eBuilding);
			if(iPopRequired > 0)
			{
				int iCurrentPop = getTotalPopulation();
				if(iCurrentPop < iPopRequired)
				{
					GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_NEED_NATIONAL_POP", pkBuildingInfo->GetTextKey(), "", iPopRequired - iCurrentPop);
					if(toolTipSink == NULL)
					return false;
				}
			}
		}
#endif
#if defined(MOD_BALANCE_CORE_FOLLOWER_POP_WONDER)
		//Requires a certain religion follower size, either nationally or globally.
		if(MOD_BALANCE_CORE_FOLLOWER_POP_WONDER)
		{
			CvGameReligions* pReligions = GC.getGame().GetGameReligions();
			ReligionTypes eFoundedReligion = pReligions->GetFounderBenefitsReligion(GetID());
			if (eFoundedReligion == NO_RELIGION)
			{
				eFoundedReligion = GetReligions()->GetReligionInMostCities();
			}
			if(eFoundedReligion != NO_RELIGION)
			{
				const CvReligion* pReligion = pReligions->GetReligion(eFoundedReligion, GetID());
				if(pReligion)
				{
					if (pkBuildingInfo->GetNationalFollowerPopRequired() > 0)
					{
						CvCity* pHolyCity = NULL;
						CvPlot* pHolyCityPlot = GC.getMap().plot(pReligion->m_iHolyCityX, pReligion->m_iHolyCityY);
						if (pHolyCityPlot)
						{
							pHolyCity = pHolyCityPlot->getPlotCity();
						}
						if (pHolyCity == NULL)
						{
							pHolyCity = GET_PLAYER(GetID()).getCapitalCity();
						}
						if (pReligion->m_Beliefs.IsBuildingClassEnabled(eBuildingClass, GetID(), pHolyCity, true))
						{
							int iPopRequired = pkBuildingInfo->GetNationalFollowerPopRequired();
							int iLoop;
							int iCurrentPop = 0;
							CvCity* pLoopCity;
							for (pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
							{
								iCurrentPop += pLoopCity->GetCityReligions()->GetNumFollowers(eFoundedReligion);
							}
							if (iCurrentPop < iPopRequired)
							{
								GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_NEED_FOLLOWER_POP", pkBuildingInfo->GetTextKey(), "", iPopRequired - iCurrentPop);
								if (toolTipSink == NULL)
									return false;
							}
						}
					}
					if(pkBuildingInfo->GetGlobalFollowerPopRequired() > 0)
					{
						CvCity* pHolyCity = NULL;
						CvPlot* pHolyCityPlot = GC.getMap().plot(pReligion->m_iHolyCityX, pReligion->m_iHolyCityY);
						if (pHolyCityPlot)
						{
							pHolyCity = pHolyCityPlot->getPlotCity();
						}
						if (pHolyCity == NULL)
						{
							pHolyCity = GET_PLAYER(GetID()).getCapitalCity();
						}
						if (pReligion->m_Beliefs.IsBuildingClassEnabled(eBuildingClass, GetID(), pHolyCity))
						{
							int iPopRequiredPercent = pkBuildingInfo->GetGlobalFollowerPopRequired();
							iPopRequiredPercent -= GetReformationFollowerReduction();
							if (GC.getMap().getWorldInfo().getReformationPercent() > 0)
							{
								iPopRequiredPercent *= GC.getMap().getWorldInfo().getReformationPercent();
								iPopRequiredPercent /= 100;
							}

							int iCurrentPop = pReligions->GetNumFollowers(eFoundedReligion);
							int iCurrentPopPercent = (iCurrentPop * 100) / GC.getGame().getTotalPopulation();

							if (iCurrentPopPercent < iPopRequiredPercent)
							{
								int iPercentage = iPopRequiredPercent - iCurrentPopPercent;
								GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_NEED_GLOBAL_FOLLOWER_POP", pkBuildingInfo->GetTextKey(), "", iPercentage);
								if (toolTipSink == NULL)
									return false;
							}
						}
					}
				}
			}
		}
#endif

		BuildingTypes ePrereqBuilding;
		int iNumNeeded;
		for(iI = 0; iI < numBuildingClassInfos; iI++)
		{
			iNumNeeded = getBuildingClassPrereqBuilding(eBuilding, ((BuildingClassTypes)iI), bContinue);
			//int iNumHave = getBuildingClassCount((BuildingClassTypes)iI);
			ePrereqBuilding = (BuildingTypes) civilizationInfo.getCivilizationBuildings(iI);
			if(NO_BUILDING != ePrereqBuilding)
			{
				CvBuildingEntry* pkPrereqBuilding = GC.getBuildingInfo(ePrereqBuilding);
				if(pkPrereqBuilding)
				{
					int iNumHave = vPreExistingBuildings[ePrereqBuilding];
					if(iNumHave < iNumNeeded)
					{
						ePrereqBuilding = (BuildingTypes) civilizationInfo.getCivilizationBuildings(iI);

						GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_COUNT_NEEDED", pkPrereqBuilding->GetTextKey(), "", iNumNeeded - iNumHave);

						if(toolTipSink == NULL)
							return false;

						// If we have less than 5 to go, list what cities need them
						int iNonPuppetCities = getNumCities() - GetNumPuppetCities();
						if(iNumNeeded == iNonPuppetCities && iNumNeeded - iNumHave < 5)
						{
							(*toolTipSink) += "[NEWLINE]";

							int iLoop=0;
							for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								if(pLoopCity && !pLoopCity->IsPuppet() && pLoopCity->GetCityBuildings()->GetNumBuilding(ePrereqBuilding) == 0)
								{
									(*toolTipSink) += pLoopCity->getName();
									(*toolTipSink) += " ";
								}
							}
						}
					}
				}
			}
		}
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(eBuilding);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if(LuaSupport::CallTestAll(pkScriptSystem, "PlayerCanConstruct", args.get(), bResult))
		{
			// Check the result.
			if(bResult == false)
			{
				return false;
			}
		}
	}

	return true;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::canCreate(ProjectTypes eProject, bool bContinue, bool bTestVisible) const
{
	CvProjectEntry* pkProjectInfo = GC.getProjectInfo(eProject);
	if(!pkProjectInfo)
	{
		return false;
	}

	CvProjectEntry& pProjectInfo = *pkProjectInfo;

	int iI;

	// No projects for barbs
	if(isBarbarian())
	{
		return false;
	}

	// no minors either
	if(isMinorCiv())
	{
		return false;
	}

	// If cost is -1 then that means it can't be built
	if(pProjectInfo.GetProductionCost() == -1)
	{
		return false;
	}

	// Tech requirement
	if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pProjectInfo.GetTechPrereq()))))
	{
		return false;
	}

	// Policy branch requirement?
	if(pProjectInfo.GetCultureBranchesRequired() > 0)
	{
		if(GetPlayerPolicies()->GetNumPolicyBranchesFinished() < pProjectInfo.GetCultureBranchesRequired())
		{
			return false;
		}
	}

	// Requires a particular victory condition to be enabled?
	if(pProjectInfo.GetVictoryPrereq() != NO_VICTORY)
	{
		if(!(GC.getGame().isVictoryValid((VictoryTypes)(pProjectInfo.GetVictoryPrereq()))))
		{
			return false;
		}

		if(isMinorCiv())
		{
			return false;
		}

		if(GET_TEAM(getTeam()).getVictoryCountdown((VictoryTypes)pProjectInfo.GetVictoryPrereq()) >= 0)
		{
			return false;
		}
	}

	if (!pProjectInfo.IsRepeatable())
	{
		if (GC.getGame().isProjectMaxedOut(eProject))
		{
			return false;
		}

		if (GET_TEAM(getTeam()).isProjectMaxedOut(eProject))
		{
			return false;
		}
	}

	if (pProjectInfo.GetNumRequiredTier3Tenets())
	{
		PolicyBranchTypes eIdeology = GetPlayerPolicies()->GetLateGamePolicyTree();
		if (eIdeology == NO_POLICY_BRANCH_TYPE)
			return false;

		int iNumTenets = GetPlayerPolicies()->GetNumTenetsOfLevel(eIdeology, 3);
		if (iNumTenets < pProjectInfo.GetNumRequiredTier3Tenets())
			return false;
	}

	if(!bTestVisible)
	{
		if (pProjectInfo.InfluenceAllRequired())
		{
			if (GetCulture()->GetNumCivsInfluentialOn() < GC.getGame().GetGameCulture()->GetNumCivsInfluentialForWin())
				return false;
		}

		if (pProjectInfo.IdeologyRequired())
		{
			if (GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
				return false;
			else if (GetCulture()->GetPublicOpinionType() > PUBLIC_OPINION_CONTENT)
				return false;
		}

		// Resource Requirements
		ResourceTypes eResource;
		int iNumResource;
		for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
		{
			eResource = (ResourceTypes) iResourceLoop;
			iNumResource = pProjectInfo.GetResourceQuantityRequirement(eResource);

			if(iNumResource > 0)
			{
				if(getNumResourceAvailable(eResource) < iNumResource)
				{
					return false;
				}
			}
		}

		if (!pProjectInfo.IsRepeatable())
		{
			if (GC.getGame().isProjectMaxedOut(eProject, (GET_TEAM(getTeam()).getProjectMaking(eProject) + ((bContinue) ? -1 : 0))))
			{
				return false;
			}

			if (GET_TEAM(getTeam()).isProjectMaxedOut(eProject, (GET_TEAM(getTeam()).getProjectMaking(eProject) + ((bContinue) ? -1 : 0))))
			{
				return false;
			}
		}

		// Nukes disabled? (by UN or something)
		if(GC.getGame().isNoNukes())
		{
			if(pProjectInfo.IsAllowsNukes())
			{
				for(iI = 0; iI < GC.getNumUnitInfos(); iI++)
				{
					CvUnitEntry* pkUnitEntry = GC.getUnitInfo((UnitTypes)iI);
					if(pkUnitEntry && pkUnitEntry->GetNukeDamageLevel() != -1)
					{
						return false;
					}
				}
			}
		}

		if(pProjectInfo.GetAnyoneProjectPrereq() != NO_PROJECT)
		{
			if(GC.getGame().getProjectCreatedCount((ProjectTypes)(pProjectInfo.GetAnyoneProjectPrereq())) == 0)
			{
				return false;
			}
		}

		for(iI = 0; iI < GC.getNumProjectInfos(); iI++)
		{
			if(GET_TEAM(getTeam()).getProjectCount((ProjectTypes)iI) < pProjectInfo.GetProjectsNeeded(iI))
			{
				return false;
			}
		}
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(eProject);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if(LuaSupport::CallTestAll(pkScriptSystem, "PlayerCanCreate", args.get(), bResult))
		{
			// Check the result.
			if(bResult == false)
			{
				return false;
			}
		}
	}

	return true;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::canPrepare(SpecialistTypes eSpecialist, bool) const
{
	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(eSpecialist);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if(LuaSupport::CallTestAll(pkScriptSystem, "PlayerCanPrepare", args.get(), bResult))
		{
			// Check the result.
			if(bResult == false)
			{
				return false;
			}
		}
	}


	return false;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::canMaintain(ProcessTypes eProcess, bool) const
{
	// Check to see if it exists, scenarios can remove them and leave holes in the list.
	const CvProcessInfo* pkProcessInfo = GC.getProcessInfo(eProcess);
	if (!pkProcessInfo)
		return false;

	if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pkProcessInfo->getTechPrereq()))))
	{
		return false;
	}

	for(int iI = 0; iI < GC.getNumLeagueProjectInfos(); iI++)
	{
		LeagueProjectTypes eLeagueProject = (LeagueProjectTypes) iI;
		CvLeagueProjectEntry* pInfo = GC.getLeagueProjectInfo(eLeagueProject);
		if (pInfo && pInfo->GetProcess() == eProcess)
		{
			if (!GC.getGame().GetGameLeagues()->CanContributeToLeagueProject(GetID(), eLeagueProject))
			{
				return false;
			}
		}
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(eProcess);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if(LuaSupport::CallTestAll(pkScriptSystem, "PlayerCanMaintain", args.get(), bResult))
		{
			// Check the result.
			if(bResult == false)
			{
				return false;
			}
		}
	}

	return true;
}

//	--------------------------------------------------------------------------------
/// Can we purchase this unit or building in any of our cities?
bool CvPlayer::IsCanPurchaseAnyCity(bool bTestPurchaseCost, bool bTestTrainable, UnitTypes eUnit, BuildingTypes eBuilding, YieldTypes ePurchaseYield)
{
	int iLoop;
	CvCity *pLoopCity;

	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (pLoopCity->IsCanPurchase(bTestPurchaseCost, bTestTrainable, eUnit, eBuilding, NO_PROJECT, ePurchaseYield))
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isProductionMaxedUnitClass(UnitClassTypes eUnitClass) const
{
	if(eUnitClass == NO_UNITCLASS)
	{
		return false;
	}

	if(GC.getGame().isUnitClassMaxedOut(eUnitClass))
	{
		return true;
	}

	if(GET_TEAM(getTeam()).isUnitClassMaxedOut(eUnitClass))
	{
		return true;
	}

	if(isUnitClassMaxedOut(eUnitClass))
	{
		return true;
	}

	return false;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isProductionMaxedBuildingClass(BuildingClassTypes eBuildingClass, bool bAcquireCity) const
{
	if(eBuildingClass == NO_BUILDINGCLASS)
	{
		return false;
	}

	CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
	if(pkBuildingClassInfo == NULL)
	{
		return false;
	}

	if(!bAcquireCity)
	{
		if(GC.getGame().isBuildingClassMaxedOut(eBuildingClass))
		{
			return true;
		}
	}

	if(GET_TEAM(getTeam()).isBuildingClassMaxedOut(eBuildingClass))
	{
		return true;
	}

	if(isBuildingClassMaxedOut(eBuildingClass, ((bAcquireCity) ? pkBuildingClassInfo->getExtraPlayerInstances() : 0)))
	{
		return true;
	}

	return false;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isProductionMaxedProject(ProjectTypes eProject) const
{
	if(eProject == NO_PROJECT)
	{
		return false;
	}

	if (GC.getProjectInfo(eProject) != NULL && GC.getProjectInfo(eProject)->IsRepeatable())
		return false;

	if(GC.getGame().isProjectMaxedOut(eProject))
	{
		return true;
	}

	if(GET_TEAM(getTeam()).isProjectMaxedOut(eProject))
	{
		return true;
	}

	return false;
}


//	--------------------------------------------------------------------------------
int CvPlayer::getProductionNeeded(UnitTypes eUnit) const
{
	CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eUnit);

	CvAssertMsg(pkUnitEntry, "This should never be hit");
	if(pkUnitEntry == NULL)
		return 0;

	UnitClassTypes eUnitClass = (UnitClassTypes)pkUnitEntry->GetUnitClassType();
	CvAssert(NO_UNITCLASS != eUnitClass);

	CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
	CvAssert(pkUnitClassInfo);
	if(pkUnitClassInfo == NULL)
		return 0;

	bool bCombat = (pkUnitEntry->GetCombat() > 0 || pkUnitEntry->GetRangedCombat() > 0);

	int iProductionNeeded = pkUnitEntry->GetProductionCost();
	iProductionNeeded *= 100 + getUnitClassCount(eUnitClass) * pkUnitClassInfo->getInstanceCostModifier();
	iProductionNeeded /= 100;

	if (pkUnitEntry->GetProductionCostPerEra() != 0)
	{
		int iEra = GetCurrentEra() - 1;
		if (iEra > 0)
		{
			iProductionNeeded += pkUnitEntry->GetProductionCostPerEra() * iEra;
		}
	}

	if(isMinorCiv())
	{
		iProductionNeeded *= GC.getMINOR_CIV_PRODUCTION_PERCENT();
		iProductionNeeded /= 100;
	}

	iProductionNeeded *= GC.getUNIT_PRODUCTION_PERCENT();
	iProductionNeeded /= 100;

	iProductionNeeded *= GC.getGame().getGameSpeedInfo().getTrainPercent();
	iProductionNeeded /= 100;

	iProductionNeeded *= GC.getGame().getStartEraInfo().getTrainPercent();
	iProductionNeeded /= 100;

#if defined(MOD_BALANCE_CORE)
	int iMod = 100;
	UnitCombatTypes eUnitCombat = (UnitCombatTypes)pkUnitEntry->GetUnitCombatType();
	if (eUnitCombat != NO_UNITCOMBAT && GetPlayerTraits()->GetUnitCombatProductionCostModifier(eUnitCombat).first != 0)
	{
		if (GetPlayerTraits()->GetUnitCombatProductionCostModifier(eUnitCombat).second == false || (GetPlayerTraits()->GetUnitCombatProductionCostModifier(eUnitCombat).second == true && isGoldenAge()))
		{
			iMod += GetPlayerTraits()->GetUnitCombatProductionCostModifier(eUnitCombat).first;
		}
	}
#if defined(MOD_BALANCE_DYNAMIC_UNIT_SUPPLY)
	if (MOD_BALANCE_DYNAMIC_UNIT_SUPPLY && bCombat)
	{
		int iWarWeariness = GetCulture()->GetWarWeariness();
		iMod += min(75, iWarWeariness);
	}
#endif
	iProductionNeeded *= iMod;
	iProductionNeeded /= 100;
#endif

	if (!isHuman() && !IsAITeammateOfHuman() && !isBarbarian() && bCombat)
	{
		if(isWorldUnitClass(eUnitClass))
		{
			iProductionNeeded *= GC.getGame().getHandicapInfo().getAIWorldTrainPercent();
			iProductionNeeded /= 100;
		}
		else
		{
			iProductionNeeded *= GC.getGame().getHandicapInfo().getAITrainPercent();
			iProductionNeeded /= 100;
		}

		iProductionNeeded *= std::max(0, ((GC.getGame().getHandicapInfo().getAIPerEraModifier() * GetCurrentEra()) + 100));
		iProductionNeeded /= 100;
	}

	iProductionNeeded += getUnitExtraCost(eUnitClass);

	return std::max(1, iProductionNeeded);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getProductionNeeded(BuildingTypes eTheBuilding) const
{
	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eTheBuilding);
	if(pkBuildingInfo == NULL)
	{
		//This should never happen.
		return 1;
	}

	int iProductionNeeded = pkBuildingInfo->GetProductionCost();
	int iProductionModifier = 0;

	if(pkBuildingInfo->GetNumCityCostMod() > 0 && getNumCities() > 0)
	{
		iProductionModifier += (pkBuildingInfo->GetNumCityCostMod() * getNumCities());
	}
#if defined(MOD_BALANCE_CORE_WONDER_COST_INCREASE)
	if(MOD_BALANCE_CORE_WONDER_COST_INCREASE && isWorldWonderClass(pkBuildingInfo->GetBuildingClassInfo()))
	{
		int iLoop;
		for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity->getNumWorldWonders() > 0)
			{
				for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
				{
					const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
					CvBuildingEntry* pkeBuildingInfo = GC.getBuildingInfo(eBuilding);
					if(pkeBuildingInfo == NULL)
					{
						//This should never happen.
						continue;
					}
				
					// Has this Building
					if(pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
					{
						if(isWorldWonderClass(pkeBuildingInfo->GetBuildingClassInfo()))
						{
							if (pkeBuildingInfo->GetPrereqAndTech() == NO_TECH)
								continue;

							CvTechEntry* pkTechInfo = GC.getTechInfo((TechTypes)pkeBuildingInfo->GetPrereqAndTech());
							if (pkTechInfo)
							{
								// Loop through all eras and apply Building production mod based on how much time has passed
								EraTypes eBuildingUnlockedEra = (EraTypes)pkTechInfo->GetEra();

								if (eBuildingUnlockedEra == NO_ERA)
									continue;

								int iEraDivisor = GetCurrentEra() - eBuildingUnlockedEra;
								switch (iEraDivisor)
								{
								case 0:
									iProductionModifier += GC.getBALANCE_CORE_WORLD_WONDER_SAME_ERA_COST_MODIFIER();
									break;
								case 1:
									iProductionModifier += GC.getBALANCE_CORE_WORLD_WONDER_PREVIOUS_ERA_COST_MODIFIER();
									break;
								case 2:
									iProductionModifier += GC.getBALANCE_CORE_WORLD_WONDER_EARLIER_ERA_COST_MODIFIER();
									break;
								}
							}
						}
					}
				}
			}
		}
	}
#endif

	if(isMinorCiv())
	{
		iProductionModifier += GC.getMINOR_CIV_PRODUCTION_PERCENT() - 100;
	}

	iProductionModifier += GC.getBUILDING_PRODUCTION_PERCENT() - 100;

	iProductionModifier += GC.getGame().getGameSpeedInfo().getConstructPercent() - 100;

	iProductionModifier += GC.getGame().getStartEraInfo().getConstructPercent() - 100;

	if(pkBuildingInfo->GetPrereqAndTech() != NO_TECH)
	{
		CvTechEntry* pkTechInfo = GC.getTechInfo((TechTypes)pkBuildingInfo->GetPrereqAndTech());
		if(pkTechInfo)
		{
			// Loop through all eras and apply Building production mod based on how much time has passed
			int iTotalEraMod = 0;
			EraTypes eBuildingUnlockedEra = (EraTypes) pkTechInfo->GetEra();

			if(eBuildingUnlockedEra < GetCurrentEra())
			{
				for(int iLoop = eBuildingUnlockedEra; iLoop < GetCurrentEra(); iLoop++)
				{
					CvAssertMsg(iLoop >= 0, "Loop should be within era bounds");
					CvAssertMsg(iLoop <GC.getNumEraInfos(), "Loop should be within era bounds");

					if(iLoop >= 0 && iLoop < GC.getNumEraInfos())
					{
						CvEraInfo* pkEraInfo = GC.getEraInfo((EraTypes)iLoop);
						if(pkEraInfo)
						{
							iTotalEraMod += pkEraInfo->getLaterEraBuildingConstructMod();
						}
					}
				}

				iProductionModifier += iTotalEraMod;
			}
		}
	}
	else
	{
		int iTotalEraMod = 0;
		for (int iLoop = 0; iLoop < GetCurrentEra(); iLoop++)
		{
			CvAssertMsg(iLoop >= 0, "Loop should be within era bounds");
			CvAssertMsg(iLoop <GC.getNumEraInfos(), "Loop should be within era bounds");

			if (iLoop >= 0 && iLoop < GC.getNumEraInfos())
			{
				CvEraInfo* pkEraInfo = GC.getEraInfo((EraTypes)iLoop);
				if (pkEraInfo)
				{
					iTotalEraMod += pkEraInfo->getLaterEraBuildingConstructMod();
				}
			}
		}

		iProductionModifier += iTotalEraMod;
	}

	if(!isHuman() && !IsAITeammateOfHuman() && !isBarbarian())
	{
		if(isWorldWonderClass(pkBuildingInfo->GetBuildingClassInfo()))
		{
			iProductionModifier += GC.getGame().getHandicapInfo().getAIWorldConstructPercent() - 100;
		}
		else
		{
			iProductionModifier += GC.getGame().getHandicapInfo().getAIConstructPercent() - 100;
		}

		if (MOD_BALANCE_CORE_DIFFICULTY)
		{
			if (!isWorldWonderClass(pkBuildingInfo->GetBuildingClassInfo()))
				iProductionModifier += std::max(0, ((GC.getGame().getHandicapInfo().getAIPerEraModifier() * GetCurrentEra()) + 100)) - 100;
		}
		else
			iProductionModifier += std::max(0, ((GC.getGame().getHandicapInfo().getAIPerEraModifier() * GetCurrentEra()) + 100)) - 100;
	}

	iProductionNeeded *= (100 + iProductionModifier);
	iProductionNeeded /= 100;

	return std::max(1, iProductionNeeded);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getProductionNeeded(ProjectTypes eProject) const
{
	int iProductionNeeded;

	iProductionNeeded = GC.getProjectInfo(eProject)->GetProductionCost();

	if(isMinorCiv())
	{
		iProductionNeeded *= GC.getMINOR_CIV_PRODUCTION_PERCENT();
		iProductionNeeded /= 100;
	}

	iProductionNeeded *= GC.getPROJECT_PRODUCTION_PERCENT();
	iProductionNeeded /= 100;

	iProductionNeeded *= GC.getGame().getGameSpeedInfo().getCreatePercent();
	iProductionNeeded /= 100;

	iProductionNeeded *= GC.getGame().getStartEraInfo().getCreatePercent();
	iProductionNeeded /= 100;

	if (!isHuman() && !IsAITeammateOfHuman() && !isBarbarian() && !GC.getProjectInfo(eProject)->IsRepeatable())
	{
		if(isWorldProject(eProject))
		{
			iProductionNeeded *= GC.getGame().getHandicapInfo().getAIWorldCreatePercent();
			iProductionNeeded /= 100;
		}
		else
		{
			iProductionNeeded *= GC.getGame().getHandicapInfo().getAICreatePercent();
			iProductionNeeded /= 100;
		}

		if (!MOD_BALANCE_CORE_DIFFICULTY)
		{
			iProductionNeeded *= std::max(0, ((GC.getGame().getHandicapInfo().getAIPerEraModifier() * GetCurrentEra()) + 100));
			iProductionNeeded /= 100;
		}
	}

	return std::max(1, iProductionNeeded);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionNeeded(SpecialistTypes eSpecialist) const
{
	CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
	if(pkSpecialistInfo == NULL)
	{
		//This should never happen! If this does, fix the calling function!
		CvAssert(pkSpecialistInfo);
		return 0;
	}

	int iProductionNeeded;
	iProductionNeeded = pkSpecialistInfo->getCost();

	if(isMinorCiv())
	{
		iProductionNeeded *= GC.getMINOR_CIV_PRODUCTION_PERCENT();
		iProductionNeeded /= 100;
	}

	iProductionNeeded *= GC.getGame().getGameSpeedInfo().getCreatePercent();
	iProductionNeeded /= 100;

	iProductionNeeded *= GC.getGame().getStartEraInfo().getCreatePercent();
	iProductionNeeded /= 100;

	return std::max(1, iProductionNeeded);
}

#if defined(MOD_PROCESS_STOCKPILE)
//	--------------------------------------------------------------------------------
int CvPlayer::getMaxStockpile() const
{
	// The default of 30 hammers means a city can stockpile between 15% and 30% of the production of a World Wonder
	int iProdPerEra = gCustomMods.getOption("PROCESS_STOCKPILE_PER_ERA", 30);
	// Adjust for game speed
	iProdPerEra *= GC.getGame().getGameSpeedInfo().getConstructPercent();

	return ((GetCurrentEra() + 1) * iProdPerEra) / 100;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionModifier(CvString* toolTipSink) const
{
	int iMultiplier = 0;

	int iTempMod;

	// Unit Supply
	iTempMod = GetUnitProductionMaintenanceMod();
	iMultiplier += iTempMod;
	GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_UNIT_SUPPLY", iTempMod);

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionModifier(UnitTypes eUnit, CvString* toolTipSink) const
{
	int iMultiplier = getProductionModifier(toolTipSink);
	int iTempMod;

	CvUnitEntry* pUnitEntry = GC.getUnitInfo(eUnit);

	if(pUnitEntry)
	{
		// Military bonus
		if(pUnitEntry->IsMilitaryProduction())
		{
			iTempMod = getMilitaryProductionModifier();
			iMultiplier += iTempMod;
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_MILITARY_PLAYER", iTempMod);
		}

		// Settler bonus
		if(pUnitEntry->IsFound())
		{
			iTempMod = getSettlerProductionModifier();
			iMultiplier += iTempMod;
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_SETTLER_PLAYER", iTempMod);
		}

		// Unit Combat class bonus
		if(pUnitEntry->GetUnitCombatType() != NO_UNITCOMBAT)
		{
			iTempMod = getUnitCombatProductionModifiers((UnitCombatTypes) pUnitEntry->GetUnitCombatType());
			iMultiplier += iTempMod;
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_UNIT_COBMAT_CLASS_PLAYER", iTempMod);
		}

		// Trait bonus
		CvPlayerTraits* pPlayerTraits = GetPlayerTraits();
		std::vector<TraitTypes> vTraits = pPlayerTraits->GetPotentiallyActiveTraits();
		for(size_t iI = 0; iI < vTraits.size(); iI++)
		{
			if(pPlayerTraits->HasTrait(vTraits[iI]))
			{
				iMultiplier += pUnitEntry->GetProductionTraits(iI);

				if(pUnitEntry->GetSpecialUnitType() != NO_SPECIALUNIT)
				{
					CvSpecialUnitInfo* pkSpecialUnitInfo = GC.getSpecialUnitInfo((SpecialUnitTypes) pUnitEntry->GetSpecialUnitType());
					if(pkSpecialUnitInfo)
					{
						iTempMod = pkSpecialUnitInfo->getProductionTraits(iI);
						iMultiplier += iTempMod;
						GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_UNIT_TRAIT", iTempMod);
					}
				}
			}
		}
	}

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionModifier(BuildingTypes eBuilding, CvString* toolTipSink) const
{
	int iMultiplier = getProductionModifier(toolTipSink);
	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if(pkBuildingInfo == NULL)
	{
		return iMultiplier;
	}

	CvGame& kGame = GC.getGame();
	const CvBuildingClassInfo& kBuildingClassInfo = pkBuildingInfo->GetBuildingClassInfo();

	int iTempMod;

	CvPlayerTraits* pPlayerTraits = GetPlayerTraits();
	std::vector<TraitTypes> vTraits = pPlayerTraits->GetPotentiallyActiveTraits();
	for(size_t iI = 0; iI < vTraits.size(); iI++)
	{
		if(pPlayerTraits->HasTrait(vTraits[iI]))
		{
			iTempMod = pkBuildingInfo->GetProductionTraits(iI);
			iMultiplier += iTempMod;
			kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_BUILDING_TRAIT", iTempMod);
		}
	}

	// World Wonder
	if(::isWorldWonderClass(kBuildingClassInfo))
	{
		iTempMod = getMaxGlobalBuildingProductionModifier();
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WORLD_WONDER_PLAYER", iTempMod);
		iTempMod = m_pPlayerPolicies->GetNumericModifier(POLICYMOD_WONDER_PRODUCTION_MODIFIER);
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_POLICY", iTempMod);
	}

	// Team Wonder
	else if(::isTeamWonderClass(kBuildingClassInfo))
	{
		iTempMod = getMaxTeamBuildingProductionModifier();
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_TEAM_WONDER_PLAYER", iTempMod);
		iTempMod = m_pPlayerPolicies->GetNumericModifier(POLICYMOD_WONDER_PRODUCTION_MODIFIER);
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_POLICY", iTempMod);
	}

	// National Wonder
	else if(::isNationalWonderClass(kBuildingClassInfo))
	{
		iTempMod = getMaxPlayerBuildingProductionModifier();
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_NATIONAL_WONDER_PLAYER", iTempMod);
		iTempMod = m_pPlayerPolicies->GetNumericModifier(POLICYMOD_WONDER_PRODUCTION_MODIFIER);
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_POLICY", iTempMod);
	}

	// Normal Building
	else
	{
		iTempMod = m_pPlayerPolicies->GetNumericModifier(POLICYMOD_BUILDING_PRODUCTION_MODIFIER);
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_BUILDING_POLICY_PLAYER", iTempMod);
	}

	// Religion
	if(pkBuildingInfo->IsReligious())
	{
		iTempMod = m_pPlayerPolicies->GetNumericModifier(POLICYMOD_RELIGION_PRODUCTION_MODIFIER);
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_RELIGION_PLAYER", iTempMod);
	}

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionModifier(ProjectTypes eProject, CvString* toolTipSink) const
{
	int iMultiplier = getProductionModifier(toolTipSink);
	int iTempMod;

	if(GC.getProjectInfo(eProject)->IsSpaceship())
	{
		iTempMod = getSpaceProductionModifier();
		iMultiplier += iTempMod;
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_SPACE_PLAYER", iTempMod);
	}

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionModifier(SpecialistTypes, CvString* toolTipSink) const
{
	int iMultiplier = getProductionModifier(toolTipSink);
	int iTempMod;

	iTempMod = getSpecialistProductionModifier();
	iMultiplier += iTempMod;
	GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_SPECIALIST_PLAYER", iTempMod);

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionModifier(ProcessTypes /*eProcess*/, CvString* toolTipSink) const
{
	int iMultiplier = getProductionModifier(toolTipSink);

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getBuildingClassPrereqBuilding(BuildingTypes eBuilding, BuildingClassTypes ePrereqBuildingClass, int iExtra) const
{
	CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
	if(pkBuilding == NULL)
	{
		CvAssertMsg(pkBuilding, "Should never happen...");
		return -1;
	}

	int iPrereqs = pkBuilding->GetPrereqNumOfBuildingClass(ePrereqBuildingClass);

	// dont bother with the rest of the calcs if we have no prereqs
	if(iPrereqs == 0)
	{
		return 0;
	}
	// -1 means Building is needed in all Cities
	else if(iPrereqs == -1)
	{
#if defined(MOD_BUILDINGS_NW_EXCLUDE_RAZING)
		BuildingTypes ePrereqBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(ePrereqBuildingClass);
#endif
		int iNonPuppetCities = 0;
		int iLoop = 0;
		const CvCity* pLoopCity = NULL;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity && !pLoopCity->IsPuppet())
			{
#if defined(MOD_BUILDINGS_NW_EXCLUDE_RAZING)
				// Don't count this city if it is being razed and doesn't already have the pre-req building
				if (!(MOD_BUILDINGS_NW_EXCLUDE_RAZING && pLoopCity->IsRazing() && pLoopCity->GetCityBuildings()->GetNumBuilding(ePrereqBuilding) == 0))
#endif
				iNonPuppetCities++;
			}
		}

		return iNonPuppetCities;
	}
	else
	{
		iPrereqs *= std::max(0, GC.getMap().getWorldInfo().getBuildingClassPrereqModifier() + 100);
		iPrereqs /= 100;
	}

	if(!isLimitedWonderClass(pkBuilding->GetBuildingClassInfo()))
	{
		BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkBuilding->GetBuildingClassType();
		iPrereqs *= (getBuildingClassCount(eBuildingClass) + iExtra + 1);
	}

	bool OCC = GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE);
	if (OCC && isHuman())
	{
		iPrereqs = std::min(1, iPrereqs);
	}
#if defined(MOD_BALANCE_CORE)
	//Poor Venice got ignored here...
	if (MOD_BALANCE_CORE && OCC || GET_PLAYER(GetID()).GetPlayerTraits()->IsNoAnnexing())
	{
		iPrereqs = std::min(1, iPrereqs);
	}
#endif

	return iPrereqs;
}


//	--------------------------------------------------------------------------------
void CvPlayer::removeBuildingClass(BuildingClassTypes eBuildingClass)
{
	CvCity* pLoopCity;
	BuildingTypes eBuilding;
	int iLoop;

	eBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(eBuildingClass)));

	if(eBuilding != NO_BUILDING)
	{
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity->GetCityBuildings()->GetNumRealBuilding(eBuilding) > 0)
			{
				pLoopCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, 0);
				break;
			}
		}
	}
}

//	--------------------------------------------------------------------------------
// What is the effect of a building on the player?
void CvPlayer::processBuilding(BuildingTypes eBuilding, int iChange, bool bFirst, CvArea* pArea)
{
	int iI, iJ;

	CvBuildingEntry* pBuildingInfo = GC.getBuildingInfo(eBuilding);
	if(pBuildingInfo == NULL)
		return;

	// One-shot items
	if(bFirst && iChange > 0)
	{
		// Free Policies
		int iFreePolicies = pBuildingInfo->GetFreePolicies();
		if(iFreePolicies > 0)
			ChangeNumFreePolicies(iFreePolicies);

		int iFreeGreatPeople = pBuildingInfo->GetFreeGreatPeople();
		if(iFreeGreatPeople > 0)
			ChangeNumFreeGreatPeople(iFreeGreatPeople);

		// Golden Age
		if(pBuildingInfo->IsGoldenAge())
		{
			int iGoldenAgeTurns = getGoldenAgeLength();
#if defined(MOD_BALANCE_CORE)
			int iValue = GetGoldenAgeProgressMeter();
			changeGoldenAgeTurns(iGoldenAgeTurns, iValue, true);
#else
			changeGoldenAgeTurns(iGoldenAgeTurns);
#endif
		}

		// Global Pop change
		if(pBuildingInfo->GetGlobalPopulationChange() != 0)
		{
			CvCity* pLoopCity;
			int iLoop;

			for(iI = 0; iI < MAX_PLAYERS; iI++)
			{
				if(GET_PLAYER((PlayerTypes)iI).isAlive())
				{
					if(GET_PLAYER((PlayerTypes)iI).getTeam() == getTeam())
					{
						if(pBuildingInfo->IsTeamShare() || (iI == GetID()))
						{
							for(pLoopCity = GET_PLAYER((PlayerTypes)iI).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER((PlayerTypes)iI).nextCity(&iLoop))
							{
								pLoopCity->setPopulation(std::max(1, (pLoopCity->getPopulation() + iChange * GC.getBuildingInfo(eBuilding)->GetGlobalPopulationChange())));
							}
						}
					}
				}
			}
		}

		// Free techs
		if(pBuildingInfo->GetFreeTechs() > 0)
		{
			if(!isHuman())
			{
				for(iI = 0; iI < pBuildingInfo->GetFreeTechs(); iI++)
				{
					for(int iLoop = 0; iLoop < iChange; iLoop++)
						AI_chooseFreeTech();
				}
			}
			else
			{
				Localization::String localizedText = Localization::Lookup("TXT_KEY_MISC_COMPLETED_WONDER_CHOOSE_TECH");
				localizedText << pBuildingInfo->GetTextKey();
				chooseTech(pBuildingInfo->GetFreeTechs() * iChange, localizedText.toUTF8());
			}
		}
		if(pBuildingInfo->GetMedianTechPercentChange() > 0)
		{
			ChangeMedianTechPercentage(pBuildingInfo->GetMedianTechPercentChange());
		}

		if(pBuildingInfo->GetExtraSpies() > 0)
		{
			CvPlayerEspionage* pEspionage = GetEspionage();
			CvAssertMsg(pEspionage, "pEspionage is null! What's up with that?!");
			if(pEspionage)
			{
				int iNumSpies = pBuildingInfo->GetExtraSpies();
#if defined(MOD_BALANCE_CORE_SPIES)
				if (MOD_BALANCE_CORE_SPIES) {
					//Optional: Spies scaled for the number of City-States in the game.
					int iNumMinor = ((GC.getGame().GetNumMinorCivsEver() * /*15*/ GC.getBALANCE_SPY_TO_MINOR_RATIO()) / 100);
					if(iNumMinor > 1)
					{
						iNumSpies += iNumMinor;
					}
				}
#endif
				for(int i = 0; i < iNumSpies; i++)
				{
					pEspionage->CreateSpy();
				}
			}
		}

		if(pBuildingInfo->GetInstantSpyRankChange() > 0)
		{
			CvPlayerEspionage* pEspionage = GetEspionage();
			CvAssertMsg(pEspionage, "pEspionage is null! What's up with that?!");
			if(pEspionage)
			{
				for(uint ui = 0; ui < pEspionage->m_aSpyList.size(); ui++)
				{
					pEspionage->LevelUpSpy(ui);
				}
			}
		}

		if(pBuildingInfo->GetSpyRankChange() > 0)
		{
			ChangeStartingSpyRank(pBuildingInfo->GetSpyRankChange());
		}

		// Free Gold
		if(pBuildingInfo->GetGold() > 0)
			GetTreasury()->ChangeGold(pBuildingInfo->GetGold());

		// Instant Friendship change with all Minors
		int iMinorFriendshipChange = pBuildingInfo->GetMinorFriendshipChange();
		if(iMinorFriendshipChange != 0)
		{
			int iNewValue;
			//iMinorFriendshipChange += 100;	// Make it a mod

			for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
			{
				iNewValue = GET_PLAYER((PlayerTypes) iMinorLoop).GetMinorCivAI()->GetBaseFriendshipWithMajorTimes100(GetID());
				iNewValue += iMinorFriendshipChange * 100;

				GET_PLAYER((PlayerTypes) iMinorLoop).GetMinorCivAI()->SetFriendshipWithMajorTimes100(GetID(), iNewValue);
			}
		}
	}
#if defined(MOD_BALANCE_CORE)
	for(int iDomains = 0; iDomains < NUM_DOMAIN_TYPES; iDomains++)
	{
		DomainTypes eDomain = (DomainTypes)iDomains;
		if(eDomain != NO_DOMAIN)
		{
			int iNewValue;
			iNewValue = pBuildingInfo->GetDomainFreeExperiencePerGreatWorkGlobal(iDomains);
			if(iNewValue > 0)
			{
				ChangeDomainFreeExperiencePerGreatWorkGlobal(eDomain, iNewValue);
			}
			iNewValue = pBuildingInfo->GetDomainFreeExperienceGlobal(iDomains);
			if (iNewValue > 0)
			{
				ChangeDomainFreeExperience(eDomain, iNewValue);
			}
		}
	}

	ChangeReformationFollowerReduction(pBuildingInfo->GetReformationFollowerReduction() * iChange);
	ChangeNumMissionarySpreads(pBuildingInfo->GetExtraMissionarySpreadsGlobal() * iChange);

	if (pBuildingInfo->NullifyInfluenceModifier())
	{
		if (iChange > 0)
			SetNullifyInfluenceModifier(true);
		else
			SetNullifyInfluenceModifier(false);
	}

	if (pBuildingInfo->GetNoUnhappfromXSpecialistsGlobal() != 0)
	{
		ChangeNoUnhappfromXSpecialists(pBuildingInfo->GetNoUnhappfromXSpecialistsGlobal() * iChange);
	}

	if(pBuildingInfo->IsSecondaryPantheon())
	{
		ChangeSecondReligionPantheonCount((pBuildingInfo->IsSecondaryPantheon()) ? iChange : 0);
	}
	if(pBuildingInfo->GetTRSpeedBoost() != 0)
	{
		ChangeTRSpeedBoost(pBuildingInfo->GetTRSpeedBoost() * iChange);
	}
	if(pBuildingInfo->GetTRVisionBoost() != 0)
	{
		ChangeTRVisionBoost(pBuildingInfo->GetTRVisionBoost() * iChange);
	}
	if(pBuildingInfo->GetVotesPerGPT() != 0)
	{
		ChangeVotesPerGPT(pBuildingInfo->GetVotesPerGPT() * iChange);
	}
	if(pBuildingInfo->GetGlobalBuildingGoldMaintenanceMod() != 0)
	{
		ChangeBuildingGoldMaintenanceMod(pBuildingInfo->GetGlobalBuildingGoldMaintenanceMod() * iChange);
	}
	if(pBuildingInfo->GetEventTourism() != 0)
	{
		ChangeEventTourism(pBuildingInfo->GetEventTourism() * iChange);
	}
	if(pBuildingInfo->GetSingleVotes() > 0)
	{
		ChangeSingleVotes(pBuildingInfo->GetSingleVotes() * iChange);
	}

	if (pBuildingInfo->GetExtraMissionaryStrength() != 0)
	{
		ChangeMissionaryExtraStrength(pBuildingInfo->GetExtraMissionaryStrength() * iChange);
	}

	if (MOD_BALANCE_CORE_HAPPINESS_MODIFIERS && pBuildingInfo->GetEmpireNeedsModifierGlobal() != 0)
	{
		ChangeEmpireNeedsModifierGlobal(pBuildingInfo->GetEmpireNeedsModifierGlobal() * iChange);
	}
	if(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS && pBuildingInfo->GetPovertyHappinessChangeBuildingGlobal() != 0)
	{
		ChangePovertyUnhappinessGlobal(pBuildingInfo->GetPovertyHappinessChangeBuildingGlobal() * iChange);
	}
	if(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS && pBuildingInfo->GetDefenseHappinessChangeBuildingGlobal() != 0)
	{
		ChangeDefenseUnhappinessGlobal(pBuildingInfo->GetDefenseHappinessChangeBuildingGlobal() * iChange);
	}
	if(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS && pBuildingInfo->GetIlliteracyHappinessChangeBuildingGlobal() != 0)
	{
		ChangeIlliteracyUnhappinessGlobal(pBuildingInfo->GetIlliteracyHappinessChangeBuildingGlobal() * iChange);
	}
	if(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS && pBuildingInfo->GetUnculturedHappinessChangeBuildingGlobal() != 0)
	{
		ChangeUnculturedUnhappinessGlobal(pBuildingInfo->GetUnculturedHappinessChangeBuildingGlobal() * iChange);
	}
	if(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS && pBuildingInfo->GetMinorityHappinessChangeBuildingGlobal() != 0)
	{
		ChangeMinorityUnhappinessGlobal(pBuildingInfo->GetMinorityHappinessChangeBuildingGlobal() * iChange);
	}
	ChangeLandmarksTourismPercentGlobal(pBuildingInfo->GetLandmarksTourismPercentGlobal() * iChange);
	ChangeGreatWorksTourismModifierGlobal(pBuildingInfo->GetGreatWorksTourismModifierGlobal() * iChange);

	ChangeExtraSupplyPerPopulation(pBuildingInfo->GetCitySupplyModifierGlobal() * iChange);
	changeCitySupplyFlatGlobal(pBuildingInfo->GetCitySupplyFlatGlobal() * iChange);

	if (pBuildingInfo->AllowsProductionTradeRoutesGlobal())
	{
		if (iChange > 0)
			SetProductionRoutesAllCities(true);
		else
			SetProductionRoutesAllCities(false);
	}
	if (pBuildingInfo->AllowsFoodTradeRoutesGlobal())
	{
		if (iChange > 0)
			SetFoodRoutesAllCities(true);
		else
			SetFoodRoutesAllCities(false);
	}
#endif

	if(pBuildingInfo->GetFreeBuildingClass() != NO_BUILDINGCLASS)
	{
		BuildingTypes eFreeBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(pBuildingInfo->GetFreeBuildingClass());
		changeFreeBuildingCount(eFreeBuilding, iChange);
	}

	// Unit upgrade cost mod
	ChangeUnitUpgradeCostMod(pBuildingInfo->GetUnitUpgradeCostMod() * iChange);

	// Policy cost mod
	ChangePolicyCostBuildingModifier(pBuildingInfo->GetPolicyCostModifier() * iChange);

	// Border growth mods
	ChangePlotCultureCostModifier(pBuildingInfo->GetGlobalPlotCultureCostModifier() * iChange);
	ChangePlotGoldCostMod(pBuildingInfo->GetGlobalPlotBuyCostModifier() * iChange);
#if defined(MOD_BUILDINGS_CITY_WORKING)
	ChangeCityWorkingChange(pBuildingInfo->GetGlobalCityWorkingChange() * iChange);
#endif

#if defined(MOD_BUILDINGS_CITY_AUTOMATON_WORKERS)
	ChangeCityAutomatonWorkersChange(pBuildingInfo->GetGlobalCityAutomatonWorkersChange() * iChange);
#endif

	// City Culture Mod
	ChangeJONSCultureCityModifier(pBuildingInfo->GetGlobalCultureRateModifier() * iChange);

	// Trade route gold modifier
	GetTreasury()->ChangeCityConnectionTradeRouteGoldModifier(pBuildingInfo->GetCityConnectionTradeRouteModifier() * iChange);

	// Free Promotion
	PromotionTypes eFreePromotion = (PromotionTypes) pBuildingInfo->GetFreePromotion();
	if(eFreePromotion != NO_PROMOTION)
		ChangeFreePromotionCount(eFreePromotion, iChange);

	// Free Promotion Removed
	PromotionTypes eFreePromotionRemoved = (PromotionTypes) pBuildingInfo->GetFreePromotionRemoved();
	if(eFreePromotionRemoved != NO_PROMOTION)
		ChangeFreePromotionCount(eFreePromotionRemoved, -iChange);

	// Extra Happiness Per City
	ChangeExtraHappinessPerCity(pBuildingInfo->GetHappinessPerCity() * iChange);

	// Extra Happiness Per Policy
	ChangeExtraHappinessPerXPolicies(pBuildingInfo->GetHappinessPerXPolicies() * iChange);

	// City Count Unhappiness Mod
	ChangeCityCountUnhappinessMod(pBuildingInfo->GetCityCountUnhappinessMod() * iChange);

	// Hurries
	for(iI = 0; iI < GC.getNumHurryInfos(); iI++)
	{
		changeHurryModifier((HurryTypes) iI, (pBuildingInfo->GetHurryModifier(iI) * iChange));
	}

	changeGreatPeopleRateModFromBldgs(pBuildingInfo->GetGlobalGreatPeopleRateModifier() * iChange);
	changeGreatGeneralRateModFromBldgs(pBuildingInfo->GetGreatGeneralRateModifier() * iChange);
	ChangeGreatScientistBeakerMod(pBuildingInfo->GetGreatScientistBeakerModifier() * iChange);
	ChangeGreatPersonExpendGold(pBuildingInfo->GetGreatPersonExpendGold() * iChange);
#if defined(MOD_DIPLOMACY_CITYSTATES)
	if (MOD_DIPLOMACY_CITYSTATES) ChangeGPExpendInfluence(pBuildingInfo->GetGPExpendInfluence() * iChange);
#endif
	recomputeGreatPeopleModifiers();

	changeGoldenAgeModifier(pBuildingInfo->GetGoldenAgeModifier() * iChange);
	changeFreeExperienceFromBldgs(pBuildingInfo->GetGlobalFreeExperience() * iChange);
	changeWorkerSpeedModifier(pBuildingInfo->GetWorkerSpeedModifier() * iChange);
	ChangeSpecialistCultureChange(pBuildingInfo->GetSpecialistExtraCulture() * iChange);
	changeBorderObstacleCount(pBuildingInfo->IsPlayerBorderObstacle() * iChange);

#if defined(HH_MOD_BUILDINGS_FRUITLESS_PILLAGE)
	changeBorderGainlessPillageCount(pBuildingInfo->IsPlayerBorderGainlessPillage() * iChange);
#endif
	changeSpaceProductionModifier(pBuildingInfo->GetGlobalSpaceProductionModifier() * iChange);

	for(iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		pArea->changeYieldRateModifier(GetID(), ((YieldTypes)iI), (pBuildingInfo->GetAreaYieldModifier(iI) * iChange));
		changeYieldRateModifier(((YieldTypes)iI), (pBuildingInfo->GetGlobalYieldModifier(iI) * iChange));
#if defined(MOD_BALANCE_CORE_POLICIES)
		changeYieldFromDeath(((YieldTypes)iI), (pBuildingInfo->GetYieldFromDeath(iI) * iChange));

		ChangeYieldFromPillage(((YieldTypes)iI), (pBuildingInfo->GetYieldFromPillageGlobalPlayer(iI) * iChange));
		ChangeYieldFromVictory(((YieldTypes)iI), (pBuildingInfo->GetYieldFromVictoryGlobalPlayer(iI) * iChange));
#endif
#if defined(MOD_BALANCE_CORE)
		changeYieldGPExpend(((YieldTypes)iI), (pBuildingInfo->GetYieldFromGPExpend(iI) * iChange));
		int iMod = pBuildingInfo->GetGreatWorkYieldChange(iI) * iChange;
		if(iMod != 0)
		{
			ChangeGreatWorkYieldChange((YieldTypes)iI, iMod);
		}

		for (iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
		{
			changeResourceYieldChange(((ResourceTypes)iJ), ((YieldTypes)iI), (pBuildingInfo->GetResourceYieldChangeGlobal((ResourceTypes)iJ, (YieldTypes)iI) * iChange));
		}
#endif
	}

	for(iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
	{
		for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
		{
			changeSpecialistExtraYield(((SpecialistTypes)iI), ((YieldTypes)iJ), (pBuildingInfo->GetSpecialistYieldChange(iI, iJ) * iChange));
		}
	}

	int iOldEspionageModifier = GetEspionageModifier();
	ChangeEspionageModifier(pBuildingInfo->GetGlobalEspionageModifier() * iChange);
	if(iOldEspionageModifier != GetEspionageModifier())
	{
		int iLoop;
		CvCity* pLoopCity;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
			{
				PlayerTypes ePlayer = (PlayerTypes)ui;
				GET_PLAYER(ePlayer).GetEspionage()->UpdateCity(pLoopCity);
			}
		}
	}

	ChangeExtraLeagueVotes(pBuildingInfo->GetExtraLeagueVotes() * iChange);
#if defined(MOD_BALANCE_CORE_SPIES)
	if(MOD_BALANCE_CORE_SPIES)
	{
		if(pBuildingInfo->GetAdvancedActionGold() > 0)
		{
			changeAdvancedActionGold(pBuildingInfo->GetAdvancedActionGold() * iChange);
		}
		if(pBuildingInfo->GetAdvancedActionScience() > 0)
		{
			changeAdvancedActionScience(pBuildingInfo->GetAdvancedActionScience() * iChange);
		}
		if(pBuildingInfo->GetAdvancedActionUnrest() > 0)
		{
			changeAdvancedActionUnrest(pBuildingInfo->GetAdvancedActionUnrest() * iChange);
		}
		if(pBuildingInfo->GetAdvancedActionRebellion() > 0)
		{
			changeAdvancedActionRebellion(pBuildingInfo->GetAdvancedActionRebellion() * iChange);
		}
		if(pBuildingInfo->GetAdvancedActionGP() > 0)
		{
			changeAdvancedActionGP(pBuildingInfo->GetAdvancedActionGP() * iChange);
		}
		if(pBuildingInfo->GetAdvancedActionUnit() > 0)
		{
			changeAdvancedActionUnit(pBuildingInfo->GetAdvancedActionUnit() * iChange);
		}
		if(pBuildingInfo->GetAdvancedActionWonder() > 0)
		{
			changeAdvancedActionWonder(pBuildingInfo->GetAdvancedActionWonder() * iChange);
		}
		if(pBuildingInfo->GetAdvancedActionBuilding() > 0)
		{
			changeAdvancedActionBuilding(pBuildingInfo->GetAdvancedActionBuilding() * iChange);
		}
		if(pBuildingInfo->GetCannotFailSpies() > 0)
		{
			changeCannotFailSpies(pBuildingInfo->GetCannotFailSpies() * iChange);
		}
	}

	changeMaxAirUnits(pBuildingInfo->GetAirModifierGlobal() * iChange);
	for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
	{
		YieldTypes eYield = (YieldTypes) iJ;
		for(int iK = 0; iK < GC.getNumImprovementInfos(); iK++)
		{
			ImprovementTypes eImprovement = (ImprovementTypes)iK;
			if(eImprovement != NO_IMPROVEMENT)
			{
				int iYieldChange = pBuildingInfo->GetImprovementYieldChangeGlobal(eImprovement, eYield);
				if(iYieldChange != 0)
				{
					ChangeImprovementExtraYield(eImprovement, eYield, (iYieldChange * iChange));
				}
			}
		}
	}

#endif
	// Loop through Cities
	int iLoop;
	CvCity* pLoopCity;
	int iBuildingCount;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		// Building modifiers
		BuildingClassTypes eBuildingClass;
		for(iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
		{
			eBuildingClass = (BuildingClassTypes) iI;

			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
			if(!pkBuildingClassInfo)
			{
				continue;
			}

			BuildingTypes eTestBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

			if(eTestBuilding != NO_BUILDING)
			{
				CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eTestBuilding);
				if(pkBuilding)
				{
					iBuildingCount = pLoopCity->GetCityBuildings()->GetNumBuilding(eTestBuilding);
					if(iBuildingCount > 0)
					{
#if !defined(MOD_API_UNIFIED_YIELDS_CONSOLIDATION)
						pLoopCity->ChangeJONSCulturePerTurnFromBuildings(pBuildingInfo->GetBuildingClassYieldChange(eBuildingClass, YIELD_CULTURE) * iBuildingCount * iChange);
#endif

						// Building Class Yield Stuff
						for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
						{
#if !defined(MOD_API_UNIFIED_YIELDS_CONSOLIDATION)
							switch(iJ)
							{
							case YIELD_CULTURE:
							{
								// Skip, handled above
								break;
							}
							case YIELD_FAITH:
							{
								pLoopCity->ChangeFaithPerTurnFromBuildings(pBuildingInfo->GetBuildingClassYieldChange(eBuildingClass, iJ) * iBuildingCount * iChange);
								break;
							}
							default:
							{
#endif
								YieldTypes eYield = (YieldTypes) iJ;
								int iYieldChange = pBuildingInfo->GetBuildingClassYieldChange(eBuildingClass, eYield);
								if(iYieldChange > 0)
								{
									pLoopCity->ChangeBaseYieldRateFromBuildings(eYield, iYieldChange * iBuildingCount * iChange);
								}

								int iYieldMod = pBuildingInfo->GetBuildingClassYieldModifier(eBuildingClass, eYield);
								if (iYieldMod != 0)
								{
									pLoopCity->changeYieldRateModifier(eYield, iYieldMod * iBuildingCount * iChange);
								}
#if !defined(MOD_API_UNIFIED_YIELDS_CONSOLIDATION)
							}
							}
#endif
						}
					}
				}

			}
		}
		//and update city happiness for all cities, as we may have changed something somewhere...
		pLoopCity->UpdateHappinessFromBuildingClasses();
	}
#if defined(MOD_BALANCE_CORE)
	//Refresh cache data.
	countNumBuildings(eBuilding, true);
	countNumBuildingsInPuppets(eBuilding, true);
#endif
}

//	--------------------------------------------------------------------------------
/// Get yield change from buildings for a specific building class
int CvPlayer::GetBuildingClassYieldChange(BuildingClassTypes eBuildingClass, YieldTypes eYieldType)
{
	int rtnValue = 0;

	CvBuildingXMLEntries* pBuildings = GC.GetGameBuildings();

	if(pBuildings)
	{
		for(int i = 0; i < pBuildings->GetNumBuildings(); i++)
		{
			// Do we have this building anywhere in empire?
			int iNum = countNumBuildings((BuildingTypes)i);

			if(iNum > 0)
			{
				CvBuildingEntry* pEntry = pBuildings->GetEntry(i);
				if(pEntry)
				{
					rtnValue += (pEntry->GetBuildingClassYieldChange(eBuildingClass, eYieldType) * iNum);
				}
			}
		}
	}

#if defined(MOD_BALANCE_CORE)
	CorporationTypes eCorporation = GetCorporations()->GetFoundedCorporation();
	if (eCorporation != NO_CORPORATION)
	{
		CvCorporationEntry* pkCorporation = GC.getCorporationInfo(eCorporation);
		if (pkCorporation)
		{
			rtnValue += pkCorporation->GetBuildingClassYieldChange(eBuildingClass, eYieldType);
		}
	}
#endif

	return rtnValue;
}

//	--------------------------------------------------------------------------------
/// Get yield change from buildings for a specific building class
int CvPlayer::GetBuildingClassYieldModifier(BuildingClassTypes eBuildingClass, YieldTypes eYieldType)
{
	int rtnValue = 0;

	CvBuildingXMLEntries* pBuildings = GC.GetGameBuildings();

	if (pBuildings)
	{
		for (int i = 0; i < pBuildings->GetNumBuildings(); i++)
		{
			// Do we have this building anywhere in empire?
			int iNum = countNumBuildings((BuildingTypes)i);

			if (iNum > 0)
			{
				CvBuildingEntry* pEntry = pBuildings->GetEntry(i);
				if (pEntry)
				{
					rtnValue += (pEntry->GetBuildingClassYieldModifier(eBuildingClass, eYieldType) * iNum);
				}
			}
		}
	}

	return rtnValue;
}

//	--------------------------------------------------------------------------------
/// Can we eBuild on pPlot?
bool CvPlayer::canBuild(const CvPlot* pPlot, BuildTypes eBuild, bool bTestEra, bool bTestVisible, bool bTestGold, bool bTestPlotOwner) const
{
	if(!(pPlot->canBuild(eBuild, GetID(), bTestVisible, bTestPlotOwner)))
	{
		return false;
	}

	if(GC.getBuildInfo(eBuild)->getTechPrereq() != NO_TECH)
	{
		if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)GC.getBuildInfo(eBuild)->getTechPrereq())))
		{
			if((!bTestEra && !bTestVisible) || ((GetCurrentEra() + 1) < GC.getTechInfo((TechTypes) GC.getBuildInfo(eBuild)->getTechPrereq())->GetEra()))
			{
				return false;
			}
		}
	}
#if defined(MOD_BALANCE_CORE)
	if(MOD_BALANCE_CORE && GC.getBuildInfo(eBuild)->getTechObsolete() != NO_TECH)
	{
		if((GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)GC.getBuildInfo(eBuild)->getTechObsolete())))
		{
			return false;
		}
	}
#endif


	// Is this an improvement that is only useable by a specific civ?
	ImprovementTypes eImprovement = (ImprovementTypes)GC.getBuildInfo(eBuild)->getImprovement();
	if(eImprovement != NO_IMPROVEMENT)
	{
		CvImprovementEntry* pkEntry = GC.getImprovementInfo(eImprovement);
		if(pkEntry->IsSpecificCivRequired())
		{
			CivilizationTypes eCiv = pkEntry->GetRequiredCivilization();
			if(eCiv != getCivilizationType())
			{
				return false;
			}
		}
	}

	if(!bTestVisible)
	{
		if(IsBuildBlockedByFeature(eBuild, pPlot->getFeatureType()))
		{
			return false;
		}

		if(bTestGold)
		{
			if(std::max(0, GetTreasury()->GetGold()) < getBuildCost(pPlot, eBuild))
			{
				return false;
			}
		}
	}

	return true;
}

//	--------------------------------------------------------------------------------
/// Are we prevented from eBuild-ing because of a Feature on this plot?
bool CvPlayer::IsBuildBlockedByFeature(BuildTypes eBuild, FeatureTypes eFeature) const
{
	// No Feature here to block us
	if(eFeature == NO_FEATURE)
	{
		return false;
	}

	// Build does not remove the Feature on pPlot
	if(!GC.getBuildInfo(eBuild)->isFeatureRemove(eFeature))
	{
		return false;
	}

	TechTypes ePrereqTech = (TechTypes) GC.getBuildInfo(eBuild)->getFeatureTech(eFeature);

	// Clearing Feature doesn't require any Tech, so we can do it right now if we have to
	if(ePrereqTech == NO_TECH)
	{
		return false;
	}

	// Clearing eFeature requires a Tech, but we have it
	if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech(ePrereqTech))
	{
		return false;
	}

	// Feature is blocking us!
	return true;
}

//	--------------------------------------------------------------------------------
// Returns the cost
int CvPlayer::getBuildCost(const CvPlot* pPlot, BuildTypes eBuild) const
{
	CvAssert(eBuild >= 0 && eBuild < GC.getNumBuildInfos());


	CvBuildInfo* pkBuildInfo = GC.getBuildInfo(eBuild);
	if(pkBuildInfo == NULL)
	{
		return 0;
	}

	if(pPlot->getBuildProgress(eBuild) > 0)
	{
		return 0;
	}

	if(pPlot->getRouteType() != NO_ROUTE && pPlot->getRouteType() == pkBuildInfo->getRoute() && pPlot->IsRoutePillaged())
	{
		return 0;
	}

	int iBuildCost = pkBuildInfo->getCost();

	// Cost increases as more Improvements are built
	iBuildCost += (getTotalImprovementsBuilt() * pkBuildInfo->getCostIncreasePerImprovement());

	iBuildCost *= (100 + getImprovementCostModifier());
	iBuildCost /= 100;

	if(pPlot->getFeatureType() != NO_FEATURE)
	{
		iBuildCost += pkBuildInfo->getFeatureCost(pPlot->getFeatureType());
	}

	iBuildCost *= getHandicapInfo().getImprovementCostPercent();
	iBuildCost /= 100;

	iBuildCost *= GC.getGame().getGameSpeedInfo().getImprovementPercent();
	iBuildCost /= 100;

	return std::max(0, iBuildCost);
}


//	--------------------------------------------------------------------------------
RouteTypes CvPlayer::getBestRoute(CvPlot* pPlot) const
{
	if (pPlot==NULL)
		return GET_TEAM(getTeam()).GetBestPossibleRoute();

	RouteTypes eRoute;
	RouteTypes eBestRoute;
	int iValue;
	int iBestValue;
	int iI;

	iBestValue = 0;
	eBestRoute = NO_ROUTE;

	for(iI = 0; iI < GC.getNumBuildInfos(); iI++)
	{
		const BuildTypes eBuild = static_cast<BuildTypes>(iI);
		CvBuildInfo* pkBuildInfo = GC.getBuildInfo(eBuild);
		if(pkBuildInfo)
		{
			eRoute = ((RouteTypes)(pkBuildInfo->getRoute()));
			if(eRoute != NO_ROUTE)
			{
				CvRouteInfo* pkRouteInfo = GC.getRouteInfo(eRoute);
				if(pkRouteInfo)
				{
					if( (pPlot->getRouteType() == eRoute) || canBuild(pPlot, eBuild) )
					{
#if defined(MOD_BALANCE_CORE)
						if(MOD_BALANCE_CORE && pkBuildInfo->getTechObsolete() == NO_TECH)
						{
							iValue = pkRouteInfo->getValue();
						}
						else if(MOD_BALANCE_CORE && !GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pkBuildInfo->getTechObsolete())))
						{
							iValue = pkRouteInfo->getValue();
						}
						else
						{
							iValue = 0;
						}
#else
						iValue = pkRouteInfo->getValue();
#endif
						if(iValue > iBestValue)
						{
							iBestValue = iValue;
							eBestRoute = eRoute;
						}

					}
				}
			}
		}
	}

	return eBestRoute;
}


//	--------------------------------------------------------------------------------
int CvPlayer::getImprovementUpgradeRate() const
{
	int iRate;

	iRate = 100; // XXX

	iRate *= std::max(0, (getImprovementUpgradeRateModifier() + 100));
	iRate /= 100;

	return iRate;
}

//	--------------------------------------------------------------------------------
/// How much Production do we get from removing ANY Feature in the game? (Policy Bonus)
int CvPlayer::GetAllFeatureProduction() const
{
	return m_iAllFeatureProduction;
}

//	--------------------------------------------------------------------------------
/// Changes how much Production we get from removing ANY Feature in the game (Policy Bonus)
void CvPlayer::ChangeAllFeatureProduction(int iChange)
{
	if(iChange != 0)
	{
		m_iAllFeatureProduction += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// How far a tile is from a city (1-3) This is used to determine camera zoom on the city view
int CvPlayer::GetCityDistanceHighwaterMark() const
{
	return m_iCityDistanceHighwaterMark;
}

//	--------------------------------------------------------------------------------
/// Set how far a tile is from a city (1-3) This is used to determine camera zoom on the city view
void CvPlayer::SetCityDistanceHighwaterMark(int iNewValue)
{
	m_iCityDistanceHighwaterMark = iNewValue;
}


//	--------------------------------------------------------------------------------
int CvPlayer::calculateTotalYield(YieldTypes eYield) const
{
#if defined(MOD_API_UNIFIED_YIELDS)
	// This is based on the switch in CvEconomicAI::LogMonitor() that calls different methods for culture and faith
	// I've added this here as a "safe guard"
	if (eYield == YIELD_CULTURE)
	{
		return GetTotalJONSCulturePerTurn() + m_viInstantYieldsTotal[YIELD_CULTURE] / (GC.getGame().getElapsedGameTurns() + 1);
	}
	else if (eYield == YIELD_FAITH)
	{
		return GetTotalFaithPerTurn() + m_viInstantYieldsTotal[YIELD_FAITH] / (GC.getGame().getElapsedGameTurns() + 1);
	}
	else if (eYield == YIELD_TOURISM)
	{
		return GetCulture()->GetTourism() / 100 + m_viInstantYieldsTotal[YIELD_TOURISM] / (GC.getGame().getElapsedGameTurns() + 1);
	}
#endif

	const CvCity* pLoopCity;
	int iTotalYield = 0;
	int iLoop = 0;

	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iTotalYield += pLoopCity->getYieldRateTimes100(eYield, false);
	}

	//average accumulated instant yields over elapsed turns
	iTotalYield += (m_viInstantYieldsTotal[eYield] * 100) / (GC.getGame().getElapsedGameTurns() + 1);

	return iTotalYield / 100;
}

//	--------------------------------------------------------------------------------
/// How much Production is being eaten up by Units? (cached)
int CvPlayer::GetUnitProductionMaintenanceMod() const
{
	// Kind of a cop-out, but it fixes some bugs for now
	return calculateUnitProductionMaintenanceMod();
}

//	--------------------------------------------------------------------------------
/// How much Production is being eaten up by Units? (update cache)
void CvPlayer::UpdateUnitProductionMaintenanceMod()
{
	m_iUnitProductionMaintenanceMod = calculateUnitProductionMaintenanceMod();

	if(GetID() == GC.getGame().getActivePlayer())
	{
		GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
	}
}

//	--------------------------------------------------------------------------------
/// How much Production is being eaten up by Units?
int CvPlayer::calculateUnitProductionMaintenanceMod() const
{
	int iPaidUnits = GetNumUnitsOutOfSupply();

	// Example: Player can support 8 Units, he has 12. 4 * 10 means he loses 40% of his Production
	int iNormal = 10;
#if defined(MOD_BALANCE_DYNAMIC_UNIT_SUPPLY)
	if (MOD_BALANCE_DYNAMIC_UNIT_SUPPLY)
	{
		iNormal = 5;
	}
#endif
	int iMaintenanceMod = min(/*70*/ GC.getMAX_UNIT_SUPPLY_PRODMOD(), iPaidUnits * iNormal);
	iMaintenanceMod = -iMaintenanceMod;

	return iMaintenanceMod;
}

//	--------------------------------------------------------------------------------
/// How much Growth is being eaten up by Units? (cached)
int CvPlayer::GetUnitGrowthMaintenanceMod() const
{
	// Kind of a cop-out, but it fixes some bugs for now
	return calculateUnitGrowthMaintenanceMod();
}

//	--------------------------------------------------------------------------------
/// How much Growth is being eaten up by Units? (update cache)
void CvPlayer::UpdateUnitGrowthMaintenanceMod()
{
	m_iUnitGrowthMaintenanceMod = calculateUnitGrowthMaintenanceMod();

	if (GetID() == GC.getGame().getActivePlayer())
	{
		GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
	}
}

//	--------------------------------------------------------------------------------
/// How much Growth is being eaten up by Units?
int CvPlayer::calculateUnitGrowthMaintenanceMod() const
{
	int iPaidUnits = GetNumUnitsOutOfSupply();

	// Example: Player can support 8 Units, he has 12. 4 * 10 means he loses 40% of his Production
	int iMaintenanceMod = min(/*70*/ GC.getMAX_UNIT_SUPPLY_PRODMOD(), iPaidUnits * 5);
	iMaintenanceMod = -iMaintenanceMod;

	return iMaintenanceMod;
}

//	--------------------------------------------------------------------------------
/// How many Units can we support for free without losing Production and Growth?
int CvPlayer::GetNumUnitsSupplied() const
{
	if (m_iNumUnitsSuppliedCached == -1)
	{

		int iFreeUnits = GetNumUnitsSuppliedByHandicap();
		iFreeUnits += GetNumUnitsSuppliedByCities();
		iFreeUnits += GetNumUnitsSuppliedByPopulation();
#if defined(MOD_BALANCE_DYNAMIC_UNIT_SUPPLY)
		if (MOD_BALANCE_DYNAMIC_UNIT_SUPPLY)
		{
			int iWarWeariness = GetCulture()->GetWarWeariness()/2;
			int iMod = (100 - min(75, iWarWeariness));
			iFreeUnits *= iMod;
			iFreeUnits /= 100;
		}
#endif

		if (!isMinorCiv() && !isHuman() && !IsAITeammateOfHuman())
		{
			int iMod = (100 + GC.getGame().getHandicapInfo().getAIUnitSupplyPercent());
			iFreeUnits *= iMod;
			iFreeUnits /= 100;
		}

		m_iNumUnitsSuppliedCached = max(0,iFreeUnits);
	}

	return m_iNumUnitsSuppliedCached;
}

//	--------------------------------------------------------------------------------
/// Units supplied from Difficulty Level
int CvPlayer::GetNumUnitsSuppliedByHandicap(bool bIgnoreReduction) const
{
#if defined(MOD_TRAITS_EXTRA_SUPPLY)
	int iSupply = getHandicapInfo().getProductionFreeUnits() + m_pTraits->GetExtraSupply();
	if (MOD_BALANCE_DYNAMIC_UNIT_SUPPLY)
	{
		if (!bIgnoreReduction)
		{
			iSupply -= GetCurrentEra();
			if (iSupply <= 0)
				iSupply = 0;
		}
	}
	// Don't need a test here for MOD_TRAITS_EXTRA_SUPPLY being enabled, as if it isn't GetExtraSupply() will return 0
	return iSupply;
#else
	return getHandicapInfo().getProductionFreeUnits();
#endif
}

//	--------------------------------------------------------------------------------
/// Units supplied by Cities
int CvPlayer::GetNumUnitsSuppliedByCities(bool bIgnoreReduction) const
{
	if (MOD_BALANCE_DYNAMIC_UNIT_SUPPLY)
	{
		int iStartingSupply = getHandicapInfo().getProductionFreeUnitsPerCity();
		
		int iValue = m_pTraits->GetExtraSupply();
		const CvCity* pLoopCity;
		int iLoop;
		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			int iSupply = (iStartingSupply + pLoopCity->getCitySupplyFlat() + getCitySupplyFlatGlobal());
			iValue += iSupply;
		}

		if (!bIgnoreReduction)
		{
			int iTechProgress = (GET_TEAM(getTeam()).GetTeamTechs()->GetNumTechsKnown() * 100) / GC.getNumTechInfos();
			if(iTechProgress >= 100)
				iTechProgress = 100;
			
			iTechProgress *= 5;
			iTechProgress /= 6;

			iValue *= 100;
			iValue /= (100 + iTechProgress);
		}
		if (iValue < 0)
			return 0;
		
		return iValue;
	}
#if defined(MOD_TRAITS_EXTRA_SUPPLY)
	// Don't need a test here for MOD_TRAITS_EXTRA_SUPPLY being enabled, as if it isn't GetExtraSupply() will return 0
	return ((getHandicapInfo().getProductionFreeUnitsPerCity() + m_pTraits->GetExtraSupply()) * getNumCities());
#else
	return getHandicapInfo().getProductionFreeUnitsPerCity() * getNumCities();
#endif
}

//	--------------------------------------------------------------------------------
/// Units supplied by Population
int CvPlayer::GetNumUnitsSuppliedByPopulation(bool bIgnoreReduction) const
{
#if defined(MOD_TRAITS_EXTRA_SUPPLY)
	if (MOD_BALANCE_DYNAMIC_UNIT_SUPPLY)
	{
		int iStartingSupply = getHandicapInfo().getProductionFreeUnitsPopulationPercent();
		
		int iValue = 0;
		const CvCity* pLoopCity;
		int iLoop;
		
		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			int iPopulation = 0;
			int iSupply = (iStartingSupply + pLoopCity->getCitySupplyModifier() + m_pTraits->GetExtraSupplyPerPopulation() + GetExtraSupplyPerPopulation());
			if (pLoopCity->IsPuppet() && !GetPlayerTraits()->IsNoAnnexing())
			{
				iPopulation = (pLoopCity->getPopulation() / 2) * 100;
			}
			else
			{
				iPopulation = pLoopCity->getPopulation() * 100;
			}

			iValue += ((iPopulation * iSupply) / 100);
		}

		if (!bIgnoreReduction)
		{
			int iTechProgress = (GET_TEAM(getTeam()).GetTeamTechs()->GetNumTechsKnown() * 100) / GC.getNumTechInfos();
			if(iTechProgress >= 100)
				iTechProgress = 100;
			
			iTechProgress *= 7;
				
			iValue *= 100;
			iValue /= (100 + iTechProgress);
		}

		iValue /= 100;

		if (iValue < 0)
			return 0;

		return iValue; 
	}
	// Don't need a test here for MOD_TRAITS_EXTRA_SUPPLY being enabled, as if it isn't GetExtraSupply() will return 0
	return getTotalPopulation() * (m_pTraits->GetExtraSupplyPerPopulation() + GetExtraSupplyPerPopulation() + getHandicapInfo().getProductionFreeUnitsPopulationPercent()) / 100;
#else
	return getTotalPopulation() * getHandicapInfo().getProductionFreeUnitsPopulationPercent() / 100;
#endif
}

//	--------------------------------------------------------------------------------
/// How much Units are eating Production?
int CvPlayer::GetNumUnitsOutOfSupply() const
{
	int iNumUnitsToSupply = getNumMilitaryUnits() - getNumUnitsSupplyFree();
	return std::max(0, iNumUnitsToSupply - GetNumUnitsSupplied());
}

#if defined(MOD_BALANCE_CORE)
int CvPlayer::GetNumUnitsToSupply() const
{
	return getNumMilitaryUnits() - getNumUnitsSupplyFree();
}

//these are mercenaries etc
int CvPlayer::getNumUnitsSupplyFree() const
{
	return m_iSupplyFreeUnits;
}

void CvPlayer::changeNumUnitsSupplyFree(int iValue)
{
	if (iValue != 0)
	{
		m_iSupplyFreeUnits += iValue;
	}
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::calculateUnitCost() const
{
	int iFreeUnits;
	int iPaidUnits;
	int iBaseUnitCost;
	int iExtraCost;

	return GetTreasury()->CalculateUnitCost(iFreeUnits, iPaidUnits, iBaseUnitCost, iExtraCost);
}

//	--------------------------------------------------------------------------------
int CvPlayer::calculateUnitSupply() const
{
	int iPaidUnits;
	int iBaseSupplyCost;

	return GetTreasury()->CalculateUnitSupply(iPaidUnits, iBaseSupplyCost);
}

//	--------------------------------------------------------------------------------
int CvPlayer::calculateResearchModifier(TechTypes eTech)
{
	int iModifier = 100;

	if(NO_TECH == eTech)
	{
		return iModifier;
	}

	int iKnownCount = 0;
	int iPossibleKnownCount = 0;
	for(int iI = 0; iI < MAX_CIV_TEAMS; iI++)
	{
		CvTeam& kLoopTeam = GET_TEAM((TeamTypes)iI);
		if(kLoopTeam.isAlive() && !kLoopTeam.isMinorCiv())
		{
#if defined(MOD_DIPLOMACY_TECH_BONUSES)
			bool bCouldBorrowTech;
			
			if (MOD_DIPLOMACY_TECH_BONUSES)
			{
#if defined(MOD_API_EXTENSIONS)
				if (GetEspionage()->GetNumSpies() > 0)
				{
					// We've got spies!  So we need one in a capital of a player in the other team
					bCouldBorrowTech = GET_TEAM(getTeam()).HasSpyAtTeam((TeamTypes)iI);
				}
				else
#endif
				{
					// No spies yet, so use embassy status
					bCouldBorrowTech = GET_TEAM(getTeam()).HasEmbassyAtTeam((TeamTypes)iI);
				}
			}
			else
			{
				bCouldBorrowTech = GET_TEAM(getTeam()).isHasMet((TeamTypes)iI);
			}
			
			if(bCouldBorrowTech)
#else
			if(GET_TEAM(getTeam()).isHasMet((TeamTypes)iI))
#endif
			{
				if(kLoopTeam.GetTeamTechs()->HasTech(eTech))
				{
					iKnownCount++;
				}
			}
			iPossibleKnownCount++;
		}
	}
	if(iPossibleKnownCount > 0)
	{
		iModifier += (GC.getTECH_COST_TOTAL_KNOWN_TEAM_MODIFIER() * iKnownCount) / iPossibleKnownCount;
	}

	int iPossiblePaths = 0;
	int iUnknownPaths = 0;
	for(int iI = 0; iI < GC.getNUM_OR_TECH_PREREQS(); iI++)
	{
		if(GC.getTechInfo(eTech)->GetPrereqOrTechs(iI) != NO_TECH)
		{
			if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(GC.getTechInfo(eTech)->GetPrereqOrTechs(iI)))))
			{
				iUnknownPaths++;
			}

			iPossiblePaths++;
		}
	}
	CvAssertMsg(iPossiblePaths >= iUnknownPaths, "The number of possible paths is expected to match or exceed the number of unknown ones");
	iModifier += (iPossiblePaths - iUnknownPaths) * GC.getTECH_COST_KNOWN_PREREQ_MODIFIER();

	// Leagues mod
	int iLeaguesMod = GC.getGame().GetGameLeagues()->GetResearchMod(GetID(), eTech);
	if (iLeaguesMod != 0)
	{
#if defined(MOD_DIPLOMACY_CITYSTATES_RESOLUTIONS)
		if(MOD_DIPLOMACY_CITYSTATES_RESOLUTIONS && (!isMinorCiv() && !isBarbarian()))
		{
			//Research bonus for city-state alliances
			PlayerTypes eMinor;
			int iMinorAllies = 0;
			int iLeaguesAidScience = 0;
			for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
			{
				eMinor = (PlayerTypes) iMinorLoop;
				if(GET_PLAYER(eMinor).GetMinorCivAI()->IsAllies(GetID()))
				{
					iMinorAllies++;
				}
			}
			if(iMinorAllies > 0)
			{
				//+5% Science per ally.
				iLeaguesAidScience += min(50, (iMinorAllies * /*5*/ GC.getSCHOLAR_MINOR_ALLY_MULTIPLIER()));
				SetScienceRateFromMinorAllies(iLeaguesAidScience);
				iLeaguesMod += GetScienceRateFromMinorAllies();
			}
			else
			{
				SetScienceRateFromMinorAllies(0);
			}
		}
#endif
		iModifier *= (100 + iLeaguesMod);
		iModifier /= 100;
	}

	return iModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::calculateGoldRate() const
{
	return calculateGoldRateTimes100() / 100;
}


//	--------------------------------------------------------------------------------
int CvPlayer::calculateGoldRateTimes100() const
{
	// If we're in anarchy, then no Gold is collected!
	if(IsAnarchy())
	{
		return 0;
	}

	int iRate = 0;

	iRate = GetTreasury()->CalculateBaseNetGoldTimes100();

	return iRate;
}

//	--------------------------------------------------------------------------------
int CvPlayer::unitsRequiredForGoldenAge() const
{
	return (GC.getBASE_GOLDEN_AGE_UNITS() + (getNumUnitGoldenAges() * GC.getGOLDEN_AGE_UNITS_MULTIPLIER()));
}


//	--------------------------------------------------------------------------------
int CvPlayer::unitsGoldenAgeCapable() const
{
	const CvUnit* pLoopUnit;
	int iCount;
	int iLoop;

	iCount = 0;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->isGoldenAge())
		{
			iCount++;
		}
	}

	return iCount;
}


//	--------------------------------------------------------------------------------
int CvPlayer::unitsGoldenAgeReady() const
{
	const CvUnit* pLoopUnit;
	bool* pabUnitUsed;
	int iCount;
	int iLoop;
	int iI;

	pabUnitUsed = FNEW(bool[GC.getNumUnitInfos()], c_eCiv5GameplayDLL, 0);

	for(iI = 0; iI < GC.getNumUnitInfos(); iI++)
	{
		pabUnitUsed[iI] = false;
	}

	iCount = 0;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(!(pabUnitUsed[pLoopUnit->getUnitType()]))
		{
			if(pLoopUnit->isGoldenAge())
			{
				pabUnitUsed[pLoopUnit->getUnitType()] = true;
				iCount++;
			}
		}
	}

	SAFE_DELETE_ARRAY(pabUnitUsed);

	return iCount;
}

//	--------------------------------------------------------------------------------
int CvPlayer::greatGeneralThreshold() const
{
	int iThreshold;

	iThreshold = ((/*200*/ GC.getGREAT_GENERALS_THRESHOLD() * std::max(0, (getGreatGeneralsThresholdModifier() + 100))) / 100);

	UnitClassTypes eUnitClassGeneral = (UnitClassTypes)GC.getInfoTypeForString("UNITCLASS_GREAT_GENERAL");
	int iMod = GetPlayerTraits()->GetGreatPersonCostReduction(GetGreatPersonFromUnitClass(eUnitClassGeneral));
	if (iMod != 0)
	{
		iThreshold *= (100 + iMod);
		iThreshold /= 100;
	}

	iThreshold *= GC.getGame().getGameSpeedInfo().getTrainPercent();
	iThreshold /= 100;

	return std::max(1, iThreshold);
}

//	--------------------------------------------------------------------------------
int CvPlayer::greatAdmiralThreshold() const
{
	int iThreshold;

	iThreshold = ((/*200*/ GC.getGREAT_GENERALS_THRESHOLD() * std::max(0, (getGreatAdmiralsThresholdModifier() + 100))) / 100);

	UnitClassTypes eUnitClassAdmiral = (UnitClassTypes)GC.getInfoTypeForString("UNITCLASS_GREAT_ADMIRAL");
	int iMod = GetPlayerTraits()->GetGreatPersonCostReduction(GetGreatPersonFromUnitClass(eUnitClassAdmiral));
	if (iMod != 0)
	{
		iThreshold *= (100 + iMod);
		iThreshold /= 100;
	}

	iThreshold *= GC.getGame().getGameSpeedInfo().getTrainPercent();
	iThreshold /= 100;

	return std::max(1, iThreshold);
}

//	--------------------------------------------------------------------------------
int CvPlayer::specialistYield(SpecialistTypes eSpecialist, YieldTypes eYield) const
{
	CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
	if(pkSpecialistInfo == NULL)
	{
		//This function REQUIRES a valid specialist info.
		CvAssert(pkSpecialistInfo);
		return 0;
	}

	int iRtnValue = pkSpecialistInfo->getYieldChange(eYield) + getSpecialistExtraYield(eSpecialist, eYield) + GetPlayerTraits()->GetSpecialistYieldChange(eSpecialist, eYield);
#if defined(MOD_API_UNIFIED_YIELDS)
	iRtnValue += getSpecialistYieldChange(eSpecialist, eYield);
#endif

	if (eSpecialist != GC.getDEFAULT_SPECIALIST())
	{
		iRtnValue += getSpecialistExtraYield(eYield);
	}
	return (iRtnValue);
}

//	--------------------------------------------------------------------------------
/// How much additional Yield does every City produce?
#if defined(MOD_BUGFIX_MINOR)
int CvPlayer::GetCityYieldChangeTimes100(YieldTypes eYield) const
#else
int CvPlayer::GetCityYieldChange(YieldTypes eYield) const
#endif
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiCityYieldChange[eYield];
}

//	--------------------------------------------------------------------------------
/// Changes how much additional Yield every City produces
#if defined(MOD_BUGFIX_MINOR)
void CvPlayer::ChangeCityYieldChangeTimes100(YieldTypes eYield, int iChange)
#else
void CvPlayer::ChangeCityYieldChange(YieldTypes eYield, int iChange)
#endif
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiCityYieldChange.setAt(eYield, m_aiCityYieldChange[eYield] + iChange);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
/// How much additional Yield do coastal Cities produce?
int CvPlayer::GetCoastalCityYieldChange(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiCoastalCityYieldChange[eYield];
}

//	--------------------------------------------------------------------------------
/// Changes how much additional Yield coastal Cities produce
void CvPlayer::ChangeCoastalCityYieldChange(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiCoastalCityYieldChange.setAt(eYield, m_aiCoastalCityYieldChange[eYield] + iChange);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
/// How much additional Yield does the Capital produce?
#if defined(MOD_BUGFIX_MINOR)
int CvPlayer::GetCapitalYieldChangeTimes100(YieldTypes eYield) const
#else
int CvPlayer::GetCapitalYieldChange(YieldTypes eYield) const
#endif
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiCapitalYieldChange[eYield];
}

//	--------------------------------------------------------------------------------
/// Changes how much additional Yield the Capital produces
#if defined(MOD_BUGFIX_MINOR)
void CvPlayer::ChangeCapitalYieldChangeTimes100(YieldTypes eYield, int iChange)
#else
void CvPlayer::ChangeCapitalYieldChange(YieldTypes eYield, int iChange)
#endif
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiCapitalYieldChange.setAt(eYield, m_aiCapitalYieldChange[eYield] + iChange);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
/// How much additional Yield does the Capital produce per pop?
int CvPlayer::GetCapitalYieldPerPopChange(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiCapitalYieldPerPopChange[eYield];
}

//	--------------------------------------------------------------------------------
/// Changes how much additional Yield the Capital produces per pop
void CvPlayer::ChangeCapitalYieldPerPopChange(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiCapitalYieldPerPopChange.setAt(eYield, m_aiCapitalYieldPerPopChange[eYield] + iChange);

		updateYield();
	}
}


//	--------------------------------------------------------------------------------
/// How much additional Yield does the Capital produce per pop?
int CvPlayer::GetCapitalYieldPerPopChangeEmpire(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiCapitalYieldPerPopChangeEmpire[eYield];
}

//	--------------------------------------------------------------------------------
/// Changes how much additional Yield the Capital produces per pop
void CvPlayer::ChangeCapitalYieldPerPopChangeEmpire(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiCapitalYieldPerPopChangeEmpire.setAt(eYield, m_aiCapitalYieldPerPopChangeEmpire[eYield] + iChange);

		updateYield();
	}
}


//	--------------------------------------------------------------------------------
/// How much additional Yield does a Great Work produce?
int CvPlayer::GetGreatWorkYieldChange(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiGreatWorkYieldChange[eYield];
}

//	--------------------------------------------------------------------------------
/// Changes how much additional Yield a Great Work produces
void CvPlayer::ChangeGreatWorkYieldChange(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiGreatWorkYieldChange.setAt(eYield, m_aiGreatWorkYieldChange[eYield] + iChange);
	}
}

//	--------------------------------------------------------------------------------
CvPlot* CvPlayer::getStartingPlot() const
{
	return GC.getMap().plotCheckInvalid(m_iStartingX, m_iStartingY);
}


//	--------------------------------------------------------------------------------
void CvPlayer::setStartingPlot(CvPlot* pNewValue)
{
	CvPlot* pOldStartingPlot = getStartingPlot();

	if(pOldStartingPlot != pNewValue)
	{
		if(pOldStartingPlot != NULL)
		{
			pOldStartingPlot->area()->changeNumStartingPlots(-1);
		}

		if(pNewValue == NULL)
		{
			m_iStartingX = INVALID_PLOT_COORD;
			m_iStartingY = INVALID_PLOT_COORD;
		}
		else
		{
			m_iStartingX = pNewValue->getX();
			m_iStartingY = pNewValue->getY();

			getStartingPlot()->setStartingPlot(true);

			CvArea* pArea = getStartingPlot()->area();
			if(pArea != NULL)
				pArea->changeNumStartingPlots(1);
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getTotalPopulation() const
{
	return m_iTotalPopulation;
}


//	--------------------------------------------------------------------------------
float CvPlayer::getAveragePopulation() const
{
	if(getNumCities() == 0)
	{
		return 0;
	}

	return getTotalPopulation() / (float)getNumCities();
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeTotalPopulation(int iChange)
{
	m_iTotalPopulation = (m_iTotalPopulation + iChange);
	CvAssert(getTotalPopulation() >= 0);
}


//	--------------------------------------------------------------------------------
long CvPlayer::getRealPopulation() const
{
	const CvCity* pLoopCity;
	__int64 iTotalPopulation = 0;
	int iLoop = 0;

	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iTotalPopulation += pLoopCity->getRealPopulation();
	}

	if(iTotalPopulation > INT_MAX)
	{
		iTotalPopulation = INT_MAX;
	}

	return ((long)(iTotalPopulation));
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNewCityExtraPopulation() const
{
	return m_iNewCityExtraPopulation;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNewCityExtraPopulation(int iChange)
{
	if(iChange != 0)
	{
		m_iNewCityExtraPopulation += iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetFreeFoodBox() const
{
	return m_iFreeFoodBox;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeFreeFoodBox(int iChange)
{
	if(iChange != 0)
	{
		m_iFreeFoodBox += iChange;
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getTotalLand() const
{
	return m_iTotalLand;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeTotalLand(int iChange)
{
	m_iTotalLand = (m_iTotalLand + iChange);
	CvAssert(getTotalLand() >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getTotalLandScored() const
{
	return m_iTotalLandScored;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeTotalLandScored(int iChange)
{
	if(iChange != 0)
	{
		m_iTotalLandScored = (m_iTotalLandScored + iChange);
		CvAssert(getTotalLandScored() >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Total culture per turn
int CvPlayer::GetTotalJONSCulturePerTurn() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_POLICIES))
	{
		return 0;
	}

	// No culture during Anarchy
	if(IsAnarchy())
	{
		return 0;
	}

	int iCulturePerTurn = 0;

	// Culture per turn from Cities
	iCulturePerTurn += GetJONSCulturePerTurnFromCities();

	// Special bonus which adds excess Happiness to Culture?
	iCulturePerTurn += GetJONSCulturePerTurnFromExcessHappiness();

	// Trait bonus which adds Culture for trade partners? 
	iCulturePerTurn += GetJONSCulturePerTurnFromTraits();

	// Free culture that's part of the player
	iCulturePerTurn += GetJONSCulturePerTurnForFree();

	// Culture from Minor Civs
	iCulturePerTurn += GetCulturePerTurnFromMinorCivs();

	// Culture from Religion
	iCulturePerTurn += GetCulturePerTurnFromReligion();
	
	// Temporary boost from bonus turns
	iCulturePerTurn += GetCulturePerTurnFromBonusTurns();

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (MOD_DIPLOMACY_CIV4_FEATURES) {
		// We're a vassal of someone, we get x% of his science
		iCulturePerTurn += (GetYieldPerTurnFromVassals(YIELD_CULTURE));
	}

	if (MOD_BALANCE_CORE_JFD)
	{
		iCulturePerTurn += GetYieldPerTurnFromMinors(YIELD_CULTURE);
	}
#endif

	// Golden Age bonus
	if (isGoldenAge() && !IsGoldenAgeCultureBonusDisabled())
	{
		iCulturePerTurn += ((iCulturePerTurn * GC.getGOLDEN_AGE_CULTURE_MODIFIER()) / 100);
	}

	return iCulturePerTurn;
}

//	--------------------------------------------------------------------------------
/// Culture per turn from Cities
int CvPlayer::GetJONSCulturePerTurnFromCities() const
{
	int iCulturePerTurn = 0;

	// Add in culture from Cities
	const CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iCulturePerTurn += pLoopCity->getJONSCulturePerTurn();
	}

	return iCulturePerTurn;
}

//	--------------------------------------------------------------------------------
/// Culture per turn from Cities times 100
int CvPlayer::GetJONSCultureFromCitiesTimes100(bool bIgnoreTrade) const
{
	int iCulture = 0;

	const CvCity* pLoopCity;

	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iCulture += pLoopCity->getYieldRateTimes100(YIELD_CULTURE, bIgnoreTrade);
	}

	return iCulture;
}

//	--------------------------------------------------------------------------------
/// Special bonus which adds excess Happiness to Culture?
int CvPlayer::GetJONSCulturePerTurnFromExcessHappiness() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS))
	{
		return 0;
	}
	if (MOD_BALANCE_CORE_HAPPINESS)
		return 0;

	if(getHappinessToCulture() != 0)
	{
		if(GetExcessHappiness() > 0)
		{
			int iFreeCulture = GetExcessHappiness() * getHappinessToCulture();
			iFreeCulture /= 100;

			return iFreeCulture;
		}
	}

	return 0;
}

//	--------------------------------------------------------------------------------
/// Trait bonus which adds Culture for trade partners? //ADDED: Culture from resources exported/imported
int CvPlayer::GetJONSCulturePerTurnFromTraits() const
{
#if defined(MOD_API_UNIFIED_YIELDS)
	return (GetYieldPerTurnFromTraits(YIELD_CULTURE) + GetYieldPerTurnFromResources(YIELD_CULTURE, true, true));
#else
	return GetPlayerTraits()->GetYieldChangePerTradePartner(YIELD_CULTURE) * GetTrade()->GetNumDifferentTradingPartners();
#endif
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Yield per turn from resources imported/exported
int CvPlayer::GetYieldPerTurnFromResources(YieldTypes eYield, bool bExported, bool bImported) const
{
	int iExport = 0;
	int iImport = 0;
	int iTotal = 0;
	int iEra = GetCurrentEra();
	if(iEra < 1)
	{
		iEra = 1;
	}
	//Let's get our total imports/exports
	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
		CvResourceInfo* pInfo = GC.getResourceInfo(eResourceLoop);
		// Is it a luxury?
		if (pInfo && pInfo->getResourceUsage() == RESOURCEUSAGE_LUXURY)
		{
			if(getResourceExport(eResourceLoop) > 0)
			{
				iExport++;
			}
			if(getResourceImport(eResourceLoop) > 0)
			{
				iImport++;
			}
			else if(getResourceFromMinors(eResourceLoop) > 0)
			{
				iImport++;
			}
			else if(getResourceSiphoned(eResourceLoop) > 0)
			{
				iImport++;
			}
		}
	}
	if(bExported)
	{
		if(GetPlayerTraits()->GetYieldFromExport(eYield) > 0)
		{
			iTotal += (iEra * iExport * GetPlayerTraits()->GetYieldFromExport(eYield));
		}
	}
	if(bImported)
	{
		if(GetPlayerTraits()->GetYieldFromImport(eYield) > 0)
		{
			iTotal += (iEra * iImport * GetPlayerTraits()->GetYieldFromImport(eYield));
		}
	}

	return iTotal;
}
#endif
//	--------------------------------------------------------------------------------
/// Culture per turn player starts with for free
int CvPlayer::GetJONSCulturePerTurnForFree() const
{
	return m_iJONSCulturePerTurnForFree;
}

//	--------------------------------------------------------------------------------
/// Culture per turn player starts with for free
void CvPlayer::ChangeJONSCulturePerTurnForFree(int iChange)
{
	if(iChange != 0)
		m_iJONSCulturePerTurnForFree += iChange;

	if(GC.getGame().getActivePlayer() == GetID())
	{
		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
	}
}

//	--------------------------------------------------------------------------------
/// DEPRECATED, use GetCulturePerTurnFromMinorCivs() instead
int CvPlayer::GetJONSCulturePerTurnFromMinorCivs() const
{
	return GetCulturePerTurnFromMinorCivs();
}

//	--------------------------------------------------------------------------------
/// DEPRECATED, value is now changed within CvMinorCivAI
void CvPlayer::ChangeJONSCulturePerTurnFromMinorCivs(int /*iChange*/)
{
	CvAssertMsg(false, "ChangeJONSCulturePerTurnFromMinorCivs called, but Anton meant to disable it");
}

//	--------------------------------------------------------------------------------
/// Culture per turn from all minor civs
int CvPlayer::GetCulturePerTurnFromMinorCivs() const
{
	int iAmount = 0;
	PlayerTypes eMinor;
	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		eMinor = (PlayerTypes) iMinorLoop;
		iAmount += GetCulturePerTurnFromMinor(eMinor);
	}

	return iAmount;
}

//	--------------------------------------------------------------------------------
// Culture per turn from a minor civ
int CvPlayer::GetCulturePerTurnFromMinor(PlayerTypes eMinor) const
{
	int iAmount = 0;

	if(GET_PLAYER(eMinor).isAlive())
	{
		// Includes flat bonus and any bonus from cultural buildings
		iAmount += GET_PLAYER(eMinor).GetMinorCivAI()->GetCurrentCultureBonus(GetID());
	}

	return iAmount;
}

//	--------------------------------------------------------------------------------
/// Culture per turn from religion
int CvPlayer::GetCulturePerTurnFromReligion() const
{
	int iOtherCulturePerTurn = 0;
	int iReligionCulturePerTurn = 0;

	// Start by seeing how much the other types are bringing in
	iOtherCulturePerTurn += GetJONSCulturePerTurnFromCities();
	iOtherCulturePerTurn += GetJONSCulturePerTurnFromExcessHappiness();
	iOtherCulturePerTurn += GetJONSCulturePerTurnForFree();
	iOtherCulturePerTurn += GetCulturePerTurnFromMinorCivs();

	// Founder beliefs
	CvGameReligions* pReligions = GC.getGame().GetGameReligions();
	ReligionTypes eFoundedReligion = GC.getGame().GetGameReligions()->GetFounderBenefitsReligion(GetID());
	if(eFoundedReligion == NO_RELIGION)
	{
		eFoundedReligion = GetReligions()->GetReligionInMostCities();
	}
	if(eFoundedReligion != NO_RELIGION)
	{
		const CvReligion* pReligion = pReligions->GetReligion(eFoundedReligion, NO_PLAYER);
		if(pReligion)
		{
#if defined(MOD_API_UNIFIED_YIELDS)
			iReligionCulturePerTurn += GetYieldPerTurnFromReligion(YIELD_CULTURE);
#else
			iReligionCulturePerTurn += pReligion->m_Beliefs.GetHolyCityYieldChange(YIELD_CULTURE);

			int iTemp = pReligion->m_Beliefs.GetYieldChangePerForeignCity(YIELD_CULTURE);
			if (iTemp > 0)
			{
				iReligionCulturePerTurn += (iTemp * GetReligions()->GetNumForeignCitiesFollowing());
			}

			iTemp = pReligion->m_Beliefs.GetYieldChangePerXForeignFollowers(YIELD_CULTURE);
			if (iTemp > 0)
			{
				int iFollowers = GetReligions()->GetNumForeignFollowers(false /*bAtPeace*/);
				if (iFollowers > 0)
				{
					iReligionCulturePerTurn += (iFollowers / iTemp);
				}
			}
#endif
			bool bAtPeace = GET_TEAM(getTeam()).getAtWarCount(false) == 0;
			CvCity* pHolyCity = NULL;
			CvPlot* pHolyCityPlot = GC.getMap().plot(pReligion->m_iHolyCityX, pReligion->m_iHolyCityY);
			if (pHolyCityPlot)
			{
				pHolyCity = pHolyCityPlot->getPlotCity();
			}
			int iMod = pReligion->m_Beliefs.GetPlayerCultureModifier(bAtPeace, GetID(), pHolyCity, true);

			if (iMod != 0)
			{
				iReligionCulturePerTurn += ((iReligionCulturePerTurn + iOtherCulturePerTurn) * iMod) / 100;
			}
			return iReligionCulturePerTurn;
		}
	}
	return 0;
}

//	--------------------------------------------------------------------------------
/// Culture from Bonus Turns
int CvPlayer::GetCulturePerTurnFromBonusTurns() const
{
	int iValue = 0;

	int iCulturePerTurn = 0;
	if (GetCultureBonusTurns() > 0 || GetCultureBonusTurnsConquest() > 0)
	{
		// Culture per turn from Cities
		iCulturePerTurn += GetJONSCulturePerTurnFromCities();

		// Special bonus which adds excess Happiness to Culture?
		iCulturePerTurn += GetJONSCulturePerTurnFromExcessHappiness();

		// Trait bonus which adds Culture for trade partners? 
		iCulturePerTurn += GetJONSCulturePerTurnFromTraits();

		// Free culture that's part of the player
		iCulturePerTurn += GetJONSCulturePerTurnForFree();

		// Culture from Minor Civs
		iCulturePerTurn += GetCulturePerTurnFromMinorCivs();

		// Culture from Religion
		iCulturePerTurn += GetCulturePerTurnFromReligion();

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		if (MOD_DIPLOMACY_CIV4_FEATURES) {
			// We're a vassal of someone, we get x% of his science
			iCulturePerTurn += (GetYieldPerTurnFromVassals(YIELD_CULTURE));
		}

		if (MOD_BALANCE_CORE_JFD)
		{
			iCulturePerTurn += GetYieldPerTurnFromMinors(YIELD_CULTURE);
		}
#endif

		// Golden Age bonus
		if (isGoldenAge() && !IsGoldenAgeCultureBonusDisabled())
		{
			iCulturePerTurn += ((iCulturePerTurn * GC.getGOLDEN_AGE_CULTURE_MODIFIER()) / 100);
		}
	}

	if (GetCultureBonusTurns() > 0)
	{
		iValue += ((iCulturePerTurn * GC.getTEMPORARY_CULTURE_BOOST_MOD()) / 100);
	}
#if defined(MOD_BALANCE_CORE)
	if (GetCultureBonusTurnsConquest() > 0)
	{
		iValue += ((iCulturePerTurn * GetPlayerTraits()->GetCultureBonusModifierConquest()) / 100);
	}	
#endif

	return iValue;
}

//	--------------------------------------------------------------------------------
/// Modifier for all Cities' culture
int CvPlayer::GetJONSCultureCityModifier() const
{
	return m_iJONSCultureCityModifier;
}

//	--------------------------------------------------------------------------------
/// Modifier for all Cities' culture
void CvPlayer::ChangeJONSCultureCityModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iJONSCultureCityModifier += iChange;

		if(GC.getGame().getActivePlayer() == GetID())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

#if defined(MOD_DIPLOMACY_CITYSTATES)
//	--------------------------------------------------------------------------------
/// Modifier for all Cities' culture
int CvPlayer::GetLeagueCultureCityModifier() const
{
	return m_iLeagueCultureCityModifier;
}

//	--------------------------------------------------------------------------------
/// Modifier for all Cities' culture
void CvPlayer::ChangeLeagueCultureCityModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iLeagueCultureCityModifier += iChange;

		if(GC.getGame().getActivePlayer() == GetID())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getJONSCulture() const
{
	// City States can't pick Policies, sorry!
	if(isMinorCiv())
		return 0;

	if(GC.getGame().isOption(GAMEOPTION_NO_POLICIES))
	{
		return 0;
	}

	return m_iJONSCulture;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setJONSCulture(int iNewValue)
{
	if(getJONSCulture() != iNewValue)
	{
		// Add to the total we've ever had
		if(iNewValue > m_iJONSCulture)
		{
			ChangeJONSCultureEverGenerated(iNewValue - m_iJONSCulture);
		}

		m_iJONSCulture = max(0,iNewValue);

		if(GC.getGame().getActivePlayer() == GetID())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeJONSCulture(int iChange)
{
	setJONSCulture(getJONSCulture() + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::GetJONSCultureEverGenerated() const
{
	return m_iJONSCultureEverGenerated;
}


//	--------------------------------------------------------------------------------
void CvPlayer::SetJONSCultureEverGenerated(int iNewValue)
{
	if(GetJONSCultureEverGenerated() != iNewValue)
	{
		m_iJONSCultureEverGenerated = iNewValue;
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeJONSCultureEverGenerated(int iChange)
{
	SetJONSCultureEverGenerated(GetJONSCultureEverGenerated() + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::GetJONSCulturePerCityPerTurn() const
{
	int iCulture = GetJONSCultureEverGenerated();
	int iNumCities = getNumCities();

	// Puppet Cities don't count
	iNumCities -= GetNumPuppetCities();

	int iNumTurns = GC.getGame().getElapsedGameTurns();

	if(iNumTurns == 0)
	{
		iNumTurns = 1;
	}

	int iCulturePerCityPerTurn = 100 * iCulture / iNumCities / iNumTurns;
	return iCulturePerCityPerTurn;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetWondersConstructed() const
{
	return m_iWondersConstructed;
}


//	--------------------------------------------------------------------------------
void CvPlayer::SetWondersConstructed(int iNewValue)
{
	m_iWondersConstructed = iNewValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeWondersConstructed(int iChange)
{
	SetWondersConstructed(GetWondersConstructed() + iChange);
}

//	--------------------------------------------------------------------------------
/// Amount of extra Culture per Wonder
int CvPlayer::GetCulturePerWonder() const
{
	return m_iCulturePerWonder;
}

//	--------------------------------------------------------------------------------
/// Changes amount of extra Culture per Wonder
void CvPlayer::ChangeCulturePerWonder(int iChange)
{
	if(iChange != 0)
	{
		m_iCulturePerWonder += iChange;

		int iTotalCultureChange;

		// Loop through all Cities and change how much Culture they produce based on how many Wonders they have
		CvCity* pLoopCity;
		int iLoop;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			iTotalCultureChange = pLoopCity->getNumWorldWonders() * iChange;
			pLoopCity->ChangeJONSCulturePerTurnFromPolicies(iTotalCultureChange);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Culture multiplier for having a world wonder
int CvPlayer::GetCultureWonderMultiplier() const
{
	return m_iCultureWonderMultiplier;
}

//	--------------------------------------------------------------------------------
/// Changes amount of extra Culture per Wonder
void CvPlayer::ChangeCultureWonderMultiplier(int iChange)
{
	if(iChange != 0)
		m_iCultureWonderMultiplier += iChange;
}

//	--------------------------------------------------------------------------------
/// Amount of Culture provided for each Tech Researched
int CvPlayer::GetCulturePerTechResearched() const
{
	return m_iCulturePerTechResearched;
}

//	--------------------------------------------------------------------------------
/// Changes amount of Culture provided for each Tech Researched
void CvPlayer::ChangeCulturePerTechResearched(int iChange)
{
	if(iChange != 0)
	{
		m_iCulturePerTechResearched += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Specialist Culture Modifier
int CvPlayer::GetSpecialistCultureChange() const
{
	return m_iSpecialistCultureChange;
}

//	--------------------------------------------------------------------------------
/// Specialist Culture Modifier
void CvPlayer::ChangeSpecialistCultureChange(int iChange)
{
	if(iChange != 0)
	{
		CvCity* pLoopCity;
		int iLoop;

		int iTotalCulture = 0;

		SpecialistTypes eSpecialist;
		int iSpecialistLoop;
		int iSpecialistCount;

		// Undo old culture
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			for(iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
			{
				eSpecialist = (SpecialistTypes) iSpecialistLoop;
				iSpecialistCount = pLoopCity->GetCityCitizens()->GetSpecialistCount(eSpecialist);
				iTotalCulture += (iSpecialistCount * pLoopCity->GetCultureFromSpecialist(eSpecialist));
			}

			pLoopCity->ChangeJONSCulturePerTurnFromSpecialists(-iTotalCulture);
		}

		// CHANGE VALUE
		m_iSpecialistCultureChange += iChange;

		iTotalCulture = 0;

		// Apply new culture
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			for(iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
			{
				eSpecialist = (SpecialistTypes) iSpecialistLoop;
				iSpecialistCount = pLoopCity->GetCityCitizens()->GetSpecialistCount(eSpecialist);
				iTotalCulture += (iSpecialistCount * pLoopCity->GetCultureFromSpecialist(eSpecialist));
			}

			pLoopCity->ChangeJONSCulturePerTurnFromSpecialists(iTotalCulture);
		}
	}
}

//	--------------------------------------------------------------------------------
/// What is the sum of culture yield from the previous N turns?
/// NOTE: This uses the data tracked in recording a replay, so if replays are disabled in the future then this must change!
int CvPlayer::GetCultureYieldFromPreviousTurns(int iGameTurn, int iNumPreviousTurnsToCount)
{
	// Culture per turn yield is tracked in replay data, so use that
	int iSum = 0;
	for (int iI = 1; iI < iNumPreviousTurnsToCount+1; iI++)
	{
		int iTurn = iGameTurn - iI;
		if (iTurn < 0)
		{
			break;
		}

		int iTurnCulture = getReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_CULTUREPERTURN"), iTurn);
		if (iTurnCulture >= 0)
		{
			iSum += iTurnCulture;
		}
		else if (iTurnCulture == -1) // No data for this turn (ex. late era start)
		{
			iSum += (3 * GetTotalJONSCulturePerTurn());
		}
	}

	return iSum;
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// What is the sum of tourism yield from the previous N turns?
/// NOTE: This uses the data tracked in recording a replay, so if replays are disabled in the future then this must change!
int CvPlayer::GetTourismYieldFromPreviousTurns(int iGameTurn, int iNumPreviousTurnsToCount)
{
	// Culture per turn yield is tracked in replay data, so use that
	int iSum = 0;
	for (int iI = 1; iI < iNumPreviousTurnsToCount+1; iI++)
	{
		int iTurn = iGameTurn - iI;
		if (iTurn < 0)
		{
			break;
		}

		int iTurnTourism = getReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_TOURISMPERTURN"), iTurn);
		if (iTurnTourism >= 0)
		{
			iSum += iTurnTourism;
		}
		else if (iTurnTourism == -1) // No data for this turn (ex. late era start)
		{
			iSum += (3 * GetCulture()->GetTourism() / 100);
		}
	}

	return iSum;
}

int CvPlayer::GetGAPYieldFromPreviousTurns(int iGameTurn, int iNumPreviousTurnsToCount)
{
	// Culture per turn yield is tracked in replay data, so use that
	int iSum = 0;
	for (int iI = 1; iI < iNumPreviousTurnsToCount + 1; iI++)
	{
		int iTurn = iGameTurn - iI;
		if (iTurn < 0)
		{
			break;
		}

		int iTurnGAP = getReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_GAPPERTURN"), iTurn);
		if (iTurnGAP >= 0)
		{
			iSum += iTurnGAP;
		}
		else if (iTurnGAP == -1) // No data for this turn (ex. late era start)
		{
			iSum += (3 * GetGoldenAgePointsFromEmpire() + GetHappinessForGAP());
		}
	}

	return iSum;
}
#endif

//	--------------------------------------------------------------------------------
/// Cities remaining to get a free culture building
int CvPlayer::GetNumCitiesFreeCultureBuilding() const
{
	return m_iNumCitiesFreeCultureBuilding;
}

//	--------------------------------------------------------------------------------
/// Changes number of cities remaining to get a free culture building
void CvPlayer::ChangeNumCitiesFreeCultureBuilding(int iChange)
{
	if(iChange != 0)
		m_iNumCitiesFreeCultureBuilding += iChange;
}

//	--------------------------------------------------------------------------------
/// Cities remaining to get a free culture building
int CvPlayer::GetNumCitiesFreeFoodBuilding() const
{
	return m_iNumCitiesFreeFoodBuilding;
}

//	--------------------------------------------------------------------------------
/// Changes number of cities remaining to get a free culture building
void CvPlayer::ChangeNumCitiesFreeFoodBuilding(int iChange)
{
	if(iChange != 0)
		m_iNumCitiesFreeFoodBuilding += iChange;
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Cities remaining to get a free building
int CvPlayer::GetNumCitiesFreeChosenBuilding(BuildingClassTypes eBuildingClass) const
{
	CvAssertMsg(eBuildingClass < GC.getNumBuildingClassInfos(), "Index out of bounds");
	CvAssertMsg(eBuildingClass > -1, "Index out of bounds");
	return m_paiNumCitiesFreeChosenBuilding[eBuildingClass];
}

//	--------------------------------------------------------------------------------
/// Changes number of cities remaining to get a free building
void CvPlayer::ChangeNumCitiesFreeChosenBuilding(BuildingClassTypes eBuildingClass, int iChange)
{
	m_paiNumCitiesFreeChosenBuilding.setAt(eBuildingClass, (m_paiNumCitiesFreeChosenBuilding[eBuildingClass] + iChange));
}
/// New Founded City waiting to get a free unit?
bool CvPlayer::IsFreeUnitNewFoundCity(UnitClassTypes eUnitClass) const
{
	CvAssertMsg(eUnitClass < GC.getNumUnitClassInfos(), "Index out of bounds");
	CvAssertMsg(eUnitClass > -1, "Index out of bounds");
	return m_pabNewFoundCityFreeUnit[eUnitClass];
}
//	--------------------------------------------------------------------------------
/// Changes number of newly founded cities to get a free building
void CvPlayer::ChangeNewFoundCityFreeUnit(UnitClassTypes eUnitClass, bool bValue)
{
	m_pabNewFoundCityFreeUnit.setAt(eUnitClass, bValue);
}
/// New Founded City waiting to get a free building?
bool CvPlayer::IsFreeBuildingNewFoundCity(BuildingClassTypes eBuildingClass) const
{
	CvAssertMsg(eBuildingClass < GC.getNumBuildingClassInfos(), "Index out of bounds");
	CvAssertMsg(eBuildingClass > -1, "Index out of bounds");
	return m_pabNewFoundCityFreeBuilding[eBuildingClass];
}
//	--------------------------------------------------------------------------------
/// Changes number of newly founded cities to get a free building
void CvPlayer::ChangeNewFoundCityFreeBuilding(BuildingClassTypes eBuildingClass, bool bValue)
{
	m_pabNewFoundCityFreeBuilding.setAt(eBuildingClass, bValue);
}
/// Cities remaining to get a free building
bool CvPlayer::IsFreeChosenBuildingNewCity(BuildingClassTypes eBuildingClass) const
{
	CvAssertMsg(eBuildingClass < GC.getNumBuildingClassInfos(), "Index out of bounds");
	CvAssertMsg(eBuildingClass > -1, "Index out of bounds");
	return m_pabFreeChosenBuildingNewCity[eBuildingClass];
}

//	--------------------------------------------------------------------------------
/// Changes number of new cities remaining to get a free building
void CvPlayer::ChangeFreeChosenBuildingNewCity(BuildingClassTypes eBuildingClass, bool bValue)
{
	m_pabFreeChosenBuildingNewCity.setAt(eBuildingClass, bValue);
}
// City waiting to get a free building?
bool CvPlayer::IsFreeBuildingAllCity(BuildingClassTypes eBuildingClass) const
{
	CvAssertMsg(eBuildingClass < GC.getNumBuildingClassInfos(), "Index out of bounds");
	CvAssertMsg(eBuildingClass > -1, "Index out of bounds");
	return m_pabAllCityFreeBuilding[eBuildingClass];
}
// Change Cities that get a Free building
void CvPlayer::ChangeAllCityFreeBuilding(BuildingClassTypes eBuildingClass, bool bValue)
{
	m_pabAllCityFreeBuilding.setAt(eBuildingClass, bValue);
}

/// Reformation Unlock
void CvPlayer::SetReformation(bool bValue)
{
	if(m_bIsReformation != bValue)
	{
		m_bIsReformation = bValue;
	}
}

bool CvPlayer::IsReformation() const
{
	return m_bIsReformation;
}

int CvPlayer::GetReformationFollowerReduction() const
{
	return m_iReformationFollowerReduction;
}

void CvPlayer::ChangeReformationFollowerReduction(int iValue)
{
	m_iReformationFollowerReduction += iValue;
}
#endif
//	--------------------------------------------------------------------------------
/// Handle earning yields from a combat win
void CvPlayer::DoYieldsFromKill(CvUnit* pAttackingUnit, CvUnit* pDefendingUnit)
{
#if defined(MOD_BALANCE_CORE)
	//Bonus resource in a city every time you win a battle.
	if (MOD_BALANCE_CORE && pDefendingUnit != NULL && pDefendingUnit->IsCombatUnit())
	{
		CvCity* pOriginCity = NULL;
		if (pAttackingUnit != NULL)
		{
			pOriginCity = pAttackingUnit->getOriginCity();
			if (pOriginCity == NULL)
				pOriginCity = getCapitalCity();
		}
		else if (pDefendingUnit->plot()->getOwner() == GetID())
		{
			pOriginCity = pDefendingUnit->plot()->getOwningCity();
		}

		doInstantYield(INSTANT_YIELD_TYPE_VICTORY, false, NO_GREATPERSON, NO_BUILDING, 0, true, NO_PLAYER, NULL, false, pOriginCity, pDefendingUnit->getDomainType() == DOMAIN_SEA, true, false, NO_YIELD, pDefendingUnit, NO_TERRAIN, NULL, NULL, pAttackingUnit);
		doInstantYield(INSTANT_YIELD_TYPE_VICTORY_GLOBAL, false, NO_GREATPERSON, NO_BUILDING, 0, true, NO_PLAYER, NULL, false, NULL, pDefendingUnit->getDomainType() == DOMAIN_SEA, true, false, NO_YIELD, pDefendingUnit, NO_TERRAIN, NULL, NULL, pAttackingUnit);
	}
#endif
}

//	--------------------------------------------------------------------------------
/// Each a technology from conquering a city
void CvPlayer::DoTechFromCityConquer(CvCity* pConqueredCity)
{
	PlayerTypes eOpponent = pConqueredCity->getOwner();
	FStaticVector<TechTypes, 128, true, c_eCiv5GameplayDLL> vePossibleTechs;
	int iCheapestTechCost = MAX_INT;
	for (int i = 0; i < GC.getNumTechInfos(); i++)
	{
		TechTypes e = (TechTypes) i;
		CvTechEntry* pInfo = GC.getTechInfo(e);
		if (pInfo)
		{
			// They have it
			if (GET_TEAM(GET_PLAYER(eOpponent).getTeam()).GetTeamTechs()->HasTech(e))
			{
				// We don't
				if (!GET_TEAM(getTeam()).GetTeamTechs()->HasTech(e))
				{
					// But we could
					if (GetPlayerTechs()->CanResearch(e))
					{
						if (pInfo->GetResearchCost() < iCheapestTechCost)
						{
							iCheapestTechCost = pInfo->GetResearchCost();
							vePossibleTechs.clear();
							vePossibleTechs.push_back(e);
						}
						else if (pInfo->GetResearchCost() == iCheapestTechCost)
						{
							vePossibleTechs.push_back(e);
						}
					}
				}
			}
		}
	}

	if (!vePossibleTechs.empty())
	{
		int iRoll = GC.getGame().getSmallFakeRandNum((int)vePossibleTechs.size(), GET_PLAYER(pConqueredCity->getOwner()).GetPseudoRandomSeed());
		TechTypes eFreeTech = vePossibleTechs[iRoll];
		CvAssert(eFreeTech != NO_TECH)
		if (eFreeTech != NO_TECH)
		{
			GET_TEAM(getTeam()).setHasTech(eFreeTech, true, GetID(), true, true);
			GET_TEAM(getTeam()).GetTeamTechs()->SetNoTradeTech(eFreeTech, true);
		}
	}
#if defined(MOD_BALANCE_CORE)
	else
	{
		int iEra = GetCurrentEra();
		if(iEra <= 1)
		{
			iEra = 1;
		}
		const char* strTargetNameKey = pConqueredCity->getNameKey();
		TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
		int iValue = (pConqueredCity->getPopulation() * 20 * iEra);
		iValue *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
		iValue /= 100;
		if(eCurrentTech == NO_TECH)
		{
			changeOverflowResearch(iValue);
		}
		else
		{
			GET_TEAM(GET_PLAYER(GetID()).getTeam()).GetTeamTechs()->ChangeResearchProgress(eCurrentTech, iValue, GetID());
		}
		if(GetID() == GC.getGame().getActivePlayer())
		{
			Localization::String strMessage;
			Localization::String strSummary;
			strMessage = Localization::Lookup("TXT_KEY_SCIENCE_BOOST_CONQUEST");
			strMessage << iValue;
			strMessage << strTargetNameKey;
			strSummary = Localization::Lookup("TXT_KEY_SCIENCE_BOOST_CONQUEST_SUMMARY");

			CvNotifications* pNotification = GetNotifications();
			if(pNotification)
			{
				pNotification->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), pConqueredCity->getX(), pConqueredCity->getY(), (int) pConqueredCity->GetID(), GetID());
			}
		}
	}
#endif
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Generate a random great work on city conquest
void CvPlayer::DoFreeGreatWorkOnConquest(PlayerTypes ePlayer, CvCity* pCity)
{
	GreatWorkSlotType eArtArtifactSlot = CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT();
	GreatWorkSlotType eMusicSlot = CvTypes::getGREAT_WORK_SLOT_MUSIC();
	GreatWorkSlotType eWritingSlot = CvTypes::getGREAT_WORK_SLOT_LITERATURE();

	int iOpenSlots = 0;
	int iStuffStolen = 0;
	CvWeightedVector<int, SAFE_ESTIMATE_NUM_BUILDINGS, true> artChoices;
	const char* strTargetNameKey = pCity->getNameKey();
	const CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iOpenSlots += pLoopCity->GetCityBuildings()->GetNumAvailableGreatWorkSlots(eArtArtifactSlot);
		iOpenSlots += pLoopCity->GetCityBuildings()->GetNumAvailableGreatWorkSlots(eMusicSlot);
		iOpenSlots += pLoopCity->GetCityBuildings()->GetNumAvailableGreatWorkSlots(eWritingSlot);
	}
	if (GET_PLAYER(ePlayer).isAlive() && !GET_PLAYER(ePlayer).isMinorCiv() && !GET_PLAYER(ePlayer).isBarbarian())
	{
		if (iOpenSlots > 0)
		{
			int iCityLoop;
			CvCity* pPlayerCity = NULL;
			int iGreatWorkIndex;
			for (pPlayerCity = GET_PLAYER(ePlayer).firstCity(&iCityLoop); pPlayerCity != NULL; pPlayerCity = GET_PLAYER(ePlayer).nextCity(&iCityLoop))
			{
				if (pPlayerCity != NULL && pPlayerCity != pCity)
				{
					int iDistance = plotDistance(pCity->getX(), pCity->getY(), pPlayerCity->getX(), pPlayerCity->getY());
					if (iDistance > 0)
					{
						for (int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
						{
							const CvCivilizationInfo& playerCivilizationInfo = GET_PLAYER(ePlayer).getCivilizationInfo();
							BuildingTypes eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings((BuildingClassTypes)iBuildingClassLoop);
							if (eBuilding != NO_BUILDING)
							{
								CvBuildingEntry *pkBuilding = GC.getBuildingInfo(eBuilding);
								if (pkBuilding)
								{
									if (pPlayerCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0 && (pkBuilding->GetGreatWorkSlotType() == eArtArtifactSlot || pkBuilding->GetGreatWorkSlotType() == eMusicSlot || pkBuilding->GetGreatWorkSlotType() == eWritingSlot))
									{
										int iNumSlots = pkBuilding->GetGreatWorkCount();
										if (iNumSlots > 0)
										{
											for (int iI = 0; iI < iNumSlots; iI++)
											{
												iGreatWorkIndex = pPlayerCity->GetCityBuildings()->GetBuildingGreatWork((BuildingClassTypes)iBuildingClassLoop, iI);
												if (iGreatWorkIndex != -1 && !GetCulture()->ControlsGreatWork(iGreatWorkIndex))
												{
													artChoices.push_back(iGreatWorkIndex, iDistance);
													if ((GC.getLogging() && GC.getAILogging()))
													{
														CvGameCulture *pCulture = GC.getGame().GetGameCulture();
														if (pCulture)
														{
															CvString strLogString;
															strLogString.Format("Found Great Work for Conquest Plunder: %d, Distance: %d, Name: %s", iGreatWorkIndex, iDistance, pCulture->GetGreatWorkName(iGreatWorkIndex).GetCString());
															GetHomelandAI()->LogHomelandMessage(strLogString);
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			artChoices.SortItems();
			int iNotificationArtwork = -1;
			if (artChoices.size() > 0)
			{
				int iPlunder = GC.getGame().getSmallFakeRandNum(max(1, (iOpenSlots / 5)), GET_PLAYER(pCity->getOwner()).GetPseudoRandomSeed());
				if (iPlunder <= 2)
				{
					iPlunder = 2;
				}
				if (iPlunder > artChoices.size())
				{
					iPlunder = artChoices.size();
				}
				if ((GC.getLogging() && GC.getAILogging()))
				{
					CvString strLogString;
					strLogString.Format("Number of Great Works to steal for Conquest Plunder: %d", iPlunder);
					GetHomelandAI()->LogHomelandMessage(strLogString);
				}
				for (int iGrab = 0; iGrab < artChoices.size(); iGrab++)
				{
					if (iStuffStolen >= iPlunder)
					{
						break;
					}
					int iCityLoop;
					CvCity* pPlayerCity = NULL;
					int iGreatWorkIndex;
					for (pPlayerCity = GET_PLAYER(ePlayer).firstCity(&iCityLoop); pPlayerCity != NULL; pPlayerCity = GET_PLAYER(ePlayer).nextCity(&iCityLoop))
					{
						if (iStuffStolen >= iPlunder)
						{
							break;
						}
						if (pPlayerCity != NULL && pPlayerCity != pCity)
						{
							for (int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
							{
								if (iStuffStolen >= iPlunder)
								{
									break;
								}
								const CvCivilizationInfo& playerCivilizationInfo = GET_PLAYER(ePlayer).getCivilizationInfo();
								BuildingTypes eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings((BuildingClassTypes)iBuildingClassLoop);
								if (eBuilding != NO_BUILDING)
								{
									CvBuildingEntry *pkBuilding = GC.getBuildingInfo(eBuilding);
									if (pkBuilding)
									{
										if (pPlayerCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0 && (pkBuilding->GetGreatWorkSlotType() == eArtArtifactSlot || pkBuilding->GetGreatWorkSlotType() == eMusicSlot || pkBuilding->GetGreatWorkSlotType() == eWritingSlot))
										{
											int iNumSlots = pkBuilding->GetGreatWorkCount();
											if (iNumSlots > 0)
											{
												for (int iI = 0; iI < iNumSlots; iI++)
												{
													if (iStuffStolen >= iPlunder)
													{
														break;
													}
													iGreatWorkIndex = pPlayerCity->GetCityBuildings()->GetBuildingGreatWork((BuildingClassTypes)iBuildingClassLoop, iI);
													if (iGreatWorkIndex == artChoices.GetElement(iGrab))
													{
														iNotificationArtwork = iGreatWorkIndex;
														// and create great work at home
														BuildingClassTypes eGWBuildingClass;
														int iGWSlot;
														CvCity *pArtCity = GetCulture()->GetClosestAvailableGreatWorkSlot(pPlayerCity->getX(), pPlayerCity->getY(), pkBuilding->GetGreatWorkSlotType(), &eGWBuildingClass, &iGWSlot);
														if (pArtCity)
														{
															// remove existing great works
															pPlayerCity->GetCityBuildings()->SetBuildingGreatWork((BuildingClassTypes)iBuildingClassLoop, iI, -1);
															pArtCity->GetCityBuildings()->SetBuildingGreatWork(eGWBuildingClass, iGWSlot, iGreatWorkIndex);
															iStuffStolen++;
															if ((GC.getLogging() && GC.getAILogging()))
															{
																CvGameCulture *pCulture = GC.getGame().GetGameCulture();
																if (pCulture)
																{
																	CvString strLogString;
																	strLogString.Format("Great Work STOLEN for Conquest Plunder: %s. Number stolen: %d. Max to steal: %d", pCulture->GetGreatWorkName(iGreatWorkIndex).GetCString(), iStuffStolen, iPlunder);
																	GetHomelandAI()->LogHomelandMessage(strLogString);
																}
															}
															if (GetID() == GC.getGame().getActivePlayer())
															{
																CvPopupInfo kPopup(BUTTONPOPUP_GREAT_WORK_COMPLETED_ACTIVE_PLAYER, iGreatWorkIndex);
																GC.GetEngineUserInterface()->AddPopup(kPopup);
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			if (iStuffStolen > 0)
			{
				if (GetID() == GC.getGame().getActivePlayer())
				{
					Localization::String strMessage;
					Localization::String strSummary;
					strMessage = Localization::Lookup("TXT_KEY_ART_STOLEN");
					strMessage << iStuffStolen;
					strMessage << strTargetNameKey;
					strSummary = Localization::Lookup("TXT_KEY_ART_STOLEN_SUMMARY");

					CvNotifications* pNotification = GetNotifications();
					if (pNotification)
					{
						pNotification->Add(NOTIFICATION_GREAT_WORK_COMPLETED_ACTIVE_PLAYER, strMessage.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), iNotificationArtwork, GET_PLAYER(ePlayer).GetID());
					}
				}
				if (ePlayer == GC.getGame().getActivePlayer())
				{
					Localization::String strMessage;
					Localization::String strSummary;
					strMessage = Localization::Lookup("TXT_KEY_ART_PLUNDERED");
					strMessage << iStuffStolen;
					strMessage << strTargetNameKey;
					strSummary = Localization::Lookup("TXT_KEY_ART_PLUNDERED_SUMMARY");

					CvNotifications* pNotification = GET_PLAYER(ePlayer).GetNotifications();
					if (pNotification)
					{
						pNotification->Add(NOTIFICATION_GREAT_WORK_COMPLETED_ACTIVE_PLAYER, strMessage.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), iNotificationArtwork, pCity->getOwner());
					}
				}
			}
		}
	}
}
void CvPlayer::DoWarVictoryBonuses()
{
	int iTurns = GetPlayerTraits()->GetGoldenAgeFromVictory();
	if(iTurns > 0)
	{
		if(iTurns < GC.getGame().goldenAgeLength())
		{
			iTurns = GC.getGame().goldenAgeLength();
		}
		// Player modifier
		int iLengthModifier = getGoldenAgeModifier();

		// Trait modifier
		iLengthModifier += GetPlayerTraits()->GetGoldenAgeDurationModifier();

#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
		// Do we get increased Golden Ages from a resource monopoly?
		if(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
		{
			for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
			{
				ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
				if(eResourceLoop != NO_RESOURCE)
				{
					CvResourceInfo* pInfo = GC.getResourceInfo(eResourceLoop);
					if (pInfo && pInfo->isMonopoly())
					{
						if(HasGlobalMonopoly(eResourceLoop) && pInfo->getMonopolyGALength() > 0)
						{
							int iTemp = pInfo->getMonopolyGALength();
							iTemp += GetMonopolyModPercent();
							iLengthModifier += iTemp;
						}
					}
				}
			}
		}
#endif
		if(iLengthModifier != 0)
		{
			iTurns = iTurns * (100 + iLengthModifier) / 100;
		}
		int iValue = GetGoldenAgeProgressMeter();
		changeGoldenAgeTurns(iTurns, iValue, true);
	}

	int iTourism = GetHistoricEventTourism(HISTORIC_EVENT_WAR);
	ChangeNumHistoricEvents(HISTORIC_EVENT_WAR, 1);
	// Culture boost based on previous turns
	if(iTourism > 0)
	{
		GetCulture()->AddTourismAllKnownCivsWithModifiers(iTourism);
		if(GetID() == GC.getGame().getActivePlayer())
		{
			CvCity* pCity = getCapitalCity();
			if(pCity != NULL)
			{
				char text[256] = {0};
				sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_TOURISM]", iTourism);
				SHOW_PLOT_POPUP(pCity->plot(), GetID(), text);

				CvNotifications* pNotification = GetNotifications();
				if(pNotification)
				{
					CvString strMessage;
					CvString strSummary;
					strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_WAR", iTourism);
					strSummary = GetLocalizedText("TXT_KEY_TOURISM_EVENT_SUMMARY");
					pNotification->Add(NOTIFICATION_CULTURE_VICTORY_SOMEONE_INFLUENTIAL, strMessage, strSummary, pCity->getX(), pCity->getY(), GetID());
				}
			}
		}
	}
}
void CvPlayer::DoDifficultyBonus(HistoricEventTypes eHistoricEvent)
{
	int iEra = GC.getGame().getCurrentEra();
	if(iEra <= 0)
	{
		iEra = 1;
	}
	int iHandicapBase = 0;
	int iHandicapA = 0;
	int iHandicapB = 0;
	int iHandicapC = 0;
	int iYieldHandicap = 0;

	CvString strLogString;

	CvHandicapInfo* pHandicapInfo = GC.getHandicapInfo(GC.getGame().getHandicapType());
	if(pHandicapInfo)
	{
		iHandicapBase = pHandicapInfo->getAIDifficultyBonusBase();
		iHandicapA = pHandicapInfo->getAIDifficultyBonusEarly();
		iHandicapB = pHandicapInfo->getAIDifficultyBonusMid();
		iHandicapC = pHandicapInfo->getAIDifficultyBonusLate();
		iYieldHandicap = iHandicapBase * ((iHandicapC * iEra * iEra) + (iHandicapB * iEra) + iHandicapA) / 100;
	}
	if (iYieldHandicap > 0)
	{
		switch (eHistoricEvent)
		{
			case HISTORIC_EVENT_ERA:
			{
				iYieldHandicap *= 3;
				int iLoop;
				CvCity* pLoopCity;
				for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if (pLoopCity != NULL)
					{
						pLoopCity->changeFood(iYieldHandicap);
						pLoopCity->changeProduction(iYieldHandicap);
					}
				}
				GetTreasury()->ChangeGold(iYieldHandicap);
				ChangeGoldenAgeProgressMeter(iYieldHandicap);
				changeJONSCulture(iYieldHandicap);

				TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
				if (eCurrentTech == NO_TECH)
				{
					changeOverflowResearch(iYieldHandicap);
				}
				else
				{
					GET_TEAM(getTeam()).GetTeamTechs()->ChangeResearchProgress(eCurrentTech, iYieldHandicap, GetID());
				}
				strLogString.Format("CBP AI DIFFICULTY BONUS FROM HISTORIC EVENT: ERA - Received Handicap Bonus (%d in Yields): FOOD, PRODUCTION, GOLD, GAP, CULTURE, SCIENCE.", iYieldHandicap);
				break;
			}
			case HISTORIC_EVENT_WONDER:
			{
				GetTreasury()->ChangeGold(iYieldHandicap);
				ChangeGoldenAgeProgressMeter(iYieldHandicap);
				strLogString.Format("CBP AI DIFFICULTY BONUS FROM HISTORIC EVENT: WONDER - Received Handicap Bonus (%d in Yields): GOLD, GAP.", iYieldHandicap);
				break;
			}
			case HISTORIC_EVENT_GP:
			{
				GetTreasury()->ChangeGold(iYieldHandicap);
				ChangeGoldenAgeProgressMeter(iYieldHandicap);
				strLogString.Format("CBP AI DIFFICULTY BONUS FROM HISTORIC EVENT: GP - Received Handicap Bonus (%d in Yields): GOLD, GAP", iYieldHandicap);
				break;
			}
			case HISTORIC_EVENT_WAR:
			{
				int iLoop;
				CvCity* pLoopCity;
				for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if (pLoopCity != NULL)
					{
						pLoopCity->changeFood(iYieldHandicap);
						pLoopCity->changeProduction(iYieldHandicap);
					}
				}
				GetTreasury()->ChangeGold(iYieldHandicap);
				ChangeGoldenAgeProgressMeter(iYieldHandicap);
				changeJONSCulture(iYieldHandicap);

				TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
				if (eCurrentTech == NO_TECH)
				{
					changeOverflowResearch(iYieldHandicap);
				}
				else
				{
					GET_TEAM(getTeam()).GetTeamTechs()->ChangeResearchProgress(eCurrentTech, iYieldHandicap, GetID());
				}
				strLogString.Format("CBP AI DIFFICULTY BONUS FROM HISTORIC EVENT: WAR - Received Handicap Bonus (%d in Yields): FOOD, PRODUCTION, GOLD, GAP, CULTURE, SCIENCE.", iYieldHandicap);
				break;
			}
			case HISTORIC_EVENT_GA:
			{
				int iLoop;
				CvCity* pLoopCity;
				for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if (pLoopCity != NULL)
					{
						pLoopCity->changeFood(iYieldHandicap);
						pLoopCity->changeProduction(iYieldHandicap);
					}
				}
				GetTreasury()->ChangeGold(iYieldHandicap);
				ChangeGoldenAgeProgressMeter(iYieldHandicap);
				changeJONSCulture(iYieldHandicap);

				TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
				if (eCurrentTech == NO_TECH)
				{
					changeOverflowResearch(iYieldHandicap);
				}
				else
				{
					GET_TEAM(getTeam()).GetTeamTechs()->ChangeResearchProgress(eCurrentTech, iYieldHandicap, GetID());
				}
				strLogString.Format("CBP AI DIFFICULTY BONUS FROM HISTORIC EVENT: GA - Received Handicap Bonus (%d in Yields): FOOD, PRODUCTION, GOLD, GAP, CULTURE, SCIENCE.", iYieldHandicap);
				break;
			}
			case HISTORIC_EVENT_DIG:
			case HISTORIC_EVENT_TRADE_CS:
			case HISTORIC_EVENT_TRADE_LAND:
			case HISTORIC_EVENT_TRADE_SEA:
			{
				GetTreasury()->ChangeGold(iYieldHandicap);
				strLogString.Format("CBP AI DIFFICULTY BONUS FROM HISTORIC EVENT: DIG/TRADE - Received Handicap Bonus (%d in Yields): GOLD.", iYieldHandicap);
				break;
			}
			case HISTORIC_EVENT_CITY_FOUND_CAPITAL:
			{
				int iLoop;
				CvCity* pLoopCity;
				for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if (pLoopCity != NULL)
					{
						pLoopCity->changeFood(iYieldHandicap);
						pLoopCity->changeProduction(iYieldHandicap);
					}
				}
				GetTreasury()->ChangeGold(iYieldHandicap);
				ChangeGoldenAgeProgressMeter(iYieldHandicap);
				strLogString.Format("CBP AI DIFFICULTY BONUS FROM HISTORIC EVENT: FOUND CAPITAL - Received Handicap Bonus (%d in Yields): FOOD, PRODUCTION, GOLD, GAP", iYieldHandicap);
				break;
			}
			case HISTORIC_EVENT_CITY_FOUND:
			{
				int iLoop;
				CvCity* pLoopCity;
				for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if (pLoopCity != NULL)
					{
						pLoopCity->changeFood(iYieldHandicap);
						pLoopCity->changeProduction(iYieldHandicap);
					}
				}
				GetTreasury()->ChangeGold(iYieldHandicap);
				ChangeGoldenAgeProgressMeter(iYieldHandicap);
				changeJONSCulture(iYieldHandicap);

				TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
				if (eCurrentTech == NO_TECH)
				{
					changeOverflowResearch(iYieldHandicap);
				}
				else
				{
					GET_TEAM(getTeam()).GetTeamTechs()->ChangeResearchProgress(eCurrentTech, iYieldHandicap, GetID());
				}
				strLogString.Format("CBP AI DIFFICULTY BONUS FROM HISTORIC EVENT: FOUND CITY - Received Handicap Bonus (%d in Yields): FOOD, PRODUCTION, GOLD, GAP, CULTURE, SCIENCE.", iYieldHandicap);
				break;
			}
		}
	}

	if (GC.getLogging() && GC.getAILogging())
	{
		CvString strTemp;

		CvString strFileName = "DifficultyHandicapLog.csv";
		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

		CvString strPlayerName;
		strPlayerName = getCivilizationShortDescription();
		strTemp += strPlayerName;
		strTemp += ", ";

		CvString strTurn;

		strTurn.Format("%d, ", GC.getGame().getGameTurn()); // turn
		strTemp += strTurn;

		strTemp += strLogString;

		pLog->Msg(strTemp);
	}
}
#endif
#if defined(MOD_API_UNIFIED_YIELDS)
//	--------------------------------------------------------------------------------
/// Yield per turn from Religion
int CvPlayer::GetYieldPerTurnFromReligion(YieldTypes) const
{
	return 0;
}

//	--------------------------------------------------------------------------------
/// Trait bonus which adds Faith for trade partners? 
int CvPlayer::GetYieldPerTurnFromTraits(YieldTypes eYield) const
{
	if (!MOD_BALANCE_YIELD_SCALE_ERA)
		return GetPlayerTraits()->GetYieldChangePerTradePartner(eYield) * GetTrade()->GetNumDifferentTradingPartners();

	return 0;
}
#endif

//	--------------------------------------------------------------------------------
/// Total faith per turn
int CvPlayer::GetTotalFaithPerTurn() const
{
	int iFaithPerTurn = 0;

	// If we're in anarchy, then no Faith is generated!
	if (IsAnarchy())
		return 0;
#if defined(MOD_BALANCE_CORE)
	//No barbs or minors, please!
	if (isBarbarian() || isMinorCiv())
		return 0;
#endif

	// Faith per turn from Cities
	iFaithPerTurn += GetFaithPerTurnFromCities();

#if defined(MOD_API_UNIFIED_YIELDS)
	// Trait bonus which adds Faith for trade partners? 
	iFaithPerTurn += GetYieldPerTurnFromTraits(YIELD_FAITH);
#endif

	// Faith per turn from Minor Civs
	iFaithPerTurn += GetFaithPerTurnFromMinorCivs();

	// Faith per turn from Religion (Founder beliefs)
	iFaithPerTurn += GetFaithPerTurnFromReligion();

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (MOD_DIPLOMACY_CIV4_FEATURES) {
		// We're a vassal of someone, we get x% of his faith
		iFaithPerTurn += (GetYieldPerTurnFromVassals(YIELD_FAITH));
	}

	if (MOD_BALANCE_CORE_JFD)
	{
		iFaithPerTurn += GetYieldPerTurnFromMinors(YIELD_FAITH);
	}
#endif

	return iFaithPerTurn;
}

//	--------------------------------------------------------------------------------
/// Faith per turn from Cities
int CvPlayer::GetFaithPerTurnFromCities() const
{
	int iFaithPerTurn = 0;

	// Add in culture from Cities
	const CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iFaithPerTurn += pLoopCity->GetFaithPerTurn();
	}

	return iFaithPerTurn;
}

//	--------------------------------------------------------------------------------
/// Faith per turn from Minor Civs
int CvPlayer::GetFaithPerTurnFromMinorCivs() const
{
	int iFaithPerTurn = 0;
	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		iFaithPerTurn += GetFaithPerTurnFromMinor((PlayerTypes)iMinorLoop);
	}
	return iFaithPerTurn;
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Gold per turn from Minor Civs
int CvPlayer::GetGoldPerTurnFromMinorCivs() const
{
	int iFaithPerTurn = 0;
	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		iFaithPerTurn += GetGoldPerTurnFromMinor((PlayerTypes)iMinorLoop);
	}
	return iFaithPerTurn;
}
//	--------------------------------------------------------------------------------
/// Science per turn from Minor Civs
int CvPlayer::GetSciencePerTurnFromMinorCivs() const
{
	int iFaithPerTurn = 0;
	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		iFaithPerTurn += GetSciencePerTurnFromMinor((PlayerTypes)iMinorLoop);
	}
	return iFaithPerTurn;
}
//	--------------------------------------------------------------------------------
/// Gold per turn from a Minor Civ
int CvPlayer::GetGoldPerTurnFromMinor(PlayerTypes eMinor) const
{
	int iGoldPerTurn = 0;

	if(GET_PLAYER(eMinor).isAlive())
	{
		iGoldPerTurn += GET_PLAYER(eMinor).GetMinorCivAI()->GetCurrentGoldBonus(GetID());
	}

	return iGoldPerTurn;
}
//	--------------------------------------------------------------------------------
/// Science per turn from a Minor Civ
int CvPlayer::GetSciencePerTurnFromMinor(PlayerTypes eMinor) const
{
	int iSciencePerTurn = 0;

	if(GET_PLAYER(eMinor).isAlive())
	{
		iSciencePerTurn += GET_PLAYER(eMinor).GetMinorCivAI()->GetCurrentScienceBonus(GetID());
	}

	return iSciencePerTurn;
}

int CvPlayer::GetYieldPerTurnFromMinors(YieldTypes eYield) const
{
	return m_aiYieldFromMinors[eYield];
}
void CvPlayer::SetYieldPerTurnFromMinors(YieldTypes eYield, int iValue)
{
	if (iValue != m_aiYieldFromMinors[eYield])
	{
		m_aiYieldFromMinors.setAt(eYield, iValue);
	}
}
#endif
//	--------------------------------------------------------------------------------
/// Faith per turn from a Minor Civ
int CvPlayer::GetFaithPerTurnFromMinor(PlayerTypes eMinor) const
{
	int iFaithPerTurn = 0;

	if(GET_PLAYER(eMinor).isAlive())
	{
		iFaithPerTurn += GET_PLAYER(eMinor).GetMinorCivAI()->GetCurrentFaithBonus(GetID());
	}

	return iFaithPerTurn;
}

//	--------------------------------------------------------------------------------
/// Faith per turn from Religion
int CvPlayer::GetFaithPerTurnFromReligion() const
{
	int iFaithPerTurn = 0;
#if defined(MOD_API_UNIFIED_YIELDS)
	iFaithPerTurn += GetYieldPerTurnFromReligion(YIELD_FAITH);
#else
	// Founder beliefs
	CvGameReligions* pReligions = GC.getGame().GetGameReligions();
	ReligionTypes eFoundedReligion = GetReligions()->GetReligionInMostCities();
	if(eFoundedReligion != NO_RELIGION)
	{
		const CvReligion* pReligion = pReligions->GetReligion(eFoundedReligion, NO_PLAYER);
		if(pReligion)
		{
			iFaithPerTurn += pReligion->m_Beliefs.GetHolyCityYieldChange(YIELD_FAITH);

			int iTemp = pReligion->m_Beliefs.GetYieldChangePerForeignCity(YIELD_FAITH);
			if (iTemp > 0)
			{
				iFaithPerTurn += (iTemp * GetReligions()->GetNumForeignCitiesFollowing());
			}

			iTemp = pReligion->m_Beliefs.GetYieldChangePerXForeignFollowers(YIELD_FAITH);
			if (iTemp > 0)
			{
				int iFollowers = GetReligions()->GetNumForeignFollowers(false /*bAtPeace*/);
				if (iFollowers > 0)
				{
					iFaithPerTurn += (iTemp / iFollowers);
				}
			}
		}
	}
#endif
	return iFaithPerTurn;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetFaith() const
{
	return m_iFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetFaith(int iNewValue)
{
	if(GC.getGame().isOption(GAMEOPTION_NO_RELIGION))
	{
		return;
	}

	if(GetFaith() != iNewValue)
	{
		// Add to the total we've ever had
		if(iNewValue > m_iFaith)
		{
			ChangeFaithEverGenerated(iNewValue - m_iFaith);
		}

		m_iFaith = max(0,iNewValue);

		if(GC.getGame().getActivePlayer() == GetID())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeFaith(int iChange)
{
	if(GC.getGame().isOption(GAMEOPTION_NO_RELIGION))
	{
		return;
	}

	SetFaith(GetFaith() + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetFaithEverGenerated() const
{
	return m_iFaithEverGenerated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetFaithEverGenerated(int iNewValue)
{
	if(m_iFaithEverGenerated != iNewValue)
		m_iFaithEverGenerated = iNewValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeFaithEverGenerated(int iChange)
{
	SetFaithEverGenerated(GetFaithEverGenerated() + iChange);
}

//	--------------------------------------------------------------------------------
/// Updates how much Happiness we have
void CvPlayer::DoUpdateTotalHappiness()
{
	// Start level
	m_iHappiness = getHandicapInfo().getHappinessDefault();
		
	// Gamespeed Bonus level
	m_iHappiness += GC.getGame().getGameSpeedInfo().GetStartingHappiness();

	int iLuxFlat = 0;
	if (!MOD_BALANCE_CORE_HAPPINESS)
	{
		// Increase from Luxury Resources
		m_iHappiness += GetHappinessFromResources();

		// Happiness bonus for multiple Resource types
		m_iHappiness += GetHappinessFromResourceVariety();

		// Increase from Local City Happiness
		m_iHappiness += GetHappinessFromCities();

	}
	else
	{
		iLuxFlat = GetBonusHappinessFromLuxuriesFlat();
	}

	// Increase from buildings
	//m_iHappiness += GetHappinessFromBuildings();

	// Increase from policies
	//m_iHappiness += GetHappinessFromPolicies();

	// Increase from num cities (player based, for buildings and such)
	//m_iHappiness += getNumCities() * m_iHappinessPerCity;

	// Increase from Religion
	m_iHappiness += GetHappinessFromReligion();

	// Increase from Natural Wonders
	m_iHappiness += GetHappinessFromNaturalWonders();

	// Friendship with Minors can provide Happiness
	m_iHappiness += GetHappinessFromMinorCivs();

	// Increase from Leagues
	m_iHappiness += GetHappinessFromLeagues();

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (MOD_DIPLOMACY_CIV4_FEATURES) {
		// Increase from Vassals
		m_iHappiness += GetHappinessFromVassals();
	}
#endif
#if defined(MOD_BALANCE_CORE_EVENTS)
	CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		m_iHappiness += pLoopCity->GetEventHappiness();
	}
#endif

	// Increase for each City connected to Capital with a Trade Route
	DoUpdateCityConnectionHappiness();
	m_iHappiness += GetHappinessFromTradeRoutes();

#if !defined(NO_ACHIEVEMENTS)
	if (isLocalPlayer() && GetExcessHappiness() >= 100)
	{
		gDLL->UnlockAchievement(ACHIEVEMENT_XP2_45);
	}
#endif

	if (m_iHappiness > 0 && MOD_BALANCE_CORE_HAPPINESS)
	{
		DistributeHappinessToCities(m_iHappiness, iLuxFlat);

		m_iHappiness += iLuxFlat;
	}

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
}

void CvPlayer::DistributeHappinessToCities(int iTotal, int iLux)
{
	CvCity* pLoopCity;
	int iLoop;

	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (pLoopCity->IsPuppet() && !GetPlayerTraits()->IsNoAnnexing())
			continue;

		pLoopCity->ResetHappinessFromEmpire();
		pLoopCity->ResetHappinessFromLuxuries();
	}

	int iTempTotal = iTotal + iLux;

	while(iTempTotal > 0)
	{
		bool bAllFull = true;
		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if (pLoopCity->IsPuppet() && !GetPlayerTraits()->IsNoAnnexing())
				continue;

			int iTotalHappiness = pLoopCity->GetLocalHappiness();

			if (iTotalHappiness < pLoopCity->getPopulation())
			{
				bAllFull = false;
				break;
			}
		}
		if (bAllFull)
			break;

		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if (pLoopCity->IsPuppet() && !GetPlayerTraits()->IsNoAnnexing())
				continue;

			int iTotalHappiness = pLoopCity->GetLocalHappiness();

			if (iTotalHappiness >= pLoopCity->getPopulation())
				continue;

			if (iTotal > 0)
			{
				iTotal--;
				pLoopCity->ChangeHappinessFromEmpire(1);
				iTempTotal--;
			}
			else if (iLux > 0)
			{
				iLux--;
				pLoopCity->ChangeHappinessFromLuxuries(1);
				iTempTotal--;
			}

			if (iTempTotal <= 0 || (iTotal <= 0 && iLux <= 0))
				break;
		}

		if (iTempTotal <= 0 || (iTotal <= 0 && iLux <= 0))
			break;
	}
}

int CvPlayer::GetEmpireHappinessForCity(CvCity* pCity) const
{
	if (pCity != NULL && pCity->IsPuppet() && !GetPlayerTraits()->IsNoAnnexing())
		return 0;

	if (getCapitalCity() == NULL)
		return 0;

	return pCity != NULL ? (pCity->GetHappinessFromEmpire() + pCity->GetLuxuryHappinessFromEmpire()) : (getCapitalCity()->GetHappinessFromEmpire() + getCapitalCity()->GetLuxuryHappinessFromEmpire());
}

int CvPlayer::GetEmpireUnhappinessForCity(CvCity* pCity) const
{ 
	if (pCity != NULL && pCity->IsPuppet() && !GetPlayerTraits()->IsNoAnnexing())
		return 0;

	if (getCapitalCity() == NULL)
		return 0;

	return pCity != NULL ? pCity->GetUnhappinessFromEmpire() : getCapitalCity()->GetUnhappinessFromEmpire();
}

//	--------------------------------------------------------------------------------
/// How much Happiness we have
int CvPlayer::GetHappiness() const
{
	return m_iHappiness;
}

//	--------------------------------------------------------------------------------
/// Sets how much Happiness we have
void CvPlayer::SetHappiness(int iNewValue)
{
	if(GetHappiness() != iNewValue)
	{
		m_iHappiness = iNewValue;
	}
}

/// Sets how much Unhappiness we have
void CvPlayer::SetUnhappiness(int iNewValue)
{
	if(m_iUnhappiness != iNewValue)
	{
		m_iUnhappiness = iNewValue;

		int iLoop;
		for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if (pLoopCity->IsPuppet() && !GetPlayerTraits()->IsNoAnnexing())
				continue;

			pLoopCity->UpdateUnhappinessFromEmpire();
		}
	}
}
int CvPlayer::GetUnhappiness() const
{
	return m_iUnhappiness;
}

int CvPlayer::GetHappinessRatioRawPercent()
{
	int iUnhappyCitizens = getUnhappinessFromCitizenNeeds();
	int iHappyCitizens = getHappinessFromCitizenNeeds();
	return ((iHappyCitizens * 100) / max(1, iUnhappyCitizens) / 2);
}

void CvPlayer::CalculateNetHappiness()
{
	//Not active player, or a barb, or a minor? Get out!
	if(isMinorCiv() || isBarbarian())
	{
		return;
	}

	//reset this as well, when a building is constructed or a policy adopted
	m_iNumUnitsSuppliedCached = -1;

	DoUpdateTotalHappiness();
	DoUpdateTotalUnhappiness();

	if (MOD_BALANCE_CORE_HAPPINESS)
	{
		int iUnhappyCitizens = getUnhappinessFromCitizenNeeds();
		if (iUnhappyCitizens == 0)
			m_iHappinessTotal = 100;
		else
		{
			int iHappyCitizens = getHappinessFromCitizenNeeds();
			int iPercent = min(200, (iHappyCitizens * 100) / max(1, iUnhappyCitizens));

			iPercent /= 2;

			if (iPercent != m_iHappinessTotal)
			{
				m_iHappinessTotal = iPercent;
				GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
			}
		}
	}
	else
	{

		int iHappiness = GetHappiness();
		int iUnhappiness = GetUnhappiness();

		int iDiff = (iHappiness - iUnhappiness);
		if (iDiff != m_iHappinessTotal)
		{
			m_iHappinessTotal = iDiff;
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

void CvPlayer::ChangeEmpireNeedsModifierGlobal(int iChange)
{
	m_iEmpireNeedsModifierGlobal += iChange;
}
int CvPlayer::GetEmpireNeedsModifierGlobal() const
{
	return m_iEmpireNeedsModifierGlobal;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvPlayer::GetPovertyUnhappinessGlobal() const
{
	return m_iChangePovertyUnhappinessGlobal;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangePovertyUnhappinessGlobal(int iChange)
{
	m_iChangePovertyUnhappinessGlobal += iChange;
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvPlayer::GetDefenseUnhappinessGlobal() const
{
	return m_iChangeDefenseUnhappinessGlobal;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangeDefenseUnhappinessGlobal(int iChange)
{
	m_iChangeDefenseUnhappinessGlobal += iChange;
}
/// Extra yield from building
int CvPlayer::GetUnculturedUnhappinessGlobal() const
{
	return m_iChangeUnculturedUnhappinessGlobal;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangeUnculturedUnhappinessGlobal(int iChange)
{
	m_iChangeUnculturedUnhappinessGlobal += iChange;
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvPlayer::GetIlliteracyUnhappinessGlobal() const
{
	return m_iChangeIlliteracyUnhappinessGlobal;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangeIlliteracyUnhappinessGlobal(int iChange)
{
	m_iChangeIlliteracyUnhappinessGlobal += iChange;
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvPlayer::GetMinorityUnhappinessGlobal() const
{
	return m_iChangeMinorityUnhappinessGlobal;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangeMinorityUnhappinessGlobal(int iChange)
{
	m_iChangeMinorityUnhappinessGlobal += iChange;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvPlayer::GetLandmarksTourismPercentGlobal() const
{
	return m_iLandmarksTourismPercentGlobal;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangeLandmarksTourismPercentGlobal(int iChange)
{
	m_iLandmarksTourismPercentGlobal += iChange;
}


//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvPlayer::GetGreatWorksTourismModifierGlobal() const
{
	return m_iGreatWorksTourismModifierGlobal;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangeGreatWorksTourismModifierGlobal(int iChange)
{
	m_iGreatWorksTourismModifierGlobal += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetHappinessForGAP() const
{
	if (MOD_BALANCE_CORE_HAPPINESS)
	{
		int iTotalGAP = 0;
		const CvCity* pLoopCity;
		int iLoop;
		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			int iGAP = pLoopCity->getHappinessDelta();
			if (iGAP > 0)
				iTotalGAP += iGAP;
		}

		return iTotalGAP;
	}
	return GetExcessHappiness();
}
/// How much over our Happiness limit are we?
int CvPlayer::GetExcessHappiness() const
{
	if(isMinorCiv() || isBarbarian() || (getNumCities() == 0))
	{
		if (MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
			return 50;
		else
			return 0;
	}

	return m_iHappinessTotal;
}

//	--------------------------------------------------------------------------------
/// Has the player passed the Happiness limit?
bool CvPlayer::IsEmpireUnhappy() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS) || isMinorCiv() || isBarbarian())
	{
		return false;
	}
	if(MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	{
		if (GetExcessHappiness() < GC.getUNHAPPY_THRESHOLD())
			return true;
	}
	else
	{
		if (GetExcessHappiness() < 0)
			return true;
	}
	return false;
}

//	--------------------------------------------------------------------------------
/// Is the empire REALLY unhappy? (other penalties)
bool CvPlayer::IsEmpireVeryUnhappy() const
{
	if (GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS) || isMinorCiv() || isBarbarian())
	{
		return false;
	}
	if (MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	{
		if (GetExcessHappiness() < /*-10*/ GC.getVERY_UNHAPPY_THRESHOLD())
			return true;
	}
	else if(GetExcessHappiness() <= /*-10*/ GC.getVERY_UNHAPPY_THRESHOLD())
	{
		return true;
	}
	return false;
}

//	--------------------------------------------------------------------------------
/// Is the empire SUPER unhappy? (leads to revolts)
bool CvPlayer::IsEmpireSuperUnhappy() const
{
	if (GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS) || isMinorCiv() || isBarbarian())
	{
		return false;
	}
	if (MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	{
		if (GetExcessHappiness() < /*-10*/ GC.getSUPER_UNHAPPY_THRESHOLD())
			return true;
	}
	else if (GetExcessHappiness() <= /*-20*/ GC.getSUPER_UNHAPPY_THRESHOLD())
	{
		return true;
	}
	return false;
}

//	--------------------------------------------------------------------------------
/// Uprisings pop up if the empire is Very Unhappy
void CvPlayer::DoUpdateUprisings()
{
	if (MOD_BALANCE_CORE_HAPPINESS && GC.getGame().isOption(GAMEOPTION_NO_BARBARIANS))
		return;
		
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	if(MOD_BALANCE_CORE_HAPPINESS && IsEmpireVeryUnhappy())
	{
		// If we're very unhappy, make the counter wind down
		if(GetUprisingCounter() > 0)
		{
			ChangeUprisingCounter(-1);

			// Time's up!
			if(GetUprisingCounter() == 0)
			{
				DoUprising();
				DoResetUprisingCounter(/*bFirstTime*/ false);
			}
		}
		// Very Unhappy for the first time - seed the counter
		else
		{
			DoResetUprisingCounter(/*bFirstTime*/ true);
		}
	}
	else
#endif
	if(IsEmpireSuperUnhappy())
	{
		// If we're very unhappy, make the counter wind down
		if(GetUprisingCounter() > 0)
		{
			ChangeUprisingCounter(-1);

			// Time's up!
			if(GetUprisingCounter() == 0)
			{
				DoUprising();
				DoResetUprisingCounter(/*bFirstTime*/ false);
			}
		}
		// Very Unhappy for the first time - seed the counter
		else
		{
			DoResetUprisingCounter(/*bFirstTime*/ true);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Uprising countdown - get
int CvPlayer::GetUprisingCounter() const
{
	return m_iUprisingCounter;
}

//	--------------------------------------------------------------------------------
/// Uprising countdown - set
void CvPlayer::SetUprisingCounter(int iValue)
{
	m_iUprisingCounter = iValue;
}

//	--------------------------------------------------------------------------------
/// Uprising countdown - change
void CvPlayer::ChangeUprisingCounter(int iChange)
{
	SetUprisingCounter(GetUprisingCounter() + iChange);
}

//	--------------------------------------------------------------------------------
/// Uprising countdown - seed
void CvPlayer::DoResetUprisingCounter(bool bFirstTime)
{
	int iTurns = /*4*/ GC.getUPRISING_COUNTER_MIN() + GC.getGame().getSmallFakeRandNum(/*3*/ GC.getUPRISING_COUNTER_POSSIBLE(), GetPseudoRandomSeed());

	// Game speed mod
	int iMod = GC.getGame().getGameSpeedInfo().getTrainPercent();
	// Only LENGTHEN time between rebels
	if(iMod > 100)
	{
		iTurns *= iMod;
		iTurns /= 100;
	}

	if(bFirstTime)
		iTurns /= 2;

	if (IsEmpireSuperUnhappy())
	{
		iTurns *= 75;
		iTurns /= 100;
	}
	if(iTurns <= 0)
		iTurns = 1;

	SetUprisingCounter(iTurns);
}

//	--------------------------------------------------------------------------------
// Fire off an uprising somewhere
void CvPlayer::DoUprising()
{
	// In hundreds
	int iNumRebels = /*100*/ GC.getUPRISING_NUM_BASE();
	int iExtra = getNumCities() + GC.getGame().getSmallFakeRandNum(getNumCities(), GetPseudoRandomSeed());
		
	iNumRebels += iExtra * /*20*/ GC.getUPRISING_NUM_CITY_COUNT();
	iNumRebels /= 100;

	// Find a random city to pop up a bad man
	CvCity* pBestCity = NULL;
	int iBestWeight = 0;

	CvCity* pLoopCity;
	int iLoop;
	CvGame& theGame = GC.getGame();
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		int iTempWeight = pLoopCity->getPopulation();
		iTempWeight += theGame.getSmallFakeRandNum(10, GetPseudoRandomSeed() + pLoopCity->plot()->GetPlotIndex());

		if(iTempWeight > iBestWeight)
		{
			iBestWeight = iTempWeight;
			pBestCity = pLoopCity;
		}
	}

	// Found a place to set up an uprising?
	if(pBestCity != NULL)
	{
		int iBestPlot = -1;
		int iBestPlotWeight = -1;
		CvPlot* pPlot;

		CvCityCitizens* pCitizens = pBestCity->GetCityCitizens();

		// Start at 1, since ID 0 is the city plot itself

		for(int iPlotLoop = 1; iPlotLoop < pBestCity->GetNumWorkablePlots(); iPlotLoop++)
		{
			pPlot = pCitizens->GetCityPlotFromIndex(iPlotLoop);

			if(!pPlot)		// Should be valid, but make sure
				continue;

			// Can't be impassable
			if(!pPlot->isValidMovePlot(GetID()))
				continue;

			// Can't be water
			if(pPlot->isWater())
				continue;

			// Can't be ANOTHER city
			if(pPlot->isCity())
				continue;

			// Don't place on a plot where a unit is already standing
			if(pPlot->getNumUnits() > 0)
				continue;

			int iTempWeight = theGame.getSmallFakeRandNum(10, GetPseudoRandomSeed() + iPlotLoop);

			// Add weight if there's an improvement here!
			if(pPlot->getImprovementType() != NO_IMPROVEMENT)
			{
				iTempWeight += 4;

				// If there's also a resource, even more weight!
				if(pPlot->getResourceType(getTeam()) != NO_RESOURCE)
					iTempWeight += 3;
			}

			// Add weight if there's a defensive bonus for this plot
			if(pPlot->defenseModifier(BARBARIAN_TEAM, false, false))
				iTempWeight += 4;

			// Don't pick plots that aren't ours
			if(pPlot->getOwner() != GetID())
				iTempWeight = -1;

			if(iTempWeight > iBestPlotWeight)
			{
				iBestPlotWeight = iTempWeight;
				iBestPlot = iPlotLoop;
			}
		}

		// Found valid plot
		if(iBestPlot != -1)
		{
			// Make barbs able to enter ANYONE'S territory
			theGame.SetBarbarianReleaseTurn(0);

			pPlot = pCitizens->GetCityPlotFromIndex(iBestPlot);

			// Pick a unit type
			UnitTypes eUnit = theGame.GetRandomSpawnUnitType(GetID(), /*bIncludeUUs*/ true, /*bIncludeRanged*/ true);

			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_REBELS");
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_REBELS_SUMMARY");
				pNotifications->Add(NOTIFICATION_REBELS, strMessage.toUTF8(), strSummary.toUTF8(), pPlot->getX(), pPlot->getY(), eUnit, BARBARIAN_PLAYER);
			}

			// Init unit
			GET_PLAYER(BARBARIAN_PLAYER).initUnit(eUnit, pPlot->getX(), pPlot->getY());
			iNumRebels--;	// Reduce the count since we just added the seed rebel

			// Loop until all rebels are placed
			do
			{
				iNumRebels--;

				// Pick a new unit type (for variety)
				UnitTypes eUnit = theGame.GetRandomSpawnUnitType(GetID(), /*bIncludeUUs*/ true, /*bIncludeRanged*/ true);

				// Init unit
				CvUnit* pUnit = GET_PLAYER(BARBARIAN_PLAYER).initUnit(eUnit, pPlot->getX(), pPlot->getY());
				CvAssert(pUnit);
				if (pUnit)
				{
					if (!pUnit->jumpToNearestValidPlotWithinRange(5))
						pUnit->kill(false);		// Could not find a spot!
				}
			}
			while(iNumRebels > 0);
		}
	}
}

//	--------------------------------------------------------------------------------
/// City can revolt if the empire is Very Unhappy
void CvPlayer::DoUpdateCityRevolts()
{
	int iPublicUnhappiness = 0;
	if (GetCulture()->GetPublicOpinionUnhappiness() > 0 || IsEmpireSuperUnhappy() || (MOD_BALANCE_CORE_HAPPINESS && IsEmpireVeryUnhappy()))
	{
		iPublicUnhappiness = 1;
	}
	if (IsEmpireVeryUnhappy() && iPublicUnhappiness > 0)
	{
		if(GetCityRevoltCounter() > 0)
		{
			ChangeCityRevoltCounter(-iPublicUnhappiness);

			// Time's up!
			if(GetCityRevoltCounter() == 0)
			{
				DoCityRevolt();
				SetCityRevoltCounter(0);
			}
			else
			{
				CvCity *pMostUnhappyCity = GetMostUnhappyCity();
				PlayerTypes eRecipient = GetMostUnhappyCityRecipient(pMostUnhappyCity);
				if (pMostUnhappyCity != NULL && eRecipient != NO_PLAYER)
				{
					if (GET_PLAYER(eRecipient).isAlive())
					{
						CvNotifications* pNotifications = GetNotifications();
						if (pNotifications && isHuman())
						{
							Localization::String strMessage = GetLocalizedText("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLT", GetCityRevoltCounter(), pMostUnhappyCity->getName(), GET_PLAYER(eRecipient).getCivilizationShortDescription());
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLT_SUMMARY");
							pNotifications->Add(NOTIFICATION_CITY_REVOLT_POSSIBLE, strMessage.toUTF8(), strSummary.toUTF8(), pMostUnhappyCity->getX(), pMostUnhappyCity->getY(), -1);
						}
					}
					else if (GET_PLAYER(eRecipient).isEverAlive())
					{
						CvNotifications* pNotifications = GetNotifications();
						if (pNotifications && isHuman())
						{
							Localization::String strMessage = GetLocalizedText("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLUTION_CP", GetCityRevoltCounter(), pMostUnhappyCity->getName(), GET_PLAYER(eRecipient).getCivilizationShortDescription());
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLUTION_CP_SUMMARY");
							pNotifications->Add(NOTIFICATION_CITY_REVOLT_POSSIBLE, strMessage.toUTF8(), strSummary.toUTF8(), pMostUnhappyCity->getX(), pMostUnhappyCity->getY(), -1);
						}
					}
					else
					{
						CvNotifications* pNotifications = GetNotifications();
						if (pNotifications && isHuman())
						{
							Localization::String strMessage = GetLocalizedText("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLUTION_CP_FREE_CITY", GetCityRevoltCounter(), pMostUnhappyCity->getName());
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLUTION_CP_SUMMARY");
							pNotifications->Add(NOTIFICATION_CITY_REVOLT_POSSIBLE, strMessage.toUTF8(), strSummary.toUTF8(), pMostUnhappyCity->getX(), pMostUnhappyCity->getY(), -1);
						}
					}
				}
			}
		}
		// Super Unhappy for the first time - seed the counter
		else
		{
			DoResetCityRevoltCounter();
		}
	}
	else
	{
		SetCityRevoltCounter(-1);
	}
}

//	--------------------------------------------------------------------------------
/// City revolt countdown - get
int CvPlayer::GetCityRevoltCounter() const
{
	return m_iCityRevoltCounter;
}

//	--------------------------------------------------------------------------------
/// City revolt countdown - set
void CvPlayer::SetCityRevoltCounter(int iValue)
{
	if (iValue != m_iCityRevoltCounter)
		m_iCityRevoltCounter = iValue;
}

//	--------------------------------------------------------------------------------
/// City revolt countdown - change
void CvPlayer::ChangeCityRevoltCounter(int iChange)
{
	SetCityRevoltCounter(GetCityRevoltCounter() + iChange);

	if ((GC.getLogging() && GC.getAILogging()))
	{
		int Counter = m_iCityRevoltCounter;
		CvString strLogString;
		strLogString.Format("CP - Countdown for City Revolt CONTINUES - %d turns.", Counter);

		CvString strTemp;

		CvString strFileName = "CityRevolutions.csv";
		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

		CvString strPlayerName;
		strPlayerName = getCivilizationShortDescription();
		strTemp += strPlayerName;
		strTemp += ", ";

		CvString strTurn;

		strTurn.Format("%d, ", GC.getGame().getGameTurn()); // turn
		strTemp += strTurn;

		strTemp += strLogString;

		pLog->Msg(strTemp);
	}
}

//	--------------------------------------------------------------------------------
/// City revolt countdown - seed
void CvPlayer::DoResetCityRevoltCounter()
{
	int iTurns = /*5*/ GC.getREVOLT_COUNTER_MIN();
	CvGame& theGame = GC.getGame();

	// Game speed mod
	int iMod = theGame.getGameSpeedInfo().getTrainPercent();
	// Only LENGTHEN time between rebels
	if(iMod > 100)
	{
		iTurns *= iMod;
		iTurns /= 100;
	}

	if (MOD_BALANCE_CORE_HAPPINESS && IsEmpireSuperUnhappy())
	{
		iTurns *= 75;
		iTurns /= 100;
	}

	if(iTurns <= 0)
		iTurns = 1;

	CvCity *pMostUnhappyCity = GetMostUnhappyCity();
	PlayerTypes eRecipient = GetMostUnhappyCityRecipient(pMostUnhappyCity);
	if(pMostUnhappyCity != NULL && eRecipient != NO_PLAYER)
	{
		SetCityRevoltCounter(iTurns);

		if (GET_PLAYER(eRecipient).isAlive())
		{
			CvNotifications* pNotifications = GetNotifications();
			if (pNotifications && isHuman())
			{
				Localization::String strMessage = GetLocalizedText("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLT", iTurns, pMostUnhappyCity->getName(), GET_PLAYER(eRecipient).getCivilizationShortDescription());
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLT_SUMMARY");
				pNotifications->Add(NOTIFICATION_CITY_REVOLT_POSSIBLE, strMessage.toUTF8(), strSummary.toUTF8(), pMostUnhappyCity->getX(), pMostUnhappyCity->getY(), -1);
			}

			if ((GC.getLogging() && GC.getAILogging()))
			{
				CvString strLogString;
				strLogString.Format("CP - Countdown for City Revolt BEGINS - %s, will go to %s in %d turns.", pMostUnhappyCity->getName().GetCString(), GET_PLAYER(eRecipient).getCivilizationShortDescription(), iTurns);

				CvString strTemp;

				CvString strFileName = "CityRevolutions.csv";
				FILogFile* pLog;
				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

				CvString strPlayerName;
				strPlayerName = getCivilizationShortDescription();
				strTemp += strPlayerName;
				strTemp += ", ";

				CvString strTurn;

				strTurn.Format("%d, ", GC.getGame().getGameTurn()); // turn
				strTemp += strTurn;

				strTemp += strLogString;

				pLog->Msg(strTemp);
			}
		}
		else if (GET_PLAYER(eRecipient).isEverAlive())
		{
			CvNotifications* pNotifications = GetNotifications();
			if (pNotifications && isHuman())
			{
				Localization::String strMessage = GetLocalizedText("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLUTION_CP", iTurns, pMostUnhappyCity->getName(), GET_PLAYER(eRecipient).getCivilizationShortDescription());
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLUTION_CP_SUMMARY");
				pNotifications->Add(NOTIFICATION_CITY_REVOLT_POSSIBLE, strMessage.toUTF8(), strSummary.toUTF8(), pMostUnhappyCity->getX(), pMostUnhappyCity->getY(), -1);
			}

			if ((GC.getLogging() && GC.getAILogging()))
			{
				CvString strLogString;
				strLogString.Format("CP - Countdown for City Revolt BEGINS - %s, will go to DEAD PLAYER %s in %d turns.", pMostUnhappyCity->getName().GetCString(), GET_PLAYER(eRecipient).getName(), iTurns);

				CvString strTemp;

				CvString strFileName = "CityRevolutions.csv";
				FILogFile* pLog;
				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

				CvString strPlayerName;
				strPlayerName = getCivilizationShortDescription();
				strTemp += strPlayerName;
				strTemp += ", ";

				CvString strTurn;

				strTurn.Format("%d, ", GC.getGame().getGameTurn()); // turn
				strTemp += strTurn;

				strTemp += strLogString;

				pLog->Msg(strTemp);
			}
		}
		else
		{
			CvNotifications* pNotifications = GetNotifications();
			if (pNotifications && isHuman())
			{
				Localization::String strMessage = GetLocalizedText("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLUTION_CP_FREE_CITY", iTurns, pMostUnhappyCity->getName());
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLUTION_CP_SUMMARY");
				pNotifications->Add(NOTIFICATION_CITY_REVOLT_POSSIBLE, strMessage.toUTF8(), strSummary.toUTF8(), pMostUnhappyCity->getX(), pMostUnhappyCity->getY(), -1);
			}

			if ((GC.getLogging() && GC.getAILogging()))
			{
				CvString strLogString;
				strLogString.Format("CP - Countdown for City Revolt BEGINS - %s, will go to FREE CITY PLAYER in %d turns.", pMostUnhappyCity->getName().GetCString(), iTurns);

				CvString strTemp;

				CvString strFileName = "CityRevolutions.csv";
				FILogFile* pLog;
				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

				CvString strPlayerName;
				strPlayerName = getCivilizationShortDescription();
				strTemp += strPlayerName;
				strTemp += ", ";

				CvString strTurn;

				strTurn.Format("%d, ", GC.getGame().getGameTurn()); // turn
				strTemp += strTurn;

				strTemp += strLogString;

				pLog->Msg(strTemp);
			}
		}
	}
}

//	--------------------------------------------------------------------------------
// Fire off a city revolt somewhere
void CvPlayer::DoCityRevolt()
{
	CvCity *pMostUnhappyCity = GetMostUnhappyCity();
	PlayerTypes eRecipient = GetMostUnhappyCityRecipient(pMostUnhappyCity);
	if(pMostUnhappyCity != NULL && eRecipient != NO_PLAYER)
	{
#if defined(MOD_BALANCE_CORE)
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityFlipped, pMostUnhappyCity, eRecipient, pMostUnhappyCity->getOwner());
#endif
		if (!GET_PLAYER(eRecipient).isAlive())
		{ 
			if (GET_PLAYER(eRecipient).isEverAlive())
			{
				PlayerTypes eOldPlayer = pMostUnhappyCity->getOriginalOwner();
				if (eOldPlayer != NO_PLAYER && !GET_PLAYER(eOldPlayer).isAlive())
				{
					DoRevolutionPlayer(eOldPlayer, pMostUnhappyCity->GetID());
				}
			}
			else
			{
				const CvString strCityName = pMostUnhappyCity->getName();
				const char* charCityName = pMostUnhappyCity->getName().GetCString();
				if (GC.getGame().CreateFreeCityPlayer(pMostUnhappyCity))
				{
					CvPlayer &kRecipient = GET_PLAYER(eRecipient);
					for (int iNotifyLoop = 0; iNotifyLoop < MAX_MAJOR_CIVS; ++iNotifyLoop){
						PlayerTypes eNotifyPlayer = (PlayerTypes)iNotifyLoop;

						if (eNotifyPlayer == NO_PLAYER)
							continue;

						CvPlayerAI& kCurNotifyPlayer = GET_PLAYER(eNotifyPlayer);

						if (!kCurNotifyPlayer.isAlive())
							continue;

						if (!GET_TEAM(kCurNotifyPlayer.getTeam()).isHasMet(getTeam()))
							continue;

						if (!GET_TEAM(kCurNotifyPlayer.getTeam()).isHasMet(kRecipient.getTeam()))
							continue;

						CvNotifications* pNotifications = kCurNotifyPlayer.GetNotifications();
						if (pNotifications)
						{
							Localization::String strMessage;
							if (eNotifyPlayer == GetID())
							{
								strMessage = GetLocalizedText("TXT_KEY_NOTIFICATION_CITY_REVOLT_FREE_CITY", strCityName, kRecipient.getCivilizationShortDescription());
							}
							else
							{
								strMessage = GetLocalizedText("TXT_KEY_NOTIFICATION_OTHER_PLAYER_CITY_REVOLT_FREE_CITY", getCivilizationAdjective(), strCityName, kRecipient.getCivilizationShortDescription());
							}
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_REVOLT_SUMMARY");
							pNotifications->Add(NOTIFICATION_CITY_REVOLT, strMessage.toUTF8(), strSummary.toUTF8(), GET_PLAYER(eRecipient).getCapitalCity()->getX(), GET_PLAYER(eRecipient).getCapitalCity()->getY(), -1);
						}
					}

					if (GC.getLogging() && GC.getAILogging() && pMostUnhappyCity != NULL)
					{
						CvString playerName;
						FILogFile* pLog;
						CvString strBaseString;
						CvString strOutBuf;
						CvString strFileName = "CityRevolutions.csv";
						playerName = getCivilizationShortDescription();
						pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
						strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
						strBaseString += playerName + ", ";
						strOutBuf.Format("Defection! %s ceded to new FREE CITY of %s", charCityName, kRecipient.getName());
						strBaseString += strOutBuf;
						pLog->Msg(strBaseString);
					}
				}
			}
		}
		else
		{
			CvPlayer &kRecipient = GET_PLAYER(eRecipient);
			for (int iNotifyLoop = 0; iNotifyLoop < MAX_MAJOR_CIVS; ++iNotifyLoop){
				PlayerTypes eNotifyPlayer = (PlayerTypes)iNotifyLoop;
				CvPlayerAI& kCurNotifyPlayer = GET_PLAYER(eNotifyPlayer);
				CvNotifications* pNotifications = kCurNotifyPlayer.GetNotifications();
				if (pNotifications)
				{
					Localization::String strMessage;
					if (eNotifyPlayer == GetID())
					{
						strMessage = GetLocalizedText("TXT_KEY_NOTIFICATION_CITY_REVOLT", pMostUnhappyCity->getName(), kRecipient.getCivilizationShortDescription());
					}
					else
					{
						strMessage = GetLocalizedText("TXT_KEY_NOTIFICATION_OTHER_PLAYER_CITY_REVOLT", getCivilizationAdjective(), pMostUnhappyCity->getName(), kRecipient.getCivilizationShortDescription());
					}
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_REVOLT_SUMMARY");
					pNotifications->Add(NOTIFICATION_CITY_REVOLT, strMessage.toUTF8(), strSummary.toUTF8(), pMostUnhappyCity->getX(), pMostUnhappyCity->getY(), -1);
				}
			}

			if (GC.getLogging() && GC.getAILogging() && pMostUnhappyCity != NULL)
			{
				CvString playerName;
				FILogFile* pLog;
				CvString strBaseString;
				CvString strOutBuf;
				CvString strFileName = "CityRevolutions.csv";
				playerName = getCivilizationShortDescription();
				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				strBaseString += playerName + ", ";
				strOutBuf.Format("Defection! %s ceded to %s", pMostUnhappyCity->getName().GetCString(), kRecipient.getName());
				strBaseString += strOutBuf;
				pLog->Msg(strBaseString);
			}

			// get the plot before transferring ownership
			CvPlot *pPlot = pMostUnhappyCity->plot();
			kRecipient.acquireCity(pMostUnhappyCity, false/*bConquest*/, true/*bGift*/);
			pMostUnhappyCity = NULL; //no longer valid

			 // Move Units from player that don't belong here
			if (pPlot->getNumUnits() > 0)
			{
				// Get the current list of units because we will possibly be moving them out of the plot's list
				IDInfoVector currentUnits;
				if (pPlot->getUnits(&currentUnits) > 0)
				{
					for (IDInfoVector::const_iterator itr = currentUnits.begin(); itr != currentUnits.end(); ++itr)
					{
						CvUnit* pLoopUnit = (CvUnit*)GetPlayerUnit(*itr);

						if (pLoopUnit && pLoopUnit->getOwner() == GetID())
						{
							pLoopUnit->finishMoves();
							if (!pLoopUnit->jumpToNearestValidPlot())
								pLoopUnit->kill(false);
						}
					}
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
// Calculate city that will want to revolt
CvCity *CvPlayer::GetMostUnhappyCity()
{
	CvCity *pRtnValue = NULL;
	int iHighestUnhappiness = -1;

	if (getNumCities() > 1)
	{
		PolicyBranchTypes ePreferredIdeology = GetCulture()->GetPublicOpinionPreferredIdeology();

		int iLoop;
		CvCity* pLoopCity;
		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if (pLoopCity->isCapital())
				continue;

			if (pLoopCity->IsOriginalMajorCapital())
				continue;

			// mind the sign change
			int iUnhappiness = -1 * pLoopCity->getHappinessDelta(true);
			pLoopCity->setHappinessDelta(iUnhappiness * -1);

			if (iUnhappiness <= 0)
				continue;

			// Look at each civ
			for (int iLoopPlayer = 0; iLoopPlayer < MAX_CIV_PLAYERS; iLoopPlayer++)
			{
				CvPlayer &kPlayer = GET_PLAYER((PlayerTypes)iLoopPlayer);
				if (iLoopPlayer != GetID())
				{		
					PolicyBranchTypes eOtherCivIdeology = NO_POLICY_BRANCH_TYPE;
					int iCulturalDominanceOverUs = 0;
					if (kPlayer.isAlive() && !kPlayer.isMinorCiv())
					{
						if (eOtherCivIdeology != NO_POLICY_BRANCH_TYPE && eOtherCivIdeology == ePreferredIdeology)
						{
							iUnhappiness *= 20;
						}
						iCulturalDominanceOverUs = kPlayer.GetCulture()->GetInfluenceLevel(GetID()) - GetCulture()->GetInfluenceLevel((PlayerTypes)iLoopPlayer);
					}
					else
					{
						if (!kPlayer.isAlive() && kPlayer.isMinorCiv())
						{
							iCulturalDominanceOverUs = 5;
						}
						else if (!kPlayer.isAlive())
						{
							iCulturalDominanceOverUs = 5;
						}
					}
					// Find how far their capital is from this city
					int iX = kPlayer.GetOriginalCapitalX();
					int iY = kPlayer.GetOriginalCapitalY();
					int iCapitalDistance = plotDistance(pLoopCity->getX(), pLoopCity->getY(), iX, iY);

					int iDistanceFactor = 100 - iCapitalDistance;
					if (iDistanceFactor <= 0)
						iDistanceFactor = 1;

					iDistanceFactor = (int)sqrt((float)iDistanceFactor);
					iUnhappiness += (iDistanceFactor * iCulturalDominanceOverUs);
				}
			}

			if (pLoopCity->getOriginalOwner() == GetID())
				iUnhappiness /= 4;

			if (pLoopCity->IsPuppet())
				iUnhappiness *= 2;

			int iCapitalDistance = plotDistance(pLoopCity->getX(), pLoopCity->getY(), getCapitalCity()->getX(), getCapitalCity()->getY());

			int iDistanceFactor = 100 - iCapitalDistance;
			if (iDistanceFactor <= 0)
				iDistanceFactor = 1;

			iUnhappiness += iDistanceFactor / 10;

			int iModifier = 0;
			if (GAMEEVENTINVOKE_VALUE(iModifier, GAMEEVENT_CityFlipChance, pLoopCity->GetID(), GetID()) == GAMEEVENTRETURN_VALUE) {
				if (iModifier != 0) {
					iUnhappiness += iModifier;
				}
			}

			if (iUnhappiness > iHighestUnhappiness)
			{
				iHighestUnhappiness = iUnhappiness;
				pRtnValue = pLoopCity;
			}
		}
	}

	return pRtnValue;
}

// Calculate player that will receive city if it revolts
PlayerTypes CvPlayer::GetMostUnhappyCityRecipient(CvCity* pMostUnhappyCity)
{
	PlayerTypes eRtnValue = NO_PLAYER;
	int iBestValue = 0;

	if (pMostUnhappyCity != NULL)
	{
		if (!GET_PLAYER(pMostUnhappyCity->getOriginalOwner()).isAlive())
			return pMostUnhappyCity->getOriginalOwner();

		if (pMostUnhappyCity->getOriginalOwner() != pMostUnhappyCity->getOwner())
			return pMostUnhappyCity->getOriginalOwner();

		PolicyBranchTypes ePreferredIdeology = GetCulture()->GetPublicOpinionPreferredIdeology();

		//doesn't happen if we're influenced by someone
		if (ePreferredIdeology == NO_POLICY_BRANCH_TYPE || ePreferredIdeology == GetPlayerPolicies()->GetLateGamePolicyTree())
		{
			if (GC.getGame().CreateFreeCityPlayer(pMostUnhappyCity, true))
			{
				PlayerTypes ePotentialFreeCityPlayer = GC.getGame().GetPotentialFreeCityPlayer(pMostUnhappyCity);
				if (ePotentialFreeCityPlayer != NO_PLAYER && GC.getGame().GetPotentialFreeCityTeam(pMostUnhappyCity) != NO_TEAM)
					return ePotentialFreeCityPlayer;
			}
		}

		// Look at each civ
		for (int iLoopPlayer = 0; iLoopPlayer < MAX_MAJOR_CIVS; iLoopPlayer++)
		{
			CvPlayer &kPlayer = GET_PLAYER((PlayerTypes)iLoopPlayer);
			if (iLoopPlayer != GetID())
			{
				if (kPlayer.isAlive() && !kPlayer.isMinorCiv() && kPlayer.getCapitalCity() != NULL)
				{
					if (kPlayer.IsEmpireSuperUnhappy())
						continue;

					PublicOpinionTypes eOpinionInMyCiv = GetCulture()->GetPublicOpinionType();
					int iCulturalDominanceOverUs = kPlayer.GetCulture()->GetInfluenceLevel(GetID()) - GetCulture()->GetInfluenceLevel((PlayerTypes)iLoopPlayer);
					if (eOpinionInMyCiv == PUBLIC_OPINION_REVOLUTIONARY_WAVE || (IsEmpireSuperUnhappy() && iCulturalDominanceOverUs > 1))
					{
						int iValue = 1000;
						if (iCulturalDominanceOverUs > 0)
						{
							iValue *= iCulturalDominanceOverUs+1;
						}
						// Find how far their capital is from this city
						int iCapitalDistance = plotDistance(pMostUnhappyCity->getX(), pMostUnhappyCity->getY(), kPlayer.getCapitalCity()->getX(), kPlayer.getCapitalCity()->getY());

						iValue -= iCapitalDistance * 2;

						PolicyBranchTypes eOtherCivIdeology = kPlayer.GetPlayerPolicies()->GetLateGamePolicyTree();
						if (eOtherCivIdeology != NO_POLICY_BRANCH_TYPE && eOtherCivIdeology == ePreferredIdeology)
							iValue *= 3;

						int iModifier = 0;
						if (GAMEEVENTINVOKE_VALUE(iModifier, GAMEEVENT_CityFlipRecipientChance, pMostUnhappyCity->GetID(), GetID(), (PlayerTypes)iLoopPlayer) == GAMEEVENTRETURN_VALUE) {
							if (iModifier != 0) {
								iValue += iModifier;
							}
						}

						if (iValue > iBestValue)
						{
							iBestValue = iValue;
							eRtnValue = (PlayerTypes)iLoopPlayer;
						}
					}
				}
			}
		}
	}

	return eRtnValue;
}

//	--------------------------------------------------------------------------------
/// Returns the amount of Happiness being added by Policies
int CvPlayer::GetHappinessFromPolicies() const
{
	return 0;
}

//	--------------------------------------------------------------------------------
/// Returns the amount of Local Happiness generated in the cities
int CvPlayer::GetHappinessFromCities() const
{
	int iHappiness = 0;

	const CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (pLoopCity->IsPuppet() && MOD_BALANCE_CORE_PUPPET_CHANGES)
			continue;

		iHappiness += pLoopCity->GetLocalHappiness();
	}

	return iHappiness;
}

//	--------------------------------------------------------------------------------
/// Returns the amount of extra Happiness per City
int CvPlayer::GetExtraHappinessPerCity() const
{
	return m_iHappinessPerCity;
}

//	--------------------------------------------------------------------------------
/// Returns the amount of extra Happiness per City
int CvPlayer::GetHappinessFromBuildings() const
{
	return 0;
}

//	--------------------------------------------------------------------------------
/// Changes amount of extra Happiness per City
void CvPlayer::ChangeExtraHappinessPerCity(int iChange)
{
	CvAssertMsg(m_iHappinessPerCity >= 0, "Count of buildings helping Happiness is corrupted");

	if(iChange != 0)
		m_iHappinessPerCity += iChange;
}

//	--------------------------------------------------------------------------------
/// Returns the amount of extra Happiness per City
int CvPlayer::GetExtraHappinessPerXPolicies() const
{
	return m_iHappinessPerXPolicies;
}

//	--------------------------------------------------------------------------------
/// Changes amount of extra Happiness per City
void CvPlayer::ChangeExtraHappinessPerXPolicies(int iChange)
{
	CvAssertMsg(m_iHappinessPerXPolicies >= 0, "Count of extra happiness per buildings is corrupted");

	if(iChange != 0)
		m_iHappinessPerXPolicies += iChange;
}

/// Returns the amount of extra Happiness per City
int CvPlayer::GetExtraHappinessPerXPoliciesFromPolicies() const
{
	return m_iExtraHappinessPerXPoliciesFromPolicies;
}

//	--------------------------------------------------------------------------------
/// Changes amount of extra Happiness per City
void CvPlayer::ChangeExtraHappinessPerXPoliciesFromPolicies(int iChange)
{
	CvAssertMsg(m_iExtraHappinessPerXPoliciesFromPolicies >= 0, "Count of extra happiness per buildings is corrupted");

	if (iChange != 0)
		m_iExtraHappinessPerXPoliciesFromPolicies += iChange;
}

/// Returns the amount of extra Happiness per City
int CvPlayer::GetHappinessPerXGreatWorks() const
{
	return m_iHappinessPerXGreatWorks;
}

//	--------------------------------------------------------------------------------
/// Changes amount of extra Happiness per City
void CvPlayer::ChangeHappinessPerXGreatWorks(int iChange)
{
	CvAssertMsg(m_iHappinessPerXGreatWorks  >= 0, "Count of extra happiness per buildings is corrupted");

	if (iChange != 0)
		m_iHappinessPerXGreatWorks += iChange;
}
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
int CvPlayer::GetHappinessFromResourceMonopolies() const
{
	int iTotalHappiness = 0;
	// Do we get increased Happiness from a resource monopoly?
	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
		CvResourceInfo* pInfo = GC.getResourceInfo(eResourceLoop);
		if (pInfo && pInfo->isMonopoly())
		{
			if(HasGlobalMonopoly(eResourceLoop) && pInfo->getMonopolyHappiness() > 0)
			{
				int iTemp = pInfo->getMonopolyHappiness();
				iTemp += GetMonopolyModFlat();
				iTotalHappiness += iTemp;
			}
		}
	}
	return iTotalHappiness;
}
#endif
//	--------------------------------------------------------------------------------
/// Total amount of Happiness gained from Resources
int CvPlayer::GetHappinessFromResources() const
{
	int iTotalHappiness = 0;

	// Check all connected Resources
	for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResource = (ResourceTypes) iResourceLoop;

		int iBaseHappiness = GetHappinessFromLuxury(eResource);
		if(iBaseHappiness)
		{
			// Resource bonus from Minors, and this is a Luxury we're getting from one (Policies, etc.)
			if(IsMinorResourceBonus() && getResourceFromMinors(eResource) > 0)
			{
				iBaseHappiness *= /*150*/ GC.getMINOR_POLICY_RESOURCE_HAPPINESS_MULTIPLIER();
				iBaseHappiness /= 100;
			}

			iTotalHappiness += iBaseHappiness;
			iTotalHappiness += GetExtraHappinessPerLuxury();
		}
	}

	return iTotalHappiness;
}

//	--------------------------------------------------------------------------------
/// Amount of Happiness from having a variety of Luxuries
int CvPlayer::GetHappinessFromResourceVariety() const
{
	int iMultipleLuxuriesBonus = /*1*/ GC.getHAPPINESS_PER_EXTRA_LUXURY();
	if (iMultipleLuxuriesBonus == 0)
		return 0;

	// Check all connected Resources
	int iNumHappinessResources = 0;
	for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResource = (ResourceTypes) iResourceLoop;
		if(GetHappinessFromLuxury(eResource) > 0)
		{
			iNumHappinessResources++;
		}
	}

	if(iNumHappinessResources > 1)
	{
		return (iNumHappinessResources-1) * iMultipleLuxuriesBonus;
	}

	return 0;
}


//	--------------------------------------------------------------------------------
/// Total amount of Happiness gained from Religion
int CvPlayer::GetHappinessFromReligion()
{
	int iHappinessFromReligion = 0;
	CvGameReligions* pReligions = GC.getGame().GetGameReligions();

	// Founder beliefs
	ReligionTypes eFoundedReligion = GC.getGame().GetGameReligions()->GetFounderBenefitsReligion(GetID());
	if(eFoundedReligion == NO_RELIGION)
	{
		eFoundedReligion = GetReligions()->GetReligionInMostCities();
	}
	if(eFoundedReligion != NO_RELIGION)
	{
		const CvReligion* pReligion = pReligions->GetReligion(eFoundedReligion, GetID());
		if (pReligion)
		{
			CvCity* pHolyCity = NULL;
			CvPlot* pHolyCityPlot = GC.getMap().plot(pReligion->m_iHolyCityX, pReligion->m_iHolyCityY);
			if (pHolyCityPlot)
			{
				pHolyCity = pHolyCityPlot->getPlotCity();
			}

			bool bAtPeace = GET_TEAM(getTeam()).getAtWarCount(false) == 0;
			iHappinessFromReligion += pReligion->m_Beliefs.GetPlayerHappiness(bAtPeace, GetID(), pHolyCity, true);

			float iHappinessPerFollowingCity = pReligion->m_Beliefs.GetHappinessPerFollowingCity(GetID(), pHolyCity, true);
			iHappinessFromReligion += (int)((float)pReligions->GetNumCitiesFollowing(eFoundedReligion) * iHappinessPerFollowingCity);

			int iHappinessPerXPeacefulForeignFollowers = pReligion->m_Beliefs.GetHappinessPerXPeacefulForeignFollowers(GetID(), pHolyCity, true);
			if (iHappinessPerXPeacefulForeignFollowers > 0)
			{
				iHappinessFromReligion += GetReligions()->GetNumForeignFollowers(true, /*bAtPeace */eFoundedReligion) / iHappinessPerXPeacefulForeignFollowers;
			}
#if defined(MOD_BALANCE_CORE_BELIEFS)
			int iPantheon = 0;
			if (pHolyCity == NULL)
			{
				pHolyCity = getCapitalCity();
			}
			int iHappiness = pReligion->m_Beliefs.GetHappinessPerPantheon(GetID(), pHolyCity, true);
			if (iHappiness > 0)
			{
				iPantheon = GC.getGame().GetGameReligions()->GetNumPantheonsCreated();
				if (iPantheon > 0)
				{
					if (iPantheon > 8)
					{
						iPantheon = 8;
					}
					iHappinessFromReligion += (iPantheon * iHappiness);
				}
			}
			
			int iSpyHappiness = pReligion->m_Beliefs.GetHappinessFromForeignSpies(GetID(), pHolyCity, true);
			if (iSpyHappiness > 0)
			{
				int numForeignSpies = 0;
				CvPlayerEspionage* pEspionage = GetEspionage();
				if (pEspionage)
				{
					for (uint ui = 0; ui < pEspionage->m_aSpyList.size(); ui++)
					{
						if (pEspionage->m_aSpyList[ui].m_eSpyState == SPY_STATE_DEAD)
							continue;

						if (pEspionage->m_aSpyList[ui].m_eSpyState == SPY_STATE_TRAVELLING)
							continue;

						CvPlot* pPlot = GC.getMap().plot(pEspionage->m_aSpyList[ui].m_iCityX, pEspionage->m_aSpyList[ui].m_iCityY);
						if (pPlot == NULL)
							continue;

						CvCity* pSpyCity = pPlot->getPlotCity();

						if (pSpyCity == NULL)
							continue;

						if (pSpyCity->getOwner() == GetID())
							continue;

						numForeignSpies++;
					}
				}
				iHappinessFromReligion += numForeignSpies * iSpyHappiness;
			}
			
#endif
		}
	}

	return iHappinessFromReligion;
}

//	--------------------------------------------------------------------------------
// Happiness from finding Natural Wonders
int CvPlayer::GetHappinessFromNaturalWonders() const
{
	int iNumWonders = GET_TEAM(getTeam()).GetNumNaturalWondersDiscovered();

	int iHappiness = iNumWonders* /*1*/ GC.getHAPPINESS_PER_NATURAL_WONDER();
	
#if defined(HH_MOD_NATURAL_WONDER_MODULARITY)
	int iBonusHappiness = iNumWonders* (m_pPlayerPolicies->GetNumericModifier(POLICYMOD_EXTRA_NATURALWONDER_HAPPINESS));
	iHappiness += iBonusHappiness;
#endif

	// Trait boosts this further?
	if(m_pTraits->GetNaturalWonderHappinessModifier() > 0)
	{
		iHappiness *= (100 + m_pTraits->GetNaturalWonderHappinessModifier());
		iHappiness /= 100;
	}

#if defined(MOD_BALANCE_CORE)
	for (int iI = 0; iI < GC.getNumFeatureInfos(); iI++)
	{
		FeatureTypes eFeature = (FeatureTypes)iI;
		if (eFeature == NO_FEATURE)
			continue;

		if (!IsNWOwned(eFeature))
			continue;

		int iPlotHappiness = GC.getFeatureInfo(eFeature)->getInBorderHappiness();

		if (iPlotHappiness > 0)
		{
			// Trait boosts this further?
			if (m_pTraits->GetNaturalWonderYieldModifier() > 0)
			{
				iPlotHappiness *= (100 + m_pTraits->GetNaturalWonderYieldModifier());
				iPlotHappiness /= 100;
			}

			iHappiness += iPlotHappiness;
		}
	}

	iHappiness +=  GET_TEAM(getTeam()).GetNumLandmarksBuilt();
#else
	for(int iI = 0; iI < GC.getMap().numPlots(); iI++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iI);
		if(pPlot == NULL)
		{
			continue;
		}

		if(pPlot->getOwner() != m_eID)
		{
			continue;
		}

		FeatureTypes eFeature = pPlot->getFeatureType();
		if(eFeature == NO_FEATURE)
		{
			continue;
		}

		int iPlotHappiness = GC.getFeatureInfo(eFeature)->getInBorderHappiness();

		if(iPlotHappiness > 0)
		{
			// Trait boosts this further?
			if(m_pTraits->GetNaturalWonderYieldModifier() > 0)
			{
				iPlotHappiness *= (100 + m_pTraits->GetNaturalWonderYieldModifier());
				iPlotHappiness /= 100;
			}

			iHappiness += iPlotHappiness;
		}
	}
#endif
	return iHappiness;
}
#if defined(MOD_BALANCE_CORE)
void CvPlayer::SetNWOwned(FeatureTypes eFeature, bool bValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eFeature >= 0, "eFeature is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFeature < GC.getNumFeatureInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");


	if (m_abNWOwned[eFeature] != bValue)
	{
		m_abNWOwned.setAt(eFeature, bValue);
	}
}
bool CvPlayer::IsNWOwned(FeatureTypes eFeature) const
{
	return m_abNWOwned[eFeature];
}

void CvPlayer::ChangeUnitClassProductionModifier(UnitClassTypes eUnitClass, int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eUnitClass >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eUnitClass < GC.getNumUnitClassInfos(), "eUnitClass expected to be < GC.getNumUnitClassInfos()");
	m_paiUnitClassProductionModifiers.setAt(eUnitClass, m_paiUnitClassProductionModifiers[eUnitClass] + iValue);
}
int CvPlayer::GetUnitClassProductionModifier(UnitClassTypes eUnitClass) const
{
	VALIDATE_OBJECT
		CvAssertMsg(eUnitClass >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eUnitClass < GC.getNumUnitClassInfos(), "eUnitClass expected to be < GC.getNumUnitClassInfos()");
	return m_paiUnitClassProductionModifiers[eUnitClass];
}
#endif
//	--------------------------------------------------------------------------------
/// Extra Happiness from every connected Luxury
int CvPlayer::GetExtraHappinessPerLuxury() const
{
	return m_iExtraHappinessPerLuxury;
}

//	--------------------------------------------------------------------------------
/// Change Extra Happiness from every connected Luxury
void CvPlayer::ChangeExtraHappinessPerLuxury(int iChange)
{
	//antonjs: consider: this check wasn't here before, maybe we shouldn't have it in case mods, scenarios use luxuries in a unique malus way
	//CvAssertMsg(m_iExtraHappinessPerLuxury + iChange >= 0, "Net extra happiness per luxury not expected to be negative!");
	// slewis - Hey Anton, I removed this because it was complaining during my awesome Fall of Rome scenario.
	m_iExtraHappinessPerLuxury += iChange;
}
#if defined(MOD_BALANCE_CORE_HAPPINESS)
//	--------------------------------------------------------------------------------
int CvPlayer::getGlobalAverage(YieldTypes eYield) const
{	
	int iYield = 0;

	if(eYield == YIELD_CULTURE)
	{
		iYield = GC.getGame().GetCultureAverage();
	}
	else if(eYield == YIELD_SCIENCE)
	{
		iYield = GC.getGame().GetScienceAverage();
	}
	else if(eYield == YIELD_PRODUCTION)
	{
		iYield = GC.getGame().GetDefenseAverage();
	}
	else if(eYield == YIELD_GOLD)
	{
		iYield = GC.getGame().GetGoldAverage();
	}

	return iYield;
}
#endif

#if defined(MOD_BALANCE_CORE_HAPPINESS_LUXURY)
//	--------------------------------------------------------------------------------
int CvPlayer::GetPlayerHappinessLuxuryPopulationFactor1000() const
{
	//todo: add traits and policy effects here
	return GC.getBALANCE_HAPPINESS_LUXURY_POP_SCALER();
}

int CvPlayer::GetPlayerHappinessLuxuryCountFactor1000() const
{
	//todo: add traits and policy effects here
	return GC.getBALANCE_HAPPINESS_LUXURY_COUNT_SCALER();
}

int CvPlayer::GetBonusHappinessFromLuxuries(int iPop) const
{
	if (iPop == 0)
		return 0;

	int iTotalResourceWeight = 0;
	for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResource = (ResourceTypes) iResourceLoop;
		int iBaseVal = GetHappinessFromLuxury(eResource, false) * 1000;
		if (iBaseVal <= 0)
			continue;

		iBaseVal += (GetExtraHappinessPerLuxury() * 1000);

		CvResourceInfo* pInfo = GC.getResourceInfo(eResource);
		if (pInfo && pInfo->isMonopoly())
		{
			if (HasGlobalMonopoly(eResource) && pInfo->getMonopolyHappiness() > 0)
			{
				iBaseVal += (pInfo->getMonopolyHappiness() + GetMonopolyModFlat()) * 1000;
			}
		}

		// Resource bonus from Minors, and this is a Luxury we're getting from one (Policies, etc.)
		if (IsMinorResourceBonus() && getResourceFromMinors(eResource) > 0)
		{
			iBaseVal *= /*150*/ GC.getMINOR_POLICY_RESOURCE_HAPPINESS_MULTIPLIER();
			iBaseVal /= 100;
		}

		iTotalResourceWeight += iBaseVal;
	}

	if (iTotalResourceWeight <= 0)
		return 0;

	//scaler is in 1/1000th
	int iScaled = int(0.5f + iTotalResourceWeight / 1000.f * iPop * GetPlayerHappinessLuxuryPopulationFactor1000() / 1000);

	return max(1, iScaled);
	
}

int CvPlayer::GetBonusHappinessFromLuxuriesFlat() const
{
	int iTotalResourceWeight = 0;

	int iCityScaler = getNumCities() * GC.getBALANCE_HAPPINESS_LUXURY_POP_SCALER();
	iCityScaler /= 100;

	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResource = (ResourceTypes)iResourceLoop;
		int iBaseVal = GetHappinessFromLuxury(eResource);
		if (iBaseVal <= 0)
			continue;

		iBaseVal += GetExtraHappinessPerLuxury();
		iBaseVal += iCityScaler;

		CvResourceInfo* pInfo = GC.getResourceInfo(eResource);
		if (pInfo && pInfo->isMonopoly())
		{
			if (HasGlobalMonopoly(eResource) && pInfo->getMonopolyHappiness() > 0)
			{
				iBaseVal += (pInfo->getMonopolyHappiness() + GetMonopolyModFlat());
			}
		}

		// Resource bonus from Minors, and this is a Luxury we're getting from one (Policies, etc.)
		if (IsMinorResourceBonus() && getResourceFromMinors(eResource) > 0)
		{
			iBaseVal *= /*150*/ GC.getMINOR_POLICY_RESOURCE_HAPPINESS_MULTIPLIER();
			iBaseVal /= 100;
		}

		iTotalResourceWeight += iBaseVal;
	}

	if (iTotalResourceWeight <= 0)
		return 0;

	return iTotalResourceWeight;

}

int CvPlayer::GetBonusHappinessFromLuxuriesFlatForUI() const
{
	int iTotalResourceWeight = 0;

	int iCityScaler = getNumCities() * GC.getBALANCE_HAPPINESS_LUXURY_POP_SCALER();
	iCityScaler /= 100;
	
	int iNumResources = 0;
	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResource = (ResourceTypes)iResourceLoop;
		int iBaseVal = GetHappinessFromLuxury(eResource);
		if (iBaseVal <= 0)
			continue;

		iBaseVal += GetExtraHappinessPerLuxury();
		iBaseVal += iCityScaler;

		CvResourceInfo* pInfo = GC.getResourceInfo(eResource);
		if (pInfo && pInfo->isMonopoly())
		{
			if (HasGlobalMonopoly(eResource) && pInfo->getMonopolyHappiness() > 0)
			{
				iBaseVal += (pInfo->getMonopolyHappiness() + GetMonopolyModFlat());
			}
		}

		// Resource bonus from Minors, and this is a Luxury we're getting from one (Policies, etc.)
		if (IsMinorResourceBonus() && getResourceFromMinors(eResource) > 0)
		{
			iBaseVal *= /*150*/ GC.getMINOR_POLICY_RESOURCE_HAPPINESS_MULTIPLIER();
			iBaseVal /= 100;
		}

		iTotalResourceWeight += iBaseVal;

		iNumResources++;
	}

	if (iTotalResourceWeight <= 0)
		return 0;

	return iTotalResourceWeight / max(1, iNumResources);
	 
}


int CvPlayer::GetBonusHappinessFromLuxuriesGradient() const
{
	int iCurrentWeight = 1000;
	for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResource = (ResourceTypes) iResourceLoop;
		if(eResource != NO_RESOURCE && GetHappinessFromLuxury(eResource) > 0)
		{
			iCurrentWeight = (iCurrentWeight*GetPlayerHappinessLuxuryCountFactor1000()) / 1000; //reduce the weight for each additional luxury
		}
	}

	//scaler is in 1/1000th
	return int(0.5f + iCurrentWeight / 1000.f * getAveragePopulation() * GetPlayerHappinessLuxuryPopulationFactor1000() / 1000.f );
}
#endif

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvPlayer::GetUnhappinessFromWarWeariness() const
{
	return GetCulture()->GetWarWeariness();
}
#endif
//	--------------------------------------------------------------------------------
/// How much happiness credit for having this resource as a luxury?
int CvPlayer::GetHappinessFromLuxury(ResourceTypes eResource, bool bIncludeImport) const
{
	if (GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(GetID(), eResource))
		return 0;

	CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);
	if(pkResourceInfo)
	{
		// Only look at Luxuries
		if(pkResourceInfo->getResourceUsage() != RESOURCEUSAGE_LUXURY)
		{
			return 0;
		}

		// Any extras?
		else if (getNumResourceAvailable(eResource, /*bIncludeImport*/ bIncludeImport) > 0)
		{
			return pkResourceInfo->getHappiness();
		}

		else if(GetPlayerTraits()->GetLuxuryHappinessRetention() > 0)
		{
			if(getResourceExport(eResource) > 0)
			{
				return ((pkResourceInfo->getHappiness() * GetPlayerTraits()->GetLuxuryHappinessRetention()) / 100);
			}
		}
	}

	return 0;
}

//	--------------------------------------------------------------------------------
/// How much Unhappiness are Units producing?
int CvPlayer::GetUnhappinessFromUnits() const
{
	int iUnhappinessFromUnits = m_iUnhappinessFromUnits;

	int iFreeUnitUnhappiness = /*0*/ GC.getFREE_UNIT_HAPPINESS();
	if(iFreeUnitUnhappiness != 0)
	{
#if defined(MOD_API_EXTENSIONS)
		// If unhappy is 2 and free happy is 4, we need to subtract 2
		// If unhappy is 5 and free happy is 4, we need to subtract 4 --> these two make "the min of unhappy and free happy"
		// If unhappy is -2 and free happy is 4, we need to subtract 0 --> this one adds "the previous figure not to be negative"
		iUnhappinessFromUnits -= std::max(0, std::min(iUnhappinessFromUnits, iFreeUnitUnhappiness));
#else
		iUnhappinessFromUnits -= iFreeUnitUnhappiness;
#endif
	}

#if !defined(MOD_API_EXTENSIONS)
	// Can't be less than 0
	if(iUnhappinessFromUnits < 0)
	{
		iUnhappinessFromUnits = 0;
	}
#endif

#if defined(MOD_API_EXTENSIONS)
	if(iUnhappinessFromUnits > 0 && GetUnhappinessFromUnitsMod() != 0)
#else
	if(GetUnhappinessFromUnitsMod() != 0)
#endif
	{
		iUnhappinessFromUnits *= (100 + GetUnhappinessFromUnitsMod());
		iUnhappinessFromUnits /= 100;
	}

	return iUnhappinessFromUnits;
}

//	--------------------------------------------------------------------------------
/// Changes how much Happiness Units produce
void CvPlayer::ChangeUnhappinessFromUnits(int iChange)
{
	m_iUnhappinessFromUnits += iChange;
}

//	--------------------------------------------------------------------------------
/// How much of our Happiness is being used up? (Population + Units)
int CvPlayer::DoUpdateTotalUnhappiness(CvCity* pAssumeCityAnnexed, CvCity* pAssumeCityPuppeted)
{

	if (isMinorCiv() || isBarbarian())
	{
		return 0;
	}

	int iUnhappiness = 0;

	if (!MOD_BALANCE_CORE_HAPPINESS)
	{

		// City Count Unhappiness
		iUnhappiness += GetUnhappinessFromCityCount(pAssumeCityAnnexed, pAssumeCityPuppeted);

		// Occupied City Count Unhappiness
		iUnhappiness += GetUnhappinessFromCapturedCityCount(pAssumeCityAnnexed, pAssumeCityPuppeted);

		// City Population Unhappiness
		iUnhappiness += GetUnhappinessFromCityPopulation(pAssumeCityAnnexed, pAssumeCityPuppeted);

		// Occupied City Population Unhappiness
		iUnhappiness += GetUnhappinessFromOccupiedCities(pAssumeCityAnnexed, pAssumeCityPuppeted);

		// Unit Unhappiness (Builders)
		iUnhappiness += GetUnhappinessFromUnits();

		iUnhappiness /= 100;
	}

	iUnhappiness += GetCulture()->GetPublicOpinionUnhappiness();

	if (MOD_BALANCE_CORE_JFD && !isMinorCiv() && !isBarbarian())
	{
		iUnhappiness += getUnhappinessFromCityJFDSpecial();
	}

	if(MOD_BALANCE_CORE_HAPPINESS && !isMinorCiv() && !isBarbarian())
	{
		iUnhappiness += GetUnhappinessFromWarWeariness();
	}
	if (!MOD_BALANCE_CORE_HAPPINESS)
	{
		// AI gets reduced Unhappiness on higher levels
		if (!isHuman() && !IsAITeammateOfHuman())
		{
			iUnhappiness *= GC.getGame().getHandicapInfo().getAIUnhappinessPercent();
			iUnhappiness /= 100;
		}
	}

	SetUnhappiness(iUnhappiness);
	return iUnhappiness;
}

//	--------------------------------------------------------------------------------
/// Used for providing info to the player
int CvPlayer::GetUnhappinessFromCityForUI(CvCity* pCity) const
{
	int iNumCitiesUnhappinessTimes100 = 0;
	float iPopulationUnhappinessTimes100 = 0;

	int iPopulation = pCity->getPopulation() * 100;

	// No Unhappiness from Specialist Pop? (Policies, etc.)
	if(isHalfSpecialistUnhappiness())
	{
		int iSpecialistCount = pCity->GetCityCitizens()->GetTotalSpecialistCount() * 100;
		iPopulation -= (iSpecialistCount / 2);
	}

	// Occupied?
	if(pCity->IsOccupied() && !pCity->IsIgnoreCityForHappiness())
	{
		iNumCitiesUnhappinessTimes100 += (100 * /*5*/ GC.getUNHAPPINESS_PER_CAPTURED_CITY());
		iPopulationUnhappinessTimes100 += int(iPopulation* /*1.34f*/ GC.getUNHAPPINESS_PER_OCCUPIED_POPULATION());

		// Mod (Policies, etc.)
		if(GetOccupiedPopulationUnhappinessMod() != 0)
		{
			iPopulationUnhappinessTimes100 *= (100 + GetOccupiedPopulationUnhappinessMod());
			iPopulationUnhappinessTimes100 /= 100;
		}
	}
	// Normal City
	else
	{
		iNumCitiesUnhappinessTimes100 += (100 * /*2*/ GC.getUNHAPPINESS_PER_CITY());
		iPopulationUnhappinessTimes100 += (iPopulation* (/*1*/ GC.getUNHAPPINESS_PER_POPULATION() + GC.getUNHAPPINESS_PER_POPULATION_FLOAT()));

		if(pCity->isCapital() && GetCapitalUnhappinessMod() != 0)
		{
			iPopulationUnhappinessTimes100 *= (100 + GetCapitalUnhappinessMod());
			iPopulationUnhappinessTimes100 /= 100;
		}
#if defined(MOD_BALANCE_CORE)
		if(pCity->GetLocalUnhappinessMod() != 0)
		{
			iPopulationUnhappinessTimes100 *= (100 + pCity->GetLocalUnhappinessMod());
			iPopulationUnhappinessTimes100 /= 100;
		}
#endif

		iPopulationUnhappinessTimes100 *= (100 + GetUnhappinessMod());
		iPopulationUnhappinessTimes100 /= 100;

		iPopulationUnhappinessTimes100 *= 100 + GetPlayerTraits()->GetPopulationUnhappinessModifier();
		iPopulationUnhappinessTimes100 /= 100;
	}

	if (!MOD_BALANCE_CORE_HAPPINESS)
	{
		// Population Handicap mod
		iPopulationUnhappinessTimes100 *= getHandicapInfo().getPopulationUnhappinessMod();
		iPopulationUnhappinessTimes100 /= 100;
	}

	// City Count Player mod
	int iMod = 0;
	iMod += GetCityCountUnhappinessMod();
	iMod += GetPlayerTraits()->GetCityUnhappinessModifier();

	iNumCitiesUnhappinessTimes100 *= (100 + iMod);
	iNumCitiesUnhappinessTimes100 /= 100;

	// City Count Handicap mod
	iNumCitiesUnhappinessTimes100 *= getHandicapInfo().getNumCitiesUnhappinessMod();
	iNumCitiesUnhappinessTimes100 /= 100;

	// City Count Map size mod
	iNumCitiesUnhappinessTimes100 *= GC.getMap().getWorldInfo().getNumCitiesUnhappinessPercent();
	iNumCitiesUnhappinessTimes100 /= 100;

	return iNumCitiesUnhappinessTimes100 + (int)iPopulationUnhappinessTimes100;
}

//	--------------------------------------------------------------------------------
/// Unhappiness from number of Cities
int CvPlayer::GetUnhappinessFromCityCount(CvCity* pAssumeCityAnnexed, CvCity* pAssumeCityPuppeted) const
{
	int iUnhappiness = 0;
	int iUnhappinessPerCity = /*2*/ GC.getUNHAPPINESS_PER_CITY() * 100;

	bool bCityValid;

	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		bCityValid = false;

		// Assume city is puppeted, and counts
		if(pLoopCity == pAssumeCityPuppeted)
			bCityValid = true;
		// Assume city is annexed, and does NOT count
		else if(pLoopCity == pAssumeCityAnnexed)
			bCityValid = false;
		// Assume city doesn't exist, and does NOT count
		else if(pLoopCity->IsIgnoreCityForHappiness())
			bCityValid = false;
		// Normal city
		else if(!pLoopCity->IsOccupied() || pLoopCity->IsNoOccupiedUnhappiness())
			bCityValid = true;
#if defined(MOD_BALANCE_CORE_HAPPINESS)
		if(MOD_BALANCE_CORE_HAPPINESS)
		{
			//Tradition policy bonus - Capital grants no founding unhappiness.
			if(pLoopCity->isCapital() && GetCapitalUnhappinessMod() != 0)
			{
				bCityValid = false;
			}
		}
#endif
#if defined(MOD_BALANCE_CORE_POLICIES)
		if(MOD_BALANCE_CORE_POLICIES)
		{
			//Expansion policy bonus - Cities grant no unhappiness from expansion.
			if(IsNoUnhappinessExpansion())
			{
				bCityValid = false;
			}
		}
#endif
		if(bCityValid)
			iUnhappiness += iUnhappinessPerCity;
	}

	// Player count mod
	int iMod = 0;
	iMod += GetCityCountUnhappinessMod();
	iMod += GetPlayerTraits()->GetCityUnhappinessModifier();

	iUnhappiness *= (100 + iMod);
	iUnhappiness /= 100;

	// Handicap mod
	iUnhappiness *= getHandicapInfo().getNumCitiesUnhappinessMod();
	iUnhappiness /= 100;

	// Map size mod
	iUnhappiness *= GC.getMap().getWorldInfo().getNumCitiesUnhappinessPercent();
	iUnhappiness /= 100;

	return iUnhappiness;
}

//	--------------------------------------------------------------------------------
/// Unhappiness from number of Captured Cities
int CvPlayer::GetUnhappinessFromCapturedCityCount(CvCity* pAssumeCityAnnexed, CvCity* pAssumeCityPuppeted) const
{
	int iUnhappiness = 0;
	int iUnhappinessPerCapturedCity = /*5*/ GC.getUNHAPPINESS_PER_CAPTURED_CITY() * 100;

	bool bCityValid;

	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		bCityValid = false;

		// Assume city is puppeted, and does NOT count
		if(pLoopCity == pAssumeCityPuppeted)
			bCityValid = false;
		// Assume city is annexed, and counts
		else if(pLoopCity == pAssumeCityAnnexed)
			bCityValid = true;
		// Assume city doesn't exist, and does NOT count
		else if(pLoopCity->IsIgnoreCityForHappiness())
			bCityValid = false;
		// Occupied city
		else if(pLoopCity->IsOccupied() && !pLoopCity->IsNoOccupiedUnhappiness())
			bCityValid = true;

		// Extra Unhappiness from Occupied Cities
		if(bCityValid)
			iUnhappiness += iUnhappinessPerCapturedCity;
	}

	// Player count mod
	int iMod = 0;
	iMod += GetCityCountUnhappinessMod();
	iMod += GetPlayerTraits()->GetCityUnhappinessModifier();

	iUnhappiness *= (100 + iMod);
	iUnhappiness /= 100;

	// Handicap mod
	iUnhappiness *= getHandicapInfo().getNumCitiesUnhappinessMod();
	iUnhappiness /= 100;

	// Map size mod
	iUnhappiness *= GC.getMap().getWorldInfo().getNumCitiesUnhappinessPercent();
	iUnhappiness /= 100;

	return iUnhappiness;
}

//	--------------------------------------------------------------------------------
/// Unhappiness from City Population
int CvPlayer::GetUnhappinessFromCityPopulation(CvCity* pAssumeCityAnnexed, CvCity* pAssumeCityPuppeted) const
{

#if defined(MOD_BALANCE_CORE_HAPPINESS)
	if(MOD_BALANCE_CORE_HAPPINESS)
	{
		return 0;
	}
#endif
	float iUnhappiness = 0;
	float iUnhappinessFromThisCity;

	float iUnhappinessPerPop = (/*1*/ GC.getUNHAPPINESS_PER_POPULATION() + GC.getUNHAPPINESS_PER_POPULATION_FLOAT()) * 100;
	int iPopulation;
	int iSpecialistCount;

	bool bCityValid;

	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		bCityValid = false;

		// Assume pLoopCity is Annexed, and does NOT count
		if(pLoopCity == pAssumeCityAnnexed)
			bCityValid = false;
		// Assume that pLoopCity is a Puppet and IS counted here
		else if(pLoopCity == pAssumeCityPuppeted)
			bCityValid = true;
		// Assume city doesn't exist, and does NOT count
		else if(pLoopCity->IsIgnoreCityForHappiness())
			bCityValid = false;
		// Occupied Cities don't get counted here (see the next function)
		else if(!pLoopCity->IsOccupied() || pLoopCity->IsNoOccupiedUnhappiness())
			bCityValid = true;

		if(bCityValid)
		{
			iPopulation = pLoopCity->getPopulation();

			// No Unhappiness from Specialist Pop? (Policies, etc.)
			if(isHalfSpecialistUnhappiness())
			{
				iSpecialistCount = pLoopCity->GetCityCitizens()->GetTotalSpecialistCount();
				iSpecialistCount++; // Round up
				iPopulation -= (iSpecialistCount / 2);
			}

			iUnhappinessFromThisCity = iPopulation * iUnhappinessPerPop;

			if(pLoopCity->isCapital() && GetCapitalUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + GetCapitalUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#if defined(MOD_BALANCE_CORE)
			if(pLoopCity->GetLocalUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + pLoopCity->GetLocalUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#endif

			iUnhappiness += iUnhappinessFromThisCity;
		}
	}

	iUnhappiness *= (100 + GetUnhappinessMod());
	iUnhappiness /= 100;

	iUnhappiness *= 100 + GetPlayerTraits()->GetPopulationUnhappinessModifier();
	iUnhappiness /= 100;

	if (!MOD_BALANCE_CORE_HAPPINESS)
	{
		// Handicap mod
		iUnhappiness *= getHandicapInfo().getPopulationUnhappinessMod();
		iUnhappiness /= 100;
	}

	return (int)iUnhappiness;
}

//	--------------------------------------------------------------------------------
/// Unhappiness from Puppet City Population
int CvPlayer::GetUnhappinessFromPuppetCityPopulation() const
{
	int iLoop = 0;
	if (MOD_BALANCE_CORE_PUPPET_CHANGES)
	{
		int iTotal = 0;
		for (const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if (pLoopCity->IsRazing() || pLoopCity->IsResistance())
				continue;
			if (!pLoopCity->IsPuppet())
				continue;
			else
				iTotal += pLoopCity->getPopulation() / max(1, GC.getBALANCE_HAPPINESS_PUPPET_THRESHOLD_MOD());
		}
		return iTotal;
	}

	int iUnhappiness = 0;
	float iUnhappinessPerPop = (/*1*/ GC.getUNHAPPINESS_PER_POPULATION() + GC.getUNHAPPINESS_PER_POPULATION_FLOAT()) * 100;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		bool bCityValid = false;

		if(pLoopCity->IsPuppet())
			bCityValid = true;

		// Assume city doesn't exist, and does NOT count
		if(pLoopCity->IsIgnoreCityForHappiness())
			bCityValid = false;

		if(bCityValid)
		{
			int iPopulation = pLoopCity->getPopulation();

			// No Unhappiness from Specialist Pop? (Policies, etc.)
			// slewis - 2013.5.7 
			// This function, along with GetUnhappinessFromCitySpecialists, is only called through the UI to reflect 
			// to the player what's going on with their happiness. So I removed the effect that specialists have on 
			// puppeted cities and let the GetUnhappinessFromCitySpecialists correct that problem.

			/*if(isHalfSpecialistUnhappiness())
			{
				int iSpecialistCount = pLoopCity->GetCityCitizens()->GetTotalSpecialistCount();
				iSpecialistCount++; // Round up
				iPopulation -= (iSpecialistCount / 2);
			}*/
			iPopulation -= pLoopCity->GetCityCitizens()->GetTotalSpecialistCount();

			float iUnhappinessFromThisCity = iPopulation * iUnhappinessPerPop;

			if(pLoopCity->isCapital() && GetCapitalUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + GetCapitalUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#if defined(MOD_BALANCE_CORE)
			if(pLoopCity->GetLocalUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + pLoopCity->GetLocalUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#endif

			iUnhappiness += (int)iUnhappinessFromThisCity;
		}
	}

	iUnhappiness *= (100 + GetUnhappinessMod());
	iUnhappiness /= 100;

	iUnhappiness *= 100 + GetPlayerTraits()->GetPopulationUnhappinessModifier();
	iUnhappiness /= 100;

	if (!MOD_BALANCE_CORE_HAPPINESS)
	{
		// Handicap mod
		iUnhappiness *= getHandicapInfo().getPopulationUnhappinessMod();
		iUnhappiness /= 100;
	}

	return iUnhappiness;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetUnhappinessFromCitySpecialists(CvCity* pAssumeCityAnnexed, CvCity* pAssumeCityPuppeted) const
{
	float iUnhappiness = 0;
	float iUnhappinessFromThisCity;
	float iUnhappinessPerPop = /*1*/ (/*1*/ GC.getUNHAPPINESS_PER_POPULATION() + GC.getUNHAPPINESS_PER_POPULATION_FLOAT()) * 100;
	int iPopulation;

	bool bCityValid;

	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		bCityValid = false;

		// Assume pLoopCity is Annexed, and does NOT count
		if(pLoopCity == pAssumeCityAnnexed)
			bCityValid = false;
		// Assume that pLoopCity is a Puppet and IS counted here
		else if(pLoopCity == pAssumeCityPuppeted)
			bCityValid = true;
		// Assume city doesn't exist, and does NOT count
		else if(pLoopCity->IsIgnoreCityForHappiness())
			bCityValid = false;
		// Occupied Cities don't get counted here (see the next function)
		else if(!pLoopCity->IsOccupied() || pLoopCity->IsNoOccupiedUnhappiness())
			bCityValid = true;

		if (pLoopCity->IsPuppet() && MOD_BALANCE_CORE_PUPPET_CHANGES)
			bCityValid = false;

		if(bCityValid)
		{
			iPopulation = pLoopCity->GetCityCitizens()->GetTotalSpecialistCount();

#if defined(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS)
			//Less unhappiness from specialists....
			if (MOD_BALANCE_CORE_HAPPINESS_MODIFIERS || MOD_BALANCE_CORE_JFD)
			{
				iUnhappinessPerPop = (float)/*25*/ GC.getBALANCE_UNHAPPINESS_PER_SPECIALIST();
				int iNoHappinessSpecialists = 0;
				if (iPopulation > 0)
				{
					//...in capital?
					if (pLoopCity->isCapital())
					{
						iNoHappinessSpecialists += GetNoUnhappfromXSpecialistsCapital();
					}
					//...elsewhere?	
					iNoHappinessSpecialists += GetNoUnhappfromXSpecialists();

					iNoHappinessSpecialists += pLoopCity->GetNoUnhappfromXSpecialists();
				}
				//Can't give more free happiness than specialists.
				if (iNoHappinessSpecialists > iPopulation)
				{
					iNoHappinessSpecialists = iPopulation;
				}
				if (iNoHappinessSpecialists > 0)
				{
					iPopulation -= iNoHappinessSpecialists;
				}
			}
#endif

			// No Unhappiness from Specialist Pop? (Policies, etc.)
			if(isHalfSpecialistUnhappiness())
			{
				iPopulation++; // Round up
				iPopulation /= 2;
			}

			iUnhappinessFromThisCity = iPopulation * iUnhappinessPerPop;

#if defined(MOD_BALANCE_CORE_HAPPINESS)
			if(MOD_BALANCE_CORE_HAPPINESS || MOD_BALANCE_CORE_JFD)
			{
				iUnhappiness += iUnhappinessFromThisCity;
			}
			if(!MOD_BALANCE_CORE_HAPPINESS)
			{
//Took these away as they were making specialists do weird things.
#endif
			if(pLoopCity->isCapital() && GetCapitalUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + GetCapitalUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#if defined(MOD_BALANCE_CORE)
			if(pLoopCity->GetLocalUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + pLoopCity->GetLocalUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#endif

			iUnhappiness += iUnhappinessFromThisCity;
#if defined(MOD_BALANCE_CORE_HAPPINESS)
			}
#endif
		}
	}
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	if(!MOD_BALANCE_CORE_HAPPINESS)
	{
#endif
	iUnhappiness *= (100 + GetUnhappinessMod());
	iUnhappiness /= 100;

	iUnhappiness *= 100 + GetPlayerTraits()->GetPopulationUnhappinessModifier();
	iUnhappiness /= 100;

	// Handicap mod
	iUnhappiness *= getHandicapInfo().getPopulationUnhappinessMod();
	iUnhappiness /= 100;

#if defined(MOD_BALANCE_CORE_HAPPINESS)
	}
#endif
	return (int)iUnhappiness;
}

//	--------------------------------------------------------------------------------
/// Unhappiness from City Population in Occupied Cities
int CvPlayer::GetUnhappinessFromOccupiedCities(CvCity* pAssumeCityAnnexed, CvCity* pAssumeCityPuppeted) const
{
	int iUnhappiness = 0;
	int iUnhappinessFromThisCity;

	double fUnhappinessPerPop = /*1.34f*/ GC.getUNHAPPINESS_PER_OCCUPIED_POPULATION() * 100;
	int iPopulation;
	int iSpecialistCount;

	bool bCityValid;
	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		bCityValid = false;

		// Assume pLoopCity is Annexed, and counts
		if(pLoopCity == pAssumeCityAnnexed)
			bCityValid = true;
		// Assume that pLoopCity is a Puppet and does NOT count
		else if(pLoopCity == pAssumeCityPuppeted)
			bCityValid = false;
		// Assume city doesn't exist, and does NOT count
		else if(pLoopCity->IsIgnoreCityForHappiness())
			bCityValid = false;
		// Occupied Cities
		else if(pLoopCity->IsOccupied() && !pLoopCity->IsNoOccupiedUnhappiness())
			bCityValid = true;
#if defined(MOD_BALANCE_CORE_HAPPINESS)
		if(MOD_BALANCE_CORE_HAPPINESS && (pLoopCity->IsResistance() || pLoopCity->IsRazing()))
		{
			bCityValid = true;
		}
#endif

		if(bCityValid)
		{
			iPopulation = pLoopCity->getPopulation();

			// No Unhappiness from Specialist Pop? (Policies, etc.)
			if(isHalfSpecialistUnhappiness())
			{
				iSpecialistCount = pLoopCity->GetCityCitizens()->GetTotalSpecialistCount();
				iSpecialistCount++; // Round up
				iPopulation -= (iSpecialistCount / 2);
			}

			iUnhappinessFromThisCity = int(double(iPopulation) * fUnhappinessPerPop);

			// Mod (Policies, etc.)
			if(GetOccupiedPopulationUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + GetOccupiedPopulationUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#if defined(MOD_BALANCE_CORE_POLICIES)
			if(MOD_BALANCE_CORE_POLICIES && GetGarrisonsOccupiedUnhapppinessMod() != 0)
			{
				if(pLoopCity->HasGarrison())
				{
					iUnhappinessFromThisCity *= (100 + GetGarrisonsOccupiedUnhapppinessMod());
					iUnhappinessFromThisCity /= 100;
				}
			}
#endif

			iUnhappiness += iUnhappinessFromThisCity;
		}
	}

	if (!MOD_BALANCE_CORE_HAPPINESS)
	{
		// Handicap mod
		iUnhappiness *= getHandicapInfo().getPopulationUnhappinessMod();
		iUnhappiness /= 100;
	}

	return iUnhappiness;
}

//	--------------------------------------------------------------------------------
/// Unhappiness from Units Percent (50 = 50% of normal)
int CvPlayer::GetUnhappinessFromUnitsMod() const
{
	return m_iUnhappinessFromUnitsMod;
}

//	--------------------------------------------------------------------------------
/// Change Unhappiness from Units Percent (50 = 50% of normal)
void CvPlayer::ChangeUnhappinessFromUnitsMod(int iChange)
{
	if(iChange != 0)
	{
		m_iUnhappinessFromUnitsMod += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Unhappiness Mod (-50 = 50% of normal)
int CvPlayer::GetUnhappinessMod() const
{
	return m_iUnhappinessMod;
}

//	--------------------------------------------------------------------------------
/// Change Unhappiness Mod (-50 = 50% of normal)
void CvPlayer::ChangeUnhappinessMod(int iChange)
{
	if(iChange != 0)
	{
		m_iUnhappinessMod += iChange;
	}
}
#if defined(MOD_BALANCE_CORE_HAPPINESS)
int CvPlayer::getHappinessFromCitizenNeeds() const
{
	int iHappiness = 0;
	int iLoop = 0;
	for (const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (pLoopCity != NULL)
		{
			iHappiness += pLoopCity->GetLocalHappiness();
		}
	}
	return iHappiness;
}
int CvPlayer::getUnhappinessFromCitizenNeeds() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			iUnhappiness += pLoopCity->getUnhappinessAggregated();
		}
	}
	return iUnhappiness;
}

int CvPlayer::getUnhappinessFromCityCulture() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			if (pLoopCity->IsPuppet() && MOD_BALANCE_CORE_PUPPET_CHANGES)
				continue;

			iUnhappiness += pLoopCity->getUnhappinessFromCulture();
		}
	}
	return iUnhappiness;
}
int CvPlayer::getUnhappinessFromCityScience() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			if (pLoopCity->IsPuppet() && MOD_BALANCE_CORE_PUPPET_CHANGES)
				continue;

			iUnhappiness += pLoopCity->getUnhappinessFromScience();
		}
	}
	return iUnhappiness;
}
int CvPlayer::getUnhappinessFromCityDefense() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			if (pLoopCity->IsPuppet() && MOD_BALANCE_CORE_PUPPET_CHANGES)
				continue;

			iUnhappiness += pLoopCity->getUnhappinessFromDefense();
		}		
	}
	return iUnhappiness;
}
int CvPlayer::getUnhappinessFromCityGold() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			if (pLoopCity->IsPuppet() && MOD_BALANCE_CORE_PUPPET_CHANGES)
				continue;

			iUnhappiness += pLoopCity->getUnhappinessFromGold();
		}
	}
	return iUnhappiness;
}
int CvPlayer::getUnhappinessFromCityConnection() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			if (pLoopCity->IsPuppet() && MOD_BALANCE_CORE_PUPPET_CHANGES)
				continue;

			iUnhappiness += pLoopCity->getUnhappinessFromConnection();
		}
	}
	return iUnhappiness;
}
int CvPlayer::getUnhappinessFromCityPillaged() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			if (pLoopCity->IsPuppet() && MOD_BALANCE_CORE_PUPPET_CHANGES)
				continue;

			iUnhappiness += pLoopCity->getUnhappinessFromPillaged();
		}
	}
	return iUnhappiness;
}
int CvPlayer::getUnhappinessFromCityStarving() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			if (pLoopCity->IsPuppet() && MOD_BALANCE_CORE_PUPPET_CHANGES)
				continue;

			iUnhappiness += pLoopCity->getUnhappinessFromStarving();
		}
	}
	return iUnhappiness;
}
int CvPlayer::getUnhappinessFromCityMinority() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			if (pLoopCity->IsPuppet() && MOD_BALANCE_CORE_PUPPET_CHANGES)
				continue;

			iUnhappiness += pLoopCity->getUnhappinessFromReligion();
		}
	}
	return iUnhappiness;
}

int CvPlayer::getUnhappinessFromCityJFDSpecial() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for (const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (pLoopCity != NULL)
		{
			if (pLoopCity->IsPuppet() && MOD_BALANCE_CORE_PUPPET_CHANGES)
				continue;

			iUnhappiness += pLoopCity->getJFDSpecialUnhappinessSources();
		}
	}

	iUnhappiness += (GetUnhappinessFromCitySpecialists(NULL, NULL) / 100);
	return iUnhappiness;
}
#endif

//	--------------------------------------------------------------------------------
/// City Count Unhappiness Mod (-50 = 50% of normal)
int CvPlayer::GetCityCountUnhappinessMod() const
{
	return m_iCityCountUnhappinessMod;
}

//	--------------------------------------------------------------------------------
/// Change City Count Unhappiness Mod (-50 = 50% of normal)
void CvPlayer::ChangeCityCountUnhappinessMod(int iChange)
{
	if(iChange != 0)
	{
		m_iCityCountUnhappinessMod += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Occupied Population Unhappiness Mod (-50 = 50% of normal)
int CvPlayer::GetOccupiedPopulationUnhappinessMod() const
{
	return m_iOccupiedPopulationUnhappinessMod;
}

//	--------------------------------------------------------------------------------
/// Occupied Population Count Unhappiness Mod (-50 = 50% of normal)
void CvPlayer::ChangeOccupiedPopulationUnhappinessMod(int iChange)
{
	if(iChange != 0)
	{
		m_iOccupiedPopulationUnhappinessMod += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Unhappiness from Capital Mod (-50 = 50% of normal)
int CvPlayer::GetCapitalUnhappinessMod() const
{
	return m_iCapitalUnhappinessMod;
}

//	--------------------------------------------------------------------------------
/// Change Unhappiness from Capital Mod (-50 = 50% of normal)
void CvPlayer::ChangeCapitalUnhappinessMod(int iChange)
{
	if(iChange != 0)
	{
		m_iCapitalUnhappinessMod += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// How much Happiness are we getting from Units being Garrisoned in Cities?
int CvPlayer::GetHappinessPerGarrisonedUnit() const
{
	return m_iHappinessPerGarrisonedUnitCount;
}

//	--------------------------------------------------------------------------------
/// Set the amount of Happiness we're getting from Units being Garrisoned in Cities
void CvPlayer::SetHappinessPerGarrisonedUnit(int iValue)
{
	m_iHappinessPerGarrisonedUnitCount = iValue;
}

//	--------------------------------------------------------------------------------
/// Change the amount of Happiness we're getting from Units being Garrisoned in Cities
void CvPlayer::ChangeHappinessPerGarrisonedUnit(int iChange)
{
	SetHappinessPerGarrisonedUnit(m_iHappinessPerGarrisonedUnitCount + iChange);
}

//	--------------------------------------------------------------------------------
/// Returns cached amount of Happiness being brought in for having Cities connected via a Route
int CvPlayer::GetHappinessFromTradeRoutes() const
{
	return m_iCityConnectionHappiness;
}

//	--------------------------------------------------------------------------------
/// How much Happiness coming from Trade Routes?
void CvPlayer::DoUpdateCityConnectionHappiness()
{
	int iHappinessPerTradeRoute = GetHappinessPerTradeRoute();

	int iNumCities = 0;
	if(iHappinessPerTradeRoute != 0)
	{
		CvCity* pCapitalCity = getCapitalCity();

		// Must have a capital before we can check if other Cities are connected to it!
		if(pCapitalCity != NULL && getNumCities() > 1)
		{
			CvCity* pLoopCity;

			int iLoop;
			for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				if(pLoopCity != pCapitalCity)
				{
					if(pLoopCity->IsConnectedToCapital())
					{
						iNumCities++;
					}
				}
			}
		}
	}
	m_iCityConnectionHappiness = iHappinessPerTradeRoute * iNumCities / 100;	// Bring it out of hundreds
}

//	--------------------------------------------------------------------------------
/// How muchHappiness are we getting from Trade Routes?
int CvPlayer::GetHappinessPerTradeRoute() const
{
	return m_iHappinessPerTradeRouteCount;
}

//	--------------------------------------------------------------------------------
/// Set the amont of Happiness we're getting from Trade Routes
void CvPlayer::SetHappinessPerTradeRoute(int iValue)
{
	m_iHappinessPerTradeRouteCount = iValue;
}

//	--------------------------------------------------------------------------------
/// Change the amont of Happiness we're getting from Trade Routes
void CvPlayer::ChangeHappinessPerTradeRoute(int iChange)
{
	SetHappinessPerTradeRoute(m_iHappinessPerTradeRouteCount + iChange);
}

//	--------------------------------------------------------------------------------
/// How much Happiness are we getting from large cities?
int CvPlayer::GetHappinessPerXPopulation() const
{
	return m_iHappinessPerXPopulation;
}

//	--------------------------------------------------------------------------------
/// Set the amount of Happiness we're getting from large cities
void CvPlayer::SetHappinessPerXPopulation(int iValue)
{
	m_iHappinessPerXPopulation = iValue;
}

//	--------------------------------------------------------------------------------
/// Change the amount of Happiness we're getting from large cities
void CvPlayer::ChangeHappinessPerXPopulation(int iChange)
{
	SetHappinessPerXPopulation(m_iHappinessPerXPopulation + iChange);
}
#if defined(MOD_BALANCE_CORE_POLICIES)
//	--------------------------------------------------------------------------------
/// How much Happiness are we getting from large empires?
int CvPlayer::GetHappinessPerXPopulationGlobal() const
{
	return m_iHappinessPerXPopulationGlobal;
}

//	--------------------------------------------------------------------------------
/// Set the amount of Happiness we're getting from large empires
void CvPlayer::SetHappinessPerXPopulationGlobal(int iValue)
{
	m_iHappinessPerXPopulationGlobal = iValue;
}

//	--------------------------------------------------------------------------------
/// Change the amount of Happiness we're getting from large empires
void CvPlayer::ChangeHappinessPerXPopulationGlobal(int iChange)
{
	SetHappinessPerXPopulationGlobal(m_iHappinessPerXPopulationGlobal + iChange);
}
/// How much Happiness are we getting from large empires?
int CvPlayer::GetIdeologyPoint() const
{
	return m_iIdeologyPoint;
}

//	--------------------------------------------------------------------------------
/// Set the amount of Happiness we're getting from large empires
void CvPlayer::SetIdeologyPoint(int iValue)
{
	m_iIdeologyPoint = iValue;
}

//	--------------------------------------------------------------------------------

void CvPlayer::ChangeIdeologyPoint(int iChange)
{
	SetIdeologyPoint(m_iIdeologyPoint + iChange);
}



/// How much Happiness are we getting from large empires?
int CvPlayer::GetNoXPLossUnitPurchase() const
{
	return m_iNoXPLossUnitPurchase;
}

//	--------------------------------------------------------------------------------

void CvPlayer::SetNoXPLossUnitPurchase(int iValue)
{
	m_iNoXPLossUnitPurchase = iValue;
}

//	
void CvPlayer::ChangeNoXPLossUnitPurchase(int iChange)
{
	SetNoXPLossUnitPurchase(m_iNoXPLossUnitPurchase + iChange);
}


/// How much Happiness are we getting from large empires?
int CvPlayer::GetCSAlliesLowersPolicyNeedWonders() const
{
	return m_iXCSAlliesLowersPolicyNeedWonders;
}

void CvPlayer::ChangePositiveWarScoreTourismMod(int iChange)
{
	if (iChange != 0)
	{
		m_iPositiveWarScoreTourismMod += iChange;
	}
}
int CvPlayer::GetPositiveWarScoreTourismMod() const
{
	return m_iPositiveWarScoreTourismMod;
}

void CvPlayer::ChangeIsNoCSDecayAtWar(int iValue)
{
	if (iValue != 0)
	{
		m_iIsNoCSDecayAtWar += iValue;
	}
}
bool CvPlayer::IsNoCSDecayAtWar() const
{
	return (m_iIsNoCSDecayAtWar > 0);
}
void CvPlayer::ChangeCanBullyFriendlyCS(int iValue)
{
	if (iValue != 0)
	{
		m_iCanBullyFriendlyCS += iValue;
	}
}
bool CvPlayer::IsCanBullyFriendlyCS() const
{
	return (m_iCanBullyFriendlyCS > 0);
}
void CvPlayer::ChangeBullyGlobalCSReduction(int iValue)
{
	if (iValue != 0)
	{
		m_iBullyGlobalCSReduction += iValue;
	}
}
int CvPlayer::GetBullyGlobalCSReduction() const
{
	return m_iBullyGlobalCSReduction;
}
#endif

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
void CvPlayer::ChangeIsVassalsNoRebel(int iValue)
{
	if (iValue != 0)
	{
		m_iIsVassalsNoRebel += iValue;
	}
}
bool CvPlayer::IsVassalsNoRebel() const
{
	return (m_iIsVassalsNoRebel > 0);
}

void CvPlayer::ChangeVassalCSBonusModifier(int iValue)
{
	if (iValue != 0)
	{
		m_iVassalCSBonusModifier += iValue;
	}
}
int CvPlayer::GetVassalCSBonusModifier() const
{
	return m_iVassalCSBonusModifier;
}
#endif
//	--------------------------------------------------------------------------------
/// Change the amount of Happiness we're getting from large empires
void CvPlayer::ChangeCSAlliesLowersPolicyNeedWonders(int iChange)
{
	if(iChange != 0)
	{
		m_iXCSAlliesLowersPolicyNeedWonders += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Happiness from Minors
int CvPlayer::GetHappinessFromMinorCivs() const
{
	return m_iHappinessFromMinorCivs;
}

void CvPlayer::UpdateHappinessFromMinorCivs()
{
	int iHappiness = 0;
	PlayerTypes eMinor;
	for (int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		eMinor = (PlayerTypes)iMinorLoop;
		iHappiness += GetHappinessFromMinor(eMinor);
	}
	m_iHappinessFromMinorCivs = iHappiness;
}

//	--------------------------------------------------------------------------------
/// Happiness from a Minor
int CvPlayer::GetHappinessFromMinor(PlayerTypes eMinor) const
{
	int iAmount = 0;

	if(GET_PLAYER(eMinor).isAlive())
	{
		// Includes flat bonus and any per luxury bonus
		iAmount += GET_PLAYER(eMinor).GetMinorCivAI()->GetCurrentHappinessBonus(GetID());
	}

	return iAmount;
}

//	--------------------------------------------------------------------------------
/// Happiness from Leagues
int CvPlayer::GetHappinessFromLeagues() const
{
	return m_iHappinessFromLeagues;
}

//	--------------------------------------------------------------------------------
/// Happiness from Leagues
void CvPlayer::SetHappinessFromLeagues(int iValue)
{
	m_iHappinessFromLeagues = iValue;
}

//	--------------------------------------------------------------------------------
/// Happiness from Leagues
void CvPlayer::ChangeHappinessFromLeagues(int iChange)
{
	SetHappinessFromLeagues(GetHappinessFromLeagues() + iChange);
}

//	--------------------------------------------------------------------------------
/// Get the global modifier on the espionage progress rate
int CvPlayer::GetEspionageModifier() const
{
	return m_iEspionageModifier;
}

//	--------------------------------------------------------------------------------
/// Change the global modifier on the espionage progress rate
void CvPlayer::ChangeEspionageModifier(int iChange)
{
	m_iEspionageModifier = (m_iEspionageModifier + iChange);
}

//	--------------------------------------------------------------------------------
/// At what rank do spies start the game at?
int CvPlayer::GetStartingSpyRank() const
{
	if(m_iSpyStartingRank > SPY_RANK_SPECIAL_AGENT)
	{
		return SPY_RANK_SPECIAL_AGENT;
	}
	return m_iSpyStartingRank;
}

//	--------------------------------------------------------------------------------
/// Change the rank that spies start the game at
void CvPlayer::ChangeStartingSpyRank(int iChange)
{
	m_iSpyStartingRank = (m_iSpyStartingRank + iChange);
}

#if defined(MOD_RELIGION_CONVERSION_MODIFIERS)
//	--------------------------------------------------------------------------------
/// Get the global modifier on the conversion progress rate
int CvPlayer::GetConversionModifier() const
{
	return m_iConversionModifier;
}

//	--------------------------------------------------------------------------------
/// Change the global modifier on the conversion progress rate
void CvPlayer::ChangeConversionModifier(int iChange)
{
	m_iConversionModifier = (m_iConversionModifier + iChange);
}
#endif

//	--------------------------------------------------------------------------------
/// Extra league votes
int CvPlayer::GetExtraLeagueVotes() const
{
	return m_iExtraLeagueVotes;
}

#if defined(MOD_DIPLOMACY_CITYSTATES)
//	--------------------------------------------------------------------------------
/// Extra league votes from faith
int CvPlayer::GetFaithToVotes() const
{
	return m_iFaithToVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from faith
void CvPlayer::ChangeFaithToVotes(int iChange)
{
	m_iFaithToVotes = iChange;
	CvAssert(m_iFaithToVotes >= 0);
	if (m_iFaithToVotes < 0)
	{
		m_iFaithToVotes = 0;
	}
}

//	--------------------------------------------------------------------------------
/// Extra league votes from faith
int CvPlayer::TestFaithToVotes(int iChange)
{
	int iFaithVotes = 0;
	int iFollowers = 0;
	int iTotalFaithVotes = 0;
	CvGameReligions* pReligions = GC.getGame().GetGameReligions();

	// Number of Cities Following Religion
	ReligionTypes eFoundedReligion = pReligions->GetFounderBenefitsReligion(GetID());
	if(eFoundedReligion != NO_RELIGION)
	{
		if(iChange > 0)
		{
			iFaithVotes = iChange;
			iFollowers = pReligions->GetNumCitiesFollowing(eFoundedReligion);
			int iMaxVotes = pReligions->GetNumReligionsFounded();
			iTotalFaithVotes = (iFollowers / iFaithVotes);
			//Never fewer than one vote.
			if(iTotalFaithVotes < 1)
			{
				iTotalFaithVotes = 1;
			}
			//No more votes than religions in the game - this should scale votes much better.
			else if(iTotalFaithVotes > iMaxVotes)
			{
				iTotalFaithVotes = iMaxVotes;
			}
		}
	}
	return iTotalFaithVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from conquered capitals
int CvPlayer::GetCapitalsToVotes() const
{
	return m_iCapitalsToVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from conquered capitals
void CvPlayer::ChangeCapitalsToVotes(int iChange)
{
	m_iCapitalsToVotes = iChange;
	CvAssert(m_iCapitalsToVotes >= 0);
	if (m_iCapitalsToVotes < 0)
	{
		m_iCapitalsToVotes = 0;
	}
}

//	--------------------------------------------------------------------------------
/// Extra league votes from conquered capitals
int CvPlayer::TestCapitalsToVotes(int iChange)
{
	int iCapitalVotes = 0;

	if(iChange > 0)
	{
		iCapitalVotes = (GetNumCapitalCities() * iChange);
	}
	return iCapitalVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from DoF
int CvPlayer::GetDoFToVotes() const
{
	return m_iDoFToVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from DoF
void CvPlayer::ChangeDoFToVotes(int iChange)
{
	m_iDoFToVotes = iChange;
	CvAssert(m_iDoFToVotes >= 0);
	if (m_iDoFToVotes < 0)
	{
		m_iDoFToVotes = 0;
	}
}

//	--------------------------------------------------------------------------------
/// Extra league votes from DoF
int CvPlayer::TestDoFToVotes(int iChange)
{
	int iDoFToVotes = 0;
	
	if(iChange > 0)
	{
		iDoFToVotes = ((GetDiplomacyAI()->GetNumDoF() / 2) * iChange);
	}
	
	return iDoFToVotes;

}

//	--------------------------------------------------------------------------------
/// Extra league votes from RA
int CvPlayer::GetRAToVotes() const
{
	return m_iRAToVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from RA
void CvPlayer::ChangeRAToVotes(int iChange)
{
	m_iRAToVotes = iChange;
	CvAssert(m_iRAToVotes >= 0);
	if (m_iRAToVotes < 0)
	{
		m_iRAToVotes = 0;
	}
}

//	--------------------------------------------------------------------------------
/// Extra league votes from RA
int CvPlayer::TestRAToVotes(int iChange)
{
	int iRAToVotes = 0;
	
	if(iChange > 0)
	{
		iRAToVotes = (GetDiplomacyAI()->GetNumRA() * iChange);
	}
	
	return iRAToVotes;
}
//	--------------------------------------------------------------------------------
/// Extra league votes from RA
int CvPlayer::GetDefensePactsToVotes() const
{
	return m_iDefensePactsToVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from RA
void CvPlayer::ChangeDefensePactsToVotes(int iChange)
{
	m_iDefensePactsToVotes = iChange;
	CvAssert(m_iDefensePactsToVotes >= 0);
	if (m_iDefensePactsToVotes < 0)
	{
		m_iDefensePactsToVotes = 0;
	}
}
//	--------------------------------------------------------------------------------
/// Extra league votes from Defense Pacts
int CvPlayer::TestDefensePactsToVotes(int iChange)
{
	int iDefensePactsToVotes = 0;
	
	if(iChange > 0)
	{
		iDefensePactsToVotes = (GetDiplomacyAI()->GetNumDefensePacts() * iChange);
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		if (MOD_DIPLOMACY_CIV4_FEATURES)
		{
			iDefensePactsToVotes += GET_TEAM(getTeam()).GetNumVassals();
		}
#endif
	}
	
	return iDefensePactsToVotes;
}

//	--------------------------------------------------------------------------------
/// Extra influence from GPs
int CvPlayer::GetGPExpendInfluence() const
{
	return m_iGPExpendInfluence;
}

//	--------------------------------------------------------------------------------
/// Extra influence from GPs
void CvPlayer::ChangeGPExpendInfluence(int iChange)
{
	m_iGPExpendInfluence += iChange;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from embassy
int CvPlayer::GetImprovementLeagueVotes() const
{
	return m_iImprovementLeagueVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from embassy
void CvPlayer::ChangeImprovementLeagueVotes(int iChange)
{
	m_iImprovementLeagueVotes += iChange;
	CvAssert(m_iImprovementLeagueVotes >= 0);
	if (m_iImprovementLeagueVotes < 0)
	{
		m_iImprovementLeagueVotes = 0;
	}
}

/// League Bonuses for Poor Players
void CvPlayer::SetLeagueArt(bool bValue)
{
	if(m_bIsLeagueArt != bValue)
	{
		m_bIsLeagueArt = bValue;
	}
}

bool CvPlayer::IsLeagueArt() const
{
	return m_bIsLeagueArt;
}

/// League Bonuses for Poor Players
void CvPlayer::SetLeagueScholar(bool bValue)
{
	if(m_bIsLeagueScholar != bValue)
	{
		m_bIsLeagueScholar = bValue;
	}
}

bool CvPlayer::IsLeagueScholar() const
{
	return m_bIsLeagueScholar;
}


/// League Bonuses for Poor Players
void CvPlayer::SetLeagueAid(bool bValue)
{
	if(m_bIsLeagueAid != bValue)
	{
		m_bIsLeagueAid = bValue;
	}
}

bool CvPlayer::IsLeagueAid() const
{
	return m_bIsLeagueAid;
}

/// Process League Bonuses for Poor Players
void CvPlayer::ProcessLeagueResolutions()
{
	CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
	if(pLeague == NULL)
	{
		return;
	}
	if(IsLeagueAid())
	{
		if ( pLeague->GetArtsyGreatPersonRateModifier() > 0)
		{
			//Production and Culture
#if defined(MOD_BALANCE_CORE)
			if(AidRankGeneric(1) == GetID()) // calculate only Culture related score
#else
			if(AidRank() == GetID())
#endif
			{
#if defined(MOD_BALANCE_CORE)
				// calculate modifier that is actually related to Resolution's ArtsyGreatPersonRateMod parameter
				int iScoreMod = pLeague->GetArtsyGreatPersonRateModifier() * ScoreDifferencePercent(1) / 100;
#endif
				CvCity* pLoopCity;
				int iLoop;
				int iAid = 0;
				for(pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
				{
#if defined(MOD_BALANCE_CORE)
					int iAid = (iScoreMod - pLoopCity->GetTotalArtsyAid());
#else
					int iAid = (ScoreDifference() - pLoopCity->GetTotalArtsyAid());
#endif
					if(iAid != 0)
					{
						pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_PRODUCTION, iAid);

						pLoopCity->ChangeTotalArtsyAid(iAid);
					}

				}
#if defined(MOD_BALANCE_CORE)
				iAid = iScoreMod - GetLeagueCultureCityModifier();
#else
				iAid = ScoreDifference() - GetLeagueCultureCityModifier();
#endif
				if(iAid != 0)
				{
					ChangeLeagueCultureCityModifier(iAid);
				}
			}
			//Remove bonuses from filty first-worlders.
#if defined(MOD_BALANCE_CORE)
			if(AidRankGeneric(1) != GetID()) // calculate only Culture related score
#else
			if(AidRank() != GetID())
#endif
			{
				CvCity* pLoopCity;
				int iLoop;
				for(pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
				{
					if(pLoopCity->GetTotalArtsyAid() != 0)
					{

						pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_PRODUCTION, pLoopCity->GetTotalArtsyAid() * -1);

						pLoopCity->SetTotalArtsyAid(0);
					}
				}
				if(GetLeagueCultureCityModifier() != 0)
				{
					ChangeLeagueCultureCityModifier(GetLeagueCultureCityModifier() * -1);
				}
			}
		}
		else if (pLeague && pLeague->GetScienceyGreatPersonRateModifier() > 0)
		{
			//Food and Research
#if defined(MOD_BALANCE_CORE)
			if(AidRankGeneric(2) == GetID()) // calculate only Research related score
#else
			if(AidRank() == GetID())
#endif
			{
#if defined(MOD_BALANCE_CORE)
				// calculate modifier that is actually related to Resolution's ScienceyGreatPersonRateMod parameter
				int iScoreMod = pLeague->GetScienceyGreatPersonRateModifier() * ScoreDifferencePercent(2) / 100;
#endif
				CvCity* pLoopCity;
				int iLoop;
				int iAid = 0;
				for(pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
				{
#if defined(MOD_BALANCE_CORE)
					iAid = (iScoreMod - pLoopCity->GetTotalScienceyAid());
#else
					iAid = (ScoreDifference() - pLoopCity->GetTotalScienceyAid());
#endif
					if(iAid != 0)
					{
						pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_FOOD, iAid);

						pLoopCity->ChangeTotalScienceyAid(iAid);
					}
				}
				//Global
#if defined(MOD_BALANCE_CORE)
				iAid = (iScoreMod - GetScienceRateFromLeagueAid());
#else
				iAid = (ScoreDifference() - GetScienceRateFromLeagueAid());
#endif
				if(iAid != 0)
				{
					ChangeScienceRateFromLeagueAid(iAid);
				}
			}
			//Remove bonuses from filty first-worlders.
#if defined(MOD_BALANCE_CORE)
			if(AidRankGeneric(2) != GetID()) // calculate only Research related score
#else
			if(AidRank() != GetID())
#endif
			{
				CvCity* pLoopCity;
				int iLoop;
				for(pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
				{
					if(pLoopCity->GetTotalScienceyAid() != 0)
					{	
						pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_FOOD, (pLoopCity->GetTotalScienceyAid() * -1));

						pLoopCity->SetTotalScienceyAid(0);
					}
				}
				//Global
				if(GetScienceRateFromLeagueAid() != 0)
				{
					ChangeScienceRateFromLeagueAid(GetScienceRateFromLeagueAid() * -1);
				}
			}
		}
	}
	else if(!IsLeagueAid())
	{
		CvCity* pLoopCity;
		int iLoop;
		for(pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
		{
			if(pLoopCity->GetTotalScienceyAid() != 0)
			{	
				pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_FOOD, (pLoopCity->GetTotalScienceyAid() * -1));

				pLoopCity->SetTotalScienceyAid(0);
			}
			if(pLoopCity->GetTotalArtsyAid() != 0)
			{
				pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_PRODUCTION, pLoopCity->GetTotalArtsyAid() * -1);

				pLoopCity->SetTotalArtsyAid(0);
			}
		}
		//Global
		if(GetScienceRateFromLeagueAid() != 0)
		{
			ChangeScienceRateFromLeagueAid(GetScienceRateFromLeagueAid() * -1);
		}
		if(GetLeagueCultureCityModifier() != 0)
		{
			ChangeLeagueCultureCityModifier(GetLeagueCultureCityModifier() * -1);
		}
	}
	if(IsLeagueArt())
	{
		//Extra Science From League (Art)
		if(pLeague->GetWorldWonderYieldChange(YIELD_CULTURE) > 0)
		{
			CvCity* pLoopCity;
			int iLoop;
			for(pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
			{
				int iSciencePerWork = GET_PLAYER(GetID()).GetGreatWorkYieldChange(YIELD_SCIENCE);
				int iTotalScienceFromArt = (pLoopCity->GetCityCulture()->GetNumGreatWorks() * iSciencePerWork);
				int iAid = iTotalScienceFromArt - pLoopCity->GetBaseYieldRateFromLeague(YIELD_SCIENCE);
				if(iAid != 0)
				{
					pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_SCIENCE, iAid);
				}
			}
		}
	}
	else if(!IsLeagueArt())
	{
		CvCity* pLoopCity;
		int iLoop;
		for(pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
		{
			if(pLoopCity->GetBaseYieldRateFromLeague(YIELD_SCIENCE) != 0)
			{
				pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_SCIENCE, (pLoopCity->GetBaseYieldRateFromLeague(YIELD_SCIENCE) * -1));
			}
		}
	}
}
#if defined(MOD_BALANCE_CORE)
//	League Bonuses for Poor Players - modified version of CvPlayer::AidRank()
//	Calculates if the player is below median score depending on type of score
//	eType 0 total score, 1 art, 2 science
PlayerTypes CvPlayer::AidRankGeneric(int eType)
{
	int iRank = 0;
	int iMajorCivs = 0;
	CvWeightedVector<PlayerTypes, MAX_CIV_PLAYERS, true> veMajorRankings;
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		CvPlayer* pMajorLoop = &GET_PLAYER(eLoopPlayer);
	
		if(pMajorLoop->isAlive() && !pMajorLoop->isMinorCiv())
		{
			switch(eType)
			{
			case 1:
				iRank = pMajorLoop->GetScoreFromPolicies() + pMajorLoop->GetScoreFromGreatWorks();
				break;
			case 2:
				iRank = pMajorLoop->GetScoreFromTechs() + pMajorLoop->GetScoreFromFutureTech();
				break;
			default:
				iRank = pMajorLoop->GetScore();
			}
			if(iRank > 0)
			{
				veMajorRankings.push_back(eLoopPlayer, iRank);
				iMajorCivs++;
			}
		}
	}

	//Find the median of the Civs.
	int iTopTier = (iMajorCivs / 2);
	if(iTopTier <= 0)
	{
		iTopTier = 1;
	}

	veMajorRankings.SortItems();
	if(veMajorRankings.size() != 0)
	{
		for(int iRanking = 0; iRanking < veMajorRankings.size(); iRanking++)
		{
			if(veMajorRankings.GetElement(iRanking) == GetID())
			{
				//Are we in the bottom 50% of Civs? If so, we need aid!
				if(iRanking >= iTopTier)
				{
					return GetID();
				}
			}
		}
	}
	return NO_PLAYER;
}
#endif
/// League Bonuses for Poor Players
PlayerTypes CvPlayer::AidRank()
{
#if defined(MOD_BALANCE_CORE)
	return AidRankGeneric();
#else
	int iRank = 0;
	int iMajorCivs = 0;
	CvWeightedVector<PlayerTypes, MAX_CIV_PLAYERS, true> veMajorRankings;
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		CvPlayer* pMajorLoop = &GET_PLAYER(eLoopPlayer);
	
		if(pMajorLoop->isAlive() && !pMajorLoop->isMinorCiv())
		{
			iRank = pMajorLoop->GetScore();

			if(iRank > 0)
			{
				veMajorRankings.push_back(eLoopPlayer, iRank);
				iMajorCivs++;
			}
		}
	}

	//Find the median of the Civs.
	int iTopTier = (iMajorCivs / 2);
	if(iTopTier <= 0)
	{
		iTopTier = 1;
	}

	veMajorRankings.SortItems();
	if(veMajorRankings.size() != 0)
	{
		for(int iRanking = 0; iRanking < veMajorRankings.size(); iRanking++)
		{
			if(veMajorRankings.GetElement(iRanking) == GetID())
			{
				//Are we in the bottom 50% of Civs? If so, we need aid!
				if(iRanking >= iTopTier)
				{
					return GetID();
				}
			}
		}
	}
	return NO_PLAYER;
#endif
}
#if defined(MOD_BALANCE_CORE)
//	League Bonuses for Poor Players - modified version of CvPlayer::ScoreDifference()
//	Calculates difference between player's score and best score using percentage scale
//	0% - best score, 100% - worst score
int CvPlayer::ScoreDifferencePercent(int eType)
{
	int iScore = 0;
	int iBestScore = 0;
	int iWorstScore = INT_MAX;
	int iPlayerScore = 0;
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		CvPlayer* pMajorLoop = &GET_PLAYER(eLoopPlayer);
		if(pMajorLoop->isAlive() && !pMajorLoop->isMinorCiv())
		{
			switch(eType)
			{
			case 1:
				iScore = pMajorLoop->GetScoreFromPolicies() + pMajorLoop->GetScoreFromGreatWorks();
				break;
			case 2:
				iScore = pMajorLoop->GetScoreFromTechs() + pMajorLoop->GetScoreFromFutureTech();
				break;
			default:
				iScore = pMajorLoop->GetScore();
			}
			if(iScore > iBestScore) iBestScore = iScore;
			if(iScore < iWorstScore) iWorstScore = iScore;
			if(GetID() == eLoopPlayer) iPlayerScore = iScore;
		}
	}
	if(iBestScore == 0) return 0; // nothing to scale
	// rescale to 0..100
	return MapToPercent(iPlayerScore, iBestScore, iWorstScore);
}
#endif
/// League Bonuses for Poor Players
int CvPlayer::ScoreDifference()
{
	int iScore = 0;
	int iBestScore = 0;
	int iMajors = 0;
	int iPlayerScore = 0;
	int iDifference = 0;
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		CvPlayer* pMajorLoop = &GET_PLAYER(eLoopPlayer);

		if(pMajorLoop->isAlive() && !pMajorLoop->isMinorCiv())
		{
			iScore = pMajorLoop->GetScore();
			iMajors++;

			if(iScore > iBestScore)
			{
				iBestScore = iScore;
			}
		}
	}
	if(iBestScore > 0)
	{
		iPlayerScore = GET_PLAYER(GetID()).GetScore();
		iDifference = iBestScore - iPlayerScore;
		int iMax = /*30*/ GC.getLEAGUE_AID_MAX();
		int iMin = /*10*/ (GC.getLEAGUE_AID_MAX() / 3);

		//Bring down to % value.
		iDifference /= 50;
		//Never lower than 10%
		if(iDifference < iMin)
		{
			iDifference = iMin;
		}
		//Never higher than 30%
		if(iDifference > iMax)
		{
			iDifference = iMax;
		}
	}
	return iDifference;
}

//	--------------------------------------------------------------------------------
/// Extra science from CS
int CvPlayer::GetScienceRateFromMinorAllies() const
{
	return m_iScienceRateFromLeague;
}

//	--------------------------------------------------------------------------------
/// Extra science from CS
void CvPlayer::ChangeScienceRateFromMinorAllies(int iChange)
{
	SetScienceRateFromMinorAllies(GetScienceRateFromMinorAllies() + iChange);
}

/// Extra science from CS
void CvPlayer::SetScienceRateFromMinorAllies(int iValue)
{
	if(GetScienceRateFromMinorAllies() != iValue)
		m_iScienceRateFromLeague = iValue;
}

//	--------------------------------------------------------------------------------
/// Extra science from aid
int CvPlayer::GetScienceRateFromLeagueAid() const
{
	return m_iScienceRateFromLeagueAid;
}

//	--------------------------------------------------------------------------------
/// Extra science from aid
void CvPlayer::ChangeScienceRateFromLeagueAid(int iChange)
{
	SetScienceRateFromLeagueAid(GetScienceRateFromLeagueAid() + iChange);
}
//	--------------------------------------------------------------------------------
/// Extra science from aid
void CvPlayer::SetScienceRateFromLeagueAid(int iValue)
{
	if(GetScienceRateFromLeagueAid() != iValue)
		m_iScienceRateFromLeagueAid = iValue;
}
#endif

//	--------------------------------------------------------------------------------
/// Extra league votes
void CvPlayer::ChangeExtraLeagueVotes(int iChange)
{
	m_iExtraLeagueVotes += iChange;
	CvAssert(m_iExtraLeagueVotes >= 0);
	if (m_iExtraLeagueVotes < 0)
	{
		m_iExtraLeagueVotes = 0;
	}
}

//	--------------------------------------------------------------------------------
/// How much weaker do Units get when wounded?
int CvPlayer::GetWoundedUnitDamageMod() const
{
	return m_iWoundedUnitDamageMod;
}

//	--------------------------------------------------------------------------------
/// How much weaker do Units get when wounded?
void CvPlayer::SetWoundedUnitDamageMod(int iValue)
{
	m_iWoundedUnitDamageMod = iValue;

	if(m_iWoundedUnitDamageMod < /*50*/ -GC.getWOUNDED_DAMAGE_MULTIPLIER())
	{
		m_iWoundedUnitDamageMod = /*50*/ -GC.getWOUNDED_DAMAGE_MULTIPLIER();
	}
}

//	--------------------------------------------------------------------------------
/// How much weaker do Units get when wounded?
void CvPlayer::ChangeWoundedUnitDamageMod(int iChange)
{
	SetWoundedUnitDamageMod(m_iWoundedUnitDamageMod + iChange);
}

//	--------------------------------------------------------------------------------
/// Unit upgrade cost mod
int CvPlayer::GetUnitUpgradeCostMod() const
{
	return m_iUnitUpgradeCostMod;
}

//	--------------------------------------------------------------------------------
/// Unit upgrade cost mod
void CvPlayer::SetUnitUpgradeCostMod(int iValue)
{
	m_iUnitUpgradeCostMod = iValue;

	if(m_iUnitUpgradeCostMod < /*-75*/ GC.getUNIT_UPGRADE_COST_DISCOUNT_MAX())
		m_iUnitUpgradeCostMod = /*-75*/ GC.getUNIT_UPGRADE_COST_DISCOUNT_MAX();
}

//	--------------------------------------------------------------------------------
/// Unit upgrade cost mod
void CvPlayer::ChangeUnitUpgradeCostMod(int iChange)
{
	SetUnitUpgradeCostMod(m_iUnitUpgradeCostMod + iChange);
}

//	--------------------------------------------------------------------------------
/// How much of a combat bonus do we get VS Barbarian Units?
int CvPlayer::GetBarbarianCombatBonus() const
{
	return m_iBarbarianCombatBonus;
}

//	--------------------------------------------------------------------------------
/// Sets how much of a combat bonus we get VS Barbarian Units
void CvPlayer::SetBarbarianCombatBonus(int iValue)
{
	m_iBarbarianCombatBonus = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes how much of a combat bonus we get VS Barbarian Units
void CvPlayer::ChangeBarbarianCombatBonus(int iChange)
{
	SetBarbarianCombatBonus(m_iBarbarianCombatBonus + iChange);
}

//	--------------------------------------------------------------------------------
/// Do we always see where Barb Camps appear?
bool CvPlayer::IsAlwaysSeeBarbCamps() const
{
	return m_iAlwaysSeeBarbCampsCount > 0;
}

//	--------------------------------------------------------------------------------
/// Sets if we always see where Barb Camps appear
void CvPlayer::SetAlwaysSeeBarbCampsCount(int iValue)
{
	m_iAlwaysSeeBarbCampsCount = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes if we always see where Barb Camps appear
void CvPlayer::ChangeAlwaysSeeBarbCampsCount(int iChange)
{
	SetAlwaysSeeBarbCampsCount(m_iAlwaysSeeBarbCampsCount + iChange);
}

//	--------------------------------------------------------------------------------
CvPlayerTechs* CvPlayer::GetPlayerTechs() const
{
	return m_pPlayerTechs;
}

//	--------------------------------------------------------------------------------
CvPlayerPolicies* CvPlayer::GetPlayerPolicies() const
{
	return m_pPlayerPolicies;
}

//	--------------------------------------------------------------------------------
CvPlayerTraits* CvPlayer::GetPlayerTraits() const
{
	return m_pTraits;
}

//	--------------------------------------------------------------------------------
CvFlavorManager* CvPlayer::GetFlavorManager() const
{
	return m_pFlavorManager;
}

//	--------------------------------------------------------------------------------
CvTacticalAI* CvPlayer::GetTacticalAI() const
{
	return m_pTacticalAI;
}

//	--------------------------------------------------------------------------------
CvHomelandAI* CvPlayer::GetHomelandAI() const
{
	return m_pHomelandAI;
}

#if defined(MOD_API_EXTENSIONS)
bool CvPlayer::grantPolicy(PolicyTypes iPolicy, bool bFree)
{
	if (!HasPolicy(iPolicy)) {
		setHasPolicy(iPolicy, true, bFree);
		
		return true;
	}
	
	return false;
}

bool CvPlayer::revokePolicy(PolicyTypes iPolicy)
{
	if (HasPolicy(iPolicy)) {
		setHasPolicy(iPolicy, false, m_pPlayerPolicies->IsFreePolicy(iPolicy));
		
		return true;
	}
	
	return false;
}

bool CvPlayer::swapPolicy(PolicyTypes iNewPolicy, PolicyTypes iOldPolicy)
{
	bool bWasFree = m_pPlayerPolicies->IsFreePolicy(iOldPolicy);
	
	if (!HasPolicy(iNewPolicy) && revokePolicy(iOldPolicy)) {
		return grantPolicy(iNewPolicy, bWasFree);
	}
	
	return false;
}
#endif

//	--------------------------------------------------------------------------------
#if defined(MOD_API_EXTENSIONS)
void CvPlayer::setHasPolicy(PolicyTypes eIndex, bool bNewValue, bool bFree)
#else
void CvPlayer::setHasPolicy(PolicyTypes eIndex, bool bNewValue)
#endif
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumPolicyInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	
	if(m_pPlayerPolicies->HasPolicy(eIndex) != bNewValue)
	{
#if defined(MOD_API_EXTENSIONS)
		m_pPlayerPolicies->SetPolicy(eIndex, bNewValue, bFree);
#else
		m_pPlayerPolicies->SetPolicy(eIndex, bNewValue);
#endif
		processPolicies(eIndex, bNewValue ? 1 : -1);
#if defined(MOD_BALANCE_CORE)
		GetPlayerPolicies()->ClearCache();
#endif
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNextPolicyCost() const
{
	return m_iCostNextPolicy;
}

//	--------------------------------------------------------------------------------
void CvPlayer::DoUpdateNextPolicyCost()
{
	m_iCostNextPolicy = GetPlayerPolicies()->GetNextPolicyCost();
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canAdoptPolicy(PolicyTypes eIndex) const
{
	return GetPlayerPolicies()->CanAdoptPolicy(eIndex);
}

//	--------------------------------------------------------------------------------
void CvPlayer::doAdoptPolicy(PolicyTypes ePolicy)
{
	CvPolicyEntry* pkPolicyInfo = GC.getPolicyInfo(ePolicy);
	CvAssert(pkPolicyInfo != NULL);
	if(pkPolicyInfo == NULL)
		return;

	// Can we actually adopt this?
	if(!canAdoptPolicy(ePolicy))
		return;

	bool bTenet = pkPolicyInfo->GetLevel() > 0;

	// Pay Culture cost - if applicable
	if (bTenet && GetNumFreeTenets() > 0)
	{
		ChangeNumFreeTenets(-1, false);
	}
	else if (GetNumFreePolicies() > 0)
	{
		ChangeNumFreePolicies(-1);
	}
	else
	{
		changeJONSCulture(-getNextPolicyCost());
	}

	setHasPolicy(ePolicy, true);

	// Update cost if trying to buy another policy this turn
	DoUpdateNextPolicyCost();

	// Branch unlocked
	PolicyBranchTypes ePolicyBranch = (PolicyBranchTypes) pkPolicyInfo->GetPolicyBranchType();
	GetPlayerPolicies()->SetPolicyBranchUnlocked(ePolicyBranch, true, false);

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	// This Dirty bit must only be set when changing something for the active player
	if(GC.getGame().getActivePlayer() == GetID())
	{
		GC.GetEngineUserInterface()->setDirty(Policies_DIRTY_BIT, true);
	}
#if defined(MOD_BALANCE_CORE)
	CvCity* pCapital = getCapitalCity();
	int iPolicyGEorGM = GetPlayerTraits()->GetPolicyGEorGM();
	if (iPolicyGEorGM > 0 && pCapital != NULL)
	{
		doPolicyGEorGM(iPolicyGEorGM);
	}
	int iLoop;
	doInstantYield(INSTANT_YIELD_TYPE_POLICY_UNLOCK, false, NO_GREATPERSON, NO_BUILDING, 0, false);
	doInstantGreatPersonProgress(INSTANT_YIELD_TYPE_POLICY_UNLOCK);

	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) 
	{
		pLoopCity->GetCityCitizens()->SetDirty(true);
	}
#endif

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(ePolicy);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		LuaSupport::CallHook(pkScriptSystem, "PlayerAdoptPolicy", args.get(), bResult);
	}

	updateYield();		// Policies can change the yield
}

//	--------------------------------------------------------------------------------
/// Empire in Anarchy?
bool CvPlayer::IsAnarchy() const
{
	return GetAnarchyNumTurns() > 0;
}

//	--------------------------------------------------------------------------------
/// Empire in Anarchy?
int CvPlayer::GetAnarchyNumTurns() const
{
	return m_iAnarchyNumTurns;
}

//	--------------------------------------------------------------------------------
/// Empire in Anarchy?
void CvPlayer::SetAnarchyNumTurns(int iValue)
{
	if(iValue != GetAnarchyNumTurns())
	{
		if (iValue > 0 && m_iAnarchyNumTurns <= 0)
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerAnarchy, GetID(), true, iValue);
		else if (iValue <= 0 && GetAnarchyNumTurns() > 0)
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerAnarchy, GetID(), false, 0);

		m_iAnarchyNumTurns = iValue;

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Empire in Anarchy?
void CvPlayer::ChangeAnarchyNumTurns(int iChange)
{
	SetAnarchyNumTurns(GetAnarchyNumTurns() + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getAdvancedStartPoints() const
{
	return m_iAdvancedStartPoints;
}

//	--------------------------------------------------------------------------------
void CvPlayer::setAdvancedStartPoints(int iNewValue)
{
	if(getAdvancedStartPoints() != iNewValue)
	{
		m_iAdvancedStartPoints = iNewValue;

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(MiscButtons_DIRTY_BIT, true);
			GC.GetEngineUserInterface()->setDirty(SelectionButtons_DIRTY_BIT, true);
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeAdvancedStartPoints(int iChange)
{
	setAdvancedStartPoints(getAdvancedStartPoints() + iChange);
}


//	--------------------------------------------------------------------------------
// Get Attack Bonus for a certain period of time
int CvPlayer::GetAttackBonusTurns() const
{
	return m_iAttackBonusTurns;
}

//	--------------------------------------------------------------------------------
// Set Attack Bonus for a certain period of time
void CvPlayer::ChangeAttackBonusTurns(int iChange)
{
	if(iChange != 0)
	{
		m_iAttackBonusTurns += iChange;
	}
}

//	--------------------------------------------------------------------------------
// Get Culture Bonus for a certain period of time
int CvPlayer::GetCultureBonusTurns() const
{
	return m_iCultureBonusTurns;
}

//	--------------------------------------------------------------------------------
// Set Culture Bonus for a certain period of time
void CvPlayer::ChangeCultureBonusTurns(int iChange)
{
	if (iChange != 0)
	{
		m_iCultureBonusTurns += iChange;
	}
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
// Get Culture Bonus for a certain period of time
int CvPlayer::GetCultureBonusTurnsConquest() const
{
	return m_iCultureBonusTurnsConquest;
}

//	--------------------------------------------------------------------------------
// Set Culture Bonus for a certain period of time
void CvPlayer::ChangeCultureBonusTurnsConquest(int iChange)
{
	if (iChange != 0)
	{
		m_iCultureBonusTurnsConquest += iChange;
	}
}

//	--------------------------------------------------------------------------------
// Get Culture Bonus for a certain period of time
int CvPlayer::GetProductionBonusTurnsConquest() const
{
	return m_iProductionBonusTurnsConquest;
}

//	--------------------------------------------------------------------------------
// Set Culture Bonus for a certain period of time
void CvPlayer::ChangeProductionBonusTurnsConquest(int iChange)
{
	if (iChange != 0)
	{
		m_iProductionBonusTurnsConquest += iChange;
	}
}
#endif
//	--------------------------------------------------------------------------------
// Get Tourism Bonus for a certain period of time
int CvPlayer::GetTourismBonusTurns() const
{
	return m_iTourismBonusTurns;
}

//	--------------------------------------------------------------------------------
// Set Tourism Bonus for a certain period of time
void CvPlayer::ChangeTourismBonusTurns(int iChange)
{
	if (iChange != 0)
	{
		m_iTourismBonusTurns += iChange;
	}
}

#if defined(MOD_DIPLOMACY_CITYSTATES)
//	--------------------------------------------------------------------------------
void CvPlayer::DoProcessVotes()
{
	if(GC.getGame().isOption(GAMEOPTION_NO_LEAGUES))
	{
		return;
	}
	ChangeFaithToVotes(0);
	ChangeCapitalsToVotes(0);
	ChangeDoFToVotes(0);
	ChangeRAToVotes(0);
	ChangeDefensePactsToVotes(0);

	// Minors and Barbs don't matter
	if(!isMinorCiv() && !isBarbarian())
	{
		// Loop through Cities
		int iLoop;
		CvCity* pLoopCity;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
			{
				const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
				CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
			
				// Has this Building
				if(pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
				{
					if(pkBuildingInfo->GetFaithToVotes() > 0)
					{
						int iTestFaith = TestFaithToVotes(pkBuildingInfo->GetFaithToVotes());
						ChangeFaithToVotes(iTestFaith);
					}
					if(pkBuildingInfo->GetCapitalsToVotes() > 0)
					{
						int iTestCapital = TestCapitalsToVotes(pkBuildingInfo->GetCapitalsToVotes());
						ChangeCapitalsToVotes(iTestCapital);	
					}
					if(pkBuildingInfo->GetDoFToVotes() > 0)
					{
						int iTestDoF = TestDoFToVotes(pkBuildingInfo->GetDoFToVotes());
						ChangeDoFToVotes(iTestDoF);
					}
					if(pkBuildingInfo->GetRAToVotes() > 0)
					{
						int iTestRA = TestRAToVotes(pkBuildingInfo->GetRAToVotes());
						ChangeRAToVotes(iTestRA);
					}
					if(pkBuildingInfo->GetDPToVotes() > 0)
					{
						int iTestDP = TestDefensePactsToVotes(pkBuildingInfo->GetDPToVotes());
						ChangeDefensePactsToVotes(iTestDP);
					}
				}
			}
		}
	}
}
#endif
#if defined(MOD_BALANCE_CORE_YIELDS)
void CvPlayer::DoChangeGreatGeneralRate()
{
	//Check for buildings and beliefs that add Great General points.
	int iLoop;
	int iGreatGeneralPoints = 0;

	UnitClassTypes eUnitClassGeneral = (UnitClassTypes)GC.getInfoTypeForString("UNITCLASS_GREAT_GENERAL");
	GreatPersonTypes eGreatPerson = GetGreatPersonFromUnitClass(eUnitClassGeneral);
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			iGreatGeneralPoints += pLoopCity->getYieldRate(YIELD_GREAT_GENERAL_POINTS, false);

			const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(pLoopCity->GetCityReligions()->GetReligiousMajority(), pLoopCity->getOwner());
			if(pReligion)
			{
				int iReligionYieldChange = pReligion->m_Beliefs.GetCityYieldChange(pLoopCity->getPopulation(), YIELD_GREAT_GENERAL_POINTS, GetID(), pLoopCity);
				if(iReligionYieldChange > 0)
				{
					iGreatGeneralPoints += iReligionYieldChange;
				}
				BeliefTypes eSecondaryPantheon = pLoopCity->GetCityReligions()->GetSecondaryReligionPantheonBelief();
				if (eSecondaryPantheon != NO_BELIEF && pLoopCity->getPopulation() >= GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetMinPopulation())
				{
					iReligionYieldChange = GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetCityYieldChange(YIELD_GREAT_GENERAL_POINTS);
					if(iReligionYieldChange > 0)
					{
						iGreatGeneralPoints += iReligionYieldChange;
					}
				}
				if (eGreatPerson != NO_GREATPERSON)
				{
					iGreatGeneralPoints += pReligion->m_Beliefs.GetGreatPersonPoints(eGreatPerson, pLoopCity->getOwner(), pLoopCity, true);
				}
			}
		}
	}
	//Check for policies that add Great General points.
	for(int iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)
	{
		PolicyTypes pPolicy = (PolicyTypes)iPolicyLoop;
		CvPolicyEntry* pkPolicyInfo = GC.getPolicyInfo(pPolicy);
		if(pkPolicyInfo)
		{
			if(GetPlayerPolicies()->HasPolicy(pPolicy) && !GetPlayerPolicies()->IsPolicyBlocked(pPolicy))
			{
				if(pkPolicyInfo->GetCityYieldChange(YIELD_GREAT_GENERAL_POINTS) > 0)
				{
					for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if(pLoopCity != NULL)
						{
							iGreatGeneralPoints += pkPolicyInfo->GetCityYieldChange(YIELD_GREAT_GENERAL_POINTS);
						}
					}
				}
			}
		}
	}
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
#if defined(MOD_UNITS_XP_TIMES_100)
	changeCombatExperienceTimes100(iGreatGeneralPoints * 100);
#else
	changeCombatExperience(iGreatGeneralPoints);
#endif
#else
#if defined(MOD_UNITS_XP_TIMES_100)
	changeCombatExperienceTimes100(iGreatGeneralPoints * 100);
#else
	changeCombatExperience(iGreatGeneralPoints);
#endif
#endif
}
void CvPlayer::DoChangeGreatAdmiralRate()
{
	//Check for buildings and beliefs that add Great General points.
	int iLoop;
	int iGreatAdmiralPoints = 0;

	UnitClassTypes eUnitClassAdmiral = (UnitClassTypes)GC.getInfoTypeForString("UNITCLASS_GREAT_ADMIRAL");
	GreatPersonTypes eGreatPerson = GetGreatPersonFromUnitClass(eUnitClassAdmiral);

	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			iGreatAdmiralPoints += pLoopCity->getYieldRate(YIELD_GREAT_ADMIRAL_POINTS, false);
			
			const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(pLoopCity->GetCityReligions()->GetReligiousMajority(), pLoopCity->getOwner());
			if(pReligion)
			{
				int iReligionYieldChange = pReligion->m_Beliefs.GetCityYieldChange(pLoopCity->getPopulation(), YIELD_GREAT_ADMIRAL_POINTS, GetID(), pLoopCity);
				if(iReligionYieldChange > 0)
				{
					iGreatAdmiralPoints += iReligionYieldChange;
				}
				BeliefTypes eSecondaryPantheon = pLoopCity->GetCityReligions()->GetSecondaryReligionPantheonBelief();
				if (eSecondaryPantheon != NO_BELIEF && pLoopCity->getPopulation() >= GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetMinPopulation())
				{
					iReligionYieldChange = GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetCityYieldChange(YIELD_GREAT_ADMIRAL_POINTS);
					if(iReligionYieldChange > 0)
					{
						iGreatAdmiralPoints += iReligionYieldChange;
					}
				}

				if (eGreatPerson != NO_GREATPERSON)
				{
					iGreatAdmiralPoints += pReligion->m_Beliefs.GetGreatPersonPoints(eGreatPerson, pLoopCity->getOwner(), pLoopCity, true);
				}
			}
		}
	}
	//Check for policies that add Great Admiral points.
	for(int iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)
	{
		PolicyTypes pPolicy = (PolicyTypes)iPolicyLoop;
		CvPolicyEntry* pkPolicyInfo = GC.getPolicyInfo(pPolicy);
		if(pkPolicyInfo)
		{
			if(GetPlayerPolicies()->HasPolicy(pPolicy) && !GetPlayerPolicies()->IsPolicyBlocked(pPolicy))
			{
				if (pkPolicyInfo->GetCityYieldChange(YIELD_GREAT_ADMIRAL_POINTS) > 0)
				{
					for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if(pLoopCity != NULL)
						{
							iGreatAdmiralPoints += pkPolicyInfo->GetCityYieldChange(YIELD_GREAT_ADMIRAL_POINTS);
						}
					}
				}
			}
		}
	}
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
#if defined(MOD_UNITS_XP_TIMES_100)
	changeNavalCombatExperienceTimes100(iGreatAdmiralPoints * 100);
#else
	changeNavalCombatExperience(iGreatAdmiralPoints);
#endif
#else
#if defined(MOD_UNITS_XP_TIMES_100)
	changeNavalCombatExperienceTimes100(iGreatAdmiralPoints * 100);
#else
	changeNavalCombatExperience(iGreatAdmiralPoints);
#endif
#endif
}
#endif
//	--------------------------------------------------------------------------------
/// Update all Golden-Age related stuff
void CvPlayer::DoProcessGoldenAge()
{
	if(GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS))
	{
		return;
	}

	// Minors and Barbs can't get GAs
	if(!isMinorCiv() && !isBarbarian())
	{
		// Already in a GA - don't decrement counter while in Anarchy
		if(getGoldenAgeTurns() > 0)
		{
			if(!IsAnarchy())
			{
				changeGoldenAgeTurns(-1);
			}
		}
#if defined(MOD_BALANCE_CORE)
		if (MOD_BALANCE_CORE_HAPPINESS_NATIONAL || getGoldenAgeTurns() <= 0)
#else
		// Not in GA
		else
		{
#endif
			// Note: This will actually REDUCE the GA meter if the player is running in the red
			ChangeGoldenAgeProgressMeter(GetHappinessForGAP());
			
#if defined(MOD_API_UNIFIED_YIELDS_GOLDEN_AGE)
			ChangeGoldenAgeProgressMeter(GetGoldenAgePointsFromEmpire());
#endif
#if defined(MOD_BALANCE_CORE)
			if(getGoldenAgeTurns() <= 0)
			{
#endif
			// Enough GA Progress to trigger new GA?
			if(GetGoldenAgeProgressMeter() >= GetGoldenAgeProgressThreshold())
			{
				int iOverflow = GetGoldenAgeProgressMeter() - GetGoldenAgeProgressThreshold();
#if defined(MOD_BALANCE_CORE)
				int iValue = GetGoldenAgeProgressMeter();
#endif
				SetGoldenAgeProgressMeter(iOverflow);
				
				int iLength = getGoldenAgeLength();
#if defined(MOD_BALANCE_CORE)
				changeGoldenAgeTurns(iLength, iValue);
#else
				changeGoldenAgeTurns(iLength);
#endif

				// If it's the active player then show the popup
				if(GetID() == GC.getGame().getActivePlayer())
				{
					// Don't show in MP
					if(!GC.getGame().isNetworkMultiPlayer())	// KWG: Candidate for !GC.getGame().isOption(GAMEOPTION_SIMULTANEOUS_TURNS)
					{
						CvPopupInfo kPopupInfo(BUTTONPOPUP_GOLDEN_AGE_REWARD);
						GC.GetEngineUserInterface()->AddPopup(kPopupInfo);
					}
				}
			}
#if defined(MOD_BALANCE_CORE)
			}
#endif
#if !defined(MOD_BALANCE_CORE)
		}
#endif
	}
}
#if defined(MOD_BALANCE_CORE)
int CvPlayer::GetGoldenAgePointsFromEmpire()
{
	int iGAPoints = 0;
	// GA points from religion
	iGAPoints += GetYieldPerTurnFromReligion(YIELD_GOLDEN_AGE_POINTS);

	// Trait bonus which adds GA points for trade partners? 
	iGAPoints +=  GetYieldPerTurnFromTraits(YIELD_GOLDEN_AGE_POINTS);

	iGAPoints += GetGoldenAgePointsFromCities();

	if (MOD_BALANCE_CORE_JFD)
	{
		iGAPoints += GetYieldPerTurnFromMinors(YIELD_GOLDEN_AGE_POINTS);
	}

	return iGAPoints;
}

int CvPlayer::GetGoldenAgePointsFromCities()
{
	int iGAPoints = 0;
	// Add in all the GA points from city yields
	CvCity* pLoopCity;
	int iLoop;
	int iYield = 0;
	int iCityYield = 0;
	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iGAPoints += pLoopCity->getYieldRate(YIELD_GOLDEN_AGE_POINTS, false);
		if (GetPlayerTraits()->GetTourismToGAP() > 0)
		{
			iCityYield += pLoopCity->GetBaseTourism();
		}
	}

	iCityYield /= 100;
	iYield += iCityYield;
	if (GetPlayerTraits()->GetGoldToGAP() > 0)
	{
		iYield += GetTreasury()->CalculateBaseNetGold();
	}
	iYield *= (GetPlayerTraits()->GetTourismToGAP() + GetPlayerTraits()->GetGoldToGAP());
	iYield /= 100;
	if (iYield > 0)
	{
		iGAPoints += iYield;
	}
	
	return iGAPoints;
}
#endif
//	--------------------------------------------------------------------------------
/// How much do we need in the GA meter to trigger the next one?
int CvPlayer::GetGoldenAgeProgressThreshold() const
{
	int iThreshold = /*500*/ GC.getGOLDEN_AGE_BASE_THRESHOLD_HAPPINESS();
	iThreshold += GetNumGoldenAges() * /*500*/ GC.getGOLDEN_AGE_EACH_GA_ADDITIONAL_HAPPINESS();

	// Increase cost based on the # of cities in the empire
	int iCostExtra = int(iThreshold * (getNumCities() - 1) * /*0.02*/ GC.getGOLDEN_AGE_THRESHOLD_CITY_MULTIPLIER());
	iThreshold += iCostExtra;

	if(GetGoldenAgeMeterMod() != 0)
	{
		iThreshold *= (100 + GetGoldenAgeMeterMod());
		iThreshold /= 100;
	}

	// Game Speed Mod
	iThreshold *= GC.getGame().getGameSpeedInfo().getGreatPeoplePercent();
	iThreshold /= 100;

	// Make the number nice to look at
	int iVisibleDivisor = /*5*/ GC.getGOLDEN_AGE_VISIBLE_THRESHOLD_DIVISOR();
	iThreshold /= iVisibleDivisor;
	iThreshold *= iVisibleDivisor;

	return iThreshold;
}

//	--------------------------------------------------------------------------------
/// What is our progress towards the next GA?
int CvPlayer::GetGoldenAgeProgressMeter() const
{
	return m_iGoldenAgeProgressMeter;
}

//	--------------------------------------------------------------------------------
/// Sets what is our progress towards the next GA
void CvPlayer::SetGoldenAgeProgressMeter(int iValue)
{
	m_iGoldenAgeProgressMeter = iValue;

	if(m_iGoldenAgeProgressMeter < 0)
	{
		m_iGoldenAgeProgressMeter = 0;
	}

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
}

//	--------------------------------------------------------------------------------
/// Changes what is our progress towards the next GA
void CvPlayer::ChangeGoldenAgeProgressMeter(int iChange)
{
	if (MOD_BALANCE_NO_GAP_DURING_GA && isGoldenAge())
	{
		return;
	}
	SetGoldenAgeProgressMeter(GetGoldenAgeProgressMeter() + iChange);

}

//	--------------------------------------------------------------------------------
/// Modifier for how big the GA meter is (-50 = 50% of normal)
int CvPlayer::GetGoldenAgeMeterMod() const
{
	return m_iGoldenAgeMeterMod;
}

//	--------------------------------------------------------------------------------
/// Sets Modifier for how big the GA meter is (-50 = 50% of normal)
void CvPlayer::SetGoldenAgeMeterMod(int iValue)
{
	m_iGoldenAgeMeterMod = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes Modifier for how big the GA meter is (-50 = 50% of normal)
void CvPlayer::ChangeGoldenAgeMeterMod(int iChange)
{
	SetGoldenAgeMeterMod(GetGoldenAgeMeterMod() + iChange);
}

//	--------------------------------------------------------------------------------
/// How many GAs have we had in this game?
int CvPlayer::GetNumGoldenAges() const
{
	return m_iNumGoldenAges;
}

//	--------------------------------------------------------------------------------
/// Sets how many GAs have we had in this game
void CvPlayer::SetNumGoldenAges(int iValue)
{
	m_iNumGoldenAges = iValue;

#if !defined(NO_ACHIEVEMENTS)
	if(iValue > 0 && isHuman() && !GC.getGame().isGameMultiPlayer()&& GET_PLAYER(GC.getGame().getActivePlayer()).isLocalPlayer())
	{
		gDLL->UnlockAchievement(ACHIEVEMENT_GOLDEN_AGE);

		const char* strLeader = getLeaderTypeKey();
		if(m_iNumGoldenAges >=5 && NULL != strLeader && strcmp(strLeader, "LEADER_DARIUS") == 0)
		{
			gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_ARCHAEMENNID);
		}
	}
#endif
}

//	--------------------------------------------------------------------------------
/// Changes how many GAs have we had in this game
void CvPlayer::ChangeNumGoldenAges(int iChange)
{
	SetNumGoldenAges(GetNumGoldenAges() + iChange);
}

//	--------------------------------------------------------------------------------
/// How many turns left in GA? (0 if not in GA)
int CvPlayer::getGoldenAgeTurns() const
{
	return m_iGoldenAgeTurns;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isGoldenAge() const
{
	return (getGoldenAgeTurns() > 0);
}

//	--------------------------------------------------------------------------------
#if defined(MOD_BALANCE_CORE)
void CvPlayer::changeGoldenAgeTurns(int iChange, int iValue, bool bFree)
#else
void CvPlayer::changeGoldenAgeTurns(int iChange)
#endif
{
	Localization::String locString;
	Localization::String locSummaryString;

	bool bOldGoldenAge;

	if(iChange != 0)
	{
		bOldGoldenAge = isGoldenAge();

		m_iGoldenAgeTurns = (m_iGoldenAgeTurns + iChange);
		CvAssert(getGoldenAgeTurns() >= 0);

		if(bOldGoldenAge != isGoldenAge())
		{
			GC.getMap().updateYield();	// Do the entire map, so that any potential golden age bonus is reflected in the yield icons.

			if(isGoldenAge())
			{
				if (!bFree)
				{
					ChangeNumGoldenAges(1);
				}
			}
			else
			{
				gDLL->GameplayGoldenAgeEnded();

#if defined(MOD_EVENTS_GOLDEN_AGE)
				if (MOD_EVENTS_GOLDEN_AGE) {
					GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerGoldenAge, GetID(), false, 0);
				}
#endif
#if defined(MOD_BALANCE_CORE)
				CvCity* pLoopCity;
				int iLoop;
				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if(pLoopCity != NULL)
					{
						pLoopCity->GetCityCulture()->CalculateBaseTourismBeforeModifiers();
						pLoopCity->GetCityCulture()->CalculateBaseTourism();
					}
				}
				ChangeGarrisonedCityRangeStrikeModifier(GetPlayerTraits()->GetGoldenAgeGarrisonedCityRangeStrikeModifier() * -1);
#endif
			}

			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				NotificationTypes eNotification = NO_NOTIFICATION_TYPE;

				if(isGoldenAge())
				{
					eNotification = NOTIFICATION_GOLDEN_AGE_BEGUN_ACTIVE_PLAYER;
					locString = Localization::Lookup("TXT_KEY_NOTIFICATION_GOLDEN_AGE_BEGUN_ACTIVE_PLAYER");
					locSummaryString = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_GOLDEN_AGE_BEGUN_ACTIVE_PLAYER");
				}
				else
				{
					eNotification = NOTIFICATION_GOLDEN_AGE_ENDED_ACTIVE_PLAYER;
					locString = Localization::Lookup("TXT_KEY_NOTIFICATION_GOLDEN_AGE_ENDED_ACTIVE_PLAYER");
					locSummaryString = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_GOLDEN_AGE_ENDED_ACTIVE_PLAYER");
				}

				pNotifications->Add(eNotification, locString.toUTF8(), locSummaryString.toUTF8(), -1, -1, -1);
			}
		}

		if (iChange > 0)
		{
#if defined(MOD_BALANCE_CORE)
			//Instant Boost
			CvCity* pCapitalCity = getCapitalCity();
			if (pCapitalCity != NULL)
			{
				doInstantYield(INSTANT_YIELD_TYPE_INSTANT, false, NO_GREATPERSON, NO_BUILDING, iValue, false, NO_PLAYER, NULL, false, pCapitalCity);
			}
#endif

#if defined(MOD_BALANCE_CORE)
			if (GetGoldenAgeTourism() > 0)
			{
				int iTourism = GetHistoricEventTourism(HISTORIC_EVENT_GA);
				ChangeNumHistoricEvents(HISTORIC_EVENT_GA, 1);
				// Culture boost based on previous turns
				if (iTourism > 0)
				{
					GetCulture()->AddTourismAllKnownCivsWithModifiers(iTourism);
					CvCity* pCapitalCity = getCapitalCity();

					if (GetID() == GC.getGame().getActivePlayer())
					{
						if (pCapitalCity != NULL)
						{
							char text[256] = { 0 };
							sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_TOURISM]", iTourism);
							SHOW_PLOT_POPUP(pCapitalCity->plot(), GetID(), text);

							CvNotifications* pNotification = GetNotifications();
							if (pNotification)
							{
								CvString strMessage;
								CvString strSummary;
								strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GOLDEN_AGE", iTourism);
								strSummary = GetLocalizedText("TXT_KEY_TOURISM_EVENT_SUMMARY");
								pNotification->Add(NOTIFICATION_CULTURE_VICTORY_SOMEONE_INFLUENTIAL, strMessage, strSummary, pCapitalCity->getX(), pCapitalCity->getY(), GetID());
							}
						}
					}
				}
			}
			if (GetPlayerTraits()->GetWLTKDGATimer() > 0)
			{
				int iValue2 = GetPlayerTraits()->GetWLTKDGATimer();
				iValue2 *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iValue2 /= 100;
				int iLoop;
				for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if (pLoopCity != NULL)
					{
						pLoopCity->ChangeWeLoveTheKingDayCounter(iValue2);
					}
				}
				CvNotifications* pNotification = GetNotifications();
				if (pNotification)
				{
					CvString strMessage;
					CvString strSummary;
					strMessage = GetLocalizedText("TXT_KEY_CARNAVAL_WLTKD", iValue2);
					strSummary = GetLocalizedText("TXT_KEY_CARNAVAL_WLTKD_S");
					pNotification->Add(NOTIFICATION_GENERIC, strMessage, strSummary, -1, -1, GetID());
				}
			}
			if (GetPlayerTraits()->GetGoldenAgeGarrisonedCityRangeStrikeModifier() > 0)
			{
				ChangeGarrisonedCityRangeStrikeModifier(GetPlayerTraits()->GetGoldenAgeGarrisonedCityRangeStrikeModifier() * 1);
			}
#endif

			locString = Localization::Lookup("TXT_KEY_NOTIFICATION_GOLDEN_AGE_BEGUN");
			locString << getCivilizationAdjectiveKey();
			GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, GetID(), locString.toUTF8(), -1, -1);

			gDLL->GameplayGoldenAgeStarted();

#if defined(MOD_EVENTS_GOLDEN_AGE)
			if (MOD_EVENTS_GOLDEN_AGE) {
				GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerGoldenAge, GetID(), true, iChange);
			}
#endif
#if defined(MOD_BALANCE_CORE)
			CvCity* pLoopCity;
			int iLoop;
			for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				if (pLoopCity != NULL)
				{
					pLoopCity->GetCityCulture()->CalculateBaseTourismBeforeModifiers();
					pLoopCity->GetCityCulture()->CalculateBaseTourism();
				}
			}
#endif
		}

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGoldenAgeLength() const
{
	int iTurns = GC.getGame().goldenAgeLength();

	// Player modifier
	int iLengthModifier = getGoldenAgeModifier();

	// Trait modifier
	iLengthModifier += GetPlayerTraits()->GetGoldenAgeDurationModifier();

#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	// Do we get increased Golden Ages from a resource monopoly?
	if(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	{
		for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
		{
			ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
			if(eResourceLoop != NO_RESOURCE)
			{
				CvResourceInfo* pInfo = GC.getResourceInfo(eResourceLoop);
				if (pInfo && pInfo->isMonopoly())
				{
					if(HasGlobalMonopoly(eResourceLoop) && pInfo->getMonopolyGALength() > 0)
					{
						int iTemp = pInfo->getMonopolyGALength();
						iTemp += GetMonopolyModPercent();
						iLengthModifier += iTemp;
					}
				}
			}
		}
	}
#endif
#if defined(MOD_BALANCE_CORE)
	if(iLengthModifier != 0)
#else
	if(iLengthModifier > 0)
#endif
	{
		iTurns = iTurns * (100 + iLengthModifier) / 100;
	}

	return iTurns;
}

//	--------------------------------------------------------------------------------

#if defined(MOD_BALANCE_CORE)
int CvPlayer::getGoldenAgeLengthModifier() const // JJ: A way to get the golden age modifier only, in case your iTurn is not GC.getGame().goldenAgeLength()
{

	// Player modifier
	int iLengthModifier = getGoldenAgeModifier();

	// Trait modifier
	iLengthModifier += GetPlayerTraits()->GetGoldenAgeDurationModifier();

#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	// Do we get increased Golden Ages from a resource monopoly?
	if(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	{
		for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
		{
			ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
			if(eResourceLoop != NO_RESOURCE)
			{
				CvResourceInfo* pInfo = GC.getResourceInfo(eResourceLoop);
				if (pInfo && pInfo->isMonopoly())
				{
					if(HasGlobalMonopoly(eResourceLoop) && pInfo->getMonopolyGALength() > 0)
					{
						int iTemp = pInfo->getMonopolyGALength();
						iTemp += GetMonopolyModPercent();
						iLengthModifier += iTemp;
					}
				}
			}
		}
	}
#endif

	return iLengthModifier;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getNumUnitGoldenAges() const
{
	return m_iNumUnitGoldenAges;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeNumUnitGoldenAges(int iChange)
{
	m_iNumUnitGoldenAges = (m_iNumUnitGoldenAges + iChange);
	CvAssert(getNumUnitGoldenAges() >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getStrikeTurns() const
{
	return m_iStrikeTurns;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeStrikeTurns(int iChange)
{
	m_iStrikeTurns = (m_iStrikeTurns + iChange);
	CvAssert(getStrikeTurns() >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getGoldenAgeModifier() const
{
	return m_iGoldenAgeModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGoldenAgeModifier(int iChange)
{
	m_iGoldenAgeModifier += iChange;
}

#if defined(MOD_GLOBAL_TRULY_FREE_GP)
//	--------------------------------------------------------------------------------
int CvPlayer::getGreatPeopleCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatPeopleCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatPeopleCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatPeopleCreated(bool bIsFree)
{
	m_iGreatPeopleCreated++;
	if (bIsFree) m_iFreeGreatPeopleCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatGeneralsCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatGeneralsCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatGeneralsCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatGeneralsCreated(bool bIsFree)
{
	m_iGreatGeneralsCreated++;
	if (bIsFree) m_iFreeGreatGeneralsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatAdmiralsCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatAdmiralsCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatAdmiralsCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatAdmiralsCreated(bool bIsFree)
{
	m_iGreatAdmiralsCreated++;
	if (bIsFree) m_iFreeGreatAdmiralsCreated++;
}

#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
//	--------------------------------------------------------------------------------
int CvPlayer::getGreatMerchantsCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatMerchantsCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatMerchantsCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatMerchantsCreated(bool bIsFree)
{
	m_iGreatMerchantsCreated++;
	if (bIsFree) m_iFreeGreatMerchantsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatScientistsCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatScientistsCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatScientistsCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatScientistsCreated(bool bIsFree)
{
	m_iGreatScientistsCreated++;
	if (bIsFree) m_iFreeGreatScientistsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatEngineersCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatEngineersCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatEngineersCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatEngineersCreated(bool bIsFree)
{
	m_iGreatEngineersCreated++;
	if (bIsFree) m_iFreeGreatEngineersCreated++;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatWritersCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatWritersCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatWritersCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatWritersCreated(bool bIsFree)
{
	m_iGreatWritersCreated++;
	if (bIsFree) m_iFreeGreatWritersCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatArtistsCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatArtistsCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatArtistsCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatArtistsCreated(bool bIsFree)
{
	m_iGreatArtistsCreated++;
	if (bIsFree) m_iFreeGreatArtistsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatMusiciansCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatMusiciansCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatMusiciansCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatMusiciansCreated(bool bIsFree)
{
	m_iGreatMusiciansCreated++;
	if (bIsFree) m_iFreeGreatMusiciansCreated++;
}

#if defined(MOD_DIPLOMACY_CITYSTATES)
//	--------------------------------------------------------------------------------
int CvPlayer::getGreatDiplomatsCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatDiplomatsCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatDiplomatsCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatDiplomatsCreated(bool bIsFree)
{
	m_iGreatDiplomatsCreated++;
	if (bIsFree) m_iFreeGreatDiplomatsCreated++;
}
#endif
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra1Created(bool bExcludeFree) const
{
	int iCount = m_iGPExtra1Created;
	if (bExcludeFree) iCount -= m_iFreeGPExtra1Created;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra1Created(bool bIsFree)
{
	m_iGPExtra1Created++;
	if (bIsFree) m_iFreeGPExtra1Created++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra2Created(bool bExcludeFree) const
{
	int iCount = m_iGPExtra2Created;
	if (bExcludeFree) iCount -= m_iFreeGPExtra2Created;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra2Created(bool bIsFree)
{
	m_iGPExtra2Created++;
	if (bIsFree) m_iFreeGPExtra2Created++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra3Created(bool bExcludeFree) const
{
	int iCount = m_iGPExtra3Created;
	if (bExcludeFree) iCount -= m_iFreeGPExtra3Created;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra3Created(bool bIsFree)
{
	m_iGPExtra3Created++;
	if (bIsFree) m_iFreeGPExtra3Created++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra4Created(bool bExcludeFree) const
{
	int iCount = m_iGPExtra4Created;
	if (bExcludeFree) iCount -= m_iFreeGPExtra4Created;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra4Created(bool bIsFree)
{
	m_iGPExtra4Created++;
	if (bIsFree) m_iFreeGPExtra4Created++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra5Created(bool bExcludeFree) const
{
	int iCount = m_iGPExtra5Created;
	if (bExcludeFree) iCount -= m_iFreeGPExtra5Created;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra5Created(bool bIsFree)
{
	m_iGPExtra5Created++;
	if (bIsFree) m_iFreeGPExtra5Created++;
}
#endif
#else
//	--------------------------------------------------------------------------------
int CvPlayer::getGreatPeopleCreated() const
{
	return m_iGreatPeopleCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatPeopleCreated()
{
	m_iGreatPeopleCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatGeneralsCreated() const
{
	return m_iGreatGeneralsCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatGeneralsCreated()
{
	m_iGreatGeneralsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatAdmiralsCreated() const
{
	return m_iGreatAdmiralsCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatAdmiralsCreated()
{
	m_iGreatAdmiralsCreated++;
}

#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
//	--------------------------------------------------------------------------------
int CvPlayer::getGreatMerchantsCreated() const
{
	return m_iGreatMerchantsCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatMerchantsCreated()
{
	m_iGreatMerchantsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatScientistsCreated() const
{
	return m_iGreatScientistsCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatScientistsCreated()
{
	m_iGreatScientistsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatEngineersCreated() const
{
	return m_iGreatEngineersCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatEngineersCreated()
{
	m_iGreatEngineersCreated++;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatWritersCreated() const
{
	return m_iGreatWritersCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatWritersCreated()
{
	m_iGreatWritersCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatArtistsCreated() const
{
	return m_iGreatArtistsCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatArtistsCreated()
{
	m_iGreatArtistsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatMusiciansCreated() const
{
	return m_iGreatMusiciansCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatMusiciansCreated()
{
	m_iGreatMusiciansCreated++;
}

#if defined(MOD_DIPLOMACY_CITYSTATES)
//	--------------------------------------------------------------------------------
int CvPlayer::getGreatDiplomatsCreated() const
{
	return m_iGreatDiplomatsCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatDiplomatsCreated()
{
	m_iGreatDiplomatsCreated++;
}
#endif
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getMerchantsFromFaith() const
{
	return m_iMerchantsFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementMerchantsFromFaith()
{
	m_iMerchantsFromFaith++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getScientistsFromFaith() const
{
	return m_iScientistsFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementScientistsFromFaith()
{
	m_iScientistsFromFaith++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getWritersFromFaith() const
{
	return m_iWritersFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementWritersFromFaith()
{
	m_iWritersFromFaith++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getArtistsFromFaith() const
{
	return m_iArtistsFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementArtistsFromFaith()
{
	m_iArtistsFromFaith++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getMusiciansFromFaith() const
{
	return m_iMusiciansFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementMusiciansFromFaith()
{
	m_iMusiciansFromFaith++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGeneralsFromFaith() const
{
	return m_iGeneralsFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGeneralsFromFaith()
{
	m_iGeneralsFromFaith++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getAdmiralsFromFaith() const
{
	return m_iAdmiralsFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementAdmiralsFromFaith()
{
	m_iAdmiralsFromFaith++;
}

#if defined(MOD_DIPLOMACY_CITYSTATES)
//	--------------------------------------------------------------------------------
int CvPlayer::getDiplomatsFromFaith() const
{
	return m_iDiplomatsFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementDiplomatsFromFaith()
{
	m_iDiplomatsFromFaith++;
}
#endif
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra1FromFaith() const
{
	return m_iGPExtra1FromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra1FromFaith()
{
	m_iGPExtra1FromFaith++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra2FromFaith() const
{
	return m_iGPExtra2FromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra2FromFaith()
{
	m_iGPExtra2FromFaith++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra3FromFaith() const
{
	return m_iGPExtra3FromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra3FromFaith()
{
	m_iGPExtra3FromFaith++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra4FromFaith() const
{
	return m_iGPExtra4FromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra4FromFaith()
{
	m_iGPExtra4FromFaith++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra5FromFaith() const
{
	return m_iGPExtra5FromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra5FromFaith()
{
	m_iGPExtra5FromFaith++;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getEngineersFromFaith() const
{
	return m_iEngineersFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementEngineersFromFaith()
{
	m_iEngineersFromFaith++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatPeopleThresholdModifier() const
{
	return m_iGreatPeopleThresholdModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGreatPeopleThresholdModifier(int iChange)
{
	m_iGreatPeopleThresholdModifier = (m_iGreatPeopleThresholdModifier + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatGeneralsThresholdModifier() const
{
	return m_iGreatGeneralsThresholdModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGreatGeneralsThresholdModifier(int iChange)
{
	m_iGreatGeneralsThresholdModifier += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatAdmiralsThresholdModifier() const
{
	return m_iGreatAdmiralsThresholdModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGreatAdmiralsThresholdModifier(int iChange)
{
	m_iGreatAdmiralsThresholdModifier += iChange;
}


//	--------------------------------------------------------------------------------
int CvPlayer::getPolicyCostModifier() const
{
	return m_iPolicyCostModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::recomputePolicyCostModifier()
{
	int iCost = m_pPlayerPolicies->GetNumericModifier(POLICYMOD_POLICY_COST_MODIFIER);
	iCost += GetPolicyCostBuildingModifier();
	iCost += GetPolicyCostMinorCivModifier();
	iCost += GetPlayerTraits()->GetPolicyCostModifier();

	if(iCost < /*-75*/ GC.getPOLICY_COST_DISCOUNT_MAX())
		iCost = /*-75*/ GC.getPOLICY_COST_DISCOUNT_MAX();

	m_iPolicyCostModifier = iCost;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatPeopleRateModifier() const
{
	return m_iGreatPeopleRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatGeneralRateModifier() const
{
	return m_iGreatGeneralRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatAdmiralRateModifier() const
{
	return m_iGreatAdmiralRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatWriterRateModifier() const
{
	return m_iGreatWriterRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatArtistRateModifier() const
{
	return m_iGreatArtistRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatMusicianRateModifier() const
{
	return m_iGreatMusicianRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatMerchantRateModifier() const
{
	return m_iGreatMerchantRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatScientistRateModifier() const
{
	return m_iGreatScientistRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatEngineerRateModifier() const
{
	return m_iGreatEngineerRateModifier;
}

#if defined(MOD_DIPLOMACY_CITYSTATES)
//	--------------------------------------------------------------------------------
int CvPlayer::getGreatDiplomatRateModifier() const
{
	return m_iGreatDiplomatRateModifier;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getDomesticGreatGeneralRateModifier() const
{
	return m_iDomesticGreatGeneralRateModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGreatPeopleRateModFromBldgs(int ichange)
{
	m_iGreatPeopleRateModFromBldgs += ichange;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGreatGeneralRateModFromBldgs(int ichange)
{
	m_iGreatGeneralRateModFromBldgs += ichange;
}

//	--------------------------------------------------------------------------------
/// Do effects when a unit is killed in combat
#if defined(MOD_API_EXTENSIONS)
void CvPlayer::DoUnitKilledCombat(CvUnit* pKillingUnit, PlayerTypes eKilledPlayer, UnitTypes eUnitType)
#else
void CvPlayer::DoUnitKilledCombat(PlayerTypes eKilledPlayer, UnitTypes eUnitType)
#endif
{
	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(eKilledPlayer);
		args->Push(eUnitType);
#if defined(MOD_API_EXTENSIONS)
		args->Push(pKillingUnit ? pKillingUnit->GetID() : -1);
#endif

		bool bResult;
		LuaSupport::CallHook(pkScriptSystem, "UnitKilledInCombat", args.get(), bResult);
	}
}
#if defined(MOD_BALANCE_CORE)
void CvPlayer::doInstantYield(InstantYieldType iType, bool bCityFaith, GreatPersonTypes eGreatPerson, BuildingTypes eBuilding, int iPassYield, bool bEraScale, PlayerTypes ePlayer, CvPlot* pPlot, bool bSuppress, CvCity* pCity, bool bDomainSea, bool bInternational, bool bEvent, YieldTypes ePassYield, CvUnit* pUnit, TerrainTypes ePassTerrain, CvMinorCivQuest* pQuestData, CvCity* pOtherCity, CvUnit* pAttackingUnit)
{
	//No minors or barbs here, please!
	if(isMinorCiv() || isBarbarian())
		return;

	YieldTypes eYield;
	TerrainTypes eTerrain;

	ReligionTypes eReligion = NO_RELIGION;
	ReligionTypes eLocalReligion = NO_RELIGION;
	eReligion = GC.getGame().GetGameReligions()->GetFounderBenefitsReligion(GetID());
	if(eReligion == NO_RELIGION)
	{
		eReligion = GetReligions()->GetReligionInMostCities();
	}

	const CvReligion* pReligion = NULL;
	if(eReligion != NO_RELIGION)
	{
		//Let's check for holy city status - if this isn't our holy city, let's send the boosts there instead.
		pReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, GetID());
	}
	int iEra = 0;
	iEra = GetCurrentEra();
	if(iEra <= 0)
	{
		iEra = 1;
	}

	int iNumFollowerCities = 0;
	int iNumFollowers = 0;
	if (eReligion > RELIGION_PANTHEON)
	{
		iNumFollowerCities = GC.getGame().GetGameReligions()->GetNumCitiesFollowing(eReligion);
		iNumFollowers = GC.getGame().GetGameReligions()->GetNumFollowers(eReligion);
	}
	else if (eReligion == RELIGION_PANTHEON)
	{
		iNumFollowerCities = GC.getGame().GetGameReligions()->GetNumDomesticCitiesFollowing(eReligion, GetID());
		iNumFollowers = GC.getGame().GetGameReligions()->GetNumFollowers(eReligion, GetID());
	}

	CvString totalyieldString = "";
	//Let's loop through all cities for this.
	int iLoop;
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity == NULL)
			continue;

		//If we passed in a city, only check that city.
		if (pCity != NULL && pLoopCity != pCity)
			continue;

		CvString yieldString = "";
		CvString cityyieldString = "";
		CvString citynameString = "";

		//Get local faith if needed.
		if(bCityFaith)
		{
			eLocalReligion = pCity->GetCityReligions()->GetReligiousMajority();
			//Different faiths at national and local levels? We should check both, because one might be a founder bonus, and the other a follower bonus. Blegh!
			if(eLocalReligion != eReligion)
			{
				pReligion = GC.getGame().GetGameReligions()->GetReligion(eLocalReligion, GetID());
				eReligion = eLocalReligion;

				if (eReligion > RELIGION_PANTHEON)
				{
					iNumFollowerCities = GC.getGame().GetGameReligions()->GetNumCitiesFollowing(eReligion);
					iNumFollowers = GC.getGame().GetGameReligions()->GetNumFollowers(eReligion);
				}
				else if (eReligion == RELIGION_PANTHEON)
				{
					iNumFollowerCities = GC.getGame().GetGameReligions()->GetNumDomesticCitiesFollowing(eReligion, GetID());
					iNumFollowers = GC.getGame().GetGameReligions()->GetNumFollowers(eReligion, GetID());
				}
			}
		}

		
		for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
		{
			eYield = (YieldTypes) iI;

			if(eYield == NO_YIELD)
				continue;
		
			CvYieldInfo* pYieldInfo = GC.getYieldInfo(eYield);
		
			//First let's get our values...
			//Note that many beliefs pass in a city - that's because only holy cities (or capitals for pantheons) should get those bonuses!
			int iValue = 0;
			switch(iType)
			{
				case INSTANT_YIELD_TYPE_MINOR_QUEST_REWARD:
				{
					if (eYield != ePassYield)
						continue;

					iValue += iPassYield;
					break;
				}
				case INSTANT_YIELD_TYPE_BIRTH:
				{
					iValue += ((pLoopCity->GetYieldFromBirth(eYield) + getYieldFromBirth(eYield)) * max(1, iPassYield));
					if(pReligion)
					{
						iValue += (pReligion->m_Beliefs.GetYieldPerBirth(eYield, GetID(), pLoopCity) * max(1, iPassYield));
					}
					if(pLoopCity->isCapital())
					{
						iValue += (getYieldFromBirthCapital(eYield) * max(1, iPassYield));
					}
					//Scale it here to avoid scaling the growth yield below.
					if(MOD_BALANCE_CORE_NEW_GP_ATTRIBUTES && bEraScale)
					{
						iValue *= iEra;
					}

					//And now on growth % bonuses.
					int iCurrentYield = 0;

					if(eYield == YIELD_CULTURE)
					{
						iCurrentYield = pLoopCity->getJONSCulturePerTurn();
					}
					else if (eYield == YIELD_FAITH)
					{
						iCurrentYield = pLoopCity->GetFaithPerTurn();
					}
					else
					{
						iCurrentYield = pLoopCity->getYieldRate(eYield, false);
					}
					if(iCurrentYield != 0)
					{
						iValue += (((iCurrentYield * pLoopCity->GetGrowthExtraYield(eYield)) / 100) * max(1, iPassYield));
						if(iValue <= 0 && pLoopCity->GetGrowthExtraYield(eYield) > 0)
						{
							iValue = 1;
						}
					}
					break;
				}
				case INSTANT_YIELD_TYPE_BIRTH_RETROACTIVE:
				{
					if (eYield != ePassYield)
						continue;

					iValue = iPassYield;
					break;
				}
				case INSTANT_YIELD_TYPE_ERA_UNLOCK:
				{
					if(pReligion)
					{
						
						iValue += pReligion->m_Beliefs.GetYieldFromEraUnlock(eYield, GetID(), pLoopCity, true) * pReligion->m_Beliefs.GetCityScalerLimiter(iNumFollowerCities);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_POLICY_UNLOCK:
				{
					int iScaleValue = pLoopCity->GetYieldFromPolicyUnlock(eYield);
					//Scale it here to avoid scaling the growth yield below.
					if (MOD_BALANCE_CORE_NEW_GP_ATTRIBUTES)
					{
						iScaleValue *= iEra;
					}
					iValue += iScaleValue;

					if(pReligion)
					{
						iValue += pReligion->m_Beliefs.GetYieldFromPolicyUnlock(eYield, GetID(), pLoopCity, true) * pReligion->m_Beliefs.GetFollowerScalerLimiter(iNumFollowers);
					}
					
					break;
				}
				case INSTANT_YIELD_TYPE_INSTANT:
				{
					if(eBuilding != NO_BUILDING)
					{
						CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
						if(pkBuildingInfo)
						{
							iValue += pkBuildingInfo->GetInstantYield(eYield);
							if(GetPlayerTraits()->IsTechBoostFromCapitalScienceBuildings() && iPassYield > 0 && eYield == YIELD_SCIENCE)
							{
								iValue += iPassYield;
							}
						}
					}
					else 
					{
						if(iPassYield != 0 && !bEvent)
						{
							int iPercent = GetPlayerTraits()->GetGAPToYield(eYield);
							if(iPercent != 0)
							{
								iPassYield *= iPercent;
								iPassYield /= 100;
						
								iValue += iPassYield;
							}
						}
						if(bEvent && ePassYield == eYield)
						{
							iValue += iPassYield;
						}
					}
					break;
				}
				case INSTANT_YIELD_TYPE_TECH:
				{
					iValue +=  pLoopCity->GetYieldFromTech(eYield);
					if(pLoopCity->isCapital())
					{
						iValue += getYieldFromTech(eYield);
					}
					break;
				}

				case INSTANT_YIELD_TYPE_SPY_ATTACK:
				{
					iValue += pLoopCity->GetYieldFromSpyAttack(eYield);
					if (iValue != 0)
					{
						if (iPassYield == 0)
							iValue /= 4;
						else
							iValue *= iPassYield;
					}
					break;
				}
				case INSTANT_YIELD_TYPE_SPY_DEFENSE:
				{
					iValue += pLoopCity->GetYieldFromSpyDefense(eYield);
					if (iValue != 0)
					{
						if (iPassYield == 0)
							iValue /= 4;
						else
							iValue *= iPassYield;
					}
					break;
				}
				case INSTANT_YIELD_TYPE_DELEGATES:
				{
					if (pLoopCity->isCapital())
					{
						iValue += (getYieldFromDelegateCount(eYield) * iPassYield);
					}
					break;
				}			
				
				case INSTANT_YIELD_TYPE_CONSTRUCTION:
				{
					iValue += pLoopCity->GetYieldFromConstruction(eYield) + getYieldFromConstruction(eYield);
					if (pReligion)
					{
						iValue += pReligion->m_Beliefs.GetYieldPerConstruction(eYield, GetID(), pLoopCity);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_CONSTRUCTION_WONDER:
				{
					iValue += getYieldFromwonderConstruction(eYield);
					break;
				}
				case INSTANT_YIELD_TYPE_BORDERS:
				{
					int iScaleValue = pLoopCity->GetYieldFromBorderGrowth(eYield) + getYieldFromBorderGrowth(eYield) + GetPlayerTraits()->GetYieldFromTileEarn(eYield);

					iScaleValue *= iEra;

					iValue += iScaleValue;

					if(pReligion)
					{
						iValue += pReligion->m_Beliefs.GetYieldPerBorderGrowth(eYield, GetID(), pLoopCity);
					}
					for(int iI = 0; iI < GC.getNumTerrainInfos(); iI++)
					{
						eTerrain = (TerrainTypes) iI;

						if(eTerrain == NO_TERRAIN)
							continue;
						if(eTerrain == ePassTerrain)
						{
							iScaleValue = GetPlayerTraits()->GetYieldChangeFromTileEarnTerrainType(eTerrain, eYield);
							iScaleValue *= iEra;
							iValue += iScaleValue;
						}
					}
					break;
				}
				case INSTANT_YIELD_TYPE_PROPOSAL:
				{
					if(pReligion)
					{
						iValue += pReligion->m_Beliefs.GetYieldFromProposal(eYield, GetID(), pLoopCity, true);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_GP_USE:
				{
					if(pLoopCity->isCapital())
					{
						iValue += getYieldGPExpend(eYield);
						if(eYield == YIELD_GOLD)
						{
							iValue += GetGreatPersonExpendGold();
						}
					}
					if(eGreatPerson != NO_GREATPERSON)
					{
						if(pLoopCity->isCapital())
						{
							iValue += getGreatPersonExpendedYield(eGreatPerson, eYield);
							//Scale it here to avoid scaling the growth yield below.
							if (bEraScale)
							{
								iValue *= iEra;
							}
						}
						if(pReligion)
						{
							iValue += (pReligion->m_Beliefs.GetYieldFromGPUse(eYield, GetID(), pLoopCity, true) + pReligion->m_Beliefs.GetGreatPersonExpendedYield(eGreatPerson, eYield, GetID(), pLoopCity, true)) * pReligion->m_Beliefs.GetCityScalerLimiter(iNumFollowerCities);
						}
					}
					if(eYield == YIELD_FAITH)
					{
						if(pReligion)
						{
							iValue += pReligion->m_Beliefs.GetGreatPersonExpendedFaith(GetID(), pLoopCity, true);
							//Scale it here to avoid scaling the growth yield below.
							if (bEraScale)
							{
								iValue *= iEra;
							}
						}
					}
					break;
				}
				case INSTANT_YIELD_TYPE_GP_BORN:
				{
					if(eGreatPerson != NO_GREATPERSON)
					{
						iValue += GetPlayerTraits()->GetGreatPersonBornYield(eGreatPerson, eYield);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_F_CONQUEST:
				{
					if (pLoopCity->isCapital())
					{
						iValue += (getConquerorYield(eYield) + GetPlayerTraits()->GetYieldFromConquest(eYield));
					}
					if (pReligion)
					{
						if (pReligion->m_Beliefs.GetYieldFromConquest(eYield, GetID(), pLoopCity, true) > 0)
						{
							if (eYield == YIELD_GREAT_ADMIRAL_POINTS && bDomainSea)
							{
								iValue += pReligion->m_Beliefs.GetYieldFromConquest(eYield, GetID(), pLoopCity, true);
							}
							else if (eYield == YIELD_GREAT_GENERAL_POINTS && !bDomainSea)
							{
								iValue += pReligion->m_Beliefs.GetYieldFromConquest(eYield, GetID(), pLoopCity, true);
							}
							else if (eYield != YIELD_GREAT_ADMIRAL_POINTS && eYield != YIELD_GREAT_GENERAL_POINTS)
							{
								iValue += pReligion->m_Beliefs.GetYieldFromConquest(eYield, GetID(), pLoopCity, true);
							}
						}
					}
					if (iPassYield != 0 && iValue != 0)
					{
						iValue *= iPassYield;
					}

					if (pLoopCity->isCapital() && pOtherCity != NULL)
					{
						for (int iI = 0; iI < GC.getNumTerrainInfos(); iI++)
						{
							eTerrain = (TerrainTypes)iI;

							if (eTerrain != NO_TERRAIN)
							{
								int iTraitValue = GetPlayerTraits()->GetYieldChangeFromTileConquest(eTerrain, eYield);

								if (iTraitValue <= 0)
									continue;

								int iNumTiles = pOtherCity->CountAllOwnedTerrain(eTerrain);
								if (iNumTiles > 0)
								{
									iValue += (iTraitValue * iNumTiles);
								}
							}
						}
					}
					break;
				}
				case INSTANT_YIELD_TYPE_VICTORY:
				{
					if(eYield == YIELD_GREAT_ADMIRAL_POINTS && !bDomainSea)
					{
						continue;
					}
					if(eYield == YIELD_GREAT_GENERAL_POINTS && bDomainSea)
					{
						continue;
					}

					if (eYield == YIELD_SCIENCE)
					{
						int iPercent = GetPlayerTraits()->GetUnresearchedTechBonusFromKills();

						if (iPercent > 0)
						{
							int iTechValue = 0;

							CvUnitEntry* pkUnitInfo = GC.getUnitInfo(pUnit->getUnitType());
							if (pkUnitInfo)
							{
								TechTypes ePrereq = (TechTypes)pkUnitInfo->GetPrereqAndTech();
								if (ePrereq != NO_TECH)
								{
									CvTechEntry* pkTechInfo = GC.getTechInfo(ePrereq);
									if (pkTechInfo && !GET_TEAM(getTeam()).GetTeamTechs()->HasTech(ePrereq))
									{
#if defined(MOD_API_EXTENSIONS)
										int iCombatStrength = pUnit != NULL ? max(pUnit->GetBaseCombatStrength(), pUnit->GetBaseRangedCombatStrength()) : max(pkUnitInfo->GetCombat(), pkUnitInfo->GetRangedCombat());
#else
										int iCombatStrength = max(pkUnitInfo->GetCombat(), pkUnitInfo->GetRangedCombat());
#endif
										if (iCombatStrength > 0)
										{
											int iTechCost = GetPlayerTechs()->GetResearchCost(ePrereq);
											iTechValue = (iTechCost * iPercent) / 100;

											// Cannot be greater than the tech's cost
											int iRemainingCost = iTechCost - GetPlayerTechs()->GetResearchProgress(ePrereq);
											if (iTechValue > iRemainingCost)
											{
												iTechValue = iRemainingCost;
											}

											if (iTechValue > 0)
											{
												iValue += iTechValue;
											}
										}
									}
								}
							}
						}
					}

					CvUnitEntry* pkKilledUnitInfo = GC.getUnitInfo(pUnit->getUnitType());
					if (pkKilledUnitInfo)
					{
#if defined(MOD_API_EXTENSIONS)
						int iCombatStrength = pUnit != NULL ? max(pUnit->GetBaseCombatStrength(), pUnit->GetBaseRangedCombatStrength()) : max(pkKilledUnitInfo->GetCombat(), pkKilledUnitInfo->GetRangedCombat());
#else
						int iCombatStrength = max(pkKilledUnitInfo->GetCombat(), pkKilledUnitInfo->GetRangedCombat());
#endif
						int iKillYield = 0;
						if (iCombatStrength > 0)
						{
							switch (eYield)
							{
							case YIELD_GOLD:
								iKillYield += GetPlayerPolicies()->GetNumericModifier(POLICYMOD_GOLD_FROM_KILLS);
								break;

							case YIELD_CULTURE:
								iKillYield += GetPlayerTraits()->GetCultureFromKills();
								iKillYield += GetPlayerPolicies()->GetNumericModifier(POLICYMOD_CULTURE_FROM_KILLS);

								// Do we get it for barbarians?
								if (pUnit->getOwner() == BARBARIAN_PLAYER)
								{
									iKillYield += GetPlayerPolicies()->GetNumericModifier(POLICYMOD_CULTURE_FROM_BARBARIAN_KILLS);
								}
								break;

							case YIELD_FAITH:
								iKillYield += GetPlayerTraits()->GetFaithFromKills();

								if (eYield == YIELD_FAITH && (GC.getGame().isOption(GAMEOPTION_NO_RELIGION)))
								{
									return;
								}
								break;
							}

							iKillYield += GetYieldFromKills(eYield);
							iKillYield += GetPlayerTraits()->GetYieldFromKills(eYield);

							if (pUnit->getOwner() == BARBARIAN_PLAYER) {
								iKillYield += GetYieldFromBarbarianKills(eYield);
								iKillYield += GetPlayerTraits()->GetYieldFromBarbarianKills(eYield);
							}

							ReligionTypes eReligion = GC.getGame().GetGameReligions()->GetFounderBenefitsReligion(GetID());
							if (eReligion == NO_RELIGION)
							{
								eReligion = GetReligions()->GetReligionInMostCities();
							}
							if (eReligion != NO_RELIGION)
							{
								const CvReligion* pMyReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, GetID());
								if (pMyReligion)
								{
									CvCity* pHolyCity = NULL;
									CvPlot* pHolyCityPlot = GC.getMap().plot(pMyReligion->m_iHolyCityX, pMyReligion->m_iHolyCityY);
									if (pHolyCityPlot)
									{
										pHolyCity = pHolyCityPlot->getPlotCity();
									}
									if (pHolyCity == NULL)
									{
										pHolyCity = getCapitalCity();
									}

									iKillYield += pMyReligion->m_Beliefs.GetYieldFromKills(eYield, GetID(), pHolyCity, true);

									if (pUnit->getOwner() == BARBARIAN_PLAYER)
									{
										iKillYield += pMyReligion->m_Beliefs.GetYieldFromBarbarianKills(eYield, GetID(), pHolyCity, true);
									}
								}
							}
							if (pAttackingUnit != NULL)
							{
								iKillYield += GC.getGame().GetGameReligions()->GetBeliefYieldForKill(eYield, pAttackingUnit->getX(), pAttackingUnit->getY(), GetID());

								UnitTypes eAttackingUnitType = pAttackingUnit->getUnitType();

								CvUnitEntry* pkAttackingUnitInfo = GC.getUnitInfo(eAttackingUnitType);
								if (pkAttackingUnitInfo)
								{
									iKillYield += pkAttackingUnitInfo->GetYieldFromKills(eYield);

									iKillYield += pAttackingUnit->getYieldFromKills(eYield);

									// Do we get it for barbarians?
									if (pUnit != NULL && pUnit->getOwner() == BARBARIAN_PLAYER)
									{
										iKillYield += pkAttackingUnitInfo->GetYieldFromBarbarianKills(eYield);
										iKillYield += pAttackingUnit->getYieldFromBarbarianKills(eYield);
									}
								}
							}
							iKillYield = (iKillYield * iCombatStrength) / 100;

							if (iKillYield > 0)
								iValue += iKillYield;
						}
					}
					int iTempYield = pLoopCity->GetYieldFromVictory(eYield);
					if (bEraScale)
					{
						iTempYield *= iEra;
					}
					iValue += iTempYield;
					break;
				}
				case INSTANT_YIELD_TYPE_VICTORY_GLOBAL:
				{
					if (eYield == YIELD_GREAT_ADMIRAL_POINTS && !bDomainSea)
					{
						continue;
					}
					if (eYield == YIELD_GREAT_GENERAL_POINTS && bDomainSea)
					{
						continue;
					}
					iValue += GetYieldFromVictory(eYield) + pLoopCity->GetYieldFromVictoryGlobal(eYield);
					break;
				}
				case INSTANT_YIELD_TYPE_PILLAGE:
				{
					iValue += pLoopCity->GetYieldFromPillage(eYield);
					break;
				}			
				case INSTANT_YIELD_TYPE_PILLAGE_GLOBAL:
				{
					iValue += GetYieldFromPillage(eYield) + pLoopCity->GetYieldFromPillageGlobal(eYield);
					break;
				}
				
				case INSTANT_YIELD_TYPE_U_PROD:
				{
					if (pLoopCity->GetYieldFromUnitProduction(eYield) > 0)
					{
						int iBonus = iPassYield;
						iBonus *= pLoopCity->GetYieldFromUnitProduction(eYield);
						iBonus /= 100;

						iValue += iBonus;
					}
					break;
				}
				case INSTANT_YIELD_TYPE_PURCHASE:
				{
					if(iPassYield != 0)
					{
						iValue += ((iPassYield * pLoopCity->GetYieldFromPurchase(eYield)) / 100);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_TILE_PURCHASE:
				{
					iValue += GetPlayerTraits()->GetYieldFromTilePurchase(eYield);
					for (int iI = 0; iI < GC.getNumTerrainInfos(); iI++)
					{
						eTerrain = (TerrainTypes)iI;

						if (eTerrain == NO_TERRAIN)
							continue;
						if (eTerrain == ePassTerrain)
						{
							iValue += GetPlayerTraits()->GetYieldChangeFromTilePurchaseTerrainType(eTerrain, eYield);
						}
					}
					break;
				}
				case INSTANT_YIELD_TYPE_FOUND:
				{
					iValue += GetPlayerTraits()->GetYieldFromSettle(eYield);
					iValue += getFounderYield(eYield);
					for (int iI = 0; iI < GC.getNumTerrainInfos(); iI++)
					{
						eTerrain = (TerrainTypes)iI;

						if (eTerrain != NO_TERRAIN && pCity != NULL)
						{
							int iTraitValue = GetPlayerTraits()->GetYieldChangeFromTileSettle(eTerrain, eYield);

							if (iTraitValue <= 0)
								continue;

							int iNumTiles = pCity->CountTerrain(eTerrain);
							if (iNumTiles > 0)
							{
								iValue += (iTraitValue * iNumTiles);
							}
						}
					}
					break;
				}
				case INSTANT_YIELD_TYPE_TR_END:
				{
					if(bInternational && (eYield == YIELD_SCIENCE || eYield == YIELD_FOOD || eYield == YIELD_PRODUCTION))
					{
						iValue += GetPlayerTraits()->GetTradeRouteStartYield(eYield);
					}
					else if(!bInternational && (eYield == YIELD_GOLD || eYield == YIELD_CULTURE))
					{
						iValue += GetPlayerTraits()->GetTradeRouteStartYield(eYield);
					}
					else if(eYield >= YIELD_FAITH)
					{
						iValue += GetPlayerTraits()->GetTradeRouteStartYield(eYield);
					}
					if (!bInternational)
					{
						iValue += pLoopCity->GetYieldFromInternalTREnd(eYield);
						if (pOtherCity != NULL)
						{
							iValue += pOtherCity->GetYieldFromInternalTREnd(eYield);
						}
					}
					break;
				}
				case INSTANT_YIELD_TYPE_CONVERSION:
				{
					int iBaseValue = pReligion->m_Beliefs.GetYieldFromConversion(eYield, GetID(), pLoopCity, true);
					if (iBaseValue != 0)
					{
						int iTempValue = iBaseValue;
						iTempValue *= (100 + pReligion->m_Beliefs.GetCityScalerLimiter(iNumFollowerCities) * pReligion->m_Beliefs.GetCityScalerLimiter(iNumFollowerCities));
						iTempValue /= 100;

						iBaseValue += iTempValue;
					}

					iValue += iBaseValue;
					break;
				}
				case INSTANT_YIELD_TYPE_CONVERSION_EXPO:
				{
					iValue += pReligion->m_Beliefs.GetYieldFromConversionExpo(eYield, GetID(), pLoopCity, true) * iNumFollowerCities;
					break;
				}
				case INSTANT_YIELD_TYPE_DEATH:
				{
					if(pLoopCity->isCapital())
					{
						iValue += getYieldFromDeath(eYield);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_BULLY:
				{
					if (eYield != ePassYield && ePassYield != NO_YIELD)
						continue;

					if (iPassYield == 0)
						iValue += GetYieldFromMinorDemand(eYield);
					else if (ePassYield != NO_YIELD)
						iValue += iPassYield;
					else
					{
						int iTemp = GetYieldFromMinorDemand(eYield) * iPassYield;
						iTemp /= 100;
						iValue += iTemp;
					}
					break;
				}
				case INSTANT_YIELD_TYPE_SPREAD:
				{
					if(pReligion && pPlot != NULL)
					{
						CvCity* pCity = pPlot->getPlotCity();
						if(pCity == NULL)
						{
							pCity = pPlot->GetAdjacentCity();
						}
						if(pCity != NULL)
						{
							if(!pCity->GetCityReligions()->IsHolyCityForReligion(eReligion))
							{
								iValue += pReligion->m_Beliefs.GetYieldFromSpread(eYield, GetID(), pLoopCity, true) * max(1, iPassYield+1);
							}
						}
					}
					break;
				}
				case INSTANT_YIELD_TYPE_F_SPREAD:
				{
					if(ePlayer != NO_PLAYER && ePlayer != GetID())
					{
						if(GET_PLAYER(ePlayer).isMinorCiv() && eYield == YIELD_TOURISM)
						{
							continue;
						}
						if(pReligion)
						{
							int iTempValue = pReligion->m_Beliefs.GetYieldFromForeignSpread(eYield, GetID(), pLoopCity, true);
							iTempValue *= max(1, iPassYield+1);

							iValue += iTempValue;

							CvCity* pCity = pPlot->getPlotCity();
							if (pCity == NULL)
							{
								pCity = pPlot->GetAdjacentCity();
							}
							if (pCity != NULL)
							{
								if (eYield == YIELD_SCIENCE && iPassYield > 0)
								{
									ReligionTypes eCurrentReligion = pCity->GetCityReligions()->GetReligiousMajority();
									if (eCurrentReligion != eReligion)
									{
										iValue += (iPassYield * pReligion->m_Beliefs.GetSciencePerOtherReligionFollower(GetID(), pLoopCity, true));
									}
								}
							}
						}
					}
					
					break;
				}	
				case INSTANT_YIELD_TYPE_TR_MOVEMENT:
				{
					if(eYield == YIELD_GREAT_ADMIRAL_POINTS && !bDomainSea)
					{
						continue;
					}
					if(eYield == YIELD_GREAT_GENERAL_POINTS && bDomainSea)
					{
						continue;
					}
					iValue += GetPlayerTraits()->GetYieldFromRouteMovement(eYield);
					break;
				}
				case INSTANT_YIELD_TYPE_SCOUTING:
				{
					if(pUnit == NULL)
						continue;

					if(eYield == YIELD_GREAT_ADMIRAL_POINTS && !bDomainSea)
					{
						continue;
					}
					if(eYield == YIELD_GREAT_GENERAL_POINTS && bDomainSea)
					{
						continue;
					}
					iValue += (pUnit->getYieldFromScouting(eYield) * pUnit->GetNumTilesRevealedThisTurn());
					break;
				}
				case INSTANT_YIELD_TYPE_LEVEL_UP:
				{
					if(pUnit == NULL)
						continue;

					if(eYield == YIELD_GREAT_ADMIRAL_POINTS && !bDomainSea)
					{
						continue;
					}
					if(eYield == YIELD_GREAT_GENERAL_POINTS && bDomainSea)
					{
						continue;
					}

					int iLevelUpYield = pLoopCity->GetYieldFromUnitLevelUp(eYield) + GetPlayerTraits()->GetYieldFromLevelUp(eYield);

					if (iPassYield != 0 && iLevelUpYield > 0)
					{
						int iMetric = ((((iPassYield * iPassYield) - (2 * iPassYield) + 1)) * iLevelUpYield);
						if (iMetric <= 0)
							iMetric = 1;

						iValue += iMetric;
					}
					break;
				}
				case INSTANT_YIELD_TYPE_CULTURE_BOMB:
				{
					if (eYield != ePassYield)
						continue;

					iValue += iPassYield;

					break;
				}

				case INSTANT_YIELD_TYPE_REMOVE_HERESY:
				{
					if (pReligion)
					{
						int iTempVal = pReligion->m_Beliefs.GetYieldFromRemoveHeresy(eYield, GetID(), pLoopCity, true);
						iTempVal *= iPassYield;
						if (iTempVal > 0)
							iValue += iTempVal;
					}

					break;
				}

				case INSTANT_YIELD_TYPE_FAITH_PURCHASE:
				{
					if (pReligion)
					{
						int iTempVal = pReligion->m_Beliefs.GetYieldFromFaithPurchase(eYield, GetID(), pLoopCity, true);
						iTempVal *= iPassYield;
						iTempVal /= 100;
						iValue += iTempVal;
					}

					int iTempVal = pLoopCity->GetYieldFromFaithPurchase(eYield);
					iTempVal *= iPassYield;
					iTempVal /= 100;
					iValue += iTempVal;

					break;
				}
				case INSTANT_YIELD_TYPE_PROMOTION_OBTAINED:
				{
					if (eYield != ePassYield)
						continue;

					if (pCity == NULL && pLoopCity == getCapitalCity())
					{
						iValue += iPassYield;
					}

					else if (pLoopCity == pCity)
					{
						iValue += iPassYield;
					}

					break;
				}
				case INSTANT_YIELD_TYPE_BARBARIAN_CAMP_CLEARED:
				{
					iValue += MAX(GetPlayerTraits()->GetYieldFromBarbarianCampClear(eYield, bEraScale), 0);

					break;
				}
				case INSTANT_YIELD_TYPE_TR_PRODUCTION_SIPHON:
				{
					if (eYield != ePassYield)
						continue;

					iValue += iPassYield;

					break;
				}
				case INSTANT_YIELD_TYPE_TR_MOVEMENT_IN_FOREIGN:
				{
					if (pUnit == NULL)
						continue;
					if (eYield == YIELD_GREAT_ADMIRAL_POINTS && !bDomainSea)
					{
						continue;
					}
					if (eYield == YIELD_GREAT_GENERAL_POINTS && bDomainSea)
					{
						continue;
					}
					if (pUnit->IsInForeignOwnedTerritory())
					{
						iValue += GetPlayerTraits()->GetYieldFromRouteMovementInForeignTerritory(eYield, false);
						iValue += GetPlayerTraits()->GetYieldFromRouteMovementInForeignTerritory(eYield, true);

						PlayerTypes eOtherPlayer = pUnit->plot()->getOwner();

						if (eOtherPlayer != NO_PLAYER && GET_PLAYER(eOtherPlayer).isBarbarian() == false && eOtherPlayer != GetID())
						{
							iValue += GET_PLAYER(eOtherPlayer).GetPlayerTraits()->GetYieldFromRouteMovementInForeignTerritory(eYield, true);
						}
					}

					break;
				}
			}
			//Now, let's apply these yields here as total yields.
			if(iValue != 0)
			{
				//Exclusions
				if(eYield != YIELD_POPULATION)
				{
					if (iType != INSTANT_YIELD_TYPE_TR_MOVEMENT && iType != INSTANT_YIELD_TYPE_PURCHASE && iType != INSTANT_YIELD_TYPE_U_PROD && iType != INSTANT_YIELD_TYPE_MINOR_QUEST_REWARD && iType != INSTANT_YIELD_TYPE_TR_MOVEMENT_IN_FOREIGN)
					{
						if (ePlayer == NO_PLAYER && eYield == YIELD_TOURISM)
						{
							//nothing
						}
						else
						{
							iValue *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
							iValue /= 100;
						}
					}

					//Exclusion for birth yields and GP expense and policy unlocks (as we do it up above to avoid % growth and religion bonuses from being scaled).
					if (bEraScale && iType != INSTANT_YIELD_TYPE_BIRTH && iType != INSTANT_YIELD_TYPE_GP_USE && iType != INSTANT_YIELD_TYPE_POLICY_UNLOCK && iType != INSTANT_YIELD_TYPE_BORDERS && iType != INSTANT_YIELD_TYPE_REMOVE_HERESY && iType != INSTANT_YIELD_TYPE_VICTORY)
					{
						iValue *= iEra;
					}
				}

				switch(eYield)
				{
					case YIELD_FOOD:
					{
						pLoopCity->changeFood(iValue);
						if(pLoopCity->getFood() <= 0)
						{
							pLoopCity->setFood(0);
						}
					}
					break;
					case YIELD_PRODUCTION:
					{
						if ((pLoopCity->getProduction() < pLoopCity->getProductionNeeded()) && pLoopCity->isProduction())
						{
							pLoopCity->changeProduction(iValue);
						}
						else
						{
							pLoopCity->changeOverflowProduction(iValue);
						}
						if (pLoopCity->getProduction() <= 0)
						{
							pLoopCity->setProduction(0);
						}
					}
					break;
					case YIELD_GOLD:
					{
						GetTreasury()->ChangeGold(iValue);
						if(GetTreasury()->GetGold() <= 0)
						{
							GetTreasury()->SetGold(0);
						}
					}
					break;
					case YIELD_SCIENCE:
					{
						TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
						if(eCurrentTech == NO_TECH)
						{
							changeOverflowResearch(iValue);
							if(getOverflowResearch() <= 0)
							{
								setOverflowResearch(0);
							}
						}
						else
						{
							GET_TEAM(getTeam()).GetTeamTechs()->ChangeResearchProgress(eCurrentTech, iValue, GetID());
							if(GET_TEAM(getTeam()).GetTeamTechs()->GetResearchProgress(eCurrentTech) <= 0)
							{
								GET_TEAM(getTeam()).GetTeamTechs()->SetResearchProgress(eCurrentTech, 0, GetID());
							}
						}
					}
					break;
					case YIELD_CULTURE:
					{
						changeJONSCulture(iValue);
						pLoopCity->ChangeJONSCultureStored(iValue);
						if(pLoopCity->GetJONSCultureStored() <= 0)
						{
							pLoopCity->SetJONSCultureStored(0);
						}
					}
					break;
					case YIELD_FAITH:
					{
						ChangeFaith(iValue);
						if(GetFaith() <= 0)
						{
							SetFaith(0);
						}
					}
					break;
					case YIELD_TOURISM:
					{
						if(ePlayer != NO_PLAYER)
						{
							int iRealInfluence = GetCulture()->ChangeInfluenceOn(ePlayer, iValue, true, true);
							iValue = iRealInfluence;

							if(pPlot != NULL && pPlot->getOwner() != NO_PLAYER && GET_PLAYER(pPlot->getOwner()).isMajorCiv())
							{
								// Show tourism spread
								if (pPlot->GetActiveFogOfWarMode() == FOGOFWARMODE_OFF)
								{
									CvString strInfluenceText;
									InfluenceLevelTypes eLevel = GetCulture()->GetInfluenceLevel(pPlot->getOwner());

									if (eLevel == INFLUENCE_LEVEL_UNKNOWN)
										strInfluenceText = GetLocalizedText( "TXT_KEY_CO_UNKNOWN" );
									else if (eLevel == INFLUENCE_LEVEL_EXOTIC)
										strInfluenceText = GetLocalizedText( "TXT_KEY_CO_EXOTIC");
									else if (eLevel == INFLUENCE_LEVEL_FAMILIAR)
										strInfluenceText = GetLocalizedText( "TXT_KEY_CO_FAMILIAR");
									else if (eLevel == INFLUENCE_LEVEL_POPULAR)
										strInfluenceText = GetLocalizedText( "TXT_KEY_CO_POPULAR");
									else if (eLevel == INFLUENCE_LEVEL_INFLUENTIAL)
										strInfluenceText = GetLocalizedText( "TXT_KEY_CO_INFLUENTIAL");
									else if (eLevel == INFLUENCE_LEVEL_DOMINANT)
										strInfluenceText = GetLocalizedText( "TXT_KEY_CO_DOMINANT");

									char text[256] = {0};
									sprintf_s(text, "[COLOR_WHITE]+%d [ICON_TOURISM][ENDCOLOR]   %s", iValue, strInfluenceText.c_str());
									SHOW_PLOT_POPUP(pPlot, GetID(), text);
								}
							}
						}
						else
						{
							GetCulture()->AddTourismAllKnownCivsWithModifiers(iValue);
						}
					}
					break;
					case YIELD_GOLDEN_AGE_POINTS:
					{
						ChangeGoldenAgeProgressMeter(iValue);
						if(GetGoldenAgeProgressMeter() <= 0)
						{
							SetGoldenAgeProgressMeter(0);
						}
					}
					break;
					case YIELD_GREAT_GENERAL_POINTS:
					{
	#if defined(MOD_UNITS_XP_TIMES_100)
						changeCombatExperienceTimes100(iValue * 100);
						if(getCombatExperienceTimes100() <= 0)
						{
							setCombatExperienceTimes100(0);
						}
	#else
						changeCombatExperience(iValue);
						if(getCombatExperience() <= 0)
						{
							setCombatExperience(0);
						}
	#endif
					}
					break;
					case YIELD_GREAT_ADMIRAL_POINTS:
					{
	#if defined(MOD_UNITS_XP_TIMES_100)
						changeNavalCombatExperienceTimes100(iValue * 100);
						if(getNavalCombatExperienceTimes100() <= 0)
						{
							setNavalCombatExperienceTimes100(0);
						}
	#else
						changeNavalCombatExperience(iValue);
						if(getNavalCombatExperience() <= 0)
						{
							setNavalCombatExperience(0);
						}
	#endif
					}
					break;
					case YIELD_POPULATION:
					{
						if(iValue < 0 && pLoopCity->getPopulation() <= iValue)
						{
							pLoopCity->setPopulation(1);
						}
						else
						{
							pLoopCity->changePopulation(iValue, true, true);
						}
					}
					break;
					case YIELD_CULTURE_LOCAL:
					{
						if (iType == INSTANT_YIELD_TYPE_MINOR_QUEST_REWARD)
						{
							getCapitalCity()->ChangeUnmoddedHappinessFromBuildings(iValue);
						}
						else
						{
							pLoopCity->ChangeJONSCultureStored(iValue);
							if (pLoopCity->GetJONSCultureStored() <= 0)
							{
								pLoopCity->SetJONSCultureStored(0);
							}
						}
					}
					break;
				}

				//keep track of what we're doing
				m_viInstantYieldsTotal.setAt(eYield, m_viInstantYieldsTotal[eYield] + iValue);


				//And now notifications.
				if(GetID() == GC.getGame().getActivePlayer() && iValue > 0)
				{
					char text[256] = {0};
					
					yieldString.Format("%s+%%d[ENDCOLOR] %s", pYieldInfo->getColorString(), pYieldInfo->getIconString());
					sprintf_s(text, yieldString, iValue);
					SHOW_PLOT_POPUP(pLoopCity->plot(), GetID(), text);

					if(citynameString == "")
					{
						citynameString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_CITY", pLoopCity->getNameKey());
					}
					if(cityyieldString != "")
					{
						cityyieldString += ", ";
					}
					if (iType == INSTANT_YIELD_TYPE_MINOR_QUEST_REWARD)
					{
						if (eYield == YIELD_CULTURE_LOCAL)
						{
							cityyieldString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_DETAILS_HAPPINESS", iValue);
						}
						else if (eYield == YIELD_JFD_LOYALTY)
						{
							cityyieldString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_DETAILS_INFLUENCE", iValue);
						}
						else if (eYield == YIELD_JFD_SOVEREIGNTY)
						{
							cityyieldString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_DETAILS_EXPERIENCE", iValue);
						}
						else if (eYield == YIELD_JFD_HEALTH && pCity == NULL)
						{
							cityyieldString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_DETAILS_GPP_GLOBAL", iValue);
						}
						else if (eYield == YIELD_JFD_HEALTH)
						{
							cityyieldString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_DETAILS_GPP", iValue);
						}
						else
						{
							cityyieldString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_DETAILS", pYieldInfo->GetDescriptionKey(), pYieldInfo->getIconString(), iValue);
						}
					}
					else
					{
						cityyieldString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_DETAILS", pYieldInfo->GetDescriptionKey(), pYieldInfo->getIconString(), iValue);
					}
 				}

				//store off this data
				if (eYield != YIELD_TOURISM)
				{
					changeInstantYieldValue(eYield, iValue);
				}
			}
		}
		if(citynameString != "" && cityyieldString != "")
		{
			citynameString += cityyieldString;
		}
		if(totalyieldString != "" && citynameString != "")
		{
			totalyieldString += "[NEWLINE]";
		}
		totalyieldString += citynameString;
	}
	CvNotifications* pNotifications = GetNotifications();
	if(!bSuppress && GetID() == GC.getGame().getActivePlayer() && pNotifications && totalyieldString != "")
	{
		Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_INSTANT_YIELD");
		if(pCity != NULL)
		{
			strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_INSTANT_YIELD_IN_CITY");
			strSummary << pCity->getNameKey();
		}
		Localization::String localizedText;
		switch(iType)
		{
			case INSTANT_YIELD_TYPE_MINOR_QUEST_REWARD:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					CvString MoreData = NULL;
					if (pQuestData != NULL)
					{
						const char* MinorName = GET_PLAYER(pQuestData->GetMinor()).getNameKey();
						switch (pQuestData->GetType())
						{
						case MINOR_CIV_QUEST_ROUTE:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_ROUTE_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_KILL_CAMP:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_KILL_CAMP_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_CONNECT_RESOURCE:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_CONNECT_RESOURCE_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_CONSTRUCT_WONDER:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_CONSTRUCT_WONDER_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_GREAT_PERSON:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_GREAT_PERSON_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_KILL_CITY_STATE:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_KILL_CITY_STATE_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_FIND_PLAYER:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_FIND_PLAYER_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_FIND_NATURAL_WONDER:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_FIND_NATURAL_WONDER_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_GIVE_GOLD:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_GIVE_GOLD_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_PLEDGE_TO_PROTECT:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_PLEDGE_TO_PROTECT_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_CONTEST_CULTURE:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_CONTEST_CULTURE_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_CONTEST_FAITH:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_CONTEST_FAITH_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_CONTEST_TECHS:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_CONTEST_TECHS_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_INVEST:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_INVEST_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_BULLY_CITY_STATE:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_BULLY_CITY_STATE_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_DENOUNCE_MAJOR:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_DENOUNCE_MAJOR_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_SPREAD_RELIGION:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_SPREAD_RELIGION_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_TRADE_ROUTE:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_TRADE_ROUTE_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_WAR:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_WAR_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_CONSTRUCT_NATIONAL_WONDER:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_CONSTRUCT_NATIONAL_WONDER_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_FIND_CITY_STATE:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_FIND_CITY_STATE_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_INFLUENCE:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_INFLUENCE_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_CONTEST_TOURISM:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_CONTEST_TOURISM_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_ARCHAEOLOGY:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_ARCHAEOLOGY_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_CIRCUMNAVIGATION:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_CIRCUMNAVIGATION_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_LIBERATION:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_LIBERATION_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_HORDE:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_HORDE_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_REBELLION:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_REBELLION_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_DISCOVER_PLOT:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_DISCOVER_PLOT_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_BUILD_X_BUILDINGS:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_BUILD_X_BUILDINGS_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_UNIT_STEAL_FROM:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_UNIT_STEAL_FROM_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_UNIT_COUP_CITY:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_UNIT_COUP_CITY_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_UNIT_GET_CITY:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_UNIT_GET_CITY_NAME", MinorName);
							break;
						}
					}

					if (MoreData != NULL)
					{
						localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_MINOR_QUEST");
						localizedText << MoreData;
						localizedText << totalyieldString;
						//We do this at the player level once per turn.
						addInstantYieldText(iType, localizedText.toUTF8());
					}
					else
					{
						localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_MINOR_QUEST");
						localizedText << "";
						localizedText << totalyieldString;
						//We do this at the player level once per turn.
						addInstantYieldText(iType, localizedText.toUTF8());
					}
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_BIRTH:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_BIRTH");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_BIRTH_RETROACTIVE:
			{
				if (getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_BIRTH_RETROACTIVE");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_ERA_UNLOCK:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_ERA");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_POLICY_UNLOCK:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_POLICY");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_INSTANT:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_INSTANT");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_TECH:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_TECH");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_CONSTRUCTION:
			case INSTANT_YIELD_TYPE_CONSTRUCTION_WONDER:
			{
				if(eBuilding != NO_BUILDING)
				{
					CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
					if(pkBuildingInfo)
					{
						if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
						{
							localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_CONSTRUCTION");
							localizedText << totalyieldString << pkBuildingInfo->GetDescriptionKey();
							//We do this at the player level once per turn.
							addInstantYieldText(iType, localizedText.toUTF8());
						}
						else
						{
							localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
							localizedText << totalyieldString << pkBuildingInfo->GetDescriptionKey();
							//We do this at the player level once per turn.
							addInstantYieldText(iType, localizedText.toUTF8());
						}
					}
				}
				return;
			}
			case INSTANT_YIELD_TYPE_BORDERS:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_BORDERS");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_PROPOSAL:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_PROPOSAL");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_GP_USE:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_GP_USE");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_GP_BORN:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_GP_BORN");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_F_CONQUEST:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_CONQUEST");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_VICTORY:
			case INSTANT_YIELD_TYPE_VICTORY_GLOBAL:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_VICTORY");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_PILLAGE:
			case INSTANT_YIELD_TYPE_PILLAGE_GLOBAL:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_PILLAGE");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_U_PROD:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_UNIT_PRODUCTION");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_PURCHASE:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_PURCHASE");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_TILE_PURCHASE:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_TILE_PURCHASE");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_FOUND:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_FOUND");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_TR_END:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_TRADE_ROUTE");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_CONVERSION:
			case INSTANT_YIELD_TYPE_CONVERSION_EXPO:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_CONVERSION");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_DEATH:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_DEATH");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_BULLY:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_BULLY");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_SPREAD:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_SPREAD");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_F_SPREAD:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_FOREIGN_SPREAD");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_DELEGATES:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_DELEGATES");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_SPY_DEFENSE:
			case INSTANT_YIELD_TYPE_SPY_ATTACK:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_SPIES");
				localizedText << totalyieldString;
				break;
			}
			
			case INSTANT_YIELD_TYPE_TR_MOVEMENT:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_TR_MOVEMENT");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_SCOUTING:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_SCOUTING");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_LEVEL_UP:
			{
				if(pUnit != NULL)
				{
					CvUnitEntry* pkUnitInfo = GC.getUnitInfo(pUnit->getUnitType());
					if(pkUnitInfo)
					{
						localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_LEVEL_UP");
						localizedText << totalyieldString;
						localizedText << pkUnitInfo->GetDescriptionKey();
						break;
					}
				}
			}	
			case INSTANT_YIELD_TYPE_CULTURE_BOMB:
			{
				if (getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_CULTURE_BOMB");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_REMOVE_HERESY:
			{
				if (getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_REMOVE_HERESY");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_FAITH_PURCHASE:
			{
				if (getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_FAITH_PURCHASE");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_PROMOTION_OBTAINED:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_PROMOTION_OBTAINED");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_BARBARIAN_CAMP_CLEARED:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_BARBARIAN_CAMP_CLEARED");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_TR_PRODUCTION_SIPHON:
			{
				if (getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_TR_PRODUCTION_SIPHON");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_TR_MOVEMENT_IN_FOREIGN:
			{
				if (getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_TR_MOVEMENT_IN_FOREIGN");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
		}
		if(pCity == NULL)
		{
			CvCity* pCapitalCity = getCapitalCity();
			if(pCapitalCity != NULL)
			{
				pNotifications->Add((NotificationTypes)FString::Hash("NOTIFICATION_INSTANT_YIELD"), localizedText.toUTF8(), strSummary.toUTF8(), pCapitalCity->getX(), pCapitalCity->getY(), pCapitalCity->GetID());
			}
		}
		else
		{
			pNotifications->Add((NotificationTypes)FString::Hash("NOTIFICATION_INSTANT_YIELD"), localizedText.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), pCity->GetID());
		}
	}
}
void CvPlayer::addInstantYieldText(InstantYieldType iType, CvString strInstantYield)
{
	VALIDATE_OBJECT
	CvAssertMsg(iType >= 0, "iType expected to be >= 0");
	CvAssertMsg(iType < NUM_INSTANT_YIELD_TYPES, "iType expected to be < NUM_INSTANT_YIELD_TYPES");

	m_aistrInstantYield.setAt(iType, m_aistrInstantYield[iType] + strInstantYield);
}
void CvPlayer::setInstantYieldText(InstantYieldType iType, CvString strInstantYield)
{
	VALIDATE_OBJECT
	CvAssertMsg(iType >= 0, "iType expected to be >= 0");
	CvAssertMsg(iType < NUM_INSTANT_YIELD_TYPES, "iType expected to be < NUM_INSTANT_YIELD_TYPES");
	m_aistrInstantYield.setAt(iType, strInstantYield);
}
CvString CvPlayer::getInstantYieldText(InstantYieldType iType) const
{
	VALIDATE_OBJECT
	CvAssertMsg(iType >= 0, "iType expected to be >= 0");
	CvAssertMsg(iType < NUM_INSTANT_YIELD_TYPES, "iType expected to be < NUM_INSTANT_YIELD_TYPES");
	return m_aistrInstantYield[iType];
}
void CvPlayer::doInstantGWAM(GreatPersonTypes eGreatPerson, CvString strName, bool bConquest)
{
	CvCity* pCapital = getCapitalCity();
	int iEventGP = 0;
	if (bConquest)
		iEventGP += GetPlayerTraits()->GetCityConquestGWAM();
	else
		iEventGP += GetPlayerTraits()->GetGreatPersonGWAM(eGreatPerson);

	if (pCapital != NULL && iEventGP > 0)
	{
		int iGPWriter = 0;
		int iGPArtist = 0;
		int iGPMusician = 0;
		for (int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
		{
			const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iSpecialistLoop);
			CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
			if (pkSpecialistInfo)
			{
				if ((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_WRITER"))
				{
					iGPWriter = pCapital->GetCityCitizens()->GetSpecialistUpgradeThreshold((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass());
					iGPWriter *= 100;
					//Get % of threshold for test.
					iGPWriter *= iEventGP;
					iGPWriter /= 100;

					pCapital->GetCityCitizens()->ChangeSpecialistGreatPersonProgressTimes100(eSpecialist, iGPWriter, true);
				}
				if ((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_ARTIST"))
				{
					iGPArtist = pCapital->GetCityCitizens()->GetSpecialistUpgradeThreshold((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass());
					iGPArtist *= 100;
					//Get % of threshold for test.
					iGPArtist *= iEventGP;
					iGPArtist /= 100;

					pCapital->GetCityCitizens()->ChangeSpecialistGreatPersonProgressTimes100(eSpecialist, iGPArtist, true);

				}
				if ((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_MUSICIAN"))
				{
					iGPMusician = pCapital->GetCityCitizens()->GetSpecialistUpgradeThreshold((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass());
					iGPMusician *= 100;
					//Get % of threshold for test.
					iGPMusician *= iEventGP;
					iGPMusician /= 100;

					pCapital->GetCityCitizens()->ChangeSpecialistGreatPersonProgressTimes100(eSpecialist, iGPMusician, true);
				}
			}
		}
		if (GetID() == GC.getGame().getActivePlayer())
		{
			iGPWriter /= 100;
			iGPArtist /= 100;
			iGPMusician /= 100;
			CvNotifications* pNotification = GetNotifications();
			if (pNotification)
			{
				Localization::String strMessage = "";
				if (bConquest)
				{
					strMessage = Localization::Lookup("TXT_KEY_TOURISM_EVENT_GWAM_BONUS_CONQUEST");
					strMessage << iGPWriter;
					strMessage << iGPArtist;
					strMessage << iGPMusician;
					strMessage << strName.c_str();
				}
				else
				{
					strMessage = Localization::Lookup("TXT_KEY_TOURISM_EVENT_GWAM_BONUS_SAKOKU");
					strMessage << iGPWriter;
					strMessage << iGPArtist;
					strMessage << iGPMusician;
					strMessage << strName.c_str();
				}
				
				Localization::String strSummary = "";
				if (bConquest)
					strSummary = Localization::Lookup("TXT_KEY_TOURISM_EVENT_GWAM_BONUS_CONQUEST_S");
				else
					strSummary = Localization::Lookup("TXT_KEY_TOURISM_EVENT_GWAM_BONUS_SAKOKU_S");

				pNotification->Add(NOTIFICATION_GOLDEN_AGE_BEGUN_ACTIVE_PLAYER, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, -1);
			}
		}
	}
}
//	--------------------------------------------------------------------------------
void CvPlayer::doPolicyGEorGM(int iPolicyGEorGM)
{
	CvCity* pLoopCity;
	CvCity* pCapital = getCapitalCity();
	int iLoop;
	int iEra = GetCurrentEra();
	if (iEra < 1)
	{
		iEra = 1;
	}
	int iValue = iPolicyGEorGM * iEra * GC.getGame().getGameSpeedInfo().getInstantYieldPercent(); // Game speed mod (note that TrainPercent is a percentage value, will need to divide by 100)

	SpecialistTypes eBestSpecialist = NO_SPECIALIST;
	int iRandom = GC.getGame().getSmallFakeRandNum(100, GetPseudoRandomSeed()+iPolicyGEorGM);
	if (iRandom <= 33)
	{
		eBestSpecialist = (SpecialistTypes)GC.getInfoTypeForString("SPECIALIST_ENGINEER");
	}
	else if (iRandom > 34 && iRandom <= 66)
	{
		eBestSpecialist = (SpecialistTypes)GC.getInfoTypeForString("SPECIALIST_SCIENTIST");
	}
	else if (iRandom > 66)
	{
		eBestSpecialist = (SpecialistTypes)GC.getInfoTypeForString("SPECIALIST_MERCHANT");
	}
	if (eBestSpecialist != NULL && pCapital != NULL)
	{
		CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eBestSpecialist);
		if (pkSpecialistInfo)
		{
			int iGPThreshold = pCapital->GetCityCitizens()->GetSpecialistUpgradeThreshold((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass());
			iGPThreshold *= 100;
			//Get % of threshold for test.
			iGPThreshold *= iPolicyGEorGM;
			iGPThreshold /= 100;
			int iGPThresholdString = iGPThreshold / 100;

			for (pLoopCity = this->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = this->nextCity(&iLoop))
			{
				if (eBestSpecialist == (SpecialistTypes)GC.getInfoTypeForString("SPECIALIST_ENGINEER"))
				{
					pLoopCity->changeProduction((iValue * 2) / 100); // Production yield is 2x of science. Dividing by 100 here to minimise rounding error.
				}
				else if (eBestSpecialist == (SpecialistTypes)GC.getInfoTypeForString("SPECIALIST_MERCHANT"))
				{
					this->GetTreasury()->ChangeGold((iValue * 4) / 100); // Gold yield is 4x of science, 2x of production. Dividing by 100 here to minimise rounding error.
				}
				else if (eBestSpecialist == (SpecialistTypes)GC.getInfoTypeForString("SPECIALIST_SCIENTIST"))
				{
					TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
					if (eCurrentTech == NO_TECH)
					{
						changeOverflowResearch(iValue / 100); // Dividing by 100 here to minimise rounding error.
						if (getOverflowResearch() <= 0)
						{
							setOverflowResearch(0);
						}
					}
					else
					{
						GET_TEAM(getTeam()).GetTeamTechs()->ChangeResearchProgress(eCurrentTech, (iValue / 100), GetID()); // Dividing by 100 here to minimise rounding error.
						if (GET_TEAM(getTeam()).GetTeamTechs()->GetResearchProgress(eCurrentTech) <= 0)
						{
							GET_TEAM(getTeam()).GetTeamTechs()->SetResearchProgress(eCurrentTech, 0, GetID());
						}
					}
				}
				pLoopCity->GetCityCitizens()->ChangeSpecialistGreatPersonProgressTimes100(eBestSpecialist, iGPThreshold, true);
				if (GetID() == GC.getGame().getActivePlayer()) // The popup shows the specific great person type's icon
				{
					if (eBestSpecialist == (SpecialistTypes)GC.getInfoTypeForString("SPECIALIST_ENGINEER"))
					{
						char text[256] = { 0 };

						sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_GREAT_ENGINEER]", iGPThresholdString);
						SHOW_PLOT_POPUP(pLoopCity->plot(), GetID(),  text);
						char text2[256] = { 0 };
						sprintf_s(text2, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_PRODUCTION]", (iValue * 2 / 100));
						SHOW_PLOT_POPUP(pLoopCity->plot(), GetID(),  text2);
					}
					else if (eBestSpecialist == (SpecialistTypes)GC.getInfoTypeForString("SPECIALIST_MERCHANT"))
					{
						char text[256] = { 0 };

						sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_GREAT_MERCHANT]", iGPThresholdString);
						SHOW_PLOT_POPUP(pLoopCity->plot(), GetID(),  text);
						char text2[256] = { 0 };
						sprintf_s(text2, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_GOLD]", (iValue * 4 / 100));
						SHOW_PLOT_POPUP(pLoopCity->plot(), GetID(),  text2);
					}
					else if (eBestSpecialist == (SpecialistTypes)GC.getInfoTypeForString("SPECIALIST_SCIENTIST"))
					{
						char text[256] = { 0 };

						sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_GREAT_SCIENTIST]", iGPThresholdString);
						SHOW_PLOT_POPUP(pLoopCity->plot(), GetID(),  text);
						char text2[256] = { 0 };
						sprintf_s(text2, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_RESEARCH]", (iValue / 100));
						SHOW_PLOT_POPUP(pLoopCity->plot(), GetID(),  text2);
					}
				}
			} //end of for loop
			if (GetID() == GC.getGame().getActivePlayer()) // Moved notification outside of for loop as it was flooding the screen
			{
				CvNotifications* pNotification = GetNotifications();
				if (pNotification)
				{
					CvString strMessage = GetLocalizedText("TXT_KEY_POLICY_ADOPT_GP_BONUS", iGPThresholdString);
					CvString strSummary;
					// Class specific specialist message
					if ((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_MERCHANT"))
					{
						strMessage = GetLocalizedText("TXT_KEY_POLICY_ADOPT_GP_BONUS_MERCHANT", iGPThresholdString, (iValue * 4 / 100));
					}
					else if ((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_ENGINEER"))
					{
						strMessage = GetLocalizedText("TXT_KEY_POLICY_ADOPT_GP_BONUS_ENGINEER", iGPThresholdString, (iValue * 2 / 100));
					}
					else if ((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_SCIENTIST"))
					{
						strMessage = GetLocalizedText("TXT_KEY_POLICY_ADOPT_GP_BONUS_SCIENTIST", iGPThresholdString, (iValue / 100));
					}
					strSummary = GetLocalizedText("TXT_KEY_POLICY_ADOPT_SUMMARY_GP_BONUS");
					pNotification->Add(NOTIFICATION_GOLDEN_AGE_BEGUN_ACTIVE_PLAYER, strMessage, strSummary, -1, -1, -1);
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::doInstantGreatPersonProgress(InstantYieldType iType, bool bSuppress, CvCity* pCity, BuildingTypes eBuilding)
{
	CvCity* pLoopCity;
	CvCity* pCapital = getCapitalCity();
	int iLoop;
	CvString totalgpString = "";

	for (pLoopCity = this->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = this->nextCity(&iLoop))
	{
		if (pLoopCity == NULL)
			continue;

		//If we passed in a city, only check that city.
		if (pCity != NULL && pLoopCity != pCity)
			continue;

		// Puppets are not supposed to get GP points
		if (MOD_BALANCE_CORE_PUPPET_CHANGES && pLoopCity->IsPuppet())
			continue;

		CvString gpString = "";
		CvString citygpString = "";
		CvString citynameString = "";

		SpecialistTypes eSpecialist;

		for (int iGreatPersonTypes = 0; iGreatPersonTypes < GC.getNumGreatPersonInfos(); iGreatPersonTypes++)
		{
			GreatPersonTypes eGreatPerson = (GreatPersonTypes)iGreatPersonTypes;
			if (eGreatPerson == NULL || pCapital == NULL)
				continue;

			eSpecialist = (SpecialistTypes)GC.getGreatPersonInfo(eGreatPerson)->GetSpecialistType();
			if (eSpecialist == NULL)
				continue;

			// 1st step: Get the percent to progress towards the next GP
			int iValue = 0;
			switch (iType)
			{
				case INSTANT_YIELD_TYPE_POLICY_UNLOCK:
				{
					if (pLoopCity->isCapital() == true)
					{
						iValue += GetPlayerTraits()->GetGreatPersonProgressFromPolicyUnlock(eGreatPerson);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_CONSTRUCTION:
				{
					if (eBuilding != NO_BUILDING)
					{
						TechTypes eTech = (TechTypes)GC.getBuildingInfo(eBuilding)->GetPrereqAndTech();
						int iEra;
						if (eTech == NO_TECH)
						{
							iEra = 0;
						}
						else
						{
							iEra = GC.getTechInfo(eTech)->GetEra();
						}
						for (int iLoopEra = 0; iLoopEra <= iEra; ++iLoopEra)
						{
							iValue += pLoopCity->GetGreatPersonProgressFromConstruction(eGreatPerson, (EraTypes)iLoopEra);
						}
					}
					break;
				}
			}

			// 2nd step: Apply the desired amount of GP points to the loop city
			if (iValue != 0)
			{
				CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
				if (pkSpecialistInfo)
				{
					int iGPThreshold = pCapital->GetCityCitizens()->GetSpecialistUpgradeThreshold((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass());
					iGPThreshold *= 100;
					//Get % of threshold for test.
					iGPThreshold *= iValue;
					iGPThreshold /= 100;
					int iGPThresholdString = iGPThreshold / 100;
					CvGreatPersonInfo* pGreatPerson = GC.getGreatPersonInfo(eGreatPerson);
					pLoopCity->GetCityCitizens()->ChangeSpecialistGreatPersonProgressTimes100(eSpecialist, iGPThreshold, false); // Dont spawn the GP yet, so the points given to all cities remain the same
					// 3rd step: Notifications
					if (GetID() == GC.getGame().getActivePlayer() && iValue > 0)
					{
						char text[256] = { 0 };
						
						gpString.Format("%s+%%d[ENDCOLOR] %s", "[COLOR_WHITE]", pGreatPerson->GetIconString());
						sprintf_s(text, gpString, iGPThresholdString);
						SHOW_PLOT_POPUP(pLoopCity->plot(), GetID(),  text);
					}
					if (citynameString == "")
					{
						citynameString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_CITY", pLoopCity->getNameKey());
					}
					if (citygpString != "")
					{
						citygpString += ", ";
					}
					citygpString += GetLocalizedText("TXT_KEY_INSTANT_GREAT_PERSON_PROGRESS_DETAILS", pGreatPerson->GetDescriptionKey(), pGreatPerson->GetIconString(), iGPThresholdString);
				}
			}
		}
		if (citynameString != "" && citygpString != "")
		{
			citynameString += citygpString;
		}
		if (totalgpString != "" && citynameString != "")
		{
			totalgpString += "[NEWLINE]";
		}
		totalgpString += citynameString;
	}
	CvNotifications* pNotifications = GetNotifications();
	if (!bSuppress && GetID() == GC.getGame().getActivePlayer() && pNotifications && totalgpString != "")
	{
		Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_GREAT_PERSON_PROGRESS");
		if (pCity != NULL)
		{
			strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_GREAT_PERSON_PROGRESS_IN_CITY");
			strSummary << pCity->getNameKey();
		}
		Localization::String localizedText;
		switch (iType)
		{
			case INSTANT_YIELD_TYPE_POLICY_UNLOCK:
			{
				if (getInstantGreatPersonProgressText(iType) == "" || getInstantGreatPersonProgressText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_POLICY");
					localizedText << totalgpString;
					//We do this at the player level once per turn.
					addInstantGreatPersonProgressText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalgpString;
					//We do this at the player level once per turn.
					addInstantGreatPersonProgressText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_CONSTRUCTION:
				if (eBuilding != NO_BUILDING)
				{
					CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
					if (pkBuildingInfo)
					{
						if (getInstantGreatPersonProgressText(iType) == "" || getInstantGreatPersonProgressText(iType) == NULL)
						{
							localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_CONSTRUCTION");
							localizedText << totalgpString << pkBuildingInfo->GetDescriptionKey();
							//We do this at the player level once per turn.
							addInstantGreatPersonProgressText(iType, localizedText.toUTF8());
						}
						else
						{
							localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
							localizedText << totalgpString << pkBuildingInfo->GetDescriptionKey();
							//We do this at the player level once per turn.
							addInstantGreatPersonProgressText(iType, localizedText.toUTF8());
						}
					}
				}
				return;
		}
		if (pCity == NULL)
		{
			if (pCapital != NULL)
			{
				pNotifications->Add((NotificationTypes)FString::Hash("NOTIFICATION_INSTANT_YIELD"), localizedText.toUTF8(), strSummary.toUTF8(), pCapital->getX(), pCapital->getY(), pCapital->GetID());
			}
		}
		else
		{
			pNotifications->Add((NotificationTypes)FString::Hash("NOTIFICATION_INSTANT_YIELD"), localizedText.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), pCity->GetID());
		}
	}
	// 4th step: Loop through all cities again to check for GP spawns
	for (pLoopCity = this->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = this->nextCity(&iLoop))
	{
		if (pLoopCity == NULL)
			continue;
		for (int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
		{
			const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iSpecialistLoop);
			CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
			if (pkSpecialistInfo)
			{
				int iCheckGPThreshold = pLoopCity->GetCityCitizens()->GetSpecialistUpgradeThreshold((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass());
				// Enough to spawn a GP?
				if (pLoopCity->GetCityCitizens()->GetSpecialistGreatPersonProgress(eSpecialist) >= iCheckGPThreshold)
				{
					// No Minors
					if (!GET_PLAYER(pLoopCity->getOwner()).isMinorCiv())
					{
						// Reset progress on this Specialist
						pLoopCity->GetCityCitizens()->DoResetSpecialistGreatPersonProgressTimes100(eSpecialist, (iCheckGPThreshold * 100));

						// Now... actually create the GP!
						const UnitClassTypes eUnitClass = (UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass();
						const CivilizationTypes eCivilization = pLoopCity->getCivilizationType();
						CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(eCivilization);
						if (pCivilizationInfo != NULL)
						{
							UnitTypes eUnit = (UnitTypes)pCivilizationInfo->getCivilizationUnits(eUnitClass);

#if defined(MOD_GLOBAL_TRULY_FREE_GP)
							pLoopCity->GetCityCitizens()->DoSpawnGreatPerson(eUnit, true, false, false);
#else
							pLoopCity->GetCityCitizens()->DoSpawnGreatPerson(eUnit, true, false);
#endif
						}
					}
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::addInstantGreatPersonProgressText(InstantYieldType iType, CvString strInstantYield)
{
	VALIDATE_OBJECT
	CvAssertMsg(iType >= 0, "iType expected to be >= 0");
	CvAssertMsg(iType < NUM_INSTANT_YIELD_TYPES, "iType expected to be < NUM_INSTANT_YIELD_TYPES");

	std::map<int, CvString>::iterator it = m_aistrInstantGreatPersonProgress.find((int)iType);
	if (it != m_aistrInstantGreatPersonProgress.end())
	{
		it->second += strInstantYield;
	}
	else
	{
		m_aistrInstantGreatPersonProgress.insert(std::make_pair((int)iType, strInstantYield));
	}
}
void CvPlayer::setInstantGreatPersonProgressText(InstantYieldType iType, CvString strInstantYield)
{
	VALIDATE_OBJECT
	CvAssertMsg(iType >= 0, "iType expected to be >= 0");
	CvAssertMsg(iType < NUM_INSTANT_YIELD_TYPES, "iType expected to be < NUM_INSTANT_YIELD_TYPES");

	std::map<int, CvString>::iterator it = m_aistrInstantGreatPersonProgress.find((int)iType);
	if (it != m_aistrInstantGreatPersonProgress.end())
	{
		it->second = strInstantYield;
	}
	else
	{
		m_aistrInstantGreatPersonProgress.insert(std::make_pair((int)iType, strInstantYield));
	}
}
CvString CvPlayer::getInstantGreatPersonProgressText(InstantYieldType iType) const
{
	VALIDATE_OBJECT
	CvAssertMsg(iType >= 0, "iType expected to be >= 0");
	CvAssertMsg(iType < NUM_INSTANT_YIELD_TYPES, "iType expected to be < NUM_INSTANT_YIELD_TYPES");

	std::map<int, CvString>::const_iterator it = m_aistrInstantGreatPersonProgress.find((int)iType);
	if (it != m_aistrInstantGreatPersonProgress.end())
	{
		return it->second;
	}
	else
	{
		return "";
	}
}
#endif
//	--------------------------------------------------------------------------------
/// Do effects when a GP is consumed
#if defined(MOD_EVENTS_GREAT_PEOPLE)
void CvPlayer::DoGreatPersonExpended(UnitTypes eGreatPersonUnit, CvUnit* pGreatPersonUnit)
#else
void CvPlayer::DoGreatPersonExpended(UnitTypes eGreatPersonUnit)
#endif
{
	// Gold gained
	int iExpendGold = GetGreatPersonExpendGold();
	if(iExpendGold > 0)
	{
#if defined(MOD_BALANCE_CORE)
		iExpendGold *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
		iExpendGold /= 100;
#endif
		GetTreasury()->ChangeGold(iExpendGold);

#if !defined(NO_ACHIEVEMENTS)
		if(isHuman() && !GC.getGame().isGameMultiPlayer() && GET_PLAYER(GC.getGame().getActivePlayer()).isLocalPlayer())
		{
			// Update Steam stat and check achievement
			const int HALICARNASSUS_ACHIEVEMENT_GOLD = 1000;
			int iHalicarnassus = GC.getInfoTypeForString("BUILDINGCLASS_MAUSOLEUM_HALICARNASSUS");
			// Does player have DLC_06, and if so, do they have the Mausoleum of Halicarnassus?
			if(iHalicarnassus != -1 && getBuildingClassCount((BuildingClassTypes)iHalicarnassus) >= 1)
			{
				BuildingTypes eHalicarnassus = (BuildingTypes)GC.getInfoTypeForString("BUILDING_MAUSOLEUM_HALICARNASSUS");
				CvBuildingEntry* pHalicarnassusInfo = GC.getBuildingInfo(eHalicarnassus);
				int iHalicarnassusGold = pHalicarnassusInfo->GetGreatPersonExpendGold();

				int32 iTotalHalicarnassusGold = 0;
				if(gDLL->GetSteamStat(ESTEAMSTAT_HALICARNASSUSGOLDEARNED, &iTotalHalicarnassusGold))
				{
					iTotalHalicarnassusGold += iHalicarnassusGold;
					gDLL->SetSteamStat(ESTEAMSTAT_HALICARNASSUSGOLDEARNED, iTotalHalicarnassusGold);
					if(iTotalHalicarnassusGold >= HALICARNASSUS_ACHIEVEMENT_GOLD)
					{
						gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_HALICARNASSUS_GOLD);
					}
				}
			}
		}
#endif
	}

	if (pGreatPersonUnit)
	{
		//admiral grants a resource
		for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
		{
			int Gained = pGreatPersonUnit->getUnitInfo().GetResourceQuantityExpended((ResourceTypes)iResourceLoop);
			if (Gained != 0)
				changeNumResourceTotal((ResourceTypes)iResourceLoop, Gained);
		}

		//general grants supply points
		int iSupply = pGreatPersonUnit->getUnitInfo().GetSupplyCapBoost() + pGreatPersonUnit->GetMilitaryCapChange();
		if (iSupply > 0 && getCapitalCity() != NULL)
		{
			getCapitalCity()->changeCitySupplyFlat(iSupply);
			m_iNumUnitsSuppliedCached = -1; //force recalculation

			if (GetID() == GC.getGame().getActivePlayer())
			{
				char text[256] = { 0 };

				sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_WAR]", iSupply);
				SHOW_PLOT_POPUP( pGreatPersonUnit->plot(), GetID(), text);

				CvNotifications* pNotification = GetNotifications();
				if (pNotification)
				{
					CvString strMessage;
					CvString strSummary;
					strMessage = GetLocalizedText("TXT_KEY_UNIT_EXPENDED_SUPPLY", pGreatPersonUnit->getName().c_str(), iSupply);
					strSummary = GetLocalizedText("TXT_KEY_UNIT_EXPENDED_SUPPLY_S");
					pNotification->Add(NOTIFICATION_GENERIC, strMessage, strSummary, pGreatPersonUnit->getX(), pGreatPersonUnit->getY(), GetID());
				}
			}
		}
	}

#if defined(MOD_API_UNIFIED_YIELDS)
#else
	// Faith gained
	ReligionTypes eReligionFounded = GetReligions()->GetReligionCreatedByPlayer();
	if(eReligionFounded > RELIGION_PANTHEON)
	{
		const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eReligionFounded, GetID());
		if(pReligion)
		{
			int iFaith = pReligion->m_Beliefs.GetGreatPersonExpendedFaith();
			if(iFaith > 0)
			{
				iFaith *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iFaith /= 100;
				ChangeFaith(iFaith);
			}
#if defined(MOD_BALANCE_CORE_BELIEFS)
			int iEra = GetCurrentEra();
			if(iEra < 1)
			{
				iEra = 1;
			}
			int iCulture = pReligion->m_Beliefs.GetYieldFromGPUse(YIELD_CULTURE) * iEra;
			if(iCulture > 0)
			{
				changeJONSCulture(iCulture);
				if(GetID() == GC.getGame().getActivePlayer())
				{
					char text[256] = {0};
					
					sprintf_s(text, "[COLOR_MAGENTA]+%d[ENDCOLOR][ICON_CULTURE]", iCulture);
					DLLUI->AddPopupText(pGreatPersonUnit->getX(),pGreatPersonUnit->getY(), text);
				}
			}
			int iFaith2 = pReligion->m_Beliefs.GetYieldFromGPUse(YIELD_FAITH) * iEra;
			if(iFaith2 > 0)
			{
				ChangeFaith(iFaith2);
				if(GetID() == GC.getGame().getActivePlayer())
				{
					char text[256] = {0};
					
					sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_PEACE]", iFaith2);
					DLLUI->AddPopupText(pGreatPersonUnit->getX(),pGreatPersonUnit->getY(), text);
				}
			}
			int iGold = pReligion->m_Beliefs.GetYieldFromGPUse(YIELD_GOLD) * iEra;
			if(iGold > 0)
			{
				GetTreasury()->ChangeGold(iGold);
				if(GetID() == GC.getGame().getActivePlayer())
				{
					char text[256] = {0};
					
					sprintf_s(text, "[COLOR_YELLOW]+%d[ENDCOLOR][ICON_GOLD]", iGold);
					DLLUI->AddPopupText(pGreatPersonUnit->getX(),pGreatPersonUnit->getY(), text);
				}
			}
			int iScience = pReligion->m_Beliefs.GetYieldFromGPUse(YIELD_SCIENCE) * iEra;
			if(iScience > 0)
			{
				TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
				if(eCurrentTech == NO_TECH)
				{
					changeOverflowResearch(iScience);
				}
				else
				{
					GET_TEAM(GET_PLAYER(GetID()).getTeam()).GetTeamTechs()->ChangeResearchProgress(eCurrentTech, iScience, GetID());
				}
				if(GetID() == GC.getGame().getActivePlayer())
				{
					char text[256] = {0};
					
					sprintf_s(text, "[COLOR_BLUE]+%d[ENDCOLOR][ICON_RESEARCH]", iScience);
					DLLUI->AddPopupText(pGreatPersonUnit->getX(),pGreatPersonUnit->getY(), text);
				}
			}
			int iGA = pReligion->m_Beliefs.GetYieldFromGPUse(YIELD_GOLDEN_AGE_POINTS) * iEra;
			if(iGA > 0)
			{
				ChangeGoldenAgeProgressMeter(iGA);
				if(GetID() == GC.getGame().getActivePlayer())
				{
					char text[256] = {0};
					
					sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_GOLDEN_AGE]", iGA);
					DLLUI->AddPopupText(pGreatPersonUnit->getX(),pGreatPersonUnit->getY(), text);
				}
			}
#endif
		}
	}
#endif

#if defined(MOD_BALANCE_CORE_POLICIES) || defined(MOD_DIPLOMACY_CITYSTATES)
	//Influence Gained with all CS per expend
	int iExpendInfluence = GetInfluenceGPExpend() + GetGPExpendInfluence(); 
	if(iExpendInfluence > 0)
	{
		for (int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
		{
			PlayerTypes eMinorLoop = (PlayerTypes) iMinorLoop;
			if(eMinorLoop != NO_PLAYER)
			{
				CvPlayer* pMinorLoop = &GET_PLAYER(eMinorLoop);
				if(pMinorLoop->isMinorCiv() && pMinorLoop->isAlive())
				{
					if(GET_TEAM(pMinorLoop->getTeam()).isHasMet(getTeam()))
					{
						pMinorLoop->GetMinorCivAI()->ChangeFriendshipWithMajor(GetID(), iExpendInfluence, false);
					}
				}
			}
		}
	}
	GreatPersonTypes eGreatPerson = GetGreatPersonFromUnitClass(pGreatPersonUnit->getUnitClassType());
	doInstantYield(INSTANT_YIELD_TYPE_GP_USE, false, eGreatPerson);
#endif

#if defined(MOD_EVENTS_GREAT_PEOPLE)
	if (MOD_EVENTS_GREAT_PEOPLE) {
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_GreatPersonExpended, GetID(), pGreatPersonUnit->GetID(), eGreatPersonUnit, pGreatPersonUnit->getX(), pGreatPersonUnit->getY());
	} else {
#endif
	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if (pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(eGreatPersonUnit);

		bool bResult;
		LuaSupport::CallHook(pkScriptSystem, "GreatPersonExpended", args.get(), bResult);
	}
#if defined(MOD_EVENTS_GREAT_PEOPLE)
	}
#endif
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetGreatPersonExpendGold() const
{
	return m_iGreatPersonExpendGold;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeGreatPersonExpendGold(int ichange)
{
	m_iGreatPersonExpendGold += ichange;
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
//	Calculate score-scaled ArtsyGreatPersonRateModifier
int CvPlayer::getArtsyGreatPersonRateModifier()
{
	return GC.getGame().GetGameLeagues()->GetArtsyGreatPersonRateModifier(GetID());
}
//	Calculate score-scaled ScienceyGreatPersonRateModifier
int CvPlayer::getScienceyGreatPersonRateModifier()
{
	return GC.getGame().GetGameLeagues()->GetScienceyGreatPersonRateModifier(GetID());
}
#endif

//	--------------------------------------------------------------------------------
void CvPlayer::recomputeGreatPeopleModifiers()
{
	//=============
	// Initialize
	//=============
	m_iGreatPeopleRateModifier = 0;
	m_iGreatGeneralRateModifier = 0;
	m_iGreatAdmiralRateModifier = 0;
	m_iGreatWriterRateModifier = 0;
	m_iGreatArtistRateModifier = 0;
	m_iGreatMusicianRateModifier = 0;
	m_iGreatMerchantRateModifier = 0;
#if defined(MOD_DIPLOMACY_CITYSTATES)
	m_iGreatDiplomatRateModifier = 0;
#endif
	m_iGreatScientistRateModifier = 0;
	m_iGreatEngineerRateModifier = 0;
	m_iDomesticGreatGeneralRateModifier = 0;

	// Get from traits first
	m_iGreatPeopleRateModifier += m_pTraits->GetGreatPeopleRateModifier();
	m_iGreatGeneralRateModifier += m_pTraits->GetGreatGeneralRateModifier();
	m_iGreatScientistRateModifier += m_pTraits->GetGreatScientistRateModifier();
#if defined(MOD_BALANCE_CORE)
	m_iGreatGeneralRateModifier += (m_pTraits->GetGGGARateFromDenunciationsAndWars()) * (GetDiplomacyAI()->GetNumDenouncements() + GET_TEAM(getTeam()).getAtWarCount(true));
	m_iGreatAdmiralRateModifier += (m_pTraits->GetGGGARateFromDenunciationsAndWars()) * (GetDiplomacyAI()->GetNumDenouncements() + GET_TEAM(getTeam()).getAtWarCount(true));
#endif

	// Then get from current policies
	m_iGreatPeopleRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_PERSON_RATE);
	m_iGreatGeneralRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_GENERAL_RATE);
	m_iGreatAdmiralRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_ADMIRAL_RATE);
	m_iGreatWriterRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_WRITER_RATE);
	m_iGreatArtistRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_ARTIST_RATE);
	m_iGreatMusicianRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_MUSICIAN_RATE);
	m_iGreatMerchantRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_MERCHANT_RATE);
#if defined(MOD_BALANCE_CORE)
	m_iGreatEngineerRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_ENGINEER_RATE);
#endif
#if defined(MOD_DIPLOMACY_CITYSTATES)
	if (MOD_DIPLOMACY_CITYSTATES) {
		m_iGreatDiplomatRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_DIPLOMAT_RATE);
	}
#endif
	m_iGreatScientistRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_SCIENTIST_RATE);
	m_iDomesticGreatGeneralRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_DOMESTIC_GREAT_GENERAL_RATE);

	// Next add in buildings
	m_iGreatPeopleRateModifier += m_iGreatPeopleRateModFromBldgs;
	m_iGreatGeneralRateModifier += m_iGreatGeneralRateModFromBldgs;
	m_iDomesticGreatGeneralRateModifier += m_iDomesticGreatGeneralRateModFromBldgs;

	// Finally anything from friendships
	m_iGreatPeopleRateModifier += GetGreatPeopleRateModFromFriendships();

	// And effects from Leagues
	int iArtsyMod = GC.getGame().GetGameLeagues()->GetArtsyGreatPersonRateModifier(GetID());
	int iScienceyMod = GC.getGame().GetGameLeagues()->GetScienceyGreatPersonRateModifier(GetID());
	if (iArtsyMod != 0)
	{
		m_iGreatWriterRateModifier += iArtsyMod;
		m_iGreatArtistRateModifier += iArtsyMod;
		m_iGreatMusicianRateModifier += iArtsyMod;
	}
	if (iScienceyMod != 0)
	{
		m_iGreatScientistRateModifier += iScienceyMod;
		m_iGreatEngineerRateModifier += iScienceyMod;
		m_iGreatMerchantRateModifier += iScienceyMod;
	}

	// Finally boost domestic general from combat experience
	m_iDomesticGreatGeneralRateModifier += GC.getCOMBAT_EXPERIENCE_IN_BORDERS_PERCENT();
}

//	--------------------------------------------------------------------------------
// Do we have a trait that rewards friendships (or have a friend that does)?
int CvPlayer::GetGreatPeopleRateModFromFriendships() const
{
	int iRtnValue = 0;
	int iTraitMod = GetPlayerTraits()->GetDOFGreatPersonModifier();

	// Have the trait, one for each friend
	if(iTraitMod > 0)
	{
		iRtnValue = GetDiplomacyAI()->GetNumDoF() * iTraitMod;
	}

	// Don't have the trait, just get bonus once if friends with a player that does
	else
	{
		PlayerTypes eLoopPlayer;
		for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			eLoopPlayer = (PlayerTypes) iPlayerLoop;

			if(GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))
			{
				if(GetDiplomacyAI()->IsDoFAccepted(eLoopPlayer))
				{
					int iOthersTraitMod = GET_PLAYER(eLoopPlayer).GetPlayerTraits()->GetDOFGreatPersonModifier();
					if(iOthersTraitMod > 0)
					{
						iRtnValue += iOthersTraitMod;
					}
				}
			}
		}
	}

	return iRtnValue;
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
int CvPlayer::GetGreatScientistBeakerMod() const
{
	return m_iGreatScientistBeakerModifier;
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
void CvPlayer::SetGreatScientistBeakerMod(int iValue)
{
	m_iGreatScientistBeakerModifier = iValue;
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
void CvPlayer::ChangeGreatScientistBeakerMod(int iChange)
{
	SetGreatScientistBeakerMod(GetGreatScientistBeakerMod() + iChange);
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
int CvPlayer::GetGreatEngineerHurryMod() const
{
	return m_iGreatEngineerHurryMod;
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
void CvPlayer::SetGreatEngineerHurryMod(int iValue)
{
	m_iGreatEngineerHurryMod = iValue;
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
void CvPlayer::ChangeGreatEngineerHurryMod(int iChange)
{
	SetGreatEngineerHurryMod(GetGreatEngineerHurryMod() + iChange);
}


//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
int CvPlayer::GetTechCostXCitiesModifier() const
{
	return m_iTechCostXCitiesModifier;
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
void CvPlayer::SetTechCostXCitiesModifier(int iValue)
{
	m_iTechCostXCitiesModifier = iValue;
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
void CvPlayer::ChangeTechCostXCitiesModifier(int iChange)
{
	SetTechCostXCitiesModifier(GetTechCostXCitiesModifier() + iChange);
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
int CvPlayer::GetTourismCostXCitiesMod() const
{
	return m_iTourismCostXCitiesMod;
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
void CvPlayer::ChangeTourismCostXCitiesMod(int iChange)
{
	m_iTourismCostXCitiesMod += iChange;
}



//////////////////////////////////////////////////////////////////////////
int CvPlayer::GetGreatGeneralCombatBonus() const
{
	return m_iGreatGeneralCombatBonus;
}

//////////////////////////////////////////////////////////////////////////
void CvPlayer::SetGreatGeneralCombatBonus(int iValue)
{
	m_iGreatGeneralCombatBonus = iValue;
}

void CvPlayer::ChangeGreatGeneralCombatBonus(int iValue)
{
	m_iGreatGeneralCombatBonus += iValue;
}


//////////////////////////////////////////////////////////////////////////
// ***** Great People Spawning *****
//////////////////////////////////////////////////////////////////////////

//	--------------------------------------------------------------------------------
// Figures out how long before we spawn a free Great Person for ePlayer
void CvPlayer::DoSeedGreatPeopleSpawnCounter()
{
	int iNumTurns = /*37*/ GC.getMINOR_TURNS_GREAT_PEOPLE_SPAWN_BASE();

	// Start at -1 since if we only have one ally we don't want to add any more
	int iExtraAllies = -1;

	PlayerTypes eMinor;
	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		eMinor = (PlayerTypes) iMinorLoop;

		// Not alive
		if(!GET_PLAYER(eMinor).isAlive())
			continue;

		if(GET_PLAYER(eMinor).GetMinorCivAI()->GetAlly() == GetID())
			iExtraAllies++;
	}

	if(iExtraAllies > 0)
	{
		int iExtraAlliesChange = iExtraAllies* /*-1*/ GC.getMINOR_ADDITIONAL_ALLIES_GP_CHANGE();

		iExtraAlliesChange = max(/*-10*/ GC.getMAX_MINOR_ADDITIONAL_ALLIES_GP_CHANGE(), iExtraAlliesChange);

		iNumTurns += iExtraAlliesChange;
	}

	int iRand = /*7*/ GC.getMINOR_TURNS_GREAT_PEOPLE_SPAWN_RAND();
	iNumTurns += GC.getGame().getSmallFakeRandNum(iRand, GetPseudoRandomSeed());

	// If we're biasing the result then decrease the number of turns
	if(!IsAlliesGreatPersonBiasApplied())
	{
		iNumTurns *= /*50*/ GC.getMINOR_TURNS_GREAT_PEOPLE_SPAWN_BIAS_MULTIPLY();
		iNumTurns /= 100;

		SetAlliesGreatPersonBiasApplied(true);
	}

	// Modify for Game Speed
	iNumTurns *= GC.getGame().getGameSpeedInfo().getGreatPeoplePercent();
	iNumTurns /= 100;

	if(iNumTurns < 1)
		iNumTurns = 1;

	SetGreatPeopleSpawnCounter(iNumTurns);
}

//	--------------------------------------------------------------------------------
/// We're now allies with someone, what happens with the GP bonus?
void CvPlayer::DoApplyNewAllyGPBonus()
{
	int iChange = /*-2*/ GC.getMINOR_ADDITIONAL_ALLIES_GP_CHANGE();
	ChangeGreatPeopleSpawnCounter(iChange);

	if(GetGreatPeopleSpawnCounter() < 1)
		SetGreatPeopleSpawnCounter(1);
}

//	--------------------------------------------------------------------------------
// How long before we spawn a free GreatPeople for ePlayer?
int CvPlayer::GetGreatPeopleSpawnCounter()
{
	return m_iGreatPeopleSpawnCounter;
}

//	--------------------------------------------------------------------------------
// Sets how long before we spawn a free GreatPeople for ePlayer
void CvPlayer::SetGreatPeopleSpawnCounter(int iValue)
{
	m_iGreatPeopleSpawnCounter = iValue;
}

//	--------------------------------------------------------------------------------
// Changes how long before we spawn a free GreatPeople for ePlayer
void CvPlayer::ChangeGreatPeopleSpawnCounter(int iChange)
{
	SetGreatPeopleSpawnCounter(GetGreatPeopleSpawnCounter() + iChange);
}

//	--------------------------------------------------------------------------------
/// Create a GreatPeople
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
void CvPlayer::DoSpawnGreatPerson(PlayerTypes eMinor, bool bIsFree)
#else
void CvPlayer::DoSpawnGreatPerson(PlayerTypes eMinor)
#endif
{
	CvAssertMsg(eMinor >= MAX_MAJOR_CIVS, "eMinor is expected to be non-negative (invalid Index)");
	CvAssertMsg(eMinor < MAX_CIV_PLAYERS, "eMinor is expected to be within maximum bounds (invalid Index)");

	// Minor must have Capital
	CvCity* pMinorCapital = GET_PLAYER(eMinor).getCapitalCity();
	if(pMinorCapital == NULL)
	{
		FAssertMsg(false, "MINOR CIV AI: Trying to spawn a GreatPeople for a major civ but the minor has no capital. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
		return;
	}
	// Capital must have a plot
	CvPlot* pMinorPlot = pMinorCapital->plot();
	if(pMinorPlot == NULL)
	{
		CvAssertMsg(false, "Plot for minor civ's capital not found! Please send Anton your save file and version.");
		return;
	}

	// Note: this is the same transport method (though without a delay) as a Militaristic city-state gifting a unit
	CvCity* pMajorCity = GetClosestCityByEstimatedTurns(pMinorPlot);
	if (pMajorCity == NULL && getCapitalCity() != NULL)
	{
		pMajorCity = getCapitalCity();
	}
	int iX = pMinorCapital->getX();
	int iY = pMinorCapital->getY();
	if(pMajorCity != NULL)
	{
		iX = pMajorCity->getX();
		iY = pMajorCity->getY();
	}

	// Pick Great Person type
	UnitTypes eBestUnit = NO_UNIT;
	int iBestScore = -1;
	SpecialUnitTypes eSpecialUnitGreatPerson = (SpecialUnitTypes) GC.getInfoTypeForString("SPECIALUNIT_PEOPLE");

	for(int iUnitLoop = 0; iUnitLoop < GC.getNumUnitInfos(); iUnitLoop++)
	{
		UnitTypes eLoopUnit = (UnitTypes)iUnitLoop;
		CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eLoopUnit);

		if(pkUnitEntry && pkUnitEntry->GetSpecialUnitType() == eSpecialUnitGreatPerson)
		{
			// No prophets
			if(!pkUnitEntry->IsFoundReligion())
			{
				int iScore = GC.getGame().getSmallFakeRandNum(100, GetPseudoRandomSeed() + iX + iY);

				if(iScore > iBestScore)
				{
					iBestScore = iScore;
					eBestUnit = eLoopUnit;
				}
			}
		}
	}

	// Spawn GreatPeople
	if(eBestUnit != NO_UNIT)
	{
		CvUnit* pNewGreatPeople = initUnit(eBestUnit, iX, iY);
		CvAssert(pNewGreatPeople);

		if (pNewGreatPeople)
		{
#if defined(MOD_BALANCE_CORE)
			if (GetPlayerTraits()->IsGPWLTKD())
			{
				CvCity* pCity = pNewGreatPeople->plot()->getOwningCity();
				if (pCity != NULL && pCity->getOwner() == GetID())
				{
					int iWLTKD = (GC.getCITY_RESOURCE_WLTKD_TURNS() / 3);

					iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
					iWLTKD /= 100;

					if (iWLTKD > 0)
					{
						pCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
						CvNotifications* pNotifications = GetNotifications();
						if (pNotifications)
						{
							Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UA");
							strText << pNewGreatPeople->getNameKey() << pCity->getNameKey();
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UA");
							strSummary << pCity->getNameKey();
							pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), -1);
						}
					}
				}
			}
			if(pNewGreatPeople->isWLKTKDOnBirth())
			{
				CvCity* pLoopCity;
				int iLoop;
				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if(pLoopCity != NULL && pLoopCity->getOwner() == GetID())
					{
						int iWLTKD = (GC.getCITY_RESOURCE_WLTKD_TURNS() / 3);

						iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
						iWLTKD /= 100;

						if (iWLTKD > 0)
						{
							pLoopCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
							CvNotifications* pNotifications = GetNotifications();
							if (pNotifications)
							{
								Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UNIT");
								strText << pNewGreatPeople->getNameKey() << pLoopCity->getNameKey();
								Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UNIT");
								strSummary << pLoopCity->getNameKey();
								pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pLoopCity->getX(), pLoopCity->getY(), -1);
							}
						}
					}
				}
			}
			if(pNewGreatPeople->isGoldenAgeOnBirth())
			{
				int iGoldenAgeTurns = getGoldenAgeLength();
				int iValue = GetGoldenAgeProgressMeter();
				changeGoldenAgeTurns(iGoldenAgeTurns, iValue);
			}
			if(pNewGreatPeople->isCultureBoost())
			{
				int iValue = GetTotalJONSCulturePerTurn() * 4;
				changeJONSCulture(iValue);
				if(getCapitalCity() != NULL)
				{
					getCapitalCity()->ChangeJONSCultureStored(iValue);
				}
				CvNotifications* pNotifications = GetNotifications();
				if (pNotifications)
				{
					Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CULTURE_UNIT");
					strText << pNewGreatPeople->getNameKey();
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CULTURE_UNIT");
					strSummary << pNewGreatPeople->getNameKey();
					pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pNewGreatPeople->getX(), pNewGreatPeople->getY(), -1);
				}
			}
#endif
			// Bump up the count
			if(pNewGreatPeople->IsGreatGeneral())
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGreatGeneralsCreated(bIsFree);
#else
				incrementGreatGeneralsCreated();
#endif
			}
			else if(pNewGreatPeople->IsGreatAdmiral())
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGreatAdmiralsCreated(bIsFree);
#else
				incrementGreatAdmiralsCreated();
#endif
			}
			else if (pNewGreatPeople->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_WRITER"))
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGreatWritersCreated(bIsFree);
#else
				incrementGreatWritersCreated();
#endif
			}							
			else if (pNewGreatPeople->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_ARTIST"))
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGreatArtistsCreated(bIsFree);
#else
				incrementGreatArtistsCreated();
#endif
			}							
			else if (pNewGreatPeople->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_MUSICIAN"))
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGreatMusiciansCreated(bIsFree);
#else
				incrementGreatMusiciansCreated();
#endif
			}
#if defined(MOD_DIPLOMACY_CITYSTATES)
			else if (MOD_DIPLOMACY_CITYSTATES && pNewGreatPeople->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_GREAT_DIPLOMAT"))
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGreatDiplomatsCreated(bIsFree);
#else
				incrementGreatDiplomatsCreated();
#endif
			}
#endif
#if defined(MOD_BALANCE_CORE)
			else if (pNewGreatPeople->getUnitInfo().IsGPExtra() == 1)
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGPExtra1Created(bIsFree);
#else
				incrementGPExtra1Created();
#endif
			}
			else if (pNewGreatPeople->getUnitInfo().IsGPExtra() == 2)
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGPExtra2Created(bIsFree);
#else
				incrementGPExtra2Created();
#endif
			}
			else if (pNewGreatPeople->getUnitInfo().IsGPExtra() == 3)
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGPExtra3Created(bIsFree);
#else
				incrementGPExtra3Created();
#endif
			}
			else if (pNewGreatPeople->getUnitInfo().IsGPExtra() == 4)
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGPExtra4Created(bIsFree);
#else
				incrementGPExtra4Created();
#endif
			}
			else if (pNewGreatPeople->getUnitInfo().IsGPExtra() == 5)
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGPExtra5Created(bIsFree);
#else
				incrementGPExtra5Created();
#endif
			}
#endif
			else
			{
#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
				if (MOD_GLOBAL_SEPARATE_GP_COUNTERS)
				{
					if (pNewGreatPeople->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_MERCHANT"))
					{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
						incrementGreatMerchantsCreated(bIsFree);
#else
						incrementGreatMerchantsCreated();
#endif
					}
					else if (pNewGreatPeople->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_SCIENTIST"))
					{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
						incrementGreatScientistsCreated(bIsFree);
#else
						incrementGreatScientistsCreated();
#endif
					}
					else
					{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
						incrementGreatEngineersCreated(bIsFree);
#else
						incrementGreatEngineersCreated();
#endif
					}
				}
				else
#endif
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
					incrementGreatPeopleCreated(bIsFree);
#else
					incrementGreatPeopleCreated();
#endif
			}

			if (pNewGreatPeople->IsGreatAdmiral())
			{
				CvPlot* pSpawnPlot = GetGreatAdmiralSpawnPlot(pNewGreatPeople);
				if (pNewGreatPeople->plot() != pSpawnPlot && pSpawnPlot != NULL)
				{
					pNewGreatPeople->setXY(pSpawnPlot->getX(), pSpawnPlot->getY());
				}
			}
			else
			{
				if (!pNewGreatPeople->jumpToNearestValidPlot())
					pNewGreatPeople->kill(false);	// Could not find a spot!
			}

			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_STATE_UNIT_SPAWN");
				strMessage << GET_PLAYER(eMinor).getNameKey();
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_STATE_UNIT_SPAWN");
				strSummary << GET_PLAYER(eMinor).getNameKey();
				pNotifications->Add(NOTIFICATION_MINOR, strMessage.toUTF8(), strSummary.toUTF8(), iX, iY, eMinor);
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Time to spawn a GreatPeople?
void CvPlayer::DoGreatPeopleSpawnTurn()
{
	// Tick down
	if(GetGreatPeopleSpawnCounter() > 0)
	{
		AI_PERF_FORMAT("AI-perf.csv", ("CvPlayer::DoGreatPeopleSpawnTurn, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), getCivilizationShortDescription()) );
		ChangeGreatPeopleSpawnCounter(-1);

		// Time to spawn! - Pick a random allied minor
		if(GetGreatPeopleSpawnCounter() == 0)
		{
			PlayerTypes eBestMinor = NO_PLAYER;
			int iBestScore = -1;
			int iScore;

			PlayerTypes eMinor;
			for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
			{
				eMinor = (PlayerTypes) iMinorLoop;

				// Not alive
				if(!GET_PLAYER(eMinor).isAlive())
					continue;

				// Not an ally
				if(GET_PLAYER(eMinor).GetMinorCivAI()->GetAlly() != GetID())
					continue;

				iScore = GC.getGame().getSmallFakeRandNum(100, GetPseudoRandomSeed() + iMinorLoop);

				// Best ally yet?
				if(eBestMinor == NO_PLAYER || iScore > iBestScore)
				{
					eBestMinor = eMinor;
					iBestScore = iScore;
				}
			}

			if(eBestMinor != NO_PLAYER)
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				DoSpawnGreatPerson(eBestMinor, MOD_GLOBAL_TRULY_FREE_GP);
#else
				DoSpawnGreatPerson(eBestMinor);
#endif

			// Reseed counter
			DoSeedGreatPeopleSpawnCounter();
		}
	}
}

//	--------------------------------------------------------------------------------
CvCity* CvPlayer::GetGreatPersonSpawnCity(UnitTypes eUnit)
{
	CvCity* pBestCity = getCapitalCity();
	CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eUnit);

	if(pkUnitEntry && pkUnitEntry->GetDomainType() == DOMAIN_SEA)
	{
		int iBestValue = INT_MAX;
		int iLoop;
		for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(!pLoopCity->isCoastal())
			{
				continue;
			}

			int iValue = 4 * GC.getGame().getSmallFakeRandNum(getNumCities(), GetPseudoRandomSeed() + iLoop);

			for(int i = 0; i < NUM_YIELD_TYPES; i++)
			{
				iValue += pLoopCity->findYieldRateRank((YieldTypes)i);
			}
			iValue += pLoopCity->findPopulationRank();

			if(iValue < iBestValue)
			{
				pBestCity = pLoopCity;
				iBestValue = iValue;
			}
		}
	}

	return pBestCity;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getMaxGlobalBuildingProductionModifier() const
{
	return m_iMaxGlobalBuildingProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMaxGlobalBuildingProductionModifier(int iChange)
{
	m_iMaxGlobalBuildingProductionModifier = (m_iMaxGlobalBuildingProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getMaxTeamBuildingProductionModifier() const
{
	return m_iMaxTeamBuildingProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMaxTeamBuildingProductionModifier(int iChange)
{
	m_iMaxTeamBuildingProductionModifier = (m_iMaxTeamBuildingProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getMaxPlayerBuildingProductionModifier() const
{
	return m_iMaxPlayerBuildingProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMaxPlayerBuildingProductionModifier(int iChange)
{
	m_iMaxPlayerBuildingProductionModifier = (m_iMaxPlayerBuildingProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getFreeExperience() const
{
	return m_iFreeExperience;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeFreeExperienceFromBldgs(int iChange)
{
	m_iFreeExperienceFromBldgs += iChange;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeFreeExperienceFromMinors(int iChange)
{
	m_iFreeExperienceFromMinors += iChange;
}

//	--------------------------------------------------------------------------------
void CvPlayer::recomputeFreeExperience()
{
	m_iFreeExperience = m_iFreeExperienceFromBldgs;
	m_iFreeExperience = m_iFreeExperienceFromMinors;
	m_iFreeExperience += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_FREE_EXPERIENCE);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getFeatureProductionModifier() const
{
	return m_iFeatureProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeFeatureProductionModifier(int iChange)
{
	m_iFeatureProductionModifier = (m_iFeatureProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getWorkerSpeedModifier() const
{
	return m_iWorkerSpeedModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeWorkerSpeedModifier(int iChange)
{
	m_iWorkerSpeedModifier = (m_iWorkerSpeedModifier + iChange);
}

#if defined(MOD_CIV6_WORKER)
//	--------------------------------------------------------------------------------
int  CvPlayer::GetImprovementBuilderCost(BuildTypes iBuild) const
{
	//get the build
	if (iBuild >= 0 && iBuild < GC.getNumBuildInfos())
	{
		CvBuildInfo* pkBuildInfo = GC.getBuildInfo((BuildTypes)iBuild);
		int buildercost = pkBuildInfo->getBuilderCost();

		//if road, use RouteBuilderCostMod
		if (pkBuildInfo->getRoute() != NO_ROUTE)
		{
			buildercost *= 100 + GetRouteBuilderCostMod();
			buildercost /= 100;
		}

		return buildercost;
	}
	return 0;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getImprovementCostModifier() const
{
	return m_iImprovementCostModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeImprovementCostModifier(int iChange)
{
	m_iImprovementCostModifier = (m_iImprovementCostModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getImprovementUpgradeRateModifier() const
{
	return m_iImprovementUpgradeRateModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeImprovementUpgradeRateModifier(int iChange)
{
	m_iImprovementUpgradeRateModifier = (m_iImprovementUpgradeRateModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getSpecialistProductionModifier() const
{
	return m_iSpecialistProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeSpecialistProductionModifier(int iChange)
{
	m_iSpecialistProductionModifier = (m_iSpecialistProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getMilitaryProductionModifier() const
{
	return m_iMilitaryProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMilitaryProductionModifier(int iChange)
{
	m_iMilitaryProductionModifier = (m_iMilitaryProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getSpaceProductionModifier() const
{
	return m_iSpaceProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeSpaceProductionModifier(int iChange)
{
	m_iSpaceProductionModifier = (m_iSpaceProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getCityDefenseModifier() const
{
	return m_iCityDefenseModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeCityDefenseModifier(int iChange)
{
	m_iCityDefenseModifier = (m_iCityDefenseModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getUnitFortificationModifier() const
{
	return m_iUnitFortificationModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeUnitFortificationModifier(int iChange)
{
	m_iUnitFortificationModifier = (m_iUnitFortificationModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getUnitBaseHealModifier() const
{
	return m_iUnitBaseHealModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeUnitBaseHealModifier(int iChange)
{
	m_iUnitBaseHealModifier = (m_iUnitBaseHealModifier + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getWonderProductionModifier() const
{
	return m_iWonderProductionModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeWonderProductionModifier(int iChange)
{
	m_iWonderProductionModifier = (m_iWonderProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getSettlerProductionModifier() const
{
	return m_iSettlerProductionModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeSettlerProductionModifier(int iChange)
{
	m_iSettlerProductionModifier = (m_iSettlerProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getCapitalSettlerProductionModifier() const
{
	return m_iCapitalSettlerProductionModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeCapitalSettlerProductionModifier(int iChange)
{
	m_iCapitalSettlerProductionModifier = (m_iCapitalSettlerProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::GetPolicyCostBuildingModifier() const
{
	return m_iPolicyCostBuildingModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangePolicyCostBuildingModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iPolicyCostBuildingModifier = (m_iPolicyCostBuildingModifier + iChange);

		recomputePolicyCostModifier();
		DoUpdateNextPolicyCost();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetPolicyCostMinorCivModifier() const
{
	return m_iPolicyCostMinorCivModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangePolicyCostMinorCivModifier(int iChange)
{
	m_iPolicyCostMinorCivModifier = (m_iPolicyCostMinorCivModifier + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetInfluenceSpreadModifier() const
{
	return m_iInfluenceSpreadModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeInfluenceSpreadModifier(int iChange)
{
	m_iInfluenceSpreadModifier = (m_iInfluenceSpreadModifier + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetExtraVotesPerDiplomat() const
{
	return m_iExtraVotesPerDiplomat;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeExtraVotesPerDiplomat(int iChange)
{
	m_iExtraVotesPerDiplomat += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNumNukeUnits() const
{
	return m_iNumNukeUnits;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeNumNukeUnits(int iChange)
{
	m_iNumNukeUnits = (m_iNumNukeUnits + iChange);
	CvAssert(getNumNukeUnits() >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getNumOutsideUnits()
{
	int iOutsideUnitCount = 0;

	CvUnit* pLoopUnit;
	int iLoop;
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->plot() != NULL)
		{
			if(pLoopUnit->plot()->getOwner() != pLoopUnit->getOwner())
			{
				iOutsideUnitCount++;
			}
		}
	}

	return iOutsideUnitCount;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeNumOutsideUnits(int iChange)
{
	if(iChange != 0)
	{
		m_iNumOutsideUnits += iChange;
		CvAssert(getNumOutsideUnits() >= 0);

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getBaseFreeUnits() const
{
	return m_iBaseFreeUnits;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeBaseFreeUnits(int iChange)
{
	if(iChange != 0)
	{
		m_iBaseFreeUnits = (m_iBaseFreeUnits + iChange);

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetVerifiedOutsideUnitCount()
{
	int iOutsideUnitCount = 0;

	CvUnit* pLoopUnit;
	int iLoop;
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->plot() != NULL)
		{
			if(pLoopUnit->plot()->getOwner() != pLoopUnit->getOwner())
			{
				iOutsideUnitCount++;
			}
		}
	}

	return iOutsideUnitCount;
}


//	--------------------------------------------------------------------------------
int CvPlayer::getGoldPerUnit() const
{
	return getGoldPerUnitTimes100() / 100;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeGoldPerUnit(int iChange)
{
	if(iChange != 0)
	{
		changeGoldPerUnitTimes100(iChange * 100);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGoldPerUnitTimes100() const
{
	return m_iGoldPerUnit;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeGoldPerUnitTimes100(int iChange)
{
	if(iChange != 0)
	{
		m_iGoldPerUnit = (m_iGoldPerUnit + iChange);

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getGoldPerMilitaryUnit() const
{
	return m_iGoldPerMilitaryUnit;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeGoldPerMilitaryUnit(int iChange)
{
	if(iChange != 0)
	{
		m_iGoldPerMilitaryUnit = (m_iGoldPerMilitaryUnit + iChange);

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetImprovementGoldMaintenanceMod() const
{
	return m_iImprovementGoldMaintenanceMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeImprovementGoldMaintenanceMod(int iChange)
{
	if(iChange != 0)
	{
		m_iImprovementGoldMaintenanceMod = (m_iImprovementGoldMaintenanceMod + iChange);
	}
}

#if defined(MOD_CIV6_WORKER)
//	--------------------------------------------------------------------------------
int CvPlayer::GetRouteBuilderCostMod() const
{
	return m_iRouteBuilderCostMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeRouteBuilderCostMod(int iChange)
{
	if (iChange != 0)
	{
		m_iRouteBuilderCostMod = (m_iRouteBuilderCostMod + iChange);
	}
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::GetBuildingGoldMaintenanceMod() const
{
	return m_iBuildingGoldMaintenanceMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeBuildingGoldMaintenanceMod(int iChange)
{
	if(iChange != 0)
	{
		m_iBuildingGoldMaintenanceMod = (m_iBuildingGoldMaintenanceMod + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetUnitGoldMaintenanceMod() const
{
	return m_iUnitGoldMaintenanceMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeUnitGoldMaintenanceMod(int iChange)
{
	if(iChange != 0)
	{
		m_iUnitGoldMaintenanceMod = (m_iUnitGoldMaintenanceMod + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetUnitSupplyMod() const
{
	return m_iUnitSupplyMod;
}


//	--------------------------------------------------------------------------------
void CvPlayer::ChangeUnitSupplyMod(int iChange)
{
	if(iChange != 0)
	{
		m_iUnitSupplyMod = (m_iUnitSupplyMod + iChange);
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getExtraUnitCost() const
{
	return m_iExtraUnitCost;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeExtraUnitCost(int iChange)
{
	if(iChange != 0)
	{
		m_iExtraUnitCost = (m_iExtraUnitCost + iChange);

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumMaintenanceFreeUnits(DomainTypes eDomain, bool bOnlyCombatUnits) const
{
	int iNumFreeUnits = 0;

	// Loop through all units to see if any of them are free!
	const CvUnit* pLoopUnit;
	int iLoop;
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if (eDomain != NO_DOMAIN)
		{
			if (pLoopUnit->getDomainType() != eDomain)
			{
				continue;
			}
		}

		if (bOnlyCombatUnits)
		{
			if (!pLoopUnit->IsCombatUnit())
			{
				continue;
			}
		}

		if(pLoopUnit->IsNoMaintenance())
		{
			iNumFreeUnits++;
		}
		else if(IsGarrisonFreeMaintenance() && pLoopUnit->IsGarrisoned())
		{
			iNumFreeUnits++;
		}
#if defined(MOD_BALANCE_CORE_JFD)
		if(MOD_BALANCE_CORE_JFD && pLoopUnit->isContractUnit())
		{
			iNumFreeUnits++;
		}
#endif
	}

	return iNumFreeUnits;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNumMilitaryUnits() const
{
	return m_iNumMilitaryUnits;
}
#if defined(MOD_BATTLE_ROYALE)
//  ----------------------------------------------------------------------------------
int CvPlayer::getNumMilitarySeaUnits() const
{
	return m_iNumMilitarySeaUnits;
}

int CvPlayer::getNumMilitaryAirUnits() const
{
	return m_iNumMilitaryAirUnits;
}

int CvPlayer::getNumMilitaryLandUnits() const
{
	return m_iNumMilitaryLandUnits;
}
#endif


//	--------------------------------------------------------------------------------
#if defined(MOD_BATTLE_ROYALE)
void CvPlayer::changeNumMilitaryUnits(int iChange, DomainTypes eDomain)
#else
void CvPlayer::changeNumMilitaryUnits(int iChange)
#endif
{
	if(iChange != 0)
	{
		m_iNumMilitaryUnits = (m_iNumMilitaryUnits + iChange);
		CvAssert(getNumMilitaryUnits() >= 0);

#if defined(MOD_BATTLE_ROYALE)
		switch (eDomain)
		{
		case NO_DOMAIN:
			break;
		case DOMAIN_SEA:
			m_iNumMilitarySeaUnits = (m_iNumMilitarySeaUnits + iChange);
			CvAssert(getNumMilitarySeaUnits() >= 0);
			break;
		case DOMAIN_AIR:
			m_iNumMilitaryAirUnits = (m_iNumMilitaryAirUnits + iChange);
			CvAssert(getNumMilitaryAirUnits() >= 0);
			break;
		case DOMAIN_LAND:
			m_iNumMilitaryLandUnits = (m_iNumMilitaryLandUnits + iChange);
			CvAssert(getNumMilitarySeaUnits() >= 0);
			break;
		case DOMAIN_IMMOBILE:
			break;
		case DOMAIN_HOVER:
			break;
		default:
			break;
		}
#endif
		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getHappyPerMilitaryUnit() const
{
	return m_iHappyPerMilitaryUnit;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeHappyPerMilitaryUnit(int iChange)
{
	if(iChange != 0)
	{
		m_iHappyPerMilitaryUnit = (m_iHappyPerMilitaryUnit + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getHappinessToCulture() const
{
	return m_iHappinessToCulture;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeHappinessToCulture(int iChange)
{
	if(iChange != 0)
	{
		m_iHappinessToCulture = (m_iHappinessToCulture + iChange);
		CvAssert(getHappinessToCulture() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getHappinessToScience() const
{
	return m_iHappinessToScience;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeHappinessToScience(int iChange)
{
	if(iChange != 0)
	{
		m_iHappinessToScience = (m_iHappinessToScience + iChange);
		CvAssert(getHappinessToScience() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getHalfSpecialistUnhappinessCount() const
{
	return m_iHalfSpecialistUnhappinessCount;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isHalfSpecialistUnhappiness() const
{
	return (getHalfSpecialistUnhappinessCount() > 0);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeHalfSpecialistUnhappinessCount(int iChange)
{
	if(iChange != 0)
	{
		m_iHalfSpecialistUnhappinessCount = (m_iHalfSpecialistUnhappinessCount + iChange);
		CvAssert(getHalfSpecialistUnhappinessCount() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getHalfSpecialistFoodCount() const
{
	return m_iHalfSpecialistFoodCount;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isHalfSpecialistFood() const
{
	return (getHalfSpecialistFoodCount() > 0);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeHalfSpecialistFoodCount(int iChange)
{
	if(iChange != 0)
	{
		m_iHalfSpecialistFoodCount = (m_iHalfSpecialistFoodCount + iChange);
		CvAssert(getHalfSpecialistFoodCount() >= 0);
	}
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvPlayer::getHalfSpecialistFoodCapitalCount() const
{
	return m_iHalfSpecialistFoodCapitalCount;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isHalfSpecialistFoodCapital() const
{
	return (getHalfSpecialistFoodCapitalCount() > 0);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeHalfSpecialistFoodCapitalCount(int iChange)
{
	if(iChange != 0)
	{
		m_iHalfSpecialistFoodCapitalCount = (m_iHalfSpecialistFoodCapitalCount + iChange);
		CvAssert(getHalfSpecialistFoodCapitalCount() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getTradeRouteLandDistanceModifier() const
{
	return m_iTradeRouteLandDistanceModifier;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeTradeRouteLandDistanceModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iTradeRouteLandDistanceModifier = (m_iTradeRouteLandDistanceModifier + iChange);
		CvAssert(getTradeRouteLandDistanceModifier() >= 0);
	}
}
int CvPlayer::getTradeRouteSeaDistanceModifier() const
{
	return m_iTradeRouteSeaDistanceModifier;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeTradeRouteSeaDistanceModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iTradeRouteSeaDistanceModifier = (m_iTradeRouteSeaDistanceModifier + iChange);
		CvAssert(getTradeRouteSeaDistanceModifier() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetDomainFreeExperiencePerGreatWorkGlobal(DomainTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_DOMAIN_TYPES, "eIndex expected to be < NUM_DOMAIN_TYPES");
	return m_aiDomainFreeExperiencePerGreatWorkGlobal[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::ChangeDomainFreeExperiencePerGreatWorkGlobal(DomainTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_DOMAIN_TYPES, "eIndex expected to be < NUM_DOMAIN_TYPES");
	m_aiDomainFreeExperiencePerGreatWorkGlobal.setAt(eIndex, m_aiDomainFreeExperiencePerGreatWorkGlobal[eIndex] + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetDomainFreeExperience(DomainTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_DOMAIN_TYPES, "eIndex expected to be < NUM_DOMAIN_TYPES");

	std::map<int, int>::const_iterator it = m_piDomainFreeExperience.find((int)eIndex);
	if (it != m_piDomainFreeExperience.end()) // find returns the iterator to map::end if the key i is not present in the map
	{
		return it->second;
	}

	return 0;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeDomainFreeExperience(DomainTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_DOMAIN_TYPES, "eIndex expected to be < NUM_DOMAIN_TYPES");

	m_piDomainFreeExperience[(int)eIndex] += iChange;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNullifyInfluenceModifier(bool bValue)
{
	if (bValue != m_bNullifyInfluenceModifier)
		m_bNullifyInfluenceModifier = bValue;
}
bool CvPlayer::IsNullifyInfluenceModifier() const
{
	return m_bNullifyInfluenceModifier;
}
#endif
//	--------------------------------------------------------------------------------
#if defined(MOD_TRAITS_TRADE_ROUTE_PRODUCTION_SIPHON)
int CvPlayer::GetTradeRouteProductionSiphonPercent(bool bInternationalOnly, CvPlayer* pOtherPlayer) const
{
	if (GetPlayerTraits()->IsTradeRouteProductionSiphon() == false || MOD_TRAITS_TRADE_ROUTE_PRODUCTION_SIPHON == false)
	{
		return 0;
	}
	
	int iSiphonPercent;
	int iOpenBorderPercentIncrease;
	int iReturn;

	iSiphonPercent = GetPlayerTraits()->GetTradeRouteProductionSiphon(bInternationalOnly).m_iSiphonPercent;
	iOpenBorderPercentIncrease = GetPlayerTraits()->GetTradeRouteProductionSiphon(bInternationalOnly).m_iPercentIncreaseWithOpenBorders;

	iReturn = iSiphonPercent;
	TeamTypes eTeam = getTeam();
	TeamTypes eOtherTeam = pOtherPlayer->getTeam();

	if (eTeam != NO_TEAM && eOtherTeam != NO_TEAM && eTeam != eOtherTeam)
	{
		CvTeam* pTeam = &GET_TEAM(eTeam);
		CvTeam* pOtherTeam = &GET_TEAM(eOtherTeam);
		if (pTeam->IsAllowsOpenBordersToTeam(pOtherTeam->GetID()))
		{
			iReturn += iOpenBorderPercentIncrease;
		}
		if (pOtherTeam->IsAllowsOpenBordersToTeam(pTeam->GetID()))
		{
			iReturn += iOpenBorderPercentIncrease;
		}
	}

	return iReturn;
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::getMilitaryFoodProductionCount() const
{
	return m_iMilitaryFoodProductionCount;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isMilitaryFoodProduction() const
{
	return (getMilitaryFoodProductionCount() > 0);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMilitaryFoodProductionCount(int iChange)
{
	if(iChange != 0)
	{
		m_iMilitaryFoodProductionCount = (m_iMilitaryFoodProductionCount + iChange);
		CvAssert(getMilitaryFoodProductionCount() >= 0);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetGoldenAgeCultureBonusDisabledCount() const
{
	return m_iGoldenAgeCultureBonusDisabledCount;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsGoldenAgeCultureBonusDisabled() const
{
	return (GetGoldenAgeCultureBonusDisabledCount() > 0);
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeGoldenAgeCultureBonusDisabledCount(int iChange)
{
	if (iChange != 0)
	{
		m_iGoldenAgeCultureBonusDisabledCount = m_iGoldenAgeCultureBonusDisabledCount + iChange;
		CvAssert(GetGoldenAgeCultureBonusDisabledCount() >= 0);
	}
}

void CvPlayer::ChangeNumMissionarySpreads(int iChange)
{
	m_iNumMissionarySpreads += iChange;

	if (iChange > 0)
	{
		int iUnitLoop;
		for (CvUnit* pLoopUnit = firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iUnitLoop))
		{
			if (pLoopUnit->GetReligionData() == NULL)
				continue;

			if (pLoopUnit->IsGreatPerson())
				continue;

			if (pLoopUnit->GetReligionData()->GetSpreadsLeft() <= 0)
				continue;

			pLoopUnit->GetReligionData()->SetSpreadsLeft(pLoopUnit->GetReligionData()->GetSpreadsLeft() + iChange);
		}
	}
}
int CvPlayer::GetNumMissionarySpreads() const
{
	return m_iNumMissionarySpreads;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetSecondReligionPantheonCount() const
{
	return m_iSecondReligionPantheonCount;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsSecondReligionPantheon() const
{
	return (GetSecondReligionPantheonCount() > 0);
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeSecondReligionPantheonCount(int iChange)
{
	if (iChange != 0)
	{
		m_iSecondReligionPantheonCount = m_iSecondReligionPantheonCount + iChange;
		CvAssert(GetSecondReligionPantheonCount() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetEnablesSSPartHurryCount() const
{
	return m_iEnablesSSPartHurryCount;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsEnablesSSPartHurry() const
{
	return (GetEnablesSSPartHurryCount() > 0);
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeEnablesSSPartHurryCount(int iChange)
{
	if (iChange != 0)
	{
		m_iEnablesSSPartHurryCount = m_iEnablesSSPartHurryCount + iChange;
		CvAssert(GetEnablesSSPartHurryCount() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetEnablesSSPartPurchaseCount() const
{
	return m_iEnablesSSPartPurchaseCount;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsEnablesSSPartPurchase() const
{
	return (GetEnablesSSPartPurchaseCount() > 0);
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeEnablesSSPartPurchaseCount(int iChange)
{
	if (iChange != 0)
	{
		m_iEnablesSSPartPurchaseCount = m_iEnablesSSPartPurchaseCount + iChange;
		CvAssert(GetEnablesSSPartPurchaseCount() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getHighestUnitLevel()	const
{
	return m_iHighestUnitLevel;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setHighestUnitLevel(int iNewValue)
{
	m_iHighestUnitLevel = iNewValue;
	CvAssert(getHighestUnitLevel() >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getMaxConscript() const
{
	return m_iMaxConscript;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMaxConscript(int iChange)
{
	m_iMaxConscript = (m_iMaxConscript + iChange);
	CvAssert(getMaxConscript() >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getConscriptCount() const
{
	return m_iConscriptCount;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setConscriptCount(int iNewValue)
{
	m_iConscriptCount = iNewValue;
	CvAssert(getConscriptCount() >= 0);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeConscriptCount(int iChange)
{
	setConscriptCount(getConscriptCount() + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getOverflowResearch() const
{
#if defined(MOD_BUGFIX_MINOR)
	return getOverflowResearchTimes100() / 100;
#else
	return m_iOverflowResearch / 100;
#endif
}


//	--------------------------------------------------------------------------------
void CvPlayer::setOverflowResearch(int iNewValue)
{
	setOverflowResearchTimes100(iNewValue*100);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeOverflowResearch(int iChange)
{
	changeOverflowResearchTimes100(iChange*100);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getOverflowResearchTimes100() const
{
	return m_iOverflowResearch;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setOverflowResearchTimes100(int iNewValue)
{
	m_iOverflowResearch = iNewValue;
	CvAssert(getOverflowResearchTimes100() >= 0);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeOverflowResearchTimes100(int iChange)
{
	setOverflowResearchTimes100(getOverflowResearchTimes100() + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getExpModifier() const
{
	return m_iExpModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeExpModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iExpModifier += iChange;
		CvAssert(getExpModifier() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getExpInBorderModifier() const
{
	return m_iExpInBorderModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeExpInBorderModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iExpInBorderModifier += iChange;
		CvAssert(getExpInBorderModifier() >= 0);
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getLevelExperienceModifier() const
{
	return m_iLevelExperienceModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeLevelExperienceModifier(int iChange)
{
	m_iLevelExperienceModifier += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getMinorQuestFriendshipMod() const
{
	return m_iMinorQuestFriendshipMod;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMinorQuestFriendshipMod(int iChange)
{
	if(iChange != 0)
	{
		m_iMinorQuestFriendshipMod += iChange;
		CvAssert(getMinorQuestFriendshipMod() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getMinorGoldFriendshipMod() const
{
	return m_iMinorGoldFriendshipMod;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMinorGoldFriendshipMod(int iChange)
{
	if(iChange != 0)
	{
		m_iMinorGoldFriendshipMod += iChange;
		CvAssert(getMinorGoldFriendshipMod() >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// What is the general modifier we get towards the resting Influence point with a city-state? (ex. Social Policies)
/// NOTE: This does not include situation-dependent modifiers (ex. religion or warmongering), which are handled in CvMinorCivAI
int CvPlayer::GetMinorFriendshipAnchorMod() const
{
	return m_iMinorFriendshipMinimum;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetMinorFriendshipAnchorMod(int iValue)
{
	if (iValue < GC.getMINOR_FRIENDSHIP_AT_WAR())
	{
		CvAssertMsg(false, "Minor friendship anchor mod should not be lower than the War friendship level. Please send Anton your save file and version.");
		m_iMinorFriendshipMinimum = GC.getMINOR_FRIENDSHIP_AT_WAR();
		return;
	}

	m_iMinorFriendshipMinimum = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMinorFriendshipAnchorMod(int iChange)
{
	SetMinorFriendshipAnchorMod(GetMinorFriendshipAnchorMod() + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::GetMinorFriendshipDecayMod() const
{
	return m_iMinorFriendshipDecayMod;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeGetMinorFriendshipDecayMod(int iChange)
{
	if(iChange != 0)
	{
		m_iMinorFriendshipDecayMod += iChange;
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsMinorScienceAllies() const
{
	return GetMinorScienceAlliesCount() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetMinorScienceAlliesCount() const
{
	return m_iMinorScienceAlliesCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMinorScienceAlliesCount(int iChange)
{
	if(iChange != 0)
	{
		m_iMinorScienceAlliesCount += iChange;
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsMinorResourceBonus() const
{
	return GetMinorResourceBonusCount() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetMinorResourceBonusCount() const
{
	return m_iMinorResourceBonusCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMinorResourceBonusCount(int iChange)
{
	if(iChange != 0)
	{
		m_iMinorResourceBonusCount += iChange;
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsAbleToAnnexCityStates() const
{
	if (GetAbleToAnnexCityStatesCount() > 0)
		return true;

	if (GetPlayerTraits()->IsAbleToAnnexCityStates())
		return true;

	return false;
}
#if defined(MOD_BALANCE_CORE)
	//JFD
void CvPlayer::SetPiety(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_PietyChanged, GetID(), GetPiety(), iValue);
	if(m_iJFDPiety != iValue)
	{
		m_iJFDPiety = iValue;
	}
}
void CvPlayer::ChangePiety(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_PietyChanged, GetID(), GetPiety(), iValue);
	m_iJFDPiety += iValue;
	if(m_iJFDPiety > GC.getGame().getGameSpeedInfo().getPietyMax())
	{
		m_iJFDPiety = GC.getGame().getGameSpeedInfo().getPietyMax();
	}
	if(m_iJFDPiety < GC.getGame().getGameSpeedInfo().getPietyMin())
	{
		m_iJFDPiety = GC.getGame().getGameSpeedInfo().getPietyMin();
	}
}
int CvPlayer::GetPiety() const
{
	return m_iJFDPiety;
}
int CvPlayer::GetPietyRate() const
{
	return m_iJFDPietyRate;
}
void CvPlayer::SetPietyRate(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_PietyRateChanged, GetID(), GetPietyRate(), iValue);
	if(m_iJFDPietyRate != iValue)
	{
		m_iJFDPietyRate = iValue;
	}
}
void CvPlayer::ChangePietyRate(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_PietyRateChanged, GetID(), GetPietyRate(), iValue);
	m_iJFDPietyRate += iValue;
}
int CvPlayer::GetTurnsSinceConversion() const
{
	return m_iJFDConversionTurn;
}
void CvPlayer::SetTurnsSinceConversion(int iValue)
{
	if(m_iJFDConversionTurn != iValue)
	{
		m_iJFDConversionTurn = iValue;
	}
}
void CvPlayer::DoPiety()
{
	ReligionTypes eReligion = GetReligions()->GetStateReligion();
	if(eReligion == NO_RELIGION)
	{
		return;
	}
	else
	{
		int iRate = GetPietyRate();
		if(iRate != 0)
		{
			ChangePiety(iRate);
		}
	}
}
bool CvPlayer::HasStateReligion()
{
	if(GetReligions()->GetStateReligion() != NO_RELIGION)
	{
		return true;
	}
	return false;
}
bool CvPlayer::HasSecularized() const
{
	return m_bJFDSecularized;
}
void CvPlayer::SetHasSecularized(bool bValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerSecularizes, GetID(), GetReligions()->GetStateReligion(), bValue);
	m_bJFDSecularized = bValue;
}
bool CvPlayer::IsPagan()
{
	if(GetReligions()->HasCreatedPantheon() && !HasStateReligion() && !HasSecularized())
	{
		return true;
	}
	return false;
}

void CvPlayer::ChangeSovereignty(int iValue)
{
	m_iJFDSovereignty += iValue;
}
int CvPlayer::GetSovereignty() const
{
	return m_iJFDSovereignty;
}
void CvPlayer::SetSovereignty(int iValue)
{
	if(m_iJFDSovereignty != iValue)
	{
		m_iJFDSovereignty = iValue;
	}
}

void CvPlayer::SetGovernment(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerAdoptsGovernment, GetID(), iValue);
	if(m_iJFDGovernment != iValue)
	{
		m_iJFDGovernment = iValue;
	}
}
int CvPlayer::GetGovernment() const
{
	return m_iJFDGovernment;
}
bool CvPlayer::HasGovernment()
{
	if(GetGovernment() > -1)
	{
		return true;
	}
	return false;
}

void CvPlayer::ChangeReformCooldown(int iValue)
{
	m_iJFDReformCooldown += iValue;
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_ReformCooldownChanges, GetID(), GetReformCooldown());
}
int CvPlayer::GetReformCooldown() const
{
	return m_iJFDReformCooldown;
}
void CvPlayer::SetReformCooldown(int iValue, bool bNoEvent)
{
	if(m_iJFDReformCooldown != iValue)
	{
		m_iJFDReformCooldown = iValue;
	}
	if(!bNoEvent)
	{
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_ReformCooldownChanges, GetID(), GetReformCooldown());
	}
}

void CvPlayer::ChangeReformCooldownRate(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_ReformCooldownRateChanges, GetID(), iValue);
	m_iJFDReformCooldownRate += iValue;
}
int CvPlayer::GetReformCooldownRate() const
{
	return m_iJFDReformCooldownRate;
}
void CvPlayer::SetReformCooldownRate(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_ReformCooldownRateChanges, GetID(), iValue);
	if(m_iJFDReformCooldownRate != iValue)
	{
		m_iJFDReformCooldownRate = iValue;
	}
}

void CvPlayer::ChangeGovernmentCooldown(int iValue)
{
	m_iJFDGovernmentCooldown += iValue;
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_GovernmentCooldownChanges, GetID(), GetGovernmentCooldown());
}
int CvPlayer::GetGovernmentCooldown() const
{
	return m_iJFDGovernmentCooldown;
}
void CvPlayer::SetGovernmentCooldown(int iValue, bool bNoEvent)
{
	if(m_iJFDGovernmentCooldown != iValue)
	{
		m_iJFDGovernmentCooldown = iValue;
	}
	if(!bNoEvent)
	{
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_GovernmentCooldownChanges, GetID(), GetGovernmentCooldown());
	}
}

void CvPlayer::ChangeGovernmentCooldownRate(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_GovernmentCooldownRateChanges, GetID(), iValue);
	m_iJFDGovernmentCooldownRate += iValue;
}
int CvPlayer::GetGovernmentCooldownRate() const
{
	return m_iJFDGovernmentCooldownRate;
}
void CvPlayer::SetGovernmentCooldownRate(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_GovernmentCooldownRateChanges, GetID(), iValue);
	if(m_iJFDGovernmentCooldownRate != iValue)
	{
		m_iJFDGovernmentCooldownRate = iValue;
	}
}

int CvPlayer::GetPoliticLeader() const
{
	return m_iJFDPoliticLeader;
}
void CvPlayer::SetPoliticLeader(int iID)
{
	m_iJFDPoliticLeader = iID;
}

CvString CvPlayer::GetPoliticLeaderKey() const
{
	return m_strJFDPoliticKey;
}
void CvPlayer::SetPoliticLeaderKey(const char* strKey)
{
	m_strJFDPoliticKey = strKey;
}

CvString CvPlayer::GetLegislatureName() const
{
	return m_strJFDLegislatureName;
}
void CvPlayer::SetLegislatureName(const char* strKey)
{
	m_strJFDLegislatureName = strKey;
}

int CvPlayer::GetPoliticPercent(int iID) const
{
	return m_paiJFDPoliticPercent[iID];
}
void CvPlayer::SetPoliticPercent(int iID, int iValue)
{
	m_paiJFDPoliticPercent.setAt(iID, iValue);
}

void CvPlayer::DoGovernmentCooldown()
{
	if(GetGovernmentCooldown() <= 0)
	{
		return;
	}
	int iRate = GetGovernmentCooldownRate();
	if(iRate != 0)
	{
		ChangeGovernmentCooldown(-iRate);
		if(GetGovernmentCooldown() <= 0)
		{
			SetGovernmentCooldown(0, true);
		}
	}
}
void CvPlayer::DoReformCooldown()
{
	if(GetReformCooldown() <= 0)
	{
		return;
	}
	int iRate = GetReformCooldownRate();
	if(iRate != 0)
	{
		ChangeReformCooldown(-iRate);
		if(GetReformCooldown() <= 0)
		{
			SetReformCooldown(0, true);
		}
	}
}
void CvPlayer::SetCurrency(int iValue)
{
	if(!HasCurrency())
	{
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerAdoptsCurrency, GetID(), iValue, -1);
	}
	else
	{
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerAdoptsCurrency, GetID(), iValue, GetCurrency());
	}
	if(m_iJFDCurrency != iValue)
	{
		m_iJFDCurrency = iValue;
	}
}
int CvPlayer::GetCurrency() const
{
	return m_iJFDCurrency;
}
bool CvPlayer::HasCurrency()
{
	if(GetCurrency() > -1)
	{
		return true;
	}
	return false;
}

CvString CvPlayer::GetCurrencyName() const
{
	return m_strJFDCurrencyName;
}
void CvPlayer::SetCurrencyName(const char* strKey)
{
	m_strJFDCurrencyName = strKey;
}

void CvPlayer::SetProsperityScore(int iValue)
{
	if(m_iJFDProsperity != iValue)
	{
		m_iJFDProsperity = iValue;
	}
}
int CvPlayer::GetProsperityScore() const
{
	return m_iJFDProsperity;
}

bool CvPlayer::PlayerHasContract(ContractTypes eContract) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eContract >= 0, "eContract expected to be >= 0");
	CvAssertMsg(eContract < GC.getNumContractInfos(), "eContract expected to be < GC.GetNumContractInfos()");
	return m_abActiveContract[eContract];
}
void CvPlayer::SetActiveContract(ContractTypes eContract, bool bValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eContract >= 0, "eContract expected to be >= 0");
	CvAssertMsg(eContract < GC.getNumContractInfos(), "eContract expected to be < GC.GetNumContractInfos()");
	if (m_abActiveContract[eContract] != bValue)
	{
		m_abActiveContract.setAt(eContract, bValue);
	}
}

//JFD DONE
void CvPlayer::DoDiversity(DomainTypes eDomain)
{
	//////Let's get sum total of all land military unit AI types and boost the lowest type.
	int iLowest = MAX_INT;
	int iUnitAI = -1;

	FStaticVector<int, NUM_UNITAI_TYPES, true, c_eCiv5GameplayDLL> veAITypeTotals;
	for (int i = 0; i < NUM_UNITAI_TYPES; i++)
	{
		veAITypeTotals.push_back(-1);
	}


	for (int iI = 0; iI < GC.getNumUnitInfos(); iI++)
	{
		const UnitTypes eLoopUnit = static_cast<UnitTypes>(iI);
		CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eLoopUnit);
		if (pkUnitInfo)
		{
			if (pkUnitInfo->GetDomainType() != eDomain)
				continue;

			if (pkUnitInfo->GetCombat() <= 0 && pkUnitInfo->GetRangedCombat() <= 0)
				continue;

			if (!canTrain(eLoopUnit))
				continue;

			int iNumUnits = GetNumUnitsOfType(eLoopUnit, true);

			if (veAITypeTotals[pkUnitInfo->GetDefaultUnitAIType()] == -1)
				veAITypeTotals[pkUnitInfo->GetDefaultUnitAIType()] = 0;

			veAITypeTotals[pkUnitInfo->GetDefaultUnitAIType()] += iNumUnits;
		}
	}

	for (int i = 0; i < NUM_UNITAI_TYPES; i++)
	{
		if (veAITypeTotals[i] == -1)
			continue;

		UnitAITypes UnitAI = (UnitAITypes)i;
		int iNumUnits = veAITypeTotals[i];
		if (iNumUnits < iLowest)
		{
			iLowest = iNumUnits;
			iUnitAI = (int)UnitAI;
		}
	}

	if (iUnitAI == NO_UNITAI)
		return;

	if (iUnitAI != m_aiDomainDiversity[eDomain])
	{
		if (GC.getLogging() && GC.getAILogging())
		{
			CvString strLogString;
			CvString strAI;
			getUnitAIString(strAI, (UnitAITypes)iUnitAI);

			switch (eDomain)
			{
			case DOMAIN_LAND:
				strLogString.Format("ARMY DIVERSITY CHANGE! WE NEED: ");
				break;
			case DOMAIN_SEA:
				strLogString.Format("NAVY DIVERSITY CHANGE! WE NEED: ");
				break;
			case DOMAIN_AIR:
				strLogString.Format("AIR DIVERSITY CHANGE! WE NEED: ");
				break;
			}
			strLogString += strAI;
			GetHomelandAI()->LogHomelandMessage(strLogString);
		}

		m_aiDomainDiversity.setAt(eDomain, iUnitAI);
	}
}
int CvPlayer::GetDiversity(DomainTypes eDomain) const
{
	return m_aiDomainDiversity[eDomain];
}

int CvPlayer::GetDominationResistance(PlayerTypes ePlayer)
{
	if (ePlayer == NO_PLAYER)
		return 0;

	int iResistance = GetDiplomacyAI()->GetOtherPlayerWarmongerAmount(ePlayer);
	if (iResistance == 0)
		return 0;

	iResistance /= 10;

	iResistance *= GetCurrentEra();

	int iHandicapCap = 50;
	if (GET_PLAYER(ePlayer).isHuman())
	{
		iHandicapCap = GC.getGame().getHandicapInfo().getAIResistanceCap();
	}

	return min(iHandicapCap, iResistance);
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetArchaeologicalDigTourism() const
{
	return m_iArchaeologicalDigTourism;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeArchaeologicalDigTourism(int iChange)
{
	m_iArchaeologicalDigTourism += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetGoldenAgeTourism() const
{
	return m_iGoldenAgeTourism;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeGoldenAgeTourism(int iChange)
{
	m_iGoldenAgeTourism += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetExtraCultureandScienceTradeRoutes() const
{
	return m_iExtraCultureandScienceTradeRoutes;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeExtraCultureandScienceTradeRoutes(int iChange)
{
	m_iExtraCultureandScienceTradeRoutes += iChange;
}



//	--------------------------------------------------------------------------------
bool CvPlayer::CanUpgradeCSVassalTerritory() const
{
	if (GetUpgradeCSVassalTerritory() > 0)
	{
		return true;
	}

	return false;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetUpgradeCSVassalTerritory() const
{
	return m_iUpgradeCSVassalTerritory;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeUpgradeCSVassalTerritory(int iChange)
{
	m_iUpgradeCSVassalTerritory += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetRazingSpeedBonus() const
{
	return m_iRazingSpeedBonus;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeRazingSpeedBonus(int iChange)
{
	m_iRazingSpeedBonus += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetNoPartisans() const
{
	return m_iNoPartisans;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNoPartisans(int iChange)
{
	m_iNoPartisans += iChange;
}
//	--------------------------------------------------------------------------------
bool CvPlayer::IsNoPartisans() const
{
	if (GetNoPartisans() > 0)
	{
		return true;
	}

	return false;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetSpawnCooldown() const
{
	return m_iSpawnCooldown;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetSpawnCooldown(int iValue)
{
	m_iSpawnCooldown = iValue;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeSpawnCooldown(int iChange)
{
	m_iSpawnCooldown += iChange;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsDiplomaticMarriage() const
{
	if (GetAbleToMarryCityStatesCount() > 0)
		return true;

	if (GetPlayerTraits()->IsDiplomaticMarriage())
		return true;

	return false;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetAbleToMarryCityStatesCount() const
{
	return m_iAbleToMarryCityStatesCount;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeAbleToMarryCityStatesCount(int iChange)
{
	m_iAbleToMarryCityStatesCount += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeTRSpeedBoost(int iChange)
{
	m_iTRSpeedBoost += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetTRSpeedBoost(int iChange)
{
	m_iTRSpeedBoost = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetTRSpeedBoost() const
{
	return m_iTRSpeedBoost;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeVotesPerGPT(int iChange)
{
	m_iVotesPerGPT += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetVotesPerGPT() const
{
	return m_iVotesPerGPT;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeTRVisionBoost(int iChange)
{
	m_iTRVisionBoost += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetTRVisionBoost(int iChange)
{
	m_iTRVisionBoost = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetTRVisionBoost() const
{
	return m_iTRVisionBoost;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeEventTourism(int iChange)
{
	m_iEventTourism += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetEventTourism(int iChange)
{
	m_iEventTourism = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetEventTourism() const
{
	return m_iEventTourism;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetGlobalTourismAlreadyReceived(MinorCivQuestTypes eQuest, int iValue)
{
	CvAssertMsg(eQuest >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eQuest < NUM_MINOR_CIV_QUEST_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	if(iValue != 0)
	{
		m_aiGlobalTourismAlreadyReceived.setAt(eQuest, iValue);
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::GlobalTourismAlreadyReceived(MinorCivQuestTypes eQuest) const
{
	CvAssertMsg(eQuest >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eQuest < NUM_MINOR_CIV_QUEST_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	return m_aiGlobalTourismAlreadyReceived[eQuest];
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeEventTourismCS(int iChange)
{
	m_iEventTourismCS += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetEventTourismCS(int iChange)
{
	m_iEventTourismCS = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetEventTourismCS() const
{
	return m_iEventTourismCS;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumHistoricEvents(HistoricEventTypes eHistoricEvent, int iChange)
{
	if (!isMajorCiv())
	{
		return;
	}
	m_iNumHistoricEvent += iChange;
	CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			pLoopCity->GetCityCulture()->CalculateBaseTourismBeforeModifiers();
			pLoopCity->GetCityCulture()->CalculateBaseTourism();
		}
	}
	CvCity* pCapital = getCapitalCity();
	int iEventGP = GetPlayerTraits()->GetEventGP();
	if(pCapital != NULL && iEventGP > 0)
	{
		vector<SpecialistTypes> vPossibleSpecialists;
		for (int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
		{
			const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iSpecialistLoop);
			CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
			if (pkSpecialistInfo)
			{
				// Does this Specialist spawn a GP?
				if (pkSpecialistInfo->getGreatPeopleUnitClass() != NO_UNITCLASS)
				{
					vPossibleSpecialists.push_back(eSpecialist);

					//boost the chance if we have a slot for the corresponding great work
					if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_WRITER"))
					{ 
						if(GetCulture()->GetNumAvailableGreatWorkSlots(CvTypes::getGREAT_WORK_SLOT_LITERATURE()) > 0)
						{
							vPossibleSpecialists.push_back(eSpecialist);
						}
					}
					else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_ARTIST"))
					{
						if(GetCulture()->GetNumAvailableGreatWorkSlots(CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT()) > 0)
						{
							vPossibleSpecialists.push_back(eSpecialist);
						}
					}
					else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_MUSICIAN"))
					{
						if(GetCulture()->GetNumAvailableGreatWorkSlots(CvTypes::getGREAT_WORK_SLOT_MUSIC()) > 0)
						{
							vPossibleSpecialists.push_back(eSpecialist);
						}
					}
				}
			}
		}

		//choose one
		int iChoice = GC.getGame().getSmallFakeRandNum(vPossibleSpecialists.size(), GetPseudoRandomSeed() + GC.getGame().getNumCities() + m_iNumHistoricEvent);
		SpecialistTypes eBestSpecialist = vPossibleSpecialists.empty() ? NO_SPECIALIST : vPossibleSpecialists[iChoice];
		if(eBestSpecialist != NO_SPECIALIST)
		{
			CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eBestSpecialist);
			if(pkSpecialistInfo)
			{
				int iGPThreshold = pCapital->GetCityCitizens()->GetSpecialistUpgradeThreshold((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass());
				iGPThreshold *= 100;
				//Get % of threshold for test.
				iGPThreshold *= iEventGP;
				iGPThreshold /= 100;
				
				pCapital->GetCityCitizens()->ChangeSpecialistGreatPersonProgressTimes100(eBestSpecialist, iGPThreshold, true);
				if(GetID() == GC.getGame().getActivePlayer())
				{
					iGPThreshold /= 100;
					char text[256] = {0};
					sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_GREAT_PEOPLE]", iGPThreshold);
					SHOW_PLOT_POPUP(pCapital->plot(), GetID(), text);
					CvNotifications* pNotification = GetNotifications();
					if(pNotification)
					{
						CvString strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS", iGPThreshold);
						CvString strSummary;
						// Class specific specialist message.
						if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_SCIENTIST"))
						{
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS_SCIENTIST", iGPThreshold);
						}
						else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_WRITER"))
						{ 
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS_WRITER", iGPThreshold);
						}
						else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_ARTIST"))
						{
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS_ARTIST", iGPThreshold);
						}
						else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_MUSICIAN"))
						{
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS_MUSICIAN", iGPThreshold);
						}
						else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_MERCHANT"))
						{
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS_MERCHANT", iGPThreshold);
						}
						else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_ENGINEER"))
						{
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS_ENGINEER", iGPThreshold);
						}
#if defined(MOD_DIPLOMACY_CITYSTATES)
						else if(MOD_DIPLOMACY_CITYSTATES && (UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_GREAT_DIPLOMAT"))
						{
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS_DIPLOMAT", iGPThreshold);
						}
#endif
						strSummary = GetLocalizedText("TXT_KEY_TOURISM_EVENT_SUMMARY_GP_BONUS");
						pNotification->Add(NOTIFICATION_GOLDEN_AGE_BEGUN_ACTIVE_PLAYER, strMessage, strSummary, -1, -1, -1);
					}
				}
			}
		}
	}
#if defined(MOD_BALANCE_CORE_DIFFICULTY)
	if (MOD_BALANCE_CORE_DIFFICULTY && !isMinorCiv() && !isHuman() && !isBarbarian() && getNumCities() > 0)
	{
		DoDifficultyBonus(eHistoricEvent);
	}
#endif
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetNumHistoricEvents(int iChange)
{
	m_iNumHistoricEvent = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetNumHistoricEvents() const
{
	return m_iNumHistoricEvent;
}
int CvPlayer::GetHistoricEventTourism(HistoricEventTypes eHistoricEvent, CvCity* pCity)
{

	int iTourism = 0;

	CvString strLogString; 
	
	switch (eHistoricEvent)
	{
	case HISTORIC_EVENT_GP:
		if (GC.getLogging() && GC.getAILogging())
		{
			strLogString.Format("Great Person Historic Event triggered.");
		}
		iTourism = GetEventTourism();
		break;
	case HISTORIC_EVENT_ERA:
		if (GC.getLogging() && GC.getAILogging())
		{
			strLogString.Format("Era Change Historic Event triggered.");
		}
		iTourism = GetEventTourism();
		break;
	case HISTORIC_EVENT_WAR:
		if (GC.getLogging() && GC.getAILogging())
		{
			strLogString.Format("War Historic Event triggered.");
		}
		iTourism = GetEventTourism();
		break;
	case HISTORIC_EVENT_WONDER:
		if (GC.getLogging() && GC.getAILogging())
		{
			strLogString.Format("Wonder Historic Event triggered.");
		}
		iTourism = GetEventTourism();
		break;
	case HISTORIC_EVENT_DIG:
		if (GC.getLogging() && GC.getAILogging())
		{
			strLogString.Format("Archaeological Dig Historic Event triggered.");
		}
		iTourism = GetArchaeologicalDigTourism();
		break;
	case HISTORIC_EVENT_TRADE_CS:
		if (GC.getLogging() && GC.getAILogging())
		{
			strLogString.Format("City-State Trade Historic Event triggered.");
		}
		iTourism = GetEventTourismCS();
		break;
	case HISTORIC_EVENT_GA:
		if (GC.getLogging() && GC.getAILogging())
		{
			strLogString.Format("Golden Age Historic Event triggered.");
		}
		iTourism = GetGoldenAgeTourism();
		break;
	case HISTORIC_EVENT_TRADE_LAND:
		if (GC.getLogging() && GC.getAILogging())
		{
			strLogString.Format("Land Trade Specific Event triggered.");
		}
		if (pCity != NULL)
		{
			iTourism = pCity->GetLandTourismBonus();
		}
		break;
	case HISTORIC_EVENT_TRADE_SEA:
		if (GC.getLogging() && GC.getAILogging())
		{
			strLogString.Format("Sea Trade Specific Event triggered.");
		}
		if (pCity != NULL)
		{
			iTourism = pCity->GetSeaTourismBonus();
		}
		break;
	}

	if (iTourism <= 0)
		return 0;

	int iPreviousTurnsToCount = iTourism;

	// Calculate boost
	int iTotalBonus = GetCultureYieldFromPreviousTurns(GC.getGame().getGameTurn(), iPreviousTurnsToCount / 3);
	iTotalBonus += GetTourismYieldFromPreviousTurns(GC.getGame().getGameTurn(), iPreviousTurnsToCount);

	// Mod for City Count
	int iMod = (GC.getMap().getWorldInfo().GetNumCitiesPolicyCostMod() / 2);	// Default is 5, gets smaller on larger maps

	int iNumCities = GetMaxEffectiveCities();

	iMod *= (iNumCities - 1);

	if (iMod <= 0)
		iMod = 1;
	else if (iMod >= 75)
		iMod = 75;

	int iSubtraction = (iTotalBonus * iMod);
	iSubtraction /= 100;

	iTotalBonus -= iSubtraction;

	switch (eHistoricEvent)
	{
	case HISTORIC_EVENT_GP:
		iTotalBonus /= 15;
		break;
	case HISTORIC_EVENT_ERA:
		iTotalBonus /= 10;
		break;
	case HISTORIC_EVENT_WAR:
		iTotalBonus /= 5;
		break;
	case HISTORIC_EVENT_WONDER:
		iTotalBonus /= 5;
		break;
	case HISTORIC_EVENT_DIG:
		iTotalBonus /= 10;
		break;
	case HISTORIC_EVENT_TRADE_CS:
		iTotalBonus /= 5;
		break;
	case HISTORIC_EVENT_GA:
		iTotalBonus /= 5;
		break;
	case HISTORIC_EVENT_TRADE_LAND:
		iTotalBonus /= 15;
		break;
	case HISTORIC_EVENT_TRADE_SEA:
		iTotalBonus /= 15;
		break;
	}

	if (GC.getLogging() && GC.getAILogging())
	{
		CvString strTemp;

		CvString strFileName = "HistoricEventLog.csv";
		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

		CvString strPlayerName;
		strPlayerName = getCivilizationShortDescription();
		strTemp += strPlayerName;
		strTemp += ", ";

		CvString strTurn;
 
		strTurn.Format("%d, ", GC.getGame().getGameTurn()); // turn
		strTemp += strTurn;

		strTemp += strLogString;

		CvString strData;
		strData.Format(" --- Total Events: %d. Tourism bonus with all civs (before modifiers): %d", GetNumHistoricEvents(), iTotalBonus);
		strTemp += strData;
		
		pLog->Msg(strTemp);
	}

	return iTotalBonus;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeSingleVotes(int iChange)
{
	m_iSingleVotes += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetSingleVotes(int iChange)
{
	m_iSingleVotes = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetSingleVotes() const
{
	return m_iSingleVotes;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMonopolyModFlat(int iChange)
{
	m_iMonopolyModFlat += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetMonopolyModFlat(int iChange)
{
	m_iMonopolyModFlat = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetMonopolyModFlat() const
{
	return m_iMonopolyModFlat;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMonopolyModPercent(int iChange)
{
	m_iMonopolyModPercent += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetMonopolyModPercent(int iChange)
{
	m_iMonopolyModPercent = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetMonopolyModPercent() const
{
	return m_iMonopolyModPercent;
}

/// What are we willing to give/receive for peace with the active human player?
int CvPlayer::GetCachedValueOfPeaceWithHuman() const
{
	return m_iCachedValueOfPeaceWithHuman;
}

/// Sets what are we willing to give/receive for peace with the active human player
void CvPlayer::SetCachedValueOfPeaceWithHuman(int iValue)
{
	m_iCachedValueOfPeaceWithHuman = iValue;
}

/// What are we willing to give/receive for peace with the active human player?
int CvPlayer::GetFaithPurchaseCooldown() const
{
	return m_iFaithPurchaseCooldown;
}

/// Sets what are we willing to give/receive for peace with the active human player
void CvPlayer::ChangeFaithPurchaseCooldown(int iValue)
{
	m_iFaithPurchaseCooldown += iValue;
}

int CvPlayer::GetNumCSAllies() const
{
	return m_iCSAllies;
}
void CvPlayer::SetNumCSAllies(int iChange)
{
	if (m_iCSAllies != iChange)
	{
		m_iCSAllies = iChange;
	}
}

int CvPlayer::GetNumCSFriends() const
{
	return m_iCSFriends;
}
void CvPlayer::SetNumCSFriends(int iChange)
{
	if (m_iCSFriends != iChange)
	{
		m_iCSFriends = iChange;
	}
}

void CvPlayer::RefreshCSAlliesFriends()
{
	int iFriends = 0;
	int iAllies = 0;
	// Loop through all minors and get the total number we've met.
	for (int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		PlayerTypes eMinor = (PlayerTypes)iMinorLoop;

		if (GET_PLAYER(eMinor).isAlive() && GET_PLAYER(eMinor).isMinorCiv())
		{
			if (GET_PLAYER(eMinor).GetMinorCivAI()->IsAllies(GetID()))
			{
				iAllies++;
			}
			else if (GET_PLAYER(eMinor).GetMinorCivAI()->IsFriends(GetID()))
			{
				iFriends++;
			}
		}
	}
	SetNumCSAllies(iAllies);
	SetNumCSFriends(iFriends);
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::GetAbleToAnnexCityStatesCount() const
{
	return m_iAbleToAnnexCityStatesCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeAbleToAnnexCityStatesCount(int iChange)
{
	m_iAbleToAnnexCityStatesCount += iChange;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsOnlyTradeSameIdeology() const
{
	return m_iOnlyTradeSameIdeology > 0;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeOnlyTradeSameIdeology(int iChange)
{
	m_iOnlyTradeSameIdeology += iChange;
}

#if defined(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS)
//	--------------------------------------------------------------------------------
int CvPlayer::GetPovertyUnhappinessMod() const
{
	return m_iPovertyUnhappinessMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangePovertyUnhappinessMod(int iChange)
{
	m_iPovertyUnhappinessMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetDefenseUnhappinessMod() const
{
	return m_iDefenseUnhappinessMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeDefenseUnhappinessMod(int iChange)
{
	m_iDefenseUnhappinessMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetUnculturedUnhappinessMod() const
{
	return m_iUnculturedUnhappinessMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeUnculturedUnhappinessMod(int iChange)
{
	m_iUnculturedUnhappinessMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetIlliteracyUnhappinessMod() const
{
	return m_iIlliteracyUnhappinessMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeIlliteracyUnhappinessMod(int iChange)
{
	m_iIlliteracyUnhappinessMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetMinorityUnhappinessMod() const
{
	return m_iMinorityUnhappinessMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMinorityUnhappinessMod(int iChange)
{
	m_iMinorityUnhappinessMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetPovertyUnhappinessModCapital() const
{
	return m_iPovertyUnhappinessModCapital;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangePovertyUnhappinessModCapital(int iChange)
{
	m_iPovertyUnhappinessModCapital += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetDefenseUnhappinessModCapital() const
{
	return m_iDefenseUnhappinessModCapital;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeDefenseUnhappinessModCapital(int iChange)
{
	m_iDefenseUnhappinessModCapital += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetUnculturedUnhappinessModCapital() const
{
	return m_iUnculturedUnhappinessModCapital;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeUnculturedUnhappinessModCapital(int iChange)
{
	m_iUnculturedUnhappinessModCapital += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetIlliteracyUnhappinessModCapital() const
{
	return m_iIlliteracyUnhappinessModCapital;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeIlliteracyUnhappinessModCapital(int iChange)
{
	m_iIlliteracyUnhappinessModCapital += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetMinorityUnhappinessModCapital() const
{
	return m_iMinorityUnhappinessModCapital;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMinorityUnhappinessModCapital(int iChange)
{
	m_iMinorityUnhappinessModCapital += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetPuppetUnhappinessMod() const
{
	return m_iPuppetUnhappinessMod;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangePuppetUnhappinessMod(int iChange)
{
	m_iPuppetUnhappinessMod += iChange;
}
// Specialists
//	--------------------------------------------------------------------------------
int CvPlayer::GetNoUnhappfromXSpecialists() const
{
	return m_iNoUnhappfromXSpecialists;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNoUnhappfromXSpecialists(int iChange)
{
	m_iNoUnhappfromXSpecialists += iChange;
}

int CvPlayer::GetTechDeviation() const
{

	int iOurTech = GET_TEAM(getTeam()).GetTeamTechs()->GetNumTechsKnown();
	int iNumTechs = GC.getNumTechInfos();

	int iPercentResearched = iOurTech * 100;
	iPercentResearched /= max(1, iNumTechs);

	iPercentResearched *= (int)GC.getBALANCE_HAPPINESS_TECH_BASE_MODIFIER();
	iPercentResearched /= 100;
	/*
	//Let's modify this based on the number of player techs - more techs means the threshold goes higher.
	int iOurTech = GET_TEAM(getTeam()).GetTeamTechs()->GetNumTechsKnown();
	int iAvgTech = GC.getGame().GetGlobalTechAvg();

	int iTechDeviation = iOurTech - iAvgTech;

	//Using the num of techs to get a % - num of techs artificially increased to slow rate of runaways
	int iTech = (int)((iTechDeviation * iTechDeviation) * /*.1*/ //GC.getBALANCE_HAPPINESS_TECH_BASE_MODIFIER());

	/*
	if (iTech > 0 && iTech > (GC.getBALANCE_HAPPINESS_TECH_BASE_MODIFIER() * 100))
		iTech = ((int)GC.getBALANCE_HAPPINESS_TECH_BASE_MODIFIER() * 100);
	else if (iTech < 0 && iTech <= (GC.getBALANCE_HAPPINESS_TECH_BASE_MODIFIER() * -100))
		iTech = ((int)GC.getBALANCE_HAPPINESS_TECH_BASE_MODIFIER() * -100);
	*/

	return iPercentResearched;
}


//	--------------------------------------------------------------------------------
int CvPlayer::GetHappfromXSpecialists() const
{
	return m_iHappfromXSpecialists;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeHappfromXSpecialists(int iChange)
{
	m_iHappfromXSpecialists += iChange;
}



//	--------------------------------------------------------------------------------
int CvPlayer::GetNoUnhappfromXSpecialistsCapital() const
{
	return m_iNoUnhappfromXSpecialistsCapital;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNoUnhappfromXSpecialistsCapital(int iChange)
{
	m_iNoUnhappfromXSpecialistsCapital += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetSpecialistFoodChange() const
{
	return m_iSpecialistFoodChange;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeSpecialistFoodChange(int iChange)
{
	m_iSpecialistFoodChange += iChange;
}



//	--------------------------------------------------------------------------------
int CvPlayer::GetWarWearinessModifier() const
{
	return m_iWarWearinessModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeWarWearinessModifier(int iChange)
{
	m_iWarWearinessModifier += iChange;
}

int CvPlayer::GetWarScoreModifier() const
{
	return m_iWarScoreModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeWarScoreModifier(int iChange)
{
	m_iWarScoreModifier += iChange;
}

void CvPlayer::SetProductionRoutesAllCities(bool bValue)
{
	if (m_bAllowsProductionTradeRoutesGlobal != bValue)
	{
		m_bAllowsProductionTradeRoutesGlobal = bValue;
	}
}
bool CvPlayer::IsProductionRoutesAllCities() const
{
	return m_bAllowsProductionTradeRoutesGlobal;
}

void CvPlayer::SetFoodRoutesAllCities(bool bValue)
{
	if (m_bAllowsFoodTradeRoutesGlobal != bValue)
	{
		m_bAllowsFoodTradeRoutesGlobal = bValue;
	}
}
bool CvPlayer::IsFoodRoutesAllCities() const
{
	return m_bAllowsFoodTradeRoutesGlobal;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getCultureBombTimer() const
{
	return m_iCultureBombTimer;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setCultureBombTimer(int iNewValue)
{
	if(getCultureBombTimer() != iNewValue)
	{
		m_iCultureBombTimer = iNewValue;
		CvAssert(getCultureBombTimer() >= 0);
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeCultureBombTimer(int iChange)
{
	setCultureBombTimer(getCultureBombTimer() + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getConversionTimer() const
{
	return m_iConversionTimer;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setConversionTimer(int iNewValue)
{
	if(getConversionTimer() != iNewValue)
	{
		m_iConversionTimer = iNewValue;
		CvAssert(getConversionTimer() >= 0);

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(MiscButtons_DIRTY_BIT, true);
		}
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeConversionTimer(int iChange)
{
	setConversionTimer(getConversionTimer() + iChange);
}

//	--------------------------------------------------------------------------------
CvCity* CvPlayer::getCapitalCity() const
{
	return getCity(m_iCapitalCityID);
}

//	--------------------------------------------------------------------------------
void CvPlayer::setCapitalCity(CvCity* pNewCapitalCity)
{
	CvCity* pOldCapitalCity;

	pOldCapitalCity = getCapitalCity();

	if(pOldCapitalCity != pNewCapitalCity)
	{
		if(pNewCapitalCity != NULL)
		{
			// Need to set our original capital x,y?
			if(GetOriginalCapitalX() == -1 || GetOriginalCapitalY() == -1)
			{
				m_iOriginalCapitalX = pNewCapitalCity->getX();
				m_iOriginalCapitalY = pNewCapitalCity->getY();
			}

			m_iCapitalCityID = pNewCapitalCity->GetID();
		}
		else
		{
			m_iCapitalCityID = -1;
		}
	}
}

//	--------------------------------------------------------------------------------
/// Where was our original capital located?
int CvPlayer::GetOriginalCapitalX() const
{
	return m_iOriginalCapitalX;
}

//	--------------------------------------------------------------------------------
/// Where was our original capital located?
int CvPlayer::GetOriginalCapitalY() const
{
	return m_iOriginalCapitalY;
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
void CvPlayer::setOriginalCapitalXY(CvCity* pCapitalCity)
{
	if(pCapitalCity != NULL)
	{
		m_iOriginalCapitalX = pCapitalCity->getX();
		m_iOriginalCapitalY = pCapitalCity->getY();
	}
}
#endif

//	--------------------------------------------------------------------------------
/// Have we lost our holy city in war?
bool CvPlayer::IsHasLostHolyCity() const
{
	return m_bLostHolyCity;
}

//	--------------------------------------------------------------------------------
/// Sets us to having lost our capital in war
void CvPlayer::SetHasLostHolyCity(bool bValue, PlayerTypes eConqueror)
{
	if (bValue != m_bLostCapital)
	{
		m_bLostHolyCity = bValue;
		m_eHolyCityConqueror = eConqueror;
	}
}

//	--------------------------------------------------------------------------------
/// Sets us to having lost our capital in war
void CvPlayer::SetLostHolyCityXY(int iX, int iY)
{
	m_iHolyCityX = iX;
	m_iHolyCityY = iY;
}

int CvPlayer::GetLostHolyCityX()
{
	return m_iHolyCityX;
}
int CvPlayer::GetLostHolyCityY()
{
	return m_iHolyCityY;
}

PlayerTypes CvPlayer::GetHolyCityConqueror()
{
	return m_eHolyCityConqueror;
}


//	--------------------------------------------------------------------------------
/// Have we lost our capital in war?
bool CvPlayer::IsHasLostCapital() const
{
	return m_bLostCapital;
}

//	--------------------------------------------------------------------------------
/// Sets us to having lost our capital in war
void CvPlayer::SetHasLostCapital(bool bValue, PlayerTypes eConqueror)
{
	if(bValue != m_bLostCapital)
	{
		m_bLostCapital = bValue;
		m_eConqueror = eConqueror;

		// Don't really care if a City State lost its capital
		if(!isMinorCiv())
		{
			int iMostOriginalCapitals = 0;
			TeamTypes eWinningTeam = NO_TEAM;
			PlayerTypes eWinningPlayer = NO_PLAYER;

			{
				// Calculate who owns the most original capitals by iterating through all civs 
				// and finding out who owns their original capital.
				typedef std::tr1::array<int, MAX_CIV_TEAMS> CivTeamArray;
				CivTeamArray aTeamCityCount;
				aTeamCityCount.assign(0);

				CvMap& kMap = GC.getMap();
				for (int iLoopPlayer = 0; iLoopPlayer < MAX_MAJOR_CIVS; ++iLoopPlayer)
				{
					const PlayerTypes ePlayer = static_cast<PlayerTypes>(iLoopPlayer);
					CvPlayer& kLoopPlayer = GET_PLAYER(ePlayer);
					if(kLoopPlayer.isEverAlive())
					{
						const int iOriginalCapitalX = kLoopPlayer.GetOriginalCapitalX();
						const int iOriginalCapitalY = kLoopPlayer.GetOriginalCapitalY();
						if(iOriginalCapitalX != -1 && iOriginalCapitalY != -1)
						{
							CvPlot* pkPlot = kMap.plot(iOriginalCapitalX, iOriginalCapitalY);
							if(pkPlot != NULL)
							{
								CvCity* pkCapitalCity = pkPlot->getPlotCity();
								if(pkCapitalCity != NULL)
								{
									const PlayerTypes eCapitalOwner = pkCapitalCity->getOwner();
									if(eCapitalOwner != NO_PLAYER)
									{
										CvPlayer& kCapitalOwnerPlayer = GET_PLAYER(eCapitalOwner);
										aTeamCityCount[kCapitalOwnerPlayer.getTeam()]++;
									}
								}
							}	
						}
					}
				}

				// What's the max count and are they the only team to have the max?
				CivTeamArray::iterator itMax = max_element(aTeamCityCount.begin(), aTeamCityCount.end());
				if(count(aTeamCityCount.begin(), aTeamCityCount.end(), *itMax) == 1)
				{
					eWinningTeam = static_cast<TeamTypes>(itMax - aTeamCityCount.begin());
					iMostOriginalCapitals = *itMax;

					CvTeam& kTeam = GET_TEAM(eWinningTeam);
					eWinningPlayer = kTeam.getLeaderID();
				}			
			}

			// Someone just lost their capital, test to see if someone wins
			if(bValue)
			{
				// slewis - Moved Conquest victory elsewhere so that victory is more accurately awarded
				//GC.getGame().DoTestConquestVictory();

				Localization::String localizedBuffer;
				Localization::String localizedSummary;
				NotificationTypes eNotificationType = NOTIFICATION_CAPITAL_LOST;

				for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
				{
					PlayerTypes ePlayer = (PlayerTypes)ui;
					CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();
					if(!pNotifications)
					{
						continue;
					}

					// Notify Player lost their capital
					if(ePlayer == GetID())
					{
						eNotificationType = NOTIFICATION_CAPITAL_LOST_ACTIVE_PLAYER;
						localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_YOU_LOST_CAPITAL");
						if (eWinningPlayer == ePlayer)
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_LOST_CAPITAL_YOU_WINNING");
							localizedBuffer << iMostOriginalCapitals;
						}
						else if (eWinningTeam != NO_TEAM)
						{
							if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(eWinningTeam))
							{
								if (eWinningPlayer != NO_PLAYER) // there is a winning player
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_LOST_CAPITAL_OTHER_PLAYER_WINNING");
									if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
									}
									else
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
									}
									localizedBuffer << iMostOriginalCapitals;
								}
								else
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_LOST_CAPITAL_TEAM_WINNING");
									localizedBuffer << (int)eWinningTeam;
									localizedBuffer << iMostOriginalCapitals;
								}
							}
							else // if someone is winning
							{
								localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_LOST_CAPITAL_UNMET_WINNING");
								localizedBuffer << iMostOriginalCapitals;
							}
						}
						else // if no one is winning
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_LOST_CAPITAL");
						}
					}
					// Known player
					else if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(getTeam()))
					{
						eNotificationType = NOTIFICATION_CAPITAL_LOST;
						localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_PLAYER_LOST_CAPITAL");
						localizedSummary << getCivilizationShortDescriptionKey();

						if (eWinningTeam != NO_TEAM)
						{
							if (GET_TEAM(eWinningTeam).isHasMet(GET_PLAYER(ePlayer).getTeam()))
							{
								if (eWinningPlayer == GetID())
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL_YOU_WINNING");

									if (GC.getGame().isGameMultiPlayer() && isHuman())
									{
										localizedBuffer << getNickName();
									}
									else
									{
										localizedBuffer << getNameKey();
									}
									localizedBuffer << iMostOriginalCapitals;
								}
								else if (eWinningPlayer != NO_PLAYER)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL_OTHER_WINNING");
									if (GC.getGame().isGameMultiPlayer() && isHuman())
									{
										localizedBuffer << getNickName();
									}
									else
									{
										localizedBuffer << getNameKey();
									}

									if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
									}
									else
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
									}
									localizedBuffer << iMostOriginalCapitals;
								}
								else // if (eWinningTeam != NO_TEAM)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL_TEAM_WINNING");
									if (GC.getGame().isGameMultiPlayer() && isHuman())
									{
										localizedBuffer << getNickName();
									}
									else
									{
										localizedBuffer << getNameKey();
									}

									localizedBuffer << (int)eWinningTeam;
									localizedBuffer << iMostOriginalCapitals;
								}
							}
							else
							{
								localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL_UNMET_WINNING");
								if (GC.getGame().isGameMultiPlayer() && isHuman())
								{
									localizedBuffer << getNickName();
								}
								else
								{
									localizedBuffer << getNameKey();
								}
								localizedBuffer << iMostOriginalCapitals;
							}
						}
						else
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL");
							if (GC.getGame().isGameMultiPlayer() && isHuman())
							{
								localizedBuffer << getNickName();
							}
							else
							{
								localizedBuffer << getNameKey();
							}
						}
					}
					else // unmet player
					{
						eNotificationType = NOTIFICATION_CAPITAL_LOST;
						localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_SOMEONE_LOST_CAPITAL");

						if (eWinningTeam != NO_TEAM)
						{
							if (GET_TEAM(eWinningTeam).isHasMet(GET_PLAYER(ePlayer).getTeam()))
							{
								if (eWinningPlayer == GetID())
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_LOST_CAPITAL_YOU_WINNING");
									localizedBuffer << iMostOriginalCapitals;
								}
								else if (eWinningPlayer != NO_PLAYER)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_LOST_CAPITAL_OTHER_WINNING");
									if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
									}
									else
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
									}
									localizedBuffer << iMostOriginalCapitals;
								}
								else // if (eWinningTeam != NO_TEAM)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_LOST_CAPITAL_TEAM_WINNING");
									localizedBuffer << (int)eWinningTeam;
									localizedBuffer << iMostOriginalCapitals;
								}
							}
							else
							{
								localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_LOST_CAPITAL_UNMET_WINNING");
								localizedBuffer << iMostOriginalCapitals;
							}
						}
						else
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_LOST_CAPITAL");
						}
					}

					pNotifications->Add(eNotificationType, localizedBuffer.toUTF8(), localizedSummary.toUTF8(), -1, -1, -1);
				}

				//replay message
				{
					Localization::String message;
					if (eWinningPlayer != NO_PLAYER)
					{
						message = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL_OTHER_WINNING");
						if (GC.getGame().isGameMultiPlayer() && isHuman())
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNickName();
#else
							localizedBuffer << getNickName();
#endif
						}
						else
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNameKey();
#else
							localizedBuffer << getNameKey();
#endif
						}

						if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
						{
#if defined(MOD_BUGFIX_MINOR)
							message << GET_PLAYER(eWinningPlayer).getNickName();
#else
							localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
#endif
						}
						else
						{
#if defined(MOD_BUGFIX_MINOR)
							message << GET_PLAYER(eWinningPlayer).getNameKey();
#else
							localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
#endif
						}

#if defined(MOD_BUGFIX_MINOR)
						message << iMostOriginalCapitals;
#else
						localizedBuffer << iMostOriginalCapitals;
#endif
					}
					else if (eWinningTeam != NO_TEAM)
					{
						message = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL_TEAM_WINNING");
						if (GC.getGame().isGameMultiPlayer() && isHuman())
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNickName();
#else
							localizedBuffer << getNickName();
#endif
						}
						else
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNameKey();
#else
							localizedBuffer << getNameKey();
#endif
						}

#if defined(MOD_BUGFIX_MINOR)
						message << (int)eWinningTeam;
						message << iMostOriginalCapitals;
#else
						localizedBuffer << (int)eWinningTeam;
						localizedBuffer << iMostOriginalCapitals;
#endif
					}
					else
					{
						message = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL");
						if (GC.getGame().isGameMultiPlayer() && isHuman())
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNickName();
#else
							localizedBuffer << getNickName();
#endif
						}
						else
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNameKey();
#else
							localizedBuffer << getNameKey();
#endif
						}
					}

					CvString translatedMessage = message.toUTF8();
					GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, GetID(), translatedMessage, GetOriginalCapitalX(), GetOriginalCapitalY());
				}					
			}
			// Player recovered capital!
			else
			{
				Localization::String localizedBuffer;
				Localization::String localizedSummary;

				for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
				{
					PlayerTypes ePlayer = (PlayerTypes)ui;
					CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();
					if(!pNotifications)
					{
						continue;
					}

					// Notify Player lost their capital
					if(ePlayer == GetID())
					{
						localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_RECOVERED_CAPITAL");
						if (eWinningPlayer == ePlayer)
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_REGAINED_CAPITAL_YOU_WINNING");
							localizedBuffer << iMostOriginalCapitals;
						}
						else if (GET_TEAM(getTeam()).isHasMet(eWinningTeam))
						{
							if (eWinningPlayer != NO_PLAYER) // there is a winning player
							{
								localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_REGAINED_CAPITAL_OTHER_PLAYER_WINNING");
								if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
								{
									localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
								}
								else
								{
									localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
								}
								localizedBuffer << iMostOriginalCapitals;
							}
							else
							{
								localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_REGAINED_CAPITAL_TEAM_WINNING");
								localizedBuffer << (int)eWinningTeam;
								localizedBuffer << iMostOriginalCapitals;
							}
						}
						else if (eWinningTeam != NO_TEAM) // if someone is winning
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_REGAINED_CAPITAL_UNMET_WINNING");
							localizedBuffer << iMostOriginalCapitals;
						}
						else // if no one is winning
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_RECOVERED_CAPITAL");
						}
					}
					// Known player
					else if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(getTeam()))
					{
						localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_PLAYER_RECOVERED_CAPITAL");
						localizedSummary << getCivilizationShortDescriptionKey();

						if (eWinningTeam != NO_TEAM)
						{
							if (GET_TEAM(eWinningTeam).isHasMet(getTeam()))
							{
								if (eWinningPlayer == ePlayer)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL_YOU_WINNING");
									localizedBuffer << iMostOriginalCapitals;
								}
								else if (eWinningPlayer != NO_PLAYER)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL_OTHER_WINNING");
									if (GC.getGame().isGameMultiPlayer() && isHuman())
									{
										localizedBuffer << getNickName();
									}
									else
									{
										localizedBuffer << getNameKey();
									}

									if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
									}
									else
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
									}
									localizedBuffer << iMostOriginalCapitals;
								}
								else // if (eWinningTeam != NO_TEAM)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL_TEAM_WINNING");
									if (GC.getGame().isGameMultiPlayer() && isHuman())
									{
										localizedBuffer << getNickName();
									}
									else
									{
										localizedBuffer << getNameKey();
									}

									localizedBuffer << (int)eWinningTeam;
									localizedBuffer << iMostOriginalCapitals;
								}
							}
							else
							{
								localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL_UNMET_WINNING");
								if (GC.getGame().isGameMultiPlayer() && isHuman())
								{
									localizedBuffer << getNickName();
								}
								else
								{
									localizedBuffer << getNameKey();
								}
								localizedBuffer << iMostOriginalCapitals;
							}
						}
						else
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL");
							if (GC.getGame().isGameMultiPlayer() && isHuman())
							{
								localizedBuffer << getNickName();
							}
							else
							{
								localizedBuffer << getNameKey();
							}
						}
					}
					else // unmet player
					{
						localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_SOMEONE_RECOVERED_CAPITAL");

						if (eWinningTeam != NO_TEAM)
						{
							if (GET_TEAM(eWinningTeam).isHasMet(getTeam()))
							{
								if (eWinningPlayer == ePlayer)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_REGAINED_CAPITAL_YOU_WINNING");
									localizedBuffer << iMostOriginalCapitals;
								}
								else if (eWinningPlayer != NO_PLAYER)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_REGAINED_CAPITAL_OTHER_WINNING");
									if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
									}
									else
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
									}
									localizedBuffer << iMostOriginalCapitals;
								}
								else // if (eWinningTeam != NO_TEAM)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_REGAINED_CAPITAL_TEAM_WINNING");
									localizedBuffer << (int)eWinningTeam;
									localizedBuffer << iMostOriginalCapitals;
								}
							}
							else
							{
								localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_REGAINED_CAPITAL_UNMET_WINNING");
								localizedBuffer << iMostOriginalCapitals;
							}
						}
						else
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_REGAINED_CAPITAL");
						}
					}

					pNotifications->Add(NOTIFICATION_CAPITAL_RECOVERED, localizedBuffer.toUTF8(), localizedSummary.toUTF8(), -1, -1, -1);
				}

				//replay message
				{
					Localization::String message;
					if (eWinningPlayer != NO_PLAYER)
					{
						message = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL_OTHER_WINNING");
						if (GC.getGame().isGameMultiPlayer() && isHuman())
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNickName();
#else
							localizedBuffer << getNickName();
#endif
						}
						else
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNameKey();
#else
							localizedBuffer << getNameKey();
#endif
						}

						if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
						{
#if defined(MOD_BUGFIX_MINOR)
							message << GET_PLAYER(eWinningPlayer).getNickName();
#else
							localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
#endif
						}
						else
						{
#if defined(MOD_BUGFIX_MINOR)
							message << GET_PLAYER(eWinningPlayer).getNameKey();
#else
							localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
#endif
						}

#if defined(MOD_BUGFIX_MINOR)
						message << iMostOriginalCapitals;
#else
						localizedBuffer << iMostOriginalCapitals;
#endif
					}
					else if (eWinningTeam != NO_TEAM)
					{
						message = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL_TEAM_WINNING");
						if (GC.getGame().isGameMultiPlayer() && isHuman())
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNickName();
#else
							localizedBuffer << getNickName();
#endif
						}
						else
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNameKey();
#else
							localizedBuffer << getNameKey();
#endif
						}

#if defined(MOD_BUGFIX_MINOR)
						message << (int)eWinningTeam;
						message << iMostOriginalCapitals;
#else
						localizedBuffer << (int)eWinningTeam;
						localizedBuffer << iMostOriginalCapitals;
#endif
					}
					else
					{
						message = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL");
						if (GC.getGame().isGameMultiPlayer() && isHuman())
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNickName();
#else
							localizedBuffer << getNickName();
#endif
						}
						else
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNameKey();
#else
							localizedBuffer << getNameKey();
#endif
						}
					}

					CvString translatedMessage = message.toUTF8();
					GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, GetID(), translatedMessage, GetOriginalCapitalX(), GetOriginalCapitalY());
				}					
			}
		}
	}
}


//	--------------------------------------------------------------------------------
/// Player who first captured our capital
PlayerTypes CvPlayer::GetCapitalConqueror() const
{
	return m_eConqueror;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getCitiesLost() const
{
	return m_iCitiesLost;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeCitiesLost(int iChange)
{
	m_iCitiesLost = (m_iCitiesLost + iChange);
}

//	--------------------------------------------------------------------------------

int CvPlayer::GetMilitaryRating() const
{
	return m_iMilitaryRating;
}

//	--------------------------------------------------------------------------------

void CvPlayer::SetMilitaryRating(int iValue)
{
	m_iMilitaryRating = iValue;
}

//	--------------------------------------------------------------------------------

void CvPlayer::ChangeMilitaryRating(int iChange)
{
	SetMilitaryRating(GetMilitaryRating() + iChange);
}

//	--------------------------------------------------------------------------------

void CvPlayer::updateMightStatistics()
{
	m_iTurnSliceMightRecomputed = GC.getGame().getTurnSlice();
	m_iMilitaryMight = calculateMilitaryMight();
	m_iEconomicMight = calculateEconomicMight();
	m_iProductionMight = calculateProductionMight();

#if defined(MOD_BATTLE_ROYALE)
	if (MOD_BATTLE_ROYALE)
	{
		m_iMilitarySeaMight = calculateMilitaryMight(DOMAIN_SEA);
		m_iMilitaryAirMight = calculateMilitaryMight(DOMAIN_AIR);
		m_iMilitaryLandMight = calculateMilitaryMight(DOMAIN_LAND);
	}
#endif
}

//	--------------------------------------------------------------------------------
int CvPlayer::getPower() const
{
	// more lazy evaluation
	if (m_iTurnSliceMightRecomputed < GC.getGame().getTurnSlice())
		const_cast<CvPlayer*>(this)->updateMightStatistics();

	return m_iMilitaryMight + m_iEconomicMight;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetMilitaryMight(bool bForMinor) const
{
	// more lazy evaluation
	if (m_iTurnSliceMightRecomputed < GC.getGame().getTurnSlice())
		const_cast<CvPlayer*>(this)->updateMightStatistics();

	if (bForMinor && GetPlayerTraits()->GetBullyMilitaryStrengthModifier() != 0)
	{
		int iBonus = m_iMilitaryMight;
		iBonus *= (100 + GetPlayerTraits()->GetBullyMilitaryStrengthModifier());
		iBonus /= 100;
		return iBonus;
	}

	return m_iMilitaryMight;
}
#if defined(MOD_BATTLE_ROYALE)
//	--------------------------------------------------------------------------------
int CvPlayer::GetMilitarySeaMight() const
{
	if (m_iTurnSliceMightRecomputed < GC.getGame().getTurnSlice())
	{
		const_cast<CvPlayer*>(this)->updateMightStatistics();
	}
	return m_iMilitarySeaMight;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetMilitaryAirMight() const
{
	if (m_iTurnSliceMightRecomputed < GC.getGame().getTurnSlice())
	{
		const_cast<CvPlayer*>(this)->updateMightStatistics();
	}
	return m_iMilitaryAirMight;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetMilitaryLandMight() const
{
	if (m_iTurnSliceMightRecomputed < GC.getGame().getTurnSlice())
	{
		const_cast<CvPlayer*>(this)->updateMightStatistics();
	}
	return m_iMilitaryLandMight;
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::GetEconomicMight() const
{
	// more lazy evaluation
	if (m_iTurnSliceMightRecomputed < GC.getGame().getTurnSlice())
		const_cast<CvPlayer*>(this)->updateMightStatistics();

	return m_iEconomicMight;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetProductionMight() const
{
	// more lazy evaluation
	if(m_iTurnSliceMightRecomputed < GC.getGame().getElapsedGameTurns())
		const_cast<CvPlayer*>(this)->updateMightStatistics();

	return m_iProductionMight;
}

//	--------------------------------------------------------------------------------
int CvPlayer::calculateMilitaryMight(DomainTypes eDomain) const
{
	int iSum = 0;
	int iLoop;
	for(const CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(!pLoopUnit->IsCombatUnit())
			continue;

		if (eDomain != NO_DOMAIN && pLoopUnit->getDomainType() != eDomain)
			continue;

		//we are interested in the offensive capabilities of the player
		int iPower = pLoopUnit->GetBestAttackStrength() / 100;

		//some promotions already influence the combat strength so to prevent double counting only consider the advanced promotions
		int iPromotionFactor = 100;
		if (pLoopUnit->getLevel()>3)
			iPromotionFactor += pLoopUnit->getLevel() * 10 - 30;

		//assume garrisons won't take part in offensive action
		if (pLoopUnit->IsGarrisoned())
			iPower /= 2;

		iSum += (iPower*iPromotionFactor)/100;
	}
	
	return iSum;
}

//	--------------------------------------------------------------------------------
int CvPlayer::calculateEconomicMight() const
{
	int iEconomicMight = 5;
	iEconomicMight += getTotalPopulation();

	iEconomicMight += calculateTotalYield(YIELD_FOOD);
	iEconomicMight += calculateTotalYield(YIELD_PRODUCTION);
	iEconomicMight += calculateTotalYield(YIELD_SCIENCE);
	iEconomicMight += calculateTotalYield(YIELD_GOLD);
	iEconomicMight += calculateTotalYield(YIELD_CULTURE);

	//Finally, divide our power by the number of cities we own - the more we have, the less we can defend.
	int iNumCities = (getNumCities() * 10) + 100;
	if (iNumCities > 0)
	{
		iEconomicMight *= 100;
		iEconomicMight /= min(300, iNumCities);
	}

	//Finally, divide our power by the number of cities we own - the more we have, the more our upkeep.
	return iEconomicMight;
}

//	--------------------------------------------------------------------------------
int CvPlayer::calculateProductionMight() const
{
	int iMight = 0;
	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iMight += pLoopCity->getRawProductionDifference(/*bIgnoreFood*/ true, /*bOverflow*/ false);
	}

	return iMight;
}

#if defined(MOD_UNITS_XP_TIMES_100)
int CvPlayer::getCombatExperienceTimes100() const
#else
int CvPlayer::getCombatExperience() const
#endif
{
#if defined(MOD_UNITS_XP_TIMES_100)
	return m_iCombatExperienceTimes100;
#else
	return m_iCombatExperience;
#endif
}

//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
#if defined(MOD_UNITS_XP_TIMES_100)
void CvPlayer::setCombatExperienceTimes100(int iExperienceTimes100, CvUnit* pFromUnit)
#else
void CvPlayer::setCombatExperience(int iExperience, CvUnit* pFromUnit)
#endif
#else
#if defined(MOD_UNITS_XP_TIMES_100)
void CvPlayer::setCombatExperienceTimes100(int iExperienceTimes100)
#else
void CvPlayer::setCombatExperience(int iExperience)
#endif
#endif
{

#if defined(MOD_UNITS_XP_TIMES_100)
	CvAssert(iExperienceTimes100 >= 0);
	
	if (iExperienceTimes100 != getCombatExperienceTimes100())
#else
	CvAssert(iExperience >= 0);
	
	if (iExperience != getCombatExperience())
#endif
	{
#if defined(MOD_UNITS_XP_TIMES_100)
		m_iCombatExperienceTimes100 = iExperienceTimes100;
#else
		m_iCombatExperience = iExperience;
#endif

		// Enough XP for a Great General to appear?
		if(!isBarbarian())
		{
#if defined(MOD_UNITS_XP_TIMES_100)
			int iExperienceThresholdTimes100 = greatGeneralThreshold() * 100;
			if (m_iCombatExperienceTimes100 >= iExperienceThresholdTimes100 && iExperienceThresholdTimes100 > 0)
#else
			int iExperienceThreshold = greatGeneralThreshold();
			if (m_iCombatExperience >= iExperienceThreshold && iExperienceThreshold > 0)
#endif
			{
				// create great person
				CvCity* pBestCity = NULL;
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
				if(pFromUnit == NULL)
				{
#endif
					int iBestValue = INT_MAX;
					int iLoop;
					for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						int iValue = 4 * GC.getGame().getSmallFakeRandNum(getNumCities(), GetPseudoRandomSeed() + iLoop);

						for(int i = 0; i < NUM_YIELD_TYPES; i++)
						{
							iValue += pLoopCity->findYieldRateRank((YieldTypes)i);
						}
						iValue += pLoopCity->findPopulationRank();

						if(iValue < iBestValue)
						{
							pBestCity = pLoopCity;
							iBestValue = iValue;
						}
					}
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
				}
#endif

#if defined(MOD_GLOBAL_LOCAL_GENERALS)
				if(pBestCity || pFromUnit)
#else
				if(pBestCity)
#endif
				{
					// Figure out which Promotion is the one which makes a unit a Great General
					for(int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
					{
						const PromotionTypes eLoopPromotion = static_cast<PromotionTypes>(iI);
						CvPromotionEntry* pkPromotionInfo = GC.getPromotionInfo(eLoopPromotion);
						if(pkPromotionInfo)
						{
							if(pkPromotionInfo->IsGreatGeneral())
							{
								for(int iI = 0; iI < GC.getNumUnitInfos(); iI++)
								{
									const UnitTypes eLoopUnit = static_cast<UnitTypes>(iI);
									CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eLoopUnit);
									if(pkUnitInfo)
									{
										if(pkUnitInfo->GetFreePromotions(eLoopPromotion))
										{
											// Is this the right unit of this class for this civ?
											const UnitTypes eUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits((UnitClassTypes)pkUnitInfo->GetUnitClassType());

											if(eUnit == eLoopUnit)
											{
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
												if(pFromUnit)
												{
													CUSTOMLOG("Create Great General at (%d, %d) from unit %s", pFromUnit->plot()->getX(), pFromUnit->plot()->getY(), pFromUnit->getName().GetCString());
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
													createGreatGeneral(eUnit, pFromUnit->plot()->getX(), pFromUnit->plot()->getY(), false);
#else
													createGreatGeneral(eUnit, pFromUnit->plot()->getX(), pFromUnit->plot()->getY());
#endif
												}
												else
												{
#endif
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
													pBestCity->createGreatGeneral(eUnit, false);
#else
													pBestCity->createGreatGeneral(eUnit);
#endif
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
												}
#endif
#if defined(MOD_UNITS_XP_TIMES_100)
												setCombatExperienceTimes100(getCombatExperienceTimes100() - iExperienceThresholdTimes100);
#else
												setCombatExperience(getCombatExperience() - iExperienceThreshold);
#endif
												break;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
#if defined(MOD_UNITS_XP_TIMES_100)
void CvPlayer::changeCombatExperienceTimes100(int iChangeTimes100, CvUnit* pFromUnit)
#else
void CvPlayer::changeCombatExperience(int iChange, CvUnit* pFromUnit)
#endif
#else
#if defined(MOD_UNITS_XP_TIMES_100)
void CvPlayer::changeCombatExperienceTimes100(int iChangeTimes100)
#else
void CvPlayer::changeCombatExperience(int iChange)
#endif
#endif
{
#if defined(MOD_UNITS_XP_TIMES_100)
	if (!MOD_UNITS_XP_TIMES_100) {
		// If NOT using XP times 100, remove any fractional part
		iChangeTimes100 -= (iChangeTimes100 % 100);
	}
	if (getCombatExperienceTimes100() + iChangeTimes100 < 0)
#else
	if (getCombatExperience() + iChange < 0)
#endif
	{
#if defined(MOD_UNITS_XP_TIMES_100)
		setCombatExperienceTimes100(0);
#else
		setCombatExperience(0);
#endif
	}
	else
	{
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
#if defined(MOD_UNITS_XP_TIMES_100)
		setCombatExperienceTimes100(getCombatExperienceTimes100() + iChangeTimes100, pFromUnit);
#else
		setCombatExperience(getCombatExperience() + iChange, pFromUnit);
#endif
#else
#if defined(MOD_UNITS_XP_TIMES_100)
		setCombatExperienceTimes100(getCombatExperienceTimes100() + iChangeTimes100);
#else
		setCombatExperience(getCombatExperience() + iChange);
#endif
#endif
	}

#if defined(MOD_UNITS_XP_TIMES_100)
	m_iLifetimeCombatExperienceTimes100 += iChangeTimes100;
#else
	m_iLifetimeCombatExperience += iChange;
#endif
}

//	--------------------------------------------------------------------------------
#if defined(MOD_UNITS_XP_TIMES_100)
int CvPlayer::getNavalCombatExperienceTimes100() const
#else
int CvPlayer::getNavalCombatExperience() const
#endif
{
#if defined(MOD_UNITS_XP_TIMES_100)
	return m_iNavalCombatExperienceTimes100;
#else
	return m_iNavalCombatExperience;
#endif
}

//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
#if defined(MOD_UNITS_XP_TIMES_100)
void CvPlayer::setNavalCombatExperienceTimes100(int iExperienceTimes100, CvUnit* pFromUnit)
#else
void CvPlayer::setNavalCombatExperience(int iExperience, CvUnit* pFromUnit)
#endif
#else
#if defined(MOD_UNITS_XP_TIMES_100)
void CvPlayer::setNavalCombatExperienceTimes100(int iExperienceTimes100)
#else
void CvPlayer::setNavalCombatExperience(int iExperience)
#endif
#endif
{
#if defined(MOD_UNITS_XP_TIMES_100)
	CvAssert(iExperienceTimes100 >= 0);

	if (iExperienceTimes100 != getNavalCombatExperienceTimes100())
#else
	CvAssert(iExperience >= 0);

	if (iExperience != getNavalCombatExperience())
#endif
	{
#if defined(MOD_UNITS_XP_TIMES_100)
		m_iNavalCombatExperienceTimes100 = iExperienceTimes100;
#else
		m_iNavalCombatExperience = iExperience;
#endif

		// Enough XP for a Great Admiral to appear?
		if(!isBarbarian())
		{
#if defined(MOD_UNITS_XP_TIMES_100)
			int iExperienceThresholdTimes100 = greatAdmiralThreshold() * 100;
			if (m_iNavalCombatExperienceTimes100 >= iExperienceThresholdTimes100 && iExperienceThresholdTimes100 > 0)
#else
			int iExperienceThreshold = greatAdmiralThreshold();
			if (m_iNavalCombatExperience >= iExperienceThreshold && iExperienceThreshold > 0)
#endif
			{
				// create great person
				CvCity* pBestCity = NULL;
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
				if(pFromUnit == NULL)
				{
#endif
					int iBestValue = INT_MAX;
					int iLoop;
					for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if(!pLoopCity->isCoastal())
						{
							continue;
						}

						int iValue = 4 * GC.getGame().getSmallFakeRandNum(getNumCities(), GetPseudoRandomSeed() + iLoop);

						for(int i = 0; i < NUM_YIELD_TYPES; i++)
						{
							iValue += pLoopCity->findYieldRateRank((YieldTypes)i);
						}
						iValue += pLoopCity->findPopulationRank();

						if(iValue < iBestValue)
						{
							pBestCity = pLoopCity;
							iBestValue = iValue;
						}
					}
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
				}
#endif

#if defined(MOD_GLOBAL_LOCAL_GENERALS)
				if(pBestCity || pFromUnit)
#else
				if(pBestCity)
#endif
				{
					for(int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
					{
						const PromotionTypes eLoopPromotion = static_cast<PromotionTypes>(iI);
						CvPromotionEntry* pkPromotionInfo = GC.getPromotionInfo(eLoopPromotion);
						if(pkPromotionInfo)
						{
							if(pkPromotionInfo->IsGreatAdmiral())
							{
								for(int iI = 0; iI < GC.getNumUnitInfos(); iI++)
								{
									const UnitTypes eLoopUnit = static_cast<UnitTypes>(iI);
									CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eLoopUnit);
									if(pkUnitInfo)
									{
										if(pkUnitInfo->GetFreePromotions(eLoopPromotion))
										{
											// Is this the right unit of this class for this civ?
											const UnitTypes eUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits((UnitClassTypes)pkUnitInfo->GetUnitClassType());

											if(eUnit == eLoopUnit)
											{
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
												if(pFromUnit)
												{
													CUSTOMLOG("Create Great Admiral at (%d, %d) from unit %s", pFromUnit->plot()->getX(), pFromUnit->plot()->getY(), pFromUnit->getName().GetCString());
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
													createGreatAdmiral(eUnit, pFromUnit->plot()->getX(), pFromUnit->plot()->getY(), false);
#else
													createGreatAdmiral(eUnit, pFromUnit->plot()->getX(), pFromUnit->plot()->getY());
#endif

#if defined(MOD_PROMOTIONS_FLAGSHIP)
													if (MOD_PROMOTIONS_FLAGSHIP)
													{
														pFromUnit->setHasPromotion((PromotionTypes)GC.getPROMOTION_FLAGSHIP(), true);
													}
#endif
												}
												else
												{
#endif
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
													pBestCity->createGreatAdmiral(eUnit, false);
#else
													pBestCity->createGreatAdmiral(eUnit);
#endif
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
												}
#endif
#if defined(MOD_UNITS_XP_TIMES_100)
												setNavalCombatExperienceTimes100(getNavalCombatExperienceTimes100() - iExperienceThresholdTimes100);
#else
												setNavalCombatExperience(getNavalCombatExperience() - iExperienceThreshold);
#endif
												break;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
#if defined(MOD_UNITS_XP_TIMES_100)
void CvPlayer::changeNavalCombatExperienceTimes100(int iChangeTimes100, CvUnit* pFromUnit)
#else
void CvPlayer::changeNavalCombatExperience(int iChange, CvUnit* pFromUnit)
#endif
#else
#if defined(MOD_UNITS_XP_TIMES_100)
void CvPlayer::changeNavalCombatExperienceTimes100(int iChangeTimes100)
#else
void CvPlayer::changeNavalCombatExperience(int iChange)
#endif
#endif
{
#if defined(MOD_UNITS_XP_TIMES_100)
	if (!MOD_UNITS_XP_TIMES_100)
	{
		// If NOT using XP times 100, remove any fractional part
		iChangeTimes100 -= (iChangeTimes100 % 100);
	}
	if (getNavalCombatExperienceTimes100() + iChangeTimes100 < 0)
#else
	if (getNavalCombatExperience() + iChange < 0)
#endif
	{
#if defined(MOD_UNITS_XP_TIMES_100)
		setNavalCombatExperienceTimes100(0);
#else
		setNavalCombatExperience(0);
#endif
	}
	else
	{
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
#if defined(MOD_UNITS_XP_TIMES_100)
		setNavalCombatExperienceTimes100(getNavalCombatExperienceTimes100() + iChangeTimes100, pFromUnit);
#else
		setNavalCombatExperience(getNavalCombatExperience() + iChange, pFromUnit);
#endif
#else
#if defined(MOD_UNITS_XP_TIMES_100)
		setNavalCombatExperienceTimes100(getNavalCombatExperienceTimes100() + iChangeTimes100);
#else
		setNavalCombatExperience(getNavalCombatExperience() + iChange);
#endif
#endif
	}

#if defined(MOD_UNITS_XP_TIMES_100)
	m_iLifetimeCombatExperienceTimes100 += iChangeTimes100;
#else
	m_iLifetimeCombatExperience += iChange;
#endif
}

//	--------------------------------------------------------------------------------
#if defined(MOD_UNITS_XP_TIMES_100)
int CvPlayer::getLifetimeCombatExperienceTimes100() const
#else
int CvPlayer::getLifetimeCombatExperience() const
#endif
{
#if defined(MOD_UNITS_XP_TIMES_100)
	return m_iLifetimeCombatExperienceTimes100;
#else
	return m_iLifetimeCombatExperience;
#endif
}

#if defined(MOD_GLOBAL_NO_CONQUERED_SPACESHIPS)
//	--------------------------------------------------------------------------------
// Remove all the parts of the spaceship that this player has assembled
void CvPlayer::disassembleSpaceship(CvPlot* pPlot) {
	if (MOD_GLOBAL_NO_CONQUERED_SPACESHIPS && !isMinorCiv() && !isBarbarian()) {
		CUSTOMLOG("Disassemble spaceship for player %i", GetID());
		CvTeam& thisTeam = GET_TEAM(getTeam());

		if (thisTeam.getProjectCount((ProjectTypes) GC.getSPACE_RACE_TRIGGER_PROJECT()) == 1) {
			thisTeam.changeProjectCount((ProjectTypes) GC.getSPACESHIP_CAPSULE(), -1 * thisTeam.getProjectCount((ProjectTypes) GC.getSPACESHIP_CAPSULE()));
			thisTeam.changeProjectCount((ProjectTypes) GC.getSPACESHIP_BOOSTER(), -1 * thisTeam.getProjectCount((ProjectTypes) GC.getSPACESHIP_BOOSTER()));
			thisTeam.changeProjectCount((ProjectTypes) GC.getSPACESHIP_STASIS(), -1 * thisTeam.getProjectCount((ProjectTypes) GC.getSPACESHIP_STASIS()));
			thisTeam.changeProjectCount((ProjectTypes) GC.getSPACESHIP_ENGINE(), -1 * thisTeam.getProjectCount((ProjectTypes) GC.getSPACESHIP_ENGINE()));

			if (pPlot) {
				CUSTOMLOG("Removing launch pad at (%i, %i)", pPlot->getX(), pPlot->getY());
				auto_ptr<ICvPlot1> pDllPlot(new CvDllPlot(pPlot));
				gDLL->GameplaySpaceshipEdited(pDllPlot.get(), 0x0000); // Remove the launch pad
			}
		}
	}
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::getBorderObstacleCount() const
{
	return m_iBorderObstacleCount;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isBorderObstacle() const
{
	return (getBorderObstacleCount() > 0);
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeBorderObstacleCount(int iChange)
{
	if(iChange != 0)
	{
		m_iBorderObstacleCount = (m_iBorderObstacleCount + iChange);
		CvAssert(getBorderObstacleCount() >= 0);
	}
}

#if defined(HH_MOD_BUILDINGS_FRUITLESS_PILLAGE)
//	--------------------------------------------------------------------------------
bool CvPlayer::isBorderGainlessPillage() const
{
	return (m_iBorderGainlessPillageCount > 0);
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeBorderGainlessPillageCount(int iChange)
{
	if(iChange != 0)
	{
		m_iBorderGainlessPillageCount = m_iBorderGainlessPillageCount + iChange;
	}
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::getNetID() const
{
	return CvPreGame::netID(GetID());
}

//	--------------------------------------------------------------------------------
void CvPlayer::setNetID(int iNetID)
{
	CvPreGame::setNetID(GetID(), iNetID);
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isConnected() const
{
	return gDLL->IsPlayerConnected(GetID());
}

//	--------------------------------------------------------------------------------
void CvPlayer::sendTurnReminder()
{
	//Send a game invite to the player if they aren't currently connected to the game.
	gDLL->sendTurnReminder(GetID());

	/* email notifications not implimented.
	if(!getPbemEmailAddress().empty() &&
	        !gDLL->GetPitbossSmtpHost().empty())
	{

	}
	*/
}

//	--------------------------------------------------------------------------------
uint CvPlayer::getStartTime() const
{
	return m_uiStartTime;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setStartTime(uint uiStartTime)
{
	m_uiStartTime = uiStartTime;
}


//	--------------------------------------------------------------------------------
uint CvPlayer::getTotalTimePlayed() const
{
	return ((timeGetTime() - m_uiStartTime)/1000);
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isMinorCiv() const
{
	return CvPreGame::isMinorCiv(m_eID);
}


#if defined(MOD_API_EXTENSIONS)
//	--------------------------------------------------------------------------------
bool CvPlayer::isMajorCiv() const
{
	return GET_TEAM(getTeam()).isMajorCiv();
}
#endif


//	--------------------------------------------------------------------------------
/// Has this player betrayed a Minor Civ he was bullying by declaring war on him?
bool CvPlayer::IsHasBetrayedMinorCiv() const
{
	return m_bHasBetrayedMinorCiv;
}

//	--------------------------------------------------------------------------------
/// Sets this player to have betrayed a Minor Civ he was bullying by declaring war on him
void CvPlayer::SetHasBetrayedMinorCiv(bool bValue)
{
	if(IsHasBetrayedMinorCiv() != bValue)
	{
		m_bHasBetrayedMinorCiv = bValue;
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::setAlive(bool bNewValue, bool bNotify)
{
	CvString strBuffer;
	int iI;

	if(isAlive() != bNewValue)
	{
		m_bAlive = bNewValue;

		GET_TEAM(getTeam()).changeAliveCount((isAlive()) ? 1 : -1);

		GC.getGame().GetGameLeagues()->DoPlayerAliveStatusChanged(GetID());

		// Tell Minor Civ AI what's up so that it knows when to add/remove bonuses for players it's friends with
		if(isMinorCiv())
		{
			GetMinorCivAI()->DoChangeAliveStatus(bNewValue);
		}

		if(isAlive())
		{
			if(!isEverAlive() && !isObserver())
			{
				m_bEverAlive = true;

				GET_TEAM(getTeam()).changeEverAliveCount(1);
			}

			if(getNumCities() == 0)
			{
				setFoundedFirstCity(false);
			}

			GET_TEAM(getTeam()).SetKilledByTeam(NO_TEAM);

			if(isSimultaneousTurns() || (GC.getGame().getNumGameTurnActive() == 0) || (GC.getGame().isSimultaneousTeamTurns() && GET_TEAM(getTeam()).isTurnActive()))
			{
				setTurnActive(true);
			}

			gDLL->openSlot(GetID());
		}
		else
		{
			clearResearchQueue();
			killUnits();
			killCities();
			if(CvPreGame::isNetworkMultiplayerGame() && m_eID == GC.getGame().getActivePlayer())
				gDLL->netDisconnect();

			if (!GET_TEAM(getTeam()).isAlive())
			{
				for (int i = 0; i < MAX_TEAMS; i++)
				{
					TeamTypes eTheirTeam = (TeamTypes)i;
					if (getTeam() != eTheirTeam)
					{
						// close both embassies
						GET_TEAM(getTeam()).CloseEmbassyAtTeam(eTheirTeam);
						GET_TEAM(eTheirTeam).CloseEmbassyAtTeam(getTeam());

						// cancel any research agreements
						GET_TEAM(getTeam()).CancelResearchAgreement(eTheirTeam);
						GET_TEAM(eTheirTeam).CancelResearchAgreement(getTeam());

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
						if (MOD_DIPLOMACY_CIV4_FEATURES) {
							GET_TEAM(getTeam()).DoEndVassal(eTheirTeam, true, true);
							GET_TEAM(eTheirTeam).DoEndVassal(getTeam(), true, true);
						}
#endif
#if defined(MOD_BALANCE_CORE)
						GET_TEAM(getTeam()).setAtWar(eTheirTeam, false, false);
						GET_TEAM(eTheirTeam).setAtWar(getTeam(), false, false);
#endif
						if (GET_TEAM(getTeam()).isMinorCiv())
						{
							// Reset incoming units
							for (int iLoop = 0; iLoop < MAX_PLAYERS; iLoop++)
							{
								PlayerTypes eLoopPlayer = (PlayerTypes)iLoop; 
								if (eLoopPlayer == NO_PLAYER || !GET_PLAYER(eLoopPlayer).isMinorCiv())
									continue;

								if (GET_PLAYER(eLoopPlayer).GetMinorCivAI()->GetPermanentAlly() == GetID())
								{
									GET_PLAYER(eLoopPlayer).GetMinorCivAI()->SetPermanentAlly(NO_PLAYER);
								}
							}
						}
					}
				}
			}

			// Reset incoming units
			for(int iLoop = 0; iLoop < MAX_PLAYERS; iLoop++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes) iLoop;
				SetIncomingUnitCountdown(eLoopPlayer, -1);
				SetIncomingUnitType(eLoopPlayer, NO_UNIT);
#if defined(MOD_BALANCE_CORE)
				// forget any denouncing
				GetDiplomacyAI()->SetDenouncedPlayer(eLoopPlayer, false);
				GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetDenouncedPlayer(GetID(), false);
				GET_PLAYER(eLoopPlayer).recomputeGreatPeopleModifiers(); //if we are getting any modifiers from denouncement
#endif
			}

			GC.getGame().GetGameDeals().DoCancelAllDealsWithPlayer(GetID());

			// Reset relationships with minor civs
			for(int iPlayerLoop = MAX_MAJOR_CIVS; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
			{
				PlayerTypes eOtherPlayer = (PlayerTypes) iPlayerLoop;
				GET_PLAYER(eOtherPlayer).GetMinorCivAI()->ResetFriendshipWithMajor(GetID());
			}

			setTurnActive(false);

			gDLL->closeSlot(GetID());

			if(bNotify && !isBarbarian())
			{
				Localization::String strMessage = Localization::Lookup("TXT_KEY_MISC_CIV_DESTROYED");
				strMessage << getCivilizationAdjectiveKey();
				Localization::String strSummary = Localization::Lookup("TXT_KEY_MISC_CIV_DESTROYED_SHORT");
				strSummary << getCivilizationShortDescriptionKey();

				for(iI = 0; iI < MAX_PLAYERS; iI++)
				{
					const PlayerTypes eOtherPlayer = static_cast<PlayerTypes>(iI);
					CvPlayerAI& kOtherPlayer = GET_PLAYER(eOtherPlayer);

					if(kOtherPlayer.isAlive() && kOtherPlayer.GetNotifications())
					{
						kOtherPlayer.GetNotifications()->Add(NOTIFICATION_PLAYER_KILLED, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, -1);
					}
				}

				GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, GetID(), strMessage.toUTF8(), -1, -1);
			}

			GC.getGame().testVictory();
		}

		GC.getGame().setScoreDirty(true);
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::setBeingResurrected(bool bValue)
{
	if (m_bBeingResurrected != bValue)
	{
		m_bBeingResurrected = bValue;
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::verifyAlive()
{
	bool bKill;

	if(isAlive())
	{
		bKill = false;

		if(!bKill)
		{
			if(!isBarbarian())
			{
				if(getNumCities() == 0 && getAdvancedStartPoints() < 0)
				{
					if((getNumUnits() == 0) || (!(GC.getGame().isOption(GAMEOPTION_COMPLETE_KILLS)) && isFoundedFirstCity()))
					{
						if(!GetPlayerTraits()->IsStaysAliveZeroCities())
						{
							bKill = true;
						}
					}
				}
			}
		}

		if(!bKill)
		{
			if(!isBarbarian())
			{
				if(GC.getGame().getMaxCityElimination() > 0)
				{
					if(getCitiesLost() >= GC.getGame().getMaxCityElimination())
					{
						bKill = true;
					}
				}
			}
		}

		if(bKill)
		{
			setAlive(false, false);
		}
	}
	else
	{
		if((getNumCities() > 0) || (getNumUnits() > 0))
		{
			setAlive(true);
		}
	}
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isTurnActive() const
{
	return m_bTurnActive;
}

//	--------------------------------------------------------------------------------
void CvPlayer::setTurnActiveForPbem(bool bActive)
{
	CvAssertMsg(GC.getGame().isPbem(), "You are using setTurnActiveForPbem. Are you sure you know what you're doing?");

	// does nothing more than to set the member variable before saving the game
	// the rest of the turn will be performed upon loading the game
	// This allows the player to browse the game in paused mode after he has generated the save
	if(isTurnActive() != bActive)
	{
		m_bTurnActive = bActive;
		GC.getGame().changeNumGameTurnActive(isTurnActive() ? 1 : -1, "setTurnActiveForPlayByEmail");
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::setTurnActive(bool bNewValue, bool bDoTurn) // R: bDoTurn default is true (CvPlayer.h)
{
	//experiment for debugging. in single player mode create autosaves after the human turn for easier reproduction of observed AI problems
#if defined(VPDEBUG)
	if(!GC.getGame().isGameMultiPlayer() && isHuman() && bNewValue==false)
		gDLL->AutoSave(false, true);
#endif

	if(isTurnActive() != bNewValue)
	{
		CvGame& kGame = GC.getGame();
		CvMap& theMap = GC.getMap();
		m_bTurnActive = bNewValue; // R: this is causing the AI playing twice in one turn bug
#if defined(MOD_BUGFIX_AI_DOUBLE_TURN_MP_LOAD)
		// DN: There is a strange issue with players missing their turns after loading a game, with the AI getting two turns in a row.
		// It seems *to me* that Civ is incorrectly thinking telling us that the players have already indicated they have finished their turns
		// A hacky solution to this is to tell Civ to cancel the player turn complete state.
		// Otherwise they get their turn ended in the next call to updateMoves after the condition (!player.isEndTurn() && gDLL->HasReceivedTurnComplete(player.GetID()) && player.isHuman())
		// R: the function CancelActivePlayerEndTurn() does not help with this issue, because player.isEndTurn() == False, only gDLL->HasReceivedTurnComplete(player.GetID()) seems to catch this issue, was there a wrong gDLL->sendTurnComplete() somewhere?
		// in addition, this bug does not advance the turn count
		// also, the players do not really miss their turns, what actually happens is that the AI plays twice in one turn
		if(bNewValue)
			if(kGame.isFirstActivationOfPlayersAfterLoad())
				if(isHuman() && isAlive() && isSimultaneousTurns() && isLocalPlayer())
					if(gDLL->HasReceivedTurnComplete(GetID()))
						gDLL->sendTurnUnready();
#endif
		DLLUI->PublishEndTurnDirty();

		/////////////////////////////////////////////
		// TURN IS BEGINNING
		/////////////////////////////////////////////

		if(isTurnActive())
		{
			CvAssertMsg(isAlive(), "isAlive is expected to be true");

			setEndTurn(false);

			DoUnitAttrition();

#if defined(MOD_CORE_DELAYED_VISIBILITY)
			//force update in case one of our units was killed or moved
			for (int iI = 0; iI < theMap.numPlots(); iI++)
				theMap.plotByIndexUnchecked(iI)->flipVisibility(getTeam());
#endif

			if(kGame.getActivePlayer() == m_eID)
				theMap.updateDeferredFog();

			if((kGame.isHotSeat() || kGame.isPbem()) && isHuman() && bDoTurn)
			{
				DLLUI->clearEventMessages();

				kGame.setActivePlayer(GetID());
			}

			if(CvPreGame::isPitBoss() && kGame.getActivePlayer() != m_eID && isHuman() && gDLL->IsHost() && !isConnected())
			{//send turn reminder if the player isn't actively connected to the game.
				sendTurnReminder();
			}

			/*
			std::ostringstream infoStream;
			infoStream << "setTurnActive(true) for player ";
			infoStream << (int)GetID();	infoStream << " ";
			infoStream << getName();
			kGame.changeNumGameTurnActive(1, infoStream.str());
			infoStream << std::endl;
			if (isMajorCiv() || isBarbarian()) 
				OutputDebugString(infoStream.str().c_str());
			*/

			DLLUI->PublishPlayerTurnStatus(DLLUIClass::TURN_START, GetID());

			if(bDoTurn)
			{
				SetAllUnitsUnprocessed();

				//important! this sets the city connection flag for all our plots
				//we cannot rely on a lazy update when accessing them because we would need to do it for all players, creating overhead
				GetCityConnections()->Update();
				GetTreasury()->DoUpdateCityConnectionGold();

				if(kGame.isFinalInitialized())
				{
					if(isAlive())
					{
						if(GetDiplomacyRequests())
						{
							GetDiplomacyRequests()->BeginTurn();
						}

						//this is misleading - actual turn processing now happens in CvGame::updateMoves()
						doTurn();
						doTurnUnits();
					}
				}

				if((GetID() == kGame.getActivePlayer()) && (kGame.getElapsedGameTurns() > 0))
				{
					if(kGame.isNetworkMultiPlayer())
					{
						DLLUI->AddMessage(0, GetID(), true, GC.getEVENT_MESSAGE_TIME(), GetLocalizedText("TXT_KEY_MISC_TURN_BEGINS").GetCString(), "AS2D_NEWTURN", MESSAGE_TYPE_DISPLAY_ONLY);
					}
				}

				doWarnings();
			}

#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				if (isHuman())
				{
					// JdH: we just activated a human
					// later the AI players need to try to contact the player
					CvDiplomacyRequests::s_aDiploHumans.push_back(GetID());
				}
			}
#endif

			if(GetID() == kGame.getActivePlayer())
			{
				if(DLLUI->GetLengthSelectionList() == 0)
				{
					DLLUI->setCycleSelectionCounter(1);
				}

				DLLUI->setDirty(SelectionCamera_DIRTY_BIT, true);

				// slewis - added this so the tutorial knows when a turn begins
				DLLUI->PublishActivePlayerTurnStart();
			}
			else if(isHuman() && kGame.isGameMultiPlayer())
			{
				DLLUI->PublishRemotePlayerTurnStart();
			}
		}

		/////////////////////////////////////////////
		// TURN IS ENDING
		/////////////////////////////////////////////

		else
		{
#if defined(MOD_CORE_DELAYED_VISIBILITY)
			//visibility expires now!
			for (int iI = 0; iI < theMap.numPlots(); iI++)
				theMap.plotByIndexUnchecked(iI)->flipVisibility(getTeam());
#endif

#if defined(MOD_EVENTS_RED_TURN)
			if (MOD_EVENTS_RED_TURN)
			// RED <<<<<
			{
				ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
				if(pkScriptSystem)
				{	
					CvLuaArgsHandle args;

					args->Push(GetID());

					bool bResult;
					LuaSupport::CallHook(pkScriptSystem, "PlayerEndTurnInitiated", args.get(), bResult);
				}
			}
			// RED >>>>>
#endif
#if defined(MOD_EVENTS_PLAYER_TURN)
			if (MOD_EVENTS_PLAYER_TURN) {
				GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerDoneTurn, GetID());
			}
#endif
			CvAssertFmt(GetEndTurnBlockingType() == NO_ENDTURN_BLOCKING_TYPE, "Expecting the end-turn blocking to be NO_ENDTURN_BLOCKING_TYPE, got %d", GetEndTurnBlockingType());
			SetEndTurnBlocking(NO_ENDTURN_BLOCKING_TYPE, -1);	// Make sure this is clear so the UI doesn't block when it is not our turn.

			//important: healing and restoration of movement points
			DoUnitReset();

			if(!isHuman())
			{
				RepositionInvalidUnits();
			}

			if(GetNotifications())
			{
				GetNotifications()->EndOfTurnCleanup();
			}

			if(GetDiplomacyRequests())
			{
				GetDiplomacyRequests()->EndTurn();
			}

			if(GetID() == kGame.getActivePlayer())
			{
				DLLUI->PublishActivePlayerTurnEnd();
			}

			/*
			if (!isHuman() || (isHuman() && !isAlive()) || (isHuman() && gDLL->HasReceivedTurnAllComplete(GetID())) || kGame.getAIAutoPlay())
			{
				std::ostringstream infoStream;
				infoStream << "setTurnActive(false) for player ";
				infoStream << (int)GetID(); infoStream << " ";
				infoStream << getName();
				kGame.changeNumGameTurnActive(-1, infoStream.str());
				infoStream << std::endl;
				if (isMajorCiv() || isBarbarian()) 
					OutputDebugString(infoStream.str().c_str());
			}
			*/

#if defined(MOD_EVENTS_RED_TURN)
			if (MOD_EVENTS_RED_TURN)
			// RED <<<<<
			{
				ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
				if(pkScriptSystem)
				{	
					CvLuaArgsHandle args;

					args->Push(GetID());

					bool bResult;
					LuaSupport::CallHook(pkScriptSystem, "PlayerEndTurnCompleted", args.get(), bResult);
				}
			}
			// RED >>>>>
#endif

			DLLUI->PublishPlayerTurnStatus(DLLUIClass::TURN_END, GetID());
		}
	}
	else
	{
		CvString logOutput;
		logOutput.Format("SetTurnActive() called without changing the end turn status. Player(%i) OldTurnActive(%i) NewTurnActive(%i)", GetID(), isTurnActive(), bNewValue);
		gDLL->netMessageDebugLog(logOutput);
	}
}

//	----------------------------------------------------------------------------
bool CvPlayer::isSimultaneousTurns() const
{
	if(GC.getGame().isOption(GAMEOPTION_DYNAMIC_TURNS))
	{//in dynamic turns mode, our turn mode varies
		return m_bDynamicTurnsSimultMode;
	}
	else if(GC.getGame().isOption(GAMEOPTION_SIMULTANEOUS_TURNS))
	{
		return true;
	}

	return false;
}


//	----------------------------------------------------------------------------
void CvPlayer::setDynamicTurnsSimultMode(bool simultaneousTurns)
{
	if(simultaneousTurns != m_bDynamicTurnsSimultMode)
	{
		CvNotifications* pNotifications = GetNotifications();
		if (pNotifications)
		{
			NotificationTypes notifyType = NOTIFICATION_TURN_MODE_SEQUENTIAL;
			Localization::String localizedText = Localization::Lookup("TXT_KEY_NOTIFICATION_TURN_MODE_SEQUENTIAL");
			Localization::String localizedTextSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_TURN_MODE_SEQUENTIAL_SUMMARY");
			if(simultaneousTurns)
			{
				notifyType = NOTIFICATION_TURN_MODE_SIMULTANEOUS;
				localizedText = Localization::Lookup("TXT_KEY_NOTIFICATION_TURN_MODE_SIMULTANEOUS");
				localizedTextSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_TURN_MODE_SIMULTANEOUS_SUMMARY");
			}

			pNotifications->Add(notifyType, localizedText.toUTF8(), localizedTextSummary.toUTF8(), -1, -1, -1);
		}

		m_bDynamicTurnsSimultMode = simultaneousTurns;
	}
	
}

//	----------------------------------------------------------------------------
bool CvPlayer::isAutoMoves() const
{
	return m_bAutoMoves;
}

//	----------------------------------------------------------------------------
void CvPlayer::setAutoMoves(bool bNewValue)
{
	if(isAutoMoves() != bNewValue)
	{
		m_bAutoMoves = bNewValue;
		m_bProcessedAutoMoves = false;
	}
}

//	----------------------------------------------------------------------------
bool CvPlayer::hasProcessedAutoMoves() const
{
	return m_bProcessedAutoMoves;
}

//	----------------------------------------------------------------------------
void CvPlayer::setProcessedAutoMoves(bool bNewValue)
{
	if(hasProcessedAutoMoves() != bNewValue)
	{
		m_bProcessedAutoMoves = bNewValue;
	}
}

//	----------------------------------------------------------------------------
bool CvPlayer::isEndTurn() const
{
	return m_bEndTurn;
}

//	------------------------------------------------------------------------------------------------
void CvPlayer::setEndTurn(bool bNewValue)
{
	CvGame& game = GC.getGame();

	if(isSimultaneousTurns()
		&& bNewValue 
		&& game.isNetworkMultiPlayer() 
		&& !gDLL->HasReceivedTurnAllCompleteFromAllPlayers())
	{//When doing simultaneous turns in multiplayer, we don't want anyone to end their turn until everyone has signalled TurnAllComplete.
		// No setting end turn to true until all the players have sent the TurnComplete network message
		return;
	}

	// If this is a remote player in an MP match, don't
	// honor the end of turn request if the player still
	// has units to run the simulation for the turn
	if(!isEndTurn() && isHuman() && GetID() != game.getActivePlayer())
	{
		if(hasBusyUnitOrCity() || (!gDLL->HasReceivedTurnComplete(GetID()) && hasReadyUnit()))
		{
			return;
		}
	}
	else if(!isHuman())
	{
		if(hasBusyUnitOrCity())
		{
			return;
		}
	}

	if(isEndTurn() != bNewValue)
	{
		//  If the game isn't MP and the player has queued popups force him to deal with them first
		if(!GC.getGame().isGameMultiPlayer())
		{
			//if (GC.GetEngineUserInterface()->isPopupQueued())
			//{
			//	GC.GetEngineUserInterface()->setForcePopup(true);
			//	return;
			//}
			//if (GC.GetEngineUserInterface()->isDiploOrPopupWaiting())
			//{
			//	return;
			//}
		}

		CvAssertMsg(isTurnActive(), "isTurnActive is expected to be true");

		m_bEndTurn = bNewValue;

		if(isEndTurn())
		{
			if(!GC.getGame().isOption(GAMEOPTION_DYNAMIC_TURNS) && GC.getGame().isOption(GAMEOPTION_SIMULTANEOUS_TURNS))
			{//fully simultaneous turns only run automoves after every human has moved.
				checkRunAutoMovesForEveryone();
			}
			else
			{
				setAutoMoves(true);
			}
		}
		else
			setAutoMoves(false);
	}
	else
	{
		// This check is here for the AI.  Currently, the setEndTurn(true) never seems to get called for AI players, the automoves are just set directly
		// Why is this?  It would be great if all players were processed the same.
		if(!bNewValue && isAutoMoves())
			setAutoMoves(false);
	}
}

//	---------------------------------------------------------------------------
void CvPlayer::checkRunAutoMovesForEveryone()
{
	bool runAutoMovesForEveryone = true;
	int i = 0;
	for(i = 0; i < MAX_PLAYERS; ++i)
	{
		CvPlayer& p = CvPlayerAI::getPlayer((PlayerTypes)i);
		if(p.isHuman() && !p.isObserver() 
			// Check to see if this human player hasn't gotten to the end turn phase of their turn.  
			// This gets tricky because hot joiners can hop into an ai civ that already finished their turn.
			// When this occurs, the hot joiner will not be turn active, will have already run their automoves,
			// and not have end turn set. (AIs do not set end turn) *sigh*
			// To handle that case, we assume that human players who are not endturn and turn inactive after TurnAllComplete
			// are ready for the human automoves phase.
			&& (!p.isEndTurn()
			&& (!gDLL->HasReceivedTurnAllCompleteFromAllPlayers() || p.isTurnActive()))) 
		{
			runAutoMovesForEveryone = false;
			break;
		}
	}

	if(runAutoMovesForEveryone)
	{
		for(i = 0; i < MAX_PLAYERS; ++i)
		{
			CvPlayer& p = CvPlayerAI::getPlayer((PlayerTypes)i);
			if(p.isHuman())
			{
				p.setAutoMoves(true);
			}
		}
	}
}

//	---------------------------------------------------------------------------
EndTurnBlockingTypes CvPlayer::GetEndTurnBlockingType(void) const
{
	return m_eEndTurnBlockingType;
}

//	---------------------------------------------------------------------------
int CvPlayer::GetEndTurnBlockingNotificationIndex(void) const
{
	return m_iEndTurnBlockingNotificationIndex;
}

//	---------------------------------------------------------------------------
void CvPlayer::SetEndTurnBlocking(EndTurnBlockingTypes eBlockingType, int iNotificationIndex)
{
	bool bFireEvent = false;
	if(m_eEndTurnBlockingType != eBlockingType || m_iEndTurnBlockingNotificationIndex != iNotificationIndex)
	{
		bFireEvent = true;
	}

	EndTurnBlockingTypes ePrevBlockingType = m_eEndTurnBlockingType;
	m_eEndTurnBlockingType = eBlockingType;
	m_iEndTurnBlockingNotificationIndex = iNotificationIndex;

	if(bFireEvent)
	{
		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->SetEndTurnBlockingChanged( ePrevBlockingType, m_eEndTurnBlockingType );
			GC.GetEngineUserInterface()->UpdateEndTurn();
		}
	}
}

//	---------------------------------------------------------------------------
bool CvPlayer::isTurnDone() const
{
	// if this returns true, popups and diplomacy will wait to appear until next turn
	if(!GC.getGame().isPbem() && !GC.getGame().isHotSeat())
	{
		return false;
	}
	if(!isHuman())
	{
		return true;
	}
	if(!isEndTurn())
	{
		return false;
	}
	return (!isAutoMoves());
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isExtendedGame() const
{
	return m_bExtendedGame;
}


//	--------------------------------------------------------------------------------
void CvPlayer::makeExtendedGame()
{
	m_bExtendedGame = true;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isFoundedFirstCity() const
{
	return m_bFoundedFirstCity;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setFoundedFirstCity(bool bNewValue)
{
	if(isFoundedFirstCity() != bNewValue)
	{
		m_bFoundedFirstCity = bNewValue;

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(PercentButtons_DIRTY_BIT, true);
			GC.GetEngineUserInterface()->setDirty(ResearchButtons_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumCitiesFounded() const
{
	return m_iNumCitiesFounded;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumCitiesFounded(int iValue)
{
	m_iNumCitiesFounded += iValue;
}

//	--------------------------------------------------------------------------------
// check to see if we defeated this other player
void CvPlayer::CheckForMurder(PlayerTypes ePossibleVictimPlayer)
{
	// Cache whether the player is human or not.  If the player is killed, the CvPreGame::slotStatus is changed to SS_CLOSED
	// but the slot status is used to determine if the player is human or not, so it looks like it is an AI!
	// This should be fixed, but might have unforeseen ramifications so...
	CvPlayer& kPossibleVictimPlayer = GET_PLAYER(ePossibleVictimPlayer);
	bool bPossibleVictimIsHuman = kPossibleVictimPlayer.isHuman();

	// This may 'kill' the player if it is deemed that he does not have the proper units to stay alive
	kPossibleVictimPlayer.verifyAlive();

	// You... you killed him!
	if(!kPossibleVictimPlayer.isAlive())
	{
		GET_TEAM(kPossibleVictimPlayer.getTeam()).SetKilledByTeam(getTeam());
		kPossibleVictimPlayer.SetEverConqueredBy(m_eID, true);

		// Leader pops up and whines
		if(!CvPreGame::isNetworkMultiplayerGame())		// Not in MP
		{
			if(!bPossibleVictimIsHuman && !kPossibleVictimPlayer.isMinorCiv() && !kPossibleVictimPlayer.isBarbarian())
				kPossibleVictimPlayer.GetDiplomacyAI()->DoKilledByPlayer(GetID());
		}

		// do post-dying clean up
		if (!kPossibleVictimPlayer.isMinorCiv())
		{
			for (uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
			{
				PlayerTypes eCleanupPlayer = (PlayerTypes)ui;
				GET_PLAYER(eCleanupPlayer).GetDiplomacyAI()->KilledPlayerCleanup(kPossibleVictimPlayer.GetID());
				
				// Apply a backstabbing mark to the players on the team that killed us (in case we're ever resurrected)
				if (!bPossibleVictimIsHuman && GET_PLAYER(eCleanupPlayer).getTeam() == getTeam())
				{
					kPossibleVictimPlayer.GetDiplomacyAI()->SetEverBackstabbedBy(eCleanupPlayer, true);
				}
			}
		}
		
#if defined(MOD_BALANCE_CORE_HAPPINESS)
		if (MOD_BALANCE_CORE_HAPPINESS && kPossibleVictimPlayer.isMajorCiv())
		{
			kPossibleVictimPlayer.GetCulture()->SetWarWeariness(0);
		}
#endif
		
#if defined(MOD_BALANCE_CORE)
		DoWarVictoryBonuses();
#endif
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isStrike() const
{
	return m_bStrike;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setStrike(bool bNewValue)
{
	if(m_bStrike != bNewValue)
	{
		m_bStrike = bNewValue;

		if(m_bStrike)
		{
			if(GetID() == GC.getGame().getActivePlayer())
			{
				GC.GetEngineUserInterface()->AddMessage(0, GetID(), false, GC.getEVENT_MESSAGE_TIME(), GetLocalizedText("TXT_KEY_MISC_UNITS_ON_STRIKE").GetCString(), "AS2D_STRIKE", MESSAGE_TYPE_MINOR_EVENT, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_WARNING_TEXT"));

				GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
			}
		}
	}
}


//	--------------------------------------------------------------------------------
/// Is the player is cramped in his current area?
bool CvPlayer::IsCramped() const
{
	return m_bCramped;
}

//	--------------------------------------------------------------------------------
/// Determines if the player is cramped in his current area.  Not a perfect algorithm, as it will double-count Plots shared by different Cities, but it should be good enough
void CvPlayer::DoUpdateCramped()
{
	m_bCramped = false;

	int iTotalPlotsNearby = 0;
	int iUsablePlotsNearby = 0;

	int iRange = GC.getCRAMPED_RANGE_FROM_CITY();

	int iLoop;
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		for(int iX = -iRange; iX <= iRange; iX++)
		{
			for(int iY = -iRange; iY <= iRange; iY++)
			{
				CvPlot* pPlot = plotXYWithRangeCheck(pLoopCity->getX(), pLoopCity->getY(), iX, iY, iRange);
				if(pPlot != NULL)
				{
					// Plot not owned by me
					if(!pPlot->isOwned() || pPlot->getOwner() != GetID())
					{
						iTotalPlotsNearby++;

						// A "good" unowned Plot
						if(!pPlot->isOwned() && pPlot->isValidMovePlot(GetID()) && !pPlot->isWater())
						{
							iUsablePlotsNearby++;
						}
					}
				}
			}
		}
	}

	if (iTotalPlotsNearby > 0 && (100 * iUsablePlotsNearby) / iTotalPlotsNearby <= GC.getCRAMPED_USABLE_PLOT_PERCENT()) //20
		m_bCramped = true;
}

//	--------------------------------------------------------------------------------
const CvHandicapInfo& CvPlayer::getHandicapInfo() const
{
	static CvHandicapInfo emptyResult;

	CvHandicapInfo* pkHandicapInfo = GC.getHandicapInfo(getHandicapType());
	if (pkHandicapInfo == NULL)
	{
		const char* szError = "ERROR: Player does not contain valid handicap!!";
		GC.LogMessage(szError);
		CvAssertMsg(false, szError);

		return emptyResult;
	}
	else
		return *pkHandicapInfo;
}

//	--------------------------------------------------------------------------------
HandicapTypes CvPlayer::getHandicapType() const
{
	return CvPreGame::handicap(GetID());
}

//	--------------------------------------------------------------------------------
const CvCivilizationInfo& CvPlayer::getCivilizationInfo() const
{
	static CvCivilizationInfo emptyResult;

	CvCivilizationInfo* pkCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
	if(pkCivilizationInfo == NULL)
	{
		const char* szError = "ERROR: Player does not contain valid civilization type!!";
		GC.LogMessage(szError);
		CvAssertMsg(false, szError);

		return emptyResult;
	}
	else
		return *pkCivilizationInfo;
}

//	--------------------------------------------------------------------------------
CivilizationTypes CvPlayer::getCivilizationType() const
{
	return CvPreGame::civilization(GetID());
}


//	--------------------------------------------------------------------------------
const CvLeaderHeadInfo& CvPlayer::getLeaderInfo() const
{
	static CvLeaderHeadInfo emptyResult;

	CvLeaderHeadInfo* pkLeaderInfo = GC.getLeaderHeadInfo(getLeaderType());
	if(pkLeaderInfo == NULL)
	{
		const char* szError = "ERROR: Player does not contain valid leader type!!";
		GC.LogMessage(szError);
		CvAssertMsg(false, szError);

		return emptyResult;
	}
	else
		return *pkLeaderInfo;
}

//	--------------------------------------------------------------------------------
LeaderHeadTypes CvPlayer::getLeaderType() const
{
	return CvPreGame::leaderHead(GetID());
}
#if defined(MOD_API_EXTENSIONS)
//	--------------------------------------------------------------------------------
void CvPlayer::setLeaderType(LeaderHeadTypes eNewLeader)
{
    if (isMajorCiv())
	{
		LeaderHeadTypes eOldLeader = getLeaderType();
		
		// Set the new leader type
		CvPreGame::setLeaderHead(GetID(), eNewLeader);
	
		// Update the player's personality
		setPersonalityType(eNewLeader);
	
		// Update the player's traits (Leader_Traits)
		GetPlayerTraits()->Reset();
		GetPlayerTraits()->InitPlayerTraits();
		recomputePolicyCostModifier();
		
		if (!isHuman()) {
			// Update the player's biases (Leader_MajorCivApproachBiases)
			// Nothing to do as they are not cached in CvPlayer
	
			// Update the player's flavours (Leader_Flavors)
			GetFlavorManager()->ChangeLeader(eOldLeader, eNewLeader);
			
			// Update the player's strategies
			// Nothing to do as these will auto-update based on the new flavours at the end of the player's turn
		}
	}
}
#endif

//	--------------------------------------------------------------------------------
LeaderHeadTypes CvPlayer::getPersonalityType() const
{
	return m_ePersonalityType;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setPersonalityType(LeaderHeadTypes eNewValue)
{
	m_ePersonalityType = eNewValue;
}


//	--------------------------------------------------------------------------------
EraTypes CvPlayer::GetCurrentEra() const
{
	return GET_TEAM(getTeam()).GetCurrentEra();
}

//	--------------------------------------------------------------------------------
void CvPlayer::setTeam(TeamTypes eTeam)
{
	CvAssert(eTeam != NO_TEAM);
	CvAssert(getTeam() != NO_TEAM);

	GET_TEAM(getTeam()).changeNumMembers(-1);
	if(isAlive())
	{
		GET_TEAM(getTeam()).changeAliveCount(-1);
	}
	if(isEverAlive())
	{
		GET_TEAM(getTeam()).changeEverAliveCount(-1);
	}
	GET_TEAM(getTeam()).changeNumCities(-(getNumCities()));
	GET_TEAM(getTeam()).changeTotalPopulation(-(getTotalPopulation()));
	GET_TEAM(getTeam()).changeTotalLand(-(getTotalLand()));

#if defined(MOD_BALANCE_CORE)
	GET_TEAM(getTeam()).removePlayer(GetID());
#endif

	CvPreGame::setTeamType(GetID(), eTeam);

#if defined(MOD_BALANCE_CORE)
	if (GET_TEAM(getTeam()).addPlayer(GetID()))
		GET_TEAM(getTeam()).changeNumMembers(1);
#else
	GET_TEAM(getTeam()).changeNumMembers(1);
#endif

	if(isAlive())
	{
		GET_TEAM(getTeam()).changeAliveCount(1);
	}
	if(isEverAlive())
	{
		GET_TEAM(getTeam()).changeEverAliveCount(1);
	}
	GET_TEAM(getTeam()).changeNumCities(getNumCities());
	GET_TEAM(getTeam()).changeTotalPopulation(getTotalPopulation());
	GET_TEAM(getTeam()).changeTotalLand(getTotalLand());
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsAITeammateOfHuman() const
{
	bool bRtnValue = false;

#if defined(MOD_BALANCE_CORE)
	const std::vector<PlayerTypes>& teammates = GET_TEAM(getTeam()).getPlayers();
	for (size_t i = 0; i < teammates.size(); ++i)
	{
		CvPlayer& player = GET_PLAYER(teammates[i]);
#else
	for(int i = 0; i < MAX_PLAYERS; ++i)
	{
		CvPlayer& player = GET_PLAYER(static_cast<PlayerTypes>(i));
#endif
		if (player.isHuman() && player.isAlive())
		{
			if(player.getTeam() == getTeam())
			{
				bRtnValue = true;
				break;
			}
		}
	}

	return bRtnValue;
}

//	--------------------------------------------------------------------------------
PlayerColorTypes CvPlayer::getPlayerColor() const
{
	return CvPreGame::playerColor(GetID());
}

//	--------------------------------------------------------------------------------
const CvColorA& CvPlayer::getPlayerTextColor() const
{
	CvAssertMsg(getPlayerColor() != NO_PLAYERCOLOR, "getPlayerColor() is not expected to be equal with NO_PLAYERCOLOR");
	CvPlayerColorInfo* pkPlayerColorInfo = GC.GetPlayerColorInfo(getPlayerColor());
	CvColorInfo* pkColorInfo = NULL;
	if(pkPlayerColorInfo)
	{
		ColorTypes eTextColor = static_cast<ColorTypes>(pkPlayerColorInfo->GetColorTypeText());
		pkColorInfo = GC.GetColorInfo(eTextColor);
		if(pkColorInfo)
			return pkColorInfo->GetColor();
	}

	//Default to black text if no color exists.
	static CvColorA black(0,0,0,1.0f);
	return black;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getSeaPlotYield(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiSeaPlotYield[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeSeaPlotYield(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiSeaPlotYield.setAt(eIndex, m_aiSeaPlotYield[eIndex] + iChange);

		updateYield();
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getYieldRateModifier(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldRateModifier[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldRateModifier(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldRateModifier.setAt(eIndex, m_aiYieldRateModifier[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
#if defined(MOD_BALANCE_CORE_POLICIES)
int CvPlayer::GetApproachScratchValue(PlayerTypes ePlayer, MajorCivApproachTypes eMajorCivApproach) const
{
	CvAssertMsg(ePlayer >= 0, "ePlayer expected to be >= 0");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer expected to be < MAX_MAJOR_CIVS");
	CvAssertMsg(eMajorCivApproach >= 0, "eMajorCivApproach expected to be >= 0");
	CvAssertMsg(eMajorCivApproach < NUM_MAJOR_CIV_APPROACHES, "eMajorCivApproach expected to be < NUM_MAJOR_CIV_APPROACHES");
	return  m_ppiApproachScratchValue[ePlayer][eMajorCivApproach];
}
void CvPlayer::SetApproachScratchValue(PlayerTypes ePlayer, MajorCivApproachTypes eMajorCivApproach, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "ePlayer expected to be >= 0");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer expected to be < MAX_MAJOR_CIVS");
	CvAssertMsg(eMajorCivApproach >= 0, "eMajorCivApproach expected to be >= 0");
	CvAssertMsg(eMajorCivApproach < NUM_MAJOR_CIV_APPROACHES, "eMajorCivApproach expected to be < NUM_MAJOR_CIV_APPROACHES");

	if(iValue != 0)
	{
		m_ppiApproachScratchValue[ePlayer][eMajorCivApproach] = iValue;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetTradeReligionModifier() const
{
	return m_iTradeReligionModifier;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeTradeReligionModifier(int iChange)
{
	m_iTradeReligionModifier += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromBirth(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldFromBirth[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromBirth(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldFromBirth.setAt(eIndex, m_aiYieldFromBirth[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromBirthCapital(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldFromBirthCapital[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromBirthCapital(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldFromBirthCapital.setAt(eIndex, m_aiYieldFromBirthCapital[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromDeath(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldFromDeath[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromDeath(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldFromDeath.setAt(eIndex, m_aiYieldFromDeath[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

int CvPlayer::GetYieldFromPillage(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromPillage[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangeYieldFromPillage(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiYieldFromPillage.setAt(eIndex, m_aiYieldFromPillage[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

int CvPlayer::GetYieldFromVictory(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
		CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromVictory[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangeYieldFromVictory(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiYieldFromVictory.setAt(eIndex, m_aiYieldFromVictory[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromConstruction(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldFromConstruction[eIndex];
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromConstruction(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldFromConstruction.setAt(eIndex, m_aiYieldFromConstruction[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromwonderConstruction(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldFromwonderConstruction[eIndex];
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromwonderConstruction(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiYieldFromwonderConstruction.setAt(eIndex, m_aiYieldFromwonderConstruction[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromTech(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldFromTech[eIndex];
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromTech(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldFromTech.setAt(eIndex, m_aiYieldFromTech[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromBorderGrowth(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldFromBorderGrowth[eIndex];
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromBorderGrowth(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldFromBorderGrowth.setAt(eIndex, m_aiYieldFromBorderGrowth[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::getYieldGPExpend(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldGPExpend[eIndex];
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldGPExpend(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldGPExpend.setAt(eIndex, m_aiYieldGPExpend[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::getConquerorYield(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiConquerorYield[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeConquerorYield(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiConquerorYield.setAt(eIndex, m_aiConquerorYield[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::getFounderYield(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiFounderYield[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeFounderYield(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiFounderYield.setAt(eIndex, m_aiFounderYield[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getArtifactYieldBonus(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiArtifactYieldBonus[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeArtifactYieldBonus(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiArtifactYieldBonus.setAt(eIndex, m_aiArtifactYieldBonus[eIndex] + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getArtYieldBonus(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiArtYieldBonus[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeArtYieldBonus(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiArtYieldBonus.setAt(eIndex, m_aiArtYieldBonus[eIndex] + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getMusicYieldBonus(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiMusicYieldBonus[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeMusicYieldBonus(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiMusicYieldBonus.setAt(eIndex, m_aiMusicYieldBonus[eIndex] + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getLitYieldBonus(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiLitYieldBonus[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeLitYieldBonus(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiLitYieldBonus.setAt(eIndex, m_aiLitYieldBonus[eIndex] + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getFilmYieldBonus(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiFilmYieldBonus[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeFilmYieldBonus(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiFilmYieldBonus.setAt(eIndex, m_aiFilmYieldBonus[eIndex] + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getRelicYieldBonus(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiRelicYieldBonus[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeRelicYieldBonus(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiRelicYieldBonus.setAt(eIndex, m_aiRelicYieldBonus[eIndex] + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGoldenAgeYieldMod(YieldTypes eIndex)	const
{
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiGoldenAgeYieldMod[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeGoldenAgeYieldMod(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiGoldenAgeYieldMod.setAt(eIndex, m_aiGoldenAgeYieldMod[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromNonSpecialistCitizens(YieldTypes eIndex)	const
{
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromNonSpecialistCitizens[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromNonSpecialistCitizens(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiYieldFromNonSpecialistCitizens.setAt(eIndex, m_aiYieldFromNonSpecialistCitizens[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getYieldModifierFromGreatWorks(YieldTypes eIndex)	const
{
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldModifierFromGreatWorks[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldModifierFromGreatWorks(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiYieldModifierFromGreatWorks.setAt(eIndex, m_aiYieldModifierFromGreatWorks[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getYieldModifierFromActiveSpies(YieldTypes eIndex)	const
{
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldModifierFromActiveSpies[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldModifierFromActiveSpies(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiYieldModifierFromActiveSpies.setAt(eIndex, m_aiYieldModifierFromActiveSpies[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromDelegateCount(YieldTypes eIndex)	const
{
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromDelegateCount[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromDelegateCount(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiYieldFromDelegateCount.setAt(eIndex, m_aiYieldFromDelegateCount[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getReligionYieldRateModifier(YieldTypes eIndex)	const
{
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiReligionYieldRateModifier[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeReligionYieldRateModifier(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiReligionYieldRateModifier.setAt(eIndex, m_aiReligionYieldRateModifier[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetGarrisonsOccupiedUnhapppinessMod() const
{
	return m_iGarrisonsOccupiedUnhapppinessMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGarrisonsOccupiedUnhapppinessMod(int iChange)
{
	m_iGarrisonsOccupiedUnhapppinessMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetXPopulationConscription() const
{
	return m_iXPopulationConscription;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeXPopulationConscription(int iChange)
{
	m_iXPopulationConscription += iChange;
}
void CvPlayer::DoXPopulationConscription(CvCity* pCity)
{
	UnitTypes eBestUnit = NO_UNIT;
	int iStrengthBest = 0;
	// Loop through adding the available units
	for (int iUnitLoop = 0; iUnitLoop < GC.getNumUnitInfos(); iUnitLoop++)
	{
		UnitTypes eLoopUnit = (UnitTypes)iUnitLoop;
		if (eLoopUnit != NO_UNIT)
		{
			CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eLoopUnit);
			if (pkUnitEntry)
			{
				if (!pCity->canTrain(eLoopUnit))
				{
					continue;
				}

				if (pkUnitEntry->GetCombat() <= 0 && pkUnitEntry->GetRangedCombat() <= 0)
					continue;

				if (pkUnitEntry->GetDefaultUnitAIType() == UNITAI_EXPLORE)
					continue;

				if (pkUnitEntry->GetDomainType() == DOMAIN_SEA)
				{
					int iChance = GC.getGame().getSmallFakeRandNum(10, pCity->plot()->GetPlotIndex() + getTotalPopulation());
					if (iChance < 5)
					{
						continue;
					}
				}
				bool bBad = false;
				ResourceTypes eResource;
				for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
				{
					eResource = (ResourceTypes)iResourceLoop;
					int iNumResource = pkUnitEntry->GetResourceQuantityRequirement(eResource);
					if (iNumResource > 0)
					{
						bBad = true;
						break;
					}
					if (pkUnitEntry->GetResourceType() == eResource)
					{
						bBad = true;
						break;
					}
				}

				if (bBad)
				{
					continue;
				}

				int iCombatStrength = (pkUnitEntry->GetPower() + GC.getGame().getSmallFakeRandNum(pkUnitEntry->GetPower(), pCity->plot()->GetPlotIndex() + getTotalPopulation()));
				if (pkUnitEntry->GetRange() > 0)
				{
					iCombatStrength *= 50;
					iCombatStrength /= 100;
				}

				if (iCombatStrength <= 0)
					iCombatStrength = 1;
				
				if (iCombatStrength > iStrengthBest)
				{
					iStrengthBest = iCombatStrength;
					eBestUnit = eLoopUnit;
				}
			}
		}
	}
	if (eBestUnit != NO_UNIT)
	{
		CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eBestUnit);
		if (pkUnitEntry)
		{
			UnitAITypes eUnitAI = pkUnitEntry->GetDefaultUnitAIType();
			int iResult = pCity->CreateUnit(eBestUnit, eUnitAI, REASON_GIFT);
			CvAssertMsg(iResult != -1, "Unable to create unit");

			if (iResult != -1)
			{
				CvUnit* pUnit = getUnit(iResult);
				changeNumUnitsSupplyFree(1);
				pUnit->changeNoSupply(1);
				PromotionTypes ePromotionConscript = (PromotionTypes)GC.getInfoTypeForString("PROMOTION_CONSCRIPT");
				if (ePromotionConscript != NO_PROMOTION)
					pUnit->setHasPromotion(ePromotionConscript, true);

				if (!pUnit->jumpToNearestValidPlot())
				{
					pUnit->kill(false);	// Could not find a valid spot!
				}
				else
				{
					pUnit->finishMoves();
					pUnit->SetTurnProcessed(true);
					CvNotifications* pNotifications = GetNotifications();
					if (pUnit && pNotifications)
					{
						Localization::String localizedText = Localization::Lookup("TXT_KEY_NOTIFICATION_CONSCRIPTION_SPAWN");
						localizedText << pCity->getNameKey() << pCity->getPopulation() << pUnit->getNameKey();
						Localization::String localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CONSCRIPTION_SPAWN_SUMMARY");
						localizedSummary << getNameKey() << pUnit->getNameKey();
						pNotifications->Add(NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER, localizedText.toUTF8(), localizedSummary.toUTF8(), pUnit->getX(), pUnit->getY(), eBestUnit);
					}
					if (GC.getLogging() && GC.getAILogging())
					{
						CvString strLogString;
						strLogString.Format("Conscripted %s spawned at %s. Population: %d", pUnit->getName().GetCString(), pCity->getName().GetCString(), pCity->getPopulation());
						GetHomelandAI()->LogHomelandMessage(strLogString);
					}
				}
			}
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetExtraMoves() const
{
	return m_iExtraMoves;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeExtraMoves(int iChange)
{
	m_iExtraMoves += iChange;
}
//	--------------------------------------------------------------------------------
bool CvPlayer::IsNoUnhappinessExpansion() const
{
	return GetNoUnhappinessExpansion() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNoUnhappinessExpansion() const
{
	return m_iNoUnhappinessExpansion;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNoUnhappinessExpansion(int iChange)
{
	if(iChange != 0)
	{
		m_iNoUnhappinessExpansion += iChange;
	}
}
//	--------------------------------------------------------------------------------
bool CvPlayer::IsNoUnhappyIsolation() const
{
	return GetNoUnhappyIsolation() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNoUnhappyIsolation() const
{
	return m_iNoUnhappyIsolation;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNoUnhappyIsolation(int iChange)
{
	if(iChange != 0)
	{
		m_iNoUnhappyIsolation += iChange;
	}
}
//	--------------------------------------------------------------------------------
bool CvPlayer::IsDoubleBorderGA() const
{
	return GetDoubleBorderGA() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetDoubleBorderGA() const
{
	return m_iDoubleBorderGA;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeDoubleBorderGA(int iChange)
{
	if(iChange != 0)
	{
		m_iDoubleBorderGA += iChange;
	}
}
//Increased influence from CS quests
//	--------------------------------------------------------------------------------
bool CvPlayer::IsIncreasedQuestInfluence() const
{
	return GetIncreasedQuestInfluence() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetIncreasedQuestInfluence() const
{
	return m_iIncreasedQuestInfluence;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeIncreasedQuestInfluence(int iChange)
{
	if(iChange != 0)
	{
		m_iIncreasedQuestInfluence += iChange;
	}
}
//Citadel Boost
//	--------------------------------------------------------------------------------
bool CvPlayer::IsCultureBombBoost() const
{
	return GetCultureBombBoost() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetCultureBombBoost() const
{
	return m_iCultureBombBoost;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeCultureBombBoost(int iChange)
{
	if(iChange != 0)
	{
		m_iCultureBombBoost += iChange;
	}
}

//Puppet Prod Boost
//	--------------------------------------------------------------------------------
bool CvPlayer::IsPuppetProdMod() const
{
	return GetPuppetProdMod() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetPuppetProdMod() const
{
	return m_iPuppetProdMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changePuppetProdMod(int iChange)
{
	if(iChange != 0)
	{
		m_iPuppetProdMod += iChange;
	}
}

//Occupied Prod Boost
//	--------------------------------------------------------------------------------
bool CvPlayer::IsOccupiedProdMod() const
{
	return GetOccupiedProdMod() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetOccupiedProdMod() const
{
	return m_iOccupiedProdMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeOccupiedProdMod(int iChange)
{
	if(iChange != 0)
	{
		m_iOccupiedProdMod += iChange;
	}
}

//Free Gold from Internal Trade Routes
//	--------------------------------------------------------------------------------
bool CvPlayer::IsGoldInternalTrade() const
{
	return GetGoldInternalTrade() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetGoldInternalTrade() const
{
	return m_iGoldInternalTrade;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGoldInternalTrade(int iChange)
{
	if(iChange != 0)
	{
		m_iGoldInternalTrade += iChange;
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetFreeWCVotes() const
{
	return m_iFreeWCVotes;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeFreeWCVotes(int iChange)
{
	m_iFreeWCVotes += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetInfluenceGPExpend() const
{
	return m_iInfluenceGPExpend;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeInfluenceGPExpend(int iChange)
{
	m_iInfluenceGPExpend += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetFreeTradeRoute() const
{
	return m_iFreeTradeRoute;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeFreeTradeRoute(int iChange)
{
	m_iFreeTradeRoute += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetFreeSpy() const
{
	return m_iFreeSpy;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeFreeSpy(int iChange)
{
	m_iFreeSpy += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetReligionDistance() const
{
	return m_iReligionDistance;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeReligionDistance(int iChange)
{
	m_iReligionDistance += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetPressureMod() const
{
	return m_iPressureMod;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changePressureMod(int iChange)
{
	m_iPressureMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetCityStateCombatModifier() const
{
	return m_iCityStateCombatModifier;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeCityStateCombatModifier(int iChange)
{
	m_iCityStateCombatModifier += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getBuildingClassCultureChange(BuildingClassTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiBuildingClassCulture[eIndex];
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeBuildingClassCultureChange(BuildingClassTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	m_paiBuildingClassCulture.setAt(eIndex, m_paiBuildingClassCulture[eIndex] + iChange);
	CvAssert(getBuildingClassCultureChange(eIndex) >= 0);
}
#endif
#if defined(MOD_BALANCE_CORE_SPIES)
bool CvPlayer::IsAdvancedActionsEnabled() const
{
	return m_bAdvancedActionsEnabled;
}
void CvPlayer::SetAdvancedActionsEnabled(bool bValue)
{
	if (m_bAdvancedActionsEnabled != bValue)
		m_bAdvancedActionsEnabled = bValue;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetAdvancedActionGold() const
{
	return m_iAdvancedActionGold;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeAdvancedActionGold(int iChange)
{
	m_iAdvancedActionGold += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::setAdvancedActionGold(int iChange)
{
	m_iAdvancedActionGold = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetAdvancedActionScience() const
{
	return m_iAdvancedActionScience;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeAdvancedActionScience(int iChange)
{
	m_iAdvancedActionScience += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::setAdvancedActionScience(int iChange)
{
	m_iAdvancedActionScience = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetAdvancedActionUnrest() const
{
	return m_iAdvancedActionUnrest;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeAdvancedActionUnrest(int iChange)
{
	m_iAdvancedActionUnrest += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::setAdvancedActionUnrest(int iChange)
{
	m_iAdvancedActionUnrest = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetAdvancedActionRebellion() const
{
	return m_iAdvancedActionRebellion;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeAdvancedActionRebellion(int iChange)
{
	m_iAdvancedActionRebellion += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::setAdvancedActionRebellion(int iChange)
{
	m_iAdvancedActionRebellion = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetAdvancedActionGP() const
{
	return m_iAdvancedActionGP;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeAdvancedActionGP(int iChange)
{
	m_iAdvancedActionGP += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::setAdvancedActionGP(int iChange)
{
	m_iAdvancedActionGP = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetAdvancedActionUnit() const
{
	return m_iAdvancedActionUnit;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeAdvancedActionUnit(int iChange)
{
	m_iAdvancedActionUnit += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::setAdvancedActionUnit(int iChange)
{
	m_iAdvancedActionUnit = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetAdvancedActionWonder() const
{
	return m_iAdvancedActionWonder;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeAdvancedActionWonder(int iChange)
{
	m_iAdvancedActionWonder += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::setAdvancedActionWonder(int iChange)
{
	m_iAdvancedActionWonder = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetAdvancedActionBuilding() const
{
	return m_iAdvancedActionBuilding;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeAdvancedActionBuilding(int iChange)
{
	m_iAdvancedActionBuilding += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::setAdvancedActionBuilding(int iChange)
{
	m_iAdvancedActionBuilding = iChange;
}
//	--------------------------------------------------------------------------------
bool CvPlayer::IsCannotFailSpies() const
{
	return GetCannotFailSpies() > 0;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetCannotFailSpies() const
{
	return m_iCannotFailSpies;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeCannotFailSpies(int iChange)
{
	m_iCannotFailSpies += iChange;
}

void CvPlayer::changeMaxAirUnits(int iChange)
{
	if (iChange != 0)
	{
		m_iMaxAirUnits += iChange;
	}
}
int CvPlayer::getMaxAirUnits() const
{
	return m_iMaxAirUnits;
}

//	--------------------------------------------------------------------------------
/// Extra yield for a improvement this city is working?
int CvPlayer::GetImprovementExtraYield(ImprovementTypes eImprovement, YieldTypes eYield) const
{
	CvAssertMsg(eImprovement >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eImprovement < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eYield >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiImprovementYieldChange[eImprovement][eYield];
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeImprovementExtraYield(ImprovementTypes eImprovement, YieldTypes eYield, int iChange)
{
	CvAssertMsg(eImprovement >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eImprovement < GC.getNumImprovementInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eYield >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiImprovementYieldChange[eImprovement];
		yields[eYield] = (m_ppiImprovementYieldChange[eImprovement][eYield] + iChange);
		m_ppiImprovementYieldChange[eImprovement] = yields;
		CvAssert(GetImprovementExtraYield(eImprovement, eYield) >= 0);

		updateYield();
	}
}
#endif
#if defined(MOD_BALANCE_CORE_BUILDING_INVESTMENTS)
//	--------------------------------------------------------------------------------
int CvPlayer::GetInvestmentModifier() const
{
	return m_iInvestmentModifier;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeInvestmentModifier(int iChange)
{
	m_iInvestmentModifier += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetMissionInfluenceModifier() const
{
	return m_iMissionInfluenceModifier;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeMissionInfluenceModifier(int iChange)
{
	m_iMissionInfluenceModifier += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetHappinessPerActiveTradeRoute() const
{
	return m_iHappinessPerActiveTradeRoute;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeHappinessPerActiveTradeRoute(int iChange)
{
	m_iHappinessPerActiveTradeRoute += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNeedsModifierFromAirUnits() const
{
	return m_iNeedsModifierFromAirUnits;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeNeedsModifierFromAirUnits(int iChange)
{
	m_iNeedsModifierFromAirUnits += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetFlatDefenseFromAirUnits() const
{
	return m_iFlatDefenseFromAirUnits;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeFlatDefenseFromAirUnits(int iChange)
{
	if (iChange != 0)
	{
		m_iFlatDefenseFromAirUnits += iChange;

		CvCity* pLoopCity;

		int iLoop;
		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			pLoopCity->updateStrengthValue();
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetPuppetYieldPenaltyMod() const
{
	return m_iPuppetYieldPenaltyMod;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changePuppetYieldPenaltyMod(int iChange)
{
	m_iPuppetYieldPenaltyMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetConquestPerEraBuildingProductionMod() const
{
	return m_iConquestPerEraBuildingProductionMod;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeConquestPerEraBuildingProductionMod(int iChange)
{
	m_iConquestPerEraBuildingProductionMod += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetAdmiralLuxuryBonus() const
{
	return m_iAdmiralLuxuryBonus;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeAdmiralLuxuryBonus(int iChange)
{
	m_iAdmiralLuxuryBonus += iChange;
}



//	--------------------------------------------------------------------------------
bool CvPlayer::IsCSResourcesCountMonopolies() const
{
	return (m_iCSResourcesCountMonopolies > 0);
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeCSResourcesCountMonopolies(int iChange)
{
	m_iCSResourcesCountMonopolies += iChange;
}


int CvPlayer::GetScalingNationalPopulationRequrired(BuildingTypes eBuilding) const
{
	if(eBuilding != NO_BUILDING)
	{
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
		if(pkBuildingInfo)
		{
			int iNationalPop = pkBuildingInfo->GetNationalPopulationRequired();
			if(iNationalPop > 0)
			{
				int iScaler = (getNumCities() * pkBuildingInfo->GetNumCityCostMod());
				iNationalPop *= (100 + iScaler);
				iNationalPop /= 100;

				int iModifier = 100 - GetPlayerTraits()->GetNationalPopReqModifier();

				//If OCC... 1/2 the value
				if (GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE))
					iModifier -= 50;

				iNationalPop *= iModifier;
				iNationalPop /= 100;
				
				return max(0, iNationalPop);
			}
		}
	}
	return 0;
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::getCapitalYieldRateModifier(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiCapitalYieldRateModifier[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeCapitalYieldRateModifier(YieldTypes eIndex, int iChange)
{
	CvCity* pCapitalCity;

	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiCapitalYieldRateModifier.setAt(eIndex, m_aiCapitalYieldRateModifier[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		pCapitalCity = getCapitalCity();
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getExtraYieldThreshold(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiExtraYieldThreshold[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::updateExtraYieldThreshold(YieldTypes eIndex)
{
	int iBestValue;

	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	iBestValue = GetPlayerTraits()->GetExtraYieldThreshold(eIndex);

	if(getExtraYieldThreshold(eIndex) != iBestValue)
	{
		m_aiExtraYieldThreshold.setAt(eIndex, iBestValue);
		CvAssert(getExtraYieldThreshold(eIndex) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetScience() const
{
	return GetScienceTimes100() / 100;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetScienceTimes100() const
{
	// If we're in anarchy, then no Research is done!
	if(IsAnarchy())
		return 0;

	int iValue = 0;

	// Science from our Cities
	iValue += GetScienceFromCitiesTimes100(false);

#if defined(MOD_API_UNIFIED_YIELDS)
	// Science from religion
	iValue += GetYieldPerTurnFromReligion(YIELD_SCIENCE) * 100;
#endif

#if defined(MOD_API_UNIFIED_YIELDS)
	// Trait bonus which adds Science for trade partners? 
	iValue += GetYieldPerTurnFromTraits(YIELD_SCIENCE) * 100;
#endif

	// Science from other players!
#if defined(MOD_BALANCE_CORE)
	if (!isMinorCiv())
		//avoid pointless recursion
		iValue += GetScienceFromOtherPlayersTimes100();
#else
	iValue += GetScienceFromOtherPlayersTimes100();
#endif

	// Happiness converted to Science? (Policies, etc.)
	iValue += GetScienceFromHappinessTimes100();

	// Research Agreement bonuses
	iValue += GetScienceFromResearchAgreementsTimes100();

	// If we have a negative Treasury + GPT then it gets removed from Science
	iValue += GetScienceFromBudgetDeficitTimes100();

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (MOD_DIPLOMACY_CIV4_FEATURES) {
		// We're a vassal of someone, we get x% of his science
		iValue += (GetYieldPerTurnFromVassals(YIELD_SCIENCE) * 100);
	}

	if (MOD_BALANCE_CORE_JFD)
	{
		iValue += GetYieldPerTurnFromMinors(YIELD_FAITH) * 100;
	}
#endif
#if defined(MOD_BALANCE_CORE)
	if(MOD_BALANCE_CORE_MINOR_CIV_GIFT)
	{
		iValue += GetSciencePerTurnFromMinorCivs() * 100;
	}
#endif
#if defined(MOD_DIPLOMACY_CITYSTATES)
	if (MOD_DIPLOMACY_CITYSTATES) {
		//Science Funding Rate Boost
		if(IsLeagueAid())
		{
			int iFreeScience = GetScienceFromCitiesTimes100(false) * GetScienceRateFromLeagueAid();
			iFreeScience /= 100;

			iValue += iFreeScience;
		}
	}
#endif
	return max(iValue, 0);
}

//	--------------------------------------------------------------------------------
/// Where is our Science coming from?
int CvPlayer::GetScienceFromCitiesTimes100(bool bIgnoreTrade) const
{
	int iScience = 0;

	const CvCity* pLoopCity;

	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iScience += pLoopCity->getYieldRateTimes100(YIELD_SCIENCE, bIgnoreTrade);
	}

	return iScience;
}

//	--------------------------------------------------------------------------------
/// Where is our Science coming from?
int CvPlayer::GetScienceFromOtherPlayersTimes100() const
{
	int iScience = 0;

	PlayerTypes ePlayer;
	int iScienceFromPlayer;
	for(int iPlayerLoop = MAX_MAJOR_CIVS; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		ePlayer = (PlayerTypes) iPlayerLoop;

		iScienceFromPlayer = 0;

		if(IsGetsScienceFromPlayer(ePlayer))
		{
			iScienceFromPlayer = GET_PLAYER(ePlayer).GetMinorCivAI()->GetScienceFriendshipBonusTimes100();

			iScience += iScienceFromPlayer;
		}
	}
	return iScience;
}

//	--------------------------------------------------------------------------------
/// Where is our Science coming from?
int CvPlayer::GetScienceFromHappinessTimes100() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS))
	{
		return 0;
	}
	if (MOD_BALANCE_CORE_HAPPINESS)
		return 0;

	int iScience = 0;

	if(getHappinessToScience() != 0)
	{
		if(GetExcessHappiness() >= 0)
		{
			int iFreeScience = GetScienceFromCitiesTimes100(false) * getHappinessToScience();
			iFreeScience /= 100;

			iScience += iFreeScience;
		}
	}

	return iScience;
}

//	--------------------------------------------------------------------------------
/// Where is our Science coming from?
int CvPlayer::GetScienceFromResearchAgreementsTimes100() const
{
	int iScience = GetScienceFromCitiesTimes100(false);

	int iResearchAgreementBonus = /*0*/ GC.getRESEARCH_AGREEMENT_MOD() * GET_TEAM(getTeam()).GetTotalNumResearchAgreements(); // RAs currently do not have this effect
	iScience *= iResearchAgreementBonus;	// Apply to the % to the current value
	iScience /= 100;

	return iScience;
}

//	--------------------------------------------------------------------------------
/// Where is our Science coming from?
int CvPlayer::GetScienceFromBudgetDeficitTimes100() const
{
	int iScience = 0;
	int iGoldPerTurn = calculateGoldRateTimes100();
	if(GetTreasury()->GetGoldTimes100() + iGoldPerTurn < 0)
	{
		iScience += (GetTreasury()->GetGoldTimes100() + iGoldPerTurn);
	}

	return iScience;
}

//	--------------------------------------------------------------------------------
/// What is the sum of science yield (not counting Research Agreements or Great Scientist bonuses) from the previous N turns?
/// NOTE: This uses the data tracked in recording a replay, so if replays are disabled in the future then this must change!
int CvPlayer::GetScienceYieldFromPreviousTurns(int iGameTurn, int iNumPreviousTurnsToCount)
{
	// Beakers per turn yield is tracked in replay data, so use that
	int iSum = 0;
	for (int iI = 1; iI < iNumPreviousTurnsToCount; iI++)
	{
		int iTurn = iGameTurn - iI;
		if (iTurn < 0)
		{
			break;
		}

		int iTurnScience = getReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_SCIENCEPERTURN"), iTurn);
		if (iTurnScience >= 0)
		{
			iSum += iTurnScience;
		}
		else if (iTurnScience == -1) // No data for this turn (ex. late era start)
		{
			iSum += (3 * GetScience());
		}
	}

	return iSum;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsGetsScienceFromPlayer(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= MAX_MAJOR_CIVS, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");

	// Might have global modifier
	if(IsMinorScienceAllies() && GET_PLAYER(ePlayer).GetMinorCivAI()->IsAllies(GetID()))
	{
		return true;
	}

	return m_pabGetsScienceFromPlayer[ePlayer];
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetGetsScienceFromPlayer(PlayerTypes ePlayer, bool bNewValue)
{
	CvAssertMsg(ePlayer >= MAX_MAJOR_CIVS, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(bNewValue != m_pabGetsScienceFromPlayer[ePlayer])
	{
		m_pabGetsScienceFromPlayer.setAt(ePlayer, bNewValue);
	}
}

//	--------------------------------------------------------------------------------
/// Player spending too much cash?
void CvPlayer::DoDeficit()
{
	if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_PlayerCanDisband, GetID()) == GAMEEVENTRETURN_FALSE) {
		return;
	}

	int iNumMilitaryUnits = 0;

	CvUnit* pLoopUnit;
	int iLoop;
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->IsCombatUnit())
			iNumMilitaryUnits++;
	}

	// If the player has more units than cities, start disbanding things
#if defined(MOD_BALANCE_CORE)
	if(isBarbarian())
	{
		return;
	}
	int iMax = isMinorCiv() ? ((GetCurrentEra() + 4) * getNumCities()) : max(10, getNumCities());
	if(iNumMilitaryUnits >= iMax)
#else
	if(iNumMilitaryUnits > getNumCities())
#endif
	{
		int iRand = GC.getGame().getSmallFakeRandNum(100, GetPseudoRandomSeed());
		if (iRand < 50)
		{
			CvUnit* pLandUnit = NULL;
			CvUnit* pNavalUnit = NULL;
			int iLandScore = MAX_INT;
			int iNavalScore = MAX_INT;

			// Look for obsolete land units if in deficit or have sufficient units
			//if(GetMilitaryAI()->GetLandDefenseState() <= DEFENSE_STATE_NEUTRAL)
			if (iRand <= 25)
			{
				pLandUnit = GetMilitaryAI()->FindBestUnitToScrap(true /*bLand*/, true /*bDeficitForcedDisband*/, iLandScore);
			}

			// Look for obsolete naval units if in deficit or have sufficient units
			//if(GetMilitaryAI()->GetNavalDefenseState() <= DEFENSE_STATE_NEUTRAL)
			else
			{
				pNavalUnit = GetMilitaryAI()->FindBestUnitToScrap(false/*bNaval*/, true /*bDeficitForcedDisband*/, iNavalScore);
			}

			if(iLandScore < MAX_INT && (GetMilitaryAI()->GetLandDefenseState() <= GetMilitaryAI()->GetNavalDefenseState() || iLandScore <= iNavalScore))
			{
				if(pLandUnit)
				{
					CvNotifications* pNotifications = GetNotifications();
					if(pNotifications)
					{
						Localization::String locString = Localization::Lookup("TXT_KEY_NTFN_UNIT_DISBANDED");
						Localization::String locSummary = Localization::Lookup("TXT_KEY_NTFN_UNIT_DISBANDED_S");
						pNotifications->Add(NOTIFICATION_UNIT_DIED, locString.toUTF8(), locSummary.toUTF8(), pLandUnit->getX(), pLandUnit->getY(), pLandUnit->getUnitType(), GetID());
					}

					pLandUnit->scrap();
					GetMilitaryAI()->LogDeficitScrapUnit(pLandUnit);
				}
			}
			else if(iNavalScore < MAX_INT)
			{
				if(pNavalUnit)
				{
					CvNotifications* pNotifications = GetNotifications();
					if(pNotifications)
					{
						Localization::String locString = Localization::Lookup("TXT_KEY_NTFN_UNIT_DISBANDED");
						Localization::String locSummary = Localization::Lookup("TXT_KEY_NTFN_UNIT_DISBANDED_S");
						pNotifications->Add(NOTIFICATION_UNIT_DIED, locString.toUTF8(), locSummary.toUTF8(), pNavalUnit->getX(), pNavalUnit->getY(), pNavalUnit->getUnitType(), GetID());
					}

					pNavalUnit->scrap();
					GetMilitaryAI()->LogDeficitScrapUnit(pNavalUnit);
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getSpecialistExtraYield(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiSpecialistExtraYield[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeSpecialistExtraYield(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		// Have to handle Specialists yield update manually here because the "updateYield()" below only accounts for land Yield!

		CvCity* pLoopCity;
		int iLoop;
		int iNumTotalSpecialists = 0;

		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			for(int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
			{
				iNumTotalSpecialists = pLoopCity->GetCityCitizens()->GetSpecialistCount((SpecialistTypes) iSpecialistLoop);
//				iNumTotalSpecialists = pLoopCity->getSpecialistCount((SpecialistTypes) iSpecialistLoop) + pLoopCity->getFreeSpecialistCount((SpecialistTypes) iSpecialistLoop);

				for(int iTempLoop = 0; iTempLoop < iNumTotalSpecialists; iTempLoop++)
				{
					pLoopCity->processSpecialist((SpecialistTypes) iSpecialistLoop, -1);
				}
			}
		}

		m_aiSpecialistExtraYield.setAt(eIndex ,m_aiSpecialistExtraYield[eIndex] + iChange);
		CvAssert(getSpecialistExtraYield(eIndex) >= 0);

		updateYield();

		// Reprocess Specialist AFTER yield change
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			for(int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
			{
				iNumTotalSpecialists = pLoopCity->GetCityCitizens()->GetSpecialistCount((SpecialistTypes) iSpecialistLoop);
//				iNumTotalSpecialists = pLoopCity->getSpecialistCount((SpecialistTypes) iSpecialistLoop) + pLoopCity->getFreeSpecialistCount((SpecialistTypes) iSpecialistLoop);

				for(int iTempLoop = 0; iTempLoop < iNumTotalSpecialists; iTempLoop++)
				{
					pLoopCity->processSpecialist((SpecialistTypes) iSpecialistLoop, 1);
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Returns how "close" we are to another player (useful for diplomacy, war planning, etc.)
PlayerProximityTypes CvPlayer::GetProximityToPlayer(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePlayer < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
	return (PlayerProximityTypes) m_aiProximityToPlayer[ePlayer];
}

//	--------------------------------------------------------------------------------
/// Sets how "close" we are to another player (useful for diplomacy, war planning, etc.)
void CvPlayer::SetProximityToPlayer(PlayerTypes ePlayer, PlayerProximityTypes eProximity)
{
	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePlayer < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");

	CvAssertMsg(GetID() != ePlayer, "Trying to calculate proximity to oneself. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	CvAssertMsg(eProximity >= NO_PLAYER_PROXIMITY, "eIndex is expected to be non-negative (invalid Index)");	// NO_PLAYER_PROXIMITY is valid because some players may have no Cities (e.g. on the first turn)
	CvAssertMsg(eProximity < NUM_PLAYER_PROXIMITIES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if((GC.getLogging() && GC.getAILogging()))
	{
		if(eProximity != m_aiProximityToPlayer[ePlayer])
		{
			// Open the log file
			CvString strFileName = "PlayerProximityLog.csv";
			FILogFile* pLog;
			pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
			CvString strLog, strTemp;

			CvString strPlayerName;
			strPlayerName = getCivilizationShortDescription();
			strLog += strPlayerName;
			strLog += ",";

			strTemp.Format("%d,", GC.getGame().getGameTurn()); // turn
			strLog += strTemp;
			CvString strOtherPlayerName;
			strOtherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
			strLog += strOtherPlayerName;
			strLog += ",";

			switch(m_aiProximityToPlayer[ePlayer])
			{
			case NO_PLAYER_PROXIMITY:
				strLog += "No player proximity,";
				break;
			case PLAYER_PROXIMITY_NEIGHBORS:
				strLog += "Neighbors,";
				break;
			case PLAYER_PROXIMITY_CLOSE:
				strLog += "Close,";
				break;
			case PLAYER_PROXIMITY_FAR:
				strLog += "Far,";
				break;
			case PLAYER_PROXIMITY_DISTANT:
				strLog += "Distant,";
				break;
			}

			strLog += "-->,";

			switch(eProximity)
			{
			case NO_PLAYER_PROXIMITY:
				strLog += "No player proximity,";
				break;
			case PLAYER_PROXIMITY_NEIGHBORS:
				strLog += "Neighbors,";
				break;
			case PLAYER_PROXIMITY_CLOSE:
				strLog += "Close,";
				break;
			case PLAYER_PROXIMITY_FAR:
				strLog += "Far,";
				break;
			case PLAYER_PROXIMITY_DISTANT:
				strLog += "Distant,";
				break;
			}

			pLog->Msg(strLog);
		}
	}

	m_aiProximityToPlayer.setAt(ePlayer, eProximity);
}

//	--------------------------------------------------------------------------------
/// Figure out how "close" we are to another player (useful for diplomacy, war planning, etc.)
void CvPlayer::DoUpdateProximityToPlayer(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePlayer < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");

	//the current pair for comparison
	pair<int, int> closestCities = GetDiplomacyAI()->GetClosestCityPair(ePlayer);
	if (closestCities.first < 0 || closestCities.second < 0)
	{
		SetProximityToPlayer(ePlayer, NO_PLAYER_PROXIMITY);
		return;
	}

	//default
	PlayerProximityTypes eProximity = PLAYER_PROXIMITY_DISTANT;

	//can't embark? non-continent members are distant.
	if (!GET_TEAM(getTeam()).canEmbark())
	{
		CvPlot* pA = GC.getMap().plotByIndex(closestCities.first);
		CvPlot* pB = GC.getMap().plotByIndex(closestCities.second);
		if (pA->getArea() != pB->getArea())
		{
			SetProximityToPlayer(ePlayer, PLAYER_PROXIMITY_DISTANT);
			return;
		}
	}

	// Closest Cities must be within a certain range
	int iDistance = plotDistance(closestCities.first,closestCities.second);
	if(iDistance < /*6*/ GC.getPROXIMITY_NEIGHBORS_CLOSEST_CITY_REQUIREMENT())
	{
		eProximity = PLAYER_PROXIMITY_NEIGHBORS;
	}
	// If our closest Cities are pretty near one another and our average is less than the max then we can be considered CLOSE
	else if(iDistance < /*12*/ GC.getPROXIMITY_CLOSE_CLOSEST_CITY_POSSIBILITY())
	{
		eProximity = PLAYER_PROXIMITY_CLOSE;
	}
	// If our closest Cities are far away from one another and our average is less than the max then we can be considered FAR
	else if(iDistance < /*18*/ GC.getPROXIMITY_FAR_DISTANCE_MAX())
	{
		eProximity = PLAYER_PROXIMITY_FAR;
	}

	//can embark, but not oceanic? non-continent members are one pip less.
	if (GET_TEAM(getTeam()).canEmbark() && !GET_TEAM(getTeam()).canEmbarkAllWaterPassage())
	{
		CvPlot* pA = GC.getMap().plotByIndex(closestCities.first);
		CvPlot* pB = GC.getMap().plotByIndex(closestCities.second);
		if (pA->getArea() != pB->getArea())
		{
			if (eProximity == PLAYER_PROXIMITY_FAR)
				eProximity = PLAYER_PROXIMITY_DISTANT;
			else if (eProximity == PLAYER_PROXIMITY_CLOSE)
				eProximity = PLAYER_PROXIMITY_FAR;
			else if (eProximity == PLAYER_PROXIMITY_NEIGHBORS)
				eProximity = PLAYER_PROXIMITY_CLOSE;
		}
	}

	SetProximityToPlayer(ePlayer, eProximity);
}

//	--------------------------------------------------------------------------------
/// Update the beakers accumulated during the term of RAs
void CvPlayer::UpdateResearchAgreements(int iValue)
{
	PlayerTypes ePlayerLoop;
	TeamTypes eTeamLoop;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		ePlayerLoop = (PlayerTypes) iPlayerLoop;
		eTeamLoop = GET_PLAYER(ePlayerLoop).getTeam();
		if(ePlayerLoop == GetID())
			continue;
		if(eTeamLoop == getTeam())
			continue;

		if(GET_TEAM(getTeam()).IsHasResearchAgreement(eTeamLoop))
		{
			// Note that this increases the counter for all players on the other team,
			// even though the RA was only made with one of them.  This is because
			// RAs, though made with players, are restricted and tracked by 1 per team.
			// This must change if future implementations allow for multiple RAs to be
			// made with a particular team.
			ChangeResearchAgreementCounter(ePlayerLoop, iValue);
		}
		else if(GetResearchAgreementCounter(ePlayerLoop) != 0)
		{
			SetResearchAgreementCounter(ePlayerLoop, 0);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Get the beakers accumulated during the RA with a player
int CvPlayer::GetResearchAgreementCounter(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePlayer < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiResearchAgreementCounter[ePlayer];
}

//	--------------------------------------------------------------------------------
/// Set the beakers accumulated during the RA with a player
void CvPlayer::SetResearchAgreementCounter(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePlayer < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");

	CvAssertMsg(GetID() != ePlayer, "Trying to make a RA Agreement with oneself. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_aiResearchAgreementCounter.setAt(ePlayer, iValue);
}

//	--------------------------------------------------------------------------------
/// Change the beakers accumulated during the RA with a player
void CvPlayer::ChangeResearchAgreementCounter(PlayerTypes ePlayer, int iChange)
{
	SetResearchAgreementCounter(ePlayer, GetResearchAgreementCounter(ePlayer) + iChange);
}

//	--------------------------------------------------------------------------------
/// Someone sent us a present!
void CvPlayer::DoCivilianReturnLogic(bool bReturn, PlayerTypes eToPlayer, int iUnitID)
{
	CvUnit* pUnit = getUnit(iUnitID);
	if(!pUnit)
	{
		return;
	}

	CvPlot* pPlot = pUnit->plot();
	if(!pPlot)
	{
		return;
	}

	// Kill any units this guy is transporting
	IDInfo* pUnitNode = pPlot->headUnitNode();
	while(pUnitNode != NULL)
	{
		CvUnit* pLoopUnit = ::getUnit(*pUnitNode);
		pUnitNode = pPlot->nextUnitNode(pUnitNode);

		if(NULL != pLoopUnit && pLoopUnit->getTransportUnit() == pUnit)
			pLoopUnit->kill(true);
	}

	// What are the details for the new unit?
	UnitTypes eNewUnitType = pUnit->getUnitType();

	if(!bReturn)
		eNewUnitType = pUnit->getCaptureUnitType(getCivilizationType());

	int iX = pUnit->getX();
	int iY = pUnit->getY();

	// Returns to the previous owner
	if(bReturn)
	{
		pUnit->kill(true);
		CvUnit* pNewUnit = GET_PLAYER(eToPlayer).initUnit(eNewUnitType, iX, iY);
		CvAssert(pNewUnit != NULL);
		if (pNewUnit)
		{
			if (!pNewUnit->jumpToNearestValidPlot())
				pNewUnit->kill(false);	// Could not find a spot!
		}

		// Returned to a city-state
		if(GET_PLAYER(eToPlayer).isMinorCiv())
		{
			int iInfluence = /*45*/ GC.getRETURN_CIVILIAN_FRIENDSHIP();
			GET_PLAYER(eToPlayer).GetMinorCivAI()->ChangeFriendshipWithMajor(GetID(), iInfluence);
		}
		// Returned to major power
		else if(!GET_PLAYER(eToPlayer).isHuman())
		{
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
			// Additional diplo bonus for returning civilians in the early game, especially Settlers
			int iTheirEra = GET_PLAYER(eToPlayer).GetCurrentEra();
			if (iTheirEra <= 1)
			{
				if (pNewUnit->isFound())
				{
					if (iTheirEra == 0)
					{
						GET_PLAYER(eToPlayer).GetDiplomacyAI()->ChangeNumCiviliansReturnedToMe(GetID(), 5);
					}
					else if (iTheirEra == 1)
					{
						GET_PLAYER(eToPlayer).GetDiplomacyAI()->ChangeNumCiviliansReturnedToMe(GetID(), 4);
					}
				}
				else
				{
					if (iTheirEra == 0)
					{
						GET_PLAYER(eToPlayer).GetDiplomacyAI()->ChangeNumCiviliansReturnedToMe(GetID(), 3);
					}
					else if (iTheirEra == 1)
					{
						GET_PLAYER(eToPlayer).GetDiplomacyAI()->ChangeNumCiviliansReturnedToMe(GetID(), 2);
					}
				}
			}
			else
			{
#endif
				GET_PLAYER(eToPlayer).GetDiplomacyAI()->ChangeNumCiviliansReturnedToMe(GetID(), 1);
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
			}
#endif
		}
#if defined(MOD_BALANCE_CORE)
		else if(GET_PLAYER(eToPlayer).isHuman() && pNewUnit)
		{
			CvNotifications* pNotification = GET_PLAYER(eToPlayer).GetNotifications();
			if(pNotification)
			{
				Localization::String localizedText = Localization::Lookup("TXT_KEY_NOTIFICATION_UNIT_RETURNED_AI");
				localizedText << getNameKey() << pNewUnit->getUnitInfo().GetTextKey();
				Localization::String localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_UNIT_RETURNED_AI_SUMMARY");
				localizedSummary << getNameKey() << pNewUnit->getUnitInfo().GetTextKey();
				pNotification->Add(NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER, localizedText.toUTF8(), localizedSummary.toUTF8(), pNewUnit->getX(), pNewUnit->getY(), pNewUnit->getUnitType());
			}
		}
#endif
	}
	// Kept for oneself
	else
	{
		// Make a new unit because the kind we should capture doesn't match (e.g. Settler to Worker)
		if(eNewUnitType != pUnit->getUnitType())
		{
#if defined(MOD_GLOBAL_GRATEFUL_SETTLERS)
			// In OCC games, all captured settlers are converted
			if ((pUnit->isFound() || pUnit->IsFoundAbroad()) && MOD_GLOBAL_GRATEFUL_SETTLERS && !(GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && isHuman())) {
				int iDefectProb = gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_PERCENT", 20);
				int iPercent = 0;

				// Approach is very important
				switch (GetDiplomacyAI()->GetMajorCivApproach(eToPlayer, false)) {
					case MAJOR_CIV_APPROACH_WAR:
						iPercent = iDefectProb * gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_WAR_MULTIPLIER", 0) / gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DIVISOR", 8);
						break;
					case MAJOR_CIV_APPROACH_HOSTILE:
						iPercent = iDefectProb * gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_HOSTILE_MULTIPLIER", 2) / gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DIVISOR", 8);
						break;
					case MAJOR_CIV_APPROACH_GUARDED:
						iPercent = iDefectProb * gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_GUARDED_MULTIPLIER", 4) / gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DIVISOR", 8);
						break;
					case MAJOR_CIV_APPROACH_DECEPTIVE:
						iPercent = iDefectProb * gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DECEPTIVE_MULTIPLIER", 4) / gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DIVISOR", 8);
						break;
					case MAJOR_CIV_APPROACH_AFRAID:
						iPercent = iDefectProb * gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_AFRAID_MULTIPLIER", 4) / gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DIVISOR", 8);
						break;
					case MAJOR_CIV_APPROACH_NEUTRAL:
						iPercent = iDefectProb * gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_NEUTRAL_MULTIPLIER", 6) / gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DIVISOR", 8);
						break;
					case MAJOR_CIV_APPROACH_FRIENDLY:
						iPercent = iDefectProb * gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_FRIENDLY_MULTIPLIER", 10) / gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DIVISOR", 8);
						break;
					default:
						break;
				}

				// Opinion also matters
				switch (GetDiplomacyAI()->GetMajorCivOpinion(eToPlayer)) {
					case MAJOR_CIV_OPINION_ALLY:
						iPercent += iDefectProb * 5 / 4;
						break;
					case MAJOR_CIV_OPINION_FRIEND:
						iPercent += iDefectProb * 1;
						break;
					case MAJOR_CIV_OPINION_FAVORABLE:
						iPercent += iDefectProb * 3 / 4;
						break;
					case MAJOR_CIV_OPINION_NEUTRAL:
						iPercent += iDefectProb * 1 / 2;
						break;
					case MAJOR_CIV_OPINION_COMPETITOR:
						iPercent += iDefectProb * 0;
						break;
					case MAJOR_CIV_OPINION_ENEMY:
						iPercent += iDefectProb * -1;
						break;
					case MAJOR_CIV_OPINION_UNFORGIVABLE:
						iPercent += iDefectProb * -1;
						break;
					default:
						break;
				}

				// Limit the outcome
				iPercent = std::min(50, std::max(5, iPercent));

				// Our masters sent us into a war-zone, we'll stick where we are!
				if (GetDiplomacyAI()->GetNumOurEnemiesPlayerAtWarWith(eToPlayer) > 0) {
					iPercent *= 2;
				}

				// If they will found the second city (ie kudos) multiply by 1.5
				if (getNumCities() == 1) {
					iPercent *= 3;
					iPercent /= 2;
				}

#if defined(MOD_GLOBAL_RELIGIOUS_SETTLERS)
				if (MOD_GLOBAL_RELIGIOUS_SETTLERS) {
					ReligionTypes eReligion = pUnit->GetReligionData()->GetReligion();

					if (eReligion > RELIGION_PANTHEON) {
						const CvReligion* pkReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, NO_PLAYER);

						if (pkReligion) {
							CvPlot* pPlot = GC.getMap().plot(pkReligion->m_iHolyCityX, pkReligion->m_iHolyCityY);

							if (pPlot) {
								CvCity* pHolyCity = pPlot->getPlotCity();

								if (pHolyCity->getOriginalOwner() == GetID()) {
									// Bonus if the liberator founded their holy city
									iPercent += gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_HOLYCITY_FOUNDER", 20);
								} else if (pHolyCity->getOwner() == GetID()) {
									// Serious bad karma if the liberator has captured their holy city
									iPercent += gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_HOLYCITY_OCCUPIER", -20);
								}
							}
						}
					}
				}
#endif

				// Limit the outcome
				iPercent = std::min(80, iPercent);
				
				// Use the popularity difference between the players to skew the probability
				int iSmileRatio = (GetExcessHappiness() * 100) / (std::max(0, GET_PLAYER(eToPlayer).GetExcessHappiness()) + 10);
				iPercent = iPercent * std::min(150, std::max(75, iSmileRatio)) / 100;
				CUSTOMLOG("Settler defect percent: %i (Approach=%i, Opinion=%i)", iPercent, GetDiplomacyAI()->GetMajorCivApproach(eToPlayer, false), GetDiplomacyAI()->GetMajorCivOpinion(eToPlayer));

				if (GC.getGame().getSmallFakeRandNum(100, GetPseudoRandomSeed()) < iPercent) {
					if (GC.getGame().getActivePlayer() == GetID()) {
						CvPopupInfo kPopupInfo(BUTTONPOPUP_TEXT);
						strcpy_s(kPopupInfo.szText, "TXT_KEY_GRATEFUL_SETTLERS");
						GC.GetEngineUserInterface()->AddPopup(kPopupInfo);
					}
				} else {
					pUnit->kill(true);
					CvUnit* pNewUnit = initUnit(eNewUnitType, iX, iY);
					CvAssert(pNewUnit != NULL);
					if (pNewUnit)
						pNewUnit->finishMoves();
				}
			} else {
#endif
				pUnit->kill(true);
				CvUnit* pNewUnit = initUnit(eNewUnitType, iX, iY);
				CvAssert(pNewUnit != NULL);
				if (pNewUnit)
					pNewUnit->finishMoves();
#if defined(MOD_GLOBAL_GRATEFUL_SETTLERS)
			}
#endif
		}
	}
}
#if defined(MOD_BALANCE_CORE)
void CvPlayer::DoTradeInfluenceAP()
{
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();
	int iOwner = GetID();
	if(GetPlayerTraits()->IsTradeRouteMinorInfluenceAdmiralPoints())
	{
		for (uint ui = 0; ui < pTrade->GetNumTradeConnections(); ui++)
		{
			if (pTrade->IsTradeRouteIndexEmpty(ui))
			{
				continue;
			}

			const TradeConnection* pConnection = &(pTrade->GetTradeConnection(ui));

			if (pConnection->m_eOriginOwner == iOwner && pConnection->m_eDestOwner != iOwner)
			{
				bool bMinorCiv = GET_PLAYER(pConnection->m_eDestOwner).isMinorCiv();
				if(bMinorCiv)
				{
					int iInfluence = GC.getGame().getGameSpeedInfo().getGoldGiftMod() / 100;
					if (pConnection->m_eDomain == DOMAIN_LAND)
					{
						GET_PLAYER(pConnection->m_eDestOwner).GetMinorCivAI()->ChangeFriendshipWithMajor((PlayerTypes)iOwner, iInfluence);
						changeNavalCombatExperienceTimes100(iInfluence * 100);
					}
					else if (pConnection->m_eDomain == DOMAIN_SEA)
					{
						iInfluence *= 2;
						GET_PLAYER(pConnection->m_eDestOwner).GetMinorCivAI()->ChangeFriendshipWithMajor((PlayerTypes)iOwner, iInfluence);
						changeNavalCombatExperienceTimes100(iInfluence * 100);
					}
				}
			}
		}
	}
}
#endif
//	--------------------------------------------------------------------------------
/// Units in the ether coming towards us?
void CvPlayer::DoIncomingUnits()
{
	AI_PERF_FORMAT("AI-perf.csv", ("CvPlayer::DoIncomingUnits, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), getCivilizationShortDescription()) );
	for(int iLoop = 0; iLoop < MAX_PLAYERS; iLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iLoop;
		CvAssertMsg(GetIncomingUnitCountdown(eLoopPlayer) >= -1, "Incoming Unit countdown is an invalid value. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
		if(GetIncomingUnitCountdown(eLoopPlayer) > 0)
		{
			ChangeIncomingUnitCountdown(eLoopPlayer, -1);

			// Time to spawn a new unit
			if(GetIncomingUnitCountdown(eLoopPlayer) == 0)
			{
				// Must have capital to actually spawn unit
				CvCity* pCapital = getCapitalCity();
				if(pCapital)
				{
					CvUnit* pNewUnit = initUnit(GetIncomingUnitType(eLoopPlayer), pCapital->getX(), pCapital->getY());
					CvAssert(pNewUnit);
					if (pNewUnit)
					{
						if(pNewUnit->getDomainType() != DOMAIN_AIR)
						{
							if (!pNewUnit->jumpToNearestValidPlot())
								pNewUnit->kill(false);
						}

						// Gift from a major to a city-state
						if (isMinorCiv() && !GET_PLAYER(eLoopPlayer).isMinorCiv())
						{
							GetMinorCivAI()->DoUnitGiftFromMajor(eLoopPlayer, pNewUnit, /*bDistanceGift*/ true);
						}
					}
				}

				// Reset stuff
				SetIncomingUnitCountdown(eLoopPlayer, -1);
				SetIncomingUnitType(eLoopPlayer, NO_UNIT);
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Someone sent us a present!
void CvPlayer::DoDistanceGift(PlayerTypes eFromPlayer, CvUnit* pUnit)
{
	if(!pUnit)
	{
		return;
	}

	CvPlot* pPlot = pUnit->plot();
	if(!pPlot)
	{
		return;
	}

	// Also add any units this guy is transporting
	IDInfo* pUnitNode = pPlot->headUnitNode();
	while(pUnitNode != NULL)
	{
		CvUnit* pLoopUnit = ::getUnit(*pUnitNode);
		pUnitNode = pPlot->nextUnitNode(pUnitNode);

		if(NULL != pLoopUnit && pLoopUnit->getTransportUnit() == pUnit)
			AddIncomingUnit(eFromPlayer, pLoopUnit);
	}

	AddIncomingUnit(eFromPlayer, pUnit);
}
bool CvPlayer::CanGiftUnit(PlayerTypes eToPlayer)
{
	if (GET_PLAYER(eToPlayer).isMinorCiv())
	{
		if (GET_PLAYER(eToPlayer).GetIncomingUnitCountdown(GetID()) != -1)
		{
			return false;
		}

		int iNum = GET_PLAYER(eToPlayer).GetNumUnitsToSupply();
		int iMax = max(3, ((GET_PLAYER(eToPlayer).GetCurrentEra() + 2) * GET_PLAYER(eToPlayer).getNumCities()));

		if (iNum >= iMax)
			return false;

		return true;
	}
	return false;
}
//	--------------------------------------------------------------------------------
/// Someone sent us a present!
void CvPlayer::AddIncomingUnit(PlayerTypes eFromPlayer, CvUnit* pUnit)
{
	UnitTypes eUnitType = pUnit->getUnitType();

	// Gift to a minor civ for friendship
	if(isMinorCiv() && eFromPlayer < MAX_MAJOR_CIVS)
	{
		CvAssertMsg(GetIncomingUnitType(eFromPlayer) == NO_UNIT, "Adding incoming unit when one is already on its way. Please send Anton your save file and version.");
		CvAssertMsg(GetIncomingUnitCountdown(eFromPlayer) == -1, "Adding incoming unit when one is already on its way. Please send Anton your save file and version.");
		if(GetIncomingUnitCountdown(eFromPlayer) == -1)
		{
			SetIncomingUnitCountdown(eFromPlayer, GC.getMINOR_UNIT_GIFT_TRAVEL_TURNS());
			SetIncomingUnitType(eFromPlayer, eUnitType);
		}

		// Get rid of the old unit
		pUnit->kill(true);
	}
	// Gift from minor civ to this major civ (ex. Austria UA, but NOT Militaristic unit spawning, that is handled elsewhere)
	else if(!isMinorCiv() && GET_PLAYER(eFromPlayer).isMinorCiv())
	{
		int iX = pUnit->getX();
		int iY = pUnit->getY();
		UnitTypes eType = pUnit->getUnitType();

		// Get rid of the old unit
		pUnit->kill(true);

		// Add the new unit in its place
		if(eType != NO_UNIT)
		{
			CvUnit* pNewUnit = initUnit(eType, iX, iY);
			CvAssert(pNewUnit);
			if (pNewUnit)
#if defined(MOD_BUGFIX_MOVE_AFTER_PURCHASE)
			{
				if (!pUnit->getUnitInfo().CanMoveAfterPurchase())
				{
#endif
					pNewUnit->finishMoves();
#if defined(MOD_BUGFIX_MOVE_AFTER_PURCHASE)
				}
				if (getCapitalCity() != NULL)
				{
					pNewUnit->setOriginCity(getCapitalCity()->GetID());
				}
			}
#endif
		}
	}
	else
	{
		CvAssertMsg(false, "Unexpected case for adding an incoming unit for this player. Please send Anton your save file and version.");
	}
}
//AI Routine for Gifting
PlayerTypes CvPlayer::GetBestGiftTarget()
{
	int iBestValue = 0;
	PlayerTypes eBestMinor = NO_PLAYER;
	for (int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		PlayerTypes eLoopMinor = (PlayerTypes)iMinorLoop;
		if (eLoopMinor != NO_PLAYER)
		{
			CvPlayer* eMinor = &GET_PLAYER(eLoopMinor);
			if (eMinor && eMinor->isAlive())
			{
				CvCity* pCity = eMinor->getCapitalCity();
				if (pCity == NULL)
					continue;

				//First, the exclusions!
				if (!CanGiftUnit(eLoopMinor))
					continue;

				//Initializations...
				int iScore = 0;

				CvMinorCivAI* pMinorCivAI = eMinor->GetMinorCivAI();
				int iFriendship = pMinorCivAI->GetFriendshipFromUnitGift(GetID(), false, true);

				// Skip if not revealed.
				if (!pCity->plot()->isRevealed(getTeam()))
				{
					continue;
				}

				if (!GET_TEAM(eMinor->getTeam()).isHasMet(getTeam()))
					continue;

				if (pMinorCivAI->IsNoAlly() && pMinorCivAI->IsFriends(GetID()))
				{
					continue;
				}
				if (pMinorCivAI->GetPermanentAlly() == GetID())
				{
					continue;
				}
				if (pMinorCivAI->GetPermanentAlly() != GetID() && pMinorCivAI->GetPermanentAlly() != NO_PLAYER)
				{
					continue;
				}
				//If we are at war with target minor, let's not send diplomatic lambs to slaughter.
				if (eMinor->GetMinorCivAI()->IsAtWarWithPlayersTeam(GetID()))
				{
					continue;
				}

				if (eMinor->GetMinorCivAI()->IsActiveQuestForPlayer(GetID(), MINOR_CIV_QUEST_HORDE) || eMinor->GetMinorCivAI()->IsActiveQuestForPlayer(GetID(), MINOR_CIV_QUEST_REBELLION))
				{
					continue;
				}

				// Did we bully you recently?  If so, being friendly now would be very odd.
				if (pMinorCivAI->IsRecentlyBulliedByMajor(GetID()))
				{
					continue;
				}

				int iOtherMajorLoop;
				PlayerTypes eOtherMajor;
				int iFriendshipWithMinor;
				int iOtherPlayerFriendshipWithMinor;

				EconomicAIStrategyTypes eNeedHappiness = (EconomicAIStrategyTypes)GC.getInfoTypeForString("ECONOMICAISTRATEGY_NEED_HAPPINESS");
				EconomicAIStrategyTypes eNeedHappinessCritical = (EconomicAIStrategyTypes)GC.getInfoTypeForString("ECONOMICAISTRATEGY_NEED_HAPPINESS_CRITICAL");
				bool bNeedHappiness = (eNeedHappiness != NO_ECONOMICAISTRATEGY) ? GetEconomicAI()->IsUsingStrategy(eNeedHappiness) : false;
				bool bNeedHappinessCritical = (eNeedHappinessCritical != NO_ECONOMICAISTRATEGY) ? GetEconomicAI()->IsUsingStrategy(eNeedHappinessCritical) : false;

				MinorCivApproachTypes eApproach;

				// **************************
				// Approaches
				// **************************

				iScore = 100;
				eApproach = GetDiplomacyAI()->GetMinorCivApproach(eLoopMinor);

				if (eApproach == MINOR_CIV_APPROACH_IGNORE)
				{
					iScore /= 2;
				}

				// **************************
				// Benefits to Us!
				// **************************

				//DIPLOMACY - We want all of them the same!
				if (GetDiplomacyAI()->IsGoingForDiploVictory())
				{
					iScore *= 2;
				}

				//MILITARY - We want units and happiness!!
				else if (GetDiplomacyAI()->IsGoingForWorldConquest())
				{
					if (pMinorCivAI->GetTrait() == MINOR_CIV_TRAIT_MILITARISTIC)
					{
						iScore *= 2;
					}
				}

				//SCIENCE - We want happiness and growth!!
				else if (GetDiplomacyAI()->IsGoingForSpaceshipVictory())
				{
					if (pMinorCivAI->GetTrait() == MINOR_CIV_TRAIT_MARITIME)
					{
						iScore *= 2;
					}
					if (pMinorCivAI->GetTrait() == MINOR_CIV_TRAIT_MERCANTILE)
					{
						iScore *= 2;
					}
				}

				//CULTURE - We want culture and religion!!
				else if (GetDiplomacyAI()->IsGoingForCultureVictory())
				{
					if (pMinorCivAI->GetTrait() == MINOR_CIV_TRAIT_CULTURED)
					{
						iScore *= 2;
					}
					if (pMinorCivAI->GetTrait() == MINOR_CIV_TRAIT_RELIGIOUS)
					{
						iScore *= 2;
					}
				}

				// Is Our Influence worth more here? Definitely take advantage of this.
				if (pMinorCivAI->IsActiveQuestForPlayer(GetID(), MINOR_CIV_QUEST_INFLUENCE))
				{
					iScore *= 5;
				}

				// Do they have a resource we lack?
				int iResourcesWeLack = pMinorCivAI->GetNumResourcesMajorLacks(GetID());
				if (iResourcesWeLack > 0)
				{
					if (bNeedHappiness)
					{
						iScore *= 3;
					}
					else if (bNeedHappinessCritical)
					{
						iScore *= 4;
					}
					else
					{
						iScore *= 2;
					}
				}

				//Will they give us a WLTKD for their resource?
				CvCity* pLoopCity;
				int iCityLoop;
				for (pLoopCity = GET_PLAYER(GetID()).firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iCityLoop))
				{
					if (pLoopCity != NULL)
					{
						ResourceTypes eResourceDemanded = pLoopCity->GetResourceDemanded();
						if (eResourceDemanded != NO_RESOURCE)
						{
							//Will we get a WLTKD from this? We want it a bit more, please.
							if (eMinor->getResourceInOwnedPlots(eResourceDemanded) > 0)
							{
								iScore *= 3;
								iScore /= 2;
							}
						}
					}
				}

				//Nobody likes hostile city-states.
				if (pMinorCivAI->GetPersonality() == MINOR_CIV_PERSONALITY_HOSTILE)
				{
					iScore /= 2;
				}
				//If our friendship is under 0, we've probably done something bad to this City-State. Let's not look at them!
				if (eMinor->GetMinorCivAI()->GetEffectiveFriendshipWithMajor(GetID()) < 0)
				{
					iScore /= 2;
				}

				// **************************
				// Other Relationships!
				// **************************

				PlayerTypes eAlliedPlayer = NO_PLAYER;
				iFriendshipWithMinor = pMinorCivAI->GetEffectiveFriendshipWithMajor(GetID());
				eAlliedPlayer = pMinorCivAI->GetAlly();

				if (eAlliedPlayer != NO_PLAYER)
				{
					int iHighestInfluence = 0;
					// Loop through other players to see if we can pass them in influence
					for (iOtherMajorLoop = 0; iOtherMajorLoop < MAX_MAJOR_CIVS; iOtherMajorLoop++)
					{
						eOtherMajor = (PlayerTypes)iOtherMajorLoop;

						iOtherPlayerFriendshipWithMinor = pMinorCivAI->GetEffectiveFriendshipWithMajor(eOtherMajor);
						if (iOtherPlayerFriendshipWithMinor > iHighestInfluence)
						{
							iHighestInfluence = iOtherPlayerFriendshipWithMinor;
						}
						if (eOtherMajor != NO_PLAYER && eOtherMajor != GetID() && GET_TEAM(GET_PLAYER(GetID()).getTeam()).isHasMet(GET_PLAYER(eOtherMajor).getTeam()))
						{
							MajorCivApproachTypes eApproachType = GetDiplomacyAI()->GetMajorCivApproach(eOtherMajor, false);
							MajorCivOpinionTypes eOpinion = GetDiplomacyAI()->GetMajorCivOpinion(eOtherMajor);
							// If another player is allied, let's evaluate that.
							// Only care if they are allies
							if (pMinorCivAI->IsAllies(eOtherMajor))
							{
								//Are they not on our team?
								if (GET_PLAYER(eOtherMajor).getTeam() != getTeam())
								{
									//If their influence is way higher than ours, let's tune this down...
									if (iOtherPlayerFriendshipWithMinor >= (60 + iFriendship + iFriendshipWithMinor))
									{
										iScore /= 4;
									}
									//If we can pass them, ramp it up!
									else if (iOtherPlayerFriendshipWithMinor < (iFriendship + iFriendshipWithMinor))
									{
										iScore *= 4;
									}
								}
								// If a teammate is allied, let's discourage going there.
								else
								{
									iScore /= 5;
								}
								// If a friendly player is allied, let's discourage going there.
								if (eApproachType == MAJOR_CIV_APPROACH_FRIENDLY)
								{
									iScore /= 2;
								}
								// If an enemy is allied, let's take their stuff!
								else if (eApproachType == MAJOR_CIV_APPROACH_HOSTILE)
								{
									iScore *= 2;
								}
								// If an ally is allied, let's leave it alone!
								if (eOpinion == MAJOR_CIV_OPINION_ALLY)
								{
									iScore /= 2;
								}
								// If an competitor is allied, let's fight for it!
								else if (eOpinion == MAJOR_CIV_OPINION_COMPETITOR)
								{
									iScore *= 2;
								}
							}
							// Is another player really close to us? If so, let's keep an eye on things.
							else if (iOtherPlayerFriendshipWithMinor >= (iFriendshipWithMinor - 30))
							{
								iScore *= 2;
							}
						}
					}
					int iDifference = (iFriendshipWithMinor - iHighestInfluence);
					// Are we allied? Yay! But let's be careful.
					if (pMinorCivAI->IsAllies(GetID()))
					{
						// Are WE allies by a wide margin (over 100)? If so, let's find someone new to love.
						if (iDifference >= 60)
						{
							iScore /= 5;
						}
						// Are we close to losing our status? If so, obsess away!
						else if (iDifference <= 30 || pMinorCivAI->IsCloseToNotBeingAllies(GetID()))
						{
							iScore *= 5;
						}
					}
				}
				else
				{
					// Are we close to becoming an normal (60) ally and no one else ? If so, obsess away!
#if defined(MOD_CITY_STATE_SCALE)
					if ((iFriendshipWithMinor + iFriendship) >= pMinorCivAI->GetAlliesThreshold(GetID()))
#else
					if ((iFriendshipWithMinor + iFriendship) >= pMinorCivAI->GetAlliesThreshold())
#endif
					{
						iScore *= 4;
					}

					// Are we already Friends? If so, let's stay the course.
					if (pMinorCivAI->IsFriends(GetID()))
					{
						iScore *= 4;
					}
				}

				//All CSs should theoretically be valuable if we've gotten this far.
				if (iScore <= 0)
				{
					iScore = 1;
				}
				if (iScore > iBestValue)
				{
					iBestValue = iScore;
					eBestMinor = eLoopMinor;
				}
			}
		}
	}
	return eBestMinor;
}
//	--------------------------------------------------------------------------------
/// Units in the ether coming towards us?
UnitTypes CvPlayer::GetIncomingUnitType(PlayerTypes eFromPlayer) const
{
	CvAssertMsg(eFromPlayer >= 0, "eFromPlayer is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFromPlayer < MAX_PLAYERS, "eFromPlayer is expected to be within maximum bounds (invalid Index)");
	return (UnitTypes) m_aiIncomingUnitTypes[eFromPlayer];
}

//	--------------------------------------------------------------------------------
/// Units in the ether coming towards us?
void CvPlayer::SetIncomingUnitType(PlayerTypes eFromPlayer, UnitTypes eUnitType)
{
	CvAssertMsg(eFromPlayer >= 0, "eFromPlayer is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFromPlayer < MAX_PLAYERS, "eFromPlayer is expected to be within maximum bounds (invalid Index)");

	CvAssertMsg(eUnitType >= NO_UNIT, "eUnitType is expected to be non-negative (invalid Index)");
	CvAssertMsg(eUnitType < GC.getNumUnitInfos(), "eUnitType is expected to be within maximum bounds (invalid Index)");

	if(eUnitType != m_aiIncomingUnitTypes[eFromPlayer])
	{
		m_aiIncomingUnitTypes.setAt(eFromPlayer, eUnitType);
	}
}

//	--------------------------------------------------------------------------------
/// Units in the ether coming towards us?
int CvPlayer::GetIncomingUnitCountdown(PlayerTypes eFromPlayer) const
{
	CvAssertMsg(eFromPlayer >= 0, "eFromPlayer is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFromPlayer < MAX_PLAYERS, "eFromPlayer is expected to be within maximum bounds (invalid Index)");
	return m_aiIncomingUnitCountdowns[eFromPlayer];
}

//	--------------------------------------------------------------------------------
/// Units in the ether coming towards us?
void CvPlayer::SetIncomingUnitCountdown(PlayerTypes eFromPlayer, int iNumTurns)
{
	CvAssertMsg(eFromPlayer >= 0, "eFromPlayer is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFromPlayer < MAX_PLAYERS, "eFromPlayer is expected to be within maximum bounds (invalid Index)");

	if(iNumTurns != m_aiIncomingUnitCountdowns[eFromPlayer])
		m_aiIncomingUnitCountdowns.setAt(eFromPlayer, iNumTurns);
}

//	--------------------------------------------------------------------------------
/// Units in the ether coming towards us?
void CvPlayer::ChangeIncomingUnitCountdown(PlayerTypes eFromPlayer, int iChange)
{
	if(iChange != 0)
		SetIncomingUnitCountdown(eFromPlayer, GetIncomingUnitCountdown(eFromPlayer) + iChange);
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isOption(PlayerOptionTypes eID) const
{
	for (PlayerOptionsVector::const_iterator itr = m_aOptions.begin(); itr != m_aOptions.end(); ++itr )
	{
		if ((*itr).first == eID)
			return (*itr).second != 0;
	}
	return false;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setOption(PlayerOptionTypes eID, bool bNewValue)
{
	int iIndex = 0;
	for (PlayerOptionsVector::const_iterator itr = m_aOptions.begin(); itr != m_aOptions.end(); ++itr )
	{
		if ((*itr).first == eID)
		{
			m_aOptions.setAt(iIndex, PlayerOptionEntry((uint)eID, bNewValue?1:0));
			return;
		}
		++iIndex;
	}

	m_aOptions.push_back(PlayerOptionEntry((uint)eID, bNewValue?1:0));
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isPlayable() const
{
	return CvPreGame::isPlayable(GetID());
}

//	--------------------------------------------------------------------------------
void CvPlayer::setPlayable(bool bNewValue)
{
	CvPreGame::setPlayable(GetID(), bNewValue);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNumResourceUsed(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiNumResourceUsed[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeNumResourceUsed(ResourceTypes eIndex, int iChange)
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumResourceInfos());

	if(iChange != 0)
	{
		m_paiNumResourceUsed.setAt(eIndex, m_paiNumResourceUsed[eIndex] + iChange);
	}
#if !defined(MOD_BALANCE_CORE)
	if(iChange > 0)
		DoTestOverResourceNotification(eIndex);
#endif

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	CvAssert(m_paiNumResourceUsed[eIndex] >= 0);
}
//	--------------------------------------------------------------------------------
int CvPlayer::getNumResourcesFromOther(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	// Mod applied to how much we have?
	CvResourceInfo *pkResource = GC.getResourceInfo(eIndex);
	if (pkResource == NULL)
	{
		return 0;
	}

	int iTotalNumResource = m_paiNumResourceTotal[eIndex];

#if defined(MOD_BALANCE_CORE)
	// Additional resources from Corporation
	CorporationTypes eCorporation = GetCorporations()->GetFoundedCorporation();
	if (eCorporation != NO_CORPORATION)
	{
		CvCorporationEntry* pkCorporationInfo = GC.getCorporationInfo(eCorporation);
		if (pkCorporationInfo)
		{
			int iFreeResource = pkCorporationInfo->GetNumFreeResource(eIndex);
			if (iFreeResource > 0)
			{
				iTotalNumResource += iFreeResource;
			}
		}
	}

	int iCSResource = getResourceFromCSAlliances(eIndex);
	if (iCSResource != 0)
	{
		TechTypes eRevealTech = (TechTypes)pkResource->getTechReveal();

		if (eRevealTech == NO_TECH || GET_TEAM(getTeam()).GetTeamTechs()->HasTech(eRevealTech))
		{
			iCSResource *= GetNumCSAllies();
			iCSResource /= 100;
			iTotalNumResource += iCSResource;
		}
		else
		{
			PolicyTypes eRevealPolicy = (PolicyTypes)pkResource->getPolicyReveal();

			// Is there no Reveal Tech or do we have it?
			if (eRevealPolicy != NO_POLICY && GetPlayerPolicies()->HasPolicy(eRevealPolicy))
			{
				iCSResource *= GetNumCSAllies();
				iCSResource /= 100;
				iTotalNumResource += iCSResource;
			}
		}
	}
#endif

	if (pkResource->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)
	{
#if defined(MOD_BALANCE_CORE)
		const CvCity* pLoopCity;
		int iLoop;
		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if (pLoopCity != NULL)
			{
				if (pLoopCity->GetResourceQuantityPerXFranchises(eIndex) > 0)
				{
					int iFranchises = GetCorporations()->GetNumFranchises();
					if (iFranchises > 0)
					{
						iTotalNumResource += (iFranchises / pLoopCity->GetResourceQuantityPerXFranchises(eIndex));
					}
				}
			}
		}
#endif
		if (GetStrategicResourceMod() != 0)
		{
			iTotalNumResource *= GetStrategicResourceMod();
			iTotalNumResource /= 100;
		}
	}

#if defined(MOD_BALANCE_CORE)
	ReligionTypes eFounder = GC.getGame().GetGameReligions()->GetReligionCreatedByPlayer(GetID());
	if (eFounder == NO_RELIGION)
	{
		eFounder = GetReligions()->GetReligionInMostCities();
	}
	const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eFounder, GetID());
	if (pReligion)
	{
		CvCity* pHolyCity = NULL;
		CvPlot* pHolyCityPlot = GC.getMap().plot(pReligion->m_iHolyCityX, pReligion->m_iHolyCityY);
		if (pHolyCityPlot)
		{
			pHolyCity = pHolyCityPlot->getPlotCity();
		}
		if (pHolyCity == NULL)
		{
			pHolyCity = GET_PLAYER(GetID()).getCapitalCity();
		}
		int iQuantityMod = pReligion->m_Beliefs.GetResourceQuantityModifier(eIndex, GetID(), pHolyCity, true);
		if (iQuantityMod != 0)
		{
			iQuantityMod *= GC.getGame().GetGameReligions()->GetNumCitiesFollowing(eFounder);

			iTotalNumResource *= 100 + std::min(25, iQuantityMod);
			iTotalNumResource /= 100;
		}
	}
#endif

	//And remove the starter.
	iTotalNumResource -= m_paiNumResourceTotal[eIndex];

	return iTotalNumResource;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getNumResourceTotal(ResourceTypes eIndex, bool bIncludeImport, bool bIncludeMinors) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	// Mod applied to how much we have?
	CvResourceInfo *pkResource = GC.getResourceInfo(eIndex);
	if (pkResource == NULL)
	{
		return 0;
	}

	int iTotalNumResource = m_paiNumResourceTotal[eIndex];

#if defined(MOD_BALANCE_CORE)
	// Additional resources from Corporation
	CorporationTypes eCorporation = GetCorporations()->GetFoundedCorporation();
	if (eCorporation != NO_CORPORATION)
	{
		CvCorporationEntry* pkCorporationInfo = GC.getCorporationInfo(eCorporation);
		if (pkCorporationInfo)
		{
			int iFreeResource = pkCorporationInfo->GetNumFreeResource(eIndex);
			if (iFreeResource > 0)
			{
				iTotalNumResource += iFreeResource;
			}
		}
	}

	int iCSResource = getResourceFromCSAlliances(eIndex);
	if (iCSResource != 0)
	{
		TechTypes eRevealTech = (TechTypes)pkResource->getTechReveal();

		if (eRevealTech == NO_TECH || GET_TEAM(getTeam()).GetTeamTechs()->HasTech(eRevealTech))
		{
			iCSResource *= GetNumCSAllies();
			iCSResource /= 100;
			iTotalNumResource += iCSResource;
		}
		else
		{
			PolicyTypes eRevealPolicy = (PolicyTypes)pkResource->getPolicyReveal();

			// Is there no Reveal Tech or do we have it?
			if (eRevealPolicy != NO_POLICY && GetPlayerPolicies()->HasPolicy(eRevealPolicy))
			{
				iCSResource *= GetNumCSAllies();
				iCSResource /= 100;
				iTotalNumResource += iCSResource;
			}
		}
	}
#endif

	if(pkResource->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)
	{
#if defined(MOD_BALANCE_CORE)
		const CvCity* pLoopCity;
		int iLoop;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity != NULL)
			{
				if(pLoopCity->GetResourceQuantityPerXFranchises(eIndex) > 0)
				{
					int iFranchises = GetCorporations()->GetNumFranchises();
					if(iFranchises > 0)
					{
						iTotalNumResource += (iFranchises / pLoopCity->GetResourceQuantityPerXFranchises(eIndex));
					}
				}
			}
		}
#endif
		if(GetStrategicResourceMod() != 0)
		{
			iTotalNumResource *= GetStrategicResourceMod();
			iTotalNumResource /= 100;
		}
	}

#if defined(MOD_BALANCE_CORE)
	ReligionTypes eFounder = GC.getGame().GetGameReligions()->GetReligionCreatedByPlayer(GetID());
	if (eFounder == NO_RELIGION)
	{
		eFounder = GetReligions()->GetReligionInMostCities();
	}
	const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eFounder, GetID());
	if (pReligion)
	{
		CvCity* pHolyCity = NULL;
		CvPlot* pHolyCityPlot = GC.getMap().plot(pReligion->m_iHolyCityX, pReligion->m_iHolyCityY);
		if (pHolyCityPlot)
		{
			pHolyCity = pHolyCityPlot->getPlotCity();
		}
		if (pHolyCity == NULL)
		{
			pHolyCity = GET_PLAYER(GetID()).getCapitalCity();
		}
		int iQuantityMod = pReligion->m_Beliefs.GetResourceQuantityModifier(eIndex, GetID(), pHolyCity, true);
		if (iQuantityMod != 0)
		{
			iQuantityMod *= GC.getGame().GetGameReligions()->GetNumCitiesFollowing(eFounder);

			iTotalNumResource *= 100 + std::min(25, iQuantityMod);
			iTotalNumResource /= 100;
		}
	}
#endif
	if (bIncludeMinors && !IsCSResourcesCountMonopolies())
		bIncludeMinors = false;

	if (bIncludeImport || bIncludeMinors)
		iTotalNumResource += getResourceFromMinors(eIndex);

	if(bIncludeImport)
	{
		iTotalNumResource += getResourceImport(eIndex);
		iTotalNumResource += getResourceSiphoned(eIndex);
	}

	iTotalNumResource -= getResourceExport(eIndex);

	return iTotalNumResource;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeNumResourceTotal(ResourceTypes eIndex, int iChange, bool bIgnoreResourceWarning)
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumResourceInfos());

	if(iChange != 0)
	{
		m_paiNumResourceTotal.setAt(eIndex, m_paiNumResourceTotal[eIndex] + iChange);

#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
		if(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
		{
			CheckForMonopoly(eIndex);
		}
#endif

		// Minors with an Ally give their Resources to their friend (awww)
		if(isMinorCiv())
		{
			PlayerTypes eBestRelationsPlayer = GetMinorCivAI()->GetAlly();

			if(eBestRelationsPlayer != NO_PLAYER)
			{
				ResourceUsageTypes eUsage = GC.getResourceInfo(eIndex)->getResourceUsage();

				if(eUsage == RESOURCEUSAGE_STRATEGIC || eUsage == RESOURCEUSAGE_LUXURY)
				{
					GET_PLAYER(eBestRelationsPlayer).changeResourceFromMinors(eIndex, iChange);
					changeResourceExport(eIndex, iChange);

					// Someone new is getting the bonus - but do they have the tech to see it?
					if (GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)GC.getResourceInfo(eIndex)->getTechReveal()))
					{
						CvNotifications* pNotifications = GET_PLAYER(eBestRelationsPlayer).GetNotifications();
						if(pNotifications && !GetMinorCivAI()->IsDisableNotifications())
						{
							Localization::String strMessage;
							Localization::String strSummary;

							// Adding Resources
							if(iChange > 0)
							{
								strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_BFF_NEW_RESOURCE");
								strMessage << getNameKey() << GC.getResourceInfo(eIndex)->GetDescriptionKey();
								strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MINOR_BFF_NEW_RESOURCE");
								strSummary << getNameKey() << GC.getResourceInfo(eIndex)->GetDescriptionKey();
							}
							// Lost Resources
							else
							{
								strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_BFF_LOST_RESOURCE");
								strMessage << getNameKey() << GC.getResourceInfo(eIndex)->GetDescriptionKey();
								strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MINOR_BFF_LOST_RESOURCE");
								strSummary << getNameKey() << GC.getResourceInfo(eIndex)->GetDescriptionKey();
							}

							int iX = -1;
							int iY = -1;

							CvCity* capCity = getCapitalCity();

							if(capCity != NULL)
							{
								iX = capCity->getX();
								iY = capCity->getY();
							}

							pNotifications->Add(NOTIFICATION_MINOR, strMessage.toUTF8(), strSummary.toUTF8(), iX, iY, -1);
						}
					}
				}
			}
		}

		// Any players siphoning resources from us need to be updated as well
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_PLAYERS; iPlayerLoop++)
		{
			GET_PLAYER((PlayerTypes)iPlayerLoop).UpdateResourcesSiphoned();
		}
	}
	if(iChange < 0 && !bIgnoreResourceWarning)
#if !defined(MOD_BALANCE_CORE)
	{
		DoTestOverResourceNotification(eIndex);
	}
#endif

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	CvAssert(m_paiNumResourceTotal[eIndex] >= 0);
}
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
//	--------------------------------------------------------------------------------
int CvPlayer::getResourceOverValue(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiResourceOverValue[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceOverValue(ResourceTypes eIndex, int iChange)
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumResourceInfos());

	if(iChange != 0)
	{
		m_paiResourceOverValue.setAt(eIndex, m_paiResourceOverValue[eIndex] + iChange);
	}

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	CvAssert(m_paiResourceOverValue[eIndex] >= 0);
}
//	--------------------------------------------------------------------------------
void CvPlayer::setResourceOverValue(ResourceTypes eIndex, int iChange)
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumResourceInfos());

	m_paiResourceOverValue.setAt(eIndex, iChange);

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	CvAssert(m_paiResourceOverValue[eIndex] >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getResourceFromCSAlliances(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiResourceFromCSAlliances[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceFromCSAlliances(ResourceTypes eIndex, int iChange)
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumResourceInfos());

	if (iChange != 0)
	{
		m_paiResourceFromCSAlliances.setAt(eIndex, m_paiResourceFromCSAlliances[eIndex] + iChange);
	}

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	CvAssert(m_paiResourceFromCSAlliances[eIndex] >= 0);
}
//	--------------------------------------------------------------------------------
void CvPlayer::setResourceFromCSAlliances(ResourceTypes eIndex, int iChange)
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumResourceInfos());

	m_paiResourceFromCSAlliances.setAt(eIndex, iChange);

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	CvAssert(m_paiResourceFromCSAlliances[eIndex] >= 0);
}

//	--------------------------------------------------------------------------------
bool CvPlayer::HasGlobalMonopoly(ResourceTypes eResource) const
{
	return m_pabHasGlobalMonopoly[eResource];
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetHasGlobalMonopoly(ResourceTypes eResource, bool bNewValue)
{
	if(!MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
		return;

	if (bNewValue != m_pabHasGlobalMonopoly[eResource])
	{
		m_pabHasGlobalMonopoly.setAt(eResource, bNewValue);

		YieldTypes eYield;
		CvResourceInfo* pResource = GC.getResourceInfo(eResource);
		if (pResource)
		{
			for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				eYield = (YieldTypes)iI;

				if (eYield == NO_YIELD)
					continue;

				int iModValue = pResource->getCityYieldModFromMonopoly(eYield);
				if (iModValue != 0)
				{
					if (bNewValue)
					{
						changeCityYieldModFromMonopoly(eYield, iModValue);
					}
					else
					{
						changeCityYieldModFromMonopoly(eYield, (iModValue * -1));
					}
				}
			}

#if defined(MOD_API_UNIFIED_YIELDS)
			for (int iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
			{
				SpecialistTypes eSpecialist = (SpecialistTypes)iI;
				GreatPersonTypes eGreatPerson = GetGreatPersonFromSpecialist(eSpecialist);
				if (eSpecialist != NO_SPECIALIST && eGreatPerson != NO_GREATPERSON)
				{
					int iModValue = pResource->getMonopolyGreatPersonRateModifier(eSpecialist, MONOPOLY_GLOBAL);
					if (iModValue > 0)
					{
						if (bNewValue)
						{
							changeSpecificGreatPersonRateModifierFromMonopoly(eGreatPerson, MONOPOLY_GLOBAL, iModValue);
						}
						else
						{
							changeSpecificGreatPersonRateModifierFromMonopoly(eGreatPerson, MONOPOLY_GLOBAL, iModValue * -1);
						}
					}
				}
			}
#endif
		}
	}

	std::vector<ResourceTypes>::iterator it = std::find(m_vResourcesWGlobalMonopoly.begin(),m_vResourcesWGlobalMonopoly.end(),eResource);
	if (bNewValue && it==m_vResourcesWGlobalMonopoly.end())
		m_vResourcesWGlobalMonopoly.push_back(eResource);
	else if (!bNewValue && it!=m_vResourcesWGlobalMonopoly.end())
		m_vResourcesWGlobalMonopoly.erase(it);
}
//	--------------------------------------------------------------------------------
bool CvPlayer::HasStrategicMonopoly(ResourceTypes eResource) const
{
	return m_pabHasStrategicMonopoly[eResource];
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetHasStrategicMonopoly(ResourceTypes eResource, bool bNewValue)
{
	if(!MOD_BALANCE_CORE_RESOURCE_MONOPOLIES_STRATEGIC)
		return;

	if(bNewValue != m_pabHasStrategicMonopoly[eResource])
	{
		m_pabHasStrategicMonopoly.setAt(eResource, bNewValue);

		CvResourceInfo* pResource = GC.getResourceInfo(eResource);
		if (pResource)
		{
#if defined(MOD_API_UNIFIED_YIELDS)
			for (int iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
			{
				SpecialistTypes eSpecialist = (SpecialistTypes)iI;
				GreatPersonTypes eGreatPerson = GetGreatPersonFromSpecialist(eSpecialist);
				if (eSpecialist != NO_SPECIALIST && eGreatPerson != NO_GREATPERSON)
				{
					int iModValue = pResource->getMonopolyGreatPersonRateModifier(eSpecialist, MONOPOLY_STRATEGIC);
					if (iModValue > 0)
					{
						if (bNewValue)
						{
							changeSpecificGreatPersonRateModifierFromMonopoly(eGreatPerson, MONOPOLY_STRATEGIC, iModValue);
						}
						else
						{
							changeSpecificGreatPersonRateModifierFromMonopoly(eGreatPerson, MONOPOLY_STRATEGIC, iModValue * -1);
						}
					}
				}
			}
#endif
		}
	}

	std::vector<ResourceTypes>::iterator it = std::find(m_vResourcesWStrategicMonopoly.begin(),m_vResourcesWStrategicMonopoly.end(),eResource);
	if (bNewValue && it==m_vResourcesWStrategicMonopoly.end())
		m_vResourcesWStrategicMonopoly.push_back(eResource);
	else if (!bNewValue && it!=m_vResourcesWStrategicMonopoly.end())
		m_vResourcesWStrategicMonopoly.erase(it);
}

//	--------------------------------------------------------------------------------
void CvPlayer::CheckForMonopoly(ResourceTypes eResource)
{
	const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);
	if(pkResourceInfo != NULL)
	{
		if (pkResourceInfo->isMonopoly() && (pkResourceInfo->getTechReveal() == NO_TECH || HasTech((TechTypes)pkResourceInfo->getTechReveal())))
		{
			bool bGainingBonus = false;
			bool bGainingStrategicBonus = false;
			bool bLosingBonus = false;
			bool bLosingStrategicBonus = false;
			int iTotalNumResource = GC.getMap().getNumResources(eResource);
			if (iTotalNumResource > 0)
			{
				int iOwnedNumResource = getNumResourceTotal(eResource, false, IsCSResourcesCountMonopolies()) + getResourceExport(eResource);
				if (GetPlayerTraits()->IsImportsCountTowardsMonopolies())
				{
					iOwnedNumResource += getResourceImport(eResource);
				}
				
				if (pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_LUXURY && !GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(GetID(), eResource))
				{
					int iThreshold = max(GC.getGame().GetGreatestPlayerResourceMonopolyValue(eResource), GC.getGLOBAL_RESOURCE_MONOPOLY_THRESHOLD());
					//Do we have +50% of this resource under our control?
					bool bValid = false;
					if (GC.getGame().GetGreatestPlayerResourceMonopoly(eResource) == GetID())
					{
						if (((iOwnedNumResource * 100) / iTotalNumResource) >= iThreshold && ((iOwnedNumResource * 100) / iTotalNumResource) > GC.getGLOBAL_RESOURCE_MONOPOLY_THRESHOLD())
							bValid = true;
					}
					else
					{
						if (((iOwnedNumResource * 100) / iTotalNumResource) > iThreshold)
							bValid = true;
					}
					if (bValid)
					{
						if(m_pabHasGlobalMonopoly[eResource] == false)
						{
							bGainingBonus = true;
							GC.getGame().UpdateGreatestPlayerResourceMonopoly(eResource);
						}
						SetHasGlobalMonopoly(eResource, true);						
					}
					else
					{
						if(m_pabHasGlobalMonopoly[eResource] == true)
						{
							bLosingBonus = true;
							GC.getGame().UpdateGreatestPlayerResourceMonopoly(eResource);
						}
						SetHasGlobalMonopoly(eResource, false);
					}
				}
				else if(pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)
				{
					//Do we have +25% of this resource under our control?
					if(((iOwnedNumResource * 100) / iTotalNumResource) > GC.getSTRATEGIC_RESOURCE_MONOPOLY_THRESHOLD())
					{
						if(m_pabHasStrategicMonopoly[eResource] == false)
						{
							bGainingStrategicBonus = true;
							GC.getGame().UpdateGreatestPlayerResourceMonopoly(eResource);
						}
						SetHasStrategicMonopoly(eResource, true);
					}
					else
					{
						if(m_pabHasStrategicMonopoly[eResource] == true)
						{
							bLosingStrategicBonus = true;
							GC.getGame().UpdateGreatestPlayerResourceMonopoly(eResource);
						}
						SetHasStrategicMonopoly(eResource, false);
					}
					//Do we also have 50% of this resource under our control?
					int iThreshold = max(GC.getGame().GetGreatestPlayerResourceMonopolyValue(eResource), GC.getGLOBAL_RESOURCE_MONOPOLY_THRESHOLD());

					bool bValid = false;
					if (GC.getGame().GetGreatestPlayerResourceMonopoly(eResource) == GetID())
					{
						if (((iOwnedNumResource * 100) / iTotalNumResource) >= iThreshold && ((iOwnedNumResource * 100) / iTotalNumResource) > GC.getGLOBAL_RESOURCE_MONOPOLY_THRESHOLD())
							bValid = true;
					}
					else
					{
						if (((iOwnedNumResource * 100) / iTotalNumResource) > iThreshold)
							bValid = true;
					}

					if (bValid)
					{
						if(m_pabHasGlobalMonopoly[eResource] == false)
						{
							bGainingBonus = true;
							GC.getGame().UpdateGreatestPlayerResourceMonopoly(eResource);
						}
						SetHasGlobalMonopoly(eResource, true);
						
					}
					else
					{
						if(m_pabHasGlobalMonopoly[eResource] == true)
						{
							bLosingBonus = true;
							GC.getGame().UpdateGreatestPlayerResourceMonopoly(eResource);
						}
						SetHasGlobalMonopoly(eResource, false);
					}
				}
				CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
				if(pLeague != NULL)
				{
					if (GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(GetID(), eResource))
					{
						if(m_pabHasGlobalMonopoly[eResource] == true)
						{
							bLosingBonus = true;
							GC.getGame().UpdateGreatestPlayerResourceMonopoly(eResource);
						}
						SetHasGlobalMonopoly(eResource, false);
					}
				}
			}
			else
			{
				SetHasGlobalMonopoly(eResource, false);

			}
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications && MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
			{
				const char* strResourceHelp = pkResourceInfo->GetHelp();

				// Adding Resources
				if(bGainingBonus)
				{
					Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MONOPOLY_GAINED");
					strMessage << pkResourceInfo->GetTextKey();
					strMessage << strResourceHelp;
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MONOPOLY_GAINED");
					strSummary << pkResourceInfo->GetTextKey();

					pNotifications->Add(NOTIFICATION_DISCOVERED_BONUS_RESOURCE, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, eResource);
					updateYield();
					for(int iPlayer = 0; iPlayer < MAX_PLAYERS; ++iPlayer)
					{
						//Notify human players of this, as they'll care.
						CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iPlayer);
						if(GET_TEAM(kLoopPlayer.getTeam()).isHasMet(getTeam()) && kLoopPlayer.isHuman() && (kLoopPlayer.GetID() != GetID()))
						{
							Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_PLAYER_MONOPOLY_GAINED");
							strMessage << pkResourceInfo->GetTextKey();
							strMessage << strResourceHelp;
							strMessage << getCivilizationInfo().getShortDescriptionKey();
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_OTHER_PLAYER_MONOPOLY_GAINED");
							strSummary << pkResourceInfo->GetTextKey();
							strSummary << getCivilizationInfo().getShortDescriptionKey();

							kLoopPlayer.GetNotifications()->Add(NOTIFICATION_DISCOVERED_BONUS_RESOURCE, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, eResource);
						}
					}
				}
				// Lost Resources
				else if(bLosingBonus && MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
				{
					Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MONOPOLY_LOST");
					strMessage << pkResourceInfo->GetTextKey();
					strMessage << strResourceHelp;
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MONOPOLY_LOST");
					strSummary << pkResourceInfo->GetTextKey();

					pNotifications->Add(NOTIFICATION_DISCOVERED_BONUS_RESOURCE, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, eResource);
					updateYield();
				}
				// Adding Resources
				if(bGainingStrategicBonus && MOD_BALANCE_CORE_RESOURCE_MONOPOLIES_STRATEGIC)
				{
					Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_STRATEGIC_MONOPOLY_GAINED");
					strMessage << pkResourceInfo->GetTextKey();
					strMessage << strResourceHelp;
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_STRATEGIC_MONOPOLY_GAINED");
					strSummary << pkResourceInfo->GetTextKey();

					pNotifications->Add(NOTIFICATION_DISCOVERED_BONUS_RESOURCE, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, eResource);
					updateYield();
					for(int iPlayer = 0; iPlayer < MAX_PLAYERS; ++iPlayer)
					{
						//Notify human players of this, as they'll care.
						CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iPlayer);
						if(GET_TEAM(kLoopPlayer.getTeam()).isHasMet(getTeam()) && kLoopPlayer.isHuman() && (kLoopPlayer.GetID() != GetID()))
						{
							Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_PLAYER_STRATEGIC_MONOPOLY_GAINED");
							strMessage << pkResourceInfo->GetTextKey();
							strMessage << strResourceHelp;
							strMessage << getCivilizationInfo().getShortDescriptionKey();
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_OTHER_PLAYER_STRATEGIC_MONOPOLY_GAINED");
							strSummary << pkResourceInfo->GetTextKey();
							strSummary << getCivilizationInfo().getShortDescriptionKey();

							kLoopPlayer.GetNotifications()->Add(NOTIFICATION_DISCOVERED_BONUS_RESOURCE, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, eResource);
						}
					}
				}
				// Lost Resources
				else if(bLosingStrategicBonus && MOD_BALANCE_CORE_RESOURCE_MONOPOLIES_STRATEGIC)
				{
					Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_STRATEGIC_MONOPOLY_LOST");
					strMessage << pkResourceInfo->GetTextKey();
					strMessage << strResourceHelp;
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_STRATEGIC_MONOPOLY_LOST");
					strSummary << pkResourceInfo->GetTextKey();

					pNotifications->Add(NOTIFICATION_DISCOVERED_BONUS_RESOURCE, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, eResource);
					updateYield();
				}
			}
		}
	}
}
#endif
//	--------------------------------------------------------------------------------
/// Get the monopoly percentage owned for eResource.
int CvPlayer::GetMonopolyPercent(ResourceTypes eResource) const
{
	int iOwnedNumResource = getNumResourceTotal(eResource, false, IsCSResourcesCountMonopolies()) + getResourceExport(eResource);
	if (GetPlayerTraits()->IsImportsCountTowardsMonopolies())
	{
		iOwnedNumResource += getResourceImport(eResource);
	}
	int iTotalNumResource = GC.getMap().getNumResources(eResource);

	if (iTotalNumResource <= 0)
	{
		// if we own a resource, but it's not on the map at all, it is 100%
		return iOwnedNumResource > 0 ? 100 : 0;
	}

	return (iOwnedNumResource * 100) / iTotalNumResource;
}
int CvPlayer::getCityYieldModFromMonopoly(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	return m_aiCityYieldModFromMonopoly[eIndex];
}
void CvPlayer::changeCityYieldModFromMonopoly(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiCityYieldModFromMonopoly.setAt(eIndex, m_aiCityYieldModFromMonopoly[eIndex] + iChange);
	}
}

//	--------------------------------------------------------------------------------
//	--------------------------------------------------------------------------------
/// Do we get copies of each type of luxury connected by eFromPlayer?
int CvPlayer::getSiphonLuxuryCount(PlayerTypes eFromPlayer) const
{
	CvAssertMsg(eFromPlayer >= 0, "eFromPlayer is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFromPlayer < MAX_PLAYERS, "eFromPlayer is expected to be within maximum bounds (invalid Index)");

	return m_aiSiphonLuxuryCount[eFromPlayer];
}

//	--------------------------------------------------------------------------------
/// Change number of copies we get of luxury types connected by eFromPlayer
void CvPlayer::changeSiphonLuxuryCount(PlayerTypes eFromPlayer, int iChange)
{
	CvAssertMsg(eFromPlayer >= 0, "eFromPlayer is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFromPlayer < MAX_PLAYERS, "eFromPlayer is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiSiphonLuxuryCount.setAt(eFromPlayer, m_aiSiphonLuxuryCount[eFromPlayer] + iChange);
		CvAssert(getSiphonLuxuryCount(eFromPlayer) >= 0);

		UpdateResourcesSiphoned();
	}
}

//	--------------------------------------------------------------------------------
/// Count up the number of resources we have been siphoning from others and compare it to how many 
/// we are now allowed to siphon.  Change our resource count if there is a discrepancy.
void CvPlayer::UpdateResourcesSiphoned()
{
	FStaticVector<int, 64, true, c_eCiv5GameplayDLL> vDeltas;
	
	// Subtract all currently siphoned resources
	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
		vDeltas.push_back(-1 * getResourceSiphoned(eResourceLoop));
	}

	// Add back in valid siphoned resources
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes ePlayerLoop = (PlayerTypes) iPlayerLoop;
		int iSiphonLuxuryCount = getSiphonLuxuryCount(ePlayerLoop);
		if (iSiphonLuxuryCount > 0)
		{
			for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
			{
				ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
				CvResourceInfo* pInfo = GC.getResourceInfo(eResourceLoop);
				// Is it a luxury?
				if (pInfo && pInfo->getResourceUsage() == RESOURCEUSAGE_LUXURY)
				{
					// Do they have at least one of this type, even if it was exported?
					if (GET_PLAYER(ePlayerLoop).getNumResourceTotal(eResourceLoop, /*bIncludeImport*/ false) > 0 || GET_PLAYER(ePlayerLoop).getResourceExport(eResourceLoop) > 0)
					{
						vDeltas[eResourceLoop] += iSiphonLuxuryCount;
					}
				}
			}
		}
	}

	// Propagate any actual changes
	for (uint i = 0; i < vDeltas.size(); i++)
	{
		if (vDeltas[i] != 0)
		{
			ResourceTypes eResource = (ResourceTypes) i;
			changeResourceSiphoned(eResource, vDeltas[i]);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Are we over our resource limit? If so, give out a notification
void CvPlayer::DoTestOverResourceNotification(ResourceTypes eIndex)
{
#if defined(MOD_BALANCE_CORE)
	if((getNumResourceAvailable(eIndex, true) < 0) && (getNumResourceUsed(eIndex) > 0))
#else
	if(getNumResourceAvailable(eIndex, true) < 0)
#endif
	{
#if defined(MOD_BALANCE_CORE)
		//Flip the amount available as our drain pool - helper for cities to prevent empire wide drop.
		setResourceOverValue(eIndex, (getNumResourceAvailable(eIndex, true) * -1));
		int iUnitLoop;
		CvUnit* pLoopUnit = NULL;

		// Test
		bool bTest = false;
		for(pLoopUnit = firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iUnitLoop))
		{
			if(!pLoopUnit)
			{
				continue;
			}
			CvUnitEntry* pkUnitInfo = GC.getUnitInfo(pLoopUnit->getUnitType());
			if(pkUnitInfo)
			{
				if(pkUnitInfo->GetResourceQuantityRequirement(eIndex) > 0)
				{
					bTest = true;
					break;
				}
			}
		}
		if(!bTest)
			return;
#endif
		const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eIndex);
		if(pkResourceInfo != NULL && pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)
		{
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_OVER_RESOURCE_LIMIT");
				strText << pkResourceInfo->GetTextKey();
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_OVER_RESOURCE_LIMIT");
				strSummary << pkResourceInfo->GetTextKey();
#if defined(MOD_BALANCE_CORE)
				pNotifications->Add(NOTIFICATION_DISCOVERED_STRATEGIC_RESOURCE, strText.toUTF8(), strSummary.toUTF8(), -1, -1, eIndex);
#else
				pNotifications->Add(NOTIFICATION_DEMAND_RESOURCE, strText.toUTF8(), strSummary.toUTF8(), -1, -1, eIndex);
#endif
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Is our collection of Strategic Resources modified?
int CvPlayer::GetStrategicResourceMod() const
{
	return m_iStrategicResourceMod;
}

//	--------------------------------------------------------------------------------
/// Is our collection of Strategic Resources modified?
void CvPlayer::ChangeStrategicResourceMod(int iChange)
{
	m_iStrategicResourceMod += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNumResourceAvailable(ResourceTypes eIndex, bool bIncludeImport) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return getNumResourceTotal(eIndex, bIncludeImport) - getNumResourceUsed(eIndex);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getResourceGiftedToMinors(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiResourceGiftedToMinors[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceGiftedToMinors(ResourceTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiResourceGiftedToMinors.setAt(eIndex, m_paiResourceGiftedToMinors[eIndex] + iChange);
		CvAssert(getResourceGiftedToMinors(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getResourceExport(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiResourceExport[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceExport(ResourceTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiResourceExport.setAt(eIndex, m_paiResourceExport[eIndex] + iChange);
		CvAssert(getResourceExport(eIndex) >= 0);

		CalculateNetHappiness();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getResourceImport(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiResourceImport[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceImport(ResourceTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiResourceImport.setAt(eIndex, m_paiResourceImport[eIndex] + iChange);
		CvAssert(getResourceImport(eIndex) >= 0);

		CalculateNetHappiness();

		if (GetPlayerTraits()->IsImportsCountTowardsMonopolies())
		{
			CheckForMonopoly(eIndex);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getResourceFromMinors(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	int iNumResourceFromMinors = m_paiResourceFromMinors[eIndex];

	// Resource bonus doubles quantity of Resources from Minors (Policies, etc.)
	if(IsMinorResourceBonus())
	{
		iNumResourceFromMinors *= /*200*/ GC.getMINOR_POLICY_RESOURCE_MULTIPLIER();
		iNumResourceFromMinors /= 100;
	}

	return iNumResourceFromMinors;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceFromMinors(ResourceTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiResourceFromMinors.setAt(eIndex, m_paiResourceFromMinors[eIndex] + iChange);
		CvAssert(getResourceFromMinors(eIndex) >= 0);

		CalculateNetHappiness();

		if (IsCSResourcesCountMonopolies())
			CheckForMonopoly(eIndex);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getResourceSiphoned(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	int iNumResourceSiphoned = m_paiResourcesSiphoned[eIndex];

	return iNumResourceSiphoned;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceSiphoned(ResourceTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_paiResourcesSiphoned.setAt(eIndex, m_paiResourcesSiphoned[eIndex] + iChange);
		CvAssert(getResourceSiphoned(eIndex) >= 0);

		CalculateNetHappiness();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getResourceInOwnedPlots(ResourceTypes eIndex)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	int iCount = 0;

	// go through all the plots the player has under their control
	for (PlotIndexContainer::const_iterator it = m_aiPlots.begin(); it != m_aiPlots.end(); ++it)
	{
		CvPlot* pPlot = GC.getMap().plotByIndex(*it);
		if (pPlot && pPlot->getResourceType(getTeam()) == eIndex)
		{
			iCount++;
		}
	}

	return iCount;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getTotalImprovementsBuilt() const
{
	return m_iTotalImprovementsBuilt;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeTotalImprovementsBuilt(int iChange)
{
	m_iTotalImprovementsBuilt = (m_iTotalImprovementsBuilt + iChange);
	CvAssert(getTotalImprovementsBuilt() >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getImprovementCount(ImprovementTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumImprovementInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiImprovementCount[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeImprovementCount(ImprovementTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumImprovementInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	m_paiImprovementCount.setAt(eIndex, m_paiImprovementCount[eIndex] + iChange);
	CvAssert(getImprovementCount(eIndex) >= 0);
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvPlayer::getTotalImprovementsBuilt(ImprovementTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumImprovementInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiTotalImprovementsBuilt[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeTotalImprovementsBuilt(ImprovementTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumImprovementInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	m_paiTotalImprovementsBuilt.setAt(eIndex, m_paiTotalImprovementsBuilt[eIndex] + iChange);
	CvAssert(getTotalImprovementsBuilt(eIndex) >= 0);
}
#endif


//	--------------------------------------------------------------------------------
int CvPlayer::getGreatPersonImprovementCount()
{
	int iCount = 0;
	for (int i = 0; i < GC.getNumImprovementInfos(); i++)
	{
		ImprovementTypes e = (ImprovementTypes)i;
		CvImprovementEntry* pInfo = GC.getImprovementInfo(e);
		if (pInfo && pInfo->IsCreatedByGreatPerson())
		{
			iCount += getImprovementCount(e);
		}
	}
	return iCount;
}


//	--------------------------------------------------------------------------------
int CvPlayer::getFreeBuildingCount(BuildingTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiFreeBuildingCount[eIndex];
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isBuildingFree(BuildingTypes eIndex)	const
{
	return (getFreeBuildingCount(eIndex) > 0);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeFreeBuildingCount(BuildingTypes eIndex, int iChange)
{
	CvCity* pLoopCity;
	int iOldFreeBuildingCount;
	int iLoop;

	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		iOldFreeBuildingCount = getFreeBuildingCount(eIndex);

		m_paiFreeBuildingCount.setAt(eIndex, m_paiFreeBuildingCount[eIndex] + iChange);
		CvAssert(getFreeBuildingCount(eIndex) >= 0);

		if(iOldFreeBuildingCount == 0)
		{
			CvAssertMsg(getFreeBuildingCount(eIndex) > 0, "getFreeBuildingCount(eIndex) is expected to be greater than 0");

			for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				pLoopCity->GetCityBuildings()->SetNumFreeBuilding(eIndex, 1);
			}
		}
		else if(getFreeBuildingCount(eIndex) == 0)
		{
			CvAssertMsg(iOldFreeBuildingCount > 0, "iOldFreeBuildingCount is expected to be greater than 0");

			for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				pLoopCity->GetCityBuildings()->SetNumFreeBuilding(eIndex, 0);
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Is ePromotion a free promotion?
int CvPlayer::GetFreePromotionCount(PromotionTypes ePromotion) const
{
	CvAssertMsg(ePromotion >= 0, "ePromotion is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePromotion < GC.getNumPromotionInfos(), "ePromotion is expected to be within maximum bounds (invalid Index)");
	return m_paiFreePromotionCount[ePromotion];
}

//	--------------------------------------------------------------------------------
/// Is ePromotion a free promotion?
bool CvPlayer::IsFreePromotion(PromotionTypes ePromotion)	const
{
	return (GetFreePromotionCount(ePromotion) > 0);
}

//	--------------------------------------------------------------------------------
/// Is ePromotion a free promotion?
void CvPlayer::ChangeFreePromotionCount(PromotionTypes ePromotion, int iChange)
{
	CvAssertMsg(ePromotion >= 0, "ePromotion is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePromotion < GC.getNumPromotionInfos(), "ePromotion is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		bool bWasFree = IsFreePromotion(ePromotion);

		m_paiFreePromotionCount.setAt(ePromotion, m_paiFreePromotionCount[ePromotion] + iChange);

		CvAssert(GetFreePromotionCount(ePromotion) >= 0);

		// This promotion is now set to be free, but wasn't before we called this function
		if(IsFreePromotion(ePromotion) && !bWasFree)
		{
			// Loop through Units
			CvUnit* pLoopUnit;

			int iLoop;
			for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
			{
				// Valid Promotion for this Unit?
				if(::IsPromotionValidForUnitCombatType(ePromotion, pLoopUnit->getUnitType()))
				{
					pLoopUnit->setHasPromotion(ePromotion, true);
				}

				else if(::IsPromotionValidForCivilianUnitType(ePromotion, pLoopUnit->getUnitType()))
				{
					pLoopUnit->setHasPromotion(ePromotion, true);
				}
			}
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getUnitCombatProductionModifiers(UnitCombatTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitCombatClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiUnitCombatProductionModifiers[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeUnitCombatProductionModifiers(UnitCombatTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitCombatClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiUnitCombatProductionModifiers.setAt(eIndex, m_paiUnitCombatProductionModifiers[eIndex] + iChange);
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getUnitCombatFreeExperiences(UnitCombatTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitCombatClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiUnitCombatFreeExperiences[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeUnitCombatFreeExperiences(UnitCombatTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitCombatClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiUnitCombatFreeExperiences.setAt(eIndex, m_paiUnitCombatFreeExperiences[eIndex] + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getUnitClassCount(UnitClassTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiUnitClassCount[eIndex];
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isUnitClassMaxedOut(UnitClassTypes eIndex, int iExtra) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eIndex);
	if(pkUnitClassInfo == NULL)
	{
		return false;
	}

#if defined(MOD_BALANCE_CORE)
	if(isUnitLimitPerCity(eIndex))
	{
		CvAssertMsg(getUnitClassCount(eIndex) <= (getNumCities() * pkUnitClassInfo->getUnitInstancePerCity()), "getUnitInstancePerCity is expected to be less than maximum bound of UnitInstancePerCity (invalid index)");
		return ((getUnitClassCount(eIndex) + iExtra) >= (getNumCities() * pkUnitClassInfo->getUnitInstancePerCity()));
	}
	else if(isNationalUnitClass(eIndex))
	{
		CvAssertMsg(getUnitClassCount(eIndex) <= pkUnitClassInfo->getMaxPlayerInstances(), "getUnitClassCount is expected to be less than maximum bound of MaxPlayerInstances (invalid index)");
		return ((getUnitClassCount(eIndex) + iExtra) >= pkUnitClassInfo->getMaxPlayerInstances());
	}
	else
	{
		return false;
	}
#else
	if(!isNationalUnitClass(eIndex))
	{
		return false;
	}

	CvAssertMsg(getUnitClassCount(eIndex) <= pkUnitClassInfo->getMaxPlayerInstances(), "getUnitClassCount is expected to be less than maximum bound of MaxPlayerInstances (invalid index)");

	return ((getUnitClassCount(eIndex) + iExtra) >= pkUnitClassInfo->getMaxPlayerInstances());
#endif
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeUnitClassCount(UnitClassTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	m_paiUnitClassCount.setAt(eIndex, m_paiUnitClassCount[eIndex] + iChange);
	CvAssert(getUnitClassCount(eIndex) >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getUnitClassMaking(UnitClassTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiUnitClassMaking[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeUnitClassMaking(UnitClassTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiUnitClassMaking.setAt(eIndex, m_paiUnitClassMaking[eIndex] + iChange);
		CvAssert(getUnitClassMaking(eIndex) >= 0);

		const CvCivilizationInfo& playerCivilizationInfo = getCivilizationInfo();
		UnitTypes eUnit = static_cast<UnitTypes>(playerCivilizationInfo.getCivilizationUnits(eIndex));
		CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
		if(pkUnitInfo)
		{
			// Builder Limit
			if(pkUnitInfo->GetWorkRate() > 0 && pkUnitInfo->GetDomainType() == DOMAIN_LAND)
			{
				ChangeNumBuilders(iChange);
			}

			// Update the amount of a Resource used up by Units in Production
			for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
			{
				ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);
				CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
				if(pkResource)
				{
					if(pkUnitInfo->GetResourceQuantityRequirement(iResourceLoop) > 0)
					{
						changeNumResourceUsed(eResource, iChange * pkUnitInfo->GetResourceQuantityRequirement(iResourceLoop));
					}
				}
			}

			if(GetID() == GC.getGame().getActivePlayer())
			{
				GC.GetEngineUserInterface()->setDirty(Help_DIRTY_BIT, true);
			}
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getUnitClassCountPlusMaking(UnitClassTypes eIndex) const
{
	return (getUnitClassCount(eIndex) + getUnitClassMaking(eIndex));
}


//	--------------------------------------------------------------------------------
int CvPlayer::getBuildingClassCount(BuildingClassTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiBuildingClassCount[eIndex];
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isBuildingClassMaxedOut(BuildingClassTypes eIndex, int iExtra) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eIndex);
	if(pkBuildingClassInfo == NULL)
	{
		CvAssertMsg(false, "This should never happen...");
		return false;
	}

	if(!isNationalWonderClass(*pkBuildingClassInfo))
	{
		return false;
	}

	CvAssertMsg(getBuildingClassCount(eIndex) <= (pkBuildingClassInfo->getMaxPlayerInstances() + pkBuildingClassInfo->getExtraPlayerInstances()), "BuildingClassCount is expected to be less than or match the number of max player instances plus extra player instances");

	return ((getBuildingClassCount(eIndex) + iExtra) >= (pkBuildingClassInfo->getMaxPlayerInstances() + pkBuildingClassInfo->getExtraPlayerInstances()));
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeBuildingClassCount(BuildingClassTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	m_paiBuildingClassCount.setAt(eIndex, m_paiBuildingClassCount[eIndex] + iChange);
	CvAssert(getBuildingClassCount(eIndex) >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getBuildingClassMaking(BuildingClassTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiBuildingClassMaking[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeBuildingClassMaking(BuildingClassTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiBuildingClassMaking.setAt(eIndex, m_paiBuildingClassMaking[eIndex] + iChange);
		CvAssert(getBuildingClassMaking(eIndex) >= 0);

		const BuildingTypes eBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eIndex);
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
		if(pkBuildingInfo)
		{
			// Update the amount of a Resource used up by Buildings in Production
			for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
			{
				const ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);
				CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);
				if(pkResourceInfo)
				{
					if(pkBuildingInfo->GetResourceQuantityRequirement(iResourceLoop) > 0)
					{
						changeNumResourceUsed(eResource, iChange * pkBuildingInfo->GetResourceQuantityRequirement(iResourceLoop));
					}
				}

			}
		}


		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Help_DIRTY_BIT, true);
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getBuildingClassCountPlusMaking(BuildingClassTypes eIndex) const
{
	return (getBuildingClassCount(eIndex) + getBuildingClassMaking(eIndex));
}


//	--------------------------------------------------------------------------------
// The following two functions are only used to keep track of how many Projects are in progress so we know what each player's Resource situation is
// Check out CvTeam::getProjectMaking() for something used more
int CvPlayer::getProjectMaking(ProjectTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiProjectMaking[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeProjectMaking(ProjectTypes eIndex, int iChange, CvCity* pCity)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiProjectMaking.setAt(eIndex, m_paiProjectMaking[eIndex] + iChange);
		CvAssert(getProjectMaking(eIndex) >= 0);

		// Update the amount of a Resource used up by Projects in Production
		for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
		{
			if(GC.getProjectInfo(eIndex)->GetResourceQuantityRequirement(iResourceLoop) > 0)
			{
				changeNumResourceUsed((ResourceTypes) iResourceLoop, iChange * GC.getProjectInfo(eIndex)->GetResourceQuantityRequirement(iResourceLoop));
			}
		}

		if (iChange > 0)
		{
			ProjectTypes eUtopia = (ProjectTypes)GC.getInfoTypeForString("PROJECT_UTOPIA_PROJECT", true);
			if (eUtopia == eIndex)
			{
				int iNumTurns = pCity != NULL ? pCity->getProductionTurnsLeft() : -1;
				PlayerTypes ePlayer;
				for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
				{
					ePlayer = (PlayerTypes)iPlayerLoop;

					if (GC.getGame().getActivePlayer() != ePlayer)
					{
						CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();
						if (pNotifications)
						{
							Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_PROJECT_STARTED");
							strText << getNameKey();
							strText << GC.getProjectInfo(eIndex)->GetDescription();
							strText << iNumTurns;
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_PROJECT_STARTED_S");
							strSummary << GC.getProjectInfo(eIndex)->GetDescription();
							pNotifications->Add(NOTIFICATION_CULTURE_VICTORY_WITHIN_ONE, strText.toUTF8(), strSummary.toUTF8(), -1, -1, ePlayer);
						}
					}
				}
			}
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getHurryCount(HurryTypes eIndex) const
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumHurryInfos());
	return m_paiHurryCount[eIndex];
}


//	--------------------------------------------------------------------------------
// Do we have access to this Hurry type?
bool CvPlayer::IsHasAccessToHurry(HurryTypes eIndex) const
{
	return (getHurryCount(eIndex) > 0);
}

//	--------------------------------------------------------------------------------
/// Can we use this Hurry RIGHT NOW?
bool CvPlayer::IsCanHurry(HurryTypes eIndex) const
{
	CvHurryInfo* pkHurryInfo = GC.getHurryInfo(eIndex);
	if(pkHurryInfo == NULL)
		return false;

	int iCost = GetHurryGoldCost(eIndex);

	// Can we pay for this Hurry?
	if(iCost < 0 || GetTreasury()->GetGold() < iCost)
	{
		return false;
	}

	// Science Rushing
	if(pkHurryInfo->getGoldPerBeaker() > 0)
	{
		return true;
	}

	// Culture Rushing
	if(pkHurryInfo->getGoldPerCulture() > 0)
	{
		// If we already have enough Culture for the next Policy, there's nothing to rush!
		if(getNextPolicyCost() > getJONSCulture())
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
/// How much Gold does it cost us to Hurry? (whatever the applicable item is)
int CvPlayer::GetHurryGoldCost(HurryTypes eHurry) const
{
	int iGold = -1;

	CvHurryInfo* pkHurryInfo = GC.getHurryInfo(eHurry);
	if(pkHurryInfo == NULL)
	{
		//This should never happen.
		return -1;
	}

	// Science Rushing
	if(pkHurryInfo->getGoldPerBeaker() > 0)
	{
		TechTypes eTech = GetPlayerTechs()->GetCurrentResearch();

		if(eTech != NO_TECH)
		{
			int iTotalCost = GET_TEAM(getTeam()).GetTeamTechs()->GetResearchCost(eTech);
			int iResearchLeft = GET_TEAM(getTeam()).GetTeamTechs()->GetResearchLeft(eTech);

			// Cost of Gold rushing based on the ORIGINAL Research price
			int iGoldForFullPrice = iTotalCost * pkHurryInfo->getGoldPerBeaker();
			iGoldForFullPrice = (int) pow((double) iGoldForFullPrice, (double) /*1.10f*/ GC.getHURRY_GOLD_TECH_EXPONENT());

			// Figure out the actual cost by comparing what's left to the original Research cost, and multiplying that by the amount to Gold rush the original cost
			iGold = (iGoldForFullPrice * iResearchLeft / iTotalCost);
		}
	}

	// Culture Rushing
	if(pkHurryInfo->getGoldPerCulture() > 0)
	{
		int iCurrentPolicyCost = getNextPolicyCost();

		if(iCurrentPolicyCost > 0)
		{
			int iCultureLeft = iCurrentPolicyCost - getJONSCulture();

			// Cost of Gold rushing based on the ORIGINAL Culture price
			int iGoldForFullPrice = iCurrentPolicyCost * pkHurryInfo->getGoldPerCulture();
			iGoldForFullPrice = (int) pow((double) iGoldForFullPrice, (double) /*1.10f*/ GC.getHURRY_GOLD_CULTURE_EXPONENT());

			// Figure out the actual cost by comparing what's left to the original Culture cost, and multiplying that by the amount to Gold rush the original cost
			iGold = (iGoldForFullPrice * iCultureLeft / iCurrentPolicyCost);
		}
	}

	return iGold;
}

//	--------------------------------------------------------------------------------
/// Hurry something!
void CvPlayer::DoHurry(HurryTypes eIndex)
{
	CvHurryInfo* pkHurryInfo = GC.getHurryInfo(eIndex);
	if(pkHurryInfo)
	{
		if(IsCanHurry(eIndex))
		{
			int iGoldCost = GetHurryGoldCost(eIndex);
			GetTreasury()->ChangeGold(-iGoldCost);

			// Science Rushing
			if(pkHurryInfo->getGoldPerBeaker() > 0)
			{
				TechTypes eTech = GetPlayerTechs()->GetCurrentResearch();

				GET_TEAM(getTeam()).setHasTech(eTech, true, GetID(), false, false);
			}

			// Culture Rushing
			if(pkHurryInfo->getGoldPerCulture() > 0)
			{
				setJONSCulture(getNextPolicyCost());
			}
		}
	}
}


//	--------------------------------------------------------------------------------
bool CvPlayer::canPopRush()
{
	return (m_iPopRushHurryCount > 0);
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeHurryCount(HurryTypes eIndex, int iChange)
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumHurryInfos());

	int oldHurryCount = m_paiHurryCount[eIndex];
	m_paiHurryCount.setAt(eIndex, m_paiHurryCount[eIndex] + iChange);
	CvAssert(getHurryCount(eIndex) >= 0);

	CvHurryInfo* pkHurryInfo = GC.getHurryInfo(eIndex);
	if(pkHurryInfo == NULL)
		return;

	// if we just went from 0 to 1 (or the reverse)
	if((oldHurryCount > 0) != (m_paiHurryCount[eIndex] > 0))
	{
		// does this hurry reduce population?
		if(pkHurryInfo->getProductionPerPopulation() > 0)
		{
			m_iPopRushHurryCount += iChange;
			CvAssert(m_iPopRushHurryCount >= 0);
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getHurryModifier(HurryTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumHurryInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiHurryModifier[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeHurryModifier(HurryTypes eIndex, int iChange)
{
	if(iChange != 0)
	{
		CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
		CvAssertMsg(eIndex < GC.getNumHurryInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
		m_paiHurryModifier.setAt(eIndex, m_paiHurryModifier[eIndex] + iChange);
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::setResearchingTech(TechTypes eIndex, bool bNewValue)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(m_pPlayerTechs->IsResearchingTech(eIndex) != bNewValue)
	{
		GetPlayerTechs()->SetResearchingTech(eIndex, bNewValue);

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Popup_DIRTY_BIT, true); // to check whether we still need the tech chooser popup
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getSpecialistExtraYield(SpecialistTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 expected to be >= 0");
	CvAssertMsg(eIndex1 < GC.getNumSpecialistInfos(), "eIndex1 expected to be < GC.getNumSpecialistInfos()");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 expected to be >= 0");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 expected to be < NUM_YIELD_TYPES");
	return m_ppaaiSpecialistExtraYield[eIndex1][eIndex2];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeSpecialistExtraYield(SpecialistTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 expected to be >= 0");
	CvAssertMsg(eIndex1 < GC.getNumSpecialistInfos(), "eIndex1 expected to be < GC.getNumSpecialistInfos()");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 expected to be >= 0");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 expected to be < NUM_YIELD_TYPES");

	if(iChange != 0)
	{
		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppaaiSpecialistExtraYield[eIndex1];
		yields[eIndex2] = (m_ppaaiSpecialistExtraYield[eIndex1][eIndex2] + iChange);
		m_ppaaiSpecialistExtraYield.setAt(eIndex1, yields);
		CvAssert(getSpecialistExtraYield(eIndex1, eIndex2) >= 0);

		updateExtraSpecialistYield();
	}
}


#if defined(MOD_API_UNIFIED_YIELDS) && defined(MOD_API_PLOT_YIELDS)
//	--------------------------------------------------------------------------------
int CvPlayer::getPlotYieldChange(PlotTypes eIndex1, YieldTypes eIndex2) const
{
	if (MOD_API_PLOT_YIELDS) {
		CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
		CvAssertMsg(eIndex1 < GC.getNumPlotInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
		CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
		CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
		return m_ppiPlotYieldChange[eIndex1][eIndex2];
	} else {
		return 0;
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::changePlotYieldChange(PlotTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	if (MOD_API_PLOT_YIELDS) {
		CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
		CvAssertMsg(eIndex1 < GC.getNumPlotInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
		CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
		CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

		if(iChange != 0)
		{
			CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

			Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiPlotYieldChange[eIndex1];
			yields[eIndex2] = (m_ppiPlotYieldChange[eIndex1][eIndex2] + iChange);
			m_ppiPlotYieldChange[eIndex1] = yields;
			CvAssert(getPlotYieldChange(eIndex1, eIndex2) >= 0);

			updateYield();
		}
	}
}
#endif

#if defined(MOD_API_UNIFIED_YIELDS)
//	--------------------------------------------------------------------------------
int CvPlayer::getFeatureYieldChange(FeatureTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiFeatureYieldChange[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeFeatureYieldChange(FeatureTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiFeatureYieldChange[eIndex1];
		yields[eIndex2] = (m_ppiFeatureYieldChange[eIndex1][eIndex2] + iChange);
		m_ppiFeatureYieldChange[eIndex1] = yields;
		CvAssert(getFeatureYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getCityYieldFromUnimprovedFeature(FeatureTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiCityYieldFromUnimprovedFeature[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeCityYieldFromUnimprovedFeature(FeatureTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number.");

		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiCityYieldFromUnimprovedFeature[eIndex1];
		yields[eIndex2] = (m_ppiCityYieldFromUnimprovedFeature[eIndex1][eIndex2] + iChange);
		m_ppiCityYieldFromUnimprovedFeature[eIndex1] = yields;
		CvAssert(getCityYieldFromUnimprovedFeature(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getUnimprovedFeatureYieldChange(FeatureTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiUnimprovedFeatureYieldChange[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeUnimprovedFeatureYieldChange(FeatureTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number.");

		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiUnimprovedFeatureYieldChange[eIndex1];
		yields[eIndex2] = (m_ppiUnimprovedFeatureYieldChange[eIndex1][eIndex2] + iChange);
		m_ppiUnimprovedFeatureYieldChange[eIndex1] = yields;
		CvAssert(getUnimprovedFeatureYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getResourceYieldChange(ResourceTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumResourceInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiResourceYieldChange[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceYieldChange(ResourceTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumResourceInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiResourceYieldChange[eIndex1];
		yields[eIndex2] = (m_ppiResourceYieldChange[eIndex1][eIndex2] + iChange);
		m_ppiResourceYieldChange[eIndex1] = yields;
		CvAssert(getResourceYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getTerrainYieldChange(TerrainTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumTerrainInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiTerrainYieldChange[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeTerrainYieldChange(TerrainTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumTerrainInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiTerrainYieldChange[eIndex1];
		yields[eIndex2] = (m_ppiTerrainYieldChange[eIndex1][eIndex2] + iChange);
		m_ppiTerrainYieldChange[eIndex1] = yields;
		CvAssert(getTerrainYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getTradeRouteYieldChange(DomainTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < NUM_DOMAIN_TYPES, "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiTradeRouteYieldChange[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeTradeRouteYieldChange(DomainTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < NUM_DOMAIN_TYPES, "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiTradeRouteYieldChange[eIndex1];
		yields[eIndex2] = (m_ppiTradeRouteYieldChange[eIndex1][eIndex2] + iChange);
		m_ppiTradeRouteYieldChange[eIndex1] = yields;
		CvAssert(getTradeRouteYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getSpecialistYieldChange(SpecialistTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumSpecialistInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiSpecialistYieldChange[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeSpecialistYieldChange(SpecialistTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumSpecialistInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiSpecialistYieldChange[eIndex1];
		yields[eIndex2] = (m_ppiSpecialistYieldChange[eIndex1][eIndex2] + iChange);
		m_ppiSpecialistYieldChange[eIndex1] = yields;
		CvAssert(getSpecialistYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatPersonExpendedYield(GreatPersonTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumGreatPersonInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiGreatPersonExpendedYield[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGreatPersonExpendedYield(GreatPersonTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumGreatPersonInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiGreatPersonExpendedYield[eIndex1];
		yields[eIndex2] = (m_ppiGreatPersonExpendedYield[eIndex1][eIndex2] + iChange);
		m_ppiGreatPersonExpendedYield[eIndex1] = yields;
		CvAssert(getGreatPersonExpendedYield(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGoldenAgeGreatPersonRateModifier(GreatPersonTypes eGreatPerson) const
{
	CvAssertMsg(eGreatPerson >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eGreatPerson < GC.getNumGreatPersonInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piGoldenAgeGreatPersonRateModifier[eGreatPerson];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGoldenAgeGreatPersonRateModifier(GreatPersonTypes eGreatPerson, int iChange)
{
	CvAssertMsg(eGreatPerson >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eGreatPerson < GC.getNumGreatPersonInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_piGoldenAgeGreatPersonRateModifier[eGreatPerson] += iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetYieldFromKills(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piYieldFromKills[eYield];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromKills(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_piYieldFromKills[eYield] += iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetYieldFromBarbarianKills(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piYieldFromBarbarianKills[eYield];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromBarbarianKills(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_piYieldFromBarbarianKills[eYield] += iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetYieldChangeTradeRoute(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piYieldChangeTradeRoute[eYield];
}

void CvPlayer::ChangeYieldChangeTradeRoute(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_piYieldChangeTradeRoute[eYield] += iChange;

		updateYield();
	}
}

int CvPlayer::GetYieldChangesNaturalWonder(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piYieldChangesNaturalWonder[eYield];
}

void CvPlayer::ChangeYieldChangesNaturalWonder(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_piYieldChangesNaturalWonder[eYield] += iChange;

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetYieldChangesPerReligionTimes100(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	return m_piYieldChangesPerReligion[eYield];
}

void CvPlayer::ChangeYieldChangesPerReligionTimes100(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_piYieldChangesPerReligion[eYield] += iChange;

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetYieldChangeWorldWonder(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piYieldChangeWorldWonder[eYield];
}

void CvPlayer::ChangeYieldChangeWorldWonder(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_piYieldChangeWorldWonder[eYield] += iChange;

		updateYield();
	}
}

int CvPlayer::GetYieldFromMinorDemand(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piYieldFromMinorDemand[eYield];
}

void CvPlayer::ChangeYieldFromMinorDemand(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_piYieldFromMinorDemand[eYield] += iChange;
	}
}

int CvPlayer::GetYieldFromWLTKD(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piYieldFromWLTKD[eYield];
}

void CvPlayer::ChangeYieldFromWLTKD(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_piYieldFromWLTKD[eYield] += iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getBuildingClassYieldChange(BuildingClassTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumBuildingClassInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiBuildingClassYieldChange[eIndex1][eIndex2];
}

#if defined(MOD_BALANCE_CORE)
// (Corp) Note to future modders: if you think this works as you expect, you're wrong. just ignore it. Use ::GetBuildingClassYieldChange() instead (note the capital), or fix this so it's functional.
// grrrr....
#endif
//	--------------------------------------------------------------------------------
void CvPlayer::changeBuildingClassYieldChange(BuildingClassTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumBuildingClassInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiBuildingClassYieldChange[eIndex1];
		yields[eIndex2] = (m_ppiBuildingClassYieldChange[eIndex1][eIndex2] + iChange);
		m_ppiBuildingClassYieldChange.setAt(eIndex1, yields);
		CvAssert(getBuildingClassYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}
#endif

#if defined(MOD_API_UNIFIED_YIELDS) && defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
/// Does the player get a great person rate modifier from having a monopoly?
//	--------------------------------------------------------------------------------
int CvPlayer::getSpecificGreatPersonRateModifierFromMonopoly(GreatPersonTypes eGreatPerson, MonopolyTypes eMonopoly) const
{
	CvAssertMsg(eGreatPerson >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eGreatPerson < GC.getNumGreatPersonInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	CvAssertMsg(eMonopoly >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eMonopoly < NUM_MONOPOLY_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (eGreatPerson != NO_GREATPERSON && eMonopoly != NO_MONOPOLY)
	{
		std::map<GreatPersonTypes, std::map<MonopolyTypes, int>>::const_iterator itGreatPerson = m_ppiSpecificGreatPersonRateModifierFromMonopoly.find(eGreatPerson);
		if (itGreatPerson != m_ppiSpecificGreatPersonRateModifierFromMonopoly.end())
		{
			std::map<MonopolyTypes, int>::const_iterator itMonopoly = itGreatPerson->second.find(eMonopoly);
			if (itMonopoly != itGreatPerson->second.end())
			{
				return itMonopoly->second;
			}
		}
	}

	return 0;
}

/// Overload to sum up modifiers from both global (including global monopoly mod percent) and strategic monopolies, for convenience
//	--------------------------------------------------------------------------------
int CvPlayer::getSpecificGreatPersonRateModifierFromMonopoly(GreatPersonTypes eGreatPerson) const
{
	CvAssertMsg(eGreatPerson >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eGreatPerson < GC.getNumGreatPersonInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	int iMod = 0;
	if (eGreatPerson != NO_GREATPERSON)
	{
		for (int iI = 0; iI < NUM_MONOPOLY_TYPES; iI++)
		{
			MonopolyTypes eMonopoly = (MonopolyTypes)iI;
			if (eMonopoly != NO_MONOPOLY)
			{
				iMod += getSpecificGreatPersonRateModifierFromMonopoly(eGreatPerson, eMonopoly);
				if (eMonopoly == MONOPOLY_GLOBAL)
				{
					iMod += GetMonopolyModPercent();
				}
			}
		}
	}

	return iMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeSpecificGreatPersonRateModifierFromMonopoly(GreatPersonTypes eGreatPerson, MonopolyTypes eMonopoly, int iChange)
{
	CvAssertMsg(eGreatPerson >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eGreatPerson < GC.getNumGreatPersonInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	CvAssertMsg(eMonopoly >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eMonopoly < NUM_MONOPOLY_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0 && eGreatPerson != NO_GREATPERSON && eMonopoly != NO_MONOPOLY)
	{
		m_ppiSpecificGreatPersonRateModifierFromMonopoly[eGreatPerson][eMonopoly] += iChange;
	}
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getImprovementYieldChange(ImprovementTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumImprovementInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppaaiImprovementYieldChange[eIndex1][eIndex2];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeImprovementYieldChange(ImprovementTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumImprovementInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppaaiImprovementYieldChange[eIndex1];
		yields[eIndex2] = (m_ppaaiImprovementYieldChange[eIndex1][eIndex2] + iChange);
		m_ppaaiImprovementYieldChange.setAt(eIndex1, yields);
		CvAssert(getImprovementYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::removeFromArmy(int iArmyID, int iID)
{
	CvArmyAI* pThisArmyAI = getArmyAI(iArmyID);
	if(pThisArmyAI)
		return pThisArmyAI->RemoveUnit(iID);

	return false;
}


//	---------------------------------------------------------------------------
bool CvPlayer::removeFromArmy(int iID)
{
	// for all the army AIs
	int iLoop;
	for(CvArmyAI* pLoopArmyAI = firstArmyAI(&iLoop); pLoopArmyAI != NULL; pLoopArmyAI = nextArmyAI(&iLoop))
	{
		//unit can only be in one army
		if (removeFromArmy(pLoopArmyAI->GetID(), iID))
			return true;
	}

	return false;
}

//	---------------------------------------------------------------------------
//	Finds the path length from this tech type to one you already know (FIXED)
//	This one doesn't count technologies multiple times during recursive calls!
//	A temporary buffer is used to mark techs already visited, so they can be 
//	counted only once when the recursive calls end.
int CvPlayer::findPathLengthNew(TechTypes eTech, int pTechs[]) const
{
	CvAssertMsg(eTech != NO_TECH, "Tech is not assigned a valid value");
	int i;

	// if buffer is empty then initialize, start recursive calls and count techs at the end
	if (pTechs == NULL)
	{
		int pTechBuffer[200]; // ideally need to count all techs and allocate a dynamic array
		std::fill(pTechBuffer, pTechBuffer+200, 0);
		(void) findPathLengthNew(eTech, pTechBuffer);
		int iNumTechs = 0;
		for (i=0; i<200; i++) iNumTechs += pTechBuffer[i]; // count all techs that we visited during recursive calls
		return iNumTechs;
	}

	// if buffer is not empty then mark the tech as required and analyze prerequisite techs
	CvTechEntry* pkTechInfo = GC.getTechInfo(eTech);
	if(pkTechInfo == NULL)
		return 0;
	if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech(eTech)) // We have this tech
		return 0;
	
	// this tech is not yet FULLY researched, so mark it; always 1, so they won't be counted multiple times!
	pTechs[(int) eTech] = 1;
	//	Cycle through the AND paths and mark their techs
	for(i = 0; i < GC.getNUM_AND_TECH_PREREQS(); i++)
	{
		TechTypes ePreReq = (TechTypes)pkTechInfo->GetPrereqAndTechs(i);
		if(ePreReq != NO_TECH)
			(void) findPathLengthNew(ePreReq, pTechs);
	}

	// OR paths omitted as of now, not used

	return 0;
}

//	---------------------------------------------------------------------------
//	Finds the path length from this tech type to one you already know
//	If bCost is false, then it returns number of techs that need to be researched to acquire eTech
//	If bCost is true, then it returns the cost of a currently researched tech
int CvPlayer::findPathLength(TechTypes eTech, bool bCost) const
{
	int i;
	int iNumSteps = 0;
	int iShortestPath = 0;
	int iPathLength = 0;
	TechTypes ePreReq;
	TechTypes eShortestOr;

	CvTechEntry* pkTechInfo = GC.getTechInfo(eTech);
	if(pkTechInfo == NULL)
		return 0;

	if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech(eTech)) // We have this tech
		return 0;

	/* WRONG - MULTIPLE COUNTS
	//	Cycle through the and paths and add up their tech lengths
	for(i = 0; i < GC.getNUM_AND_TECH_PREREQS(); i++)
	{
		ePreReq = (TechTypes)pkTechInfo->GetPrereqAndTechs(i);

		if(ePreReq != NO_TECH)
		{
			iPathLength += findPathLength(ePreReq, bCost);
		}
	}
	*/
	iPathLength = findPathLengthNew(eTech, NULL);

	eShortestOr = NO_TECH;
	iShortestPath = INT_MAX;
	//	Find the shortest OR tech
	for(i = 0; i < GC.getNUM_OR_TECH_PREREQS(); i++)
	{
		//	Grab the tech
		ePreReq = (TechTypes)pkTechInfo->GetPrereqOrTechs(i);

		//	If this is a valid tech
		if(ePreReq != NO_TECH)
		{
			//	Recursively find the path length (takes into account all ANDs)
			//iNumSteps = findPathLength(ePreReq, bCost);
			iNumSteps = findPathLengthNew(ePreReq, NULL);

			//	If the prereq is a valid tech and its the current shortest, mark it as such
			if(iNumSteps < iShortestPath)
			{
				eShortestOr = ePreReq;
				iShortestPath = iNumSteps;
			}
		}
	}

	//	If the shortest OR is a valid tech, add the steps to it...
	if(eShortestOr != NO_TECH)
	{
		iPathLength += iShortestPath;
	}

	//return (iPathLength + ((bCost) ? GET_TEAM(getTeam()).GetTeamTechs()->GetResearchCost(eTech) : 1));
	return bCost ? (GET_TEAM(getTeam()).GetTeamTechs()->GetResearchCost(eTech)) : iPathLength;
}


//	--------------------------------------------------------------------------------
//	Function specifically for python/tech chooser screen
int CvPlayer::getQueuePosition(TechTypes eTech) const
{
	int i = 1;
	const CLLNode<TechTypes>* pResearchNode;

	for(pResearchNode = headResearchQueueNode(); pResearchNode; pResearchNode = nextResearchQueueNode(pResearchNode))
	{
		if(pResearchNode->m_data == eTech)
		{
			return i;
		}
		i++;
	}

	return -1;
}


//	--------------------------------------------------------------------------------
void CvPlayer::clearResearchQueue()
{
	int iI;

	m_researchQueue.clear();

	for(iI = 0; iI < GC.getNumTechInfos(); iI++)
	{
		setResearchingTech(((TechTypes)iI), false);
	}

	if(getTeam() == GC.getGame().getActiveTeam())
	{
		GC.GetEngineUserInterface()->setDirty(ResearchButtons_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(Score_DIRTY_BIT, true);
	}
}


//	--------------------------------------------------------------------------------
//	Pushes research onto the queue.  If it is an append if will put it
//	and its pre-reqs into the queue.  If it is not an append it will change
//	research immediately and should be used with clear.  Clear will clear the entire queue.
bool CvPlayer::pushResearch(TechTypes eTech, bool bClear)
{
	int i;
	int iNumSteps;
	int iShortestPath;
	bool bOrPrereqFound;
	TechTypes ePreReq;
	TechTypes eShortestOr;

	CvAssertMsg(eTech != NO_TECH, "Tech is not assigned a valid value");

	CvTechEntry* pkTechInfo = GC.getTechInfo(eTech);
	if(pkTechInfo == NULL)
		return false;


	if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech(eTech) || m_pPlayerTechs->IsResearchingTech(eTech))
	{
		//	We have this tech, no reason to add this to the pre-reqs
		return true;
	}

	if(!GetPlayerTechs()->CanEverResearch(eTech))
	{
		return false;
	}

	//	Pop the entire queue...
	if(bClear)
	{
		clearResearchQueue();
	}

	//	Add in all the pre-reqs for the and techs...
	for(i = 0; i < GC.getNUM_AND_TECH_PREREQS(); i++)
	{
		ePreReq = (TechTypes)pkTechInfo->GetPrereqAndTechs(i);

		if(ePreReq != NO_TECH)
		{
			if(!pushResearch(ePreReq))
			{
				return false;
			}
		}
	}

	// Will return the shortest path of all the or techs.  Tie breaker goes to the first one...
	eShortestOr = NO_TECH;
	iShortestPath = INT_MAX;
	bOrPrereqFound = false;
	//	Cycle through all the OR techs
	for(i = 0; i < GC.getNUM_OR_TECH_PREREQS(); i++)
	{
		ePreReq = (TechTypes)pkTechInfo->GetPrereqOrTechs(i);

		if(ePreReq != NO_TECH)
		{
			bOrPrereqFound = true;

			//	If the pre-req exists, and we have it, it is the shortest path, get out, we're done
			if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech(ePreReq))
			{
				eShortestOr = ePreReq;
				break;
			}

			if(GetPlayerTechs()->CanEverResearch(ePreReq))
			{
				//	Find the length of the path to this pre-req
				iNumSteps = findPathLength(ePreReq);

				//	If this pre-req is a valid tech, and its the shortest current path, set it as such
				if(iNumSteps < iShortestPath)
				{
					eShortestOr = ePreReq;
					iShortestPath = iNumSteps;
				}
			}
		}
	}

	//	If the shortest path tech is valid, push it (and its children) on to the research queue recursively
	if(eShortestOr != NO_TECH)
	{
		if(!pushResearch(eShortestOr))
		{
			return false;
		}
	}
	else if(bOrPrereqFound)
	{
		return false;
	}

	//	Insert this tech at the end of the queue
	m_researchQueue.insertAtEnd(eTech);

	setResearchingTech(eTech, true);

	//	Set the dirty bits
	if(getTeam() == GC.getGame().getActiveTeam())
	{
		GC.GetEngineUserInterface()->setDirty(ResearchButtons_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(Score_DIRTY_BIT, true);
	}
	return true;
}


//	--------------------------------------------------------------------------------
//	If bHead is true we delete the entire queue...
void CvPlayer::popResearch(TechTypes eTech)
{
	CLLNode<TechTypes>* pResearchNode;

	for(pResearchNode = headResearchQueueNode(); pResearchNode; pResearchNode = nextResearchQueueNode(pResearchNode))
	{
		if(pResearchNode->m_data == eTech)
		{
			m_researchQueue.deleteNode(pResearchNode);
			break;
		}
	}

	setResearchingTech(eTech, false);

	if(getTeam() == GC.getGame().getActiveTeam())
	{
		GC.GetEngineUserInterface()->setDirty(ResearchButtons_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(Score_DIRTY_BIT, true);
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getLengthResearchQueue() const
{
	return m_researchQueue.getLength();
}


//	--------------------------------------------------------------------------------
CLLNode<TechTypes>* CvPlayer::nextResearchQueueNode(CLLNode<TechTypes>* pNode)
{
	return m_researchQueue.next(pNode);
}

//	--------------------------------------------------------------------------------
const CLLNode<TechTypes>* CvPlayer::nextResearchQueueNode(const CLLNode<TechTypes>* pNode) const
{
	return m_researchQueue.next(pNode);
}

//	--------------------------------------------------------------------------------
CLLNode<TechTypes>* CvPlayer::headResearchQueueNode()
{
	return m_researchQueue.head();
}

//	--------------------------------------------------------------------------------
const CLLNode<TechTypes>* CvPlayer::headResearchQueueNode() const
{
	return m_researchQueue.head();
}

//	--------------------------------------------------------------------------------
CLLNode<TechTypes>* CvPlayer::tailResearchQueueNode()
{
	return m_researchQueue.tail();
}


//	--------------------------------------------------------------------------------
void CvPlayer::addCityName(const CvString& szName)
{
	m_cityNames.insertAtEnd(szName);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getNumCityNames() const
{
	return m_cityNames.getLength();
}


//	--------------------------------------------------------------------------------
CvString CvPlayer::getCityName(int iIndex) const
{
	CLLNode<CvString>* pCityNameNode;

	pCityNameNode = m_cityNames.nodeNum(iIndex);

	if(pCityNameNode != NULL)
	{
		return pCityNameNode->m_data;
	}
	else
	{
		return "";
	}
}

//	--------------------------------------------------------------------------------
CLLNode<CvString>* CvPlayer::nextCityNameNode(CLLNode<CvString>* pNode)
{
	return m_cityNames.next(pNode);
}

//	--------------------------------------------------------------------------------
const CLLNode<CvString>* CvPlayer::nextCityNameNode(const CLLNode<CvString>* pNode) const
{
	return m_cityNames.next(pNode);
}

//	--------------------------------------------------------------------------------
CLLNode<CvString>* CvPlayer::headCityNameNode()
{
	return m_cityNames.head();
}

//	--------------------------------------------------------------------------------
const CLLNode<CvString>* CvPlayer::headCityNameNode() const
{
	return m_cityNames.head();
}

//	--------------------------------------------------------------------------------
CvCity* CvPlayer::firstCity(int* pIterIdx, bool bRev)
{
	if (bRev)
		*pIterIdx = m_cities.GetCount()-1;
	else
		*pIterIdx = 0;
	return m_cities.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
const CvCity* CvPlayer::firstCity(int* pIterIdx, bool bRev) const
{
	if (bRev)
		*pIterIdx = m_cities.GetCount()-1;
	else
		*pIterIdx = 0;
	return m_cities.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
CvCity* CvPlayer::nextCity(int* pIterIdx, bool bRev)
{
	if (bRev)
		(*pIterIdx)--;
	else
		(*pIterIdx)++;

	return m_cities.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
const CvCity* CvPlayer::nextCity(int* pIterIdx, bool bRev) const
{
	if (bRev)
		(*pIterIdx)--;
	else
		(*pIterIdx)++;

	return m_cities.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
#if defined(MOD_BALANCE_CORE)
CvCity* CvPlayer::nextCity(const CvCity* pCurrent, bool bRev)
{
	int iIdx = m_cities.GetIndexForID(pCurrent->GetID());

	if (iIdx<0)
		return NULL;

	if (bRev)
		iIdx--;
	else
		iIdx++;

	return m_cities.GetAt(iIdx);
}

//	--------------------------------------------------------------------------------
const CvCity* CvPlayer::nextCity(const CvCity* pCurrent, bool bRev) const
{
	int iIdx = m_cities.GetIndexForID(pCurrent->GetID());

	if (iIdx<0)
		return NULL;

	if (bRev)
		iIdx--;
	else
		iIdx++;

	return m_cities.GetAt(iIdx);
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getNumCities() const
{
	return m_cities.GetCount();
}

//	--------------------------------------------------------------------------------
CvCity* CvPlayer::getCity(int iID) const
{
	return(m_cities.Get(iID));
}

//	--------------------------------------------------------------------------------
CvCity* CvPlayer::addCity()
{
	m_iNumUnitsSuppliedCached = -1;
	return(m_cities.Add());
}

//	--------------------------------------------------------------------------------
void CvPlayer::deleteCity(int iID)
{
	m_cities.Remove(iID);
	m_iNumUnitsSuppliedCached = -1;

	GC.getGame().SetClosestCityMapDirty();

#if defined(MOD_BALANCE_CORE)
	int iLoop=0;
	for (CvCity* pCity=firstCity(&iLoop); pCity!=NULL; pCity=nextCity(&iLoop))
		pCity->UpdateClosestFriendlyNeighbors();
#endif
}

int CvPlayer::GetCityDistanceInEstimatedTurns( const CvPlot* pPlot ) const
{
	if ( isMajorCiv() )
		return GC.getGame().GetClosestCityDistanceInTurns( pPlot, GetID() );

	//for minors we fake it
	CvCity* pCapital = getCapitalCity();
	if (pCapital && pPlot)
		return plotDistance(*pPlot, *pCapital->plot()) / 2;

	return INT_MAX;
}

CvCity* CvPlayer::GetClosestCityByEstimatedTurns( const CvPlot* pPlot ) const
{
	//careful, player-specific GetClosestCity only works for majors (because of performance)
	if ( isMajorCiv() )
		return GC.getGame().GetClosestCityByEstimatedTurns( pPlot, GetID() );

	//for minors just assume they have only one city (99% correct)
	return getCapitalCity();
}

int CvPlayer::GetCityDistanceInPlots(const CvPlot* pPlot) const
{
	if ( isMajorCiv() )
		return GC.getGame().GetClosestCityDistanceInPlots( pPlot, GetID() );

	//for minors we fake it
	CvCity* pCapital = getCapitalCity();
	if (pCapital && pPlot)
		return plotDistance(*pPlot, *pCapital->plot()) / 2;

	return INT_MAX;
}

CvCity* CvPlayer::GetClosestCityByPlots(const CvPlot* pPlot) const
{
	if ( isMajorCiv() )
		return GC.getGame().GetClosestCityByPlots( pPlot, GetID() );

	//for minors just assume they have only one city (99% correct)
	return getCapitalCity();
}

//	--------------------------------------------------------------------------------
CvCity* CvPlayer::GetFirstCityWithBuildingClass(BuildingClassTypes eBuildingClass)
{
	CvCity *pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		const CvCivilizationInfo& playerCivilizationInfo = getCivilizationInfo();
		BuildingTypes eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings((BuildingClassTypes)eBuildingClass);
		if (eBuilding != NO_BUILDING)
		{
			if (pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
			{
				return pLoopCity;
			}
		}
	}
	return false;
}

//	--------------------------------------------------------------------------------
const CvUnit* CvPlayer::firstUnit(int* pIterIdx, bool bRev) const
{
	if (bRev)
		*pIterIdx = m_units.GetCount()-1;
	else
		*pIterIdx = 0;
	return m_units.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
CvUnit* CvPlayer::firstUnit(int* pIterIdx, bool bRev)
{
	if (bRev)
		*pIterIdx = m_units.GetCount()-1;
	else
		*pIterIdx = 0;
	return m_units.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
const CvUnit* CvPlayer::nextUnit(int* pIterIdx, bool bRev) const
{
	if (bRev)
		(*pIterIdx)--;
	else
		(*pIterIdx)++;
	return m_units.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
CvUnit* CvPlayer::nextUnit(int* pIterIdx, bool bRev)
{
	if (bRev)
		(*pIterIdx)--;
	else
		(*pIterIdx)++;
	return m_units.GetAt(*pIterIdx);
}

#if defined(MOD_BALANCE_CORE)
CvUnit* CvPlayer::nextUnit(const CvUnit* pCurrent, bool bRev)
{
	int iIdx = m_units.GetIndexForID(pCurrent->GetID());

	if (iIdx<0)
		return NULL;

	if (bRev)
		iIdx--;
	else
		iIdx++;

	return m_units.GetAt(iIdx);
}

//	--------------------------------------------------------------------------------
const CvUnit* CvPlayer::nextUnit(const CvCity* pCurrent, bool bRev) const
{
	int iIdx = m_units.GetIndexForID(pCurrent->GetID());

	if (iIdx<0)
		return NULL;

	if (bRev)
		iIdx--;
	else
		iIdx++;

	return m_units.GetAt(iIdx);
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::getNumUnits() const
{
	return m_units.GetCount();
}


//	--------------------------------------------------------------------------------
CvUnit* CvPlayer::getUnit(int iID) const
{
#if defined(MOD_BALANCE_CORE)
	//spread it out a little for an easy breakpoint
	CvUnit* pUnit = m_units.Get(iID);
	return pUnit;
#else
	return (m_units.GetAt(iID));
#endif
}

//	--------------------------------------------------------------------------------
CvUnit* CvPlayer::addUnit()
{
	CvUnit* pResult = m_units.Add();

	//debugging ...
	for (int iIdx = 0; iIdx < m_units.GetCount()-1; iIdx++)
	{
		if (m_units.GetAt(iIdx)==pResult)
			OutputDebugString("inconsistent state: double unit pointer!\n");
	}

	return pResult;
}


//	--------------------------------------------------------------------------------
void CvPlayer::deleteUnit(int iID)
{
	m_units.Remove(iID);
}


//	--------------------------------------------------------------------------------
const CvArmyAI* CvPlayer::firstArmyAI(int* pIterIdx, bool bRev) const
{
	if (bRev)
		*pIterIdx = m_armyAIs.GetCount()-1;
	else
		*pIterIdx = 0;
	return m_armyAIs.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
CvArmyAI* CvPlayer::firstArmyAI(int* pIterIdx, bool bRev)
{
	if (bRev)
		*pIterIdx = m_armyAIs.GetCount()-1;
	else
		*pIterIdx = 0;	
	return m_armyAIs.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
const CvArmyAI* CvPlayer::nextArmyAI(int* pIterIdx, bool bRev) const
{
	if (bRev)
		(*pIterIdx)--;
	else
		(*pIterIdx)++;
	return m_armyAIs.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
CvArmyAI* CvPlayer::nextArmyAI(int* pIterIdx, bool bRev)
{
	if (bRev)
		(*pIterIdx)--;
	else
		(*pIterIdx)++;
	return m_armyAIs.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNumArmyAIs() const
{
	return m_armyAIs.GetCount();
}


//	--------------------------------------------------------------------------------
const CvArmyAI* CvPlayer::getArmyAI(int iID) const
{
	return ((CvArmyAI*)(m_armyAIs.Get(iID)));
}

//	--------------------------------------------------------------------------------
CvArmyAI* CvPlayer::getArmyAI(int iID)
{
	return ((CvArmyAI*)(m_armyAIs.Get(iID)));
}


//	--------------------------------------------------------------------------------
CvArmyAI* CvPlayer::addArmyAI()
{
	CvArmyAI* pArmy = m_armyAIs.Add();
	if (pArmy)
		pArmy->SetOwner(m_eID);
	return pArmy;
}


//	--------------------------------------------------------------------------------
void CvPlayer::deleteArmyAI(int iID)
{
	bool bRemoved = m_armyAIs.Remove(iID);
	DEBUG_VARIABLE(bRemoved);
	CvAssertMsg(bRemoved, "could not find army, delete failed");
}


//	--------------------------------------------------------------------------------
const CvAIOperation* CvPlayer::getAIOperation(int iID) const
{
	std::map<int, CvAIOperation*>::const_iterator it = m_AIOperations.find(iID);
	if(it != m_AIOperations.end())
	{
		return it->second;
	}
	return 0;
}

//	--------------------------------------------------------------------------------
CvAIOperation* CvPlayer::getFirstAIOperation()
{
	CvAIOperation* rtnValue = NULL;

	m_CurrentOperation = m_AIOperations.begin();
	if(m_CurrentOperation != m_AIOperations.end())
	{
		rtnValue = m_CurrentOperation->second;
	}
	return rtnValue;
}

//	--------------------------------------------------------------------------------
CvAIOperation* CvPlayer::getNextAIOperation()
{
	CvAIOperation* rtnValue = NULL;

	if(m_CurrentOperation != m_AIOperations.end())
	{
		++m_CurrentOperation;
		if(m_CurrentOperation != m_AIOperations.end())
		{
			rtnValue = m_CurrentOperation->second;
		}
	}
	return rtnValue;
}

//	--------------------------------------------------------------------------------
CvAIOperation* CvPlayer::getAIOperation(int iID)
{
	std::map<int, CvAIOperation*>::iterator it = m_AIOperations.find(iID);
	if(it != m_AIOperations.end())
	{
		return it->second;
	}
	return 0;
}


//	--------------------------------------------------------------------------------
CvAIOperation* CvPlayer::addAIOperation(int OperationType, PlayerTypes eEnemy, int iArea, CvCity* pTarget, CvCity* pMuster, bool bOceanMoves)
{
	CvAIOperation* pNewOperation = CvAIOperation::CreateOperation((AIOperationTypes) OperationType);
	if (!pNewOperation)
		return NULL;

	//because of stupidity, we need to enable CvPlayer::getOperation() before initializing the operation
	m_AIOperations.insert(std::make_pair(m_iNextOperationID.get(), pNewOperation));

	//check if initialization works out
	pNewOperation->Init(m_iNextOperationID, m_eID, eEnemy, iArea, pTarget, pMuster, bOceanMoves);
	if (pNewOperation->GetOperationState() == AI_OPERATION_STATE_ABORTED || pNewOperation->GetOperationState() == AI_OPERATION_STATE_INVALID)
	{
		pNewOperation->LogOperationEnd();
		deleteAIOperation(pNewOperation->GetID());
		return NULL;
	}

	//success
	m_iNextOperationID++;

	return pNewOperation;
}

//	--------------------------------------------------------------------------------
void CvPlayer::deleteAIOperation(int iID)
{
	std::map<int, CvAIOperation*>::iterator it = m_AIOperations.find(iID);
	if(it != m_AIOperations.end())
	{
		delete(it->second);
		m_AIOperations.erase(it);
	}
	else
	{
		CvAssertMsg(false, "could not find operation, delete failed");
	}
}

bool CvPlayer::StopAllLandOffensiveOperationsAgainstPlayer(PlayerTypes ePlayer, bool bIncludeSneakOps, AIOperationAbortReason eReason)
{
	bool bFoundOne = false;

	// loop through all entries looking for match
	std::map<int , CvAIOperation*>::iterator iter;
	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
	{
		CvAIOperation* pThisOperation = iter->second;

		if (pThisOperation->GetOperationState() == AI_OPERATION_STATE_SUCCESSFUL_FINISH)
			continue;

		if(pThisOperation->IsOffensive() && !pThisOperation->IsNavalOperation() && pThisOperation->GetOperationState() != AI_OPERATION_STATE_ABORTED)
		{
			if( (ePlayer == NO_PLAYER && pThisOperation->GetEnemy() != BARBARIAN_PLAYER) || ePlayer == pThisOperation->GetEnemy())
			{
				if (bIncludeSneakOps || !pThisOperation->IsAllowedDuringPeace())
				{
					bFoundOne = true;
					pThisOperation->SetToAbort(eReason);
				}
			}
		}
	}

	return bFoundOne;
}

int CvPlayer::GetNumOffensiveOperations(DomainTypes eDomain)
{
	int iNum = 0;
	// loop through all entries looking for match
	std::map<int , CvAIOperation*>::iterator iter;
	for (iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
	{
		CvAIOperation* pThisOperation = iter->second;
		if (!pThisOperation->IsDefensive() && pThisOperation->GetOperationState() != AI_OPERATION_STATE_ABORTED)
		{
			if (eDomain == DOMAIN_SEA && pThisOperation->IsNavalOperation())
				iNum++;
			else if (eDomain == DOMAIN_LAND && !pThisOperation->IsNavalOperation())
				iNum++;
		}
	}

	return iNum;
}

bool CvPlayer::StopAllLandDefensiveOperationsAgainstPlayer(PlayerTypes ePlayer, AIOperationAbortReason eReason)
{
	bool bFoundOne = false;

	// loop through all entries looking for match
	std::map<int , CvAIOperation*>::iterator iter;
	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
	{
		CvAIOperation* pThisOperation = iter->second;

		if (pThisOperation->GetOperationState() == AI_OPERATION_STATE_SUCCESSFUL_FINISH)
			continue;

		if(pThisOperation->IsDefensive() && !pThisOperation->IsNavalOperation() && pThisOperation->GetOperationState() != AI_OPERATION_STATE_ABORTED)
		{
			if(ePlayer == NO_PLAYER || ePlayer == pThisOperation->GetEnemy())
			{
				bFoundOne = true;
				pThisOperation->SetToAbort(eReason);
			}
		}
	}

	return bFoundOne;
}

bool CvPlayer::StopAllSeaOffensiveOperationsAgainstPlayer(PlayerTypes ePlayer, bool bIncludeSneakOps, AIOperationAbortReason eReason)
{
	bool bFoundOne = false;

	// loop through all entries looking for match
	std::map<int , CvAIOperation*>::iterator iter;
	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
	{
		CvAIOperation* pThisOperation = iter->second;

		if (pThisOperation->GetOperationState() == AI_OPERATION_STATE_SUCCESSFUL_FINISH)
			continue;

		if(pThisOperation->IsOffensive() && pThisOperation->IsNavalOperation() && pThisOperation->GetOperationState() != AI_OPERATION_STATE_ABORTED)
		{
			if( (ePlayer == NO_PLAYER && pThisOperation->GetEnemy() != BARBARIAN_PLAYER) || ePlayer == pThisOperation->GetEnemy())
			{
				if (bIncludeSneakOps || !pThisOperation->IsAllowedDuringPeace())
				{
					bFoundOne = true;
					pThisOperation->SetToAbort(eReason);
				}
			}
		}
	}

	return bFoundOne;
}

bool CvPlayer::StopAllSeaDefensiveOperationsAgainstPlayer(PlayerTypes ePlayer, AIOperationAbortReason eReason)
{
	bool bFoundOne = false;

	// loop through all entries looking for match
	std::map<int , CvAIOperation*>::iterator iter;
	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
	{
		CvAIOperation* pThisOperation = iter->second;

		if (pThisOperation->GetOperationState() == AI_OPERATION_STATE_SUCCESSFUL_FINISH)
			continue;

		if(pThisOperation->IsDefensive() && pThisOperation->IsNavalOperation() && pThisOperation->GetOperationState() != AI_OPERATION_STATE_ABORTED)
		{
			if(ePlayer == NO_PLAYER || ePlayer == pThisOperation->GetEnemy())
			{
				bFoundOne = true;
				pThisOperation->SetToAbort(eReason);
			}
		}
	}

	return bFoundOne;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::haveAIOperationOfType(int iOperationType, int* piID /* optional return argument */, PlayerTypes eTargetPlayer /* optional additional match criteria */, CvPlot* pTarget /* optional additional match criteria */)
{
	// loop through all entries looking for match
	std::map<int , CvAIOperation*>::iterator iter;
	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
	{
		CvAIOperation* pThisOperation = iter->second;
		if(pThisOperation->GetOperationType() == iOperationType && pThisOperation->GetOperationState() != AI_OPERATION_STATE_ABORTED)
		{
			if(eTargetPlayer == NO_PLAYER || eTargetPlayer == pThisOperation->GetEnemy())
			{
				if(pTarget == NULL || pTarget == pThisOperation->GetTargetPlot() || pTarget == pThisOperation->GetMusterPlot())
				{
					// Fill in optional parameter (ID) if passed in
					if(piID != NULL)
					{
						*piID = pThisOperation->GetID();
					}
					return true;
				}
			}
		}
	}
	// Fill in optional parameter (ID) if passed in
	if(piID != NULL)
	{
		*piID = -1;
	}
	return false;
}

//	--------------------------------------------------------------------------------
int CvPlayer::numOperationsOfType(int iOperationType)
{
	int iRtnValue = 0;

	std::map<int , CvAIOperation*>::iterator iter;
	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
	{
		CvAIOperation* pThisOperation = iter->second;
		if(pThisOperation->GetOperationType() == iOperationType && pThisOperation->GetOperationState() != AI_OPERATION_STATE_ABORTED)
		{
			iRtnValue++;
		}
	}

	return iRtnValue;
}

//	--------------------------------------------------------------------------------
/// Is an existing operation already going after this city?
bool CvPlayer::IsCityAlreadyTargeted(CvCity* pCity, DomainTypes eDomain, int iPercentToTarget, int iIgnoreOperationID, AIOperationTypes eAlreadyActiveOperation) const
{
	if (pCity == NULL)
		return false;	

	CvAIOperation* pOperation;
	std::map<int , CvAIOperation*>::const_iterator iter;
	AIOperationState eOperationState = AI_OPERATION_STATE_INVALID;
	if (iPercentToTarget <= 50)
	{
		eOperationState = AI_OPERATION_STATE_GATHERING_FORCES;
	}
	else
	{
		eOperationState = AI_OPERATION_STATE_MOVING_TO_TARGET;
	}
	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
	{
		pOperation = iter->second;

		if(pOperation)
		{
			if(iIgnoreOperationID == -1 || iIgnoreOperationID != pOperation->GetID())
			{
				if (pOperation->GetOperationState() <= eOperationState)
				{
					if(pOperation->GetTargetPlot() != NULL)
					{
						if(pOperation->GetTargetPlot() == pCity->plot())
						{
							// Naval attacks are mixed land/naval operations
							if((eDomain == NO_DOMAIN || eDomain == DOMAIN_SEA) && pOperation->IsNavalOperation())
							{
								return true;
							}

							if((eDomain == NO_DOMAIN || eDomain == DOMAIN_LAND) && !pOperation->IsNavalOperation())
							{
								return true;
							}
						}
						else if(pOperation->GetTargetPlot()->getOwningCity() != NULL)
						{
							if(pOperation->GetTargetPlot()->getOwningCity() == pCity)
							{
								// Naval attacks are mixed land/naval operations
								if((eDomain == NO_DOMAIN || eDomain == DOMAIN_SEA) && pOperation->IsNavalOperation())
								{
									return true;
								}

								if((eDomain == NO_DOMAIN || eDomain == DOMAIN_LAND) && !pOperation->IsNavalOperation())
								{
									return true;
								}
							}
						}
					}
				}
			}
			if (eAlreadyActiveOperation == AI_OPERATION_TYPE_INVALID || eAlreadyActiveOperation == pOperation->GetOperationType())
			{
				if (pOperation->GetOperationState() <= eOperationState)
				{
					if (pOperation->GetTargetPlot() != NULL)
					{
						if (pOperation->GetTargetPlot() == pCity->plot())
						{
							// Naval attacks are mixed land/naval operations
							if ((eDomain == NO_DOMAIN || eDomain == DOMAIN_SEA) && pOperation->IsNavalOperation())
							{
								return true;
							}

							if ((eDomain == NO_DOMAIN || eDomain == DOMAIN_LAND) && !pOperation->IsNavalOperation())
							{
								return true;
							}
						}
						else if (pOperation->GetTargetPlot()->getOwningCity() != NULL)
						{
							if (pOperation->GetTargetPlot()->getOwningCity() == pCity)
							{
								// Naval attacks are mixed land/naval operations
								if ((eDomain == NO_DOMAIN || eDomain == DOMAIN_SEA) && pOperation->IsNavalOperation())
								{
									return true;
								}

								if ((eDomain == NO_DOMAIN || eDomain == DOMAIN_LAND) && !pOperation->IsNavalOperation())
								{
									return true;
								}
							}
						}
					}
				}
			}
		}
	}

	return false;
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Is an existing operation already starting from this city?
bool CvPlayer::IsMusterCityAlreadyTargeted(CvCity* pCity, DomainTypes eDomain, int iPercentToTarget, int iIgnoreOperationID, AIOperationTypes eAlreadyActiveOperation) const
{
	CvAIOperation* pOperation;
	std::map<int, CvAIOperation*>::const_iterator iter;
	AIOperationState eOperationState = AI_OPERATION_STATE_INVALID;
	if (iPercentToTarget <= 50)
	{
		eOperationState = AI_OPERATION_STATE_GATHERING_FORCES;
	}
	else
	{
		eOperationState = AI_OPERATION_STATE_MOVING_TO_TARGET;
	}
	for (iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
	{
		pOperation = iter->second;

		if (pOperation)
		{
			if (iIgnoreOperationID == -1 || iIgnoreOperationID != pOperation->GetID())
			{
				if (pOperation->GetOperationState() <= eOperationState)
				{
					if(pOperation->GetMusterPlot() != NULL)
					{
						if(pOperation->GetMusterPlot() == pCity->plot())
						{
							// Naval attacks are mixed land/naval operations
							if((eDomain == NO_DOMAIN || eDomain == DOMAIN_SEA) && pOperation->IsNavalOperation())
							{
								return true;
							}

							if((eDomain == NO_DOMAIN || eDomain == DOMAIN_LAND) && !pOperation->IsNavalOperation())
							{
								return true;
							}
						}
						else if(pOperation->GetMusterPlot()->getOwningCity() != NULL)
						{
							if(pOperation->GetMusterPlot()->getOwningCity() == pCity)
							{
								// Naval attacks are mixed land/naval operations
								if((eDomain == NO_DOMAIN || eDomain == DOMAIN_SEA) && pOperation->IsNavalOperation())
								{
									return true;
								}

								if((eDomain == NO_DOMAIN || eDomain == DOMAIN_LAND) && !pOperation->IsNavalOperation())
								{
									return true;
								}
							}
						}
					}
				}
			}
			if (eAlreadyActiveOperation == AI_OPERATION_TYPE_INVALID || eAlreadyActiveOperation == pOperation->GetOperationType())
			{
				if (pOperation->GetOperationState() <= eOperationState)
				{
					if (pOperation->GetMusterPlot() != NULL)
					{
						if (pOperation->GetMusterPlot() == pCity->plot())
						{
							// Naval attacks are mixed land/naval operations
							if ((eDomain == NO_DOMAIN || eDomain == DOMAIN_SEA) && pOperation->IsNavalOperation())
							{
								return true;
							}

							if ((eDomain == NO_DOMAIN || eDomain == DOMAIN_LAND) && !pOperation->IsNavalOperation())
							{
								return true;
							}
						}
						else if (pOperation->GetMusterPlot()->getOwningCity() != NULL)
						{
							if (pOperation->GetMusterPlot()->getOwningCity() == pCity)
							{
								// Naval attacks are mixed land/naval operations
								if ((eDomain == NO_DOMAIN || eDomain == DOMAIN_SEA) && pOperation->IsNavalOperation())
								{
									return true;
								}

								if ((eDomain == NO_DOMAIN || eDomain == DOMAIN_LAND) && !pOperation->IsNavalOperation())
								{
									return true;
								}
							}
						}
					}
				}
			}
		}
	}

	return false;
}
#endif

#if defined(MOD_BALANCE_CORE)
bool CvPlayer::IsPlotTargetedForExplorer(const CvPlot* pPlot, const CvUnit* pIgnoreUnit) const
{
	if (!pPlot)
		return false;

	// Loop through our units
	int iLoop = 0;
	for(const CvUnit* pUnit = firstUnit(&iLoop); pUnit; pUnit = nextUnit(&iLoop))
	{
		if (pUnit==pIgnoreUnit)
			continue;

		if(pUnit->AI_getUnitAIType() == UNITAI_EXPLORE || (pUnit->IsAutomated() && pUnit->GetAutomateType() == AUTOMATE_EXPLORE) )
		{
			CvPlot* pMissionPlot = pUnit->GetMissionAIPlot();
			if (pMissionPlot && ::plotDistance(*pMissionPlot,*pPlot)<3)
				return true;
		}
	}
	return false;
}
#endif

//	--------------------------------------------------------------------------------
/// Are we already sending a settler to this plot (or any plot within 3)
bool CvPlayer::IsPlotTargetedForCity(CvPlot *pPlot, CvAIOperation* pOpToIgnore) const
{
	std::map<int , CvAIOperation*>::const_iterator iter;
	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
	{
		CvAIOperation* pOperation = iter->second;
		if(pOperation && pOperation != pOpToIgnore && pOperation->HasTargetPlot())
		{
			switch (pOperation->GetOperationType())
			{
			case AI_OPERATION_FOUND_CITY:
			case AI_OPERATION_FOUND_CITY_OVERSEAS:
			case AI_OPERATION_FOUND_CITY_QUICK:
				{
					if (plotDistance(*pPlot,*pOperation->GetTargetPlot()) <= 3)
					{
						return true;
					}
				}
			}
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
unsigned int CvPlayer::getNumReplayDataSets() const
{
	return m_ReplayDataSets.size();
}

//	--------------------------------------------------------------------------------
const char* CvPlayer::getReplayDataSetName(unsigned int idx) const
{
	if(idx < m_ReplayDataSets.size())
		return m_ReplayDataSets[idx];

	return NULL;
}

//	--------------------------------------------------------------------------------
unsigned int CvPlayer::getReplayDataSetIndex(const char* szDataSetName)
{
	CvString dataSetName = szDataSetName;

	unsigned int idx = 0;
	for(std::vector<CvString>::iterator it = m_ReplayDataSets.begin(); it != m_ReplayDataSets.end(); ++it)
	{
		if((*it) == dataSetName)
			return idx;

		idx++;
	}

	m_ReplayDataSets.push_back(dataSetName);
	m_ReplayDataSetValues.push_back(TurnData());
	return m_ReplayDataSets.size() - 1;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getReplayDataValue(unsigned int uiDataSet, unsigned int uiTurn) const
{
	if(uiDataSet < m_ReplayDataSetValues.size())
	{
		const TurnData& dataSet = m_ReplayDataSetValues[uiDataSet];
		TurnData::const_iterator it = dataSet.find(uiTurn);
		if(it != dataSet.end())
		{
			return (*it).second;
		}
	}

	return -1;
}

//	--------------------------------------------------------------------------------
void CvPlayer::setReplayDataValue(unsigned int uiDataSet, unsigned int uiTurn, int iValue)
{
	if(uiDataSet < m_ReplayDataSetValues.size())
	{
		TurnData& dataSet = m_ReplayDataSetValues[uiDataSet];
		dataSet[uiTurn] = iValue;
	}
}

//	--------------------------------------------------------------------------------
CvPlayer::TurnData CvPlayer::getReplayDataHistory(unsigned int uiDataSet) const
{
	if(uiDataSet < m_ReplayDataSetValues.size())
	{
		return m_ReplayDataSetValues[uiDataSet];
	}

	return CvPlayer::TurnData();
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeInstantYieldValue(YieldTypes eYield, int iValue)
{
	if (iValue != 0)
	{
		int iTurn = GC.getGame().getGameTurn();
		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiInstantYieldHistoryValues[iTurn];
		yields[eYield] = (m_ppiInstantYieldHistoryValues[iTurn][eYield] + iValue);
		m_ppiInstantYieldHistoryValues[iTurn] = yields;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getInstantYieldValue(YieldTypes eYield, int iTurn) const
{
	//catch for CTD
	if (iTurn <= 0 || iTurn >= GC.getGame().getEstimateEndTurn())
		return 0;

	return m_ppiInstantYieldHistoryValues[iTurn][eYield];
}

CvString CvPlayer::getInstantYieldHistoryTooltip(int iGameTurn, int iNumPreviousTurnsToCount)
{
	CvString yieldtooltip = "";
	int MaxTurnsBack = 0;

	bool bShowPlayerTourism = false;
	vector<int> tourismVal(MAX_MAJOR_CIVS, 0);
	for (int i = 0; i < NUM_YIELD_TYPES; i++)
	{
		int TurnsBack = 0;
		YieldTypes eYield = (YieldTypes)i;
		if (eYield == NO_YIELD)
			continue;

		if (eYield == YIELD_POPULATION)
			continue;

		if (eYield > YIELD_CULTURE_LOCAL)
			continue;

		if (GC.getYieldInfo(eYield) == NULL)
			continue;

		//current turn
		int iSum = 0;

		//turn zero is strange
		if (iGameTurn == 0)
		{
			iSum += getInstantYieldValue(eYield, GC.getGame().getGameTurn());
			int iTempSum = 0;
			int iNumPlayers = 0;
			if (eYield == YIELD_TOURISM)
			{
				for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
				{
					PlayerTypes ePlayer = (PlayerTypes)iPlayerLoop;
					int iTempTourism = getInstantTourismValue(ePlayer, GC.getGame().getGameTurn());
					if (iTempTourism != 0)
					{
						iNumPlayers++;
						bShowPlayerTourism = true;
					}

					iTempSum += iTempTourism;
					tourismVal[iPlayerLoop] += iTempTourism;
				}
				iTempSum /= max(1, iNumPlayers);
				iSum += iTempSum;
			}
			TurnsBack++;
		}
		else
		{
			//and x turns back
			for (int iI = iNumPreviousTurnsToCount; iI >= 0; iI--)
			{
				int iTurn = iGameTurn - iI;
				if (iTurn < 0)
				{
					continue;
				}

				iSum += getInstantYieldValue(eYield, iTurn);
				int iTempSum = 0;
				int iNumPlayers = 0;
				if (eYield == YIELD_TOURISM)
				{
					for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
					{
						PlayerTypes ePlayer = (PlayerTypes)iPlayerLoop;
						int iTempTourism = getInstantTourismValue(ePlayer, iTurn);
						if (iTempTourism != 0)
						{
							iNumPlayers++;
							bShowPlayerTourism = true;
						}

						iTempSum += iTempTourism;
						tourismVal[iPlayerLoop] += iTempTourism;
					}
					iTempSum /= max(1, iNumPlayers);
					iSum += iTempSum;
				}
				TurnsBack++;
			}
		}
		if (TurnsBack > MaxTurnsBack)
			MaxTurnsBack = TurnsBack;

		if (iSum > 0)
		{
			if (yieldtooltip != "")
			{
				yieldtooltip += "[NEWLINE]";
			}

			Localization::String localizedIYText;

			localizedIYText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_TOTAL");

			localizedIYText << GC.getYieldInfo(eYield)->GetDescription();
			localizedIYText << GC.getYieldInfo(eYield)->getIconString();
			localizedIYText << GC.getYieldInfo(eYield)->getColorString();
			localizedIYText << iSum;

			yieldtooltip += localizedIYText.toUTF8();

			int iAverage = max(1, (iSum / max(1, MaxTurnsBack)));

			yieldtooltip += " " + GetLocalizedText("TXT_KEY_INSTANT_YIELD_AVERAGE", iAverage);

			if (eYield == YIELD_FOOD || eYield == YIELD_PRODUCTION)
			{
				iAverage /= max(1, getNumCities());
				yieldtooltip += " " + GetLocalizedText("TXT_KEY_INSTANT_YIELD_AVERAGE_CITIES", iAverage);
			}
		}
	}

	if (bShowPlayerTourism)
	{
		yieldtooltip += " " + GetLocalizedText("TXT_KEY_INSTANT_YIELD_PER_PLAYER_TOURISM");
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes ePlayer = (PlayerTypes)iPlayerLoop;
			if (tourismVal[iPlayerLoop] == 0)
				continue;

			int iTourismAverage = max(1, (tourismVal[iPlayerLoop] / max(1, MaxTurnsBack)));

			yieldtooltip += " " + GetLocalizedText("TXT_KEY_INSTANT_YIELD_PER_PLAYER_TOURISM_NAME", GET_PLAYER(ePlayer).getCivilizationShortDescription(), tourismVal[iPlayerLoop], iTourismAverage);
		}
	}

	CvString tooltip = GetLocalizedText("TXT_KEY_YIELD_PER_TURN_HEADER", min(iNumPreviousTurnsToCount, MaxTurnsBack)) + "[NEWLINE]";

	if (yieldtooltip != "")
	{
		tooltip += yieldtooltip;
	}
	else
	{
		tooltip = GetLocalizedText("TXT_KEY_YIELD_PER_TURN_HEADER_EMPTY");
	}

	return tooltip;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeInstantTourismValue(PlayerTypes ePlayer, int iValue)
{
	if (iValue != 0)
	{
		int iTurn = GC.getGame().getGameTurn();
		Firaxis::Array<int, MAX_MAJOR_CIVS> players = m_ppiInstantTourismHistoryValues[iTurn];
		players[ePlayer] = (m_ppiInstantTourismHistoryValues[iTurn][ePlayer] + iValue);
		m_ppiInstantTourismHistoryValues[iTurn] = players;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getInstantTourismValue(PlayerTypes ePlayer, int iTurn) const
{
	//catch for CTD
	if (iTurn <= 0 || iTurn >= GC.getGame().getEstimateEndTurn())
		return 0;

	return m_ppiInstantTourismHistoryValues[iTurn][ePlayer];
}


//	--------------------------------------------------------------------------------
std::string CvPlayer::getScriptData() const
{
	return m_strScriptData;
}

//	--------------------------------------------------------------------------------
void CvPlayer::setScriptData(std::string strNewValue)
{
	m_strScriptData = strNewValue;
}

//	--------------------------------------------------------------------------------
const CvString& CvPlayer::getPbemEmailAddress() const
{
	return CvPreGame::emailAddress(GetID());
}

//	--------------------------------------------------------------------------------
void CvPlayer::setPbemEmailAddress(const char* szAddress)
{
	CvPreGame::setEmailAddress(GetID(), szAddress);
}

// Protected Functions...

//	--------------------------------------------------------------------------------
void CvPlayer::doResearch()
{
	if(GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))
	{
		return;
	}

	AI_PERF_FORMAT("AI-perf.csv", ("CvPlayer::doResearch, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), getCivilizationShortDescription()) );
	bool bForceResearchChoice;
	int iOverflowResearch;

	if(GetPlayerTechs()->IsResearch())
	{
		bForceResearchChoice = false;

		// Force player to pick Research if he doesn't have anything assigned
		if(GetPlayerTechs()->GetCurrentResearch() == NO_TECH)
		{
			if(GetID() == GC.getGame().getActivePlayer() && GetScienceTimes100() > 0)
			{
				chooseTech();
			}

			if(GC.getGame().getElapsedGameTurns() > 4)
			{
				AI_chooseResearch();

				bForceResearchChoice = true;
			}
		}

		TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
		if(eCurrentTech == NO_TECH)
		{
			int iOverflow = (GetScienceTimes100()) / std::max(1, calculateResearchModifier(eCurrentTech));
			changeOverflowResearchTimes100(iOverflow);
		}
		else
		{
			iOverflowResearch = (getOverflowResearchTimes100() * calculateResearchModifier(eCurrentTech)) / 100;
			setOverflowResearch(0);
			if(GET_TEAM(getTeam()).GetTeamTechs())
			{
				int iBeakersTowardsTechTimes100 = GetScienceTimes100() + iOverflowResearch;
#if defined(MOD_BUGFIX_RESEARCH_OVERFLOW)
				GET_TEAM(getTeam()).GetTeamTechs()->ChangeResearchProgressTimes100(eCurrentTech, iBeakersTowardsTechTimes100, GetID(), iOverflowResearch, calculateResearchModifier(eCurrentTech));
#else
				GET_TEAM(getTeam()).GetTeamTechs()->ChangeResearchProgressTimes100(eCurrentTech, iBeakersTowardsTechTimes100, GetID());
#endif
				UpdateResearchAgreements(GetScienceTimes100() / 100);
			}
		}

		if(bForceResearchChoice)
		{
			clearResearchQueue();
		}
	}
	GetPlayerTechs()->CheckForTechAchievement();

}

//	--------------------------------------------------------------------------------
void CvPlayer::doAdvancedStartAction(AdvancedStartActionTypes eAction, int iX, int iY, int iData, bool bAdd)
{
	CvPlot* pPlot = GC.getMap().plot(iX, iY);

	if(0 == getNumCities())
	{
		switch(eAction)
		{
		case ADVANCEDSTARTACTION_EXIT:
			//Try to build this player's empire
			if(GetID() == GC.getGame().getActivePlayer())
			{
				GC.GetEngineUserInterface()->setBusy(true);
			}
			if(GetID() == GC.getGame().getActivePlayer())
			{
				GC.GetEngineUserInterface()->setBusy(false);
			}
			break;
		case ADVANCEDSTARTACTION_AUTOMATE:
		case ADVANCEDSTARTACTION_CITY:
			break;
		default:
			// The first action must be to place a city
			// so players can lose by spending everything
			return;
		}
	}

	switch(eAction)
	{
	case ADVANCEDSTARTACTION_EXIT:
		GetTreasury()->ChangeGold(getAdvancedStartPoints());
		setAdvancedStartPoints(-1);
		if(GC.getGame().getActivePlayer() == GetID())
		{
			GC.GetEngineUserInterface()->setInAdvancedStart(false);
		}

		if(isHuman())
		{
			int iLoop;
			for(CvCity* pCity = firstCity(&iLoop); NULL != pCity; pCity = nextCity(&iLoop))
			{
				pCity->chooseProduction();
			}

			chooseTech();
		}
		break;
	case ADVANCEDSTARTACTION_AUTOMATE:
		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setBusy(true);
		}
		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setBusy(false);
		}
		break;
	case ADVANCEDSTARTACTION_UNIT:
	{
		if(pPlot == NULL)
			return;

		UnitTypes eUnit = (UnitTypes) iData;
		int iCost = getAdvancedStartUnitCost(eUnit, bAdd, pPlot);

		if(bAdd && iCost < 0)
		{
			return;
		}

		// Add unit to the map
		if(bAdd)
		{
			if(getAdvancedStartPoints() >= iCost)
			{
				CvUnit* pUnit = initUnit(eUnit, iX, iY);
				if(NULL != pUnit)
				{
					pUnit->finishMoves();
					changeAdvancedStartPoints(-iCost);
				}
			}
		}

		// Remove unit from the map
		else
		{
			// If cost is -1 we already know this unit isn't present
			if(iCost != -1)
			{
				IDInfo* pUnitNode = pPlot->headUnitNode();
				while(pUnitNode != NULL)
				{
					CvUnit* pLoopUnit = ::getUnit(*pUnitNode);
					pUnitNode = pPlot->nextUnitNode(pUnitNode);

					if(NULL != pLoopUnit && pLoopUnit->getUnitType() == eUnit)
					{
						pLoopUnit->kill(false);
						changeAdvancedStartPoints(iCost);
						return;
					}
				}
			}

			// Proper unit not found above, delete first found
			IDInfo* pUnitNode = pPlot->headUnitNode();
			if(pUnitNode != NULL)
			{
				CvUnit* pUnit = ::getUnit(*pUnitNode);

				iCost = getAdvancedStartUnitCost(pUnit->getUnitType(), false);
				CvAssertMsg(iCost != -1, "If this is -1 then that means it's going to try to delete a unit which shouldn't exist");
				pUnit->kill(false);
				changeAdvancedStartPoints(iCost);
			}
		}

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Advanced_Start_DIRTY_BIT, true);
		}
	}
	break;
	case ADVANCEDSTARTACTION_CITY:
	{
		if(pPlot == NULL)
			return;

		int iCost = getAdvancedStartCityCost(bAdd, pPlot);

		if(iCost < 0)
		{
			return;
		}

		// Add City to the map
		if(bAdd)
		{
			if(0 == getNumCities())
			{
				PlayerTypes eClosestPlayer = NO_PLAYER;
				int iMinDistance = INT_MAX;
				for(int iPlayer = 0; iPlayer < MAX_CIV_PLAYERS; iPlayer++)
				{
					CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iPlayer);
					if(kPlayer.isAlive())
					{
						if(kPlayer.getTeam() == getTeam())
						{
							if(0 == kPlayer.getNumCities())
							{
								CvAssert(kPlayer.getStartingPlot() != NULL);
								int iDistance = plotDistance(iX, iY, kPlayer.getStartingPlot()->getX(), kPlayer.getStartingPlot()->getY());
								if(iDistance < iMinDistance)
								{
									eClosestPlayer = kPlayer.GetID();
									iMinDistance = iDistance;
								}
							}
						}
					}
				}
				CvAssertMsg(eClosestPlayer != NO_PLAYER, "Self at a minimum should always be valid");
				if(eClosestPlayer != GetID())
				{
					CvPlot* pTempPlot = GET_PLAYER(eClosestPlayer).getStartingPlot();
					GET_PLAYER(eClosestPlayer).setStartingPlot(getStartingPlot());
					setStartingPlot(pTempPlot);
				}
			}
			if(getAdvancedStartPoints() >= iCost || 0 == getNumCities())
			{
				found(iX, iY);
				changeAdvancedStartPoints(-iCost);
				CvCity* pCity = pPlot->getPlotCity();
				if(pCity != NULL)
				{
					if(pCity->getPopulation() > 1)
					{
						pCity->setFood(pCity->growthThreshold() / 2);
					}
				}
			}
		}

		// Remove City from the map
		else
		{
			pPlot->setRouteType(NO_ROUTE);
			pPlot->getPlotCity()->kill();
			pPlot->setImprovementType(NO_IMPROVEMENT);
			changeAdvancedStartPoints(iCost);
		}

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Advanced_Start_DIRTY_BIT, true);
		}
	}
	break;
	case ADVANCEDSTARTACTION_POP:
	{
		if(pPlot == NULL)
			return;

		CvCity* pCity = pPlot->getPlotCity();

		if(pCity != NULL)
		{
			int iCost = getAdvancedStartPopCost(bAdd, pCity);

			if(iCost < 0)
			{
				return;
			}

			// Add Pop to the City
			if(bAdd)
			{
				if(getAdvancedStartPoints() >= iCost)
				{
					pCity->changePopulation(1);
					changeAdvancedStartPoints(-iCost);
					if(pCity->getPopulation() > 1)
					{
						pCity->setFood(pCity->growthThreshold() / 2);
					}
				}
			}

			// Remove Pop from the city
			else
			{
				pCity->changePopulation(-1);
				changeAdvancedStartPoints(iCost);
				if(pCity->getPopulation() == 1)
				{
					pCity->setFood(0);
				}
			}
		}
	}
	break;
	case ADVANCEDSTARTACTION_BUILDING:
	{
		if(pPlot == NULL)
			return;

		CvCity* pCity = pPlot->getPlotCity();

		if(pCity != NULL)
		{
			BuildingTypes eBuilding = (BuildingTypes) iData;

			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
			if(pkBuildingInfo == NULL)
			{
				return;
			}

			int iCost = getAdvancedStartBuildingCost(eBuilding, bAdd, pCity);
			if(iCost < 0)
			{
				return;
			}

			// Add Building to the City
			if(bAdd)
			{
				if(getAdvancedStartPoints() >= iCost)
				{
					pCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, pCity->GetCityBuildings()->GetNumRealBuilding(eBuilding)+1);
					changeAdvancedStartPoints(-iCost);
				}
			}

			// Remove Building from the map
			else
			{
				pCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, pCity->GetCityBuildings()->GetNumRealBuilding(eBuilding)-1);
				changeAdvancedStartPoints(iCost);
			}
		}

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Advanced_Start_DIRTY_BIT, true);
		}
	}
	break;
	case ADVANCEDSTARTACTION_ROUTE:
	{
		if(pPlot == NULL)
			return;

		RouteTypes eRoute = (RouteTypes) iData;
		int iCost = getAdvancedStartRouteCost(eRoute, bAdd, pPlot);

		if(bAdd && iCost < 0)
		{
			return;
		}

		// Add Route to the plot
		if(bAdd)
		{
			if(getAdvancedStartPoints() >= iCost)
			{
				pPlot->setRouteType(eRoute);
				changeAdvancedStartPoints(-iCost);
			}
		}

		// Remove Route from the Plot
		else
		{
			if(pPlot->getRouteType() != eRoute)
			{
				eRoute = pPlot->getRouteType();
				iCost = getAdvancedStartRouteCost(eRoute, bAdd);
			}

			if(iCost < 0)
			{
				return;
			}

			pPlot->setRouteType(NO_ROUTE);
			changeAdvancedStartPoints(iCost);
		}

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Advanced_Start_DIRTY_BIT, true);
		}
	}
	break;
	case ADVANCEDSTARTACTION_IMPROVEMENT:
	{
		if(pPlot == NULL)
			return;

		ImprovementTypes eImprovement = (ImprovementTypes) iData;
		int iCost = getAdvancedStartImprovementCost(eImprovement, bAdd, pPlot);

		if(bAdd && iCost < 0)
		{
			return;
		}

		// Add Improvement to the plot
		if(bAdd)
		{
			if(getAdvancedStartPoints() >= iCost)
			{
				if(pPlot->getFeatureType() != NO_FEATURE)
				{
					for(int iI = 0; iI < GC.getNumBuildInfos(); ++iI)
					{
						CvBuildInfo* pkBuildInfo = GC.getBuildInfo((BuildTypes) iI);
						if(!pkBuildInfo)
						{
							continue;
						}

						ImprovementTypes eLoopImprovement = ((ImprovementTypes)(pkBuildInfo->getImprovement()));

						if(eImprovement == eLoopImprovement)
						{
							if(pkBuildInfo->isFeatureRemove(pPlot->getFeatureType()) && canBuild(pPlot, (BuildTypes)iI))
							{
								pPlot->setFeatureType(NO_FEATURE);
								break;
							}
						}
					}
				}

				pPlot->setImprovementType(eImprovement, GetID());

				changeAdvancedStartPoints(-iCost);
			}
		}

		// Remove Improvement from the Plot
		else
		{
			if(pPlot->getImprovementType() != eImprovement)
			{
				eImprovement = pPlot->getImprovementType();
				iCost = getAdvancedStartImprovementCost(eImprovement, bAdd, pPlot);
			}

			if(iCost < 0)
			{
				return;
			}

			pPlot->setImprovementType(NO_IMPROVEMENT);
			changeAdvancedStartPoints(iCost);
		}

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Advanced_Start_DIRTY_BIT, true);
		}
	}
	break;
	case ADVANCEDSTARTACTION_TECH:
	{
		TechTypes eTech = (TechTypes) iData;
		int iCost = getAdvancedStartTechCost(eTech, bAdd);

		if(iCost < 0)
		{
			return;
		}

		// Add Tech to team
		if(bAdd)
		{
			if(getAdvancedStartPoints() >= iCost)
			{
				GET_TEAM(getTeam()).setHasTech(eTech, true, GetID(), false, false);
				changeAdvancedStartPoints(-iCost);
			}
		}

		// Remove Tech from the Team
		else
		{
			GET_TEAM(getTeam()).setHasTech(eTech, false, GetID(), false, false);
			changeAdvancedStartPoints(iCost);
		}

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Advanced_Start_DIRTY_BIT, true);
		}
	}
	break;
	case ADVANCEDSTARTACTION_VISIBILITY:
	{
		if(pPlot == NULL)
			return;

		int iCost = getAdvancedStartVisibilityCost(bAdd, pPlot);

		if(iCost < 0)
		{
			return;
		}

		// Add Visibility to the plot
		if(bAdd)
		{
			if(getAdvancedStartPoints() >= iCost)
			{
#if defined(MOD_API_EXTENSIONS)
				pPlot->setRevealed(getTeam(), true, NULL, true);
#else
				pPlot->setRevealed(getTeam(), true, true);
#endif
				changeAdvancedStartPoints(-iCost);
			}
		}

		// Remove Visibility from the Plot
		else
		{
#if defined(MOD_API_EXTENSIONS)
			pPlot->setRevealed(getTeam(), false, NULL, true);
#else
			pPlot->setRevealed(getTeam(), false, true);
#endif
			changeAdvancedStartPoints(iCost);
		}
	}
	break;
	default:
		CvAssert(false);
		break;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing a unit
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartUnitCost(UnitTypes eUnit, bool bAdd, CvPlot* pPlot)
{
	if(0 == getNumCities())
	{
		return -1;
	}

	CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
	if(pkUnitInfo == NULL)
	{
		return -1;
	}

	int iCost = (getProductionNeeded(eUnit) * pkUnitInfo->GetAdvancedStartCost()) / 100;
	if(iCost < 0)
	{
		return -1;
	}

	if(NULL == pPlot)
	{
		if(bAdd)
		{
			bool bValid = false;
			int iLoop;
			for(CvCity* pLoopCity = firstCity(&iLoop); NULL != pLoopCity; pLoopCity = nextCity(&iLoop))
			{
				if(pLoopCity->canTrain(eUnit))
				{
					bValid = true;
					break;
				}
			}

			if(!bValid)
			{
				return -1;
			}
		}
	}
	else
	{
		CvCity* pCity = NULL;

		if(0 == GC.getADVANCED_START_ALLOW_UNITS_OUTSIDE_CITIES())
		{
			pCity = pPlot->getPlotCity();

			if(NULL == pCity || pCity->getOwner() != GetID())
			{
				return -1;
			}

			iCost *= 100;
			iCost /= std::max(1, 100 + pCity->getProductionModifier(eUnit));
		}
		else
		{
			if(pPlot->getOwner() != GetID())
			{
				return -1;
			}

			iCost *= 100;
			iCost /= std::max(1, 100 + getProductionModifier(eUnit));
		}


		if(bAdd)
		{
			int iMaxUnitsPerCity = GC.getADVANCED_START_MAX_UNITS_PER_CITY();
			if(iMaxUnitsPerCity >= 0)
			{
				if(pkUnitInfo->IsMilitarySupport() && getNumMilitaryUnits() >= iMaxUnitsPerCity * getNumCities())
				{
					return -1;
				}
			}

			if(NULL != pCity)
			{
				if(!pCity->canTrain(eUnit))
				{
					return -1;
				}
			}
			else
			{
				if(!pPlot->canTrain(eUnit, false, false))
				{
					return -1;
				}
				if(!pPlot->isValidMovePlot(GetID()))
				{
					return -1;
				}
			}
		}
		// Must be this unit at plot in order to remove
		else
		{
			bool bUnitFound = false;

			IDInfo* pUnitNode = pPlot->headUnitNode();
			while(pUnitNode != NULL)
			{
				CvUnit* pLoopUnit = ::getUnit(*pUnitNode);
				pUnitNode = pPlot->nextUnitNode(pUnitNode);

				if(NULL != pLoopUnit && pLoopUnit->getUnitType() == eUnit)
				{
					bUnitFound = true;
				}
			}

			if(!bUnitFound)
			{
				return -1;
			}
		}
	}

	return iCost;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing a City
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartCityCost(bool bAdd, CvPlot* pPlot)
{
	int iNumCities = getNumCities();

	int iCost = getNewCityProductionValue();

	if(iCost < 0)
	{
		return -1;
	}

	// Valid plot?
	if(pPlot != NULL)
	{
		// Need valid plot to found on if adding
		if(bAdd)
		{
			if(!canFound(pPlot->getX(), pPlot->getY()))
			{
				return -1;
			}
		}
		// Need your own city present to remove
		else
		{
			if(pPlot->isCity())
			{
				if(pPlot->getPlotCity()->getOwner() != GetID())
				{
					return -1;
				}
			}
			else
			{
				return -1;
			}
		}

		// Is there a distance limit on how far a city can be placed from a player's start/another city?
		if(GC.getADVANCED_START_CITY_PLACEMENT_MAX_RANGE() > 0)
		{
			PlayerTypes eClosestPlayer = NO_PLAYER;
			int iClosestDistance = INT_MAX;

			for(int iPlayer = 0; iPlayer < MAX_CIV_PLAYERS; ++iPlayer)
			{
				CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iPlayer);

				if(kPlayer.isAlive())
				{
					CvPlot* pStartingPlot = kPlayer.getStartingPlot();

					if(NULL != pStartingPlot)
					{
						int iDistance = ::plotDistance(pPlot->getX(), pPlot->getY(), pStartingPlot->getX(), pStartingPlot->getY());
						if(iDistance <= GC.getADVANCED_START_CITY_PLACEMENT_MAX_RANGE())
						{
							if(iDistance < iClosestDistance || (iDistance == iClosestDistance && getTeam() != kPlayer.getTeam()))
							{
								iClosestDistance = iDistance;
								eClosestPlayer = kPlayer.GetID();
							}
						}
					}
				}
			}

			if(NO_PLAYER == eClosestPlayer || GET_PLAYER(eClosestPlayer).getTeam() != getTeam())
			{
				return -1;
			}
			//Only allow founding a city at someone elses start point if
			//We have no cities and they have no cities.
			if((GetID() != eClosestPlayer) && ((getNumCities() > 0) || (GET_PLAYER(eClosestPlayer).getNumCities() > 0)))
			{
				return -1;
			}
		}
	}

	// Increase cost if the XML defines that additional units will cost more
	if(0 != GC.getADVANCED_START_CITY_COST_INCREASE())
	{
		if(!bAdd)
		{
			--iNumCities;
		}

		if(iNumCities > 0)
		{
			iCost *= 100 + GC.getADVANCED_START_CITY_COST_INCREASE() * iNumCities;
			iCost /= 100;
		}
	}

	return iCost;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing Population
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartPopCost(bool bAdd, CvCity* pCity)
{
	if(0 == getNumCities())
	{
		return -1;
	}

	int iCost = (getGrowthThreshold(1) * GC.getADVANCED_START_POPULATION_COST()) / 100;

	if(NULL != pCity)
	{
		if(pCity->getOwner() != GetID())
		{
			return -1;
		}

		int iPopulation = pCity->getPopulation();

		// Need to have Population to remove it
		if(!bAdd)
		{
			--iPopulation;

			if(iPopulation < GC.getINITIAL_CITY_POPULATION() + GC.getGame().getStartEraInfo().getFreePopulation())
			{
				return -1;
			}
		}

		iCost = (getGrowthThreshold(iPopulation) * GC.getADVANCED_START_POPULATION_COST()) / 100;

		// Increase cost if the XML defines that additional Pop will cost more
		if(0 != GC.getADVANCED_START_POPULATION_COST_INCREASE())
		{
			--iPopulation;

			if(iPopulation > 0)
			{
				iCost *= 100 + GC.getADVANCED_START_POPULATION_COST_INCREASE() * iPopulation;
				iCost /= 100;
			}
		}
	}

	return iCost;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing a Building from a city
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartBuildingCost(BuildingTypes eBuilding, bool bAdd, CvCity* pCity)
{
	if(0 == getNumCities())
	{
		return -1;
	}

	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if(pkBuildingInfo == NULL)
	{
		return -1;
	}

	int iCost = getProductionNeeded(eBuilding);

	if(iCost < 0)
	{
		return -1;
	}

	if(pkBuildingInfo->GetFreeStartEra() != NO_ERA && GC.getGame().getStartEra() >=  pkBuildingInfo->GetFreeStartEra())
	{
		// you get this building for free
		return -1;
	}

	if(NULL == pCity)
	{
		if(bAdd)
		{
			bool bValid = false;
			int iLoop;
			for(CvCity* pLoopCity = firstCity(&iLoop); NULL != pLoopCity; pLoopCity = nextCity(&iLoop))
			{
				if(pLoopCity->canConstruct(eBuilding))
				{
					bValid = true;
					break;
				}
			}

			if(!bValid)
			{
				return -1;
			}
		}
	}
	if(NULL != pCity)
	{
		if(pCity->getOwner() != GetID())
		{
			return -1;
		}

		iCost *= 100;
		iCost /= std::max(1, 100 + pCity->getProductionModifier(eBuilding));

		if(bAdd)
		{
			if(!pCity->canConstruct(eBuilding, true, false, false))
			{
				return -1;
			}
		}
		else
		{
			if(pCity->GetCityBuildings()->GetNumRealBuilding(eBuilding) <= 0)
			{
				return -1;
			}

			// Check other buildings in this city and make sure none of them require this one

			// Loop through Buildings to see which are present
			for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
			{
				const BuildingTypes eBuildingLoop = static_cast<BuildingTypes>(iBuildingLoop);
				CvBuildingEntry* pkBuildingLoopInfo = GC.getBuildingInfo(eBuildingLoop);
				if(pkBuildingLoopInfo)
				{
					if(pCity->GetCityBuildings()->GetNumBuilding(eBuildingLoop) > 0)
					{
						// Loop through present Building's requirements
						for(int iBuildingClassPrereqLoop = 0; iBuildingClassPrereqLoop < GC.getNumBuildingClassInfos(); iBuildingClassPrereqLoop++)
						{
							const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iBuildingClassPrereqLoop);
							CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
							if(pkBuildingClassInfo)
							{
								if(pkBuildingLoopInfo->IsBuildingClassNeededInCity(iBuildingClassPrereqLoop))
								{
									if((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(iBuildingClassPrereqLoop)) == eBuilding)
									{
										return -1;
									}
								}
#if defined(MOD_BALANCE_CORE)
								// Does this city have prereq buildings?
								if(MOD_BALANCE_CORE && pkBuildingLoopInfo->IsBuildingClassNeededAnywhere(iBuildingClassPrereqLoop))
								{
									int iNumBuildings = 0;
									BuildingTypes ePrereqBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(iBuildingClassPrereqLoop)));

									if(ePrereqBuilding != NO_BUILDING)
									{
										CvCity* pLoopCity;
										int iLoop;
										for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
										{
											if(pLoopCity->GetCityBuildings()->GetNumBuilding(ePrereqBuilding) > 0)
											{
												iNumBuildings++;
											}
										}
										if(iNumBuildings == 0)
										{
											return -1;
										}
									}
								}
								// Does this city have prereq buildings?
								if(MOD_BALANCE_CORE && pkBuildingLoopInfo->IsBuildingClassNeededNowhere(iBuildingClassPrereqLoop))
								{
									BuildingTypes ePrereqBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(iBuildingClassPrereqLoop)));

									if(ePrereqBuilding != NO_BUILDING)
									{
										CvCity* pLoopCity;
										int iLoop;
										for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
										{
											if(pLoopCity->GetCityBuildings()->GetNumBuilding(ePrereqBuilding) > 0)
											{
												return -1;
											}
										}
									}
								}
#endif
							}
						}
					}
				}
			}
		}
	}

	return iCost;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing Route
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartRouteCost(RouteTypes eRoute, bool bAdd, CvPlot* pPlot)
{
	if(0 == getNumCities())
	{
		return -1;
	}

	if(eRoute == NO_ROUTE)
	{
		return -1;
	}

	CvRouteInfo* pkRouteInfo = GC.getRouteInfo(eRoute);
	if(pkRouteInfo == NULL)
	{
		return -1;
	}

	int iCost = pkRouteInfo->getAdvancedStartCost();

	// This denotes cities may not be purchased through Advanced Start
	if(iCost < 0)
	{
		return -1;
	}

	iCost *= GC.getGame().getGameSpeedInfo().getBuildPercent();
	iCost /= 100;

	// No invalid plots!
	if(pPlot != NULL)
	{
		if(pPlot->isCity())
		{
			return -1;
		}

		if(bAdd)
		{
			if(!pPlot->isValidMovePlot(GetID()) || pPlot->isWater())
			{
				return -1;
			}
			// Can't place twice
			if(pPlot->getRouteType() == eRoute)
			{
				return -1;
			}
		}
		else
		{
			// Need Route to remove it
			if(pPlot->getRouteType() != eRoute)
			{
				return -1;
			}
		}

		// Must be owned by me
		if(pPlot->getOwner() != GetID())
		{
			return -1;
		}
	}

	// Tech requirement
	for(int iBuildLoop = 0; iBuildLoop < GC.getNumBuildInfos(); iBuildLoop++)
	{
		const BuildTypes eBuild = static_cast<BuildTypes>(iBuildLoop);
		CvBuildInfo* pkBuildInfo = GC.getBuildInfo(eBuild);
		if(pkBuildInfo)
		{
			if(pkBuildInfo->getRoute() == eRoute)
			{
				if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkBuildInfo->getTechPrereq())))
				{
					return -1;
				}
#if defined(MOD_BALANCE_CORE)
				else if(MOD_BALANCE_CORE && pkBuildInfo->getTechObsolete() != NO_TECH && (GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkBuildInfo->getTechObsolete())))
				{
					return -1;
				}
#endif
			}
		}
	}

	return iCost;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing Improvement
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartImprovementCost(ImprovementTypes eImprovement, bool bAdd, CvPlot* pPlot)
{
	if(eImprovement == NO_IMPROVEMENT)
	{
		return -1;
	}

	if(0 == getNumCities())
	{
		return -1;
	}

	int iCost = 0; //GC.getImprovementInfo(eImprovement)->GetAdvancedStartCost();

	// This denotes cities may not be purchased through Advanced Start
	if(iCost < 0)
	{
		return -1;
	}

	iCost *= GC.getGame().getGameSpeedInfo().getBuildPercent();
	iCost /= 100;

	// Can this Improvement be on our plot?
	if(pPlot != NULL)
	{
		if(bAdd)
		{
			// Valid Plot
			if(!pPlot->canHaveImprovement(eImprovement, GetID(), false))
			{
				return -1;
			}

			bool bValid = false;

			for(int iI = 0; iI < GC.getNumBuildInfos(); ++iI)
			{
				CvBuildInfo* pkBuildInfo = GC.getBuildInfo((BuildTypes) iI);
				if(!pkBuildInfo)
				{
					continue;
				}
				ImprovementTypes eLoopImprovement = ((ImprovementTypes)(pkBuildInfo->getImprovement()));

				if(eImprovement == eLoopImprovement && canBuild(pPlot, (BuildTypes)iI))
				{
					bValid = true;

					FeatureTypes eFeature = pPlot->getFeatureType();
					if(NO_FEATURE != eFeature && pkBuildInfo->isFeatureRemove(eFeature))
					{
						iCost += GC.getFeatureInfo(eFeature)->getAdvancedStartRemoveCost();
					}

					break;
				}
			}

			if(!bValid)
			{
				return -1;
			}

			// Can't place twice
			if(pPlot->getImprovementType() == eImprovement)
			{
				return -1;
			}
		}
		else
		{
			// Need this improvement in order to remove it
			if(pPlot->getImprovementType() != eImprovement)
			{
				return -1;
			}
		}

		// Must be owned by me
		if(pPlot->getOwner() != GetID())
		{
			return -1;
		}
	}

	// Tech requirement
	for(int iBuildLoop = 0; iBuildLoop < GC.getNumBuildInfos(); iBuildLoop++)
	{
		CvBuildInfo* pkBuildInfo = GC.getBuildInfo((BuildTypes) iBuildLoop);
		if(!pkBuildInfo)
		{
			continue;
		}

		if(pkBuildInfo->getImprovement() == eImprovement)
		{
			if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkBuildInfo->getTechPrereq())))
			{
				return -1;
			}
#if defined(MOD_BALANCE_CORE)
			else if(MOD_BALANCE_CORE && pkBuildInfo->getTechObsolete() != NO_TECH && (GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkBuildInfo->getTechObsolete())))
			{
				return -1;
			}
#endif
		}
	}

	return iCost;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing Tech
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartTechCost(TechTypes eTech, bool bAdd)
{
	if(eTech == NO_TECH)
	{
		return -1;
	}

	if(0 == getNumCities())
	{
		return -1;
	}

	int iCost = (GET_TEAM(getTeam()).GetTeamTechs()->GetResearchCost(eTech) * GC.getTechInfo(eTech)->GetAdvancedStartCost()) / 100;
	if(iCost < 0)
	{
		return -1;
	}

	if(bAdd)
	{
		if(!GetPlayerTechs()->CanResearch(eTech, false))
		{
			return -1;
		}
	}
	else if(!bAdd)
	{
		if(!GET_TEAM(getTeam()).GetTeamTechs()->HasTech(eTech))
		{
			return -1;
		}

		// Search through all techs to see if any of the currently owned ones requires this tech
		for(int iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)
		{
			TechTypes eTechLoop = (TechTypes) iTechLoop;

			if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech(eTechLoop))
			{
				int iPrereqLoop;

				// Or Prereqs
				for(iPrereqLoop = 0; iPrereqLoop < GC.getNUM_OR_TECH_PREREQS(); iPrereqLoop++)
				{
					if(GC.getTechInfo(eTechLoop)->GetPrereqOrTechs(iPrereqLoop) == eTech)
					{
						return -1;
					}
				}

				// And Prereqs
				for(iPrereqLoop = 0; iPrereqLoop < GC.getNUM_AND_TECH_PREREQS(); iPrereqLoop++)
				{
					if(GC.getTechInfo(eTechLoop)->GetPrereqAndTechs(iPrereqLoop) == eTech)
					{
						return -1;
					}
				}
			}
		}

		// If player has placed anything on the map which uses this tech then you cannot remove it
		int iLoop;

		// Units
		CvUnit* pLoopUnit;
		for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		{
			if(pLoopUnit->getUnitInfo().GetPrereqAndTech() == eTech)
			{
				return -1;
			}

			for(int iI = 0; iI < GC.getNUM_UNIT_AND_TECH_PREREQS(); iI++)
			{
				if(pLoopUnit->getUnitInfo().GetPrereqAndTechs(iI) == eTech)
				{
					return -1;
				}
			}
		}

		// Cities
		CvCity* pLoopCity;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			// All Buildings
			for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
			{
				const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
				CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
				if(pkBuildingInfo)
				{
					if(pLoopCity->GetCityBuildings()->GetNumRealBuilding(eBuilding) > 0)
					{
						if(pkBuildingInfo->GetPrereqAndTech() == eTech)
						{
							return -1;
						}

						for(int iI = 0; iI < GC.getNUM_BUILDING_AND_TECH_PREREQS(); iI++)
						{
							if(pkBuildingInfo->GetPrereqAndTechs(iI) == eTech)
							{
								return -1;
							}
						}
					}
				}
			}
		}

	}

	return iCost;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing Visibility
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartVisibilityCost(bool bAdd, CvPlot* pPlot)
{
	if(0 == getNumCities())
	{
		return -1;
	}

	int iNumVisiblePlots = 0;
	int iCost = GC.getADVANCED_START_VISIBILITY_COST();

	// This denotes Visibility may not be purchased through Advanced Start
	if(iCost == -1)
	{
		return -1;
	}

	// Valid Plot?
	if(pPlot != NULL)
	{
		if(bAdd)
		{
			if(pPlot->isRevealed(getTeam()))
			{
				return -1;
			}
			if(!pPlot->isAdjacentRevealed(getTeam()))
			{
				return -1;
			}
		}
		else
		{
			if(!pPlot->isRevealed(getTeam()))
			{
				return -1;
			}
		}
	}

	// Increase cost if the XML defines that additional units will cost more
	if(0 != GC.getADVANCED_START_VISIBILITY_COST_INCREASE())
	{
		const int nPlots = GC.getMap().numPlots();
		for(int iPlotLoop = 0; iPlotLoop < nPlots; iPlotLoop++)
		{
			CvPlot* pMapPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);

			if(pMapPlot->isRevealed(getTeam()))
			{
				++iNumVisiblePlots;
			}
		}

		if(!bAdd)
		{
			--iNumVisiblePlots;
		}

		if(iNumVisiblePlots > 0)
		{
			iCost *= 100 + GC.getADVANCED_START_VISIBILITY_COST_INCREASE() * iNumVisiblePlots;
			iCost /= 100;
		}
	}

	return iCost;
}

//	--------------------------------------------------------------------------------
void CvPlayer::doWarnings()
{
	if(m_eID == GC.getGame().getActivePlayer())
	{
		//update enemy units close to your territory
		int iMaxCount = range(((getNumCities() + 4) / 7), 2, 5);
		for(int iI = 0; iI < GC.getMap().numPlots(); iI++)
		{
			if(iMaxCount == 0)
			{
				break;
			}

			CvPlot* pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

			if(pLoopPlot->isAdjacentPlayer(GetID()))
			{
				if(!(pLoopPlot->isCity()))
				{
					if(pLoopPlot->isVisible(getTeam()))
					{
						CvUnit* pUnit = pLoopPlot->getVisibleEnemyDefender(GetID());
						if(pUnit != NULL)
						{
							CvCity* pNearestCity = GC.getMap().findCity(pLoopPlot->getX(), pLoopPlot->getY(), GetID(), NO_TEAM, !(pLoopPlot->isWater()));

							if(pNearestCity != NULL)
							{
								CvString message = GetLocalizedText("TXT_KEY_MISC_ENEMY_TROOPS_SPOTTED", pNearestCity->getNameKey());
								GC.GetEngineUserInterface()->AddPlotMessage(0, pLoopPlot->GetPlotIndex(), GetID(), true, GC.getEVENT_MESSAGE_TIME(), message);

								iMaxCount--;
							}
						}
					}
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::processPolicies(PolicyTypes ePolicy, int iChange)
{
	int iI, iJ;

	CvPolicyEntry* pPolicy = GC.getPolicyInfo(ePolicy);
	if(pPolicy == NULL)
		return;

#if defined(MOD_TRAITS_OTHER_PREREQS)
	if (MOD_TRAITS_OTHER_PREREQS) {
		GetPlayerTraits()->InitPlayerTraits();
	}
#endif

	const CvPolicyEntry& kPolicy = (*pPolicy);

	ChangeCulturePerWonder(pPolicy->GetCulturePerWonder() * iChange);
	ChangeCultureWonderMultiplier(pPolicy->GetCultureWonderMultiplier() * iChange);
	ChangeCulturePerTechResearched(pPolicy->GetCulturePerTechResearched() * iChange);
	ChangeGoldenAgeMeterMod(pPolicy->GetGoldenAgeMeterMod() * iChange);
	changeGoldenAgeModifier(pPolicy->GetGoldenAgeDurationMod() * iChange);
	changeWorkerSpeedModifier(pPolicy->GetWorkerSpeedModifier() * iChange);
	changeImprovementCostModifier(pPolicy->GetImprovementCostModifier() * iChange);
	changeImprovementUpgradeRateModifier(pPolicy->GetImprovementUpgradeRateModifier() * iChange);
	changeSpecialistProductionModifier(pPolicy->GetSpecialistProductionModifier() * iChange);
	changeMilitaryProductionModifier(pPolicy->GetMilitaryProductionModifier() * iChange);
	changeBaseFreeUnits(pPolicy->GetBaseFreeUnits() * iChange);
	ChangeHappinessPerGarrisonedUnit(pPolicy->GetHappinessPerGarrisonedUnit() * iChange);
	ChangeHappinessPerTradeRoute(pPolicy->GetHappinessPerTradeRoute() * iChange);
	ChangeHappinessPerXPopulation(pPolicy->GetHappinessPerXPopulation() * iChange);
#if defined(MOD_BALANCE_CORE_POLICIES)
	ChangeGreatGeneralCombatBonus(pPolicy->GetGreatGeneralExtraBonus() * iChange);
	ChangeExtraSupplyPerPopulation(pPolicy->GetExtraSupplyPerPopulation() * iChange);
	ChangeCSAlliesLowersPolicyNeedWonders(pPolicy->GetXCSAlliesLowersPolicyNeedWonders() * iChange);
	ChangeHappinessPerXPopulationGlobal(pPolicy->GetHappinessPerXPopulationGlobal() * iChange);
	ChangeIdeologyPoint(pPolicy->GetIdeologyPoint() * iChange);
	ChangeNoXPLossUnitPurchase(pPolicy->IsNoXPLossUnitPurchase() * iChange);
	ChangeEventTourism(pPolicy->GetEventTourism() * iChange);
	ChangeEventTourismCS(pPolicy->GetEventTourismCS() * iChange);
	ChangeMonopolyModFlat(pPolicy->GetMonopolyModFlat() * iChange);
	ChangeMonopolyModPercent(pPolicy->GetMonopolyModPercent() * iChange);
	ChangeTRVisionBoost(pPolicy->GetTRVisionBoost() * iChange);
	ChangeTRSpeedBoost(pPolicy->GetTRSpeedBoost() * iChange);
	ChangeExtraHappinessPerXPoliciesFromPolicies(pPolicy->GetHappinessPerXPolicies() * iChange);
	ChangeHappinessPerXGreatWorks(pPolicy->GetHappinessPerXGreatWorks() * iChange);
	ChangeMissionaryExtraStrength(pPolicy->GetExtraMissionaryStrength() * iChange);
	ChangeNumMissionarySpreads(pPolicy->GetExtraMissionarySpreads() * iChange);

	ChangePositiveWarScoreTourismMod(pPolicy->GetPositiveWarScoreTourismMod() * iChange);

	ChangeIsNoCSDecayAtWar(pPolicy->IsNoCSDecayAtWar() * iChange);
	ChangeCanBullyFriendlyCS(pPolicy->CanBullyFriendlyCS() * iChange);
	ChangeBullyGlobalCSReduction(pPolicy->GetBullyGlobalCSReduction() * iChange);
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	ChangeIsVassalsNoRebel(pPolicy->IsVassalsNoRebel() * iChange);
	ChangeVassalCSBonusModifier(pPolicy->GetVassalCSBonusModifier() * iChange);
#endif

	if(pPolicy->GetCorporationOfficesAsFranchises() != 0)
	{
		GetCorporations()->SetCorporationOfficesAsFranchises(pPolicy->GetCorporationOfficesAsFranchises() * iChange);
		GetCorporations()->RecalculateNumFranchises();
	}
	if(pPolicy->GetCorporationRandomForeignFranchiseMod() != 0)
	{
		GetCorporations()->SetCorporationRandomForeignFranchiseMod(pPolicy->GetCorporationRandomForeignFranchiseMod());
		GetCorporations()->RecalculateNumFranchises();
	}
	if(pPolicy->GetCorporationFreeFranchiseAbovePopular() != 0)
	{
		GetCorporations()->SetCorporationFreeFranchiseAbovePopular(pPolicy->GetCorporationFreeFranchiseAbovePopular() * iChange);
		GetCorporations()->RecalculateNumFranchises();
	}
	if (pPolicy->GetAdditionalNumFranchisesMod() > 0)
	{
		GetCorporations()->ChangeAdditionalNumFranchisesMod(pPolicy->GetAdditionalNumFranchisesMod() * iChange);
	}
	if (pPolicy->GetAdditionalNumFranchises() > 0)
	{
		GetCorporations()->ChangeAdditionalNumFranchises(pPolicy->GetAdditionalNumFranchises() * iChange);
	}

	if (pPolicy->IsNoForeignCorpsInCities())
	{
		GetCorporations()->SetNoForeignCorpsInCities(pPolicy->IsNoForeignCorpsInCities() * iChange);
	}
	if (pPolicy->IsNoFranchisesInForeignCities())
	{
		GetCorporations()->SetNoFranchisesInForeignCities(pPolicy->IsNoForeignCorpsInCities() * iChange);
	}

	if(pPolicy->IsUpgradeCSVassalTerritory())
	{
		ChangeUpgradeCSVassalTerritory(pPolicy->IsUpgradeCSVassalTerritory() * iChange);
	}
	if(pPolicy->GetArchaeologicalDigTourism() != 0)
	{
		ChangeArchaeologicalDigTourism(pPolicy->GetArchaeologicalDigTourism() * iChange);
	}
	if(pPolicy->GetGoldenAgeTourism() != 0)
	{
		ChangeGoldenAgeTourism(pPolicy->GetGoldenAgeTourism() * iChange);
	}
	if (pPolicy->GetExtraCultureandScienceTradeRoutes() != 0)
	{
		ChangeExtraCultureandScienceTradeRoutes(pPolicy->GetExtraCultureandScienceTradeRoutes() * iChange);
	}
	ChangeRazingSpeedBonus(pPolicy->GetRazingSpeedBonus() * iChange);
	ChangeNoPartisans(pPolicy->IsNoPartisans() * iChange);

	if(pPolicy->GetTradeRouteLandDistanceModifier() != 0)
	{
		changeTradeRouteLandDistanceModifier(pPolicy->GetTradeRouteLandDistanceModifier() * iChange);
	}
	if(pPolicy->GetTradeRouteSeaDistanceModifier() != 0)
	{
		changeTradeRouteSeaDistanceModifier(pPolicy->GetTradeRouteSeaDistanceModifier() * iChange);
	}
	if(pPolicy->GetEspionageModifier() != 0)
	{
		ChangeEspionageModifier(pPolicy->GetEspionageModifier() * iChange);
	}
	ChangeGreatScientistBeakerMod(pPolicy->GetGreatScientistBeakerModifier() * iChange);
	ChangeGreatEngineerHurryMod(pPolicy->GetGreatEngineerHurryModifier() * iChange);
	ChangeTechCostXCitiesModifier(pPolicy->GetTechCostXCitiesMod() * iChange);
	ChangeTourismCostXCitiesMod(pPolicy->GetTourismCostXCitiesMod() * iChange);
#endif
	ChangeExtraHappinessPerLuxury(pPolicy->GetExtraHappinessPerLuxury() * iChange);
	ChangeUnhappinessFromUnitsMod(pPolicy->GetUnhappinessFromUnitsMod() * iChange);
	ChangeUnhappinessMod(pPolicy->GetUnhappinessMod() * iChange);
	ChangeCityCountUnhappinessMod(pPolicy->GetCityCountUnhappinessMod() * iChange);
	ChangeOccupiedPopulationUnhappinessMod(pPolicy->GetOccupiedPopulationUnhappinessMod() * iChange);
	ChangeCapitalUnhappinessMod(pPolicy->GetCapitalUnhappinessMod() * iChange);
	ChangeWoundedUnitDamageMod(pPolicy->GetWoundedUnitDamageMod() * iChange);
	ChangeUnitUpgradeCostMod(pPolicy->GetUnitUpgradeCostMod() * iChange);
	ChangeBarbarianCombatBonus(pPolicy->GetBarbarianCombatBonus() * iChange);
	ChangeAlwaysSeeBarbCampsCount(pPolicy->IsAlwaysSeeBarbCamps() * iChange);
	ChangeMaxNumBuilders(pPolicy->GetNumExtraBuilders() * iChange);
	ChangePlotGoldCostMod(pPolicy->GetPlotGoldCostMod() * iChange);
#if defined(MOD_POLICIES_CITY_WORKING)
	ChangeCityWorkingChange(pPolicy->GetCityWorkingChange() * iChange);
#endif
#if defined(MOD_POLICIES_CITY_AUTOMATON_WORKERS)
	ChangeCityAutomatonWorkersChange(pPolicy->GetCityAutomatonWorkersChange() * iChange);
#endif
	ChangePlotCultureCostModifier(pPolicy->GetPlotCultureCostModifier() * iChange);
	ChangePlotCultureExponentModifier(pPolicy->GetPlotCultureExponentModifier() * iChange);
	ChangeNumCitiesPolicyCostDiscount(pPolicy->GetNumCitiesPolicyCostDiscount() * iChange);
	ChangeGarrisonFreeMaintenanceCount(pPolicy->IsGarrisonFreeMaintenance() * iChange);
	ChangeGarrisonedCityRangeStrikeModifier(pPolicy->GetGarrisonedCityRangeStrikeModifier() * iChange);
	ChangeUnitPurchaseCostModifier(pPolicy->GetUnitPurchaseCostModifier() * iChange);
	GetTreasury()->ChangeCityConnectionTradeRouteGoldModifier(pPolicy->GetCityConnectionTradeRouteGoldModifier() * iChange);
	changeGoldPerUnit(pPolicy->GetGoldPerUnit() * iChange);
	changeGoldPerMilitaryUnit(pPolicy->GetGoldPerMilitaryUnit() * iChange);
	ChangeCityStrengthMod(pPolicy->GetCityStrengthMod() * iChange);
	ChangeCityGrowthMod(pPolicy->GetCityGrowthMod() * iChange);
	ChangeCapitalGrowthMod(pPolicy->GetCapitalGrowthMod() * iChange);
	changeSettlerProductionModifier(pPolicy->GetSettlerProductionModifier() * iChange);
	changeCapitalSettlerProductionModifier(pPolicy->GetCapitalSettlerProductionModifier() * iChange);
	ChangeImprovementGoldMaintenanceMod(pPolicy->GetImprovementGoldMaintenanceMod() * iChange);
#if defined(MOD_CIV6_WORKER)
	ChangeRouteBuilderCostMod(pPolicy->GetRouteBuilderCostMod() * iChange);
#endif
	ChangeBuildingGoldMaintenanceMod(pPolicy->GetBuildingGoldMaintenanceMod() * iChange);
	ChangeUnitGoldMaintenanceMod(pPolicy->GetUnitGoldMaintenanceMod() * iChange);
	ChangeUnitSupplyMod(pPolicy->GetUnitSupplyMod() * iChange);
	changeHappyPerMilitaryUnit(pPolicy->GetHappyPerMilitaryUnit() * iChange);
	changeHappinessToCulture(pPolicy->GetHappinessToCulture() * iChange);
	changeHappinessToScience(pPolicy->GetHappinessToScience() * iChange);
	changeHalfSpecialistUnhappinessCount((pPolicy->IsHalfSpecialistUnhappiness()) ? iChange : 0);
	changeHalfSpecialistFoodCount((pPolicy->IsHalfSpecialistFood()) ? iChange : 0);
#if defined(MOD_BALANCE_CORE)
	changeHalfSpecialistFoodCapitalCount((pPolicy->IsHalfSpecialistFoodCapital()) ? iChange : 0);
#endif
	changeMilitaryFoodProductionCount((pPolicy->IsMilitaryFoodProduction()) ? iChange : 0);
	ChangeGoldenAgeCultureBonusDisabledCount((pPolicy->IsGoldenAgeCultureBonusDisabled()) ? iChange : 0);
	ChangeSecondReligionPantheonCount((pPolicy->IsSecondReligionPantheon()) ? iChange : 0);
	ChangeEnablesSSPartHurryCount((pPolicy->IsEnablesSSPartHurry()) ? iChange : 0);
	ChangeEnablesSSPartPurchaseCount((pPolicy->IsEnablesSSPartPurchase()) ? iChange : 0);
	changeMaxConscript(getWorldSizeMaxConscript(kPolicy) * iChange);
	changeExpModifier(pPolicy->GetExpModifier() * iChange);
	changeExpInBorderModifier(pPolicy->GetExpInBorderModifier() * iChange);
	changeMinorQuestFriendshipMod(pPolicy->GetMinorQuestFriendshipMod() * iChange);
	changeMinorGoldFriendshipMod(pPolicy->GetMinorGoldFriendshipMod() * iChange);
	ChangeMinorFriendshipAnchorMod(pPolicy->GetMinorFriendshipMinimum() * iChange);
	changeGetMinorFriendshipDecayMod(pPolicy->GetMinorFriendshipDecayMod() * iChange);
	ChangeMinorScienceAlliesCount(pPolicy->IsMinorScienceAllies() * iChange);
	ChangeMinorResourceBonusCount(pPolicy->IsMinorResourceBonus() * iChange);
	ChangeNewCityExtraPopulation(pPolicy->GetNewCityExtraPopulation() * iChange);
	ChangeFreeFoodBox(pPolicy->GetFreeFoodBox() * iChange);
	ChangeStrategicResourceMod(pPolicy->GetStrategicResourceMod() * iChange);
#if defined(MOD_BALANCE_CORE)
	if(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES_STRATEGIC && pPolicy->GetStrategicResourceMod() > 0)
	{
		for(int iLoop = 0; iLoop < GC.getNumResourceInfos(); iLoop++)
		{
			const ResourceTypes eResource = static_cast<ResourceTypes>(iLoop);
			CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
			if(pkResource && pkResource->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)
			{
				CheckForMonopoly(eResource);
			}
		}
	}
	for (iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
	{
		const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
		CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
		if (pkUnitClassInfo && pPolicy->GetUnitClassProductionModifiers(iI) != 0)
		{
			ChangeUnitClassProductionModifier(eUnitClass, (pPolicy->GetUnitClassProductionModifiers(iI) * iChange));
		}
	}
	
#endif
	ChangeAbleToAnnexCityStatesCount((pPolicy->IsAbleToAnnexCityStates()) ? iChange : 0);
	ChangeOnlyTradeSameIdeology((pPolicy->IsOnlyTradeSameIdeology()) ? iChange : 0);
	if (pPolicy->IsOnlyTradeSameIdeology())
	{
		for (int i = 0; i < MAX_CIV_PLAYERS; i++)
		{
			PlayerTypes eOtherPlayer = (PlayerTypes)i;
			if (eOtherPlayer != GetID() && GET_PLAYER(eOtherPlayer).isAlive() && !GET_PLAYER(eOtherPlayer).isMinorCiv())
			{
				if(GET_PLAYER(eOtherPlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE)
				{
					if (GET_PLAYER(eOtherPlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != GetPlayerPolicies()->GetLateGamePolicyTree())
					{
						GC.getGame().GetGameTrade()->CancelTradeBetweenTeams(GET_PLAYER(eOtherPlayer).getTeam(), getTeam());
					}
				}
			}
		}
	}
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	if(MOD_BALANCE_CORE_HAPPINESS)
	{
		ChangePovertyUnhappinessMod(pPolicy->GetPovertyHappinessChangePolicy() * iChange);
		ChangeDefenseUnhappinessMod(pPolicy->GetDefenseHappinessChangePolicy() * iChange);
		ChangeUnculturedUnhappinessMod(pPolicy->GetUnculturedHappinessChangePolicy() * iChange);
		ChangeIlliteracyUnhappinessMod(pPolicy->GetIlliteracyHappinessChangePolicy() * iChange);
		ChangeMinorityUnhappinessMod(pPolicy->GetMinorityHappinessChangePolicy() * iChange);
		ChangePovertyUnhappinessModCapital(pPolicy->GetPovertyHappinessChangePolicyCapital() * iChange);
		ChangeDefenseUnhappinessModCapital(pPolicy->GetDefenseHappinessChangePolicyCapital() * iChange);
		ChangeUnculturedUnhappinessModCapital(pPolicy->GetUnculturedHappinessChangePolicyCapital() * iChange);
		ChangeIlliteracyUnhappinessModCapital(pPolicy->GetIlliteracyHappinessChangePolicyCapital() * iChange);
		ChangeMinorityUnhappinessModCapital(pPolicy->GetMinorityHappinessChangePolicyCapital() * iChange);
		ChangePuppetUnhappinessMod(pPolicy->GetPuppetUnhappinessMod() * iChange);
		ChangeNoUnhappfromXSpecialists(pPolicy->GetNoUnhappfromXSpecialists() * iChange);
		ChangeHappfromXSpecialists(pPolicy->GetHappfromXSpecialists() * iChange);
		ChangeNoUnhappfromXSpecialistsCapital(pPolicy->GetNoUnhappfromXSpecialistsCapital() * iChange);
		ChangeSpecialistFoodChange(pPolicy->GetSpecialistFoodChange() * iChange);
		ChangeWarWearinessModifier(pPolicy->GetWarWearinessModifier() * iChange);
		ChangeWarScoreModifier(pPolicy->GetWarScoreModifier() * iChange);

	}
#endif
#if defined(MOD_BALANCE_CORE_POLICIES)
	if(MOD_BALANCE_CORE_POLICIES)
	{
		if (pPolicy->GetDefenseBoost() != 0)
		{
			int iLoop;
			CvCity* pLoopCity;
			for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				pLoopCity->updateStrengthValue();
			}
		}
		for (iI = 0; iI < GC.getNumResourceInfos(); iI++)
		{
			changeResourceFromCSAlliances((ResourceTypes)iI, (pPolicy->GetResourceFromCSAlly(iI) * iChange));
		}
		ChangeNoUnhappinessExpansion(pPolicy->GetNoUnhappinessExpansion() * iChange);
		ChangeNoUnhappyIsolation(pPolicy->GetNoUnhappyIsolation() * iChange);
		ChangeDoubleBorderGA(pPolicy->GetDoubleBorderGA() * iChange);
		changeGarrisonsOccupiedUnhapppinessMod(pPolicy->GetGarrisonsOccupiedUnhapppinessMod() * iChange);
		changeTradeReligionModifier(pPolicy->GetTradeReligionModifier() * iChange);
		changeFreeWCVotes(pPolicy->GetFreeWCVotes() * iChange);
		if (pPolicy->GetIncreasedQuestInfluence() != 0)
		{
			ChangeIncreasedQuestInfluence(pPolicy->GetIncreasedQuestInfluence() * iChange);
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
			{
				PlayerTypes ePlayer = (PlayerTypes)iPlayerLoop;
				CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);
				if (ePlayer != NO_PLAYER && kPlayer.isMinorCiv() && kPlayer.isAlive())
				{
					kPlayer.GetMinorCivAI()->RecalculateRewards(GetID());				
				}
			}
		}
		changeCultureBombBoost(pPolicy->GetCultureBombBoost() * iChange);
		changePuppetProdMod(pPolicy->GetPuppetProdMod() * iChange);
		changeOccupiedProdMod(pPolicy->GetOccupiedProdMod() * iChange);
		changeGoldInternalTrade(pPolicy->GetInternalTradeGold() * iChange);
		changeInfluenceGPExpend(pPolicy->GetInfluenceGPExpend() * iChange);
		changeFreeTradeRoute(pPolicy->GetFreeTradeRoute() * iChange);
		changeFreeSpy(pPolicy->GetFreeSpy() * iChange);

		changeReligionDistance(pPolicy->GetReligionDistance() * iChange);
		changePressureMod(pPolicy->GetPressureMod() * iChange);

		changeCityStateCombatModifier(pPolicy->GetCityStateCombatModifier() * iChange);

		if(GetFreeSpy() > 0)
		{
			CvPlayerEspionage* pEspionage = GetEspionage();
			CvAssertMsg(pEspionage, "pEspionage is null! What's up with that?!");
			if(pEspionage)
			{
				int iNumSpies = GetFreeSpy();
#if defined(MOD_BALANCE_CORE_SPIES)
				if (MOD_BALANCE_CORE_SPIES) {
					//Optional: Spies scaled for the number of City-States in the game.
					int iNumMinor = ((GC.getGame().GetNumMinorCivsEver() * /*15*/ GC.getBALANCE_SPY_TO_MINOR_RATIO()) / 100);
					if(iNumMinor > 1)
					{
						iNumSpies += iNumMinor;
					}
				}
#endif
				for(int i = 0; i < iNumSpies; i++)
				{
					pEspionage->CreateSpy();
				}
				changeFreeSpy(GetFreeSpy() * -1);
			}
		}
		
		int iLoop;
		CvCity* pLoopCity;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pPolicy->GetFreePopulation() > 0)
			{
				pLoopCity->changePopulation(pPolicy->GetFreePopulation(), true, true);
			}
			if (pPolicy->GetFreePopulationCapital() > 0 && pLoopCity->isCapital())
			{
				pLoopCity->changePopulation(pPolicy->GetFreePopulationCapital(), true, true);
			}
		}
		changeExtraMoves(pPolicy->GetExtraMoves() * iChange);

		if(pPolicy->GetXPopulationConscription() > 0)
		{
			changeXPopulationConscription(pPolicy->GetXPopulationConscription() * iChange);
			int iLoop;
			for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				if(pLoopCity == NULL)
				{
					continue;
				}
				if(pLoopCity->getPopulation() < GetXPopulationConscription())
				{
					continue;
				}
				if(pLoopCity->IsRazing())
				{
					continue;
				}
				if (GetNumUnitsOutOfSupply() > 0)
				{
					continue;
				}
				DoXPopulationConscription(pLoopCity);
			}
		}
	}
#endif
#if defined(MOD_BALANCE_CORE_BUILDING_INVESTMENTS)
	changeInvestmentModifier(pPolicy->GetInvestmentModifier() * iChange);

	changeMissionInfluenceModifier(pPolicy->GetMissionInfluenceModifier() * iChange);
	changeHappinessPerActiveTradeRoute(pPolicy->GetHappinessPerActiveTradeRoute() * iChange);
	changeCSResourcesCountMonopolies(pPolicy->IsCSResourcesForMonopolies() ? iChange : 0);

	changeNeedsModifierFromAirUnits(pPolicy->GetNeedsModifierFromAirUnits() * iChange);
	changeFlatDefenseFromAirUnits(pPolicy->GetFlatDefenseFromAirUnits() * iChange);
	changePuppetYieldPenaltyMod(pPolicy->GetPuppetYieldPenaltyMod() * iChange);
	changeConquestPerEraBuildingProductionMod(pPolicy->GetConquestPerEraBuildingProductionMod() * iChange);
	changeAdmiralLuxuryBonus(pPolicy->GetAdmiralLuxuryBonus() * iChange);

#endif
	if(pPolicy->IsOneShot())
	{
		if(m_pPlayerPolicies->HasOneShotPolicyFired(ePolicy))
		{
			return;
		}
		else
		{
			m_pPlayerPolicies->SetOneShotPolicyFired(ePolicy,true);
		}
	}

	GetPlayerPolicies()->ChangeNumExtraBranches(pPolicy->GetNumExtraBranches() * iChange);

	ChangeAllFeatureProduction(pPolicy->GetAllFeatureProduction());

	int iMod;
	YieldTypes eYield;

	for(iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		eYield = (YieldTypes) iI;

#if defined(MOD_BALANCE_CORE_POLICIES)
		changeYieldFromBirth(eYield, (pPolicy->GetYieldFromBirth(iI) * iChange));
		changeYieldFromBirthCapital(eYield, (pPolicy->GetYieldFromBirthCapital(iI) * iChange));

		changeYieldFromConstruction(eYield, (pPolicy->GetYieldFromConstruction(iI) * iChange));
		changeYieldFromwonderConstruction(eYield, (pPolicy->GetYieldFromWonderConstruction(iI) * iChange));

		changeYieldFromTech(eYield, (pPolicy->GetYieldFromTech(iI) * iChange));
		if (pPolicy->IsOpener() && pPolicy->GetYieldFromTech(iI) * iChange > 0)
		{
			int iTechValue = (GET_TEAM(getTeam() ).GetTeamTechs()->GetNumTechsKnown()-1) * pPolicy->GetYieldFromTech(iI);

			if (iTechValue > 0)
				doInstantYield(INSTANT_YIELD_TYPE_INSTANT, false, NO_GREATPERSON, NO_BUILDING, iTechValue, false, NO_PLAYER, NULL, false, getCapitalCity(), false, true, true, eYield);
		}
		changeYieldFromBorderGrowth(eYield, (pPolicy->GetYieldFromBorderGrowth(iI) * iChange));
		changeYieldGPExpend(eYield, (pPolicy->GetYieldGPExpend(iI) * iChange));
		changeConquerorYield(eYield, (pPolicy->GetConquerorYield(iI) * iChange));
		changeReligionYieldRateModifier(eYield, (pPolicy->GetReligionYieldMod(iI) * iChange));
		changeGoldenAgeYieldMod(eYield, (pPolicy->GetGoldenAgeYieldMod(iI) * iChange));
		changeFounderYield(eYield, (pPolicy->GetFounderYield(iI) * iChange));

		changeArtifactYieldBonus(eYield, (pPolicy->GetArtifactYieldChanges(iI) * iChange));
		changeArtYieldBonus(eYield, (pPolicy->GetArtYieldChanges(iI) * iChange));
		changeMusicYieldBonus(eYield, (pPolicy->GetMusicYieldChanges(iI) * iChange));
		changeLitYieldBonus(eYield, (pPolicy->GetLitYieldChanges(iI) * iChange));
		changeFilmYieldBonus(eYield, (pPolicy->GetFilmYieldChanges(iI) * iChange));
		changeRelicYieldBonus(eYield, (pPolicy->GetRelicYieldChanges(iI) * iChange));

		changeYieldFromNonSpecialistCitizens(eYield, (pPolicy->GetYieldFromNonSpecialistCitizens(iI) * iChange));
		changeYieldModifierFromGreatWorks(eYield, (pPolicy->GetYieldModifierFromGreatWorks(iI) * iChange));
		changeYieldModifierFromActiveSpies(eYield, (pPolicy->GetYieldModifierFromActiveSpies(iI) * iChange));
		changeYieldFromDelegateCount(eYield, (pPolicy->GetYieldFromDelegateCount(iI) * iChange));

		if (pPolicy->GetYieldFromBirthRetroactive(eYield) != 0)
		{
			int iLoop;
			for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				int iVal = pLoopCity->getPopulation() * pPolicy->GetYieldFromBirthRetroactive(eYield);
				doInstantYield(INSTANT_YIELD_TYPE_BIRTH_RETROACTIVE, false, NO_GREATPERSON, NO_BUILDING, iVal, true, NO_PLAYER, NULL, false, pLoopCity, false, true, false, eYield);
			}
		}

		if (pPolicy->GetYieldFromBirthCapitalRetroactive(eYield) != 0)
		{
			if (getCapitalCity() != NULL)
			{
				int iVal = getCapitalCity()->getPopulation() * pPolicy->GetYieldFromBirthCapitalRetroactive(eYield);
				doInstantYield(INSTANT_YIELD_TYPE_BIRTH_RETROACTIVE, false, NO_GREATPERSON, NO_BUILDING, iVal, true, NO_PLAYER, NULL, false, getCapitalCity(), false, true, false, eYield);
			}
		}
#endif

		iMod = pPolicy->GetYieldModifier(iI) * iChange;
		if(iMod != 0)
			changeYieldRateModifier(eYield, iMod);

		iMod = pPolicy->GetCityYieldChange(iI) * iChange;
		if(iMod != 0)
#if defined(MOD_BUGFIX_MINOR)
			ChangeCityYieldChangeTimes100(eYield, iMod * 100);
#else
			ChangeCityYieldChange(eYield, iMod * 100);
#endif

		iMod = pPolicy->GetCoastalCityYieldChange(iI) * iChange;
		if(iMod != 0)
			ChangeCoastalCityYieldChange(eYield, iMod);

		iMod = pPolicy->GetCapitalYieldChange(iI) * iChange;
		if(iMod != 0)
#if defined(MOD_BUGFIX_MINOR)
			ChangeCapitalYieldChangeTimes100(eYield, iMod * 100);
#else
			ChangeCapitalYieldChange(eYield, iMod * 100);
#endif

		iMod = pPolicy->GetCapitalYieldPerPopChange(iI) * iChange;
		if(iMod != 0)
			ChangeCapitalYieldPerPopChange(eYield, iMod);

		iMod = pPolicy->GetCapitalYieldPerPopChangeEmpire(iI) * iChange;
		if (iMod != 0)
			ChangeCapitalYieldPerPopChangeEmpire(eYield, iMod);

		iMod = pPolicy->GetCapitalYieldModifier(iI) * iChange;
		if(iMod != 0)
			changeCapitalYieldRateModifier(eYield, iMod);

		iMod = pPolicy->GetGreatWorkYieldChange(iI) * iChange;
		if(iMod != 0)
			ChangeGreatWorkYieldChange(eYield, iMod);

		iMod = pPolicy->GetSpecialistExtraYield(iI) * iChange;
		if(iMod != 0)
			changeSpecialistExtraYield(eYield, iMod);

#if defined(MOD_API_UNIFIED_YIELDS)
		iMod = pPolicy->GetYieldFromKills(iI) * iChange;
		if(iMod != 0)
			changeYieldFromKills(eYield, iMod);

		iMod = pPolicy->GetYieldFromBarbarianKills(iI) * iChange;
		if(iMod != 0)
			changeYieldFromBarbarianKills(eYield, iMod);

		iMod = pPolicy->GetYieldChangeTradeRoute(iI) * iChange;
		if(iMod != 0)
			ChangeYieldChangeTradeRoute(eYield, iMod);

		iMod = pPolicy->GetYieldChangesNaturalWonder(iI) * iChange;
		if(iMod != 0)
			ChangeYieldChangesNaturalWonder(eYield, iMod);

		iMod = pPolicy->GetYieldChangesPerReligionTimes100(iI) * iChange;
		if (iMod != 0)
			ChangeYieldChangesPerReligionTimes100(eYield, iMod);

		iMod = pPolicy->GetYieldChangeWorldWonder(iI) * iChange;
		if(iMod != 0)
			ChangeYieldChangeWorldWonder(eYield, iMod);

		iMod = pPolicy->GetYieldFromMinorDemand(iI) * iChange;
		if(iMod != 0)
			ChangeYieldFromMinorDemand(eYield, iMod);

		iMod = pPolicy->GetYieldFromWLTKD(iI) * iChange;
		if (iMod != 0)
			ChangeYieldFromWLTKD(eYield, iMod);
#endif
	}

	for(iI = 0; iI < GC.getNumUnitCombatClassInfos(); iI++)
	{
		changeUnitCombatProductionModifiers((UnitCombatTypes)iI, (pPolicy->GetUnitCombatProductionModifiers(iI) * iChange));
		changeUnitCombatFreeExperiences((UnitCombatTypes)iI, (pPolicy->GetUnitCombatFreeExperiences(iI) * iChange));
	}

	for(iI = 0; iI < GC.getNumHurryInfos(); iI++)
	{
		if(GC.getHurryInfo((HurryTypes) iI)->getPolicyPrereq() == ePolicy)
		{
			changeHurryCount(((HurryTypes)iI), iChange);
		}
		{
			changeHurryModifier((HurryTypes) iI, (pPolicy->GetHurryModifier(iI) * iChange));
		}
	}

#if defined(MOD_API_UNIFIED_YIELDS) && defined(MOD_API_PLOT_YIELDS)
	for(iI = 0; iI < GC.getNumPlotInfos(); iI++)
	{
		for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
		{
			changePlotYieldChange(((PlotTypes)iI), ((YieldTypes)iJ), (pPolicy->GetPlotYieldChanges(iI, iJ) * iChange));
		}
	}
#endif

#if defined(MOD_API_UNIFIED_YIELDS)
	for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
	{
		for(iI = 0; iI < GC.getNumFeatureInfos(); iI++)
		{
			changeFeatureYieldChange(((FeatureTypes)iI), ((YieldTypes)iJ), (pPolicy->GetFeatureYieldChanges(iI, iJ) * iChange));
		}

		for(iI = 0; iI < GC.getNumFeatureInfos(); iI++)
		{
			changeCityYieldFromUnimprovedFeature(((FeatureTypes)iI), ((YieldTypes)iJ), (pPolicy->GetCityYieldFromUnimprovedFeature(iI, iJ) * iChange));
			changeUnimprovedFeatureYieldChange(((FeatureTypes)iI), ((YieldTypes)iJ), (pPolicy->GetUnimprovedFeatureYieldChanges(iI, iJ) * iChange));
		}

		for(iI = 0; iI < GC.getNumResourceInfos(); iI++)
		{
			changeResourceYieldChange(((ResourceTypes)iI), ((YieldTypes)iJ), (pPolicy->GetResourceYieldChanges(iI, iJ) * iChange));
		}

		for(iI = 0; iI < GC.getNumTerrainInfos(); iI++)
		{
			changeTerrainYieldChange(((TerrainTypes)iI), ((YieldTypes)iJ), (pPolicy->GetTerrainYieldChanges(iI, iJ) * iChange));
		}

		for(iI = 0; iI < NUM_DOMAIN_TYPES; iI++)
		{
			changeTradeRouteYieldChange(((DomainTypes)iI), ((YieldTypes)iJ), (pPolicy->GetTradeRouteYieldChange(iI, iJ) * iChange));
		}

		for(iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
		{
			changeSpecialistYieldChange(((SpecialistTypes)iI), ((YieldTypes)iJ), (pPolicy->GetSpecialistYieldChanges(iI, iJ) * iChange));
		}

		for(iI = 0; iI < GC.getNumGreatPersonInfos(); iI++)
		{
			changeGreatPersonExpendedYield(((GreatPersonTypes)iI), ((YieldTypes)iJ), (pPolicy->GetGreatPersonExpendedYield(iI, iJ) * iChange));
		}
	}

	for(iI = 0; iI < GC.getNumGreatPersonInfos(); iI++)
	{
		iMod = pPolicy->GetGoldenAgeGreatPersonRateModifier(iI) * iChange;
		if(iMod != 0)
			changeGoldenAgeGreatPersonRateModifier((GreatPersonTypes)iI, iMod);
	}
#endif

	for(iI = 0; iI < GC.getNumImprovementInfos(); iI++)
	{
		for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
		{
			changeImprovementYieldChange(((ImprovementTypes)iI), ((YieldTypes)iJ), (pPolicy->GetImprovementYieldChanges(iI, iJ) * iChange));
		}
	}

	// Free Promotions
	PromotionTypes ePromotion;
	for(iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		ePromotion = (PromotionTypes) iI;

		if(pPolicy->IsFreePromotion(ePromotion))
			ChangeFreePromotionCount(ePromotion, iChange);
	}

	CvCity* pLoopCity;
	PlayerTypes ePlayer;

	// All player Capital Locations Revealed
	if(pPolicy->IsRevealAllCapitals())
	{
		for(iI = 0; iI < MAX_CIV_PLAYERS; iI++)
		{
			ePlayer = (PlayerTypes) iI;

			if(GET_PLAYER(ePlayer).isAlive())
			{
				pLoopCity = GET_PLAYER(ePlayer).getCapitalCity();

				if(pLoopCity != NULL)
				{
					pLoopCity->plot()->setRevealed(getTeam(), true);
				}
			}
		}
	}

	// Friendship Decay for OTHER PLAYERS
	CvNotifications* pNotifications;
	Localization::String locString;
	Localization::String locSummary;

	int iOtherPlayersDecay = pPolicy->GetOtherPlayersMinorFriendshipDecayMod();
	if(iOtherPlayersDecay != 0)
	{
		for(iI = 0; iI < MAX_MAJOR_CIVS; iI++)
		{
			ePlayer = (PlayerTypes) iI;

			if(GET_PLAYER(ePlayer).isEverAlive())
			{
				// Don't hurt us or teammates
				if(GET_PLAYER(ePlayer).getTeam() != getTeam())
				{
#if defined(MOD_BALANCE_CORE)
					if(GET_PLAYER(ePlayer).GetMinorFriendshipDecayMod() <= 0)
					{
						// Send notification to affected players
						locString = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_FRIENDSHIP_DECAY");
						locString << getNameKey();
						locSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MINOR_FRIENDSHIP_DECAY");

						pNotifications = GET_PLAYER(ePlayer).GetNotifications();
						if(pNotifications)
						{
							pNotifications->Add(NOTIFICATION_DIPLOMACY_DECLARATION, locString.toUTF8(), locSummary.toUTF8(), -1, -1, -1);
						}
					}
#endif
					GET_PLAYER(ePlayer).changeGetMinorFriendshipDecayMod(iOtherPlayersDecay * iChange);
#if !defined(MOD_BALANCE_CORE)
					// Send notification to affected players
					locString = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_FRIENDSHIP_DECAY");
					locString << getNameKey();
					locSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MINOR_FRIENDSHIP_DECAY");

					pNotifications = GET_PLAYER(ePlayer).GetNotifications();
					if(pNotifications)
					{
						pNotifications->Add(NOTIFICATION_DIPLOMACY_DECLARATION, locString.toUTF8(), locSummary.toUTF8(), -1, -1, -1);
					}
#endif
				}
			}
		}
	}

	BuildingClassTypes eBuildingClass;
	BuildingTypes eBuilding;
	int iBuildingCount;
	int iYieldMod;
	int iYieldChange;

	// How many cities get free culture buildings?
	int iNumCitiesFreeCultureBuilding = pPolicy->GetNumCitiesFreeCultureBuilding();
	int iNumCitiesFreeFoodBuilding = pPolicy->GetNumCitiesFreeFoodBuilding();

	// Loop through Cities
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(iNumCitiesFreeCultureBuilding > 0)
		{
			BuildingTypes eCultureBuilding = pLoopCity->ChooseFreeCultureBuilding();
			if(eCultureBuilding != NO_BUILDING)
			{
				pLoopCity->GetCityBuildings()->SetNumFreeBuilding(eCultureBuilding, 1);

				if(pLoopCity->getFirstBuildingOrder(eCultureBuilding) == 0)
				{
					pLoopCity->clearOrderQueue();
					pLoopCity->chooseProduction();		// Send a notification to the user that what they were building was given to them, and they need to produce something else.
				}
			}
			else
			{
				pLoopCity->SetOwedCultureBuilding(true);
			}

			// Decrement cities left to get free culture building (at end of loop we'll set the remainder)
			iNumCitiesFreeCultureBuilding--;
		}

		if(iNumCitiesFreeFoodBuilding > 0)
		{
			BuildingTypes eFoodBuilding = pLoopCity->ChooseFreeFoodBuilding();
			if(eFoodBuilding != NO_BUILDING)
			{
				pLoopCity->GetCityBuildings()->SetNumFreeBuilding(eFoodBuilding, 1);

				if(pLoopCity->getFirstBuildingOrder(eFoodBuilding) == 0)
				{
					pLoopCity->clearOrderQueue();
					pLoopCity->chooseProduction();		// Send a notification to the user that what they were building was given to them, and they need to produce something else.
				}
			}
#if defined(MOD_BUGFIX_FREE_FOOD_BUILDING)
			else
			{
				pLoopCity->SetOwedFoodBuilding(true);
			}
#endif

			// Decrement cities left to get free food building (at end of loop we'll set the remainder)
			iNumCitiesFreeFoodBuilding--;
		}

		// Free Culture-per-turn in every City
		int iCityCultureChange = pPolicy->GetCulturePerCity() * iChange;
		if(pLoopCity->HasGarrison())
		{
			iCityCultureChange += (pPolicy->GetCulturePerGarrisonedUnit() * iChange);
		}

		pLoopCity->ChangeJONSCulturePerTurnFromPolicies(iCityCultureChange);
		
#if defined(MOD_API_UNIFIED_YIELDS)
		int iTotalWonders = 0;
#endif

		// Building modifiers
		for(iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
		{
			eBuildingClass = (BuildingClassTypes) iI;

			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
			if(!pkBuildingClassInfo)
			{
				continue;
			}

			eBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

			if(eBuilding != NO_BUILDING)
			{
				CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
				if(pkBuilding)
				{
					iBuildingCount = pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding);

					if(iBuildingCount > 0)
					{
#if defined(MOD_API_UNIFIED_YIELDS)
						if (::isWorldWonderClass(pkBuilding->GetBuildingClassInfo())) 
						{
							iTotalWonders += iBuildingCount;
						}
#endif
						
#if defined(MOD_API_UNIFIED_YIELDS)
						iYieldMod = pPolicy->GetBuildingClassYieldModifiers(eBuildingClass, YIELD_CULTURE);
						if (iYieldMod != 0)
						{
							pLoopCity->changeYieldRateModifier(YIELD_CULTURE, iYieldMod * iBuildingCount * iChange);
						}
						iYieldChange = pPolicy->GetBuildingClassCultureChange(eBuildingClass);
						iYieldChange += pPolicy->GetBuildingClassYieldChanges(eBuildingClass, YIELD_CULTURE);
						if (iYieldChange != 0)
						{
							pLoopCity->ChangeJONSCulturePerTurnFromPolicies(iYieldChange * iBuildingCount * iChange);
#if defined(MOD_BALANCE_CORE_POLICIES)
							pLoopCity->changeBuildingClassCultureChange(eBuildingClass, (iYieldChange * iBuildingCount * iChange));
						}
						//Policy-Religion Fusion Yield Changes
						iYieldChange = pPolicy->GetReligionBuildingYieldMod(eBuildingClass, YIELD_CULTURE);
						if (MOD_BALANCE_CORE_POLICIES && iYieldChange != 0)
						{
							pLoopCity->changeReligionBuildingYieldRateModifier(eBuildingClass, YIELD_CULTURE, (iYieldChange * iBuildingCount * iChange));
#endif
						}
#else
						pLoopCity->ChangeJONSCulturePerTurnFromPolicies(pPolicy->GetBuildingClassCultureChange(eBuildingClass) * iBuildingCount * iChange);
#endif

						// Building Class Yield Stuff
						for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
						{
							switch(iJ)
							{
							case YIELD_CULTURE:
								// Skip, handled above
								break;
							case YIELD_FAITH:
#if defined(MOD_API_UNIFIED_YIELDS)
								{
									eYield = (YieldTypes) iJ;
									iYieldMod = pPolicy->GetBuildingClassYieldModifiers(eBuildingClass, eYield);
									if (iYieldMod != 0)
									{
										pLoopCity->changeYieldRateModifier(eYield, iYieldMod * iBuildingCount * iChange);
									}
									iYieldChange = pPolicy->GetBuildingClassYieldChanges(eBuildingClass, eYield);
									if (iYieldChange != 0)
									{
										pLoopCity->ChangeFaithPerTurnFromPolicies(iYieldChange * iBuildingCount * iChange);
									}
#if defined(MOD_BALANCE_CORE_POLICIES)
									//Policy-Religion Fusion Yield Changes
									iYieldChange = pPolicy->GetReligionBuildingYieldMod(eBuildingClass, eYield);
									if (MOD_BALANCE_CORE_POLICIES && iYieldChange != 0)
									{
										pLoopCity->changeReligionBuildingYieldRateModifier(eBuildingClass, eYield, (iYieldChange * iBuildingCount * iChange));
									}
#endif
								}
#else
								pLoopCity->ChangeFaithPerTurnFromPolicies(pPolicy->GetBuildingClassYieldChanges(eBuildingClass, iJ) * iBuildingCount * iChange);
#endif
								break;
							default:
								{
									eYield = (YieldTypes) iJ;
									iYieldMod = pPolicy->GetBuildingClassYieldModifiers(eBuildingClass, eYield);
#if defined(MOD_BALANCE_CORE)
									if (iYieldMod != 0)
#else
									if (iYieldMod > 0)
#endif
									{
										pLoopCity->changeYieldRateModifier(eYield, iYieldMod * iBuildingCount * iChange);
									}
									iYieldChange = pPolicy->GetBuildingClassYieldChanges(eBuildingClass, eYield);
									if (iYieldChange != 0)
									{
										pLoopCity->ChangeBaseYieldRateFromBuildings(eYield, iYieldChange * iBuildingCount * iChange);
									}
#if defined(MOD_BALANCE_CORE_POLICIES)
									//Policy-Religion Fusion Yield Changes
									iYieldChange = pPolicy->GetReligionBuildingYieldMod(eBuildingClass, eYield);
									if (MOD_BALANCE_CORE_POLICIES && iYieldChange != 0)
									{
										pLoopCity->changeReligionBuildingYieldRateModifier(eBuildingClass, eYield, (iYieldChange * iBuildingCount * iChange));
									}
#endif
								}
							}
						}
					}
				}
			}
		}

#if defined(MOD_API_UNIFIED_YIELDS)
		if (iTotalWonders > 0) {
			for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				YieldTypes eYield = (YieldTypes) iI;
				int iYield = pPolicy->GetYieldChangeWorldWonder(iI);

#if !defined(MOD_API_UNIFIED_YIELDS_CONSOLIDATION)
				if (eYield == YIELD_CULTURE)
				{
					pLoopCity->ChangeJONSCulturePerTurnFromBuildings(iYield * iTotalWonders * iChange);
				}
				else if (eYield == YIELD_FAITH)
				{
					pLoopCity->ChangeFaithPerTurnFromBuildings(iYield * iTotalWonders * iChange);
				}
				else
#endif
				{
					pLoopCity->ChangeBaseYieldRateFromBuildings(eYield, iYield * iTotalWonders * iChange);
				}
			}
		}
#endif
	}
#if defined(MOD_BALANCE_CORE)
	// Free Buildings from Policies
	if(MOD_BALANCE_CORE)
	{
		for(iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
		{
			const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iI);
			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
			if(pkBuildingClassInfo)
			{
				int iNumFreeBuildings = pPolicy->GetFreeChosenBuilding(eBuildingClass);
				if(iNumFreeBuildings > 0 || (pPolicy->GetAllCityFreeBuilding() == eBuildingClass))
				{
					const BuildingTypes eBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(pkBuildingClassInfo->GetID())));
					if(NO_BUILDING != eBuilding)
					{
						CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
						if(pkBuildingInfo)
						{
							ChangeNumCitiesFreeChosenBuilding(eBuildingClass, iNumFreeBuildings);
							ChangeAllCityFreeBuilding(eBuildingClass, (pPolicy->GetAllCityFreeBuilding() == eBuildingClass) * iChange);
							int iLoopTwo;
							for(pLoopCity = firstCity(&iLoopTwo); pLoopCity != NULL; pLoopCity = nextCity(&iLoopTwo))
							{
								if(pLoopCity->isValidBuildingLocation(eBuilding))
								{
									if (GetNumCitiesFreeChosenBuilding(eBuildingClass) > 0 || IsFreeBuildingAllCity(eBuildingClass))
									{
										if(pLoopCity->GetCityBuildings()->GetNumRealBuilding(eBuilding) > 0)
										{
											pLoopCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, 0);
										}

										pLoopCity->GetCityBuildings()->SetNumFreeBuilding(eBuilding, 1);

										if(pLoopCity->GetCityBuildings()->GetNumFreeBuilding(eBuilding) > 0)
										{
											ChangeNumCitiesFreeChosenBuilding(eBuildingClass, -1);
										}
										if(pLoopCity->getFirstBuildingOrder(eBuilding) == 0)
										{
											pLoopCity->clearOrderQueue();
											pLoopCity->chooseProduction();
											// Send a notification to the user that what they were building was given to them, and they need to produce something else.
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if (pPolicy->GetNewCityFreeBuilding() != NO_BUILDINGCLASS)
	{
		ChangeFreeChosenBuildingNewCity(pPolicy->GetNewCityFreeBuilding(), iChange);
	}
	if (pPolicy->GetNewFoundCityFreeBuilding() != NO_BUILDINGCLASS)
	{
		ChangeNewFoundCityFreeBuilding(pPolicy->GetNewFoundCityFreeBuilding(), iChange);
	}
	if (pPolicy->GetNewFoundCityFreeUnit() != NO_UNITCLASS)
	{
		ChangeNewFoundCityFreeUnit(pPolicy->GetNewFoundCityFreeUnit(), iChange);
	}
#endif

	// Store off number of newly built cities that will get a free building
	ChangeNumCitiesFreeCultureBuilding(iNumCitiesFreeCultureBuilding);
	ChangeNumCitiesFreeFoodBuilding(iNumCitiesFreeFoodBuilding);

	// Not really techs but this is what we use (for now)
	for(iI = 0; iI < GC.getNUM_AND_TECH_PREREQS(); iI++)
	{
		if(pPolicy->GetPolicyDisables(iI) != NO_POLICY)
		{
			if(m_pPlayerPolicies->HasPolicy((PolicyTypes) pPolicy->GetPolicyDisables(iI)))
			{
				setHasPolicy((PolicyTypes) pPolicy->GetPolicyDisables(iI), false);
			}
		}
	}

	// Attack bonus for a period of time
	int iTurns = pPolicy->GetAttackBonusTurns() * iChange;
	if(iTurns > 0)
	{
		if (MOD_BALANCE_CORE_MILITARY_PROMOTION_ADVANCED)
		{
			iTurns *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iTurns /= 100;
		}
		ChangeAttackBonusTurns(iTurns);
	}

	// Golden Age!
	int iGoldenAgeTurns = pPolicy->GetGoldenAgeTurns() * iChange;
	if(iGoldenAgeTurns > 0)
	{
		// Player modifier
		int iLengthModifier = getGoldenAgeModifier();
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
		// Do we get increased Golden Ages from a resource monopoly?
		if(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
		{
			for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
			{
				ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
				if(eResourceLoop != NO_RESOURCE)
				{
					CvResourceInfo* pInfo = GC.getResourceInfo(eResourceLoop);
					if (pInfo && pInfo->isMonopoly())
					{
						if(HasGlobalMonopoly(eResourceLoop) && pInfo->getMonopolyGALength() > 0)
						{
							int iTemp = pInfo->getMonopolyGALength();
							iTemp += GetMonopolyModPercent();
							iLengthModifier += iTemp;
						}
					}
				}
			}
		}
#endif
		// Trait modifier
		iLengthModifier += GetPlayerTraits()->GetGoldenAgeDurationModifier();

		if(iLengthModifier > 0)
		{
			iGoldenAgeTurns = iGoldenAgeTurns * (100 + iLengthModifier) / 100;
		}

		// Game Speed mod
		iGoldenAgeTurns *= GC.getGame().getGameSpeedInfo().getGoldenAgePercent();
		iGoldenAgeTurns /= 100;
#if defined(MOD_BALANCE_CORE)
		int iValue = GetGoldenAgeProgressMeter();
		changeGoldenAgeTurns(iGoldenAgeTurns, iValue);
#else
		changeGoldenAgeTurns(iGoldenAgeTurns);
#endif
	}

	// Free Techs
	int iNumFreeTechs = pPolicy->GetNumFreeTechs() * iChange;
	if(iNumFreeTechs > 0)
	{
		if(!isHuman())
		{
			for(iI = 0; iI < iNumFreeTechs; iI++)
			{
				AI_chooseFreeTech();
			}
		}
		else
		{
			CvString strBuffer = GetLocalizedText("TXT_KEY_MISC_COMPLETED_WONDER_CHOOSE_TECH", pPolicy->GetTextKey());
			chooseTech(iNumFreeTechs, strBuffer.GetCString());
		}
	}

	ChangeMedianTechPercentage(pPolicy->GetMedianTechPercentChange());

	// Free Policies
	int iNumFreePolicies = pPolicy->GetNumFreePolicies() * iChange;
	if(iNumFreePolicies > 0)
	{
		ChangeNumFreePolicies(iNumFreePolicies);
	}

	if(pPolicy->IncludesOneShotFreeUnits())
	{
		if(!m_pPlayerPolicies->HaveOneShotFreeUnitsFired(ePolicy))
		{
			m_pPlayerPolicies->SetOneShotFreeUnitsFired(ePolicy,true);

			int iNumFreeGreatPeople = pPolicy->GetNumFreeGreatPeople() * iChange;
			if(iNumFreeGreatPeople > 0)
			{
				ChangeNumFreeGreatPeople(iNumFreeGreatPeople);
			}

			if(getCapitalCity() != NULL)
			{
				int iX = getCapitalCity()->getX();
				int iY = getCapitalCity()->getY();

				for(iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
				{
					const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
					CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
					if(pkUnitClassInfo)
					{
						int iNumFreeUnits = pPolicy->GetNumFreeUnitsByClass(eUnitClass);
						if(iNumFreeUnits > 0)
						{
							const UnitTypes eUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eUnitClass);
							CvUnitEntry* pUnitEntry = GC.getUnitInfo(eUnit);
							if (isHuman() && pUnitEntry != NULL && pUnitEntry->IsFound() && GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE))
							{
								continue;
							}

							for(int iUnitLoop = 0; iUnitLoop < iNumFreeUnits; iUnitLoop++)
							{
								CvUnit* pNewUnit = NULL;
								// for venice
								if (pUnitEntry->IsFound() && GetPlayerTraits()->IsNoAnnexing())
								{
									// drop a merchant of venice instead
									// find the eUnit replacement that's the merchant of venice
									for(int iVeniceSearch = 0; iVeniceSearch < GC.getNumUnitClassInfos(); iVeniceSearch++)
									{
										const UnitClassTypes eVeniceUnitClass = static_cast<UnitClassTypes>(iVeniceSearch);
										CvUnitClassInfo* pkVeniceUnitClassInfo = GC.getUnitClassInfo(eVeniceUnitClass);
										if(pkVeniceUnitClassInfo)
										{
											const UnitTypes eMerchantOfVeniceUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eVeniceUnitClass);
											if (eMerchantOfVeniceUnit != NO_UNIT)
											{
												CvUnitEntry* pVeniceUnitEntry = GC.getUnitInfo(eMerchantOfVeniceUnit);
												if (pVeniceUnitEntry->IsCanBuyCityState())
												{
													pNewUnit = initUnit(eMerchantOfVeniceUnit, iX, iY);				
													break;
												}
											}
										}
									}
								}
								else
								{
									pNewUnit = initUnit(eUnit, iX, iY);
								}

								if (pNewUnit)
								{
#if defined(MOD_BALANCE_CORE)
									if(pNewUnit->isWLKTKDOnBirth())
									{
										CvCity* pLoopCity;
										int iLoop;
										for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
										{
											if(pLoopCity != NULL && pLoopCity->getOwner() == GetID())
											{
												int iWLTKD = (GC.getCITY_RESOURCE_WLTKD_TURNS() / 3);

												iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
												iWLTKD /= 100;

												if (iWLTKD > 0)
												{
													pLoopCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
													CvNotifications* pNotifications = GetNotifications();
													if (pNotifications)
													{
														Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UNIT");
														strText << pNewUnit->getNameKey() << pLoopCity->getNameKey();
														Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UNIT");
														strSummary << pLoopCity->getNameKey();
														pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pLoopCity->getX(), pLoopCity->getY(), -1);
													}
												}
											}
										}
									}
									if(pNewUnit->isGoldenAgeOnBirth())
									{
										int iGoldenAgeTurns = getGoldenAgeLength();
										int iValue = GetGoldenAgeProgressMeter();
										changeGoldenAgeTurns(iGoldenAgeTurns, iValue);
									}
									if(pNewUnit->isCultureBoost())
									{
										int iValue = GetTotalJONSCulturePerTurn() * 4;
										changeJONSCulture(iValue);
										if(getCapitalCity() != NULL)
										{
											getCapitalCity()->ChangeJONSCultureStored(iValue);
										}
										CvNotifications* pNotifications = GetNotifications();
										if (pNotifications)
										{
											Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CULTURE_UNIT");
											strText << pNewUnit->getNameKey();
											Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CULTURE_UNIT");
											strSummary << pNewUnit->getNameKey();
											pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pNewUnit->getX(), pNewUnit->getY(), -1);
										}
									}
#endif
									if(pNewUnit->IsGreatGeneral())
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGreatGeneralsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGreatGeneralsCreated();
#endif
										bool bJumpSuccess = pNewUnit->jumpToNearestValidPlot();
										if (bJumpSuccess)
										{
											getCapitalCity()->addProductionExperience(pNewUnit);
										}
										else
										{
											pNewUnit->kill(false);
										}
									}
									else if(pNewUnit->IsGreatAdmiral())
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGreatAdmiralsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGreatAdmiralsCreated();
#endif
										CvPlot *pSpawnPlot = GetGreatAdmiralSpawnPlot(pNewUnit);
										if (pNewUnit->plot() != pSpawnPlot)
										{
											pNewUnit->setXY(pSpawnPlot->getX(), pSpawnPlot->getY());
											getCapitalCity()->addProductionExperience(pNewUnit);
										}
									}
									else if(pNewUnit->getUnitInfo().IsFoundReligion())
									{
										ReligionTypes eReligion = GetReligions()->GetReligionCreatedByPlayer();
										if (eReligion == NO_RELIGION)
										{
											eReligion = GetReligions()->GetReligionInMostCities();
										}
										int iReligionSpreads = pNewUnit->getUnitInfo().GetReligionSpreads();
										int iReligiousStrength = pNewUnit->getUnitInfo().GetReligiousStrength();
#if defined(MOD_BALANCE_CORE)
										iReligiousStrength *= (100 + GetPlayerTraits()->GetExtraMissionaryStrength());
										iReligiousStrength /= 100;
#endif
										if(iReligionSpreads > 0 && eReligion > RELIGION_PANTHEON)
										{
#if defined(MOD_BUGFIX_EXTRA_MISSIONARY_SPREADS)
											if (MOD_BUGFIX_EXTRA_MISSIONARY_SPREADS)
											{
												if (GetHolyCity() && GetHolyCity()->getOwner() == GetID())
												{
													pNewUnit->GetReligionData()->SetSpreadsLeft(iReligionSpreads + GetHolyCity()->GetCityBuildings()->GetMissionaryExtraSpreads() + GetNumMissionarySpreads());
												}
												else if (getCapitalCity())
												{
													pNewUnit->GetReligionData()->SetSpreadsLeft(iReligionSpreads + getCapitalCity()->GetCityBuildings()->GetMissionaryExtraSpreads() + GetNumMissionarySpreads());
												}
												else
												{
													pNewUnit->GetReligionData()->SetSpreadsLeft(iReligionSpreads);
												}
											}
											else
											{
												pNewUnit->GetReligionData()->SetSpreadsLeft(iReligionSpreads);
											}
#else
											pNewUnit->GetReligionData()->SetSpreadsLeft(iReligionSpreads);
#endif
											pNewUnit->GetReligionData()->SetReligiousStrength(iReligiousStrength);
											pNewUnit->GetReligionData()->SetReligion(eReligion);
										}
									}
									else if (pNewUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_WRITER"))
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGreatWritersCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGreatWritersCreated();
#endif
#if !defined(MOD_BALANCE_CORE)
										if (pNewUnit->getUnitInfo().GetOneShotTourism() > 0)
										{
											pNewUnit->SetTourismBlastStrength(GetCulture()->GetTourismBlastStrength(pNewUnit->getUnitInfo().GetOneShotTourism()));
										}
#endif

										pNewUnit->jumpToNearestValidPlot();
									}							
									else if (pNewUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_ARTIST"))
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGreatArtistsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGreatArtistsCreated();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}							
									else if (pNewUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_MUSICIAN"))
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGreatMusiciansCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGreatMusiciansCreated();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
#if defined(MOD_DIPLOMACY_CITYSTATES)
									else if (MOD_DIPLOMACY_CITYSTATES && pNewUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_GREAT_DIPLOMAT"))
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGreatDiplomatsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGreatDiplomatsCreated();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
#endif
#if defined(MOD_BALANCE_CORE)
									else if (pNewUnit->getUnitInfo().IsGPExtra() == 1)
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGPExtra1Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGPExtra1Created();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
									else if (pNewUnit->getUnitInfo().IsGPExtra() == 2)
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGPExtra2Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGPExtra2Created();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
									else if (pNewUnit->getUnitInfo().IsGPExtra() == 3)
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGPExtra3Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGPExtra3Created();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
									else if (pNewUnit->getUnitInfo().IsGPExtra() == 4)
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGPExtra4Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGPExtra4Created();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
									else if (pNewUnit->getUnitInfo().IsGPExtra() == 5)
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGPExtra5Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGPExtra5Created();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
#endif
									else if(pNewUnit->IsGreatPerson())
									{
#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
										if (MOD_GLOBAL_SEPARATE_GP_COUNTERS) 
										{
											if (pNewUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_MERCHANT"))
											{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
												incrementGreatMerchantsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
												incrementGreatMerchantsCreated();
#endif
											}
											else if (pNewUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_SCIENTIST"))
											{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
												incrementGreatScientistsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
												incrementGreatScientistsCreated();
#endif
											}
											else
											{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
												incrementGreatEngineersCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
												incrementGreatEngineersCreated();
#endif
											}
										}
										else
#endif
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
											incrementGreatPeopleCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
											incrementGreatPeopleCreated();
#endif
											pNewUnit->jumpToNearestValidPlot();
									}
									else
									{
										pNewUnit->jumpToNearestValidPlot();
										if (pNewUnit && getCapitalCity() != NULL)
										{
											getCapitalCity()->addProductionExperience(pNewUnit);
										}
									}
								}
							}
						}
					}
				}
				int iNumFreeCombatLandUnits = pPolicy->GetBestNumberLandCombatUnitClass();
				CvCity* pCapital = getCapitalCity();
				if(iNumFreeCombatLandUnits > 0)
				{
					UnitTypes eBestLandUnit = NO_UNIT;
					int iStrengthBestLandCombat = 0;
					for(iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
					{
						const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
						CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
						if(pkUnitClassInfo)
						{
							const UnitTypes eUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eUnitClass);
							CvUnitEntry* pUnitEntry = GC.getUnitInfo(eUnit);
							if(pUnitEntry)
							{
								if(!pCapital->canTrain(eUnit))
								{
									continue;
								}
								if(pUnitEntry->GetRangedCombat() > 0)
								{
									continue;
								}
								if(pUnitEntry->GetDomainType() == DOMAIN_LAND)
								{
									bool bBad = false;
									ResourceTypes eResource;
									for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
									{
										eResource = (ResourceTypes) iResourceLoop;
										int iNumResource = pUnitEntry->GetResourceQuantityRequirement(eResource);
										if (iNumResource > 0)
										{
											if(getNumResourceAvailable(eResource, true) < iNumResource)
											{
												bBad = true;
												break;
											}
										}
									}
									if(bBad)
									{
										continue;
									}
									int iCombatLandStrength = (std::max(1, pUnitEntry->GetCombat()));
									if(iCombatLandStrength > iStrengthBestLandCombat)
									{
										iStrengthBestLandCombat = iCombatLandStrength;
										eBestLandUnit = eUnit;
									}
								}
							}
						}
					}
					if(eBestLandUnit != NO_UNIT)
					{
						for(int iUnitLoop = 0; iUnitLoop < iNumFreeCombatLandUnits; iUnitLoop++)
						{
							CvUnitEntry* pkbUnitEntry = GC.getUnitInfo(eBestLandUnit);
							if(pkbUnitEntry)
							{
								UnitAITypes eUnitAI = pkbUnitEntry->GetDefaultUnitAIType();
								int iResult = pCapital->CreateUnit(eBestLandUnit, eUnitAI, REASON_GIFT);
								CvAssertMsg(iResult != -1, "Unable to create unit");
								if (iResult != -1)
								{
									CvUnit* pUnit = getUnit(iResult);
									if (!pUnit->jumpToNearestValidPlot())
									{
										pUnit->kill(false);	// Could not find a valid spot!
									}
								}
							}
						}
					}
					else
					{
						for(int iUnitLoop = 0; iUnitLoop < iNumFreeCombatLandUnits; iUnitLoop++)
						{
							UnitTypes eWarrior = (UnitTypes)GC.getInfoTypeForString("UNIT_WARRIOR");
							CvUnitEntry* pkbUnitEntry = GC.getUnitInfo(eWarrior);
							if(pkbUnitEntry)
							{
								UnitAITypes eUnitAI = pkbUnitEntry->GetDefaultUnitAIType();
								int iResult = pCapital->CreateUnit(eWarrior, eUnitAI, REASON_GIFT);
								CvAssertMsg(iResult != -1, "Unable to create unit");
								if (iResult != -1)
								{
									CvUnit* pUnit = getUnit(iResult);
									if (!pUnit->jumpToNearestValidPlot())
									{
										pUnit->kill(false);	// Could not find a valid spot!
									}
								}
							}
						}
					}
				}
				int iNumFreeRangedLandUnits = pPolicy->GetBestNumberLandRangedUnitClass();
				if(iNumFreeRangedLandUnits > 0)
				{
					UnitTypes eBestLandRangedUnit = NO_UNIT;
					int iStrengthBestLandRanged = 0;
					for(iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
					{
						const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
						CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
						if(pkUnitClassInfo)
						{
							const UnitTypes eUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eUnitClass);
							CvUnitEntry* pUnitEntry = GC.getUnitInfo(eUnit);
							if(pUnitEntry)
							{
								if(!pCapital->canTrain(eUnit))
								{
									continue;
								}
								if(pUnitEntry->GetDomainType() == DOMAIN_LAND && pUnitEntry->GetRangedCombat() > 0)
								{
									bool bBad = false;
									ResourceTypes eResource;
									for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
									{
										eResource = (ResourceTypes) iResourceLoop;
										int iNumResource = pUnitEntry->GetResourceQuantityRequirement(eResource);
										if (iNumResource > 0)
										{
											if(getNumResourceAvailable(eResource, true) < iNumResource)
											{
												bBad = true;
												break;
											}
										}
									}
									if(bBad)
									{
										continue;
									}
									int iCombatLandRangedStrength = (std::max(1, pUnitEntry->GetRangedCombat()));
									if(iCombatLandRangedStrength > iStrengthBestLandRanged)
									{
										iStrengthBestLandRanged = iCombatLandRangedStrength;
										eBestLandRangedUnit = eUnit;
									}
								}
							}
						}
					}
					if(eBestLandRangedUnit != NO_UNIT)
					{
						for(int iUnitLoop = 0; iUnitLoop < iNumFreeRangedLandUnits; iUnitLoop++)
						{
							CvUnitEntry* pkbUnitEntry = GC.getUnitInfo(eBestLandRangedUnit);
							if(pkbUnitEntry)
							{
								UnitAITypes eUnitAI = pkbUnitEntry->GetDefaultUnitAIType();
								int iResult = pCapital->CreateUnit(eBestLandRangedUnit, eUnitAI, REASON_GIFT);
								CvAssertMsg(iResult != -1, "Unable to create unit");
								if (iResult != -1)
								{
									CvUnit* pUnit = getUnit(iResult);
									if (!pUnit->jumpToNearestValidPlot())
									{
										pUnit->kill(false);	// Could not find a valid spot!
									}
								}
							}
						}
					}
					else
					{
						for(int iUnitLoop = 0; iUnitLoop < iNumFreeRangedLandUnits; iUnitLoop++)
						{
							UnitTypes eArcher = (UnitTypes)GC.getInfoTypeForString("UNIT_ARCHER");
							CvUnitEntry* pkbUnitEntry = GC.getUnitInfo(eArcher);
							if(pkbUnitEntry)
							{
								UnitAITypes eUnitAI = pkbUnitEntry->GetDefaultUnitAIType();
								int iResult = pCapital->CreateUnit(eArcher, eUnitAI, REASON_GIFT);
								CvAssertMsg(iResult != -1, "Unable to create unit");
								if (iResult != -1)
								{
									CvUnit* pUnit = getUnit(iResult);
									if (!pUnit->jumpToNearestValidPlot())
									{
										pUnit->kill(false);	// Could not find a valid spot!
									}
								}
							}
						}
					}
				}
				int iNumFreeCombatSeaUnits = pPolicy->GetBestNumberSeaCombatUnitClass();
				if(iNumFreeCombatSeaUnits > 0 && pCapital->isCoastal())
				{
					UnitTypes eBestSeaUnit = NO_UNIT;
					int iStrengthBestSeaCombat = 0;
					for(iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
					{
						const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
						CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
						if(pkUnitClassInfo)
						{
							const UnitTypes eUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eUnitClass);
							CvUnitEntry* pUnitEntry = GC.getUnitInfo(eUnit);
							if(pUnitEntry)
							{
								if(!pCapital->canTrain(eUnit))
								{
									continue;
								}
								if(pUnitEntry->GetRangedCombat() > 0)
								{
									continue;
								}
								if(pUnitEntry->GetDomainType() == DOMAIN_SEA)
								{
									bool bBad = false;
									ResourceTypes eResource;
									for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
									{
										eResource = (ResourceTypes) iResourceLoop;
										int iNumResource = pUnitEntry->GetResourceQuantityRequirement(eResource);
										if (iNumResource > 0)
										{
											if(getNumResourceAvailable(eResource, true) < iNumResource)
											{
												bBad = true;
												break;
											}
										}
									}
									if(bBad)
									{
										continue;
									}
									int iCombatSeaStrength = (std::max(1, pUnitEntry->GetCombat()));
									if(iCombatSeaStrength > iStrengthBestSeaCombat)
									{
										iStrengthBestSeaCombat = iCombatSeaStrength;
										eBestSeaUnit = eUnit;
									}
								}
							}
						}
					}
					if(eBestSeaUnit != NO_UNIT)
					{
						for(int iUnitLoop = 0; iUnitLoop < iNumFreeCombatSeaUnits; iUnitLoop++)
						{
							CvUnitEntry* pkbUnitEntry = GC.getUnitInfo(eBestSeaUnit);
							if(pkbUnitEntry)
							{
								UnitAITypes eUnitAI = pkbUnitEntry->GetDefaultUnitAIType();
								int iResult = pCapital->CreateUnit(eBestSeaUnit, eUnitAI, REASON_GIFT);
								CvAssertMsg(iResult != -1, "Unable to create unit");
								if (iResult != -1)
								{
									CvUnit* pUnit = getUnit(iResult);
									if (!pUnit->jumpToNearestValidPlot())
									{
										pUnit->kill(false);	// Could not find a valid spot!
									}
								}
							}
						}
					}
					else
					{
						for(int iUnitLoop = 0; iUnitLoop < iNumFreeCombatSeaUnits; iUnitLoop++)
						{
							UnitTypes eCaravel = (UnitTypes)GC.getInfoTypeForString("UNIT_CARAVEL");
							CvUnitEntry* pkbUnitEntry = GC.getUnitInfo(eCaravel);
							if(pkbUnitEntry)
							{
								UnitAITypes eUnitAI = pkbUnitEntry->GetDefaultUnitAIType();
								int iResult = pCapital->CreateUnit(eCaravel, eUnitAI, REASON_GIFT);
								CvAssertMsg(iResult != -1, "Unable to create unit");
								if (iResult != -1)
								{
									CvUnit* pUnit = getUnit(iResult);
									if (!pUnit->jumpToNearestValidPlot())
									{
										pUnit->kill(false);	// Could not find a valid spot!
									}
								}
							}
						}
					}
				}
				int iNumFreeRangedSeaUnits = pPolicy->GetBestNumberSeaRangedUnitClass();
				if(iNumFreeRangedSeaUnits > 0 && pCapital->isCoastal())
				{
					UnitTypes eBestSeaRangedUnit = NO_UNIT;
					int iStrengthBestSeaRanged = 0;
					for(iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
					{
						const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
						CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
						if(pkUnitClassInfo)
						{
							const UnitTypes eUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eUnitClass);
							CvUnitEntry* pUnitEntry = GC.getUnitInfo(eUnit);
							if(pUnitEntry)
							{
								if(!pCapital->canTrain(eUnit))
								{
									continue;
								}
								if(pUnitEntry->GetDomainType() == DOMAIN_SEA && pUnitEntry->GetRangedCombat() > 0)
								{
									bool bBad = false;
									ResourceTypes eResource;
									for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
									{
										eResource = (ResourceTypes) iResourceLoop;
										int iNumResource = pUnitEntry->GetResourceQuantityRequirement(eResource);
										if (iNumResource > 0)
										{
											if(getNumResourceAvailable(eResource, true) < iNumResource)
											{
												bBad = true;
												break;
											}
										}
									}
									if(bBad)
									{
										continue;
									}
									int iCombatSeaRangedStrength = (std::max(1, pUnitEntry->GetRangedCombat()));
									if(iCombatSeaRangedStrength > iStrengthBestSeaRanged)
									{
										iStrengthBestSeaRanged = iCombatSeaRangedStrength;
										eBestSeaRangedUnit = eUnit;
									}
								}
							}
						}
					}
					if(eBestSeaRangedUnit != NO_UNIT)
					{
						for(int iUnitLoop = 0; iUnitLoop < iNumFreeRangedSeaUnits; iUnitLoop++)
						{
							CvUnitEntry* pkbUnitEntry = GC.getUnitInfo(eBestSeaRangedUnit);
							if(pkbUnitEntry)
							{
								UnitAITypes eUnitAI = pkbUnitEntry->GetDefaultUnitAIType();
								int iResult = pCapital->CreateUnit(eBestSeaRangedUnit, eUnitAI, REASON_GIFT);
								CvAssertMsg(iResult != -1, "Unable to create unit");
								if (iResult != -1)
								{
									CvUnit* pUnit = getUnit(iResult);
									if (!pUnit->jumpToNearestValidPlot())
									{
										pUnit->kill(false);	// Could not find a valid spot!
									}
								}
							}
						}
					}
					else
					{
						for(int iUnitLoop = 0; iUnitLoop < iNumFreeRangedSeaUnits; iUnitLoop++)
						{
							UnitTypes eGalleass = (UnitTypes)GC.getInfoTypeForString("UNIT_GALLEASS");
							CvUnitEntry* pkbUnitEntry = GC.getUnitInfo(eGalleass);
							if(pkbUnitEntry)
							{
								UnitAITypes eUnitAI = pkbUnitEntry->GetDefaultUnitAIType();
								int iResult = pCapital->CreateUnit(eGalleass, eUnitAI, REASON_GIFT);
								CvAssertMsg(iResult != -1, "Unable to create unit");
								if (iResult != -1)
								{
									CvUnit* pUnit = getUnit(iResult);
									if (!pUnit->jumpToNearestValidPlot())
									{
										pUnit->kill(false);	// Could not find a valid spot!
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// Great People bonus from Allied city-states
	if(pPolicy->IsMinorGreatPeopleAllies())
	{
		DoAdoptedGreatPersonCityStatePolicy();
	}

	// Add a Reformation belief if eligible
#if defined(MOD_RELIGION_LOCAL_RELIGIONS)
	if (isHuman() && pPolicy->IsAddReformationBelief() && GetReligions()->HasCreatedReligion(true) && !GetReligions()->HasAddedReformationBelief())
#else
	if (isHuman() && pPolicy->IsAddReformationBelief() && GetReligions()->HasCreatedReligion() && !GetReligions()->HasAddedReformationBelief())
#endif
	{
		pNotifications = GetNotifications();
		if(pNotifications)
		{
			CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_ADD_REFORMATION_BELIEF");
			CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_ADD_REFORMATION_BELIEF");
			pNotifications->Add(NOTIFICATION_ADD_REFORMATION_BELIEF, strBuffer, strSummary, -1, -1, -1);
		}
	}

	// if the steal tech faster amount is modified, then update the progress of all spies
	if (pPolicy->GetStealTechFasterModifier() != 0)
	{
		GetEspionage()->UpdateSpies();
	}
#if defined(MOD_BALANCE_CORE)
	if (pPolicy->GetStealGWFasterModifier() != 0)
	{
		GetEspionage()->UpdateSpies();
	}
#endif

	CvPlot *pLoopPlot;
	ResourceTypes eResource;
	for(iI = 0; iI < GC.getMap().numPlots(); iI++)
	{
		pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);
		eResource = pLoopPlot->getResourceType();
		if(eResource != NO_RESOURCE)
		{
			if(GC.getResourceInfo(eResource)->getPolicyReveal() == (int)ePolicy)
			{
				pLoopPlot->updateYield();
				if (pLoopPlot->isRevealed(getTeam()))
				{
					pLoopPlot->setLayoutDirty(true);
				}
			}
		}
	}

	GetTrade()->UpdateTradeConnectionValues();
	recomputeGreatPeopleModifiers();
	recomputePolicyCostModifier();
	recomputeFreeExperience();
#if defined(MOD_BALANCE_CORE)
	CvCity* pLoopCity2;
	int iLoop2;
	for(pLoopCity2 = firstCity(&iLoop2); pLoopCity2 != NULL; pLoopCity2 = nextCity(&iLoop2))
	{
		if(pLoopCity2 != NULL)
		{
			pLoopCity2->UpdateReligion(pLoopCity2->GetCityReligions()->GetReligiousMajority());		
			pLoopCity2->UpdateHappinessFromBuildingClasses();
		}
	}
#endif
	CalculateNetHappiness();

	doUpdateBarbarianCampVisibility();

	GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
}

#if defined(MOD_BALANCE_CORE)
void CvPlayer::processCorporations(CorporationTypes eCorporation, int iChange)
{
	CvCorporationEntry* pkCorporationEntry = GC.getCorporationInfo(eCorporation);
	if(pkCorporationEntry == NULL)
		return;

	int iI, jJ;

	for (iI = 0; iI < GC.getNUM_YIELD_TYPES(); iI++)
	{
		for (jJ = 0; jJ < GC.getNumSpecialistInfos(); jJ++)
		{
			changeSpecialistYieldChange((SpecialistTypes)jJ, (YieldTypes)iI, pkCorporationEntry->GetSpecialistYieldChange(jJ, iI) * iChange);
		}
	}
	// Loop through Cities
	int iLoop;
	CvCity* pLoopCity;
	int iBuildingCount;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		// Building modifiers
		BuildingClassTypes eBuildingClass;
		for(iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
		{
			eBuildingClass = (BuildingClassTypes) iI;

			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
			if(!pkBuildingClassInfo)
			{
				continue;
			}

			BuildingTypes eTestBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

			if(eTestBuilding != NO_BUILDING)
			{
				CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eTestBuilding);
				if(pkBuilding)
				{
					iBuildingCount = pLoopCity->GetCityBuildings()->GetNumBuilding(eTestBuilding);
					if(iBuildingCount > 0)
					{
						// Building Class Yield Stuff
						for(int iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
						{
							YieldTypes eYield = (YieldTypes)iJ;
								
							int iYieldChange = pkCorporationEntry->GetBuildingClassYieldChange(eBuildingClass, eYield);
							if(iYieldChange <= 0)
								continue;

							pLoopCity->ChangeBaseYieldRateFromBuildings(eYield, iYieldChange * iBuildingCount * iChange);
						}
					}
				}
			}
		}
	}
}
#endif

//	--------------------------------------------------------------------------------
/// If we should see where the locations of all current Barb Camps are, do it
void CvPlayer::doUpdateBarbarianCampVisibility()
{
	if(IsAlwaysSeeBarbCamps())
	{
		CvPlot* pPlot;

		ImprovementTypes eImprovement;

		for(int iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); ++iPlotLoop)
		{
			pPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);

			if(pPlot->isRevealed(getTeam()))
			{
				eImprovement = pPlot->getImprovementType();

				// Camp here
				if(eImprovement == GC.getBARBARIAN_CAMP_IMPROVEMENT())
				{
					// We don't see Camp
					if(pPlot->getRevealedImprovementType(getTeam()) != eImprovement)
					{
						pPlot->setRevealedImprovementType(getTeam(), eImprovement);
					}
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isPbemNewTurn() const
{
	return m_bPbemNewTurn;
}

//	--------------------------------------------------------------------------------
void CvPlayer::setPbemNewTurn(bool bNew)
{
	m_bPbemNewTurn = bNew;
}

//	--------------------------------------------------------------------------------
CvEconomicAI* CvPlayer::GetEconomicAI() const
{
	return m_pEconomicAI;
}

//	--------------------------------------------------------------------------------
CvMilitaryAI* CvPlayer::GetMilitaryAI() const
{
	return m_pMilitaryAI;
}

//	--------------------------------------------------------------------------------
CvCitySpecializationAI* CvPlayer::GetCitySpecializationAI() const
{
	return m_pCitySpecializationAI;
}

//	--------------------------------------------------------------------------------
CvWonderProductionAI* CvPlayer::GetWonderProductionAI() const
{
	return m_pWonderProductionAI;
}

//	--------------------------------------------------------------------------------
CvGrandStrategyAI* CvPlayer::GetGrandStrategyAI() const
{
	return m_pGrandStrategyAI;
}

//	--------------------------------------------------------------------------------
CvDiplomacyAI* CvPlayer::GetDiplomacyAI() const
{
	return m_pDiplomacyAI;
}

//	--------------------------------------------------------------------------------
CvPlayerReligions* CvPlayer::GetReligions() const
{
	return m_pReligions;
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
CvPlayerCorporations* CvPlayer::GetCorporations() const
{
	return m_pCorporations;
}
//	--------------------------------------------------------------------------------
CvPlayerContracts* CvPlayer::GetContracts() const
{
	return m_pContracts;
}
#endif

//	--------------------------------------------------------------------------------
CvReligionAI* CvPlayer::GetReligionAI() const
{
	return m_pReligionAI;
}

//	--------------------------------------------------------------------------------
CvMinorCivAI* CvPlayer::GetMinorCivAI() const
{
	return m_pMinorCivAI;
}

//	--------------------------------------------------------------------------------
CvDealAI* CvPlayer::GetDealAI() const
{
	return m_pDealAI;
}

//	--------------------------------------------------------------------------------
/// Get the object that decides what task the builders should perform
CvBuilderTaskingAI* CvPlayer::GetBuilderTaskingAI() const
{
	return m_pBuilderTaskingAI;
}

//	--------------------------------------------------------------------------------
/// Get the city connection that gives you information about the route connections between cities
CvCityConnections* CvPlayer::GetCityConnections() const
{
	return m_pCityConnections;
}

//	--------------------------------------------------------------------------------
/// Get the player's information about their espionage
CvPlayerEspionage* CvPlayer::GetEspionage() const
{
	return m_pEspionage;
}

//	--------------------------------------------------------------------------------
/// Get the player's espionage AI version
CvEspionageAI* CvPlayer::GetEspionageAI() const
{
	return m_pEspionageAI;
}

//	--------------------------------------------------------------------------------
/// Get the player's information about their trade
CvPlayerTrade* CvPlayer::GetTrade() const
{
	return m_pTrade;
}

//	--------------------------------------------------------------------------------
/// Get the player's trade AI version
CvTradeAI* CvPlayer::GetTradeAI() const
{
	return m_pTradeAI;
}

//	--------------------------------------------------------------------------------
/// Get the player's League AI
CvLeagueAI* CvPlayer::GetLeagueAI() const
{
	return m_pLeagueAI;
}

//	--------------------------------------------------------------------------------
CvPlayerCulture* CvPlayer::GetCulture() const
{
	return m_pCulture;
}

//	--------------------------------------------------------------------------------
CvNotifications* CvPlayer::GetNotifications() const
{
	return m_pNotifications;
}

#if defined(MOD_API_EXTENSIONS)
//	--------------------------------------------------------------------------------
int CvPlayer::AddNotification(NotificationTypes eNotificationType, const char* sMessage, const char* sSummary, int iGameDataIndex, int iExtraGameData)
{
  return AddNotification(eNotificationType, sMessage, sSummary, NULL, iGameDataIndex, iExtraGameData);
}

int CvPlayer::AddNotification(NotificationTypes eNotificationType, const char* sMessage, const char* sSummary, CvPlot* pPlot, int iGameDataIndex, int iExtraGameData)
{
  int iNotification = -1;
  
  CvNotifications* pNotifications = GetNotifications();

  if (pNotifications) {
    const int iPlotX = pPlot ? pPlot->getX() : -1;
    const int iPlotY = pPlot ? pPlot->getY() : -1;
	
    iNotification = pNotifications->Add(eNotificationType, sMessage, sSummary, iPlotX, iPlotY, iGameDataIndex, iExtraGameData);
  }
  
  return iNotification;
}
#endif

//	--------------------------------------------------------------------------------
CvTreasury* CvPlayer::GetTreasury() const
{
	return m_pTreasury;
}

int CvPlayer::GetPseudoRandomSeed() const
{
	//this should return a different number for each turn (each call would be even better ...)
	return GetID() + m_pTreasury ? m_pTreasury->GetLifetimeGrossGold() : 0 + getGlobalAverage(YIELD_CULTURE);
}

//	--------------------------------------------------------------------------------
CvDiplomacyRequests* CvPlayer::GetDiplomacyRequests() const
{
	return m_pDiplomacyRequests;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::HasActiveDiplomacyRequests() const
{
	PlayerTypes ePlayer = GetID();

	// Do I have any?
	CvDiplomacyRequests* pkDiploRequests = GetDiplomacyRequests();
	if(pkDiploRequests && pkDiploRequests->HasActiveRequest())
		return true;
#if defined(MOD_ACTIVE_DIPLOMACY)
	if (!MOD_ACTIVE_DIPLOMACY || !GC.getGame().isReallyNetworkMultiPlayer())
	{
#endif
		// Do I have any for others?
		for (int i = 0; i < MAX_PLAYERS; ++i)
		{
			const CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)i);
			if (kPlayer.isAlive())
			{
				pkDiploRequests = kPlayer.GetDiplomacyRequests();
				if (pkDiploRequests)
				{
					if (pkDiploRequests->HasActiveRequestFrom(ePlayer))
						return true;
				}
			}
		}
#if defined(MOD_ACTIVE_DIPLOMACY)
	}
#endif
	return false;
}

//	--------------------------------------------------------------------------------
//
// read object from a stream
// used during load
//
void CvPlayer::Read(FDataStream& kStream)
{
	// Init data before load
	reset();

	// Version number to maintain backwards compatibility
	uint uiVersion;
	kStream >> uiVersion;
	MOD_SERIALIZE_INIT_READ(kStream);

#if defined(MOD_BALANCE_CORE)
	kStream >> m_syncArchive;
	//Values below deleted, as they're already in the sync archive! Use the sync archive from now on!
#endif

	m_pPlayerPolicies->Read(kStream);
	m_pEconomicAI->Read(kStream);
	m_pCitySpecializationAI->Read(kStream);
	m_pWonderProductionAI->Read(kStream);
	m_pMilitaryAI->Read(kStream);
	m_pGrandStrategyAI->Read(kStream);
	m_pDiplomacyAI->Read(kStream);
	m_pReligions->Read(kStream);
	m_pReligionAI->Read(kStream);
#if defined(MOD_BALANCE_CORE)
	m_pCorporations->Read(kStream);
#endif
	m_pPlayerTechs->Read(kStream);
	m_pFlavorManager->Read(kStream);
	m_pTacticalAI->Read(kStream);
	m_pHomelandAI->Read(kStream);
	m_pMinorCivAI->Read(kStream);
	m_pDealAI->Read(kStream);
	m_pBuilderTaskingAI->Read(kStream);
	m_pCityConnections->Read(kStream);
	m_pDangerPlots->Read(kStream);
	m_pTraits->Read(kStream);
	kStream >> *m_pEspionage;
	kStream >> *m_pEspionageAI;
	kStream >> *m_pTrade;
	kStream >> *m_pTradeAI;
	m_pLeagueAI->Read(kStream);
	kStream >> *m_pCulture;

	bool bReadNotifications;
	kStream >> bReadNotifications;
	if(bReadNotifications)
	{
		if (!m_pNotifications)
			m_pNotifications = FNEW(CvNotifications, c_eCiv5GameplayDLL, 0);
		m_pNotifications->Init(GetID());
		m_pNotifications->Read(kStream);
	}
	m_pTreasury->Read(kStream);

	// If this is a real player, hook up the player-level flavor recipients
	if(GetID() != NO_PLAYER)
	{
		SlotStatus s = CvPreGame::slotStatus(GetID());
		if((s == SS_TAKEN || s == SS_COMPUTER) && !isBarbarian())
		{
			m_pFlavorManager->AddFlavorRecipient(m_pPlayerTechs,        false /*bPropogateFlavors*/);
			m_pFlavorManager->AddFlavorRecipient(m_pPlayerPolicies,     false /*bPropogateFlavors*/);
			m_pFlavorManager->AddFlavorRecipient(m_pWonderProductionAI, false /*bPropogateFlavors*/);
		}
	}

	kStream >> m_researchQueue;
	kStream >> m_eEndTurnBlockingType;
	kStream >> m_iEndTurnBlockingNotificationIndex;

	kStream >> m_cityNames;

	kStream >> m_cities;
	GC.getGame().SetClosestCityMapDirty();

	kStream >> m_units;
	kStream >> m_armyAIs;

	{
		m_AIOperations.clear();
		uint iSize;
		int iID;
		int iOperationType;
		kStream >> iSize;
		for(uint i = 0; i < iSize; i++)
		{
			kStream >> iID;
			kStream >> iOperationType;
			CvAIOperation* pThisOperation = CvAIOperation::CreateOperation((AIOperationTypes)iOperationType);
			pThisOperation->Read(kStream);
			m_AIOperations.insert(std::make_pair(pThisOperation->GetID(), pThisOperation));
		}
	}

	if (uiVersion <= 10)
	{
		// Unused popup queue
		int iSize;
		kStream >> iSize;
		CvAssert(iSize == 0);
	}

	kStream >> m_ReplayDataSets;
	kStream >> m_ReplayDataSetValues;

	kStream >> m_ppiInstantYieldHistoryValues;
	kStream >> m_ppiInstantTourismHistoryValues;

	kStream >> m_aVote;
	kStream >> m_aUnitExtraCosts;

	// reading plot values
	kStream >> m_aiPlots;

	if(!isBarbarian())
	{
		// Get the NetID from the initialization structure
		setNetID(gDLL->getAssignedNetworkID(GetID()));
	}

	m_bfEverConqueredBy.ClearAll();
	int iSize;
	kStream >> iSize;
	for(int i = 0; i < iSize; i++)
	{
		bool bValue;
		kStream >> bValue;
		if(bValue)
		{
			m_bfEverConqueredBy.SetBit(i);
		}
	}

	kStream >> m_strEmbarkedGraphicOverride;
	m_kPlayerAchievements.Read(kStream);

	if(GetID() < MAX_MAJOR_CIVS)
	{
		if(!m_pDiplomacyRequests)
			m_pDiplomacyRequests = FNEW(CvDiplomacyRequests, c_eCiv5GameplayDLL, 0);
		else
			m_pDiplomacyRequests->Uninit();

		m_pDiplomacyRequests->Init(GetID());
		m_pDiplomacyRequests->Read(kStream);
	}

	if(m_bTurnActive)
		GC.getGame().changeNumGameTurnActive(1, std::string("setTurnActive() [loading save game] for player ") + getName());

#if defined(MOD_API_UNIFIED_YIELDS) && defined(MOD_API_PLOT_YIELDS)
	// MOD_SERIALIZE_READ - v57/v58/v59 broke the save format  couldn't be helped, but don't make a habit of it!!!
	kStream >> m_ppiPlotYieldChange;
#endif
#if defined(MOD_API_UNIFIED_YIELDS)
	// MOD_SERIALIZE_READ - v57/v58/v59 and v61 broke the save format  couldn't be helped, but don't make a habit of it!!!
	kStream >> m_ppiImprovementYieldChange;
	kStream >> m_ppiFeatureYieldChange;
	kStream >> m_ppiResourceYieldChange;
	kStream >> m_ppiTerrainYieldChange;
	kStream >> m_ppiTradeRouteYieldChange;
	kStream >> m_ppiSpecialistYieldChange;
	kStream >> m_ppiGreatPersonExpendedYield;
	kStream >> m_piGoldenAgeGreatPersonRateModifier;
	kStream >> m_ppiUnimprovedFeatureYieldChange;
	kStream >> m_ppiCityYieldFromUnimprovedFeature;
	kStream >> m_piYieldFromKills;
	kStream >> m_piYieldFromBarbarianKills;
	kStream >> m_piYieldChangeTradeRoute;
	kStream >> m_piYieldChangesNaturalWonder;
	kStream >> m_piYieldChangesPerReligion;
	kStream >> m_piYieldChangeWorldWonder;
	kStream >> m_piYieldFromMinorDemand;
	kStream >> m_piYieldFromWLTKD;
	kStream >> m_ppiBuildingClassYieldChange;
	kStream >> m_piCityFeatures;
	kStream >> m_piNumBuildings;
	kStream >> m_piNumBuildingsInPuppets;
	kStream >> m_ppiApproachScratchValue;
#endif
#if defined(MOD_API_UNIFIED_YIELDS) && defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	{
		int iNumEntries;
		kStream >> iNumEntries;
		m_ppiSpecificGreatPersonRateModifierFromMonopoly.clear();
		for (int iI = 0; iI < iNumEntries; iI++)
		{
			int iGreatPerson;
			int iMonopoly;
			int iModifier;

			kStream >> iGreatPerson;
			kStream >> iMonopoly;
			kStream >> iModifier;

			m_ppiSpecificGreatPersonRateModifierFromMonopoly[(GreatPersonTypes)iGreatPerson][(MonopolyTypes)iMonopoly] = iModifier;
		}
	}
#endif

#if defined(MOD_BALANCE_CORE)
	kStream >> m_aistrInstantGreatPersonProgress;
	kStream >> m_piDomainFreeExperience;
#endif

#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	kStream >> m_pabHasGlobalMonopoly;
	kStream >> m_pabHasStrategicMonopoly;

	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		if (MOD_BALANCE_CORE_RESOURCE_MONOPOLIES && m_pabHasGlobalMonopoly[iResourceLoop])
		{
			SetHasGlobalMonopoly((ResourceTypes)iResourceLoop, true);
		}
		if (MOD_BALANCE_CORE_RESOURCE_MONOPOLIES_STRATEGIC && m_pabHasStrategicMonopoly[iResourceLoop])
		{
			SetHasStrategicMonopoly((ResourceTypes)iResourceLoop, true);
		}
	}
	kStream >> m_noSettlingPlots;
#endif

#if defined(MOD_BALANCE_CORE)
	UpdateAreaEffectUnits();
	UpdateAreaEffectPlots();
	GET_TEAM(getTeam()).updateTeamStatus();
	UpdateCurrentAndFutureWars();
	int iLoop=0;
	for (CvCity* pCity=firstCity(&iLoop); pCity!=NULL; pCity=nextCity(&iLoop))
		pCity->UpdateClosestFriendlyNeighbors();
#endif

}

//	--------------------------------------------------------------------------------
//
// save object to a stream
// used during save
//
void CvPlayer::Write(FDataStream& kStream) const
{
	//Save version number.  THIS MUST BE FIRST!!
	kStream << g_CurrentCvPlayerVersion;
	MOD_SERIALIZE_INIT_WRITE(kStream);

#if defined(MOD_BALANCE_CORE)
	kStream << m_syncArchive;
	//Values below deleted, as they're already in the sync archive! Use the sync archive from now on!
#endif
	m_pPlayerPolicies->Write(kStream);
	m_pEconomicAI->Write(kStream);
	m_pCitySpecializationAI->Write(kStream);
	m_pWonderProductionAI->Write(kStream);
	m_pMilitaryAI->Write(kStream);
	m_pGrandStrategyAI->Write(kStream);
	m_pDiplomacyAI->Write(kStream);
	m_pReligions->Write(kStream);
	m_pReligionAI->Write(kStream);
#if defined(MOD_BALANCE_CORE)
	m_pCorporations->Write(kStream);
#endif
	m_pPlayerTechs->Write(kStream);
	m_pFlavorManager->Write(kStream);
	m_pTacticalAI->Write(kStream);
	m_pHomelandAI->Write(kStream);
	m_pMinorCivAI->Write(kStream);
	m_pDealAI->Write(kStream);
	m_pBuilderTaskingAI->Write(kStream);
	m_pCityConnections->Write(kStream);
	m_pDangerPlots->Write(kStream);
	m_pTraits->Write(kStream);
	kStream << *m_pEspionage;
	kStream << *m_pEspionageAI;
	kStream << *m_pTrade;
	kStream << *m_pTradeAI;
	m_pLeagueAI->Write(kStream);
	kStream << *m_pCulture;

	if(m_pNotifications)
	{
		kStream << true;
		m_pNotifications->Write(kStream);
	}
	else
	{
		kStream << false;
	}
	m_pTreasury->Write(kStream);

	kStream << m_researchQueue;
	kStream << m_eEndTurnBlockingType;
	kStream << m_iEndTurnBlockingNotificationIndex;

	kStream << m_cityNames;
	kStream << m_cities;
	kStream << m_units;
	kStream << m_armyAIs;

	{
		uint iSize = m_AIOperations.size();
		kStream << iSize;
		std::map<int, CvAIOperation*>::const_iterator it;
		for(it = m_AIOperations.begin(); it != m_AIOperations.end(); ++it)
		{
			kStream << it->first;
			CvAIOperation* pThisOperation = it->second;
			kStream << pThisOperation->GetOperationType();
			pThisOperation->Write(kStream);
		}
	}

	kStream << m_ReplayDataSets;
	kStream << m_ReplayDataSetValues;
	
	kStream << m_ppiInstantYieldHistoryValues;
	kStream << m_ppiInstantTourismHistoryValues;

	kStream << m_aVote;
	kStream << m_aUnitExtraCosts;

	kStream << m_aiPlots;

	// writing out
	{
		int iSize = MAX_PLAYERS;
		kStream << iSize;
		for(int i = 0; i < iSize; i++)
		{
			bool bValue = m_bfEverConqueredBy.GetBit(i);
			kStream << bValue;
		}
	}

	kStream << m_strEmbarkedGraphicOverride;

	m_kPlayerAchievements.Write(kStream);
	
	if (GetID() < MAX_MAJOR_CIVS)
		m_pDiplomacyRequests->Write(kStream);	
	
#if defined(MOD_API_UNIFIED_YIELDS) && defined(MOD_API_PLOT_YIELDS)
	// MOD_SERIALIZE_READ - v57/v58/v59 broke the save format  couldn't be helped, but don't make a habit of it!!!
	kStream << m_ppiPlotYieldChange;
#endif
#if defined(MOD_API_UNIFIED_YIELDS)
	// MOD_SERIALIZE_READ - v57/v58/v59 and v61 broke the save format  couldn't be helped, but don't make a habit of it!!!
	kStream << m_ppiImprovementYieldChange;
	kStream << m_ppiFeatureYieldChange;
	kStream << m_ppiResourceYieldChange;
	kStream << m_ppiTerrainYieldChange;
	kStream << m_ppiTradeRouteYieldChange;
	kStream << m_ppiSpecialistYieldChange;
	kStream << m_ppiGreatPersonExpendedYield;
	kStream << m_piGoldenAgeGreatPersonRateModifier;
	kStream << m_ppiUnimprovedFeatureYieldChange;
	kStream << m_ppiCityYieldFromUnimprovedFeature;
	kStream << m_piYieldFromKills;
	kStream << m_piYieldFromBarbarianKills;
	kStream << m_piYieldChangeTradeRoute;
	kStream << m_piYieldChangesNaturalWonder;
	kStream << m_piYieldChangesPerReligion;
	kStream << m_piYieldChangeWorldWonder;
	kStream << m_piYieldFromMinorDemand;
	kStream << m_piYieldFromWLTKD;
	kStream << m_ppiBuildingClassYieldChange;
	kStream << m_piCityFeatures;
	kStream << m_piNumBuildings;
	kStream << m_piNumBuildingsInPuppets;
	kStream << m_ppiApproachScratchValue;
#endif
#if defined(MOD_API_UNIFIED_YIELDS) && defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	{
		int iSize = 0;
		for (std::map<GreatPersonTypes, std::map<MonopolyTypes, int>>::const_iterator it = m_ppiSpecificGreatPersonRateModifierFromMonopoly.begin(); it != m_ppiSpecificGreatPersonRateModifierFromMonopoly.end(); ++it)
		{
			iSize += it->second.size();
		}
		kStream << iSize;
		for (std::map<GreatPersonTypes, std::map<MonopolyTypes, int>>::const_iterator itGreatPerson = m_ppiSpecificGreatPersonRateModifierFromMonopoly.begin(); itGreatPerson != m_ppiSpecificGreatPersonRateModifierFromMonopoly.end(); ++itGreatPerson)
		{
			int iGreatPerson = (int)itGreatPerson->first;
			for (std::map<MonopolyTypes, int>::const_iterator itMonopoly = itGreatPerson->second.begin(); itMonopoly != itGreatPerson->second.end(); ++itMonopoly)
			{
				int iMonopoly = (int)itMonopoly->first;
				int iModifier = itMonopoly->second;
				kStream << iGreatPerson;
				kStream << iMonopoly;
				kStream << iModifier;
			}
		}
	}
#endif
#if defined(MOD_BALANCE_CORE)
	kStream << m_aistrInstantGreatPersonProgress;
	kStream << m_piDomainFreeExperience;
#endif
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	kStream << m_pabHasGlobalMonopoly;
	kStream << m_pabHasStrategicMonopoly;
	kStream << m_noSettlingPlots;
#endif
}

//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
void CvPlayer::createGreatGeneral(UnitTypes eGreatPersonUnit, int iX, int iY, bool bIsFree)
#else
void CvPlayer::createGreatGeneral(UnitTypes eGreatPersonUnit, int iX, int iY)
#endif
{
	CvUnit* pGreatPeopleUnit = initUnit(eGreatPersonUnit, iX, iY);
	if(NULL == pGreatPeopleUnit)
	{
		CvAssert(false);
		return;
	}
#if defined(MOD_BALANCE_CORE)
	if(GetPlayerTraits()->IsGPWLTKD() && pGreatPeopleUnit != NULL)
	{
		CvCity* pCity = pGreatPeopleUnit->plot()->getOwningCity();
		if (pCity != NULL && pCity->getOwner() == GetID())
		{
			int iWLTKD = (GC.getCITY_RESOURCE_WLTKD_TURNS() / 3);

			iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iWLTKD /= 100;

			if (iWLTKD > 0)
			{
				pCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
				CvNotifications* pNotifications = GetNotifications();
				if (pNotifications)
				{
					Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UA");
					strText << pGreatPeopleUnit->getNameKey() << pCity->getNameKey();
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UA");
					strSummary << pCity->getNameKey();
					pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), -1);
				}
			}
		}
	}
	if(pGreatPeopleUnit->isWLKTKDOnBirth())
	{
		CvCity* pLoopCity;
		int iLoop;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity != NULL && pLoopCity->getOwner() == GetID())
			{
				int iWLTKD = (GC.getCITY_RESOURCE_WLTKD_TURNS() / 3);

				iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iWLTKD /= 100;

				if (iWLTKD > 0)
				{
					pLoopCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
					CvNotifications* pNotifications = GetNotifications();
					if (pNotifications)
					{
						Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UNIT");
						strText << pGreatPeopleUnit->getNameKey() << pLoopCity->getNameKey();
						Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UNIT");
						strSummary << pLoopCity->getNameKey();
						pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pLoopCity->getX(), pLoopCity->getY(), -1);
					}
				}
			}
		}
	}
	if(pGreatPeopleUnit->getUnitInfo().IsFoundReligion())
	{
		ReligionTypes eReligion = GetReligions()->GetReligionCreatedByPlayer();
		int iReligionSpreads = pGreatPeopleUnit->getUnitInfo().GetReligionSpreads();
		int iReligiousStrength = pGreatPeopleUnit->getUnitInfo().GetReligiousStrength();
		iReligiousStrength *= (100 + GetPlayerTraits()->GetExtraMissionaryStrength());
		iReligiousStrength /= 100;
		if(iReligionSpreads > 0 && eReligion > RELIGION_PANTHEON)
		{
			pGreatPeopleUnit->GetReligionData()->SetSpreadsLeft(iReligionSpreads);
			pGreatPeopleUnit->GetReligionData()->SetReligiousStrength(iReligiousStrength);
			pGreatPeopleUnit->GetReligionData()->SetReligion(eReligion);
		}
	}
	if(pGreatPeopleUnit->isGoldenAgeOnBirth())
	{
		int iGoldenAgeTurns = getGoldenAgeLength();
		int iValue = GetGoldenAgeProgressMeter();
		changeGoldenAgeTurns(iGoldenAgeTurns, iValue);
	}
	if(pGreatPeopleUnit->isCultureBoost())
	{
		int iValue = GetTotalJONSCulturePerTurn() * 4;
		changeJONSCulture(iValue);
		if(getCapitalCity() != NULL)
		{
			getCapitalCity()->ChangeJONSCultureStored(iValue);
		}
		CvNotifications* pNotifications = GetNotifications();
		if (pNotifications)
		{
			Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CULTURE_UNIT");
			strText << pGreatPeopleUnit->getNameKey();
			Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CULTURE_UNIT");
			strSummary << pGreatPeopleUnit->getNameKey();
			pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pGreatPeopleUnit->getX(), pGreatPeopleUnit->getY(), -1);
		}
	}
	if(pGreatPeopleUnit->IsCombatUnit() && getCapitalCity() != NULL)
	{
		getCapitalCity()->addProductionExperience(pGreatPeopleUnit);
		pGreatPeopleUnit->setOriginCity(getCapitalCity()->GetID());
	}
#endif
	ChangeNumGreatPeople(1);

#if defined(MOD_GLOBAL_TRULY_FREE_GP)
	incrementGreatGeneralsCreated(bIsFree);
#else
	incrementGreatGeneralsCreated();
#endif

#if defined(MOD_GLOBAL_TRULY_FREE_GP)
	changeGreatGeneralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE() * ((getGreatGeneralsCreated(bIsFree) / 10) + 1));
#else
	changeGreatGeneralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE() * ((getGreatGeneralsCreated() / 10) + 1));
#endif

	for(int iI = 0; iI < MAX_PLAYERS; iI++)
	{
		if(GET_PLAYER((PlayerTypes)iI).getTeam() == getTeam())
		{
#if defined(MOD_BUGFIX_MINOR)
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
			GET_PLAYER((PlayerTypes)iI).changeGreatGeneralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE_TEAM() * ((getGreatGeneralsCreated(bIsFree) / 10) + 1));
#else
			GET_PLAYER((PlayerTypes)iI).changeGreatGeneralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE_TEAM() * ((getGreatGeneralsCreated() / 10) + 1));
#endif
#else
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
			GET_PLAYER((PlayerTypes)iI).changeGreatGeneralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE_TEAM() * ((getGreatPeopleCreated(bIsFree) / 10) + 1));
#else
			GET_PLAYER((PlayerTypes)iI).changeGreatGeneralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE_TEAM() * ((getGreatPeopleCreated() / 10) + 1));
#endif
#endif
		}
	}

#if defined(MOD_GLOBAL_LOCAL_GENERALS)
	CvPlot* pPlot = pGreatPeopleUnit->plot();

	// In rare cases we can gain the general from an embarked unit being attacked, or from a hovering unit over coast
	// so if this plot is water, relocate the Great General
	if (pPlot->isWater() || pGreatPeopleUnit->IsCombatUnit()) {
		pGreatPeopleUnit->jumpToNearestValidPlot();
	}
#else
	CvPlot* pPlot = GC.getMap().plot(iX, iY);
#endif

#if !defined(NO_ACHIEVEMENTS)
	//Achievements and Stats
	if(pGreatPeopleUnit->isHuman() && !GC.getGame().isGameMultiPlayer())
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_GREATGENERALS);
		const char* strLeader = GET_PLAYER(pGreatPeopleUnit->getOwner()).getLeaderTypeKey();
		if(strLeader && strcmp(strLeader, "LEADER_WU_ZETIAN") == 0)
		{
			gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_SUNTZU);
		}

		CvAchievementUnlocker::Check_PSG();
	}
#endif
	// Notification
	if(GetNotifications())
	{
		Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER");
		Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_GREAT_PERSON");
		GetNotifications()->Add(NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER, strText.toUTF8(), strSummary.toUTF8(), pPlot->getX(), pPlot->getY(), eGreatPersonUnit);
	}
}

//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
void CvPlayer::createGreatAdmiral(UnitTypes eGreatPersonUnit, int iX, int iY, bool bIsFree)
#else
void CvPlayer::createGreatAdmiral(UnitTypes eGreatPersonUnit, int iX, int iY)
#endif
{
	CvUnit* pGreatPeopleUnit = initUnit(eGreatPersonUnit, iX, iY);
	if(NULL == pGreatPeopleUnit)
	{
		CvAssert(false);
		return;
	}
#if defined(MOD_BALANCE_CORE)
	if(GetPlayerTraits()->IsGPWLTKD() && pGreatPeopleUnit != NULL)
	{
		CvCity* pCity = pGreatPeopleUnit->plot()->getOwningCity();
		if (pCity != NULL && pCity->getOwner() == GetID())
		{
			int iWLTKD = (GC.getCITY_RESOURCE_WLTKD_TURNS() / 3);

			iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iWLTKD /= 100;

			if (iWLTKD > 0)
			{
				pCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
				CvNotifications* pNotifications = GetNotifications();
				if (pNotifications)
				{
					Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UA");
					strText << pGreatPeopleUnit->getNameKey() << pCity->getNameKey();
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UA");
					strSummary << pCity->getNameKey();
					pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), -1);
				}
			}
		}
	}
	if(pGreatPeopleUnit->isWLKTKDOnBirth())
	{
		CvCity* pLoopCity;
		int iLoop;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity != NULL && pLoopCity->getOwner() == GetID())
			{
				int iWLTKD = (GC.getCITY_RESOURCE_WLTKD_TURNS() / 3);

				iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iWLTKD /= 100;

				if (iWLTKD > 0)
				{
					pLoopCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
					CvNotifications* pNotifications = GetNotifications();
					if (pNotifications)
					{
						Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UNIT");
						strText << pGreatPeopleUnit->getNameKey() << pLoopCity->getNameKey();
						Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UNIT");
						strSummary << pLoopCity->getNameKey();
						pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pLoopCity->getX(), pLoopCity->getY(), -1);
					}
				}
			}
		}
	}
	if(pGreatPeopleUnit->isGoldenAgeOnBirth())
	{
		int iGoldenAgeTurns = getGoldenAgeLength();
		int iValue = GetGoldenAgeProgressMeter();
		changeGoldenAgeTurns(iGoldenAgeTurns, iValue);
	}
	if(pGreatPeopleUnit->isCultureBoost())
	{
		int iValue = GetTotalJONSCulturePerTurn() * 4;
		changeJONSCulture(iValue);
		if(getCapitalCity() != NULL)
		{
			getCapitalCity()->ChangeJONSCultureStored(iValue);
		}
		CvNotifications* pNotifications = GetNotifications();
		if (pNotifications)
		{
			Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CULTURE_UNIT");
			strText << pGreatPeopleUnit->getNameKey();
			Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CULTURE_UNIT");
			strSummary << pGreatPeopleUnit->getNameKey();
			pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pGreatPeopleUnit->getX(), pGreatPeopleUnit->getY(), -1);
		}
	}
	if(pGreatPeopleUnit->IsCombatUnit())
	{
		getCapitalCity()->addProductionExperience(pGreatPeopleUnit);
	}
#endif
	ChangeNumGreatPeople(1);
#if !defined(MOD_GLOBAL_LOCAL_GENERALS)
	CvPlot *pSpawnPlot = GetGreatAdmiralSpawnPlot(pGreatPeopleUnit);
	if (pGreatPeopleUnit->plot() != pSpawnPlot)
	{
		pGreatPeopleUnit->setXY(pSpawnPlot->getX(), pSpawnPlot->getY());
	}
#endif

#if defined(MOD_GLOBAL_TRULY_FREE_GP)
	incrementGreatAdmiralsCreated(bIsFree);
#else
	incrementGreatAdmiralsCreated();
#endif
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
	changeGreatAdmiralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE() * ((getGreatAdmiralsCreated(bIsFree) / 10) + 1));
#else
	changeGreatAdmiralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE() * ((getGreatAdmiralsCreated() / 10) + 1));
#endif

	for(int iI = 0; iI < MAX_PLAYERS; iI++)
	{
		if(GET_PLAYER((PlayerTypes)iI).getTeam() == getTeam())
		{
#if defined(MOD_BUGFIX_MINOR)
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
			GET_PLAYER((PlayerTypes)iI).changeGreatAdmiralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE_TEAM() * ((getGreatAdmiralsCreated(bIsFree) / 10) + 1));
#else
			GET_PLAYER((PlayerTypes)iI).changeGreatAdmiralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE_TEAM() * ((getGreatAdmiralsCreated() / 10) + 1));
#endif
#else
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
			GET_PLAYER((PlayerTypes)iI).changeGreatAdmiralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE_TEAM() * ((getGreatPeopleCreated(bIsFree) / 10) + 1));
#else
			GET_PLAYER((PlayerTypes)iI).changeGreatAdmiralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE_TEAM() * ((getGreatPeopleCreated() / 10) + 1));
#endif
#endif
		}
	}

	CvPlot* pPlot = GC.getMap().plot(iX, iY);

	// Notification
	if(GetNotifications())
	{
		Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER");
		Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_GREAT_PERSON");
		GetNotifications()->Add(NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER, strText.toUTF8(), strSummary.toUTF8(), pPlot->getX(), pPlot->getY(), eGreatPersonUnit);
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::launch(VictoryTypes eVictory)
{
	CvTeam& kTeam = GET_TEAM(getTeam());

	if(!kTeam.canLaunch(eVictory))
	{
		return;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getUnitExtraCost(UnitClassTypes eUnitClass) const
{
	for(std::vector< std::pair<UnitClassTypes, int> >::const_iterator it = m_aUnitExtraCosts.begin(); it != m_aUnitExtraCosts.end(); ++it)
	{
		if((*it).first == eUnitClass)
		{
			return ((*it).second);
		}
	}

	return 0;
}

//	--------------------------------------------------------------------------------
void CvPlayer::setUnitExtraCost(UnitClassTypes eUnitClass, int iCost)
{
	for(std::vector< std::pair<UnitClassTypes, int> >::iterator it = m_aUnitExtraCosts.begin(); it != m_aUnitExtraCosts.end(); ++it)
	{
		if((*it).first == eUnitClass)
		{
			if(0 == iCost)
			{
				m_aUnitExtraCosts.erase(it);
			}
			else
			{
				(*it).second = iCost;
			}
			return;
		}
	}

	if(0 != iCost)
	{
		m_aUnitExtraCosts.push_back(std::make_pair(eUnitClass, iCost));
	}
}

// CACHE: cache frequently used values
///////////////////////////////////////

//	--------------------------------------------------------------------------------
void CvPlayer::invalidatePopulationRankCache()
{
	int iLoop;
	CvCity* pLoopCity;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->invalidatePopulationRankCache();
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::invalidateYieldRankCache(YieldTypes)
{
	int iLoop;
	CvCity* pLoopCity;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->invalidateYieldRankCache();
	}
}

//	--------------------------------------------------------------------------------
PlayerTypes CvPlayer::pickConqueredCityOwner(const CvCity& kCity) const
{
	PlayerTypes eBestPlayer = kCity.getOriginalOwner();

	if(NO_PLAYER != eBestPlayer)
	{
		CvPlayer& kBestPlayer = GET_PLAYER(eBestPlayer);

		if(kBestPlayer.getTeam() == getTeam())
		{
			return eBestPlayer;
		}
	}

	return GetID();
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canStealTech(PlayerTypes eTarget, TechTypes eTech) const
{
	if(GET_TEAM(GET_PLAYER(eTarget).getTeam()).GetTeamTechs()->HasTech(eTech))
	{
		if(GetPlayerTechs()->CanResearch(eTech))
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canSpyDestroyUnit(PlayerTypes, CvUnit& kUnit) const
{
	if(kUnit.getTeam() == getTeam())
	{
		return false;
	}

	if(kUnit.getUnitInfo().GetProductionCost() <= 0)
	{
		return false;
	}

	if(!kUnit.plot()->isVisible(getTeam()))
	{
		return false;
	}

	return true;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canSpyBribeUnit(PlayerTypes eTarget, CvUnit& kUnit) const
{
	if(!canSpyDestroyUnit(eTarget, kUnit))
	{
		return false;
	}

	// Can't buy units when at war
	if(kUnit.isEnemy(getTeam()))
	{
		return false;
	}

	IDInfo* pUnitNode = kUnit.plot()->headUnitNode();

	while(pUnitNode != NULL)
	{
		CvUnit* pLoopUnit = ::getUnit(*pUnitNode);
		pUnitNode = kUnit.plot()->nextUnitNode(pUnitNode);

		if(NULL != pLoopUnit && pLoopUnit != &kUnit)
		{
			if(pLoopUnit->isEnemy(getTeam()))
			{
				// If we buy the unit, we will be on the same plot as an enemy unit! Not good.
				return false;
			}
		}
	}

	return true;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canSpyDestroyBuilding(PlayerTypes, BuildingTypes eBuilding) const
{
	CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
	if(pkBuilding)
	{
		if(pkBuilding->GetProductionCost() <= 0)
		{
			return false;
		}

		if(::isLimitedWonderClass(pkBuilding->GetBuildingClassInfo()))
		{
			return false;
		}
	}

	return true;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canSpyDestroyProject(PlayerTypes eTarget, ProjectTypes eProject) const
{
	CvProjectEntry& kProject = *GC.getProjectInfo(eProject);
	if(kProject.GetProductionCost() <= 0)
	{
		return false;
	}

	if(GET_TEAM(GET_PLAYER(eTarget).getTeam()).getProjectCount(eProject) <= 0)
	{
		return false;
	}

	if(::isWorldProject(eProject))
	{
		return false;
	}

	if(!kProject.IsSpaceship())
	{
		return false;
	}
	else
	{
		VictoryTypes eVictory = (VictoryTypes)kProject.GetVictoryPrereq();
		if(NO_VICTORY != eVictory)
		{
			// Can't destroy spaceship components if we have already launched
			if(GET_TEAM(GET_PLAYER(eTarget).getTeam()).getVictoryCountdown(eVictory) >= 0)
			{
				return false;
			}
		}
	}

	return true;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNewCityProductionValue() const
{
	if(GC.getSETTLER_PRODUCTION_SPEED() != 0)
	{
		return GC.getSETTLER_PRODUCTION_SPEED();
	}

	int iValue = 0;
	for (int iJ = 0; iJ < GC.getNumBuildingClassInfos(); iJ++)
	{
		const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iJ);
		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
		if (pkBuildingClassInfo)
		{
			const BuildingTypes eBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(iJ)));
			if (NO_BUILDING != eBuilding)
			{
				CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
				if (pkBuildingInfo)
				{
					if (pkBuildingInfo->GetFreeStartEra() != NO_ERA)
					{
						if (GC.getGame().getStartEra() >= pkBuildingInfo->GetFreeStartEra())
						{
							iValue += (100 * getProductionNeeded(eBuilding)) / std::max(1, 100 + getProductionModifier(eBuilding));
						}
					}
				}
			}
		}
	}

	iValue *= 100 + GC.getNEW_CITY_BUILDING_VALUE_MODIFIER();
	iValue /= 100;

	CvGame& kGame = GC.getGame();

	iValue += (GC.getADVANCED_START_CITY_COST() * kGame.getGameSpeedInfo().getGrowthPercent()) / 100;

	int iPopulation = GC.getINITIAL_CITY_POPULATION() + kGame.getStartEraInfo().getFreePopulation();
	for(int i = 1; i <= iPopulation; ++i)
	{
		iValue += (getGrowthThreshold(i) * GC.getADVANCED_START_POPULATION_COST()) / 100;
	}

	if (MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	{
		iValue *= (100 + (getNumCities() * GC.getBALANCE_HAPPINESS_EMPIRE_MULTIPLIER()));
		iValue /= 100;
	}

	return iValue;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGrowthThreshold(int iPopulation) const
{
	CvAssertMsg(iPopulation > 0, "Population of city should be at least 1. Please show Jon this and send your last 5 autosaves.");

	int iThreshold;

	int iBaseThreshold = /*15*/ GC.getBASE_CITY_GROWTH_THRESHOLD();

	int iExtraPopThreshold = int((iPopulation-1) * /*6*/ GC.getCITY_GROWTH_MULTIPLIER());

	iBaseThreshold += iExtraPopThreshold;
	iExtraPopThreshold = (int) pow(double(iPopulation-1), (double) /*1.8*/ GC.getCITY_GROWTH_EXPONENT());

	iThreshold = iBaseThreshold + iExtraPopThreshold;

	if(isMinorCiv())
	{
		iThreshold *= GC.getMINOR_CIV_GROWTH_PERCENT();
		iThreshold /= 100;
	}

	iThreshold *= GC.getGame().getGameSpeedInfo().getGrowthPercent();
	iThreshold /= 100;

	iThreshold *= GC.getGame().getStartEraInfo().getGrowthPercent();
	iThreshold /= 100;

	if(!isHuman() && !IsAITeammateOfHuman() && !isBarbarian())
	{
		iThreshold *= GC.getGame().getHandicapInfo().getAIGrowthPercent();
		iThreshold /= 100;

		if (!MOD_BALANCE_CORE_DIFFICULTY)
		{
			iThreshold *= std::max(0, ((GC.getGame().getHandicapInfo().getAIPerEraModifier() * GetCurrentEra()) + 100));
			iThreshold /= 100;
		}
	}

	return std::max(1, iThreshold);
}

//	--------------------------------------------------------------------------------
/// This determines what plots the player has under control
void CvPlayer::UpdatePlots(void)
{
	m_aiPlots.clear();

	int iNumPlotsInEntireWorld = GC.getMap().numPlots();
	for(int iI = 0; iI < iNumPlotsInEntireWorld; iI++)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);
		if(pLoopPlot->getOwner() != m_eID)
			continue;

		//somebody might have plundered an improvement
		pLoopPlot->updateWaterFlags();

		m_aiPlots.push_back(iI);
	}
}

//	--------------------------------------------------------------------------------
/// Adds a plot at the end of the list
void CvPlayer::AddAPlot(CvPlot* pPlot)
{
	if(!pPlot)
		return;

	m_aiPlots.push_back(pPlot->GetPlotIndex());
}

//	--------------------------------------------------------------------------------
/// Returns the list of the plots the player owns
const PlotIndexContainer& CvPlayer::GetPlots(void) const
{
	return m_aiPlots;
}

//	--------------------------------------------------------------------------------
/// How many plots does this player own?
int CvPlayer::GetNumPlots() const
{
	return m_aiPlots.size();
}


//	--------------------------------------------------------------------------------
/// City strength mod (i.e. 100 = strength doubled)
int CvPlayer::GetCityStrengthMod() const
{
	return m_iCityStrengthMod;
}

//	--------------------------------------------------------------------------------
/// Sets City strength mod (i.e. 100 = strength doubled)
void CvPlayer::SetCityStrengthMod(int iValue)
{
	CvAssert(iValue >= 0);
	m_iCityStrengthMod = iValue;

	// Loop through all Cities and update their strength
	CvCity* pLoopCity;
	int iLoop;

	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->updateStrengthValue();
	}
}

//	--------------------------------------------------------------------------------
/// Changes City strength mod (i.e. 100 = strength doubled)
void CvPlayer::ChangeCityStrengthMod(int iChange)
{
	if(iChange != 0)
	{
		SetCityStrengthMod(GetCityStrengthMod() + iChange);
	}
}

//	--------------------------------------------------------------------------------
/// City growth percent mod (i.e. 100 = foodDifference doubled)
int CvPlayer::GetCityGrowthMod() const
{
	return m_iCityGrowthMod;
}

//	--------------------------------------------------------------------------------
/// Sets City growth percent mod (i.e. 100 = foodDifference doubled)
void CvPlayer::SetCityGrowthMod(int iValue)
{
	CvAssert(iValue >= 0);
	m_iCityGrowthMod = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes City growth percent mod (i.e. 100 = foodDifference doubled)
void CvPlayer::ChangeCityGrowthMod(int iChange)
{
	if(iChange != 0)
	{
		SetCityGrowthMod(GetCityGrowthMod() + iChange);
	}
}


//	--------------------------------------------------------------------------------
/// Capital growth percent mod (i.e. 100 = foodDifference doubled)
int CvPlayer::GetCapitalGrowthMod() const
{
	return m_iCapitalGrowthMod;
}

//	--------------------------------------------------------------------------------
/// Sets Capital growth percent mod (i.e. 100 = foodDifference doubled)
void CvPlayer::SetCapitalGrowthMod(int iValue)
{
	CvAssert(iValue >= 0);
	m_iCapitalGrowthMod = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes Capital growth percent mod (i.e. 100 = foodDifference doubled)
void CvPlayer::ChangeCapitalGrowthMod(int iChange)
{
	if(iChange != 0)
	{
		SetCapitalGrowthMod(GetCapitalGrowthMod() + iChange);
	}
}

//	--------------------------------------------------------------------------------
/// How many Plot has this player bought (costs should ramp up as more are purchased)
int CvPlayer::GetNumPlotsBought() const
{
	return m_iNumPlotsBought;
}

//	--------------------------------------------------------------------------------
/// Sets how many Plot has this player bought (costs should ramp up as more are purchased)
void CvPlayer::SetNumPlotsBought(int iValue)
{
	CvAssert(iValue >= 0);
	m_iNumPlotsBought = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes how many Plot has this player bought (costs should ramp up as more are purchased)
void CvPlayer::ChangeNumPlotsBought(int iChange)
{
	if(iChange != 0)
	{
		SetNumPlotsBought(GetNumPlotsBought() + iChange);
	}
}

//	--------------------------------------------------------------------------------
/// Gold cost of buying a new Plot
int CvPlayer::GetBuyPlotCost() const
{
	int iCost = /*50*/ GC.getPLOT_BASE_COST();
	iCost += (/*5*/ GC.getPLOT_ADDITIONAL_COST_PER_PLOT() * GetNumPlotsBought());

	// Cost Mod (Policies, etc.)
	if(GetPlotGoldCostMod() != 0)
	{
		iCost *= (100 + GetPlotGoldCostMod());
		iCost /= 100;
	}

	if(isMinorCiv())
	{
		iCost *= /*200*/ GC.getMINOR_CIV_GOLD_PERCENT();
		iCost /= 100;
	}

	return iCost;
}

//	--------------------------------------------------------------------------------
/// How much of a discount do we have for Plot buying
int CvPlayer::GetPlotGoldCostMod() const
{
	return m_iPlotGoldCostMod;
}

//	--------------------------------------------------------------------------------
/// Changes how much of a discount we have for Plot buying
void CvPlayer::ChangePlotGoldCostMod(int iChange)
{
	if(iChange != 0)
	{
		m_iPlotGoldCostMod += iChange;
	}
}

#if defined(MOD_TRAITS_CITY_WORKING) || defined(MOD_BUILDINGS_CITY_WORKING) || defined(MOD_POLICIES_CITY_WORKING) || defined(MOD_TECHS_CITY_WORKING)
//	--------------------------------------------------------------------------------
/// How many more city rings can we work
int CvPlayer::GetCityWorkingChange() const
{
	return m_iCityWorkingChange;
}

//	--------------------------------------------------------------------------------
/// Changes how many more city rings we can work
void CvPlayer::ChangeCityWorkingChange(int iChange)
{
	if(iChange != 0)
	{
		CvCity* pLoopCity;
		int iLoop;
		
		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
			int iOldPlots = pLoopCity->GetNumWorkablePlots();
			int iNewPlots = pLoopCity->GetNumWorkablePlots(iChange);
			
			for (int iI = std::min(iOldPlots, iNewPlots); iI < std::max(iOldPlots, iNewPlots); ++iI) {
				CvPlot* pLoopPlot = iterateRingPlots(pLoopCity->getX(), pLoopCity->getY(), iI);

				if (pLoopPlot) {
					pLoopPlot->changeCityRadiusCount(iChange);
					pLoopPlot->changePlayerCityRadiusCount(GetID(), iChange);
				}
			}
		}

		m_iCityWorkingChange += iChange;
	}
}
#endif

#if defined(MOD_TRAITS_CITY_AUTOMATON_WORKERS) || defined(MOD_BUILDINGS_CITY_AUTOMATON_WORKERS) || defined(MOD_POLICIES_CITY_AUTOMATON_WORKERS) || defined(MOD_TECHS_CITY_AUTOMATON_WORKERS)
//	--------------------------------------------------------------------------------
/// How many more automatons does each city have?
int CvPlayer::GetCityAutomatonWorkersChange() const
{
	return m_iCityAutomatonWorkersChange;
}

//	--------------------------------------------------------------------------------
/// Changes how many more automatons each city has
void CvPlayer::ChangeCityAutomatonWorkersChange(int iChange)
{
	if (iChange != 0)
	{
		CvCity* pLoopCity;
		int iLoop;

		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
			pLoopCity->changeCityAutomatonWorkersChange(iChange);
		}

		m_iCityAutomatonWorkersChange += iChange;
	}
}
#endif

//	--------------------------------------------------------------------------------
/// How much Culture is required for this City to acquire a new Plot
int CvPlayer::GetPlotCultureCostModifier() const
{
	return m_iPlotCultureCostModifier;
}

//	--------------------------------------------------------------------------------
/// Changes how much Culture is required for this City to acquire a new Plot
void CvPlayer::ChangePlotCultureCostModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iPlotCultureCostModifier += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// How much do we dampen the exponent used to determine Culture needed for a City to acquire a new Plot?
int CvPlayer::GetPlotCultureExponentModifier() const
{
	return m_iPlotCultureExponentModifier;
}

//	--------------------------------------------------------------------------------
/// Changes how much we dampen the exponent used to determine Culture needed for a City to acquire a new Plot?
void CvPlayer::ChangePlotCultureExponentModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iPlotCultureExponentModifier += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// How much do we dampen the growth of policy costs based on number of cities?
int CvPlayer::GetNumCitiesPolicyCostDiscount() const
{
	return m_iNumCitiesPolicyCostDiscount;
}

//	--------------------------------------------------------------------------------
/// Changes how much we dampen the growth of policy costs based on number of cities
void CvPlayer::ChangeNumCitiesPolicyCostDiscount(int iChange)
{
	if(iChange != 0)
	{
		m_iNumCitiesPolicyCostDiscount += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Do we save on unit maintenance for garrisons?
bool CvPlayer::IsGarrisonFreeMaintenance() const
{
	return m_iGarrisonFreeMaintenanceCount > 0;
}

//	--------------------------------------------------------------------------------
/// Changes setting on unit maintenance for garrisons
void CvPlayer::ChangeGarrisonFreeMaintenanceCount(int iChange)
{
	if(iChange != 0)
	{
		m_iGarrisonFreeMaintenanceCount += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Increase in city range strike due to garrison
int CvPlayer::GetGarrisonedCityRangeStrikeModifier() const
{
	return m_iGarrisonedCityRangeStrikeModifier;
}

//	--------------------------------------------------------------------------------
/// Changes increase in city range strike due to garrison
void CvPlayer::ChangeGarrisonedCityRangeStrikeModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iGarrisonedCityRangeStrikeModifier += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Cost of purchasing units modified?
int CvPlayer::GetUnitPurchaseCostModifier() const
{
	return m_iUnitPurchaseCostModifier;
}

//	--------------------------------------------------------------------------------
/// Cost of purchasing units modified?
void CvPlayer::ChangeUnitPurchaseCostModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iUnitPurchaseCostModifier += iChange;
	}
}

int CvPlayer::GetPlotDanger(const CvPlot& pPlot, const CvUnit* pUnit, const UnitIdContainer& unitsToIgnore, AirActionType iAirAction)
{
	if (m_pDangerPlots->IsDirty())
		m_pDangerPlots->UpdateDanger();

	return m_pDangerPlots->GetDanger(pPlot, pUnit, unitsToIgnore, iAirAction);
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetPlotDanger(const CvCity* pCity, const CvUnit* pPretendGarrison)
{
	if (m_pDangerPlots->IsDirty())
		m_pDangerPlots->UpdateDanger();

	return m_pDangerPlots->GetDanger(pCity, pPretendGarrison);
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetPlotDanger(const CvPlot& pPlot, bool bFixedDamageOnly)
{
	if (m_pDangerPlots->IsDirty())
		m_pDangerPlots->UpdateDanger();

	return m_pDangerPlots->GetDanger(pPlot, bFixedDamageOnly);
}

void CvPlayer::ResetDangerCache(const CvPlot & Plot, int iRange)
{
	m_pDangerPlots->ResetDangerCache(&Plot, iRange);
}

std::vector<CvUnit*> CvPlayer::GetPossibleAttackers(const CvPlot& Plot, TeamTypes eTeamForVisibilityCheck)
{
	if (m_pDangerPlots->IsDirty())
		m_pDangerPlots->UpdateDanger();

	return m_pDangerPlots->GetPossibleAttackers(Plot, eTeamForVisibilityCheck);
}

bool CvPlayer::IsKnownAttacker(const CvUnit* pAttacker)
{
	if (m_pDangerPlots->IsDirty())
		m_pDangerPlots->UpdateDanger();

	return m_pDangerPlots->IsKnownAttacker(pAttacker);
}

bool CvPlayer::AddKnownAttacker(const CvUnit* pAttacker)
{
	if (m_pDangerPlots->IsDirty())
		m_pDangerPlots->UpdateDanger();

	return m_pDangerPlots->AddKnownAttacker(pAttacker);
}

//	--------------------------------------------------------------------------------
/// Find closest city to a plot (within specified search radius)
CvCity* CvPlayer::GetClosestCity(const CvPlot* pPlot, int iSearchRadius, bool bSameArea )
{
	if (!pPlot)
		return NULL;

	CvCity* pClosestCity = NULL;
	int iBestDistance = INT_MAX;

	int iLoop;
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		//need to check area
		if (bSameArea && !pLoopCity->isMatchingArea(pPlot))
			continue;

		int iDistance = plotDistance(pPlot->getX(), pPlot->getY(), pLoopCity->getX(), pLoopCity->getY());
		if(iDistance < iBestDistance && iDistance <= iSearchRadius)
		{
			pClosestCity = pLoopCity;
			iBestDistance = iDistance;
		}
	}

	return pClosestCity;
}

//	--------------------------------------------------------------------------------

int CvPlayer::GetNumRealCities() const
{
	int iNum = 0;

	const CvCity* pLoopCity;
	int iLoop;
	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (pLoopCity->IsPuppet() && !GetPlayerTraits()->IsNoAnnexing())
			continue;

		if (pLoopCity->IsOccupied() && !pLoopCity->IsNoOccupiedUnhappiness())
			continue;

		iNum++;
	}

	return iNum;
}
// How many Puppet Cities does this player own
int CvPlayer::GetNumPuppetCities() const
{
	int iNum = 0;

	const CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity->IsPuppet())
		{
			iNum++;
		}
	}

	return iNum;
}
#if defined(MOD_DIPLOMACY_CITYSTATES_RESOLUTIONS) || defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
// How many other Capital Cities does this player own
int CvPlayer::GetNumCapitalCities() const
{
	int iNum = 0;

	const CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity->IsOriginalMajorCapital() && !pLoopCity->isCapital())
		{
			iNum++;
		}
	}

	return iNum;
}

//	--------------------------------------------------------------------------------
// How many other Capital Cities does this player own
int CvPlayer::GetNumMinorsControlled() const
{
	int iNum = 0;

	const CvCity* pLoopCity;
	int iLoop;
	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (pLoopCity->IsOriginalMinorCapital() && !pLoopCity->isCapital())
		{
			iNum++;
		}
	}

	return iNum;
}
#endif

#if defined(MOD_BALANCE_CORE_MILITARY)
int CvPlayer::GetFractionOriginalCapitalsUnderControl() const
{
	return m_iFractionOriginalCapitalsUnderControl;
}

void CvPlayer::UpdateMilitaryStats()
{
	m_iFractionOriginalCapitalsUnderControl = 0;
	m_iAvgUnitExp100 = 0;

	int iLoop;
	int iOCCount = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		//don't count our own capital!
		if(pLoopCity->IsOriginalMajorCapital() && !pLoopCity->isCapital())
			iOCCount++;

	if(iOCCount > 0)
	{
		int iCivCount = 0;
		for (int iLoopPlayer = 0; iLoopPlayer < MAX_PLAYERS; iLoopPlayer++)
		{
			CvPlayer &kPlayer = GET_PLAYER((PlayerTypes)iLoopPlayer);
			if (kPlayer.isEverAlive() && kPlayer.isMajorCiv() && !kPlayer.isObserver())
				iCivCount++;
		}

		m_iFractionOriginalCapitalsUnderControl = iOCCount * 100 / max(1, (iCivCount-1));
	}

	int iExpCount = 0, iExpSum = 0;
	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if (pLoopUnit->IsCombatUnit() && pLoopUnit->AI_getUnitAIType() != UNITAI_EXPLORE)
		{
			iExpCount++;
			iExpSum += pLoopUnit->getExperienceTimes100();
		}
	}

	m_iAvgUnitExp100 = iExpSum / max(1,iExpCount);
}

void CvPlayer::UpdateAreaEffectUnit(CvUnit* pUnit)
{
	if (!pUnit || pUnit->isDelayedDeath())
		return;

	if ((pUnit->IsGreatGeneral() || pUnit->GetGreatGeneralCount() > 0) || (pUnit->IsGreatAdmiral() || pUnit->GetGreatAdmiralCount() > 0) || pUnit->IsCityAttackSupport() || pUnit->IsSapper())
	{
		bool bFound = false;
		for ( size_t i=0; i<m_unitsAreaEffectPositive.size(); i++ )
		{
			if ( m_unitsAreaEffectPositive[i].first == pUnit->GetID() )
			{
				m_unitsAreaEffectPositive[i].second = pUnit->plot()->GetPlotIndex();
				bFound = true;
				break;
			}
		}

		if (!bFound)
			m_unitsAreaEffectPositive.push_back(std::make_pair(pUnit->GetID(), pUnit->plot()->GetPlotIndex()));
	}

	if (pUnit->getNearbyEnemyCombatMod() < 0)
	{
		bool bFound = false;
		for ( size_t i=0; i<m_unitsAreaEffectNegative.size(); i++ )
		{
			if ( m_unitsAreaEffectNegative[i].first == pUnit->GetID() )
			{
				m_unitsAreaEffectNegative[i].second = pUnit->plot()->GetPlotIndex();
				bFound = true;
				break;
			}
		}

		if (!bFound)
			m_unitsAreaEffectNegative.push_back(std::make_pair(pUnit->GetID(), pUnit->plot()->GetPlotIndex()));
	}

	if (pUnit->isNearbyPromotion())
	{
		bool bFound = false;
		for (size_t i = 0; i<m_unitsAreaEffectPromotion.size(); i++)
		{
			if (m_unitsAreaEffectPromotion[i].first == pUnit->GetID())
			{
				m_unitsAreaEffectPromotion[i].second = pUnit->plot()->GetPlotIndex();
				bFound = true;
				break;
			}
		}

		if (!bFound)
			m_unitsAreaEffectPromotion.push_back(std::make_pair(pUnit->GetID(), pUnit->plot()->GetPlotIndex()));
	}

	// Must be able to intercept
	if (pUnit->canIntercept())
	{
		bool bFound = false;
		for (size_t i = 0; i < m_unitsWhichCanIntercept.size(); i++)
		{
			if (m_unitsWhichCanIntercept[i].first == pUnit->GetID())
			{
				m_unitsWhichCanIntercept[i].second = pUnit->plot()->GetPlotIndex();
				bFound = true;
				break;
			}
		}

		if (!bFound)
			m_unitsWhichCanIntercept.push_back(std::make_pair(pUnit->GetID(), pUnit->plot()->GetPlotIndex()));
	}

	//might need to update the UI
	UpdateCityStrength();
}

void CvPlayer::UpdateAreaEffectUnits()
{
	//great generals/admirals
	m_unitsAreaEffectPositive.clear();
	//maori warrior et al
	m_unitsAreaEffectNegative.clear();
	//interceptors
	m_unitsWhichCanIntercept.clear();
	//special promotions
	m_unitsAreaEffectPromotion.clear();

	// Loop through our units
	int iLoop;
	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if ((pLoopUnit->IsGreatGeneral() || pLoopUnit->GetGreatGeneralCount() > 0) || 
			(pLoopUnit->IsGreatAdmiral() || pLoopUnit->GetGreatAdmiralCount() > 0) || 
			 pLoopUnit->IsCityAttackSupport() || pLoopUnit->IsSapper())
			m_unitsAreaEffectPositive.push_back(std::make_pair(pLoopUnit->GetID(), pLoopUnit->plot()->GetPlotIndex()));

		if (pLoopUnit->getNearbyEnemyCombatMod() < 0)
			m_unitsAreaEffectNegative.push_back(std::make_pair(pLoopUnit->GetID(), pLoopUnit->plot()->GetPlotIndex()));

		if (pLoopUnit->isNearbyPromotion() || pLoopUnit->getAdjacentTileHeal()>0)
			m_unitsAreaEffectPromotion.push_back(std::make_pair(pLoopUnit->GetID(), pLoopUnit->plot()->GetPlotIndex()));

		if (pLoopUnit->canIntercept())
			m_unitsWhichCanIntercept.push_back(std::make_pair(pLoopUnit->GetID(), pLoopUnit->plot()->GetPlotIndex()));
	}

	//might need to update the UI
	UpdateCityStrength();
}

void CvPlayer::UpdateAreaEffectPlots()
{
	//moai et al
	m_plotsAreaEffectPositiveFromTraits.clear();

	// Loop through our plots
	ImprovementTypes iTraitImprovement = GetPlayerTraits()->GetCombatBonusImprovementType();
	if (iTraitImprovement!=NO_IMPROVEMENT)
	{
		for(int iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)
		{
			CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);
			if (pPlot && pPlot->getOwner()==GetID() && pPlot->getImprovementType()==iTraitImprovement )
				m_plotsAreaEffectPositiveFromTraits.push_back( iPlotLoop );
		}
	}

	//Looks for Natural Wonders
	if(GetPlayerTraits()->IsCombatBoostNearNaturalWonder())
	{
		for(int iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)
		{
			CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);
			if (pPlot && pPlot->IsNaturalWonder())
				m_plotsAreaEffectPositiveFromTraits.push_back( iPlotLoop );
		}
	}
}
const std::vector<std::pair<int, int>>& CvPlayer::GetAreaEffectPromotionUnits() const
{
	return m_unitsAreaEffectPromotion;
}
const std::vector<std::pair<int,int>>& CvPlayer::GetAreaEffectPositiveUnits() const
{
	return m_unitsAreaEffectPositive;
}

const std::vector<std::pair<int,int>>& CvPlayer::GetAreaEffectNegativeUnits() const
{
	return m_unitsAreaEffectNegative;
}

const std::vector<std::pair<int, int>>& CvPlayer::GetPossibleInterceptors() const
{
	return m_unitsWhichCanIntercept;
}

const std::vector<int>& CvPlayer::GetAreaEffectPositiveFromTraitsPlots() const
{
	return m_plotsAreaEffectPositiveFromTraits;
}

int CvPlayer::GetAreaEffectModifier(AreaEffectType eType, DomainTypes eDomain, const CvPlot* pTestPlot, const CvUnit* pIgnoreThisUnit) const
{
	int iResult = 0;
	if (pTestPlot == NULL)
		return 0;

	const std::vector<std::pair<int, int>>& possibleUnits = GetAreaEffectPositiveUnits();
	for (std::vector<std::pair<int, int>>::const_iterator it = possibleUnits.begin(); it != possibleUnits.end(); ++it)
	{
		CvPlot* pUnitPlot = GC.getMap().plotByIndexUnchecked(it->second);

		//performance: very rough distance check first without looking up the unit pointer ...
		if (plotDistance(*pUnitPlot,*pTestPlot) > 5)
			continue;

		//exclude this unit!
		CvUnit* pUnit = getUnit(it->first);
		if (pUnit == NULL || pUnit == pIgnoreThisUnit)
			continue;

		//domain check
		if (eDomain != NO_DOMAIN && pUnit->getDomainType() != eDomain)
			continue;

#if defined(MOD_PROMOTIONS_AURA_CHANGE)
		int iEffectRange = /*2*/ GC.getGREAT_GENERAL_MAX_RANGE() + pUnit->GetAuraRangeChange();
#else
		int iEffectRange = /*2*/ GC.getGREAT_GENERAL_RANGE();
#endif

		//actual distance check
		int iDistance = plotDistance(*pUnitPlot,*pTestPlot);
		if (iDistance > iEffectRange)
			continue;

		switch (eType)
		{
			case AE_GREAT_GENERAL:
			{
				if ((pUnit->IsGreatGeneral() || pUnit->GetGreatGeneralCount() > 0) || (pUnit->IsGreatAdmiral() || pUnit->GetGreatAdmiralCount() > 0))
					iResult = GetGreatGeneralCombatBonus() + GetPlayerTraits()->GetGreatGeneralExtraBonus() + pUnit->GetAuraEffectChange();
				break;
			}
			case AE_SAPPER:
			{
				if (pUnit->IsSapper() && IsAtWarWith(pTestPlot->getOwner()))
				{
					if (iDistance < iEffectRange)
					{
						iResult = GC.getSAPPED_CITY_ATTACK_MODIFIER();
					}
					else if (iDistance == iEffectRange)
					{
						iResult = GC.getSAPPED_CITY_ATTACK_MODIFIER()/2;
					}
				}
				break;
			}
			case AE_SIEGETOWER:
			{
				if (pUnit->IsCityAttackSupport())
					return 1; //just used as a boolean flag
				break;
			}
		}
	}

	return iResult;
}

void CvPlayer::UpdateCityStrength()
{
	//support unit might have moved close to the city or away from it, so just update the value for all cities without further logic
	int iCityLoop;
	for (CvCity* pLoopCity = firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = nextCity(&iCityLoop))
		pLoopCity->updateStrengthValue();
}


void CvPlayer::UpdateCurrentAndFutureWars()
{
	//cache the wars we have going - ignore barbarians
	m_playersWeAreAtWarWith.clear();
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_PLAYERS-1; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		if(GET_PLAYER(eLoopPlayer).isAlive() && GET_TEAM(getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
			m_playersWeAreAtWarWith.push_back( eLoopPlayer );
	}

	//see if we're not at war yet but war is coming
	m_playersAtWarWithInFuture.clear();
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		if(GET_PLAYER(eLoopPlayer).isAlive() && !GET_PLAYER(eLoopPlayer).isBarbarian() && !IsAtWarWith(eLoopPlayer) )
		{
			bool bWarMayBeComing = false;

			//do we want to start a war?
			if(GetDiplomacyAI()->IsArmyInPlaceForAttack(eLoopPlayer) || GetMilitaryAI()->GetSneakAttackOperation(eLoopPlayer) != NULL)
				bWarMayBeComing = true;

			//do they want to start a war?
			AggressivePostureTypes eMilitaryPosture = GetDiplomacyAI()->GetMilitaryAggressivePosture(eLoopPlayer);
			ThreatTypes eWarmongerThreat = GetDiplomacyAI()->GetWarmongerThreat(eLoopPlayer);
			if (eMilitaryPosture == AGGRESSIVE_POSTURE_INCREDIBLE || eWarmongerThreat == THREAT_SEVERE || eWarmongerThreat == THREAT_CRITICAL)
				bWarMayBeComing = true;

			//how is the general diplomatic climate?
			MajorCivApproachTypes eApproach = GetDiplomacyAI()->GetMajorCivApproach(eLoopPlayer, /*bHideTrueFeelings*/ false);
			MajorCivApproachTypes eTheirApproach = GetDiplomacyAI()->GetApproachTowardsUsGuess(eLoopPlayer);
			MajorCivOpinionTypes eOpinion = GetDiplomacyAI()->GetMajorCivOpinion(eLoopPlayer);
			if(eApproach == MAJOR_CIV_APPROACH_HOSTILE || eApproach == MAJOR_CIV_APPROACH_DECEPTIVE || 
				eApproach == MAJOR_CIV_APPROACH_AFRAID || eApproach == MAJOR_CIV_APPROACH_GUARDED ||
				eTheirApproach == MAJOR_CIV_APPROACH_HOSTILE || eTheirApproach == MAJOR_CIV_APPROACH_GUARDED ||
				eOpinion == MAJOR_CIV_OPINION_ENEMY)
				bWarMayBeComing = true;

			if (bWarMayBeComing)
				m_playersAtWarWithInFuture.push_back(eLoopPlayer);
		}
	}

}

bool CvPlayer::HasCityInDanger(bool bAboutToFall, int iMinDanger) const
{
	const CvCity *pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (bAboutToFall && pLoopCity->isInDangerOfFalling())
			return true;

		if (!bAboutToFall && GET_PLAYER(m_eID).GetPlotDanger(pLoopCity) >= iMinDanger)
			return true;
	}

	return false;
}
#endif

//	--------------------------------------------------------------------------------
// How many Cities does this player have for policy/tech cost purposes?
int CvPlayer::GetMaxEffectiveCities(bool bIncludePuppets)
{
	int iNumCities = getNumCities();

	// Don't count puppet Cities
	int iNumPuppetCities = GetNumPuppetCities();
	iNumCities -= iNumPuppetCities;

	bool bVPChange = MOD_BALANCE_CORE_DIPLOMACY_ADVANCED;

	// Don't count cities where the player hasn't decided yet what to do with them or ones that are currently being razed
	int iNumLimboCities = 0;
	const CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (pLoopCity->IsIgnoreCityForHappiness() || (!bVPChange && pLoopCity->IsRazing()))
		{
			iNumLimboCities++;
		}
	}
	iNumCities -= iNumLimboCities;

	if(iNumCities == 0)	// If we don't pretend the player has at least one city it screws up the math
		iNumCities = 1;

	// Update member variable
	if (!bVPChange)
		m_iMaxEffectiveCities = (m_iMaxEffectiveCities > iNumCities) ? m_iMaxEffectiveCities : iNumCities;
	else
		m_iMaxEffectiveCities = iNumCities;

	if (bIncludePuppets)
	{
		return m_iMaxEffectiveCities + iNumPuppetCities;
	}

	return m_iMaxEffectiveCities;
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// How many Natural Wonders has this player found in its area?
int CvPlayer::GetExtraSupplyPerPopulation() const
{
	return m_iExtraSupplyPerPopulation;
}

//	--------------------------------------------------------------------------------
/// Changes many Natural Wonders has this player found in its area
void CvPlayer::ChangeExtraSupplyPerPopulation(int iChange)
{
	m_iExtraSupplyPerPopulation += iChange;
}

int CvPlayer::getCitySupplyFlatGlobal() const
{
	return m_iCitySupplyFlatGlobal;
}
void CvPlayer::changeCitySupplyFlatGlobal(int iChange)
{
	if (iChange != 0)
		m_iCitySupplyFlatGlobal += iChange;
}
#endif
//	--------------------------------------------------------------------------------
/// How many Natural Wonders has this player found in its area?
int CvPlayer::GetNumNaturalWondersDiscoveredInArea() const
{
	return m_iNumNaturalWondersDiscoveredInArea;
}

//	--------------------------------------------------------------------------------
/// Sets how many Natural Wonders has this player found in its area
void CvPlayer::SetNumNaturalWondersDiscoveredInArea(int iValue)
{
	m_iNumNaturalWondersDiscoveredInArea = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes many Natural Wonders has this player found in its area
void CvPlayer::ChangeNumNaturalWondersDiscoveredInArea(int iChange)
{
	SetNumNaturalWondersDiscoveredInArea(GetNumNaturalWondersDiscoveredInArea() + iChange);
}

//	--------------------------------------------------------------------------------
/// Calculates how many Natural Wonders are in plots this player owns
int CvPlayer::GetNumNaturalWondersInOwnedPlots()
{
	int iValue = 0;
	// go through all the plots the player has under their control
	for (PlotIndexContainer::const_iterator it = m_aiPlots.begin(); it != m_aiPlots.end(); ++it)
	{
		CvPlot* pPlot = GC.getMap().plotByIndex(*it);

		if (pPlot && pPlot->IsNaturalWonder())
			iValue++;
	}
	return iValue;
}

//	--------------------------------------------------------------------------------
#if defined(MOD_BALANCE_CORE)

bool CvPlayer::HaveGoodSettlePlot(int iAreaID)
{
	// Check if there are good plots to settle somewhere
	int iFirstArea, iSecondArea;
	if (iAreaID==-1)
		return GetBestSettleAreas(iFirstArea, iSecondArea) > 0; 
	else
	{
		GetBestSettleAreas(iFirstArea, iSecondArea);
		return (iFirstArea == iAreaID || iSecondArea == iAreaID);
	}
}

#endif
//	--------------------------------------------------------------------------------
/// How long ago did this guy last settle a city?
int CvPlayer::GetTurnsSinceSettledLastCity() const
{
	return m_iTurnsSinceSettledLastCity;
}

//	--------------------------------------------------------------------------------
/// How long ago did this guy last settle a city?
void CvPlayer::SetTurnsSinceSettledLastCity(int iValue)
{
	if(m_iTurnsSinceSettledLastCity != iValue)
		m_iTurnsSinceSettledLastCity = iValue;
}

//	--------------------------------------------------------------------------------
/// How long ago did this guy last settle a city?
void CvPlayer::ChangeTurnsSinceSettledLastCity(int iChange)
{
	if(iChange != 0)
		SetTurnsSinceSettledLastCity(GetTurnsSinceSettledLastCity() + iChange);
}

//	--------------------------------------------------------------------------------
/// Find best continents to settle next two cities; returns number found over minimum
int CvPlayer::GetBestSettleAreas(int& iFirstArea, int& iSecondArea)
{
	//lazy update
	updatePlotFoundValues();

	CvArea* pLoopArea;
	int iLoop;
	float fBestScore = 0;	//default score of each area is zero, so we have to be better
	float fSecondBestScore = 0;
	int iBestArea = -1;
	int iSecondBestArea = -1;
	int iNumFound = 0;

	CvMap& theMap = GC.getMap();

	// Find best two scores above minimum
	for(pLoopArea = theMap.firstArea(&iLoop); pLoopArea != NULL; pLoopArea = theMap.nextArea(&iLoop))
	{
		if(pLoopArea->isWater())
			continue;

		float fScore = (float)pLoopArea->getTotalFoundValue();
		if (fScore <= 0)
			continue;

		EconomicAIStrategyTypes eStrategyExpandToOtherContinents = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_EXPAND_TO_OTHER_CONTINENTS");
		if(eStrategyExpandToOtherContinents != NO_ECONOMICAISTRATEGY)
		{
			if (GetEconomicAI()->IsUsingStrategy(eStrategyExpandToOtherContinents))
			{
				if (getCapitalCity() && pLoopArea->GetID() != getCapitalCity()->getArea())
				{
					fScore *= 2;
				}
			}
		}
		EconomicAIStrategyTypes eStrategyReallyExpandToOtherContinents = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_REALLY_EXPAND_TO_OTHER_CONTINENTS");
		if(eStrategyExpandToOtherContinents != NO_ECONOMICAISTRATEGY)
		{
			if (GetEconomicAI()->IsUsingStrategy(eStrategyReallyExpandToOtherContinents))
			{
				if (getCapitalCity() && pLoopArea->GetID() != getCapitalCity()->getArea())
				{
					fScore *= 2;
				}
			}
		}

		int nEnemyCities = 0, nMyCities = 0;
		for(int iPlayer = 0; iPlayer < MAX_MAJOR_CIVS; ++iPlayer)
		{
			if(iPlayer!=GetID())
				nEnemyCities += pLoopArea->getCitiesPerPlayer((PlayerTypes)iPlayer);
			else
				nMyCities += pLoopArea->getCitiesPerPlayer((PlayerTypes)iPlayer);
		}

		//if we don't have any cities there but our potential enemies do, be careful
		if (nEnemyCities>0 && nMyCities==0)
			fScore *= 0.50f;

		iNumFound++;
		if(fScore > fBestScore)
		{
			// Already have a best area?  If so demote to 2nd
			if(fBestScore > 0)
			{
				fSecondBestScore = fBestScore;
				iSecondBestArea = iBestArea;
			}
			iBestArea = pLoopArea->GetID();
			fBestScore = fScore;
		}

		else if(fScore > fSecondBestScore)
		{
			iSecondBestArea = pLoopArea->GetID();
			fSecondBestScore = fScore;
		}
	}

	// Return data
	iFirstArea = iBestArea;
	iSecondArea = iSecondBestArea;

	return iNumFound;
}

//	--------------------------------------------------------------------------------
/// Find the best spot in the entire world for this unit to settle
ostream& operator<<(ostream& os, const CvPlot* pPlot)
{
	if (pPlot)
	    os << pPlot->getX() << "," << pPlot->getY() << "," << pPlot->getTerrainType() << "," << pPlot->getPlotType() << "," \
			<< pPlot->getFeatureType() << "," << pPlot->getOwner() << "," << pPlot->getArea();
    return os;
}

CvPlot* CvPlayer::GetBestSettlePlot(const CvUnit* pUnit, int iTargetArea, bool bNeedSafePlot, bool& bIsSafe, CvAIOperation* pOpToIgnore, bool bForceLogging) const
{
	std::vector<SPlotWithScore> vSettlePlots;

	//--------
	bool bLogging = (GC.getLogging() && GC.getAILogging()) || bForceLogging; 
	std::stringstream dump;
	int iDanger=0, iFertility=0;

#if defined(MOD_BALANCE_CORE_MILITARY_LOGGING)
	bLogging &= MOD_BALANCE_CORE_MILITARY_LOGGING;
#endif
	//--------

	PlayerTypes eOwner = pUnit ? pUnit->getOwner() : GetID();
	TeamTypes eTeam = pUnit ? pUnit->getTeam() : getTeam();

	int iBestArea, iSecondBestArea;
	//call this the sneaky way cause it's not const
	int iNumSettleAreas = GET_PLAYER(GetID()).GetBestSettleAreas(iBestArea, iSecondBestArea);
	if(iNumSettleAreas == 0)
	{
		return NULL;
	}

	//in case we're not getting the cached data, we need to prepare some things
	vector<int> ignorePlots(GC.getMap().numPlots(), 0); //these are the plots whose yield we ignore
	if (bLogging)
	{
		GC.getGame().GetSettlerSiteEvaluator()->ComputeFlavorMultipliers(this);
		for (int iI = 0; iI < GC.getMap().numPlots(); iI++)
		{
			CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iI);
			if (pPlot->isOwned() && pPlot->getOwner() != m_eID)
				ignorePlots[iI] = 1;
			else if (pPlot->IsAdjacentOwnedByTeamOtherThan(getTeam()) && GC.getGame().GetClosestCityDistanceInPlots(pPlot)<GC.getMIN_CITY_RANGE())
				ignorePlots[iI] = 1;
		}
	}

	//prefer settling close in the beginning
	int iTimeOffset = (24 * GC.getGame().getElapsedGameTurns()) / max(512, GC.getGame().getMaxTurns());

	//basic search area around existing cities. 
	int iMaxSettleDistance = GC.getSETTLER_EVALUATION_DISTANCE() + iTimeOffset; //plot value at max distance or greater is scaled to zero
	if(IsCramped())
		iMaxSettleDistance += iTimeOffset;
	int iSettleDropoffThreshold = min(iMaxSettleDistance,GC.getSETTLER_DISTANCE_DROPOFF_MODIFIER());

	//if we want to go to other continents, we need a very large search radius
	EconomicAIStrategyTypes eStrategyExpandToOtherContinents = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_EXPAND_TO_OTHER_CONTINENTS");
	EconomicAIStrategyTypes eStrategyReallyExpandToOtherContinents = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_REALLY_EXPAND_TO_OTHER_CONTINENTS");
	bool bWantOffshore = GetEconomicAI()->IsUsingStrategy(eStrategyReallyExpandToOtherContinents) || GetEconomicAI()->IsUsingStrategy(eStrategyExpandToOtherContinents);
	bool bCanEmbark = GET_TEAM(getTeam()).canEmbark() || GetPlayerTraits()->IsEmbarkedAllWater();

	CvMap& kMap = GC.getMap();
	int iNumPlots = kMap.numPlots();
	for(int iPlotLoop = 0; iPlotLoop < iNumPlots; iPlotLoop++)
	{
		CvPlot* pPlot = kMap.plotByIndexUnchecked(iPlotLoop);

		if(!pPlot)
		{
			continue;
		}

		if (bLogging)
		{
			iDanger = pUnit->GetDanger(pPlot);
			iFertility = GC.getGame().GetSettlerSiteEvaluator()->PlotFertilityValue(pPlot,true);
		}

		if(!pPlot->isRevealed(getTeam()))
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",0," << iDanger << "," << iFertility << ",-1" << ",0" << std::endl;
			//--------------
			continue;
		}

		if(iTargetArea != -1 && pPlot->getArea() != iTargetArea)
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",1," << iDanger << "," << iFertility << ",-1" << ",-6" << std::endl;
			//--------------
			continue;
		}

		if ((pPlot->getOwner() != NO_PLAYER && pPlot->getOwner() != eOwner) || (pPlot->getImprovementType() == (ImprovementTypes)GC.getBARBARIAN_CAMP_IMPROVEMENT()))
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",1," << iDanger << "," << iFertility << ",-1" << ",-2" << std::endl;
			//--------------
			continue;
		}

		if(pPlot->IsAdjacentOwnedByTeamOtherThan(eTeam))
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",1," << iDanger << "," << iFertility << ",-1" << ",-2" << std::endl;
			//--------------
			continue;
		}

		for (std::vector<PlayerTypes>::const_iterator it = m_playersWeAreAtWarWith.begin(); it != m_playersWeAreAtWarWith.end(); ++it)
		{
			if(!GET_PLAYER(*it).isBarbarian())
			{
				if(pPlot->IsCloseToBorder(*it))
				{
					//--------------
					if (bLogging) 
					dump << pPlot << ",1," << iDanger << "," << iFertility << ",-1" << ",-2" << std::endl;
					//--------------
					continue;
				}
			}
		}

		if(pUnit && (!pUnit->canFound(pPlot) || !pUnit->canMoveInto(*pPlot)))
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",1," << iDanger << "," << iFertility << ",-1" << ",-1" << std::endl;
			//--------------
			continue;
		}

		if (IsPlotTargetedForCity(pPlot,pOpToIgnore))
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",1," << iDanger << "," << iFertility << ",-1" << ",-3" << std::endl;
			//--------------
			continue;
		}

		if(pUnit && pPlot->getArea() != pUnit->getArea() && !bCanEmbark)
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",1," << iDanger << "," << iFertility << ",-1" << ",-4" << std::endl;
			//--------------
			continue;
		}

		//check for new continent
		const CvArea* pArea = GC.getMap().getArea(pPlot->getArea());
		const CvCity* pCapital = getCapitalCity();

		//ignore if not interesting
		bool bOffshore = (pArea && pCapital && pArea->GetID() != pCapital->plot()->getArea());
		if (bWantOffshore && !bOffshore)
			continue;

		//take into account distance from existing cities
		int iRelevantDistance = GetCityDistanceInEstimatedTurns(pPlot)*2;

		//however, if we ever have a settler very far away, don't wander around forever ...
		if (pUnit && GetCityDistanceInEstimatedTurns(pUnit->plot()) * 2 > iMaxSettleDistance)
			iRelevantDistance = plotDistance(pUnit->getX(), pUnit->getY(), pPlot->getX(), pPlot->getY());

		int iScale = MapToPercent( iRelevantDistance, iMaxSettleDistance, iSettleDropoffThreshold );

		//on a new continent we want to settle along the coast
		bool bNewContinent = (pArea && pArea->getCitiesPerPlayer(GetID()) == 0);
		if (bNewContinent)
		{
			if (!pPlot->isCoastalLand())
			iScale = 1;
		}
		else
		{
			//on a settled continent we want our territory to be contiguous, unless there is lots of free space
			CvCity* pClosestCity = GC.getGame().GetClosestCityByEstimatedTurns(pPlot,true);
			if (pClosestCity && pClosestCity->getOwner() != GetID())
			{
				//todo: there is already distance check in PlotFoundValue() ...
				int iTheirDistance = GC.getGame().GetClosestCityDistanceInTurns(pPlot, true);
				int iOurDistance = GetCityDistanceInEstimatedTurns(pPlot);
				int iRatio = (100 * iTheirDistance) / iOurDistance;
				if (iRatio < 100 && iTheirDistance < 5)
				{
					//square it, ie exaggerate the effect
					iScale *= iRatio;
					iScale /= 100;
					iScale *= iRatio;
					iScale /= 100;
				}
			}
		}

		//if we want offshore expansion, distance is less important
		if (bWantOffshore && bOffshore)
			iScale = max(50,min(100,iScale*2));

		//bonus if the plot is in a desirable (large) area
		if (pPlot->getArea() == iBestArea)
			iScale *= 4;
		if (pPlot->getArea() == iSecondBestArea)
			iScale *= 2;

		if (iScale==0)
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",1," << iDanger << "," << iFertility << ",0" << ",-5" << std::endl;
			//--------------
			continue;
		}

		//finally no more obstacles
		int iValue = 0;
		if (bLogging) 
		{
			CvString strDebug;
			iValue = GC.getGame().GetSettlerSiteEvaluator()->PlotFoundValue(pPlot, this, ignorePlots, bNewContinent, &strDebug);
			//--------------
			dump << pPlot << ",1," << iDanger << "," << iFertility << "," << iScale << "," << iValue << "," << strDebug.c_str() << std::endl;
			//--------------
		}
		else
		{
			//with caching - is set to -1 if not possible / not good enough
			iValue = pPlot->getFoundValue(eOwner);
		}

		if (iValue<=0)
			continue;

		//factor in the distance
		iValue = (iValue*iScale)/100;

		vSettlePlots.push_back( SPlotWithScore(pPlot,iValue) );
	}

#if defined(MOD_BALANCE_CORE_MILITARY_LOGGING)
	if (bLogging) 
	{
		std::stringstream ss;
		ss << "CitySites_" << getCivilizationAdjective() << "_" << std::setfill('0') << std::setw(3) << GC.getGame().getGameTurn() << ".txt";
		FILogFile* pLog=LOGFILEMGR.GetLog( ss.str().c_str(), FILogFile::kDontTimeStamp );
		pLog->Msg( "#x,y,terrain,plotype,feature,owner,area,revealed,danger,fertility,distancescale,value,comments\n" );
		pLog->Msg( dump.str().c_str() );
		pLog->Close();
	}
#endif

	if (vSettlePlots.empty())
		return 0;

	//order by increasing score
	std::stable_sort( vSettlePlots.begin(), vSettlePlots.end() );
	//delete the worst half
	SPlotWithScore ref = vSettlePlots.back();
	ref.score = int(ref.score * 0.5f);
	std::vector<SPlotWithScore>::iterator cutoff = std::upper_bound( vSettlePlots.begin(), vSettlePlots.end(), ref );
	//reverse so best comes first
	vSettlePlots.erase( vSettlePlots.begin(), cutoff );
	std::reverse( vSettlePlots.begin(), vSettlePlots.end() );

	//AI cheating here ... check if a settler would likely be captured
	std::vector<CvPlot*> vBadPlots;
	for(int iI = 0; iI < iNumPlots; iI++)
	{
		CvPlot *pPlot = kMap.plotByIndexUnchecked(iI);

		if(iTargetArea!=-1 && pPlot->getArea()!=iTargetArea)
			continue;

		if (pPlot->getRevealedImprovementType(getTeam()) == GC.getBARBARIAN_CAMP_IMPROVEMENT())
		{
			vBadPlots.push_back(pPlot);
			continue;
		}

		IDInfo* pUnitNode = pPlot->headUnitNode();
		while(pUnitNode != NULL)
		{
			CvUnit* pLoopUnit = ::getUnit(*pUnitNode);
			pUnitNode = pPlot->nextUnitNode(pUnitNode);

			if (pLoopUnit && pLoopUnit->IsCombatUnit() && pLoopUnit->getDomainType() == DOMAIN_LAND)
			{
				if (pLoopUnit->isEnemy(getTeam()) || pLoopUnit->isHuman()) //extra careful with those sneaky humans
				{
					vBadPlots.push_back(pPlot);
					break;
				}
			}
		}
	}

	//see where our settler can go
	ReachablePlots reachablePlots;
	int iMaxSafeTurns = 4;
	if (pUnit)
	{
		SPathFinderUserData data(pUnit,0,iMaxSafeTurns);
		data.ePathType = PT_UNIT_REACHABLE_PLOTS;
		data.iMinMovesLeft = 1; //we want to be able to found on the final turn
		reachablePlots = GC.GetPathFinder().GetPlotsInReach(pUnit->plot(), data);
	}

	for (size_t i=0; i<vSettlePlots.size(); i++)
	{
		CvPlot* pTestPlot = vSettlePlots[i].pPlot;
		ReachablePlots::iterator it = reachablePlots.find(pTestPlot->GetPlotIndex());

		bool bDangerous = true;
		bool bCanReachThisTurn = false;
		if (it != reachablePlots.end())
		{
			bDangerous = (pUnit->GetDanger(GC.getMap().plotByIndex(it->iPlotIndex))>30); //a ranged attack or some fog danger is ok
			bCanReachThisTurn = (it->iTurns == 0 && it->iMovesLeft > 0);
		}

		//check if it's too close to an enemy
		if (!bCanReachThisTurn && !bDangerous)
		{
			for (size_t j = 0; j < vBadPlots.size(); j++)
			{
				if (vSettlePlots[i].pPlot->getArea() != vBadPlots[j]->getArea())
					continue;

				int iDistanceToDanger = plotDistance(*pTestPlot, *(vBadPlots[j]));
				if (iDistanceToDanger < 4)
				{
					bDangerous = true;
					break;
				}
			}
		}

		//if it's too far from our existing cities, it's dangerous
		if (!bDangerous && !bCanReachThisTurn)
		{
			int iDistanceToCity = GetCityDistanceInEstimatedTurns(pTestPlot);
			//also consider distance to settler here in case of re-targeting an operation
			if (iDistanceToCity>3 && pTestPlot->getOwner()!=m_eID)
				bDangerous = true;
		}

		if (bNeedSafePlot)
		{
			if (!bDangerous)
			{
				bIsSafe = true;
				return pTestPlot;
			}
		}
		else //don't care about safety but return the status nevertheless
		{
			bIsSafe = !bDangerous;
			return pTestPlot;
		}
	}

	bIsSafe = false;
	return NULL;
}

//	--------------------------------------------------------------------------------
/// How many Wonders has this Player constructed?
int CvPlayer::GetNumWonders() const
{
	return m_iNumWonders;
}

//	--------------------------------------------------------------------------------
/// Changes how many Wonders this Player has constructed
void CvPlayer::ChangeNumWonders(int iValue)
{
	if(iValue != 0)
	{
		m_iNumWonders += iValue;
	}
}

//	--------------------------------------------------------------------------------
/// How many Policies has this Player constructed?
int CvPlayer::GetNumPolicies() const
{
	return m_iNumPolicies;
}

//	--------------------------------------------------------------------------------
/// Changes how many Policies this Player has constructed
void CvPlayer::ChangeNumPolicies(int iValue)
{
	if(iValue != 0)
	{
		m_iNumPolicies += iValue;
	}
}

//	--------------------------------------------------------------------------------
/// How many GreatPeople has this Player constructed?
int CvPlayer::GetNumGreatPeople() const
{
	return m_iNumGreatPeople;
}

//	--------------------------------------------------------------------------------
/// Changes how many GreatPeople this Player has constructed
void CvPlayer::ChangeNumGreatPeople(int iValue)
{
	if(iValue != 0)
	{
		m_iNumGreatPeople += iValue;
	}
}
#if defined(MOD_BALANCE_CORE)
void CvPlayer::SetBestWonderCities()
{
	int iGPT = GetTreasury()->CalculateBaseNetGold();
	bool bIsCapitalCompetitive = isCapitalCompetitive();
	
	for (int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
	{
		int iBestValue = 0;
		CvCity* pBestCity = NULL;
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
		CvBuildingEntry* pkeBuildingInfo = GC.getBuildingInfo(eBuilding);

		//Not wonder? Skip
		if (!pkeBuildingInfo)
			continue;

		if (!::isWorldWonderClass(pkeBuildingInfo->GetBuildingClassInfo()) && !::isNationalWonderClass(pkeBuildingInfo->GetBuildingClassInfo()))
			continue;

		const CvBuildingClassInfo& kBuildingClassInfo = pkeBuildingInfo->GetBuildingClassInfo();

		bool bCivUnique = kBuildingClassInfo.getDefaultBuildingIndex() != eBuilding;

		bool bCapitalCanConstruct = false;
		int iLoopCity;
		CvCity* pLoopCity = NULL;
		// Look at all of our Cities to see which is the best.
		for (pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity))
		{
			bool bAlreadyStarted = pLoopCity->GetCityBuildings()->GetBuildingProduction(eBuilding) > 0;

			//We've already started? We can bail out here, then.
			if (pLoopCity->getProductionBuilding() == eBuilding || bAlreadyStarted)
			{
				pBestCity = pLoopCity;
				break;
			}

			//is this a unique wonder that we can't build? Ignore it.
			if (bCivUnique && !getCivilizationInfo().isCivilizationBuildingOverridden((BuildingClassTypes)pkeBuildingInfo->GetBuildingClassType()))
				continue;

			if (!pLoopCity->canConstruct(eBuilding))
			{
				pLoopCity->SetBestForWonder((BuildingClassTypes)pkeBuildingInfo->GetBuildingClassType(), false);
				continue;
			}
			else if (pLoopCity->isCapital())
				bCapitalCanConstruct = true;

			//stats to decide whether to disband a unit
			int iWaterPriority = pLoopCity->GetTradePrioritySea();
			int iLandPriority = pLoopCity->GetTradePriorityLand();

			int iWaterRoutes = -1;
			int iLandRoutes = -1;

			if (iWaterPriority >= 0)
			{
				//0 is best, and 1+ = 100% less valuable than top. More routes from better cities, please!
				iWaterRoutes = 1000 - min(1000, (iWaterPriority * 50));
			}
			if (iLandPriority >= 0)
			{
				iLandRoutes = 1000 - min(1000, (iLandPriority * 50));
			}

			//Best? Do it!
			int iValue = pLoopCity->GetCityStrategyAI()->GetBuildingProductionAI()->CheckBuildingBuildSanity(eBuilding, 1000, iLandRoutes, iWaterRoutes, iGPT, false, true);

			iValue += (-50 * pLoopCity->getProductionTurnsLeft(eBuilding, 0));

			if (iValue > iBestValue)
			{
				iBestValue = iValue;
				pBestCity = pLoopCity;
			}
		}

		//default to capital if no other option (for world wonders only if we have a chance)
		if (!pBestCity && bCapitalCanConstruct && (bIsCapitalCompetitive || ::isNationalWonderClass(pkeBuildingInfo->GetBuildingClassInfo())))
			pBestCity = getCapitalCity();

		if (pBestCity)
		{
			pBestCity->SetBestForWonder((BuildingClassTypes)pkeBuildingInfo->GetBuildingClassType(), true);

			int iLoopCity;
			CvCity* pLoopCity = NULL;

			// Remove from all other cities.
			for (pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity))
			{
				if (pLoopCity != pBestCity)
					pLoopCity->SetBestForWonder((BuildingClassTypes)pkeBuildingInfo->GetBuildingClassType(), false);
			}

			if ((GC.getLogging() && GC.getAILogging()))
			{
				CvString playerName;
				FILogFile* pLog;
				CvString strBaseString;
				CvString strOutBuf;
				playerName = getCivilizationShortDescription();
				pLog = LOGFILEMGR.GetLog(CUSTOMLOGDEBUG, FILogFile::kDontTimeStamp);
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				strBaseString += playerName + ", ";
				strOutBuf.Format("%s is the best city to construct %s", pBestCity->getName().GetCString(), pkeBuildingInfo->GetDescription());
				strBaseString += strOutBuf;
				pLog->Msg(strBaseString);
			}
		}
	}
}

//to avoid hardcoding any hammers per pop values, we look at hammers per pop for all other capitals
//however, we don't look at the total hammers, because that would be cheating :)
bool CvPlayer::isCapitalCompetitive()
{
	if (!getCapitalCity())
		return false;

	int iSum = 0;
	int iCount = 0;
	for (int iPlayer = 0; iPlayer < MAX_MAJOR_CIVS; iPlayer++)
	{
		CvPlayer& kPlayer = GET_PLAYER( (PlayerTypes)iPlayer );
		if (!kPlayer.isAlive() || !kPlayer.getCapitalCity())
			continue;

		if (iPlayer == GetID())
			continue;

		iSum += kPlayer.getCapitalCity()->getYieldRateTimes100(YIELD_PRODUCTION,false) / kPlayer.getCapitalCity()->getPopulation();
		iCount++;
	}

	int iThreshold = iSum / max(1, iCount);
	//venice exception
	if (GetPlayerTraits()->IsNoAnnexing())
		iThreshold -= iThreshold / 3;

	return (getCapitalCity()->getYieldRateTimes100(YIELD_PRODUCTION,false) / getCapitalCity()->getPopulation()) >= iThreshold;
}

#endif
//	--------------------------------------------------------------------------------
/// Special ability where city-states gift great people
void CvPlayer::DoAdoptedGreatPersonCityStatePolicy()
{
	// Loop through all minors and if they're allies, seed the GP counter
	PlayerTypes eMinor;
	for(int iPlayerLoop = MAX_MAJOR_CIVS; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		eMinor = (PlayerTypes) iPlayerLoop;

		if(GET_PLAYER(eMinor).isEverAlive())
		{
			if(GET_PLAYER(eMinor).GetMinorCivAI()->GetAlly() == GetID())
			{
				DoSeedGreatPeopleSpawnCounter();

				break;
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Special ability where city-states gift great people
bool CvPlayer::IsAlliesGreatPersonBiasApplied() const
{
	return m_bAlliesGreatPersonBiasApplied;
}

//	--------------------------------------------------------------------------------
/// Special ability where city-states gift great people
void CvPlayer::SetAlliesGreatPersonBiasApplied(bool bValue)
{
	if(m_bAlliesGreatPersonBiasApplied != bValue)
	{
		m_bAlliesGreatPersonBiasApplied = bValue;
	}
}

//	--------------------------------------------------------------------------------
/// Has this player picked up a Religion yet
bool CvPlayer::IsHasAdoptedStateReligion() const
{
	return m_bHasAdoptedStateReligion;
}

//	--------------------------------------------------------------------------------
/// Sets this player picked up a Religion yet
void CvPlayer::SetHasAdoptedStateReligion(bool bValue)
{
	if(m_bHasAdoptedStateReligion != bValue)
	{
		m_bHasAdoptedStateReligion = bValue;
	}
}

//	--------------------------------------------------------------------------------
/// Number of Cities in the empire with our State Religion
int CvPlayer::GetNumCitiesWithStateReligion()
{
	int iNumCitiesWithStateReligion = 0;

	int iLoopCity;
	CvCity* pLoopCity = NULL;
	// Look at all of our Cities to see if they have our Religion
	for(pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity))
	{
		if(pLoopCity->GetPlayersReligion() == GetID())
		{
			iNumCitiesWithStateReligion++;
		}
	}

	return iNumCitiesWithStateReligion;
}

//	--------------------------------------------------------------------------------
/// Where was this player's Religion adopted
CvCity* CvPlayer::GetHolyCity()
{
	return getCity(m_iHolyCityID);
}

//	--------------------------------------------------------------------------------
/// Sets where this player's Religion adopted
void CvPlayer::SetHolyCity(int iCityID)
{
	// This should only be set once under normal circumstances
	CvAssert(m_iHolyCityID == -1);

	m_iHolyCityID = iCityID;
}

//	--------------------------------------------------------------------------------
PromotionTypes CvPlayer::GetEmbarkationPromotion() const
{
	if(GET_TEAM(getTeam()).canDefensiveEmbark())
	{
		return (PromotionTypes)GC.getPROMOTION_DEFENSIVE_EMBARKATION();
	}

	if(m_pTraits)
	{
		if(m_pTraits->IsEmbarkedAllWater())
		{
			return (PromotionTypes)GC.getPROMOTION_ALLWATER_EMBARKATION();
		}
	}

	return (PromotionTypes)GC.getPROMOTION_EMBARKATION();
}

#if defined(MOD_PROMOTIONS_DEEP_WATER_EMBARKATION)
//	--------------------------------------------------------------------------------
PromotionTypes CvPlayer::GetDeepWaterEmbarkationPromotion() const
{
	if (MOD_PROMOTIONS_DEEP_WATER_EMBARKATION) {
		if(GET_TEAM(getTeam()).canDefensiveEmbark())
		{
			return (PromotionTypes)GC.getPROMOTION_DEFENSIVE_DEEPWATER_EMBARKATION();
		}

		return (PromotionTypes)GC.getPROMOTION_DEEPWATER_EMBARKATION();
	} else {
		return GetEmbarkationPromotion();
	}
}
#endif

//	--------------------------------------------------------------------------------
/// Provide Notification about someone adopting a new Religon
void CvPlayer::DoAnnounceReligionAdoption()
{
	CvCity* pHolyCity = GetHolyCity();

	for(int iI = 0; iI < MAX_PLAYERS; iI++)
	{
		CvPlayerAI& thisPlayer = GET_PLAYER((PlayerTypes)iI);
		if(thisPlayer.isHuman() && thisPlayer.isAlive() && thisPlayer.GetNotifications())
		{
			int iX = -1;
			int iY = -1;

			Localization::String localizedText;

			// Active Player
			if(GC.getGame().getActivePlayer() == GetID())
			{
				iX = pHolyCity->getX();
				iY = pHolyCity->getY();
				localizedText = Localization::Lookup("TXT_KEY_MISC_RELIGION_ADOPTED_YOU");
				localizedText << pHolyCity->getNameKey() << GetStateReligionKey();
			}
			// Met Player
			else if(GET_TEAM(GC.getGame().getActiveTeam()).isHasMet(thisPlayer.getTeam()))
			{
				localizedText = Localization::Lookup("TXT_KEY_MISC_RELIGION_ADOPTED_ANOTHER_PLAYER");
				localizedText << GET_PLAYER(pHolyCity->getOwner()).getNameKey() << GetStateReligionKey();

				// We've seen this player's City
				if(pHolyCity->isRevealed(thisPlayer.getTeam(), false))
				{
					iX = pHolyCity->getX();
					iY = pHolyCity->getY();
				}
			}
			// Unmet Player
			else
			{
				localizedText = Localization::Lookup("TXT_KEY_MISC_RELIGION_ADOPTED_UNKNOWN");
			}

#if defined(MOD_API_EXTENSIONS)
			thisPlayer.GetNotifications()->Add(NOTIFICATION_RELIGION_RACE, localizedText.toUTF8(), localizedText.toUTF8(), iX, iY, GetReligions()->GetReligionCreatedByPlayer(), -1);
#else
			thisPlayer.GetNotifications()->Add(NOTIFICATION_RELIGION_RACE, localizedText.toUTF8(), localizedText.toUTF8(), iX, iY, -1);
#endif
		}
	}
}

bool CvPlayer::IsAllowedToTradeWith(PlayerTypes eOtherPlayer)
{
	if (GC.getGame().GetGameLeagues()->IsTradeEmbargoed(GetID(), eOtherPlayer) && eOtherPlayer != m_eID)
	{
		return false;
	}

#if defined(MOD_DIPLOMACY_CITYSTATES_RESOLUTIONS)
	if (MOD_DIPLOMACY_CITYSTATES_RESOLUTIONS && GC.getGame().GetGameLeagues()->IsIdeologyEmbargoed(GetID(), eOtherPlayer) && eOtherPlayer != m_eID)
	{
		return false;
	}
#endif

#if defined(MOD_BALANCE_CORE)
	if (eOtherPlayer != m_eID && GET_PLAYER(eOtherPlayer).isMajorCiv() && GET_PLAYER(eOtherPlayer).GetPlayerTraits()->IsNoOpenTrade())
	{
		if (!GC.getGame().GetGameTrade()->IsPlayerConnectedToPlayer(eOtherPlayer, GetID(), true))
			return false;
	}
	if (IsOnlyTradeSameIdeology() && GET_PLAYER(eOtherPlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE)
	{
		if (GET_PLAYER(eOtherPlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != GetPlayerPolicies()->GetLateGamePolicyTree())
		{
			return false;
		}
	}
#endif
	return true;
}

bool CvPlayer::CanCrossOcean() const
{
	return GET_TEAM(getTeam()).canEmbarkAllWaterPassage() || GetPlayerTraits()->IsEmbarkedAllWater();
}
bool CvPlayer::CanCrossMountain() const
{
	return GetPlayerTraits()->IsAbleToCrossMountainsWithGreatGeneral() || GetPlayerTraits()->IsMountainPass();
}
bool CvPlayer::CanCrossIce() const
{
	return GetPlayerTraits()->IsAbleToCrossIce();
}

//////////////////////////////////////////////////////////////////////////
// Tutorial Stuff...
//////////////////////////////////////////////////////////////////////////

//	--------------------------------------------------------------------------------
bool CvPlayer::GetEverPoppedGoody()
{
	return m_bEverPoppedGoody;
}

//	--------------------------------------------------------------------------------
CvPlot* CvPlayer::GetClosestGoodyPlot(bool bStopAfterFindingFirst)
{
#if defined(MOD_CORE_ALTERNATIVE_EXPLORE_SCORE)
	CvPlot* pResultPlot = NULL;
	int iShortestPath = INT_MAX;

	// cycle through goodies
	for(int i = 0; i < GC.getMap().numPlots(); i++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(i);
#else
	FFastVector<int> aiGoodyPlots = GetEconomicAI()->GetGoodyHutPlots();

	CvPlot* pResultPlot = NULL;
	int iShortestPath = INT_MAX;

	// cycle through goodies
	for(uint uiGoodyIndex = 0; uiGoodyIndex < aiGoodyPlots.size(); uiGoodyIndex++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndex(aiGoodyPlots[uiGoodyIndex]);
#endif
		if(!pPlot || !pPlot->isGoody(getTeam()))
		{
			continue;
		}

		// cycle through units
		int iUnitLoop;
		CvUnit* pLoopUnit = NULL;

		// Setup m_units
		for(pLoopUnit = firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iUnitLoop))
		{
			if(!pLoopUnit)
			{
				continue;
			}

			if(pPlot->getArea() != pLoopUnit->getArea() && !pLoopUnit->CanEverEmbark())
			{
				continue;
			}

			int iReturnValue = INT_MAX;
			bool bResult = pLoopUnit->GeneratePath(pPlot, CvUnit::MOVEFLAG_IGNORE_DANGER, iShortestPath, &iReturnValue);

			if(bResult)
			{
				if(iReturnValue < iShortestPath)
				{
					pResultPlot = pPlot;
					iShortestPath = iReturnValue;
				}

				if(bStopAfterFindingFirst)
				{
					return pPlot;
				}
			}
		}
	}

	return pResultPlot;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::GetPlotHasOrder(CvPlot* pPlot)
{
	if(!pPlot)
	{
		return false;
	}

	int iLoopUnit;
	for(CvUnit* pLoopUnit = firstUnit(&iLoopUnit); pLoopUnit; pLoopUnit = nextUnit(&iLoopUnit))
	{
		CvPlot* pMissionPlot = pLoopUnit->GetMissionAIPlot();
		if(NULL != pMissionPlot && pMissionPlot->getX() == pPlot->getX() && pMissionPlot->getY() == pPlot->getY())
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::GetAnyUnitHasOrderToGoody()
{
#if defined(MOD_CORE_ALTERNATIVE_EXPLORE_SCORE)
	// cycle through goodies
	for(int i = 0; i < GC.getMap().numPlots(); i++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(i);
#else

	FFastVector<int> aiGoodyPlots = GetEconomicAI()->GetGoodyHutPlots();

	// cycle through goodies
	for(uint uiGoodyIndex = 0; uiGoodyIndex < aiGoodyPlots.size(); uiGoodyIndex++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndex(aiGoodyPlots[uiGoodyIndex]);
#endif
		if(!pPlot)
		{
			continue;
		}

		if(!pPlot->isGoody(getTeam()))
		{
			continue;
		}

		if(GetPlotHasOrder(pPlot))
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::GetEverTrainedBuilder()
{
	return m_bEverTrainedBuilder;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumFreeTechs() const
{
	return m_iFreeTechCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumFreeTechs(int iValue)
{
	m_iFreeTechCount = iValue;
	if(GetID() == GC.getGame().getActivePlayer())
	{
		GC.GetEngineUserInterface()->setDirty(ResearchButtons_DIRTY_BIT, true);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetMedianTechPercentage() const
{
	return m_iMedianTechPercentage;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMedianTechPercentage(int iValue)
{
	m_iMedianTechPercentage += iValue;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumFreePolicies() const
{
	return m_iNumFreePolicies;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumFreePolicies(int iValue)
{
	// Increase count of free Policies we've ever had
	int iDifference = iValue - m_iNumFreePolicies;
	if(iDifference > 0)
	{
		ChangeNumFreePoliciesEver(iDifference);
	}

	m_iNumFreePolicies = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumFreePolicies(int iChange)
{
	SetNumFreePolicies(GetNumFreePolicies() + iChange);

	if(iChange > 0 && getNumCities() > 0)
	{
		CvNotifications* pNotifications = GetNotifications();
		if(pNotifications)
		{
			CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_FREE_POLICY");
			CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_FREE_POLICY_SUMMARY");
			pNotifications->Add(NOTIFICATION_FREE_POLICY, strBuffer, strSummary, -1, -1, -1);
		}

	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumFreeTenets() const
{
	return m_iNumFreeTenets;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumFreeTenets(int iValue, bool bCountAsFreePolicies)
{
	// Increase count of free Policies we've ever had
	int iDifference = iValue - m_iNumFreeTenets;
	if (bCountAsFreePolicies && iDifference > 0)
	{
		ChangeNumFreePoliciesEver(iDifference);
	}

	m_iNumFreeTenets = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumFreeTenets(int iChange, bool bCountAsFreePolicies)
{
	SetNumFreeTenets(GetNumFreeTenets() + iChange, bCountAsFreePolicies);

	if(iChange > 0 && getNumCities() > 0)
	{
		CvNotifications* pNotifications = GetNotifications();
		if(pNotifications)
		{
			CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_FREE_POLICY");
			CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_FREE_POLICY_SUMMARY");
			pNotifications->Add(NOTIFICATION_FREE_POLICY, strBuffer, strSummary, -1, -1, -1);
		}

	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumFreeGreatPeople() const
{
	return m_iNumFreeGreatPeople;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumFreeGreatPeople(int iValue)
{
	m_iNumFreeGreatPeople = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumFreeGreatPeople(int iChange)
{
	m_iNumFreeGreatPeople = GetNumFreeGreatPeople() + iChange;
	if(iChange > 0)
	{
		if(isHuman())
		{
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				CvString strBuffer = GetLocalizedText("TXT_KEY_CHOOSE_FREE_GREAT_PERSON");
				CvString strSummary = GetLocalizedText("TXT_KEY_CHOOSE_FREE_GREAT_PERSON_TT");
				pNotifications->Add(NOTIFICATION_FREE_GREAT_PERSON, strSummary.c_str(), strBuffer.c_str(), -1, -1, -1);
			}
		}
		else
		{
			for(int iI = 0; iI < iChange; iI++)
			{
				AI_chooseFreeGreatPerson();
			}
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumMayaBoosts() const
{
	return m_iNumMayaBoosts;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumMayaBoosts(int iValue)
{
	m_iNumMayaBoosts = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumMayaBoosts(int iChange)
{
	m_iNumMayaBoosts = GetNumMayaBoosts() + iChange;
	if(iChange > 0)
	{
		if(isHuman())
		{
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_MAYA_LONG_COUNT");
				CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_MAYA_LONG_COUNT_TT");
				pNotifications->Add(NOTIFICATION_MAYA_LONG_COUNT, strSummary.c_str(), strBuffer.c_str(), -1, -1, -1);
			}
		}
		else
		{
			for(int iI = 0; iI < iChange; iI++)
			{
				GetPlayerTraits()->ChooseMayaBoost();
			}
		}
	}
}


/// Accessor: Get extra times to spread religion for missionaries from this city
int CvPlayer::GetMissionaryExtraStrength() const
{
	return m_iMissionaryExtraStrength;
}

/// Accessor: Change extra times to spread religion for missionaries from this city
void CvPlayer::ChangeMissionaryExtraStrength(int iChange)
{
	if (iChange != 0)
	{
		m_iMissionaryExtraStrength = (m_iMissionaryExtraStrength + iChange);
		CvAssert(m_iMissionaryExtraStrength >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumFaithGreatPeople() const
{
	return m_iNumFaithGreatPeople;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumFaithGreatPeople(int iValue)
{
	m_iNumFaithGreatPeople = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumFaithGreatPeople(int iChange)
{
	m_iNumFaithGreatPeople = GetNumFaithGreatPeople() + iChange;
	if(iChange > 0)
	{
		if(isHuman())
		{
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_FAITH_GREAT_PERSON");
				CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_FAITH_GREAT_PERSON_TT");
				pNotifications->Add(NOTIFICATION_FAITH_GREAT_PERSON, strSummary.c_str(), strBuffer.c_str(), -1, -1, -1);
			}
		}
		else
		{
			for(int iI = 0; iI < iChange; iI++)
			{
				AI_chooseFreeGreatPerson();
			}
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetNumArchaeologyChoices() const
{
	return m_iNumArchaeologyChoices;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumArchaeologyChoices(int iValue)
{
	m_iNumArchaeologyChoices = iValue;
}

//	--------------------------------------------------------------------------------
FaithPurchaseTypes CvPlayer::GetFaithPurchaseType() const
{
	return m_eFaithPurchaseType;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetFaithPurchaseType(FaithPurchaseTypes eType)
{
	m_eFaithPurchaseType = eType;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetFaithPurchaseIndex() const
{
	return m_iFaithPurchaseIndex;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetFaithPurchaseIndex(int iIndex)
{
	m_iFaithPurchaseIndex = iIndex;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumFreePoliciesEver() const
{
	return m_iNumFreePoliciesEver;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumFreePoliciesEver(int iValue)
{
	m_iNumFreePoliciesEver = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumFreePoliciesEver(int iChange)
{
	SetNumFreePoliciesEver(GetNumFreePoliciesEver() + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetLastSliceMoved() const
{
	return m_iLastSliceMoved;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetLastSliceMoved(int iValue)
{
	m_iLastSliceMoved = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetEverConqueredBy(PlayerTypes ePlayer, bool bValue)
{
	if(bValue)
	{
		m_bfEverConqueredBy.SetBit(ePlayer);
	}
	else
	{
		m_bfEverConqueredBy.ClearBit(ePlayer);
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsEverConqueredBy(PlayerTypes ePlayer)
{
	return m_bfEverConqueredBy.GetBit(ePlayer);
}

//	------------------------------------------------------------------------------------------------
const FAutoArchive& CvPlayer::getSyncArchive() const
{
	return m_syncArchive;
}

//	--------------------------------------------------------------------------------
FAutoArchive& CvPlayer::getSyncArchive()
{
	return m_syncArchive;
}

//	-----------------------------------------------------------------------------------------------
bool CvPlayer::isLocalPlayer() const
{
	return (GC.getGame().getActivePlayer() == GetID());
}

//	-----------------------------------------------------------------------------------------------
void CvPlayer::disconnected()
{
	bool isMultiplayer = GC.getGame().isGameMultiPlayer();
	if(isMultiplayer && isHuman() && !isLocalPlayer())
	{
			//log message for debugging the occasional lack of disconnect notification when Steam p2p connections timeout. - bolson 1/10/13
			FILogFile* logFile = LOGFILEMGR.GetLog("net_message_debug.log", 0);
			if(logFile)
			{
				logFile->DebugMsg("Attempted to post notification for player disconnect event.  Player(%i)", GetID());
			}

			CvNotifications* pNotifications = GET_PLAYER(GC.getGame().getActivePlayer()).GetNotifications();
			if(pNotifications){
				if(gDLL->IsPlayerKicked(GetID())){
					Localization::String kickedMsg = Localization::Lookup("TXT_KEY_PLAYER_KICKED");
					kickedMsg << getNameKey();
					pNotifications->Add(NOTIFICATION_PLAYER_KICKED, kickedMsg.toUTF8(), kickedMsg.toUTF8(), -1, -1, GetID());
				}
				else{
					Localization::String disconnectString = Localization::Lookup("TXT_KEY_PLAYER_DISCONNECTED");
					disconnectString << getNameKey();

					if(CvPreGame::isPitBoss()){
						disconnectString = Localization::Lookup("TXT_KEY_PLAYER_DISCONNECTED_PITBOSS");
						disconnectString << getNameKey();	
					}

					pNotifications->Add(NOTIFICATION_PLAYER_DISCONNECTED, disconnectString.toUTF8(), disconnectString.toUTF8(), -1, -1, GetID());
				}
			}

		if(!isObserver() && (!CvPreGame::isPitBoss() || gDLL->IsPlayerKicked(GetID())))
		{
			// JAR : First pass, automatically fall back to CPU so the
			// game can continue. Todo : add popup on host asking whether
			// the AI should take over or everyone should wait for the
			// player to reconnect
			CvPreGame::setSlotStatus(GetID(), SS_COMPUTER);
			CvPreGame::VerifyHandicap(GetID());	//Changing the handicap because we're switching to AI

			// Load leaderhead for this new AI player
			gDLL->NotifySpecificAILeaderInGame(GetID());
			
			if(!GC.getGame().isOption(GAMEOPTION_DYNAMIC_TURNS) && GC.getGame().isOption(GAMEOPTION_SIMULTANEOUS_TURNS))
			{//When in fully simultaneous turn mode, having a player disconnect might trigger the automove phase for all human players.
				checkRunAutoMovesForEveryone();
			}
		}
	}
}
//	-----------------------------------------------------------------------------------------------
void CvPlayer::reconnected()
{
	//Preserve observer status for the connecting human player's slot.
	if(CvPreGame::slotStatus(GetID()) != SS_OBSERVER){
		CvPreGame::setSlotStatus(GetID(), SS_TAKEN);
	}

	CvPreGame::VerifyHandicap(GetID()); //verify the handicap because we might have replaced an ai.

	CvGame& kGame = GC.getGame();
	bool isMultiplayer = kGame.isGameMultiPlayer();

	if(isMultiplayer && !isLocalPlayer())
	{
		FAutoArchive& archive = getSyncArchive();
		archive.clearDelta();

		Localization::String connectString = Localization::Lookup("TXT_KEY_PLAYER_CONNECTING");
		connectString << getNameKey();

		CvNotifications* pNotifications = GET_PLAYER(kGame.getActivePlayer()).GetNotifications();
		if(pNotifications)
		{
			pNotifications->Add(NOTIFICATION_PLAYER_CONNECTING, connectString.toUTF8(), connectString.toUTF8(), -1, -1, GetID());
		}
	}
}
//	-----------------------------------------------------------------------------------------------
bool CvPlayer::hasBusyUnitUpdatesRemaining() const
{
	return m_endTurnBusyUnitUpdatesLeft > 0;
}

//	-----------------------------------------------------------------------------------------------
void CvPlayer::setBusyUnitUpdatesRemaining(int iUpdateCount)
{
	m_endTurnBusyUnitUpdatesLeft = iUpdateCount;
}

//	-----------------------------------------------------------------------------------------------
const char* const CvPlayer::getNickName() const
{
	return CvPreGame::nicknameDisplayed(GetID()).c_str();
}

//	-----------------------------------------------------------------------------------------------
bool CvPlayer::hasUnitsThatNeedAIUpdate() const
{
	const CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(!pLoopUnit->TurnProcessed() &&
		        (pLoopUnit->IsAutomated() &&
		         pLoopUnit->AI_getUnitAIType() != UNITAI_UNKNOWN &&
		         pLoopUnit->canMove()))
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
std::string CvPlayer::debugDump(const FAutoVariableBase&) const
{
	std::string result = "Game Turn : ";
	char gameTurnBuffer[8] = {0};
	int gameTurn = GC.getGame().getGameTurn();
	sprintf_s(gameTurnBuffer, "%d\0", gameTurn);
	result += gameTurnBuffer;
	return result;
}

//	--------------------------------------------------------------------------------
std::string CvPlayer::stackTraceRemark(const FAutoVariableBase& var) const
{
	std::string result = debugDump(var);
	if(&var == &m_aOptions)
	{//detail output for player options array.
		result += "\nPlayer Options:";
		for (PlayerOptionsVector::const_iterator itr = m_aOptions.begin(); itr != m_aOptions.end(); ++itr )
		{
			CvString curOptionsStr;
			curOptionsStr.Format("\n%u, %d", itr->first, itr->second);
			result += curOptionsStr;
		}
		result += "\n";
	}
	return result;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::hasTurnTimerExpired()
{//Indicates if this player's turn time has elapsed.
	return GC.getGame().hasTurnTimerExpired(GetID());
}

//	--------------------------------------------------------------------------------
void CvPlayer::checkArmySizeAchievement()
{
#if !defined(NO_ACHIEVEMENTS)
	int numUnits = 0;
	int32 nLargestArmy = 0;
	int iI;

	for(iI = 0; iI < NUM_UNITAI_TYPES; iI++)
	{
		if((UnitAITypes)iI == UNITAI_ARTIST ||(UnitAITypes)iI == UNITAI_ENGINEER || (UnitAITypes)iI == UNITAI_UNKNOWN ||
		        (UnitAITypes)iI == UNITAI_GENERAL || (UnitAITypes)iI == UNITAI_SETTLE || (UnitAITypes)iI == UNITAI_WORKER ||
		        (UnitAITypes)iI == UNITAI_SCIENTIST || (UnitAITypes)iI == UNITAI_MERCHANT || (UnitAITypes)iI == UNITAI_WORKER_SEA ||
		        (UnitAITypes)iI == UNITAI_SPACESHIP_PART || (UnitAITypes)iI == UNITAI_TREASURE || (UnitAITypes)iI == UNITAI_PROPHET ||
		        (UnitAITypes)iI == UNITAI_MISSIONARY || (UnitAITypes)iI == UNITAI_INQUISITOR || (UnitAITypes)iI == UNITAI_ADMIRAL ||
#if defined(MOD_DIPLOMACY_CITYSTATES) 
				(MOD_DIPLOMACY_CITYSTATES && ((UnitAITypes)iI == UNITAI_DIPLOMAT || (UnitAITypes)iI == UNITAI_MESSENGER)) ||
#endif
				(UnitAITypes)iI == UNITAI_WRITER || (UnitAITypes)iI == UNITAI_MUSICIAN)
		{
			continue;
		}
		else
		{
			numUnits += GetNumUnitsWithUnitAI((UnitAITypes)iI, false, true);
		}
	}
	gDLL->GetSteamStat(ESTEAMSTAT_STANDINGARMY, &nLargestArmy);

	if(nLargestArmy < numUnits)
	{
		gDLL->SetSteamStat(ESTEAMSTAT_STANDINGARMY, numUnits);

		CvAchievementUnlocker::Check_PSG();
	}
#endif
}

//	--------------------------------------------------------------------------------
void CvPlayer::checkInitialTurnAIProcessed()
{
	int turn = GC.getGame().getGameTurn();
	if(m_lastGameTurnInitialAIProcessed != turn)
	{
		//Note: Players that are not turn active at the beginning of the game turn will 
		//process their AI when they are turn active.  However, they should still 
		//act like their initial AI has been processed.
		if(!isTurnActive() || !hasUnitsThatNeedAIUpdate())
		{
			m_lastGameTurnInitialAIProcessed = turn;
			if(GC.getGame().getActivePlayer() == GetID())
				gDLL->sendPlayerInitialAIProcessed();
		}
	}
}

//------------------------------------------------------------------------------
void CvPlayer::GatherPerTurnReplayStats(int iGameTurn)
{
	AI_PERF_FORMAT("AI-perf.csv", ("CvPlayer::GatherPerTurnReplayStats, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), getCivilizationShortDescription()) );
#if !defined(FINAL_RELEASE)
	cvStopWatch watch("Replay Stat Recording");
#endif
	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());

		bool bResult;
		LuaSupport::CallHook(pkScriptSystem, "GatherPerTurnReplayStats", args.get(), bResult);
	}

	//Only record the following statistics if the player is alive.
	if(isAlive())
	{
		//	Production Per Turn
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_PRODUCTIONPERTURN"), iGameTurn, calculateTotalYield(YIELD_PRODUCTION));
		// 	Gold
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_TOTALGOLD"), iGameTurn, GetTreasury()->GetGold());
		// 	Gold per Turn
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_GOLDPERTURN"), iGameTurn, calculateTotalYield(YIELD_GOLD));
		// 	Num Cities
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_CITYCOUNT"), iGameTurn, getNumCities());

		//	Number of Techs known
		CvTeam& team = GET_TEAM(getTeam());
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_TECHSKNOWN"), iGameTurn, team.GetTeamTechs()->GetNumTechsKnown());

		// 	Science per Turn
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_SCIENCEPERTURN"), iGameTurn, calculateTotalYield(YIELD_SCIENCE));
		// antonjs: This data is also used to calculate Great Scientist and Research Agreement beaker bonuses. If replay data changes
		// or is disabled, CvPlayer::GetScienceYieldFromPreviousTurns must also change.

		// 	Total Culture
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_TOTALCULTURE"), iGameTurn, getJONSCulture());

		// 	Culture per turn
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_CULTUREPERTURN"), iGameTurn, GetTotalJONSCulturePerTurn());
		
#if defined(MOD_BALANCE_CORE)
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_TOURISMPERTURN"), iGameTurn, GetCulture()->GetTourism() / 100);
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_GAPPERTURN"), iGameTurn, GetGoldenAgePointsFromEmpire() + GetHappinessForGAP());
#endif

		// 	Happiness
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_EXCESSHAPINESS"), iGameTurn, GetExcessHappiness());
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_HAPPINESS"), iGameTurn, GetHappiness());
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_UNHAPPINESS"), iGameTurn, GetUnhappiness());

		// 	Golden Age turns
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_GOLDENAGETURNS"), iGameTurn, getGoldenAgeTurns());

		// 	Population
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_POPULATION"), iGameTurn, getTotalPopulation());

		// 	Food Per Turn
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_FOODPERTURN"), iGameTurn, calculateTotalYield(YIELD_FOOD));

		//	Total Land
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_TOTALLAND"), iGameTurn, getTotalLand());

		CvTreasury* pkTreasury = GetTreasury();
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_GPTCITYCONNECTIONS"), iGameTurn, pkTreasury->GetCityConnectionGold());
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_GPTINTERNATIONALTRADE"), iGameTurn, pkTreasury->GetGoldPerTurnFromTradeRoutes());
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_GPTDEALS"), iGameTurn, pkTreasury->GetGoldPerTurnFromDiplomacy());
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_UNITMAINTENANCE"), iGameTurn, pkTreasury->GetExpensePerTurnUnitMaintenance());
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_BUILDINGMAINTENANCE"), iGameTurn, pkTreasury->GetBuildingGoldMaintenance());
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_IMPROVEMENTMAINTENANCE"), iGameTurn, pkTreasury->GetImprovementGoldMaintenance());
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_NUMBEROFPOLICIES"), iGameTurn, GetPlayerPolicies()->GetNumPoliciesOwned());

		// workers
		int iWorkerCount = 0;
		CvUnit* pLoopUnit;
		int iLoopUnit;
		for(pLoopUnit = firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoopUnit))
		{
			if(pLoopUnit->AI_getUnitAIType() == UNITAI_WORKER)
			{
				iWorkerCount++;
			}
		}
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_NUMBEROFWORKERS"), iGameTurn, iWorkerCount);

		// worked tiles
		int iWorkedTiles = 0;
		int iImprovedTiles = 0;
		// go through all the plots the player has under their control
		for (PlotIndexContainer::const_iterator it = m_aiPlots.begin(); it != m_aiPlots.end(); ++it)
		{
			CvPlot* pPlot = GC.getMap().plotByIndex(*it);
			if (!pPlot)
			{
				continue;
			}

			// plot has city in it, don't count
			if(pPlot->getPlotCity())
			{
				continue;
			}

			if(pPlot->isBeingWorked())
			{
				iWorkedTiles++;
			}

			if(pPlot->getImprovementType() != NO_IMPROVEMENT)
			{
				iImprovedTiles++;
			}
		}

		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_IMPROVEDTILES"), iGameTurn, iImprovedTiles);
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_WORKEDTILES"), iGameTurn, iWorkedTiles);
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_NUMBEROFWORKERS"), iGameTurn, iWorkerCount);


		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_MILITARYMIGHT"), iGameTurn, GetMilitaryMight());
	}
}

//	---------------------------------------------------------------------------
//	If the active player is in the end-turn processing phase, attempt to cancel that.
//	This should be called when something occurs that could happen during the end-turn
//	that may need the players attention this turn.
//	Ex.  A player's unit auto-moves into a goody hut plot.
bool CancelActivePlayerEndTurn()
{
	CvPlayer& kActivePlayer = GET_PLAYER(GC.getGame().getActivePlayer());

	if(kActivePlayer.isLocalPlayer() && kActivePlayer.isEndTurn())
	{
		if (gDLL->sendTurnUnready())	// This will see if we can actually do the unready, sometimes you can't in MP games.
		{
			kActivePlayer.setEndTurn(false);
			return true;
		}
		return false;
	}
	return true;
}

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
//	--------------------------------------------------------------------------------
///	Get the amount of Happiness we're getting from our vassals
int CvPlayer::GetHappinessFromVassals() const
{
	int iHappiness = 0;

	PlayerTypes ePlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		ePlayer = (PlayerTypes) iPlayerLoop;
		if(GetID() != ePlayer && GET_PLAYER(ePlayer).isAlive())
		{
			iHappiness += GetHappinessFromVassal(ePlayer);
		}
	}

	return max(0, iHappiness);
}
//	--------------------------------------------------------------------------------
/// Happiness from a Vassal
int CvPlayer::GetHappinessFromVassal(PlayerTypes ePlayer) const
{
	// Do not evaluate dead players (prevents crash)
	if (!GET_PLAYER(ePlayer).isAlive()) return 0;
	
	int iAmount = 0;
	if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassal(getTeam()))
	{
		if (MOD_BALANCE_CORE_HAPPINESS)
		{
			iAmount += 10 * (GC.getVASSAL_HAPPINESS_PERCENT() + GetVassalCSBonusModifier());
			iAmount /= 100;
		}
		else
		{
			iAmount += GET_PLAYER(ePlayer).GetExcessHappiness() * (GC.getVASSAL_HAPPINESS_PERCENT() + GetVassalCSBonusModifier());
			iAmount /= 100;
		}
	}
	return iAmount;
}
//	--------------------------------------------------------------------------------
/// Special bonus for having a vassal
int CvPlayer::GetYieldPerTurnFromVassals(YieldTypes eYield) const
{
	int iFreeYield = 0;
	int iYield = 0;
	PlayerTypes ePlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		ePlayer = (PlayerTypes) iPlayerLoop;
		
		// ePlayer vassal of ours?
		if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassal(getTeam()))
		{
			iFreeYield = 0;
			switch(eYield)
			{
				// We now collect gold from taxes
				case YIELD_GOLD:
					//iFreeYield = GET_PLAYER(ePlayer).calculateGoldRate();
					//iFreeYield *= /*33*/GC.getVASSALAGE_FREE_YIELD_FROM_VASSAL_PERCENT();
					//iFreeYield /= 100;
					break;

				case YIELD_CULTURE:
					if (eYield == YIELD_CULTURE && (GC.getGame().isOption(GAMEOPTION_NO_POLICIES)))
					{
						return 0;
					}
					iFreeYield = GET_PLAYER(ePlayer).GetTotalJONSCulturePerTurn();
					iFreeYield *= (/*33*/GC.getVASSALAGE_FREE_YIELD_FROM_VASSAL_PERCENT() + GetVassalCSBonusModifier());
					iFreeYield /= 100;

					break;

				case YIELD_FAITH:
					if (eYield == YIELD_FAITH && (GC.getGame().isOption(GAMEOPTION_NO_RELIGION)))
					{
						return 0;
					}
					iFreeYield = GET_PLAYER(ePlayer).GetTotalFaithPerTurn();
					iFreeYield *= (/*33*/GC.getVASSALAGE_FREE_YIELD_FROM_VASSAL_PERCENT() + GetVassalCSBonusModifier());
					iFreeYield /= 100;
					break;
				case YIELD_SCIENCE:
					if (eYield == YIELD_SCIENCE && (GC.getGame().isOption(GAMEOPTION_NO_SCIENCE)))
					{
						return 0;
					}
					iFreeYield = GET_PLAYER(ePlayer).GetScience();
					iFreeYield *= (/*33*/GC.getVASSALAGE_FREE_YIELD_FROM_VASSAL_PERCENT() + GetVassalCSBonusModifier());
					iFreeYield /= 100;
					break;
			}

			iYield += iFreeYield;
		}
	}
	return iYield;
}
//	--------------------------------------------------------------------------------
// Score from Vassals: 50% percent
int CvPlayer::GetScoreFromVassals() const
{
	int iScore = 0;
	PlayerTypes ePlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		ePlayer = (PlayerTypes) iPlayerLoop;
		iScore += GetScoreFromVassal(ePlayer);
	}

	return iScore;
}
//	--------------------------------------------------------------------------------
// Score from vassal
int CvPlayer::GetScoreFromVassal(PlayerTypes ePlayer) const
{
	int iScore = 0;

	if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassal(getTeam()))
	{
		iScore = GET_PLAYER(ePlayer).GetScoreFromLand() + GET_PLAYER(ePlayer).GetScoreFromPopulation();
		iScore *= /*20*/ GC.getVASSAL_SCORE_PERCENT();
		iScore /= 100;
	}

	return iScore;
}
// ------------------------

//	--------------------------------------------------------------------------------
int CvPlayer::GetVassalGoldMaintenanceMod() const
{
	return m_iVassalGoldMaintenanceMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetVassalGoldMaintenanceMod(int iValue)
{
	m_iVassalGoldMaintenanceMod = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeVassalGoldMaintenanceMod(int iChange)
{
	if(iChange != 0)
	{
		m_iVassalGoldMaintenanceMod = (m_iVassalGoldMaintenanceMod + iChange);
	}
}

void CvPlayer::DoVassalLevy()
{
	if (!m_bVassalLevy)
		return;

	// Look at all Cities
	bool bMaster = false;
	CvCity* pMasterCity = NULL;
	int iSum = 0;
	CvCity* pLoopCity;
	int iLoop;
	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		for (int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
		{
			const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

			if (pkBuildingInfo)
			{
				// Has this Building
				if (pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
				{
					if (pkBuildingInfo->IsVassalLevyEra())
					{
						bMaster = true;
						pMasterCity = pLoopCity;
						break;
					}
				}
			}
		}
	}
	if (bMaster && pMasterCity != NULL)
	{
		std::vector<UnitTypes> aExtraUnits;
		std::vector<UnitAITypes> aExtraUnitAITypes;
		CvUnit* pLoopUnit = NULL;
		int iLoop = 0;
		for (pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		{
			if (pLoopUnit->getDomainType() == DOMAIN_LAND && pLoopUnit->IsCombatUnit())
			{
				UnitTypes eCurrentUnitType = pLoopUnit->getUnitType();
				UnitAITypes eCurrentUnitAIType = pLoopUnit->AI_getUnitAIType();

				// check for duplicate unit
				bool bAddUnit = true;
				for (uint ui = 0; ui < aExtraUnits.size(); ui++)
				{
					if (aExtraUnits[ui] == eCurrentUnitType)
					{
						bAddUnit = false;
					}
				}

				if (bAddUnit)
				{
					aExtraUnits.push_back(eCurrentUnitType);
					aExtraUnitAITypes.push_back(eCurrentUnitAIType);
				}
			}
		}
		if (aExtraUnits.size() > 0)
		{
			int iTotal = GET_TEAM(getTeam()).GetNumVassals() * 2;
			for (int iK = 0; iK < iTotal; iK++)
			{
				int iUnit = GC.getGame().getSmallFakeRandNum(aExtraUnits.size(), GC.getGame().GetCultureAverage() + iK);
				CvUnit* pNewUnit = initUnit(aExtraUnits[iUnit], pMasterCity->getX(), pMasterCity->getY(), aExtraUnitAITypes[iUnit]);
				bool bJumpSuccess = pNewUnit->jumpToNearestValidPlot();
				if (bJumpSuccess)
				{
					pMasterCity->addProductionExperience(pNewUnit);
					iSum++;
				}
				if (!bJumpSuccess)
				{
					pNewUnit->kill(false);
					break;
				}
			}
			if (iSum > 0)
			{
				CvNotifications* pNotifications = GetNotifications();
				if (pNotifications && GetID() == GC.getGame().getActivePlayer())
				{
					Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_VASSAL_LEVY");
					strText << iSum;
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_VASSAL_LEVY_SUMMARY");
					strSummary << iSum;
					pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pMasterCity->getX(), pMasterCity->getY(), -1);
				}
			}
		}
	}

	m_bVassalLevy = false;
}

void CvPlayer::SetVassalLevy(bool bValue)
{
	if (m_bVassalLevy != bValue)
		m_bVassalLevy = bValue;
}

//	--------------------------------------------------------------------------------
// Generate tooltip displayed for whether or not our vassal can declare independence from us
CvString CvPlayer::GetVassalIndependenceTooltipAsMaster(PlayerTypes ePlayer) const
{
	CvTeam& kVassalTeam = GET_TEAM(GET_PLAYER(ePlayer).getTeam());

	TeamTypes eMaster = kVassalTeam.GetMaster();
	if(eMaster != getTeam())
		return "";

	CvTeam& kMasterTeam = GET_TEAM(eMaster);
	
	CvString szTooltip = "";
	
	szTooltip += GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_TT") + "[NEWLINE][NEWLINE]";

	bool bVoluntary = kVassalTeam.IsVoluntaryVassal(getTeam());
	bool bSatisfied = false;

	int iMinimumVassalTurns = bVoluntary ? GC.getGame().getGameSpeedInfo().getMinimumVoluntaryVassalTurns() : GC.getGame().getGameSpeedInfo().getMinimumVassalTurns();

	int iNumTurnsIsVassal = kVassalTeam.GetNumTurnsIsVassal();

	bSatisfied = (iNumTurnsIsVassal >= iMinimumVassalTurns);
	szTooltip += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_TURNS_TT", iMinimumVassalTurns) + "[ENDCOLOR][NEWLINE]";
	
	// Rules only for capitulated vassals
	if(!bVoluntary)
	{
		CvString szTemp = "";
		bool bAnySatisfied = false;

		int iNumCitiesWhenVassalMade = kVassalTeam.getNumCitiesWhenVassalMade();
		int iPopulationWhenVassalMade = kVassalTeam.getTotalPopulationWhenVassalMade();

		int iCityPercent = 0;
		int iPopPercent = 0;

		iCityPercent = kVassalTeam.getNumCities() * 100 / std::max(1, iNumCitiesWhenVassalMade);
		iPopPercent = kVassalTeam.getTotalPopulation() * 100 / std::max(1, iPopulationWhenVassalMade);

		bSatisfied = iCityPercent <= GC.getVASSALAGE_VASSAL_LOST_CITIES_THRESHOLD();
		bAnySatisfied = bAnySatisfied || bSatisfied;
		szTemp += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_CITY_PERCENT_TT", GC.getVASSALAGE_VASSAL_LOST_CITIES_THRESHOLD(),iCityPercent) + "[ENDCOLOR][NEWLINE]";

		bSatisfied = iPopPercent >= GC.getVASSALAGE_VASSAL_POPULATION_THRESHOLD();
		bAnySatisfied = bAnySatisfied || bSatisfied;
		szTemp += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_POP_PERCENT_TT", GC.getVASSALAGE_VASSAL_POPULATION_THRESHOLD(), iPopPercent) + "[ENDCOLOR][NEWLINE]";
		
		int iMasterCityPercent = 0;
		int iMasterPopPercent = 0;

		iMasterCityPercent = kVassalTeam.getNumCities() * 100 / std::max(1, kMasterTeam.getNumCities());
		iMasterPopPercent = kVassalTeam.getTotalPopulation() * 100 / std::max(1, kMasterTeam.getTotalPopulation());

		bSatisfied = iMasterCityPercent >= GC.getVASSALAGE_VASSAL_MASTER_CITY_PERCENT_THRESHOLD() && iMasterPopPercent >= GC.getVASSALAGE_VASSAL_MASTER_POP_PERCENT_THRESHOLD();
		bAnySatisfied = bAnySatisfied || bSatisfied;
		szTemp += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_MASTER_PERCENT_TT", GC.getVASSALAGE_VASSAL_MASTER_CITY_PERCENT_THRESHOLD(), GC.getVASSALAGE_VASSAL_MASTER_POP_PERCENT_THRESHOLD(), iMasterCityPercent, iMasterPopPercent) + "[ENDCOLOR][NEWLINE]";

		szTooltip += (bAnySatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_OR_HEADER_TT") + "[NEWLINE]";
		szTooltip += szTemp;
	}

	return szTooltip;
}

// Generate tooltip displayed for whether or not we can declare independence from master
CvString CvPlayer::GetVassalIndependenceTooltipAsVassal() const
{
	CvTeam& kVassalTeam = GET_TEAM(getTeam());

	TeamTypes eMaster = kVassalTeam.GetMaster();
	if(eMaster == NO_TEAM)
		return "";

	CvTeam& kMasterTeam = GET_TEAM(eMaster);
	
	CvString szTooltip = "";
	
	szTooltip += GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_MASTER_TT") + "[NEWLINE][NEWLINE]";

	bool bVoluntary = kVassalTeam.IsVoluntaryVassal(getTeam());
	bool bSatisfied = false;

	int iMinimumVassalTurns = bVoluntary ? GC.getGame().getGameSpeedInfo().getMinimumVoluntaryVassalTurns() : GC.getGame().getGameSpeedInfo().getMinimumVassalTurns();

	int iNumTurnsIsVassal = kVassalTeam.GetNumTurnsIsVassal();

	bSatisfied = (iNumTurnsIsVassal >= iMinimumVassalTurns);
	szTooltip += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_TURNS_TT", iMinimumVassalTurns) + "[ENDCOLOR][NEWLINE]";
	
	// Rules only for capitulated vassals
	if(!bVoluntary)
	{
		CvString szTemp = "";
		bool bAnySatisfied = false;

		int iNumCitiesWhenVassalMade = kVassalTeam.getNumCitiesWhenVassalMade();
		int iPopulationWhenVassalMade = kVassalTeam.getTotalPopulationWhenVassalMade();

		int iCityPercent = 0;
		int iPopPercent = 0;

		iCityPercent = kVassalTeam.getNumCities() * 100 / std::max(1, iNumCitiesWhenVassalMade);
		iPopPercent = kVassalTeam.getTotalPopulation() * 100 / std::max(1, iPopulationWhenVassalMade);

		bSatisfied = iCityPercent <= GC.getVASSALAGE_VASSAL_LOST_CITIES_THRESHOLD();
		bAnySatisfied = bAnySatisfied || bSatisfied;
		szTemp += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_CITY_PERCENT_TT", GC.getVASSALAGE_VASSAL_LOST_CITIES_THRESHOLD(),iCityPercent) + "[ENDCOLOR][NEWLINE]";

		bSatisfied = iPopPercent >= GC.getVASSALAGE_VASSAL_POPULATION_THRESHOLD();
		bAnySatisfied = bAnySatisfied || bSatisfied;
		szTemp += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_CITY_PERCENT_TT", GC.getVASSALAGE_VASSAL_POPULATION_THRESHOLD(), iPopPercent) + "[ENDCOLOR][NEWLINE]";
		
		int iMasterCityPercent = 0;
		int iMasterPopPercent = 0;

		iMasterCityPercent = kVassalTeam.getNumCities() * 100 / std::max(1, kMasterTeam.getNumCities());
		iMasterPopPercent = kVassalTeam.getTotalPopulation() * 100 / std::max(1, kMasterTeam.getTotalPopulation());

		bSatisfied = iMasterCityPercent >= GC.getVASSALAGE_VASSAL_MASTER_CITY_PERCENT_THRESHOLD() && iMasterPopPercent >= GC.getVASSALAGE_VASSAL_MASTER_POP_PERCENT_THRESHOLD();
		bAnySatisfied = bAnySatisfied || bSatisfied;
		szTemp += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_MASTER_PERCENT_TT", GC.getVASSALAGE_VASSAL_MASTER_CITY_PERCENT_THRESHOLD(), GC.getVASSALAGE_VASSAL_MASTER_POP_PERCENT_THRESHOLD(), iMasterCityPercent, iMasterPopPercent) + "[ENDCOLOR][NEWLINE]";

		szTooltip += (bAnySatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_OR_HEADER_TT") + "[NEWLINE]";
		szTooltip += szTemp;
	}

	return szTooltip;
}

#endif

#if defined(MOD_BALANCE_CORE)
int CvPlayer::GetScoreFromMinorAllies() const
{
	int iScore = (GC.getGame().GetNumMinorCivsEver() * 25);
	int iMaxMinorCivs = 0;
	int iMinorAllies = 0;
	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		PlayerTypes eMinor = (PlayerTypes) iMinorLoop;
		if(GET_PLAYER(eMinor).isAlive())
		{
			iMaxMinorCivs++;
		}
		if(GET_PLAYER(eMinor).GetMinorCivAI()->IsAllies(GetID()))
		{
			iMinorAllies++;
		}
	}
	if(iMaxMinorCivs > 0)
	{
		int iPercentage = ((iMinorAllies * 100) / iMaxMinorCivs);
		iScore = ((iPercentage * iScore) / 100);
		return iScore;
	}
	return 0;
}
int CvPlayer::GetScoreFromMilitarySize() const
{
	return (GetMilitaryMight() / (20 + getNumCities()));
}
#endif

#if defined(MOD_API_EXTENSIONS)
//	----------------------------------------------------------------------------
bool CvPlayer::HasBelief(BeliefTypes iBeliefType) const
{
	const ReligionTypes iReligion = GetReligions()->GetReligionCreatedByPlayer(true);
	const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(iReligion, GetID());

	return (pReligion && pReligion->m_Beliefs.HasBelief(iBeliefType));
}

bool CvPlayer::HasBuilding(BuildingTypes iBuildingType)
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasBuilding(iBuildingType)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasBuildingClass(BuildingClassTypes iBuildingClassType)
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasBuildingClass(iBuildingClassType)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasAnyWonder()
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasAnyWonder()) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasWonder(BuildingTypes iBuildingType)
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasWonder(iBuildingType)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::IsCivilization(CivilizationTypes iCivilizationType) const
{
	return (getCivilizationType() == iCivilizationType);
}

bool CvPlayer::IsInEra(EraTypes iEraType) const
{
	return (GET_TEAM(getTeam()).GetCurrentEra() == iEraType);
}

bool CvPlayer::HasReachedEra(EraTypes iEraType) const
{
	return (GET_TEAM(getTeam()).GetCurrentEra() >= iEraType);
}

bool CvPlayer::HasAnyNaturalWonder()
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasAnyNaturalWonder()) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasNaturalWonder(FeatureTypes iFeatureType)
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasNaturalWonder(iFeatureType)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasPolicy(PolicyTypes iPolicyType) const
{
	return GetPlayerPolicies()->HasPolicy(iPolicyType);
}

bool CvPlayer::HasTenet(PolicyTypes iPolicyType) const
{
	return HasPolicy(iPolicyType);
}

bool CvPlayer::HasPolicyBranch(PolicyBranchTypes iPolicyBranchType) const
{
	return GetPlayerPolicies()->IsPolicyBranchUnlocked(iPolicyBranchType);
}

bool CvPlayer::HasIdeology(PolicyBranchTypes iPolicyBranchType) const
{
	return HasPolicyBranch(iPolicyBranchType);
}
bool CvPlayer::HasSameIdeology(PlayerTypes ePlayer) const
{
	CvPlayer &kPlayer = GET_PLAYER(ePlayer);
	PolicyBranchTypes eMyIdeology = GetPlayerPolicies()->GetLateGamePolicyTree();
	PolicyBranchTypes eTheirIdeology = kPlayer.GetPlayerPolicies()->GetLateGamePolicyTree();
	if (eMyIdeology != NO_POLICY_BRANCH_TYPE && eTheirIdeology != NO_POLICY_BRANCH_TYPE && eMyIdeology == eTheirIdeology)
	{
		return true;
	}
	return false;
}
bool CvPlayer::HasProject(ProjectTypes iProjectType) const
{
	return (GET_TEAM(getTeam()).getProjectCount(iProjectType) > 0);
}

bool CvPlayer::IsAtPeace() const
{
	return !IsAtWar();
}

bool CvPlayer::IsAtPeaceAllMajors() const
{
	return !IsAtWarAnyMajor();
}

bool CvPlayer::IsAtPeaceAllMinors() const
{
	return !IsAtWarAnyMinor();
}

bool CvPlayer::IsAtPeaceWith(PlayerTypes iPlayer) const
{
	return !IsAtWarWith(iPlayer);
}

bool CvPlayer::IsAtWar() const
{
	//reference is important! otherwise the destructor will be called
	CvTeam& kTeam = GET_TEAM(getTeam());

	//ignore the barbarian team here!
	for (int iTeam = 0; iTeam < (MAX_TEAMS-1); iTeam++) {
		if (GET_TEAM((TeamTypes)iTeam).isAlive() && kTeam.isAtWar((TeamTypes)iTeam)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::IsAtWarAnyMajor() const
{
	//reference is important! otherwise the destructor will be called
	CvTeam& kTeam = GET_TEAM(getTeam());

	for (int iTeam = 0; iTeam < (MAX_TEAMS-1); iTeam++) {
		if (GET_TEAM((TeamTypes)iTeam).isAlive() && GET_TEAM((TeamTypes)iTeam).isMajorCiv() && kTeam.isAtWar((TeamTypes)iTeam)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::IsAtWarAnyMinor() const
{
	//reference is important! otherwise the destructor will be called
	CvTeam& kTeam = GET_TEAM(getTeam());

	for (int iTeam = 0; iTeam < (MAX_TEAMS-1); iTeam++) {
		if (GET_TEAM((TeamTypes)iTeam).isAlive() && GET_TEAM((TeamTypes)iTeam).isMinorCiv() && kTeam.isAtWar((TeamTypes)iTeam)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::IsAtWarWith(PlayerTypes iPlayer) const
{
	if (iPlayer==NO_PLAYER)
		return false;

	return GET_TEAM(getTeam()).isAtWar(GET_PLAYER(iPlayer).getTeam());
}

bool CvPlayer::HasPantheon() const
{
	return GetReligions()->HasCreatedPantheon();
}

bool CvPlayer::HasAnyReligion() const
{
	return GetReligions()->HasCreatedReligion();
}

bool CvPlayer::HasReligion(ReligionTypes iReligionType) const
{
	return (GetReligions()->GetReligionCreatedByPlayer() == iReligionType);
}

bool CvPlayer::HasEnhancedReligion() const
{
	const ReligionTypes eReligion = GetReligions()->GetReligionCreatedByPlayer();
	const CvReligion* pMyReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, GetID());

	return (pMyReligion && pMyReligion->m_bEnhanced);
}

bool CvPlayer::IsConnectedTo(PlayerTypes iPlayer)
{
	return IsCapitalConnectedToPlayer(iPlayer);
}

bool CvPlayer::HasSpecialistSlot(SpecialistTypes iSpecialistType)
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasSpecialistSlot(iSpecialistType)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasSpecialist(SpecialistTypes iSpecialistType)
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasSpecialist(iSpecialistType)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasTech(TechTypes iTechType) const
{
	return GET_TEAM(getTeam()).GetTeamTechs()->HasTech(iTechType);
}

bool CvPlayer::HasAnyDomesticTradeRoute() const
{
	int iOwner = GetID();
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute)) {
			continue;
		}

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));

		if (pConnection->m_eOriginOwner == iOwner && pConnection->m_eDestOwner == iOwner) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasAnyInternationalTradeRoute() const
{
	int iOwner = GetID();
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute)) {
			continue;
		}

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));

		if ((pConnection->m_eOriginOwner == iOwner && pConnection->m_eDestOwner   != iOwner) ||
		    (pConnection->m_eDestOwner   == iOwner && pConnection->m_eOriginOwner != iOwner)) {
			return true;
		}
	}

	return false;
}
int CvPlayer::GetNumInternalRoutes() const
{
	int iOwner = GetID();
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();
	int iNum = 0;
	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute)) {
			continue;
		}

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));

		if (pConnection->m_eOriginOwner == iOwner && pConnection->m_eDestOwner == iOwner) {
			iNum++;
		}
	}

	return iNum;
}

int CvPlayer::GetNumInternationalRoutes() const
{
	int iOwner = GetID();
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();
	int iNum = 0;
	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute)) {
			continue;
		}

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));

		if (pConnection->m_eOriginOwner == iOwner && pConnection->m_eDestOwner != iOwner)
		{
			iNum++;
		}
	}

	return iNum;
}
bool CvPlayer::HasAnyTradeRoute() const
{
	int iOwner = GetID();
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute)) {
			continue;
		}

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));

		if (pConnection->m_eOriginOwner == iOwner || pConnection->m_eDestOwner == iOwner) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasAnyTradeRouteWith(PlayerTypes iPlayer) const
{
	int iOwner = GetID();
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute)) {
			continue;
		}

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));

		if ((pConnection->m_eOriginOwner == iOwner && pConnection->m_eDestOwner   == iPlayer) ||
		    (pConnection->m_eDestOwner   == iOwner && pConnection->m_eOriginOwner == iPlayer)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasUnit(UnitTypes iUnitType)
{
	int iLoopUnit;

	for (CvUnit* pLoopUnit = firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoopUnit)) {
		if (!pLoopUnit->isDelayedDeath()) {
			if (pLoopUnit->IsUnit(iUnitType)) {
				return true;
			}
		}
	}

	return false;
}

bool CvPlayer::HasUnitClass(UnitClassTypes iUnitClassType)
{
	int iLoopUnit;

	for (CvUnit* pLoopUnit = firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoopUnit)) {
		if (!pLoopUnit->isDelayedDeath()) {
			if (pLoopUnit->IsUnitClass(iUnitClassType)) {
				return true;
			}
		}
	}

	return false;
}

bool CvPlayer::HasUUActive()
{
	int iLoopUnit;

	CvCivilizationInfo* pkInfo = GC.getCivilizationInfo(getCivilizationType());
	if (pkInfo)
	{
		for (CvUnit* pLoopUnit = firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoopUnit)) 
		{
			if (!pLoopUnit->isDelayedDeath()) 
			{
				if (pkInfo->isCivilizationUnitOverridden(pLoopUnit->getUnitClassType()))
				{
					return true;
				}
			}
		}
	}

	return false;
}

bool CvPlayer::HasUUPeriod() const
{
	return m_bHasUUPeriod;
}

void CvPlayer::SetHasUUPeriod()
{
	CvCivilizationInfo* pkInfo = GC.getCivilizationInfo(getCivilizationType());
	if (pkInfo)
	{
		// Loop through all units
		for (int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
		{
			// Is this one overridden for our civ?
			if (pkInfo->isCivilizationUnitOverridden(iI))
			{
				UnitTypes eCivilizationUnit = static_cast<UnitTypes>(pkInfo->getCivilizationUnits(iI));
				if (eCivilizationUnit != NO_UNIT)
				{
					CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eCivilizationUnit);
					if (pkUnitEntry && pkUnitEntry->GetCombat() > 0 || pkUnitEntry->GetRangedCombat() > 0 || pkUnitEntry->GetCultureBombRadius() > 0 || pkUnitEntry->IsCanRepairFleet() || pkUnitEntry->IsCityAttackSupport())
					{
						//obsolete? This no longer applies.
						if (pkUnitEntry->GetObsoleteTech() != NO_TECH && HasTech((TechTypes)pkUnitEntry->GetObsoleteTech()))
						{
							m_bHasUUPeriod = false;
						}
						else if (!m_bHasUUPeriod)
						{
							m_bHasUUPeriod = true;
							return;
						}
					}
				}
			}
		}
	}
	if (m_bHasUUPeriod)
		m_bHasUUPeriod = false;
}

bool CvPlayer::HasTrait(TraitTypes eTrait) const
{
	return GetPlayerTraits()->HasTrait(eTrait);
}

bool CvPlayer::HasAnyHolyCity()
{
	int iLoop;

	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		if (pLoopCity->GetCityReligions()->IsHolyCityAnyReligion()) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasHolyCity(ReligionTypes eReligion)
{
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		if (pLoopCity->GetCityReligions()->IsHolyCityForReligion(eReligion)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasCapturedHolyCity(ReligionTypes eReligion)
{
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		if (pLoopCity->GetCityReligions()->IsHolyCityForReligion(eReligion)) {
			return (pLoopCity->getOriginalOwner() != GetID());
		}
	}

	return false;
}

bool CvPlayer::HasEmbassyWith(PlayerTypes eOtherPlayer) const
{
	if (eOtherPlayer >= 0 && eOtherPlayer < MAX_MAJOR_CIVS) {
		CvPlayer& kOtherPlayer = GET_PLAYER(eOtherPlayer);

		return (kOtherPlayer.isAlive() && GET_TEAM(getTeam()).HasEmbassyAtTeam(kOtherPlayer.getTeam()));
	}

	return false;
}

void CvPlayer::DoForceDefPact(PlayerTypes eOtherPlayer)
{
	CvTeam& pOtherTeam = GET_TEAM(GET_PLAYER(eOtherPlayer).getTeam());

	GET_TEAM(getTeam()).SetHasDefensivePact(pOtherTeam.GetID(), true);
	pOtherTeam.SetHasDefensivePact(getTeam(), true);
}
int CvPlayer::CountAllFeature(FeatureTypes iFeatureType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountFeature(iFeatureType);
	}
	
	return iCount;
}

int CvPlayer::CountAllWorkedFeature(FeatureTypes iFeatureType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountWorkedFeature(iFeatureType);
	}
	
	return iCount;
}

int CvPlayer::CountAllImprovement(ImprovementTypes iImprovementType, bool bOnlyCreated)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountImprovement(iImprovementType, bOnlyCreated);
	}
	
	return iCount;
}

int CvPlayer::CountAllWorkedImprovement(ImprovementTypes iImprovementType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountWorkedImprovement(iImprovementType);
	}
	
	return iCount;
}

int CvPlayer::CountAllPlotType(PlotTypes iPlotType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountPlotType(iPlotType);
	}
	
	return iCount;
}

int CvPlayer::CountAllWorkedPlotType(PlotTypes iPlotType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountWorkedPlotType(iPlotType);
	}
	
	return iCount;
}

int CvPlayer::CountAllResource(ResourceTypes iResourceType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountResource(iResourceType);
	}
	
	return iCount;
}

int CvPlayer::CountAllWorkedResource(ResourceTypes iResourceType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountWorkedResource(iResourceType);
	}
	
	return iCount;
}

int CvPlayer::CountAllTerrain(TerrainTypes iTerrainType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountTerrain(iTerrainType);
	}
	
	return iCount;
}

int CvPlayer::CountAllWorkedTerrain(TerrainTypes iTerrainType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountWorkedTerrain(iTerrainType);
	}
	
	return iCount;
}
#endif

void CvPlayer::invalidatePlotFoundValues()
{
	m_iPlotFoundValuesUpdateTurn = -1;
}

void CvPlayer::computeAveragePlotFoundValue()
{
	// important preparation
	GC.getGame().GetSettlerSiteEvaluator()->ComputeFlavorMultipliers(this);

	unsigned int iSum = 0, iValidPlots = 0;

	CvSiteEvaluatorForSettler* pCalc = GC.getGame().GetSettlerSiteEvaluator();
	for (int iI = 0; iI < GC.getMap().numPlots(); iI++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iI);
		int iValue = pCalc->PlotFoundValue(pPlot, this, vector<int>());

		if (iValue > 0)
		{
			iSum += iValue / 1000;
			iValidPlots++;
		}
	}

	//assuming a normal distribution, this should allow all but the worst plots
	int iAvg = (iSum / max(1u,iValidPlots)) * 1000;
	m_iReferenceFoundValue = iAvg - iAvg / 3;

	//some flavor adjustment
	int iFlavorExpansion = GetFlavorManager()->GetPersonalityIndividualFlavor((FlavorTypes)GC.getInfoTypeForString("FLAVOR_EXPANSION"));
	//clamp it to a sensible range - alternatively use GetIndividualFlavor() but that has an even more undefined range
	iFlavorExpansion = min(max(0, iFlavorExpansion), 12);
	m_iReferenceFoundValue = (m_iReferenceFoundValue * (100 - 2 * iFlavorExpansion)) / 100;

	OutputDebugString(CvString::format("Average city site value for player %d is %d, flavor adjusted limit is %d\n", m_eID.get(), iAvg, m_iReferenceFoundValue.get()).c_str());
}

void CvPlayer::updatePlotFoundValues()
{
	if (m_iPlotFoundValuesUpdateTurn==GC.getGame().getGameTurn())
		return;

	//OutputDebugString(CvString::format("updating plot found values for player %d in turn %d\n",GetID(),GC.getGame().getGameTurn()).c_str());
	m_viPlotFoundValues = std::vector<int>(GC.getMap().numPlots(), -1);

	// Set all area fertilities to 0
	int iLoop = 0;
	for (CvArea* pLoopArea = GC.getMap().firstArea(&iLoop); pLoopArea != NULL; pLoopArea = GC.getMap().nextArea(&iLoop))
		pLoopArea->setTotalFoundValue(0);

	//don't need to update if never going to settle
	if (isBarbarian() || isMinorCiv())
		return;

	//don't need to update if never going to settle again
#if defined(MOD_BUGFIX_MINOR_CIV_STRATEGIES)
	EconomicAIStrategyTypes eCanSettle = (EconomicAIStrategyTypes)GC.getInfoTypeForString("ECONOMICAISTRATEGY_FOUND_CITY");
	if (EconomicAIHelpers::CannotMinorCiv(this, eCanSettle))
#else
	if (isMinorCiv())
#endif
	{
		if (GetNumCitiesFounded()>0)
			return;
	}

	// important preparation
	GC.getGame().GetSettlerSiteEvaluator()->ComputeFlavorMultipliers(this);
	vector<int> ignorePlots(GC.getMap().numPlots(), 0); //these are the plots whose yield we ignore
	for (int iI = 0; iI < GC.getMap().numPlots(); iI++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iI);
		if (pPlot->isOwned())
		{
			if (pPlot->getOwner() != m_eID) //if we own it, it's fine
				ignorePlots[iI] = 1;
		}
		else if (pPlot->IsAdjacentOwnedByTeamOtherThan(getTeam()) && GC.getGame().GetClosestCityDistanceInPlots(pPlot)<GC.getMIN_CITY_RANGE())
			ignorePlots[iI] = 1;
	}

	// first pass: precalculate found values
	CvSiteEvaluatorForSettler* pCalc = GC.getGame().GetSettlerSiteEvaluator();
	for (int iI = 0; iI < GC.getMap().numPlots(); iI++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iI);
		if (!pPlot->isRevealed(getTeam()))
			continue;

		int iValue = pCalc->PlotFoundValue(pPlot, this, ignorePlots);
		if (iValue > m_iReferenceFoundValue)
			m_viPlotFoundValues[iI] = iValue;
	}

	std::map<int,int> minDistancePerArea;
	std::map<int,int> countPerArea;

	// second pass: non-maxima suppression and aggregation
	for (int iI = 0; iI < GC.getMap().numPlots(); iI++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iI);
		int iCurrentValue = m_viPlotFoundValues[iI];
		if (iCurrentValue < m_iReferenceFoundValue)
			continue;

		for (int iCount = RING0_PLOTS; iCount<RING3_PLOTS; iCount++)
		{
			CvPlot* pLoopPlot = iterateRingPlots(pPlot,iCount);
			if (pLoopPlot == NULL)
				continue;

			if (m_viPlotFoundValues[pLoopPlot->GetPlotIndex()] > iCurrentValue)
			{
				//this is not a local maximum
				pPlot = NULL;
				break;
			}
		}

		if (pPlot)
		{
			CvArea* pLoopArea = GC.getMap().getArea(pPlot->getArea());
			if (pLoopArea && !pLoopArea->isWater() && (pLoopArea->getNumTiles() > 0))
			{
				//one supercity counts more than two mediocre ones
				int iAddValue = (int)pow((float)iCurrentValue-m_iReferenceFoundValue,1.5f);
				int newValue = pLoopArea->getTotalFoundValue() + iAddValue;
				pLoopArea->setTotalFoundValue(newValue);
				
				//track the distance from our existing cities
				int iCityDistance = GetCityDistanceInEstimatedTurns(pPlot);
				if (minDistancePerArea.find(pLoopArea->GetID())==minDistancePerArea.end())
					minDistancePerArea[pLoopArea->GetID()] = iCityDistance;
				else if (iCityDistance < minDistancePerArea[pLoopArea->GetID()])
					minDistancePerArea[pLoopArea->GetID()] = iCityDistance;

				//track the number of cities we could found there
				if (countPerArea.find(pLoopArea->GetID())==countPerArea.end())
					countPerArea[pLoopArea->GetID()] = 1;
				else
					countPerArea[pLoopArea->GetID()]++;
			}
		}
	}

	//try to make it so that we settle close areas first and try to correct the bias towards large areas
	for (CvArea* pLoopArea = GC.getMap().firstArea(&iLoop); pLoopArea != NULL; pLoopArea = GC.getMap().nextArea(&iLoop))
	{
		if (pLoopArea->getTotalFoundValue()>0)
		{
			//take care with overflow here
			float fDistScale = 0.5f + MapToPercent( minDistancePerArea[pLoopArea->GetID()],30,10 )/200.f;
			float fCountScale = 1/sqrt( (float)countPerArea[pLoopArea->GetID()] );

			pLoopArea->setTotalFoundValue( int(pLoopArea->getTotalFoundValue() * fDistScale) );
			pLoopArea->setTotalFoundValue( int(pLoopArea->getTotalFoundValue() * fCountScale) );
		}
	}

	m_iPlotFoundValuesUpdateTurn = GC.getGame().getGameTurn();
}

int CvPlayer::getPlotFoundValue(int iX, int iY)
{
	//lazy update
	updatePlotFoundValues();

	size_t iIndex = (size_t)GC.getMap().plotNum(iX,iY);

	if (iIndex<m_viPlotFoundValues.size())
		return m_viPlotFoundValues[iIndex];
	else
		return 0;
}

void CvPlayer::setPlotFoundValue(int iX, int iY, int iValue)
{
	//if setting the values manually, make sure the size is right
	if (m_viPlotFoundValues.size() != GC.getMap().numPlots())
		m_viPlotFoundValues.resize(GC.getMap().numPlots(), -1);

	size_t iIndex = (size_t)GC.getMap().plotNum(iX, iY);
	if (iIndex<m_viPlotFoundValues.size())
		m_viPlotFoundValues[iIndex] = iValue;

	//prevent lazy update from overwriting this
	m_iPlotFoundValuesUpdateTurn = GC.getGame().getGameTurn();
}

int CvPlayer::GetAvgUnitExp100() const
{
	return m_iAvgUnitExp100;
}
