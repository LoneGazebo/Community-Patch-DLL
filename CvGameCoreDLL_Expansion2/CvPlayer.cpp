/*	-------------------------------------------------------------------------------------------------------
	� 1991-2012 Take-Two Interactive Software and its subsidiaries.  Developed by Firaxis Games.  
	Sid Meier's Civilization V, Civ, Civilization, 2K Games, Firaxis Games, Take-Two Interactive Software 
	and their respective logos are all trademarks of Take-Two interactive Software, Inc.  
	All other marks and trademarks are the property of their respective owners.  
	All rights reserved. 
	------------------------------------------------------------------------------------------------------- */

#include "CvGameCoreDLLPCH.h"
#include "CvGlobals.h"
#include "CvArea.h"
#include "CvMap.h"
#include "CvPlot.h"
#include "CvRandom.h"
#include "CvTeam.h"
#include "CvGameCoreUtils.h"
#include "CvPlayerAI.h"
#include "CvPlayer.h"
#include "CvGameCoreUtils.h"
#include "CvInfos.h"
#include "CvAStar.h"
#include "CvGameTextMgr.h"
#include "CvDiplomacyAI.h"
#include "CvEconomicAI.h"
#include "CvMilitaryAI.h"
#include "CvCitySpecializationAI.h"
#include "CvWonderProductionAI.h"
#include "CvGrandStrategyAI.h"
#include "CvDiplomacyAI.h"
#include "CvTechAI.h"
#include "CvFlavorManager.h"
#include "CvHomelandAI.h"
#include "CvMinorCivAI.h"
#include "CvDealAI.h"
#include "CvImprovementClasses.h"
#include "CvBuilderTaskingAI.h"
#include "CvDangerPlots.h"
#if defined(MOD_BALANCE_CORE)
#include "CvDistanceMap.h"
#include "CvBarbarians.h"
#endif
#include "CvCityConnections.h"
#include "CvNotifications.h"
#include "CvDiplomacyRequests.h"
#include "cvStopWatch.h"
#include "CvTypes.h"
#if defined(MOD_BUGFIX_NO_PUPPET_CAPITALS)
#include "CvEnums.h"
#endif

#include "ICvDLLUserInterface.h"
#include "CvEnumSerialization.h"
#include "FStlContainerSerialization.h"
#include <sstream>
#if defined(MOD_BALANCE_CORE)
#include <iomanip>
#endif

#include "CvInternalGameCoreUtils.h"
#include "CvAchievementUnlocker.h"
#include "CvInfosSerializationHelper.h"

#include "CvDllCity.h"
#if defined(MOD_GLOBAL_NO_CONQUERED_SPACESHIPS)
#include "CvDllPlot.h"
#endif
#include "CvGoodyHuts.h"

// Include this after all other headers.
#define LINT_WARNINGS_ONLY
#include "LintFree.h"

//------------------------------------------------------------------------------
// CvPlayer Version History
// Version 1 
//	 * CvPlayer save version reset for expansion pack 2.
//------------------------------------------------------------------------------
const int g_CurrentCvPlayerVersion = 16;

//Simply empty check utility.
bool isEmpty(const char* szString)
{
	return szString == NULL || szString[0] == '\0';
}

//	--------------------------------------------------------------------------------
// Public Functions...
namespace FSerialization
{
void SyncPlayer()
{
	if(GC.getGame().isNetworkMultiPlayer())
	{
		PlayerTypes eAuthoritativePlayerID = GC.getGame().getActivePlayer();
		CvPlayer& authoritativePlayer = GET_PLAYER(eAuthoritativePlayerID);
		const FAutoArchive& archive = authoritativePlayer.getSyncArchive();
		if(archive.hasDeltas())
		{
			FMemoryStream ms;
			std::vector<std::pair<std::string, std::string> > callStacks;
			archive.saveDelta(ms, callStacks);
			gDLL->sendPlayerSyncCheck(eAuthoritativePlayerID, ms, callStacks);
		}

		// host is authoritative for AI players

		if(gDLL->IsHost())
		{
			for(int i = 0; i < MAX_PLAYERS; ++i)
			{
				CvPlayer& player = GET_PLAYER(static_cast<PlayerTypes>(i));
				if(!player.isHuman() && player.isAlive())
				{
					const FAutoArchive& aiArchive = player.getSyncArchive();
					FMemoryStream ms;
					std::vector<std::pair<std::string, std::string> > callStacks;
					aiArchive.saveDelta(ms, callStacks);
					gDLL->sendPlayerSyncCheck(static_cast<PlayerTypes>(i), ms, callStacks);
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
// clears ALL deltas for ALL players
void ClearPlayerDeltas()
{
	int i = 0;
	for(i = 0; i < MAX_PLAYERS; ++i)
	{
		CvPlayer& player = GET_PLAYER(static_cast<PlayerTypes>(i));
		FAutoArchive& archive = player.getSyncArchive();
		archive.clearDelta();
	}
}
}

//	--------------------------------------------------------------------------------
CvPlayer::CvPlayer() :
	m_syncArchive(*this)
	, m_iStartingX("CvPlayer::m_iStartingX", m_syncArchive)
	, m_iStartingY("CvPlayer::m_iStartingY", m_syncArchive)
	, m_iTotalPopulation("CvPlayer::m_iTotalPopulation", m_syncArchive, true)
	, m_iTotalLand("CvPlayer::m_iTotalLand", m_syncArchive)
	, m_iTotalLandScored("CvPlayer::m_iTotalLandScored", m_syncArchive)
	, m_iJONSCulturePerTurnForFree("CvPlayer::m_iJONSCulturePerTurnForFree", m_syncArchive)
	, m_iJONSCulturePerTurnFromMinorCivs("CvPlayer::m_iJONSCulturePerTurnFromMinorCivs", m_syncArchive)
	, m_iJONSCultureCityModifier("CvPlayer::m_iJONSCultureCityModifier", m_syncArchive)
	, m_iJONSCulture("CvPlayer::m_iJONSCulture", m_syncArchive, true)
	, m_iJONSCultureEverGenerated("CvPlayer::m_iJONSCultureEverGenerated", m_syncArchive)
	, m_iCulturePerWonder("CvPlayer::m_iCulturePerWonder", m_syncArchive)
	, m_iCultureWonderMultiplier("CvPlayer::m_iCultureWonderMultiplier", m_syncArchive)
	, m_iCulturePerTechResearched("CvPlayer::m_iCulturePerTechResearched", m_syncArchive)
	, m_iFaith("CvPlayer::m_iFaith", m_syncArchive)
	, m_iFaithEverGenerated("CvPlayer::m_iFaithEverGenerated", m_syncArchive)
	, m_iHappiness("CvPlayer::m_iHappiness", m_syncArchive)
	, m_iUprisingCounter("CvPlayer::m_iUprisingCounter", m_syncArchive)
	, m_iExtraHappinessPerLuxury("CvPlayer::m_iExtraHappinessPerLuxury", m_syncArchive)
	, m_iUnhappinessFromUnits("CvPlayer::m_iUnhappinessFromUnits", m_syncArchive)
	, m_iUnhappinessFromUnitsMod("CvPlayer::m_iUnhappinessFromUnitsMod", m_syncArchive)
	, m_iUnhappinessMod("CvPlayer::m_iUnhappinessMod", m_syncArchive)
	, m_iCityCountUnhappinessMod("CvPlayer::m_iCityCountUnhappinessMod", m_syncArchive)
	, m_iOccupiedPopulationUnhappinessMod("CvPlayer::m_iOccupiedPopulationUnhappinessMod", m_syncArchive)
	, m_iCapitalUnhappinessMod("CvPlayer::m_iCapitalUnhappinessMod", m_syncArchive)
	, m_iCityRevoltCounter("CvPlayer::m_iCityRevoltCounter", m_syncArchive)
	, m_iHappinessPerGarrisonedUnitCount("CvPlayer::m_iHappinessPerGarrisonedUnitCount", m_syncArchive)
	, m_iHappinessPerTradeRouteCount("CvPlayer::m_iHappinessPerTradeRouteCount", m_syncArchive)
	, m_iHappinessPerXPopulation("CvPlayer::m_iHappinessPerXPopulation", m_syncArchive)
	, m_iHappinessFromLeagues("CvPlayer::m_iHappinessFromLeagues", m_syncArchive)
	, m_iEspionageModifier("CvPlayer::m_iEspionageModifier", m_syncArchive)
	, m_iSpyStartingRank("CvPlayer::m_iSpyStartingRank", m_syncArchive)
	, m_iExtraLeagueVotes("CvPlayer::m_iExtraLeagueVotes", m_syncArchive)
	, m_iSpecialPolicyBuildingHappiness("CvPlayer::m_iSpecialPolicyBuildingHappiness", m_syncArchive)
	, m_iWoundedUnitDamageMod("CvPlayer::m_iWoundedUnitDamageMod", m_syncArchive)
	, m_iUnitUpgradeCostMod("CvPlayer::m_iUnitUpgradeCostMod", m_syncArchive)
	, m_iBarbarianCombatBonus("CvPlayer::m_iBarbarianCombatBonus", m_syncArchive)
	, m_iAlwaysSeeBarbCampsCount("CvPlayer::m_iAlwaysSeeBarbCampsCount", m_syncArchive)
	, m_iHappinessFromBuildings("CvPlayer::m_iHappinessFromBuildings", m_syncArchive)
	, m_iHappinessPerCity("CvPlayer::m_iHappinessPerCity", m_syncArchive)
	, m_iHappinessPerXPolicies("CvPlayer::m_iHappinessPerXPolicies", m_syncArchive)
	, m_iAdvancedStartPoints("CvPlayer::m_iAdvancedStartPoints", m_syncArchive)
	, m_iAttackBonusTurns("CvPlayer::m_iAttackBonusTurns", m_syncArchive)
	, m_iCultureBonusTurns("CvPlayer::m_iCultureBonusTurns", m_syncArchive)
	, m_iTourismBonusTurns("CvPlayer::m_iTourismBonusTurns", m_syncArchive)
	, m_iGoldenAgeProgressMeter("CvPlayer::m_iGoldenAgeProgressMeter", m_syncArchive, true)
	, m_iGoldenAgeMeterMod("CvPlayer::m_iGoldenAgeMeterMod", m_syncArchive)
	, m_iNumGoldenAges("CvPlayer::m_iNumGoldenAges", m_syncArchive)
	, m_iGoldenAgeTurns("CvPlayer::m_iGoldenAgeTurns", m_syncArchive)
	, m_iNumUnitGoldenAges("CvPlayer::m_iNumUnitGoldenAges", m_syncArchive)
	, m_iStrikeTurns("CvPlayer::m_iStrikeTurns", m_syncArchive)
	, m_iGoldenAgeModifier("CvPlayer::m_iGoldenAgeModifier", m_syncArchive)
	, m_iGreatPeopleCreated("CvPlayer::m_iGreatPeopleCreated", m_syncArchive)
	, m_iGreatGeneralsCreated("CvPlayer::m_iGreatGeneralsCreated", m_syncArchive)
	, m_iGreatAdmiralsCreated("CvPlayer::m_iGreatAdmiralsCreated", m_syncArchive)
	, m_iGreatWritersCreated("CvPlayer::m_iGreatWritersCreated", m_syncArchive)
	, m_iGreatArtistsCreated("CvPlayer::m_iGreatArtistsCreated", m_syncArchive)
	, m_iGreatMusiciansCreated("CvPlayer::m_iGreatMusiciansCreated", m_syncArchive)
	, m_iMerchantsFromFaith("CvPlayer::m_iMerchantsFromFaith", m_syncArchive)
	, m_iScientistsFromFaith("CvPlayer::m_iScientistsFromFaith", m_syncArchive)
	, m_iWritersFromFaith("CvPlayer::m_iWritersFromFaith", m_syncArchive)
	, m_iArtistsFromFaith("CvPlayer::m_iArtistsFromFaith", m_syncArchive)
	, m_iMusiciansFromFaith("CvPlayer::m_iMusiciansFromFaith", m_syncArchive)
	, m_iGeneralsFromFaith("CvPlayer::m_iGeneralsFromFaith", m_syncArchive)
	, m_iAdmiralsFromFaith("CvPlayer::m_iAdmiralsFromFaith", m_syncArchive)
	, m_iEngineersFromFaith("CvPlayer::m_iEngineersFromFaith", m_syncArchive)
	, m_iGreatPeopleThresholdModifier("CvPlayer::m_iGreatPeopleThresholdModifier", m_syncArchive)
	, m_iGreatGeneralsThresholdModifier("CvPlayer::m_iGreatGeneralsThresholdModifier", m_syncArchive)
	, m_iGreatAdmiralsThresholdModifier("CvPlayer::m_iGreatAdmiralsThresholdModifier", m_syncArchive)
	, m_iGreatGeneralCombatBonus("CvPlayer::m_iGreatGeneralCombatBonus", m_syncArchive)
	, m_iAnarchyNumTurns("CvPlayer::m_iAnarchyNumTurns", m_syncArchive)
	, m_iPolicyCostModifier("CvPlayer::m_iPolicyCostModifier", m_syncArchive)
	, m_iGreatPeopleRateModifier("CvPlayer::m_iGreatPeopleRateModifier", m_syncArchive)
	, m_iGreatPeopleRateModFromBldgs("CvPlayer::m_iGreatPeopleRateModFromBldgs", m_syncArchive)
	, m_iGreatGeneralRateModifier("CvPlayer::m_iGreatGeneralRateModifier", m_syncArchive)
	, m_iGreatGeneralRateModFromBldgs("CvPlayer::m_iGreatGeneralRateModFromBldgs", m_syncArchive)
	, m_iDomesticGreatGeneralRateModifier("CvPlayer::m_iDomesticGreatGeneralRateModifier", m_syncArchive)
	, m_iDomesticGreatGeneralRateModFromBldgs("CvPlayer::m_iDomesticGreatGeneralRateModFromBldgs", m_syncArchive)
	, m_iGreatAdmiralRateModifier("CvPlayer::m_iGreatAdmiralRateModifier", m_syncArchive)
	, m_iGreatWriterRateModifier("CvPlayer::m_iGreatWriterRateModifier", m_syncArchive)
	, m_iGreatArtistRateModifier("CvPlayer::m_iGreatArtistRateModifier", m_syncArchive)
	, m_iGreatMusicianRateModifier("CvPlayer::m_iGreatMusicianRateModifier", m_syncArchive)
	, m_iGreatMerchantRateModifier("CvPlayer::m_iGreatMerchantRateModifier", m_syncArchive)
	, m_iGreatDiplomatRateModifier("CvPlayer::m_iGreatDiplomatRateModifier", m_syncArchive)
	, m_iGreatScientistRateModifier("CvPlayer::m_iGreatScientistRateModifier", m_syncArchive)
	, m_iGreatScientistBeakerModifier("CvPlayer::m_iGreatScientistBeakerModifier", m_syncArchive)
	, m_iGreatEngineerRateModifier("CvPlayer::m_iGreatEngineerRateModifier", m_syncArchive)
	, m_iGreatPersonExpendGold("CvPlayer::m_iGreatPersonExpendGold", m_syncArchive)
	, m_iMaxGlobalBuildingProductionModifier("CvPlayer::m_iMaxGlobalBuildingProductionModifier", m_syncArchive)
	, m_iMaxTeamBuildingProductionModifier("CvPlayer::m_iMaxTeamBuildingProductionModifier", m_syncArchive)
	, m_iMaxPlayerBuildingProductionModifier("CvPlayer::m_iMaxPlayerBuildingProductionModifier", m_syncArchive)
	, m_iFreeExperience("CvPlayer::m_iFreeExperience", m_syncArchive)
	, m_iFreeExperienceFromBldgs("CvPlayer::m_iFreeExperienceFromBldgs", m_syncArchive)
	, m_iFreeExperienceFromMinors("CvPlayer::m_iFreeExperienceFromMinors", m_syncArchive)
	, m_iFeatureProductionModifier("CvPlayer::m_iFeatureProductionModifier", m_syncArchive)
	, m_iWorkerSpeedModifier("CvPlayer::m_iWorkerSpeedModifier", m_syncArchive)
	, m_iImprovementCostModifier("CvPlayer::m_iImprovementCostModifier", m_syncArchive)
	, m_iImprovementUpgradeRateModifier("CvPlayer::m_iImprovementUpgradeRateModifier", m_syncArchive)
	, m_iSpecialistProductionModifier("CvPlayer::m_iSpecialistProductionModifier", m_syncArchive)
	, m_iMilitaryProductionModifier("CvPlayer::m_iMilitaryProductionModifier", m_syncArchive)
	, m_iSpaceProductionModifier("CvPlayer::m_iSpaceProductionModifier", m_syncArchive)
	, m_iCityDefenseModifier("CvPlayer::m_iCityDefenseModifier", m_syncArchive)
	, m_iUnitFortificationModifier("CvPlayer::m_iUnitFortificationModifier", m_syncArchive)
	, m_iUnitBaseHealModifier("CvPlayer::m_iUnitBaseHealModifier", m_syncArchive)
	, m_iWonderProductionModifier("CvPlayer::m_iWonderProductionModifier", m_syncArchive)
	, m_iSettlerProductionModifier("CvPlayer::m_iSettlerProductionModifier", m_syncArchive)
	, m_iCapitalSettlerProductionModifier("CvPlayer::m_iCapitalSettlerProductionModifier", m_syncArchive)
	, m_iUnitProductionMaintenanceMod("CvPlayer::m_iUnitProductionMaintenanceMod", m_syncArchive)
	, m_iPolicyCostBuildingModifier("CvPlayer::m_iPolicyCostBuildingModifier", m_syncArchive)
	, m_iPolicyCostMinorCivModifier("CvPlayer::m_iPolicyCostMinorCivModifier", m_syncArchive)
	, m_iInfluenceSpreadModifier("CvPlayer::m_iInfluenceSpreadModifier", m_syncArchive)
	, m_iExtraVotesPerDiplomat("CvPlayer::m_iExtraVotesPerDiplomat", m_syncArchive)
	, m_iNumNukeUnits("CvPlayer::m_iNumNukeUnits", m_syncArchive)
	, m_iNumOutsideUnits("CvPlayer::m_iNumOutsideUnits", m_syncArchive, true)
	, m_iBaseFreeUnits("CvPlayer::m_iBaseFreeUnits", m_syncArchive)
	, m_iBaseFreeMilitaryUnits("CvPlayer::m_iBaseFreeMilitaryUnits", m_syncArchive)
	, m_iFreeUnitsPopulationPercent("CvPlayer::m_iFreeUnitsPopulationPercent", m_syncArchive)
	, m_iFreeMilitaryUnitsPopulationPercent("CvPlayer::m_iFreeMilitaryUnitsPopulationPercent", m_syncArchive)
	, m_iGoldPerUnit("CvPlayer::m_iGoldPerUnit", m_syncArchive)
	, m_iGoldPerMilitaryUnit("CvPlayer::m_iGoldPerMilitaryUnit", m_syncArchive)
	, m_iImprovementGoldMaintenanceMod("CvPlayer::m_iImprovementGoldMaintenanceMod", m_syncArchive)
	, m_iBuildingGoldMaintenanceMod("CvPlayer::m_iBuildingGoldMaintenanceMod", m_syncArchive)
	, m_iUnitGoldMaintenanceMod("CvPlayer::m_iUnitGoldMaintenanceMod", m_syncArchive)
	, m_iUnitSupplyMod("CvPlayer::m_iUnitSupplyMod", m_syncArchive)
	, m_iExtraUnitCost("CvPlayer::m_iExtraUnitCost", m_syncArchive)
	, m_iNumMilitaryUnits("CvPlayer::m_iNumMilitaryUnits", m_syncArchive)
	, m_iHappyPerMilitaryUnit("CvPlayer::m_iHappyPerMilitaryUnit", m_syncArchive)
	, m_iHappinessToCulture("CvPlayer::m_iHappinessToCulture", m_syncArchive)
	, m_iHappinessToScience("CvPlayer::m_iHappinessToScience", m_syncArchive)
	, m_iHalfSpecialistUnhappinessCount("CvPlayer::m_iHalfSpecialistUnhappinessCount", m_syncArchive)
	, m_iHalfSpecialistFoodCount("CvPlayer::m_iHalfSpecialistFoodCount", m_syncArchive)
	, m_iMilitaryFoodProductionCount("CvPlayer::m_iMilitaryFoodProductionCount", m_syncArchive)
	, m_iGoldenAgeCultureBonusDisabledCount("CvPlayer::m_iGoldenAgeCultureBonusDisabledCount", m_syncArchive)
	, m_iSecondReligionPantheonCount("CvPlayer::m_iSecondReligionPantheonCount", m_syncArchive)
	, m_iEnablesSSPartHurryCount("CvPlayer::m_iEnablesSSPartHurryCount", m_syncArchive)
	, m_iEnablesSSPartPurchaseCount("CvPlayer::m_iEnablesSSPartPurchaseCount", m_syncArchive)
	, m_iConscriptCount("CvPlayer::m_iConscriptCount", m_syncArchive)
	, m_iMaxConscript("CvPlayer::m_iMaxConscript", m_syncArchive)
	, m_iHighestUnitLevel("CvPlayer::m_iHighestUnitLevel", m_syncArchive)
	, m_iOverflowResearch("CvPlayer::m_iOverflowResearch", m_syncArchive, true)
	, m_iExpModifier("CvPlayer::m_iExpModifier", m_syncArchive)
	, m_iExpInBorderModifier("CvPlayer::m_iExpInBorderModifier", m_syncArchive)
	, m_iLevelExperienceModifier("CvPlayer::m_iLevelExperienceModifier", m_syncArchive)
	, m_iMinorQuestFriendshipMod("CvPlayer::m_iMinorQuestFriendshipMod", m_syncArchive)
	, m_iMinorGoldFriendshipMod("CvPlayer::m_iMinorGoldFriendshipMod", m_syncArchive)
	, m_iMinorFriendshipMinimum("CvPlayer::m_iMinorFriendshipMinimum", m_syncArchive)
	, m_iMinorFriendshipDecayMod("CvPlayer::m_iMinorFriendshipDecayMod", m_syncArchive)
	, m_iMinorScienceAlliesCount("CvPlayer::m_iMinorScienceAlliesCount", m_syncArchive)
	, m_iMinorResourceBonusCount("CvPlayer::m_iMinorResourceBonusCount", m_syncArchive)
	, m_iAbleToAnnexCityStatesCount("CvPlayer::m_iAbleToAnnexCityStatesCount", m_syncArchive)
	, m_iFreeSpecialist("CvPlayer::m_iFreeSpecialist", m_syncArchive)
	, m_iCultureBombTimer("CvPlayer::m_iCultureBombTimer", m_syncArchive)
	, m_iConversionTimer("CvPlayer::m_iConversionTimer", m_syncArchive)
	, m_iCapitalCityID("CvPlayer::m_iCapitalCityID", m_syncArchive)
	, m_iCitiesLost("CvPlayer::m_iCitiesLost", m_syncArchive)
	, m_iMilitaryMight("CvPlayer::m_iMilitaryMight", m_syncArchive)
	, m_iEconomicMight("CvPlayer::m_iEconomicMight", m_syncArchive)
	, m_iTurnMightRecomputed("CvPlayer::m_iTurnMightRecomputed", m_syncArchive)
	, m_iNewCityExtraPopulation("CvPlayer::m_iNewCityExtraPopulation", m_syncArchive)
	, m_iFreeFoodBox("CvPlayer::m_iFreeFoodBox", m_syncArchive)
	, m_iScenarioScore1("CvPlayer::m_iScenarioScore1", m_syncArchive)
	, m_iScenarioScore2("CvPlayer::m_iScenarioScore2", m_syncArchive)
	, m_iScenarioScore3("CvPlayer::m_iScenarioScore3", m_syncArchive)
	, m_iScenarioScore4("CvPlayer::m_iScenarioScore4", m_syncArchive)
	, m_iScoreFromFutureTech("CvPlayer::m_iScoreFromFutureTech", m_syncArchive)
	, m_iCombatExperience("CvPlayer::m_iCombatExperience", m_syncArchive)
	, m_iLifetimeCombatExperience("CvPlayer::m_iLifetimeCombatExperience", m_syncArchive)
	, m_iNavalCombatExperience("CvPlayer::m_iNavalCombatExperience", m_syncArchive)
#if defined(MOD_UNITS_XP_TIMES_100)
	, m_iCombatExperienceTimes100("CvPlayer::m_iCombatExperienceTimes100", m_syncArchive)
	, m_iLifetimeCombatExperienceTimes100("CvPlayer::m_iLifetimeCombatExperienceTimes100", m_syncArchive)
	, m_iNavalCombatExperienceTimes100("CvPlayer::m_iNavalCombatExperienceTimes100", m_syncArchive)
#endif
	, m_iBorderObstacleCount("CvPlayer::m_iBorderObstacleCount", m_syncArchive)
	, m_iPopRushHurryCount("CvPlayer::m_iPopRushHurryCount", m_syncArchive)
	, m_iTotalImprovementsBuilt("CvPlayer::m_iTotalImprovementsBuilt", m_syncArchive)
	, m_iNextOperationID("CvPlayer::m_iNextOperationID", m_syncArchive)
	, m_iCostNextPolicy("CvPlayer::m_iCostNextPolicy", m_syncArchive)
	, m_iNumBuilders("CvPlayer::m_iNumBuilders", m_syncArchive, true)
	, m_iMaxNumBuilders("CvPlayer::m_iMaxNumBuilders", m_syncArchive)
	, m_iCityStrengthMod("CvPlayer::m_iCityStrengthMod", m_syncArchive)
	, m_iCityGrowthMod("CvPlayer::m_iCityGrowthMod", m_syncArchive)
	, m_iCapitalGrowthMod("CvPlayer::m_iCapitalGrowthMod", m_syncArchive)
	, m_iNumPlotsBought("CvPlayer::m_iNumPlotsBought", m_syncArchive)
	, m_iPlotGoldCostMod("CvPlayer::m_iPlotGoldCostMod", m_syncArchive)
	, m_iPlotCultureCostModifier("CvPlayer::m_iPlotCultureCostModifier", m_syncArchive)
	, m_iPlotCultureExponentModifier("CvPlayer::m_iPlotCultureExponentModifier", m_syncArchive)
	, m_iNumCitiesPolicyCostDiscount("CvPlayer::m_iNumCitiesPolicyCostDiscount", m_syncArchive)
	, m_iGarrisonedCityRangeStrikeModifier("CvPlayer::m_iGarrisonedCityRangeStrikeModifier", m_syncArchive)
	, m_iGarrisonFreeMaintenanceCount("CvPlayer::m_iGarrisonFreeMaintenanceCount", m_syncArchive)
	, m_iNumCitiesFreeCultureBuilding("CvPlayer::m_iNumCitiesFreeCultureBuilding", m_syncArchive)
	, m_iNumCitiesFreeFoodBuilding("CvPlayer::m_iNumCitiesFreeFoodBuilding", m_syncArchive)
	, m_iUnitPurchaseCostModifier("CvPlayer::m_iUnitPurchaseCostModifier", m_syncArchive)
	, m_iAllFeatureProduction("CvPlayer::m_iAllFeatureProduction", m_syncArchive)
	, m_iCityDistanceHighwaterMark("CvPlayer::m_iCityDistanceHighwaterMark", m_syncArchive)
	, m_iOriginalCapitalX("CvPlayer::m_iOriginalCapitalX", m_syncArchive)
	, m_iOriginalCapitalY("CvPlayer::m_iOriginalCapitalY", m_syncArchive)
	, m_iNumWonders("CvPlayer::m_iNumWonders", m_syncArchive)
	, m_iNumPolicies("CvPlayer::m_iNumPolicies", m_syncArchive)
	, m_iNumGreatPeople("CvPlayer::m_iNumGreatPeople", m_syncArchive)
	, m_uiStartTime("CvPlayer::m_uiStartTime", m_syncArchive)  // XXX save these?
	, m_bHasBetrayedMinorCiv("CvPlayer::m_bHasBetrayedMinorCiv", m_syncArchive)
	, m_bAlive("CvPlayer::m_bAlive", m_syncArchive)
	, m_bEverAlive("CvPlayer::m_bEverAlive", m_syncArchive)
	, m_bBeingResurrected("CvPlayer::m_bBeingResurrected", m_syncArchive, false, false)
	, m_bTurnActive("CvPlayer::m_bTurnActive", m_syncArchive, false, true)
	, m_bAutoMoves("CvPlayer::m_bAutoMoves", m_syncArchive, false, true)
	, m_bEndTurn("CvPlayer::m_bEndTurn", m_syncArchive, false, true)
	, m_bDynamicTurnsSimultMode("CvPlayer::m_bDynamicTurnsSimultMode", m_syncArchive, true, false)
	, m_bPbemNewTurn("CvPlayer::m_bPbemNewTurn", m_syncArchive)
	, m_bExtendedGame("CvPlayer::m_bExtendedGame", m_syncArchive)
	, m_bFoundedFirstCity("CvPlayer::m_bFoundedFirstCity", m_syncArchive)
	, m_iNumCitiesFounded("CvPlayer::m_iNumCitiesFounded", m_syncArchive)
	, m_bStrike("CvPlayer::m_bStrike", m_syncArchive)
	, m_bCramped("CvPlayer::m_bCramped", m_syncArchive)
	, m_bLostCapital("CvPlayer::m_bLostCapital", m_syncArchive)
	, m_eConqueror("CvPlayer::m_eConqueror", m_syncArchive, NO_PLAYER)
	, m_bHasAdoptedStateReligion("CvPlayer::m_bHasAdoptedStateReligion", m_syncArchive)
	, m_bAlliesGreatPersonBiasApplied("CvPlayer::m_bAlliesGreatPersonBiasApplied", m_syncArchive)
	, m_eID("CvPlayer::m_eID", m_syncArchive)
	, m_ePersonalityType("CvPlayer::m_ePersonalityType", m_syncArchive)
	, m_aiCityYieldChange("CvPlayer::m_aiCityYieldChange", m_syncArchive)
	, m_aiCoastalCityYieldChange("CvPlayer::m_aiCoastalCityYieldChange", m_syncArchive)
	, m_aiCapitalYieldChange("CvPlayer::m_aiCapitalYieldChange", m_syncArchive)
	, m_aiCapitalYieldPerPopChange("CvPlayer::m_aiCapitalYieldPerPopChange", m_syncArchive)
	, m_aiSeaPlotYield("CvPlayer::m_aiSeaPlotYield", m_syncArchive)
	, m_aiYieldRateModifier("CvPlayer::m_aiYieldRateModifier", m_syncArchive)
	, m_aiCapitalYieldRateModifier("CvPlayer::m_aiCapitalYieldRateModifier", m_syncArchive)
	, m_aiExtraYieldThreshold("CvPlayer::m_aiExtraYieldThreshold", m_syncArchive)
	, m_aiSpecialistExtraYield("CvPlayer::m_aiSpecialistExtraYield", m_syncArchive)
	, m_aiProximityToPlayer("CvPlayer::m_aiProximityToPlayer", m_syncArchive, true)
	, m_aiResearchAgreementCounter("CvPlayer::m_aiResearchAgreementCounter", m_syncArchive)
	, m_aiIncomingUnitTypes("CvPlayer::m_aiIncomingUnitTypes", m_syncArchive, true)
	, m_aiIncomingUnitCountdowns("CvPlayer::m_aiIncomingUnitCountdowns", m_syncArchive, true)
	, m_aiMinorFriendshipAnchors("CvPlayer::m_aiMinorFriendshipAnchors", m_syncArchive, true)
	, m_aiSiphonLuxuryCount("CvPlayer::m_aiSiphonLuxuryCount", m_syncArchive)
	, m_aiGreatWorkYieldChange("CvPlayer::m_aiGreatWorkYieldChange", m_syncArchive)
	, m_aOptions("CvPlayer::m_aOptions", m_syncArchive, true)
	, m_strReligionKey("CvPlayer::m_strReligionKey", m_syncArchive)
	, m_strScriptData("CvPlayer::m_strScriptData", m_syncArchive)
	, m_paiNumResourceUsed("CvPlayer::m_paiNumResourceUsed", m_syncArchive)
	, m_paiNumResourceTotal("CvPlayer::m_paiNumResourceTotal", m_syncArchive)
	, m_paiResourceGiftedToMinors("CvPlayer::m_paiResourceGiftedToMinors", m_syncArchive)
	, m_paiResourceExport("CvPlayer::m_paiResourceExport", m_syncArchive)
	, m_paiResourceImport("CvPlayer::m_paiResourceImport", m_syncArchive)
	, m_paiResourceFromMinors("CvPlayer::m_paiResourceFromMinors", m_syncArchive)
	, m_paiResourcesSiphoned("CvPlayer::m_paiResourcesSiphoned", m_syncArchive)
	, m_paiImprovementCount("CvPlayer::m_paiImprovementCount", m_syncArchive)
	, m_paiFreeBuildingCount("CvPlayer::m_paiFreeBuildingCount", m_syncArchive)
	, m_paiFreePromotionCount("CvPlayer::m_paiFreePromotionCount", m_syncArchive)
	, m_paiUnitCombatProductionModifiers("CvPlayer::m_paiUnitCombatProductionModifiers", m_syncArchive)
	, m_paiUnitCombatFreeExperiences("CvPlayer::m_paiUnitCombatFreeExperiences", m_syncArchive)
	, m_paiUnitClassCount("CvPlayer::m_paiUnitClassCount", m_syncArchive, true)
	, m_paiUnitClassMaking("CvPlayer::m_paiUnitClassMaking", m_syncArchive, true)
	, m_paiBuildingClassCount("CvPlayer::m_paiBuildingClassCount", m_syncArchive)
	, m_paiBuildingClassMaking("CvPlayer::m_paiBuildingClassMaking", m_syncArchive, true)
	, m_paiProjectMaking("CvPlayer::m_paiProjectMaking", m_syncArchive)
	, m_paiHurryCount("CvPlayer::m_paiHurryCount", m_syncArchive)
	, m_paiHurryModifier("CvPlayer::m_paiHurryModifier", m_syncArchive)
	, m_pabLoyalMember("CvPlayer::m_pabLoyalMember", m_syncArchive)
	, m_pabGetsScienceFromPlayer("CvPlayer::m_pabGetsScienceFromPlayer", m_syncArchive)
	, m_ppaaiSpecialistExtraYield("CvPlayer::m_ppaaiSpecialistExtraYield", m_syncArchive)
	, m_ppaaiImprovementYieldChange("CvPlayer::m_ppaaiImprovementYieldChange", m_syncArchive)
	, m_ppaaiBuildingClassYieldMod("CvPlayer::m_ppaaiBuildingClassYieldMod", m_syncArchive)
	, m_UnitCycle(this)
	, m_bEverPoppedGoody("CvPlayer::m_bEverPoppedGoody", m_syncArchive)
	, m_bEverTrainedBuilder("CvPlayer::m_bEverTrainedBuilder", m_syncArchive)
	, m_iCityConnectionHappiness("CvPlayer::m_iCityConnectionHappiness", m_syncArchive)
	, m_iHolyCityID("CvPlayer::m_iHolyCityID", m_syncArchive)
	, m_iTurnsSinceSettledLastCity("CvPlayer::m_iTurnsSinceSettledLastCity", m_syncArchive)
	, m_iNumNaturalWondersDiscoveredInArea("CvPlayer::m_iNumNaturalWondersDiscoveredInArea", m_syncArchive)
	, m_iStrategicResourceMod("CvPlayer::m_iStrategicResourceMod", m_syncArchive)
	, m_iSpecialistCultureChange("CvPlayer::m_iSpecialistCultureChange", m_syncArchive)
	, m_iGreatPeopleSpawnCounter("CvPlayer::m_iGreatPeopleSpawnCounter", m_syncArchive)
	, m_iFreeTechCount("CvPlayer::m_iFreeTechCount", m_syncArchive, true)
	, m_iMedianTechPercentage("CvPlayer::m_iMedianTechPercentage", m_syncArchive, 50)
	, m_iNumFreePolicies("CvPlayer::m_iNumFreePolicies", m_syncArchive)
	, m_iNumFreePoliciesEver("CvPlayer::m_iNumFreePoliciesEver", m_syncArchive)
	, m_iNumFreeTenets("CvPlayer::m_iNumFreeTenets", m_syncArchive)
	, m_iMaxEffectiveCities("CvPlayer::m_iMaxEffectiveCities", m_syncArchive, 1)
	, m_iLastSliceMoved("CvPlayer::m_iLastSliceMoved", m_syncArchive)
	, m_eEndTurnBlockingType(NO_ENDTURN_BLOCKING_TYPE)
	, m_iEndTurnBlockingNotificationIndex(0)
	, m_activeWaitingForEndTurnMessage(false)
	, m_endTurnBusyUnitUpdatesLeft(0)
	, m_lastGameTurnInitialAIProcessed(-1)
	, m_iNumFreeGreatPeople("CvPlayer::m_iNumFreeGreatPeople", m_syncArchive)
	, m_iNumMayaBoosts("CvPlayer::m_iNumMayaBoosts", m_syncArchive)
	, m_iNumFaithGreatPeople("CvPlayer::m_iNumFaithGreatPeople", m_syncArchive)
	, m_iNumArchaeologyChoices("CvPlayer::m_iNumArchaeologyChoices", m_syncArchive)
	, m_eFaithPurchaseType(NO_AUTOMATIC_FAITH_PURCHASE)
	, m_iFaithPurchaseIndex("CvPlayer::m_iFaithPurchaseIndex", m_syncArchive)
	, m_bProcessedAutoMoves(false)
	, m_kPlayerAchievements(*this)
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	, m_iUnhappiness("CvPlayer::m_iUnhappiness", m_syncArchive)
	, m_iHappinessTotal("CvPlayer::m_iHappinessTotal", m_syncArchive)
	, m_iChangePovertyUnhappinessGlobal("CvPlayer::m_iChangePovertyUnhappinessGlobal", m_syncArchive)
	, m_iChangeDefenseUnhappinessGlobal("CvPlayer::m_iChangeDefenseUnhappinessGlobal", m_syncArchive)
	, m_iChangeUnculturedUnhappinessGlobal("CvPlayer::m_iChangeUnculturedUnhappinessGlobal", m_syncArchive)
	, m_iChangeIlliteracyUnhappinessGlobal("CvPlayer::m_iChangeIlliteracyUnhappinessGlobal", m_syncArchive)
	, m_iChangeMinorityUnhappinessGlobal("CvPlayer::m_iChangeMinorityUnhappinessGlobal", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE)
	, m_iCenterOfMassX("CvPlayer::m_iCenterOfMassX", m_syncArchive)
	, m_iCenterOfMassY("CvPlayer::m_iCenterOfMassY", m_syncArchive)
	, m_bIsReformation("CvPlayer::m_bIsReformation", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE_SPIES)
	, m_iSpyCooldown("CvPlayer::m_iSpyCooldown", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE_HAPPINESS_LUXURY)
	, m_iBaseLuxuryHappiness("CvPlayer::m_iBaseLuxuryHappiness", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE_POLICIES)
	, m_iHappinessPerXPopulationGlobal("CvPlayer::m_iHappinessPerXPopulationGlobal", m_syncArchive)
	, m_iIdeologyPoint("CvPlayer::m_iIdeologyPoint", m_syncArchive)
	, m_bOrderCorp("CvPlayer::m_bOrderCorp", m_syncArchive)
	, m_bAutocracyCorp("CvPlayer::m_bAutocracyCorp", m_syncArchive)
	, m_bFreedomCorp("CvPlayer::m_bFreedomCorp", m_syncArchive)
#endif
#if defined(MOD_RELIGION_CONVERSION_MODIFIERS)
	, m_iConversionModifier("CvPlayer::m_iConversionModifier", m_syncArchive)
#endif
#if defined(MOD_DIPLOMACY_CITYSTATES)
	, m_iImprovementLeagueVotes("CvPlayer::m_iImprovementLeagueVotes", m_syncArchive)
	, m_iFaithToVotes("CvPlayer::m_iFaithToVotes", m_syncArchive)
	, m_iCapitalsToVotes("CvPlayer::m_iCapitalsToVotes", m_syncArchive)
	, m_iDoFToVotes("CvPlayer::m_iDoFToVotes", m_syncArchive)
	, m_iRAToVotes("CvPlayer::m_iRAToVotes", m_syncArchive)
	, m_iDefensePactsToVotes("CvPlayer::m_iDefensePactsToVotes", m_syncArchive)
	, m_iGPExpendInfluence("CvPlayer::m_iGPExpendInfluence", m_syncArchive)
	, m_bIsLeagueAid("CvPlayer::m_bIsLeagueAid", m_syncArchive)
	, m_bIsLeagueScholar("CvPlayer::m_bIsLeagueScholar", m_syncArchive)
	, m_bIsLeagueArt("CvPlayer::m_bIsLeagueArt", m_syncArchive)
	, m_iScienceRateFromLeague("CvPlayer::m_iScienceRateFromLeague", m_syncArchive)
	, m_iScienceRateFromLeagueAid("CvPlayer::m_iScienceRateFromLeagueAid", m_syncArchive)
	, m_iLeagueCultureCityModifier("CvPlayer::m_iLeagueCultureCityModifier", m_syncArchive)
#endif
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
	, m_iCultureBonusTurnsConquest("CvPlayer::m_iCultureBonusTurnsConquest", m_syncArchive)
	, m_iFreeGreatPeopleCreated("CvPlayer::m_iFreeGreatPeopleCreated", m_syncArchive)
	, m_iFreeGreatGeneralsCreated("CvPlayer::m_iFreeGreatGeneralsCreated", m_syncArchive)
	, m_iFreeGreatAdmiralsCreated("CvPlayer::m_iFreeGreatAdmiralsCreated", m_syncArchive)
#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
	, m_iFreeGreatMerchantsCreated("CvPlayer::m_iFreeGreatMerchantsCreated", m_syncArchive)
	, m_iFreeGreatScientistsCreated("CvPlayer::m_iFreeGreatScientistsCreated", m_syncArchive)
	, m_iFreeGreatEngineersCreated("CvPlayer::m_iFreeGreatEngineersCreated", m_syncArchive)
#endif
	, m_iFreeGreatWritersCreated("CvPlayer::m_iFreeGreatWritersCreated", m_syncArchive)
	, m_iFreeGreatArtistsCreated("CvPlayer::m_iFreeGreatArtistsCreated", m_syncArchive)
	, m_iFreeGreatMusiciansCreated("CvPlayer::m_iFreeGreatMusiciansCreated", m_syncArchive)
#if defined(MOD_DIPLOMACY_CITYSTATES)
	, m_iFreeGreatDiplomatsCreated("CvPlayer::m_iFreeGreatDiplomatsCreated", m_syncArchive)
#endif
#endif
#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
	, m_iGPExtra1Created("CvPlayer::m_iGPExtra1Created", m_syncArchive)
	, m_iGPExtra2Created("CvPlayer::m_iGPExtra2Created", m_syncArchive)
	, m_iGPExtra3Created("CvPlayer::m_iGPExtra3Created", m_syncArchive)
	, m_iGPExtra4Created("CvPlayer::m_iGPExtra4Created", m_syncArchive)
	, m_iGPExtra5Created("CvPlayer::m_iGPExtra5Created", m_syncArchive)
	, m_iGPExtra1FromFaith("CvPlayer::m_iGPExtra1FromFaith", m_syncArchive)
	, m_iGPExtra2FromFaith("CvPlayer::m_iGPExtra2FromFaith", m_syncArchive)
	, m_iGPExtra3FromFaith("CvPlayer::m_iGPExtra3FromFaith", m_syncArchive)
	, m_iGPExtra4FromFaith("CvPlayer::m_iGPExtra4FromFaith", m_syncArchive)
	, m_iGPExtra5FromFaith("CvPlayer::m_iGPExtra5FromFaith", m_syncArchive)
	, m_iFreeGPExtra1Created("CvPlayer::m_iFreeGPExtra1Created", m_syncArchive)
	, m_iFreeGPExtra2Created("CvPlayer::m_iFreeGPExtra2Created", m_syncArchive)
	, m_iFreeGPExtra3Created("CvPlayer::m_iFreeGPExtra3Created", m_syncArchive)
	, m_iFreeGPExtra4Created("CvPlayer::m_iFreeGPExtra4Created", m_syncArchive)
	, m_iFreeGPExtra5Created("CvPlayer::m_iFreeGPExtra5Created", m_syncArchive)
	, m_iGreatMerchantsCreated("CvPlayer::m_iGreatMerchantsCreated", m_syncArchive)
	, m_iGreatScientistsCreated("CvPlayer::m_iGreatScientistsCreated", m_syncArchive)
	, m_iGreatEngineersCreated("CvPlayer::m_iGreatEngineersCreated", m_syncArchive)
#endif
#if defined(MOD_DIPLOMACY_CITYSTATES)
	, m_iGreatDiplomatsCreated("CvPlayer::m_iGreatDiplomatsCreated", m_syncArchive)
	, m_iDiplomatsFromFaith("CvPlayer::m_iDiplomatsFromFaith", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE)
	, m_iHalfSpecialistFoodCapitalCount("CvPlayer::m_iHalfSpecialistFoodCapitalCount", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE)
	, m_aistrInstantYield("CvPlayer::m_aistrInstantYield", m_syncArchive)
	, m_iJFDCurrency("CvPlayer::m_iJFDCurrency", m_syncArchive)
	, m_strJFDCurrencyName("CvPlayer::m_strJFDCurrencyName", m_syncArchive)
	, m_strJFDLegislatureName("CvPlayer::m_strJFDLegislatureName", m_syncArchive)
	, m_strJFDPoliticKey("CvPlayer::m_strJFDPoliticKey", m_syncArchive)
	, m_iJFDPoliticLeader("CvPlayer::m_iJFDPoliticLeader", m_syncArchive)
	, m_iJFDSovereignty("CvPlayer::m_iJFDSovereignty", m_syncArchive)
	, m_iJFDGovernment("CvPlayer::m_iJFDGovernment", m_syncArchive)
	, m_iJFDReformCooldown("CvPlayer::m_iJFDReformCooldown", m_syncArchive)
	, m_iJFDGovernmentCooldown("CvPlayer::m_iJFDGovernmentCooldown", m_syncArchive)
	, m_iJFDReformCooldownRate("CvPlayer::m_iJFDReformCooldownRate", m_syncArchive)
	, m_iJFDGovernmentCooldownRate("CvPlayer::m_iJFDGovernmentCooldownRate", m_syncArchive)
	, m_iJFDPiety("CvPlayer::m_iJFDPiety", m_syncArchive)
	, m_iJFDPietyRate("CvPlayer::m_iJFDPietyRate", m_syncArchive)
	, m_iJFDConversionTurn("CvPlayer::m_iJFDConversionTurn", m_syncArchive)
	, m_bJFDSecularized("CvPlayer::m_bJFDSecularized", m_syncArchive)
	, m_iUpgradeCSTerritory("CvPlayer::m_iUpgradeCSTerritory", m_syncArchive)
	, m_iArchaeologicalDigTourism("CvPlayer::m_iArchaeologicalDigTourism", m_syncArchive)
	, m_iUnitDiversity("CvPlayer::m_iUnitDiversity", m_syncArchive)
	, m_iGoldenAgeTourism("CvPlayer::m_iGoldenAgeTourism", m_syncArchive)
	, m_iRazingSpeedBonus("CvPlayer::m_iRazingSpeedBonus", m_syncArchive)
	, m_iNoPartisans("CvPlayer::m_iNoPartisans", m_syncArchive)
	, m_iSpawnCooldown("CvPlayer::m_iSpawnCooldown", m_syncArchive)
	, m_iAbleToMarryCityStatesCount("CvPlayer::m_iAbleToMarryCityStatesCount", m_syncArchive)
	, m_iCorporateFounderID("CvPlayer::m_iCorporateFounderID", m_syncArchive)
	, m_iCorporateFoundedTurn("CvPlayer::m_iCorporateFoundedTurn", m_syncArchive)
	, m_iCorporationMaxFranchises("CvPlayer::m_iCorporationMaxFranchises", m_syncArchive)
	, m_iCorporateFranchises("CvPlayer::m_iCorporateFranchises", m_syncArchive)
	, m_bTradeRoutesInvulnerable("CvPlayer::m_bTradeRoutesInvulnerable", m_syncArchive)
	, m_iTRSpeedBoost("CvPlayer::m_iTRSpeedBoost", m_syncArchive)
	, m_iVotesPerGPT("CvPlayer::m_iVotesPerGPT", m_syncArchive)
	, m_iTRVisionBoost("CvPlayer::m_iTRVisionBoost", m_syncArchive)
	, m_iBuildingMaintenanceMod("CvPlayer::m_iBuildingMaintenanceMod", m_syncArchive)
	, m_iEventTourism("CvPlayer::m_iEventTourism", m_syncArchive)
	, m_iEventTourismCS("CvPlayer::m_iEventTourismCS", m_syncArchive)
	, m_iNumHistoricEvent("CvPlayer::m_iNumHistoricEvent", m_syncArchive)
	, m_iSingleVotes("CvPlayer::m_iSingleVotes", m_syncArchive)
	, m_iMonopolyModFlat("CvPlayer::m_iMonopolyModFlat", m_syncArchive)
	, m_iMonopolyModPercent("CvPlayer::m_iMonopolyModPercent", m_syncArchive)
	, m_iCachedValueOfPeaceWithHuman("CvPlayer::m_iCachedValueOfPeaceWithHuman", m_syncArchive)
	, m_iCitiesFeatureSurrounded("CvPlayer::m_iCitiesFeatureSurrounded", m_syncArchive)
	, m_aiBestMilitaryCombatClassCity("CvPlayer::m_aiBestMilitaryCombatClassCity", m_syncArchive)
	, m_aiBestMilitaryDomainCity("CvPlayer::m_aiBestMilitaryDomainCity", m_syncArchive)
	, m_aiEventChoiceDuration("CvPlayer::m_aiEventChoiceDuration", m_syncArchive)
	, m_aiEventIncrement("CvPlayer::m_aiEventIncrement", m_syncArchive)
	, m_abEventActive("CvPlayer::m_abEventActive", m_syncArchive)
	, m_abEventChoiceActive("CvPlayer::m_abEventChoiceActive", m_syncArchive)
	, m_aiEventCooldown("CvPlayer::m_aiEventCooldown", m_syncArchive)
	, m_abEventChoiceFired("CvPlayer::m_abEventChoiceFired", m_syncArchive)
	, m_abEventFired("CvPlayer::m_abEventFired", m_syncArchive)
	, m_iPlayerEventCooldown("CvPlayer::m_iPlayerEventCooldown", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	, m_iPovertyUnhappinessMod("CvPlayer::m_iPovertyUnhappinessMod", m_syncArchive)
	, m_iDefenseUnhappinessMod("CvPlayer::m_iDefenseUnhappinessMod", m_syncArchive)
	, m_iUnculturedUnhappinessMod("CvPlayer::m_iUnculturedUnhappinessMod", m_syncArchive)
	, m_iIlliteracyUnhappinessMod("CvPlayer::m_iIlliteracyUnhappinessMod", m_syncArchive)
	, m_iMinorityUnhappinessMod("CvPlayer::m_iMinorityUnhappinessMod", m_syncArchive)
	, m_iPovertyUnhappinessModCapital("CvPlayer::m_iPovertyUnhappinessModCapital", m_syncArchive)
	, m_iDefenseUnhappinessModCapital("CvPlayer::m_iDefenseUnhappinessModCapital", m_syncArchive)
	, m_iUnculturedUnhappinessModCapital("CvPlayer::m_iUnculturedUnhappinessModCapital", m_syncArchive)
	, m_iIlliteracyUnhappinessModCapital("CvPlayer::m_iIlliteracyUnhappinessModCapital", m_syncArchive)
	, m_iMinorityUnhappinessModCapital("CvPlayer::m_iMinorityUnhappinessModCapital", m_syncArchive)
	, m_iPuppetUnhappinessMod("CvPlayer::m_iPuppetUnhappinessMod", m_syncArchive)
	, m_iCapitalUnhappinessModCBP("CvPlayer::m_iCapitalUnhappinessModCBP", m_syncArchive)
	, m_iNoUnhappfromXSpecialists("CvPlayer::m_iNoUnhappfromXSpecialists", m_syncArchive)
	, m_iNoUnhappfromXSpecialistsCapital("CvPlayer::m_iNoUnhappfromXSpecialistsCapital", m_syncArchive)
	, m_iWarWearinessModifier("CvPlayer::m_iWarWearinessModifier", m_syncArchive)
#endif
#if defined(MOD_TRAITS_CITY_WORKING) || defined(MOD_BUILDINGS_CITY_WORKING) || defined(MOD_POLICIES_CITY_WORKING) || defined(MOD_TECHS_CITY_WORKING)
	, m_iCityWorkingChange("CvPlayer::m_iCityWorkingChange", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE_POLICIES)
	, m_paiJFDPoliticPercent("CvPlayer::m_paiJFDPoliticPercent", m_syncArchive)
	, m_paiResourceOverValue("CvPlayer::m_paiResourceOverValue", m_syncArchive)
	, m_aiGlobalTourismAlreadyReceived("CvPlayer::m_aiGlobalTourismAlreadyReceived", m_syncArchive)
	, m_aiYieldFromBirth("CvPlayer::m_aiYieldFromBirth", m_syncArchive)
	, m_aiYieldFromBirthCapital("CvPlayer::m_aiYieldFromBirthCapital", m_syncArchive)
	, m_aiYieldFromDeath("CvPlayer::m_aiYieldFromDeath", m_syncArchive)
	, m_aiYieldFromConstruction("CvPlayer::m_aiYieldFromConstruction", m_syncArchive)
	, m_aiYieldFromTech("CvPlayer::m_aiYieldFromTech", m_syncArchive)
	, m_aiYieldFromBorderGrowth("CvPlayer::m_aiYieldFromBorderGrowth", m_syncArchive)
	, m_aiYieldGPExpend("CvPlayer::m_aiYieldGPExpend", m_syncArchive)
	, m_aiConquerorYield("CvPlayer::m_aiConquerorYield", m_syncArchive)
	, m_aiFounderYield("CvPlayer::m_aiFounderYield", m_syncArchive)
	, m_aiReligionYieldRateModifier("CvPlayer::m_aiReligionYieldRateModifier", m_syncArchive)
	, m_aiGoldenAgeYieldMod("CvPlayer::m_aiGoldenAgeYieldMod", m_syncArchive)
	, m_paiBuildingClassCulture("CvPlayer::m_paiBuildingClassCulture", m_syncArchive)
	, m_aiDomainFreeExperiencePerGreatWorkGlobal("CvPlayer::m_aiDomainFreeExperiencePerGreatWorkGlobal", m_syncArchive)
	, m_iGarrisonsOccupiedUnhapppinessMod("CvPlayer::m_iGarrisonsOccupiedUnhapppinessMod", m_syncArchive)
	, m_iBestRangedUnitSpawnSettle("CvPlayer::m_iBestRangedUnitSpawnSettle", m_syncArchive)
	, m_iExtraMoves("CvPlayer::m_iExtraMoves", m_syncArchive)
	, m_iNoUnhappinessExpansion("CvPlayer::m_iNoUnhappinessExpansion", m_syncArchive)
	, m_iNoUnhappyIsolation("CvPlayer::m_iNoUnhappyIsolation", m_syncArchive)
	, m_iDoubleBorderGA("CvPlayer::m_iDoubleBorderGA", m_syncArchive)
	, m_iIncreasedQuestInfluence("CvPlayer::m_iIncreasedQuestInfluence", m_syncArchive)
	, m_iCitadelBoost("CvPlayer::m_iCitadelBoost", m_syncArchive)
	, m_iPuppetProdMod("CvPlayer::m_iPuppetProdMod", m_syncArchive)
	, m_iOccupiedProdMod("CvPlayer::m_iOccupiedProdMod", m_syncArchive)
	, m_iGoldInternalTrade("CvPlayer::m_iGoldInternalTrade", m_syncArchive)
	, m_iFreeWCVotes("CvPlayer::m_iFreeWCVotes", m_syncArchive)
	, m_iInfluenceGPExpend("CvPlayer::m_iInfluenceGPExpend", m_syncArchive)
	, m_iFreeTradeRoute("CvPlayer::m_iFreeTradeRoute", m_syncArchive)
	, m_iFreeSpy("CvPlayer::m_iFreeSpy", m_syncArchive)
	, m_iReligionDistance("CvPlayer::m_iReligionDistance", m_syncArchive)
	, m_iPressureMod("CvPlayer::m_iPressureMod", m_syncArchive)
	, m_iTradeReligionModifier("CvPlayer::m_iTradeReligionModifier", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE_SPIES)
	, m_iAdvancedActionGold("CvPlayer::m_iAdvancedActionGold", m_syncArchive)
	, m_iAdvancedActionScience("CvPlayer::m_iAdvancedActionScience", m_syncArchive)
	, m_iAdvancedActionUnrest("CvPlayer::m_iAdvancedActionUnrest", m_syncArchive)
	, m_iAdvancedActionRebellion("CvPlayer::m_iAdvancedActionRebellion", m_syncArchive)
	, m_iAdvancedActionGP("CvPlayer::m_iAdvancedActionGP", m_syncArchive)
	, m_iAdvancedActionUnit("CvPlayer::m_iAdvancedActionUnit", m_syncArchive)
	, m_iAdvancedActionWonder("CvPlayer::m_iAdvancedActionWonder", m_syncArchive)
	, m_iAdvancedActionBuilding("CvPlayer::m_iAdvancedActionBuilding", m_syncArchive)
	, m_iCannotFailSpies("CvPlayer::m_iCannotFailSpies", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE_BUILDING_INVESTMENTS)
	, m_iInvestmentModifier("CvPlayer::m_iInvestmentModifier", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE)
	, m_paiNumCitiesFreeChosenBuilding("CvPlayer::m_paiNumCitiesFreeChosenBuilding", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	, m_pabHasGlobalMonopoly("CvPlayer::m_pabHasGlobalMonopoly", m_syncArchive)
	, m_pabHasStrategicMonopoly("CvPlayer::m_pabHasStrategicMonopoly", m_syncArchive)
#endif
#if defined(MOD_API_UNIFIED_YIELDS)
	, m_piGoldenAgeGreatPersonRateModifier(NULL)
	, m_piYieldFromKills(NULL)
	, m_piYieldFromBarbarianKills(NULL)
	, m_piYieldChangeTradeRoute(NULL)
	, m_piYieldChangesNaturalWonder(NULL)
	, m_piYieldChangeWorldWonder(NULL)
	, m_piYieldFromMinorDemand(NULL)
	, m_piCityFeatures(NULL)
	, m_piNumBuildings(NULL)
	, m_ppiBuildingClassYieldChange("CvPlayer::m_ppiBuildingClassYieldChange", m_syncArchive)
#endif
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	, m_iVassalGoldMaintenanceMod("CvPlayer::m_iVassalGoldMaintenanceMod", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE_SETTLER)
	, m_iFoundValueOfCapital("CvPlayer::m_iFoundValueOfCapital", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE_MILITARY)
	, m_iFractionOriginalCapitalsUnderControl("CvPlayer::m_iFractionOriginalCapitalsUnderControl", m_syncArchive)
#endif
{
	m_pPlayerPolicies = FNEW(CvPlayerPolicies, c_eCiv5GameplayDLL, 0);
	m_pEconomicAI = FNEW(CvEconomicAI, c_eCiv5GameplayDLL, 0);
	m_pMilitaryAI = FNEW(CvMilitaryAI, c_eCiv5GameplayDLL, 0);
	m_pCitySpecializationAI = FNEW(CvCitySpecializationAI, c_eCiv5GameplayDLL, 0);
	m_pWonderProductionAI = FNEW(CvWonderProductionAI(this, GC.GetGameBuildings()), c_eCiv5GameplayDLL, 0);
	m_pGrandStrategyAI = FNEW(CvGrandStrategyAI, c_eCiv5GameplayDLL, 0);
	m_pDiplomacyAI = FNEW(CvDiplomacyAI, c_eCiv5GameplayDLL, 0);
	m_pReligions = FNEW(CvPlayerReligions, c_eCiv5GameplayDLL, 0);
	m_pReligionAI = FNEW(CvReligionAI, c_eCiv5GameplayDLL, 0);
	m_pPlayerTechs = FNEW(CvPlayerTechs, c_eCiv5GameplayDLL, 0);
	m_pFlavorManager = FNEW(CvFlavorManager, c_eCiv5GameplayDLL, 0);
	m_pTacticalAI = FNEW(CvTacticalAI, c_eCiv5GameplayDLL, 0);
	m_pHomelandAI = FNEW(CvHomelandAI, c_eCiv5GameplayDLL, 0);
	m_pMinorCivAI = FNEW(CvMinorCivAI, c_eCiv5GameplayDLL, 0);
	m_pDealAI = FNEW(CvDealAI, c_eCiv5GameplayDLL, 0);
	m_pBuilderTaskingAI = FNEW(CvBuilderTaskingAI, c_eCiv5GameplayDLL, 0);
	m_pDangerPlots = FNEW(CvDangerPlots, c_eCiv5GameplayDLL, 0);
#if defined(MOD_BALANCE_CORE_SETTLER)
	m_pCityDistance = FNEW(CvDistanceMap, c_eCiv5GameplayDLL, 0);
#endif
	m_pCityConnections = FNEW(CvCityConnections, c_eCiv5GameplayDLL, 0);
	m_pTreasury = FNEW(CvTreasury, c_eCiv5GameplayDLL, 0);
	m_pTraits = FNEW(CvPlayerTraits, c_eCiv5GameplayDLL, 0);
	m_pEspionage = FNEW(CvPlayerEspionage, c_eCiv5GameplayDLL, 0);
	m_pEspionageAI = FNEW(CvEspionageAI, c_eCiv5GameplayDLL, 0);
	m_pTrade = FNEW(CvPlayerTrade, c_eCiv5GameplayDLL, 0);
	m_pTradeAI = FNEW(CvTradeAI, c_eCiv5GameplayDLL, 0);
	m_pLeagueAI = FNEW(CvLeagueAI, c_eCiv5GameplayDLL, 0);
	m_pCulture = FNEW(CvPlayerCulture, c_eCiv5GameplayDLL, 0);

	m_pNotifications = NULL;
	m_pDiplomacyRequests = NULL;

	m_iNextOperationID = 0;

	m_aiPlots.clear();
	m_bfEverConqueredBy.ClearAll();

	m_aiGreatWorkYieldChange.clear();
	m_aiSiphonLuxuryCount.clear();

	reset(NO_PLAYER, true);
}
//	--------------------------------------------------------------------------------
CvPlayer::~CvPlayer()
{
	uninit();

	SAFE_DELETE(m_pDangerPlots);
#if defined(MOD_BALANCE_CORE_SETTLER)
	SAFE_DELETE(m_pCityDistance);
#endif
	delete m_pPlayerPolicies;
	delete m_pEconomicAI;
	delete m_pMilitaryAI;
	delete m_pCitySpecializationAI;
	delete m_pWonderProductionAI;
	delete m_pGrandStrategyAI;
	delete m_pDiplomacyAI;
	delete m_pReligions;
	delete m_pReligionAI;
	delete m_pPlayerTechs;
	delete m_pFlavorManager;
	delete m_pTacticalAI;
	delete m_pHomelandAI;
	delete m_pMinorCivAI;
	delete m_pDealAI;
	delete m_pBuilderTaskingAI;
	SAFE_DELETE(m_pCityConnections);
	SAFE_DELETE(m_pNotifications);
	SAFE_DELETE(m_pDiplomacyRequests);
	SAFE_DELETE(m_pTreasury);
	SAFE_DELETE(m_pTraits);
	SAFE_DELETE(m_pEspionage);
	SAFE_DELETE(m_pEspionageAI);
	SAFE_DELETE(m_pTrade);
	SAFE_DELETE(m_pTradeAI);
	SAFE_DELETE(m_pLeagueAI);
}


//	--------------------------------------------------------------------------------
void CvPlayer::init(PlayerTypes eID)
{
	LeaderHeadTypes eBestPersonality;
	int iValue;
	int iBestValue;
	int iI, iJ;

	// only allocate notifications for civs that players can play as
	if(eID < MAX_MAJOR_CIVS)
	{
		if (!m_pNotifications)
			m_pNotifications = FNEW(CvNotifications, c_eCiv5GameplayDLL, 0);
		if (!m_pDiplomacyRequests)
			m_pDiplomacyRequests = FNEW(CvDiplomacyRequests, c_eCiv5GameplayDLL, 0);
	}

	//--------------------------------
	// Init saved data
	reset(eID);

	//--------------------------------
	// Init containers
	m_cities.RemoveAll();

	m_units.RemoveAll();

	m_armyAIs.RemoveAll();

	m_AIOperations.clear();

	//--------------------------------
	// Init non-saved data
	setupGraphical();

	//--------------------------------
	// Init other game data
	CvAssert(getTeam() != NO_TEAM);
	GET_TEAM(getTeam()).changeNumMembers(1);

#if defined(MOD_BALANCE_CORE)
	GET_TEAM(getTeam()).addPlayer( GetID() );
#endif

	PlayerTypes p = GetID();
	SlotStatus s = CvPreGame::slotStatus(p);
	if((s == SS_TAKEN) || (s == SS_COMPUTER))
	{
		setAlive(true);

		if(GC.getGame().isOption(GAMEOPTION_RANDOM_PERSONALITIES))
		{
			if(!isBarbarian() && !isMinorCiv())
			{
				iBestValue = 0;
				eBestPersonality = NO_LEADER;

				for(iI = 0; iI < GC.getNumLeaderHeadInfos(); iI++)
				{
					if(iI != GC.getBARBARIAN_LEADER() && iI != GC.getMINOR_CIVILIZATION())
					{
						iValue = (1 + GC.getGame().getJonRandNum(10000, "Choosing Personality"));

						for(iJ = 0; iJ < MAX_CIV_PLAYERS; iJ++)
						{
							if(GET_PLAYER((PlayerTypes)iJ).isAlive())
							{
								if(GET_PLAYER((PlayerTypes)iJ).getPersonalityType() == ((LeaderHeadTypes)iI))
								{
									iValue /= 2;
								}
							}
						}

						if(iValue > iBestValue)
						{
							iBestValue = iValue;
							eBestPersonality = ((LeaderHeadTypes)iI);
						}
					}
				}

				if(eBestPersonality != NO_LEADER)
				{
					setPersonalityType(eBestPersonality);
				}
			}
		}

		CvAssert(m_pTraits);
		m_pTraits->InitPlayerTraits();

		// Special handling for the Polynesian trait's overriding of embarked unit graphics
		if(m_pTraits->IsEmbarkedAllWater())
		{
			SetEmbarkedGraphicOverride("ART_DEF_UNIT_U_POLYNESIAN_WAR_CANOE");
		}
		else if(m_pTraits->IsEmbarkedToLandFlatCost())
		{
			SetEmbarkedGraphicOverride("ART_DEF_UNIT_U_DANISH_LONGBOAT");
		}

		changeGoldPerUnitTimes100(GC.getINITIAL_GOLD_PER_UNIT_TIMES_100());

		ChangeMaxNumBuilders(GC.getDEFAULT_MAX_NUM_BUILDERS());

		changeLevelExperienceModifier(GetPlayerTraits()->GetLevelExperienceModifier());
		changeMaxGlobalBuildingProductionModifier(GetPlayerTraits()->GetMaxGlobalBuildingProductionModifier());
		changeMaxTeamBuildingProductionModifier(GetPlayerTraits()->GetMaxTeamBuildingProductionModifier());
		changeMaxPlayerBuildingProductionModifier(GetPlayerTraits()->GetMaxPlayerBuildingProductionModifier());
		ChangePlotGoldCostMod(GetPlayerTraits()->GetPlotBuyCostModifier());
#if defined(MOD_TRAITS_CITY_WORKING)
		ChangeCityWorkingChange(GetPlayerTraits()->GetCityWorkingChange());
#endif
		ChangePlotCultureCostModifier(GetPlayerTraits()->GetPlotCultureCostModifier());
		GetTreasury()->ChangeCityConnectionTradeRouteGoldChange(GetPlayerTraits()->GetCityConnectionTradeRouteChange());
		changeWonderProductionModifier(GetPlayerTraits()->GetWonderProductionModifier());
		ChangeImprovementGoldMaintenanceMod(GetPlayerTraits()->GetImprovementMaintenanceModifier());

		for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
		{
#if defined(MOD_BUGFIX_MINOR)
			ChangeCityYieldChangeTimes100((YieldTypes)iJ, 100 * GetPlayerTraits()->GetFreeCityYield((YieldTypes)iJ));
#else
			ChangeCityYieldChange((YieldTypes)iJ, 100 * GetPlayerTraits()->GetFreeCityYield((YieldTypes)iJ));
#endif
			changeYieldRateModifier((YieldTypes)iJ, GetPlayerTraits()->GetYieldRateModifier((YieldTypes)iJ));
		}

		recomputeGreatPeopleModifiers();

		for(iI = 0; iI < NUM_YIELD_TYPES; iI++)
		{
			updateExtraYieldThreshold((YieldTypes)iI);
		}
#if defined(MOD_BALANCE_CORE_SETTLER_ADVANCED)
		int iBuildingMid = 0;
		int iBuildingLate = 0;
#endif
#if defined(MOD_BALANCE_CORE)
		if(GetAdvancedActionGold() < 4)
		{
			changeAdvancedActionGold(4);
		}
		if(GetAdvancedActionScience() < 4)
		{
			changeAdvancedActionScience(4);
		}
		if(GetAdvancedActionUnrest() < 2)
		{
			changeAdvancedActionUnrest(2);
		}
		if(GetAdvancedActionRebellion() < 2)
		{
			changeAdvancedActionRebellion(2);
		}
		if(GetAdvancedActionGP() < 2)
		{
			changeAdvancedActionGP(2);
		}
		if(GetAdvancedActionWonder() < 2)
		{
			changeAdvancedActionWonder(2);
		}
		if(GetAdvancedActionBuilding() < 2)
		{
			changeAdvancedActionBuilding(2);
		}
		if(GetPlayerTraits()->GetEventTourismBoost() > 0)
		{
			ChangeEventTourism(GetPlayerTraits()->GetEventTourismBoost());
		}
		if(GetPlayerTraits()->GetStartingSpyRank() > 0)
		{
			ChangeStartingSpyRank(GetPlayerTraits()->GetStartingSpyRank());
		}
#endif
		CvCivilizationInfo& playerCivilizationInfo = getCivilizationInfo();
#if defined(MOD_BALANCE_CORE_SETTLER_ADVANCED)
		if(MOD_BALANCE_CORE_SETTLER_ADVANCED)
		{
			for(iI = 0; iI < GC.getNumUnitClassInfos(); ++iI)
			{
				const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
				CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
				if(pkUnitClassInfo != NULL)
				{
					const UnitTypes eUnit = ((UnitTypes)(playerCivilizationInfo.getCivilizationUnits(iI)));
					if(NO_UNIT != eUnit)
					{
						CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
						if(pkUnitInfo->IsFoodProduction() && (pkUnitInfo->IsFoundMid()))
						{
							for(int iJ = 0; iJ < GC.getNumBuildingClassInfos(); iJ++)
							{
								const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iJ);
								CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
								if(pkBuildingClassInfo)
								{
									const BuildingTypes eBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(iJ)));
									if(NO_BUILDING != eBuilding)
									{
										CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
										if(pkBuildingInfo)
										{
											if(pkUnitInfo->GetBuildOnFound(iJ))
											{
												iBuildingMid++;
											}
										}
									}
								}
							}
						}
						if(pkUnitInfo->IsFoodProduction() && (pkUnitInfo->IsFoundLate()))
						{
							for(int iJ = 0; iJ < GC.getNumBuildingClassInfos(); iJ++)
							{
								const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iJ);
								CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
								if(pkBuildingClassInfo)
								{
									const BuildingTypes eBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(iJ)));
									if(NO_BUILDING != eBuilding)
									{
										CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
										if(pkBuildingInfo)
										{
											if(pkUnitInfo->GetBuildOnFound(iJ))
											{
												iBuildingLate++;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
#endif
		for(iI = 0; iI < GC.getNumUnitClassInfos(); ++iI)
		{
			const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
			CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
			if(pkUnitClassInfo != NULL)
			{
				const UnitTypes eUnit = ((UnitTypes)(playerCivilizationInfo.getCivilizationUnits(iI)));
				if(NO_UNIT != eUnit)
				{
					CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
#if defined(MOD_BALANCE_CORE_SETTLER_ADVANCED)
					if(pkUnitInfo != NULL && pkUnitInfo->IsFoundLate())
					{
						if(iBuildingMid > 0 && pkUnitInfo->IsFoodProduction())
						{
							setUnitExtraCost(eUnitClass, (40 * iBuildingLate));
						}
					}
					else if(pkUnitInfo != NULL && pkUnitInfo->IsFoundMid())
					{
						if(iBuildingMid > 0 && pkUnitInfo->IsFoodProduction())
						{
							setUnitExtraCost(eUnitClass, (40 * iBuildingMid));
						}
					}
					else
#endif
					if(NULL != pkUnitInfo && pkUnitInfo->IsFound())
					{
						setUnitExtraCost(eUnitClass, getNewCityProductionValue());
					}
				}
			}
		}

		BuildingTypes eFreeBuilding = GetPlayerTraits()->GetFreeBuilding();
		if(eFreeBuilding != NO_BUILDING)
		{
#if defined(MOD_BALANCE_CORE)
			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eFreeBuilding);
			if(pkBuildingInfo)
			{
				int iNumBuilding = GetPlayerTraits()->GetNumFreeBuildings();
				if(iNumBuilding > 0)
				{
					ChangeNumCitiesFreeChosenBuilding((BuildingClassTypes)pkBuildingInfo->GetBuildingClassType(), iNumBuilding);
				}
				else
				{
					changeFreeBuildingCount(eFreeBuilding, 1);
				}
			}
#else
					changeFreeBuildingCount(eFreeBuilding, 1);
#endif
		}

		SetGreatGeneralCombatBonus(GC.getGREAT_GENERAL_STRENGTH_MOD());
	}
#if defined(MOD_BALANCE_CORE)
	if(MOD_BALANCE_CORE_SPIES_ADVANCED)
	{
		setAdvancedActionGold(10);
		setAdvancedActionScience(10);
		setAdvancedActionUnrest(4);
		setAdvancedActionRebellion(4);
		setAdvancedActionGP(5);
		setAdvancedActionUnit(6);
		setAdvancedActionWonder(6);
		setAdvancedActionBuilding(6);
	}
	SetBaseLuxuryHappiness(0);
	GET_TEAM(getTeam()).DoUpdateBestRoute();
#endif

	m_aiPlots.clear();
	m_bfEverConqueredBy.ClearAll();

	AI_init();
}


//	--------------------------------------------------------------------------------
void CvPlayer::uninit()
{
	m_paiNumResourceUsed.clear();
	m_paiNumResourceTotal.clear();
	m_paiResourceGiftedToMinors.clear();
	m_paiResourceExport.clear();
	m_paiResourceImport.clear();
	m_paiResourceFromMinors.clear();
	m_paiResourcesSiphoned.clear();
	m_paiImprovementCount.clear();
	m_paiFreeBuildingCount.clear();
	m_paiFreePromotionCount.clear();
	m_paiUnitCombatProductionModifiers.clear();
	m_paiUnitCombatFreeExperiences.clear();
	m_paiUnitClassCount.clear();
	m_paiUnitClassMaking.clear();
	m_paiBuildingClassCount.clear();
	m_paiBuildingClassMaking.clear();
	m_paiProjectMaking.clear();
	m_paiHurryCount.clear();
	m_paiHurryModifier.clear();
#if defined(MOD_BALANCE_CORE)
	m_paiNumCitiesFreeChosenBuilding.clear();
	m_aistrInstantYield.clear();
#endif
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	m_pabHasGlobalMonopoly.clear();
	m_pabHasStrategicMonopoly.clear();
	m_vResourcesWGlobalMonopoly.clear();
	m_vResourcesWStrategicMonopoly.clear();
#endif
	m_pabLoyalMember.clear();
	m_pabGetsScienceFromPlayer.clear();

	m_pPlayerPolicies->Uninit();
	m_pEconomicAI->Uninit();
	m_pMilitaryAI->Uninit();
	m_pCitySpecializationAI->Uninit();
	m_pWonderProductionAI->Uninit();
	m_pGrandStrategyAI->Uninit();
	m_pDiplomacyAI->Uninit();
	m_pReligions->Uninit();
	m_pReligionAI->Uninit();
	m_pEspionage->Uninit();
	m_pEspionageAI->Uninit();
	m_pTrade->Uninit();
	m_pTradeAI->Uninit();
	m_pLeagueAI->Uninit();
	m_pPlayerTechs->Uninit();
	m_pFlavorManager->Uninit();
	m_pTacticalAI->Uninit();
	m_pHomelandAI->Uninit();
	m_pMinorCivAI->Uninit();
	m_pDealAI->Uninit();
	m_pBuilderTaskingAI->Uninit();
	m_pCityConnections->Uninit();
	if(m_pNotifications)
	{
		m_pNotifications->Uninit();
	}
	if(m_pDiplomacyRequests)
	{
		m_pDiplomacyRequests->Uninit();
	}
	m_pTreasury->Uninit();
	m_pTraits->Uninit();

	if(m_pDangerPlots)
	{
		m_pDangerPlots->Uninit();
	}

#if defined(MOD_BALANCE_CORE_SETTLER)
	m_pCityDistance->Reset();
#endif

	m_ppaaiSpecialistExtraYield.clear();
#if defined(MOD_API_UNIFIED_YIELDS) && defined(MOD_API_PLOT_YIELDS)
	m_ppiPlotYieldChange.clear();
#endif
#if defined(MOD_API_UNIFIED_YIELDS)
	m_ppiImprovementYieldChange.clear();
	m_ppiFeatureYieldChange.clear();
	m_ppiResourceYieldChange.clear();
	m_ppiTerrainYieldChange.clear();
	m_ppiTradeRouteYieldChange.clear();
	m_ppiSpecialistYieldChange.clear();
	m_ppiGreatPersonExpendedYield.clear();
	m_piGoldenAgeGreatPersonRateModifier.clear();
	m_ppiUnimprovedFeatureYieldChange.clear();
	m_ppiCityYieldFromUnimprovedFeature.clear();
	m_piYieldFromKills.clear();
	m_piYieldFromBarbarianKills.clear();
	m_ppiBuildingClassYieldChange.clear();
	m_ppiApproachScratchValue.clear();
#endif
	m_ppaaiImprovementYieldChange.clear();
	m_ppaaiBuildingClassYieldMod.clear();

	m_UnitCycle.Clear();

	m_researchQueue.clear();

	m_cityNames.clear();

	// loop through all entries freeing them up
	std::map<int , CvAIOperation*>::iterator iter;
	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
	{
		delete(iter->second);
	}
	m_AIOperations.clear();

	m_aiPlots.clear();
	m_bfEverConqueredBy.ClearAll();

	FAutoArchive& archive = getSyncArchive();
	archive.clearDelta();

	m_iStartingX = INVALID_PLOT_COORD;
	m_iStartingY = INVALID_PLOT_COORD;
	m_iTotalPopulation = 0;
	m_iTotalLand = 0;
	m_iTotalLandScored = 0;
	m_iCityConnectionHappiness = 0;
	m_iJONSCulturePerTurnForFree = 0;
	m_iJONSCulturePerTurnFromMinorCivs = 0;
	m_iJONSCultureCityModifier = 0;
	m_iJONSCulture = 0;
	m_iJONSCultureEverGenerated = 0;
	m_iCulturePerWonder = 0;
	m_iCultureWonderMultiplier = 0;
	m_iCulturePerTechResearched = 0;
	m_iFaith = 0;
	m_iFaithEverGenerated = 0;
	m_iHappiness = 0;
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	m_iUnhappiness = 0;
	m_iHappinessTotal = 0;
	m_iChangePovertyUnhappinessGlobal = 0;
	m_iChangeDefenseUnhappinessGlobal = 0;
	m_iChangeUnculturedUnhappinessGlobal = 0;
	m_iChangeIlliteracyUnhappinessGlobal = 0;
	m_iChangeMinorityUnhappinessGlobal = 0;
#endif
#if defined(MOD_BALANCE_CORE)
	m_iCenterOfMassX = 0;
	m_iCenterOfMassY = 0;
	m_bIsReformation = false;
#endif
#if defined(MOD_BALANCE_CORE_SPIES)
	m_iSpyCooldown = 0;
#endif
#if defined(MOD_BALANCE_CORE_HAPPINESS_LUXURY)
	m_iBaseLuxuryHappiness = 0;
#endif
	m_iUprisingCounter = 0;
	m_iExtraHappinessPerLuxury = 0;
	m_iUnhappinessFromUnits = 0;
	m_iUnhappinessFromUnitsMod = 0;
	m_iUnhappinessMod = 0;
	m_iCityCountUnhappinessMod = 0;
	m_iOccupiedPopulationUnhappinessMod = 0;
	m_iCapitalUnhappinessMod = 0;
	m_iCityRevoltCounter = 0;
	m_iHappinessPerGarrisonedUnitCount = 0;
	m_iHappinessPerTradeRouteCount = 0;
	m_iHappinessPerXPopulation = 0;
#if defined(MOD_BALANCE_CORE_POLICIES)
	m_iHappinessPerXPopulationGlobal = 0;
	m_iIdeologyPoint = 0;
	m_bOrderCorp = 0;
	m_bAutocracyCorp = 0;
	m_bFreedomCorp = 0;
#endif
	m_iHappinessFromLeagues = 0;
	m_iEspionageModifier = 0;
	m_iSpyStartingRank = 0;
#if defined(MOD_RELIGION_CONVERSION_MODIFIERS)
	m_iConversionModifier = 0;
#endif
	m_iExtraLeagueVotes = 0;
#if defined(MOD_DIPLOMACY_CITYSTATES)
	m_iImprovementLeagueVotes = 0;
	m_iFaithToVotes = 0;
	m_iCapitalsToVotes = 0;
	m_iDoFToVotes = 0;
	m_iRAToVotes = 0;
	m_iDefensePactsToVotes = 0;
	m_iGPExpendInfluence = 0;
	m_bIsLeagueAid = false;
	m_bIsLeagueScholar = false;
	m_bIsLeagueArt = false;
	m_iScienceRateFromLeague = 0;
	m_iScienceRateFromLeagueAid = 0;
	m_iLeagueCultureCityModifier = 0;
#endif
	m_iSpecialPolicyBuildingHappiness = 0;
	m_iWoundedUnitDamageMod = 0;
	m_iUnitUpgradeCostMod = 0;
	m_iBarbarianCombatBonus = 0;
	m_iAlwaysSeeBarbCampsCount = 0;
	m_iHappinessFromBuildings = 0;
	m_iHappinessPerCity = 0;
	m_iHappinessPerXPolicies = 0;
	m_iAdvancedStartPoints = -1;
	m_iAttackBonusTurns = 0;
	m_iCultureBonusTurns = 0;
	m_iTourismBonusTurns = 0;
	m_iGoldenAgeProgressMeter = 0;
	m_iGoldenAgeMeterMod = 0;
	m_iNumGoldenAges = 0;
	m_iGoldenAgeTurns = 0;
	m_iNumUnitGoldenAges = 0;
	m_iStrikeTurns = 0;
	m_iGoldenAgeModifier = 0;
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
	m_iCultureBonusTurnsConquest = 0;
	m_iFreeGreatPeopleCreated = 0;
	m_iFreeGreatGeneralsCreated = 0;
	m_iFreeGreatAdmiralsCreated = 0;
#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
	m_iFreeGreatMerchantsCreated = 0;
	m_iFreeGreatScientistsCreated = 0;
	m_iFreeGreatEngineersCreated = 0;
#endif
	m_iFreeGreatWritersCreated = 0;
	m_iFreeGreatArtistsCreated = 0;
	m_iFreeGreatMusiciansCreated = 0;
#if defined(MOD_DIPLOMACY_CITYSTATES)
	m_iFreeGreatDiplomatsCreated = 0;
#endif
#endif
	m_iGreatPeopleCreated = 0;
	m_iGreatGeneralsCreated = 0;
	m_iGreatAdmiralsCreated = 0;
#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
	m_iGPExtra1Created = 0;
	m_iGPExtra2Created = 0;
	m_iGPExtra3Created = 0;
	m_iGPExtra4Created = 0;
	m_iGPExtra5Created = 0;
	m_iFreeGPExtra1Created = 0;
	m_iFreeGPExtra2Created = 0;
	m_iFreeGPExtra3Created = 0;
	m_iFreeGPExtra4Created = 0;
	m_iFreeGPExtra5Created = 0;
	m_iGPExtra1FromFaith = 0;
	m_iGPExtra2FromFaith = 0;
	m_iGPExtra3FromFaith = 0;
	m_iGPExtra4FromFaith = 0;
	m_iGPExtra5FromFaith = 0;
	m_iGreatMerchantsCreated = 0;
	m_iGreatScientistsCreated = 0;
	m_iGreatEngineersCreated = 0;
#endif
	m_iGreatWritersCreated = 0;
	m_iGreatArtistsCreated = 0;
	m_iGreatMusiciansCreated = 0;
#if defined(MOD_DIPLOMACY_CITYSTATES)
	m_iGreatDiplomatsCreated = 0;
	m_iDiplomatsFromFaith = 0;
#endif
	m_iMerchantsFromFaith = 0;
	m_iScientistsFromFaith = 0;
	m_iWritersFromFaith = 0;
	m_iArtistsFromFaith = 0;
	m_iMusiciansFromFaith = 0;
	m_iGeneralsFromFaith = 0;
	m_iAdmiralsFromFaith = 0;
	m_iEngineersFromFaith = 0;
	m_iGreatPeopleThresholdModifier = 0;
	m_iGreatGeneralsThresholdModifier = 0;
	m_iGreatAdmiralsThresholdModifier = 0;
	m_iGreatGeneralCombatBonus = 0;
	m_iAnarchyNumTurns = 0;
	m_iPolicyCostModifier = 0;
	m_iGreatPeopleRateModifier = 0;
	m_iGreatPeopleRateModFromBldgs = 0;
	m_iGreatGeneralRateModifier = 0;
	m_iGreatGeneralRateModFromBldgs = 0;
	m_iDomesticGreatGeneralRateModifier = 0;
	m_iDomesticGreatGeneralRateModFromBldgs = 0;
	m_iGreatAdmiralRateModifier = 0;
	m_iGreatWriterRateModifier = 0;
	m_iGreatArtistRateModifier = 0;
	m_iGreatMusicianRateModifier = 0;
	m_iGreatMerchantRateModifier = 0;
#if defined(MOD_DIPLOMACY_CITYSTATES)
	m_iGreatDiplomatRateModifier = 0;
#endif
	m_iGreatScientistRateModifier = 0;
	m_iGreatScientistBeakerModifier = 0;
	m_iGreatEngineerRateModifier = 0;
	m_iGreatPersonExpendGold = 0;
	m_iMaxGlobalBuildingProductionModifier = 0;
	m_iMaxTeamBuildingProductionModifier = 0;
	m_iMaxPlayerBuildingProductionModifier = 0;
	m_iFreeExperience = 0;
	m_iFreeExperienceFromBldgs = 0;
	m_iFreeExperienceFromMinors = 0;
	m_iFeatureProductionModifier = 0;
	m_iWorkerSpeedModifier = 0;
	m_iImprovementCostModifier = 0;
	m_iImprovementUpgradeRateModifier = 0;
	m_iSpecialistProductionModifier = 0;
	m_iMilitaryProductionModifier = 0;
	m_iSpaceProductionModifier = 0;
	m_iCityDefenseModifier = 0;
	m_iUnitFortificationModifier = 0;
	m_iUnitBaseHealModifier = 0;
	m_iWonderProductionModifier = 0;
	m_iSettlerProductionModifier = 0;
	m_iCapitalSettlerProductionModifier = 0;
	m_iUnitProductionMaintenanceMod = 0;
	m_iPolicyCostBuildingModifier = 0;
	m_iPolicyCostMinorCivModifier = 0;
	m_iInfluenceSpreadModifier = 0;
	m_iExtraVotesPerDiplomat = 0;
	m_iNumNukeUnits = 0;
	m_iNumOutsideUnits = 0;
	m_iBaseFreeUnits = 0;
	m_iBaseFreeMilitaryUnits = 0;
	m_iFreeUnitsPopulationPercent = 0;
	m_iFreeMilitaryUnitsPopulationPercent = 0;
	m_iGoldPerUnit = 0;
	m_iGoldPerMilitaryUnit = 0;
	m_iImprovementGoldMaintenanceMod = 0;
	m_iBuildingGoldMaintenanceMod = 0;
	m_iUnitGoldMaintenanceMod = 0;
	m_iUnitSupplyMod = 0;
	m_iExtraUnitCost = 0;
	m_iNumMilitaryUnits = 0;
	m_iHappyPerMilitaryUnit = 0;
	m_iHappinessToCulture = 0;
	m_iHappinessToScience = 0;
	m_iHalfSpecialistUnhappinessCount = 0;
	m_iHalfSpecialistFoodCount = 0;
#if defined(MOD_BALANCE_CORE)
	m_iHalfSpecialistFoodCapitalCount = 0;
#endif
	m_iMilitaryFoodProductionCount = 0;
	m_iGoldenAgeCultureBonusDisabledCount = 0;
	m_iSecondReligionPantheonCount = 0;
	m_iEnablesSSPartHurryCount = 0;
	m_iEnablesSSPartPurchaseCount = 0;
	m_iConscriptCount = 0;
	m_iMaxConscript = 0;
	m_iHighestUnitLevel = 1;
	m_iOverflowResearch = 0;
	m_iExpModifier = 0;
	m_iExpInBorderModifier = 0;
	m_iLevelExperienceModifier = 0;
	m_iMinorQuestFriendshipMod = 0;
	m_iMinorGoldFriendshipMod = 0;
	m_iMinorFriendshipMinimum = 0;
	m_iMinorFriendshipDecayMod = 0;
	m_iMinorScienceAlliesCount = 0;
	m_iMinorResourceBonusCount = 0;
	m_iAbleToAnnexCityStatesCount = 0;
#if defined(MOD_BALANCE_CORE)
	m_strJFDCurrencyName = "";
	m_iJFDCurrency = -1;
	m_strJFDLegislatureName = "";
	m_strJFDPoliticKey = "";
	m_iJFDPoliticLeader = 0;
	m_iJFDSovereignty = 0;
	m_iJFDGovernment = -1;
	m_iJFDReformCooldown = 0;
	m_iJFDGovernmentCooldown = 0;
	m_iJFDGovernmentCooldownRate = 0;
	m_iJFDReformCooldownRate = 0;
	m_iJFDPiety = 0;
	m_iJFDPietyRate = 0;
	m_iJFDConversionTurn = 0;
	m_bJFDSecularized = false;
	m_iUpgradeCSTerritory = 0;
	m_iArchaeologicalDigTourism = 0;
	m_iGoldenAgeTourism = 0;
	m_iUnitDiversity = -1;
	m_iRazingSpeedBonus = 0;
	m_iNoPartisans = 0;
	m_iSpawnCooldown = 0;
	m_iAbleToMarryCityStatesCount = 0;
	m_iCorporateFounderID = 0;
	m_iCorporateFoundedTurn = 0;
	m_iCorporationMaxFranchises = 0;
	m_iCorporateFranchises = 0;
	m_bTradeRoutesInvulnerable = false;
	m_iTRSpeedBoost = 0;
	m_iVotesPerGPT = 0;
	m_iTRVisionBoost = 0;
	m_iBuildingMaintenanceMod = 0;
	m_iEventTourism = 0;
	m_iEventTourismCS = 0;
	m_iNumHistoricEvent = 0;
	m_iSingleVotes = 0;
	m_iMonopolyModFlat = 0;
	m_iMonopolyModPercent = 0;
	m_iCachedValueOfPeaceWithHuman = 0;
	m_iCitiesFeatureSurrounded = 0;
#endif
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	m_iPovertyUnhappinessMod = 0;
	m_iDefenseUnhappinessMod = 0;
	m_iUnculturedUnhappinessMod = 0;
	m_iIlliteracyUnhappinessMod = 0;
	m_iMinorityUnhappinessMod = 0;
	m_iPovertyUnhappinessModCapital = 0;
	m_iDefenseUnhappinessModCapital = 0;
	m_iUnculturedUnhappinessModCapital = 0;
	m_iIlliteracyUnhappinessModCapital = 0;
	m_iMinorityUnhappinessModCapital = 0;
	m_iPuppetUnhappinessMod = 0;
	m_iCapitalUnhappinessModCBP = 0;
	m_iNoUnhappfromXSpecialists = 0;
	m_iNoUnhappfromXSpecialistsCapital = 0;
	m_iWarWearinessModifier = 0;
	m_iPlayerEventCooldown = 0;
#endif
#if defined(MOD_BALANCE_CORE_POLICIES)
	m_iGarrisonsOccupiedUnhapppinessMod = 0;
	m_iBestRangedUnitSpawnSettle = 0;
	m_iExtraMoves = 0;
	m_iNoUnhappinessExpansion = 0;
	m_iNoUnhappyIsolation = 0;
	m_iDoubleBorderGA = 0;
	m_iIncreasedQuestInfluence = 0;
	m_iCitadelBoost = 0;
	m_iPuppetProdMod = 0;
	m_iOccupiedProdMod = 0;
	m_iGoldInternalTrade = 0;
	m_iFreeWCVotes = 0;
	m_iInfluenceGPExpend = 0;
	m_iFreeTradeRoute = 0;
	m_iFreeSpy = 0;
	m_iReligionDistance = 0;
	m_iPressureMod = 0;
	m_iTradeReligionModifier = 0;
#endif
#if defined(MOD_BALANCE_CORE_SPIES)
	m_iAdvancedActionGold = 0;
	m_iAdvancedActionScience = 0;
	m_iAdvancedActionUnrest = 0;
	m_iAdvancedActionRebellion = 0;
	m_iAdvancedActionGP = 0;
	m_iAdvancedActionUnit = 0;
	m_iAdvancedActionWonder = 0;
	m_iAdvancedActionBuilding = 0;
	m_iCannotFailSpies = 0;
#endif
#if defined(MOD_BALANCE_CORE_BUILDING_INVESTMENTS)
	m_iInvestmentModifier = 0;
#endif
	m_iCultureBombTimer = 0;
	m_iConversionTimer = 0;
	m_iCapitalCityID = -1;
	m_iCitiesLost = 0;
	m_iMilitaryMight = 0;
	m_iEconomicMight = 0;
	m_iTurnMightRecomputed = -1;
	m_iNewCityExtraPopulation = 0;
	m_iFreeFoodBox = 0;
	m_iScenarioScore1 = 0;
	m_iScenarioScore2 = 0;
	m_iScenarioScore3 = 0;
	m_iScenarioScore4 = 0;
	m_iScoreFromFutureTech = 0;
	m_iCombatExperience = 0;
	m_iLifetimeCombatExperience = 0;
	m_iNavalCombatExperience = 0;
#if defined(MOD_UNITS_XP_TIMES_100)
	m_iCombatExperienceTimes100 = 0;
	m_iLifetimeCombatExperienceTimes100 = 0;
	m_iNavalCombatExperienceTimes100 = 0;
#endif
	m_iBorderObstacleCount = 0;
	m_iPopRushHurryCount = 0;
	m_uiStartTime = 0;
	m_iTotalImprovementsBuilt = 0;
	m_iNextOperationID = 0;
	m_iCostNextPolicy = 0;
	m_iNumBuilders = 0;
	m_iMaxNumBuilders = 0;
	m_iCityStrengthMod = 0;
	m_iCityGrowthMod = 0;
	m_iCapitalGrowthMod = 0;
	m_iNumPlotsBought = 0;
	m_iPlotGoldCostMod = 0;
#if defined(MOD_TRAITS_CITY_WORKING) || defined(MOD_BUILDINGS_CITY_WORKING) || defined(MOD_POLICIES_CITY_WORKING) || defined(MOD_TECHS_CITY_WORKING)
	m_iCityWorkingChange = 0;
#endif
	m_iPlotCultureCostModifier = 0;
	m_iPlotCultureExponentModifier = 0;
	m_iNumCitiesPolicyCostDiscount = 0;
	m_iGarrisonedCityRangeStrikeModifier = 0;
	m_iGarrisonFreeMaintenanceCount = 0;
	m_iNumCitiesFreeCultureBuilding = 0;
	m_iNumCitiesFreeFoodBuilding = 0;
	m_iUnitPurchaseCostModifier = 0;
	m_iAllFeatureProduction = 0;
	m_iCityDistanceHighwaterMark = 1;
	m_iOriginalCapitalX = -1;
	m_iOriginalCapitalY = -1;
	m_iNumWonders = 0;
	m_iNumPolicies = 0;
	m_iNumGreatPeople = 0;
	m_iHolyCityID = -1;
	m_iTurnsSinceSettledLastCity = -1;
	m_iNumNaturalWondersDiscoveredInArea = 0;
	m_iStrategicResourceMod = 0;
	m_iSpecialistCultureChange = 0;
	m_iGreatPeopleSpawnCounter = 0;
	m_iFreeTechCount = 0;
	m_iMedianTechPercentage = 50;
	m_iNumFreePolicies = 0;
	m_iNumFreePoliciesEver = 0;
	m_iNumFreeTenets = 0;
	m_iNumFreeGreatPeople = 0;
	m_iNumMayaBoosts = 0;
	m_iNumFaithGreatPeople = 0;
	m_iNumArchaeologyChoices = 0;
	m_eFaithPurchaseType = NO_AUTOMATIC_FAITH_PURCHASE;
	m_iFaithPurchaseIndex = 0;
	m_iMaxEffectiveCities = 1;
	m_iLastSliceMoved = 0;

	m_bHasBetrayedMinorCiv = false;
	m_bAlive = false;
	m_bEverAlive = false;
	m_bBeingResurrected = false;
	m_bTurnActive = false;
	m_bAutoMoves = false;
	m_bProcessedAutoMoves = false;
	m_bEndTurn = false;
	m_bDynamicTurnsSimultMode = true;
	m_bPbemNewTurn = false;
	m_bExtendedGame = false;
	m_bFoundedFirstCity = false;
	m_iNumCitiesFounded = 0;
	m_bStrike = false;
	m_bCramped = false;
	m_bLostCapital = false;
	m_eConqueror = NO_PLAYER;
	m_bHasAdoptedStateReligion = false;
	m_bAlliesGreatPersonBiasApplied = false;
	m_lastGameTurnInitialAIProcessed = -1;

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	m_iVassalGoldMaintenanceMod = 0;
#endif

	m_eID = NO_PLAYER;
}


//	--------------------------------------------------------------------------------
// FUNCTION: reset()
// Initializes data members that are serialized.
void CvPlayer::reset(PlayerTypes eID, bool bConstructorCall)
{
	m_syncArchive.reset();
	//--------------------------------
	// Uninit class
	uninit();

	m_eID = eID;
	if(m_eID != NO_PLAYER)
	{
		m_ePersonalityType = CvPreGame::leaderHead(m_eID); //??? Is this repeated data???
	}
	else
	{
		m_ePersonalityType = NO_LEADER;
	}

	// tutorial info
	m_bEverPoppedGoody = false;

	m_aiCityYieldChange.clear();
	m_aiCityYieldChange.resize(NUM_YIELD_TYPES, 0);

	m_aiCoastalCityYieldChange.clear();
	m_aiCoastalCityYieldChange.resize(NUM_YIELD_TYPES, 0);

	m_aiCapitalYieldChange.clear();
	m_aiCapitalYieldChange.resize(NUM_YIELD_TYPES, 0);

	m_aiCapitalYieldPerPopChange.clear();
	m_aiCapitalYieldPerPopChange.resize(NUM_YIELD_TYPES, 0);

	m_aiSeaPlotYield.clear();
	m_aiSeaPlotYield.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldRateModifier.clear();
	m_aiYieldRateModifier.resize(NUM_YIELD_TYPES, 0);

#if defined(MOD_BALANCE_CORE_POLICIES)
	m_paiJFDPoliticPercent.clear();
	m_paiJFDPoliticPercent.resize(MAX_CIV_PLAYERS, 0);

	m_paiResourceOverValue.clear();
	m_paiResourceOverValue.resize(GC.getNumResourceInfos(), 0);

	m_aiGlobalTourismAlreadyReceived.clear();
	m_aiGlobalTourismAlreadyReceived.resize(NUM_MINOR_CIV_QUEST_TYPES, 0);

	m_aiYieldFromBirth.clear();
	m_aiYieldFromBirth.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromBirthCapital.clear();
	m_aiYieldFromBirthCapital.resize(NUM_YIELD_TYPES, 0);
	
	m_aiYieldFromDeath.clear();
	m_aiYieldFromDeath.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromConstruction.clear();
	m_aiYieldFromConstruction.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromTech.clear();
	m_aiYieldFromTech.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromBorderGrowth.clear();
	m_aiYieldFromBorderGrowth.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldGPExpend.clear();
	m_aiYieldGPExpend.resize(NUM_YIELD_TYPES, 0);

	m_aiConquerorYield.clear();
	m_aiConquerorYield.resize(NUM_YIELD_TYPES, 0);

	m_aiFounderYield.clear();
	m_aiFounderYield.resize(NUM_YIELD_TYPES, 0);

	m_aiReligionYieldRateModifier.clear();
	m_aiReligionYieldRateModifier.resize(NUM_YIELD_TYPES, 0);

	m_aiGoldenAgeYieldMod.clear();
	m_aiGoldenAgeYieldMod.resize(NUM_YIELD_TYPES, 0);

	m_paiBuildingClassCulture.clear();
	m_paiBuildingClassCulture.resize(NUM_YIELD_TYPES, 0);

	m_aiDomainFreeExperiencePerGreatWorkGlobal.clear();
	m_aiDomainFreeExperiencePerGreatWorkGlobal.resize(NUM_DOMAIN_TYPES, 0);

	m_aiBestMilitaryCombatClassCity.clear();
	m_aiBestMilitaryCombatClassCity.resize(GC.getNumUnitCombatClassInfos(), 0);

	m_aiBestMilitaryDomainCity.clear();
	m_aiBestMilitaryDomainCity.resize(NUM_DOMAIN_TYPES, 0);

	m_aiEventChoiceDuration.clear();
	m_aiEventChoiceDuration.resize(GC.getNumEventChoiceInfos(), 0);

	m_aiEventIncrement.clear();
	m_aiEventIncrement.resize(GC.getNumEventInfos(), 0);

	m_aiEventCooldown.clear();
	m_aiEventCooldown.resize(GC.getNumEventInfos(), 0);

	m_abEventActive.clear();
	m_abEventActive.resize(GC.getNumEventInfos(), false);

	m_abEventChoiceActive.clear();
	m_abEventChoiceActive.resize(GC.getNumEventChoiceInfos(), false);

	m_abEventFired.clear();
	m_abEventFired.resize(GC.getNumEventInfos(), false);

	m_abEventChoiceFired.clear();
	m_abEventChoiceFired.resize(GC.getNumEventChoiceInfos(), false);
#endif

	m_aiCapitalYieldRateModifier.clear();
	m_aiCapitalYieldRateModifier.resize(NUM_YIELD_TYPES, 0);

	m_aiGreatWorkYieldChange.clear();
	m_aiGreatWorkYieldChange.resize(NUM_YIELD_TYPES, 0);

	m_aiExtraYieldThreshold.clear();
	m_aiExtraYieldThreshold.resize(NUM_YIELD_TYPES, 0);

	m_aiSpecialistExtraYield.clear();
	m_aiSpecialistExtraYield.resize(NUM_YIELD_TYPES, 0);

	m_aiProximityToPlayer.clear();
	m_aiProximityToPlayer.resize(MAX_PLAYERS, 0);

	m_aiResearchAgreementCounter.clear();
	m_aiResearchAgreementCounter.resize(MAX_PLAYERS, 0);

	m_aiIncomingUnitTypes.clear();
	m_aiIncomingUnitTypes.resize(MAX_PLAYERS, NO_UNIT);

	m_aiIncomingUnitCountdowns.clear();
	m_aiIncomingUnitCountdowns.resize(MAX_PLAYERS, -1);

	m_aiMinorFriendshipAnchors.clear();
	m_aiMinorFriendshipAnchors.resize(MAX_PLAYERS, 0);

	m_aiSiphonLuxuryCount.clear();
	m_aiSiphonLuxuryCount.resize(MAX_PLAYERS, 0);

	m_aOptions.clear();

	m_strReligionKey = "";
	m_strScriptData = "";
	m_strEmbarkedGraphicOverride = "";

	if(!bConstructorCall)
	{
		//important, do this first
		m_cities.RemoveAll();
		m_units.RemoveAll();
		m_armyAIs.RemoveAll();

		// loop through all entries freeing them up
		std::map<int , CvAIOperation*>::iterator iter;
		for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
			delete(iter->second);
		m_AIOperations.clear();

		CvAssertMsg(0 < GC.getNumResourceInfos(), "GC.getNumResourceInfos() is not greater than zero but it is used to allocate memory in CvPlayer::reset");
		m_paiNumResourceUsed.clear();
		m_paiNumResourceUsed.resize(GC.getNumResourceInfos(), 0);

		m_paiNumResourceTotal.clear();
		m_paiNumResourceTotal.resize(GC.getNumResourceInfos(), 0);

		m_paiResourceGiftedToMinors.clear();
		m_paiResourceGiftedToMinors.resize(GC.getNumResourceInfos(), 0);

		m_paiResourceExport.clear();
		m_paiResourceExport.resize(GC.getNumResourceInfos(), 0);

		m_paiResourceImport.clear();
		m_paiResourceImport.resize(GC.getNumResourceInfos(), 0);

		m_paiResourceFromMinors.clear();
		m_paiResourceFromMinors.resize(GC.getNumResourceInfos(), 0);

		m_paiResourcesSiphoned.clear();
		m_paiResourcesSiphoned.resize(GC.getNumResourceInfos(), 0);

		CvAssertMsg(0 < GC.getNumImprovementInfos(), "GC.getNumImprovementInfos() is not greater than zero but it is used to allocate memory in CvPlayer::reset");
		m_paiImprovementCount.clear();
		m_paiImprovementCount.resize(GC.getNumImprovementInfos(), 0);

		m_paiUnitCombatProductionModifiers.clear();
		m_paiUnitCombatProductionModifiers.resize(GC.getNumUnitCombatClassInfos(), 0);

		m_paiUnitCombatFreeExperiences.clear();
		m_paiUnitCombatFreeExperiences.resize(GC.getNumUnitCombatClassInfos(), 0);

		m_paiFreeBuildingCount.clear();
		m_paiFreeBuildingCount.resize(GC.getNumBuildingInfos(), 0);

		m_paiFreePromotionCount.clear();
		m_paiFreePromotionCount.resize(GC.getNumPromotionInfos(), 0);

		m_paiUnitClassCount.clear();
		m_paiUnitClassCount.resize(GC.getNumUnitClassInfos(), 0);

		m_paiUnitClassMaking.clear();
		m_paiUnitClassMaking.resize(GC.getNumUnitClassInfos(), 0);

		m_paiBuildingClassCount.clear();
		m_paiBuildingClassCount.resize(GC.getNumBuildingClassInfos(), 0);

		m_paiBuildingClassMaking.clear();
		m_paiBuildingClassMaking.resize(GC.getNumBuildingClassInfos(), 0);

		m_paiProjectMaking.clear();
		m_paiProjectMaking.resize(GC.getNumProjectInfos(), 0);

		m_paiHurryCount.clear();
		m_paiHurryCount.resize(GC.getNumHurryInfos(), 0);

		m_paiHurryModifier.clear();
		m_paiHurryModifier.resize(GC.getNumHurryInfos(), 0);
#if defined(MOD_BALANCE_CORE)
		m_paiNumCitiesFreeChosenBuilding.clear();
		m_paiNumCitiesFreeChosenBuilding.resize(GC.getNumBuildingClassInfos(), 0);

		m_aistrInstantYield.clear();
		m_aistrInstantYield.resize(NUM_INSTANT_YIELD_TYPES);
#endif
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
		m_pabHasGlobalMonopoly.clear();
		m_pabHasGlobalMonopoly.resize(GC.getNumResourceInfos(), false);
		m_pabHasStrategicMonopoly.clear();
		m_pabHasStrategicMonopoly.resize(GC.getNumResourceInfos(), false);
		m_vResourcesWGlobalMonopoly.clear();
		m_vResourcesWStrategicMonopoly.clear();
#endif
		m_pabLoyalMember.clear();
		m_pabLoyalMember.resize(GC.getNumVoteSourceInfos(), true);

		m_pabGetsScienceFromPlayer.clear();
		m_pabGetsScienceFromPlayer.resize(MAX_CIV_PLAYERS, false);

		m_pEconomicAI->Init(GC.GetGameEconomicAIStrategies(), this);
		m_pMilitaryAI->Init(GC.GetGameMilitaryAIStrategies(), this, GetDiplomacyAI());
		m_pCitySpecializationAI->Init(GC.GetGameCitySpecializations(), this);
		m_pWonderProductionAI->Init(GC.GetGameBuildings(), this, false);
		m_pGrandStrategyAI->Init(GC.GetGameAIGrandStrategies(), this);
		m_pDiplomacyAI->Init(this);
		m_pReligions->Init(this);
		m_pReligionAI->Init(GC.GetGameBeliefs(), this);
		m_pPlayerTechs->Init(GC.GetGameTechs(), this, false);
		m_pPlayerPolicies->Init(GC.GetGamePolicies(), this, false);
		m_pTacticalAI->Init(this);
		m_pHomelandAI->Init(this);
		m_pMinorCivAI->Init(this);
		m_pDealAI->Init(this);
		m_pBuilderTaskingAI->Init(this);
		m_pCityConnections->Init(this);
		if(m_pNotifications)
		{
			m_pNotifications->Init(eID);
		}
		if(m_pDiplomacyRequests)
		{
			m_pDiplomacyRequests->Init(eID);
		}
		m_pDangerPlots->Init(eID, false /*bAllocate*/);

#if defined(MOD_BALANCE_CORE_SETTLER)
		m_pCityDistance->SetPlayer(eID);
#endif

		m_pTreasury->Init(this);
		m_pTraits->Init(GC.GetGameTraits(), this);
		m_pEspionage->Init(this);
		m_pEspionageAI->Init(this);
		m_pTrade->Init(this);
		m_pTradeAI->Init(this);
		m_pLeagueAI->Init(this);
		m_pCulture->Init(this);

		// Set up flavor manager
		m_pFlavorManager->Init(this);

		// And if this is a real player, hook up the player-level flavor recipients
		PlayerTypes p = GetID();
		if(p != NO_PLAYER)
		{
			SlotStatus s = CvPreGame::slotStatus(p);
			if((s == SS_TAKEN || s == SS_COMPUTER) && !isBarbarian())
			{
				m_pFlavorManager->AddFlavorRecipient(m_pPlayerTechs);
				m_pFlavorManager->AddFlavorRecipient(m_pPlayerPolicies);
				m_pFlavorManager->AddFlavorRecipient(m_pWonderProductionAI);
			}
		}

		Firaxis::Array< int, NUM_YIELD_TYPES > yield;
		for(unsigned int j = 0; j < NUM_YIELD_TYPES; ++j)
		{
			yield[j] = 0;
		}

		m_ppaaiSpecialistExtraYield.clear();
		m_ppaaiSpecialistExtraYield.resize(GC.getNumSpecialistInfos());
		for(unsigned int i = 0; i < m_ppaaiSpecialistExtraYield.size(); ++i)
		{
			m_ppaaiSpecialistExtraYield.setAt(i, yield);
		}

#if defined(MOD_API_UNIFIED_YIELDS) && defined(MOD_API_PLOT_YIELDS)
		m_ppiPlotYieldChange.clear();
		m_ppiPlotYieldChange.resize(GC.getNumPlotInfos());
		for(unsigned int i = 0; i < m_ppiPlotYieldChange.size(); ++i)
		{
			m_ppiPlotYieldChange[i] = yield;
		}
#endif

#if defined(MOD_API_UNIFIED_YIELDS)
		m_ppiImprovementYieldChange.clear();
		m_ppiImprovementYieldChange.resize(GC.getNumImprovementInfos());
		for(unsigned int i = 0; i < m_ppiImprovementYieldChange.size(); ++i)
		{
			m_ppiImprovementYieldChange[i] = yield;
		}

		m_ppiFeatureYieldChange.clear();
		m_ppiFeatureYieldChange.resize(GC.getNumFeatureInfos());
		for(unsigned int i = 0; i < m_ppiFeatureYieldChange.size(); ++i)
		{
			m_ppiFeatureYieldChange[i] = yield;
		}
		
		m_ppiResourceYieldChange.clear();
		m_ppiResourceYieldChange.resize(GC.getNumResourceInfos());
		for(unsigned int i = 0; i < m_ppiResourceYieldChange.size(); ++i)
		{
			m_ppiResourceYieldChange[i] = yield;
		}
		
		m_ppiTerrainYieldChange.clear();
		m_ppiTerrainYieldChange.resize(GC.getNumTerrainInfos());
		for(unsigned int i = 0; i < m_ppiTerrainYieldChange.size(); ++i)
		{
			m_ppiTerrainYieldChange[i] = yield;
		}
		
		m_ppiTradeRouteYieldChange.clear();
		m_ppiTradeRouteYieldChange.resize(NUM_DOMAIN_TYPES);
		for(unsigned int i = 0; i < m_ppiTradeRouteYieldChange.size(); ++i)
		{
			m_ppiTradeRouteYieldChange[i] = yield;
		}
		
		m_ppiSpecialistYieldChange.clear();
		m_ppiSpecialistYieldChange.resize(GC.getNumSpecialistInfos());
		for(unsigned int i = 0; i < m_ppiSpecialistYieldChange.size(); ++i)
		{
			m_ppiSpecialistYieldChange[i] = yield;
		}
		
		m_ppiGreatPersonExpendedYield.clear();
		m_ppiGreatPersonExpendedYield.resize(GC.getNumGreatPersonInfos());
		for(unsigned int i = 0; i < m_ppiGreatPersonExpendedYield.size(); ++i)
		{
			m_ppiGreatPersonExpendedYield[i] = yield;
		}
		
		m_piGoldenAgeGreatPersonRateModifier.clear();
		m_piGoldenAgeGreatPersonRateModifier.resize(GC.getNumGreatPersonInfos(), 0);

		m_ppiUnimprovedFeatureYieldChange.clear();
		m_ppiUnimprovedFeatureYieldChange.resize(GC.getNumFeatureInfos());
		for(unsigned int i = 0; i < m_ppiUnimprovedFeatureYieldChange.size(); ++i)
		{
			m_ppiUnimprovedFeatureYieldChange[i] = yield;
		}
		
		m_ppiCityYieldFromUnimprovedFeature.clear();
		m_ppiCityYieldFromUnimprovedFeature.resize(GC.getNumFeatureInfos());
		for(unsigned int i = 0; i < m_ppiCityYieldFromUnimprovedFeature.size(); ++i)
		{
			m_ppiCityYieldFromUnimprovedFeature[i] = yield;
		}
		
		m_piYieldFromKills.clear();
		m_piYieldFromKills.resize(NUM_YIELD_TYPES, 0);

		m_piYieldFromBarbarianKills.clear();
		m_piYieldFromBarbarianKills.resize(NUM_YIELD_TYPES, 0);

		m_piYieldChangeTradeRoute.clear();
		m_piYieldChangeTradeRoute.resize(NUM_YIELD_TYPES, 0);

		m_piYieldChangesNaturalWonder.clear();
		m_piYieldChangesNaturalWonder.resize(NUM_YIELD_TYPES, 0);

		m_piYieldChangeWorldWonder.clear();
		m_piYieldChangeWorldWonder.resize(NUM_YIELD_TYPES, 0);

		m_piYieldFromMinorDemand.clear();
		m_piYieldFromMinorDemand.resize(NUM_YIELD_TYPES, 0);

		m_piCityFeatures.clear();
		m_piCityFeatures.resize(GC.getNumFeatureInfos(), 0);

		m_piNumBuildings.clear();
		m_piNumBuildings.resize(GC.getNumBuildingInfos(), 0);

		m_ppiBuildingClassYieldChange.clear();
		m_ppiBuildingClassYieldChange.resize(GC.getNumBuildingClassInfos());
		for(unsigned int i = 0; i < m_ppiBuildingClassYieldChange.size(); ++i)
		{
			m_ppiBuildingClassYieldChange.setAt(i, yield);
		}
#endif

		m_ppaaiImprovementYieldChange.clear();
		m_ppaaiImprovementYieldChange.resize(GC.getNumImprovementInfos());
		for(unsigned int i = 0; i < m_ppaaiImprovementYieldChange.size(); ++i)
		{
			m_ppaaiImprovementYieldChange.setAt(i, yield);
		}

		m_ppaaiBuildingClassYieldMod.clear();
		m_ppaaiBuildingClassYieldMod.resize(GC.getNumBuildingClassInfos());
		for(unsigned int i = 0; i < m_ppaaiBuildingClassYieldMod.size(); ++i)
		{
			m_ppaaiBuildingClassYieldMod.setAt(i, yield);
		}
#if defined(MOD_BALANCE_CORE)
		m_ppiApproachScratchValue.clear();
		m_ppiApproachScratchValue.resize(MAX_MAJOR_CIVS);
		for(unsigned int i = 0; i < m_ppiApproachScratchValue.size(); ++i)
		{
			for(int iJ = 0; iJ < NUM_MAJOR_CIV_APPROACHES; ++iJ)
			{
				m_ppiApproachScratchValue[i][iJ] = 0;
			}
		}
#endif

		m_aVote.clear();
		m_aUnitExtraCosts.clear();

		AI_reset();
	}
}

//	--------------------------------------------------------------------------------
/// This is called after the map and other game constructs have been setup and just before the game starts.
void CvPlayer::gameStartInit()
{
#if defined(MOD_BALANCE_CORE)
	//make sure the non-serialized infos are up to date
	m_pDangerPlots->Init(GetID(), true);
	m_pCityDistance->SetPlayer(GetID());
#else
	// if the game is loaded, don't init the danger plots. This was already done in the serialization process.
	if(CvPreGame::gameStartType() != GAME_LOADED)
	{
		if(!GC.GetEngineUserInterface()->IsLoadedGame())
		{
			InitDangerPlots(); // moved this up because everyone should have danger plots inited. This is bad because saved games get much bigger for no reason.
		}
	}
#endif
	verifyAlive();
	if(!isAlive())
	{
		return;
	}

	if(!GC.GetEngineUserInterface()->IsLoadedGame())
	{
		InitPlots();
		UpdatePlots();
	}
}


//////////////////////////////////////
// graphical only setup
//////////////////////////////////////
void CvPlayer::setupGraphical()
{
	CvCity* pLoopCity;
	CvUnit* pLoopUnit;

	// Setup m_cities
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->setupGraphical();
	}

	// Setup m_units
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		pLoopUnit->setupGraphical();
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::initFreeState(CvGameInitialItemsOverrides& kOverrides)
{
	CvHandicapInfo& kHandicapInfo = getHandicapInfo();

	// Starting Gold
	if(kOverrides.GrantInitialGoldPerPlayer[GetID()])
	{
		int iInitialGold = kHandicapInfo.getStartingGold() + GC.getGame().getStartEraInfo().getStartingGold();
		iInitialGold *= GC.getGame().getGameSpeedInfo().getTrainPercent();
		iInitialGold /= 100;
		GetTreasury()->SetGold(iInitialGold);
	}

	// Free Culture
	if(kOverrides.GrantInitialCulturePerPlayer[GetID()])
	{
		int iInitialCulture = kHandicapInfo.getStartingPolicyPoints() + GC.getGame().getStartEraInfo().getStartingCulture();
		iInitialCulture *= GC.getGame().getGameSpeedInfo().getTrainPercent();
		iInitialCulture /= 100;
		setJONSCulture(iInitialCulture);

		 // I think policy points is a better name than Jon's Culture, don't you?
		ChangeJONSCulturePerTurnForFree(kHandicapInfo.getFreeCulturePerTurn()); // No, IMNSHO ;P
	}
	// Extra Happiness from Luxuries
	ChangeExtraHappinessPerLuxury(kHandicapInfo.getExtraHappinessPerLuxury());

	// Free starting Resources
	for(int iLoop = 0; iLoop < GC.getNumResourceInfos(); iLoop++)
	{
		const ResourceTypes eResource = static_cast<ResourceTypes>(iLoop);
		CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
		if(pkResource)
		{
			if(pkResource->getStartingResourceQuantity() != 0)
			{
				changeNumResourceTotal(eResource, pkResource->getStartingResourceQuantity());
			}
		}

	}

	CalculateNetHappiness();

	clearResearchQueue();
}

//	--------------------------------------------------------------------------------
void CvPlayer::initFreeUnits(CvGameInitialItemsOverrides& /*kOverrides*/)
{
	UnitTypes eLoopUnit;
	int iFreeCount;
	int iDefaultAI;
	int iI, iJ;

	CvEraInfo& gameStartEra = GC.getGame().getStartEraInfo();
	CvHandicapInfo& gameHandicap = GC.getGame().getHandicapInfo();
	CvHandicapInfo& playerHandicap = getHandicapInfo();
	CvCivilizationInfo& playerCivilization = getCivilizationInfo();
#if defined(MOD_BALANCE_CORE)
	int iFree = 0;
#endif
	for(iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
	{
		const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
		CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
		if(pkUnitClassInfo)
		{
			eLoopUnit = (UnitTypes)playerCivilization.getCivilizationUnits(iI);

			if(eLoopUnit != NO_UNIT)
			{
				iFreeCount = playerCivilization.getCivilizationFreeUnitsClass(iI);
				iDefaultAI = playerCivilization.getCivilizationFreeUnitsDefaultUnitAI(iI);
#if defined(MOD_BALANCE_CORE)
				if(!canTrain(eLoopUnit) && iDefaultAI != UNITAI_SETTLE) 
				{
					// Loop through adding the available units
					for(int iUnitLoop = 0; iUnitLoop < GC.GetGameUnits()->GetNumUnits(); iUnitLoop++)
					{
						const UnitTypes eUnit = static_cast<UnitTypes>(iUnitLoop);
						CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
						if(pkUnitInfo)
						{
							// Make sure this unit can be built now
							if(canTrain(eUnit))
							{
								// Make sure it matches the requested unit AI type
								if(pkUnitInfo->GetDefaultUnitAIType() == iDefaultAI)
								{
									eLoopUnit = eUnit;
									break;
								}
							}
						}
					}
				}
#endif
				iFreeCount *= (gameStartEra.getStartingUnitMultiplier() + ((!isHuman()) ? gameHandicap.getAIStartingUnitMultiplier() : 0));

				// City states only get 1 of something
				if(isMinorCiv() && iFreeCount > 1)
					iFreeCount = 1;

				for(iJ = 0; iJ < iFreeCount; iJ++)
				{
					addFreeUnit(eLoopUnit,(UnitAITypes)iDefaultAI);
#if defined(MOD_BALANCE_CORE)
					if(iDefaultAI != UNITAI_SETTLE)
					{
						iFree++;
					}
#endif
				}
			}
		}
	}

	// Trait units
	int iUnitClass = GetPlayerTraits()->GetFirstFreeUnit(NO_TECH);
	while(iUnitClass != NO_UNITCLASS)
	{
		eLoopUnit = (UnitTypes)playerCivilization.getCivilizationUnits(iUnitClass);
		iDefaultAI = GC.GetGameUnits()->GetEntry(eLoopUnit)->GetDefaultUnitAIType();
		addFreeUnit(eLoopUnit,(UnitAITypes)iDefaultAI);

		// Another?
		iUnitClass = GetPlayerTraits()->GetNextFreeUnit();
	}

	// Defensive units
	iFreeCount = gameStartEra.getStartingDefenseUnits();
	iFreeCount += playerHandicap.getStartingDefenseUnits();
	if(!isHuman())
		iFreeCount += gameHandicap.getAIStartingDefenseUnits();
#if defined(MOD_BALANCE_CORE)
	iFreeCount -= iFree;
#endif
	if(iFreeCount > 0 && !isMinorCiv())
		addFreeUnitAI(UNITAI_DEFENSE, iFreeCount);

	// Worker units
	iFreeCount = gameStartEra.getStartingWorkerUnits();
	iFreeCount += playerHandicap.getStartingWorkerUnits();

	if(!isHuman())
		iFreeCount += gameHandicap.getAIStartingWorkerUnits();

	if(iFreeCount > 0 && !isMinorCiv())
		addFreeUnitAI(UNITAI_WORKER, iFreeCount);

	// Explore units
	iFreeCount = gameStartEra.getStartingExploreUnits();
	iFreeCount += playerHandicap.getStartingExploreUnits();

	if(!isHuman())
		iFreeCount += gameHandicap.getAIStartingExploreUnits();

	if(iFreeCount > 0 && !isMinorCiv())
		addFreeUnitAI(UNITAI_EXPLORE, iFreeCount);

#if defined(MOD_BALANCE_CORE)
	//Minor Civ Units
	if(isMinorCiv())
	{
		iFreeCount = gameStartEra.getStartingMinorDefenseUnits();
		iFreeCount += gameHandicap.getStartingMinorDefenseUnits();
		if(iFreeCount > 0)
		{
			addFreeUnitAI(UNITAI_DEFENSE, iFreeCount);
		}
	}
#endif
	// If we only have one military unit and it's on defense then change its AI to explore
	if(GetNumUnitsWithUnitAI(UNITAI_EXPLORE) == 0)
	{
#if defined(MOD_BALANCE_CORE)
		if(!isMinorCiv())
		{
#endif
		int iLoop;
		CvUnit* pLoopUnit;
		for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		{
			if(pLoopUnit->AI_getUnitAIType() == UNITAI_DEFENSE)
			{
				pLoopUnit->AI_setUnitAIType(UNITAI_EXPLORE);
				break;
			}
		}
#if defined(MOD_BALANCE_CORE)
		}
#endif
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::addFreeUnitAI(UnitAITypes eUnitAI, int iCount)
{
	int iI;

	UnitTypes eBestUnit = NO_UNIT;
	int iBestValue = 0;

	CvCivilizationInfo& playerCivilzationInfo = getCivilizationInfo();
	for(iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
	{
		const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
		CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
		if(pkUnitClassInfo)
		{
			UnitTypes eLoopUnit = (UnitTypes)playerCivilzationInfo.getCivilizationUnits(iI);
			if(eLoopUnit != NO_UNIT)
			{
				CvUnitEntry* pUnitInfo = GC.getUnitInfo(eLoopUnit);
				if(pUnitInfo != NULL)
				{
					if(canTrain(eLoopUnit))
					{
						bool bValid = true;
						for(int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
						{
							const ResourceTypes eResource = static_cast<ResourceTypes>(iJ);
							CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
							if(pkResource)
							{
								if(pUnitInfo->GetResourceQuantityRequirement(iJ) > 0)
								{
									bValid = false;
								}
							}
						}

						if(bValid)
						{
							int iValue = 0;

							// Default unit AI matches
							if(pUnitInfo->GetDefaultUnitAIType() == eUnitAI)
								iValue += (pUnitInfo->GetProductionCost() * 2);
							// Not default, but still possible
							else if(pUnitInfo->GetUnitAIType(eUnitAI))
								iValue += (pUnitInfo->GetProductionCost());

							if(iValue > iBestValue)
							{
								eBestUnit = eLoopUnit;
								iBestValue = iValue;
							}
						}
					}
				}
			}
		}

	}

	if(eBestUnit != NO_UNIT)
	{
		for(iI = 0; iI < iCount; iI++)
		{
			addFreeUnit(eBestUnit, eUnitAI);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Returns plot where new unit was created
CvPlot* CvPlayer::addFreeUnit(UnitTypes eUnit, UnitAITypes eUnitAI)
{
	CvPlot* pStartingPlot;
#if defined(MOD_BUGFIX_FREE_RELIGIOUS_UNITS)
	CvPlot* pBestPlot = NULL;
#else
	CvPlot* pBestPlot;
#endif
	CvPlot* pLoopPlot;
	CvPlot* pReturnValuePlot = NULL;

	CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
	if(pkUnitInfo == NULL)
		return pReturnValuePlot;

#if defined(MOD_BUGFIX_FREE_RELIGIOUS_UNITS)
	// If pkUnitInfo is a religious unit AND the player has founded a religion, it MUST be dropped in the player's holy city
	if ((pkUnitInfo->IsSpreadReligion() || pkUnitInfo->IsRemoveHeresy()) && GetReligions()->HasCreatedReligion()) {
		CvCity* pHolyCity = GetHolyCity();
		if (pHolyCity && pHolyCity->getOwner() == GetID()) {
			// We have a holy city and we still own it
			pBestPlot = pHolyCity->plot();
		} else {
			// Ummm, our holy city either doesn't exist (maybe a mod razed it), or it belongs to someone else, better just drop this dude in the capital
			pBestPlot = getCapitalCity()->plot();
		}
	}
#endif

	if(GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && isHuman())
	{
		if((eUnitAI == UNITAI_SETTLE) || (pkUnitInfo->GetDefaultUnitAIType() == UNITAI_SETTLE))
		{
			if(GetNumUnitsWithUnitAI(UNITAI_SETTLE) >= 1)
			{
				return pReturnValuePlot;
			}
		}
	}

	// slewis
	// If we're Venice
	if (GetPlayerTraits()->IsNoAnnexing())
	{
		// if we're trying to drop a settler
		if((eUnitAI == UNITAI_SETTLE) || (pkUnitInfo->GetDefaultUnitAIType() == UNITAI_SETTLE))
		{
			// if we already have a settler
			if(GetNumUnitsWithUnitAI(UNITAI_SETTLE) >= 1)
			{
				// drop a merchant of venice instead
				// find the eUnit replacement that's the merchant of venice
				for(int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
				{
					const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
					CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
					if(pkUnitClassInfo)
					{
						const UnitTypes eLocalUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eUnitClass);
						if (eLocalUnit != NO_UNIT)
						{
							CvUnitEntry* pUnitEntry = GC.getUnitInfo(eLocalUnit);
							if (pUnitEntry->IsCanBuyCityState())
							{
								// replacing the parameters
								eUnit = eLocalUnit;
								eUnitAI = (UnitAITypes)pkUnitInfo->GetDefaultUnitAIType();
								break;
							}
						}
					}
				}
			}
		}	
	}

	CvCity* pCapital = getCapitalCity();

	if(pCapital)
	{
		pStartingPlot = pCapital->plot();
	}
	else
	{
		pStartingPlot = getStartingPlot();
	}

	if(pStartingPlot != NULL)
	{
#if defined(MOD_BUGFIX_FREE_RELIGIOUS_UNITS)
		// If pBestPlot is not NULL, don't do any of this, as we have already determined the best plot
		if (pBestPlot == NULL) {
#else
			pBestPlot = NULL;
#endif

			if (isHuman())
			{
				if (!(pkUnitInfo->IsFound()))
				{
					DirectionTypes eDirection;

					bool bDirectionValid;

					int iCount = 0;

					// Find a random direction
					do
					{
						bDirectionValid = true;

						eDirection = (DirectionTypes)GC.getGame().getJonRandNum(NUM_DIRECTION_TYPES, "Placing Starting Units (Human)");

						if (bDirectionValid)
						{
							pLoopPlot = plotDirection(pStartingPlot->getX(), pStartingPlot->getY(), eDirection);

#if defined(MOD_BUGFIX_NAVAL_FREE_UNITS)
							if (pkUnitInfo->GetDomainType() == DOMAIN_SEA) {
								if (pLoopPlot != NULL && pLoopPlot->isWater()) {
									if (!pLoopPlot->isImpassable()) {
										if (!(pLoopPlot->isUnit())) {
											pBestPlot = pLoopPlot;
											break;
										}
									}
								}
							}
							else {
#endif
								if (pLoopPlot != NULL && pLoopPlot->getArea() == pStartingPlot->getArea())
								{
									if (!pLoopPlot->isImpassable() && !pLoopPlot->isMountain())
									{
										if (!(pLoopPlot->isUnit()))
										{
											if (!(pLoopPlot->isGoody()))
											{
												pBestPlot = pLoopPlot;
												break;
											}
										}
									}
								}
#if defined(MOD_BUGFIX_NAVAL_FREE_UNITS)
							}
#endif
						}

						// Emergency escape.  Should only really break on Debug Micro map or something really funky
						iCount++;
					} while (iCount < 1000);
				}
			}

			if (pBestPlot == NULL)
			{
				pBestPlot = pStartingPlot;
			}
#if defined(MOD_BUGFIX_FREE_RELIGIOUS_UNITS)
		}
#endif

		CvUnit* pNewUnit = initUnit(eUnit, pBestPlot->getX(), pBestPlot->getY(), eUnitAI);
		CvAssert(pNewUnit != NULL);
		if (pNewUnit == NULL)
			return NULL;
#if defined(MOD_BALANCE_CORE)
		if(pNewUnit->getUnitInfo().IsSpreadReligion())
		{
			ReligionTypes eReligion = GetReligions()->GetReligionCreatedByPlayer();
			if(eReligion == NO_RELIGION)
			{
				eReligion = GetReligions()->GetReligionInMostCities();
			}
			int iReligionSpreads = pNewUnit->getUnitInfo().GetReligionSpreads();
			int iReligiousStrength = pNewUnit->getUnitInfo().GetReligiousStrength();
			if(iReligionSpreads > 0 && eReligion > RELIGION_PANTHEON)
			{
				pNewUnit->GetReligionData()->SetSpreadsLeft(iReligionSpreads);
				pNewUnit->GetReligionData()->SetReligiousStrength(iReligiousStrength);
				pNewUnit->GetReligionData()->SetReligion(eReligion);
			}
		}
#endif
		// Don't stack any units
		if(pBestPlot->getNumUnits() > 1)
		{
			if (!pNewUnit->jumpToNearestValidPlot())
			{
				// Could not find a spot for the unit
				pNewUnit->kill(false);		
				return NULL;
			}
		}
		pReturnValuePlot = pNewUnit->plot();
	}

	return pReturnValuePlot;
}


//	--------------------------------------------------------------------------------
#if defined(MOD_API_EXTENSIONS)
CvCity* CvPlayer::initCity(int iX, int iY, bool bBumpUnits, bool bInitialFounding, ReligionTypes eInitialReligion, const char* szName)
#else
CvCity* CvPlayer::initCity(int iX, int iY, bool bBumpUnits, bool bInitialFounding)
#endif
{
	CvCity* pNewCity = addCity();

	CvAssertMsg(pCity != NULL, "City is not assigned a valid value");
	if(pNewCity != NULL)
	{
		CvAssertMsg(!(GC.getMap().plot(iX, iY)->isCity()), "No city is expected at this plot when initializing new city");
#if defined(MOD_API_EXTENSIONS)
		pNewCity->init(pNewCity->GetID(), GetID(), iX, iY, bBumpUnits, bInitialFounding, eInitialReligion, szName);
#else
		pNewCity->init(pNewCity->GetID(), GetID(), iX, iY, bBumpUnits, bInitialFounding);
#endif
		pNewCity->GetCityStrategyAI()->UpdateFlavorsForNewCity();

#if defined(MOD_BALANCE_CORE_SETTLER)
		SetClosestCityMapDirty();
#endif

#if defined(MOD_BALANCE_CORE)
		int iLoop=0;
		for (CvCity* pCity=firstCity(&iLoop); pCity!=NULL; pCity=nextCity(&iLoop))
			pCity->UpdateClosestFriendlyNeighbors();
#endif
	}

	return pNewCity;
}

//	--------------------------------------------------------------------------------
// NOTE: bGift set to true if the city is given as a gift, as in the case for trades and Austria UA of annexing city-states
#if defined(MOD_API_EXTENSIONS)
#if defined(MOD_GLOBAL_VENICE_KEEPS_RESOURCES)
CvCity* CvPlayer::acquireCity(CvCity* pOldCity, bool bConquest, bool bGift, bool bVenice)
#else
CvCity* CvPlayer::acquireCity(CvCity* pOldCity, bool bConquest, bool bGift)
#endif
#else
#if defined(MOD_GLOBAL_VENICE_KEEPS_RESOURCES)
void CvPlayer::acquireCity(CvCity* pOldCity, bool bConquest, bool bGift, bool bVenice)
#else
void CvPlayer::acquireCity(CvCity* pOldCity, bool bConquest, bool bGift)
#endif
#endif
{
	if(pOldCity == NULL)
#if defined(MOD_API_EXTENSIONS)
		return NULL;
#else
		return;
#endif

	IDInfo* pUnitNode;
	CvCity* pNewCity;
	CvUnit* pLoopUnit;
	CvPlot* pCityPlot;

	CvString strBuffer;
	CvString strName;
	bool abEverOwned[MAX_PLAYERS];
	PlayerTypes eOldOwner;
	PlayerTypes eOriginalOwner;
	BuildingTypes eBuilding;
	bool bRecapture;
	int iCaptureGold;
	int iCaptureCulture;
	int iCaptureGreatWorks;
	int iGameTurnFounded;
	int iPopulation;
	int iHighestPopulation;
	int iOldPopulation;
	int iBattleDamage;
	int iI;
	FFastSmallFixedList<IDInfo, 25, true, c_eCiv5GameplayDLL > oldUnits;
	CvCityReligions tempReligions;
	bool bIsMinorCivBuyout = (pOldCity->GetPlayer()->isMinorCiv() && bGift && (IsAbleToAnnexCityStates() || GetPlayerTraits()->IsNoAnnexing())); // Austria and Venice UA

	pCityPlot = pOldCity->plot();

	pUnitNode = pCityPlot->headUnitNode();

	while(pUnitNode != NULL)
	{
		oldUnits.insertAtEnd(pUnitNode);
		pUnitNode = pCityPlot->nextUnitNode((IDInfo*)pUnitNode);
	}

	pUnitNode = oldUnits.head();

	while(pUnitNode != NULL)
	{
		pLoopUnit = ::getUnit(*pUnitNode);
		pUnitNode = oldUnits.next(pUnitNode);

		if(pLoopUnit && pLoopUnit->getTeam() != getTeam())
		{
			if(pLoopUnit->IsImmobile())
			{
				pLoopUnit->kill(false, GetID());
#if defined(MOD_API_EXTENSIONS)
				DoUnitKilledCombat(NULL, pLoopUnit->getOwner(), pLoopUnit->getUnitType());
#else
				DoUnitKilledCombat(pLoopUnit->getOwner(), pLoopUnit->getUnitType());
#endif
			}
		}
	}
	if(bConquest)
	{
#if defined(MOD_BALANCE_CORE)
		if(!isHuman())
		{
			GetDiplomacyAI()->SetPlayerNumTurnsSinceCityCapture(pOldCity->getOwner(), 0);
		}
		GET_PLAYER(pOldCity->getOwner()).GetDiplomacyAI()->SetPlayerNumTurnsSinceCityCapture(GetID(), 0);
#endif
		CvNotifications* pNotifications = GET_PLAYER(pOldCity->getOwner()).GetNotifications();
		if(pNotifications)
		{
			Localization::String locString = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_LOST");
			locString << pOldCity->getNameKey() << getNameKey();
			Localization::String locSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_LOST");
			locSummary << pOldCity->getNameKey();

#if defined(MOD_BALANCE_CORE)
			if(pOldCity->GetCityReligions()->IsHolyCityAnyReligion())
			{
				ReligionTypes eReligion = pOldCity->GetCityReligions()->GetReligionForHolyCity();
				const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, NO_PLAYER);
				if(pReligion)
				{
					CvString szReligionName = pReligion->GetName();
					locString = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_LOST_HOLY");
					locString << pOldCity->getNameKey() << getNameKey() << szReligionName;
					locSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_LOST_HOLY");
					locSummary << pOldCity->getNameKey();
				}
				UpdateReligion();
			}

#endif
			pNotifications->Add(NOTIFICATION_CITY_LOST, locString.toUTF8(), locSummary.toUTF8(), pOldCity->getX(), pOldCity->getY(), -1);
		}
#if defined(MOD_DIPLOMACY_CITYSTATES_QUESTS)
		if(MOD_DIPLOMACY_CITYSTATES_QUESTS && pOldCity->isBarbarian())
		{
			CvBarbarians::DoBarbCityCleared(pOldCity->plot());
		}
#endif

		if(!isBarbarian() && !pOldCity->isBarbarian())
		{
			int iDefaultCityValue = /*150*/ GC.getWAR_DAMAGE_LEVEL_CITY_WEIGHT();

			// Notify Diplo AI that damage has been done
			int iValue = iDefaultCityValue;
			iValue += pOldCity->getPopulation() * /*100*/ GC.getWAR_DAMAGE_LEVEL_INVOLVED_CITY_POP_MULTIPLIER();
			if (pOldCity->IsOriginalCapital())
			{
				iValue *= 3;
				iValue /= 2;
			}
#if defined(MOD_BALANCE_CORE)
			if(pOldCity->getNumWorldWonders() > 0)
			{
				iValue += (pOldCity->getNumWorldWonders() * /*100*/ GC.getWAR_DAMAGE_LEVEL_INVOLVED_CITY_POP_MULTIPLIER());
			}
#endif
			// My viewpoint
			GetDiplomacyAI()->ChangeOtherPlayerWarValueLost(pOldCity->getOwner(), GetID(), iValue);
			// Bad guy's viewpoint
			GET_PLAYER(pOldCity->getOwner()).GetDiplomacyAI()->ChangeWarValueLost(GetID(), iValue);

			// zero out any liberation credit since we just captured a city from them
			PlayerTypes ePlayer;
			CvDiplomacyAI* pOldOwnerDiploAI = GET_PLAYER(pOldCity->getOwner()).GetDiplomacyAI();
			int iNumLiberatedCities = pOldOwnerDiploAI->GetNumCitiesLiberated(GetID());
			pOldOwnerDiploAI->ChangeNumCitiesLiberated(GetID(), -iNumLiberatedCities);

			iValue = iDefaultCityValue;
			iValue += pOldCity->getPopulation() * /*120*/ GC.getWAR_DAMAGE_LEVEL_UNINVOLVED_CITY_POP_MULTIPLIER();

			// Now update everyone else in the world, but use a different multiplier (since they don't have complete info on the situation - they don't know when Units are killed)
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
			{
				ePlayer = (PlayerTypes) iPlayerLoop;

				// Not us and not the player we acquired City from
				if(ePlayer != GetID() && ePlayer != pOldCity->getOwner())
				{
					GET_PLAYER(ePlayer).GetDiplomacyAI()->ChangeOtherPlayerWarValueLost(pOldCity->getOwner(), GetID(), iValue);
				}
#if defined(MOD_BALANCE_CORE)
				if(ePlayer != NO_PLAYER)
				{
					pOldCity->SetFranchised(ePlayer, false);
					pOldCity->SetHasOffice(false);
				}
#endif
			}

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
			if (MOD_DIPLOMACY_CIV4_FEATURES) {
				// Only on conquest
				if(bConquest) {
					// Vassalage stuff
					TeamTypes eMaster = GET_TEAM(GET_PLAYER(pOldCity->getOwner()).getTeam()).GetMaster();
					if(eMaster != NO_TEAM) {
						for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
						{
							ePlayer = (PlayerTypes) iPlayerLoop;
						
							if(GET_PLAYER(ePlayer).getTeam() == eMaster) {
								// This team was the master of the loser's team
								if(GET_PLAYER(pOldCity->getOwner()).getTeam() == eMaster)
								{
									// Master's failed protect score goes up for Vassal
									GET_PLAYER(pOldCity->getOwner()).GetDiplomacyAI()->ChangeVassalFailedProtectValue(ePlayer, iValue);
								}

								// Notify Diplo AI that our master has killed a city in a civ near our empire
								// Conquering team is the master
								if(getTeam() == eMaster)
								{
									// Old city was neighbors to us
									if(GET_PLAYER(ePlayer).GetProximityToPlayer(pOldCity->getOwner()) <= PLAYER_PROXIMITY_CLOSE)
									{
										// Master protected us against our enemy!
										GET_PLAYER(ePlayer).GetDiplomacyAI()->ChangeVassalProtectValue(GetID(), iValue);
									}
								}
							}
						}
					}
				}
			}
#endif
		}

		GetMilitaryAI()->LogCityCaptured(pOldCity, pOldCity->getOwner());
	}

	if(pOldCity->getOriginalOwner() == pOldCity->getOwner())
	{
		GET_PLAYER(pOldCity->getOriginalOwner()).changeCitiesLost(1);
	}
	else if(pOldCity->getOriginalOwner() == GetID())
	{
		GET_PLAYER(pOldCity->getOriginalOwner()).changeCitiesLost(-1);
	}

	if(bConquest)
	{
		if(GetID() == GC.getGame().getActivePlayer())
		{
			strBuffer = GetLocalizedText("TXT_KEY_MISC_CAPTURED_CITY", pOldCity->getNameKey()).GetCString();
			GC.GetEngineUserInterface()->AddCityMessage(0, pOldCity->GetIDInfo(), GetID(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_CITYCAPTURE", MESSAGE_TYPE_MAJOR_EVENT, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pOldCity->getX(), pOldCity->getY(), true, true*/);
		}

		strName.Format("%s (%s)", pOldCity->getName().GetCString(), GET_PLAYER(pOldCity->getOwner()).getName());

		for(iI = 0; iI < MAX_PLAYERS; iI++)
		{
			if((PlayerTypes)iI == GC.getGame().getActivePlayer())
			{
				if(GET_PLAYER((PlayerTypes)iI).isAlive())
				{
					if(iI != GetID())
					{
						if(pOldCity->isRevealed(GET_PLAYER((PlayerTypes)iI).getTeam(), false))
						{
							strBuffer = GetLocalizedText("TXT_KEY_MISC_CITY_CAPTURED_BY", strName.GetCString(), getCivilizationShortDescriptionKey());
							GC.GetEngineUserInterface()->AddCityMessage(0, pOldCity->GetIDInfo(), ((PlayerTypes)iI), false, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_CITYCAPTURED", MESSAGE_TYPE_MAJOR_EVENT, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pOldCity->getX(), pOldCity->getY(), true, true*/);
						}
					}
				}
			}
		}

		strBuffer = GetLocalizedText("TXT_KEY_MISC_CITY_WAS_CAPTURED_BY", strName.GetCString(), getCivilizationShortDescriptionKey());
		GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, GetID(), strBuffer, pOldCity->getX(), pOldCity->getY());

#ifndef FINAL_RELEASE
		OutputDebugString("\n"); OutputDebugString(strBuffer); OutputDebugString("\n\n");
#endif
#if defined(MOD_BALANCE_CORE)
		CvNotifications* pNotifications2 = GetNotifications();
		if(pNotifications2)
		{
			if(pOldCity->GetCityReligions()->IsHolyCityAnyReligion())
			{
				ReligionTypes eReligion = pOldCity->GetCityReligions()->GetReligionForHolyCity();
				const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, NO_PLAYER);
				if(pReligion)
				{
					CvString szReligionName = pReligion->GetName();
					Localization::String locString = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_GAINED_HOLY");
					locString << pOldCity->getNameKey() << szReligionName;
					Localization::String locSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_GAINED_HOLY");
					locSummary << pOldCity->getNameKey();

					pNotifications2->Add(NOTIFICATION_CAPITAL_RECOVERED, locString.toUTF8(), locSummary.toUTF8(), pOldCity->getX(), pOldCity->getY(), -1);
				}
			}
		}
#endif
	}

	iCaptureGold = 0;
	iCaptureCulture = 0;
	iCaptureGreatWorks = 0;

	if(bConquest)
	{
		iCaptureGold = 0;

		iCaptureGold += GC.getBASE_CAPTURE_GOLD();
		iCaptureGold += (pOldCity->getPopulation() * GC.getCAPTURE_GOLD_PER_POPULATION());
		iCaptureGold += GC.getGame().getJonRandNum(GC.getCAPTURE_GOLD_RAND1(), "Capture Gold 1");
		iCaptureGold += GC.getGame().getJonRandNum(GC.getCAPTURE_GOLD_RAND2(), "Capture Gold 2");

		if(GC.getCAPTURE_GOLD_MAX_TURNS() > 0)
		{
			iCaptureGold *= range((GC.getGame().getGameTurn() - pOldCity->getGameTurnAcquired()), 0, GC.getCAPTURE_GOLD_MAX_TURNS());
			iCaptureGold /= GC.getCAPTURE_GOLD_MAX_TURNS();
		}

		iCaptureGold *= (100 + pOldCity->getCapturePlunderModifier()) / 100;
		iCaptureGold *= (100 + GetPlayerTraits()->GetPlunderModifier()) / 100;
	}

	GetTreasury()->ChangeGold(iCaptureGold);

	if(bConquest)
	{
		iCaptureCulture = pOldCity->getJONSCulturePerTurn();
		iCaptureCulture *= GetPlayerPolicies()->GetNumericModifier(POLICYMOD_CULTURAL_PLUNDER_MULTIPLIER);

		if(iCaptureCulture > 0)
		{
			changeJONSCulture(iCaptureCulture);
		}
	}

	if(bConquest)
	{
		if (GetPlayerTraits()->IsTechFromCityConquer())
		{
			// Will this be the first time we have owned this city?
			if (!pOldCity->isEverOwned(GetID()))
			{
				DoTechFromCityConquer(pOldCity);
			}
		}
	}
#if defined(MOD_BALANCE_CORE)
	if (!pOldCity->isEverOwned(GetID()))
	{
		int iExtraTerritoryClaim = GetPlayerTraits()->GetExtraConqueredCityTerritoryClaimRange();
		for (int i = 0; i < iExtraTerritoryClaim; i++)
		{
			CvPlot* pPlotToAcquire = pOldCity->GetNextBuyablePlot(false);

			// maybe the player owns ALL of the plots or there are none available?
			if(pPlotToAcquire)
			{
				pOldCity->DoAcquirePlot(pPlotToAcquire->getX(), pPlotToAcquire->getY());
			}
		}
	}
#endif
#if defined(MOD_BALANCE_CORE)
	if(bConquest && MOD_BALANCE_CORE)
	{
		if (GetPlayerTraits()->IsFreeGreatWorkOnConquest())
		{
			// Will this be the first time we have owned this city?
			if (!pOldCity->isEverOwned(GetID()))
			{
				DoFreeGreatWorkOnConquest(pOldCity->getOwner(), pOldCity);
			}
		}
	}
#endif
#if defined(MOD_BALANCE_CORE_BELIEFS)
	if(bConquest)
	{
		if (!pOldCity->isEverOwned(GetID()))
		{
			int iScaler = pOldCity->getPopulation() / 3;
			if(iScaler <= 0)
			{
				iScaler = 1;
			}
			doInstantYield(INSTANT_YIELD_TYPE_F_CONQUEST, false, NO_GREATPERSON, NO_BUILDING, iScaler);

			if(MOD_BALANCE_CORE_LUXURIES_TRAIT && !isMinorCiv() && !isBarbarian() && (GetPlayerTraits()->GetUniqueLuxuryQuantity() > 0))
			{
				GetPlayerTraits()->AddUniqueLuxuriesAround(pOldCity, GetPlayerTraits()->GetUniqueLuxuryQuantity());
			}
		}
		if(MOD_BALANCE_CORE_AFRAID_ANNEX)
		{
			if(GetPlayerTraits()->IsBullyAnnex())
			{
				if(pOldCity->GetPlayer()->isMinorCiv() && !pOldCity->isEverOwned(GetID()))
				{
					int iGoldenAge = pOldCity->getPopulation() * 20;
					ChangeGoldenAgeProgressMeter(iGoldenAge);
					if(GetID() == GC.getGame().getActivePlayer())
					{
						char text[256] = {0};
						float fDelay = 0.5f;
						sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_GOLDEN_AGE]", iGoldenAge);
						DLLUI->AddPopupText(pOldCity->getX(),pOldCity->getY(), text, fDelay);
					}
				}
			}
		}
	}
#endif

	// slewis - warmonger calculations
	if (bConquest)
	{
#if defined(MOD_DIPLOMACY_CITYSTATES_QUESTS)
		if(!isMinorCiv() && !isBarbarian())
#else
		if(!isMinorCiv())
#endif
		{
			bool bDoWarmonger = true;

			// Don't award warmongering if you're conquering a city you owned back
			if (pOldCity->getOriginalOwner() == GetID())
			{
				bDoWarmonger = false;
			}
#if defined(MOD_BALANCE_CORE)
			// Don't award warmongering if you're conquering a city that you were the last to own.
			if (pOldCity->getPreviousOwner() == GetID())
			{
				bDoWarmonger = false;
			}
			//Captured a city from barbs? Everyone likes that!
			if(GET_PLAYER(pOldCity->getOwner()).isBarbarian())
			{
				bDoWarmonger = false;
			}
			PlayerTypes eLiberatedPlayer = NO_PLAYER;

			// Captured someone's city that didn't originally belong to us - Liberate a player?
			eOldOwner = pOldCity->getOwner();
			if(pOldCity->getOriginalOwner() != eOldOwner && pOldCity->getOriginalOwner() != GetID())
			{
				eLiberatedPlayer = pOldCity->getOriginalOwner();
				if(eLiberatedPlayer != NO_PLAYER)
				{
					if(CanLiberatePlayerCity(eLiberatedPlayer))
					{
						bDoWarmonger = false;
						pOldCity->SetNoWarmonger(true);
					}
				}
			}
#endif

			if (bDoWarmonger)
			{
				CvDiplomacyAIHelpers::ApplyWarmongerPenalties(GetID(), pOldCity->getOwner(), pOldCity->isCapital(), pOldCity);
#if defined(MOD_BALANCE_CORE)
				pOldCity->SetNoWarmonger(false);
#endif
			}
		}
	}
#if defined(MOD_BALANCE_CORE)
	//Let's not slaughter citizens in a city we've owned before.
	bool bSlaughter = true;
	if(bConquest)
	{
		//Our city originally? Don't slaughter.
		if(pOldCity->getOriginalOwner() == GetID())
		{
			bSlaughter = false;
		}
		//We are liberators, so don't slaughter.
		if(pOldCity->isBarbarian())
		{
			bSlaughter = false;
		}
		//Recently captured and still in resistance? Don't slaughter.
		if(pOldCity->IsResistance() || pOldCity->IsRazing())
		{
			bSlaughter = false;
		}
	}
#endif
	int iNumBuildingInfos = GC.getNumBuildingInfos();
	std::vector<int> paiNumRealBuilding(iNumBuildingInfos, 0);
	std::vector<int> paiBuildingOriginalOwner(iNumBuildingInfos, 0);
	std::vector<int> paiBuildingOriginalTime(iNumBuildingInfos, 0);
	struct CopyGreatWorkData
	{
		int m_iGreatWork;
		BuildingTypes m_eBuildingType;
		int m_iSlot;
		bool m_bTransferred;
	};
	std::vector<CopyGreatWorkData> paGreatWorkData;
	int iOldCityX = pOldCity->getX();
	int iOldCityY = pOldCity->getY();
	eOldOwner = pOldCity->getOwner();
	eOriginalOwner = pOldCity->getOriginalOwner();
	iGameTurnFounded = pOldCity->getGameTurnFounded();
	iPopulation = pOldCity->getPopulation();
	iOldPopulation = iPopulation;
	iHighestPopulation = pOldCity->getHighestPopulation();
	bool bEverCapital = pOldCity->IsEverCapital();
	strName = pOldCity->getNameKey();
	int iOldCultureLevel = pOldCity->GetJONSCultureLevel();
	bool bHasMadeAttack = pOldCity->isMadeAttack();
#if defined(MOD_BALANCE_CORE)
	bool bNeedsWarmonger = pOldCity->IsNoWarmongerYet();
#endif

	tempReligions.Init(pOldCity);
	tempReligions.Copy(pOldCity->GetCityReligions());

	iBattleDamage = pOldCity->getDamage();

	// Traded cities between humans don't heal (an exploit would be to trade a city back and forth between teammates to get an instant heal.)
	if(!bGift || !isHuman() || !GET_PLAYER(pOldCity->getOwner()).isHuman())
	{
		int iBattleDamgeThreshold = pOldCity->GetMaxHitPoints() * /*50*/ GC.getCITY_CAPTURE_DAMAGE_PERCENT();
		iBattleDamgeThreshold /= 100;

		if(iBattleDamage > iBattleDamgeThreshold)
		{
			iBattleDamage = iBattleDamgeThreshold;
		}
	}

	for(iI = 0; iI < MAX_PLAYERS; iI++)
	{
		abEverOwned[iI] = pOldCity->isEverOwned((PlayerTypes)iI);
	}

	abEverOwned[GetID()] = true;
#if defined(MOD_BALANCE_CORE)
	bool abTraded[MAX_PLAYERS];
	int aiNumTimesOwned[MAX_PLAYERS];
	for(iI = 0; iI < MAX_PLAYERS; iI++)
	{
		abTraded[iI] = pOldCity->IsTraded((PlayerTypes)iI);
		aiNumTimesOwned[iI] = pOldCity->GetNumTimesOwned((PlayerTypes)iI);
	}
#endif

	for(iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		paiNumRealBuilding[iI] = pOldCity->GetCityBuildings()->GetNumRealBuilding((BuildingTypes)iI);
		paiBuildingOriginalOwner[iI] = pOldCity->GetCityBuildings()->GetBuildingOriginalOwner((BuildingTypes)iI);
		paiBuildingOriginalTime[iI] = pOldCity->GetCityBuildings()->GetBuildingOriginalTime((BuildingTypes)iI);

		if (pOldCity->GetCityBuildings()->GetNumBuilding((BuildingTypes)iI) > 0)
		{
			CvBuildingEntry *pkBuilding = GC.getBuildingInfo((BuildingTypes)iI);
			if (pkBuilding)
			{
				for (int jJ = 0; jJ < pkBuilding->GetGreatWorkCount(); jJ++)
				{
					int iGreatWork = pOldCity->GetCityBuildings()->GetBuildingGreatWork((BuildingClassTypes)pkBuilding->GetBuildingClassType(), jJ);
					if (iGreatWork != NO_GREAT_WORK)
					{
						CopyGreatWorkData kData;
						kData.m_iGreatWork = iGreatWork;
						kData.m_eBuildingType = (BuildingTypes)iI;
						kData.m_iSlot = jJ;
						kData.m_bTransferred = false;
						paGreatWorkData.push_back(kData);

						CvPlayer &kOldCityPlayer = GET_PLAYER(pOldCity->getOriginalOwner());
						if (kOldCityPlayer.GetCulture()->GetSwappableWritingIndex() == iGreatWork)
						{
							kOldCityPlayer.GetCulture()->SetSwappableWritingIndex(-1);
						}
						if (kOldCityPlayer.GetCulture()->GetSwappableArtifactIndex() == iGreatWork)
						{
							kOldCityPlayer.GetCulture()->SetSwappableArtifactIndex(-1);
						}
						if (kOldCityPlayer.GetCulture()->GetSwappableArtIndex() == iGreatWork)
						{
							kOldCityPlayer.GetCulture()->SetSwappableArtIndex(-1);
						}
						if (kOldCityPlayer.GetCulture()->GetSwappableMusicIndex() == iGreatWork)
						{
							kOldCityPlayer.GetCulture()->SetSwappableMusicIndex(-1);
						}
					}
				}
			}
		}
	}

	std::vector<BuildingYieldChange> aBuildingYieldChange;
	for(iI = 0; iI < GC.getNumBuildingClassInfos(); ++iI)
	{
		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo((BuildingClassTypes)iI);
		if(!pkBuildingClassInfo)
		{
			continue;
		}

		for(int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
		{
			BuildingYieldChange kChange;
			kChange.eBuildingClass = (BuildingClassTypes)iI;
			kChange.eYield = (YieldTypes)iYield;
			kChange.iChange = pOldCity->GetCityBuildings()->GetBuildingYieldChange((BuildingClassTypes)iI, (YieldTypes)iYield);
			if(0 != kChange.iChange)
			{
				aBuildingYieldChange.push_back(kChange);
			}
		}
	}

	bRecapture = false; //((eHighestCulturePlayer != NO_PLAYER) ? (GET_PLAYER(eHighestCulturePlayer).getTeam() == getTeam()) : false);

	// Returning spies back to pool
	CvCityEspionage* pOldCityEspionage = pOldCity->GetCityEspionage();
	if(pOldCityEspionage)
	{
		for(int i = 0; i < MAX_MAJOR_CIVS; i++)
		{
			int iAssignedSpy = pOldCityEspionage->m_aiSpyAssignment[i];
			// if there is a spy in the city
			if(iAssignedSpy != -1)
			{
				CvNotifications* pNotifications = GET_PLAYER((PlayerTypes)i).GetNotifications();
				if(pNotifications)
				{
					CvPlayerEspionage* pEspionage = GET_PLAYER((PlayerTypes)i).GetEspionage();
					CvEspionageSpy* pSpy = &(pEspionage->m_aSpyList[iAssignedSpy]);

					Localization::String strSummary;
					Localization::String strNotification;
					if(bConquest)
					{
						strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SPY_EVICTED_CONQUEST_S");
						if(((PlayerTypes)i) == GetID())
						{
							strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_EVICTED_CONQUEST_YOU");
							strNotification << pEspionage->GetSpyRankName(pSpy->m_eRank);
#if defined(MOD_BUGFIX_SPY_NAMES)
							strNotification << pSpy->GetSpyName(&GET_PLAYER((PlayerTypes)i));
#else
							strNotification << GET_PLAYER((PlayerTypes)i).getCivilizationInfo().getSpyNames(pSpy->m_iName);
#endif
							strNotification << pOldCity->getNameKey();
						}
						else
						{
							strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_EVICTED_CONQUEST");
							strNotification << pEspionage->GetSpyRankName(pSpy->m_eRank);
#if defined(MOD_BUGFIX_SPY_NAMES)
							strNotification << pSpy->GetSpyName(&GET_PLAYER((PlayerTypes)i));
#else
							strNotification << GET_PLAYER((PlayerTypes)i).getCivilizationInfo().getSpyNames(pSpy->m_iName);
#endif
							strNotification << pOldCity->getNameKey();
							strNotification << getCivilizationInfo().getShortDescriptionKey();
						}
					}
					else
					{
						strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SPY_EVICTED_TRADE_S");
						if(((PlayerTypes)i) == GetID())
						{
							strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_EVICTED_TRADE_YOU");
							strNotification << pEspionage->GetSpyRankName(pSpy->m_eRank);
#if defined(MOD_BUGFIX_SPY_NAMES)
							strNotification << pSpy->GetSpyName(&GET_PLAYER((PlayerTypes)i));
#else
							strNotification << GET_PLAYER((PlayerTypes)i).getCivilizationInfo().getSpyNames(pSpy->m_iName);
#endif
							strNotification << pOldCity->getNameKey();
						}
						else
						{
							strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_EVICTED_TRADE");
							strNotification << pEspionage->GetSpyRankName(pSpy->m_eRank);
#if defined(MOD_BUGFIX_SPY_NAMES)
							strNotification << pSpy->GetSpyName(&GET_PLAYER((PlayerTypes)i));
#else
							strNotification << GET_PLAYER((PlayerTypes)i).getCivilizationInfo().getSpyNames(pSpy->m_iName);
#endif
							strNotification << pOldCity->getNameKey();
							strNotification << getCivilizationInfo().getShortDescriptionKey();
						}
					}

					pNotifications->Add(NOTIFICATION_SPY_EVICTED, strNotification.toUTF8(), strSummary.toUTF8(), -1, -1, pOldCity->getOwner());
				}

				GET_PLAYER((PlayerTypes)i).GetEspionage()->ExtractSpyFromCity(iAssignedSpy);
				// create notifications indicating what has happened with the spy
			}
		}
	}

	GC.getGame().GetGameTrade()->ClearAllCityTradeRoutes(pCityPlot);

	bool bCapital = pOldCity->isCapital();

	// find the plot
	FStaticVector<int, 121, true, c_eCiv5GameplayDLL, 0> aiPurchasedPlotX;
	FStaticVector<int, 121, true, c_eCiv5GameplayDLL, 0> aiPurchasedPlotY;
	const int iMaxRange = /*5*/ GC.getMAXIMUM_ACQUIRE_PLOT_DISTANCE();

	for(int iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);
		if(pLoopPlot && pLoopPlot->GetCityPurchaseOwner() == eOldOwner && pLoopPlot->GetCityPurchaseID() == pOldCity->GetID())
		{
			aiPurchasedPlotX.push_back(pLoopPlot->getX());
			aiPurchasedPlotY.push_back(pLoopPlot->getY());
			pLoopPlot->ClearCityPurchaseInfo();
		}
	}

	int iOldCityRings = pOldCity->getWorkPlotDistance();

#if defined(MOD_GLOBAL_VENICE_KEEPS_RESOURCES)
	pOldCity->PreKill(bVenice);
#else
	pOldCity->PreKill();
#endif

	{
		auto_ptr<ICvCity1> pkDllOldCity(new CvDllCity(pOldCity));
		gDLL->GameplayCityCaptured(pkDllOldCity.get(), GetID());
	}

	GET_PLAYER(eOldOwner).deleteCity(pOldCity->GetID());
	// adapted from PostKill()

	GC.getGame().addReplayMessage(REPLAY_MESSAGE_CITY_CAPTURED, m_eID, "", pCityPlot->getX(), pCityPlot->getY());

	PlayerTypes ePlayer;
	// Update Proximity between this Player and all others
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		ePlayer = (PlayerTypes) iPlayerLoop;

		if(ePlayer != m_eID)
		{
			if(GET_PLAYER(ePlayer).isAlive())
			{
				GET_PLAYER(m_eID).DoUpdateProximityToPlayer(ePlayer);
				GET_PLAYER(ePlayer).DoUpdateProximityToPlayer(m_eID);
			}
		}
	}

	GC.getMap().updateWorkingCity(pCityPlot,iOldCityRings*2);
	// Lost the capital!
	if(bCapital)
	{
#if defined(MOD_GLOBAL_NO_CONQUERED_SPACESHIPS)
		GET_PLAYER(eOldOwner).disassembleSpaceship(pCityPlot);
#endif
		GET_PLAYER(eOldOwner).findNewCapital();
		GET_TEAM(getTeam()).resetVictoryProgress();
	}

	GC.GetEngineUserInterface()->setDirty(NationalBorders_DIRTY_BIT, true);
	// end adapted from PostKill()

#if defined(MOD_API_EXTENSIONS)
	pNewCity = initCity(pCityPlot->getX(), pCityPlot->getY(), !bConquest, (!bConquest && !bGift), NO_RELIGION, strName.c_str());
#else
	pNewCity = initCity(pCityPlot->getX(), pCityPlot->getY(), !bConquest, (!bConquest && !bGift));
#endif

	CvAssertMsg(pNewCity != NULL, "NewCity is not assigned a valid value");

#ifdef _MSC_VER
#pragma warning ( push )
#pragma warning ( disable : 6011 ) 
#endif

	// For buyouts, set it up like a new city founded by this player, to avoid liberation later on etc.
	if(bIsMinorCivBuyout)
	{
#if defined(MOD_GLOBAL_CS_LIBERATE_AFTER_BUYOUT)
		if (MOD_GLOBAL_CS_LIBERATE_AFTER_BUYOUT) {
			pNewCity->setPreviousOwner(eOldOwner);
			pNewCity->setOriginalOwner(eOriginalOwner);
			pNewCity->setGameTurnFounded(iGameTurnFounded);
			pNewCity->SetEverCapital(bEverCapital);
		} else {
#endif
			pNewCity->setPreviousOwner(NO_PLAYER);
			pNewCity->setOriginalOwner(m_eID);
			pNewCity->setGameTurnFounded(GC.getGame().getGameTurn());
			pNewCity->SetEverCapital(false);
#if defined(MOD_GLOBAL_CS_LIBERATE_AFTER_BUYOUT)
		}
#endif

		AwardFreeBuildings(pNewCity);
	}
	// Otherwise, set it up using the data from the old city
	else
	{
		pNewCity->setPreviousOwner(eOldOwner);
		pNewCity->setOriginalOwner(eOriginalOwner);
		pNewCity->setGameTurnFounded(iGameTurnFounded);
		pNewCity->SetEverCapital(bEverCapital);
	}

	// Population change for capturing a city
#if defined(MOD_BALANCE_CORE)
	if(!bRecapture && bConquest && bSlaughter)	
#else
	if(!bRecapture && bConquest)	// Don't drop it if we're recapturing our own City
#endif
	{
		int iPercentPopulationRetained = /*50*/ GC.getCITY_CAPTURE_POPULATION_PERCENT();
		int iInfluenceReduction = GetCulture()->GetInfluenceCityConquestReduction(eOldOwner);
		iPercentPopulationRetained += (iInfluenceReduction * (100 - iPercentPopulationRetained) / 100);

		iPopulation = max(1, iPopulation * iPercentPopulationRetained / 100);
	}
#if defined(MOD_BALANCE_CORE)
	pNewCity->setPopulation(iPopulation, true, true);
#else
	pNewCity->setPopulation(iPopulation);
#endif
	pNewCity->setHighestPopulation(iHighestPopulation);
	pNewCity->setName(strName);
	pNewCity->setNeverLost(false);
	pNewCity->setDamage(iBattleDamage,true);
	pNewCity->setMadeAttack(bHasMadeAttack);
#if defined(MOD_BALANCE_CORE)
	pNewCity->SetNoWarmonger(bNeedsWarmonger);
#endif

	for(iI = 0; iI < MAX_PLAYERS; iI++)
	{
		pNewCity->setEverOwned(((PlayerTypes)iI), abEverOwned[iI]);
#if defined(MOD_BALANCE_CORE)
		if((PlayerTypes)iI != NO_PLAYER)
		{
			pNewCity->SetFranchised((PlayerTypes)iI, false);
			pNewCity->SetHasOffice(false);
		}
#endif
#if defined(MOD_BALANCE_CORE)
		pNewCity->SetTraded(((PlayerTypes)iI), abTraded[iI]);
		pNewCity->SetNumTimesOwned(((PlayerTypes)iI), aiNumTimesOwned[iI]);
#endif
	}

	//I've traded for this? I don't want to give away again
	if (bGift)
		pNewCity->SetTraded( GetID(), true);

	pNewCity->SetJONSCultureLevel(iOldCultureLevel);
	pNewCity->GetCityReligions()->Copy(&tempReligions);
	pNewCity->GetCityReligions()->RemoveFormerPantheon();

	if(bCapital)
	{
		GET_PLAYER(eOldOwner).SetHasLostCapital(true, m_eID);
	}

	CvCivilizationInfo& playerCivilizationInfo = getCivilizationInfo();
#if defined(MOD_BALANCE_CORE)
	if(GetPlayerTraits()->IsReconquista())
	{
		ReligionTypes eReligion = GetReligions()->GetReligionCreatedByPlayer(false);
		if(eReligion != NO_RELIGION)
		{
			pNewCity->GetCityReligions()->AdoptReligionFully(eReligion);
		}
		else
		{
			eReligion = GetReligions()->GetReligionInMostCities();
			if(eReligion != NO_RELIGION)
			{
				pNewCity->GetCityReligions()->AdoptReligionFully(eReligion);
			}
		}
	}
#endif
#if !defined(NO_ACHIEVEMENTS)
	if(bConquest && !GC.getGame().isGameMultiPlayer() && isHuman())
	{
		const char* szCivKey = getCivilizationTypeKey();

		// Check for Kris Swordsman achievement
		if(strcmp(szCivKey, "CIVILIZATION_INDONESIA") == 0)
		{
			CvUnit *pConqueringUnit = pCityPlot->getUnitByIndex(0);
			if (pConqueringUnit->getUnitType() == (UnitTypes)GC.getInfoTypeForString("UNIT_KRIS_SWORDSMAN", true))
			{
				PromotionTypes ePromotion = (PromotionTypes)GC.getInfoTypeForString("PROMOTION_ENEMY_BLADE", true);
				if (pConqueringUnit->isHasPromotion(ePromotion))
				{
					gDLL->UnlockAchievement(ACHIEVEMENT_XP2_21);
				}
			}
		}

		// Check for Rome conquering Statue of Zeus Achievement
		bool bUsingXP1Scenario1 = gDLL->IsModActivated(CIV5_XP1_SCENARIO1_MODID);
		bool bUsingXP1Scenario2 = gDLL->IsModActivated(CIV5_XP1_SCENARIO2_MODID);
		bool bUsingXP2Scenario1 = gDLL->IsModActivated(CIV5_XP2_SCENARIO1_MODID);

		const char* szNameKey = pNewCity->getNameKey();
		if(bUsingXP2Scenario1)
		{
			if(strcmp(szCivKey, "CIVILIZATION_ENGLAND") == 0)
			{
				if(strcmp(szNameKey, "TXT_KEY_CIVIL_WAR_SCENARIO_CITY_NAME_GETTYSBURG") == 0)
				{
					CvUnit *pConqueringUnit = pCityPlot->getUnitByIndex(0);
					PromotionTypes ePromotion = (PromotionTypes)GC.getInfoTypeForString("PROMOTION_PICKETT", true);
					if (pConqueringUnit->isHasPromotion(ePromotion))
					{
						gDLL->UnlockAchievement(ACHIEVEMENT_XP2_59);
					}
				}
			}
		}

		if(bUsingXP1Scenario1)
		{
			const HandicapTypes eCurrentHandicap = GC.getGame().getHandicapType();
			HandicapTypes eEmporerHandicap = NO_HANDICAP;
			HandicapTypes eDeityHandicap = NO_HANDICAP;

			const int numHandicapInfos = GC.getNumHandicapInfos();
			for(int i = 0; i < numHandicapInfos; ++i)
			{
				const HandicapTypes eHandicap = static_cast<HandicapTypes>(i);
				CvHandicapInfo* pkInfo = GC.getHandicapInfo(eHandicap);
				if(pkInfo != NULL)
				{
					if(strcmp(pkInfo->GetType(), "HANDICAP_EMPEROR") == 0)
					{
						eEmporerHandicap = eHandicap;
					}
					else if(strcmp(pkInfo->GetType(), "HANDICAP_DEITY") == 0)
					{
						eDeityHandicap = eHandicap;
					}
				}
			}

			if(szCivKey && szNameKey)
			{
				if(strcmp(szCivKey, "CIVILIZATION_ENGLAND") == 0)
				{
					if(strcmp(szNameKey, "TXT_KEY_CITYSTATE_JERUSALEM") == 0)
					{
						if(eCurrentHandicap >= eEmporerHandicap)
						{
							gDLL->UnlockAchievement(ACHIEVEMENT_XP1_39);
						}
					}
				}
				else if(strcmp(szCivKey, "CIVILIZATION_OTTOMAN") == 0)
				{
					if(strcmp(szNameKey, "TXT_KEY_CITY_NAME_CONSTANTINOPLE") == 0)
					{
						if(eCurrentHandicap >= eDeityHandicap)
						{
							gDLL->UnlockAchievement(ACHIEVEMENT_XP1_40);
						}
					}
				}
			}	
		}

		if(bUsingXP1Scenario2)
		{
			bool bHasConstantinople = false;
			bool bHasRome = false;

			if(strcmp(szNameKey, "TXT_KEY_CITY_NAME_CONSTANTINOPLE") == 0)
			{
				bHasConstantinople = true;

				if(pNewCity->getOriginalOwner() != GetID())
				{
					gDLL->UnlockAchievement(ACHIEVEMENT_XP1_47);
				}
			}
			else if(strcmp(szNameKey, "TXT_KEY_CITY_NAME_ROME") == 0)
			{
				bHasRome = true;
			}

			if(bHasConstantinople || bHasRome)
			{
				int iLoop = 0;
				for(CvCity* pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
				{
					const char* szOtherNameKey = pCity->getNameKey();
					if(strcmp(szOtherNameKey, "TXT_KEY_CITY_NAME_CONSTANTINOPLE") == 0)
					{
						bHasConstantinople = true;
					}
					else if(strcmp(szOtherNameKey, "TXT_KEY_CITY_NAME_ROME") == 0)
					{
						bHasRome = true;
					}
				}
			}

			if(bHasRome && bHasConstantinople)
			{
				gDLL->UnlockAchievement(ACHIEVEMENT_XP1_48);
			}

			if(strcmp(getCivilizationTypeKey(), "CIVILIZATION_CELTS") == 0)
			{
				//Did we cap what was originally a sassinid city?
				typedef std::pair<int,int> Location;
				typedef std::tr1::array<Location, 7> SassanidCityArray;
				SassanidCityArray SassanidCities = {
					Location(87,17), //Ctesiphon
					Location(85,20), //Singara
					Location(81,21), //Nisibis
					Location(79,24), //Amida
					Location(82,28), //Thospia
					Location(81,33), //Anium
					Location(87,33), //Artaxata
				};
				
				int iNewPlotX = pNewCity->getX();
				int iNewPlotY = pNewCity->getY();

				//Test if we still own each city.
				for(SassanidCityArray::iterator it = SassanidCities.begin(); it != SassanidCities.end(); ++it)
				{
					if(it->first == iNewPlotX && it->second == iNewPlotY)
					{
						gDLL->UnlockAchievement(ACHIEVEMENT_XP1_51);

					}
				}
			}

		}
	}
#endif
#if defined(MOD_BALANCE_CORE)
	if(bConquest && !bGift)
	{
#endif
	std::vector<BuildingTypes> freeConquestBuildings = m_pPlayerPolicies->GetFreeBuildingsOnConquest();
	for(iI = 0; iI < (int)freeConquestBuildings.size(); iI++)
	{
		const BuildingTypes eLoopBuilding = freeConquestBuildings[iI];
		if (eLoopBuilding != NO_BUILDING)
		{
			CvBuildingEntry* pkLoopBuildingInfo = GC.getBuildingInfo(eLoopBuilding);
			if(pkLoopBuildingInfo)
			{
				if (eLoopBuilding == pkLoopBuildingInfo->GetID())
				{
#if defined(MOD_BUGFIX_BUILDINGCLASS_NOT_BUILDING)
					BuildingTypes eFreeBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(pkLoopBuildingInfo->GetBuildingClassType());
					pNewCity->GetCityBuildings()->SetNumRealBuilding(eFreeBuilding, 0);
					pNewCity->GetCityBuildings()->SetNumFreeBuilding(eFreeBuilding, 1);
#else
					pNewCity->GetCityBuildings()->SetNumFreeBuilding(eLoopBuilding, 1);
#endif
				}
			}
		}
	}
#if defined(MOD_BALANCE_CORE)
	}
	// Free Buildings from Policies
	if(MOD_BALANCE_CORE)
	{
		for(iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
		{
			const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iI);
			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
			if(pkBuildingClassInfo)
			{
				int iNumFreeBuildings = GetNumCitiesFreeChosenBuilding(eBuildingClass);
				if(iNumFreeBuildings > 0)
				{
					const BuildingTypes eBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(pkBuildingClassInfo->GetID())));
					if(NO_BUILDING != eBuilding)
					{
						CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
						if(pkBuildingInfo)
						{
							if(pNewCity->isValidBuildingLocation(eBuilding))
							{
								if(pNewCity->GetCityBuildings()->GetNumRealBuilding(eBuilding) > 0)
								{
									pNewCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, 0);
								}

								pNewCity->GetCityBuildings()->SetNumFreeBuilding(eBuilding, 1);

								if(pNewCity->GetCityBuildings()->GetNumFreeBuilding(eBuilding) > 0)
								{
									ChangeNumCitiesFreeChosenBuilding(eBuildingClass, -1);
								}
							}
						}
					}
				}
			}
		}
	}
#endif
	BuildingTypes eTraitFreeBuilding = GetPlayerTraits()->GetFreeBuildingOnConquest();
	for(iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		const BuildingTypes eLoopBuilding = static_cast<BuildingTypes>(iI);
		CvBuildingEntry* pkLoopBuildingInfo = GC.getBuildingInfo(eLoopBuilding);
		if(pkLoopBuildingInfo)
		{
			const CvBuildingClassInfo& kLoopBuildingClassInfo = pkLoopBuildingInfo->GetBuildingClassInfo();

			int iNum = 0;

			if(eTraitFreeBuilding == pkLoopBuildingInfo->GetID())
			{
				pNewCity->GetCityBuildings()->SetNumFreeBuilding(eTraitFreeBuilding, 1);
			}

			else if(paiNumRealBuilding[iI] > 0)
			{
				const BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkLoopBuildingInfo->GetBuildingClassType();
				if(::isWorldWonderClass(kLoopBuildingClassInfo))
				{
					eBuilding = eLoopBuilding;
				}
#if defined(MOD_BALANCE_CORE)
				else if(GetPlayerTraits()->IsKeepConqueredBuildings())
				{
					eBuilding = eLoopBuilding;
				}
#endif
				else
				{
					eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings(eBuildingClass);
				}

				if(eBuilding != NO_BUILDING)
				{
					CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
					if(pkBuildingInfo)
					{
						if(!pkLoopBuildingInfo->IsNeverCapture())
						{
							if(!isProductionMaxedBuildingClass(((BuildingClassTypes)(pkBuildingInfo->GetBuildingClassType())), true))
							{
								// here would be a good place to put additional checks (for example, influence)
#if defined(MOD_BALANCE_CORE)
								if(GetPlayerTraits()->IsKeepConqueredBuildings() || !bConquest || bGift || bRecapture || (GC.getGame().getJonRandNum(100, "Capture Probability") < pkLoopBuildingInfo->GetConquestProbability()))
#else
								if(!bConquest || bRecapture || (GC.getGame().getJonRandNum(100, "Capture Probability") < pkLoopBuildingInfo->GetConquestProbability()))
#endif
								{
									iNum += paiNumRealBuilding[iI];
								}
							}
						}

#if !defined(NO_ACHIEVEMENTS)
						// Check for Tomb Raider Achievement
						if(bConquest && !GC.getGame().isGameMultiPlayer() && pkLoopBuildingInfo->GetType() && _stricmp(pkLoopBuildingInfo->GetType(), "BUILDING_BURIAL_TOMB") == 0 && isHuman())
						{
							if(iCaptureGold > 0)  //Need to actually pillage something from the 'tomb'
							{
								gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_TOMBRAIDER);
							}
						}
#endif

#if !defined(NO_ACHIEVEMENTS)
						// Check for Rome conquering Statue of Zeus Achievement
						if(bConquest && !GC.getGame().isGameMultiPlayer() && pkLoopBuildingInfo->GetType() && _stricmp(pkLoopBuildingInfo->GetType(), "BUILDING_STATUE_ZEUS") == 0 && isHuman())
						{
							const char* pkCivKey = getCivilizationTypeKey();
							if(pkCivKey && strcmp(pkCivKey, "CIVILIZATION_ROME") == 0)
							{
								gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_ROME_GETS_ZEUS);
							}
						}
#endif

						pNewCity->GetCityBuildings()->SetNumRealBuildingTimed(eBuilding, iNum, false, ((PlayerTypes)(paiBuildingOriginalOwner[iI])), paiBuildingOriginalTime[iI]);

						if (iNum > 0)
						{
							if (pkBuildingInfo->GetGreatWorkCount() > 0)
							{
								for (unsigned int jJ=0; jJ < paGreatWorkData.size(); jJ++)
								{
									if (paGreatWorkData[jJ].m_eBuildingType == iI)
									{
										pNewCity->GetCityBuildings()->SetBuildingGreatWork(eBuildingClass, paGreatWorkData[jJ].m_iSlot, paGreatWorkData[jJ].m_iGreatWork);
										paGreatWorkData[jJ].m_bTransferred = true;
										iCaptureGreatWorks++;
									}
								}
							}
						}
					}
				}
			}
		}
	}
	for(std::vector<BuildingYieldChange>::iterator it = aBuildingYieldChange.begin(); it != aBuildingYieldChange.end(); ++it)
	{
		pNewCity->GetCityBuildings()->SetBuildingYieldChange((*it).eBuildingClass, (*it).eYield, (*it).iChange);
	}

	// Distribute any remaining Great Works to other buildings
	for (unsigned int jJ=0; jJ < paGreatWorkData.size(); jJ++)
	{
		if (!paGreatWorkData[jJ].m_bTransferred)
		{
			BuildingClassTypes eBuildingClass = NO_BUILDINGCLASS; // Passed by reference below
			int iSlot = -1; // Passed by reference below
			GreatWorkType eType = GC.getGame().GetGameCulture()->m_CurrentGreatWorks[paGreatWorkData[jJ].m_iGreatWork].m_eType;
			GreatWorkSlotType eGreatWorkSlot = CultureHelpers::GetGreatWorkSlot(eType);
			if (pNewCity->GetCityBuildings()->GetNextAvailableGreatWorkSlot(eGreatWorkSlot, &eBuildingClass, &iSlot))
			{
				pNewCity->GetCityBuildings()->SetBuildingGreatWork(eBuildingClass, iSlot, paGreatWorkData[jJ].m_iGreatWork);
				paGreatWorkData[jJ].m_bTransferred = true;
				iCaptureGreatWorks++;
			}
			else
			{
				BuildingClassTypes eGWBuildingClass;
				int iGWSlot;
				CvCity *pGWCity = GetCulture()->GetClosestAvailableGreatWorkSlot(pCityPlot->getX(), pCityPlot->getY(), eGreatWorkSlot, &eGWBuildingClass, &iGWSlot);
				if (pGWCity)
				{
					pGWCity->GetCityBuildings()->SetBuildingGreatWork(eGWBuildingClass, iGWSlot, paGreatWorkData[jJ].m_iGreatWork);
					paGreatWorkData[jJ].m_bTransferred = true;
					iCaptureGreatWorks++;
				}
			}
		}
	}

	// Did we re-acquire our Capital?
	if(pCityPlot->getX() == GetOriginalCapitalX() && pCityPlot->getY() == GetOriginalCapitalY())
	{
		SetHasLostCapital(false, NO_PLAYER);

		const BuildingTypes eCapitalBuilding = (BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(GC.getCAPITAL_BUILDINGCLASS()));
		if(eCapitalBuilding != NO_BUILDING)
		{
#if defined(MOD_EVENTS_CITY_CAPITAL)
			CvCity* pOldCapital = getCapitalCity();
			if (pOldCapital != NULL)
#else
			if (getCapitalCity() != NULL)
#endif
			{
				getCapitalCity()->GetCityBuildings()->SetNumRealBuilding(eCapitalBuilding, 0);
			}
			CvAssertMsg(!(pNewCity->GetCityBuildings()->GetNumRealBuilding(eCapitalBuilding)), "(pBestCity->getNumRealBuilding(eCapitalBuilding)) did not return false as expected");
			pNewCity->GetCityBuildings()->SetNumRealBuilding(eCapitalBuilding, 1);

#if defined(MOD_EVENTS_CITY_CAPITAL)
			if (MOD_EVENTS_CITY_CAPITAL) {
				GAMEEVENTINVOKE_HOOK(GAMEEVENT_CapitalChanged, GetID(), pNewCity->GetID(), (pOldCapital ? pOldCapital->GetID() : -1));
			}
#endif
		}
	}

	// slewis - moved this here so that conquest victory is tested with each city capture
	GC.getGame().DoTestConquestVictory();

	GC.getMap().updateWorkingCity(pCityPlot,pNewCity->getWorkPlotDistance()*2);
	if(bConquest)
	{
		for(int iDX = -iMaxRange; iDX <= iMaxRange; iDX++)
		{
			for(int iDY = -iMaxRange; iDY <= iMaxRange; iDY++)
			{
				CvPlot* pLoopPlot = plotXYWithRangeCheck(iOldCityX, iOldCityY, iDX, iDY, iMaxRange);
				if(pLoopPlot)
				{
					pLoopPlot->verifyUnitValidPlot();
				}
			}
		}

#if !defined(NO_ACHIEVEMENTS)
		// Check for Askia Achievement
		if(isHuman() && !CvPreGame::isNetworkMultiplayerGame())
		{
			const char* pkLeaderKey = getLeaderTypeKey();
			if(pkLeaderKey && strcmp(pkLeaderKey, "LEADER_ASKIA") == 0)
			{
				CvCity* pkCaptialCity = getCapitalCity();
				if(pkCaptialCity != NULL)	// Shouldn't be NULL, but...
				{
					CvPlot* pkCapitalPlot = pkCaptialCity->plot();
					CvPlot* pkNewCityPlot = pNewCity->plot();
					if(pkCapitalPlot && pkNewCityPlot)
					{
						// Get the area each plot is located in.
						CvArea* pkCapitalArea = pkCapitalPlot->area();
						CvArea* pkNewCityArea = pkNewCityPlot->area();

						if(pkCapitalArea && pkNewCityArea)
						{
							// The area the new city is locate on has to be of a certain size to qualify so that tiny islands are not included
#define ACHIEVEMENT_MIN_CONTINENT_SIZE	8
							if(pkNewCityArea->GetID() != pkCapitalArea->GetID() && pkNewCityArea->getNumTiles() >= ACHIEVEMENT_MIN_CONTINENT_SIZE)
							{
								gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_WARCANOE);
							}
						}
					}
				}
			}
		}
#endif
	}

	pCityPlot->setRevealed(GET_PLAYER(eOldOwner).getTeam(), true);

	// If the old owner is "killed," then notify everyone's Grand Strategy AI
	if(GET_PLAYER(eOldOwner).getNumCities() == 0 && !GET_PLAYER(eOldOwner).GetPlayerTraits()->IsStaysAliveZeroCities() && !bIsMinorCivBuyout)
	{
		if(!isMinorCiv() && !isBarbarian())
		{
			for(int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)
			{
				if(GetID() != iMajorLoop && GET_PLAYER((PlayerTypes) iMajorLoop).isAlive())
				{
					// Have I met the player who killed the guy?
					if(GET_TEAM(GET_PLAYER((PlayerTypes) iMajorLoop).getTeam()).isHasMet(getTeam()))
					{
						GET_PLAYER((PlayerTypes) iMajorLoop).GetDiplomacyAI()->DoPlayerKilledSomeone(GetID(), eOldOwner);
					}
				}
			}

#if defined(MOD_DIPLOMACY_CITYSTATES)
			//Let's give the Embassies of the defeated player to the new player
			if(MOD_DIPLOMACY_CITYSTATES && GET_PLAYER(eOldOwner).GetImprovementLeagueVotes() > 0)
			{
				int iEmbassyVotes = GET_PLAYER(eOldOwner).GetImprovementLeagueVotes();
				ChangeImprovementLeagueVotes(iEmbassyVotes);
			}
#endif
		}
	}
#if defined(MOD_DIPLOMACY_CITYSTATES)
	if(GET_PLAYER(eOldOwner).isMinorCiv() && GET_PLAYER(eOldOwner).getNumCities() == 0)
	{
		for(int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)
		{
			PlayerTypes ePlayer = (PlayerTypes)iMajorLoop;
			if(ePlayer != NO_PLAYER && !GET_PLAYER(ePlayer).isMinorCiv())
			{
				if(GET_PLAYER(eOldOwner).GetIncomingUnitCountdown(ePlayer) > 0)
				{
					// Must have capital to actually spawn unit
					CvCity* pCapital = GET_PLAYER(ePlayer).getCapitalCity();
					if(pCapital)
					{
						if(GET_PLAYER(eOldOwner).GetIncomingUnitType(ePlayer) != NO_UNIT)
						{
							CvUnit* pNewUnit = GET_PLAYER(ePlayer).initUnit(GET_PLAYER(eOldOwner).GetIncomingUnitType(ePlayer), pCapital->getX(), pCapital->getY());
							CvAssert(pNewUnit);
							if (pNewUnit)
							{
								if(pNewUnit->getDomainType() != DOMAIN_AIR)
								{
									if (!pNewUnit->jumpToNearestValidPlot())
									{
										pNewUnit->kill(false);
									}
								}
								CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();
								if(pNotifications && ePlayer == GC.getGame().getActivePlayer())
								{
									Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CS_GIFT_RETURNED_SUMMARY");
									strSummary <<  GET_PLAYER(eOldOwner).getCivilizationShortDescriptionKey();
									Localization::String strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_CS_GIFT_RETURNED");
									strNotification <<  GET_PLAYER(eOldOwner).getNameKey();
									strNotification <<  pNewUnit->getNameKey();
									pNotifications->Add(NOTIFICATION_GENERIC, strNotification.toUTF8(), strSummary.toUTF8(), pCapital->getX(), pCapital->getY(), -1);
								}
							}
						}
					}
				}
				GET_PLAYER(eOldOwner).GetMinorCivAI()->SetJerk(GET_PLAYER((PlayerTypes) iMajorLoop).getTeam(), 0);
			}
		}
	}			
#endif
	// If not, old owner should look at city specializations
	else
	{
		GET_PLAYER(eOldOwner).GetCitySpecializationAI()->SetSpecializationsDirty(SPECIALIZATION_UPDATE_MY_CITY_CAPTURED);
	}

	// Do the same for the new owner
	GetCitySpecializationAI()->SetSpecializationsDirty(SPECIALIZATION_UPDATE_ENEMY_CITY_CAPTURED);

	bool bDisbanded = false;

	// In OCC games, all captured cities are toast
	if(GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && isHuman())
	{
		bDisbanded = true;
		disband(pNewCity);
		// disband will delete the city
		pNewCity = NULL;

		// Set the plots to no owner
		for(uint ui = 0; ui < aiPurchasedPlotX.size(); ui++)
		{
			CvPlot* pPlot = GC.getMap().plot(aiPurchasedPlotX[ui], aiPurchasedPlotY[ui]);
			pPlot->setOwner(NO_PLAYER, -1, /*bCheckUnits*/ true, /*bUpdateResources*/ true);
		}

	}
	else //if (bConquest)
	{
		// Set the plots to the new owner, now, we may be flipping it to a liberated player and we need to pass on the information.
		for(uint ui = 0; ui < aiPurchasedPlotX.size(); ui++)
		{
			CvPlot* pPlot = GC.getMap().plot(aiPurchasedPlotX[ui], aiPurchasedPlotY[ui]);
			if(pPlot->getOwner() != pNewCity->getOwner())
				pPlot->setOwner(pNewCity->getOwner(), /*iAcquireCityID*/ pNewCity->GetID(), /*bCheckUnits*/ true, /*bUpdateResources*/ true);
		}

		// Is this City being Occupied?
		if(pNewCity->getOriginalOwner() != GetID())
		{
			pNewCity->SetOccupied(true);

			int iInfluenceReduction = GetCulture()->GetInfluenceCityConquestReduction(eOldOwner);
#if defined(MOD_BALANCE_CORE)
			int iResistanceTurns = (((pNewCity->getPopulation() * 2) / 3) * (100 - iInfluenceReduction)) / 100;
			if(iResistanceTurns <= 0)
			{
				iResistanceTurns = 1;
			}
#else
			int iResistanceTurns = pNewCity->getPopulation() * (100 - iInfluenceReduction) / 100;
#endif

			if (iResistanceTurns > 0)
			{
				pNewCity->ChangeResistanceTurns(iResistanceTurns);
			}
		}

		long lResult = 0;

		if(lResult == 0)
		{
			PlayerTypes eLiberatedPlayer = NO_PLAYER;

			// Captured someone's city that didn't originally belong to us - Liberate a player?
			if(pNewCity->getOriginalOwner() != eOldOwner && pNewCity->getOriginalOwner() != GetID())
			{
				eLiberatedPlayer = pNewCity->getOriginalOwner();
				if(!CanLiberatePlayerCity(eLiberatedPlayer))
				{
					eLiberatedPlayer = NO_PLAYER;
				}
			}

#if defined(MOD_BUGFIX_VENICE_PUPPETS_CAPITAL)
			// Venice MUST liberate their own capital
			if (GetPlayerTraits()->IsNoAnnexing() && pNewCity->getX() == GetOriginalCapitalX() && pNewCity->getY() == GetOriginalCapitalY())
			{
				if (iCaptureGold > 0 || iCaptureCulture > 0 || iCaptureGreatWorks > 0) {
					if (iCaptureCulture == 0 && iCaptureGreatWorks == 0) {
						strBuffer = GetLocalizedText("TXT_KEY_POPUP_GOLD_CITY_CAPTURE", iCaptureGold, pNewCity->getNameKey());
					} else {
						strBuffer = GetLocalizedText("TXT_KEY_POPUP_GOLD_AND_CULTURE_CITY_CAPTURE", iCaptureGold, iCaptureCulture, iCaptureGreatWorks, pNewCity->getNameKey());
					}
					GC.GetEngineUserInterface()->AddCityMessage(0, pNewCity->GetIDInfo(), GetID(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer);
				}
			}
			else
#endif
			// AI decides what to do with a City
			if(!isHuman())
			{
#if defined(MOD_BALANCE_CORE)
				AI_conquerCity(pNewCity, eOldOwner, bGift); // could delete the pointer...
#else
				AI_conquerCity(pNewCity, eOldOwner); // could delete the pointer...
#endif
				// So we will check to see if the plot still contains the city.
				CvCity* pkCurrentCity = pCityPlot->getPlotCity();
				if (pkCurrentCity == NULL || pNewCity != pkCurrentCity || pkCurrentCity->getOwner() != GetID())
				{
					// The city is gone or is not ours anymore (we gave it away)
					pNewCity = NULL;
				}
			}

			// Human decides what to do with a City
			else if(!GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS))
			{
				// Used to display info for annex/puppet/raze popup - turned off in DoPuppet and DoAnnex
				pNewCity->SetIgnoreCityForHappiness(true);
				if (GetPlayerTraits()->IsNoAnnexing() && bIsMinorCivBuyout)
				{
					pNewCity->DoCreatePuppet();
				}
				else if (pNewCity->getOriginalOwner() != GetID() || GetPlayerTraits()->IsNoAnnexing() || bIsMinorCivBuyout)
				{
					if(GC.getGame().getActivePlayer() == GetID())
					{
						int iTemp[5] = { pNewCity->GetID(), iCaptureGold, iCaptureCulture, iCaptureGreatWorks, eLiberatedPlayer };
						bool bTemp[2] = { bIsMinorCivBuyout, bConquest };
						GC.GetEngineUserInterface()->AddPopup(BUTTONPOPUP_CITY_CAPTURED, POPUP_PARAM_INT_ARRAY(iTemp), POPUP_PARAM_BOOL_ARRAY(bTemp));
						// We are adding a popup that the player must make a choice in, make sure they are not in the end-turn phase.
						CancelActivePlayerEndTurn();
					}
				}
				else
				{
					pNewCity->SetIgnoreCityForHappiness(false);
				}
			}

			// No choice but to capture it, tell about pillage gold (if any)
			else if(iCaptureGold > 0 || iCaptureCulture > 0 || iCaptureGreatWorks > 0)
			{
				if (iCaptureCulture == 0 && iCaptureGreatWorks == 0)
				{
					strBuffer = GetLocalizedText("TXT_KEY_POPUP_GOLD_CITY_CAPTURE", iCaptureGold, pNewCity->getNameKey());
					GC.GetEngineUserInterface()->AddCityMessage(0, pNewCity->GetIDInfo(), GetID(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer);
				}
				else
				{
					strBuffer = GetLocalizedText("TXT_KEY_POPUP_GOLD_AND_CULTURE_CITY_CAPTURE", iCaptureGold, iCaptureCulture, iCaptureGreatWorks, pNewCity->getNameKey());
					GC.GetEngineUserInterface()->AddCityMessage(0, pNewCity->GetIDInfo(), GetID(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer);

				}
			}
		}
	}
	// Be careful below here, pNewCity can be NULL.
	CheckForMurder(eOldOwner);

	if(GC.getGame().getActiveTeam() == GET_PLAYER(eOldOwner).getTeam())
	{
		CvMap& theMap = GC.getMap();
		theMap.updateDeferredFog();
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem && pNewCity != NULL)
	{
		CvLuaArgsHandle args;
		args->Push(eOldOwner);
		args->Push(bCapital);
		args->Push(pNewCity->getX());
		args->Push(pNewCity->getY());
		args->Push(GetID());
		args->Push(iOldPopulation);
		args->Push(bConquest);
		args->Push((int)paGreatWorkData.size());
		args->Push(iCaptureGreatWorks);

		bool bResult;
		LuaSupport::CallHook(pkScriptSystem, "CityCaptureComplete", args.get(), bResult);
	}

#if defined(MOD_API_EXTENSIONS)
		return pNewCity;
#endif
#ifdef _MSC_VER
#pragma warning ( pop ) // restore warning level suppressed for pNewCity null check
#endif// _MSC_VER
}


//	--------------------------------------------------------------------------------
void CvPlayer::killCities()
{
	//can't kill the cities directly because that invalidates the iterator
	std::vector<int> citiesToKill;

	int iLoop;
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		citiesToKill.push_back(pLoopCity->GetID());
	}

	for (std::vector<int>::iterator it=citiesToKill.begin(); it!=citiesToKill.end(); ++it)
	{
		CvCity* pLoopCity = getCity(*it);
		pLoopCity->kill(false);
	}
}

const int RESERVE_TOP_X_NAMES = 5;	/// Never steal one of the first 5 names

//	--------------------------------------------------------------------------------
CvString CvPlayer::getNewCityName() const
{
	const CLLNode<CvString>* pNode;
	CvString strName;

	for(pNode = headCityNameNode(); (pNode != NULL); pNode = nextCityNameNode(pNode))
	{
		strName = pNode->m_data;
		if(isCityNameValid(strName, true))
		{
			strName = pNode->m_data;
			break;
		}
	}

	if(strName.IsEmpty())
	{
		getCivilizationCityName(strName, getCivilizationType());
	}

	if(strName.IsEmpty())
	{
		// Pick a name from another civ in the game
		int iPlayersAlive = 0;
		for(int iI = 0; iI < MAX_PLAYERS; iI++)
		{
			const PlayerTypes ePlayer = static_cast<PlayerTypes>(iI);
			CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);
			if(ePlayer != GetID() && kPlayer.isAlive() && !kPlayer.isMinorCiv() && !kPlayer.isBarbarian())
			{
				iPlayersAlive++;
			}
		}

		int iChosenPlayer = GC.getGame().getJonRandNum(iPlayersAlive, "Random Player To Steal City Name");

		int iPlayersFound = 0;
		for(int iI = 0; iI < MAX_PLAYERS; iI++)
		{
			const PlayerTypes ePlayer = static_cast<PlayerTypes>(iI);
			CvPlayerAI &kPlayer = GET_PLAYER(ePlayer);
			if(ePlayer != GetID() && kPlayer.isAlive() && !kPlayer.isMinorCiv() && !kPlayer.isBarbarian())
			{
				if(iPlayersFound == iChosenPlayer)
				{
					strName = GetBorrowedCityName(kPlayer.getCivilizationType());			
					break;
				}
				else
				{
					iPlayersFound++;
				}
			}
		}
	}

	if(strName.IsEmpty())
	{
		// Pick a name from another civ in the DATABASE
		int iCivsInDB = 0;
		for(int iI = 0; iI < GC.getNumCivilizationInfos(); iI++)
		{
			const CivilizationTypes eCiv = static_cast<CivilizationTypes>(iI);

			CvCivilizationInfo* pkCivilizationInfo = GC.getCivilizationInfo(eCiv);
			if(pkCivilizationInfo != NULL && pkCivilizationInfo->getNumCityNames() > RESERVE_TOP_X_NAMES)
			{
				iCivsInDB++;
			}
		}

		int iChosenCiv = GC.getGame().getJonRandNum(iCivsInDB, "Random Civ To Steal City Name");

		int iCivsFound = 0;
		for(int iI = 0; iI < GC.getNumCivilizationInfos(); iI++)
		{
			const CivilizationTypes eCiv = static_cast<CivilizationTypes>(iI);

			CvCivilizationInfo* pkCivilizationInfo = GC.getCivilizationInfo(eCiv);
			if (pkCivilizationInfo != NULL && pkCivilizationInfo->getNumCityNames() > RESERVE_TOP_X_NAMES)
			{
				if (iCivsFound == iChosenCiv)
				{
					strName = GetBorrowedCityName(eCiv);
					break;
				}
				else
				{
					iCivsFound++;
				}
			}
		}
	}

	if(strName.IsEmpty())
	{
		strName = "TXT_KEY_CITY";
	}

	return strName;
}

//	--------------------------------------------------------------------------------
CvString CvPlayer::GetBorrowedCityName(CivilizationTypes eCivToBorrowFrom) const
{
	CvString szRtnValue;
	CvCivilizationInfo *pCivInfo = GC.getCivilizationInfo(eCivToBorrowFrom);

	if (pCivInfo)
	{
		int iRange = pCivInfo->getNumCityNames() - RESERVE_TOP_X_NAMES;
		int iRandOffset = GC.getGame().getJonRandNum(iRange, "Random City Name To Steal");
		for(int iI = 0; iI < iRange; iI++)     
		{
			CvString strCityName = pCivInfo->getCityNames(RESERVE_TOP_X_NAMES + ((iI + iRandOffset) % iRange));
			szRtnValue = GetLocalizedText(strCityName.c_str());

			if(isCityNameValid(szRtnValue, true))
			{
				break;
			}
		}
	}

	return szRtnValue;

}

//	--------------------------------------------------------------------------------
void CvPlayer::getCivilizationCityName(CvString& szBuffer, CivilizationTypes eCivilization) const
{
	int iRandOffset;
	int iLoopName;

	CvCivilizationInfo* pkCivilizationInfo = GC.getCivilizationInfo(eCivilization);
	if(pkCivilizationInfo == NULL)
	{
		//This should never happen.
		return;
	}

	if(isBarbarian())
	{
		iRandOffset = GC.getGame().getJonRandNum(pkCivilizationInfo->getNumCityNames(), "Random Barb Name");
	}
	else
	{
		iRandOffset = 0;
	}

	// Minor Civs use special lists
	if(isMinorCiv())
	{
		CvMinorCivInfo* pkMinorCivInfo = GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType());
		if(pkMinorCivInfo)
		{
			CvMinorCivInfo& kMinorCivInfo = *pkMinorCivInfo;
			for(int iI = 0; iI < kMinorCivInfo.getNumCityNames(); iI++)
			{
				iLoopName = ((iI + iRandOffset) % kMinorCivInfo.getNumCityNames());

				const CvString strCityName = kMinorCivInfo.getCityNames(iLoopName);
				CvString strName = GetLocalizedText(strCityName.c_str());

				if(isCityNameValid(strName, true))
				{
					szBuffer = strCityName;
					break;
				}
			}
		}
	}
	else
	{
		CvCivilizationInfo& kCivInfo = *pkCivilizationInfo;
		for(int iI = 0; iI < kCivInfo.getNumCityNames(); iI++)
		{
			iLoopName = ((iI + iRandOffset) % kCivInfo.getNumCityNames());

			const CvString strCityName = kCivInfo.getCityNames(iLoopName);
			CvString strName = GetLocalizedText(strCityName.c_str());

			if(isCityNameValid(strName, true))
			{
				szBuffer = strCityName;
				break;
			}
		}
	}
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isCityNameValid(CvString& szName, bool bTestDestroyed) const
{
	const CvCity* pLoopCity;
	int iLoop;

	if(bTestDestroyed)
	{
		if(GC.getGame().isDestroyedCityName(szName))
		{
			return false;
		}

		for(int iPlayer = 0; iPlayer < MAX_PLAYERS; ++iPlayer)
		{
			CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iPlayer);
			for(pLoopCity = kLoopPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kLoopPlayer.nextCity(&iLoop))
			{
				if(pLoopCity->getName() == szName)
				{
					return false;
				}
			}
		}
	}
	else
	{
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity->getName() == szName)
			{
				return false;
			}
		}
	}

	return true;
}

//	--------------------------------------------------------------------------------
/// How far out this player may buy plots
int CvPlayer::getBuyPlotDistance() const
{
	int iDistance = GC.getMAXIMUM_BUY_PLOT_DISTANCE();
	
	iDistance = std::min(MAX_CITY_RADIUS, std::max(getWorkPlotDistance(), iDistance));
	return iDistance;
}

//	--------------------------------------------------------------------------------
/// How far out this player may work plots
int CvPlayer::getWorkPlotDistance() const
{
	int iDistance = GC.getMAXIMUM_WORK_PLOT_DISTANCE();
	
#if defined(MOD_TRAITS_CITY_WORKING) || defined(MOD_BUILDINGS_CITY_WORKING) || defined(MOD_POLICIES_CITY_WORKING)
	// Change distance based on traits, policies, wonders, etc
	iDistance += GetCityWorkingChange();
#endif
#if defined(MOD_TECHS_CITY_WORKING)
	// Change distance based on techs, etc
	if (getTeam()!=NO_TEAM)
		iDistance += GET_TEAM(getTeam()).GetCityWorkingChange();
#endif
	
	iDistance = std::min(MAX_CITY_RADIUS, std::max(MIN_CITY_RADIUS, iDistance));
	return iDistance;
}

//	--------------------------------------------------------------------------------
/// How many plots a generic city may work
int CvPlayer::GetNumWorkablePlots() const
{
	return ((6 * (1+getWorkPlotDistance()) * getWorkPlotDistance() / 2) + 1);
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// This player liberates iOldCityID and gives it back to ePlayer
void CvPlayer::DoRevolutionPlayer(PlayerTypes ePlayer, int iOldCityID)
{
	CvCity* pCity = getCity(iOldCityID);
	CvAssert(pCity);
	if (!pCity)
		return;

	if(ePlayer == NO_PLAYER)
	{
		return;
	}

	PlayerTypes eCurrentOwner = pCity->getOwner();
	CvPlot* pPlot = pCity->plot();

	// Set that this team has been liberated
	TeamTypes eLiberatedTeam = GET_PLAYER(ePlayer).getTeam();

	// Who originally took out this team?
	TeamTypes eConquerorTeam = GET_TEAM(eLiberatedTeam).GetKilledByTeam();

	if (!GET_PLAYER(ePlayer).isAlive())
	{
		GET_PLAYER(ePlayer).setBeingResurrected(true);

		// Put everyone at peace with this guy
		for(int iOtherTeamLoop = 0; iOtherTeamLoop < MAX_CIV_TEAMS; iOtherTeamLoop++)
		{
			if(eLiberatedTeam != iOtherTeamLoop)
			{
#if defined(MOD_EVENTS_WAR_AND_PEACE)
				GET_TEAM(eLiberatedTeam).makePeace((TeamTypes) iOtherTeamLoop, /*bBumpUnits*/false, /*bSuppressNotification*/true, GetID());
#else
				GET_TEAM(eLiberatedTeam).makePeace((TeamTypes) iOtherTeamLoop, /*bBumpUnits*/false, /*bSuppressNotification*/true);
#endif
			}
		}
	
		if (!GET_PLAYER(ePlayer).isMinorCiv())
		{
			// add notification
			Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_CIV_REVOLUTION_CP");
			strMessage << pCity->getNameKey(); // CITY NAME
			strMessage << GET_PLAYER(ePlayer).getCivilizationAdjectiveKey(); // LIBERATED CIV NAME
			strMessage << GET_PLAYER(ePlayer).getCivilizationDescriptionKey();// LIBERATED CIV NAME
			Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CIV_REVOLUTION_SHORT_CP");
			if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(ePlayer).isHuman())
			{
				strSummary << GET_PLAYER(ePlayer).getNickName();
			}
			else
			{
				strSummary << GET_PLAYER(ePlayer).getNameKey();
			}		

			for(int iI = 0; iI < MAX_PLAYERS; iI++)
			{
				const PlayerTypes eOtherPlayer = static_cast<PlayerTypes>(iI);
				CvPlayerAI& kOtherPlayer = GET_PLAYER(eOtherPlayer);
				if(kOtherPlayer.isAlive() && kOtherPlayer.GetNotifications())
				{
					kOtherPlayer.GetNotifications()->Add(NOTIFICATION_RESURRECTED_MAJOR_CIV, strMessage.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), -1);
				}
			}

			CvString temp = strMessage.toUTF8();
			GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, m_eID, temp);
		}
	}

	// Give the city back to the liberated player
	GET_PLAYER(ePlayer).acquireCity(pCity, false, true);

	// Now verify the player is alive
	GET_PLAYER(ePlayer).verifyAlive();
	GET_PLAYER(ePlayer).setBeingResurrected(false);


	// Move Units from player that don't belong here
	if(pPlot->getNumUnits() > 0)
	{
		// Get the current list of units because we will possibly be moving them out of the plot's list
		IDInfoVector currentUnits;
		if (pPlot->getUnits(&currentUnits) > 0)
		{
			for(IDInfoVector::const_iterator itr = currentUnits.begin(); itr != currentUnits.end(); ++itr)
			{
				CvUnit* pLoopUnit = (CvUnit*)GetPlayerUnit(*itr);

				if(pLoopUnit && pLoopUnit->getOwner() == eCurrentOwner)
				{
					pLoopUnit->finishMoves();
					if (!pLoopUnit->jumpToNearestValidPlot())
						pLoopUnit->kill(false);
				}
			}
		}
	}
	if(GC.getLogging() && GC.getAILogging() && pCity != NULL)
	{
		CvString playerName;
		FILogFile* pLog;
		CvString strBaseString;
		CvString strOutBuf;
		CvString strFileName = "CustomMods.csv";
		playerName = getCivilizationShortDescription();
		pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";
		strOutBuf.Format("Revolution! City restored to %s", GET_PLAYER(pCity->getOwner()).getName());
		strBaseString += strOutBuf;
		pLog->Msg(strBaseString);
	}
#if defined(MOD_DIPLOMACY_CITYSTATES)
	//Let's give the Embassies of the defeated player back to the liberated player
	if(MOD_DIPLOMACY_CITYSTATES && GET_PLAYER(ePlayer).GetImprovementLeagueVotes() > 0)
	{
		for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			ePlayer = (PlayerTypes) iPlayerLoop;
			if(ePlayer != NO_PLAYER && GET_PLAYER(ePlayer).getTeam() == eConquerorTeam)
			{
				int iEmbassyVotes = GET_PLAYER(ePlayer).GetImprovementLeagueVotes();
				GET_PLAYER(ePlayer).ChangeImprovementLeagueVotes(-iEmbassyVotes);
			}
		}
	}
#endif
}
CvPlot* CvPlayer::GetCenterOfMassEmpire() const
{
	if(m_iCenterOfMassX == -1 || m_iCenterOfMassY == -1)
	{
		return NULL;
	}
	//this handles wrapped coordinates
	CvPlot* pRtnValue = GC.getMap().plot(m_iCenterOfMassX, m_iCenterOfMassY);
	
	return pRtnValue;
}
void CvPlayer::SetCenterOfMassEmpire()
{
	int iTotalX = 0;
	int iTotalY = 0;
	int iNumCities = 0;

	int iLoop;
	CvCity* pCity = firstCity(&iLoop);

	if (!pCity)
		return;

	int iTotalX2 = 0;
	int iTotalY2 = 0;
	int iWorldWidth = GC.getMap().getGridWidth();
	int iWorldHeight = GC.getMap().getGridHeight();

	//the first unit is our reference ...
	int iRefX = pCity->getX();
	int iRefY = pCity->getY();
	iNumCities++;
	pCity = nextCity(&iLoop);

	while(pCity)
	{
		if(pCity->IsPuppet())
		{
			pCity = nextCity(&iLoop);
			continue;
		}

		int iDX = pCity->getX() - iRefX;
		int iDY = pCity->getY() - iRefY;

		if (GC.getMap().isWrapX())
		{
			if( iDX > +(iWorldWidth / 2))
				iDX -= iWorldWidth;
			if( iDX < -(iWorldWidth / 2))
				iDX += iWorldWidth;
		}
		if (GC.getMap().isWrapY())
		{
			if( iDY > +(iWorldHeight / 2))
				iDY -= iWorldHeight;
			if( iDY < -(iWorldHeight / 2))
				iDY += iWorldHeight;
		}

		iTotalX += iDX;
		iTotalY += iDY;
		iTotalX2 += iDX*iDX;
		iTotalY2 += iDY*iDY;
		iNumCities++;

		pCity = nextCity(&iLoop);
	}

	if (iNumCities==0)
		return;

	//finally, compute average (with rounding)
	int iAvgX = (iTotalX + (iNumCities / 2)) / iNumCities + iRefX;
	int iAvgY = (iTotalY + (iNumCities / 2)) / iNumCities + iRefY;

	m_iCenterOfMassX = iAvgX;
	m_iCenterOfMassY = iAvgY;
}

void CvPlayer::UpdateBestMilitaryCities()
{
	//What are you doing here? Get out!
	if(isMinorCiv() || isBarbarian())
		return;

	//First let's test domain, then we'll test combat class.
	CvCity* pLoopCity = NULL;
	int iLoop;
	
	//Domain Value - let's get the city with the higher # of domain bonuses, and make it our best domain city.
	for (int iDomainLoop = 0; iDomainLoop < NUM_DOMAIN_TYPES; iDomainLoop++)
	{
		int iBestDomainValue = 0;
		DomainTypes eTestDomain = (DomainTypes)iDomainLoop;
		if(eTestDomain != NO_DOMAIN)
		{
			CvCity* pBestDomainCity = NULL;
			for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				//Production is king, and also our base value.
				int iDomainValue = (pLoopCity->getYieldRate(YIELD_PRODUCTION, false) / 5);
				if(pLoopCity->getDomainFreeExperience(eTestDomain) > 0)
				{
					iDomainValue += max(1, pLoopCity->getDomainFreeExperience(eTestDomain));
				}
				if(pLoopCity->getDomainFreeExperienceFromGreatWorks(eTestDomain) > 0)
				{
					iDomainValue += max(1, pLoopCity->getDomainFreeExperienceFromGreatWorks(eTestDomain));
				}
				if(pLoopCity->getDomainFreeExperienceFromGreatWorksGlobal(eTestDomain) > 0)
				{
					iDomainValue += max(1, pLoopCity->getDomainFreeExperienceFromGreatWorksGlobal(eTestDomain));
				}
				if(pLoopCity->getDomainProductionModifier(eTestDomain) > 0)
				{
					iDomainValue += max(1, pLoopCity->getDomainProductionModifier(eTestDomain));
				}
				if(iDomainValue > iBestDomainValue)
				{
					iBestDomainValue = iDomainValue;
					pBestDomainCity = pLoopCity;
				}
			}
			if(pBestDomainCity != NULL && pBestDomainCity != GetBestMilitaryCity(NO_UNITCOMBAT, eTestDomain))
			{
				if(GC.getLogging() && GC.getAILogging())
				{
					CvString strCity = pBestDomainCity->getName();
					CvString strLogString;
					strLogString.Format("***************** New Military Domain City Chosen: %s. ****************", strCity.c_str());
					GetHomelandAI()->LogHomelandMessage(strLogString);
				}
				SetBestMilitaryCityDomain(pBestDomainCity->GetID(), eTestDomain);
			}
		}
	}

	//Unitcombat Value - let's find the best unitcombat class city (includes promotions for unit combat classes below).
	for(int iI = 0; iI < GC.getNumUnitCombatClassInfos(); iI++)
	{
		int iBestCombatClassValue = 0;
		const UnitCombatTypes eUnitCombatClass = static_cast<UnitCombatTypes>(iI);
		CvBaseInfo* pkUnitCombatClassInfo = GC.getUnitCombatClassInfo(eUnitCombatClass);
		if(pkUnitCombatClassInfo)
		{
			CvCity* pBestCombatClassCity = NULL;
			for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				//Production is king, and also our base value.
				int iCombatClassValue = (pLoopCity->getYieldRate(YIELD_PRODUCTION, false) / 5);
				if(pLoopCity->getUnitCombatFreeExperience(eUnitCombatClass) > 0)
				{
					iCombatClassValue += max(1, pLoopCity->getUnitCombatFreeExperience(eUnitCombatClass));
				}
				if(pLoopCity->getUnitCombatProductionModifier(eUnitCombatClass) > 0)
				{
					iCombatClassValue += max(1, pLoopCity->getUnitCombatProductionModifier(eUnitCombatClass));
				}
				//Promotion Bonus
				for(int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
				{
					const PromotionTypes ePromotion = static_cast<PromotionTypes>(iI);
					CvPromotionEntry* pkPromotionInfo = GC.getPromotionInfo(ePromotion);
					if(pkPromotionInfo)
					{
						if(pLoopCity->isFreePromotion(ePromotion))
						{
							if(pkPromotionInfo->GetUnitCombatClass(eUnitCombatClass))
							{
								iCombatClassValue += 25;
							}
						}
					}
				}
				if(iCombatClassValue > iBestCombatClassValue)
				{
					iBestCombatClassValue = iCombatClassValue;
					pBestCombatClassCity = pLoopCity;
				}
			}
			if(pBestCombatClassCity != NULL && pBestCombatClassCity != GetBestMilitaryCity(eUnitCombatClass, NO_DOMAIN))
			{
				SetBestMilitaryCityCombatClass(pBestCombatClassCity->GetID(), eUnitCombatClass);
				if(GC.getLogging() && GC.getAILogging())
				{
					CvString strCity = pBestCombatClassCity->getName();
					CvString strLogString;
					strLogString.Format("***************** New Military Combat Class City Chosen: %s. ****************", strCity.c_str());
					GetHomelandAI()->LogHomelandMessage(strLogString);
				}
			}
		}
	}
}
void CvPlayer::SetBestMilitaryCityDomain(int iValue, DomainTypes eDomain)
{
	VALIDATE_OBJECT
	CvAssertMsg(eDomain >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eDomain < NUM_DOMAIN_TYPES, "eIndex1 is expected to be within maximum bounds (invalid Index)");
	return m_aiBestMilitaryDomainCity.setAt(eDomain, iValue);
}
void CvPlayer::SetBestMilitaryCityCombatClass(int iValue, UnitCombatTypes eUnitCombat)
{
	VALIDATE_OBJECT
	CvAssertMsg(eUnitCombat >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eUnitCombat < GC.getNumUnitCombatClassInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	return m_aiBestMilitaryCombatClassCity.setAt(eUnitCombat, iValue);
}
CvCity* CvPlayer::GetBestMilitaryCity(UnitCombatTypes eUnitCombat, DomainTypes eDomain)
{
	if(eUnitCombat != NO_UNITCOMBAT)
	{
		return getCity(m_aiBestMilitaryCombatClassCity[eUnitCombat]);
	}
	else if(eDomain != NO_DOMAIN)
	{
		return getCity(m_aiBestMilitaryDomainCity[eDomain]);
	}
	else
	{
		return NULL;
	}
}
#endif
#if defined(MOD_BALANCE_CORE_EVENTS)
int CvPlayer::GetEventChoiceDuration(EventChoiceTypes eEventChoice) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEventChoice >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEventChoice < GC.getNumEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	return m_aiEventChoiceDuration[eEventChoice];
}
void CvPlayer::ChangeEventChoiceDuration(EventChoiceTypes eEventChoice,int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEventChoice >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEventChoice < GC.getNumEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	if(iValue != 0)
	{
		m_aiEventChoiceDuration.setAt(eEventChoice, m_aiEventChoiceDuration[eEventChoice] + iValue);
	}
}
void CvPlayer::SetEventChoiceDuration(EventChoiceTypes eEventChoice,int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEventChoice >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEventChoice < GC.getNumEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	m_aiEventChoiceDuration.setAt(eEventChoice, iValue);
}
int CvPlayer::GetEventIncrement(EventTypes eEvent) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	return m_aiEventIncrement[eEvent];
}
void CvPlayer::IncrementEvent(EventTypes eEvent, int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	if(iValue != 0)
	{
		m_aiEventIncrement.setAt(eEvent, m_aiEventIncrement[eEvent] + iValue);
	}
}
int CvPlayer::GetPlayerEventCooldown() const
{
	VALIDATE_OBJECT
	return m_iPlayerEventCooldown;
}
void CvPlayer::ChangePlayerEventCooldown(int iValue)
{
	VALIDATE_OBJECT
	if(iValue != 0)
	{
		m_iPlayerEventCooldown += iValue;
	}
}
int CvPlayer::GetEventCooldown(EventTypes eEvent) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	return m_aiEventCooldown[eEvent];
}
void CvPlayer::ChangeEventCooldown(EventTypes eEvent,int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	if(iValue != 0)
	{
		m_aiEventCooldown.setAt(eEvent, m_aiEventCooldown[eEvent] + iValue);
	}
}
void CvPlayer::SetEventCooldown(EventTypes eEvent,int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	m_aiEventCooldown.setAt(eEvent, iValue);
}

void CvPlayer::SetEventActive(EventTypes eEvent, bool bValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	m_abEventActive.setAt(eEvent, bValue);
}
bool CvPlayer::IsEventActive(EventTypes eEvent) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	return m_abEventActive[eEvent];
}
void CvPlayer::SetEventChoiceActive(EventChoiceTypes eEventChoice, bool bValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEventChoice >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEventChoice < GC.getNumEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	m_abEventChoiceActive.setAt(eEventChoice, bValue);
}
bool CvPlayer::IsEventChoiceActive(EventChoiceTypes eEventChoice) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEventChoice >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEventChoice < GC.getNumEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	return m_abEventChoiceActive[eEventChoice];
}
void CvPlayer::SetEventChoiceFired(EventChoiceTypes eEvent, bool bValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	m_abEventChoiceFired.setAt(eEvent, bValue);
}
bool CvPlayer::IsEventChoiceFired(EventChoiceTypes eEvent) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	return m_abEventChoiceFired[eEvent];
}
void CvPlayer::SetEventFired(EventTypes eEvent, bool bValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	m_abEventFired.setAt(eEvent, bValue);
}
bool CvPlayer::IsEventFired(EventTypes eEvent) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	return m_abEventFired[eEvent];
}
void CvPlayer::DoEvents()
{
	//Minors? Barbs? Get out!
	if(isMinorCiv() || isBarbarian())
		return;

	//Event Choice Duration First - if we're in one, let's do the countdown now.
	//We need to do this first so we can cancel the event(s).
	for(int iLoop = 0; iLoop < GC.getNumEventChoiceInfos(); iLoop++)
	{
		EventChoiceTypes eEventChoice = (EventChoiceTypes)iLoop;
		if(eEventChoice != NO_EVENT_CHOICE)
		{
			if(GetEventChoiceDuration(eEventChoice) > 0)
			{
				ChangeEventChoiceDuration(eEventChoice, -1);
				if(GC.getLogging())
				{
					CvModEventChoiceInfo* pkEventInfo = GC.getEventChoiceInfo(eEventChoice);
					if(pkEventInfo != NULL)
					{
						CvString playerName;
						FILogFile* pLog;
						CvString strBaseString;
						CvString strOutBuf;
						CvString strFileName = "EventLogging.csv";
						playerName = getCivilizationShortDescription();
						pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
						strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
						strBaseString += playerName + ", ";
						strOutBuf.Format("Event Choice Cooldown: %s Changing Value by -1. Cooldown Remaining: %d", pkEventInfo->GetDescription(), GetEventChoiceDuration(eEventChoice));
						strBaseString += strOutBuf;
						pLog->Msg(strBaseString);
					}
				}
				if(GetEventChoiceDuration(eEventChoice) == 0)
				{
					DoCancelEventChoice(eEventChoice);
				}
			}
		}
	}

	//Let's loop through all events.
	FStaticVector<EventTypes, 256, true, c_eCiv5GameplayDLL, 0> veValidEvents;
	for(int iLoop = 0; iLoop < GC.getNumEventInfos(); iLoop++)
	{
		EventTypes eEvent = (EventTypes)iLoop;
		if(eEvent != NO_EVENT)
		{
			CvModEventInfo* pkEventInfo = GC.getEventInfo(eEvent);
			if(pkEventInfo == NULL)
			{
				continue;
			}

			if(pkEventInfo->getRandomChance() == -1)
				continue;

			if(pkEventInfo->isOneShot() && IsEventFired(eEvent))
				continue;

			//Lua Hook
			if (GAMEEVENTINVOKE_TESTANY(GAMEEVENT_EventCanTake, GetID(), eEvent) == GAMEEVENTRETURN_FALSE) 
			{
				continue;
			}

			//Global Cooldown Second - if we've had this event recently, let's check this.
			if(GetEventCooldown(eEvent) > 0)
			{
				if(GC.getLogging())
				{
					CvModEventInfo* pkEventInfo = GC.getEventInfo(eEvent);
					if(pkEventInfo != NULL)
					{
						CvString playerName;
						FILogFile* pLog;
						CvString strBaseString;
						CvString strOutBuf;
						CvString strFileName = "EventLogging.csv";
						playerName = getCivilizationShortDescription();
						pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
						strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
						strBaseString += playerName + ", ";
						strOutBuf.Format("Player Event: %s. Cooldown Active. Cooldown: %d", pkEventInfo->GetDescription(), GetEventCooldown(eEvent));
						strBaseString += strOutBuf;
						pLog->Msg(strBaseString);
					}
				}
				ChangeEventCooldown(eEvent, -1);
				continue;
			}
			if(GetPlayerEventCooldown() > 0)
			{
				if(GC.getLogging())
				{
					CvModEventInfo* pkEventInfo = GC.getEventInfo(eEvent);
					if(pkEventInfo != NULL)
					{
						CvString playerName;
						FILogFile* pLog;
						CvString strBaseString;
						CvString strOutBuf;
						CvString strFileName = "EventLogging.csv";
						playerName = getCivilizationShortDescription();
						pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
						strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
						strBaseString += playerName + ", ";
						strOutBuf.Format("Player Event: %s. Global Cooldown Active. Cooldown: %d", pkEventInfo->GetDescription(), GetPlayerEventCooldown());
						strBaseString += strOutBuf;
						pLog->Msg(strBaseString);
					}
				}
				ChangePlayerEventCooldown(-1);
				if(!pkEventInfo->IgnoresGlobalCooldown())
				{
					return;
				}
			}

			int iRandom = GC.getGame().getJonRandNum(1000, "Random Event Chance");
			int iLimit = pkEventInfo->getRandomChance() + GetEventIncrement(eEvent);
			if(iRandom < iLimit)
			{
				//Check validity (expensive!)
				if(!IsEventValid(eEvent))
					continue;

				//We did it! But reverse our increment.
				IncrementEvent(eEvent, -GetEventIncrement(eEvent));
				if(GC.getLogging())
				{
					CvString playerName;
					FILogFile* pLog;
					CvString strBaseString;
					CvString strOutBuf;
					CvString strFileName = "EventLogging.csv";
					playerName = getCivilizationShortDescription();
					pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
					strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
					strBaseString += playerName + ", ";
					strOutBuf.Format("Event added to list for player. Event: %s", pkEventInfo->GetDescription());
					strBaseString += strOutBuf;
					pLog->Msg(strBaseString);
				}
			}
			else
			{
				//We didn't do it? Bummer. BUT if there's a delta, the chance gets higher next turn...
				if(pkEventInfo->getRandomChanceDelta() > 0)
				{
					//Check validity (expensive!)
					if(!IsEventValid(eEvent))
						continue;

					IncrementEvent(eEvent, pkEventInfo->getRandomChanceDelta());
					if(GC.getLogging())
					{
						CvString playerName;
						FILogFile* pLog;
						CvString strBaseString;
						CvString strOutBuf;
						CvString strFileName = "EventLogging.csv";
						playerName = getCivilizationShortDescription();
						pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
						strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
						strBaseString += playerName + ", ";
						strOutBuf.Format("Event failed random test. Incrementing. Event: %s, Increment: %d", pkEventInfo->GetDescription(), GetEventIncrement(eEvent));
						strBaseString += strOutBuf;
						pLog->Msg(strBaseString);
					}
				}
				continue;
			}

			veValidEvents.push_back(eEvent);
		}
	}
	if(veValidEvents.size() > 0)
	{
		if(GC.getLogging())
		{
			CvString playerName;
			FILogFile* pLog;
			CvString strBaseString;
			CvString strOutBuf;
			CvString strFileName = "EventLogging.csv";
			playerName = getCivilizationShortDescription();
			pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			strBaseString += playerName + ", ";
			strOutBuf.Format("Found %d Events for seeding", veValidEvents.size());
			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}
		int iRandIndex = GC.getGame().getJonRandNum(veValidEvents.size(), "Picking random event for player.");
		EventTypes eChosenEvent = veValidEvents[iRandIndex];
		if(eChosenEvent != NO_EVENT)
		{
			CvModEventInfo* pkEventInfo = GC.getEventInfo(eChosenEvent);
			if(pkEventInfo != NULL)
			{
				for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
				{
					PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;
					if(ePlayer != NO_PLAYER && GET_PLAYER(ePlayer).isAlive())
					{
						//Not global?
						if(!pkEventInfo->isGlobal() && ePlayer != GetID())
							continue;

						GET_PLAYER(ePlayer).DoStartEvent(eChosenEvent);
					}
				}
			}
		}
	}
}
bool CvPlayer::IsEventValid(EventTypes eEvent)
{
	CvModEventInfo* pkEventInfo = GC.getEventInfo(eEvent);
	if(pkEventInfo == NULL)
	{
		return false;
	}

	//Lua Hook
	if (GAMEEVENTINVOKE_TESTANY(GAMEEVENT_EventCanActivate, GetID(), eEvent) == GAMEEVENTRETURN_FALSE) 
	{
		return false;
	}

	//Don't do choice ones in MP
	bool bDontShowRewardPopup = (GC.GetEngineUserInterface()->IsOptionNoRewardPopups() || GC.getGame().isReallyNetworkMultiPlayer());

	if(pkEventInfo->getNumChoices() > 1 && bDontShowRewardPopup)
		return false;
		
	//Let's narrow down all events here!
	if(pkEventInfo->getPrereqTech() != -1 && !GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
		return false;

	if(pkEventInfo->getObsoleteTech() != -1 && GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
		return false;

	if(pkEventInfo->getRequiredEra() != -1 && GetCurrentEra() < (EraTypes)pkEventInfo->getRequiredEra())
		return false;

	if(pkEventInfo->getObsoleteEra() != -1 && GetCurrentEra() >= (EraTypes)pkEventInfo->getObsoleteEra())
		return false;

	if(pkEventInfo->getMinimumNationalPopulation() > 0 && getCurrentTotalPop() < pkEventInfo->getMinimumNationalPopulation())
		return false;

	if(pkEventInfo->getMinimumNumberCities() > 0 && getNumCities() < pkEventInfo->getMinimumNumberCities())
		return false;

	if(pkEventInfo->getRequiredCiv() != -1 && getCivilizationType() != (CivilizationTypes)pkEventInfo->getRequiredCiv())
		return false;

	if(pkEventInfo->getRequiredPolicy() != -1 && !GetPlayerPolicies()->HasPolicy((PolicyTypes)pkEventInfo->getRequiredPolicy()))
		return false;

	if(pkEventInfo->getRequiredIdeology() != -1 && GetPlayerPolicies()->GetLateGamePolicyTree() != (PolicyBranchTypes)pkEventInfo->getRequiredIdeology())
		return false;

	if(pkEventInfo->hasStateReligion() && GetReligions()->GetStateReligion() == NO_RELIGION)
		return false;

	if(pkEventInfo->hasPantheon() && GetReligions()->GetReligionCreatedByPlayer(true) != RELIGION_PANTHEON)
		return false;

	if(pkEventInfo->isUnhappy() && !IsEmpireUnhappy())
		return false;

	if(pkEventInfo->isSuperUnhappy() && !IsEmpireSuperUnhappy())
		return false;

	if(pkEventInfo->isRequiresIdeology() && GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
		return false;

	if(pkEventInfo->isRequiresWar() && GetMilitaryAI()->GetNumberCivsAtWarWith(false) <= 0)
		return false;

	if(pkEventInfo->getRequiredActiveEvent() != -1 && GetEventCooldown((EventTypes)pkEventInfo->getRequiredActiveEvent()) <= 0)
		return false;

	if(pkEventInfo->getRequiredActiveEventChoice() != -1 && GetEventChoiceDuration((EventChoiceTypes)pkEventInfo->getRequiredActiveEventChoice()) <= 0)
		return false;

	if(pkEventInfo->getRequiredNoActiveEvent() != -1 && GetEventCooldown((EventTypes)pkEventInfo->getRequiredNoActiveEvent()) > 0)
		return false;

	if(pkEventInfo->getRequiredNoActiveEventChoice() != -1 && GetEventChoiceDuration((EventChoiceTypes)pkEventInfo->getRequiredNoActiveEventChoice()) > 0)
		return false;

	if(pkEventInfo->getRequiredStateReligion() != -1)
	{
		if(GetReligions()->GetStateReligion() != pkEventInfo->getRequiredStateReligion())
			return false;
	}

	if(!pkEventInfo->isRequiresHolyCity() && pkEventInfo->getRequiredReligion() != -1)
	{
		if((GetReligions()->GetCurrentReligion() != (ReligionTypes)pkEventInfo->getRequiredReligion()) && (GetReligions()->GetReligionInMostCities() != (ReligionTypes)pkEventInfo->getRequiredReligion()))
			return false;
	}

	if(pkEventInfo->hasMetAnotherCiv())
	{
		if(GET_TEAM(getTeam()).getHasMetCivCount(true) <= 0)
			return false;
	}

	if(MOD_DIPLOMACY_CIV4_FEATURES && pkEventInfo->isMaster() && GET_TEAM(getTeam()).GetNumVassals() <= 0)
		return false;

	if(MOD_DIPLOMACY_CIV4_FEATURES && pkEventInfo->isVassal() && !GET_TEAM(getTeam()).IsVassalOfSomeone())
		return false;


	if(pkEventInfo->getUnitTypeRequired() != -1)
	{
		bool bHas = false;
		CvUnit* pLoopUnit;
		int iLoop;
		for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		{
			if(pLoopUnit != NULL && pLoopUnit->getUnitClassType() == (UnitClassTypes)pkEventInfo->getUnitTypeRequired())
			{
				bHas = true;
				break;
			}
		}
		if(!bHas)
		{
			return false;
		}
	}

	if(pkEventInfo->isRequiresHolyCity())
	{
		bool bHas = false;
		CvCity* pCity = NULL;
		int iLoop;
		for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
		{
			if(pkEventInfo->getRequiredReligion() != -1)
			{
				if(pCity != NULL && pCity->GetCityReligions()->IsHolyCityForReligion((ReligionTypes)pkEventInfo->getRequiredReligion()))
				{
					bHas = true;
					break;
				}
			}
			else
			{
				if(pCity != NULL && pCity->GetCityReligions()->IsHolyCityAnyReligion())
				{
					bHas = true;
					break;
				}
			}
		}
		if(!bHas)
		{
			return false;
		}
	}

	if(pkEventInfo->isRequiresWarMinor())
	{
		bool bHas = false;
		for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			// Is this a player we have relations with?
			if(GET_PLAYER(eLoopPlayer).isBarbarian())
			{
				return false;
			}
			if(!GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				return false;
			}
			if(eLoopPlayer != GetID())
			{
				if(GET_TEAM(getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
				{
					bHas = true;
					break;
				}
			}
		}
		if(!bHas)
		{
			return false;
		}
	}
	bool bHas = true;
	for(int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
	{
		const ResourceTypes eResource = static_cast<ResourceTypes>(iJ);
		CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
		if(pkResource)
		{
			if(pkEventInfo->getResourceRequired(eResource) > 0)
			{
				if(getNumResourceTotal(eResource, false) < pkEventInfo->getResourceRequired(eResource))
				{
					bHas = false;
					break;
				}
			}
		}
	}
	if(!bHas)
	{
		return false;
	}

	if(pkEventInfo->getBuildingRequired() != -1)
	{
		BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventInfo->getBuildingRequired();
		if(eBuildingClass != NO_BUILDINGCLASS)
		{
			bool bHas = false;
			CvCity* pCity = NULL;
			int iLoop;
			for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
			{
				if(pCity != NULL && pCity->GetCityBuildings()->GetNumBuildingClass(eBuildingClass) > 0)
				{
					bHas = true;
					break;
				}
			}
			if(!bHas)
			{
				return false;
			}
		}
	}
	if(pkEventInfo->getBuildingLimiter() != -1)
	{
		BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventInfo->getBuildingLimiter();
		if(eBuildingClass != NO_BUILDINGCLASS)
		{
			bool bHas = false;
			CvCity* pCity = NULL;
			int iLoop;
			for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
			{
				if(pCity != NULL && pCity->GetCityBuildings()->GetNumBuildingClass(eBuildingClass) > 0)
				{
					bHas = true;
					break;
				}
			}
			if(bHas)
			{
				return false;
			}
		}
	}
	if(pkEventInfo->getRequiredImprovement() != -1)
	{
		ImprovementTypes eImprovement = (ImprovementTypes)pkEventInfo->getRequiredImprovement();
		if(eImprovement != NO_IMPROVEMENT)
		{
			bool bHas = false;
			CvPlot* pLoopPlot;
			int iNumPlotsInEntireWorld = GC.getMap().numPlots();
			for(int iI = 0; iI < iNumPlotsInEntireWorld; iI++)
			{
				pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

				if(pLoopPlot == NULL)
					return false;

				if(pLoopPlot->getOwner() == GetID() && pLoopPlot->getImprovementType() == eImprovement)
				{
					bHas = true;
					break;
				}
			}
			if(!bHas)
			{
				return false;
			}
		}
	}
	//Check our minimum yields - this looks at stored values, not yields per turn.
	bHas = true;
	for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes)iI;
		if(eYield == NO_YIELD)
			return false;
							
		int iNeededYield = pkEventInfo->getYieldMinimum(eYield);
		if(pkEventInfo->isEraScaling())
		{
			int iEra = GetCurrentEra();
			if(iEra <= 0)
			{
				iEra = 1;
			}
			iNeededYield *= iEra;
		}
		if(iNeededYield != 0)
		{
			if(eYield == YIELD_GOLD)
			{
				if(iNeededYield > GetTreasury()->GetGold())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_SCIENCE)
			{
				TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
				int iTech = 0;
				if(eCurrentTech != NO_TECH)
				{
					iTech = GetPlayerTechs()->GetResearchProgress(eCurrentTech);
				}
				if(iNeededYield > iTech)
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_FAITH)
			{
				if(iNeededYield > GetFaith())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_GOLDEN_AGE_POINTS)
			{
				if(iNeededYield > GetGoldenAgeProgressMeter())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_CULTURE)
			{
				if(iNeededYield > getJONSCulture())
				{
					bHas = false;
					break;
				}
			}
		}
	}
	if(!bHas)
	{
		return false;
	}

	if(pkEventInfo->getRequiredActiveCityEvent() != -1)
	{
		bool bHas = false;
		CvCity* pCity = NULL;
		int iLoop;
		for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
		{
			if(pCity != NULL && pCity->GetEventCooldown((CityEventTypes)pkEventInfo->getRequiredActiveCityEvent()) > 0)
			{
				bHas = true;
				break;
			}
		}
		if(!bHas)
		{
			return false;
		}
	}

	if(pkEventInfo->getRequiredActiveCityEventChoice() != -1)
	{
		bool bHas = false;
		CvCity* pCity = NULL;
		int iLoop;
		for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
		{
			if(pCity != NULL && pCity->GetEventChoiceDuration((CityEventChoiceTypes)pkEventInfo->getRequiredActiveCityEventChoice()) > 0)
			{
				bHas = true;
				break;
			}
		}
		if(!bHas)
		{
			return false;
		}
	}

	if(pkEventInfo->isInDebt() && GetTreasury()->GetGold() > 0)
		return false;

	if(pkEventInfo->isLosingMoney() && GetTreasury()->CalculateBaseNetGold() > 0)
		return false;

	if(pkEventInfo->getRequiredActiveOtherPlayerEvent() != -1 || pkEventInfo->getRequiredActiveOtherPlayerEventChoice() != -1 || pkEventInfo->getRequiredNoActiveOtherPlayerEvent() != -1 || pkEventInfo->getRequiredNoActiveOtherPlayerEventChoice() != -1)
	{
		bHas = false;
		for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			// Is this a player we have relations with?
			if(GET_PLAYER(eLoopPlayer).isBarbarian())
			{
				continue;
			}
			if(GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				continue;
			}
			if(eLoopPlayer != GetID())
			{
				if(pkEventInfo->getRequiredActiveOtherPlayerEvent() != -1)
				{
					if(GET_PLAYER(eLoopPlayer).GetEventCooldown((EventTypes)pkEventInfo->getRequiredActiveOtherPlayerEvent()) > 0)
					{
						bHas = true;
						break;
					}
				}
				if(pkEventInfo->getRequiredActiveOtherPlayerEventChoice() != -1)
				{
					if(GET_PLAYER(eLoopPlayer).GetEventChoiceDuration((EventChoiceTypes)pkEventInfo->getRequiredActiveOtherPlayerEventChoice()) > 0)
					{
						bHas = true;
						break;
					}
				}
				if(pkEventInfo->getRequiredNoActiveOtherPlayerEvent() != -1)
				{
					if(GET_PLAYER(eLoopPlayer).GetEventCooldown((EventTypes)pkEventInfo->getRequiredNoActiveOtherPlayerEvent()) > 0)
					{
						bHas = false;
						break;
					}
				}
				if(pkEventInfo->getRequiredNoActiveOtherPlayerEventChoice() != -1)
				{
					if(GET_PLAYER(eLoopPlayer).GetEventChoiceDuration((EventChoiceTypes)pkEventInfo->getRequiredNoActiveOtherPlayerEventChoice()) > 0)
					{
						bHas = false;
						break;
					}
				}
			}
		}
		if(!bHas)
		{
			return false;
		}
	}

	return true;
}
bool CvPlayer::IsEventChoiceValid(EventChoiceTypes eChosenEventChoice, EventTypes eParentEvent)
{
	if(eChosenEventChoice == NO_EVENT_CHOICE)
		return false;

	CvModEventChoiceInfo* pkEventInfo = GC.getEventChoiceInfo(eChosenEventChoice);
	if(pkEventInfo == NULL)
	{
		return false;
	}

	//Lua Hook
	if (GAMEEVENTINVOKE_TESTANY(GAMEEVENT_EventChoiceCanTake, GetID(), eChosenEventChoice) == GAMEEVENTRETURN_FALSE) {
		return false;
	}

	if(!pkEventInfo->isParentEvent(eParentEvent))
		return false;

	if(pkEventInfo->isOneShot() && IsEventChoiceFired(eChosenEventChoice))
		return false;

	//Event Choice already active for this event? Abort!
	if(GetEventChoiceDuration(eChosenEventChoice) > 0)
	{
		if(GC.getLogging())
		{
			CvString playerName;
			FILogFile* pLog;
			CvString strBaseString;
			CvString strOutBuf;
			CvString strFileName = "EventLogging.csv";
			playerName = getCivilizationShortDescription();
			pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			strBaseString += playerName + ", ";
			strOutBuf.Format("Event choice already active for player, skipping: %s, Event: %s. Cooldown: %d", pkEventInfo->GetDescription(), pkEventInfo->GetDescription(), GetEventChoiceDuration(eChosenEventChoice));
			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}
		return false;
	}

	//Let's narrow down all events here!
	if(pkEventInfo->getPrereqTech() != -1 && !GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
		return false;

	if(pkEventInfo->getObsoleteTech() != -1 && GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
		return false;

	if(pkEventInfo->getRequiredEra() != -1 && GetCurrentEra() < (EraTypes)pkEventInfo->getRequiredEra())
		return false;

	if(pkEventInfo->getObsoleteEra() != -1 && GetCurrentEra() >= (EraTypes)pkEventInfo->getObsoleteEra())
		return false;

	if(pkEventInfo->getMinimumNationalPopulation() > 0 && getCurrentTotalPop() < pkEventInfo->getMinimumNationalPopulation())
		return false;

	if(pkEventInfo->getMinimumNumberCities() > 0 && getNumCities() < pkEventInfo->getMinimumNumberCities())
		return false;

	if(pkEventInfo->getRequiredCiv() != -1 && getCivilizationType() != (CivilizationTypes)pkEventInfo->getRequiredCiv())
		return false;

	if(pkEventInfo->getRequiredPolicy() != -1 && !GetPlayerPolicies()->HasPolicy((PolicyTypes)pkEventInfo->getRequiredPolicy()))
		return false;

	if(pkEventInfo->getRequiredIdeology() != -1 && GetPlayerPolicies()->GetLateGamePolicyTree() != (PolicyBranchTypes)pkEventInfo->getRequiredIdeology())
		return false;

	if(pkEventInfo->hasStateReligion() && GetReligions()->GetStateReligion() == NO_RELIGION)
		return false;

	if(pkEventInfo->hasPantheon() && GetReligions()->GetReligionCreatedByPlayer(true) != RELIGION_PANTHEON)
		return false;

	if(pkEventInfo->isUnhappy() && !IsEmpireUnhappy())
		return false;

	if(pkEventInfo->isSuperUnhappy() && !IsEmpireSuperUnhappy())
		return false;

	if(pkEventInfo->isRequiresIdeology() && GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
		return false;

	if(pkEventInfo->isRequiresWar() && GetMilitaryAI()->GetNumberCivsAtWarWith(false) <= 0)
		return false;

	if(pkEventInfo->getRequiredStateReligion() != -1)
	{
		if(GetReligions()->GetStateReligion() != pkEventInfo->getRequiredStateReligion())
			return false;
	}

	if(!pkEventInfo->isRequiresHolyCity() && pkEventInfo->getRequiredReligion() != -1)
	{
		if((GetReligions()->GetCurrentReligion() != (ReligionTypes)pkEventInfo->getRequiredReligion()) && (GetReligions()->GetReligionInMostCities() != (ReligionTypes)pkEventInfo->getRequiredReligion()))
			return false;
	}

	if(pkEventInfo->getRequiredActiveEvent() != -1 && GetEventCooldown((EventTypes)pkEventInfo->getRequiredActiveEvent()) <= 0)
		return false;

	if(pkEventInfo->getRequiredActiveEventChoice() != -1 && GetEventChoiceDuration((EventChoiceTypes)pkEventInfo->getRequiredActiveEventChoice()) <= 0)
		return false;

	if(pkEventInfo->getRequiredNoActiveEvent() != -1 && GetEventCooldown((EventTypes)pkEventInfo->getRequiredNoActiveEvent()) > 0)
		return false;

	if(pkEventInfo->getRequiredNoActiveEventChoice() != -1 && GetEventChoiceDuration((EventChoiceTypes)pkEventInfo->getRequiredNoActiveEventChoice()) > 0)
		return false;

	if(pkEventInfo->hasMetAnotherCiv())
	{
		if(GET_TEAM(getTeam()).getHasMetCivCount(true) <= 0)
			return false;
	}

	if(MOD_DIPLOMACY_CIV4_FEATURES && pkEventInfo->isMaster() && GET_TEAM(getTeam()).GetNumVassals() <= 0)
		return false;

	if(MOD_DIPLOMACY_CIV4_FEATURES && pkEventInfo->isVassal() && !GET_TEAM(getTeam()).IsVassalOfSomeone())
		return false;

	if(pkEventInfo->getUnitTypeRequired() != -1)
	{
		bool bHas = false;
		CvUnit* pLoopUnit;
		int iLoop;
		for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		{
			if(pLoopUnit != NULL && pLoopUnit->getUnitClassType() == (UnitClassTypes)pkEventInfo->getUnitTypeRequired())
			{
				bHas = true;
				break;
			}
		}
		if(!bHas)
		{
			return false;
		}
	}


	if(pkEventInfo->isRequiresHolyCity())
	{
		bool bHas = false;
		CvCity* pCity = NULL;
		int iLoop;
		for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
		{
			if(pkEventInfo->getRequiredReligion() != -1)
			{
				if(pCity != NULL && pCity->GetCityReligions()->IsHolyCityForReligion((ReligionTypes)pkEventInfo->getRequiredReligion()))
				{
					bHas = true;
					break;
				}
			}
			else
			{
				if(pCity != NULL && pCity->GetCityReligions()->IsHolyCityAnyReligion())
				{
					bHas = true;
					break;
				}
			}
		}
		if(!bHas)
		{
			return false;
		}
	}
	

	if(pkEventInfo->isRequiresWarMinor())
	{
		bool bHas = false;
		for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			// Is this a player we have relations with?
			if(GET_PLAYER(eLoopPlayer).isBarbarian())
			{
				continue;
			}
			if(!GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				continue;
			}
			if(eLoopPlayer != GetID())
			{
				if(GET_TEAM(getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
				{
					bHas = true;
					break;
				}
			}
		}
		if(!bHas)
		{
			return false;
		}
	}
	bool bHas = true;
	for(int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
	{
		const ResourceTypes eResource = static_cast<ResourceTypes>(iJ);
		CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
		if(pkResource)
		{
			if(pkEventInfo->getResourceRequired(eResource) > 0)
			{
				if(getNumResourceTotal(eResource, false) < pkEventInfo->getResourceRequired(eResource))
				{
					bHas = false;
					break;
				}
			}
		}
	}
	if(!bHas)
	{
		return false;
	}

	if(pkEventInfo->getBuildingRequired() != -1)
	{
		BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventInfo->getBuildingRequired();
		if(eBuildingClass != NO_BUILDINGCLASS)
		{
			bool bHas = false;
			CvCity* pCity = NULL;
			int iLoop;
			for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
			{
				if(pCity != NULL && pCity->GetCityBuildings()->GetNumBuildingClass(eBuildingClass) > 0)
				{
					bHas = true;
					break;
				}
			}
			if(!bHas)
			{
				return false;
			}
		}
	}
	if(pkEventInfo->getBuildingLimiter() != -1)
	{
		BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventInfo->getBuildingLimiter();
		if(eBuildingClass != NO_BUILDINGCLASS)
		{
			bool bHas = false;
			CvCity* pCity = NULL;
			int iLoop;
			for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
			{
				if(pCity != NULL && pCity->GetCityBuildings()->GetNumBuildingClass(eBuildingClass) > 0)
				{
					bHas = true;
					break;
				}
			}
			if(bHas)
			{
				return false;
			}
		}
	}
	if(pkEventInfo->getRequiredImprovement() != -1)
	{
		ImprovementTypes eImprovement = (ImprovementTypes)pkEventInfo->getRequiredImprovement();
		if(eImprovement != NO_IMPROVEMENT)
		{
			bool bHas = false;
			CvPlot* pLoopPlot;
			int iNumPlotsInEntireWorld = GC.getMap().numPlots();
			for(int iI = 0; iI < iNumPlotsInEntireWorld; iI++)
			{
				pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

				if(pLoopPlot == NULL)
					continue;

				if(pLoopPlot->getOwner() == GetID() && pLoopPlot->getImprovementType() == eImprovement)
				{
					bHas = true;
					break;
				}
			}
			if(!bHas)
			{
				return false;
			}
		}
	}
	//Check our minimum yields - this looks at stored values, not yields per turn.
	bHas = true;
	for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes)iI;
		if(eYield == NO_YIELD)
			continue;
							
		int iNeededYield = pkEventInfo->getYieldMinimum(eYield);
		if(pkEventInfo->getPreCheckEventYield(eYield) != 0)
		{
			if(iNeededYield < pkEventInfo->getPreCheckEventYield(eYield))
			{
				iNeededYield = pkEventInfo->getPreCheckEventYield(eYield);
			}
		}
		if(pkEventInfo->IsEraScaling())
		{
			int iEra = GetCurrentEra();
			if(iEra <= 0)
			{
				iEra = 1;
			}
			iNeededYield *= iEra;
		}
		if(iNeededYield != 0)
		{
			if(eYield == YIELD_GOLD)
			{
				if(iNeededYield > GetTreasury()->GetGold())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_SCIENCE)
			{
				TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
				int iTech = 0;
				if(eCurrentTech != NO_TECH)
				{
					iTech = GetPlayerTechs()->GetResearchProgress(eCurrentTech);
				}
				if(iNeededYield > iTech)
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_FAITH)
			{
				if(iNeededYield > GetFaith())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_GOLDEN_AGE_POINTS)
			{
				if(iNeededYield > GetGoldenAgeProgressMeter())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_CULTURE)
			{
				if(iNeededYield > getJONSCulture())
				{
					bHas = false;
					break;
				}
			}
		}
	}
	if(!bHas)
	{
		return false;
	}

	if(pkEventInfo->getRequiredActiveCityEvent() != -1)
	{
		bool bHas = false;
		CvCity* pCity = NULL;
		int iLoop;
		for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
		{
			if(pCity != NULL && pCity->GetEventCooldown((CityEventTypes)pkEventInfo->getRequiredActiveCityEvent()) > 0)
			{
				bHas = true;
				break;
			}
		}
		if(!bHas)
		{
			return false;
		}
	}

	if(pkEventInfo->getRequiredActiveCityEventChoice() != -1)
	{
		bool bHas = false;
		CvCity* pCity = NULL;
		int iLoop;
		for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
		{
			if(pCity != NULL && pCity->GetEventChoiceDuration((CityEventChoiceTypes)pkEventInfo->getRequiredActiveCityEventChoice()) > 0)
			{
				bHas = true;
				break;
			}
		}
		if(!bHas)
		{
			return false;
		}
	}

	if(pkEventInfo->isInDebt() && GetTreasury()->GetGold() > 0)
		return false;

	if(pkEventInfo->isLosingMoney() && GetTreasury()->CalculateBaseNetGold() > 0)
		return false;

	if(pkEventInfo->getRequiredActiveOtherPlayerEvent() != -1 || pkEventInfo->getRequiredActiveOtherPlayerEventChoice() != -1 || pkEventInfo->getRequiredNoActiveOtherPlayerEvent() != -1 || pkEventInfo->getRequiredNoActiveOtherPlayerEventChoice() != -1)
	{
		bHas = false;
		for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			// Is this a player we have relations with?
			if(GET_PLAYER(eLoopPlayer).isBarbarian())
			{
				continue;
			}
			if(GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				continue;
			}
			if(eLoopPlayer != GetID())
			{
				if(pkEventInfo->getRequiredActiveOtherPlayerEvent() != -1)
				{
					if(GET_PLAYER(eLoopPlayer).GetEventCooldown((EventTypes)pkEventInfo->getRequiredActiveOtherPlayerEvent()) > 0)
					{
						bHas = true;
						break;
					}
				}
				if(pkEventInfo->getRequiredActiveOtherPlayerEventChoice() != -1)
				{
					if(GET_PLAYER(eLoopPlayer).GetEventChoiceDuration((EventChoiceTypes)pkEventInfo->getRequiredActiveOtherPlayerEventChoice()) > 0)
					{
						bHas = true;
						break;
					}
				}
				if(pkEventInfo->getRequiredNoActiveOtherPlayerEvent() != -1)
				{
					if(GET_PLAYER(eLoopPlayer).GetEventCooldown((EventTypes)pkEventInfo->getRequiredNoActiveOtherPlayerEvent()) > 0)
					{
						bHas = false;
						break;
					}
				}
				if(pkEventInfo->getRequiredNoActiveOtherPlayerEventChoice() != -1)
				{
					if(GET_PLAYER(eLoopPlayer).GetEventChoiceDuration((EventChoiceTypes)pkEventInfo->getRequiredNoActiveOtherPlayerEventChoice()) > 0)
					{
						bHas = false;
						break;
					}
				}
			}
		}
		if(!bHas)
		{
			return false;
		}
	}

	return true;
}
void CvPlayer::DoStartEvent(EventTypes eChosenEvent)
{
	if(eChosenEvent != NO_EVENT)
	{
		CvModEventInfo* pkEventInfo = GC.getEventInfo(eChosenEvent);
		if(pkEventInfo != NULL)
		{
			//Set true so we know we're doing an event right now.
			SetEventActive(eChosenEvent, true);

			int iMin = GC.getEVENT_MIN_DURATION_BETWEEN();
			iMin *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iMin /= 100;
			ChangePlayerEventCooldown(iMin);
			
			//Set oneshot stuff so this event can't fire ever again.
			if(pkEventInfo->isOneShot())
			{
				SetEventFired(eChosenEvent, true);
			}

			//Lua Hook
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_EventActivated, GetID(), eChosenEvent);

			//Gamespeed.
			int iEventDuration = pkEventInfo->getCooldown();
			iEventDuration *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iEventDuration /= 100;
			ChangeEventCooldown(eChosenEvent, iEventDuration);
			if(GC.getLogging())
			{
				CvString playerName;
				FILogFile* pLog;
				CvString strBaseString;
				CvString strOutBuf;
				CvString strFileName = "EventLogging.csv";
				playerName = getCivilizationShortDescription();
				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				strBaseString += playerName + ", ";
				strOutBuf.Format("Event started for player: %s. Cooldown: %d", pkEventInfo->GetDescription(), iEventDuration);
				strBaseString += strOutBuf;
				pLog->Msg(strBaseString);
			}
			int iNumEvents = 0;
			EventChoiceTypes eEventChoice = NO_EVENT_CHOICE;
			for(int iLoop = 0; iLoop < GC.getNumEventChoiceInfos(); iLoop++)
			{
				eEventChoice = (EventChoiceTypes)iLoop;
				if(eEventChoice != NO_EVENT_CHOICE)
				{
					CvModEventChoiceInfo* pkEventChoiceInfo = GC.getEventChoiceInfo(eEventChoice);
					if(pkEventChoiceInfo != NULL)
					{
						if(IsEventChoiceValid(eEventChoice, eChosenEvent))
						{
							iNumEvents++;
							if(pkEventInfo->getNumChoices() == 1)
							{
								DoEventChoice(eEventChoice, eChosenEvent);
								if(isHuman())
								{
									CvPopupInfo kPopupInfo(BUTTONPOPUP_MODDER_9, eEventChoice, GetID());
									GC.GetEngineUserInterface()->AddPopup(kPopupInfo);
								}
								return;
							}
						}
					}
				}
			}
			if(iNumEvents > 0 && pkEventInfo->getNumChoices() > 1)
			{
				if(isHuman())
				{
					CvNotifications* pNotifications = GetNotifications();
					if(pNotifications)
					{
						CvString strBuffer = GetLocalizedText("TXT_KEY_CHOOSE_EVENT_CHOICE");
						CvString strSummary = GetLocalizedText("TXT_KEY_CHOOSE_EVENT_CHOICE_TT");
						pNotifications->Add((NotificationTypes)FString::Hash("NOTIFICATION_EVENT_CHOICE"), strSummary.c_str(), strBuffer.c_str(), -1, -1, eChosenEvent);
					}
				}
				else
				{
					//Lua Hook
					if (GAMEEVENTINVOKE_TESTANY(GAMEEVENT_OverrideAIEvent, GetID(), eChosenEvent) == GAMEEVENTRETURN_TRUE) 
					{
						return;
					}

					AI_DoEventChoice(eChosenEvent);
				}
			}
		}
	}
}
void CvPlayer::DoCancelEventChoice(EventChoiceTypes eChosenEventChoice)
{
	if(eChosenEventChoice == NO_EVENT_CHOICE)
		return;

	CvModEventChoiceInfo* pkEventChoiceInfo = GC.getEventChoiceInfo(eChosenEventChoice);
	if(pkEventChoiceInfo != NULL)
	{
		//Lua Hook
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_EventChoiceEnded, GetID(), eChosenEventChoice);

		bool bChanged = false;
		if(GC.getLogging())
		{
			CvString playerName;
			FILogFile* pLog;
			CvString strBaseString;
			CvString strOutBuf;
			CvString strFileName = "EventLogging.csv";
			playerName = getCivilizationShortDescription();
			pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			strBaseString += playerName + ", ";
			strOutBuf.Format("Event choice ended for player: %s", pkEventChoiceInfo->GetDescription());
			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}
		//Let's make sure this is at zero.
		ChangeEventChoiceDuration(eChosenEventChoice, -GetEventChoiceDuration(eChosenEventChoice));
					
		//Let's only deduct if we actually started this event and it expires.
		if(IsEventChoiceActive(eChosenEventChoice) && pkEventChoiceInfo->Expires())
		{
			if(pkEventChoiceInfo->getEventPolicy() != -1)
			{
				PolicyTypes ePolicy = (PolicyTypes)pkEventChoiceInfo->getEventPolicy();
				if(ePolicy != -1)
				{
					GetPlayerPolicies()->SetPolicy(ePolicy, false, true);
					bChanged = true;
				}
			}
			if(pkEventChoiceInfo->getEventTech() != -1)
			{
				TechTypes eTech = (TechTypes)pkEventChoiceInfo->getEventTech();
				if(eTech != -1)
				{
					GET_TEAM(getTeam()).GetTeamTechs()->SetHasTech(eTech, false);
				}
			}
			if(pkEventChoiceInfo->getEventBuilding() != -1)
			{
				BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventChoiceInfo->getEventBuilding();
				if(eBuildingClass != -1)
				{
					const CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
	
					if (pkBuildingClassInfo)
					{
						CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
		
						if (pCivilizationInfo != NULL)
						{
							BuildingTypes eBuildingType = (BuildingTypes) pCivilizationInfo->getCivilizationBuildings(eBuildingClass);
							CvCity *pLoopCity;
							int iLoop;
							for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								pLoopCity->GetCityBuildings()->SetNumFreeBuilding(eBuildingType, 0);
								pLoopCity->GetCityBuildings()->SetNumRealBuilding(eBuildingType, 0);
								bChanged = true;
							}
						}
					}
				}
			}
			if(pkEventChoiceInfo->getEventPromotion() != -1)
			{
				PromotionTypes ePromotion = (PromotionTypes)pkEventChoiceInfo->getEventPromotion();
				if(ePromotion != -1)
				{
					CvUnit* pLoopUnit;
					int iLoop;
					for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
					{
						if(pLoopUnit->getUnitType() != NO_UNIT)
						{
							if(::IsPromotionValidForUnitCombatType(ePromotion, pLoopUnit->getUnitType()) || ::IsPromotionValidForUnitCombatType(ePromotion, pLoopUnit->getUnitType()))
							{
								pLoopUnit->setHasPromotion(ePromotion, false);
								bChanged = true;
							}
						}
					}
					ChangeFreePromotionCount(ePromotion, -1);
				}
			}
			for(int iI = 0; iI < GC.getNumResourceInfos(); iI++)
			{
				ResourceTypes eResource = (ResourceTypes)iI;
				if(eResource != NO_RESOURCE)
				{
					int iBonus = pkEventChoiceInfo->getEventResourceChange(eResource);
					iBonus *= -1;
					if(iBonus != 0)
					{
						changeNumResourceTotal(eResource, iBonus);
						bChanged = true;
					}
				}
			}
			if(pkEventChoiceInfo->getPlayerHappiness() != 0)
			{
				if(getCapitalCity() != NULL)
				{
					getCapitalCity()->ChangeEventHappiness(pkEventChoiceInfo->getPlayerHappiness() * -1);
					bChanged = true;
				}
			}
			if(pkEventChoiceInfo->getCityHappinessGlobal() != 0)
			{
				CvCity *pLoopCity;
				int iLoop;
				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					pLoopCity->ChangeEventHappiness(pkEventChoiceInfo->getCityHappinessGlobal() * -1);
					bChanged = true;
				}
			}
			for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				YieldTypes eYield = (YieldTypes)iI;
				if(eYield == NO_YIELD)
					continue;

				if(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS)
				{
					int iUnhappinessNeedMod = pkEventChoiceInfo->getCityUnhappinessNeedMod(eYield);
					if(iUnhappinessNeedMod != 0)
					{
						iUnhappinessNeedMod *= -1;
						if(eYield == YIELD_GOLD)
						{
							ChangePovertyUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_CULTURE)
						{
							ChangeUnculturedUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_PRODUCTION)
						{
							ChangeDefenseUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_SCIENCE)
						{
							ChangeIlliteracyUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_FAITH)
						{
							ChangeMinorityUnhappinessGlobal(iUnhappinessNeedMod);
						}
					}
				}

				int iYieldChange = pkEventChoiceInfo->getCityYield(eYield);
				if(iYieldChange != 0)
				{
					if(pkEventChoiceInfo->IsEraScaling())
					{
						int iEra = GetCurrentEra();
						if(iEra <= 0)
						{
							iEra = 1;
						}
						iYieldChange *= iEra;
					}
					CvCity *pLoopCity;
					int iLoop;
					for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						pLoopCity->ChangeEventCityYield(eYield, iYieldChange * -1);
						bChanged = true;
					}
				}
				// Building modifiers
				for(int iJ = 0; iJ < GC.getNumBuildingClassInfos(); iJ++)
				{
					BuildingClassTypes eBuildingClass = (BuildingClassTypes) iJ;

					CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
					if(!pkBuildingClassInfo)
					{
						continue;
					}
					if(pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield) != 0)
					{
						BuildingTypes eBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

						if(eBuilding != NO_BUILDING)
						{
							CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
							if(pkBuilding)
							{
								CvCity *pLoopCity;
								int iLoop;
								for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
								{
									int iBuildingCount = pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding);

									pLoopCity->ChangeEventBuildingClassYield(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield) * -1);
									bChanged = true;
									if(iBuildingCount > 0)
									{
										pLoopCity->ChangeBaseYieldRateFromBuildings(eYield, pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield) * -1);
									}
								}
							}
						}
					}
					if(pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield) != 0)
					{
						BuildingTypes eBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

						if(eBuilding != NO_BUILDING)
						{
							CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
							if(pkBuilding)
							{
								CvCity *pLoopCity;
								int iLoop;
								for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
								{
									int iBuildingCount = pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding);
									pLoopCity->ChangeEventBuildingClassYieldModifier(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield) * -1);
									bChanged = true;
									if(iBuildingCount > 0)
									{
										pLoopCity->changeYieldRateModifier(eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield) * -1);
									}
								}
							}
						}
					}
				}
				for(int iJ = 0; iJ < GC.getNumImprovementInfos(); iJ++)
				{
					ImprovementTypes eImprovement = (ImprovementTypes)iJ;
					if(eImprovement != NO_IMPROVEMENT && pkEventChoiceInfo->getImprovementYield(eImprovement, eYield) != 0)
					{
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							pLoopCity->ChangeEventImprovementYield(eImprovement, eYield, pkEventChoiceInfo->getImprovementYield(eImprovement, eYield) * -1);
						}
						bChanged = true;
					}
				}
				for(int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
				{
					FeatureTypes eFeature = (FeatureTypes)iJ;
					if(eFeature != NO_FEATURE && pkEventChoiceInfo->getFeatureYield(eFeature, eYield) != 0)
					{
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							pLoopCity->ChangeEventFeatureYield(eFeature, eYield, pkEventChoiceInfo->getFeatureYield(eFeature, eYield) * -1);
						}
						bChanged = true;
					}
				}
				for(int iJ = 0; iJ < GC.getNumTerrainInfos(); iJ++)
				{
					TerrainTypes eTerrain = (TerrainTypes)iJ;
					if(eTerrain != NO_TERRAIN && pkEventChoiceInfo->getTerrainYield(eTerrain, eYield) != 0)
					{
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							pLoopCity->ChangeEventTerrainYield(eTerrain, eYield, pkEventChoiceInfo->getTerrainYield(eTerrain, eYield) * -1);
						}
						bChanged = true;
					}
				}
				for(int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
				{
					ResourceTypes eResource = (ResourceTypes)iJ;
					if(eResource != NO_RESOURCE && pkEventChoiceInfo->getResourceYield(eResource, eYield) != 0)
					{
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							pLoopCity->ChangeEventResourceYield(eResource, eYield, pkEventChoiceInfo->getResourceYield(eResource, eYield) * -1);
						}
						bChanged = true;
					}
				}
			}
		}
		if(bChanged)
		{
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications && GC.getGame().getActivePlayer() == GetID())
			{
				Localization::String strMessage;
				Localization::String strSummary;
				strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_EVENT_HAS_ENDED");
				strMessage << GetScaledHelpText(eChosenEventChoice, true);
				strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_EVENT_HAS_ENDED_T");

				pNotifications->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, -1, GetID());
			}
			CvCity* pLoopCity;
			int iLoop;
			for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				if(pLoopCity != NULL)
				{
					for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
					{
						YieldTypes eYield = (YieldTypes) iI;
						if(eYield == NO_YIELD)
							continue;

						pLoopCity->UpdateSpecialReligionYields(eYield);
						pLoopCity->UpdateCityYields(eYield);
					}
					pLoopCity->UpdateReligion(pLoopCity->GetCityReligions()->GetReligiousMajority());
					CalculateNetHappiness();
					pLoopCity->GetCityCulture()->CalculateBaseTourismBeforeModifiers();
					pLoopCity->GetCityCulture()->CalculateBaseTourism();
				}
			}
		}
		//Set it false here so we know the event choice is over now.
		SetEventChoiceActive(eChosenEventChoice, false);
	}
}
CvString CvPlayer::GetScaledHelpText(EventChoiceTypes eEventChoice, bool bYieldsOnly)
{
	CvString CoreYieldTip = "";
	CvModEventChoiceInfo* pkEventChoiceInfo = GC.getEventChoiceInfo(eEventChoice);
	if(pkEventChoiceInfo == NULL)
	{
		return "";
	}
	Localization::String localizedCoreText;
	if(bYieldsOnly)
	{
		localizedCoreText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION");
	}
	else
	{
		localizedCoreText = Localization::Lookup(pkEventChoiceInfo->GetHelp());
	}

	int iEra = GetCurrentEra();
	if(iEra <= 0)
	{
		iEra = 1;
	}
	CvString yieldCostTip = "";
	CvString yieldInstantTip = "";
	CvString yieldCityTip = "";
	CvString turnsTip = "";
				
	for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eIndex = (YieldTypes)iI;
		if(eIndex == NO_YIELD)
		{
			continue;
		}
		CvYieldInfo* pYield = GC.getYieldInfo(eIndex);
		if(pYield)
		{
			int iValue = pkEventChoiceInfo->getPreCheckEventYield(eIndex);
			if(pkEventChoiceInfo->IsEraScaling())
			{
				iValue *= iEra;
			}
			iValue *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iValue /= 100;
			if(iValue != 0)
			{
				iValue *= -1;
				if(yieldCostTip != "")
				{
					yieldCostTip += ", ";
				}
				Localization::String localizedCostText;
				if(bYieldsOnly)
				{
					localizedCostText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_SPENT");
				}
				else
				{
					localizedCostText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED");
				}
				localizedCostText << pYield->GetDescription();
				localizedCostText << pYield->getIconString();
				localizedCostText << iValue;

				const char* const localized = localizedCostText.toUTF8();
				if(localized)
				{
					yieldCostTip += localized;
				}
			}
			iValue = pkEventChoiceInfo->getEventYield(eIndex);
			if(pkEventChoiceInfo->IsEraScaling())
			{
				iValue *= iEra;
			}
			iValue *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iValue /= 100;
			if(iValue != 0)
			{
				if(yieldInstantTip != "")
				{
					yieldInstantTip += ", ";
				}
				Localization::String localizedEventText;
				if(bYieldsOnly)
				{
					localizedEventText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_INSTANT");
				}
				else
				{
					localizedEventText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED");
				}
				localizedEventText << pYield->GetDescription();
				localizedEventText << pYield->getIconString();
				localizedEventText << iValue;

				const char* const localized = localizedEventText.toUTF8();
				if(localized)
				{
					yieldInstantTip += localized;
				}
			}
			iValue = pkEventChoiceInfo->getCityYield(eIndex);
			if(pkEventChoiceInfo->IsEraScaling())
			{
				iValue *= iEra;
			}
			if(iValue != 0)
			{
				if(yieldCityTip != "")
				{
					yieldCityTip += ", ";
				}
				Localization::String localizedCityText;
				if(bYieldsOnly)
				{
					localizedCityText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_CITY");
				}
				else
				{
					localizedCityText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED");
				}
				localizedCityText << pYield->GetDescription();
				localizedCityText << pYield->getIconString();
				localizedCityText << iValue;

				const char* const localized = localizedCityText.toUTF8();
				if(localized)
				{
					yieldCityTip += localized;
				}
			}
		}
	}
	localizedCoreText << yieldCostTip;
	localizedCoreText << yieldInstantTip;
	localizedCoreText << yieldCityTip;

	//Duration
	int iDuration = pkEventChoiceInfo->getEventDuration();
	if(iDuration > 0)
	{
		iDuration *= GC.getGame().getGameSpeedInfo().getTrainPercent();
		iDuration /= 100;
		Localization::String localizedDurationText;
		if(bYieldsOnly)
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_TURNS");
		}
		else
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_YIELD_DURATION");
		}
		localizedDurationText << iDuration;
		const char* const localized = localizedDurationText.toUTF8();
		if(localized)
		{
			turnsTip += localized;
		}
	}
	localizedCoreText << turnsTip;

	const char* const finallocalized = localizedCoreText.toUTF8();
	if(finallocalized)
	{
		CoreYieldTip = finallocalized;
	}
	return CoreYieldTip.c_str();
}
void CvPlayer::DoEventChoice(EventChoiceTypes eEventChoice, EventTypes eEvent)
{
	if(eEventChoice != NO_EVENT_CHOICE)
	{
		CvModEventChoiceInfo* pkEventChoiceInfo = GC.getEventChoiceInfo(eEventChoice);
		if(pkEventChoiceInfo != NULL)
		{
			//Set oneshot stuff so this event can't fire ever again.
			if(pkEventChoiceInfo->isOneShot())
			{
				SetEventChoiceFired(eEventChoice, true);
			}
			//Set false so we know we've completed the city event.
			//Loop through all city events and set any related to this to false, just to be sure.
			//This is purely for the notification system to keep the icon from disappearing until a choice has been made.
			if(eEvent == NO_EVENT)
			{
				for(int iLoop = 0; iLoop < GC.getNumEventInfos(); iLoop++)
				{
					EventTypes eEvent = (EventTypes)iLoop;
					if(eEvent != NO_EVENT)
					{
						if(pkEventChoiceInfo->isParentEvent(eEvent))
						{
							SetEventActive(eEvent, false);
						}
					}
				}
			}
			else
			{
				SetEventActive(eEvent, false);
			}
			//Lua Hook
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_EventChoiceActivated, GetID(), eEventChoice);

			if(GC.getLogging())
			{
				CvString playerName;
				FILogFile* pLog;
				CvString strBaseString;
				CvString strOutBuf;
				CvString strFileName = "EventLogging.csv";
				playerName = getCivilizationShortDescription();
				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				strBaseString += playerName + ", ";
				strOutBuf.Format("Event choice chosen by player: %s", pkEventChoiceInfo->GetDescription());
				strBaseString += strOutBuf;
				pLog->Msg(strBaseString);
			}
			//Set the cooldown for all events.
			if(pkEventChoiceInfo->getEventDuration() > 0)
			{
				//Gamespeed.
				int iEventDuration = pkEventChoiceInfo->getEventDuration();
				iEventDuration *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iEventDuration /= 100;
				ChangeEventChoiceDuration(eEventChoice, iEventDuration);
			}
			//Do the cost first, as that goes through whether or not the event succeeds!
			for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				YieldTypes eYield = (YieldTypes)iI;
				if(eYield == NO_YIELD)
					continue;
							
				int iPassYield = pkEventChoiceInfo->getPreCheckEventYield(eYield);
				if(iPassYield != 0)
				{
					iPassYield *= -1;
					CvCity* pCity = getCapitalCity();
					if(pCity != NULL)
					{
						doInstantYield(INSTANT_YIELD_TYPE_INSTANT, false, NO_GREATPERSON, NO_BUILDING, iPassYield, pkEventChoiceInfo->IsEraScaling(), NO_PLAYER, NULL, true, pCity, false, true, true, eYield);
					}
				}
			}
			//Let's see if it even happens.
			if(pkEventChoiceInfo->getEventChance() > 0)
			{
				int iRandom = GC.getGame().getJonRandNum(100, "Random Event Chance");
				int iLimit = pkEventChoiceInfo->getEventChance();
				if(iRandom < iLimit)
				{
					//Notify if it did not work.
					CvNotifications* pNotifications = GetNotifications();
					if(pNotifications && GC.getGame().getActivePlayer() == GetID())
					{
						for(int iLoop = 0; iLoop < GC.getNumCityEventInfos(); iLoop++)
						{
							EventTypes eEvent = (EventTypes)iLoop;
							if(eEvent != NO_EVENT)
							{
								if(pkEventChoiceInfo->isParentEvent(eEvent))
								{
									CvModEventInfo* pkEventInfo = GC.getEventInfo(eEvent);
									if(pkEventInfo != NULL)
									{
										Localization::String strMessage;
										Localization::String strSummary;
										strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_EVENT_FAILED");
										strMessage << pkEventChoiceInfo->GetDescription();
										strMessage << GetScaledHelpText(eEventChoice, false);
										strMessage << pkEventInfo->GetDescription();
										strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_EVENT_FAILED_T");
										strSummary << pkEventInfo->GetDescription();

										pNotifications->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, -1, GetID());
										break;
									}
								}
							}
						}
					}
					return;
				}
			}
			//Succeeded? Set event choice active here so we know to deduct it later.
			SetEventChoiceActive(eEventChoice, true);

			//Now on to the actions themselves.
			if(pkEventChoiceInfo->getEventPolicy() != -1)
			{
				PolicyTypes ePolicy = (PolicyTypes)pkEventChoiceInfo->getEventPolicy();
				if(ePolicy != -1)
				{
					GetPlayerPolicies()->SetPolicy(ePolicy, true, true);
				}
			}
			if(pkEventChoiceInfo->getEventTech() != -1)
			{
				TechTypes eTech = (TechTypes)pkEventChoiceInfo->getEventTech();
				if(eTech != -1)
				{
					GET_TEAM(getTeam()).GetTeamTechs()->SetHasTech(eTech, true);
				}
			}
			if(pkEventChoiceInfo->getEventBuilding() != -1)
			{
				BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventChoiceInfo->getEventBuilding();
				if(eBuildingClass != NO_BUILDINGCLASS)
				{
					const CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
	
					if (pkBuildingClassInfo)
					{
						CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
		
						if (pCivilizationInfo != NULL)
						{
							BuildingTypes eBuildingType = (BuildingTypes) pCivilizationInfo->getCivilizationBuildings(eBuildingClass);
							if(eBuildingType != NO_BUILDING)
							{
								CvCity *pLoopCity;
								int iLoop;
								for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
								{
									pLoopCity->GetCityBuildings()->SetNumFreeBuilding(eBuildingType, 1);
								}
							}
						}
					}
				}
			}
			if(pkEventChoiceInfo->getEventPromotion() != -1)
			{
				PromotionTypes ePromotion = (PromotionTypes)pkEventChoiceInfo->getEventPromotion();
				if(ePromotion != -1)
				{
					CvUnit* pLoopUnit;
					int iLoop;
					for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
					{
						if(pLoopUnit->getUnitType() != NO_UNIT)
						{
							if(::IsPromotionValidForUnitCombatType(ePromotion, pLoopUnit->getUnitType()) || ::IsPromotionValidForUnitCombatType(ePromotion, pLoopUnit->getUnitType()))
							{
								if(pLoopUnit->HasPromotion(ePromotion))
								{
#if defined(MOD_UNITS_XP_TIMES_100)
									pLoopUnit->changeExperienceTimes100(15 * 100);
#else
									pLoopUnit->changeExperience(15);
#endif
								}
								else
								{
									pLoopUnit->setHasPromotion(ePromotion, true);
								}
							}
						}
					}
					ChangeFreePromotionCount(ePromotion, 1);
				}
			}
			for(int iI = 0; iI < GC.getNumResourceInfos(); iI++)
			{
				ResourceTypes eResource = (ResourceTypes)iI;
				if(eResource != NO_RESOURCE)
				{
					int iBonus = pkEventChoiceInfo->getEventResourceChange(eResource);
					if(iBonus != 0)
					{
						changeNumResourceTotal(eResource, iBonus);
					}
				}
			}
			for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				YieldTypes eYield = (YieldTypes)iI;
				if(eYield == NO_YIELD)
					continue;

				if(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS)
				{
					int iUnhappinessNeedMod = pkEventChoiceInfo->getCityUnhappinessNeedMod(eYield);
					if(iUnhappinessNeedMod != 0)
					{
						if(eYield == YIELD_GOLD)
						{
							ChangePovertyUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_CULTURE)
						{
							ChangeUnculturedUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_PRODUCTION)
						{
							ChangeDefenseUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_SCIENCE)
						{
							ChangeIlliteracyUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_FAITH)
						{
							ChangeMinorityUnhappinessGlobal(iUnhappinessNeedMod);
						}
					}
				}

				int iYieldChange = pkEventChoiceInfo->getCityYield(eYield);
				if(iYieldChange != 0)
				{
					if(pkEventChoiceInfo->IsEraScaling())
					{
						int iEra = GetCurrentEra();
						if(iEra <= 0)
						{
							iEra = 1;
						}
						iYieldChange *= iEra;
					}
					CvCity *pLoopCity;
					int iLoop;
					for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						pLoopCity->ChangeEventCityYield(eYield, iYieldChange);
					}
				}
				// Building modifiers
				for(int iJ = 0; iJ < GC.getNumBuildingClassInfos(); iJ++)
				{
					BuildingClassTypes eBuildingClass = (BuildingClassTypes) iJ;

					CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
					if(!pkBuildingClassInfo)
					{
						continue;
					}
					if(pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield) != 0)
					{
						BuildingTypes eBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

						if(eBuilding != NO_BUILDING)
						{
							CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
							if(pkBuilding)
							{
								CvCity *pLoopCity;
								int iLoop;
								for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
								{
									int iBuildingCount = pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding);

									pLoopCity->ChangeEventBuildingClassYield(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield));
									if(iBuildingCount > 0)
									{
										pLoopCity->ChangeBaseYieldRateFromBuildings(eYield, pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield));
									}
								}
							}
						}
					}
					if(pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield) != 0)
					{
						BuildingTypes eBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

						if(eBuilding != NO_BUILDING)
						{
							CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
							if(pkBuilding)
							{
								CvCity *pLoopCity;
								int iLoop;
								for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
								{
									int iBuildingCount = pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding);

									pLoopCity->ChangeEventBuildingClassYieldModifier(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield));
									if(iBuildingCount > 0)
									{
										pLoopCity->changeYieldRateModifier(eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield));
									}
								}
							}
						}
					}
				}
							
				int iPassYield = pkEventChoiceInfo->getEventYield(eYield);
				if(iPassYield != 0)
				{
					CvCity* pCity = getCapitalCity();
					if(pCity != NULL)
					{
						doInstantYield(INSTANT_YIELD_TYPE_INSTANT, false, NO_GREATPERSON, NO_BUILDING, iPassYield, pkEventChoiceInfo->IsEraScaling(), NO_PLAYER, NULL, true, pCity, false, true, true, eYield);
					}
				}
				for(int iJ = 0; iJ < GC.getNumImprovementInfos(); iJ++)
				{
					ImprovementTypes eImprovement = (ImprovementTypes)iJ;
					if(eImprovement != NO_IMPROVEMENT && pkEventChoiceInfo->getImprovementYield(eImprovement, eYield) != 0)
					{
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							pLoopCity->ChangeEventImprovementYield(eImprovement, eYield, pkEventChoiceInfo->getImprovementYield(eImprovement, eYield));
						}
					}
				}
				for(int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
				{
					FeatureTypes eFeature = (FeatureTypes)iJ;
					if(eFeature != NO_FEATURE && pkEventChoiceInfo->getFeatureYield(eFeature, eYield) != 0)
					{
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							pLoopCity->ChangeEventFeatureYield(eFeature, eYield, pkEventChoiceInfo->getFeatureYield(eFeature, eYield));
						}
					}
				}
				for(int iJ = 0; iJ < GC.getNumTerrainInfos(); iJ++)
				{
					TerrainTypes eTerrain = (TerrainTypes)iJ;
					if(eTerrain != NO_TERRAIN && pkEventChoiceInfo->getTerrainYield(eTerrain, eYield) != 0)
					{
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							pLoopCity->ChangeEventTerrainYield(eTerrain, eYield, pkEventChoiceInfo->getTerrainYield(eTerrain, eYield));
						}
					}
				}
				for(int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
				{
					ResourceTypes eResource = (ResourceTypes)iJ;
					if(eResource != NO_RESOURCE && pkEventChoiceInfo->getResourceYield(eResource, eYield) != 0)
					{
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							pLoopCity->ChangeEventResourceYield(eResource, eYield, pkEventChoiceInfo->getResourceYield(eResource, eYield));
						}
					}
				}
			}
			if(pkEventChoiceInfo->getGoldenAgeTurns() > 0)
			{
				int iTurns = pkEventChoiceInfo->getGoldenAgeTurns();
				iTurns *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iTurns /= 100;
				changeGoldenAgeTurns(iTurns);
			}
			if(pkEventChoiceInfo->getNumFreeGreatPeople() > 0)
			{
				ChangeNumFreeGreatPeople(pkEventChoiceInfo->getNumFreeGreatPeople());
			}
			if(pkEventChoiceInfo->getNumFreePolicies() > 0)
			{
				ChangeNumFreePolicies(pkEventChoiceInfo->getNumFreePolicies());
			}
			if(pkEventChoiceInfo->getPlayerHappiness() != 0)
			{
				if(getCapitalCity() != NULL)
				{
					getCapitalCity()->ChangeEventHappiness(pkEventChoiceInfo->getPlayerHappiness());
				}
			}
			if(pkEventChoiceInfo->getCityHappinessGlobal() != 0)
			{
				CvCity *pLoopCity;
				int iLoop;
				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					pLoopCity->ChangeEventHappiness(pkEventChoiceInfo->getCityHappinessGlobal());
				}
			}
			if(pkEventChoiceInfo->getRandomBarbs() > 0)
			{
				// In hundreds
				int iNumRebels = pkEventChoiceInfo->getRandomBarbs();
				CvGame& theGame = GC.getGame();

				CvCity *pLoopCity;
				int iLoop;
				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					// Found a place to set up an uprising?
					if(pLoopCity != NULL)
					{
						int iBestPlot = -1;
						int iBestPlotWeight = -1;
						CvPlot* pPlot;

						CvCityCitizens* pCitizens = pLoopCity->GetCityCitizens();

						// Start at 1, since ID 0 is the city plot itself

						for(int iPlotLoop = 1; iPlotLoop < pLoopCity->GetNumWorkablePlots(); iPlotLoop++)
						{
							pPlot = pCitizens->GetCityPlotFromIndex(iPlotLoop);

							if(!pPlot)		// Should be valid, but make sure
								continue;

							// Can't be impassable
							if(!pPlot->isValidMovePlot(BARBARIAN_PLAYER))
								continue;

							// Can't be water
							if(pPlot->isWater())
								continue;

							// Can't be ANOTHER city
							if(pPlot->isCity())
								continue;

							// Don't place on a plot where a unit is already standing
							if(pPlot->getNumUnits() > 0)
								continue;

							int iTempWeight = theGame.getJonRandNum(10, "Uprising rand plot location.");

							// Add weight if there's an improvement here!
							if(pPlot->getImprovementType() != NO_IMPROVEMENT)
							{
								iTempWeight += 4;

								// If also a a resource, even more weight!
								if(pPlot->getResourceType(getTeam()) != NO_RESOURCE)
									iTempWeight += 3;
							}
			
							// Don't pick plots that aren't ours
							if(pPlot->getOwner() != GetID())
								iTempWeight = -1;

							// Add weight if there's a defensive bonus for this plot
							if(pPlot->defenseModifier(BARBARIAN_TEAM, false, false))
								iTempWeight += 4;

							if(iTempWeight > iBestPlotWeight)
							{
								iBestPlotWeight = iTempWeight;
								iBestPlot = iPlotLoop;
							}
						}

						// Found valid plot
						if(iBestPlot != -1)
						{
							// Make barbs able to enter ANYONE'S territory
							theGame.SetBarbarianReleaseTurn(0);

							pPlot = pCitizens->GetCityPlotFromIndex(iBestPlot);

							// Pick a unit type - should give us more melee than ranged
							UnitTypes eUnit = theGame.GetCompetitiveSpawnUnitType(GetID(), /*bIncludeUUs*/ true, /*bIncludeRanged*/ true, false, true);
							UnitTypes emUnit = theGame.GetCompetitiveSpawnUnitType(GetID(), /*bIncludeUUs*/ true, /*bIncludeRanged*/ false, false, true);

							// Init unit
							CvUnit* pstartUnit = GET_PLAYER(BARBARIAN_PLAYER).initUnit(emUnit, pPlot->getX(), pPlot->getY());
							CvAssert(pstartUnit);
							if (pstartUnit)
							{
								if (!pstartUnit->jumpToNearestValidPlotWithinRange(3))
								{
									pstartUnit->kill(false);		// Could not find a spot!
								}
								else
								{
									pstartUnit->setMoves(0);
								}
							}
							iNumRebels--;	// Reduce the count since we just added the seed rebel

							// Loop until all rebels are placed
							if(iNumRebels > 0)
							{
								do
								{
									iNumRebels--;

									// Init unit
									CvUnit* pmUnit = GET_PLAYER(BARBARIAN_PLAYER).initUnit(emUnit, pPlot->getX(), pPlot->getY());
									CvAssert(pmUnit);
									if (pmUnit)
									{
										if (!pmUnit->jumpToNearestValidPlotWithinRange(3))
										{
											pmUnit->kill(false);		// Could not find a spot!
										}
										else
										{
											pmUnit->setMoves(0);
										}
									}

									iNumRebels--;
									if(iNumRebels > 0)
									{		
										// Init unit
										CvUnit* pUnit = GET_PLAYER(BARBARIAN_PLAYER).initUnit(eUnit, pPlot->getX(), pPlot->getY());
										CvAssert(pUnit);
										if (pUnit)
										{
											if (!pUnit->jumpToNearestValidPlotWithinRange(3))
											{
												pUnit->kill(false);		// Could not find a spot!
											}
											else
											{
												pUnit->setMoves(0);
											}
										}
										}
								}
								while(iNumRebels > 0);
							}
						}
					}
				}
			}
			if(pkEventChoiceInfo->getFreeScaledUnits() > 0)
			{
				// In hundreds
				int iNumRecruits = pkEventChoiceInfo->getFreeScaledUnits();
				CvGame& theGame = GC.getGame();

				CvCity *pLoopCity;
				int iLoop;
				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					// Found a place to set up an uprising?
					if(pLoopCity != NULL)
					{
						int iBestPlot = -1;
						int iBestPlotWeight = -1;
						CvPlot* pPlot;

						CvCityCitizens* pCitizens = pLoopCity->GetCityCitizens();

						// Start at 1, since ID 0 is the city plot itself

						for(int iPlotLoop = 1; iPlotLoop < pLoopCity->GetNumWorkablePlots(); iPlotLoop++)
						{
							pPlot = pCitizens->GetCityPlotFromIndex(iPlotLoop);

							if(!pPlot)		// Should be valid, but make sure
								continue;

							// Can't be impassable
							if(!pPlot->isValidMovePlot(GetID()))
								continue;

							// Can't be water
							if(pPlot->isWater())
								continue;

							// Can't be ANOTHER city
							if(pPlot->isCity())
								continue;

							// Don't place on a plot where a unit is already standing
							if(pPlot->getNumUnits() > 0)
								continue;

							int iTempWeight = theGame.getJonRandNum(10, "Uprising rand plot location.");

							// Add weight if there's an improvement here!
							if(pPlot->getImprovementType() != NO_IMPROVEMENT)
							{
								iTempWeight += 4;

								// If also a a resource, even more weight!
								if(pPlot->getResourceType(getTeam()) != NO_RESOURCE)
									iTempWeight += 3;
							}
			
							// Don't pick plots that aren't ours
							if(pPlot->getOwner() != GetID())
								iTempWeight = -1;

							// Add weight if there's a defensive bonus for this plot
							if(pPlot->defenseModifier(getTeam(), false, false))
								iTempWeight += 4;

							if(iTempWeight > iBestPlotWeight)
							{
								iBestPlotWeight = iTempWeight;
								iBestPlot = iPlotLoop;
							}
						}

						// Found valid plot
						if(iBestPlot != -1)
						{
							pPlot = pCitizens->GetCityPlotFromIndex(iBestPlot);

							// Pick a unit type - should give us more melee than ranged
							UnitTypes eUnit = theGame.GetCompetitiveSpawnUnitType(GetID(), /*bIncludeUUs*/ false, /*bIncludeRanged*/ true, false, true);
							UnitTypes emUnit = theGame.GetCompetitiveSpawnUnitType(GetID(), /*bIncludeUUs*/ false, /*bIncludeRanged*/ false, false, true);

							CvUnit* pstartUnit = GET_PLAYER(GetID()).initUnit(emUnit, pPlot->getX(), pPlot->getY());
							CvAssert(pstartUnit);
							if (pstartUnit)
							{
								if (!pstartUnit->jumpToNearestValidPlotWithinRange(3))
								{
									pstartUnit->kill(false);		// Could not find a spot!
								}
								else
								{
									pstartUnit->setMoves(0);
								}
							}
							iNumRecruits--;	// Reduce the count since we just added the seed rebel

							// Loop until all rebels are placed
							if(iNumRecruits > 0)
							{
								do
								{
									iNumRecruits--;

									// Init unit
									CvUnit* pmUnit = initUnit(emUnit, pPlot->getX(), pPlot->getY());
									CvAssert(pmUnit);
									if (pmUnit)
									{
										if (!pmUnit->jumpToNearestValidPlotWithinRange(3))
										{
											pmUnit->kill(false);		// Could not find a spot!
										}
										else
										{
											pmUnit->setMoves(0);
										}
									}

									iNumRecruits--;
									if(iNumRecruits > 0)
									{		
										// Init unit
										CvUnit* pUnit = initUnit(eUnit, pPlot->getX(), pPlot->getY());
										CvAssert(pUnit);
										if (pUnit)
										{
											if (!pUnit->jumpToNearestValidPlotWithinRange(3))
											{
												pUnit->kill(false);		// Could not find a spot!
											}
											else
											{
												pUnit->setMoves(0);
											}
										}
										}
								}
								while(iNumRecruits > 0);
							}
						}
					}
				}
			}
			for(int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
			{
				const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
				CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
				if(pkUnitClassInfo)
				{
					if(pkEventChoiceInfo->getNumFreeUnits((UnitClassTypes)iI) <= 0)
						continue;

					CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
		
					if (pCivilizationInfo != NULL)
					{
						const UnitTypes eLoopUnit = (UnitTypes) pCivilizationInfo->getCivilizationUnits(iI);
						if(eLoopUnit != NO_UNIT)
						{
							CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eLoopUnit);
							if(pkUnitEntry)
							{
								CvCity *pLoopCity;
								int iLoop;
								for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
								{
									for(int iJ = 0; iJ < pkEventChoiceInfo->getNumFreeUnits((UnitClassTypes)iI); iJ++)
									{
										UnitAITypes eUnitAI = pkUnitEntry->GetDefaultUnitAIType();
										int iResult = pLoopCity->CreateUnit(eLoopUnit, eUnitAI);

										CvAssertMsg(iResult != -1, "Unable to create unit");

										if (iResult != -1)
										{
											CvUnit* pUnit = getUnit(iResult);
											if (!pUnit->jumpToNearestValidPlot())
											{
												pUnit->kill(false);	// Could not find a valid spot!
											}
											pUnit->setMoves(0);
										}
									}
								}
							}
						}
					}
				}
			}
			for(int iI = 0; iI < GC.getNumReligionInfos(); iI++)
			{
				ReligionTypes eReligion = (ReligionTypes)iI;
				if(eReligion == NO_RELIGION)
					continue;

				int iPercent = (ReligionTypes)pkEventChoiceInfo->getEventConvertReligionPercent(iI);
				if(iPercent > 0)
				{
					CvCity *pLoopCity;
					int iLoop;
					for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						pLoopCity->GetCityReligions()->ConvertPercentForcedFollowers(eReligion, iPercent);
					}
				}
				int iPop = (ReligionTypes)pkEventChoiceInfo->getEventConvertReligion(iI);
				if(iPop > 0)
				{
					CvCity *pLoopCity;
					int iLoop;
					for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						pLoopCity->GetCityReligions()->ConvertNumberFollowers(eReligion, iPop);
					}
				}
			}
			if(pkEventChoiceInfo->getResistanceTurns() > 0)
			{
				int iTurns = pkEventChoiceInfo->getResistanceTurns();
				iTurns *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iTurns /= 100;
				CvCity *pLoopCity;
				int iLoop;
				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					pLoopCity->ChangeResistanceTurns(iTurns);
				}
			}
			if(pkEventChoiceInfo->getWLTKD() > 0)
			{
				int iTurns = pkEventChoiceInfo->getWLTKD();
				iTurns *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iTurns /= 100;
				CvCity *pLoopCity;
				int iLoop;
				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					pLoopCity->ChangeWeLoveTheKingDayCounter(iTurns);
				}
			}

			//Let's do our notification stuff here.
			for(int iI = 0; iI < pkEventChoiceInfo->GetNumNotifications(); iI++)
			{
				CvString strNotificationString = pkEventChoiceInfo->GetNotificationInfo(iI)->GetNotificationString();		
				if(strNotificationString != NULL && strNotificationString != "")
				{
					NotificationTypes eNotificationType = (NotificationTypes)FString::Hash(strNotificationString);
					
					if(eNotificationType != NO_NOTIFICATION_TYPE)
					{
						Localization::String strMessage;
						Localization::String strSummary;
						strSummary = Localization::Lookup(pkEventChoiceInfo->GetNotificationInfo(iI)->GetShortDescription());
						strSummary << getCivilizationShortDescriptionKey();
						strSummary << getCivilizationDescription();
						strSummary << getName();
						strMessage = Localization::Lookup(pkEventChoiceInfo->GetNotificationInfo(iI)->GetDescription());
						strMessage << getCivilizationShortDescriptionKey();
						strMessage << getCivilizationDescription();
						strMessage << getName();
						strMessage << GetScaledHelpText(eEventChoice, true);
						bool bGlobal = pkEventChoiceInfo->GetNotificationInfo(iI)->IsWorldEvent();
						for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
						{
							PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;
							if(ePlayer != NO_PLAYER && GET_PLAYER(ePlayer).isMajorCiv())
							{
								//Not global? Skip all but me.
								if(!bGlobal && ePlayer != GetID())
									continue;

								//Global? Seed only to known players.
								if(bGlobal && ePlayer != GetID() && !GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(getTeam()))
									continue;

								//Send out notifications!
								CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();
								if(pNotifications && GC.getGame().getActivePlayer() == ePlayer)
								{
									if(pkEventChoiceInfo->GetNotificationInfo(iI)->IsNeedPlayerID())
									{
										pNotifications->Add(eNotificationType, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, GetID(), pkEventChoiceInfo->GetNotificationInfo(iI)->GetVariable2());
									}
									else
									{
										pNotifications->Add(eNotificationType, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, pkEventChoiceInfo->GetNotificationInfo(iI)->GetVariable1(), pkEventChoiceInfo->GetNotificationInfo(iI)->GetVariable2());
									}
								}
							}
						}
					}
				}
			}
			CvCity* pLoopCity;
			int iLoop;
			for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				if(pLoopCity != NULL)
				{					
					for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
					{
						YieldTypes eYield = (YieldTypes) iI;
						if(eYield == NO_YIELD)
							continue;

						pLoopCity->UpdateSpecialReligionYields(eYield);
						pLoopCity->UpdateCityYields(eYield);
					}
					pLoopCity->UpdateReligion(pLoopCity->GetCityReligions()->GetReligiousMajority());
					CalculateNetHappiness();
					pLoopCity->GetCityCulture()->CalculateBaseTourismBeforeModifiers();
					pLoopCity->GetCityCulture()->CalculateBaseTourism();
				}
			}
		}
	}
}
#endif
//	--------------------------------------------------------------------------------
/// This player liberates iOldCityID and gives it back to ePlayer
void CvPlayer::DoLiberatePlayer(PlayerTypes ePlayer, int iOldCityID)
{
	CvCity* pCity = getCity(iOldCityID);
	CvAssert(pCity);
	if (!pCity)
		return;

	PlayerTypes eOldOwner = pCity->getOwner();
	CvPlot* pPlot = pCity->plot();

#if defined(MOD_BALANCE_CORE)
	if(ePlayer == NO_PLAYER || GET_PLAYER(ePlayer).isBarbarian())
	{
		ePlayer = pCity->getOriginalOwner();
	}
	if(ePlayer == NO_PLAYER)
	{
		return;
	}
#endif

	// Set that this team has been liberated
	TeamTypes eTeam = getTeam();
	TeamTypes eLiberatedTeam = GET_PLAYER(ePlayer).getTeam();

	// Who originally took out this team?
	TeamTypes eConquerorTeam = GET_TEAM(eLiberatedTeam).GetKilledByTeam();

	if (!GET_PLAYER(ePlayer).isAlive())
	{
		GET_PLAYER(ePlayer).setBeingResurrected(true);
		GET_TEAM(eLiberatedTeam).SetLiberatedByTeam(eTeam);

		// Put everyone at peace with this guy
		for(int iOtherTeamLoop = 0; iOtherTeamLoop < MAX_CIV_TEAMS; iOtherTeamLoop++)
		{
			if(eLiberatedTeam != iOtherTeamLoop)
			{
#if defined(MOD_EVENTS_WAR_AND_PEACE)
				GET_TEAM(eLiberatedTeam).makePeace((TeamTypes) iOtherTeamLoop, /*bBumpUnits*/false, /*bSuppressNotification*/true, GetID());
#else
				GET_TEAM(eLiberatedTeam).makePeace((TeamTypes) iOtherTeamLoop, /*bBumpUnits*/false, /*bSuppressNotification*/true);
#endif
			}
		}
	
		if (!GET_PLAYER(ePlayer).isMinorCiv())
		{
			// add notification
			Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_CIV_RESURRECTED");
			strMessage << getCivilizationShortDescriptionKey(); // LIBERATING CIV NAME
			strMessage << pCity->getNameKey(); // CITY NAME
			strMessage << GET_PLAYER(ePlayer).getCivilizationAdjectiveKey(); // LIBERATED CIV NAME
			strMessage << GET_PLAYER(ePlayer).getCivilizationDescriptionKey();// LIBERATED CIV NAME
			Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CIV_RESURRECTED_SHORT");
			if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(ePlayer).isHuman())
			{
				strSummary << GET_PLAYER(ePlayer).getNickName();
			}
			else
			{
				strSummary << GET_PLAYER(ePlayer).getNameKey();
			}
			if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(m_eID).isHuman())
			{
				strSummary << GET_PLAYER(m_eID).getNickName();
			}
			else
			{
				strSummary << GET_PLAYER(m_eID).getNameKey();
			}			

			for(int iI = 0; iI < MAX_PLAYERS; iI++)
			{
				const PlayerTypes eOtherPlayer = static_cast<PlayerTypes>(iI);
				CvPlayerAI& kOtherPlayer = GET_PLAYER(eOtherPlayer);
				if(kOtherPlayer.isAlive() && kOtherPlayer.GetNotifications() && iI != m_eID)
				{
					kOtherPlayer.GetNotifications()->Add(NOTIFICATION_RESURRECTED_MAJOR_CIV, strMessage.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), -1);
				}
			}

			CvString temp = strMessage.toUTF8();
			GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, m_eID, temp);
		}
	}
	else
	{
		GET_PLAYER(ePlayer).GetDiplomacyAI()->ChangeNumCitiesLiberated(m_eID, 1);
#if defined(MOD_BALANCE_CORE)
		GET_PLAYER(ePlayer).GetDiplomacyAI()->SetLiberatedCitiesTurn(m_eID, GC.getGame().getGameTurn());
#endif

		if (!GET_PLAYER(ePlayer).isMinorCiv())
		{
			// add notification
			Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_LIBERATED");
			if(GC.getGame().isGameMultiPlayer() && isHuman())
			{
				strMessage << getNickName();
			}
			else
			{
				strMessage << getNameKey();
			}
			strMessage << pCity->getNameKey(); // CITY NAME
			strMessage << GET_PLAYER(ePlayer).getCivilizationShortDescriptionKey();// RESTORED CIV NAME
			Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CIV_LIBERATED_SHORT");
			strSummary << pCity->getNameKey();
			if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(ePlayer).isHuman())
			{
				strSummary << GET_PLAYER(ePlayer).getNickName();
			}
			else
			{
				strSummary << GET_PLAYER(ePlayer).getNameKey();
			}

			for(int iI = 0; iI < MAX_PLAYERS; iI++)
			{
				const PlayerTypes eOtherPlayer = static_cast<PlayerTypes>(iI);
				CvPlayerAI& kOtherPlayer = GET_PLAYER(eOtherPlayer);
				if(kOtherPlayer.isAlive() && kOtherPlayer.GetNotifications() && iI != m_eID)
				{
					kOtherPlayer.GetNotifications()->Add(NOTIFICATION_LIBERATED_MAJOR_CITY, strMessage.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), -1);
				}
			}
		}
	}

	// Give the city back to the liberated player
#if defined(MOD_API_EXTENSIONS)
	CvCity* pNewCity = GET_PLAYER(ePlayer).acquireCity(pCity, false, true);
#else
	GET_PLAYER(ePlayer).acquireCity(pCity, false, true);
#endif

	if (!GET_PLAYER(ePlayer).isMinorCiv())
	{
		// slewis - if the player we're liberating the city for is dead, give the liberating player a resurrection mark in the once-defeated player's book
		if (!GET_PLAYER(ePlayer).isAlive())
		{
			CvDiplomacyAI* pDiploAI = GET_PLAYER(ePlayer).GetDiplomacyAI();
			PlayerTypes eMePlayer = GetID();
			pDiploAI->SetResurrectedBy(eMePlayer, true);
			pDiploAI->SetLandDisputeLevel(eMePlayer, DISPUTE_LEVEL_NONE);
			pDiploAI->SetWonderDisputeLevel(eMePlayer, DISPUTE_LEVEL_NONE);
			pDiploAI->SetMinorCivDisputeLevel(eMePlayer, DISPUTE_LEVEL_NONE);
			pDiploAI->SetWarmongerThreat(eMePlayer, THREAT_NONE);

			pDiploAI->SetPlayerNoSettleRequestCounter(eMePlayer, -1);
			pDiploAI->SetPlayerStopSpyingRequestCounter(eMePlayer, -1);
			pDiploAI->SetDemandCounter(eMePlayer, -1);
			pDiploAI->ChangeNumTimesCultureBombed(eMePlayer, -pDiploAI->GetNumTimesCultureBombed(eMePlayer));
			pDiploAI->ChangeNegativeReligiousConversionPoints(eMePlayer, -pDiploAI->GetNegativeReligiousConversionPoints(eMePlayer));
			pDiploAI->ChangeNegativeArchaeologyPoints(eMePlayer, -pDiploAI->GetNegativeArchaeologyPoints(eMePlayer));

			pDiploAI->ChangeNumTimesRobbedBy(eMePlayer, -pDiploAI->GetNumTimesRobbedBy(eMePlayer));
			pDiploAI->SetPlayerBrokenMilitaryPromise(eMePlayer, false);
			pDiploAI->SetPlayerIgnoredMilitaryPromise(eMePlayer, false);
			pDiploAI->SetBrokenBorderPromiseValue(eMePlayer, 0);
			pDiploAI->SetIgnoredBorderPromiseValue(eMePlayer, 0);
			pDiploAI->SetBrokenExpansionPromiseValue(eMePlayer, 0);
			pDiploAI->SetIgnoredExpansionPromiseValue(eMePlayer, 0);

			pDiploAI->SetPlayerBrokenAttackCityStatePromise(eMePlayer, false);
			pDiploAI->SetPlayerIgnoredAttackCityStatePromise(eMePlayer, false);
			pDiploAI->SetPlayerBrokenBullyCityStatePromise(eMePlayer, false);
			pDiploAI->SetPlayerIgnoredBullyCityStatePromise(eMePlayer, false);

			pDiploAI->SetPlayerBrokenNoConvertPromise(eMePlayer, false);
			pDiploAI->SetPlayerIgnoredNoConvertPromise(eMePlayer, false);

			pDiploAI->SetPlayerBrokenNoDiggingPromise(eMePlayer, false);
			pDiploAI->SetPlayerIgnoredNoDiggingPromise(eMePlayer, false);

			pDiploAI->SetPlayerBrokenSpyPromise(eMePlayer, false);
			pDiploAI->SetPlayerIgnoredSpyPromise(eMePlayer, false);

			pDiploAI->SetPlayerBrokenCoopWarPromise(eMePlayer, false);

			pDiploAI->SetOtherPlayerNumProtectedMinorsKilled(eMePlayer, 0);
			pDiploAI->SetOtherPlayerNumProtectedMinorsAttacked(eMePlayer, 0);
			pDiploAI->SetOtherPlayerNumProtectedMinorsBullied(eMePlayer, 0);
			pDiploAI->SetOtherPlayerTurnsSinceSidedWithProtectedMinor(eMePlayer, -1);

			pDiploAI->SetFriendDenouncedUs(eMePlayer, false);
			pDiploAI->SetDenouncedPlayer(eMePlayer, false); // forget any denouncing
			GetDiplomacyAI()->SetDenouncedPlayer(ePlayer, false); // forget any denouncing
			pDiploAI->SetFriendDeclaredWarOnUs(eMePlayer, false);

			pDiploAI->ChangeNumTimesNuked(eMePlayer, -pDiploAI->GetNumTimesNuked(eMePlayer));
		}
	}

	// Now verify the player is alive
	GET_PLAYER(ePlayer).verifyAlive();
	GET_PLAYER(ePlayer).setBeingResurrected(false);

	// Is this a Minor we have liberated?
#if defined(MOD_BALANCE_CORE)
	if(GET_PLAYER(ePlayer).isMinorCiv() && !GET_PLAYER(ePlayer).isBarbarian())
#else
	if(GET_PLAYER(ePlayer).isMinorCiv())
#endif
	{
		if(!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(getTeam()))
		{
			GET_TEAM(GET_PLAYER(ePlayer).getTeam()).meet(getTeam(), true);
		}
		GET_PLAYER(ePlayer).GetMinorCivAI()->DoLiberationByMajor(eOldOwner, eConquerorTeam);
	}

	// slewis
	// negate warmonger
	for(int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)
	{
		PlayerTypes eMajor = (PlayerTypes)iMajorLoop;
		if(GetID() != eMajor && GET_PLAYER(eMajor).isAlive())
		{
			// Have I met the player who conquered the city?
			if(GET_TEAM(GET_PLAYER(eMajor).getTeam()).isHasMet(getTeam()))
			{
#if defined(MOD_CONFIG_AI_IN_XML)
				int iWarmongerOffset = CvDiplomacyAIHelpers::GetPlayerCaresValue(GetID(), ePlayer, pNewCity->isCapital(), pNewCity, GetID(), true);
				GET_PLAYER(eMajor).GetDiplomacyAI()->ChangeOtherPlayerWarmongerAmountTimes100(GetID(), -iWarmongerOffset);
#else
				int iNumCities = max(GET_PLAYER(ePlayer).getNumCities(), 1);
				int iWarmongerOffset = CvDiplomacyAIHelpers::GetWarmongerOffset(iNumCities, GET_PLAYER(ePlayer).isMinorCiv());
				GET_PLAYER(eMajor).GetDiplomacyAI()->ChangeOtherPlayerWarmongerAmount(GetID(), -iWarmongerOffset);
#endif
			}
		}
	}

	// Move Units from player that don't belong here
	if(pPlot->getNumUnits() > 0)
	{
		// Get the current list of units because we will possibly be moving them out of the plot's list
		IDInfoVector currentUnits;
		if (pPlot->getUnits(&currentUnits) > 0)
		{
			for(IDInfoVector::const_iterator itr = currentUnits.begin(); itr != currentUnits.end(); ++itr)
			{
				CvUnit* pLoopUnit = (CvUnit*)GetPlayerUnit(*itr);

				if(pLoopUnit && pLoopUnit->getOwner() == eOldOwner)
				{
					pLoopUnit->finishMoves();
					if (!pLoopUnit->jumpToNearestValidPlot())
						pLoopUnit->kill(false);
				}
			}
		}
	}

#if defined(MOD_EVENTS_LIBERATION)
	if (MOD_EVENTS_LIBERATION) {
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerLiberated, GetID(), ePlayer, pNewCity->GetID());
	}
#endif

#if defined(MOD_DIPLOMACY_CITYSTATES)
	//Let's give the Embassies of the defeated player back to the liberated player
	if(MOD_DIPLOMACY_CITYSTATES && GET_PLAYER(ePlayer).GetImprovementLeagueVotes() > 0)
	{
		for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			ePlayer = (PlayerTypes) iPlayerLoop;
			if(ePlayer != NO_PLAYER && GET_PLAYER(ePlayer).getTeam() == eConquerorTeam)
			{
				int iEmbassyVotes = GET_PLAYER(ePlayer).GetImprovementLeagueVotes();
				GET_PLAYER(ePlayer).ChangeImprovementLeagueVotes(-iEmbassyVotes);
			}
		}
	}
#endif
}

//	--------------------------------------------------------------------------------
bool CvPlayer::CanLiberatePlayer(PlayerTypes ePlayer)
{
	// Other Player must be dead now
	if(GET_PLAYER(ePlayer).isAlive())
	{
		return false;
	}

	if(GET_PLAYER(ePlayer).IsEverConqueredBy(m_eID))
	{
		return false;
	}

	if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetKilledByTeam() == getTeam())
	{
		return false;
	}
	
#if defined(MOD_EVENTS_LIBERATION)
	if (MOD_EVENTS_LIBERATION) {
		if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_PlayerCanLiberate, GetID(), ePlayer) == GAMEEVENTRETURN_FALSE) {
			return false;
		}
	}
#endif

	return true;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::CanLiberatePlayerCity(PlayerTypes ePlayer)
{
	if (!GET_PLAYER(ePlayer).isAlive())
	{
		return CanLiberatePlayer(ePlayer);
	}

	return true;
}

//	--------------------------------------------------------------------------------
CvUnit* CvPlayer::initUnit(UnitTypes eUnit, int iX, int iY, UnitAITypes eUnitAI, DirectionTypes eFacingDirection, bool bNoMove, bool bSetupGraphical, int iMapLayer /* = 0 */, int iNumGoodyHutsPopped)
{
	CvAssertMsg(eUnit != NO_UNIT, "Unit is not assigned a valid value");
	if (eUnit == NO_UNIT)
		return NULL;

	CvUnitEntry* pkUnitDef = GC.getUnitInfo(eUnit);
	CvAssertFmt(pkUnitDef != NULL, "Trying to create unit of type %d, which does not exist", eUnit);
	if (pkUnitDef == NULL)
		return NULL;

	CvUnit* pUnit = addUnit();
	CvAssertMsg(pUnit != NULL, "Unit is not assigned a valid value");
	if(NULL != pUnit)
	{
		pUnit->init(pUnit->GetID(), eUnit, ((eUnitAI == NO_UNITAI) ? pkUnitDef->GetDefaultUnitAIType() : eUnitAI), GetID(), iX, iY, eFacingDirection, bNoMove, bSetupGraphical, iMapLayer, iNumGoodyHutsPopped);
#if !defined(NO_TUTORIALS)
		// slewis - added for the tutorial
		if(pUnit->getUnitInfo().GetWorkRate() > 0 && pUnit->getUnitInfo().GetDomainType() == DOMAIN_LAND)
		{
			m_bEverTrainedBuilder = true;
		}
		// end added for the tutorial
#endif
	}

	m_kPlayerAchievements.AddUnit(pUnit);

	return pUnit;
}

CvUnit* CvPlayer::initUnitWithNameOffset(UnitTypes eUnit, int nameOffset, int iX, int iY, UnitAITypes eUnitAI, DirectionTypes eFacingDirection, bool bNoMove, bool bSetupGraphical, int iMapLayer /* = 0 */, int iNumGoodyHutsPopped)
{
	CvAssertMsg(eUnit != NO_UNIT, "Unit is not assigned a valid value");
	if (eUnit == NO_UNIT)
		return NULL;

	CvUnitEntry* pkUnitDef = GC.getUnitInfo(eUnit);
	CvAssertFmt(pkUnitDef != NULL, "Trying to create unit of type %d, which does not exist", eUnit);
	if (pkUnitDef == NULL)
		return NULL;

	CvUnit* pUnit = addUnit();
	CvAssertMsg(pUnit != NULL, "Unit is not assigned a valid value");
	if(NULL != pUnit)
	{
		pUnit->initWithNameOffset(pUnit->GetID(), eUnit, nameOffset, ((eUnitAI == NO_UNITAI) ? pkUnitDef->GetDefaultUnitAIType() : eUnitAI), GetID(), iX, iY, eFacingDirection, bNoMove, bSetupGraphical, iMapLayer, iNumGoodyHutsPopped);

#if !defined(NO_TUTORIALS)
		// slewis - added for the tutorial
		if(pUnit->getUnitInfo().GetWorkRate() > 0 && pUnit->getUnitInfo().GetDomainType() == DOMAIN_LAND)
		{
			m_bEverTrainedBuilder = true;
		}
		// end added for the tutorial
#endif
	}

	m_kPlayerAchievements.AddUnit(pUnit);

	return pUnit;
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
CvUnit* CvPlayer::initNamedUnit(UnitTypes eUnit, const char* strKey, int iX, int iY, UnitAITypes eUnitAI, DirectionTypes eFacingDirection, bool bNoMove, bool bSetupGraphical, int iMapLayer /* = 0 */, int iNumGoodyHutsPopped)
{
	CvAssertMsg(eUnit != NO_UNIT, "Unit is not assigned a valid value");
	if (eUnit == NO_UNIT)
		return NULL;

	CvUnitEntry* pkUnitDef = GC.getUnitInfo(eUnit);
	CvAssertFmt(pkUnitDef != NULL, "Trying to create unit of type %d, which does not exist", eUnit);
	if (pkUnitDef == NULL)
		return NULL;

	if(strKey == NULL)
		return NULL;

	CvString strName = strKey;
	if(GC.getGame().isGreatPersonBorn(strName))
	{
		return NULL;
	}

	CvUnit* pUnit = addUnit();
	CvAssertMsg(pUnit != NULL, "Unit is not assigned a valid value");
	if(NULL != pUnit)
	{
		pUnit->initWithSpecificName(pUnit->GetID(), eUnit, strKey, ((eUnitAI == NO_UNITAI) ? pkUnitDef->GetDefaultUnitAIType() : eUnitAI), GetID(), iX, iY, eFacingDirection, bNoMove, bSetupGraphical, iMapLayer, iNumGoodyHutsPopped);
	}

	return pUnit;
}
#endif
//	--------------------------------------------------------------------------------
void CvPlayer::disbandUnit(bool)
{
	CvUnit* pLoopUnit;
	CvUnit* pBestUnit;
	char szBuffer[1024];
	const size_t lenBuffer = 1024;
	int iValue;
	int iBestValue;
	int iLoop;

	iBestValue = INT_MAX;
	pBestUnit = NULL;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(!(pLoopUnit->hasCargo()))
		{
			if(!(pLoopUnit->isGoldenAge()))
			{
				if(pLoopUnit->getUnitInfo().GetProductionCost() > 0)
				{
					{
						iValue = (10000 + GC.getGame().getJonRandNum(1000, "Disband Unit"));

						iValue += (pLoopUnit->getUnitInfo().GetProductionCost() * 5);

#if defined(MOD_UNITS_XP_TIMES_100)
						iValue += (pLoopUnit->getExperienceTimes100() / 100 * 20);
#else
						iValue += (pLoopUnit->getExperience() * 20);
#endif
						iValue += (pLoopUnit->getLevel() * 100);

						if(pLoopUnit->IsGarrisoned())
						{
							iValue *= 2;
						}

						if(pLoopUnit->plot()->getTeam() == pLoopUnit->getTeam())
						{
							iValue *= 3;
						}

						switch(pLoopUnit->AI_getUnitAIType())
						{
						case UNITAI_UNKNOWN:
							break;

						case UNITAI_SETTLE:
							iValue *= 20;
							break;

						case UNITAI_WORKER:
							iValue *= 10;
							break;

						case UNITAI_ATTACK:
						case UNITAI_CITY_BOMBARD:
						case UNITAI_FAST_ATTACK:
						case UNITAI_DEFENSE:
						case UNITAI_COUNTER:
							iValue *= 2;
							break;

						case UNITAI_RANGED:
						case UNITAI_CITY_SPECIAL:
						case UNITAI_PARADROP:
							iValue *= 6;
							break;

						case UNITAI_EXPLORE:
							iValue *= 15;
							break;

						case UNITAI_ARTIST:
						case UNITAI_SCIENTIST:
						case UNITAI_GENERAL:
						case UNITAI_MERCHANT:
#if defined(MOD_DIPLOMACY_CITYSTATES)
						case UNITAI_DIPLOMAT:
						case UNITAI_MESSENGER:
#endif
						case UNITAI_ENGINEER:
						case UNITAI_SPACESHIP_PART:
						case UNITAI_TREASURE:
						case UNITAI_PROPHET:
						case UNITAI_MISSIONARY:
						case UNITAI_INQUISITOR:
						case UNITAI_ADMIRAL:
						case UNITAI_WRITER:
						case UNITAI_MUSICIAN:
							break;

						case UNITAI_ICBM:
							iValue *= 4;
							break;

						case UNITAI_WORKER_SEA:
							iValue *= 18;
							break;

						case UNITAI_ATTACK_SEA:
						case UNITAI_RESERVE_SEA:
						case UNITAI_ESCORT_SEA:
							break;

						case UNITAI_EXPLORE_SEA:
							iValue *= 25;
							break;

						case UNITAI_ASSAULT_SEA:
						case UNITAI_SETTLER_SEA:
						case UNITAI_CARRIER_SEA:
						case UNITAI_MISSILE_CARRIER_SEA:
							iValue *= 5;
							break;

						case UNITAI_PIRATE_SEA:
						case UNITAI_ATTACK_AIR:
							break;

						case UNITAI_DEFENSE_AIR:
						case UNITAI_CARRIER_AIR:
						case UNITAI_MISSILE_AIR:
							iValue *= 3;
							break;

						default:
							CvAssert(false);
							break;
						}

						if(pLoopUnit->getUnitInfo().GetExtraMaintenanceCost() > 0)
						{
							iValue /= (pLoopUnit->getUnitInfo().GetExtraMaintenanceCost() + 1);
						}

						if(iValue < iBestValue)
						{
							iBestValue = iValue;
							pBestUnit = pLoopUnit;
						}
					}
				}
			}
		}
	}

	if(pBestUnit != NULL)
	{
		if(GetID() == GC.getGame().getActivePlayer())
		{
			sprintf_s(szBuffer, lenBuffer, GetLocalizedText("TXT_KEY_MISC_UNIT_DISBANDED_NO_MONEY", pBestUnit->getNameKey()).GetCString());
			GC.GetEngineUserInterface()->AddUnitMessage(0, pBestUnit->GetIDInfo(), GetID(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer);//, "AS2D_UNITDISBANDED", MESSAGE_TYPE_MINOR_EVENT, pBestUnit->getUnitInfo().GetButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pBestUnit->getX(), pBestUnit->getY(), true, true);
		}

		CvAssert(!(pBestUnit->isGoldenAge()));

		pBestUnit->kill(false);
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::killUnits()
{
	//can't kill the units directly because that invalidates the iterator
	std::vector<int> unitsToKill;

	int iLoop;
	for(CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		unitsToKill.push_back(pLoopUnit->GetID());
	}

	//debugging ...
	for (std::vector<int>::iterator it = unitsToKill.begin(); it != unitsToKill.end(); ++it)
	{
		if (std::count(unitsToKill.begin(), unitsToKill.end(),*it)>1)
			OutputDebugString("inconsistent state: non-unique unit ID to kill!\n");
	}

	for (std::vector<int>::iterator it=unitsToKill.begin(); it!=unitsToKill.end(); ++it)
	{
		CvUnit* pLoopUnit = getUnit(*it);
		if (pLoopUnit)
			pLoopUnit->kill(false);
	}
}

#if defined(MOD_API_EXTENSIONS) || defined(MOD_BUGFIX_UNITCLASS_NOT_UNIT)
//	--------------------------------------------------------------------------------
// Given a unit class, get the players specific unit of that class
UnitTypes CvPlayer::GetSpecificUnitType(const char* szUnitClass, bool hideAssert)
{
	UnitTypes eUnitType = NO_UNIT;
	UnitClassTypes eUnitClassType = (UnitClassTypes) GC.getInfoTypeForString(szUnitClass, hideAssert);

	const CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClassType);
	
	if (pkUnitClassInfo)
	{
		CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
		
		if (pCivilizationInfo != NULL)
		{
			eUnitType = (UnitTypes) pCivilizationInfo->getCivilizationUnits(eUnitClassType);
		}
		else
		{
			eUnitType = (UnitTypes) pkUnitClassInfo->getDefaultUnitIndex();
		}
	}
	
	if (!isMinorCiv() && !isBarbarian()) {
		if (eUnitType == NO_UNIT) {
			CUSTOMLOG("GetSpecificUnitType for player %s: %s is UNKNOWN!!!", getName(), szUnitClass);
		} else {
			// CUSTOMLOG("GetSpecificUnitType for player %s: %s is %s", getName(), szUnitClass, GC.getUnitInfo(eUnitType)->GetType());
		}
	}

	return eUnitType;
}
#endif

#if defined(MOD_API_EXTENSIONS) || defined(MOD_BUGFIX_BUILDINGCLASS_NOT_BUILDING)
//	--------------------------------------------------------------------------------
// Given a building class, get the players specific building of that class
BuildingTypes CvPlayer::GetSpecificBuildingType(const char* szBuildingClass, bool hideAssert)
{
	BuildingTypes eBuildingType = NO_BUILDING;
	BuildingClassTypes eBuildingClassType = (BuildingClassTypes) GC.getInfoTypeForString(szBuildingClass, hideAssert);

	const CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClassType);
	
	if (pkBuildingClassInfo)
	{
		CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
		
		if (pCivilizationInfo != NULL)
		{
			eBuildingType = (BuildingTypes) pCivilizationInfo->getCivilizationBuildings(eBuildingClassType);
		}
		else
		{
			eBuildingType = (BuildingTypes) pkBuildingClassInfo->getDefaultBuildingIndex();
		}
	}
	
	if (!isMinorCiv() && !isBarbarian()) {
		if (eBuildingType == NO_BUILDING) {
			CUSTOMLOG("GetSpecificBuildingType for player %s: %s is UNKNOWN!!!", getName(), szBuildingClass);
		} else {
			// CUSTOMLOG("GetSpecificBuildingType for player %s: %s is %s", getName(), szBuildingClass, GC.getBuildingInfo(eBuildingType)->GetType());
		}
	}

	return eBuildingType;
}
#endif

//	--------------------------------------------------------------------------------
CvPlot *CvPlayer::GetGreatAdmiralSpawnPlot (CvUnit *pUnit)
{
	CvPlot *pInitialPlot = pUnit->plot();

	// Is this a friendly coastal city, if so we'll go with that
	CvCity *pInitialCity = pInitialPlot->getPlotCity();
	if (pInitialCity && pInitialCity->isCoastal(GC.getLAKE_MAX_AREA_SIZE()))
	{
		// Equal okay checking this plot because this is where the unit is right now
#if defined(MOD_GLOBAL_STACKING_RULES)
		if (pInitialPlot->getNumFriendlyUnitsOfType(pUnit) <= pInitialPlot->getUnitLimit())
#else
		if (pInitialPlot->getNumFriendlyUnitsOfType(pUnit) <= GC.getPLOT_UNIT_LIMIT())
#endif
		{
			return pInitialPlot;
		}
	}

	// Otherwise let's look at all our other cities
	CvCity *pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (pLoopCity != pInitialCity)
		{
			if (pLoopCity->isCoastal(GC.getLAKE_MAX_AREA_SIZE()))
			{
#if defined(MOD_GLOBAL_STACKING_RULES)
				if (pLoopCity->plot()->getNumFriendlyUnitsOfType(pUnit) < pLoopCity->plot()->getUnitLimit())
#else
				if (pLoopCity->plot()->getNumFriendlyUnitsOfType(pUnit) < GC.getPLOT_UNIT_LIMIT())
#endif
				{
					return pLoopCity->plot();
				}
			}
		}
	}

	// Don't have a coastal city, look for water plot THAT ISN'T A LAKE closest to our capital that isn't owned by an enemy
	int iCapitalX;
	int iCapitalY;
	CvCity *pCapital = getCapitalCity();
	if (pCapital)
	{
		iCapitalX = pCapital->getX();
		iCapitalY = pCapital->getY();

		CvPlot *pBestPlot = NULL;
		int iBestDistance = MAX_INT;

		for (int iI = 0; iI < GC.getMap().numPlots(); iI++)
		{
			CvPlot *pPlot = GC.getMap().plotByIndexUnchecked(iI);
			if (pPlot != NULL)
			{
				if (pPlot->isWater() && !pPlot->isLake())
				{
					if (pPlot->IsFriendlyTerritory(GetID()) || !pPlot->isOwned())
					{
#if defined(MOD_GLOBAL_STACKING_RULES)
						if (pPlot->getNumFriendlyUnitsOfType(pUnit) < pPlot->getUnitLimit())
#else
						if (pPlot->getNumFriendlyUnitsOfType(pUnit) < GC.getPLOT_UNIT_LIMIT())
#endif
						{
							int iDistance = plotDistance(iCapitalX, iCapitalY, pPlot->getX(), pPlot->getY());
							if (iDistance < iBestDistance)
							{
								pBestPlot = pPlot;
								iBestDistance = iDistance;
							}
						}
					}
				}
			}
		}

		if (pBestPlot)
		{
			return pBestPlot;
		}

		// Now we'll even accept a lake
		for (int iI = 0; iI < GC.getMap().numPlots(); iI++)
		{
			CvPlot *pPlot = GC.getMap().plotByIndexUnchecked(iI);
			if (pPlot != NULL)
			{
				if (pPlot->isWater())
				{
					if (pPlot->IsFriendlyTerritory(GetID()) || !pPlot->isOwned())
					{
#if defined(MOD_GLOBAL_STACKING_RULES)
						if (pPlot->getNumFriendlyUnitsOfType(pUnit) < pPlot->getUnitLimit())
#else
						if (pPlot->getNumFriendlyUnitsOfType(pUnit) < GC.getPLOT_UNIT_LIMIT())
#endif
						{
							int iDistance = plotDistance(iCapitalX, iCapitalY, pPlot->getX(), pPlot->getY());
							if (iDistance < iBestDistance)
							{
								pBestPlot = pPlot;
								iBestDistance = iDistance;
							}
						}
					}
				}
			}
		}
		if (pBestPlot)
		{
			return pBestPlot;
		}
	}

	CvAssertMsg (false, "Could not find valid plot for Great Admiral - placing on land");

	return pInitialPlot;
}


//	--------------------------------------------------------------------------------
/// The number of Builders a player has
int CvPlayer::GetNumBuilders() const
{
	return m_iNumBuilders;
}

//	--------------------------------------------------------------------------------
/// Sets the number of Builders a player has
void CvPlayer::SetNumBuilders(int iNum)
{
	if(GetNumBuilders() != iNum)
	{
		m_iNumBuilders = iNum;
	}
}

//	--------------------------------------------------------------------------------
/// Changes the number of Builders a player has
void CvPlayer::ChangeNumBuilders(int iChange)
{
	if(iChange != 0)
	{
		SetNumBuilders(GetNumBuilders() + iChange);
	}
}


//	--------------------------------------------------------------------------------
/// The maximum number of Builders a player can Train
int CvPlayer::GetMaxNumBuilders() const
{
	return m_iMaxNumBuilders;
}

//	--------------------------------------------------------------------------------
/// Sets the maximum number of Builders a player can Train
void CvPlayer::SetMaxNumBuilders(int iNum)
{
	if(GetMaxNumBuilders() != iNum)
	{
		m_iMaxNumBuilders = iNum;
	}
}

//	--------------------------------------------------------------------------------
/// Changes the maximum number of Builders a player can Train
void CvPlayer::ChangeMaxNumBuilders(int iChange)
{
	if(iChange != 0)
	{
		SetMaxNumBuilders(GetMaxNumBuilders() + iChange);
	}
}


//	--------------------------------------------------------------------------------
/// Returns number of Units a player has with a particular UnitAI.  The second argument allows you to check whether or not to include Units currently being trained in Cities.
int CvPlayer::GetNumUnitsWithUnitAI(UnitAITypes eUnitAIType, bool bIncludeBeingTrained, bool bIncludeWater)
{
	int iNumUnits = 0;

	CvUnit* pLoopUnit;
	CvCity* pLoopCity;
	int iLoop;

	// Current Units
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		// Don't include Water Units if we don't want them
		if(pLoopUnit->getDomainType() != DOMAIN_SEA || bIncludeWater)
		{
			if(pLoopUnit->AI_getUnitAIType() == eUnitAIType)
			{
				iNumUnits++;
			}
		}
	}

	// Units being trained now
	if(bIncludeBeingTrained)
	{
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity->isProductionUnit())
			{
				CvUnitEntry* pkUnitEntry = GC.getUnitInfo(pLoopCity->getProductionUnit());
				if(pkUnitEntry)
				{
					// Don't include Water Units if we don't want them
					if(pkUnitEntry->GetDomainType() != DOMAIN_SEA || bIncludeWater)
					{
						if(pkUnitEntry->GetDefaultUnitAIType() == eUnitAIType)
						{
							iNumUnits++;
						}
					}
				}
			}
		}
	}

	return iNumUnits;
}

//	--------------------------------------------------------------------------------
/// Returns number of Units a player has of a particular domain.  The second argument allows you to check whether or not to include civilians.
int CvPlayer::GetNumUnitsWithDomain(DomainTypes eDomain, bool bMilitaryOnly)
{
	int iNumUnits = 0;

	CvUnit* pLoopUnit;
	int iLoop;

	// Current Units
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->getDomainType() == eDomain)
		{
			if(!bMilitaryOnly || pLoopUnit->IsCombatUnit())
			{
				iNumUnits++;
			}
		}
	}

	return iNumUnits;
}

//	-----------------------------------------------------------------------------------------------
int CvPlayer::GetNumUnitsWithUnitCombat(UnitCombatTypes eUnitCombat)
{
	int iNumUnits = 0;

	CvUnit* pLoopUnit;
	int iLoop;

	// Current Units
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->getUnitCombatType() == eUnitCombat)
		{
			iNumUnits++;
		}
	}

	return iNumUnits;
}

//	-----------------------------------------------------------------------------------------------
void CvPlayer::UpdateDangerSingleUnit(CvUnit* pUnit)
{
	m_pDangerPlots->UpdateDangerSingleUnit(pUnit,false,true);
}

//	-----------------------------------------------------------------------------------------------
void CvPlayer::UpdateDangerPlots()
{
	m_pDangerPlots->UpdateDanger(false, false);
}

//	-----------------------------------------------------------------------------------------------
void CvPlayer::SetDangerPlotsDirty()
{
	m_pDangerPlots->SetDirty();
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isHuman() const
{
	if(GetID() == NO_PLAYER)
	{
		return false;
	}

	return CvPreGame::isHuman(GetID());
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isObserver() const
{
	if(GetID() == NO_PLAYER)
	{
		return false;
	}

	return CvPreGame::slotStatus(GetID()) == SS_OBSERVER;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isBarbarian() const
{
	return (GetID() == BARBARIAN_PLAYER);
}

//	--------------------------------------------------------------------------------
void CvPlayer::doBarbarianRansom(int iOption, int iUnitID)
{
	UnitHandle pUnit = getUnit(iUnitID);

	// Pay the Price
	if(iOption == 0)
	{
		int iNumGoldStolen = GC.getBARBARIAN_UNIT_GOLD_RANSOM();	// 100

		if(iNumGoldStolen > GetTreasury()->GetGold())
		{
			iNumGoldStolen = GetTreasury()->GetGold();
		}

		// Unit is ransomed for Gold
		GetTreasury()->ChangeGold(-iNumGoldStolen);
	}
	// Leave them to the Barbs
	else if(iOption == 1)
	{
		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->AddUnitMessage(0, pUnit->GetIDInfo(), GetID(), true, GC.getEVENT_MESSAGE_TIME(), GetLocalizedText("TXT_KEY_MISC_YOU_UNIT_RANSOM_KILL_BY_BARBARIANS", pUnit->getNameKey()));//,GC.getEraInfo(GC.getGame().getCurrentEra())->getAudioUnitDefeatScript(), MESSAGE_TYPE_INFO, pUnit->getUnitInfo().GetButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pUnit->getX(), pUnit->getY(), true, true);
		}

		pUnit->kill(true, BARBARIAN_PLAYER);
	}
}

//	-----------------------------------------------------------------------------------------------
const char* CvPlayer::getName() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->GetDescription();
	}

	if(GC.getGame().isMPOption(MPOPTION_ANONYMOUS) && isAlive() && GC.getGame().getGameState() == GAMESTATE_ON)
	{
		return getLeaderInfo().GetDescription();
	}

	if(GC.getGame().isGameMultiPlayer() && isHuman())
	{
		const CvString& szDisplayName = CvPreGame::nicknameDisplayed(GetID());
		if(szDisplayName.GetLength())
			return szDisplayName.c_str();
	}
	
	const CvString& szPlayerName = CvPreGame::leaderName(GetID());
	if(szPlayerName.GetLength() == 0)
	{
		return getLeaderInfo().GetDescription();
	}

	return szPlayerName.c_str();
}

//	-----------------------------------------------------------------------------------------------
const char* CvPlayer::getNameKey() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->GetTextKey();
	}

	if(GC.getGame().isMPOption(MPOPTION_ANONYMOUS) && isAlive())
	{
		return getLeaderInfo().GetTextKey();
	}

	if(GC.getGame().isGameMultiPlayer() && isHuman())
	{
		// No, this won't be a 'key', but it should just pass through the lookup code and display as is.
		const CvString& szDisplayName = CvPreGame::nicknameDisplayed(GetID());
		if(szDisplayName.GetLength())
			return szDisplayName.c_str();
	}

	const CvString& szPlayerName = CvPreGame::leaderNameKey(GetID());
	if(szPlayerName.GetLength() == 0)
	{
		return getLeaderInfo().GetTextKey();
	}

	return szPlayerName.c_str();
}


//	--------------------------------------------------------------------------------
const char* CvPlayer::getCivilizationDescription() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->GetDescription();
	}
	else if(CvPreGame::civilizationDescription(GetID()).GetLength() == 0)
	{
		return getCivilizationInfo().GetDescription();
	}
	else
	{
		return CvPreGame::civilizationDescription(GetID()).c_str();
	}
}


//	--------------------------------------------------------------------------------
const char* CvPlayer::getCivilizationDescriptionKey() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->GetTextKey();
	}
	else if(CvPreGame::civilizationDescriptionKey(GetID()).GetLength() == 0)
	{
		return getCivilizationInfo().GetTextKey();
	}
	else
	{
		return CvPreGame::civilizationDescriptionKey(GetID()).c_str();
	}
}


//	--------------------------------------------------------------------------------
const char* CvPlayer::getCivilizationShortDescription() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->getShortDescription();
	}
	else if(CvPreGame::civilizationShortDescription(GetID()).GetLength() == 0)
	{
		return getCivilizationInfo().getShortDescription();
	}
	else
	{
		return CvPreGame::civilizationShortDescription(GetID()).c_str();
	}
}


//	--------------------------------------------------------------------------------
const char* CvPlayer::getCivilizationShortDescriptionKey() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->getShortDescriptionKey();
	}
	else if(CvPreGame::civilizationShortDescriptionKey(GetID()).GetLength() == 0)
	{
		return getCivilizationInfo().getShortDescriptionKey();
	}
	else
	{
		return CvPreGame::civilizationShortDescriptionKey(GetID()).c_str();
	}
}


//	--------------------------------------------------------------------------------
const char* CvPlayer::getCivilizationAdjective() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->getAdjective();
	}
	else if(CvPreGame::civilizationAdjective(GetID()).GetLength() == 0)
	{
		return getCivilizationInfo().getAdjective();
	}
	else
	{
		return CvPreGame::civilizationAdjective(GetID()).c_str();
	}
}

//	--------------------------------------------------------------------------------
const char* CvPlayer::getCivilizationAdjectiveKey() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->getAdjectiveKeyWide();
	}
	else if(CvPreGame::civilizationAdjectiveKey(GetID()).GetLength() == 0)
	{
		return getCivilizationInfo().getAdjectiveKey();
	}
	else
	{
		return CvPreGame::civilizationAdjectiveKey(GetID()).c_str();
	}
}

//	--------------------------------------------------------------------------------
const char* CvPlayer::getCivilizationTypeKey() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->GetType();
	}
	else
	{
		return getCivilizationInfo().GetType();
	}
}

//	--------------------------------------------------------------------------------
const char* CvPlayer::getLeaderTypeKey() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->GetType();
	}
	else
	{
		return getLeaderInfo().GetType();
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isWhiteFlag() const
{
	return CvPreGame::isWhiteFlag(GetID());
}


//	--------------------------------------------------------------------------------
const char* CvPlayer::GetStateReligionName() const
{
	return GetLocalizedText(m_strReligionKey.get());
}

//	--------------------------------------------------------------------------------
CvString CvPlayer::GetStateReligionKey() const
{
	return m_strReligionKey.get();
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetStateReligionKey(const char* strKey)
{
	m_strReligionKey = strKey;
}


//	--------------------------------------------------------------------------------
const CvString CvPlayer::getWorstEnemyName() const
{
	TeamTypes eWorstEnemy;

	eWorstEnemy = NO_TEAM;

	if(eWorstEnemy != NO_TEAM)
	{
		return GET_TEAM(eWorstEnemy).getName();
	}

	return "";
}


//	--------------------------------------------------------------------------------
ArtStyleTypes CvPlayer::getArtStyleType() const
{
	if(CvPreGame::artStyle(GetID()) == NO_ARTSTYLE)
	{
		return ((ArtStyleTypes)(getCivilizationInfo().getArtStyleType()));
	}
	else
	{
		return CvPreGame::artStyle(GetID());
	}
}

//	---------------------------------------------------------------------------
void CvPlayer::doTurn()
{
	// Time building of these maps
	AI_PERF_FORMAT("AI-perf.csv", ("CvPlayer::doTurn(), Turn %d, %s", GC.getGame().getGameTurn(), getCivilizationShortDescription()));

	CvAssertMsg(isAlive(), "isAlive is expected to be true");

	doUpdateCacheOnTurn();

	updatePlotFoundValues();

	AI_doTurnPre();

	if(getCultureBombTimer() > 0)
		changeCultureBombTimer(-1);

	if(getConversionTimer() > 0)
		changeConversionTimer(-1);

	if(GetTurnsSinceSettledLastCity() >= 0)
		ChangeTurnsSinceSettledLastCity(1);

	setConscriptCount(0);
#if defined(MOD_BALANCE_CORE)
	GET_TEAM(getTeam()).updateTeamStatus();
	UpdateBestMilitaryCities();
	DoArmyDiversity();
	if(MOD_BALANCE_CORE && !isMinorCiv() && !isBarbarian())
	{
#endif
	DoUpdateCramped();

	DoUpdateUprisings();
	DoUpdateCityRevolts();
	CalculateNetHappiness();

#if defined(MOD_BALANCE_CORE_HAPPINESS)
	if(MOD_BALANCE_CORE_HAPPINESS)
	{
		if(GC.getLogging() && GC.getAILogging())
		{
			CvString playerName;
			FILogFile* pLog;
			CvString strBaseString;
			CvString strOutBuf;
			CvString strFileName = "CustomMods.csv";
			playerName = getCivilizationShortDescription();
			pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			strBaseString += playerName + ", ";
			strOutBuf.Format("Happiness: %d, Gold: %d, Defense: %d, Science: %d, Culture: %d", GetExcessHappiness() , getUnhappinessFromCityGold(), getUnhappinessFromCityDefense(), getUnhappinessFromCityScience(), getUnhappinessFromCityCulture());
			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}
	}
#endif
#if defined(MOD_BALANCE_CORE)
	//Reset every turn for CS events.
	for(int iQuestLoop = 0; iQuestLoop < NUM_MINOR_CIV_QUEST_TYPES; iQuestLoop++)
	{
		SetGlobalTourismAlreadyReceived((MinorCivQuestTypes)iQuestLoop, 0);
	}
	if(GetCorporateFounderID() > 0)
	{
		DoFreedomCorp();
		CalculateCorporateFranchisesWorldwide();
	}
	
	//Reset for reevaluation of citystrategy AI
	countCitiesFeatureSurrounded(true);
#endif
#if defined(MOD_BALANCE_CORE_AFRAID_ANNEX)
	if(MOD_BALANCE_CORE_AFRAID_ANNEX)
	{
		if(GetPlayerTraits()->IsBullyAnnex() && !IsEmpireVeryUnhappy() && !isHuman())
		{
			PlayerTypes eLoopPlayer;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
			{
				eLoopPlayer = (PlayerTypes) iPlayerLoop;
				if(GET_PLAYER(eLoopPlayer).isMinorCiv() && GET_PLAYER(eLoopPlayer).isAlive())
				{
					if(GET_PLAYER(eLoopPlayer).GetMinorCivAI()->CanMajorBullyUnit(GetID()))
					{
						GC.getGame().DoMinorBullyUnit(GetID(), eLoopPlayer);
					}
				}
			}
		}
	}
#endif
	if(GetPlayerTraits()->IsEndOfMayaLongCount())
	{
		ChangeNumMayaBoosts(1);
	}
#if defined(MOD_BALANCE_CORE)
	}
#endif
	bool bHasActiveDiploRequest = false;
	if(isAlive())
	{
		if(!isBarbarian())
		{
			if(!isMinorCiv())
			{
				GetTrade()->DoTurn();
				GetMilitaryAI()->ResetCounters();
				GetGrandStrategyAI()->DoTurn();
#if defined(MOD_ACTIVE_DIPLOMACY)
				GetDiplomacyAI()->DoTurn(DIPLO_AI_PLAYERS);
#else
				if(GC.getGame().isHotSeat() && !isHuman())
				{
					// In Hotseat, AIs only do their diplomacy pass for other AIs on their turn
					// Diplomacy toward a human is done at the beginning of the humans turn.
					GetDiplomacyAI()->DoTurn(CvDiplomacyAI::DIPLO_AI_PLAYERS);		// Do diplomacy for toward everyone
				}
				else
					GetDiplomacyAI()->DoTurn(CvDiplomacyAI::DIPLO_ALL_PLAYERS);	// Do diplomacy for toward everyone

				if (!isHuman())
					bHasActiveDiploRequest = CvDiplomacyRequests::HasActiveDiploRequestWithHuman(GetID());
#endif
			}
		}
	}

	if(isHuman() && !GC.getGame().isGameMultiPlayer())
		doArmySize();

	if( (bHasActiveDiploRequest || GC.GetEngineUserInterface()->isDiploActive()) && !GC.getGame().isGameMultiPlayer() && !isHuman())
	{
		GC.getGame().SetWaitingForBlockingInput(m_eID);
	}
	else
	{
		doTurnPostDiplomacy();
	}
#if defined(MOD_BALANCE_CORE)
	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
		if (eResourceLoop != NO_RESOURCE)
		{
			DoTestOverResourceNotification(eResourceLoop);
		}
	}
#endif
#if defined(MOD_BALANCE_CORE)
	if(MOD_BALANCE_CORE_JFD)
	{
		DoPiety();
		DoReformCooldown();
		DoGovernmentCooldown();
	}
#endif
#if defined(MOD_BALANCE_CORE_EVENTS)
	if(MOD_BALANCE_CORE_EVENTS)
	{
		DoEvents();
	}
#endif
#if defined(MOD_BALANCE_CORE)
	for (int iInstantYield = 0; iInstantYield < NUM_INSTANT_YIELD_TYPES; iInstantYield++)
	{
		InstantYieldType eInstantYield = (InstantYieldType)iInstantYield;
		if(eInstantYield != NO_INSTANT_YIELD_TYPE && getInstantYieldText(eInstantYield) != "" && getInstantYieldText(eInstantYield) != NULL)
		{
			Localization::String strInstantYield = Localization::Lookup(getInstantYieldText(eInstantYield));
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_INSTANT_YIELD_EMPIRE");
				pNotifications->Add((NotificationTypes)FString::Hash("NOTIFICATION_INSTANT_YIELD"), strInstantYield.toUTF8(), strSummary.toUTF8(), -1, -1, GetID());
			}
			setInstantYieldText(eInstantYield, "");
		}
	}
#endif
	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());

		bool bResult;
		LuaSupport::CallHook(pkScriptSystem, "PlayerDoTurn", args.get(), bResult);
	}

	m_kPlayerAchievements.StartTurn();
}

//	--------------------------------------------------------------------------------
void CvPlayer::doTurnPostDiplomacy()
{
	CvGame& kGame = GC.getGame();

	if(isAlive())
	{
		{
			AI_PERF_FORMAT("AI-perf.csv", ("Plots/Danger, Turn %03d, %s", kGame.getElapsedGameTurns(), getCivilizationShortDescription()) );

			UpdatePlots();
			UpdateDangerPlots();
			UpdateFractionOriginalCapitalsUnderControl();
			UpdateAreaEffectUnits();
			GET_TEAM(getTeam()).ClearWarDeclarationCache();
			UpdateCurrentAndFutureWars();
		}

		if(!isBarbarian())
		{
			GetEconomicAI()->DoTurn();
			GetMilitaryAI()->DoTurn();
#if defined(MOD_BALANCE_CORE)
			if(MOD_BALANCE_CORE && !isMinorCiv())
			{
#endif
			GetReligionAI()->DoTurn();
			GetTradeAI()->DoTurn();
			GetCitySpecializationAI()->DoTurn();
			GetLeagueAI()->DoTurn();
#if defined(MOD_BALANCE_CORE)
			}
#endif
		}

		if(isMinorCiv())
		{
			GetMinorCivAI()->DoTurn();
		}
	}

	// Temporary boosts
	if(GetAttackBonusTurns() > 0)
	{
		ChangeAttackBonusTurns(-1);
	}
	if(GetCultureBonusTurns() > 0)
	{
		ChangeCultureBonusTurns(-1);
	}
	if(GetTourismBonusTurns() > 0)
	{
		ChangeTourismBonusTurns(-1);
	}
#if defined(MOD_BALANCE_CORE)
	if(GetCultureBonusTurnsConquest() > 0)
	{
		ChangeCultureBonusTurnsConquest(-1);
	}
#endif

#if defined(MOD_DIPLOMACY_CITYSTATES)
	if(MOD_DIPLOMACY_CITYSTATES && (!isMinorCiv() && !isBarbarian()))
	{
		DoProcessVotes();
		ProcessLeagueResolutions();
	}
#endif
#if defined(MOD_BALANCE_CORE_YIELDS)
	if(MOD_BALANCE_CORE_YIELDS)
	{
		DoChangeGreatGeneralRate();
		DoChangeGreatAdmiralRate();
	}
#endif

	// Golden Age
	DoProcessGoldenAge();

	// Great People gifts from Allied City States (if we have that policy)
	DoGreatPeopleSpawnTurn();

	// Do turn for all Cities
	{
		AI_PERF_FORMAT("AI-perf.csv", ("Do City Turns, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), getCivilizationShortDescription()) );
		if(getNumCities() > 0)
		{
			int iLoop = 0;
			for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				pLoopCity->doTurn();
			}
		}
	}

	// Gold
	GetTreasury()->DoGold();

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	// Tax out from after we've calculated our gold for this turn
	GetTreasury()->CalculateExpensePerTurnFromVassalTaxes();
#endif
	// Culture

	// Prevent exploits in turn timed MP games - no accumulation of culture if player hasn't picked yet
	GetCulture()->SetLastTurnLifetimeCulture(GetJONSCultureEverGenerated());
	if(kGame.isOption(GAMEOPTION_END_TURN_TIMER_ENABLED))
	{
		if(getJONSCulture() < getNextPolicyCost())
			changeJONSCulture(GetTotalJONSCulturePerTurn());
	}
	else
	{
		changeJONSCulture(GetTotalJONSCulturePerTurn());
	}

	// Compute the cost of policies for this turn
	DoUpdateNextPolicyCost();

	// if this is the human player, have the popup come up so that he can choose a new policy
	if(isAlive() && isHuman() && getNumCities() > 0)
	{
		if(!GC.GetEngineUserInterface()->IsPolicyNotificationSeen())
		{
			if(getNextPolicyCost() <= getJONSCulture() && GetPlayerPolicies()->GetNumPoliciesCanBeAdopted() > 0)
			{
				CvNotifications* pNotifications = GetNotifications();
				if(pNotifications)
				{
					CvString strBuffer;

					if(kGame.isOption(GAMEOPTION_POLICY_SAVING))
						strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_ENOUGH_CULTURE_FOR_POLICY_DISMISS");
					else
						strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_ENOUGH_CULTURE_FOR_POLICY");

					CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_ENOUGH_CULTURE_FOR_POLICY");
					pNotifications->Add(NOTIFICATION_POLICY, strBuffer, strSummary, -1, -1, -1);
				}
			}
		}

		if (GetPlayerPolicies()->IsTimeToChooseIdeology() && GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
		{
#if defined(MOD_BALANCE_CORE)
			if(GetPlayerTraits()->IsAdoptionFreeTech())
			{
				CvString strBuffer = GetLocalizedText("TXT_KEY_MISC_CHOSE_IDEOLOGY_UA_CHOOSE_TECH");
				chooseTech(1, strBuffer.GetCString());
			}
#endif
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				CvString strBuffer;
#if defined(MOD_CONFIG_GAME_IN_XML)
				if (GetCurrentEra() > GD_INT_GET(IDEOLOGY_START_ERA))
#else
				if (GetCurrentEra() > GC.getInfoTypeForString("ERA_INDUSTRIAL"))
#endif
				{
					strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_CHOOSE_IDEOLOGY_ERA");
				}
				else
				{
					strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_CHOOSE_IDEOLOGY_FACTORIES");
				}
				CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_CHOOSE_IDEOLOGY");
				pNotifications->Add(NOTIFICATION_CHOOSE_IDEOLOGY, strBuffer, strSummary, -1, -1, GetID());
			}
		}
	}

	if (isAlive() && getNumCities() > 0 && !isHuman() && !isMinorCiv())
	{
		if (GetPlayerPolicies()->IsTimeToChooseIdeology() && GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
		{
#if defined(MOD_BALANCE_CORE)
			if(GetPlayerTraits()->IsAdoptionFreeTech())
			{
				AI_chooseFreeTech();
			}
#endif
			AI_PERF_FORMAT("AI-perf.csv", ("DoChooseIdeology, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), getCivilizationShortDescription()) );
			GetPlayerPolicies()->DoChooseIdeology();
		}
	}

	if(!isBarbarian() && !isHuman())
	{
		AI_PERF_FORMAT("AI-perf.csv", ("DoPolicyAI, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), getCivilizationShortDescription()) );
		GetPlayerPolicies()->DoPolicyAI();
	}

	// Science
	doResearch();

	GetEspionage()->DoTurn();
#if defined(MOD_BALANCE_CORE)
	if(MOD_BALANCE_CORE && !isMinorCiv())
	{
#endif
	// Faith
	CvGameReligions* pGameReligions = kGame.GetGameReligions();
	pGameReligions->DoPlayerTurn(*this);

	// Leagues
	CvGameLeagues* pGameLeagues = kGame.GetGameLeagues();
	pGameLeagues->DoPlayerTurn(*this);

	// Anarchy counter
	if(GetAnarchyNumTurns() > 0)
		ChangeAnarchyNumTurns(-1);
#if defined(MOD_BALANCE_CORE)
	}
#endif
	DoIncomingUnits();

	const int iGameTurn = kGame.getGameTurn();

	GatherPerTurnReplayStats(iGameTurn);

	GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);

	AI_doTurnPost();
}

//	--------------------------------------------------------------------------------
void CvPlayer::doTurnUnits()
{
	CvArmyAI* pLoopArmyAI;
	CvUnit* pLoopUnit;
	int iLoop;

	AI_doTurnUnitsPre();

	// Start: TACTICAL AI UNIT PROCESSING
	m_pTacticalAI->DoTurn();

	// Start: OPERATIONAL AI UNIT PROCESSING
	std::map<int, CvAIOperation*>::iterator iter;
	bool bKilledSomething;
	do
	{
		bKilledSomething = false;
		for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
		{
			CvAIOperation* pThisOperation = iter->second;
			if(pThisOperation)
			{
				if(pThisOperation->DoDelayedDeath())
				{
					bKilledSomething = true;
					break;
				}
			}
		}
		// hack
	}
	while(bKilledSomething);

	for(pLoopArmyAI = firstArmyAI(&iLoop); pLoopArmyAI != NULL; pLoopArmyAI = nextArmyAI(&iLoop))
	{
		pLoopArmyAI->DoDelayedDeath();
	}

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		pLoopUnit->doDelayedDeath();
	}

	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
	{
		CvAIOperation* pThisOperation = iter->second;
		if(pThisOperation)
		{
			pThisOperation->DoTurn();
		}
	}

	do
	{
		bKilledSomething = false;
		for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
		{
			CvAIOperation* pThisOperation = iter->second;
			if(pThisOperation)
			{
				if(pThisOperation->DoDelayedDeath())
				{
					bKilledSomething = true;
					break;
				}
			}
		}
		// hack
	}
	while(bKilledSomething);

	for(pLoopArmyAI = firstArmyAI(&iLoop); pLoopArmyAI != NULL; pLoopArmyAI = nextArmyAI(&iLoop))
	{
		pLoopArmyAI->DoTurn();
	}

	// Homeland AI
	m_pHomelandAI->DoTurn();

	// Start: old unit AI processing
	for(int iPass = 0; iPass < 4; iPass++)
	{
		for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		{
			switch(pLoopUnit->getDomainType())
			{
			case DOMAIN_AIR:
				if(iPass == 1)
				{
					pLoopUnit->doTurn();
				}
				break;
			case DOMAIN_SEA:
				if(iPass == 2)
				{
					pLoopUnit->doTurn();
				}
				break;
			case DOMAIN_LAND:
				if(iPass == 3)
				{
					pLoopUnit->doTurn();
				}
				break;
			case DOMAIN_IMMOBILE:
				if(iPass == 0)
				{
					pLoopUnit->doTurn();
				}
				break;
			case NO_DOMAIN:
				CvAssertMsg(false, "Unit with no Domain");
				break;
			default:
				if(iPass == 3)
				{
					pLoopUnit->doTurn();
				}
				break;
			}
		}
	}

	if(GetID() == GC.getGame().getActivePlayer())
	{
		GC.GetEngineUserInterface()->setDirty(Waypoints_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(SelectionButtons_DIRTY_BIT, true);
	}

	GC.GetEngineUserInterface()->setDirty(UnitInfo_DIRTY_BIT, true);

	AI_doTurnUnitsPost();
}

//	--------------------------------------------------------------------------------
/// Indicate that the AI has not processed any units yet
void CvPlayer::SetAllUnitsUnprocessed()
{
	CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		pLoopUnit->SetTurnProcessed(false);

#if defined(MOD_CORE_PER_TURN_DAMAGE)
		pLoopUnit->flipDamageReceivedPerTurn();
#endif
	}


#if defined(MOD_CORE_PER_TURN_DAMAGE)
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->flipDamageReceivedPerTurn();
	}
#endif
}

//	--------------------------------------------------------------------------------
/// Units heal and then get their movement back
void CvPlayer::DoUnitReset()
{
	CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		// First heal the unit
		pLoopUnit->doHeal();

		// then damage it again
		int iCitadelDamage;
		if(pLoopUnit->IsNearEnemyCitadel(iCitadelDamage))
		{
			pLoopUnit->changeDamage(iCitadelDamage, NO_PLAYER, /*fAdditionalTextDelay*/ 0.5f);
#if defined(MOD_CORE_PER_TURN_DAMAGE)
			pLoopUnit->addDamageReceivedThisTurn(iCitadelDamage);
#endif
		}

		// Finally (now that healing is done), restore movement points
		pLoopUnit->setMoves(pLoopUnit->maxMoves());
#if defined(MOD_PROMOTIONS_FLAGSHIP)
		if(pLoopUnit->IsGreatGeneral() || (MOD_PROMOTIONS_FLAGSHIP && pLoopUnit->IsGreatAdmiral()))
#else
		if(pLoopUnit->IsGreatGeneral())
#endif
		{
			pLoopUnit->setMoves(pLoopUnit->GetGreatGeneralStackMovement());
		}

		// Archaeologist can't move on turn he finishes a dig (while waiting for user to decide his next action)
		else if (pLoopUnit->AI_getUnitAIType() == UNITAI_ARCHAEOLOGIST)
		{
			CvPlayer &kPlayer = GET_PLAYER(pLoopUnit->getOwner());
			if (kPlayer.GetCulture()->HasDigCompleteHere(pLoopUnit->plot()))
			{
				pLoopUnit->setMoves(0);
			}
		}

		pLoopUnit->SetIgnoreDangerWakeup(false);
		pLoopUnit->setMadeAttack(false);
		pLoopUnit->setMadeInterception(false);

		if(!isHuman())
		{
			const MissionData* pkMissionData = pLoopUnit->GetHeadMissionData();
			if(pkMissionData)
			{
				if(pkMissionData->eMissionType == CvTypes::getMISSION_RANGE_ATTACK() ||
				        pkMissionData->eMissionType == CvTypes::getMISSION_AIRSTRIKE() ||
				        pkMissionData->eMissionType == CvTypes::getMISSION_AIR_SWEEP() ||
				        pkMissionData->eMissionType == CvTypes::getMISSION_NUKE())
				{
					CvAssertMsg(0, "An AI unit has a combat mission queued at the end of its turn.");
					pLoopUnit->ClearMissionQueue();	// Clear the whole thing, the AI will re-evaluate next turn.
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Damage units from attrition (start of turn so we can get notifications)
void CvPlayer::DoUnitAttrition()
{
	CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		pLoopUnit->DoAttrition();
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::RespositionInvalidUnits()
{
	CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(!pLoopUnit)
		{
			continue;
		}

		if(pLoopUnit->isDelayedDeath())
		{
			continue;
		}

		if(pLoopUnit->isCargo())
		{
			continue;
		}

		if(pLoopUnit->isInCombat())
		{
			continue;
		}

		CvPlot* pPlot = pLoopUnit->plot();
		if(!pPlot)
		{
			continue;
		}

#if defined(MOD_GLOBAL_STACKING_RULES)
		if(pPlot->getNumFriendlyUnitsOfType(pLoopUnit) > pPlot->getUnitLimit())
#else
		if(pPlot->getNumFriendlyUnitsOfType(pLoopUnit) > GC.getPLOT_UNIT_LIMIT())
#endif
		{
			if (!pLoopUnit->jumpToNearestValidPlot())
				pLoopUnit->kill(false);	// Could not find a valid location!
		}
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::updateYield()
{
	// This will go through all of the plots and update the yield if the player owns it.
	// The plot will not contribute to the player's yield unless it is worked by a city.
	// Previously this would just go through all the plots the city can work (3 rings around it)
	// but all plots have their yields updated on load and not updating them here could lead to 
	// a visual discrepancy.
	CvMap& kMap = GC.getMap();
	int iNumPlots = kMap.numPlots();
	PlayerTypes ePlayer = GetID();
	for (int iI = 0; iI < iNumPlots; iI++)
	{
		CvPlot* pkPlot = kMap.plotByIndexUnchecked(iI);
		if (pkPlot->getOwner() == ePlayer)
			pkPlot->updateYield();
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::updateExtraSpecialistYield()
{
	CvCity* pLoopCity;
	int iLoop;

	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->updateExtraSpecialistYield();
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::updateCityPlotYield()
{
	CvCity* pLoopCity;
	int iLoop;

	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->plot()->updateYield();
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::updateCitySight(bool bIncrement)
{
	CvCity* pLoopCity;
	int iLoop;

	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->plot()->updateSight(bIncrement);
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::UpdateNotifications()
{
	if(GetNotifications())
	{
		GetNotifications()->Update();
	}

	if(GetDiplomacyRequests())
	{
		GetDiplomacyRequests()->Update();
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::UpdateReligion()
{
	CalculateNetHappiness();

#if defined(MOD_BALANCE_CORE)
	int iLoop;
	CvCity* pLoopCity;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
		{
			YieldTypes eYield = (YieldTypes)iI;
			if(eYield == NO_YIELD)
				continue;

			pLoopCity->UpdateSpecialReligionYields(eYield);
		}
	}
	GC.getGame().GetGameReligions()->DoUpdateReligion(GetID());
#endif
}

//	--------------------------------------------------------------------------------
void CvPlayer::updateTimers()
{
	CvUnit* pLoopUnit;
	int iLoop;
	m_endTurnBusyUnitUpdatesLeft--;
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		pLoopUnit->UpdateMission();
		pLoopUnit->doDelayedDeath();
	}

	GetDiplomacyAI()->update();
}

//	--------------------------------------------------------------------------------
bool CvPlayer::hasPromotableUnit() const
{
	const CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->isPromotionReady() && !pLoopUnit->isDelayedDeath())
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::hasReadyUnit() const
{
	const CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->ReadyToMove() && !pLoopUnit->isDelayedDeath())
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetCountReadyUnits() const
{
	int iRtnValue = 0;
	const CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->ReadyToMove() && !pLoopUnit->isDelayedDeath())
		{
			iRtnValue++;
		}
	}

	return iRtnValue;
}

//	--------------------------------------------------------------------------------
const CvUnit* CvPlayer::GetFirstReadyUnit() const
{
	const CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->ReadyToMove() && !pLoopUnit->isDelayedDeath())
		{
			return pLoopUnit;
		}
	}

	return NULL;
}

//	--------------------------------------------------------------------------------
void CvPlayer::EndTurnsForReadyUnits()
{
	CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->ReadyToMove() && !pLoopUnit->isDelayedDeath())
		{
			pLoopUnit->finishMoves();
#if defined(MOD_BALANCE_CORE)
			if(GC.getLogging() && GC.getAILogging())
			{
				CvString strCiv = GET_PLAYER(pLoopUnit->getOwner()).getCivilizationAdjective();
				CvString strLogString;
				strLogString.Format("Warning: Forcing turn end for %s %s at %d,d", strCiv.c_str(), pLoopUnit->getName().c_str(), pLoopUnit->getX(), pLoopUnit->getY() );
				GetHomelandAI()->LogHomelandMessage(strLogString);
			}
#endif
		}
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::hasAutoUnit() const
{
	const CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->ReadyToAuto())
		{
			return true;
		}
	}

	return false;
}

//	----------------------------------------------------------------------------
bool CvPlayer::hasBusyUnit() const
{
	const CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->IsBusy())
		{
			return true;
		}
	}

	return false;
}

//	----------------------------------------------------------------------------
bool CvPlayer::hasBusyCity() const
{
	const CvCity* pLoopCity;
	int iLoop;

	for(pLoopCity = firstCity(&iLoop); pLoopCity; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity->IsBusy())
		{
			return true;
		}
	}

	return false;
}

//	----------------------------------------------------------------------------
const CvCity* CvPlayer::getBusyCity() const
{
	const CvCity* pLoopCity;
	int iLoop;

	for(pLoopCity = firstCity(&iLoop); pLoopCity; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity->IsBusy())
		{
			return pLoopCity;
		}
	}

	return false;
}

//	----------------------------------------------------------------------------
bool CvPlayer::hasBusyUnitOrCity() const
{
	if(hasBusyUnit())
		return true;
	return hasBusyCity();
}

//	--------------------------------------------------------------------------------
const UnitHandle CvPlayer::getBusyUnit() const
{
	const UnitHandle result;
	const CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->IsBusy())
		{
			result = pLoopUnit;
		}
	}
	return result;
}


//	--------------------------------------------------------------------------------
void CvPlayer::chooseTech(int iDiscover, const char* strText, TechTypes iTechJustDiscovered)
{
	if(GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))
	{
		return;
	}

	if(iDiscover > 0)
	{
		SetNumFreeTechs(GetNumFreeTechs()+iDiscover);
	}

	if(iDiscover > 0)
	{
		CvNotifications* pNotifications = GetNotifications();
		if(pNotifications)
		{
			pNotifications->Add(NOTIFICATION_FREE_TECH, strText, strText, -1, -1, iDiscover, iTechJustDiscovered);
		}
	}
	else if(strText == 0 || strText[0] == 0)
	{
		CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_NEW_RESEARCH");
		CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_NEW_RESEARCH");
		CvNotifications* pNotifications = GetNotifications();
		if(pNotifications)
		{
			pNotifications->Add(NOTIFICATION_TECH, strBuffer, strSummary, -1, -1, iDiscover, iTechJustDiscovered);
		}
	}
	else
	{
		CvNotifications* pNotifications = GetNotifications();
		if(pNotifications)
		{
			pNotifications->Add(NOTIFICATION_TECH, strText, strText, -1, -1, iDiscover, iTechJustDiscovered);
		}
	}
}

//////////////////////////////////////////////////////////////////////////
// Civ 5 Score
//////////////////////////////////////////////////////////////////////////

//	--------------------------------------------------------------------------------
/// What is this player's score?
int CvPlayer::GetScore(bool bFinal, bool bWinner) const
{
	if(!isAlive())
		return 0;

	if(GET_TEAM(getTeam()).getNumMembers() == 0)
		return 0;

	int iScore = 0;

	iScore += GetScoreFromCities();
	iScore += GetScoreFromPopulation();
	iScore += GetScoreFromLand();
	iScore += GetScoreFromWonders();
	iScore += GetScoreFromPolicies();
	iScore += GetScoreFromGreatWorks();
	iScore += GetScoreFromReligion();
	iScore += GetScoreFromTechs();
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (MOD_DIPLOMACY_CIV4_FEATURES) {
		iScore += GetScoreFromVassals();
	}
#endif
#if defined(MOD_BALANCE_CORE)
	iScore += GetScoreFromMinorAllies();
	iScore += GetScoreFromMilitarySize();
#endif
	iScore += GetScoreFromFutureTech();
	iScore += GetScoreFromScenario1();
	iScore += GetScoreFromScenario2();
	iScore += GetScoreFromScenario3();
	iScore += GetScoreFromScenario4();

	// If the game is over, we apply a mod to the value, rewarding players who finish early
	if(bFinal && bWinner)
	{
		int iGameProgressPercent = 100 * GC.getGame().getGameTurn() / GC.getGame().getEstimateEndTurn();
		iGameProgressPercent = iGameProgressPercent < 1 ? 1 : iGameProgressPercent;
		iScore *= 100;
		iScore /= iGameProgressPercent;
	}

	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from Cities: 10 per city (with mod for map size)
int CvPlayer::GetScoreFromCities() const
{
	int iScore = getNumCities() * /*10*/ GC.getSCORE_CITY_MULTIPLIER();

	iScore *= GC.getGame().GetMapScoreMod();
	iScore /= 100;

	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from Population: 6 per pop (with mod for map size)
int CvPlayer::GetScoreFromPopulation() const
{
	int iScore = getTotalPopulation() * /*4*/ GC.getSCORE_POPULATION_MULTIPLIER();

	iScore *= GC.getGame().GetMapScoreMod();
	iScore /= 100;

	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from Land: 6 per plot (with mod for map size)
int CvPlayer::GetScoreFromLand() const
{
	int iScore = getTotalLand() * /*1*/ GC.getSCORE_LAND_MULTIPLIER();

	iScore *= GC.getGame().GetMapScoreMod();
	iScore /= 100;

	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from world wonders
int CvPlayer::GetScoreFromWonders() const
{
	int iScore = GetNumWonders() * /*25*/ GC.getSCORE_WONDER_MULTIPLIER();
	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from policies
int CvPlayer::GetScoreFromPolicies() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_POLICIES))
	{
		return 0;
	}
#if defined(MOD_BUGFIX_DUMMY_POLICIES)
	int iScore = GetPlayerPolicies()->GetNumPoliciesOwned(MOD_BUGFIX_DUMMY_POLICIES) * /*4*/ GC.getSCORE_POLICY_MULTIPLIER();
#else
	int iScore = GetPlayerPolicies()->GetNumPoliciesOwned() * /*4*/ GC.getSCORE_POLICY_MULTIPLIER();
#endif
	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from world wonders: 40 per
int CvPlayer::GetScoreFromGreatWorks() const
{
	int iScore = GetCulture()->GetNumGreatWorks() * /*4*/ GC.getSCORE_GREAT_WORK_MULTIPLIER();
	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from world wonders: 40 per
int CvPlayer::GetScoreFromReligion() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_RELIGION))
	{
		return 0;
	}
	int iScore = 0;
	CvGameReligions *pGameReligions = GC.getGame().GetGameReligions();
	ReligionTypes eReligion = GetReligions()->GetReligionCreatedByPlayer();
	if (eReligion > RELIGION_PANTHEON)
	{
		const CvReligion *pReligion = pGameReligions->GetReligion(eReligion, GetID());
		iScore += pReligion->m_Beliefs.GetNumBeliefs() * /*20*/ GC.getSCORE_BELIEF_MULTIPLIER();
		iScore += pGameReligions->GetNumCitiesFollowing(eReligion) * /*1*/ GC.getSCORE_RELIGION_CITIES_MULTIPLIER();
	}
	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from Tech: 4 per
int CvPlayer::GetScoreFromTechs() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))
	{
		return 0;
	}

	// Normally we recompute it each time
	int iScore = GET_TEAM(getTeam()).GetTeamTechs()->GetNumTechsKnown() * /*4*/ GC.getSCORE_TECH_MULTIPLIER();
	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from Future Tech: 10 per
int CvPlayer::GetScoreFromFutureTech() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))
	{
		return 0;
	}

	return m_iScoreFromFutureTech;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeScoreFromFutureTech(int iChange)
{
	if(iChange != 0)
		m_iScoreFromFutureTech += iChange;
}

//	--------------------------------------------------------------------------------
// Score from scenario-specific items
int CvPlayer::GetScoreFromScenario1() const
{
	return m_iScenarioScore1;
}
void CvPlayer::ChangeScoreFromScenario1(int iChange)
{
	if(iChange != 0)
		m_iScenarioScore1 += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetScoreFromScenario2() const
{
	return m_iScenarioScore2;
}
void CvPlayer::ChangeScoreFromScenario2(int iChange)
{
	if(iChange != 0)
		m_iScenarioScore2 += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetScoreFromScenario3() const
{
	return m_iScenarioScore3;
}
void CvPlayer::ChangeScoreFromScenario3(int iChange)
{
	if(iChange != 0)
		m_iScenarioScore3 += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetScoreFromScenario4() const
{
	return m_iScenarioScore4;
}
void CvPlayer::ChangeScoreFromScenario4(int iChange)
{
	if(iChange != 0)
		m_iScenarioScore4 += iChange;
}

//////////////////////////////////////////////////////////////////////////
// End Civ 5 Score
//////////////////////////////////////////////////////////////////////////

//	--------------------------------------------------------------------------------
#if defined(MOD_BALANCE_CORE)
int CvPlayer::countCityFeatures(FeatureTypes eFeature, bool bReset) const
#else
int CvPlayer::countCityFeatures(FeatureTypes eFeature) const
#endif
{
	int iCount = 0;
#if defined(MOD_BALANCE_CORE)
	if(bReset)
	{
#endif
	const CvCity* pLoopCity;
	const CvPlot* pLoopPlot;
	int iLoop;
	int iI;

	iCount = 0;

	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{

		for(iI = 0; iI < pLoopCity->GetNumWorkablePlots(); iI++)
		{
			pLoopPlot = iterateRingPlots(pLoopCity->getX(), pLoopCity->getY(), iI);

			if(pLoopPlot != NULL)
			{
				if(pLoopPlot->getFeatureType() == eFeature)
				{
					iCount++;
				}
			}
		}
	}
#if defined(MOD_BALANCE_CORE)
		GET_PLAYER(GetID()).setCityFeatures(eFeature, iCount);
		return 0;
	}
	else
	{
		return getCityFeatures(eFeature);
	}
#endif
}


//	--------------------------------------------------------------------------------
#if defined(MOD_BALANCE_CORE)
int CvPlayer::countNumBuildings(BuildingTypes eBuilding, bool bReset) const
#else
int CvPlayer::countNumBuildings(BuildingTypes eBuilding) const
#endif
{
	int iCount = 0;
#if defined(MOD_BALANCE_CORE)
	if(bReset)
	{
#endif
	const CvCity* pLoopCity;
	
	int iLoop;

	iCount = 0;

	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
		{
			iCount += pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding);
		}
	}
#if defined(MOD_BALANCE_CORE)
		GET_PLAYER(GetID()).setNumBuildings(eBuilding, iCount);
		return 0;
	}
	else
	{
		return getNumBuildings(eBuilding);
	}
#endif
}

//	--------------------------------------------------------------------------------
/// How many cities in the empire surrounded by features?
#if defined(MOD_BALANCE_CORE)
int CvPlayer::countCitiesFeatureSurrounded(bool bReset) const
#else
int CvPlayer::countCitiesFeatureSurrounded() const
#endif
{
	int iCount = 0;
#if defined(MOD_BALANCE_CORE)
	if(bReset)
	{
#endif
	const CvCity* pLoopCity;
	
	int iLoop;

	iCount = 0;

	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity->IsFeatureSurrounded())
			iCount ++;
	}
#if defined(MOD_BALANCE_CORE)
		GET_PLAYER(GetID()).setCitiesFeatureSurrounded(iCount);
		return 0;
	}
	else
	{
		return getCitiesFeatureSurrounded();
	}
#endif
}
#if defined(MOD_BALANCE_CORE)
void CvPlayer::setCityFeatures(FeatureTypes eFeature, int iValue)
{
	CvAssertMsg(eFeature >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFeature < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	
	m_piCityFeatures[eFeature] = iValue;
}
int CvPlayer::getCityFeatures(FeatureTypes eFeature) const
{
	CvAssertMsg(eFeature >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFeature < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	return m_piCityFeatures[eFeature];
}
void CvPlayer::setNumBuildings(BuildingTypes eBuilding, int iValue)
{
	CvAssertMsg(eFeature >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFeature < GC.getNumBuildingInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");

	m_piNumBuildings[eBuilding] = iValue;
}
int CvPlayer::getNumBuildings(BuildingTypes eBuilding) const
{
	CvAssertMsg(eBuilding >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eBuilding < GC.getNumBuildingInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	return m_piNumBuildings[eBuilding];
}
void CvPlayer::setCitiesFeatureSurrounded(int iValue)
{
	m_iCitiesFeatureSurrounded = iValue;
}
int CvPlayer::getCitiesFeatureSurrounded() const
{
	return m_iCitiesFeatureSurrounded;
}
#endif

//	--------------------------------------------------------------------------------
bool CvPlayer::IsCityConnectedToCity(CvCity* pCity1, CvCity* pCity2, RouteTypes eRestrictRoute, bool bIgnoreHarbors, SPath* pPathOut)
{
	return IsPlotConnectedToPlot(m_eID, pCity1->plot(), pCity2->plot(), eRestrictRoute, bIgnoreHarbors, pPathOut);
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsCapitalConnectedToPlayer(PlayerTypes ePlayer, RouteTypes eRestrictRoute)
{
	// everybody needs to be alive!
	if(!isAlive() || !(GET_PLAYER(ePlayer).isAlive()))
	{
		return false;
	}

	CvCity* pOtherPlayerCapital = GET_PLAYER(ePlayer).getCapitalCity();
	if(pOtherPlayerCapital == NULL)
	{
		return false;
	}

	return IsCapitalConnectedToCity(pOtherPlayerCapital, eRestrictRoute);
}


#if defined(MOD_API_EXTENSIONS)
//	---------------------------------------------------------------------------
bool CvPlayer::IsCapitalConnectedToCity(CvCity* pCity, RouteTypes eRestrictRoute)
{
	if (!pCity || eRestrictRoute==NO_ROUTE)
		return false;

	if(pCity->isCapital())
	{
		return true;
	}

	CvCity* pPlayerCapital = getCapitalCity();
	if(pPlayerCapital == NULL)
	{
		return false;
	}

	//todo: unify this with CvCityConnections!

	//did we already check it this turn?
	std::map<int,std::pair<int,bool>>::iterator lastState = m_capitalConnectionLookup[eRestrictRoute].find(pCity->GetID());
	if (lastState!=m_capitalConnectionLookup[eRestrictRoute].end() && lastState->second.first==GC.getGame().getGameTurn())
		return lastState->second.second;

	//do the actual pathfinding only once per turn
	bool bResult = IsPlotConnectedToPlot(GetID(), pPlayerCapital->plot(), pCity->plot(), eRestrictRoute);

	m_capitalConnectionLookup[eRestrictRoute][pCity->GetID()] = std::make_pair(GC.getGame().getGameTurn(), bResult);
	return bResult;
}

#else
//	---------------------------------------------------------------------------
bool CvPlayer::IsCapitalConnectedToCity(CvCity* pCity, RouteTypes eRestrictRoute)
{
	CvCity* pPlayerCapital = getCapitalCity();
	if(pPlayerCapital == NULL)
	{
		return false;
	}

	return IsCityConnectedToCity(pPlayerCapital, pCity, eRestrictRoute);
}
#endif

//	--------------------------------------------------------------------------------
void CvPlayer::findNewCapital()
{
	CvCity* pOldCapital;
	CvCity* pLoopCity;
	CvCity* pBestCity;
	BuildingTypes eCapitalBuilding;
	int iValue;
	int iBestValue;
	int iLoop;

	eCapitalBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(GC.getCAPITAL_BUILDINGCLASS())));

	if(eCapitalBuilding == NO_BUILDING)
	{
		return;
	}

	pOldCapital = getCapitalCity();

	iBestValue = 0;
	pBestCity = NULL;

	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != pOldCapital)
		{
			if(0 == pLoopCity->GetCityBuildings()->GetNumRealBuilding(eCapitalBuilding))
			{
#if defined(MOD_BUGFIX_NO_PUPPET_CAPITALS)
				// First pass, exclude cities in resistance, puppets, and those burning to the ground
				if (!(pLoopCity->IsResistance() || pLoopCity->IsPuppet() || pLoopCity->IsRazing()))
				{
#endif
					iValue = (pLoopCity->getPopulation() * 4);

					int iYieldValueTimes100 = pLoopCity->getYieldRateTimes100(YIELD_FOOD, false);
					iYieldValueTimes100 += (pLoopCity->getYieldRateTimes100(YIELD_PRODUCTION, false) * 3);
					iYieldValueTimes100 += (pLoopCity->getYieldRateTimes100(YIELD_GOLD, false) * 2);
					iValue += (iYieldValueTimes100 / 100);

					iValue += (pLoopCity->getNumGreatPeople() * 2);

					if (iValue > iBestValue)
					{
						iBestValue = iValue;
						pBestCity = pLoopCity;
					}
#if defined(MOD_BUGFIX_NO_PUPPET_CAPITALS)
				}
#endif
			}
		}
	}

#if defined(MOD_BUGFIX_NO_PUPPET_CAPITALS)
	if (pBestCity != NULL)
	{
		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if (pLoopCity != pOldCapital)
			{
				if (0 == pLoopCity->GetCityBuildings()->GetNumRealBuilding(eCapitalBuilding))
				{
					// Second pass, consider only those we ignored first time
					if (pLoopCity->IsResistance())
					{
						// We'll take a city in resistance (ie one we have decided to assimilate) over all others
						iValue = pLoopCity->getPopulation() + 500;
					}
					else if (pLoopCity->IsPuppet())
					{
						// We'll take a puppet city next, at least we're not burning it to the ground!
						iValue = pLoopCity->getPopulation() + 250;
					}
					else if (pLoopCity->IsRazing())
					{
						// Might be an idea to stop the burning!
						iValue = pLoopCity->getPopulation();
					}
					else
					{
						iValue = iBestValue;
					}

					if (iValue > iBestValue)
					{
						iBestValue = iValue;
						pBestCity = pLoopCity;
					}
				}
			}
		}
	}
#endif

	if (pBestCity != NULL)
	{
		if (pOldCapital != NULL)
		{
			pOldCapital->GetCityBuildings()->SetNumRealBuilding(eCapitalBuilding, 0);
		}
		CvAssertMsg(!(pBestCity->GetCityBuildings()->GetNumRealBuilding(eCapitalBuilding)), "(pBestCity->getNumRealBuilding(eCapitalBuilding)) did not return false as expected");
		pBestCity->GetCityBuildings()->SetNumRealBuilding(eCapitalBuilding, 1);

#if defined(MOD_EVENTS_CITY_CAPITAL)
		if (MOD_EVENTS_CITY_CAPITAL) {
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_CapitalChanged, GetID(), pBestCity->GetID(), (pOldCapital ? pOldCapital->GetID() : -1));
		}
#endif

#if defined(MOD_BUGFIX_NO_PUPPET_CAPITALS)
		if (pBestCity->IsPuppet())
		{
			gDLL->sendDoTask(pBestCity->GetID(), TASK_ANNEX_PUPPET, -1, -1, false, false, false, false);
		}
		else if (pBestCity->IsRazing() && !isHuman())
		{
			// For the AI, we'll stop burining our new capital!
			gDLL->sendDoTask(pBestCity->GetID(), TASK_UNRAZE, -1, -1, false, false, false, false);
		}
#endif

#if defined(MOD_GLOBAL_NO_CONQUERED_SPACESHIPS)
		if (MOD_GLOBAL_NO_CONQUERED_SPACESHIPS && !isMinorCiv() && !isBarbarian()) {
			// Rebuild the spaceship launch pad
			CvTeam& thisTeam = GET_TEAM(getTeam());

			if (thisTeam.getProjectCount((ProjectTypes)GC.getSPACE_RACE_TRIGGER_PROJECT()) == 1) {
				if (isAlive()) {
					CUSTOMLOG("Rebuilding launch pad at (%i, %i)", pBestCity->getX(), pBestCity->getY());
					auto_ptr<ICvPlot1> pDllPlot(new CvDllPlot(pBestCity->plot()));
					gDLL->GameplaySpaceshipEdited(pDllPlot.get(), 0x0001); // Display just the launch pad
				}
			}
		}
#endif
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canRaze(CvCity* pCity, bool bIgnoreCapitals) const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_CITY_RAZING))
	{
		return false;
	}

	// If we don't own this city right now then we can't raze it!
	if(pCity->getOwner() != GetID())
	{
		return false;
	}

	// Can't raze a city that originally belonged to us
	if(pCity->getOriginalOwner() == GetID())
	{
		return false;
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(pCity->getOwner());
		args->Push(pCity->GetID());

		bool bResult = false;
		if(LuaSupport::CallTestAll(pkScriptSystem, "CanRazeOverride", args.get(), bResult))
		{
			// Check the result.
			if(bResult == true)
			{
				return true;
			}
		}
	}

#if defined(MOD_EVENTS_CITY_RAZING)
	if (MOD_EVENTS_CITY_RAZING) {
		// Note the subtle difference between CanRazeOverride and PlayerCanRaze, the former needs everyone to agree, the latter anyone
		if (GAMEEVENTINVOKE_TESTANY(GAMEEVENT_PlayerCanRaze, pCity->getOwner(), pCity->GetID()) == GAMEEVENTRETURN_TRUE) {
			return true;
		}
	}
#endif

	// No razing of capitals
	CvPlayer* pOriginalOwner = &GET_PLAYER(pCity->getOriginalOwner());
	bool bOriginalCapital =	pCity->getX() == pOriginalOwner->GetOriginalCapitalX() &&
	                        pCity->getY() == pOriginalOwner->GetOriginalCapitalY();

	if(!bIgnoreCapitals && pCity->IsEverCapital() && bOriginalCapital)
	{
		return false;
	}

	// No razing of Holy Cities
	if (pCity->GetCityReligions()->IsHolyCityAnyReligion())
	{
		return false;
	}

	// No razing of cities with unique luxuries
	ResourceTypes eResource = pCity->plot()->getResourceType();
	if (eResource != NO_RESOURCE)
	{
		CvResourceInfo *pkResource = GC.getResourceInfo(eResource);
		if (pkResource && pkResource->GetRequiredCivilization() != NO_CIVILIZATION)
		{
			return false;
		}
	}

	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(pCity->getOwner());
		args->Push(pCity->GetID());

		bool bResult = false;
		if(LuaSupport::CallTestAll(pkScriptSystem, "CanRaze", args.get(), bResult))
		{
			// Check the result.
			if(bResult == false)
			{
				return false;
			}
		}
	}

	return true;
}


//	--------------------------------------------------------------------------------
void CvPlayer::raze(CvCity* pCity)
{
	char szBuffer[1024];
	const size_t lenBuffer = 1024;
	int iI;

	if(!canRaze(pCity))
	{
		return;
	}

	CvAssert(pCity->getOwner() == GetID());

	if(GetID() == GC.getGame().getActivePlayer())
	{
		sprintf_s(szBuffer, lenBuffer, GetLocalizedText("TXT_KEY_MISC_DESTROYED_CITY", pCity->getNameKey()).GetCString());
		GC.GetEngineUserInterface()->AddCityMessage(0, pCity->GetIDInfo(), GetID(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer/*, "AS2D_CITYRAZE", MESSAGE_TYPE_MAJOR_EVENT, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pCity->getX(), pCity->getY(), true, true*/);

	}

	for(iI = 0; iI < MAX_PLAYERS; iI++)
	{
		if(GET_PLAYER((PlayerTypes)iI).isAlive())
		{
			if(iI != GetID() && iI == GC.getGame().getActivePlayer())
			{
				if(pCity->isRevealed(GET_PLAYER((PlayerTypes)iI).getTeam(), false))
				{
					sprintf_s(szBuffer, lenBuffer, GetLocalizedText("TXT_KEY_MISC_CITY_HAS_BEEN_RAZED_BY", pCity->getNameKey(), getCivilizationDescriptionKey()).GetCString());
					GC.GetEngineUserInterface()->AddCityMessage(0, pCity->GetIDInfo(), ((PlayerTypes)iI), false, GC.getEVENT_MESSAGE_TIME(), szBuffer/*, "AS2D_CITYRAZED", MESSAGE_TYPE_MAJOR_EVENT, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pCity->getX(), pCity->getY(), true, true*/);
				}
			}
		}
	}

	sprintf_s(szBuffer, lenBuffer, GetLocalizedText("TXT_KEY_MISC_CITY_RAZED_BY", pCity->getNameKey(), getCivilizationShortDescriptionKey()).GetCString());
	GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, GetID(), szBuffer, pCity->getX(), pCity->getY());

	pCity->SetIgnoreCityForHappiness(false);

	CalculateNetHappiness();

#if defined(MOD_BALANCE_CORE)
	if(pCity->IsNoWarmongerYet())
	{
		PlayerTypes eFormerOwner = pCity->getPreviousOwner();
		if(eFormerOwner != NO_PLAYER)
		{
			CvDiplomacyAIHelpers::ApplyWarmongerPenalties(GetID(), eFormerOwner, pCity->IsOriginalMajorCapital(), pCity);
			pCity->SetNoWarmonger(false);
		}
	}
#endif
	int iPopulationDrop = 1;
	iPopulationDrop *= (100 + GetPlayerTraits()->GetRazeSpeedModifier());
	iPopulationDrop /= 100;
#if defined(MOD_BALANCE_CORE)
	iPopulationDrop *= (100 + GetRazingSpeedBonus());
	iPopulationDrop /= 100;
#endif
	int iTurnsToRaze = pCity->getPopulation();
	if(iPopulationDrop > 0)
	{
		iTurnsToRaze = (iTurnsToRaze + iPopulationDrop - 1) / iPopulationDrop;
	}

	pCity->ChangeRazingTurns(iTurnsToRaze);

	DoUpdateNextPolicyCost();

	// Update City UI
	if(GetID() == GC.getGame().getActivePlayer())
	{
		GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::unraze(CvCity* pCity)
{
	if (GetPlayerTraits()->IsNoAnnexing())
	{
		pCity->DoCreatePuppet();
	}
	else
	{
		pCity->DoAnnex();
	}

	pCity->ChangeRazingTurns(-pCity->GetRazingTurns());

	DoUpdateNextPolicyCost();

	// Update City UI
	if(GetID() == GC.getGame().getActivePlayer())
	{
		GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
	}
}



//	--------------------------------------------------------------------------------
void CvPlayer::disband(CvCity* pCity)
{
	CvPlot* pPlot = pCity->plot();

	if(getNumCities() == 1)
	{
		setFoundedFirstCity(false);
	}

	GC.getGame().addDestroyedCityName(pCity->getNameKey());

	for(int eBuildingType = 0; eBuildingType < GC.getNumBuildingInfos(); eBuildingType++)
	{
		CvBuildingEntry* buildingInfo = GC.getBuildingInfo((BuildingTypes) eBuildingType);
		if(buildingInfo)
		{
			// if this building exists
			int iExists = pCity->GetCityBuildings()->GetNumRealBuilding((BuildingTypes) eBuildingType);
			int iPreferredPosition = buildingInfo->GetPreferredDisplayPosition();
			if(iPreferredPosition > 0)
			{
				auto_ptr<ICvCity1> pDllCity(new CvDllCity(pCity));

				if(iExists > 0)
				{
					// kill the wonder
					GC.GetEngineUserInterface()->AddDeferredWonderCommand(WONDER_REMOVED, pDllCity.get(), (BuildingTypes) eBuildingType, 0);
				}
				else
				{
					// else if we are currently in the process of building this wonder
					if(pCity->getProductionBuilding() == eBuildingType)
					{
						// kill the half built wonder
						if(isWorldWonderClass(buildingInfo->GetBuildingClassInfo()))
						{
							GC.GetEngineUserInterface()->AddDeferredWonderCommand(WONDER_REMOVED, pDllCity.get(), (BuildingTypes) eBuildingType, 0);
						}
					}
				}
			}
		}
	}

	{
		auto_ptr<ICvCity1> pkDllCity(new CvDllCity(pCity));
		gDLL->GameplayCitySetDamage(pkDllCity.get(), 0, pCity->getDamage());
		gDLL->GameplayCityDestroyed(pkDllCity.get(), NO_PLAYER);
	}

	pCity->kill();

	if(pPlot)
	{
		IDInfoVector currentUnits;
		if (pPlot->getUnits(&currentUnits) > 0)
		{
			for (IDInfoVector::const_iterator itr = currentUnits.begin(); itr != currentUnits.end(); ++itr)
			{
				CvUnit* pUnit = ::getUnit(*itr);

				if(pUnit && !pPlot->isValidDomainForLocation(*pUnit))
				{
					if (!pUnit->jumpToNearestValidPlot())
						pUnit->kill(false);
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Is a Particular Goody ID a valid Goody for a certain plot?
bool CvPlayer::canReceiveGoody(CvPlot* pPlot, GoodyTypes eGoody, CvUnit* pUnit) const
{
	CvCity* pCity;
	UnitTypes eUnit;
	bool bTechFound;
	int iI;

	Database::SingleResult kResult;
	CvGoodyInfo kGoodyInfo;
	const bool bResult = DB.SelectAt(kResult, "GoodyHuts", eGoody);
	DEBUG_VARIABLE(bResult);
	CvAssertMsg(bResult, "Cannot find goody info.");
	kGoodyInfo.CacheResult(kResult);

#if defined(MOD_EVENTS_GOODY_CHOICE)
	if (MOD_EVENTS_GOODY_CHOICE) {
		bool bPick = (pUnit && pUnit->isHasPromotion((PromotionTypes)GC.getPROMOTION_GOODY_HUT_PICKER()));
		int iUnit = pUnit ? pUnit->GetID() : -1;
		if (GAMEEVENTINVOKE_TESTANY(GAMEEVENT_GoodyHutCanNotReceive, GetID(), iUnit, eGoody, bPick) == GAMEEVENTRETURN_TRUE) {
			return false;
		}
	}
#endif

	if(!CvGoodyHuts::IsCanPlayerReceiveGoody(GetID(), eGoody))
	{
		return false;
	}

	// No XP in first 10 turns
	if(kGoodyInfo.getExperience() > 0)
	{
		if((pUnit == NULL) || !(pUnit->canAcquirePromotionAny()) || (GC.getGame().getElapsedGameTurns() < 10))
		{
			return false;
		}
	}

	// Unit Healing
	if(kGoodyInfo.getDamagePrereq() > 0)
	{
		if((pUnit == NULL) || (pUnit->getDamage() < ((pUnit->GetMaxHitPoints() * kGoodyInfo.getDamagePrereq()) / 100)))
		{
			return false;
		}
	}

	// Early pantheon
	if(kGoodyInfo.isPantheonFaith())
	{
		if(GC.getGame().getElapsedGameTurns() < 20)
		{
			return false;
		}
		else
		{
			return (!GetReligions()->HasCreatedPantheon() && !GetReligions()->HasCreatedReligion());
		}
	}

	// Faith toward Great Prophet
	if(kGoodyInfo.getProphetPercent() > 0)
	{
		if(GC.getGame().getElapsedGameTurns() < 20)
		{
			return false;
		}
		else
		{
			return (GetReligions()->HasCreatedPantheon() && !GetReligions()->HasCreatedReligion());
		}
	}

	// Population
	if(kGoodyInfo.getPopulation() > 0)
	{
		if(getNumCities() == 0)
		{
			return false;
		}

		// Don't give more Population if we're already over our Pop limit
		if(IsEmpireUnhappy())
		{
			return false;
		}
	}
#if defined(MOD_BALANCE_CORE)
	//Golden Age
	if(kGoodyInfo.getGoldenAge() > 0)
	{
		if(GetNumGoldenAges() <= 0)
		{
			return false;
		}
	}
	//Free Tiles
	if(kGoodyInfo.getFreeTiles() > 0 && pPlot != NULL)
	{
		int iDistance;
		int iBestCityDistance = -1;
		CvCity* pBestCity = NULL;

		CvCity* pLoopCity;
		int iLoop;
		// Find the closest City to us to add a Pop point to
		for(pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
		{
			iDistance = plotDistance(pPlot->getX(), pPlot->getY(), pLoopCity->getX(), pLoopCity->getY());

			if(iBestCityDistance == -1 || iDistance < iBestCityDistance)
			{
				iBestCityDistance = iDistance;
				pBestCity = pLoopCity;
			}
		}

		if(pBestCity == NULL)
		{
			return false;
		}
	}
	if(pPlot == NULL && kGoodyInfo.getMapRange() > 0 && kGoodyInfo.getMapOffset() > 0)
	{
		return false;
	}
	if(pPlot != NULL && kGoodyInfo.getMapRange() > 0 && kGoodyInfo.getMapOffset() > 0)
	{
		bool bGood = false;
		int iOffset = kGoodyInfo.getMapOffset();
		int iDX, iDY;
		for(iDX = -(iOffset); iDX <= iOffset; iDX++)
		{
			for(iDY = -(iOffset); iDY <= iOffset; iDY++)
			{
				CvPlot* pLoopPlot = plotXYWithRangeCheck(pPlot->getX(), pPlot->getY(), iDX, iDY, iOffset);

				if(pLoopPlot != NULL)
				{
					if(!(pLoopPlot->isRevealed(getTeam())))
					{
						if(pLoopPlot->isCity() && pLoopPlot->getOwner() != GetID() && pLoopPlot->getOwner() != NO_PLAYER)
						{
							bGood = true;
							break;
						}
					}
				}
			}
		}
		if(!bGood)
		{
			return false;
		}
	}
#endif

	// Reveal Nearby Barbs
	if(kGoodyInfo.getRevealNearbyBarbariansRange() > 0)
	{
		int iDX, iDY;
		int iBarbCampDistance = kGoodyInfo.getRevealNearbyBarbariansRange();
		CvPlot* pNearbyPlot;

		int iNumCampsFound = 0;

		ImprovementTypes barbCampType = (ImprovementTypes) GC.getBARBARIAN_CAMP_IMPROVEMENT();

		// Look at nearby Plots to make sure another camp isn't too close
		for(iDX = -(iBarbCampDistance); iDX <= iBarbCampDistance; iDX++)
		{
			for(iDY = -(iBarbCampDistance); iDY <= iBarbCampDistance; iDY++)
			{
				pNearbyPlot = plotXY(pPlot->getX(), pPlot->getY(), iDX, iDY);

				if(pNearbyPlot != NULL)
				{
					if(plotDistance(pNearbyPlot->getX(), pNearbyPlot->getY(), pPlot->getX(), pPlot->getY()) <= iBarbCampDistance)
					{
						if(pNearbyPlot->getImprovementType() == barbCampType)
						{
							iNumCampsFound++;
						}
					}
				}
			}
		}

		// Needs to be at least 2 nearby Camps
		if(iNumCampsFound < 2)
		{
			return false;
		}
	}

	// Reveal Unknown Resource
	if(kGoodyInfo.isRevealUnknownResource())
	{
		// Can't get this if you have no Capital City
		if(getCapitalCity() == NULL)
		{
			return false;
		}

		CvResourceInfo* pResource;
		ResourceClassTypes eResourceClassBonus = (ResourceClassTypes) GC.getInfoTypeForString("RESOURCECLASS_BONUS");

		bool bPlayerDoesntKnowOfResource = false;

		int iNumResourceInfos = GC.getNumResourceInfos();
		for(int iResourceLoop = 0; iResourceLoop < iNumResourceInfos; iResourceLoop++)
		{
			pResource = GC.getResourceInfo((ResourceTypes) iResourceLoop);

			// No "Bonus" Resources (that only give Yield), because those are lame to get from a Hut
			if(pResource != NULL && pResource->getResourceClassType() != eResourceClassBonus)
			{
				if(!GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes) pResource->getTechReveal()))
				{
					bPlayerDoesntKnowOfResource = true;
				}
			}
		}

		// If the player already knows where all the Resources are then there's no point in this Goody
		if(!bPlayerDoesntKnowOfResource)
		{
			return false;
		}
	}

	// Unit Upgrade
	if(kGoodyInfo.isUpgradeUnit())
	{
		if(pUnit == NULL)
		{
			return false;
		}

		if(pUnit->IsHasBeenPromotedFromGoody())
		{
			return false;
		}

		UnitClassTypes eUpgradeUnitClass = (UnitClassTypes) GC.getUnitInfo(pUnit->getUnitType())->GetGoodyHutUpgradeUnitClass();

		if(eUpgradeUnitClass == NO_UNITCLASS)
		{
			return false;
		}

		UnitTypes eUpgradeUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eUpgradeUnitClass);

		if(eUpgradeUnit == NO_UNIT)
		{
			return false;
		}
	}

	// Tech
	if(kGoodyInfo.isTech())
	{
		bTechFound = false;

		int iNumTechInfos = GC.getNumTechInfos();
		for(iI = 0; iI < iNumTechInfos; iI++)
		{
			const TechTypes eTech = static_cast<TechTypes>(iI);
			CvTechEntry* pkTech = GC.getTechInfo(eTech);
			if(pkTech != NULL && pkTech->IsGoodyTech())
			{
				if(GetPlayerTechs()->CanResearch(eTech))
				{
#if defined(MOD_BALANCE_CORE)
					if(MOD_BALANCE_CORE && GetPlayerTechs()->GetCurrentResearch() != eTech)
					{
#endif
					bool bUseTech = true;
					ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
					if (pkScriptSystem) 
					{
						CvLuaArgsHandle args;
						args->Push(GetID());
						args->Push(eTech);

						// Attempt to execute the game events.
						// Will return false if there are no registered listeners.
						bool bScriptResult = false;
						if (LuaSupport::CallTestAll(pkScriptSystem, "GoodyHutCanResearch", args.get(), bScriptResult)) 
						{
							bUseTech = bResult;
						}
					}

					if(bUseTech)
					{
						bTechFound = true;
					}
					break;
#if defined(MOD_BALANCE_CORE)
					}
#endif
				}
			}
		}

		if(!bTechFound)
		{
			return false;
		}
	}

	///////////////////////////////////////
	///////////////////////////////////////
	// Bad Goodies follow beneath this line
	///////////////////////////////////////
	///////////////////////////////////////

	if(kGoodyInfo.isBad())
	{
		if((pUnit == NULL) || pUnit->isNoBadGoodies())
		{
			return false;
		}
	}

	if(kGoodyInfo.getUnitClassType() != NO_UNITCLASS)
	{
		eUnit = ((UnitTypes)(getCivilizationInfo().getCivilizationUnits(kGoodyInfo.getUnitClassType())));

		if(eUnit == NO_UNIT)
		{
			return false;
		}

		CvUnitEntry* pUnitInfo = GC.getUnitInfo(eUnit);
		if(pUnitInfo == NULL)
		{
			return false;
		}

		// No combat units in MP in the first 20 turns
		if(pUnitInfo->GetCombat() > 0)
		{
			if(GC.getGame().isGameMultiPlayer() || (GC.getGame().getElapsedGameTurns() < 20))
			{
				return false;
			}
		}

		// Builders
		if(pUnitInfo->GetWorkRate() > 0)
		{
			// Max limit
			if(GetMaxNumBuilders() > -1 && GetNumBuilders() >= GetMaxNumBuilders())
			{
				return false;
			}

			bool bHasTechWhichUnlocksImprovement = false;

			// Need a tech which unlocks something to do
			int iNumTechInfos = GC.getNumTechInfos();
			int iNumBuildInfos = GC.getNumBuildInfos();
			for(int iTechLoop = 0; iTechLoop < iNumTechInfos; iTechLoop++)
			{
				if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes) iTechLoop))
				{
					// Look at Builds
					for(int iBuildLoop = 0; iBuildLoop < iNumBuildInfos; iBuildLoop++)
					{
						CvBuildInfo* pkBuildInfo = GC.getBuildInfo((BuildTypes) iBuildLoop);
						if(!pkBuildInfo)
						{
							continue;
						}
						if(pkBuildInfo->getTechPrereq() == (TechTypes) iTechLoop)
						{
							if(pkBuildInfo->getImprovement() != NO_IMPROVEMENT || pkBuildInfo->getRoute() != NO_ROUTE)
							{
								bHasTechWhichUnlocksImprovement = true;
								break;
							}
						}
					}
				}
				// Already found something
				if(bHasTechWhichUnlocksImprovement)
				{
					break;
				}
			}

			// Player doesn't have any Tech which allows Improvements
			if(!bHasTechWhichUnlocksImprovement)
			{
				return false;
			}
		}

		// OCC games - no Settlers
		if(GetPlayerTraits()->IsNoAnnexing() || (GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && isHuman()))
		{
			if(pUnitInfo->IsFound() || pUnitInfo->IsFoundAbroad())
			{
				return false;
			}
		}
	}

	// Barbarians
	if(kGoodyInfo.getBarbarianUnitClass() != NO_UNITCLASS)
	{
		if(GC.getGame().isOption(GAMEOPTION_NO_BARBARIANS))
		{
			return false;
		}

		if(getNumCities() == 0)
		{
			return false;
		}

		if(getNumCities() == 1)
		{
			pCity = GC.getMap().findCity(pPlot->getX(), pPlot->getY(), NO_PLAYER, getTeam());

			if(pCity != NULL)
			{
				if(plotDistance(pPlot->getX(), pPlot->getY(), pCity->getX(), pCity->getY()) <= (8 - getNumCities()))
				{
					return false;
				}
			}
		}
	}

	return true;
}


//	--------------------------------------------------------------------------------
void CvPlayer::receiveGoody(CvPlot* pPlot, GoodyTypes eGoody, CvUnit* pUnit)
{
	CvPlot* pLoopPlot;
	CvPlot* pBestPlot = NULL;
	CvString strBuffer;
	CvString strTempBuffer;
	TechTypes eBestTech;
	UnitTypes eUnit;
	int iGold;
	int iOffset;
	int iRange;
	int iBarbCount;
	int iValue;
	int iBestValue;
	int iPass;
	int iDX, iDY;
	int iI;

	CvAssertMsg(canReceiveGoody(pPlot, eGoody, pUnit), "Instance is expected to be able to recieve goody");

	Database::SingleResult kResult;
	CvGoodyInfo kGoodyInfo;
	const bool bResult = DB.SelectAt(kResult, "GoodyHuts", eGoody);
	DEBUG_VARIABLE(bResult);
	CvAssertMsg(bResult, "Cannot find goody info.");
	kGoodyInfo.CacheResult(kResult);

	CvGoodyHuts::DoPlayerReceivedGoody(GetID(), eGoody);

	strBuffer = kGoodyInfo.GetDescription();

	// Gold
	iGold = kGoodyInfo.getGold() + (kGoodyInfo.getNumGoldRandRolls() * GC.getGame().getJonRandNum(kGoodyInfo.getGoldRandAmount(), "Goody Gold Rand"));

	if(iGold != 0)
	{
		GetTreasury()->ChangeGold(iGold);

		strBuffer += GetLocalizedText("TXT_KEY_MISC_RECEIVED_GOLD", iGold);
	}

	// Population
	if(kGoodyInfo.getPopulation() > 0)
	{
		int iDistance;
		int iBestCityDistance = -1;
		CvCity* pBestCity = NULL;

		CvCity* pLoopCity;
		int iLoop;
		// Find the closest City to us to add a Pop point to
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			iDistance = plotDistance(pPlot->getX(), pPlot->getY(), pLoopCity->getX(), pLoopCity->getY());

			if(iBestCityDistance == -1 || iDistance < iBestCityDistance)
			{
				iBestCityDistance = iDistance;
				pBestCity = pLoopCity;
			}
		}

		if(pBestCity != NULL)
		{
			pBestCity->changePopulation(kGoodyInfo.getPopulation());
#if defined(MOD_BALANCE_CORE)
			doInstantYield(INSTANT_YIELD_TYPE_BIRTH, true, NO_GREATPERSON, NO_BUILDING, 0, true, NO_PLAYER, NULL, false, pBestCity);
#endif
		}
	}
#if defined(MOD_BALANCE_CORE)
	// Production
	if(MOD_BALANCE_CORE && kGoodyInfo.getProduction() > 0)
	{
		int iDistance;
		int iBestCityDistance = -1;
		CvCity* pBestCity = NULL;

		CvCity* pLoopCity;
		int iLoop;
		// Find the closest City to us to add a Pop point to
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			iDistance = plotDistance(pPlot->getX(), pPlot->getY(), pLoopCity->getX(), pLoopCity->getY());

			if(iBestCityDistance == -1 || iDistance < iBestCityDistance)
			{
				iBestCityDistance = iDistance;
				pBestCity = pLoopCity;
			}
		}

		if(pBestCity != NULL)
		{
			pBestCity->changeProduction(kGoodyInfo.getProduction());
		}
	}
	// Golden Age Points
	int iGoldenAge = kGoodyInfo.getGoldenAge();
	if(iGoldenAge > 0 && GetNumGoldenAges() > 0)
	{
		// Game Speed Mod
		iGoldenAge *= GC.getGame().getGameSpeedInfo().getCulturePercent();
		iGoldenAge /= 100;

		ChangeGoldenAgeProgressMeter(iGoldenAge);
	}
	//Free Tiles
	int iFreeTiles = kGoodyInfo.getFreeTiles();
	if(iFreeTiles > 0)
	{
		int iDistance;
		int iBestCityDistance = -1;
		CvCity* pBestCity = NULL;

		CvCity* pLoopCity;
		int iLoop;
		// Find the closest City to us to add a Pop point to
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			iDistance = plotDistance(pPlot->getX(), pPlot->getY(), pLoopCity->getX(), pLoopCity->getY());

			if(iBestCityDistance == -1 || iDistance < iBestCityDistance)
			{
				iBestCityDistance = iDistance;
				pBestCity = pLoopCity;
			}
		}

		if(pBestCity != NULL)
		{
			// Game Speed Mod
			iFreeTiles *= GC.getGame().getGameSpeedInfo().getCulturePercent();
			iFreeTiles /= 100;

			if(iFreeTiles > 0)
			{
				for (int i = 0; i < iFreeTiles; i++)
				{
					CvPlot* pPlotToAcquire = pBestCity->GetNextBuyablePlot(false);
					// maybe the player owns ALL of the plots or there are none available?
					if(pPlotToAcquire)
					{
						pBestCity->DoAcquirePlot(pPlotToAcquire->getX(), pPlotToAcquire->getY());
					}
				}
			}
		}
	}
#endif
	// Culture
	int iCulture = kGoodyInfo.getCulture();
	if(iCulture > 0)
	{
		// Game Speed Mod
		iCulture *= GC.getGame().getGameSpeedInfo().getCulturePercent();
		iCulture /= 100;

		changeJONSCulture(iCulture);

#if defined(MOD_BUGFIX_GOODY_HUT_MESSAGES)
		strBuffer += GetLocalizedText("TXT_KEY_MISC_RECEIVED_CULTURE", iCulture);
#endif
	}

	// Faith
	int iFaith = kGoodyInfo.getFaith();
	if(iFaith > 0)
	{
		// Game Speed Mod
		iFaith *= GC.getGame().getGameSpeedInfo().getFaithPercent();
		iFaith /= 100;

		ChangeFaith(iFaith);

#if defined(MOD_BUGFIX_GOODY_HUT_MESSAGES)
		strBuffer += GetLocalizedText("TXT_KEY_MISC_RECEIVED_FAITH", iFaith);
#endif
	}

	// Faith for pantheon
	bool bPantheon = kGoodyInfo.isPantheonFaith();
	if(bPantheon)
	{
		// Enough so still get a pantheon if 3 civs pop this in same turn
		iFaith = GC.getGame().GetGameReligions()->GetMinimumFaithNextPantheon() + 2 * GC.getRELIGION_GAME_FAITH_DELTA_NEXT_PANTHEON();
		int iDivisor = /*10*/ GC.getGOLD_PURCHASE_VISIBLE_DIVISOR();
		iFaith /= iDivisor;
		iFaith *= iDivisor;
		ChangeFaith(iFaith);

#if defined(MOD_BUGFIX_GOODY_HUT_MESSAGES)
		strBuffer += GetLocalizedText("TXT_KEY_MISC_RECEIVED_FAITH", iFaith);
#endif
	}

	// Faith for percent of great prophet
	int iProphetPercent = kGoodyInfo.getProphetPercent();
	if(iProphetPercent > 0)
	{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
		iFaith = GetReligions()->GetCostNextProphet(false /*bIncludeBeliefDiscounts*/, true /*bAdjustForSpeedDifficulty*/, MOD_GLOBAL_TRULY_FREE_GP) * iProphetPercent / 100;
#else
		iFaith = GetReligions()->GetCostNextProphet(false /*bIncludeBeliefDiscounts*/, true /*bAdjustForSpeedDifficulty*/) * iProphetPercent / 100;
#endif
		int iDivisor = /*10*/ GC.getGOLD_PURCHASE_VISIBLE_DIVISOR();
		iFaith /= iDivisor;
		iFaith *= iDivisor;
		ChangeFaith(iFaith);

#if defined(MOD_BUGFIX_GOODY_HUT_MESSAGES)
		strBuffer += GetLocalizedText("TXT_KEY_MISC_RECEIVED_FAITH", iFaith);
#endif
	}

	// Reveal Nearby Barbs
	if(kGoodyInfo.getRevealNearbyBarbariansRange() > 0)
	{
		// Look at nearby Plots to make sure another camp isn't too close
		const int iBarbCampDistance = kGoodyInfo.getRevealNearbyBarbariansRange();
		for(iDX = -(iBarbCampDistance); iDX <= iBarbCampDistance; iDX++)
		{
			for(iDY = -(iBarbCampDistance); iDY <= iBarbCampDistance; iDY++)
			{
				CvPlot* pNearbyBarbarianPlot = plotXY(pPlot->getX(), pPlot->getY(), iDX, iDY);
				if(pNearbyBarbarianPlot != NULL)
				{
					if(plotDistance(pNearbyBarbarianPlot->getX(), pNearbyBarbarianPlot->getY(), pPlot->getX(), pPlot->getY()) <= iBarbCampDistance)
					{
						if(pNearbyBarbarianPlot->getImprovementType() == GC.getBARBARIAN_CAMP_IMPROVEMENT())
						{
							// Reveal Plot
							pNearbyBarbarianPlot->setRevealed(getTeam(), true);
							// Reveal Barb Camp here
							pNearbyBarbarianPlot->setRevealedImprovementType(getTeam(), pNearbyBarbarianPlot->getImprovementType());
						}
					}
				}
			}
		}
	}

	// Map
	iRange = kGoodyInfo.getMapRange();

	if(iRange > 0)
	{
		iOffset = kGoodyInfo.getMapOffset();

		if(iOffset > 0)
		{
			iBestValue = 0;
			pBestPlot = NULL;

			int iRandLimit;

			for(iDX = -(iOffset); iDX <= iOffset; iDX++)
			{
				for(iDY = -(iOffset); iDY <= iOffset; iDY++)
				{
					pLoopPlot = plotXYWithRangeCheck(pPlot->getX(), pPlot->getY(), iDX, iDY, iOffset);

					if(pLoopPlot != NULL)
					{
						if(!(pLoopPlot->isRevealed(getTeam())))
						{
							// Avoid water plots!
#if defined(MOD_BALANCE_CORE)
							//Let's reveal cities instead.
							if(pLoopPlot->isCity() && pLoopPlot->getOwner() != GetID() && pLoopPlot->getOwner() != NO_PLAYER)
							{
								iRandLimit = 0;
								if(GET_PLAYER(pLoopPlot->getOwner()).isMajorCiv())
								{
									iRandLimit += 10000;
								}
								else if(GET_PLAYER(pLoopPlot->getOwner()).isMinorCiv())
								{
									iRandLimit += 1000;
								}

#else
							if(pPlot->isWater())
								iRandLimit = 10;
							else
								iRandLimit = 10000;
#endif
							iValue = (1 + GC.getGame().getJonRandNum(iRandLimit, "Goody Map"));

							iValue *= plotDistance(pPlot->getX(), pPlot->getY(), pLoopPlot->getX(), pLoopPlot->getY());

							if(iValue > iBestValue)
							{
								iBestValue = iValue;
								pBestPlot = pLoopPlot;
							}
#if defined(MOD_BALANCE_CORE)
							}
#endif
						}
					}
				}
			}
		}

		if(pBestPlot == NULL)
		{
			pBestPlot = pPlot;
		}

		for(iDX = -(iRange); iDX <= iRange; iDX++)
		{
			for(iDY = -(iRange); iDY <= iRange; iDY++)
			{
				pLoopPlot = plotXY(pBestPlot->getX(), pBestPlot->getY(), iDX, iDY);

				if(pLoopPlot != NULL)
				{
					if(plotDistance(pBestPlot->getX(), pBestPlot->getY(), pLoopPlot->getX(), pLoopPlot->getY()) <= iRange)
					{
						if(GC.getGame().getJonRandNum(100, "Goody Map") < kGoodyInfo.getMapProb())
						{
							pLoopPlot->setRevealed(getTeam(), true);
						}
					}
				}
			}
		}
	}

	// Experience
	if(pUnit != NULL)
	{
#if defined(MOD_UNITS_XP_TIMES_100)
		pUnit->changeExperienceTimes100(kGoodyInfo.getExperience() * 100);
#else
		pUnit->changeExperience(kGoodyInfo.getExperience());
#endif
	}

	// Unit Heal
	if(pUnit != NULL)
	{
		pUnit->changeDamage(-(kGoodyInfo.getHealing()));
	}

	// Reveal Unknown Resource
	if(kGoodyInfo.isRevealUnknownResource())
	{
		if(getCapitalCity() != NULL)
		{
			CvCity* pCapital = getCapitalCity();

			CvPlot* pResourcePlot;
			int iResourceDistance;
			TechTypes eRevealTech;
			int iResourceCost;
			int iBestResourceCost = -1;
			ResourceTypes eResource;
			ResourceTypes eBestResource = NO_RESOURCE;
			CvPlot* pBestResourcePlot = NULL;

			ResourceClassTypes eResourceClassBonus;

			// Look at Resources on all Plots
			for(int iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)
			{
				pResourcePlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);
				eResource = pResourcePlot->getResourceType();

				if(eResource != NO_RESOURCE)
				{
					CvResourceInfo& pResource = *GC.getResourceInfo(eResource);
					eResourceClassBonus = (ResourceClassTypes) GC.getInfoTypeForString("RESOURCECLASS_BONUS");

					// No "Bonus" Resources (that only give Yield), because those are lame to get from a Hut
					if(pResource.getResourceClassType() != eResourceClassBonus)
					{
						// Can't be on a Plot that we've already force-revealed!
						if(!pResourcePlot->IsResourceForceReveal(getTeam()))
						{
							// Must be a Resource we don't already see
							eRevealTech = (TechTypes) pResource.getTechReveal();
							if(!GET_TEAM(getTeam()).GetTeamTechs()->HasTech(eRevealTech))
							{
								iResourceDistance = plotDistance(pResourcePlot->getX(), pResourcePlot->getY(), pCapital->getX(), pCapital->getY());

								// Must be within 10 plots of our Capital
								if(iResourceDistance <= 10)
								{
									iResourceCost = GC.getTechInfo(eRevealTech)->GetResearchCost();

									// Find the one with the cheapest Tech (or pick one if we haven't identified one yet)
									if(iBestResourceCost == -1 || iResourceCost < iBestResourceCost)
									{
										iBestResourceCost = iResourceCost;
										eBestResource = eResource;
										pBestResourcePlot = pResourcePlot;
									}
								}
							}
						}
					}
				}
			}

			CvAssert(pBestResourcePlot);

			// Did we find something to show?
			if(pBestResourcePlot != NULL)
			{
				pBestResourcePlot->setRevealed(getTeam(), true);
				pBestResourcePlot->SetResourceForceReveal(getTeam(), true);
				//pBestPlot->updateFog();

				if(getTeam() == GC.getGame().getActiveTeam())
				{
					pBestResourcePlot->setLayoutDirty(true);
				}

				// Also reveal adjacent Plots
				CvPlot* pAdjacentPlot;
				for(int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; iDirectionLoop++)
				{
					pAdjacentPlot = plotDirection(pBestResourcePlot->getX(), pBestResourcePlot->getY(), ((DirectionTypes) iDirectionLoop));

					if(pAdjacentPlot != NULL)
					{
						pAdjacentPlot->setRevealed(getTeam(), true);
					}
				}

				CvString strTempString;
				strTempString.Format(" (%s)", GC.getResourceInfo(eBestResource)->GetDescription());
				strBuffer += strTempString;
			}
		}
	}

	// Unit Upgrade
	if(kGoodyInfo.isUpgradeUnit())
	{
		UnitClassTypes eUpgradeUnitClass = NO_UNITCLASS;
		UnitTypes eUpgradeUnit = NO_UNIT;

		if(pUnit != NULL)
		{
			eUpgradeUnitClass = (UnitClassTypes) pUnit->getUnitInfo().GetGoodyHutUpgradeUnitClass();
			eUpgradeUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eUpgradeUnitClass);
		}
		
		if(eUpgradeUnit != NO_UNIT)
		{
			// Add new upgrade Unit

			// if we promoted an scouting unit from a goody hut, turn him into whatever the new unit's default AI is if it is not a suitable explorer anymore
			UnitAITypes currentAIDefault = pUnit->AI_getUnitAIType();
			UnitAITypes newAIDefault = GC.getUnitInfo(eUpgradeUnit)->GetDefaultUnitAIType();
			if(currentAIDefault == UNITAI_EXPLORE)
			{
				if(newAIDefault == UNITAI_EXPLORE || newAIDefault == UNITAI_ATTACK || newAIDefault == UNITAI_DEFENSE || newAIDefault == UNITAI_FAST_ATTACK || newAIDefault == UNITAI_COUNTER)
				{
					newAIDefault = UNITAI_EXPLORE;
				}
			}

			CvUnit* pNewUnit = initUnit(eUpgradeUnit, pPlot->getX(), pPlot->getY(), newAIDefault, NO_DIRECTION, false, false, 0, pUnit->GetNumGoodyHutsPopped());
			pUnit->finishMoves();
			pUnit->SetBeenPromotedFromGoody(true);

			CvAssert(pNewUnit);
			if (pNewUnit != NULL)
			{
#if defined(MOD_EVENTS_UNIT_UPGRADES)
			// MUST call the event before convert() as that kills the old unit
			if (MOD_EVENTS_UNIT_UPGRADES) {
				GAMEEVENTINVOKE_HOOK(GAMEEVENT_UnitUpgraded, GetID(), pUnit->GetID(), pNewUnit->GetID(), true);
			} else {
#endif
				ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
				if (pkScriptSystem)
				{
					CvLuaArgsHandle args;
					args->Push(GetID());
					args->Push(pUnit->GetID());
					args->Push(pNewUnit->GetID());
					args->Push(true); // bGoodyHut

					bool bScriptResult;
					LuaSupport::CallHook(pkScriptSystem, "UnitUpgraded", args.get(), bScriptResult);
				}
#if defined(MOD_EVENTS_UNIT_UPGRADES)
			}
#endif

				pNewUnit->convert(pUnit, true);
				pNewUnit->setupGraphical();
			}
			else
				pUnit->kill(false);

			// Since the old unit died, it will block the goody reward popup unless we call this
			GC.GetEngineUserInterface()->SetDontShowPopups(false);
		}
	}

	// Tech
	if(kGoodyInfo.isTech())
	{
		iBestValue = 0;
		eBestTech = NO_TECH;

		for(iI = 0; iI < GC.getNumTechInfos(); iI++)
		{
			const TechTypes eTech = static_cast<TechTypes>(iI);
			CvTechEntry* pkTech = GC.getTechInfo(eTech);
			if(pkTech != NULL && pkTech->IsGoodyTech())
			{
				if(GetPlayerTechs()->CanResearch(eTech))
				{
					bool bUseTech = true;

#if defined(MOD_EVENTS_GOODY_TECH)
					if (MOD_EVENTS_GOODY_TECH) {
						if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_GoodyHutCanResearch, GetID(), iI) == GAMEEVENTRETURN_FALSE) {
							bUseTech = false;
						}
					} else {
#endif
					ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
					if (pkScriptSystem)
					{
						CvLuaArgsHandle args;
						args->Push(GetID());
						args->Push(eTech);

						// Attempt to execute the game events.
						// Will return false if there are no registered listeners.
						bool bScriptResult = false;
						if (LuaSupport::CallTestAll(pkScriptSystem, "GoodyHutCanResearch", args.get(), bScriptResult))
						{
							bUseTech = bScriptResult;
						}
					}
#if defined(MOD_EVENTS_GOODY_TECH)
					}
#endif
#if defined(MOD_BALANCE_CORE)
					//Are we already researching a tech? No value here.
					if(MOD_BALANCE_CORE && GetPlayerTechs()->GetCurrentResearch() == eTech)
					{
						bUseTech = false;
					}
#endif
					if(bUseTech)
					{
						iValue = (1 + GC.getGame().getJonRandNum(10000, "Goody Tech"));

						if(iValue > iBestValue)
						{
							iBestValue = iValue;
							eBestTech = eTech;
						}
					}
				}
			}
		}

		CvAssertMsg(eBestTech != NO_TECH, "BestTech is not assigned a valid value");

#if defined(MOD_EVENTS_GOODY_TECH)
		if (MOD_EVENTS_GOODY_TECH) {
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_GoodyHutTechResearched, GetID(), eBestTech);
		} else {
#endif
		ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
		if (pkScriptSystem) 
		{
			CvLuaArgsHandle args;
			args->Push(GetID());
			args->Push(eBestTech);

			bool bScriptResult;
			LuaSupport::CallHook(pkScriptSystem, "GoodyHutTechResearched", args.get(), bScriptResult);
		}
#if defined(MOD_EVENTS_GOODY_TECH)
		}
#endif

		GET_TEAM(getTeam()).setHasTech(eBestTech, true, GetID(), true, true);
		GET_TEAM(getTeam()).GetTeamTechs()->SetNoTradeTech(eBestTech, true);
	}

	// Units
	if(kGoodyInfo.getUnitClassType() != NO_UNITCLASS)
	{
		eUnit = (UnitTypes)getCivilizationInfo().getCivilizationUnits(kGoodyInfo.getUnitClassType());

		if(eUnit != NO_UNIT)
		{
			CvUnit* pNewUnit = initUnit(eUnit, pPlot->getX(), pPlot->getY());
			// see if there is an open spot to put him - no over-stacking allowed!
			if(pNewUnit && pUnit && pUnit->AreUnitsOfSameType(*pNewUnit))  // pUnit isn't in this plot yet (if it even exists) so we can't check on if we are over-stacked directly
			{
				pBestPlot = NULL;
				iBestValue = INT_MAX;
				const int iPopRange = 2;
				for(iDX = -(iPopRange); iDX <= iPopRange; iDX++)
				{
					for(iDY = -(iPopRange); iDY <= iPopRange; iDY++)
					{
						pLoopPlot	= plotXYWithRangeCheck(pPlot->getX(), pPlot->getY(), iDX, iDY, iPopRange);
						if(pLoopPlot != NULL)
						{
							if(pLoopPlot->isValidDomainForLocation(*pNewUnit) && pNewUnit->isMatchingDomain(pLoopPlot))
							{
								if(pNewUnit->canMoveInto(*pLoopPlot))
								{
#if defined(MOD_GLOBAL_STACKING_RULES)
									if(pLoopPlot->getNumFriendlyUnitsOfType(pUnit) < pLoopPlot->getUnitLimit())
#else
									if(pLoopPlot->getNumFriendlyUnitsOfType(pUnit) < GC.getPLOT_UNIT_LIMIT())
#endif
									{
										if(pNewUnit->canEnterTerritory(pLoopPlot->getTeam()) && !pNewUnit->isEnemy(pLoopPlot->getTeam(), pLoopPlot))
										{
											if((pNewUnit->getDomainType() != DOMAIN_AIR) || pLoopPlot->isFriendlyCity(*pNewUnit, true))
											{
												if(pLoopPlot->isRevealed(getTeam()))
												{
													iValue = 1 + GC.getGame().getJonRandNum(6, "spawn goody unit that would over-stack"); // okay, I'll admit it, not a great heuristic

													if(plotDistance(pPlot->getX(),pPlot->getY(),pLoopPlot->getX(),pLoopPlot->getY()) > 1)
													{
														iValue += 12;
													}

													if(pLoopPlot->area() != pPlot->area())  // jumped to a different land mass, cool
													{
														iValue *= 10;
													}

													if(iValue < iBestValue)
													{
														iBestValue = iValue;
														pBestPlot = pLoopPlot;
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				if(pBestPlot != NULL)
				{
					bool bVis = pBestPlot->isVisibleToWatchingHuman();
					pNewUnit->setXY(pBestPlot->getX(), pBestPlot->getY(), false, true, true && bVis, true);
					pNewUnit->SetPosition(pBestPlot);	// Need this to put the unit in the right spot graphically
					pNewUnit->finishMoves();
				}
				else
				{
					pNewUnit->kill(false);
				}
			}
		}
	}

	// Barbarians
	if(kGoodyInfo.getBarbarianUnitClass() != NO_UNITCLASS)
	{
		iBarbCount = 0;

		eUnit = (UnitTypes)GET_PLAYER(BARBARIAN_PLAYER).getCivilizationInfo().getCivilizationUnits(kGoodyInfo.getBarbarianUnitClass());

		if(eUnit != NO_UNIT)
		{
			for(iPass = 0; iPass < 10; iPass++)
			{
				if(iBarbCount < kGoodyInfo.getMinBarbarians())
				{
					for(iI = 0; iI < NUM_DIRECTION_TYPES; iI++)
					{
						pLoopPlot = plotDirection(pPlot->getX(), pPlot->getY(), ((DirectionTypes)iI));

						if(pLoopPlot != NULL)
						{
							if(pLoopPlot->getArea() == pPlot->getArea())
							{
								if(pLoopPlot->isValidMovePlot(GetID()) && !pLoopPlot->isCity())
								{
									if(pLoopPlot->getNumUnits() == 0)
									{
										if((iPass > 0) || (GC.getGame().getJonRandNum(100, "Goody Barbs") < kGoodyInfo.getBarbarianUnitProb()))
										{
											GET_PLAYER(BARBARIAN_PLAYER).initUnit(eUnit, pLoopPlot->getX(), pLoopPlot->getY(), ((pLoopPlot->isWater()) ? UNITAI_ATTACK_SEA : UNITAI_ATTACK));
											iBarbCount++;

											if((iPass > 0) && (iBarbCount == kGoodyInfo.getMinBarbarians()))
											{
												break;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if(!strBuffer.empty() && GC.getGame().getActivePlayer() == GetID())
	{
		GC.GetEngineUserInterface()->AddPlotMessage(0, pPlot->GetPlotIndex(), GetID(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer);
	}

	// If it's the active player then show the popup
	if(GetID() == GC.getGame().getActivePlayer())
	{
		GC.getMap().updateDeferredFog();

		bool bDontShowRewardPopup = GC.GetEngineUserInterface()->IsOptionNoRewardPopups();

		// Don't show in MP, or if the player has turned it off
#if defined(MOD_API_EXTENSIONS)
		if(!GC.getGame().isReallyNetworkMultiPlayer() && !bDontShowRewardPopup)
#else
		if(!GC.getGame().isNetworkMultiPlayer() && !bDontShowRewardPopup)	// KWG: Candidate for !GC.getGame().isOption(GAMEOPTION_SIMULTANEOUS_TURNS)
#endif
		{
			int iSpecialValue = 0;

			if(iGold > 0)
				iSpecialValue = iGold;
			else if(iCulture > 0)
				iSpecialValue = iCulture;
			else if(iFaith > 0)
				iSpecialValue = iFaith;

			CvPopupInfo kPopupInfo(BUTTONPOPUP_GOODY_HUT_REWARD, eGoody, iSpecialValue);
			GC.GetEngineUserInterface()->AddPopup(kPopupInfo);
			// We are adding a popup that the player must make a choice in, make sure they are not in the end-turn phase.
			CancelActivePlayerEndTurn();
		}
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::doGoody(CvPlot* pPlot, CvUnit* pUnit)
{
	CvHandicapInfo& playerHandicapInfo = getHandicapInfo();

	GoodyTypes eGoody;

	CvAssertMsg(pPlot->isGoody(), "pPlot->isGoody is expected to be true");

	if(!isBarbarian())
	{
		m_bEverPoppedGoody = true;
		pPlot->removeGoody();

		// Minors don't get Goodies :(
		if(isMinorCiv())
		{
			return;
		}

		// Need to have Goodies in the Handicap file to pick from
		if(playerHandicapInfo.getNumGoodies() > 0)
		{
			// Make a list of valid Goodies to pick randomly from
			int iValidGoodiesLoop;
			bool bValid;

			std::vector<GoodyTypes> avValidGoodies;
			for(int iGoodyLoop = 0; iGoodyLoop < playerHandicapInfo.getNumGoodies(); iGoodyLoop++)
			{
				eGoody = (GoodyTypes) playerHandicapInfo.getGoodies(iGoodyLoop);
				bValid = false;

				// Check to see if we've already verified this Goody is valid (since there can be multiples in the vector)
				for(iValidGoodiesLoop = 0; iValidGoodiesLoop < (int) avValidGoodies.size(); iValidGoodiesLoop++)
				{
					if(avValidGoodies[iValidGoodiesLoop] == eGoody)
					{
						avValidGoodies.push_back(eGoody);
						bValid = true;
						break;
					}
				}

				if(bValid)
					continue;

				if(canReceiveGoody(pPlot, eGoody, pUnit))
				{
					avValidGoodies.push_back(eGoody);
				}
			}

#if defined(MOD_GLOBAL_ANYTIME_GOODY_GOLD)
			// Any valid Goodies?  If not, add back the gold goody hut(s)
			if(MOD_GLOBAL_ANYTIME_GOODY_GOLD && avValidGoodies.size() == 0)
			{
				for(int iGoodyLoop = 0; iGoodyLoop < playerHandicapInfo.getNumGoodies(); iGoodyLoop++)
				{
					eGoody = (GoodyTypes) playerHandicapInfo.getGoodies(iGoodyLoop);

					Database::SingleResult kResult;
					const bool bResult = DB.SelectAt(kResult, "GoodyHuts", eGoody);
					DEBUG_VARIABLE(bResult);
					CvAssertMsg(bResult, "Cannot find goody info.");

					CvGoodyInfo kGoodyInfo;
					kGoodyInfo.CacheResult(kResult);

					if (kGoodyInfo.getGold() > 0)
					{
						avValidGoodies.push_back(eGoody);
					}
				}
			}
#endif

			// Any valid Goodies?
			if(avValidGoodies.size() > 0)
			{
#if defined(MOD_BUGFIX_MINOR)
				// Fix the bug where the AI won't get anything for Goody Hut pickers!!!
				if (pUnit && pUnit->isHasPromotion((PromotionTypes)GC.getPROMOTION_GOODY_HUT_PICKER()) && GC.getGame().getActivePlayer() == GetID())
				{
#else
				if (pUnit && pUnit->isHasPromotion((PromotionTypes)GC.getPROMOTION_GOODY_HUT_PICKER()))
				{
					if(GC.getGame().getActivePlayer() == GetID())
#endif
					{
						CvPopupInfo kPopupInfo(BUTTONPOPUP_CHOOSE_GOODY_HUT_REWARD, GetID(), pUnit->GetID());
						GC.GetEngineUserInterface()->AddPopup(kPopupInfo);
						// We are adding a popup that the player must make a choice in, make sure they are not in the end-turn phase.
						CancelActivePlayerEndTurn();
					}
				}
				else
				{
					int iRand = GC.getGame().getJonRandNum(avValidGoodies.size(), "Picking a Goody result");
					eGoody = (GoodyTypes) avValidGoodies[iRand];
					receiveGoody(pPlot, eGoody, pUnit);
				}
				
#if !defined(NO_ACHIEVEMENTS)
				if (pUnit && isHuman() && !GC.getGame().isGameMultiPlayer())
				{
					pUnit->ChangeNumGoodyHutsPopped(pUnit->GetNumGoodyHutsPopped() + 1);
					if (pUnit->isHasPromotion((PromotionTypes)GC.getPROMOTION_GOODY_HUT_PICKER()) && pUnit->GetNumGoodyHutsPopped() >= 5)
					{
						gDLL->UnlockAchievement(ACHIEVEMENT_XP2_25);
					}
				}
#endif
			}

			pPlot->AddArchaeologicalRecord(CvTypes::getARTIFACT_ANCIENT_RUIN(), m_eID, NO_PLAYER);
		}
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::AwardFreeBuildings(CvCity* pCity)
{
	int iNumFreeCultureBuildings = GetNumCitiesFreeCultureBuilding();
	if(iNumFreeCultureBuildings > 0)
	{
		BuildingTypes eBuilding = pCity->ChooseFreeCultureBuilding();
		if(eBuilding != NO_BUILDING)
		{
			pCity->GetCityBuildings()->SetNumFreeBuilding(eBuilding, 1);
		}
		else
		{
			pCity->SetOwedCultureBuilding(true);
		}

		ChangeNumCitiesFreeCultureBuilding(-1);
	}

	int iNumFreeFoodBuildings = GetNumCitiesFreeFoodBuilding();
	if(iNumFreeFoodBuildings > 0)
	{
		BuildingTypes eBuilding = pCity->ChooseFreeFoodBuilding();
		if(eBuilding != NO_BUILDING)
		{
			pCity->GetCityBuildings()->SetNumFreeBuilding(eBuilding, 1);
		}
#if defined(MOD_BUGFIX_FREE_FOOD_BUILDING)
		else
		{
			pCity->SetOwedFoodBuilding(true);
		}
#endif

		ChangeNumCitiesFreeFoodBuilding(-1);
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNoSettling(int iPlotIndex)
{
	m_noSettlingPlots.insert(iPlotIndex);
}
bool CvPlayer::IsNoSettling(int iPlotIndex) const
{
	return m_noSettlingPlots.find(iPlotIndex)!= m_noSettlingPlots.end();
}
void CvPlayer::ClearNoSettling()
{
	m_noSettlingPlots.clear();
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canFound(int iX, int iY) const
{
	return canFound(iX,iY,false,false,NULL);
}

bool CvPlayer::canFound(int iX, int iY, bool bIgnoreDistanceToExistingCities, bool bIgnoreHappiness, const CvUnit* pUnit) const
{
	CvPlot* pPlot = GC.getMap().plot(iX, iY);
#if defined(MOD_EVENTS_CITY_FOUNDING)
	if (MOD_EVENTS_CITY_FOUNDING) {
		if (GAMEEVENTINVOKE_TESTANY(GAMEEVENT_PlayerCanFoundCityRegardless, GetID(), iX, iY) == GAMEEVENTRETURN_TRUE) {
			return true;
		}
	}
#endif

#if defined(MOD_EVENTS_CITY_FOUNDING)
	if (MOD_EVENTS_CITY_FOUNDING) {
		if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_PlayerCanFoundCity, GetID(), iX, iY) == GAMEEVENTRETURN_FALSE) {
			return false;
		}
	}
#endif

	// Has the AI agreed to not settle here?
	if(IsNoSettling(pPlot->GetPlotIndex()))
		return false;

	// Haxor for Venice to prevent secondary founding
	if (GetPlayerTraits()->IsNoAnnexing() && getCapitalCity())
	{
		return false;
	}

	// Settlers cannot found cities while empire is very unhappy
	if(!bIgnoreHappiness && IsEmpireVeryUnhappy())
		return false;

	return GC.getGame().GetSettlerSiteEvaluator()->CanFound(pPlot, this, bIgnoreDistanceToExistingCities, pUnit);
}

//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_RELIGIOUS_SETTLERS)
void CvPlayer::found(int iX, int iY, ReligionTypes eReligion, bool bForce)
#else
void CvPlayer::found(int iX, int iY)
#endif
{
	if(!bForce && !canFound(iX, iY))
	{
		return;
	}

	SetTurnsSinceSettledLastCity(0);

#if defined(MOD_BALANCE_CORE)
	if (getNumCities() <= 0)
	{
		int iFoundValue = GC.getMap().plot(iX,iY)->getFoundValue(GetID());
		SetFoundValueOfCapital(iFoundValue);
	}
#endif

#if defined(MOD_GLOBAL_RELIGIOUS_SETTLERS) && defined(MOD_API_EXTENSIONS)
	CvCity* pCity = initCity(iX, iY, true, true, eReligion);
#else
	CvCity* pCity = initCity(iX, iY);
#endif
	CvAssertMsg(pCity != NULL, "City is not assigned a valid value");
	if(pCity == NULL)
		return;

	int iExtraTerritoryClaim = GetPlayerTraits()->GetExtraFoundedCityTerritoryClaimRange();
	for (int i = 0; i < iExtraTerritoryClaim; i++)
	{
#if defined(MOD_BALANCE_CORE)
		CvPlot* pPlotToAcquire = pCity->GetNextBuyablePlot(false);
#else
		CvPlot* pPlotToAcquire = pCity->GetNextBuyablePlot();
#endif

		// maybe the player owns ALL of the plots or there are none available?
		if(pPlotToAcquire)
		{
			pCity->DoAcquirePlot(pPlotToAcquire->getX(), pPlotToAcquire->getY());
		}
	}
#if defined(MOD_BALANCE_CORE)
	if(MOD_BALANCE_CORE && !isMinorCiv() && (GetNumCitiesFounded() <= 1))
	{
		if(GetPlayerTraits()->IsPopulationBoostReligion())
		{
			int iFaith = GC.getGame().GetGameReligions()->GetMinimumFaithNextPantheon();
			SetFaith(iFaith);
			if(GC.getGame().GetGameReligions()->CanCreatePantheon(GetID(), true) == 0)
			{
				// Create the pantheon
				if(isHuman())
				{
					//If the player is human then a net message will be received which will pick the pantheon.
					CvNotifications* pNotifications = GetNotifications();
					if(pNotifications)
					{
						CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_ENOUGH_FAITH_FOR_PANTHEON");

						CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_ENOUGH_FAITH_FOR_PANTHEON");
						pNotifications->Add(NOTIFICATION_FOUND_PANTHEON, strBuffer, strSummary, -1, -1, -1);
					}
				}
				else
				{
	#if defined(MOD_EVENTS_ACQUIRE_BELIEFS)
					const BeliefTypes eBelief = GetReligionAI()->ChoosePantheonBelief(GetID());
	#else
					const BeliefTypes eBelief = owningPlayer.GetReligionAI()->ChoosePantheonBelief();
	#endif

					GC.getGame().GetGameReligions()->FoundPantheon(GetID(), eBelief);
				}
			}
		}
	}
#endif
	for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
	{
		const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iI);
		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
		if(pkBuildingClassInfo)
		{
			const BuildingTypes eLoopBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(iI)));
			if(eLoopBuilding != NO_BUILDING)
			{
				CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eLoopBuilding);
				if(pkBuildingInfo)
				{
					if(pkBuildingInfo->GetFreeStartEra() != NO_ERA)
					{
						if(GC.getGame().getStartEra() >= pkBuildingInfo->GetFreeStartEra())
						{
							if(pCity->canConstruct(eLoopBuilding))
							{
								pCity->GetCityBuildings()->SetNumRealBuilding(eLoopBuilding, 1);

#if defined(MOD_EVENTS_CITY)
								if (MOD_EVENTS_CITY) {
									GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityConstructed, pCity->getOwner(), pCity->GetID(), eLoopBuilding, false, false);
								}
#endif
							}
						}
					}
				}
			}
		}
	}

	AwardFreeBuildings(pCity);

	DoUpdateNextPolicyCost();

	if(isHuman() && getAdvancedStartPoints() < 0)
	{
		// Human player is prompted to choose production BEFORE the AI runs for the turn.
		// So we'll force the AI strategies on the city now, just after it is founded.
		// And if the very first turn, we haven't even run player strategies once yet, so do that too.
		if(GC.getGame().getGameTurn() == 0)
		{
			this->GetEconomicAI()->DoTurn();
			this->GetMilitaryAI()->DoTurn();
			this->GetReligionAI()->DoTurn();
			this->GetEspionageAI()->DoTurn();
			this->GetTradeAI()->DoTurn();
		}
		pCity->GetCityStrategyAI()->DoTurn();
		pCity->chooseProduction();
		pCity->doFoundMessage();

		// If this is the first city (or we still aren't getting tech for some other reason notify the player)
		if(GetPlayerTechs()->GetCurrentResearch() == NO_TECH && GetScienceTimes100() > 0)
		{
			if(GetID() == GC.getGame().getActivePlayer())
			{
				chooseTech();
			}
		}
	}
	else
	{
		pCity->doFoundMessage();

		// AI civ, may need to redo city specializations
		GetCitySpecializationAI()->SetSpecializationsDirty(SPECIALIZATION_UPDATE_CITY_FOUNDED);
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(pCity->getX());
		args->Push(pCity->getY());
		
		bool bResult;
		LuaSupport::CallHook(pkScriptSystem, "PlayerCityFounded", args.get(), bResult);
	}
}

#if defined(MOD_BALANCE_CORE_SETTLER)
void CvPlayer::cityBoost(int iX, int iY, CvUnitEntry* pkUnitEntry, int iExtraPlots, int iPopChange, int iFoodPercent)
{
	//Advanced Settler Buildings
	if(pkUnitEntry && !isMinorCiv() && !isBarbarian())
	{
		CvPlot* pPlot = GC.getMap().plot(iX, iY);
		CvCity* pCity = NULL;
		if(pPlot->isCity())
		{
			pCity = GC.getMap().findCity(iX, iY, GetID(), NO_TEAM);
		}

		if(pCity)
		{
			const int iNumBuildingClassInfos = GC.getNumBuildingClassInfos();
			CvCivilizationInfo& thisCivilization = getCivilizationInfo();
			for(int iBuildingClassLoop = 0; iBuildingClassLoop < iNumBuildingClassInfos; iBuildingClassLoop++)
			{
				const BuildingClassTypes eBuildingClass = (BuildingClassTypes) iBuildingClassLoop;
				CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
				if(!pkBuildingClassInfo)
				{
					continue;
				}
				if(pkUnitEntry->GetBuildOnFound(eBuildingClass))
				{
					const BuildingTypes eFreeBuilding = (BuildingTypes)(thisCivilization.getCivilizationBuildings(eBuildingClass));
					if(pCity->isValidBuildingLocation(eFreeBuilding))
					{
						pCity->GetCityBuildings()->SetNumRealBuilding(eFreeBuilding, 1, true);
					}
				}
			}
		}

		pCity->setPopulation(GetNewCityExtraPopulation() + iPopChange, true, true);

		//25% food, to prevent instant-starvation
		pCity->changeFood((pCity->growthThreshold() * iFoodPercent / 100));

		//And a little territory to boot
		for (int i = 0; i < iExtraPlots; i++)
		{
#if defined(MOD_BALANCE_CORE)
			CvPlot* pPlotToAcquire = pCity->GetNextBuyablePlot(false);
#else
			CvPlot* pPlotToAcquire = pCity->GetNextBuyablePlot();
#endif

			// maybe the player owns ALL of the plots or there are none available?
			if(pPlotToAcquire)
			{
				pCity->DoAcquirePlot(pPlotToAcquire->getX(), pPlotToAcquire->getY());
			}
		}
	}
}
#endif

//	--------------------------------------------------------------------------------
bool CvPlayer::canTrain(UnitTypes eUnit, bool bContinue, bool bTestVisible, bool bIgnoreCost, bool bIgnoreUniqueUnitStatus, CvString* toolTipSink) const
{
	CvUnitEntry* pUnitInfoPtr = GC.getUnitInfo(eUnit);
	if(pUnitInfoPtr == NULL)
		return false;

	CvUnitEntry& pUnitInfo = *pUnitInfoPtr;

	const UnitClassTypes eUnitClass = (UnitClassTypes) pUnitInfo.GetUnitClassType();
	if(eUnitClass == NO_UNITCLASS)
	{
		return false;
	}

	CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
	if(pkUnitClassInfo == NULL)
	{
		return false;
	}

	if (GetPlayerTraits()->NoTrain(eUnitClass))
	{
		return false;
	}
#if defined(MOD_BALANCE_CORE_MINOR_CIV_GIFT)
	if(MOD_BALANCE_CORE_MINOR_CIV_GIFT && pUnitInfo.IsMinorCivGift() && !isBarbarian())
	{
		return false;
	}
#endif
#if defined(MOD_BALANCE_CORE_MILITARY)
	if(MOD_BALANCE_CORE_MILITARY && !isHuman())
	{
		if(!pUnitInfo.IsFound() && !isBarbarian() && GetNumUnitsOutOfSupply() > 0)
		{
			return false;
		}
	}
#endif
	// Should we check whether this Unit has been blocked out by the civ XML?
	if(!bIgnoreUniqueUnitStatus)
	{
		UnitTypes eThisPlayersUnitType = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eUnitClass);

		// If the player isn't allowed to train this Unit (via XML) then return false
		if(eThisPlayersUnitType != eUnit)
		{
			return false;
		}
	}

	if(!bIgnoreCost)
	{
		if(pUnitInfo.GetProductionCost() == -1)
		{
			return false;
		}
	}
#if defined(MOD_BALANCE_CORE)
	ResourceTypes eResource = (ResourceTypes)pUnitInfo.GetResourceType();
	if (MOD_BALANCE_CORE && eResource != NO_RESOURCE && !isBarbarian())
	{
		if (getNumResourceTotal(eResource, true) <= 0)
		{
			return false;
		}
	}
#endif

	// One City Challenge
	if(pUnitInfo.IsFound() || pUnitInfo.IsFoundAbroad())
	{
		if(GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && isHuman())
		{
			return false;
		}
	}
	
	//Policy Requirement
	PolicyTypes ePolicy = (PolicyTypes)pUnitInfo.GetPolicyType();
	if (ePolicy != NO_POLICY)
	{
		if (!GetPlayerPolicies()->HasPolicy(ePolicy))
		{
			return false;
		}
	}


	if (GC.getGame().isOption(GAMEOPTION_NO_RELIGION))
	{
		if (pUnitInfo.IsFoundReligion() || pUnitInfo.IsSpreadReligion() || pUnitInfo.IsRemoveHeresy())
		{
			return false;
		}
	}

	if(!bContinue)
	{
		if(!bTestVisible)
		{
			// Builder Limit
			if(pUnitInfo.GetWorkRate() > 0 && pUnitInfo.GetDomainType() == DOMAIN_LAND)
			{
				if(GetMaxNumBuilders() > -1 && GetNumBuilders() >= GetMaxNumBuilders())
				{
					return false;
				}
			}
		}
	}

	// Tech requirements
	if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pUnitInfo.GetPrereqAndTech()))))
	{
		return false;
	}

	int iI;
	for(iI = 0; iI < GC.getNUM_UNIT_AND_TECH_PREREQS(); iI++)
	{
		if(pUnitInfo.GetPrereqAndTechs(iI) != NO_TECH)
		{
			if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pUnitInfo.GetPrereqAndTechs(iI)))))
			{
				return false;
			}
		}
	}

	// Obsolete Tech
	if((TechTypes)pUnitInfo.GetObsoleteTech() != NO_TECH)
	{
		if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pUnitInfo.GetObsoleteTech())))
		{
			return false;
		}
	}

	// Game Unit Class Max
	if(GC.getGame().isUnitClassMaxedOut(eUnitClass))
	{
		return false;
	}

	// Team Unit Class Max
	if(GET_TEAM(getTeam()).isUnitClassMaxedOut(eUnitClass))
	{
		return false;
	}

	// Player Unit Class Max
	if(isUnitClassMaxedOut(eUnitClass))
	{
		return false;
	}

	// Spaceship part we already have?
	ProjectTypes eProject = (ProjectTypes) pUnitInfo.GetSpaceshipProject();
	if(eProject != NO_PROJECT)
	{
		if(GET_TEAM(getTeam()).isProjectMaxedOut(eProject))
			return false;

		int iUnitAndProjectCount = GET_TEAM(getTeam()).getProjectCount(eProject) + getUnitClassCount(eUnitClass) + GET_TEAM(getTeam()).getUnitClassMaking(eUnitClass) + ((bContinue) ? -1 : 0);
		if(iUnitAndProjectCount >= pkUnitClassInfo->getMaxPlayerInstances())
		{
			return false;
		}
	}

	if(!bTestVisible)
	{
#if defined(MOD_BALANCE_CORE_MILITARY)
		if(MOD_BALANCE_CORE_MILITARY && !pUnitInfo.IsFound() && !isBarbarian() && GetNumUnitsOutOfSupply() > 0)
		{
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_NO_SUPPLY");
			if(toolTipSink == NULL)
			return false;
		}
#endif
		// Settlers
		if(pUnitInfo.IsFound() || pUnitInfo.IsFoundAbroad())
		{
			if(IsEmpireVeryUnhappy() && GC.getVERY_UNHAPPY_CANT_TRAIN_SETTLERS() == 1)
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_VERY_UNHAPPY_SETTLERS");
				if(toolTipSink == NULL)
					return false;
			}
		}

		// Project required?
		ProjectTypes ePrereqProject = (ProjectTypes) pUnitInfo.GetProjectPrereq();
		if(ePrereqProject != NO_PROJECT)
		{
			CvProjectEntry* pkProjectInfo = GC.getProjectInfo(ePrereqProject);
			if(pkProjectInfo)
			{
				if(GET_TEAM(getTeam()).getProjectCount(ePrereqProject) == 0)
				{
					GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_UNIT_PROJECT_REQUIRED", pkProjectInfo->GetDescription());
					if(toolTipSink == NULL)
						return false;
				}
			}
		}

		// Resource Requirements
		for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
		{
			const ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);
			CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);
			if(pkResourceInfo)
			{
				const int iNumResource = pUnitInfo.GetResourceQuantityRequirement(eResource);

				if(iNumResource > 0)
				{
					// Starting project, need enough Resources plus some to start
					if(!bContinue && getNumResourceAvailable(eResource) < iNumResource)
					{
						GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_UNIT_LACKS_RESOURCES", pkResourceInfo->GetIconString(), pkResourceInfo->GetTextKey(), iNumResource);
						if(toolTipSink == NULL)
							return false;
					}
					// Continuing project, need enough Resources
					else if(bContinue && (getNumResourceAvailable(eResource) < 0))
					{
						GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_UNIT_LACKS_RESOURCES", pkResourceInfo->GetIconString(), pkResourceInfo->GetTextKey(), iNumResource);
						if(toolTipSink == NULL)
							return false;
					}
				}
			}

		}

		if(GC.getGame().isUnitClassMaxedOut(eUnitClass, (GET_TEAM(getTeam()).getUnitClassMaking(eUnitClass) + ((bContinue) ? -1 : 0))))
		{
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_GAME_COUNT_MAX", "", "", pkUnitClassInfo->getMaxTeamInstances());
			if(toolTipSink == NULL)
				return false;
		}

		if(GET_TEAM(getTeam()).isUnitClassMaxedOut(eUnitClass, (GET_TEAM(getTeam()).getUnitClassMaking(eUnitClass) + ((bContinue) ? -1 : 0))))
		{
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_TEAM_COUNT_MAX", "", "", pkUnitClassInfo->getMaxTeamInstances());
			if(toolTipSink == NULL)
				return false;
		}

		if(isUnitClassMaxedOut(eUnitClass, (getUnitClassMaking(eUnitClass) + ((bContinue) ? -1 : 0))))
		{
#if defined(MOD_BALANCE_CORE)
			if(isNationalUnitClass(eUnitClass))
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_PLAYER_COUNT_MAX", "", "", pkUnitClassInfo->getMaxPlayerInstances());
				if(toolTipSink == NULL)
					return false;
			}
			if(isUnitLimitPerCity(eUnitClass))
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_PLAYER_CITY_COUNT_MAX", "", "", (getNumCities() * pkUnitClassInfo->getUnitInstancePerCity()));
				if(toolTipSink == NULL)
					return false;
			}
#else
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_PLAYER_COUNT_MAX", "", "", pkUnitClassInfo->getMaxPlayerInstances());
			if(toolTipSink == NULL)
				return false;
#endif
		}

		if(GC.getGame().isNoNukes() || !GC.getGame().isNukesValid())
		{
			if(pUnitInfo.GetNukeDamageLevel() != -1)
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_NUKES");
				if(toolTipSink == NULL)
					return false;
			}
		}

		if(pUnitInfo.GetNukeDamageLevel() != -1)
		{
			if(GC.getGame().GetGameLeagues()->IsNoTrainingNuclearWeapons(GetID()))
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_NUKES_BY_RESOLUTION");
				if(toolTipSink == NULL)
					return false;
			}
		}

		if(pUnitInfo.GetSpecialUnitType() != NO_SPECIALUNIT)
		{
			if(!(GC.getGame().isSpecialUnitValid((SpecialUnitTypes)(pUnitInfo.GetSpecialUnitType()))))
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_SPECIAL_UNIT");
				if(toolTipSink == NULL)
					return false;
			}
		}

		if (pUnitInfo.IsTrade())
		{
			if (GetTrade()->GetNumTradeRoutesRemaining(bContinue) <= 0)
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_TRADE_UNIT_CONSTRUCTION_NO_EXTRA_SLOTS");
				if (toolTipSink == NULL)
					return false;			
			}

			DomainTypes eDomain = (DomainTypes)pUnitInfo.GetDomainType();
			if (!GetTrade()->CanCreateTradeRoute(eDomain))
			{
				if (eDomain == DOMAIN_LAND)
				{
					GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_TRADE_UNIT_CONSTRUCTION_NONE_OF_TYPE_LAND");
				}
				else if (eDomain == DOMAIN_SEA)
				{
					GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_TRADE_UNIT_CONSTRUCTION_NONE_OF_TYPE_SEA");
				}
				if (toolTipSink == NULL)
					return false;
			}
		}
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(eUnit);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if(LuaSupport::CallTestAll(pkScriptSystem, "PlayerCanTrain", args.get(), bResult))
		{
			// Check the result.
			if(bResult == false)
			{
				return false;
			}
		}
	}

	return true;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::canConstruct(BuildingTypes eBuilding, bool bContinue, bool bTestVisible, bool bIgnoreCost, CvString* toolTipSink) const
{
	std::vector<int> vTotalBuildingCount( GC.getNumBuildingInfos(), 0);
	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity && !pLoopCity->IsPuppet())
		{
			const std::vector<BuildingTypes>& vBuildings = pLoopCity->GetCityBuildings()->GetAllBuildings();
			for (size_t i=0; i<vBuildings.size(); i++)
				vTotalBuildingCount[ vBuildings[i] ]++;
		}
	}

	return canConstruct(eBuilding,vTotalBuildingCount,bContinue,bTestVisible,bIgnoreCost,toolTipSink);
}

bool CvPlayer::canConstruct(BuildingTypes eBuilding, const std::vector<int>& vPreExistingBuildings, bool bContinue, bool bTestVisible, bool bIgnoreCost, CvString* toolTipSink) const
{
	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if(pkBuildingInfo == NULL)
		return false;

	// Don't allow a city to consider an espionage building if they are playing a non-espionage game
	if(GC.getGame().isOption(GAMEOPTION_NO_ESPIONAGE) && pkBuildingInfo->IsEspionage())
	{
		return false;
	}

	CvBuildingEntry& pBuildingInfo = *pkBuildingInfo;

	int iI;
	CvTeam& currentTeam = GET_TEAM(getTeam());

	const BuildingClassTypes eBuildingClass = ((BuildingClassTypes)(pBuildingInfo.GetBuildingClassType()));
	const CvBuildingClassInfo& kBuildingClass = pkBuildingInfo->GetBuildingClassInfo();

	// Checks to make sure civilization doesn't have an override that prevents construction of this building
	if(getCivilizationInfo().getCivilizationBuildings(eBuildingClass) != eBuilding)
	{
		return false;
	}

	if(!bIgnoreCost)
	{
		if(pBuildingInfo.GetProductionCost() == -1)
		{
			return false;
		}
	}

	PolicyBranchTypes eBranch = (PolicyBranchTypes)pBuildingInfo.GetPolicyBranchType();
	if (eBranch != NO_POLICY_BRANCH_TYPE)
	{
		if (!GetPlayerPolicies()->IsPolicyBranchUnlocked(eBranch))
		{
			return false;
		}
	}
#if defined(MOD_BALANCE_CORE_POLICIES)
	PolicyTypes ePolicy = (PolicyTypes)pBuildingInfo.GetPolicyType();
	if (MOD_BALANCE_CORE_POLICIES && ePolicy != NO_POLICY)
	{
		if (!GetPlayerPolicies()->HasPolicy(ePolicy))
		{
			return false;
		}
	}
#endif
#if defined(MOD_BALANCE_CORE)
	ResourceTypes eResource = (ResourceTypes)pBuildingInfo.GetResourceType();
	if (MOD_BALANCE_CORE && eResource != NO_RESOURCE)
	{
		if (getNumResourceTotal(eResource, true) <= 0)
		{
			return false;
		}
	}
#endif
	if(!(currentTeam.GetTeamTechs()->HasTech((TechTypes)(pBuildingInfo.GetPrereqAndTech()))))
	{
		return false;
	}
	for(iI = 0; iI < GC.getNUM_BUILDING_AND_TECH_PREREQS(); iI++)
	{
		if(pBuildingInfo.GetPrereqAndTechs(iI) != NO_TECH)
		{
			if(!(currentTeam.GetTeamTechs()->HasTech((TechTypes)(pBuildingInfo.GetPrereqAndTechs(iI)))))
			{
				return false;
			}
		}
	}

	if(currentTeam.isObsoleteBuilding(eBuilding))
	{
		return false;
	}

	// Building upgrade to another type
	BuildingClassTypes eReplacementBuildingClass = (BuildingClassTypes) pBuildingInfo.GetReplacementBuildingClass();

	if(eReplacementBuildingClass != NO_BUILDINGCLASS)
	{
		BuildingTypes eUpgradeBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(eReplacementBuildingClass)));

		if(canConstruct(eUpgradeBuilding))
		{
			return false;
		}
	}

	if(pBuildingInfo.GetVictoryPrereq() != NO_VICTORY)
	{
		if(!(GC.getGame().isVictoryValid((VictoryTypes)(pBuildingInfo.GetVictoryPrereq()))))
		{
			return false;
		}

		if(isMinorCiv())
		{
			return false;
		}

		if(currentTeam.getVictoryCountdown((VictoryTypes)pBuildingInfo.GetVictoryPrereq()) >= 0)
		{
			return false;
		}
	}

	if(pBuildingInfo.GetMaxStartEra() != NO_ERA)
	{
		if(GC.getGame().getStartEra() > pBuildingInfo.GetMaxStartEra())
		{
			return false;
		}
	}

	if(GC.getGame().isBuildingClassMaxedOut(eBuildingClass))
	{
		return false;
	}

	if(currentTeam.isBuildingClassMaxedOut(eBuildingClass))
	{
		return false;
	}

	if(isBuildingClassMaxedOut(eBuildingClass))
	{
		return false;
	}

	///////////////////////////////////////////////////////////////////////////////////
	// Everything above this is what is checked to see if Building shows up in the list of construction items
	///////////////////////////////////////////////////////////////////////////////////

	if(!bTestVisible)
	{
		// Num buildings in the empire... uhhh, how is this different from the very last check in this function? (JON: It doesn't appear to be used, but I can't say for sure :)
		CvCivilizationInfo& civilizationInfo = getCivilizationInfo();
		int numBuildingClassInfos = GC.getNumBuildingClassInfos();

		for(iI = 0; iI < numBuildingClassInfos; iI++)
		{
			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo((BuildingClassTypes)iI);
			if(!pkBuildingClassInfo)
			{
				continue;
			}

			BuildingTypes ePrereqBuilding = (BuildingTypes)civilizationInfo.getCivilizationBuildings(iI);

			if(NO_BUILDING != ePrereqBuilding && currentTeam.isObsoleteBuilding(ePrereqBuilding))
			{
				CvBuildingEntry* pkPrereqBuilding = GC.getBuildingInfo(ePrereqBuilding);
				if(pkPrereqBuilding)
				{
					int iNumHave = getBuildingClassCount((BuildingClassTypes)iI);

					int iNumNeeded = getBuildingClassPrereqBuilding(eBuilding, (BuildingClassTypes)iI, 0);

					if(iNumHave < iNumNeeded)
					{
						GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_COUNT_NEEDED", pkPrereqBuilding->GetTextKey(), "", iNumNeeded - iNumHave);

						if(toolTipSink == NULL)
							return false;
					}
				}
			}
		}

		// Resource Requirements
		for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
		{
			const ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);
			CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
			if(pkResource)
			{
				int iNumResource = pBuildingInfo.GetResourceQuantityRequirement(eResource);
				if(iNumResource > 0)
				{
					if(bContinue)
						iNumResource = 0;

					if(getNumResourceAvailable(eResource) < iNumResource)
					{
						GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_LACKS_RESOURCES", pkResource->GetIconString(), pkResource->GetTextKey(), iNumResource);
						if(toolTipSink == NULL)
							return false;
					}
				}
			}
		}

		if(GC.getGame().isBuildingClassMaxedOut(eBuildingClass, (currentTeam.getBuildingClassMaking(eBuildingClass) + ((bContinue) ? -1 : 0))))
		{
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_GAME_COUNT_MAX", "", "", kBuildingClass.getMaxGlobalInstances());
			if(toolTipSink == NULL)
				return false;
		}

		if(currentTeam.isBuildingClassMaxedOut(eBuildingClass, (currentTeam.getBuildingClassMaking(eBuildingClass) + ((bContinue) ? -1 : 0))))
		{
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_TEAM_COUNT_MAX", "", "", kBuildingClass.getMaxTeamInstances());
			if(toolTipSink == NULL)
				return false;
		}

		if(isBuildingClassMaxedOut(eBuildingClass, (getBuildingClassMaking(eBuildingClass) + ((bContinue) ? -1 : 0))))
		{
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_PLAYER_COUNT_MAX", "", "", kBuildingClass.getMaxPlayerInstances());
			if(toolTipSink == NULL)
				return false;
		}

		if(getNumCities() < pBuildingInfo.GetNumCitiesPrereq())
		{
			return false;
		}

		if(getHighestUnitLevel() < pBuildingInfo.GetUnitLevelPrereq())
		{
			return false;
		}
#if defined(MOD_BALANCE_CORE)
		if(GetPlayerPolicies() && !isMinorCiv() && !isBarbarian())
		{
			int iNumPolicies = GetPlayerPolicies()->GetNumPoliciesOwned(true);
			//If # of policies will do it, then we need to see the either/or here.
			if(pBuildingInfo.GetNumPoliciesNeeded() > 0)
			{
				if(iNumPolicies < pBuildingInfo.GetNumPoliciesNeeded())
				{
					GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_NEED_POLICIES", pkBuildingInfo->GetTextKey(), "", pBuildingInfo.GetNumPoliciesNeeded() - iNumPolicies);
					if(toolTipSink == NULL)
					return false;
				}
			}
		}
#endif

#if defined(MOD_BALANCE_CORE_POP_REQ_BUILDINGS)
		//Requires a certain population size, nationally.
		if(MOD_BALANCE_CORE_POP_REQ_BUILDINGS)
		{
			int iPopRequired = GetScalingNationalPopulationRequrired(eBuilding);
			if(iPopRequired > 0)
			{
				int iCurrentPop = getCurrentTotalPop();
				if(iCurrentPop < iPopRequired)
				{
					GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_NEED_NATIONAL_POP", pkBuildingInfo->GetTextKey(), "", iPopRequired - iCurrentPop);
					if(toolTipSink == NULL)
					return false;
				}
			}
		}
#endif
#if defined(MOD_BALANCE_CORE_FOLLOWER_POP_WONDER)
		//Requires a certain religion follower size, either nationally or globally.
		if(MOD_BALANCE_CORE_FOLLOWER_POP_WONDER)
		{
			CvGameReligions* pReligions = GC.getGame().GetGameReligions();
			ReligionTypes eFoundedReligion = pReligions->GetFounderBenefitsReligion(GetID());
			if(eFoundedReligion != NO_RELIGION)
			{
				const CvReligion* pReligion = pReligions->GetReligion(eFoundedReligion, GetID());
				if(pReligion)
				{
					if(pReligion->m_Beliefs.IsBuildingClassEnabled(eBuildingClass))
					{
						if(pkBuildingInfo->GetNationalFollowerPopRequired() > 0)
						{
							int iPopRequired = pkBuildingInfo->GetNationalFollowerPopRequired();
							int iLoop;
							int iCurrentPop = 0;
							CvCity* pLoopCity;
							for(pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
							{
								iCurrentPop += pLoopCity->GetCityReligions()->GetNumFollowers(eFoundedReligion);
							}				
							if(iCurrentPop < iPopRequired)
							{
								GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_NEED_FOLLOWER_POP", pkBuildingInfo->GetTextKey(), "", iPopRequired - iCurrentPop);
								if(toolTipSink == NULL)
								return false;
							}
						}
						if(pkBuildingInfo->GetGlobalFollowerPopRequired() > 0)
						{
							int iPopRequiredPercent = pkBuildingInfo->GetGlobalFollowerPopRequired();

							int iCurrentPop = pReligions->GetNumFollowers(eFoundedReligion);
							int iCurrentPopPercent = (iCurrentPop * 100) / GC.getGame().getTotalPopulation(); 

							if(iCurrentPopPercent < iPopRequiredPercent)
							{
								int iPercentage = iPopRequiredPercent - iCurrentPopPercent;
								GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_NEED_GLOBAL_FOLLOWER_POP", pkBuildingInfo->GetTextKey(), "", iPercentage);
								if(toolTipSink == NULL)
								return false;
							}
						}
					}
				}
			}
		}
#endif

		BuildingTypes ePrereqBuilding;
		int iNumNeeded;
		for(iI = 0; iI < numBuildingClassInfos; iI++)
		{
			iNumNeeded = getBuildingClassPrereqBuilding(eBuilding, ((BuildingClassTypes)iI), bContinue);
			//int iNumHave = getBuildingClassCount((BuildingClassTypes)iI);
			ePrereqBuilding = (BuildingTypes) civilizationInfo.getCivilizationBuildings(iI);
			if(NO_BUILDING != ePrereqBuilding)
			{
				CvBuildingEntry* pkPrereqBuilding = GC.getBuildingInfo(ePrereqBuilding);
				if(pkPrereqBuilding)
				{
					int iNumHave = vPreExistingBuildings[ePrereqBuilding];
					if(iNumHave < iNumNeeded)
					{
						ePrereqBuilding = (BuildingTypes) civilizationInfo.getCivilizationBuildings(iI);

						GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_COUNT_NEEDED", pkPrereqBuilding->GetTextKey(), "", iNumNeeded - iNumHave);

						if(toolTipSink == NULL)
							return false;

						// If we have less than 5 to go, list what cities need them
						int iNonPuppetCities = getNumCities() - GetNumPuppetCities();
						if(iNumNeeded == iNonPuppetCities && iNumNeeded - iNumHave < 5)
						{
							(*toolTipSink) += "[NEWLINE]";

							int iLoop=0;
							for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								if(pLoopCity && !pLoopCity->IsPuppet() && pLoopCity->GetCityBuildings()->GetNumBuilding(ePrereqBuilding) == 0)
								{
									(*toolTipSink) += pLoopCity->getName();
									(*toolTipSink) += " ";
								}
							}
						}
					}
				}
			}
		}
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(eBuilding);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if(LuaSupport::CallTestAll(pkScriptSystem, "PlayerCanConstruct", args.get(), bResult))
		{
			// Check the result.
			if(bResult == false)
			{
				return false;
			}
		}
	}

	return true;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::canCreate(ProjectTypes eProject, bool bContinue, bool bTestVisible) const
{
	CvProjectEntry* pkProjectInfo = GC.getProjectInfo(eProject);
	if(!pkProjectInfo)
	{
		return false;
	}

	CvProjectEntry& pProjectInfo = *pkProjectInfo;

	int iI;

	// No projects for barbs
	if(isBarbarian())
	{
		return false;
	}

	// no minors either
	if(isMinorCiv())
	{
		return false;
	}

	// If cost is -1 then that means it can't be built
	if(pProjectInfo.GetProductionCost() == -1)
	{
		return false;
	}

	// Tech requirement
	if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pProjectInfo.GetTechPrereq()))))
	{
		return false;
	}

	// Policy branch requirement?
	if(pProjectInfo.GetCultureBranchesRequired() > 0)
	{
		if(GetPlayerPolicies()->GetNumPolicyBranchesFinished() < pProjectInfo.GetCultureBranchesRequired())
		{
			return false;
		}
	}

	// Requires a particular victory condition to be enabled?
	if(pProjectInfo.GetVictoryPrereq() != NO_VICTORY)
	{
		if(!(GC.getGame().isVictoryValid((VictoryTypes)(pProjectInfo.GetVictoryPrereq()))))
		{
			return false;
		}

		if(isMinorCiv())
		{
			return false;
		}

		if(GET_TEAM(getTeam()).getVictoryCountdown((VictoryTypes)pProjectInfo.GetVictoryPrereq()) >= 0)
		{
			return false;
		}
	}

	if(GC.getGame().isProjectMaxedOut(eProject))
	{
		return false;
	}

	if(GET_TEAM(getTeam()).isProjectMaxedOut(eProject))
	{
		return false;
	}

	if(!bTestVisible)
	{
		// Resource Requirements
		ResourceTypes eResource;
		int iNumResource;
		for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
		{
			eResource = (ResourceTypes) iResourceLoop;
			iNumResource = pProjectInfo.GetResourceQuantityRequirement(eResource);

			if(iNumResource > 0)
			{
				if(getNumResourceAvailable(eResource) < iNumResource)
				{
					return false;
				}
			}
		}

		if(GC.getGame().isProjectMaxedOut(eProject, (GET_TEAM(getTeam()).getProjectMaking(eProject) + ((bContinue) ? -1 : 0))))
		{
			return false;
		}

		if(GET_TEAM(getTeam()).isProjectMaxedOut(eProject, (GET_TEAM(getTeam()).getProjectMaking(eProject) + ((bContinue) ? -1 : 0))))
		{
			return false;
		}

		// Nukes disabled? (by UN or something)
		if(GC.getGame().isNoNukes())
		{
			if(pProjectInfo.IsAllowsNukes())
			{
				for(iI = 0; iI < GC.getNumUnitInfos(); iI++)
				{
					CvUnitEntry* pkUnitEntry = GC.getUnitInfo((UnitTypes)iI);
					if(pkUnitEntry && pkUnitEntry->GetNukeDamageLevel() != -1)
					{
						return false;
					}
				}
			}
		}

		if(pProjectInfo.GetAnyoneProjectPrereq() != NO_PROJECT)
		{
			if(GC.getGame().getProjectCreatedCount((ProjectTypes)(pProjectInfo.GetAnyoneProjectPrereq())) == 0)
			{
				return false;
			}
		}

		for(iI = 0; iI < GC.getNumProjectInfos(); iI++)
		{
			if(GET_TEAM(getTeam()).getProjectCount((ProjectTypes)iI) < pProjectInfo.GetProjectsNeeded(iI))
			{
				return false;
			}
		}
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(eProject);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if(LuaSupport::CallTestAll(pkScriptSystem, "PlayerCanCreate", args.get(), bResult))
		{
			// Check the result.
			if(bResult == false)
			{
				return false;
			}
		}
	}

	return true;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::canPrepare(SpecialistTypes eSpecialist, bool) const
{
	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(eSpecialist);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if(LuaSupport::CallTestAll(pkScriptSystem, "PlayerCanPrepare", args.get(), bResult))
		{
			// Check the result.
			if(bResult == false)
			{
				return false;
			}
		}
	}


	return false;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::canMaintain(ProcessTypes eProcess, bool) const
{
	// Check to see if it exists, scenarios can remove them and leave holes in the list.
	const CvProcessInfo* pkProcessInfo = GC.getProcessInfo(eProcess);
	if (!pkProcessInfo)
		return false;

	if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pkProcessInfo->getTechPrereq()))))
	{
		return false;
	}

	for(int iI = 0; iI < GC.getNumLeagueProjectInfos(); iI++)
	{
		LeagueProjectTypes eLeagueProject = (LeagueProjectTypes) iI;
		CvLeagueProjectEntry* pInfo = GC.getLeagueProjectInfo(eLeagueProject);
		if (pInfo && pInfo->GetProcess() == eProcess)
		{
			if (!GC.getGame().GetGameLeagues()->CanContributeToLeagueProject(GetID(), eLeagueProject))
			{
				return false;
			}
		}
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(eProcess);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if(LuaSupport::CallTestAll(pkScriptSystem, "PlayerCanMaintain", args.get(), bResult))
		{
			// Check the result.
			if(bResult == false)
			{
				return false;
			}
		}
	}

	return true;
}

//	--------------------------------------------------------------------------------
/// Can we purchase this unit or building in any of our cities?
bool CvPlayer::IsCanPurchaseAnyCity(bool bTestPurchaseCost, bool bTestTrainable, UnitTypes eUnit, BuildingTypes eBuilding, YieldTypes ePurchaseYield)
{
	int iLoop;
	CvCity *pLoopCity;

	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (pLoopCity->IsCanPurchase(bTestPurchaseCost, bTestTrainable, eUnit, eBuilding, NO_PROJECT, ePurchaseYield))
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isProductionMaxedUnitClass(UnitClassTypes eUnitClass) const
{
	if(eUnitClass == NO_UNITCLASS)
	{
		return false;
	}

	if(GC.getGame().isUnitClassMaxedOut(eUnitClass))
	{
		return true;
	}

	if(GET_TEAM(getTeam()).isUnitClassMaxedOut(eUnitClass))
	{
		return true;
	}

	if(isUnitClassMaxedOut(eUnitClass))
	{
		return true;
	}

	return false;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isProductionMaxedBuildingClass(BuildingClassTypes eBuildingClass, bool bAcquireCity) const
{
	if(eBuildingClass == NO_BUILDINGCLASS)
	{
		return false;
	}

	CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
	if(pkBuildingClassInfo == NULL)
	{
		return false;
	}

	if(!bAcquireCity)
	{
		if(GC.getGame().isBuildingClassMaxedOut(eBuildingClass))
		{
			return true;
		}
	}

	if(GET_TEAM(getTeam()).isBuildingClassMaxedOut(eBuildingClass))
	{
		return true;
	}

	if(isBuildingClassMaxedOut(eBuildingClass, ((bAcquireCity) ? pkBuildingClassInfo->getExtraPlayerInstances() : 0)))
	{
		return true;
	}

	return false;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isProductionMaxedProject(ProjectTypes eProject) const
{
	if(eProject == NO_PROJECT)
	{
		return false;
	}

	if(GC.getGame().isProjectMaxedOut(eProject))
	{
		return true;
	}

	if(GET_TEAM(getTeam()).isProjectMaxedOut(eProject))
	{
		return true;
	}

	return false;
}


//	--------------------------------------------------------------------------------
int CvPlayer::getProductionNeeded(UnitTypes eUnit) const
{
	CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eUnit);

	CvAssertMsg(pkUnitEntry, "This should never be hit");
	if(pkUnitEntry == NULL)
		return 0;

	UnitClassTypes eUnitClass = (UnitClassTypes)pkUnitEntry->GetUnitClassType();
	CvAssert(NO_UNITCLASS != eUnitClass);

	CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
	CvAssert(pkUnitClassInfo);
	if(pkUnitClassInfo == NULL)
		return 0;

	int iProductionNeeded = pkUnitEntry->GetProductionCost();
	iProductionNeeded *= 100 + getUnitClassCount(eUnitClass) * pkUnitClassInfo->getInstanceCostModifier();
	iProductionNeeded /= 100;

	if(isMinorCiv())
	{
		iProductionNeeded *= GC.getMINOR_CIV_PRODUCTION_PERCENT();
		iProductionNeeded /= 100;
	}

	iProductionNeeded *= GC.getUNIT_PRODUCTION_PERCENT();
	iProductionNeeded /= 100;

	iProductionNeeded *= GC.getGame().getGameSpeedInfo().getTrainPercent();
	iProductionNeeded /= 100;

	iProductionNeeded *= GC.getGame().getStartEraInfo().getTrainPercent();
	iProductionNeeded /= 100;

	if(!isHuman() && !IsAITeammateOfHuman() && !isBarbarian())
	{
		if(isWorldUnitClass(eUnitClass))
		{
			iProductionNeeded *= GC.getGame().getHandicapInfo().getAIWorldTrainPercent();
			iProductionNeeded /= 100;
		}
		else
		{
			iProductionNeeded *= GC.getGame().getHandicapInfo().getAITrainPercent();
			iProductionNeeded /= 100;
		}

		iProductionNeeded *= std::max(0, ((GC.getGame().getHandicapInfo().getAIPerEraModifier() * GetCurrentEra()) + 100));
		iProductionNeeded /= 100;
	}

	iProductionNeeded += getUnitExtraCost(eUnitClass);

	return std::max(1, iProductionNeeded);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getProductionNeeded(BuildingTypes eBuilding) const
{
	int iProductionNeeded;

	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if(pkBuildingInfo == NULL)
	{
		//This should never happen.
		return 1;
	}

	iProductionNeeded = pkBuildingInfo->GetProductionCost();

	if(pkBuildingInfo->GetNumCityCostMod() > 0 && getNumCities() > 0)
	{
		iProductionNeeded += (pkBuildingInfo->GetNumCityCostMod() * getNumCities());
	}
#if defined(MOD_BALANCE_CORE_WONDER_COST_INCREASE)
	if(MOD_BALANCE_CORE_WONDER_COST_INCREASE && isWorldWonderClass(pkBuildingInfo->GetBuildingClassInfo()))
	{
		int iNumWorldWonderPercent = 0;
		const CvCity* pLoopCity;
		int iLoop;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity->getNumWorldWonders() > 0)
			{
				for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
				{
					const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
					CvBuildingEntry* pkeBuildingInfo = GC.getBuildingInfo(eBuilding);
				
					// Has this Building
					if(pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
					{
						if(isWorldWonderClass(pkeBuildingInfo->GetBuildingClassInfo()))
						{
							if(pkeBuildingInfo->GetPrereqAndTech() != NO_TECH)
							{
								CvTechEntry* pkTechInfo = GC.getTechInfo((TechTypes)pkeBuildingInfo->GetPrereqAndTech());
								if(pkTechInfo)
								{
									// Loop through all eras and apply Building production mod based on how much time has passed
									EraTypes eBuildingUnlockedEra = (EraTypes) pkTechInfo->GetEra();

									if(eBuildingUnlockedEra == GetCurrentEra())
									{
										iNumWorldWonderPercent += GC.getBALANCE_CORE_WORLD_WONDER_SAME_ERA_COST_MODIFIER();
									}
									else if((GetCurrentEra() - eBuildingUnlockedEra) == 1)
									{
										iNumWorldWonderPercent += GC.getBALANCE_CORE_WORLD_WONDER_PREVIOUS_ERA_COST_MODIFIER();
									}
									else if((GetCurrentEra() - eBuildingUnlockedEra) > 1)
									{
										iNumWorldWonderPercent += GC.getBALANCE_CORE_WORLD_WONDER_EARLIER_ERA_COST_MODIFIER();
									}
								}
							}
						}
					}
				}
			}
		}
		if(iNumWorldWonderPercent > 0)
		{
			iProductionNeeded *= (100 + iNumWorldWonderPercent);
			iProductionNeeded /= 100;
		}
	}
#endif

	if(isMinorCiv())
	{
		iProductionNeeded *= GC.getMINOR_CIV_PRODUCTION_PERCENT();
		iProductionNeeded /= 100;
	}

	iProductionNeeded *= GC.getBUILDING_PRODUCTION_PERCENT();
	iProductionNeeded /= 100;

	iProductionNeeded *= GC.getGame().getGameSpeedInfo().getConstructPercent();
	iProductionNeeded /= 100;

	iProductionNeeded *= GC.getGame().getStartEraInfo().getConstructPercent();
	iProductionNeeded /= 100;

	if(pkBuildingInfo->GetPrereqAndTech() != NO_TECH)
	{
		CvTechEntry* pkTechInfo = GC.getTechInfo((TechTypes)pkBuildingInfo->GetPrereqAndTech());
		if(pkTechInfo)
		{
			// Loop through all eras and apply Building production mod based on how much time has passed
			int iTotalEraMod = 100;
			EraTypes eBuildingUnlockedEra = (EraTypes) pkTechInfo->GetEra();

			if(eBuildingUnlockedEra < GetCurrentEra())
			{
				for(int iLoop = eBuildingUnlockedEra; iLoop < GetCurrentEra(); iLoop++)
				{
					CvAssertMsg(iLoop >= 0, "Loop should be within era bounds");
					CvAssertMsg(iLoop <GC.getNumEraInfos(), "Loop should be within era bounds");

					if(iLoop >= 0 && iLoop < GC.getNumEraInfos())
					{
						CvEraInfo* pkEraInfo = GC.getEraInfo((EraTypes)iLoop);
						if(pkEraInfo)
						{
							iTotalEraMod += pkEraInfo->getLaterEraBuildingConstructMod();
						}
					}
				}

				// Don't make a change if there's no change to make
				if(iTotalEraMod != 100)
				{
					iProductionNeeded *= iTotalEraMod;
					iProductionNeeded /= 100;
				}
			}
		}
	}

	if(!isHuman() && !IsAITeammateOfHuman() && !isBarbarian())
	{
		if(isWorldWonderClass(pkBuildingInfo->GetBuildingClassInfo()))
		{
			iProductionNeeded *= GC.getGame().getHandicapInfo().getAIWorldConstructPercent();
			iProductionNeeded /= 100;
		}
		else
		{
			iProductionNeeded *= GC.getGame().getHandicapInfo().getAIConstructPercent();
			iProductionNeeded /= 100;
		}

		iProductionNeeded *= std::max(0, ((GC.getGame().getHandicapInfo().getAIPerEraModifier() * GetCurrentEra()) + 100));
		iProductionNeeded /= 100;
	}

	return std::max(1, iProductionNeeded);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getProductionNeeded(ProjectTypes eProject) const
{
	int iProductionNeeded;

	iProductionNeeded = GC.getProjectInfo(eProject)->GetProductionCost();

	if(isMinorCiv())
	{
		iProductionNeeded *= GC.getMINOR_CIV_PRODUCTION_PERCENT();
		iProductionNeeded /= 100;
	}

	iProductionNeeded *= GC.getPROJECT_PRODUCTION_PERCENT();
	iProductionNeeded /= 100;

	iProductionNeeded *= GC.getGame().getGameSpeedInfo().getCreatePercent();
	iProductionNeeded /= 100;

	iProductionNeeded *= GC.getGame().getStartEraInfo().getCreatePercent();
	iProductionNeeded /= 100;

	if(!isHuman() && !IsAITeammateOfHuman() && !isBarbarian())
	{
		if(isWorldProject(eProject))
		{
			iProductionNeeded *= GC.getGame().getHandicapInfo().getAIWorldCreatePercent();
			iProductionNeeded /= 100;
		}
		else
		{
			iProductionNeeded *= GC.getGame().getHandicapInfo().getAICreatePercent();
			iProductionNeeded /= 100;
		}

		iProductionNeeded *= std::max(0, ((GC.getGame().getHandicapInfo().getAIPerEraModifier() * GetCurrentEra()) + 100));
		iProductionNeeded /= 100;
	}

	return std::max(1, iProductionNeeded);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionNeeded(SpecialistTypes eSpecialist) const
{
	CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
	if(pkSpecialistInfo == NULL)
	{
		//This should never happen! If this does, fix the calling function!
		CvAssert(pkSpecialistInfo);
		return 0;
	}

	int iProductionNeeded;
	iProductionNeeded = pkSpecialistInfo->getCost();

	if(isMinorCiv())
	{
		iProductionNeeded *= GC.getMINOR_CIV_PRODUCTION_PERCENT();
		iProductionNeeded /= 100;
	}

	iProductionNeeded *= GC.getGame().getGameSpeedInfo().getCreatePercent();
	iProductionNeeded /= 100;

	iProductionNeeded *= GC.getGame().getStartEraInfo().getCreatePercent();
	iProductionNeeded /= 100;

	return std::max(1, iProductionNeeded);
}

#if defined(MOD_PROCESS_STOCKPILE)
//	--------------------------------------------------------------------------------
int CvPlayer::getMaxStockpile() const
{
	// The default of 30 hammers means a city can stockpile between 15% and 30% of the production of a World Wonder
	int iProdPerEra = gCustomMods.getOption("PROCESS_STOCKPILE_PER_ERA", 30);
	// Adjust for game speed
	iProdPerEra *= GC.getGame().getGameSpeedInfo().getConstructPercent();

	return ((GetCurrentEra() + 1) * iProdPerEra) / 100;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionModifier(CvString* toolTipSink) const
{
	int iMultiplier = 0;

	int iTempMod;

	// Unit Supply
	iTempMod = GetUnitProductionMaintenanceMod();
	iMultiplier += iTempMod;
	GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_UNIT_SUPPLY", iTempMod);

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionModifier(UnitTypes eUnit, CvString* toolTipSink) const
{
	int iMultiplier = getProductionModifier(toolTipSink);
	int iTempMod;

	CvUnitEntry* pUnitEntry = GC.getUnitInfo(eUnit);

	if(pUnitEntry)
	{
		// Military bonus
		if(pUnitEntry->IsMilitaryProduction())
		{
			iTempMod = getMilitaryProductionModifier();
			iMultiplier += iTempMod;
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_MILITARY_PLAYER", iTempMod);
		}

		// Settler bonus
		if(pUnitEntry->IsFound())
		{
			iTempMod = getSettlerProductionModifier();
			iMultiplier += iTempMod;
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_SETTLER_PLAYER", iTempMod);
		}

		// Unit Combat class bonus
		if(pUnitEntry->GetUnitCombatType() != NO_UNITCOMBAT)
		{
			iTempMod = getUnitCombatProductionModifiers((UnitCombatTypes) pUnitEntry->GetUnitCombatType());
			iMultiplier += iTempMod;
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_UNIT_COBMAT_CLASS_PLAYER", iTempMod);
		}

		// Trait bonus
		CvPlayerTraits* pPlayerTraits = GetPlayerTraits();
		std::vector<TraitTypes> vTraits = pPlayerTraits->GetPotentiallyActiveTraits();
		for(size_t iI = 0; iI < vTraits.size(); iI++)
		{
			if(pPlayerTraits->HasTrait(vTraits[iI]))
			{
				iMultiplier += pUnitEntry->GetProductionTraits(iI);

				if(pUnitEntry->GetSpecialUnitType() != NO_SPECIALUNIT)
				{
					CvSpecialUnitInfo* pkSpecialUnitInfo = GC.getSpecialUnitInfo((SpecialUnitTypes) pUnitEntry->GetSpecialUnitType());
					if(pkSpecialUnitInfo)
					{
						iTempMod = pkSpecialUnitInfo->getProductionTraits(iI);
						iMultiplier += iTempMod;
						GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_UNIT_TRAIT", iTempMod);
					}
				}
			}
		}
	}

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionModifier(BuildingTypes eBuilding, CvString* toolTipSink) const
{
	int iMultiplier = getProductionModifier(toolTipSink);
	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if(pkBuildingInfo == NULL)
	{
		return iMultiplier;
	}

	CvGame& kGame = GC.getGame();
	const CvBuildingClassInfo& kBuildingClassInfo = pkBuildingInfo->GetBuildingClassInfo();

	int iTempMod;

	CvPlayerTraits* pPlayerTraits = GetPlayerTraits();
	std::vector<TraitTypes> vTraits = pPlayerTraits->GetPotentiallyActiveTraits();
	for(size_t iI = 0; iI < vTraits.size(); iI++)
	{
		if(pPlayerTraits->HasTrait(vTraits[iI]))
		{
			iTempMod = pkBuildingInfo->GetProductionTraits(iI);
			iMultiplier += iTempMod;
			kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_BUILDING_TRAIT", iTempMod);
		}
	}

	// World Wonder
	if(::isWorldWonderClass(kBuildingClassInfo))
	{
		iTempMod = getMaxGlobalBuildingProductionModifier();
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WORLD_WONDER_PLAYER", iTempMod);
		iTempMod = m_pPlayerPolicies->GetNumericModifier(POLICYMOD_WONDER_PRODUCTION_MODIFIER);
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_POLICY", iTempMod);
	}

	// Team Wonder
	else if(::isTeamWonderClass(kBuildingClassInfo))
	{
		iTempMod = getMaxTeamBuildingProductionModifier();
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_TEAM_WONDER_PLAYER", iTempMod);
		iTempMod = m_pPlayerPolicies->GetNumericModifier(POLICYMOD_WONDER_PRODUCTION_MODIFIER);
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_POLICY", iTempMod);
	}

	// National Wonder
	else if(::isNationalWonderClass(kBuildingClassInfo))
	{
		iTempMod = getMaxPlayerBuildingProductionModifier();
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_NATIONAL_WONDER_PLAYER", iTempMod);
		iTempMod = m_pPlayerPolicies->GetNumericModifier(POLICYMOD_WONDER_PRODUCTION_MODIFIER);
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_POLICY", iTempMod);
	}

	// Normal Building
	else
	{
		iTempMod = m_pPlayerPolicies->GetNumericModifier(POLICYMOD_BUILDING_PRODUCTION_MODIFIER);
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_BUILDING_POLICY_PLAYER", iTempMod);
	}

	// Religion
	if(pkBuildingInfo->IsReligious())
	{
		iTempMod = m_pPlayerPolicies->GetNumericModifier(POLICYMOD_RELIGION_PRODUCTION_MODIFIER);
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_RELIGION_PLAYER", iTempMod);
	}

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionModifier(ProjectTypes eProject, CvString* toolTipSink) const
{
	int iMultiplier = getProductionModifier(toolTipSink);
	int iTempMod;

	if(GC.getProjectInfo(eProject)->IsSpaceship())
	{
		iTempMod = getSpaceProductionModifier();
		iMultiplier += iTempMod;
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_SPACE_PLAYER", iTempMod);
	}

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionModifier(SpecialistTypes, CvString* toolTipSink) const
{
	int iMultiplier = getProductionModifier(toolTipSink);
	int iTempMod;

	iTempMod = getSpecialistProductionModifier();
	iMultiplier += iTempMod;
	GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_SPECIALIST_PLAYER", iTempMod);

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionModifier(ProcessTypes /*eProcess*/, CvString* toolTipSink) const
{
	int iMultiplier = getProductionModifier(toolTipSink);

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getBuildingClassPrereqBuilding(BuildingTypes eBuilding, BuildingClassTypes ePrereqBuildingClass, int iExtra) const
{
	CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
	if(pkBuilding == NULL)
	{
		CvAssertMsg(pkBuilding, "Should never happen...");
		return -1;
	}

	int iPrereqs = pkBuilding->GetPrereqNumOfBuildingClass(ePrereqBuildingClass);

	// dont bother with the rest of the calcs if we have no prereqs
	if(iPrereqs == 0)
	{
		return 0;
	}
	// -1 means Building is needed in all Cities
	else if(iPrereqs == -1)
	{
#if defined(MOD_BUILDINGS_NW_EXCLUDE_RAZING)
		BuildingTypes ePrereqBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(ePrereqBuildingClass);
#endif
		int iNonPuppetCities = 0;
		int iLoop = 0;
		const CvCity* pLoopCity = NULL;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity && !pLoopCity->IsPuppet())
			{
#if defined(MOD_BUILDINGS_NW_EXCLUDE_RAZING)
				// Don't count this city if it is being razed and doesn't already have the pre-req building
				if (!(MOD_BUILDINGS_NW_EXCLUDE_RAZING && pLoopCity->IsRazing() && pLoopCity->GetCityBuildings()->GetNumBuilding(ePrereqBuilding) == 0))
#endif
				iNonPuppetCities++;
			}
		}

		return iNonPuppetCities;
	}
	else
	{
		iPrereqs *= std::max(0, GC.getMap().getWorldInfo().getBuildingClassPrereqModifier() + 100);
		iPrereqs /= 100;
	}

	if(!isLimitedWonderClass(pkBuilding->GetBuildingClassInfo()))
	{
		BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkBuilding->GetBuildingClassType();
		iPrereqs *= (getBuildingClassCount(eBuildingClass) + iExtra + 1);
	}

	if(GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && isHuman())
	{
		iPrereqs = std::min(1, iPrereqs);
	}
#if defined(MOD_BALANCE_CORE)
	//Poor Venice got ignored here...
	if(MOD_BALANCE_CORE && GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) || GET_PLAYER(GetID()).GetPlayerTraits()->IsNoAnnexing())
	{
		iPrereqs = std::min(1, iPrereqs);
	}
#endif

	return iPrereqs;
}


//	--------------------------------------------------------------------------------
void CvPlayer::removeBuildingClass(BuildingClassTypes eBuildingClass)
{
	CvCity* pLoopCity;
	BuildingTypes eBuilding;
	int iLoop;

	eBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(eBuildingClass)));

	if(eBuilding != NO_BUILDING)
	{
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity->GetCityBuildings()->GetNumRealBuilding(eBuilding) > 0)
			{
				pLoopCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, 0);
				break;
			}
		}
	}
}

//	--------------------------------------------------------------------------------
// What is the effect of a building on the player?
void CvPlayer::processBuilding(BuildingTypes eBuilding, int iChange, bool bFirst, CvArea* pArea)
{
	int iI, iJ;

	CvBuildingEntry* pBuildingInfo = GC.getBuildingInfo(eBuilding);
	if(pBuildingInfo == NULL)
		return;

	// One-shot items
	if(bFirst && iChange > 0)
	{
		// Free Policies
		int iFreePolicies = pBuildingInfo->GetFreePolicies();
		if(iFreePolicies > 0)
			ChangeNumFreePolicies(iFreePolicies);

		int iFreeGreatPeople = pBuildingInfo->GetFreeGreatPeople();
		if(iFreeGreatPeople > 0)
			ChangeNumFreeGreatPeople(iFreeGreatPeople);

		// Golden Age
		if(pBuildingInfo->IsGoldenAge())
		{
			int iGoldenAgeTurns = getGoldenAgeLength();
#if defined(MOD_BALANCE_CORE)
			int iValue = GetGoldenAgeProgressMeter();
			changeGoldenAgeTurns(iGoldenAgeTurns, iValue);
#else
			changeGoldenAgeTurns(iGoldenAgeTurns);
#endif
		}

		// Global Pop change
		if(pBuildingInfo->GetGlobalPopulationChange() != 0)
		{
			CvCity* pLoopCity;
			int iLoop;

			for(iI = 0; iI < MAX_PLAYERS; iI++)
			{
				if(GET_PLAYER((PlayerTypes)iI).isAlive())
				{
					if(GET_PLAYER((PlayerTypes)iI).getTeam() == getTeam())
					{
						if(pBuildingInfo->IsTeamShare() || (iI == GetID()))
						{
							for(pLoopCity = GET_PLAYER((PlayerTypes)iI).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER((PlayerTypes)iI).nextCity(&iLoop))
							{
								pLoopCity->setPopulation(std::max(1, (pLoopCity->getPopulation() + iChange * GC.getBuildingInfo(eBuilding)->GetGlobalPopulationChange())));
							}
						}
					}
				}
			}
		}

		// Free techs
		if(pBuildingInfo->GetFreeTechs() > 0)
		{
			if(!isHuman())
			{
				for(iI = 0; iI < pBuildingInfo->GetFreeTechs(); iI++)
				{
					for(int iLoop = 0; iLoop < iChange; iLoop++)
						AI_chooseFreeTech();
				}
			}
			else
			{
				Localization::String localizedText = Localization::Lookup("TXT_KEY_MISC_COMPLETED_WONDER_CHOOSE_TECH");
				localizedText << pBuildingInfo->GetTextKey();
				chooseTech(pBuildingInfo->GetFreeTechs() * iChange, localizedText.toUTF8());
			}
		}
		if(pBuildingInfo->GetMedianTechPercentChange() > 0)
		{
			ChangeMedianTechPercentage(pBuildingInfo->GetMedianTechPercentChange());
		}

		if(pBuildingInfo->GetExtraSpies() > 0)
		{
			CvPlayerEspionage* pEspionage = GetEspionage();
			CvAssertMsg(pEspionage, "pEspionage is null! What's up with that?!");
			if(pEspionage)
			{
				int iNumSpies = pBuildingInfo->GetExtraSpies();
#if defined(MOD_BALANCE_CORE_SPIES)
				if (MOD_BALANCE_CORE_SPIES) {
					//Optional: Spies scaled for the number of City-States in the game.
					int iNumMinor = ((GC.getGame().GetNumMinorCivsEver() * /*15*/ GC.getBALANCE_SPY_TO_MINOR_RATIO()) / 100);
					if(iNumMinor > 1)
					{
						iNumSpies = iNumMinor;
					}
				}
#endif
				for(int i = 0; i < iNumSpies; i++)
				{
					pEspionage->CreateSpy();
				}
			}
		}

		if(pBuildingInfo->GetInstantSpyRankChange() > 0)
		{
			CvPlayerEspionage* pEspionage = GetEspionage();
			CvAssertMsg(pEspionage, "pEspionage is null! What's up with that?!");
			if(pEspionage)
			{
				for(uint ui = 0; ui < pEspionage->m_aSpyList.size(); ui++)
				{
					pEspionage->LevelUpSpy(ui);
				}
			}
		}

		if(pBuildingInfo->GetSpyRankChange() > 0)
		{
			ChangeStartingSpyRank(pBuildingInfo->GetSpyRankChange());
		}

		// Free Gold
		if(pBuildingInfo->GetGold() > 0)
			GetTreasury()->ChangeGold(pBuildingInfo->GetGold());

		// Instant Friendship change with all Minors
		int iMinorFriendshipChange = pBuildingInfo->GetMinorFriendshipChange();
		if(iMinorFriendshipChange != 0)
		{
			int iNewValue;
			iMinorFriendshipChange += 100;	// Make it a mod

			for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
			{
				iNewValue = GET_PLAYER((PlayerTypes) iMinorLoop).GetMinorCivAI()->GetBaseFriendshipWithMajorTimes100(GetID());
				iNewValue *= iMinorFriendshipChange;
				iNewValue /= 100;

				GET_PLAYER((PlayerTypes) iMinorLoop).GetMinorCivAI()->SetFriendshipWithMajorTimes100(GetID(), iNewValue);
			}
		}
	}
#if defined(MOD_BALANCE_CORE)
	for(int iDomains = 0; iDomains < NUM_DOMAIN_TYPES; iDomains++)
	{
		if((DomainTypes)iDomains != NO_DOMAIN)
		{
			if(pBuildingInfo->GetDomainFreeExperiencePerGreatWorkGlobal(iDomains) > 0)
			{
				ChangeDomainFreeExperiencePerGreatWorkGlobal((DomainTypes)iDomains, pBuildingInfo->GetDomainFreeExperiencePerGreatWorkGlobal(iDomains));
			}
		}
	}	
	if(pBuildingInfo->IsSecondaryPantheon())
	{
		ChangeSecondReligionPantheonCount((pBuildingInfo->IsSecondaryPantheon()) ? iChange : 0);
	}
	if(pBuildingInfo->GetCorporationHQID() > 0 && GetCorporateFounderID() <= 0)
	{
		SetCorporateFounderID(pBuildingInfo->GetCorporationHQID());
		SetCorporateFoundedTurn(GC.getGame().getGameTurn());
		if(GetID() == GC.getGame().getActivePlayer())
		{
			Localization::String strMessage;
			Localization::String strSummary;
			strMessage = Localization::Lookup("TXT_KEY_CORPORATION_FOUNDED");
			strMessage << (pBuildingInfo->GetTextKey());
			strSummary = Localization::Lookup("TXT_KEY_CORPORATION_FOUNDED_SUMMARY");

			CvNotifications* pNotification = GetNotifications();
			if(pNotification)
			{
				pNotification->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, -1, GetID());
			}
		}
	}
	if(pBuildingInfo->GetCorporationMaxFranchises() != 0)
	{
		ChangeCorporationMaxFranchises(pBuildingInfo->GetCorporationMaxFranchises() * iChange);
	}
	if(pBuildingInfo->IsTradeRouteInvulnerable())
	{
		SetTradeRoutesInvulnerable(true);
	}
	if(pBuildingInfo->GetTRSpeedBoost() != 0)
	{
		ChangeTRSpeedBoost(pBuildingInfo->GetTRSpeedBoost() * iChange);
	}
	if(pBuildingInfo->GetTRVisionBoost() != 0)
	{
		ChangeTRVisionBoost(pBuildingInfo->GetTRVisionBoost() * iChange);
	}
	if(pBuildingInfo->GetVotesPerGPT() != 0)
	{
		ChangeVotesPerGPT(pBuildingInfo->GetVotesPerGPT() * iChange);
	}
	if(pBuildingInfo->GetGlobalBuildingGoldMaintenanceMod() != 0)
	{
		ChangeBuildingMaintenanceMod(pBuildingInfo->GetGlobalBuildingGoldMaintenanceMod() * iChange);
	}
	if(pBuildingInfo->GetEventTourism() != 0)
	{
		ChangeEventTourism(pBuildingInfo->GetEventTourism() * iChange);
	}
	if(pBuildingInfo->GetSingleVotes() > 0)
	{
		ChangeSingleVotes(pBuildingInfo->GetSingleVotes() * iChange);
	}
	if(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS && pBuildingInfo->GetPovertyHappinessChangeBuildingGlobal() != 0)
	{
		ChangePovertyUnhappinessGlobal(pBuildingInfo->GetPovertyHappinessChangeBuildingGlobal() * iChange);
	}
	if(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS && pBuildingInfo->GetDefenseHappinessChangeBuildingGlobal() != 0)
	{
		ChangeDefenseUnhappinessGlobal(pBuildingInfo->GetDefenseHappinessChangeBuildingGlobal() * iChange);
	}
	if(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS && pBuildingInfo->GetIlliteracyHappinessChangeBuildingGlobal() != 0)
	{
		ChangeIlliteracyUnhappinessGlobal(pBuildingInfo->GetIlliteracyHappinessChangeBuildingGlobal() * iChange);
	}
	if(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS && pBuildingInfo->GetUnculturedHappinessChangeBuildingGlobal() != 0)
	{
		ChangeUnculturedUnhappinessGlobal(pBuildingInfo->GetUnculturedHappinessChangeBuildingGlobal() * iChange);
	}
	if(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS && pBuildingInfo->GetMinorityHappinessChangeBuildingGlobal() != 0)
	{
		ChangeMinorityUnhappinessGlobal(pBuildingInfo->GetMinorityHappinessChangeBuildingGlobal() * iChange);
	}
#endif

	if(pBuildingInfo->GetFreeBuildingClass() != NO_BUILDINGCLASS)
	{
		BuildingTypes eFreeBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(pBuildingInfo->GetFreeBuildingClass());
		changeFreeBuildingCount(eFreeBuilding, iChange);
	}

	// Unit upgrade cost mod
	ChangeUnitUpgradeCostMod(pBuildingInfo->GetUnitUpgradeCostMod() * iChange);

	// Policy cost mod
	ChangePolicyCostBuildingModifier(pBuildingInfo->GetPolicyCostModifier() * iChange);

	// Border growth mods
	ChangePlotCultureCostModifier(pBuildingInfo->GetGlobalPlotCultureCostModifier() * iChange);
	ChangePlotGoldCostMod(pBuildingInfo->GetGlobalPlotBuyCostModifier() * iChange);
#if defined(MOD_BUILDINGS_CITY_WORKING)
	ChangeCityWorkingChange(pBuildingInfo->GetGlobalCityWorkingChange() * iChange);
#endif

	// City Culture Mod
	ChangeJONSCultureCityModifier(pBuildingInfo->GetGlobalCultureRateModifier() * iChange);

	// Trade route gold modifier
	GetTreasury()->ChangeCityConnectionTradeRouteGoldModifier(pBuildingInfo->GetCityConnectionTradeRouteModifier() * iChange);

	// Free Promotion
	PromotionTypes eFreePromotion = (PromotionTypes) pBuildingInfo->GetFreePromotion();
	if(eFreePromotion != NO_PROMOTION)
		ChangeFreePromotionCount(eFreePromotion, iChange);

	// Free Promotion Removed
	PromotionTypes eFreePromotionRemoved = (PromotionTypes) pBuildingInfo->GetFreePromotionRemoved();
	if(eFreePromotionRemoved != NO_PROMOTION)
		ChangeFreePromotionCount(eFreePromotionRemoved, -iChange);

	// Extra Happiness Per City
	ChangeExtraHappinessPerCity(pBuildingInfo->GetHappinessPerCity() * iChange);

	// Extra Happiness Per Policy
	ChangeExtraHappinessPerXPolicies(pBuildingInfo->GetHappinessPerXPolicies() * iChange);

	// City Count Unhappiness Mod
	ChangeCityCountUnhappinessMod(pBuildingInfo->GetCityCountUnhappinessMod() * iChange);

	// Hurries
	for(iI = 0; iI < GC.getNumHurryInfos(); iI++)
	{
		changeHurryModifier((HurryTypes) iI, (pBuildingInfo->GetHurryModifier(iI) * iChange));
	}

	changeGreatPeopleRateModFromBldgs(pBuildingInfo->GetGlobalGreatPeopleRateModifier() * iChange);
	changeGreatGeneralRateModFromBldgs(pBuildingInfo->GetGreatGeneralRateModifier() * iChange);
	ChangeGreatScientistBeakerMod(pBuildingInfo->GetGreatScientistBeakerModifier() * iChange);
	ChangeGreatPersonExpendGold(pBuildingInfo->GetGreatPersonExpendGold() * iChange);
#if defined(MOD_DIPLOMACY_CITYSTATES)
	if (MOD_DIPLOMACY_CITYSTATES) ChangeGPExpendInfluence(pBuildingInfo->GetGPExpendInfluence() * iChange);
#endif
	recomputeGreatPeopleModifiers();

	changeGoldenAgeModifier(pBuildingInfo->GetGoldenAgeModifier() * iChange);
	changeFreeExperienceFromBldgs(pBuildingInfo->GetGlobalFreeExperience() * iChange);
	changeWorkerSpeedModifier(pBuildingInfo->GetWorkerSpeedModifier() * iChange);
	ChangeSpecialistCultureChange(pBuildingInfo->GetSpecialistExtraCulture() * iChange);
	changeBorderObstacleCount(pBuildingInfo->IsPlayerBorderObstacle() * iChange);

	changeSpaceProductionModifier(pBuildingInfo->GetGlobalSpaceProductionModifier() * iChange);

	for(iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		pArea->changeYieldRateModifier(GetID(), ((YieldTypes)iI), (pBuildingInfo->GetAreaYieldModifier(iI) * iChange));
		changeYieldRateModifier(((YieldTypes)iI), (pBuildingInfo->GetGlobalYieldModifier(iI) * iChange));
#if defined(MOD_BALANCE_CORE_POLICIES)
		changeYieldFromDeath(((YieldTypes)iI), (pBuildingInfo->GetYieldFromDeath(iI) * iChange));
#endif
#if defined(MOD_BALANCE_CORE)
		changeYieldGPExpend(((YieldTypes)iI), (pBuildingInfo->GetYieldFromGPExpend(iI) * iChange));
		int iMod = pBuildingInfo->GetGreatWorkYieldChange(iI) * iChange;
		if(iMod != 0)
		{
			ChangeGreatWorkYieldChange((YieldTypes)iI, iMod);
		}
#endif
	}

	for(iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
	{
		for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
		{
			changeSpecialistExtraYield(((SpecialistTypes)iI), ((YieldTypes)iJ), (pBuildingInfo->GetSpecialistYieldChange(iI, iJ) * iChange));
		}
	}

	int iOldEspionageModifier = GetEspionageModifier();
	ChangeEspionageModifier(pBuildingInfo->GetGlobalEspionageModifier() * iChange);
	if(iOldEspionageModifier != GetEspionageModifier())
	{
		int iLoop;
		CvCity* pLoopCity;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
			{
				PlayerTypes ePlayer = (PlayerTypes)ui;
				GET_PLAYER(ePlayer).GetEspionage()->UpdateCity(pLoopCity);
			}
		}
	}

	ChangeExtraLeagueVotes(pBuildingInfo->GetExtraLeagueVotes() * iChange);
#if defined(MOD_BALANCE_CORE_SPIES)
	if(MOD_BALANCE_CORE_SPIES)
	{
		if(pBuildingInfo->GetAdvancedActionGold() > 0)
		{
			changeAdvancedActionGold(pBuildingInfo->GetAdvancedActionGold() * iChange);
		}
		if(pBuildingInfo->GetAdvancedActionScience() > 0)
		{
			changeAdvancedActionScience(pBuildingInfo->GetAdvancedActionScience() * iChange);
		}
		if(pBuildingInfo->GetAdvancedActionUnrest() > 0)
		{
			changeAdvancedActionUnrest(pBuildingInfo->GetAdvancedActionUnrest() * iChange);
		}
		if(pBuildingInfo->GetAdvancedActionRebellion() > 0)
		{
			changeAdvancedActionRebellion(pBuildingInfo->GetAdvancedActionRebellion() * iChange);
		}
		if(pBuildingInfo->GetAdvancedActionGP() > 0)
		{
			changeAdvancedActionGP(pBuildingInfo->GetAdvancedActionGP() * iChange);
		}
		if(pBuildingInfo->GetAdvancedActionUnit() > 0)
		{
			changeAdvancedActionUnit(pBuildingInfo->GetAdvancedActionUnit() * iChange);
		}
		if(pBuildingInfo->GetAdvancedActionWonder() > 0)
		{
			changeAdvancedActionWonder(pBuildingInfo->GetAdvancedActionWonder() * iChange);
		}
		if(pBuildingInfo->GetAdvancedActionBuilding() > 0)
		{
			changeAdvancedActionBuilding(pBuildingInfo->GetAdvancedActionBuilding() * iChange);
		}
		if(pBuildingInfo->GetCannotFailSpies() > 0)
		{
			changeCannotFailSpies(pBuildingInfo->GetCannotFailSpies() * iChange);
		}
	}
	for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
	{
		YieldTypes eYield = (YieldTypes) iJ;
		for(int iK = 0; iK < GC.getNumImprovementInfos(); iK++)
		{
			ImprovementTypes eImprovement = (ImprovementTypes)iK;
			if(eImprovement != NO_IMPROVEMENT)
			{
				int iYieldChange = pBuildingInfo->GetImprovementYieldChangeGlobal(eImprovement, eYield);
				if(iYieldChange != 0)
				{
					ChangeImprovementExtraYield(eImprovement, eYield, (iYieldChange * iChange));
				}
			}
		}
	}

#endif
	// Loop through Cities
	int iLoop;
	CvCity* pLoopCity;
	int iBuildingCount;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		// Building modifiers
		BuildingClassTypes eBuildingClass;
		for(iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
		{
			eBuildingClass = (BuildingClassTypes) iI;

			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
			if(!pkBuildingClassInfo)
			{
				continue;
			}

			BuildingTypes eTestBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

			if(eTestBuilding != NO_BUILDING)
			{
				CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eTestBuilding);
				if(pkBuilding)
				{
					iBuildingCount = pLoopCity->GetCityBuildings()->GetNumBuilding(eTestBuilding);
					if(iBuildingCount > 0)
					{
#if !defined(MOD_API_UNIFIED_YIELDS_CONSOLIDATION)
						pLoopCity->ChangeJONSCulturePerTurnFromBuildings(pBuildingInfo->GetBuildingClassYieldChange(eBuildingClass, YIELD_CULTURE) * iBuildingCount * iChange);
#endif

						// Building Class Yield Stuff
						for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
						{
#if !defined(MOD_API_UNIFIED_YIELDS_CONSOLIDATION)
							switch(iJ)
							{
							case YIELD_CULTURE:
							{
								// Skip, handled above
								break;
							}
							case YIELD_FAITH:
							{
								pLoopCity->ChangeFaithPerTurnFromBuildings(pBuildingInfo->GetBuildingClassYieldChange(eBuildingClass, iJ) * iBuildingCount * iChange);
								break;
							}
							default:
							{
#endif
								YieldTypes eYield = (YieldTypes) iJ;
								int iYieldChange = pBuildingInfo->GetBuildingClassYieldChange(eBuildingClass, eYield);
								if(iYieldChange > 0)
								{
									pLoopCity->ChangeBaseYieldRateFromBuildings(eYield, iYieldChange * iBuildingCount * iChange);
								}
#if !defined(MOD_API_UNIFIED_YIELDS_CONSOLIDATION)
							}
							}
#endif
						}
					}
				}

			}
		}
	}
#if defined(MOD_BALANCE_CORE)
	//Refresh cache data.
	countNumBuildings(eBuilding, true);
#endif
}

//	--------------------------------------------------------------------------------
/// Get yield change from buildings for a specific building class
int CvPlayer::GetBuildingClassYieldChange(BuildingClassTypes eBuildingClass, YieldTypes eYieldType)
{
	int rtnValue = 0;

	CvBuildingXMLEntries* pBuildings = GC.GetGameBuildings();

	if(pBuildings)
	{
		for(int i = 0; i < pBuildings->GetNumBuildings(); i++)
		{
			// Do we have this building anywhere in empire?
			int iNum = countNumBuildings((BuildingTypes)i);

			if(iNum > 0)
			{
				CvBuildingEntry* pEntry = pBuildings->GetEntry(i);
				if(pEntry)
				{
					rtnValue += (pEntry->GetBuildingClassYieldChange(eBuildingClass, eYieldType) * iNum);
				}
			}
		}
	}

	return rtnValue;
}

//	--------------------------------------------------------------------------------
/// Can we eBuild on pPlot?
bool CvPlayer::canBuild(const CvPlot* pPlot, BuildTypes eBuild, bool bTestEra, bool bTestVisible, bool bTestGold, bool bTestPlotOwner) const
{
	if(!(pPlot->canBuild(eBuild, GetID(), bTestVisible, bTestPlotOwner)))
	{
		return false;
	}

	if(GC.getBuildInfo(eBuild)->getTechPrereq() != NO_TECH)
	{
		if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)GC.getBuildInfo(eBuild)->getTechPrereq())))
		{
			if((!bTestEra && !bTestVisible) || ((GetCurrentEra() + 1) < GC.getTechInfo((TechTypes) GC.getBuildInfo(eBuild)->getTechPrereq())->GetEra()))
			{
				return false;
			}
		}
	}
#if defined(MOD_BALANCE_CORE)
	if(MOD_BALANCE_CORE && GC.getBuildInfo(eBuild)->getTechObsolete() != NO_TECH)
	{
		if((GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)GC.getBuildInfo(eBuild)->getTechObsolete())))
		{
			return false;
		}
	}
#endif


	// Is this an improvement that is only useable by a specific civ?
	ImprovementTypes eImprovement = (ImprovementTypes)GC.getBuildInfo(eBuild)->getImprovement();
	if(eImprovement != NO_IMPROVEMENT)
	{
		CvImprovementEntry* pkEntry = GC.getImprovementInfo(eImprovement);
		if(pkEntry->IsSpecificCivRequired())
		{
			CivilizationTypes eCiv = pkEntry->GetRequiredCivilization();
			if(eCiv != getCivilizationType())
			{
				return false;
			}
		}
	}

	if(!bTestVisible)
	{
		if(IsBuildBlockedByFeature(eBuild, pPlot->getFeatureType()))
		{
			return false;
		}

		if(bTestGold)
		{
			if(std::max(0, GetTreasury()->GetGold()) < getBuildCost(pPlot, eBuild))
			{
				return false;
			}
		}
	}

	return true;
}

//	--------------------------------------------------------------------------------
/// Are we prevented from eBuild-ing because of a Feature on this plot?
bool CvPlayer::IsBuildBlockedByFeature(BuildTypes eBuild, FeatureTypes eFeature) const
{
	// No Feature here to block us
	if(eFeature == NO_FEATURE)
	{
		return false;
	}

	// Build does not remove the Feature on pPlot
	if(!GC.getBuildInfo(eBuild)->isFeatureRemove(eFeature))
	{
		return false;
	}

	TechTypes ePrereqTech = (TechTypes) GC.getBuildInfo(eBuild)->getFeatureTech(eFeature);

	// Clearing Feature doesn't require any Tech, so we can do it right now if we have to
	if(ePrereqTech == NO_TECH)
	{
		return false;
	}

	// Clearing eFeature requires a Tech, but we have it
	if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech(ePrereqTech))
	{
		return false;
	}

	// Feature is blocking us!
	return true;
}

//	--------------------------------------------------------------------------------
// Returns the cost
int CvPlayer::getBuildCost(const CvPlot* pPlot, BuildTypes eBuild) const
{
	CvAssert(eBuild >= 0 && eBuild < GC.getNumBuildInfos());


	CvBuildInfo* pkBuildInfo = GC.getBuildInfo(eBuild);
	if(pkBuildInfo == NULL)
	{
		return 0;
	}

	if(pPlot->getBuildProgress(eBuild) > 0)
	{
		return 0;
	}

	if(pPlot->getRouteType() != NO_ROUTE && pPlot->getRouteType() == pkBuildInfo->getRoute() && pPlot->IsRoutePillaged())
	{
		return 0;
	}

	int iBuildCost = pkBuildInfo->getCost();

	// Cost increases as more Improvements are built
	iBuildCost += (getTotalImprovementsBuilt() * pkBuildInfo->getCostIncreasePerImprovement());

	iBuildCost *= (100 + getImprovementCostModifier());
	iBuildCost /= 100;

	if(pPlot->getFeatureType() != NO_FEATURE)
	{
		iBuildCost += pkBuildInfo->getFeatureCost(pPlot->getFeatureType());
	}

	iBuildCost *= getHandicapInfo().getImprovementCostPercent();
	iBuildCost /= 100;

	iBuildCost *= GC.getGame().getGameSpeedInfo().getImprovementPercent();
	iBuildCost /= 100;

	return std::max(0, iBuildCost);
}


//	--------------------------------------------------------------------------------
RouteTypes CvPlayer::getBestRoute(CvPlot* pPlot) const
{
	if (pPlot==NULL)
		return GET_TEAM(getTeam()).GetBestPossibleRoute();

	RouteTypes eRoute;
	RouteTypes eBestRoute;
	int iValue;
	int iBestValue;
	int iI;

	iBestValue = 0;
	eBestRoute = NO_ROUTE;

	for(iI = 0; iI < GC.getNumBuildInfos(); iI++)
	{
		const BuildTypes eBuild = static_cast<BuildTypes>(iI);
		CvBuildInfo* pkBuildInfo = GC.getBuildInfo(eBuild);
		if(pkBuildInfo)
		{
			eRoute = ((RouteTypes)(pkBuildInfo->getRoute()));
			if(eRoute != NO_ROUTE)
			{
				CvRouteInfo* pkRouteInfo = GC.getRouteInfo(eRoute);
				if(pkRouteInfo)
				{
					if( (pPlot->getRouteType() == eRoute) || canBuild(pPlot, eBuild) )
					{
#if defined(MOD_BALANCE_CORE)
						if(MOD_BALANCE_CORE && pkBuildInfo->getTechObsolete() == NO_TECH)
						{
							iValue = pkRouteInfo->getValue();
						}
						else if(MOD_BALANCE_CORE && !GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pkBuildInfo->getTechObsolete())))
						{
							iValue = pkRouteInfo->getValue();
						}
						else
						{
							iValue = 0;
						}
#else
						iValue = pkRouteInfo->getValue();
#endif
						if(iValue > iBestValue)
						{
							iBestValue = iValue;
							eBestRoute = eRoute;
						}

					}
				}
			}
		}
	}

	return eBestRoute;
}


//	--------------------------------------------------------------------------------
int CvPlayer::getImprovementUpgradeRate() const
{
	int iRate;

	iRate = 100; // XXX

	iRate *= std::max(0, (getImprovementUpgradeRateModifier() + 100));
	iRate /= 100;

	return iRate;
}

//	--------------------------------------------------------------------------------
/// How much Production do we get from removing ANY Feature in the game? (Policy Bonus)
int CvPlayer::GetAllFeatureProduction() const
{
	return m_iAllFeatureProduction;
}

//	--------------------------------------------------------------------------------
/// Changes how much Production we get from removing ANY Feature in the game (Policy Bonus)
void CvPlayer::ChangeAllFeatureProduction(int iChange)
{
	if(iChange != 0)
	{
		m_iAllFeatureProduction += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// How far a tile is from a city (1-3) This is used to determine camera zoom on the city view
int CvPlayer::GetCityDistanceHighwaterMark() const
{
	return m_iCityDistanceHighwaterMark;
}

//	--------------------------------------------------------------------------------
/// Set how far a tile is from a city (1-3) This is used to determine camera zoom on the city view
void CvPlayer::SetCityDistanceHighwaterMark(int iNewValue)
{
	m_iCityDistanceHighwaterMark = iNewValue;
}


//	--------------------------------------------------------------------------------
int CvPlayer::calculateTotalYield(YieldTypes eYield) const
{
#if defined(MOD_API_UNIFIED_YIELDS)
	// This is based on the switch in CvEconomicAI::LogMonitor() that calls different methods for culture and faith
	// I've added this here as a "safe guard"
	if (eYield == YIELD_CULTURE) 
	{
		return GetTotalJONSCulturePerTurn();
	} 
	else if (eYield == YIELD_FAITH) 
	{
		return GetTotalFaithPerTurn();
	}
	else if(eYield == YIELD_TOURISM)
	{
		return GetCulture()->GetTourism();
	}
#endif

	const CvCity* pLoopCity;
	int iTotalYield = 0;
	int iLoop = 0;
	
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iTotalYield += pLoopCity->getYieldRateTimes100(eYield, false);
	}

	return iTotalYield / 100;
}

//	--------------------------------------------------------------------------------
/// How much does Production is being eaten up by Units? (cached)
int CvPlayer::GetUnitProductionMaintenanceMod() const
{
	// Kind of a cop-out, but it fixes some bugs for now
	return calculateUnitProductionMaintenanceMod();
}

//	--------------------------------------------------------------------------------
/// How much does Production is being eaten up by Units? (update cache)
void CvPlayer::UpdateUnitProductionMaintenanceMod()
{
	m_iUnitProductionMaintenanceMod = calculateUnitProductionMaintenanceMod();

	if(GetID() == GC.getGame().getActivePlayer())
	{
		GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
	}
}

//	--------------------------------------------------------------------------------
/// How much does Production is being eaten up by Units?
int CvPlayer::calculateUnitProductionMaintenanceMod() const
{
	int iPaidUnits = GetNumUnitsOutOfSupply();

	// Example: Player can support 8 Units, he has 12. 4 * 10 means he loses 40% of his Production
	int iMaintenanceMod = min(/*70*/ GC.getMAX_UNIT_SUPPLY_PRODMOD(), iPaidUnits * 10);
	iMaintenanceMod = -iMaintenanceMod;

	return iMaintenanceMod;
}

//	--------------------------------------------------------------------------------
/// How many Units can we support for free without paying Production?
int CvPlayer::GetNumUnitsSupplied() const
{
	int iFreeUnits = GetNumUnitsSuppliedByHandicap();
	iFreeUnits += GetNumUnitsSuppliedByCities();
	iFreeUnits += GetNumUnitsSuppliedByPopulation();

	if(!isMinorCiv() && !isHuman() && !IsAITeammateOfHuman())
	{
		int iMod = (100 + GC.getGame().getHandicapInfo().getAIUnitSupplyPercent());
		iFreeUnits *= iMod;
		iFreeUnits /= 100;
	}

	return iFreeUnits;
}

//	--------------------------------------------------------------------------------
/// Units supplied from Difficulty Level
int CvPlayer::GetNumUnitsSuppliedByHandicap() const
{
#if defined(MOD_TRAITS_EXTRA_SUPPLY)
	// Don't need a test here for MOD_TRAITS_EXTRA_SUPPLY being enabled, as if it isn't GetExtraSupply() will return 0
	return getHandicapInfo().getProductionFreeUnits() + m_pTraits->GetExtraSupply();
#else
	return getHandicapInfo().getProductionFreeUnits();
#endif
}

//	--------------------------------------------------------------------------------
/// Units supplied from Difficulty Level
int CvPlayer::GetNumUnitsSuppliedByCities() const
{
#if defined(MOD_TRAITS_EXTRA_SUPPLY)
	// Don't need a test here for MOD_TRAITS_EXTRA_SUPPLY being enabled, as if it isn't GetExtraSupply() will return 0
	return (getHandicapInfo().getProductionFreeUnitsPerCity() + m_pTraits->GetExtraSupply()) * getNumCities();
#else
	return getHandicapInfo().getProductionFreeUnitsPerCity() * getNumCities();
#endif
}

//	--------------------------------------------------------------------------------
/// Units supplied from Difficulty Level
int CvPlayer::GetNumUnitsSuppliedByPopulation() const
{
#if defined(MOD_TRAITS_EXTRA_SUPPLY)
	// Don't need a test here for MOD_TRAITS_EXTRA_SUPPLY being enabled, as if it isn't GetExtraSupply() will return 0
	return getTotalPopulation() * (getHandicapInfo().getProductionFreeUnitsPopulationPercent() + m_pTraits->GetExtraSupplyPerPopulation()) / 100;
#else
	rturn getTotalPopulation() * getHandicapInfo().getProductionFreeUnitsPopulationPercent() / 100;
#endif
}

//	--------------------------------------------------------------------------------
/// How much Units are eating Production?
int CvPlayer::GetNumUnitsOutOfSupply() const
{
	int iFreeUnits = GetNumUnitsSupplied();
	int iNumUnits = getNumUnits();

	int iNumTradeUnits = 0;
	int iLoop = 0;
	const CvUnit* pLoopUnit = NULL;
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
#if defined(MOD_BALANCE_CORE)
		if(pLoopUnit->isTrade() || pLoopUnit->IsCivilianUnit())
#else
		if(pLoopUnit->isTrade())
#endif
		{
			iNumTradeUnits++;
		}
	}
#if defined(MOD_UNITS_NO_SUPPLY)
	if (MOD_UNITS_NO_SUPPLY) {
		for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		{
			if(pLoopUnit->isNoSupply())
			{
				iFreeUnits++;
			}
		}
	}
#endif
	int iNumUnitsToSupply = iNumUnits - iNumTradeUnits;
	return std::max(0, iNumUnitsToSupply - iFreeUnits);
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvPlayer::getNumUnitsNoCivilian() const
{
	int iNumUnits = getNumUnits();

	int iNumTradeUnits = 0;
	int iLoop = 0;
	const CvUnit* pLoopUnit = NULL;
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->isTrade() || pLoopUnit->IsCivilianUnit())
		{
			iNumTradeUnits++;
		}
	}

	int iNumUnitsToSupply = iNumUnits - iNumTradeUnits;
	return iNumUnitsToSupply;
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::calculateUnitCost() const
{
	int iFreeUnits;
	int iPaidUnits;
	int iBaseUnitCost;
	int iExtraCost;

	return GetTreasury()->CalculateUnitCost(iFreeUnits, iPaidUnits, iBaseUnitCost, iExtraCost);
}

//	--------------------------------------------------------------------------------
int CvPlayer::calculateUnitSupply() const
{
	int iPaidUnits;
	int iBaseSupplyCost;

	return GetTreasury()->CalculateUnitSupply(iPaidUnits, iBaseSupplyCost);
}

//	--------------------------------------------------------------------------------
int CvPlayer::calculateResearchModifier(TechTypes eTech)
{
	int iModifier = 100;

	if(NO_TECH == eTech)
	{
		return iModifier;
	}

	int iKnownCount = 0;
	int iPossibleKnownCount = 0;
	for(int iI = 0; iI < MAX_CIV_TEAMS; iI++)
	{
		CvTeam& kLoopTeam = GET_TEAM((TeamTypes)iI);
		if(kLoopTeam.isAlive() && !kLoopTeam.isMinorCiv())
		{
#if defined(MOD_DIPLOMACY_TECH_BONUSES)
			bool bCouldBorrowTech;
			
			if (MOD_DIPLOMACY_TECH_BONUSES)
			{
#if defined(MOD_API_EXTENSIONS)
				if (GetEspionage()->GetNumSpies() > 0)
				{
					// We've got spies!  So we need one in a capital of a player in the other team
					bCouldBorrowTech = GET_TEAM(getTeam()).HasSpyAtTeam((TeamTypes)iI);
				}
				else
#endif
				{
					// No spies yet, so use embassy status
					bCouldBorrowTech = GET_TEAM(getTeam()).HasEmbassyAtTeam((TeamTypes)iI);
				}
			}
			else
			{
				bCouldBorrowTech = GET_TEAM(getTeam()).isHasMet((TeamTypes)iI);
			}
			
			if(bCouldBorrowTech)
#else
			if(GET_TEAM(getTeam()).isHasMet((TeamTypes)iI))
#endif
			{
				if(kLoopTeam.GetTeamTechs()->HasTech(eTech))
				{
					iKnownCount++;
				}
			}
			iPossibleKnownCount++;
		}
	}
	if(iPossibleKnownCount > 0)
	{
		iModifier += (GC.getTECH_COST_TOTAL_KNOWN_TEAM_MODIFIER() * iKnownCount) / iPossibleKnownCount;
	}

	int iPossiblePaths = 0;
	int iUnknownPaths = 0;
	for(int iI = 0; iI < GC.getNUM_OR_TECH_PREREQS(); iI++)
	{
		if(GC.getTechInfo(eTech)->GetPrereqOrTechs(iI) != NO_TECH)
		{
			if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(GC.getTechInfo(eTech)->GetPrereqOrTechs(iI)))))
			{
				iUnknownPaths++;
			}

			iPossiblePaths++;
		}
	}
	CvAssertMsg(iPossiblePaths >= iUnknownPaths, "The number of possible paths is expected to match or exceed the number of unknown ones");
	iModifier += (iPossiblePaths - iUnknownPaths) * GC.getTECH_COST_KNOWN_PREREQ_MODIFIER();

	// Leagues mod
	int iLeaguesMod = GC.getGame().GetGameLeagues()->GetResearchMod(GetID(), eTech);
	if (iLeaguesMod != 0)
	{
#if defined(MOD_DIPLOMACY_CITYSTATES_RESOLUTIONS)
		if(MOD_DIPLOMACY_CITYSTATES_RESOLUTIONS && (!isMinorCiv() && !isBarbarian()))
		{
			//Research bonus for city-state alliances
			PlayerTypes eMinor;
			int iMinorAllies = 0;
			int iLeaguesAidScience = 0;
			for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
			{
				eMinor = (PlayerTypes) iMinorLoop;
				if(GET_PLAYER(eMinor).GetMinorCivAI()->IsAllies(GetID()))
				{
					iMinorAllies++;
				}
			}
			if(iMinorAllies > 0)
			{
				//+5% Science per ally.
				iLeaguesAidScience += min(50, (iMinorAllies * /*5*/ GC.getSCHOLAR_MINOR_ALLY_MULTIPLIER()));
				SetScienceRateFromMinorAllies(iLeaguesAidScience);
				iLeaguesMod += GetScienceRateFromMinorAllies();
			}
			else
			{
				SetScienceRateFromMinorAllies(0);
			}
		}
#endif
		iModifier *= (100 + iLeaguesMod);
		iModifier /= 100;
	}

	return iModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::calculateGoldRate() const
{
	return calculateGoldRateTimes100() / 100;
}


//	--------------------------------------------------------------------------------
int CvPlayer::calculateGoldRateTimes100() const
{
	// If we're in anarchy, then no Gold is collected!
	if(IsAnarchy())
	{
		return 0;
	}

	int iRate = 0;

	iRate = GetTreasury()->CalculateBaseNetGoldTimes100();

	return iRate;
}

//	--------------------------------------------------------------------------------
int CvPlayer::unitsRequiredForGoldenAge() const
{
	return (GC.getBASE_GOLDEN_AGE_UNITS() + (getNumUnitGoldenAges() * GC.getGOLDEN_AGE_UNITS_MULTIPLIER()));
}


//	--------------------------------------------------------------------------------
int CvPlayer::unitsGoldenAgeCapable() const
{
	const CvUnit* pLoopUnit;
	int iCount;
	int iLoop;

	iCount = 0;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->isGoldenAge())
		{
			iCount++;
		}
	}

	return iCount;
}


//	--------------------------------------------------------------------------------
int CvPlayer::unitsGoldenAgeReady() const
{
	const CvUnit* pLoopUnit;
	bool* pabUnitUsed;
	int iCount;
	int iLoop;
	int iI;

	pabUnitUsed = FNEW(bool[GC.getNumUnitInfos()], c_eCiv5GameplayDLL, 0);

	for(iI = 0; iI < GC.getNumUnitInfos(); iI++)
	{
		pabUnitUsed[iI] = false;
	}

	iCount = 0;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(!(pabUnitUsed[pLoopUnit->getUnitType()]))
		{
			if(pLoopUnit->isGoldenAge())
			{
				pabUnitUsed[pLoopUnit->getUnitType()] = true;
				iCount++;
			}
		}
	}

	SAFE_DELETE_ARRAY(pabUnitUsed);

	return iCount;
}

//	--------------------------------------------------------------------------------
int CvPlayer::greatGeneralThreshold() const
{
	int iThreshold;

	iThreshold = ((/*200*/ GC.getGREAT_GENERALS_THRESHOLD() * std::max(0, (getGreatGeneralsThresholdModifier() + 100))) / 100);

	iThreshold *= GC.getGame().getGameSpeedInfo().getGreatPeoplePercent();
	iThreshold /= std::max(1, GC.getGame().getGameSpeedInfo().getTrainPercent());

	iThreshold *= GC.getGame().getStartEraInfo().getGreatPeoplePercent();
	iThreshold /= 100;

	return std::max(1, iThreshold);
}

//	--------------------------------------------------------------------------------
int CvPlayer::greatAdmiralThreshold() const
{
	int iThreshold;

	iThreshold = ((/*200*/ GC.getGREAT_GENERALS_THRESHOLD() * std::max(0, (getGreatAdmiralsThresholdModifier() + 100))) / 100);

	iThreshold *= GC.getGame().getGameSpeedInfo().getGreatPeoplePercent();
	iThreshold /= std::max(1, GC.getGame().getGameSpeedInfo().getTrainPercent());

	iThreshold *= GC.getGame().getStartEraInfo().getGreatPeoplePercent();
	iThreshold /= 100;

	return std::max(1, iThreshold);
}

//	--------------------------------------------------------------------------------
int CvPlayer::specialistYield(SpecialistTypes eSpecialist, YieldTypes eYield) const
{
	CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
	if(pkSpecialistInfo == NULL)
	{
		//This function REQUIRES a valid specialist info.
		CvAssert(pkSpecialistInfo);
		return 0;
	}

	int iRtnValue = pkSpecialistInfo->getYieldChange(eYield) + getSpecialistExtraYield(eSpecialist, eYield) + GetPlayerTraits()->GetSpecialistYieldChange(eSpecialist, eYield);
#if defined(MOD_API_UNIFIED_YIELDS)
	iRtnValue += getSpecialistYieldChange(eSpecialist, eYield);
#endif

	if (eSpecialist != GC.getDEFAULT_SPECIALIST())
	{
		iRtnValue += getSpecialistExtraYield(eYield);
	}
	return (iRtnValue);
}

//	--------------------------------------------------------------------------------
/// How much additional Yield does every City produce?
#if defined(MOD_BUGFIX_MINOR)
int CvPlayer::GetCityYieldChangeTimes100(YieldTypes eYield) const
#else
int CvPlayer::GetCityYieldChange(YieldTypes eYield) const
#endif
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiCityYieldChange[eYield];
}

//	--------------------------------------------------------------------------------
/// Changes how much additional Yield every City produces
#if defined(MOD_BUGFIX_MINOR)
void CvPlayer::ChangeCityYieldChangeTimes100(YieldTypes eYield, int iChange)
#else
void CvPlayer::ChangeCityYieldChange(YieldTypes eYield, int iChange)
#endif
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiCityYieldChange.setAt(eYield, m_aiCityYieldChange[eYield] + iChange);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
/// How much additional Yield do coastal Cities produce?
int CvPlayer::GetCoastalCityYieldChange(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiCoastalCityYieldChange[eYield];
}

//	--------------------------------------------------------------------------------
/// Changes how much additional Yield coastal Cities produce
void CvPlayer::ChangeCoastalCityYieldChange(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiCoastalCityYieldChange.setAt(eYield, m_aiCoastalCityYieldChange[eYield] + iChange);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
/// How much additional Yield does the Capital produce?
#if defined(MOD_BUGFIX_MINOR)
int CvPlayer::GetCapitalYieldChangeTimes100(YieldTypes eYield) const
#else
int CvPlayer::GetCapitalYieldChange(YieldTypes eYield) const
#endif
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiCapitalYieldChange[eYield];
}

//	--------------------------------------------------------------------------------
/// Changes how much additional Yield the Capital produces
#if defined(MOD_BUGFIX_MINOR)
void CvPlayer::ChangeCapitalYieldChangeTimes100(YieldTypes eYield, int iChange)
#else
void CvPlayer::ChangeCapitalYieldChange(YieldTypes eYield, int iChange)
#endif
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiCapitalYieldChange.setAt(eYield, m_aiCapitalYieldChange[eYield] + iChange);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
/// How much additional Yield does the Capital produce per pop?
int CvPlayer::GetCapitalYieldPerPopChange(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiCapitalYieldPerPopChange[eYield];
}

//	--------------------------------------------------------------------------------
/// Changes how much additional Yield the Capital produces per pop
void CvPlayer::ChangeCapitalYieldPerPopChange(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiCapitalYieldPerPopChange.setAt(eYield, m_aiCapitalYieldPerPopChange[eYield] + iChange);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
/// How much additional Yield does a Great Work produce?
int CvPlayer::GetGreatWorkYieldChange(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiGreatWorkYieldChange[eYield];
}

//	--------------------------------------------------------------------------------
/// Changes how much additional Yield a Great Work produces
void CvPlayer::ChangeGreatWorkYieldChange(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiGreatWorkYieldChange.setAt(eYield, m_aiGreatWorkYieldChange[eYield] + iChange);
	}
}

//	--------------------------------------------------------------------------------
CvPlot* CvPlayer::getStartingPlot() const
{
	return GC.getMap().plotCheckInvalid(m_iStartingX, m_iStartingY);
}


//	--------------------------------------------------------------------------------
void CvPlayer::setStartingPlot(CvPlot* pNewValue)
{
	CvPlot* pOldStartingPlot;

	pOldStartingPlot = getStartingPlot();

	if(pOldStartingPlot != pNewValue)
	{
		if(pOldStartingPlot != NULL)
		{
			pOldStartingPlot->area()->changeNumStartingPlots(-1);
		}

		if(pNewValue == NULL)
		{
			m_iStartingX = INVALID_PLOT_COORD;
			m_iStartingY = INVALID_PLOT_COORD;
		}
		else
		{
			m_iStartingX = pNewValue->getX();
			m_iStartingY = pNewValue->getY();

			getStartingPlot()->setStartingPlot(true);

			CvArea* pArea = getStartingPlot()->area();
			if(pArea != NULL)
				pArea->changeNumStartingPlots(1);
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getTotalPopulation() const
{
	return m_iTotalPopulation;
}


//	--------------------------------------------------------------------------------
int CvPlayer::getAveragePopulation() const
{
	if(getNumCities() == 0)
	{
		return 0;
	}

	return ((getTotalPopulation() / getNumCities()) + 1);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeTotalPopulation(int iChange)
{
	m_iTotalPopulation = (m_iTotalPopulation + iChange);
	CvAssert(getTotalPopulation() >= 0);
}


//	--------------------------------------------------------------------------------
long CvPlayer::getRealPopulation() const
{
	const CvCity* pLoopCity;
	__int64 iTotalPopulation = 0;
	int iLoop = 0;

	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iTotalPopulation += pLoopCity->getRealPopulation();
	}

	if(iTotalPopulation > INT_MAX)
	{
		iTotalPopulation = INT_MAX;
	}

	return ((long)(iTotalPopulation));
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNewCityExtraPopulation() const
{
	return m_iNewCityExtraPopulation;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNewCityExtraPopulation(int iChange)
{
	if(iChange != 0)
	{
		m_iNewCityExtraPopulation += iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetFreeFoodBox() const
{
	return m_iFreeFoodBox;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeFreeFoodBox(int iChange)
{
	if(iChange != 0)
	{
		m_iFreeFoodBox += iChange;
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getTotalLand() const
{
	return m_iTotalLand;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeTotalLand(int iChange)
{
	m_iTotalLand = (m_iTotalLand + iChange);
	CvAssert(getTotalLand() >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getTotalLandScored() const
{
	return m_iTotalLandScored;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeTotalLandScored(int iChange)
{
	if(iChange != 0)
	{
		m_iTotalLandScored = (m_iTotalLandScored + iChange);
		CvAssert(getTotalLandScored() >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Total culture per turn
#if defined(MOD_BALANCE_CORE)
int CvPlayer::GetTotalJONSCulturePerTurn(bool bIgnoreHappiness) const
#else
int CvPlayer::GetTotalJONSCulturePerTurn() const
#endif
{
	if(GC.getGame().isOption(GAMEOPTION_NO_POLICIES))
	{
		return 0;
	}

	// No culture during Anarchy
	if(IsAnarchy())
	{
		return 0;
	}

	int iCulturePerTurn = 0;

	// Culture per turn from Cities
	iCulturePerTurn += GetJONSCulturePerTurnFromCities();

	// Special bonus which adds excess Happiness to Culture?
	iCulturePerTurn += GetJONSCulturePerTurnFromExcessHappiness();

	// Trait bonus which adds Culture for trade partners? 
	iCulturePerTurn += GetJONSCulturePerTurnFromTraits();

	// Free culture that's part of the player
	iCulturePerTurn += GetJONSCulturePerTurnForFree();

	// Culture from Minor Civs
	iCulturePerTurn += GetCulturePerTurnFromMinorCivs();

	// Culture from Religion
	iCulturePerTurn += GetCulturePerTurnFromReligion();
	
	// Temporary boost from bonus turns
	iCulturePerTurn += GetCulturePerTurnFromBonusTurns();

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (MOD_DIPLOMACY_CIV4_FEATURES) {
		// We're a vassal of someone, we get x% of his science
		iCulturePerTurn += (GetYieldPerTurnFromVassals(YIELD_CULTURE));
	}
#endif

	// Golden Age bonus
	if (isGoldenAge() && !IsGoldenAgeCultureBonusDisabled())
	{
		iCulturePerTurn += ((iCulturePerTurn * GC.getGOLDEN_AGE_CULTURE_MODIFIER()) / 100);
	}
#if defined(MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	if(MOD_BALANCE_CORE_HAPPINESS_NATIONAL && !bIgnoreHappiness)
	{
		iCulturePerTurn += GetYieldPerTurnFromHappiness(YIELD_CULTURE, iCulturePerTurn);
	}
#endif

	return iCulturePerTurn;
}

//	--------------------------------------------------------------------------------
/// Culture per turn from Cities
int CvPlayer::GetJONSCulturePerTurnFromCities() const
{
	int iCulturePerTurn = 0;

	// Add in culture from Cities
	const CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iCulturePerTurn += pLoopCity->getJONSCulturePerTurn();
	}

	return iCulturePerTurn;
}

//	--------------------------------------------------------------------------------
/// Special bonus which adds excess Happiness to Culture?
int CvPlayer::GetJONSCulturePerTurnFromExcessHappiness() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS))
	{
		return 0;
	}

	if(getHappinessToCulture() != 0)
	{
		if(GetExcessHappiness() > 0)
		{
			int iFreeCulture = GetExcessHappiness() * getHappinessToCulture();
			iFreeCulture /= 100;

			return iFreeCulture;
		}
	}

	return 0;
}

//	--------------------------------------------------------------------------------
/// Trait bonus which adds Culture for trade partners? //ADDED: Culture from resources exported/imported
int CvPlayer::GetJONSCulturePerTurnFromTraits() const
{
#if defined(MOD_API_UNIFIED_YIELDS)
	return (GetYieldPerTurnFromTraits(YIELD_CULTURE) + GetYieldPerTurnFromResources(YIELD_CULTURE, false, true));
#else
	return GetPlayerTraits()->GetYieldChangePerTradePartner(YIELD_CULTURE) * GetTrade()->GetNumDifferentTradingPartners();
#endif
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Yield per turn from resources imported/exported
int CvPlayer::GetYieldPerTurnFromResources(YieldTypes eYield, bool bExported, bool bImported) const
{
	int iExport = 0;
	int iImport = 0;
	int iTotal = 0;
	int iEra = GetCurrentEra();
	if(iEra < 1)
	{
		iEra = 1;
	}
	//Let's get our total imports/exports
	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
		CvResourceInfo* pInfo = GC.getResourceInfo(eResourceLoop);
		// Is it a luxury?
		if (pInfo && pInfo->getResourceUsage() == RESOURCEUSAGE_LUXURY)
		{
			if(getResourceExport(eResourceLoop) > 0)
			{
				iExport++;
			}
			if(getResourceImport(eResourceLoop) > 0)
			{
				iImport++;
			}
			else if(getResourceFromMinors(eResourceLoop) > 0)
			{
				iImport++;
			}
			else if(getResourceSiphoned(eResourceLoop) > 0)
			{
				iImport++;
			}
		}
	}
	if(bExported)
	{
		if(GetPlayerTraits()->GetYieldFromExport(eYield) > 0)
		{
			iTotal += (iEra * iExport * GetPlayerTraits()->GetYieldFromExport(eYield));
		}
	}
	if(bImported)
	{
		if(GetPlayerTraits()->GetYieldFromImport(eYield) > 0)
		{
			iTotal += (iEra * iImport * GetPlayerTraits()->GetYieldFromImport(eYield));
		}
	}

	return iTotal;
}
#endif
//	--------------------------------------------------------------------------------
/// Culture per turn player starts with for free
int CvPlayer::GetJONSCulturePerTurnForFree() const
{
	return m_iJONSCulturePerTurnForFree;
}

//	--------------------------------------------------------------------------------
/// Culture per turn player starts with for free
void CvPlayer::ChangeJONSCulturePerTurnForFree(int iChange)
{
	if(iChange != 0)
		m_iJONSCulturePerTurnForFree += iChange;

	if(GC.getGame().getActivePlayer() == GetID())
	{
		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
	}
}

//	--------------------------------------------------------------------------------
/// DEPRECATED, use GetCulturePerTurnFromMinorCivs() instead
int CvPlayer::GetJONSCulturePerTurnFromMinorCivs() const
{
	return GetCulturePerTurnFromMinorCivs();
}

//	--------------------------------------------------------------------------------
/// DEPRECATED, value is now changed within CvMinorCivAI
void CvPlayer::ChangeJONSCulturePerTurnFromMinorCivs(int /*iChange*/)
{
	CvAssertMsg(false, "ChangeJONSCulturePerTurnFromMinorCivs called, but Anton meant to disable it");
}

//	--------------------------------------------------------------------------------
/// Culture per turn from all minor civs
int CvPlayer::GetCulturePerTurnFromMinorCivs() const
{
	int iAmount = 0;
	PlayerTypes eMinor;
	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		eMinor = (PlayerTypes) iMinorLoop;
		iAmount += GetCulturePerTurnFromMinor(eMinor);
	}

	return iAmount;
}

//	--------------------------------------------------------------------------------
// Culture per turn from a minor civ
int CvPlayer::GetCulturePerTurnFromMinor(PlayerTypes eMinor) const
{
	int iAmount = 0;

	if(GET_PLAYER(eMinor).isAlive())
	{
		// Includes flat bonus and any bonus from cultural buildings
		iAmount += GET_PLAYER(eMinor).GetMinorCivAI()->GetCurrentCultureBonus(GetID());
	}

	return iAmount;
}

//	--------------------------------------------------------------------------------
/// Culture per turn from religion
int CvPlayer::GetCulturePerTurnFromReligion() const
{
	int iOtherCulturePerTurn = 0;
	int iReligionCulturePerTurn = 0;

	// Start by seeing how much the other types are bringing in
	iOtherCulturePerTurn += GetJONSCulturePerTurnFromCities();
	iOtherCulturePerTurn += GetJONSCulturePerTurnFromExcessHappiness();
	iOtherCulturePerTurn += GetJONSCulturePerTurnForFree();
	iOtherCulturePerTurn += GetCulturePerTurnFromMinorCivs();

	// Founder beliefs
	CvGameReligions* pReligions = GC.getGame().GetGameReligions();
	ReligionTypes eFoundedReligion = GC.getGame().GetGameReligions()->GetFounderBenefitsReligion(GetID());
	if(eFoundedReligion == NO_RELIGION)
	{
		eFoundedReligion = GetReligions()->GetReligionInMostCities();
	}
	if(eFoundedReligion != NO_RELIGION)
	{
		const CvReligion* pReligion = pReligions->GetReligion(eFoundedReligion, NO_PLAYER);
		if(pReligion)
		{
#if defined(MOD_API_UNIFIED_YIELDS)
			iReligionCulturePerTurn += GetYieldPerTurnFromReligion(YIELD_CULTURE);
#else
			iReligionCulturePerTurn += pReligion->m_Beliefs.GetHolyCityYieldChange(YIELD_CULTURE);

			int iTemp = pReligion->m_Beliefs.GetYieldChangePerForeignCity(YIELD_CULTURE);
			if (iTemp > 0)
			{
				iReligionCulturePerTurn += (iTemp * GetReligions()->GetNumForeignCitiesFollowing());
			}

			iTemp = pReligion->m_Beliefs.GetYieldChangePerXForeignFollowers(YIELD_CULTURE);
			if (iTemp > 0)
			{
				int iFollowers = GetReligions()->GetNumForeignFollowers(false /*bAtPeace*/);
				if (iFollowers > 0)
				{
					iReligionCulturePerTurn += (iFollowers / iTemp);
				}
			}
#endif
			bool bAtPeace = GET_TEAM(getTeam()).getAtWarCount(false) == 0;
			int iMod = pReligion->m_Beliefs.GetPlayerCultureModifier(bAtPeace, GetID());

			if (iMod != 0)
			{
				iReligionCulturePerTurn += ((iReligionCulturePerTurn + iOtherCulturePerTurn) * iMod) / 100;
			}
			return iReligionCulturePerTurn;
		}
	}
	return 0;
}

//	--------------------------------------------------------------------------------
/// Culture from Bonus Turns
int CvPlayer::GetCulturePerTurnFromBonusTurns() const
{
	int iValue = 0;

	if (GetCultureBonusTurns() > 0)
	{
		// Start by seeing how much the other types are bringing in
		int iOtherCulturePerTurn = 0;
		iOtherCulturePerTurn += GetJONSCulturePerTurnFromCities();
		iOtherCulturePerTurn += GetJONSCulturePerTurnFromExcessHappiness();
		iOtherCulturePerTurn += GetJONSCulturePerTurnForFree();
		iOtherCulturePerTurn += GetCulturePerTurnFromMinorCivs();
		iOtherCulturePerTurn += GetCulturePerTurnFromReligion();

		iValue += ((iOtherCulturePerTurn * GC.getTEMPORARY_CULTURE_BOOST_MOD()) / 100);
	}
#if defined(MOD_BALANCE_CORE)
	if (GetCultureBonusTurnsConquest() > 0)
	{
		// Start by seeing how much the other types are bringing in
		int iOtherCulturePerTurn = 0;
		iOtherCulturePerTurn += GetJONSCulturePerTurnFromCities();
		iOtherCulturePerTurn += GetJONSCulturePerTurnFromExcessHappiness();
		iOtherCulturePerTurn += GetJONSCulturePerTurnForFree();
		iOtherCulturePerTurn += GetCulturePerTurnFromMinorCivs();
		iOtherCulturePerTurn += GetCulturePerTurnFromReligion();

		iValue += ((iOtherCulturePerTurn * 100) / 100);
	}	
#endif

	return iValue;
}

//	--------------------------------------------------------------------------------
/// Modifier for all Cities' culture
int CvPlayer::GetJONSCultureCityModifier() const
{
	return m_iJONSCultureCityModifier;
}

//	--------------------------------------------------------------------------------
/// Modifier for all Cities' culture
void CvPlayer::ChangeJONSCultureCityModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iJONSCultureCityModifier += iChange;

		if(GC.getGame().getActivePlayer() == GetID())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

#if defined(MOD_DIPLOMACY_CITYSTATES)
//	--------------------------------------------------------------------------------
/// Modifier for all Cities' culture
int CvPlayer::GetLeagueCultureCityModifier() const
{
	return m_iLeagueCultureCityModifier;
}

//	--------------------------------------------------------------------------------
/// Modifier for all Cities' culture
void CvPlayer::ChangeLeagueCultureCityModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iLeagueCultureCityModifier += iChange;

		if(GC.getGame().getActivePlayer() == GetID())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getJONSCulture() const
{
	// City States can't pick Policies, sorry!
	if(isMinorCiv())
		return 0;

	if(GC.getGame().isOption(GAMEOPTION_NO_POLICIES))
	{
		return 0;
	}

	return m_iJONSCulture;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setJONSCulture(int iNewValue)
{
	if(getJONSCulture() != iNewValue)
	{
		// Add to the total we've ever had
		if(iNewValue > m_iJONSCulture)
		{
			ChangeJONSCultureEverGenerated(iNewValue - m_iJONSCulture);
		}

		m_iJONSCulture = iNewValue;

		if(GC.getGame().getActivePlayer() == GetID())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeJONSCulture(int iChange)
{
	setJONSCulture(getJONSCulture() + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::GetJONSCultureEverGenerated() const
{
	return m_iJONSCultureEverGenerated;
}


//	--------------------------------------------------------------------------------
void CvPlayer::SetJONSCultureEverGenerated(int iNewValue)
{
	if(GetJONSCultureEverGenerated() != iNewValue)
	{
		m_iJONSCultureEverGenerated = iNewValue;
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeJONSCultureEverGenerated(int iChange)
{
	SetJONSCultureEverGenerated(GetJONSCultureEverGenerated() + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::GetJONSCulturePerCityPerTurn() const
{
	int iCulture = GetJONSCultureEverGenerated();
	int iNumCities = getNumCities();

	// Puppet Cities don't count
	iNumCities -= GetNumPuppetCities();

	int iNumTurns = GC.getGame().getElapsedGameTurns();

	if(iNumTurns == 0)
	{
		iNumTurns = 1;
	}

	int iCulturePerCityPerTurn = 100 * iCulture / iNumCities / iNumTurns;
	return iCulturePerCityPerTurn;
}

//	--------------------------------------------------------------------------------
/// Amount of extra Culture per Wonder
int CvPlayer::GetCulturePerWonder() const
{
	return m_iCulturePerWonder;
}

//	--------------------------------------------------------------------------------
/// Changes amount of extra Culture per Wonder
void CvPlayer::ChangeCulturePerWonder(int iChange)
{
	if(iChange != 0)
	{
		m_iCulturePerWonder += iChange;

		int iTotalCultureChange;

		// Loop through all Cities and change how much Culture they produce based on how many Wonders they have
		CvCity* pLoopCity;
		int iLoop;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			iTotalCultureChange = pLoopCity->getNumWorldWonders() * iChange;
			pLoopCity->ChangeJONSCulturePerTurnFromPolicies(iTotalCultureChange);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Culture multiplier for having a world wonder
int CvPlayer::GetCultureWonderMultiplier() const
{
	return m_iCultureWonderMultiplier;
}

//	--------------------------------------------------------------------------------
/// Changes amount of extra Culture per Wonder
void CvPlayer::ChangeCultureWonderMultiplier(int iChange)
{
	if(iChange != 0)
		m_iCultureWonderMultiplier += iChange;
}

//	--------------------------------------------------------------------------------
/// Amount of Culture provided for each Tech Researched
int CvPlayer::GetCulturePerTechResearched() const
{
	return m_iCulturePerTechResearched;
}

//	--------------------------------------------------------------------------------
/// Changes amount of Culture provided for each Tech Researched
void CvPlayer::ChangeCulturePerTechResearched(int iChange)
{
	if(iChange != 0)
	{
		m_iCulturePerTechResearched += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Specialist Culture Modifier
int CvPlayer::GetSpecialistCultureChange() const
{
	return m_iSpecialistCultureChange;
}

//	--------------------------------------------------------------------------------
/// Specialist Culture Modifier
void CvPlayer::ChangeSpecialistCultureChange(int iChange)
{
	if(iChange != 0)
	{
		CvCity* pLoopCity;
		int iLoop;

		int iTotalCulture = 0;

		SpecialistTypes eSpecialist;
		int iSpecialistLoop;
		int iSpecialistCount;

		// Undo old culture
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			for(iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
			{
				eSpecialist = (SpecialistTypes) iSpecialistLoop;
				iSpecialistCount = pLoopCity->GetCityCitizens()->GetSpecialistCount(eSpecialist);
				iTotalCulture += (iSpecialistCount * pLoopCity->GetCultureFromSpecialist(eSpecialist));
			}

			pLoopCity->ChangeJONSCulturePerTurnFromSpecialists(-iTotalCulture);
		}

		// CHANGE VALUE
		m_iSpecialistCultureChange += iChange;

		iTotalCulture = 0;

		// Apply new culture
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			for(iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
			{
				eSpecialist = (SpecialistTypes) iSpecialistLoop;
				iSpecialistCount = pLoopCity->GetCityCitizens()->GetSpecialistCount(eSpecialist);
				iTotalCulture += (iSpecialistCount * pLoopCity->GetCultureFromSpecialist(eSpecialist));
			}

			pLoopCity->ChangeJONSCulturePerTurnFromSpecialists(iTotalCulture);
		}
	}
}

//	--------------------------------------------------------------------------------
/// What is the sum of culture yield from the previous N turns?
/// NOTE: This uses the data tracked in recording a replay, so if replays are disabled in the future then this must change!
int CvPlayer::GetCultureYieldFromPreviousTurns(int iGameTurn, int iNumPreviousTurnsToCount)
{
	// Culture per turn yield is tracked in replay data, so use that
	int iSum = 0;
	for (int iI = 0; iI < iNumPreviousTurnsToCount; iI++)
	{
		int iTurn = iGameTurn - iI;
		if (iTurn < 0)
		{
			break;
		}

		int iTurnCulture = getReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_CULTUREPERTURN"), iTurn);
		if (iTurnCulture >= 0)
		{
			iSum += iTurnCulture;
		}
		else if (iTurnCulture == -1) // No data for this turn (ex. late era start)
		{
			iSum += (3 * GetTotalJONSCulturePerTurn());
		}
	}

	return iSum;
}

//	--------------------------------------------------------------------------------
/// Cities remaining to get a free culture building
int CvPlayer::GetNumCitiesFreeCultureBuilding() const
{
	return m_iNumCitiesFreeCultureBuilding;
}

//	--------------------------------------------------------------------------------
/// Changes number of cities remaining to get a free culture building
void CvPlayer::ChangeNumCitiesFreeCultureBuilding(int iChange)
{
	if(iChange != 0)
		m_iNumCitiesFreeCultureBuilding += iChange;
}

//	--------------------------------------------------------------------------------
/// Cities remaining to get a free culture building
int CvPlayer::GetNumCitiesFreeFoodBuilding() const
{
	return m_iNumCitiesFreeFoodBuilding;
}

//	--------------------------------------------------------------------------------
/// Changes number of cities remaining to get a free culture building
void CvPlayer::ChangeNumCitiesFreeFoodBuilding(int iChange)
{
	if(iChange != 0)
		m_iNumCitiesFreeFoodBuilding += iChange;
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Cities remaining to get a free building
int CvPlayer::GetNumCitiesFreeChosenBuilding(BuildingClassTypes eBuildingClass) const
{
	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
	CvAssertMsg(i > -1, "Index out of bounds");
	return m_paiNumCitiesFreeChosenBuilding[eBuildingClass];
}

//	--------------------------------------------------------------------------------
/// Changes number of cities remaining to get a free building
void CvPlayer::ChangeNumCitiesFreeChosenBuilding(BuildingClassTypes eBuildingClass, int iChange)
{
	m_paiNumCitiesFreeChosenBuilding.setAt(eBuildingClass, (m_paiNumCitiesFreeChosenBuilding[eBuildingClass] + iChange));
	CvAssert(GetNumCitiesFreeChosenBuilding(eBuildingClass) >= 0);
}
/// Reformation Unlock
void CvPlayer::SetReformation(bool bValue)
{
	if(m_bIsReformation != bValue)
	{
		m_bIsReformation = bValue;
	}
}

bool CvPlayer::IsReformation() const
{
	return m_bIsReformation;
}
#endif
#if defined(MOD_BALANCE_CORE_SPIES)
/// Sets how much Unhappiness we have
void CvPlayer::SetSpyCooldown(int iNewValue)
{
	if(m_iSpyCooldown != iNewValue)
	{
		m_iSpyCooldown = iNewValue;
	}
}
int CvPlayer::GetSpyCooldown() const
{
	return m_iSpyCooldown;
}
void CvPlayer::ChangeSpyCooldown(int iNewValue)
{
	SetSpyCooldown(GetSpyCooldown() + iNewValue);
}
#endif
//	--------------------------------------------------------------------------------
/// Handle earning yields from a combat win
#if defined(MOD_API_UNIFIED_YIELDS)
void CvPlayer::DoYieldsFromKill(CvUnit* pAttackingUnit, CvUnit* pDefendingUnit, int iX, int iY, int iExistingDelay)
#else
void CvPlayer::DoYieldsFromKill(UnitTypes eAttackingUnitType, UnitTypes eKilledUnitType, int iX, int iY, bool bWasBarbarian, int iExistingDelay)
#endif
{
#if defined(MOD_API_UNIFIED_YIELDS)
	UnitTypes eKilledUnitType = pDefendingUnit->getUnitType();
#endif

	int iNumBonuses = iExistingDelay; // Passed by reference below, incremented to stagger floating text in UI
#if defined(MOD_API_EXTENSIONS)
	DoUnresearchedTechBonusFromKill(pDefendingUnit, eKilledUnitType, iX, iY, iNumBonuses);
#else
	DoUnresearchedTechBonusFromKill(eKilledUnitType, iX, iY, iNumBonuses);
#endif
#if defined(MOD_BALANCE_CORE)
	//Bonus resource in a city every time you win a battle. (Rome UB)
	if(MOD_BALANCE_CORE)
	{
		doInstantYield(INSTANT_YIELD_TYPE_VICTORY);
	}
#endif
	for(int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)
	{
#if defined(MOD_API_UNIFIED_YIELDS)
#if defined(MOD_API_EXTENSIONS)
		DoYieldBonusFromKill((YieldTypes)iYield, pAttackingUnit, pDefendingUnit, eKilledUnitType, iX, iY, pDefendingUnit->isBarbarian(), iNumBonuses);
#else
		DoYieldBonusFromKill((YieldTypes)iYield, pAttackingUnit, eKilledUnitType, iX, iY, pDefendingUnit->isBarbarian(), iNumBonuses);
#endif
#else
#if defined(MOD_API_EXTENSIONS)
		DoYieldBonusFromKill((YieldTypes)iYield, eAttackingUnitType, pDefendingUnit, eKilledUnitType, iX, iY, bWasBarbarian, iNumBonuses);
#else
		DoYieldBonusFromKill((YieldTypes)iYield, eAttackingUnitType, eKilledUnitType, iX, iY, bWasBarbarian, iNumBonuses);
#endif
#endif
	}
}

//	--------------------------------------------------------------------------------
/// Apply and show a yield bonus from a combat win
/// If a bonus is applied, iNumBonuses must be incremented to stagger the UI text with other bonuses
#if defined(MOD_API_UNIFIED_YIELDS)
#if defined(MOD_API_EXTENSIONS)
void CvPlayer::DoYieldBonusFromKill(YieldTypes eYield, CvUnit* pAttackingUnit, CvUnit* pKilledUnit, UnitTypes eKilledUnitType, int iX, int iY, bool bWasBarbarian, int &iNumBonuses)
#else
void CvPlayer::DoYieldBonusFromKill(YieldTypes eYield, CvUnit* pAttackingUnit, UnitTypes eKilledUnitType, int iX, int iY, bool bWasBarbarian, int &iNumBonuses)
#endif
#else
#if defined(MOD_API_EXTENSIONS)
void CvPlayer::DoYieldBonusFromKill(YieldTypes eYield, UnitTypes eAttackingUnitType, CvUnit* pKilledUnit, UnitTypes eKilledUnitType, int iX, int iY, bool bWasBarbarian, int &iNumBonuses)
#else
void CvPlayer::DoYieldBonusFromKill(YieldTypes eYield, UnitTypes eAttackingUnitType, UnitTypes eKilledUnitType, int iX, int iY, bool bWasBarbarian, int &iNumBonuses)
#endif
#endif
{
	int iValue = 0;

	CvAssertMsg(eKilledUnitType != NO_UNIT, "Killed unit's type is NO_TYPE. Please send Anton your save file and version.");
	if (eKilledUnitType == NO_UNIT) return;

	CvUnitEntry* pkKilledUnitInfo = GC.getUnitInfo(eKilledUnitType);
	if(pkKilledUnitInfo)
	{
#if defined(MOD_API_EXTENSIONS)
		int iCombatStrength = pKilledUnit ? max(pKilledUnit->GetBaseCombatStrength(), pKilledUnit->GetBaseRangedCombatStrength()) : max(pkKilledUnitInfo->GetCombat(), pkKilledUnitInfo->GetRangedCombat());
#else
		int iCombatStrength = max(pkKilledUnitInfo->GetCombat(), pkKilledUnitInfo->GetRangedCombat());
#endif
		if(iCombatStrength > 0)
		{	
			switch(eYield)
			{
			case YIELD_FOOD:
			case YIELD_PRODUCTION:
				// Not supported, local to a city
#if defined(MOD_BALANCE_CORE)
				break;
#else
				return;
#endif

			case YIELD_GOLD:
				iValue += GetPlayerPolicies()->GetNumericModifier(POLICYMOD_GOLD_FROM_KILLS);
				break;

			case YIELD_CULTURE:
				iValue += GetPlayerTraits()->GetCultureFromKills();
				iValue += GetPlayerPolicies()->GetNumericModifier(POLICYMOD_CULTURE_FROM_KILLS);

				// Do we get it for barbarians?
				if(bWasBarbarian)
				{
					iValue += GetPlayerPolicies()->GetNumericModifier(POLICYMOD_CULTURE_FROM_BARBARIAN_KILLS);
				}
				break;

			case YIELD_FAITH:
				iValue += GetPlayerTraits()->GetFaithFromKills();

				if (eYield == YIELD_FAITH && (GC.getGame().isOption(GAMEOPTION_NO_RELIGION)))
				{
					return;
				}
				break;
			case YIELD_SCIENCE:
				break;
#if defined(MOD_API_UNIFIED_YIELDS_TOURISM)
			case YIELD_TOURISM:
				// Not supported, as not accumulated turn-on-turn
				break;
#endif
#if defined(MOD_API_UNIFIED_YIELDS_GOLDEN_AGE)
			case YIELD_GOLDEN_AGE_POINTS:
				break;
#endif
			}

#if defined(MOD_API_UNIFIED_YIELDS)
			iValue += GetYieldFromKills(eYield);
			iValue += GetPlayerTraits()->GetYieldFromKills(eYield);
			
			if (bWasBarbarian) {
				iValue += GetYieldFromBarbarianKills(eYield);
				iValue += GetPlayerTraits()->GetYieldFromBarbarianKills(eYield);
			}

			const ReligionTypes eReligion = GC.getGame().GetGameReligions()->GetFounderBenefitsReligion(GetID());
			if (eReligion >= RELIGION_PANTHEON) 
			{
				const CvReligion* pMyReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, GetID());
				if (pMyReligion) 
				{
					const CvCity* pCity = getCapitalCity();
					if(pCity && pCity->GetCityReligions()->GetNumFollowers(eReligion) > 0)
					{
						iValue += pMyReligion->m_Beliefs.GetYieldFromKills(eYield, GetID());

						if (bWasBarbarian) 
						{
							iValue += pMyReligion->m_Beliefs.GetYieldFromBarbarianKills(eYield, GetID());
						}
					}
				}
			}
			else
			{
				ReligionTypes eMajorityReligion = GetReligions()->GetReligionInMostCities();
				if (eMajorityReligion >= RELIGION_PANTHEON) 
				{
					const CvReligion* pMyReligion = GC.getGame().GetGameReligions()->GetReligion(eMajorityReligion, GetID());
					if (pMyReligion) 
					{
						const CvCity* pCity = getCapitalCity();
						if(pCity && pCity->GetCityReligions()->GetNumFollowers(eMajorityReligion) > 0)
						{
							iValue += pMyReligion->m_Beliefs.GetYieldFromKills(eYield, GetID());

							if (bWasBarbarian) 
							{
								iValue += pMyReligion->m_Beliefs.GetYieldFromBarbarianKills(eYield, GetID());
							}
						}
					}
				}
			}
#endif

			iValue += GC.getGame().GetGameReligions()->GetBeliefYieldForKill(eYield, iX, iY, GetID());

#if defined(MOD_API_UNIFIED_YIELDS)
			if(pAttackingUnit != NULL)
#else
			if(eAttackingUnitType != NO_UNIT)
#endif
			{
#if defined(MOD_API_UNIFIED_YIELDS)
				UnitTypes eAttackingUnitType = pAttackingUnit->getUnitType();
#endif
				CvUnitEntry* pkAttackingUnitInfo = GC.getUnitInfo(eAttackingUnitType);
				if(pkAttackingUnitInfo)
				{
					iValue += pkAttackingUnitInfo->GetYieldFromKills(eYield);

#if defined(MOD_API_UNIFIED_YIELDS)
					iValue += pAttackingUnit->getYieldFromKills(eYield);
					
					// Do we get it for barbarians?
					if(bWasBarbarian)
					{
						iValue += pkAttackingUnitInfo->GetYieldFromBarbarianKills(eYield);
						iValue += pAttackingUnit->getYieldFromBarbarianKills(eYield);
					}
#endif
				}
			}
#if defined(MOD_BALANCE_CORE)
			CvCity* pCity = getCapitalCity();
#endif
			iValue = (iValue * iCombatStrength) / 100;
#if defined(MOD_BALANCE_CORE)
			iValue *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iValue /= 100;
#endif
			if(iValue > 0)
			{
				switch(eYield)
				{
				case YIELD_GOLD:
					GetTreasury()->ChangeGold(iValue);
					break;
				case YIELD_CULTURE:
					changeJONSCulture(iValue);
#if defined(MOD_BALANCE_CORE)
					if(getCapitalCity() != NULL)
					{
						getCapitalCity()->ChangeJONSCultureStored(iValue);
					}
#endif
					break;
				case YIELD_FAITH:
					ChangeFaith(iValue);
					break;
#if defined(MOD_API_UNIFIED_YIELDS)
				case YIELD_GOLDEN_AGE_POINTS:
					ChangeGoldenAgeProgressMeter(iValue);
					break;
#endif
#if defined(MOD_BALANCE_CORE)
				case YIELD_FOOD:
					if(pCity != NULL)
					{
						pCity->changeFood(iValue);
					}
					break;
				case YIELD_PRODUCTION:
					if(pCity != NULL)
					{
						pCity->changeProduction(iValue);
					}
					break;
#endif
				case YIELD_SCIENCE:
					TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
					if(eCurrentTech == NO_TECH)
					{
						changeOverflowResearch(iValue);
					}
					else
					{
						GET_TEAM(getTeam()).GetTeamTechs()->ChangeResearchProgress(eCurrentTech, iValue, GetID());
					}
					break;
				}
				iNumBonuses++;
				ReportYieldFromKill(eYield, iValue, iX, iY, iNumBonuses);
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Apply and show a bonus towards unresearched tech when we defeat a unit of that tech
/// If a bonus is applied, iNumBonuses must be incremented to stagger the UI text with other bonuses
#if defined(MOD_API_EXTENSIONS)
void CvPlayer::DoUnresearchedTechBonusFromKill(CvUnit* pKilledUnit, UnitTypes eKilledUnitType, int iX, int iY, int &iNumBonuses)
#else
void CvPlayer::DoUnresearchedTechBonusFromKill(UnitTypes eKilledUnitType, int iX, int iY, int &iNumBonuses)
#endif
{
	CvAssertMsg(eKilledUnitType != NO_UNIT, "Killed unit's type is NO_TYPE. Please send Anton your save file and version.");
	if (eKilledUnitType == NO_UNIT) return;

	int iPercent = GetPlayerTraits()->GetUnresearchedTechBonusFromKills();

	if (iPercent > 0)
	{
		int iValue = 0;

		CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eKilledUnitType);
		if(pkUnitInfo)
		{
			TechTypes ePrereq = (TechTypes) pkUnitInfo->GetPrereqAndTech();
			if (ePrereq != NO_TECH)
			{
				CvTechEntry* pkTechInfo = GC.getTechInfo(ePrereq);
				if (pkTechInfo && !GET_TEAM(getTeam()).GetTeamTechs()->HasTech(ePrereq))
				{
#if defined(MOD_API_EXTENSIONS)
					int iCombatStrength = pKilledUnit ? max(pKilledUnit->GetBaseCombatStrength(), pKilledUnit->GetBaseRangedCombatStrength()) : max(pkUnitInfo->GetCombat(), pkUnitInfo->GetRangedCombat());
#else
					int iCombatStrength = max(pkUnitInfo->GetCombat(), pkUnitInfo->GetRangedCombat());
#endif
					if (iCombatStrength > 0)
					{
						int iTechCost = GetPlayerTechs()->GetResearchCost(ePrereq);
						iValue = (iTechCost * iPercent) / 100;

						// Cannot be greater than the tech's cost
						int iRemainingCost = iTechCost - GetPlayerTechs()->GetResearchProgress(ePrereq);
						if (iValue > iRemainingCost)
						{
							iValue = iRemainingCost;
						}

						if (iValue > 0)
						{
							GET_TEAM(getTeam()).GetTeamTechs()->ChangeResearchProgress(ePrereq, iValue, GetID());
							iNumBonuses++;
							ReportYieldFromKill(YIELD_SCIENCE, iValue, iX, iY, iNumBonuses);
						}
					}
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Show earning a yield from combat wins
#if defined(SHOW_PLOT_POPUP)
void CvPlayer::ReportYieldFromKill(YieldTypes eYield, int iValue, int iX, int iY, int)
#else
void CvPlayer::ReportYieldFromKill(YieldTypes eYield, int iValue, int iX, int iY, int iDelay)
#endif
{
	CvString yieldString;
	if(iValue > 0)
	{
#if defined(MOD_API_UNIFIED_YIELDS)
		CvYieldInfo* pYieldInfo = GC.getYieldInfo(eYield);
		yieldString.Format("%s+%%d[ENDCOLOR]%s", pYieldInfo->getColorString(), pYieldInfo->getIconString());
#else

		switch(eYield)
		{
		case YIELD_GOLD:
			yieldString = "[COLOR_YELLOW]+%d[ENDCOLOR][ICON_GOLD]";
			break;
		case YIELD_CULTURE:
			yieldString = "[COLOR_MAGENTA]+%d[ENDCOLOR][ICON_CULTURE]";
			break;
		case YIELD_FAITH:
			yieldString = "[COLOR_WHITE]+%d[ENDCOLOR][ICON_PEACE]";
			break;
		case YIELD_SCIENCE:
			yieldString = "[COLOR_BLUE]+%d[ENDCOLOR][ICON_RESEARCH]";
			break;
		case YIELD_FOOD:
			yieldString = "[COLOR_GREEN]+%d[ENDCOLOR][ICON_FOOD]";
			break;
		case YIELD_PRODUCTION:
			yieldString = "[COLOR_YELLOW]+%d[ENDCOLOR][ICON_PRODUCTION]";
			break;
		default:
			// Not supported
			return;
		}
#endif

		if(GetID() == GC.getGame().getActivePlayer())
		{
			char text[256] = {0};
#if !defined(SHOW_PLOT_POPUP)
			float fDelay = GC.getPOST_COMBAT_TEXT_DELAY() * (1 + ((float)iDelay * 0.5f)); // 1 is added to avoid overlapping with XP text
#if defined(MOD_BALANCE_CORE_POLICIES)
			fDelay += GC.getPOST_COMBAT_TEXT_DELAY() * (1 + ((float)iDelay * 0.5f)); // 1 is added to avoid overlapping with XP text
#endif
#endif
			sprintf_s(text, yieldString, iValue);
#if defined(SHOW_PLOT_POPUP)
			SHOW_PLOT_POPUP(GC.getMap().plot(iX, iY), NO_PLAYER, text, 0.0f);
#else
			GC.GetEngineUserInterface()->AddPopupText(iX, iY, text, fDelay);
#endif
		}
	}
}

//	--------------------------------------------------------------------------------
/// Each a technology from conquering a city
void CvPlayer::DoTechFromCityConquer(CvCity* pConqueredCity)
{
	PlayerTypes eOpponent = pConqueredCity->getOwner();
	FStaticVector<TechTypes, 128, true, c_eCiv5GameplayDLL> vePossibleTechs;
	int iCheapestTechCost = MAX_INT;
	for (int i = 0; i < GC.getNumTechInfos(); i++)
	{
		TechTypes e = (TechTypes) i;
		CvTechEntry* pInfo = GC.getTechInfo(e);
		if (pInfo)
		{
			// They have it
			if (GET_TEAM(GET_PLAYER(eOpponent).getTeam()).GetTeamTechs()->HasTech(e))
			{
				// We don't
				if (!GET_TEAM(getTeam()).GetTeamTechs()->HasTech(e))
				{
					// But we could
					if (GetPlayerTechs()->CanResearch(e))
					{
						if (pInfo->GetResearchCost() < iCheapestTechCost)
						{
							iCheapestTechCost = pInfo->GetResearchCost();
							vePossibleTechs.clear();
							vePossibleTechs.push_back(e);
						}
						else if (pInfo->GetResearchCost() == iCheapestTechCost)
						{
							vePossibleTechs.push_back(e);
						}
					}
				}
			}
		}
	}

	if (!vePossibleTechs.empty())
	{
		int iRoll = GC.getGame().getJonRandNum((int)vePossibleTechs.size(), "Rolling to choose free tech from conquering a city");
		TechTypes eFreeTech = vePossibleTechs[iRoll];
		CvAssert(eFreeTech != NO_TECH)
		if (eFreeTech != NO_TECH)
		{
			GET_TEAM(getTeam()).setHasTech(eFreeTech, true, GetID(), true, true);
			GET_TEAM(getTeam()).GetTeamTechs()->SetNoTradeTech(eFreeTech, true);
		}
	}
#if defined(MOD_BALANCE_CORE)
	else
	{
		int iEra = GetCurrentEra();
		if(iEra <= 1)
		{
			iEra = 1;
		}
		const char* strTargetNameKey = pConqueredCity->getNameKey();
		TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
		int iValue = (pConqueredCity->getPopulation() * 10 * iEra);
		iValue *= GC.getGame().getGameSpeedInfo().getTrainPercent();
		iValue /= 100;
		if(eCurrentTech == NO_TECH)
		{
			changeOverflowResearch(iValue);
		}
		else
		{
			GET_TEAM(GET_PLAYER(GetID()).getTeam()).GetTeamTechs()->ChangeResearchProgress(eCurrentTech, iValue, GetID());
		}
		if(GetID() == GC.getGame().getActivePlayer())
		{
			Localization::String strMessage;
			Localization::String strSummary;
			strMessage = Localization::Lookup("TXT_KEY_SCIENCE_BOOST_CONQUEST");
			strMessage << iValue;
			strMessage << strTargetNameKey;
			strSummary = Localization::Lookup("TXT_KEY_SCIENCE_BOOST_CONQUEST_SUMMARY");

			CvNotifications* pNotification = GetNotifications();
			if(pNotification)
			{
				pNotification->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), pConqueredCity->getX(), pConqueredCity->getY(), (int) pConqueredCity->GetID(), GetID());
			}
		}
	}
#endif
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Generate a random great work on city conquest
void CvPlayer::DoFreeGreatWorkOnConquest(PlayerTypes ePlayer, CvCity* pCity)
{
	GreatWorkSlotType eArtArtifactSlot = CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT();
	GreatWorkSlotType eMusicSlot = CvTypes::getGREAT_WORK_SLOT_MUSIC();
	GreatWorkSlotType eWritingSlot = CvTypes::getGREAT_WORK_SLOT_LITERATURE();

	int iOpenSlots = 0;
	int iStuffStolen = 0;
	CvWeightedVector<int, SAFE_ESTIMATE_NUM_BUILDINGS, true> artChoices;
	const char* strTargetNameKey = pCity->getNameKey();
	const CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iOpenSlots += pLoopCity->GetCityBuildings()->GetNumAvailableGreatWorkSlots(eArtArtifactSlot);
		iOpenSlots += pLoopCity->GetCityBuildings()->GetNumAvailableGreatWorkSlots(eMusicSlot);
		iOpenSlots += pLoopCity->GetCityBuildings()->GetNumAvailableGreatWorkSlots(eWritingSlot);
	}
	if(GET_PLAYER(ePlayer).isAlive() && !GET_PLAYER(ePlayer).isMinorCiv() && !GET_PLAYER(ePlayer).isBarbarian())
	{
		if(iOpenSlots > 0)
		{
			int iCityLoop;
			CvCity* pPlayerCity = NULL;
			int iGreatWorkIndex;	
			for (pPlayerCity = GET_PLAYER(ePlayer).firstCity(&iCityLoop); pPlayerCity != NULL; pPlayerCity = GET_PLAYER(ePlayer).nextCity(&iCityLoop))
			{
				if(pPlayerCity != NULL && pPlayerCity != pCity)
				{
					int iDistance = plotDistance(pCity->getX(), pCity->getY(), pPlayerCity->getX(), pPlayerCity->getY());
					if(iDistance > 0)
					{
						for(int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
						{
							CvCivilizationInfo& playerCivilizationInfo = GET_PLAYER(ePlayer).getCivilizationInfo();
							BuildingTypes eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings((BuildingClassTypes)iBuildingClassLoop);
							if (eBuilding != NO_BUILDING)
							{
								CvBuildingEntry *pkBuilding = GC.getBuildingInfo(eBuilding);
								if (pkBuilding)
								{
									if (pPlayerCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0 && (pkBuilding->GetGreatWorkSlotType() == eArtArtifactSlot || pkBuilding->GetGreatWorkSlotType() == eMusicSlot || pkBuilding->GetGreatWorkSlotType() == eWritingSlot))
									{
										int iNumSlots = pkBuilding->GetGreatWorkCount();
										if(iNumSlots > 0)
										{
											for (int iI = 0; iI < iNumSlots; iI++)
											{
												iGreatWorkIndex = pPlayerCity->GetCityBuildings()->GetBuildingGreatWork((BuildingClassTypes)iBuildingClassLoop, iI);
												if (iGreatWorkIndex != -1 && !GetCulture()->ControlsGreatWork(iGreatWorkIndex))
												{
													artChoices.push_back(iGreatWorkIndex, iDistance);
													if((GC.getLogging() && GC.getAILogging()))
													{
														CvGameCulture *pCulture = GC.getGame().GetGameCulture();
														if(pCulture)
														{
															CvString strLogString;
															strLogString.Format("Found Great Work for Conquest Plunder: %d, Distance: %d, Name: %s", iGreatWorkIndex, iDistance, pCulture->GetGreatWorkName(iGreatWorkIndex).GetCString());
															GetHomelandAI()->LogHomelandMessage(strLogString);
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			artChoices.SortItems();
			if(artChoices.size() > 0)
			{
				int iPlunder = GC.getGame().getJonRandNum(max(1, (iOpenSlots / 5)), "Art Plunder Value");
				if(iPlunder <= 2)
				{
					iPlunder = 2;
				}
				if(iPlunder > artChoices.size())
				{
					iPlunder = artChoices.size();
				}
				if((GC.getLogging() && GC.getAILogging()))
				{
					CvString strLogString;
					strLogString.Format("Number of Great Works to steal for Conquest Plunder: %d", iPlunder);
					GetHomelandAI()->LogHomelandMessage(strLogString);
				}
				for(int iGrab = 0; iGrab < artChoices.size(); iGrab++)
				{
					if(iStuffStolen >= iPlunder)
					{
						break;
					}
					int iCityLoop;
					CvCity* pPlayerCity = NULL;
					int iGreatWorkIndex;	
					for (pPlayerCity = GET_PLAYER(ePlayer).firstCity(&iCityLoop); pPlayerCity != NULL; pPlayerCity = GET_PLAYER(ePlayer).nextCity(&iCityLoop))
					{
						if(iStuffStolen >= iPlunder)
						{
							break;
						}
						if(pPlayerCity != NULL && pPlayerCity != pCity)
						{
							for(int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
							{
								if(iStuffStolen >= iPlunder)
								{
									break;
								}
								CvCivilizationInfo& playerCivilizationInfo = GET_PLAYER(ePlayer).getCivilizationInfo();
								BuildingTypes eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings((BuildingClassTypes)iBuildingClassLoop);
								if (eBuilding != NO_BUILDING)
								{
									CvBuildingEntry *pkBuilding = GC.getBuildingInfo(eBuilding);
									if (pkBuilding)
									{
										if (pPlayerCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0 && (pkBuilding->GetGreatWorkSlotType() == eArtArtifactSlot || pkBuilding->GetGreatWorkSlotType() == eMusicSlot || pkBuilding->GetGreatWorkSlotType() == eWritingSlot))
										{
											int iNumSlots = pkBuilding->GetGreatWorkCount();
											if(iNumSlots > 0)
											{
												for (int iI = 0; iI < iNumSlots; iI++)
												{
													if(iStuffStolen >= iPlunder)
													{
														break;
													}
													iGreatWorkIndex = pPlayerCity->GetCityBuildings()->GetBuildingGreatWork((BuildingClassTypes)iBuildingClassLoop, iI);
													if (iGreatWorkIndex == artChoices.GetElement(iGrab))
													{
														// and create great work at home
														BuildingClassTypes eGWBuildingClass;
														int iGWSlot;
														CvCity *pArtCity = GetCulture()->GetClosestAvailableGreatWorkSlot(pPlayerCity->getX(), pPlayerCity->getY(), pkBuilding->GetGreatWorkSlotType(), &eGWBuildingClass, &iGWSlot);
														if (pArtCity)
														{
															// remove existing great works
															pPlayerCity->GetCityBuildings()->SetBuildingGreatWork((BuildingClassTypes)iBuildingClassLoop, iI, -1);
															pArtCity->GetCityBuildings()->SetBuildingGreatWork(eGWBuildingClass, iGWSlot, iGreatWorkIndex);
															iStuffStolen++;
															if((GC.getLogging() && GC.getAILogging()))
															{
																CvGameCulture *pCulture = GC.getGame().GetGameCulture();
																if(pCulture)
																{
																	CvString strLogString;
																	strLogString.Format("Great Work STOLEN for Conquest Plunder: %s. Number stolen: %d. Max to steal: %d", pCulture->GetGreatWorkName(iGreatWorkIndex).GetCString(), iStuffStolen, iPlunder);
																	GetHomelandAI()->LogHomelandMessage(strLogString);
																}
															}															
															if(GetID() == GC.getGame().getActivePlayer())
															{
																CvPopupInfo kPopup(BUTTONPOPUP_GREAT_WORK_COMPLETED_ACTIVE_PLAYER, iGreatWorkIndex);
																GC.GetEngineUserInterface()->AddPopup(kPopup);
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			if(iStuffStolen > 0)
			{
				if(GetID() == GC.getGame().getActivePlayer())
				{
					Localization::String strMessage;
					Localization::String strSummary;
					strMessage = Localization::Lookup("TXT_KEY_ART_STOLEN");
					strMessage << iStuffStolen;
					strMessage << strTargetNameKey;
					strSummary = Localization::Lookup("TXT_KEY_ART_STOLEN_SUMMARY");

					CvNotifications* pNotification = GetNotifications();
					if(pNotification)
					{
						pNotification->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), (int) pCity->GetID(), GetID());
					}
				}
				if(ePlayer == GC.getGame().getActivePlayer())
				{
					Localization::String strMessage;
					Localization::String strSummary;
					strMessage = Localization::Lookup("TXT_KEY_ART_PLUNDERED");
					strMessage << iStuffStolen;
					strMessage << strTargetNameKey;
					strSummary = Localization::Lookup("TXT_KEY_ART_PLUNDERED_SUMMARY");

					CvNotifications* pNotification = GET_PLAYER(ePlayer).GetNotifications();
					if(pNotification)
					{
						pNotification->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), (int) pCity->GetID(), pCity->getOwner());
					}
				}
			}
			else
			{
				ChangeCultureBonusTurnsConquest(pCity->getPopulation() / 2);
				if(GetID() == GC.getGame().getActivePlayer())
				{
					Localization::String strMessage;
					Localization::String strSummary;
					strMessage = Localization::Lookup("TXT_KEY_CULTURE_BOOST_ART");
					strMessage << (pCity->getPopulation() / 2);
					strMessage << strTargetNameKey;
					strSummary = Localization::Lookup("TXT_KEY_CULTURE_BOOST_ART_SUMMARY");

					CvNotifications* pNotification = GetNotifications();
					if(pNotification)
					{
						pNotification->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), (int) pCity->GetID(), GetID());
					}
				}
				if((GC.getLogging() && GC.getAILogging()))
				{
					CvGameCulture *pCulture = GC.getGame().GetGameCulture();
					if(pCulture)
					{
						CvString strLogString;
						strLogString.Format("Tried to steal stuff for Conquest Plunder but couldn't for some reason.");
						GetHomelandAI()->LogHomelandMessage(strLogString);
					}
				}
			}
		}
		else
		{
			ChangeCultureBonusTurnsConquest(pCity->getPopulation() / 2);
			if(GetID() == GC.getGame().getActivePlayer())
			{
				Localization::String strMessage;
				Localization::String strSummary;
				strMessage = Localization::Lookup("TXT_KEY_CULTURE_BOOST_ART");
				strMessage << (pCity->getPopulation() / 2);
				strMessage << strTargetNameKey;
				strSummary = Localization::Lookup("TXT_KEY_CULTURE_BOOST_ART_SUMMARY");

				CvNotifications* pNotification = GetNotifications();
				if(pNotification)
				{
					pNotification->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), (int) pCity->GetID(), GetID());
				}
			}
			if((GC.getLogging() && GC.getAILogging()))
			{
				CvGameCulture *pCulture = GC.getGame().GetGameCulture();
				if(pCulture)
				{
					CvString strLogString;
					strLogString.Format("Tried to steal stuff for Conquest Plunder but no open slots.");
					GetHomelandAI()->LogHomelandMessage(strLogString);
				}
			}
		}
	}
	else
	{
		ChangeCultureBonusTurnsConquest(pCity->getPopulation() / 2);
		if(GetID() == GC.getGame().getActivePlayer())
		{
			Localization::String strMessage;
			Localization::String strSummary;
			strMessage = Localization::Lookup("TXT_KEY_CULTURE_BOOST_ART");
			strMessage << (pCity->getPopulation() / 2);
			strMessage << strTargetNameKey;
			strSummary = Localization::Lookup("TXT_KEY_CULTURE_BOOST_ART_SUMMARY");

			CvNotifications* pNotification = GetNotifications();
			if(pNotification)
			{
				pNotification->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), (int) pCity->GetID(), GetID());
			}
		}
		if((GC.getLogging() && GC.getAILogging()))
		{
			CvGameCulture *pCulture = GC.getGame().GetGameCulture();
			if(pCulture)
			{
				CvString strLogString;
				strLogString.Format("Tried to steal stuff for Conquest Plunder but invalid target.");
				GetHomelandAI()->LogHomelandMessage(strLogString);
			}
		}
	}
}
#endif
#if defined(MOD_API_UNIFIED_YIELDS)
//	--------------------------------------------------------------------------------
/// Yield per turn from Religion
int CvPlayer::GetYieldPerTurnFromReligion(YieldTypes eYield) const
{
	eYield;
	int iYieldPerTurn = 0;
#if !defined(MOD_BALANCE_CORE)
	CvGameReligions* pReligions = GC.getGame().GetGameReligions();
	ReligionTypes eReligion = pReligions->GetReligionCreatedByPlayer(GetID());
	//Religions
	if (eReligion != NO_RELIGION && eReligion != RELIGION_PANTHEON)
	{
		const CvReligion* pReligion = pReligions->GetReligion(eReligion, GetID());
		if (pReligion)
		{
			//Founders and Enhancers

			iYieldPerTurn += pReligion->m_Beliefs.GetHolyCityYieldChange(eYield);

			int iTemp = pReligion->m_Beliefs.GetYieldChangePerForeignCity(eYield);
			if (iTemp > 0)
			{
				iYieldPerTurn += (iTemp * GetReligions()->GetNumForeignCitiesFollowing());
			}

			iTemp = pReligion->m_Beliefs.GetYieldChangePerXForeignFollowers(eYield);
			if (iTemp > 0)
			{
				int iFollowers = GetReligions()->GetNumForeignFollowers(false /*bAtPeace*/);
				if (iFollowers > 0)
				{
					iYieldPerTurn += (iFollowers / iTemp);
				}
			}

			// This came from CvTreasury::GetGoldPerTurnFromReligion()
			if (eYield == YIELD_GOLD)
			{
				int iGoldPerFollowingCity = pReligion->m_Beliefs.GetGoldPerFollowingCity();
				iYieldPerTurn += (pReligions->GetNumCitiesFollowing(eReligion) * iGoldPerFollowingCity);

				int iGoldPerXFollowers = pReligion->m_Beliefs.GetGoldPerXFollowers();
				if(iGoldPerXFollowers > 0)
				{
					iYieldPerTurn += (pReligions->GetNumFollowers(eReligion) / iGoldPerXFollowers);
				}
			}

			//Pantheons
			int iYieldPerFollowingCity = pReligion->m_Beliefs.GetYieldPerFollowingCity(eYield);
			iYieldPerTurn += (pReligions->GetNumCitiesFollowing(eReligion) * iYieldPerFollowingCity);

			int iYieldPerXFollowers = pReligion->m_Beliefs.GetYieldPerXFollowers(eYield);
			if(iYieldPerXFollowers > 0)
			{		
				iYieldPerTurn += (pReligions->GetNumFollowers(eReligion) / iYieldPerXFollowers);
			}
			if(pReligion->m_Beliefs.GetYieldPerLux(eYield) > 0)
			{
				int iLuxCulture = pReligion->m_Beliefs.GetYieldPerLux(eYield);
				int iNumHappinessResources = 0;
				ResourceTypes eResource;
				for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
				{
					eResource = (ResourceTypes) iResourceLoop;

					if(GetHappinessFromLuxury(eResource) > 0)
					{
						iNumHappinessResources++;
					}
				}
				if(iNumHappinessResources > 0)
				{
					iLuxCulture *= iNumHappinessResources;
					iYieldPerTurn += iLuxCulture;
				}
			}
			int iYieldPerGPT = pReligion->m_Beliefs.GetYieldPerGPT(eYield);
			if(iYieldPerGPT > 0)
			{
				int iNetGold = GetTreasury()->CalculateGrossGold();
				if (iNetGold > 0)
				{
					iYieldPerTurn += (iNetGold / iYieldPerGPT);
				}
			}
			int iYieldPerScience = pReligion->m_Beliefs.GetYieldPerScience(eYield);
			if(iYieldPerScience > 0)
			{
				if(GetScience() > 0)
				{
					iYieldPerTurn += (GetScience() / iYieldPerScience);
				}
			}
			CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
			if(pLeague != NULL)
			{
				int iEra = GetCurrentEra();
				if(iEra <= 1)
				{
					iEra = 1;
				}
				int iHostYield = (pReligion->m_Beliefs.GetYieldFromHost(eYield) * iEra);
				if(iHostYield > 0)
				{
					if(pLeague->GetHostMember() == GetID())
					{
						iYieldPerTurn += iHostYield;
					}
				}
			}
		}
	}
	//Pantheons
	else
	{
		ReligionTypes ePantheon = GetReligions()->GetReligionCreatedByPlayer(true);
		if(ePantheon != NO_RELIGION)
		{
			const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(ePantheon, GetID());
			if(pReligion)
			{
				int iLoop;
				const CvCity* pLoopCity;
				int iFollowers = 0;
				int iCities = 0;
				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if(pLoopCity != NULL)
					{
						if(pLoopCity->GetCityReligions()->GetNumFollowers(ePantheon) > 0)
						{
							iFollowers += pLoopCity->GetCityReligions()->GetNumFollowers(ePantheon);
							iCities++;
						}
					}
				}

				//Pantheons
				int iYieldPerFollowingCity = pReligion->m_Beliefs.GetYieldPerFollowingCity(eYield);
				iYieldPerTurn += (iCities * iYieldPerFollowingCity);

				int iYieldPerXFollowers = pReligion->m_Beliefs.GetYieldPerXFollowers(eYield);
				if(iYieldPerXFollowers > 0)
				{		
					iYieldPerTurn += (iFollowers / iYieldPerXFollowers);
				}
				if(pReligion->m_Beliefs.GetYieldPerLux(eYield) > 0)
				{
					int iLuxCulture = pReligion->m_Beliefs.GetYieldPerLux(eYield);
					int iNumHappinessResources = 0;
					ResourceTypes eResource;
					for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
					{
						eResource = (ResourceTypes) iResourceLoop;

						if(GetHappinessFromLuxury(eResource) > 0)
						{
							iNumHappinessResources++;
						}
					}
					if(iNumHappinessResources > 0)
					{
						iLuxCulture *= iNumHappinessResources;
						iYieldPerTurn += iLuxCulture;
					}
				}
				int iYieldPerGPT = pReligion->m_Beliefs.GetYieldPerGPT(eYield);
				if(iYieldPerGPT > 0)
				{
					int iNetGold = GetTreasury()->CalculateGrossGold();
					if(iNetGold > 0)
					{
						iYieldPerTurn += (iNetGold / iYieldPerGPT);
					}
				}
				int iYieldPerScience = pReligion->m_Beliefs.GetYieldPerScience(eYield);
				if(iYieldPerScience > 0)
				{
					if(GetScience() > 0)
					{
						iYieldPerTurn += (GetScience() / iYieldPerScience);
					}
				}
			}
		}
	}
#endif
	return iYieldPerTurn;
}

//	--------------------------------------------------------------------------------
/// Trait bonus which adds Faith for trade partners? 
int CvPlayer::GetYieldPerTurnFromTraits(YieldTypes eYield) const
{
#if defined(MOD_BALANCE_CORE)
	if(MOD_BALANCE_YIELD_SCALE_ERA)
	{
		int iEra = GetCurrentEra();
		if(iEra < 1)
		{
			iEra = 1;
		}
		return (iEra * GetPlayerTraits()->GetYieldChangePerTradePartner(eYield) * GetTrade()->GetNumDifferentTradingPartners());
	}
	else
	{
#endif
	return GetPlayerTraits()->GetYieldChangePerTradePartner(eYield) * GetTrade()->GetNumDifferentTradingPartners();
#if defined(MOD_BALANCE_CORE)
	}
#endif
}
#endif

//	--------------------------------------------------------------------------------
/// Total faith per turn
#if defined(MOD_BALANCE_CORE)
	int CvPlayer::GetTotalFaithPerTurn(bool bIgnoreHappiness ) const
#else
int CvPlayer::GetTotalFaithPerTurn() const
#endif
{
	int iFaithPerTurn = 0;

	// If we're in anarchy, then no Faith is generated!
	if(IsAnarchy())
		return 0;
#if defined(MOD_BALANCE_CORE)
	//No barbs or minors, please!
	if(isBarbarian() || isMinorCiv())
		return 0;
#endif

	// Faith per turn from Cities
	iFaithPerTurn += GetFaithPerTurnFromCities();

#if defined(MOD_API_UNIFIED_YIELDS)
	// Trait bonus which adds Faith for trade partners? 
	iFaithPerTurn += GetYieldPerTurnFromTraits(YIELD_FAITH);
#endif

	// Faith per turn from Minor Civs
	iFaithPerTurn += GetFaithPerTurnFromMinorCivs();

	// Faith per turn from Religion (Founder beliefs)
	iFaithPerTurn += GetFaithPerTurnFromReligion();

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (MOD_DIPLOMACY_CIV4_FEATURES) {
		// We're a vassal of someone, we get x% of his faith
		iFaithPerTurn += (GetYieldPerTurnFromVassals(YIELD_FAITH));
	}
#endif

#if defined(MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	if(!bIgnoreHappiness && MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	{
		iFaithPerTurn += GetYieldPerTurnFromHappiness(YIELD_FAITH, iFaithPerTurn);
	}
#endif

	return iFaithPerTurn;
}

//	--------------------------------------------------------------------------------
/// Faith per turn from Cities
int CvPlayer::GetFaithPerTurnFromCities() const
{
	int iFaithPerTurn = 0;

	// Add in culture from Cities
	const CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iFaithPerTurn += pLoopCity->GetFaithPerTurn();
	}

	return iFaithPerTurn;
}

//	--------------------------------------------------------------------------------
/// Faith per turn from Minor Civs
int CvPlayer::GetFaithPerTurnFromMinorCivs() const
{
	int iFaithPerTurn = 0;
	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		iFaithPerTurn += GetFaithPerTurnFromMinor((PlayerTypes)iMinorLoop);
	}
	return iFaithPerTurn;
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Gold per turn from Minor Civs
int CvPlayer::GetGoldPerTurnFromMinorCivs() const
{
	int iFaithPerTurn = 0;
	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		iFaithPerTurn += GetGoldPerTurnFromMinor((PlayerTypes)iMinorLoop);
	}
	return iFaithPerTurn;
}
//	--------------------------------------------------------------------------------
/// Science per turn from Minor Civs
int CvPlayer::GetSciencePerTurnFromMinorCivs() const
{
	int iFaithPerTurn = 0;
	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		iFaithPerTurn += GetSciencePerTurnFromMinor((PlayerTypes)iMinorLoop);
	}
	return iFaithPerTurn;
}
//	--------------------------------------------------------------------------------
/// Gold per turn from a Minor Civ
int CvPlayer::GetGoldPerTurnFromMinor(PlayerTypes eMinor) const
{
	int iGoldPerTurn = 0;

	if(GET_PLAYER(eMinor).isAlive())
	{
		iGoldPerTurn += GET_PLAYER(eMinor).GetMinorCivAI()->GetCurrentGoldBonus(GetID());
	}

	return iGoldPerTurn;
}
//	--------------------------------------------------------------------------------
/// Science per turn from a Minor Civ
int CvPlayer::GetSciencePerTurnFromMinor(PlayerTypes eMinor) const
{
	int iSciencePerTurn = 0;

	if(GET_PLAYER(eMinor).isAlive())
	{
		iSciencePerTurn += GET_PLAYER(eMinor).GetMinorCivAI()->GetCurrentScienceBonus(GetID());
	}

	return iSciencePerTurn;
}
#endif
//	--------------------------------------------------------------------------------
/// Faith per turn from a Minor Civ
int CvPlayer::GetFaithPerTurnFromMinor(PlayerTypes eMinor) const
{
	int iFaithPerTurn = 0;

	if(GET_PLAYER(eMinor).isAlive())
	{
		iFaithPerTurn += GET_PLAYER(eMinor).GetMinorCivAI()->GetCurrentFaithBonus(GetID());
	}

	return iFaithPerTurn;
}

//	--------------------------------------------------------------------------------
/// Faith per turn from Religion
int CvPlayer::GetFaithPerTurnFromReligion() const
{
	int iFaithPerTurn = 0;
#if defined(MOD_API_UNIFIED_YIELDS)
	iFaithPerTurn += GetYieldPerTurnFromReligion(YIELD_FAITH);
#else
	// Founder beliefs
	CvGameReligions* pReligions = GC.getGame().GetGameReligions();
	ReligionTypes eFoundedReligion = GetReligions()->GetReligionInMostCities();
	if(eFoundedReligion != NO_RELIGION)
	{
		const CvReligion* pReligion = pReligions->GetReligion(eFoundedReligion, NO_PLAYER);
		if(pReligion)
		{
			iFaithPerTurn += pReligion->m_Beliefs.GetHolyCityYieldChange(YIELD_FAITH);

			int iTemp = pReligion->m_Beliefs.GetYieldChangePerForeignCity(YIELD_FAITH);
			if (iTemp > 0)
			{
				iFaithPerTurn += (iTemp * GetReligions()->GetNumForeignCitiesFollowing());
			}

			iTemp = pReligion->m_Beliefs.GetYieldChangePerXForeignFollowers(YIELD_FAITH);
			if (iTemp > 0)
			{
				int iFollowers = GetReligions()->GetNumForeignFollowers(false /*bAtPeace*/);
				if (iFollowers > 0)
				{
					iFaithPerTurn += (iTemp / iFollowers);
				}
			}
		}
	}
#endif
	return iFaithPerTurn;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetFaith() const
{
	return m_iFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetFaith(int iNewValue)
{
	if(GC.getGame().isOption(GAMEOPTION_NO_RELIGION))
	{
		return;
	}

	if(GetFaith() != iNewValue)
	{
		// Add to the total we've ever had
		if(iNewValue > m_iFaith)
		{
			ChangeFaithEverGenerated(iNewValue - m_iFaith);
		}

		m_iFaith = iNewValue;

		if(GC.getGame().getActivePlayer() == GetID())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeFaith(int iChange)
{
	if(GC.getGame().isOption(GAMEOPTION_NO_RELIGION))
	{
		return;
	}

	SetFaith(GetFaith() + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetFaithEverGenerated() const
{
	return m_iFaithEverGenerated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetFaithEverGenerated(int iNewValue)
{
	if(m_iFaithEverGenerated != iNewValue)
		m_iFaithEverGenerated = iNewValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeFaithEverGenerated(int iChange)
{
	SetFaithEverGenerated(GetFaithEverGenerated() + iChange);
}

//	--------------------------------------------------------------------------------
/// Updates how much Happiness we have
void CvPlayer::DoUpdateTotalHappiness()
{
	// Start level
	m_iHappiness = getHandicapInfo().getHappinessDefault();

#if defined(MOD_BALANCE_CORE)
	// Gamespeed Bonus level
	if(MOD_BALANCE_CORE)
	{
		int iGameSpeedHappiness = GC.getGame().getGameSpeedInfo().GetStartingHappiness();
		m_iHappiness += iGameSpeedHappiness;
	}
#endif
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	// Gamespeed Bonus level
	if(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	{
		int iMonpolyHappiness = GetHappinessFromResourceMonopolies();
		m_iHappiness += iMonpolyHappiness;
	}
#endif
#if defined(MOD_BALANCE_CORE_HAPPINESS_LUXURY)
	if(MOD_BALANCE_CORE_HAPPINESS_LUXURY)
	{
		int iExtraResourceHappiness = GetBonusHappinessFromLuxuries();
		m_iHappiness += iExtraResourceHappiness;
	}
#endif
	// Increase from Luxury Resources
	int iNumHappinessFromResources = GetHappinessFromResources();
	m_iHappiness += iNumHappinessFromResources;

	// Increase from Local City Happiness
	m_iHappiness += GetHappinessFromCities();

	// Increase from buildings
	m_iHappiness += GetHappinessFromBuildings();

	// Increase from policies
	m_iHappiness += GetHappinessFromPolicies();

	// Increase from num cities (player based, for buildings and such)
	m_iHappiness += getNumCities() * m_iHappinessPerCity;

	// Increase from Religion
	m_iHappiness += GetHappinessFromReligion();

	// Increase from Natural Wonders
	m_iHappiness += GetHappinessFromNaturalWonders();

	// Friendship with Minors can provide Happiness
	m_iHappiness += GetHappinessFromMinorCivs();

	// Increase from Leagues
	m_iHappiness += GetHappinessFromLeagues();

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (MOD_DIPLOMACY_CIV4_FEATURES) {
		// Increase from Vassals
		m_iHappiness += GetHappinessFromVassals();
	}
#endif

	// Increase for each City connected to Capital with a Trade Route
	DoUpdateCityConnectionHappiness();
	m_iHappiness += GetHappinessFromTradeRoutes();

#if !defined(NO_ACHIEVEMENTS)
	if(isLocalPlayer() && GetExcessHappiness() >= 100)
	{
		gDLL->UnlockAchievement(ACHIEVEMENT_XP2_45);
	}
#endif

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
}

//	--------------------------------------------------------------------------------
/// How much Happiness we have
int CvPlayer::GetHappiness() const
{
	return m_iHappiness;
}

//	--------------------------------------------------------------------------------
/// Sets how much Happiness we have
void CvPlayer::SetHappiness(int iNewValue)
{
	if(GetHappiness() != iNewValue)
	{
		m_iHappiness = iNewValue;
	}
}

/// Sets how much Unhappiness we have
void CvPlayer::SetUnhappiness(int iNewValue)
{
	if(m_iUnhappiness != iNewValue)
	{
		m_iUnhappiness = iNewValue;
	}
}
int CvPlayer::GetUnhappiness() const
{
	return m_iUnhappiness;
}

void CvPlayer::CalculateNetHappiness()
{
	//Not active player, or a barb, or a minor? Get out!
	if(isMinorCiv() || isBarbarian())
	{
		return;
	}

	DoUpdateTotalHappiness();
	DoUpdateTotalUnhappiness();

	int iHappiness = GetHappiness();
	int iUnhappiness = GetUnhappiness();

	int iDiff = (iHappiness-iUnhappiness);
	if (iDiff != m_iHappinessTotal)
	{
		m_iHappinessTotal = iDiff;
		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
	}
}

#if defined(MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
int CvPlayer::GetYieldPerTurnFromHappiness(YieldTypes eYield, int iValue) const
{
	//Mechanic to allow for growth malus from happiness/unhappiness.
	int iHappiness = GetExcessHappiness();

	//If Happiness is greater than or over threshold, calculate city bonus mod.
	if(iHappiness >= GC.getBALANCE_HAPPINESS_THRESHOLD())
	{
		iHappiness = (iHappiness - GC.getBALANCE_HAPPINESS_THRESHOLD());
		//Are there minimums/maximums for the bonus? Restrict this value.
		if(iHappiness >= GC.getBALANCE_HAPPINESS_BONUS_MAXIMUM())
		{
			iHappiness = GC.getBALANCE_HAPPINESS_BONUS_MAXIMUM();
		}
		else if(iHappiness <= GC.getBALANCE_HAPPINESS_BONUS_MINIMUM())
		{
			iHappiness = GC.getBALANCE_HAPPINESS_BONUS_MINIMUM();
		}
		
	}
	//If happiness is less than the main threshold, calculate city penalty mod.
	else if(iHappiness < GC.getBALANCE_HAPPINESS_THRESHOLD())
	{
		//Are there minimums/maximums for the penalty? Restrict this value.
		if(iHappiness >= GC.getBALANCE_HAPPINESS_PENALTY_MINIMUM())
		{
			iHappiness = GC.getBALANCE_HAPPINESS_PENALTY_MINIMUM();
		}
		else if(iHappiness <= GC.getBALANCE_HAPPINESS_PENALTY_MAXIMUM())
		{
			iHappiness = GC.getBALANCE_HAPPINESS_PENALTY_MAXIMUM();
		}
	}
	if(iHappiness != 0)
	{
		//Mechanic to allow for growth malus from happiness/unhappiness.
		if(eYield == YIELD_GOLD)
		{
			iValue = ((iValue * /*3*/ GC.getBALANCE_HAPPINESS_GOLD_MODIFIER() * iHappiness) / 100);
			return iValue;
		}
		else if(eYield == YIELD_FAITH)
		{
			iValue = ((iValue * /*3*/ GC.getBALANCE_HAPPINESS_FAITH_MODIFIER() * iHappiness) / 100);
			return iValue;
		}
		else if(eYield == YIELD_CULTURE)
		{
			iValue = ((iValue * /*3*/ GC.getBALANCE_HAPPINESS_CULTURE_MODIFIER() * iHappiness) / 100);
			return iValue;
		}
		else if(eYield == YIELD_SCIENCE)
		{
			iValue = ((iValue * /*3*/ GC.getBALANCE_HAPPINESS_SCIENCE_MODIFIER() * iHappiness) / 100);
			return iValue;
		}
	}
	return 0;
}
	//LUA Functions
int CvPlayer::CalculateUnhappinessTooltip(YieldTypes eYield) const
{
	//Mechanic to allow for growth malus from happiness/unhappiness.
	int iHappiness = GetExcessHappiness();

	//If Happiness is greater than or over threshold, calculate city bonus mod.
	if(iHappiness >= GC.getBALANCE_HAPPINESS_THRESHOLD())
	{
		iHappiness = (iHappiness - GC.getBALANCE_HAPPINESS_THRESHOLD());
		//Are there minimums/maximums for the bonus? Restrict this value.
		if(iHappiness > GC.getBALANCE_HAPPINESS_BONUS_MAXIMUM())
		{
			iHappiness = GC.getBALANCE_HAPPINESS_BONUS_MAXIMUM();
		}
		else if(iHappiness < GC.getBALANCE_HAPPINESS_BONUS_MINIMUM())
		{
			iHappiness = GC.getBALANCE_HAPPINESS_BONUS_MINIMUM();
		}
	}
	//If happiness is less than the main threshold, calculate city penalty mod.
	else if(iHappiness < GC.getBALANCE_HAPPINESS_THRESHOLD())
	{
		//Are there minimums/maximums for the penalty? Restrict this value.
		if(iHappiness > GC.getBALANCE_HAPPINESS_PENALTY_MINIMUM())
		{
			iHappiness = GC.getBALANCE_HAPPINESS_PENALTY_MINIMUM();
		}
		else if(iHappiness < GC.getBALANCE_HAPPINESS_PENALTY_MAXIMUM())
		{
			iHappiness = GC.getBALANCE_HAPPINESS_PENALTY_MAXIMUM();
		}			
	}
	if(iHappiness != 0)
	{
		//Mechanic to allow for growth malus from happiness/unhappiness.
		if(eYield == YIELD_GOLD)
		{
			int iValue = GetTreasury()->CalculateGrossGoldTimes100(true);
			iValue = ((iValue * /*3*/ GC.getBALANCE_HAPPINESS_GOLD_MODIFIER() * iHappiness) / 100);
			return iValue;
		}
		else if(eYield == YIELD_FAITH)
		{
			int iValue = GetTotalFaithPerTurn(true);
			iValue = ((iValue * /*3*/ GC.getBALANCE_HAPPINESS_FAITH_MODIFIER() * iHappiness) / 100);
			return iValue;
		}
		else if(eYield == YIELD_CULTURE)
		{
			int iValue = GetTotalJONSCulturePerTurn(true);
			iValue = ((iValue * /*3*/ GC.getBALANCE_HAPPINESS_CULTURE_MODIFIER() * iHappiness) / 100);
			return iValue;
		}
		else if(eYield == YIELD_SCIENCE)
		{
			int iValue = GetScienceTimes100(true);
			iValue = ((iValue * /*3*/ GC.getBALANCE_HAPPINESS_SCIENCE_MODIFIER() * iHappiness) / 100);
			return iValue;
		}
	}

	return 0;
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvPlayer::GetPovertyUnhappinessGlobal() const
{
	return m_iChangePovertyUnhappinessGlobal;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangePovertyUnhappinessGlobal(int iChange)
{
	m_iChangePovertyUnhappinessGlobal += iChange;
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvPlayer::GetDefenseUnhappinessGlobal() const
{
	return m_iChangeDefenseUnhappinessGlobal;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangeDefenseUnhappinessGlobal(int iChange)
{
	m_iChangeDefenseUnhappinessGlobal += iChange;
}
/// Extra yield from building
int CvPlayer::GetUnculturedUnhappinessGlobal() const
{
	return m_iChangeUnculturedUnhappinessGlobal;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangeUnculturedUnhappinessGlobal(int iChange)
{
	m_iChangeUnculturedUnhappinessGlobal += iChange;
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvPlayer::GetIlliteracyUnhappinessGlobal() const
{
	return m_iChangeIlliteracyUnhappinessGlobal;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangeIlliteracyUnhappinessGlobal(int iChange)
{
	m_iChangeIlliteracyUnhappinessGlobal += iChange;
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvPlayer::GetMinorityUnhappinessGlobal() const
{
	return m_iChangeMinorityUnhappinessGlobal;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangeMinorityUnhappinessGlobal(int iChange)
{
	m_iChangeMinorityUnhappinessGlobal += iChange;
}
#endif

//	--------------------------------------------------------------------------------
/// How much over our Happiness limit are we?
int CvPlayer::GetExcessHappiness() const
{
	if(isMinorCiv() || isBarbarian())
	{
		return 0;
	}
	return m_iHappinessTotal;
}

//	--------------------------------------------------------------------------------
/// Has the player passed the Happiness limit?
bool CvPlayer::IsEmpireUnhappy() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS))
	{
		return false;
	}
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	if(MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	{
		//Mechanic to allow for varied effects of happiness/unhappiness.
		int iHappiness = GetExcessHappiness();
		if(iHappiness < GC.getBALANCE_HAPPINESS_THRESHOLD_MAIN())
		{
			return true;
		}
	}
	else
	{
#endif
	if(GetExcessHappiness() < 0)
	{
		return true;
	}
#if defined(MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	}
#endif
	return false;
}

//	--------------------------------------------------------------------------------
/// Is the empire REALLY unhappy? (other penalties)
bool CvPlayer::IsEmpireVeryUnhappy() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS))
	{
		return false;
	}
#if defined(MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	if(MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	{
		//Mechanic to allow for varied effects of happiness/unhappiness.
		int iHappiness = GetExcessHappiness();
		if(iHappiness <= (/*-10*/ GC.getVERY_UNHAPPY_THRESHOLD() + GC.getBALANCE_HAPPINESS_THRESHOLD_MAIN()))
		{
			return true;
		}
	}
	else
	{
#endif
	if(GetExcessHappiness() <= /*-10*/ GC.getVERY_UNHAPPY_THRESHOLD())
	{
		return true;
	}
#if defined(MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	}
#endif
	return false;
}

//	--------------------------------------------------------------------------------
/// Is the empire SUPER unhappy? (leads to revolts)
bool CvPlayer::IsEmpireSuperUnhappy() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS))
	{
		return false;
	}
#if defined(MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	if(MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	{
		//Mechanic to allow for varied effects of happiness/unhappiness.
		int iHappiness = GetExcessHappiness();
		if(iHappiness <= (/*-20*/ GC.getSUPER_UNHAPPY_THRESHOLD() + GC.getBALANCE_HAPPINESS_THRESHOLD_MAIN()))
		{
			return true;
		}
	}
	else
	{
#endif
	if(GetExcessHappiness() <= /*-20*/ GC.getSUPER_UNHAPPY_THRESHOLD())
	{
		return true;
	}
#if defined(MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	}
#endif
	return false;
}

//	--------------------------------------------------------------------------------
/// Uprisings pop up if the empire is Very Unhappy
void CvPlayer::DoUpdateUprisings()
{
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	//Revolts only happen if super unhappy.
	if(MOD_BALANCE_CORE_HAPPINESS && IsEmpireSuperUnhappy())
	{
		// If we're very unhappy, make the counter wind down
		if(GetUprisingCounter() > 0)
		{
			ChangeUprisingCounter(-1);

			// Time's up!
			if(GetUprisingCounter() == 0)
			{
				DoUprising();
				DoResetUprisingCounter(/*bFirstTime*/ false);
			}
		}
		// Very Unhappy for the first time - seed the counter
		else
		{
			DoResetUprisingCounter(/*bFirstTime*/ true);
		}
	}
	else
#endif
	if(IsEmpireSuperUnhappy())
	{
		// If we're very unhappy, make the counter wind down
		if(GetUprisingCounter() > 0)
		{
			ChangeUprisingCounter(-1);

			// Time's up!
			if(GetUprisingCounter() == 0)
			{
				DoUprising();
				DoResetUprisingCounter(/*bFirstTime*/ false);
			}
		}
		// Very Unhappy for the first time - seed the counter
		else
		{
			DoResetUprisingCounter(/*bFirstTime*/ true);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Uprising countdown - get
int CvPlayer::GetUprisingCounter() const
{
	return m_iUprisingCounter;
}

//	--------------------------------------------------------------------------------
/// Uprising countdown - set
void CvPlayer::SetUprisingCounter(int iValue)
{
	m_iUprisingCounter = iValue;
}

//	--------------------------------------------------------------------------------
/// Uprising countdown - change
void CvPlayer::ChangeUprisingCounter(int iChange)
{
	SetUprisingCounter(GetUprisingCounter() + iChange);
}

//	--------------------------------------------------------------------------------
/// Uprising countdown - seed
void CvPlayer::DoResetUprisingCounter(bool bFirstTime)
{
	int iTurns = /*4*/ GC.getUPRISING_COUNTER_MIN();
	CvGame& theGame = GC.getGame();
	int iExtra = theGame.getJonRandNum(/*3*/ GC.getUPRISING_COUNTER_POSSIBLE(), "Uprising counter rand");
	iTurns += iExtra;

	// Game speed mod
	int iMod = theGame.getGameSpeedInfo().getTrainPercent();
	// Only LENGTHEN time between rebels
	if(iMod > 100)
	{
		iTurns *= iMod;
		iTurns /= 100;
	}

	if(bFirstTime)
		iTurns /= 2;

	if(iTurns <= 0)
		iTurns = 1;

	SetUprisingCounter(iTurns);
}

//	--------------------------------------------------------------------------------
// Fire off an uprising somewhere
void CvPlayer::DoUprising()
{
	// In hundreds
	int iNumRebels = /*100*/ GC.getUPRISING_NUM_BASE();
	int iExtraRoll = (getNumCities() - 1) * /*20*/ GC.getUPRISING_NUM_CITY_COUNT();
	iExtraRoll += 100;
	iNumRebels += GC.getGame().getJonRandNum(iExtraRoll, "Rebel count rand roll");
	iNumRebels /= 100;

	// Find a random city to pop up a bad man
	CvCity* pBestCity = NULL;
	int iBestWeight = 0;

	int iTempWeight;

	CvCity* pLoopCity;
	int iLoop;
	CvGame& theGame = GC.getGame();
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iTempWeight = pLoopCity->getPopulation();
		iTempWeight += theGame.getJonRandNum(10, "Uprising rand weight.");

		if(iTempWeight > iBestWeight)
		{
			iBestWeight = iTempWeight;
			pBestCity = pLoopCity;
		}
	}

	// Found a place to set up an uprising?
	if(pBestCity != NULL)
	{
		int iBestPlot = -1;
		int iBestPlotWeight = -1;
		CvPlot* pPlot;

		CvCityCitizens* pCitizens = pBestCity->GetCityCitizens();

		// Start at 1, since ID 0 is the city plot itself

		for(int iPlotLoop = 1; iPlotLoop < pBestCity->GetNumWorkablePlots(); iPlotLoop++)
		{
			pPlot = pCitizens->GetCityPlotFromIndex(iPlotLoop);

			if(!pPlot)		// Should be valid, but make sure
				continue;

			// Can't be impassable
			if(!pPlot->isValidMovePlot(GetID()))
				continue;

			// Can't be water
			if(pPlot->isWater())
				continue;

			// Can't be ANOTHER city
			if(pPlot->isCity())
				continue;

			// Don't place on a plot where a unit is already standing
			if(pPlot->getNumUnits() > 0)
				continue;

			iTempWeight = theGame.getJonRandNum(10, "Uprising rand plot location.");

			// Add weight if there's an improvement here!
			if(pPlot->getImprovementType() != NO_IMPROVEMENT)
			{
				iTempWeight += 4;

				// If also a a resource, even more weight!
				if(pPlot->getResourceType(getTeam()) != NO_RESOURCE)
					iTempWeight += 3;
			}

			// Add weight if there's a defensive bonus for this plot
			if(pPlot->defenseModifier(BARBARIAN_TEAM, false, false))
				iTempWeight += 4;

			// Don't pick plots that aren't ours
			if(pPlot->getOwner() != GetID())
				iTempWeight = -1;

			if(iTempWeight > iBestPlotWeight)
			{
				iBestPlotWeight = iTempWeight;
				iBestPlot = iPlotLoop;
			}
		}

		// Found valid plot
		if(iBestPlot != -1)
		{
			// Make barbs able to enter ANYONE'S territory
			theGame.SetBarbarianReleaseTurn(0);

			pPlot = pCitizens->GetCityPlotFromIndex(iBestPlot);

			// Pick a unit type
			UnitTypes eUnit = theGame.GetRandomSpawnUnitType(GetID(), /*bIncludeUUs*/ false, /*bIncludeRanged*/ false);

			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_REBELS");
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_REBELS_SUMMARY");
				pNotifications->Add(NOTIFICATION_REBELS, strMessage.toUTF8(), strSummary.toUTF8(), pPlot->getX(), pPlot->getY(), eUnit, BARBARIAN_PLAYER);
			}

			// Init unit
			GET_PLAYER(BARBARIAN_PLAYER).initUnit(eUnit, pPlot->getX(), pPlot->getY());
			iNumRebels--;	// Reduce the count since we just added the seed rebel

			// Loop until all rebels are placed
			do
			{
				iNumRebels--;

				// Init unit
				CvUnit* pUnit = GET_PLAYER(BARBARIAN_PLAYER).initUnit(eUnit, pPlot->getX(), pPlot->getY());
				CvAssert(pUnit);
				if (pUnit)
				{
					if (!pUnit->jumpToNearestValidPlotWithinRange(5))
						pUnit->kill(false);		// Could not find a spot!
				}
			}
			while(iNumRebels > 0);
		}
	}
}

//	--------------------------------------------------------------------------------
/// City can revolt if the empire is Super Unhappy
void CvPlayer::DoUpdateCityRevolts()
{
	if(IsEmpireSuperUnhappy() && GetCulture()->GetPublicOpinionUnhappiness() > 0)
	{
		if(GetCityRevoltCounter() > 0)
		{
			ChangeCityRevoltCounter(-1);

			// Time's up!
			if(GetCityRevoltCounter() == 0)
			{
				DoCityRevolt();
				SetCityRevoltCounter(0);
			}
		}
		// Super Unhappy for the first time - seed the counter
		else
		{
			DoResetCityRevoltCounter();
		}
	}
}

//	--------------------------------------------------------------------------------
/// City revolt countdown - get
int CvPlayer::GetCityRevoltCounter() const
{
	return m_iCityRevoltCounter;
}

//	--------------------------------------------------------------------------------
/// City revolt countdown - set
void CvPlayer::SetCityRevoltCounter(int iValue)
{
	m_iCityRevoltCounter = iValue;
}

//	--------------------------------------------------------------------------------
/// City revolt countdown - change
void CvPlayer::ChangeCityRevoltCounter(int iChange)
{
	SetCityRevoltCounter(GetCityRevoltCounter() + iChange);
}

//	--------------------------------------------------------------------------------
/// City revolt countdown - seed
void CvPlayer::DoResetCityRevoltCounter()
{
	int iTurns = /*5*/ GC.getREVOLT_COUNTER_MIN();
	CvGame& theGame = GC.getGame();

	// Game speed mod
	int iMod = theGame.getGameSpeedInfo().getTrainPercent();
	// Only LENGTHEN time between rebels
	if(iMod > 100)
	{
		iTurns *= iMod;
		iTurns /= 100;
	}

	if(iTurns <= 0)
		iTurns = 1;

	CvCity *pMostUnhappyCity = GetMostUnhappyCity();
	PlayerTypes eRecipient = GetMostUnhappyCityRecipient();
	if(pMostUnhappyCity && eRecipient != NO_PLAYER)
	{
		SetCityRevoltCounter(iTurns);

		CvNotifications* pNotifications = GetNotifications();
		if(pNotifications && isHuman())
		{
			Localization::String strMessage = GetLocalizedText("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLT", iTurns, pMostUnhappyCity->getName(), GET_PLAYER(eRecipient).getCivilizationShortDescription()).c_str();
			Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLT_SUMMARY");
			pNotifications->Add(NOTIFICATION_CITY_REVOLT_POSSIBLE, strMessage.toUTF8(), strSummary.toUTF8(), pMostUnhappyCity->getX(), pMostUnhappyCity->getY(), -1);
		}
	}
#if defined(MOD_BALANCE_CORE)
	else if(pMostUnhappyCity && eRecipient == NO_PLAYER)
	{
		PlayerTypes eOldPlayer = pMostUnhappyCity->getOriginalOwner();
		if(eOldPlayer != NO_PLAYER && !GET_PLAYER(eOldPlayer).isAlive())
		{
			SetCityRevoltCounter(iTurns);
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications && isHuman())
			{
				Localization::String strMessage = GetLocalizedText("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLUTION_CP", iTurns, pMostUnhappyCity->getName(), GET_PLAYER(eOldPlayer).getCivilizationShortDescription()).c_str();
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLUTION_CP_SUMMARY");
				pNotifications->Add(NOTIFICATION_CITY_REVOLT_POSSIBLE, strMessage.toUTF8(), strSummary.toUTF8(), pMostUnhappyCity->getX(), pMostUnhappyCity->getY(), -1);
			}
		}
	}
#endif
}

//	--------------------------------------------------------------------------------
// Fire off a city revolt somewhere
void CvPlayer::DoCityRevolt()
{
	CvCity *pMostUnhappyCity = GetMostUnhappyCity();
	PlayerTypes eRecipient = GetMostUnhappyCityRecipient();
	if(pMostUnhappyCity && eRecipient != NO_PLAYER)
	{
		CvPlayer &kRecipient = GET_PLAYER(eRecipient);
		for(int iNotifyLoop = 0; iNotifyLoop < MAX_MAJOR_CIVS; ++iNotifyLoop){
			PlayerTypes eNotifyPlayer = (PlayerTypes) iNotifyLoop;
			CvPlayerAI& kCurNotifyPlayer = GET_PLAYER(eNotifyPlayer);
			CvNotifications* pNotifications = kCurNotifyPlayer.GetNotifications();
			if(pNotifications)
			{
				Localization::String strMessage;
				if (eNotifyPlayer == GetID())
				{
					strMessage = GetLocalizedText("TXT_KEY_NOTIFICATION_CITY_REVOLT", pMostUnhappyCity->getName(), kRecipient.getCivilizationShortDescription());
				}
				else
				{
					strMessage = GetLocalizedText("TXT_KEY_NOTIFICATION_OTHER_PLAYER_CITY_REVOLT", getCivilizationAdjective(), pMostUnhappyCity->getName(), kRecipient.getCivilizationShortDescription());
				}
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_REVOLT_SUMMARY");
				pNotifications->Add(NOTIFICATION_CITY_REVOLT, strMessage.toUTF8(), strSummary.toUTF8(), pMostUnhappyCity->getX(), pMostUnhappyCity->getY(), -1);
			}
		}

		kRecipient.acquireCity(pMostUnhappyCity, false/*bConquest*/, false/*bGift*/);

		// Move Units from player that don't belong here
		CvPlot *pPlot = pMostUnhappyCity->plot();
		if(pPlot->getNumUnits() > 0)
		{
			// Get the current list of units because we will possibly be moving them out of the plot's list
			IDInfoVector currentUnits;
			if (pPlot->getUnits(&currentUnits) > 0)
			{
				for(IDInfoVector::const_iterator itr = currentUnits.begin(); itr != currentUnits.end(); ++itr)
				{
					CvUnit* pLoopUnit = (CvUnit*)GetPlayerUnit(*itr);

					if(pLoopUnit && pLoopUnit->getOwner() == GetID())
					{
						pLoopUnit->finishMoves();
						if (!pLoopUnit->jumpToNearestValidPlot())
							pLoopUnit->kill(false);
					}
				}
			}
		}
	}
#if defined(MOD_BALANCE_CORE)
	else if(pMostUnhappyCity && eRecipient == NO_PLAYER && pMostUnhappyCity->getOriginalOwner() != NULL)
	{
		PlayerTypes eOldPlayer = pMostUnhappyCity->getOriginalOwner();
		if(eOldPlayer != NO_PLAYER && !GET_PLAYER(eOldPlayer).isAlive())
		{
			DoRevolutionPlayer(eOldPlayer, pMostUnhappyCity->GetID());
		}
	}
#endif
}

//	--------------------------------------------------------------------------------
// Calculate city that will want to revolt
CvCity *CvPlayer::GetMostUnhappyCity()
{
	CvCity *pRtnValue = NULL;
	int iHighestUnhappiness = -1;

	if (getNumCities() > 1)
	{
		PolicyBranchTypes ePreferredIdeology = GetCulture()->GetPublicOpinionPreferredIdeology();

		int iLoop;
		CvCity* pLoopCity;
		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if (pLoopCity->isCapital())
			{
				continue;
			}

			// mind the sign change
			int iUnhappiness = - pLoopCity->getHappinessDelta(); 

			// Look at each civ
			for (int iLoopPlayer = 0; iLoopPlayer < MAX_MAJOR_CIVS; iLoopPlayer++)
			{
				CvPlayer &kPlayer = GET_PLAYER((PlayerTypes)iLoopPlayer);
				if (iLoopPlayer != GetID() && kPlayer.isAlive() && !kPlayer.isMinorCiv())
				{
					PolicyBranchTypes eOtherCivIdeology = kPlayer.GetPlayerPolicies()->GetLateGamePolicyTree();
					if (eOtherCivIdeology == ePreferredIdeology)
					{
						int iCulturalDominanceOverUs = kPlayer.GetCulture()->GetInfluenceLevel(GetID()) - GetCulture()->GetInfluenceLevel((PlayerTypes)iLoopPlayer);
						if (iCulturalDominanceOverUs > 0 && kPlayer.getCapitalCity() != NULL)
						{
							// Find how far their capital is from this city
							int iCapitalDistance = plotDistance(pLoopCity->getX(), pLoopCity->getY(), kPlayer.getCapitalCity()->getX(), kPlayer.getCapitalCity()->getY());
							if (iCapitalDistance < 100)
							{
								int iDistanceFactor = 100 - iCapitalDistance;
								iDistanceFactor = (int)sqrt((float)iDistanceFactor);
								iUnhappiness += (iDistanceFactor * iCulturalDominanceOverUs);
							}
						}
					}
				}
			}

			if (iUnhappiness > iHighestUnhappiness)
			{
				iHighestUnhappiness = iUnhappiness;
				pRtnValue = pLoopCity;
			}
		}
	}

	return pRtnValue;
}

// Calculate player that will receive city if it revolts
PlayerTypes CvPlayer::GetMostUnhappyCityRecipient()
{
	PlayerTypes eRtnValue = NO_PLAYER;
	CvCity *pMostUnhappyCity = GetMostUnhappyCity();
	int iClosestCapital = MAX_INT;

	if (pMostUnhappyCity)
	{
		PolicyBranchTypes ePreferredIdeology = GetCulture()->GetPublicOpinionPreferredIdeology();

		// Look at each civ
		for (int iLoopPlayer = 0; iLoopPlayer < MAX_MAJOR_CIVS; iLoopPlayer++)
		{
			CvPlayer &kPlayer = GET_PLAYER((PlayerTypes)iLoopPlayer);
			if (iLoopPlayer != GetID() && kPlayer.isAlive() && !kPlayer.isMinorCiv())
			{
				PolicyBranchTypes eOtherCivIdeology = kPlayer.GetPlayerPolicies()->GetLateGamePolicyTree();
				if (eOtherCivIdeology == ePreferredIdeology)
				{
#if defined(MOD_BALANCE_CORE)		
					PublicOpinionTypes eOpinionInMyCiv = GetCulture()->GetPublicOpinionType();
					if(eOpinionInMyCiv == PUBLIC_OPINION_REVOLUTIONARY_WAVE && kPlayer.getCapitalCity() != NULL)
#else
					int iCulturalDominanceOverUs = kPlayer.GetCulture()->GetInfluenceLevel(GetID()) - GetCulture()->GetInfluenceLevel((PlayerTypes)iLoopPlayer);
					if (iCulturalDominanceOverUs > 0 && kPlayer.getCapitalCity() != NULL)
#endif
					{
						// Find how far their capital is from this city
						int iCapitalDistance = plotDistance(pMostUnhappyCity->getX(), pMostUnhappyCity->getY(), kPlayer.getCapitalCity()->getX(), kPlayer.getCapitalCity()->getY());

						if (iCapitalDistance < iClosestCapital)
						{
							iClosestCapital = iCapitalDistance;
							eRtnValue = (PlayerTypes)iLoopPlayer;
						}
					}
				}
			}
		}
	}

	return eRtnValue;
}

//	--------------------------------------------------------------------------------
/// Returns the amount of Happiness being added by Policies
int CvPlayer::GetHappinessFromPolicies() const
{
	int iHappiness = m_pPlayerPolicies->GetNumericModifier(POLICYMOD_EXTRA_HAPPINESS);
	iHappiness += (getNumCities() * m_pPlayerPolicies->GetNumericModifier(POLICYMOD_EXTRA_HAPPINESS_PER_CITY));

#ifdef HH_MOD_NATURAL_WONDER_MODULARITY
	/*
	see CvPlayer::GetHappinessFromNaturalWonders()
	*/
#endif

	int iHappinessPerXPopulation;
#if defined(MOD_BALANCE_CORE_POLICIES)
	int m_iHappinessPerXPopulationGlobal;
	m_iHappinessPerXPopulationGlobal = GetHappinessPerXPopulationGlobal();
#endif
	iHappinessPerXPopulation = GetHappinessPerXPopulation();

	if(iHappinessPerXPopulation > 0)
	{
		const CvCity* pLoopCity;
		int iLoop;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity && !pLoopCity->IsPuppet())
			{
				int iExtraHappiness = pLoopCity->getPopulation() / iHappinessPerXPopulation;

				iHappiness += iExtraHappiness;
			}
		}
	}
#if defined(MOD_BALANCE_CORE_POLICIES)
	if(MOD_BALANCE_CORE_POLICIES && m_iHappinessPerXPopulationGlobal > 0)
	{
		int iTotalPop = getCurrentTotalPop();
		if(iTotalPop > 0)
		{
			int iExtraHappinessGlobal = (iTotalPop / m_iHappinessPerXPopulationGlobal);
			iHappiness += iExtraHappinessGlobal;
		}
	}
#endif

	return iHappiness;
}

//	--------------------------------------------------------------------------------
/// Returns the amount of Local Happiness generated in the cities
int CvPlayer::GetHappinessFromCities() const
{
	int iHappiness = 0;

	const CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iHappiness += pLoopCity->GetLocalHappiness();
	}

	return iHappiness;
}

//	--------------------------------------------------------------------------------
/// Returns the amount of Global Happiness being added by Buildings
int CvPlayer::GetHappinessFromBuildings() const
{
	int iHappiness = 0;
	BuildingClassTypes eBuildingClass;

	// Building Class Mods
	int iSpecialBuildingHappiness = 0;
	for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
	{
		eBuildingClass = (BuildingClassTypes) iI;

		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
		if(!pkBuildingClassInfo)
		{
			continue;
		}

		BuildingTypes eBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eBuildingClass);
		if(eBuilding != NO_BUILDING && countNumBuildings(eBuilding) > 0)
		{
			CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
			if(pkBuilding)
			{
				for(int jJ = 0; jJ < GC.getNumBuildingClassInfos(); jJ++)
				{
					BuildingClassTypes eBuildingClassThatGivesHappiness = (BuildingClassTypes) jJ;
					int iHappinessPerBuilding = pkBuilding->GetBuildingClassHappiness(eBuildingClassThatGivesHappiness);
					if(iHappinessPerBuilding > 0)
					{
						BuildingTypes eBuildingThatGivesHappiness = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eBuildingClassThatGivesHappiness);
						if(eBuildingThatGivesHappiness != NO_BUILDING)
						{
							iSpecialBuildingHappiness += iHappinessPerBuilding * countNumBuildings(eBuildingThatGivesHappiness);
						}
					}
				}
			}
		}
	}
	iHappiness += iSpecialBuildingHappiness;

	const CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iHappiness += pLoopCity->GetHappinessFromBuildings();
	}

	// Increase from num policies -- MOVE THIS CODE (and provide a new tool tip string) if we ever get happiness per X policies to something beside a building
	if(m_iHappinessPerXPolicies > 0)
	{
		iHappiness += GetPlayerPolicies()->GetNumPoliciesOwned() / m_iHappinessPerXPolicies;
	}

	return iHappiness;
}

//	--------------------------------------------------------------------------------
/// Returns the amount of extra Happiness per City
int CvPlayer::GetExtraHappinessPerCity() const
{
	return m_iHappinessPerCity;
}

//	--------------------------------------------------------------------------------
/// Changes amount of extra Happiness per City
void CvPlayer::ChangeExtraHappinessPerCity(int iChange)
{
	CvAssertMsg(m_iHappinessPerCity >= 0, "Count of buildings helping Happiness is corrupted");

	if(iChange != 0)
		m_iHappinessPerCity += iChange;
}

//	--------------------------------------------------------------------------------
/// Returns the amount of extra Happiness per City
int CvPlayer::GetExtraHappinessPerXPolicies() const
{
	return m_iHappinessPerXPolicies;
}

//	--------------------------------------------------------------------------------
/// Changes amount of extra Happiness per City
void CvPlayer::ChangeExtraHappinessPerXPolicies(int iChange)
{
	CvAssertMsg(m_iHappinessPerXPolicies >= 0, "Count of extra happiness per buildings is corrupted");

	if(iChange != 0)
		m_iHappinessPerXPolicies += iChange;
}
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
int CvPlayer::GetHappinessFromResourceMonopolies() const
{
	int iTotalHappiness = 0;
	// Do we get increased Happiness from a resource monopoly?
	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
		CvResourceInfo* pInfo = GC.getResourceInfo(eResourceLoop);
		if (pInfo && pInfo->isMonopoly())
		{
			if(HasGlobalMonopoly(eResourceLoop) && pInfo->getMonopolyHappiness() > 0)
			{
				int iTemp = pInfo->getMonopolyHappiness();
				iTemp += GetMonopolyModFlat();
				iTotalHappiness += iTemp;
			}
		}
	}
	return iTotalHappiness;
}
#endif
//	--------------------------------------------------------------------------------
/// Total amount of Happiness gained from Resources
int CvPlayer::GetHappinessFromResources() const
{
	int iTotalHappiness = 0;

	int iBaseHappiness;

	// Check all connected Resources
	ResourceTypes eResource;
	for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		eResource = (ResourceTypes) iResourceLoop;

		iBaseHappiness = GetHappinessFromLuxury(eResource);
		if(iBaseHappiness)
		{
			// Resource bonus from Minors, and this is a Luxury we're getting from one (Policies, etc.)
			if(IsMinorResourceBonus() && getResourceFromMinors(eResource) > 0)
			{
				iBaseHappiness *= /*150*/ GC.getMINOR_POLICY_RESOURCE_HAPPINESS_MULTIPLIER();
				iBaseHappiness /= 100;
			}

			iTotalHappiness += iBaseHappiness;
			iTotalHappiness += GetExtraHappinessPerLuxury();
		}
	}

	// Happiness bonus for multiple Resource types
	iTotalHappiness += GetHappinessFromResourceVariety();

	return iTotalHappiness;
}

//	--------------------------------------------------------------------------------
/// Amount of Happiness from having a variety of Luxuries
int CvPlayer::GetHappinessFromResourceVariety() const
{
	int iHappiness = 0;

	int iMultipleLuxuriesBonus = /*1*/ GC.getHAPPINESS_PER_EXTRA_LUXURY();

	// Check all connected Resources
	int iNumHappinessResources = 0;

	ResourceTypes eResource;
	for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		eResource = (ResourceTypes) iResourceLoop;

		if(GetHappinessFromLuxury(eResource) > 0)
		{
			iNumHappinessResources++;
		}
	}

	if(iNumHappinessResources > 1)
	{
		iHappiness += (--iNumHappinessResources * iMultipleLuxuriesBonus);
	}

	return iHappiness;
}


//	--------------------------------------------------------------------------------
/// Total amount of Happiness gained from Religion
int CvPlayer::GetHappinessFromReligion()
{
	int iHappinessFromReligion = 0;
	CvGameReligions* pReligions = GC.getGame().GetGameReligions();

	// Founder beliefs
	ReligionTypes eFoundedReligion = GC.getGame().GetGameReligions()->GetFounderBenefitsReligion(GetID());
	if(eFoundedReligion == NO_RELIGION)
	{
		eFoundedReligion = GetReligions()->GetReligionInMostCities();
	}
	if(eFoundedReligion != NO_RELIGION)
	{
		const CvReligion* pReligion = pReligions->GetReligion(eFoundedReligion, GetID());
		if(pReligion)
		{
			bool bAtPeace = GET_TEAM(getTeam()).getAtWarCount(false) == 0;
			iHappinessFromReligion += pReligion->m_Beliefs.GetPlayerHappiness(bAtPeace, GetID());

			float iHappinessPerFollowingCity = pReligion->m_Beliefs.GetHappinessPerFollowingCity(GetID());
			iHappinessFromReligion += (int)((float)pReligions->GetNumCitiesFollowing(eFoundedReligion) * iHappinessPerFollowingCity);

			int iHappinessPerXPeacefulForeignFollowers = pReligion->m_Beliefs.GetHappinessPerXPeacefulForeignFollowers(GetID());
			if (iHappinessPerXPeacefulForeignFollowers > 0)
			{
				iHappinessFromReligion += GetReligions()->GetNumForeignFollowers(true, /*bAtPeace */eFoundedReligion) / iHappinessPerXPeacefulForeignFollowers;
			}
#if defined(MOD_BALANCE_CORE_BELIEFS)
			int iPantheon = 0;
			int iHappiness = pReligion->m_Beliefs.GetHappinessPerPantheon(GetID());
			if(iHappiness > 0)
			{
				iPantheon = GC.getGame().GetGameReligions()->GetNumPantheonsCreated();
				if(iPantheon > 0)
				{
					iHappinessFromReligion += (iPantheon * iHappiness);
				}
			}
#endif
		}
	}

	return iHappinessFromReligion;
}

//	--------------------------------------------------------------------------------
// Happiness from finding Natural Wonders
int CvPlayer::GetHappinessFromNaturalWonders() const
{
	int iNumWonders = GET_TEAM(getTeam()).GetNumNaturalWondersDiscovered();

	int iHappiness = iNumWonders* /*1*/ GC.getHAPPINESS_PER_NATURAL_WONDER();
	
#if defined(HH_MOD_NATURAL_WONDER_MODULARITY)
	int iBonusHappiness = iNumWonders* (m_pPlayerPolicies->GetNumericModifier(POLICYMOD_EXTRA_NATURALWONDER_HAPPINESS));
	iHappiness += iBonusHappiness;
#endif

	// Trait boosts this further?
	if(m_pTraits->GetNaturalWonderHappinessModifier() > 0)
	{
		iHappiness *= (100 + m_pTraits->GetNaturalWonderHappinessModifier());
		iHappiness /= 100;
	}


	for(int iI = 0; iI < GC.getMap().numPlots(); iI++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iI);
		if(pPlot == NULL)
		{
			continue;
		}

		if(pPlot->getOwner() != m_eID)
		{
			continue;
		}

		FeatureTypes eFeature = pPlot->getFeatureType();
		if(eFeature == NO_FEATURE)
		{
			continue;
		}

		int iPlotHappiness = GC.getFeatureInfo(eFeature)->getInBorderHappiness();

		if(iPlotHappiness > 0)
		{
			// Trait boosts this further?
			if(m_pTraits->GetNaturalWonderYieldModifier() > 0)
			{
				iPlotHappiness *= (100 + m_pTraits->GetNaturalWonderYieldModifier());
				iPlotHappiness /= 100;
			}

			iHappiness += iPlotHappiness;
		}
	}

	return iHappiness;
}

//	--------------------------------------------------------------------------------
/// Extra Happiness from every connected Luxury
int CvPlayer::GetExtraHappinessPerLuxury() const
{
	return m_iExtraHappinessPerLuxury;
}

//	--------------------------------------------------------------------------------
/// Change Extra Happiness from every connected Luxury
void CvPlayer::ChangeExtraHappinessPerLuxury(int iChange)
{
	//antonjs: consider: this check wasn't here before, maybe we shouldn't have it in case mods, scenarios use luxuries in a unique malus way
	//CvAssertMsg(m_iExtraHappinessPerLuxury + iChange >= 0, "Net extra happiness per luxury not expected to be negative!");
	// slewis - Hey Anton, I removed this because it was complaining during my awesome Fall of Rome scenario.
	m_iExtraHappinessPerLuxury += iChange;
}
#if defined(MOD_BALANCE_CORE_HAPPINESS)
//	--------------------------------------------------------------------------------
int CvPlayer::getGlobalAverage(YieldTypes eYield) const
{	
	int iYield = 0;

	if(eYield == YIELD_CULTURE)
	{
		iYield = GC.getGame().GetCultureAverage();
	}
	else if(eYield == YIELD_SCIENCE)
	{
		iYield = GC.getGame().GetScienceAverage();
	}
	else if(eYield == YIELD_PRODUCTION)
	{
		iYield = GC.getGame().GetDefenseAverage();
	}
	else if(eYield == YIELD_GOLD)
	{
		iYield = GC.getGame().GetGoldAverage();
	}

	return iYield;
}
#endif
#if defined(MOD_BALANCE_CORE_HAPPINESS_LUXURY)
//	--------------------------------------------------------------------------------
int CvPlayer::getPopNeededForLux() const
{
	//Needed for LUA
	//Happiness as a factor of population and number of cities. Divisor determines this.
	int iLoop;
	int iTotalCities = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			//Venice should get a modification here.
			if(GET_PLAYER(GetID()).GetPlayerTraits()->IsNoAnnexing())
			{
				iTotalCities++;
			}
			else if(!pLoopCity->IsPuppet())
			{
				iTotalCities++;
			}
		}
	}
	int iInflation = GC.getBALANCE_HAPPINESS_POPULATION_DIVISOR();
		
	iInflation *= (100 + getCurrentTotalPop() + iTotalCities);
	iInflation /= 100;

	int iBaseHappiness = 1;
	
	//Happiness as a factor of population and number of cities. Divisor determines this.
	if(GetBaseLuxuryHappiness() <= 0)
	{
		iBaseHappiness = max(iInflation, 1);
	}
	else
	{
		iBaseHappiness = (GetBaseLuxuryHappiness() * iInflation);
	}

	return iBaseHappiness;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetBonusHappinessFromLuxuries() const
{
	if(getCurrentTotalPop() >= getPopNeededForLux())
	{
		GET_PLAYER(GetID()).SetBaseLuxuryHappiness(GetBaseLuxuryHappiness() + 1);
	}
	int iHappiness = GetBaseLuxuryHappiness();
	int iExtraHappiness = 0;
	int iNumHappinessResources = 0;
	ResourceTypes eResource;
	for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		eResource = (ResourceTypes) iResourceLoop;

		if(eResource != NO_RESOURCE && (GetHappinessFromLuxury(eResource) > 0))
		{
			iNumHappinessResources++;
		}
	}
	int iNumLux = iNumHappinessResources;
	if(iNumLux > 0)
	{
		iExtraHappiness = ((iNumLux * iHappiness) / /*8*/ max(1,GC.getBALANCE_HAPPINESS_LUXURY_BASE()));
	}
	return iExtraHappiness;
}
int CvPlayer::GetBaseLuxuryHappiness() const
{
	return m_iBaseLuxuryHappiness;
}

void CvPlayer::SetBaseLuxuryHappiness(int iValue)
{
	if(GetBaseLuxuryHappiness() != iValue)
		m_iBaseLuxuryHappiness = iValue;
}
#endif
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvPlayer::getCurrentTotalPop() const
{
	//Needed for LUA.
	int iLoop;
	int iTotalPop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		//Venice should get a boost here.
		if(GET_PLAYER(GetID()).GetPlayerTraits()->IsNoAnnexing())
		{
			if(pLoopCity != NULL)
			{
				iTotalPop += pLoopCity->getPopulation();
			}
		}
		else if(pLoopCity != NULL && !pLoopCity->IsPuppet())
		{
			iTotalPop += pLoopCity->getPopulation();
		}
	}
	return iTotalPop;
}
#endif
//	--------------------------------------------------------------------------------
/// How much happiness credit for having this resource as a luxury?
int CvPlayer::GetHappinessFromLuxury(ResourceTypes eResource) const
{
	CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);
	if(pkResourceInfo)
	{
		int iBaseHappiness = pkResourceInfo->getHappiness();

		if (GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(GetID(), eResource))
		{
			iBaseHappiness = 0;
		}

		// Only look at Luxuries
		if(pkResourceInfo->getResourceUsage() != RESOURCEUSAGE_LUXURY)
		{
			return 0;
		}

		// Any extras?
		else if(getNumResourceAvailable(eResource, /*bIncludeImport*/ true) > 0)
		{
			return iBaseHappiness;
		}

		else if(GetPlayerTraits()->GetLuxuryHappinessRetention() > 0)
		{
			if(getResourceExport(eResource) > 0)
			{
				return ((iBaseHappiness * GetPlayerTraits()->GetLuxuryHappinessRetention()) / 100);
			}
		}
	}

	return false;
}


//	--------------------------------------------------------------------------------
/// How much Unhappiness are Units producing?
int CvPlayer::GetUnhappinessFromUnits() const
{
	int iUnhappinessFromUnits = m_iUnhappinessFromUnits;

	int iFreeUnitUnhappiness = /*0*/ GC.getFREE_UNIT_HAPPINESS();
	if(iFreeUnitUnhappiness != 0)
	{
#if defined(MOD_API_EXTENSIONS)
		// If unhappy is 2 and free happy is 4, we need to subtract 2
		// If unhappy is 5 and free happy is 4, we need to subtract 4 --> these two make "the min of unhappy and free happy"
		// If unhappy is -2 and free happy is 4, we need to subtract 0 --> this one adds "the previous figure not to be negative"
		iUnhappinessFromUnits -= std::max(0, std::min(iUnhappinessFromUnits, iFreeUnitUnhappiness));
#else
		iUnhappinessFromUnits -= iFreeUnitUnhappiness;
#endif
	}

#if !defined(MOD_API_EXTENSIONS)
	// Can't be less than 0
	if(iUnhappinessFromUnits < 0)
	{
		iUnhappinessFromUnits = 0;
	}
#endif

#if defined(MOD_API_EXTENSIONS)
	if(iUnhappinessFromUnits > 0 && GetUnhappinessFromUnitsMod() != 0)
#else
	if(GetUnhappinessFromUnitsMod() != 0)
#endif
	{
		iUnhappinessFromUnits *= (100 + GetUnhappinessFromUnitsMod());
		iUnhappinessFromUnits /= 100;
	}

	return iUnhappinessFromUnits;
}

//	--------------------------------------------------------------------------------
/// Changes how much Happiness Units produce
void CvPlayer::ChangeUnhappinessFromUnits(int iChange)
{
	m_iUnhappinessFromUnits += iChange;
}

//	--------------------------------------------------------------------------------
/// How much of our Happiness is being used up? (Population + Units)
int CvPlayer::DoUpdateTotalUnhappiness(CvCity* pAssumeCityAnnexed, CvCity* pAssumeCityPuppeted)
{

#if defined(MOD_BALANCE_CORE_HAPPINESS)
	if(isMinorCiv() || isBarbarian())
	{
		return 0;
	}
#endif
	int iUnhappiness = 0;

	// City Count Unhappiness
	iUnhappiness += GetUnhappinessFromCityCount(pAssumeCityAnnexed, pAssumeCityPuppeted);

	// Occupied City Count Unhappiness
	iUnhappiness += GetUnhappinessFromCapturedCityCount(pAssumeCityAnnexed, pAssumeCityPuppeted);

	// City Population Unhappiness
	iUnhappiness += GetUnhappinessFromCityPopulation(pAssumeCityAnnexed, pAssumeCityPuppeted);

	// Occupied City Population Unhappiness
	iUnhappiness += GetUnhappinessFromOccupiedCities(pAssumeCityAnnexed, pAssumeCityPuppeted);

	// Unit Unhappiness (Builders)
	iUnhappiness += GetUnhappinessFromUnits();

	iUnhappiness /= 100;

	iUnhappiness += GetCulture()->GetPublicOpinionUnhappiness();

#if defined(MOD_BALANCE_CORE_HAPPINESS)
	if(MOD_BALANCE_CORE_HAPPINESS)
	{
		iUnhappiness += GetCulture()->GetWarWeariness();

		//These values should return either a positive number, or zero.
		iUnhappiness += (GetUnhappinessFromCitySpecialists(pAssumeCityAnnexed, pAssumeCityPuppeted) / 100);
		iUnhappiness += getUnhappinessFromCitizenNeeds();
	}
#endif

	// AI gets reduced Unhappiness on higher levels
	if(!isHuman() && !IsAITeammateOfHuman())
	{
		iUnhappiness *= GC.getGame().getHandicapInfo().getAIUnhappinessPercent();
		iUnhappiness /= 100;
	}

	SetUnhappiness(iUnhappiness);
	return iUnhappiness;
}

//	--------------------------------------------------------------------------------
/// Used for providing info to the player
int CvPlayer::GetUnhappinessFromCityForUI(CvCity* pCity) const
{
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	if(MOD_BALANCE_CORE_HAPPINESS && (isMinorCiv() || isBarbarian()))
	{
		return 0;
	}
#endif
	int iNumCitiesUnhappinessTimes100 = 0;
	int iPopulationUnhappinessTimes100 = 0;

	int iPopulation = pCity->getPopulation() * 100;

	// No Unhappiness from Specialist Pop? (Policies, etc.)
	if(isHalfSpecialistUnhappiness())
	{
		int iSpecialistCount = pCity->GetCityCitizens()->GetTotalSpecialistCount() * 100;
		iPopulation -= (iSpecialistCount / 2);
	}

	// Occupied?
	if(pCity->IsOccupied() && !pCity->IsIgnoreCityForHappiness())
	{
#if defined(MOD_BALANCE_CORE_HAPPINESS)
		if(MOD_BALANCE_CORE_HAPPINESS)
		{
			//Workaround for odd LUA.
			if(pCity->IsNoOccupiedUnhappiness())
			{
				iNumCitiesUnhappinessTimes100 += (100 * /*2*/ GC.getUNHAPPINESS_PER_CITY());
				iPopulationUnhappinessTimes100 += (iPopulation* /*1*/ GC.getUNHAPPINESS_PER_POPULATION());

				if(pCity->isCapital() && GetCapitalUnhappinessMod() != 0)
				{
					iPopulationUnhappinessTimes100 *= (100 + GetCapitalUnhappinessMod());
					iPopulationUnhappinessTimes100 /= 100;
				}
				if(pCity->GetLocalUnhappinessMod() != 0)
				{
					iPopulationUnhappinessTimes100 *= (100 + pCity->GetLocalUnhappinessMod());
					iPopulationUnhappinessTimes100 /= 100;
				}

				iPopulationUnhappinessTimes100 *= (100 + GetUnhappinessMod());
				iPopulationUnhappinessTimes100 /= 100;

				iPopulationUnhappinessTimes100 *= 100 + GetPlayerTraits()->GetPopulationUnhappinessModifier();
				iPopulationUnhappinessTimes100 /= 100;

					// Population Handicap mod
				iPopulationUnhappinessTimes100 *= getHandicapInfo().getPopulationUnhappinessMod();
				iPopulationUnhappinessTimes100 /= 100;

				// City Count Player mod
				int iMod = 0;
				iMod += GetCityCountUnhappinessMod();
				iMod += GetPlayerTraits()->GetCityUnhappinessModifier();

				iNumCitiesUnhappinessTimes100 *= (100 + iMod);
				iNumCitiesUnhappinessTimes100 /= 100;

				// City Count Handicap mod
				iNumCitiesUnhappinessTimes100 *= getHandicapInfo().getNumCitiesUnhappinessMod();
				iNumCitiesUnhappinessTimes100 /= 100;

				// City Count Map size mod
				iNumCitiesUnhappinessTimes100 *= GC.getMap().getWorldInfo().getNumCitiesUnhappinessPercent();
				iNumCitiesUnhappinessTimes100 /= 100;

				return iNumCitiesUnhappinessTimes100 + iPopulationUnhappinessTimes100;
			}
		}
#endif
		iNumCitiesUnhappinessTimes100 += (100 * /*5*/ GC.getUNHAPPINESS_PER_CAPTURED_CITY());
		iPopulationUnhappinessTimes100 += int(iPopulation* /*1.34f*/ GC.getUNHAPPINESS_PER_OCCUPIED_POPULATION());

		// Mod (Policies, etc.)
		if(GetOccupiedPopulationUnhappinessMod() != 0)
		{
			iPopulationUnhappinessTimes100 *= (100 + GetOccupiedPopulationUnhappinessMod());
			iPopulationUnhappinessTimes100 /= 100;
		}
	}
	// Normal City
	else
	{
		iNumCitiesUnhappinessTimes100 += (100 * /*2*/ GC.getUNHAPPINESS_PER_CITY());
		iPopulationUnhappinessTimes100 += (iPopulation* /*1*/ GC.getUNHAPPINESS_PER_POPULATION());

		if(pCity->isCapital() && GetCapitalUnhappinessMod() != 0)
		{
			iPopulationUnhappinessTimes100 *= (100 + GetCapitalUnhappinessMod());
			iPopulationUnhappinessTimes100 /= 100;
		}
#if defined(MOD_BALANCE_CORE)
		if(pCity->GetLocalUnhappinessMod() != 0)
		{
			iPopulationUnhappinessTimes100 *= (100 + pCity->GetLocalUnhappinessMod());
			iPopulationUnhappinessTimes100 /= 100;
		}
#endif

		iPopulationUnhappinessTimes100 *= (100 + GetUnhappinessMod());
		iPopulationUnhappinessTimes100 /= 100;

		iPopulationUnhappinessTimes100 *= 100 + GetPlayerTraits()->GetPopulationUnhappinessModifier();
		iPopulationUnhappinessTimes100 /= 100;
	}

	// Population Handicap mod
	iPopulationUnhappinessTimes100 *= getHandicapInfo().getPopulationUnhappinessMod();
	iPopulationUnhappinessTimes100 /= 100;

	// City Count Player mod
	int iMod = 0;
	iMod += GetCityCountUnhappinessMod();
	iMod += GetPlayerTraits()->GetCityUnhappinessModifier();

	iNumCitiesUnhappinessTimes100 *= (100 + iMod);
	iNumCitiesUnhappinessTimes100 /= 100;

	// City Count Handicap mod
	iNumCitiesUnhappinessTimes100 *= getHandicapInfo().getNumCitiesUnhappinessMod();
	iNumCitiesUnhappinessTimes100 /= 100;

	// City Count Map size mod
	iNumCitiesUnhappinessTimes100 *= GC.getMap().getWorldInfo().getNumCitiesUnhappinessPercent();
	iNumCitiesUnhappinessTimes100 /= 100;

	return iNumCitiesUnhappinessTimes100 + iPopulationUnhappinessTimes100;
}

//	--------------------------------------------------------------------------------
/// Unhappiness from number of Cities
int CvPlayer::GetUnhappinessFromCityCount(CvCity* pAssumeCityAnnexed, CvCity* pAssumeCityPuppeted) const
{
	int iUnhappiness = 0;
	int iUnhappinessPerCity = /*2*/ GC.getUNHAPPINESS_PER_CITY() * 100;

	bool bCityValid;

	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		bCityValid = false;

		// Assume city is puppeted, and counts
		if(pLoopCity == pAssumeCityPuppeted)
			bCityValid = true;
		// Assume city is annexed, and does NOT count
		else if(pLoopCity == pAssumeCityAnnexed)
			bCityValid = false;
		// Assume city doesn't exist, and does NOT count
		else if(pLoopCity->IsIgnoreCityForHappiness())
			bCityValid = false;
		// Normal city
		else if(!pLoopCity->IsOccupied() || pLoopCity->IsNoOccupiedUnhappiness())
			bCityValid = true;
#if defined(MOD_BALANCE_CORE_HAPPINESS)
		if(MOD_BALANCE_CORE_HAPPINESS)
		{
			//Tradition policy bonus - Capital grants no founding unhappiness.
			if(pLoopCity->isCapital() && GetCapitalUnhappinessMod() != 0)
			{
				bCityValid = false;
			}
		}
#endif
#if defined(MOD_BALANCE_CORE_POLICIES)
		if(MOD_BALANCE_CORE_POLICIES)
		{
			//Expansion policy bonus - Cities grant no unhappiness from expansion.
			if(IsNoUnhappinessExpansion())
			{
				bCityValid = false;
			}
		}
#endif
		if(bCityValid)
			iUnhappiness += iUnhappinessPerCity;
	}

	// Player count mod
	int iMod = 0;
	iMod += GetCityCountUnhappinessMod();
	iMod += GetPlayerTraits()->GetCityUnhappinessModifier();

	iUnhappiness *= (100 + iMod);
	iUnhappiness /= 100;

	// Handicap mod
	iUnhappiness *= getHandicapInfo().getNumCitiesUnhappinessMod();
	iUnhappiness /= 100;

	// Map size mod
	iUnhappiness *= GC.getMap().getWorldInfo().getNumCitiesUnhappinessPercent();
	iUnhappiness /= 100;

	return iUnhappiness;
}

//	--------------------------------------------------------------------------------
/// Unhappiness from number of Captured Cities
int CvPlayer::GetUnhappinessFromCapturedCityCount(CvCity* pAssumeCityAnnexed, CvCity* pAssumeCityPuppeted) const
{
	int iUnhappiness = 0;
	int iUnhappinessPerCapturedCity = /*5*/ GC.getUNHAPPINESS_PER_CAPTURED_CITY() * 100;

	bool bCityValid;

	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		bCityValid = false;

		// Assume city is puppeted, and does NOT count
		if(pLoopCity == pAssumeCityPuppeted)
			bCityValid = false;
		// Assume city is annexed, and counts
		else if(pLoopCity == pAssumeCityAnnexed)
			bCityValid = true;
		// Assume city doesn't exist, and does NOT count
		else if(pLoopCity->IsIgnoreCityForHappiness())
			bCityValid = false;
		// Occupied city
		else if(pLoopCity->IsOccupied() && !pLoopCity->IsNoOccupiedUnhappiness())
			bCityValid = true;

		// Extra Unhappiness from Occupied Cities
		if(bCityValid)
			iUnhappiness += iUnhappinessPerCapturedCity;
	}

	// Player count mod
	int iMod = 0;
	iMod += GetCityCountUnhappinessMod();
	iMod += GetPlayerTraits()->GetCityUnhappinessModifier();

	iUnhappiness *= (100 + iMod);
	iUnhappiness /= 100;

	// Handicap mod
	iUnhappiness *= getHandicapInfo().getNumCitiesUnhappinessMod();
	iUnhappiness /= 100;

	// Map size mod
	iUnhappiness *= GC.getMap().getWorldInfo().getNumCitiesUnhappinessPercent();
	iUnhappiness /= 100;

	return iUnhappiness;
}

//	--------------------------------------------------------------------------------
/// Unhappiness from City Population
int CvPlayer::GetUnhappinessFromCityPopulation(CvCity* pAssumeCityAnnexed, CvCity* pAssumeCityPuppeted) const
{

#if defined(MOD_BALANCE_CORE_HAPPINESS)
	if(MOD_BALANCE_CORE_HAPPINESS)
	{
		return 0;
	}
#endif
	int iUnhappiness = 0;
	int iUnhappinessFromThisCity;

	int iUnhappinessPerPop = /*1*/ GC.getUNHAPPINESS_PER_POPULATION() * 100;
	int iPopulation;
	int iSpecialistCount;

	bool bCityValid;

	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		bCityValid = false;

		// Assume pLoopCity is Annexed, and does NOT count
		if(pLoopCity == pAssumeCityAnnexed)
			bCityValid = false;
		// Assume that pLoopCity is a Puppet and IS counted here
		else if(pLoopCity == pAssumeCityPuppeted)
			bCityValid = true;
		// Assume city doesn't exist, and does NOT count
		else if(pLoopCity->IsIgnoreCityForHappiness())
			bCityValid = false;
		// Occupied Cities don't get counted here (see the next function)
		else if(!pLoopCity->IsOccupied() || pLoopCity->IsNoOccupiedUnhappiness())
			bCityValid = true;

		if(bCityValid)
		{
			iPopulation = pLoopCity->getPopulation();

			// No Unhappiness from Specialist Pop? (Policies, etc.)
			if(isHalfSpecialistUnhappiness())
			{
				iSpecialistCount = pLoopCity->GetCityCitizens()->GetTotalSpecialistCount();
				iSpecialistCount++; // Round up
				iPopulation -= (iSpecialistCount / 2);
			}

			iUnhappinessFromThisCity = iPopulation * iUnhappinessPerPop;

			if(pLoopCity->isCapital() && GetCapitalUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + GetCapitalUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#if defined(MOD_BALANCE_CORE)
			if(pLoopCity->GetLocalUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + pLoopCity->GetLocalUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#endif

			iUnhappiness += iUnhappinessFromThisCity;
		}
	}

	iUnhappiness *= (100 + GetUnhappinessMod());
	iUnhappiness /= 100;

	iUnhappiness *= 100 + GetPlayerTraits()->GetPopulationUnhappinessModifier();
	iUnhappiness /= 100;

	// Handicap mod
	iUnhappiness *= getHandicapInfo().getPopulationUnhappinessMod();
	iUnhappiness /= 100;

	return iUnhappiness;
}

//	--------------------------------------------------------------------------------
/// Unhappiness from Puppet City Population
int CvPlayer::GetUnhappinessFromPuppetCityPopulation() const
{
	int iUnhappiness = 0;
	int iUnhappinessPerPop = GC.getUNHAPPINESS_PER_POPULATION() * 100;

	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		bool bCityValid = false;

		if(pLoopCity->IsPuppet())
			bCityValid = true;

		// Assume city doesn't exist, and does NOT count
		if(pLoopCity->IsIgnoreCityForHappiness())
			bCityValid = false;

		if(bCityValid)
		{
			int iPopulation = pLoopCity->getPopulation();

			// No Unhappiness from Specialist Pop? (Policies, etc.)
			// slewis - 2013.5.7 
			// This function, along with GetUnhappinessFromCitySpecialists, is only called through the UI to reflect 
			// to the player what's going on with their happiness. So I removed the effect that specialists have on 
			// puppeted cities and let the GetUnhappinessFromCitySpecialists correct that problem.

			/*if(isHalfSpecialistUnhappiness())
			{
				int iSpecialistCount = pLoopCity->GetCityCitizens()->GetTotalSpecialistCount();
				iSpecialistCount++; // Round up
				iPopulation -= (iSpecialistCount / 2);
			}*/
			iPopulation -= pLoopCity->GetCityCitizens()->GetTotalSpecialistCount();

			int iUnhappinessFromThisCity = iPopulation * iUnhappinessPerPop;

			if(pLoopCity->isCapital() && GetCapitalUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + GetCapitalUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#if defined(MOD_BALANCE_CORE)
			if(pLoopCity->GetLocalUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + pLoopCity->GetLocalUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#endif

			iUnhappiness += iUnhappinessFromThisCity;
		}
	}

	iUnhappiness *= (100 + GetUnhappinessMod());
	iUnhappiness /= 100;

	iUnhappiness *= 100 + GetPlayerTraits()->GetPopulationUnhappinessModifier();
	iUnhappiness /= 100;

	// Handicap mod
	iUnhappiness *= getHandicapInfo().getPopulationUnhappinessMod();
	iUnhappiness /= 100;

	return iUnhappiness;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetUnhappinessFromCitySpecialists(CvCity* pAssumeCityAnnexed, CvCity* pAssumeCityPuppeted) const
{
	int iUnhappiness = 0;
	int iUnhappinessFromThisCity;
	int iUnhappinessPerPop = /*1*/ GC.getUNHAPPINESS_PER_POPULATION() * 100;
	int iPopulation;

	bool bCityValid;

	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		bCityValid = false;

		// Assume pLoopCity is Annexed, and does NOT count
		if(pLoopCity == pAssumeCityAnnexed)
			bCityValid = false;
		// Assume that pLoopCity is a Puppet and IS counted here
		else if(pLoopCity == pAssumeCityPuppeted)
			bCityValid = true;
		// Assume city doesn't exist, and does NOT count
		else if(pLoopCity->IsIgnoreCityForHappiness())
			bCityValid = false;
		// Occupied Cities don't get counted here (see the next function)
		else if(!pLoopCity->IsOccupied() || pLoopCity->IsNoOccupiedUnhappiness())
			bCityValid = true;

		if(bCityValid)
		{
			iPopulation = pLoopCity->GetCityCitizens()->GetTotalSpecialistCount();

			// No Unhappiness from Specialist Pop? (Policies, etc.)
			if(isHalfSpecialistUnhappiness())
			{
				iPopulation++; // Round up
				iPopulation /= 2;
			}
#if defined(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS)
			//Less unhappiness from specialists....
			if(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS)
			{
				iUnhappinessPerPop = /*25*/ GC.getBALANCE_UNHAPPINESS_PER_SPECIALIST();
				int iNoHappinessSpecialists = 0;
				if(iPopulation > 0)
				{
					//...in capital?
					if(pLoopCity->isCapital())
					{
						iNoHappinessSpecialists += GetNoUnhappfromXSpecialistsCapital();
					}
					//...elsewhere?	
					iNoHappinessSpecialists += GetNoUnhappfromXSpecialists();
				}
				//Can't give more free happiness than specialists.
				if(iNoHappinessSpecialists > iPopulation)
				{
					iNoHappinessSpecialists = iPopulation;
				}
				if(iNoHappinessSpecialists > 0)
				{
					iPopulation -= iNoHappinessSpecialists;
				}
			}
#endif

			iUnhappinessFromThisCity = iPopulation * iUnhappinessPerPop;

#if defined(MOD_BALANCE_CORE_HAPPINESS)
			if(MOD_BALANCE_CORE_HAPPINESS)
			{
				iUnhappiness += iUnhappinessFromThisCity;
			}
			if(!MOD_BALANCE_CORE_HAPPINESS)
			{
//Took these away as they were making specialists do weird things.
#endif
			if(pLoopCity->isCapital() && GetCapitalUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + GetCapitalUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#if defined(MOD_BALANCE_CORE)
			if(pLoopCity->GetLocalUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + pLoopCity->GetLocalUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#endif

			iUnhappiness += iUnhappinessFromThisCity;
#if defined(MOD_BALANCE_CORE_HAPPINESS)
			}
#endif
		}
	}
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	if(!MOD_BALANCE_CORE_HAPPINESS)
	{
#endif
	iUnhappiness *= (100 + GetUnhappinessMod());
	iUnhappiness /= 100;

	iUnhappiness *= 100 + GetPlayerTraits()->GetPopulationUnhappinessModifier();
	iUnhappiness /= 100;

	// Handicap mod
	iUnhappiness *= getHandicapInfo().getPopulationUnhappinessMod();
	iUnhappiness /= 100;

#if defined(MOD_BALANCE_CORE_HAPPINESS)
	}
#endif
	return iUnhappiness;
}

//	--------------------------------------------------------------------------------
/// Unhappiness from City Population in Occupied Cities
int CvPlayer::GetUnhappinessFromOccupiedCities(CvCity* pAssumeCityAnnexed, CvCity* pAssumeCityPuppeted) const
{
	int iUnhappiness = 0;
	int iUnhappinessFromThisCity;

	double fUnhappinessPerPop = /*1.34f*/ GC.getUNHAPPINESS_PER_OCCUPIED_POPULATION() * 100;
	int iPopulation;
	int iSpecialistCount;

	bool bCityValid;
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	bool bIsResistance;
#endif
	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		bCityValid = false;
#if defined(MOD_BALANCE_CORE_HAPPINESS)
		bIsResistance = false;
#endif
		// Assume pLoopCity is Annexed, and counts
		if(pLoopCity == pAssumeCityAnnexed)
			bCityValid = true;
		// Assume that pLoopCity is a Puppet and does NOT count
		else if(pLoopCity == pAssumeCityPuppeted)
			bCityValid = false;
		// Assume city doesn't exist, and does NOT count
		else if(pLoopCity->IsIgnoreCityForHappiness())
			bCityValid = false;
		// Occupied Cities
		else if(pLoopCity->IsOccupied() && !pLoopCity->IsNoOccupiedUnhappiness())
			bCityValid = true;
#if defined(MOD_BALANCE_CORE_HAPPINESS)
		if(MOD_BALANCE_CORE_HAPPINESS && (pLoopCity->IsResistance() || pLoopCity->IsRazing()))
		{
			bCityValid = true;
			bIsResistance = true;
		}
#endif

		if(bCityValid)
		{
			iPopulation = pLoopCity->getPopulation();
#if defined(MOD_BALANCE_CORE_HAPPINESS)
			if(MOD_BALANCE_CORE_HAPPINESS && bIsResistance)
			{
				iPopulation /= 2;
			}
#endif
			// No Unhappiness from Specialist Pop? (Policies, etc.)
			if(isHalfSpecialistUnhappiness())
			{
				iSpecialistCount = pLoopCity->GetCityCitizens()->GetTotalSpecialistCount();
				iSpecialistCount++; // Round up
				iPopulation -= (iSpecialistCount / 2);
			}

			iUnhappinessFromThisCity = int(double(iPopulation) * fUnhappinessPerPop);

			// Mod (Policies, etc.)
			if(GetOccupiedPopulationUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + GetOccupiedPopulationUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#if defined(MOD_BALANCE_CORE_POLICIES)
			if(MOD_BALANCE_CORE_POLICIES && GetGarrisonsOccupiedUnhapppinessMod() != 0)
			{
				if(pLoopCity->HasGarrison())
				{
					iUnhappinessFromThisCity *= (100 + GetGarrisonsOccupiedUnhapppinessMod());
					iUnhappinessFromThisCity /= 100;
				}
			}
#endif

			iUnhappiness += iUnhappinessFromThisCity;
		}
	}

	// Handicap mod
	iUnhappiness *= getHandicapInfo().getPopulationUnhappinessMod();
	iUnhappiness /= 100;

	return iUnhappiness;
}

//	--------------------------------------------------------------------------------
/// Unhappiness from Units Percent (50 = 50% of normal)
int CvPlayer::GetUnhappinessFromUnitsMod() const
{
	return m_iUnhappinessFromUnitsMod;
}

//	--------------------------------------------------------------------------------
/// Change Unhappiness from Units Percent (50 = 50% of normal)
void CvPlayer::ChangeUnhappinessFromUnitsMod(int iChange)
{
	if(iChange != 0)
	{
		m_iUnhappinessFromUnitsMod += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Unhappiness Mod (-50 = 50% of normal)
int CvPlayer::GetUnhappinessMod() const
{
	return m_iUnhappinessMod;
}

//	--------------------------------------------------------------------------------
/// Change Unhappiness Mod (-50 = 50% of normal)
void CvPlayer::ChangeUnhappinessMod(int iChange)
{
	if(iChange != 0)
	{
		m_iUnhappinessMod += iChange;
	}
}
#if defined(MOD_BALANCE_CORE_HAPPINESS)
int CvPlayer::getUnhappinessFromCitizenNeeds() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			iUnhappiness += pLoopCity->getUnhappinessAggregated();
		}
	}
	return iUnhappiness;
}

int CvPlayer::getUnhappinessFromCityCulture() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			iUnhappiness += pLoopCity->getUnhappinessFromCulture();
		}
	}
	return iUnhappiness;
}
int CvPlayer::getUnhappinessFromCityScience() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			iUnhappiness += pLoopCity->getUnhappinessFromScience();
		}
	}
	return iUnhappiness;
}
int CvPlayer::getUnhappinessFromCityDefense() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			iUnhappiness += pLoopCity->getUnhappinessFromDefense();
		}		
	}
	return iUnhappiness;
}
int CvPlayer::getUnhappinessFromCityGold() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			iUnhappiness += pLoopCity->getUnhappinessFromGold();
		}
	}
	return iUnhappiness;
}
int CvPlayer::getUnhappinessFromCityConnection() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			iUnhappiness += pLoopCity->getUnhappinessFromConnection();
		}
	}
	return iUnhappiness;
}
int CvPlayer::getUnhappinessFromCityPillaged() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			iUnhappiness += pLoopCity->getUnhappinessFromPillaged();
		}
	}
	return iUnhappiness;
}
int CvPlayer::getUnhappinessFromCityStarving() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			iUnhappiness += pLoopCity->getUnhappinessFromStarving();
		}
	}
	return iUnhappiness;
}
int CvPlayer::getUnhappinessFromCityMinority() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			iUnhappiness += pLoopCity->getUnhappinessFromReligion();
		}
	}
	return iUnhappiness;
}
#endif

//	--------------------------------------------------------------------------------
/// City Count Unhappiness Mod (-50 = 50% of normal)
int CvPlayer::GetCityCountUnhappinessMod() const
{
	return m_iCityCountUnhappinessMod;
}

//	--------------------------------------------------------------------------------
/// Change City Count Unhappiness Mod (-50 = 50% of normal)
void CvPlayer::ChangeCityCountUnhappinessMod(int iChange)
{
	if(iChange != 0)
	{
		m_iCityCountUnhappinessMod += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Occupied Population Unhappiness Mod (-50 = 50% of normal)
int CvPlayer::GetOccupiedPopulationUnhappinessMod() const
{
	return m_iOccupiedPopulationUnhappinessMod;
}

//	--------------------------------------------------------------------------------
/// Occupied Population Count Unhappiness Mod (-50 = 50% of normal)
void CvPlayer::ChangeOccupiedPopulationUnhappinessMod(int iChange)
{
	if(iChange != 0)
	{
		m_iOccupiedPopulationUnhappinessMod += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Unhappiness from Capital Mod (-50 = 50% of normal)
int CvPlayer::GetCapitalUnhappinessMod() const
{
	return m_iCapitalUnhappinessMod;
}

//	--------------------------------------------------------------------------------
/// Change Unhappiness from Capital Mod (-50 = 50% of normal)
void CvPlayer::ChangeCapitalUnhappinessMod(int iChange)
{
	if(iChange != 0)
	{
		m_iCapitalUnhappinessMod += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// How much Happiness are we getting from Units being Garrisoned in Cities?
int CvPlayer::GetHappinessPerGarrisonedUnit() const
{
	return m_iHappinessPerGarrisonedUnitCount;
}

//	--------------------------------------------------------------------------------
/// Set the amount of Happiness we're getting from Units being Garrisoned in Cities
void CvPlayer::SetHappinessPerGarrisonedUnit(int iValue)
{
	m_iHappinessPerGarrisonedUnitCount = iValue;
}

//	--------------------------------------------------------------------------------
/// Change the amount of Happiness we're getting from Units being Garrisoned in Cities
void CvPlayer::ChangeHappinessPerGarrisonedUnit(int iChange)
{
	SetHappinessPerGarrisonedUnit(m_iHappinessPerGarrisonedUnitCount + iChange);
}

//	--------------------------------------------------------------------------------
/// Returns cached amount of Happiness being brought in for having Cities connected via a Route
int CvPlayer::GetHappinessFromTradeRoutes() const
{
	return m_iCityConnectionHappiness;
}

//	--------------------------------------------------------------------------------
/// How much Happiness coming from Trade Routes?
void CvPlayer::DoUpdateCityConnectionHappiness()
{
	int iHappinessPerTradeRoute = GetHappinessPerTradeRoute();

	int iNumCities = 0;
	if(iHappinessPerTradeRoute != 0)
	{
		CvCity* pCapitalCity = getCapitalCity();

		// Must have a capital before we can check if other Cities are connected to it!
		if(pCapitalCity != NULL && getNumCities() > 1)
		{
			CvCity* pLoopCity;

			int iLoop;
			for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				if(pLoopCity != pCapitalCity)
				{
					if(GetTreasury()->HasCityConnectionRouteBetweenCities(pCapitalCity, pLoopCity))
					{
						iNumCities++;
					}
				}
			}
		}
	}
	m_iCityConnectionHappiness = iHappinessPerTradeRoute * iNumCities / 100;	// Bring it out of hundreds
}

//	--------------------------------------------------------------------------------
/// How muchHappiness are we getting from Trade Routes?
int CvPlayer::GetHappinessPerTradeRoute() const
{
	return m_iHappinessPerTradeRouteCount;
}

//	--------------------------------------------------------------------------------
/// Set the amont of Happiness we're getting from Trade Routes
void CvPlayer::SetHappinessPerTradeRoute(int iValue)
{
	m_iHappinessPerTradeRouteCount = iValue;
}

//	--------------------------------------------------------------------------------
/// Change the amont of Happiness we're getting from Trade Routes
void CvPlayer::ChangeHappinessPerTradeRoute(int iChange)
{
	SetHappinessPerTradeRoute(m_iHappinessPerTradeRouteCount + iChange);
}

//	--------------------------------------------------------------------------------
/// How much Happiness are we getting from large cities?
int CvPlayer::GetHappinessPerXPopulation() const
{
	return m_iHappinessPerXPopulation;
}

//	--------------------------------------------------------------------------------
/// Set the amount of Happiness we're getting from large cities
void CvPlayer::SetHappinessPerXPopulation(int iValue)
{
	m_iHappinessPerXPopulation = iValue;
}

//	--------------------------------------------------------------------------------
/// Change the amount of Happiness we're getting from large cities
void CvPlayer::ChangeHappinessPerXPopulation(int iChange)
{
	SetHappinessPerXPopulation(m_iHappinessPerXPopulation + iChange);
}
#if defined(MOD_BALANCE_CORE_POLICIES)
//	--------------------------------------------------------------------------------
/// How much Happiness are we getting from large empires?
int CvPlayer::GetHappinessPerXPopulationGlobal() const
{
	return m_iHappinessPerXPopulationGlobal;
}

//	--------------------------------------------------------------------------------
/// Set the amount of Happiness we're getting from large empires
void CvPlayer::SetHappinessPerXPopulationGlobal(int iValue)
{
	m_iHappinessPerXPopulationGlobal = iValue;
}

//	--------------------------------------------------------------------------------
/// Change the amount of Happiness we're getting from large empires
void CvPlayer::ChangeHappinessPerXPopulationGlobal(int iChange)
{
	SetHappinessPerXPopulationGlobal(m_iHappinessPerXPopulationGlobal + iChange);
}
/// How much Happiness are we getting from large empires?
int CvPlayer::GetIdeologyPoint() const
{
	return m_iIdeologyPoint;
}

//	--------------------------------------------------------------------------------
/// Set the amount of Happiness we're getting from large empires
void CvPlayer::SetIdeologyPoint(int iValue)
{
	m_iIdeologyPoint = iValue;
}

//	--------------------------------------------------------------------------------
/// Change the amount of Happiness we're getting from large empires
void CvPlayer::ChangeIdeologyPoint(int iChange)
{
	SetIdeologyPoint(m_iIdeologyPoint + iChange);
}

void CvPlayer::SetOrderCorp(bool bValue)
{
	if(m_bOrderCorp != bValue)
	{
		m_bOrderCorp = bValue;
	}
}
void CvPlayer::SetAutocracyCorp(bool bValue)
{
	if(m_bAutocracyCorp != bValue)
	{
		m_bAutocracyCorp = bValue;
	}
}
void CvPlayer::SetFreedomCorp(bool bValue)
{
	if(m_bFreedomCorp != bValue)
	{
		m_bFreedomCorp = bValue;
	}
}
bool CvPlayer::IsOrderCorp()
{
	return m_bOrderCorp;
}
bool CvPlayer::IsAutocracyCorp()
{
	 return m_bAutocracyCorp; 
}
bool CvPlayer::IsFreedomCorp()
{
	return m_bFreedomCorp;
}
#endif
//	--------------------------------------------------------------------------------
/// Happiness from Minors
int CvPlayer::GetHappinessFromMinorCivs() const
{
	int iHappiness = 0;
	PlayerTypes eMinor;
	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		eMinor = (PlayerTypes) iMinorLoop;
		iHappiness += GetHappinessFromMinor(eMinor);
	}
	return iHappiness;
}

//	--------------------------------------------------------------------------------
/// Happiness from a Minor
int CvPlayer::GetHappinessFromMinor(PlayerTypes eMinor) const
{
	int iAmount = 0;

	if(GET_PLAYER(eMinor).isAlive())
	{
		// Includes flat bonus and any per luxury bonus
		iAmount += GET_PLAYER(eMinor).GetMinorCivAI()->GetCurrentHappinessBonus(GetID());
	}

	return iAmount;
}

//	--------------------------------------------------------------------------------
/// Happiness from Leagues
int CvPlayer::GetHappinessFromLeagues() const
{
	return m_iHappinessFromLeagues;
}

//	--------------------------------------------------------------------------------
/// Happiness from Leagues
void CvPlayer::SetHappinessFromLeagues(int iValue)
{
	m_iHappinessFromLeagues = iValue;
}

//	--------------------------------------------------------------------------------
/// Happiness from Leagues
void CvPlayer::ChangeHappinessFromLeagues(int iChange)
{
	SetHappinessFromLeagues(GetHappinessFromLeagues() + iChange);
}

//	--------------------------------------------------------------------------------
/// Get the global modifier on the espionage progress rate
int CvPlayer::GetEspionageModifier() const
{
	return m_iEspionageModifier;
}

//	--------------------------------------------------------------------------------
/// Change the global modifier on the espionage progress rate
void CvPlayer::ChangeEspionageModifier(int iChange)
{
	m_iEspionageModifier = (m_iEspionageModifier + iChange);
}

//	--------------------------------------------------------------------------------
/// At what rank do spies start the game at?
int CvPlayer::GetStartingSpyRank() const
{
	return m_iSpyStartingRank;
}

//	--------------------------------------------------------------------------------
/// Change the rank that spies start the game at
void CvPlayer::ChangeStartingSpyRank(int iChange)
{
	m_iSpyStartingRank = (m_iSpyStartingRank + iChange);
}

#if defined(MOD_RELIGION_CONVERSION_MODIFIERS)
//	--------------------------------------------------------------------------------
/// Get the global modifier on the conversion progress rate
int CvPlayer::GetConversionModifier() const
{
	return m_iConversionModifier;
}

//	--------------------------------------------------------------------------------
/// Change the global modifier on the conversion progress rate
void CvPlayer::ChangeConversionModifier(int iChange)
{
	m_iConversionModifier = (m_iConversionModifier + iChange);
}
#endif

//	--------------------------------------------------------------------------------
/// Extra league votes
int CvPlayer::GetExtraLeagueVotes() const
{
	return m_iExtraLeagueVotes;
}

#if defined(MOD_DIPLOMACY_CITYSTATES)
//	--------------------------------------------------------------------------------
/// Extra league votes from faith
int CvPlayer::GetFaithToVotes() const
{
	return m_iFaithToVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from faith
void CvPlayer::ChangeFaithToVotes(int iChange)
{
	m_iFaithToVotes = iChange;
	CvAssert(m_iFaithToVotes >= 0);
	if (m_iFaithToVotes < 0)
	{
		m_iFaithToVotes = 0;
	}
}

//	--------------------------------------------------------------------------------
/// Extra league votes from faith
int CvPlayer::TestFaithToVotes(int iChange)
{
	int iFaithVotes = 0;
	int iFollowers = 0;
	int iTotalFaithVotes = 0;
	CvGameReligions* pReligions = GC.getGame().GetGameReligions();

	// Number of Cities Following Religion
	ReligionTypes eFoundedReligion = pReligions->GetFounderBenefitsReligion(GetID());
	if(eFoundedReligion != NO_RELIGION)
	{
		if(iChange > 0)
		{
			iFaithVotes = iChange;
			iFollowers = pReligions->GetNumCitiesFollowing(eFoundedReligion);
			int iMaxVotes = pReligions->GetNumReligionsFounded();
			iTotalFaithVotes = (iFollowers / iFaithVotes);
			//Never fewer than one vote.
			if(iTotalFaithVotes < 1)
			{
				iTotalFaithVotes = 1;
			}
			//No more votes than religions in the game - this should scale votes much better.
			else if(iTotalFaithVotes > iMaxVotes)
			{
				iTotalFaithVotes = iMaxVotes;
			}
		}
	}
	return iTotalFaithVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from conquered capitals
int CvPlayer::GetCapitalsToVotes() const
{
	return m_iCapitalsToVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from conquered capitals
void CvPlayer::ChangeCapitalsToVotes(int iChange)
{
	m_iCapitalsToVotes = iChange;
	CvAssert(m_iCapitalsToVotes >= 0);
	if (m_iCapitalsToVotes < 0)
	{
		m_iCapitalsToVotes = 0;
	}
}

//	--------------------------------------------------------------------------------
/// Extra league votes from conquered capitals
int CvPlayer::TestCapitalsToVotes(int iChange)
{
	int iCapitalVotes = 0;

	if(iChange > 0)
	{
		iCapitalVotes = (GetNumCapitalCities() * iChange);
	}
	return iCapitalVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from DoF
int CvPlayer::GetDoFToVotes() const
{
	return m_iDoFToVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from DoF
void CvPlayer::ChangeDoFToVotes(int iChange)
{
	m_iDoFToVotes = iChange;
	CvAssert(m_iDoFToVotes >= 0);
	if (m_iDoFToVotes < 0)
	{
		m_iDoFToVotes = 0;
	}
}

//	--------------------------------------------------------------------------------
/// Extra league votes from DoF
int CvPlayer::TestDoFToVotes(int iChange)
{
	int iDoFToVotes = 0;
	
	if(iChange > 0)
	{
		iDoFToVotes = (GetDiplomacyAI()->GetNumDoF() * iChange);
	}
	
	return iDoFToVotes;

}

//	--------------------------------------------------------------------------------
/// Extra league votes from RA
int CvPlayer::GetRAToVotes() const
{
	return m_iRAToVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from RA
void CvPlayer::ChangeRAToVotes(int iChange)
{
	m_iRAToVotes = iChange;
	CvAssert(m_iRAToVotes >= 0);
	if (m_iRAToVotes < 0)
	{
		m_iRAToVotes = 0;
	}
}

//	--------------------------------------------------------------------------------
/// Extra league votes from RA
int CvPlayer::TestRAToVotes(int iChange)
{
	int iRAToVotes = 0;
	
	if(iChange > 0)
	{
		iRAToVotes = (GetDiplomacyAI()->GetNumRA() * iChange);
	}
	
	return iRAToVotes;
}
//	--------------------------------------------------------------------------------
/// Extra league votes from RA
int CvPlayer::GetDefensePactsToVotes() const
{
	return m_iDefensePactsToVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from RA
void CvPlayer::ChangeDefensePactsToVotes(int iChange)
{
	m_iDefensePactsToVotes = iChange;
	CvAssert(m_iDefensePactsToVotes >= 0);
	if (m_iDefensePactsToVotes < 0)
	{
		m_iDefensePactsToVotes = 0;
	}
}
//	--------------------------------------------------------------------------------
/// Extra league votes from Defense Pacts
int CvPlayer::TestDefensePactsToVotes(int iChange)
{
	int iDefensePactsToVotes = 0;
	
	if(iChange > 0)
	{
		iDefensePactsToVotes = (GetDiplomacyAI()->GetNumDefensePacts() * iChange);
	}
	
	return iDefensePactsToVotes;
}

//	--------------------------------------------------------------------------------
/// Extra influence from GPs
int CvPlayer::GetGPExpendInfluence() const
{
	return m_iGPExpendInfluence;
}

//	--------------------------------------------------------------------------------
/// Extra influence from GPs
void CvPlayer::ChangeGPExpendInfluence(int iChange)
{
	m_iGPExpendInfluence += iChange;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from embassy
int CvPlayer::GetImprovementLeagueVotes() const
{
	return m_iImprovementLeagueVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from embassy
void CvPlayer::ChangeImprovementLeagueVotes(int iChange)
{
	m_iImprovementLeagueVotes += iChange;
	CvAssert(m_iImprovementLeagueVotes >= 0);
	if (m_iImprovementLeagueVotes < 0)
	{
		m_iImprovementLeagueVotes = 0;
	}
}

/// League Bonuses for Poor Players
void CvPlayer::SetLeagueArt(bool bValue)
{
	if(m_bIsLeagueArt != bValue)
	{
		m_bIsLeagueArt = bValue;
	}
}

bool CvPlayer::IsLeagueArt() const
{
	return m_bIsLeagueArt;
}

/// League Bonuses for Poor Players
void CvPlayer::SetLeagueScholar(bool bValue)
{
	if(m_bIsLeagueScholar != bValue)
	{
		m_bIsLeagueScholar = bValue;
	}
}

bool CvPlayer::IsLeagueScholar() const
{
	return m_bIsLeagueScholar;
}


/// League Bonuses for Poor Players
void CvPlayer::SetLeagueAid(bool bValue)
{
	if(m_bIsLeagueAid != bValue)
	{
		m_bIsLeagueAid = bValue;
	}
}

bool CvPlayer::IsLeagueAid() const
{
	return m_bIsLeagueAid;
}

/// Process League Bonuses for Poor Players
void CvPlayer::ProcessLeagueResolutions()
{
	CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
	if(pLeague == NULL)
	{
		return;
	}
	if(IsLeagueAid())
	{
		if ( pLeague->GetArtsyGreatPersonRateModifier() > 0)
		{
			//Production and Culture
			if(AidRank() == GetID())
			{
				CvCity* pLoopCity;
				int iLoop;
				int iAid = 0;
				for(pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
				{
					int iAid = (ScoreDifference() - pLoopCity->GetTotalArtsyAid());
					if(iAid != 0)
					{
						pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_PRODUCTION, iAid);

						pLoopCity->ChangeTotalArtsyAid(iAid);
					}

				}
				iAid = ScoreDifference() - GetLeagueCultureCityModifier();
				if(iAid != 0)
				{
					ChangeLeagueCultureCityModifier(iAid);
				}
			}
			//Remove bonuses from filty first-worlders.
			if(AidRank() != GetID())
			{
				CvCity* pLoopCity;
				int iLoop;
				for(pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
				{
					if(pLoopCity->GetTotalArtsyAid() != 0)
					{

						pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_PRODUCTION, pLoopCity->GetTotalArtsyAid() * -1);

						pLoopCity->SetTotalArtsyAid(0);
					}
				}
				if(GetLeagueCultureCityModifier() != 0)
				{
					ChangeLeagueCultureCityModifier(GetLeagueCultureCityModifier() * -1);
				}
			}
		}
		else if (pLeague && pLeague->GetScienceyGreatPersonRateModifier() > 0)
		{
			//Food and Research
			if(AidRank() == GetID())
			{
				CvCity* pLoopCity;
				int iLoop;
				int iAid = 0;
				for(pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
				{
					iAid = (ScoreDifference() - pLoopCity->GetTotalScienceyAid());
					if(iAid != 0)
					{
						pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_FOOD, iAid);

						pLoopCity->ChangeTotalScienceyAid(iAid);
					}
				}
				//Global
				iAid = (ScoreDifference() - GetScienceRateFromLeagueAid());
				if(iAid != 0)
				{
					ChangeScienceRateFromLeagueAid(iAid);
				}
			}
			//Remove bonuses from filty first-worlders.
			if(AidRank() != GetID())
			{
				CvCity* pLoopCity;
				int iLoop;
				for(pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
				{
					if(pLoopCity->GetTotalScienceyAid() != 0)
					{	
						pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_FOOD, (pLoopCity->GetTotalScienceyAid() * -1));

						pLoopCity->SetTotalScienceyAid(0);
					}
				}
				//Global
				if(GetScienceRateFromLeagueAid() != 0)
				{
					ChangeScienceRateFromLeagueAid(GetScienceRateFromLeagueAid() * -1);
				}
			}
		}
	}
	else if(!IsLeagueAid())
	{
		CvCity* pLoopCity;
		int iLoop;
		for(pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
		{
			if(pLoopCity->GetTotalScienceyAid() != 0)
			{	
				pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_FOOD, (pLoopCity->GetTotalScienceyAid() * -1));

				pLoopCity->SetTotalScienceyAid(0);
			}
			if(pLoopCity->GetTotalArtsyAid() != 0)
			{
				pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_PRODUCTION, pLoopCity->GetTotalArtsyAid() * -1);

				pLoopCity->SetTotalArtsyAid(0);
			}
		}
		//Global
		if(GetScienceRateFromLeagueAid() != 0)
		{
			ChangeScienceRateFromLeagueAid(GetScienceRateFromLeagueAid() * -1);
		}
		if(GetLeagueCultureCityModifier() != 0)
		{
			ChangeLeagueCultureCityModifier(GetLeagueCultureCityModifier() * -1);
		}
	}
	if(IsLeagueArt())
	{
		//Extra Science From League (Art)
		if(pLeague->GetWorldWonderYieldChange(YIELD_CULTURE) > 0)
		{
			CvCity* pLoopCity;
			int iLoop;
			for(pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
			{
				int iSciencePerWork = GET_PLAYER(GetID()).GetGreatWorkYieldChange(YIELD_SCIENCE);
				int iTotalScienceFromArt = (pLoopCity->GetCityCulture()->GetNumGreatWorks() * iSciencePerWork);
				int iAid = iTotalScienceFromArt - pLoopCity->GetBaseYieldRateFromLeague(YIELD_SCIENCE);
				if(iAid != 0)
				{
					pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_SCIENCE, iAid);
				}
			}
		}
	}
	else if(!IsLeagueArt())
	{
		CvCity* pLoopCity;
		int iLoop;
		for(pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
		{
			if(pLoopCity->GetBaseYieldRateFromLeague(YIELD_SCIENCE) != 0)
			{
				pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_SCIENCE, (pLoopCity->GetBaseYieldRateFromLeague(YIELD_SCIENCE) * -1));
			}
		}
	}
}


/// League Bonuses for Poor Players
PlayerTypes CvPlayer::AidRank()
{
	int iRank = 0;
	int iMajorCivs = 0;
	CvWeightedVector<PlayerTypes, MAX_CIV_PLAYERS, true> veMajorRankings;
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		CvPlayer* pMajorLoop = &GET_PLAYER(eLoopPlayer);
	
		if(pMajorLoop->isAlive() && !pMajorLoop->isMinorCiv())
		{
			iRank = pMajorLoop->GetScore();

			if(iRank > 0)
			{
				veMajorRankings.push_back(eLoopPlayer, iRank);
				iMajorCivs++;
			}
		}
	}

	//Find the median of the Civs.
	int iTopTier = (iMajorCivs / 2);
	if(iTopTier <= 0)
	{
		iTopTier = 1;
	}

	veMajorRankings.SortItems();
	if(veMajorRankings.size() != 0)
	{
		for(int iRanking = 0; iRanking < veMajorRankings.size(); iRanking++)
		{
			if(veMajorRankings.GetElement(iRanking) == GetID())
			{
				//Are we in the bottom 50% of Civs? If so, we need aid!
				if(iRanking >= iTopTier)
				{
					return GetID();
				}
			}
		}
	}
	return NO_PLAYER;
}

/// League Bonuses for Poor Players
int CvPlayer::ScoreDifference()
{
	int iScore = 0;
	int iBestScore = 0;
	int iMajors = 0;
	int iPlayerScore = 0;
	int iDifference = 0;
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		CvPlayer* pMajorLoop = &GET_PLAYER(eLoopPlayer);

		if(pMajorLoop->isAlive() && !pMajorLoop->isMinorCiv())
		{
			iScore = pMajorLoop->GetScore();
			iMajors++;

			if(iScore > iBestScore)
			{
				iBestScore = iScore;
			}
		}
	}
	if(iBestScore > 0)
	{
		iPlayerScore = GET_PLAYER(GetID()).GetScore();
		iDifference = iBestScore - iPlayerScore;
		int iMax = /*30*/ GC.getLEAGUE_AID_MAX();
		int iMin = /*10*/ (GC.getLEAGUE_AID_MAX() / 3);

		//Bring down to % value.
		iDifference /= 50;
		//Never lower than 10%
		if(iDifference < iMin)
		{
			iDifference = iMin;
		}
		//Never higher than 30%
		if(iDifference > iMax)
		{
			iDifference = iMax;
		}
	}
	return iDifference;
}

//	--------------------------------------------------------------------------------
/// Extra science from CS
int CvPlayer::GetScienceRateFromMinorAllies() const
{
	return m_iScienceRateFromLeague;
}

//	--------------------------------------------------------------------------------
/// Extra science from CS
void CvPlayer::ChangeScienceRateFromMinorAllies(int iChange)
{
	SetScienceRateFromMinorAllies(GetScienceRateFromMinorAllies() + iChange);
}

/// Extra science from CS
void CvPlayer::SetScienceRateFromMinorAllies(int iValue)
{
	if(GetScienceRateFromMinorAllies() != iValue)
		m_iScienceRateFromLeague = iValue;
}

//	--------------------------------------------------------------------------------
/// Extra science from aid
int CvPlayer::GetScienceRateFromLeagueAid() const
{
	return m_iScienceRateFromLeagueAid;
}

//	--------------------------------------------------------------------------------
/// Extra science from aid
void CvPlayer::ChangeScienceRateFromLeagueAid(int iChange)
{
	SetScienceRateFromLeagueAid(GetScienceRateFromLeagueAid() + iChange);
}
//	--------------------------------------------------------------------------------
/// Extra science from aid
void CvPlayer::SetScienceRateFromLeagueAid(int iValue)
{
	if(GetScienceRateFromLeagueAid() != iValue)
		m_iScienceRateFromLeagueAid = iValue;
}
#endif

//	--------------------------------------------------------------------------------
/// Extra league votes
void CvPlayer::ChangeExtraLeagueVotes(int iChange)
{
	m_iExtraLeagueVotes += iChange;
	CvAssert(m_iExtraLeagueVotes >= 0);
	if (m_iExtraLeagueVotes < 0)
	{
		m_iExtraLeagueVotes = 0;
	}
}

//	--------------------------------------------------------------------------------
/// How much weaker do Units get when wounded?
int CvPlayer::GetWoundedUnitDamageMod() const
{
	return m_iWoundedUnitDamageMod;
}

//	--------------------------------------------------------------------------------
/// How much weaker do Units get when wounded?
void CvPlayer::SetWoundedUnitDamageMod(int iValue)
{
	m_iWoundedUnitDamageMod = iValue;

	if(m_iWoundedUnitDamageMod < /*50*/ -GC.getWOUNDED_DAMAGE_MULTIPLIER())
	{
		m_iWoundedUnitDamageMod = /*50*/ -GC.getWOUNDED_DAMAGE_MULTIPLIER();
	}
}

//	--------------------------------------------------------------------------------
/// How much weaker do Units get when wounded?
void CvPlayer::ChangeWoundedUnitDamageMod(int iChange)
{
	SetWoundedUnitDamageMod(m_iWoundedUnitDamageMod + iChange);
}

//	--------------------------------------------------------------------------------
/// Unit upgrade cost mod
int CvPlayer::GetUnitUpgradeCostMod() const
{
	return m_iUnitUpgradeCostMod;
}

//	--------------------------------------------------------------------------------
/// Unit upgrade cost mod
void CvPlayer::SetUnitUpgradeCostMod(int iValue)
{
	m_iUnitUpgradeCostMod = iValue;

	if(m_iUnitUpgradeCostMod < /*-75*/ GC.getUNIT_UPGRADE_COST_DISCOUNT_MAX())
		m_iUnitUpgradeCostMod = /*-75*/ GC.getUNIT_UPGRADE_COST_DISCOUNT_MAX();
}

//	--------------------------------------------------------------------------------
/// Unit upgrade cost mod
void CvPlayer::ChangeUnitUpgradeCostMod(int iChange)
{
	SetUnitUpgradeCostMod(m_iUnitUpgradeCostMod + iChange);
}

//	--------------------------------------------------------------------------------
/// How much of a combat bonus do we get VS Barbarian Units?
int CvPlayer::GetBarbarianCombatBonus() const
{
	return m_iBarbarianCombatBonus;
}

//	--------------------------------------------------------------------------------
/// Sets how much of a combat bonus we get VS Barbarian Units
void CvPlayer::SetBarbarianCombatBonus(int iValue)
{
	m_iBarbarianCombatBonus = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes how much of a combat bonus we get VS Barbarian Units
void CvPlayer::ChangeBarbarianCombatBonus(int iChange)
{
	SetBarbarianCombatBonus(m_iBarbarianCombatBonus + iChange);
}

//	--------------------------------------------------------------------------------
/// Do we always see where Barb Camps appear?
bool CvPlayer::IsAlwaysSeeBarbCamps() const
{
	return m_iAlwaysSeeBarbCampsCount > 0;
}

//	--------------------------------------------------------------------------------
/// Sets if we always see where Barb Camps appear
void CvPlayer::SetAlwaysSeeBarbCampsCount(int iValue)
{
	m_iAlwaysSeeBarbCampsCount = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes if we always see where Barb Camps appear
void CvPlayer::ChangeAlwaysSeeBarbCampsCount(int iChange)
{
	SetAlwaysSeeBarbCampsCount(m_iAlwaysSeeBarbCampsCount + iChange);
}

//	--------------------------------------------------------------------------------
CvPlayerTechs* CvPlayer::GetPlayerTechs() const
{
	return m_pPlayerTechs;
}

//	--------------------------------------------------------------------------------
CvPlayerPolicies* CvPlayer::GetPlayerPolicies() const
{
	return m_pPlayerPolicies;
}

//	--------------------------------------------------------------------------------
CvPlayerTraits* CvPlayer::GetPlayerTraits() const
{
	return m_pTraits;
}

//	--------------------------------------------------------------------------------
CvFlavorManager* CvPlayer::GetFlavorManager() const
{
	return m_pFlavorManager;
}

//	--------------------------------------------------------------------------------
CvTacticalAI* CvPlayer::GetTacticalAI() const
{
	return m_pTacticalAI;
}

//	--------------------------------------------------------------------------------
CvHomelandAI* CvPlayer::GetHomelandAI() const
{
	return m_pHomelandAI;
}

#if defined(MOD_API_EXTENSIONS)
bool CvPlayer::grantPolicy(PolicyTypes iPolicy, bool bFree)
{
	if (!HasPolicy(iPolicy)) {
		setHasPolicy(iPolicy, true, bFree);
		
		return true;
	}
	
	return false;
}

bool CvPlayer::revokePolicy(PolicyTypes iPolicy)
{
	if (HasPolicy(iPolicy)) {
		setHasPolicy(iPolicy, false, m_pPlayerPolicies->IsFreePolicy(iPolicy));
		
		return true;
	}
	
	return false;
}

bool CvPlayer::swapPolicy(PolicyTypes iNewPolicy, PolicyTypes iOldPolicy)
{
	bool bWasFree = m_pPlayerPolicies->IsFreePolicy(iOldPolicy);
	
	if (!HasPolicy(iNewPolicy) && revokePolicy(iOldPolicy)) {
		return grantPolicy(iNewPolicy, bWasFree);
	}
	
	return false;
}
#endif

//	--------------------------------------------------------------------------------
#if defined(MOD_API_EXTENSIONS)
void CvPlayer::setHasPolicy(PolicyTypes eIndex, bool bNewValue, bool bFree)
#else
void CvPlayer::setHasPolicy(PolicyTypes eIndex, bool bNewValue)
#endif
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumPolicyInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	
	if(m_pPlayerPolicies->HasPolicy(eIndex) != bNewValue)
	{
#if defined(MOD_API_EXTENSIONS)
		m_pPlayerPolicies->SetPolicy(eIndex, bNewValue, bFree);
#else
		m_pPlayerPolicies->SetPolicy(eIndex, bNewValue);
#endif
		processPolicies(eIndex, bNewValue ? 1 : -1);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNextPolicyCost() const
{
	return m_iCostNextPolicy;
}

//	--------------------------------------------------------------------------------
void CvPlayer::DoUpdateNextPolicyCost()
{
	m_iCostNextPolicy = GetPlayerPolicies()->GetNextPolicyCost();
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canAdoptPolicy(PolicyTypes eIndex) const
{
	return GetPlayerPolicies()->CanAdoptPolicy(eIndex);
}

//	--------------------------------------------------------------------------------
void CvPlayer::doAdoptPolicy(PolicyTypes ePolicy)
{
	CvPolicyEntry* pkPolicyInfo = GC.getPolicyInfo(ePolicy);
	CvAssert(pkPolicyInfo != NULL);
	if(pkPolicyInfo == NULL)
		return;

	// Can we actually adopt this?
	if(!canAdoptPolicy(ePolicy))
		return;

	bool bTenet = pkPolicyInfo->GetLevel() > 0;

	// Pay Culture cost - if applicable
	if (bTenet && GetNumFreeTenets() > 0)
	{
		ChangeNumFreeTenets(-1, false);
	}
	else if (GetNumFreePolicies() > 0)
	{
		ChangeNumFreePolicies(-1);
	}
	else
	{
		changeJONSCulture(-getNextPolicyCost());
	}

	setHasPolicy(ePolicy, true);

	// Update cost if trying to buy another policy this turn
	DoUpdateNextPolicyCost();

	// Branch unlocked
	PolicyBranchTypes ePolicyBranch = (PolicyBranchTypes) pkPolicyInfo->GetPolicyBranchType();
	GetPlayerPolicies()->SetPolicyBranchUnlocked(ePolicyBranch, true, false);

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	// This Dirty bit must only be set when changing something for the active player
	if(GC.getGame().getActivePlayer() == GetID())
	{
		GC.GetEngineUserInterface()->setDirty(Policies_DIRTY_BIT, true);
	}
#if defined(MOD_BALANCE_CORE)
	int iLoop;
	doInstantYield(INSTANT_YIELD_TYPE_POLICY_UNLOCK);
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) 
	{
		pLoopCity->GetCityCitizens()->SetDirty(true);
	}
#endif

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(ePolicy);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		LuaSupport::CallHook(pkScriptSystem, "PlayerAdoptPolicy", args.get(), bResult);
	}

	updateYield();		// Policies can change the yield
}

//	--------------------------------------------------------------------------------
/// Empire in Anarchy?
bool CvPlayer::IsAnarchy() const
{
	return GetAnarchyNumTurns() > 0;
}

//	--------------------------------------------------------------------------------
/// Empire in Anarchy?
int CvPlayer::GetAnarchyNumTurns() const
{
	return m_iAnarchyNumTurns;
}

//	--------------------------------------------------------------------------------
/// Empire in Anarchy?
void CvPlayer::SetAnarchyNumTurns(int iValue)
{
	if(iValue != GetAnarchyNumTurns())
	{
		m_iAnarchyNumTurns = iValue;

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Empire in Anarchy?
void CvPlayer::ChangeAnarchyNumTurns(int iChange)
{
	SetAnarchyNumTurns(GetAnarchyNumTurns() + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getAdvancedStartPoints() const
{
	return m_iAdvancedStartPoints;
}

//	--------------------------------------------------------------------------------
void CvPlayer::setAdvancedStartPoints(int iNewValue)
{
	if(getAdvancedStartPoints() != iNewValue)
	{
		m_iAdvancedStartPoints = iNewValue;

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(MiscButtons_DIRTY_BIT, true);
			GC.GetEngineUserInterface()->setDirty(SelectionButtons_DIRTY_BIT, true);
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeAdvancedStartPoints(int iChange)
{
	setAdvancedStartPoints(getAdvancedStartPoints() + iChange);
}


//	--------------------------------------------------------------------------------
// Get Attack Bonus for a certain period of time
int CvPlayer::GetAttackBonusTurns() const
{
	return m_iAttackBonusTurns;
}

//	--------------------------------------------------------------------------------
// Set Attack Bonus for a certain period of time
void CvPlayer::ChangeAttackBonusTurns(int iChange)
{
	if(iChange != 0)
	{
		m_iAttackBonusTurns += iChange;
	}
}

//	--------------------------------------------------------------------------------
// Get Culture Bonus for a certain period of time
int CvPlayer::GetCultureBonusTurns() const
{
	return m_iCultureBonusTurns;
}

//	--------------------------------------------------------------------------------
// Set Culture Bonus for a certain period of time
void CvPlayer::ChangeCultureBonusTurns(int iChange)
{
	if (iChange != 0)
	{
		m_iCultureBonusTurns += iChange;
	}
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
// Get Culture Bonus for a certain period of time
int CvPlayer::GetCultureBonusTurnsConquest() const
{
	return m_iCultureBonusTurnsConquest;
}

//	--------------------------------------------------------------------------------
// Set Culture Bonus for a certain period of time
void CvPlayer::ChangeCultureBonusTurnsConquest(int iChange)
{
	if (iChange != 0)
	{
		m_iCultureBonusTurnsConquest += iChange;
	}
}
#endif
//	--------------------------------------------------------------------------------
// Get Tourism Bonus for a certain period of time
int CvPlayer::GetTourismBonusTurns() const
{
	return m_iTourismBonusTurns;
}

//	--------------------------------------------------------------------------------
// Set Tourism Bonus for a certain period of time
void CvPlayer::ChangeTourismBonusTurns(int iChange)
{
	if (iChange != 0)
	{
		m_iTourismBonusTurns += iChange;
	}
}

#if defined(MOD_DIPLOMACY_CITYSTATES)
//	--------------------------------------------------------------------------------
void CvPlayer::DoProcessVotes()
{
	if(GC.getGame().isOption(GAMEOPTION_NO_LEAGUES))
	{
		return;
	}

	// Minors and Barbs don't matter
	if(!isMinorCiv() && !isBarbarian())
	{
		// Loop through Cities
		int iLoop;
		CvCity* pLoopCity;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
			{
				const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
				CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
			
				// Has this Building
				if(pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
				{
					if(pkBuildingInfo->GetFaithToVotes() > 0)
					{
						int iTestFaith = TestFaithToVotes(pkBuildingInfo->GetFaithToVotes());
						ChangeFaithToVotes(iTestFaith);
					}
					if(pkBuildingInfo->GetCapitalsToVotes() > 0)
					{
						int iTestCapital = TestCapitalsToVotes(pkBuildingInfo->GetCapitalsToVotes());
						ChangeCapitalsToVotes(iTestCapital);	
					}
					if(pkBuildingInfo->GetDoFToVotes() > 0)
					{
						int iTestDoF = TestDoFToVotes(pkBuildingInfo->GetDoFToVotes());
						ChangeDoFToVotes(iTestDoF);
					}
					if(pkBuildingInfo->GetRAToVotes() > 0)
					{
						int iTestRA = TestRAToVotes(pkBuildingInfo->GetRAToVotes());
						ChangeRAToVotes(iTestRA);
					}
					if(pkBuildingInfo->GetDPToVotes() > 0)
					{
						int iTestDP = TestDefensePactsToVotes(pkBuildingInfo->GetDPToVotes());
						ChangeDefensePactsToVotes(iTestDP);
					}
				}
			}
		}
	}
}
#endif
#if defined(MOD_BALANCE_CORE_YIELDS)
void CvPlayer::DoChangeGreatGeneralRate()
{
	//Check for buildings and beliefs that add Great General points.
	int iLoop;
	int iGreatGeneralPoints = 0;
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			for(int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
			{
				const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);
				CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
				if(pkBuildingInfo)
				{
					if(pkBuildingInfo->GetYieldChange(YIELD_GREAT_GENERAL_POINTS) > 0)
					{
						if(pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
						{
							iGreatGeneralPoints += pkBuildingInfo->GetYieldChange(YIELD_GREAT_GENERAL_POINTS);
						}
					}
				}
			}
			const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(pLoopCity->GetCityReligions()->GetReligiousMajority(), pLoopCity->getOwner());
			if(pReligion)
			{
				int iReligionYieldChange = pReligion->m_Beliefs.GetCityYieldChange(pLoopCity->getPopulation(), YIELD_GREAT_GENERAL_POINTS, GetID());
				if(iReligionYieldChange > 0)
				{
					iGreatGeneralPoints += iReligionYieldChange;
				}
				BeliefTypes eSecondaryPantheon = pLoopCity->GetCityReligions()->GetSecondaryReligionPantheonBelief();
				if (eSecondaryPantheon != NO_BELIEF && pLoopCity->getPopulation() >= GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetMinPopulation())
				{
					iReligionYieldChange = GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetCityYieldChange(YIELD_GREAT_GENERAL_POINTS);
					if(iReligionYieldChange > 0)
					{
						iGreatGeneralPoints += iReligionYieldChange;
					}
				}
			}
		}
	}
	//Check for policies that add Great General points.
	for(int iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)
	{
		PolicyTypes pPolicy = (PolicyTypes)iPolicyLoop;
		CvPolicyEntry* pkPolicyInfo = GC.getPolicyInfo(pPolicy);
		if(pkPolicyInfo)
		{
			if(GetPlayerPolicies()->HasPolicy(pPolicy) && !GetPlayerPolicies()->IsPolicyBlocked(pPolicy))
			{
				if(pkPolicyInfo->GetCityYieldChange(YIELD_GREAT_GENERAL_POINTS) > 0)
				{
					for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if(pLoopCity != NULL)
						{
							iGreatGeneralPoints += pkPolicyInfo->GetCityYieldChange(YIELD_GREAT_GENERAL_POINTS);
						}
					}
				}
			}
		}
	}
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
#if defined(MOD_UNITS_XP_TIMES_100)
	changeCombatExperienceTimes100(iGreatGeneralPoints * 100);
#else
	changeCombatExperience(iGreatGeneralPoints);
#endif
#else
#if defined(MOD_UNITS_XP_TIMES_100)
	changeCombatExperienceTimes100(iGreatGeneralPoints * 100);
#else
	changeCombatExperience(iGreatGeneralPoints);
#endif
#endif
}
void CvPlayer::DoChangeGreatAdmiralRate()
{
	//Check for buildings and beliefs that add Great General points.
	int iLoop;
	int iGreatAdmiralPoints = 0;
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			for(int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
			{
				const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);
				CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
				if(pkBuildingInfo)
				{
					if(pkBuildingInfo->GetYieldChange(YIELD_GREAT_ADMIRAL_POINTS) > 0)
					{
						if(pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
						{
							iGreatAdmiralPoints += pkBuildingInfo->GetYieldChange(YIELD_GREAT_ADMIRAL_POINTS);
						}
					}
				}
			}
			const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(pLoopCity->GetCityReligions()->GetReligiousMajority(), pLoopCity->getOwner());
			if(pReligion)
			{
				int iReligionYieldChange = pReligion->m_Beliefs.GetCityYieldChange(pLoopCity->getPopulation(), YIELD_GREAT_ADMIRAL_POINTS, GetID());
				if(iReligionYieldChange > 0)
				{
					iGreatAdmiralPoints += iReligionYieldChange;
				}
				BeliefTypes eSecondaryPantheon = pLoopCity->GetCityReligions()->GetSecondaryReligionPantheonBelief();
				if (eSecondaryPantheon != NO_BELIEF && pLoopCity->getPopulation() >= GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetMinPopulation())
				{
					iReligionYieldChange = GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetCityYieldChange(YIELD_GREAT_ADMIRAL_POINTS);
					if(iReligionYieldChange > 0)
					{
						iGreatAdmiralPoints += iReligionYieldChange;
					}
				}
			}
		}
	}
	//Check for policies that add Great General points.
	for(int iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)
	{
		PolicyTypes pPolicy = (PolicyTypes)iPolicyLoop;
		CvPolicyEntry* pkPolicyInfo = GC.getPolicyInfo(pPolicy);
		if(pkPolicyInfo)
		{
			if(GetPlayerPolicies()->HasPolicy(pPolicy) && !GetPlayerPolicies()->IsPolicyBlocked(pPolicy))
			{
				if(pkPolicyInfo->GetCityYieldChange(YIELD_GREAT_GENERAL_POINTS) > 0)
				{
					for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if(pLoopCity != NULL)
						{
							iGreatAdmiralPoints += pkPolicyInfo->GetCityYieldChange(YIELD_GREAT_ADMIRAL_POINTS);
						}
					}
				}
			}
		}
	}
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
#if defined(MOD_UNITS_XP_TIMES_100)
	changeNavalCombatExperienceTimes100(iGreatAdmiralPoints * 100);
#else
	changeNavalCombatExperience(iGreatAdmiralPoints);
#endif
#else
#if defined(MOD_UNITS_XP_TIMES_100)
	changeNavalCombatExperienceTimes100(iGreatAdmiralPoints * 100);
#else
	changeNavalCombatExperience(iGreatAdmiralPoints);
#endif
#endif
}
#endif
//	--------------------------------------------------------------------------------
/// Update all Golden-Age related stuff
void CvPlayer::DoProcessGoldenAge()
{
	if(GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS))
	{
		return;
	}

	// Minors and Barbs can't get GAs
	if(!isMinorCiv() && !isBarbarian())
	{
		// Already in a GA - don't decrement counter while in Anarchy
		if(getGoldenAgeTurns() > 0)
		{
			if(!IsAnarchy())
			{
				changeGoldenAgeTurns(-1);
			}
		}
#if !defined(MOD_BALANCE_CORE)
		// Not in GA
		else
		{
#endif
			// Note: This will actually REDUCE the GA meter if the player is running in the red
			ChangeGoldenAgeProgressMeter(GetExcessHappiness());
			
#if defined(MOD_API_UNIFIED_YIELDS_GOLDEN_AGE)
			ChangeGoldenAgeProgressMeter(GetGoldenAgePointsFromEmpire());
#endif
#if defined(MOD_BALANCE_CORE)
			if(getGoldenAgeTurns() <= 0)
			{
#endif
			// Enough GA Progress to trigger new GA?
			if(GetGoldenAgeProgressMeter() >= GetGoldenAgeProgressThreshold())
			{
				int iOverflow = GetGoldenAgeProgressMeter() - GetGoldenAgeProgressThreshold();
#if defined(MOD_BALANCE_CORE)
				int iValue = GetGoldenAgeProgressMeter();
#endif
				SetGoldenAgeProgressMeter(iOverflow);
				
				int iLength = getGoldenAgeLength();
#if defined(MOD_BALANCE_CORE)
				changeGoldenAgeTurns(iLength, iValue);
#else
				changeGoldenAgeTurns(iLength);
#endif

				// If it's the active player then show the popup
				if(GetID() == GC.getGame().getActivePlayer())
				{
					// Don't show in MP
					if(!GC.getGame().isNetworkMultiPlayer())	// KWG: Candidate for !GC.getGame().isOption(GAMEOPTION_SIMULTANEOUS_TURNS)
					{
						CvPopupInfo kPopupInfo(BUTTONPOPUP_GOLDEN_AGE_REWARD);
						GC.GetEngineUserInterface()->AddPopup(kPopupInfo);
					}
				}
			}
#if defined(MOD_BALANCE_CORE)
			}
#endif
#if !defined(MOD_BALANCE_CORE)
		}
#endif
	}
}
#if defined(MOD_BALANCE_CORE)
int CvPlayer::GetGoldenAgePointsFromEmpire()
{
	int iGAPoints = 0;
	// GA points from religion
	iGAPoints += GetYieldPerTurnFromReligion(YIELD_GOLDEN_AGE_POINTS);

	// Trait bonus which adds GA points for trade partners? 
	iGAPoints +=  GetYieldPerTurnFromTraits(YIELD_GOLDEN_AGE_POINTS);

	// Add in all the GA points from city yields
	CvCity* pLoopCity;
	int iLoop;
	int iTourism = 0;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iGAPoints += pLoopCity->getYieldRate(YIELD_GOLDEN_AGE_POINTS, false);
		if(GetPlayerTraits()->GetTourismToGAP() > 0)
		{
			iTourism += pLoopCity->GetBaseTourism();
		}
	}
	iTourism *= GetPlayerTraits()->GetTourismToGAP();
	iTourism /= 100;
	if(iTourism > 0)
	{
		iGAPoints += iTourism;
	}
	return iGAPoints;
}
#endif
//	--------------------------------------------------------------------------------
/// How much do we need in the GA meter to trigger the next one?
int CvPlayer::GetGoldenAgeProgressThreshold() const
{
	int iThreshold = /*500*/ GC.getGOLDEN_AGE_BASE_THRESHOLD_HAPPINESS();
	iThreshold += GetNumGoldenAges() * /*500*/ GC.getGOLDEN_AGE_EACH_GA_ADDITIONAL_HAPPINESS();

	// Increase cost based on the # of cities in the empire
	int iCostExtra = int(iThreshold * (getNumCities() - 1) * /*0.02*/ GC.getGOLDEN_AGE_THRESHOLD_CITY_MULTIPLIER());
	iThreshold += iCostExtra;

	if(GetGoldenAgeMeterMod() != 0)
	{
		iThreshold *= (100 + GetGoldenAgeMeterMod());
		iThreshold /= 100;
	}

	// Game Speed Mod
	iThreshold *= GC.getGame().getGameSpeedInfo().getGreatPeoplePercent();
	iThreshold /= 100;

	// Make the number nice to look at
	int iVisibleDivisor = /*5*/ GC.getGOLDEN_AGE_VISIBLE_THRESHOLD_DIVISOR();
	iThreshold /= iVisibleDivisor;
	iThreshold *= iVisibleDivisor;

	return iThreshold;
}

//	--------------------------------------------------------------------------------
/// What is our progress towards the next GA?
int CvPlayer::GetGoldenAgeProgressMeter() const
{
	return m_iGoldenAgeProgressMeter;
}

//	--------------------------------------------------------------------------------
/// Sets what is our progress towards the next GA
void CvPlayer::SetGoldenAgeProgressMeter(int iValue)
{
	m_iGoldenAgeProgressMeter = iValue;

	if(m_iGoldenAgeProgressMeter < 0)
	{
		m_iGoldenAgeProgressMeter = 0;
	}

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
}

//	--------------------------------------------------------------------------------
/// Changes what is our progress towards the next GA
void CvPlayer::ChangeGoldenAgeProgressMeter(int iChange)
{
	SetGoldenAgeProgressMeter(GetGoldenAgeProgressMeter() + iChange);

}

//	--------------------------------------------------------------------------------
/// Modifier for how big the GA meter is (-50 = 50% of normal)
int CvPlayer::GetGoldenAgeMeterMod() const
{
	return m_iGoldenAgeMeterMod;
}

//	--------------------------------------------------------------------------------
/// Sets Modifier for how big the GA meter is (-50 = 50% of normal)
void CvPlayer::SetGoldenAgeMeterMod(int iValue)
{
	m_iGoldenAgeMeterMod = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes Modifier for how big the GA meter is (-50 = 50% of normal)
void CvPlayer::ChangeGoldenAgeMeterMod(int iChange)
{
	SetGoldenAgeMeterMod(GetGoldenAgeMeterMod() + iChange);
}

//	--------------------------------------------------------------------------------
/// How many GAs have we had in this game?
int CvPlayer::GetNumGoldenAges() const
{
	return m_iNumGoldenAges;
}

//	--------------------------------------------------------------------------------
/// Sets how many GAs have we had in this game
void CvPlayer::SetNumGoldenAges(int iValue)
{
	m_iNumGoldenAges = iValue;

#if !defined(NO_ACHIEVEMENTS)
	if(iValue > 0 && isHuman() && !GC.getGame().isGameMultiPlayer()&& GET_PLAYER(GC.getGame().getActivePlayer()).isLocalPlayer())
	{
		gDLL->UnlockAchievement(ACHIEVEMENT_GOLDEN_AGE);

		const char* strLeader = getLeaderTypeKey();
		if(m_iNumGoldenAges >=5 && NULL != strLeader && strcmp(strLeader, "LEADER_DARIUS") == 0)
		{
			gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_ARCHAEMENNID);
		}
	}
#endif
}

//	--------------------------------------------------------------------------------
/// Changes how many GAs have we had in this game
void CvPlayer::ChangeNumGoldenAges(int iChange)
{
	SetNumGoldenAges(GetNumGoldenAges() + iChange);
}

//	--------------------------------------------------------------------------------
/// How many turns left in GA? (0 if not in GA)
int CvPlayer::getGoldenAgeTurns() const
{
	return m_iGoldenAgeTurns;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isGoldenAge() const
{
	return (getGoldenAgeTurns() > 0);
}

//	--------------------------------------------------------------------------------
#if defined(MOD_BALANCE_CORE)
void CvPlayer::changeGoldenAgeTurns(int iChange, int iValue)
#else
void CvPlayer::changeGoldenAgeTurns(int iChange)
#endif
{
	Localization::String locString;
	Localization::String locSummaryString;

	bool bOldGoldenAge;

	if(iChange != 0)
	{
		bOldGoldenAge = isGoldenAge();

		m_iGoldenAgeTurns = (m_iGoldenAgeTurns + iChange);
		CvAssert(getGoldenAgeTurns() >= 0);
#if defined(MOD_BALANCE_CORE)
		if(iChange > 0 && CanGoldenAgeTourism())
		{
			int iTourism = GetEventTourism();
			ChangeNumHistoricEvents(1);
			// Culture boost based on previous turns
			int iPreviousTurnsToCount = 10;
			// Calculate boost
			iTourism *= GetCultureYieldFromPreviousTurns(GC.getGame().getGameTurn(), iPreviousTurnsToCount);
			iTourism /= 100;
			GetCulture()->AddTourismAllKnownCivs(iTourism);
			CvCity* pCapitalCity = getCapitalCity();
			if(iTourism > 0)
			{
				if(GetID() == GC.getGame().getActivePlayer())
				{
					if(pCapitalCity != NULL)
					{
						char text[256] = {0};
						float fDelay = 0.5f;
						sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_TOURISM]", iTourism);
						DLLUI->AddPopupText(pCapitalCity->getX(), pCapitalCity->getY(), text, fDelay);
						CvNotifications* pNotification = GetNotifications();
						if(pNotification)
						{
							CvString strMessage;
							CvString strSummary;
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GOLDEN_AGE", iTourism);
							strSummary = GetLocalizedText("TXT_KEY_TOURISM_EVENT_SUMMARY");
							pNotification->Add(NOTIFICATION_CULTURE_VICTORY_SOMEONE_INFLUENTIAL, strMessage, strSummary, pCapitalCity->getX(), pCapitalCity->getY(), GetID());
						}
					}
				}
			}
		}
		if(iChange > 0 && GetPlayerTraits()->GetWLTKDGATimer() > 0)
		{
			int iValue2 = GetPlayerTraits()->GetWLTKDGATimer();
			iValue2 *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iValue2 /= 100;
			int iLoop;
			for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				if(pLoopCity != NULL)
				{				
					pLoopCity->ChangeWeLoveTheKingDayCounter(iValue2);
				}
			}
			CvNotifications* pNotification = GetNotifications();
			if(pNotification)
			{
				CvString strMessage;
				CvString strSummary;
				strMessage = GetLocalizedText("TXT_KEY_CARNAVAL_WLTKD", iValue2);
				strSummary = GetLocalizedText("TXT_KEY_CARNAVAL_WLTKD_S");
				pNotification->Add(NOTIFICATION_GENERIC, strMessage, strSummary, -1, -1, GetID());
			}
		}
#endif
		if(bOldGoldenAge != isGoldenAge())
		{
			GC.getMap().updateYield();	// Do the entire map, so that any potential golden age bonus is reflected in the yield icons.

			if(isGoldenAge())
			{
				ChangeNumGoldenAges(1);
#if defined(MOD_BALANCE_CORE)
				//Instant Boost
				CvCity* pCapitalCity = getCapitalCity();
				if(pCapitalCity != NULL)
				{
					doInstantYield(INSTANT_YIELD_TYPE_INSTANT, false, NO_GREATPERSON, NO_BUILDING, iValue, false, NO_PLAYER, NULL, false, pCapitalCity);
				}
#endif

				locString = Localization::Lookup("TXT_KEY_NOTIFICATION_GOLDEN_AGE_BEGUN");
				locString << getCivilizationAdjectiveKey();
				GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, GetID(), locString.toUTF8(), -1, -1);

				gDLL->GameplayGoldenAgeStarted();

#if defined(MOD_EVENTS_GOLDEN_AGE)
				if (MOD_EVENTS_GOLDEN_AGE) {
					GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerGoldenAge, GetID(), true, iChange);
				}
#endif
#if defined(MOD_BALANCE_CORE_DIFFICULTY)
				if(MOD_BALANCE_CORE_DIFFICULTY && !isMinorCiv() && !isHuman())
				{
					int iEra = GetCurrentEra();
					if(iEra <= 0)
					{
						iEra = 1;
					}
					int iHandicap = 1;
					CvHandicapInfo* pHandicapInfo = GC.getHandicapInfo(GC.getGame().getHandicapType());
					if(pHandicapInfo)
					{
						iHandicap = pHandicapInfo->getAIDifficultyBonus();
						iHandicap *= iEra;
						iHandicap /= max(1, getNumCities());
					}
					if(iHandicap > 0)
					{
						GetTreasury()->ChangeGold(iHandicap);
						ChangeGoldenAgeProgressMeter(iHandicap);
						changeJONSCulture(iHandicap / 3);
						if(getCapitalCity() != NULL)
						{
							getCapitalCity()->ChangeJONSCultureStored(iHandicap / 3);
						}
				
						int iBeakersBonus = GetScienceYieldFromPreviousTurns(GC.getGame().getGameTurn(), (iHandicap / 10));

						TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
						if(eCurrentTech == NO_TECH)
						{
							changeOverflowResearch(iBeakersBonus);
						}
						else
						{
							GET_TEAM(getTeam()).GetTeamTechs()->ChangeResearchProgress(eCurrentTech, iBeakersBonus, GetID());
						}
						int iLoop;
						for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pLoopCity != NULL)
							{
								pLoopCity->changeFood(iHandicap / 5);
							}
						}
						if((GC.getLogging() && GC.getAILogging()))
						{
							CvString strLogString;
							strLogString.Format("CBP AI DIFFICULTY BONUS: Received %d Handicap Bonus", iHandicap);
							GetHomelandAI()->LogHomelandMessage(strLogString);
						}
					}
				}
#endif
#if defined(MOD_BALANCE_CORE)
				CvCity* pLoopCity;
				int iLoop;
				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if(pLoopCity != NULL)
					{
						pLoopCity->GetCityCulture()->CalculateBaseTourismBeforeModifiers();
						pLoopCity->GetCityCulture()->CalculateBaseTourism();
					}
				}
#endif
			}
			else
			{
				gDLL->GameplayGoldenAgeEnded();

#if defined(MOD_EVENTS_GOLDEN_AGE)
				if (MOD_EVENTS_GOLDEN_AGE) {
					GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerGoldenAge, GetID(), false, 0);
				}
#endif
#if defined(MOD_BALANCE_CORE)
				CvCity* pLoopCity;
				int iLoop;
				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if(pLoopCity != NULL)
					{
						pLoopCity->GetCityCulture()->CalculateBaseTourismBeforeModifiers();
						pLoopCity->GetCityCulture()->CalculateBaseTourism();
					}
				}
#endif
			}

			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				NotificationTypes eNotification = NO_NOTIFICATION_TYPE;

				if(isGoldenAge())
				{
					eNotification = NOTIFICATION_GOLDEN_AGE_BEGUN_ACTIVE_PLAYER;
					locString = Localization::Lookup("TXT_KEY_NOTIFICATION_GOLDEN_AGE_BEGUN_ACTIVE_PLAYER");
					locSummaryString = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_GOLDEN_AGE_BEGUN_ACTIVE_PLAYER");
				}
				else
				{
					eNotification = NOTIFICATION_GOLDEN_AGE_ENDED_ACTIVE_PLAYER;
					locString = Localization::Lookup("TXT_KEY_NOTIFICATION_GOLDEN_AGE_ENDED_ACTIVE_PLAYER");
					locSummaryString = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_GOLDEN_AGE_ENDED_ACTIVE_PLAYER");
				}

				pNotifications->Add(eNotification, locString.toUTF8(), locSummaryString.toUTF8(), -1, -1, -1);
			}
		}

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGoldenAgeLength() const
{
	int iTurns = GC.getGame().goldenAgeLength();

	// Player modifier
	int iLengthModifier = getGoldenAgeModifier();

	// Trait modifier
	iLengthModifier += GetPlayerTraits()->GetGoldenAgeDurationModifier();

#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	// Do we get increased Golden Ages from a resource monopoly?
	if(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	{
		for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
		{
			ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
			if(eResourceLoop != NO_RESOURCE)
			{
				CvResourceInfo* pInfo = GC.getResourceInfo(eResourceLoop);
				if (pInfo && pInfo->isMonopoly())
				{
					if(HasGlobalMonopoly(eResourceLoop) && pInfo->getMonopolyGALength() > 0)
					{
						int iTemp = pInfo->getMonopolyGALength();
						iTemp += GetMonopolyModPercent();
						iLengthModifier += iTemp;
					}
				}
			}
		}
	}
#endif
#if defined(MOD_BALANCE_CORE)
	if(iLengthModifier != 0)
#else
	if(iLengthModifier > 0)
#endif
	{
		iTurns = iTurns * (100 + iLengthModifier) / 100;
	}

	return iTurns;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNumUnitGoldenAges() const
{
	return m_iNumUnitGoldenAges;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeNumUnitGoldenAges(int iChange)
{
	m_iNumUnitGoldenAges = (m_iNumUnitGoldenAges + iChange);
	CvAssert(getNumUnitGoldenAges() >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getStrikeTurns() const
{
	return m_iStrikeTurns;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeStrikeTurns(int iChange)
{
	m_iStrikeTurns = (m_iStrikeTurns + iChange);
	CvAssert(getStrikeTurns() >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getGoldenAgeModifier() const
{
	return m_iGoldenAgeModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGoldenAgeModifier(int iChange)
{
	m_iGoldenAgeModifier += iChange;
}

#if defined(MOD_GLOBAL_TRULY_FREE_GP)
//	--------------------------------------------------------------------------------
int CvPlayer::getGreatPeopleCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatPeopleCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatPeopleCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatPeopleCreated(bool bIsFree)
{
	m_iGreatPeopleCreated++;
	if (bIsFree) m_iFreeGreatPeopleCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatGeneralsCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatGeneralsCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatGeneralsCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatGeneralsCreated(bool bIsFree)
{
	m_iGreatGeneralsCreated++;
	if (bIsFree) m_iFreeGreatGeneralsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatAdmiralsCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatAdmiralsCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatAdmiralsCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatAdmiralsCreated(bool bIsFree)
{
	m_iGreatAdmiralsCreated++;
	if (bIsFree) m_iFreeGreatAdmiralsCreated++;
}

#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
//	--------------------------------------------------------------------------------
int CvPlayer::getGreatMerchantsCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatMerchantsCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatMerchantsCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatMerchantsCreated(bool bIsFree)
{
	m_iGreatMerchantsCreated++;
	if (bIsFree) m_iFreeGreatMerchantsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatScientistsCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatScientistsCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatScientistsCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatScientistsCreated(bool bIsFree)
{
	m_iGreatScientistsCreated++;
	if (bIsFree) m_iFreeGreatScientistsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatEngineersCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatEngineersCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatEngineersCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatEngineersCreated(bool bIsFree)
{
	m_iGreatEngineersCreated++;
	if (bIsFree) m_iFreeGreatEngineersCreated++;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatWritersCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatWritersCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatWritersCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatWritersCreated(bool bIsFree)
{
	m_iGreatWritersCreated++;
	if (bIsFree) m_iFreeGreatWritersCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatArtistsCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatArtistsCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatArtistsCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatArtistsCreated(bool bIsFree)
{
	m_iGreatArtistsCreated++;
	if (bIsFree) m_iFreeGreatArtistsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatMusiciansCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatMusiciansCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatMusiciansCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatMusiciansCreated(bool bIsFree)
{
	m_iGreatMusiciansCreated++;
	if (bIsFree) m_iFreeGreatMusiciansCreated++;
}

#if defined(MOD_DIPLOMACY_CITYSTATES)
//	--------------------------------------------------------------------------------
int CvPlayer::getGreatDiplomatsCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatDiplomatsCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatDiplomatsCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatDiplomatsCreated(bool bIsFree)
{
	m_iGreatDiplomatsCreated++;
	if (bIsFree) m_iFreeGreatDiplomatsCreated++;
}
#endif
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra1Created(bool bExcludeFree) const
{
	int iCount = m_iGPExtra1Created;
	if (bExcludeFree) iCount -= m_iFreeGPExtra1Created;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra1Created(bool bIsFree)
{
	m_iGPExtra1Created++;
	if (bIsFree) m_iFreeGPExtra1Created++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra2Created(bool bExcludeFree) const
{
	int iCount = m_iGPExtra2Created;
	if (bExcludeFree) iCount -= m_iFreeGPExtra2Created;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra2Created(bool bIsFree)
{
	m_iGPExtra2Created++;
	if (bIsFree) m_iFreeGPExtra2Created++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra3Created(bool bExcludeFree) const
{
	int iCount = m_iGPExtra3Created;
	if (bExcludeFree) iCount -= m_iFreeGPExtra3Created;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra3Created(bool bIsFree)
{
	m_iGPExtra3Created++;
	if (bIsFree) m_iFreeGPExtra3Created++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra4Created(bool bExcludeFree) const
{
	int iCount = m_iGPExtra4Created;
	if (bExcludeFree) iCount -= m_iFreeGPExtra4Created;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra4Created(bool bIsFree)
{
	m_iGPExtra4Created++;
	if (bIsFree) m_iFreeGPExtra4Created++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra5Created(bool bExcludeFree) const
{
	int iCount = m_iGPExtra5Created;
	if (bExcludeFree) iCount -= m_iFreeGPExtra5Created;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra5Created(bool bIsFree)
{
	m_iGPExtra5Created++;
	if (bIsFree) m_iFreeGPExtra5Created++;
}
#endif
#else
//	--------------------------------------------------------------------------------
int CvPlayer::getGreatPeopleCreated() const
{
	return m_iGreatPeopleCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatPeopleCreated()
{
	m_iGreatPeopleCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatGeneralsCreated() const
{
	return m_iGreatGeneralsCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatGeneralsCreated()
{
	m_iGreatGeneralsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatAdmiralsCreated() const
{
	return m_iGreatAdmiralsCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatAdmiralsCreated()
{
	m_iGreatAdmiralsCreated++;
}

#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
//	--------------------------------------------------------------------------------
int CvPlayer::getGreatMerchantsCreated() const
{
	return m_iGreatMerchantsCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatMerchantsCreated()
{
	m_iGreatMerchantsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatScientistsCreated() const
{
	return m_iGreatScientistsCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatScientistsCreated()
{
	m_iGreatScientistsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatEngineersCreated() const
{
	return m_iGreatEngineersCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatEngineersCreated()
{
	m_iGreatEngineersCreated++;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatWritersCreated() const
{
	return m_iGreatWritersCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatWritersCreated()
{
	m_iGreatWritersCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatArtistsCreated() const
{
	return m_iGreatArtistsCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatArtistsCreated()
{
	m_iGreatArtistsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatMusiciansCreated() const
{
	return m_iGreatMusiciansCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatMusiciansCreated()
{
	m_iGreatMusiciansCreated++;
}

#if defined(MOD_DIPLOMACY_CITYSTATES)
//	--------------------------------------------------------------------------------
int CvPlayer::getGreatDiplomatsCreated() const
{
	return m_iGreatDiplomatsCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatDiplomatsCreated()
{
	m_iGreatDiplomatsCreated++;
}
#endif
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getMerchantsFromFaith() const
{
	return m_iMerchantsFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementMerchantsFromFaith()
{
	m_iMerchantsFromFaith++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getScientistsFromFaith() const
{
	return m_iScientistsFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementScientistsFromFaith()
{
	m_iScientistsFromFaith++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getWritersFromFaith() const
{
	return m_iWritersFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementWritersFromFaith()
{
	m_iWritersFromFaith++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getArtistsFromFaith() const
{
	return m_iArtistsFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementArtistsFromFaith()
{
	m_iArtistsFromFaith++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getMusiciansFromFaith() const
{
	return m_iMusiciansFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementMusiciansFromFaith()
{
	m_iMusiciansFromFaith++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGeneralsFromFaith() const
{
	return m_iGeneralsFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGeneralsFromFaith()
{
	m_iGeneralsFromFaith++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getAdmiralsFromFaith() const
{
	return m_iAdmiralsFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementAdmiralsFromFaith()
{
	m_iAdmiralsFromFaith++;
}

#if defined(MOD_DIPLOMACY_CITYSTATES)
//	--------------------------------------------------------------------------------
int CvPlayer::getDiplomatsFromFaith() const
{
	return m_iDiplomatsFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementDiplomatsFromFaith()
{
	m_iDiplomatsFromFaith++;
}
#endif
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra1FromFaith() const
{
	return m_iGPExtra1FromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra1FromFaith()
{
	m_iGPExtra1FromFaith++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra2FromFaith() const
{
	return m_iGPExtra2FromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra2FromFaith()
{
	m_iGPExtra2FromFaith++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra3FromFaith() const
{
	return m_iGPExtra3FromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra3FromFaith()
{
	m_iGPExtra3FromFaith++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra4FromFaith() const
{
	return m_iGPExtra4FromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra4FromFaith()
{
	m_iGPExtra4FromFaith++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra5FromFaith() const
{
	return m_iGPExtra5FromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra5FromFaith()
{
	m_iGPExtra5FromFaith++;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getEngineersFromFaith() const
{
	return m_iEngineersFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementEngineersFromFaith()
{
	m_iEngineersFromFaith++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatPeopleThresholdModifier() const
{
	return m_iGreatPeopleThresholdModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGreatPeopleThresholdModifier(int iChange)
{
	m_iGreatPeopleThresholdModifier = (m_iGreatPeopleThresholdModifier + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatGeneralsThresholdModifier() const
{
	return m_iGreatGeneralsThresholdModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGreatGeneralsThresholdModifier(int iChange)
{
	m_iGreatGeneralsThresholdModifier += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatAdmiralsThresholdModifier() const
{
	return m_iGreatAdmiralsThresholdModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGreatAdmiralsThresholdModifier(int iChange)
{
	m_iGreatAdmiralsThresholdModifier += iChange;
}


//	--------------------------------------------------------------------------------
int CvPlayer::getPolicyCostModifier() const
{
	return m_iPolicyCostModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::recomputePolicyCostModifier()
{
	int iCost = m_pPlayerPolicies->GetNumericModifier(POLICYMOD_POLICY_COST_MODIFIER);
	iCost += GetPolicyCostBuildingModifier();
	iCost += GetPolicyCostMinorCivModifier();
	iCost += GetPlayerTraits()->GetPolicyCostModifier();

	if(iCost < /*-75*/ GC.getPOLICY_COST_DISCOUNT_MAX())
		iCost = /*-75*/ GC.getPOLICY_COST_DISCOUNT_MAX();

	m_iPolicyCostModifier = iCost;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatPeopleRateModifier() const
{
	return m_iGreatPeopleRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatGeneralRateModifier() const
{
	return m_iGreatGeneralRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatAdmiralRateModifier() const
{
	return m_iGreatAdmiralRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatWriterRateModifier() const
{
	return m_iGreatWriterRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatArtistRateModifier() const
{
	return m_iGreatArtistRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatMusicianRateModifier() const
{
	return m_iGreatMusicianRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatMerchantRateModifier() const
{
	return m_iGreatMerchantRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatScientistRateModifier() const
{
	return m_iGreatScientistRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatEngineerRateModifier() const
{
	return m_iGreatEngineerRateModifier;
}

#if defined(MOD_DIPLOMACY_CITYSTATES)
//	--------------------------------------------------------------------------------
int CvPlayer::getGreatDiplomatRateModifier() const
{
	return m_iGreatDiplomatRateModifier;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getDomesticGreatGeneralRateModifier() const
{
	return m_iDomesticGreatGeneralRateModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGreatPeopleRateModFromBldgs(int ichange)
{
	m_iGreatPeopleRateModFromBldgs += ichange;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGreatGeneralRateModFromBldgs(int ichange)
{
	m_iGreatGeneralRateModFromBldgs += ichange;
}

//	--------------------------------------------------------------------------------
/// Do effects when a unit is killed in combat
#if defined(MOD_API_EXTENSIONS)
void CvPlayer::DoUnitKilledCombat(CvUnit* pKillingUnit, PlayerTypes eKilledPlayer, UnitTypes eUnitType)
#else
void CvPlayer::DoUnitKilledCombat(PlayerTypes eKilledPlayer, UnitTypes eUnitType)
#endif
{
	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(eKilledPlayer);
		args->Push(eUnitType);
#if defined(MOD_API_EXTENSIONS)
		args->Push(pKillingUnit ? pKillingUnit->GetID() : -1);
#endif

		bool bResult;
		LuaSupport::CallHook(pkScriptSystem, "UnitKilledInCombat", args.get(), bResult);
	}
}
#if defined(MOD_BALANCE_CORE)
void CvPlayer::doInstantYield(InstantYieldType iType, bool bCityFaith, GreatPersonTypes eGreatPerson, BuildingTypes eBuilding, int iPassYield, bool bEraScale, PlayerTypes ePlayer, CvPlot* pPlot, bool bSuppress, CvCity* pCity, bool bDomainSea, bool bInternational, bool bEvent, YieldTypes ePassYield)
{

	//No minors or barbs here, please!
	if(isMinorCiv() || isBarbarian())
		return;

	YieldTypes eYield;

	ReligionTypes eReligion = NO_RELIGION;
	ReligionTypes eLocalReligion = NO_RELIGION;
	eReligion = GC.getGame().GetGameReligions()->GetFounderBenefitsReligion(GetID());
	if(eReligion == NO_RELIGION)
	{
		eReligion = GetReligions()->GetReligionInMostCities();
	}

	const CvReligion* pReligion = NULL;
	if(eReligion != NO_RELIGION)
	{
		//Let's check for holy city status - if this isn't our holy city, let's send the boosts there instead.
		pReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, GetID());
	}
	int iEra = 0;
	iEra = GetCurrentEra();
	if(iEra <= 0)
	{
		iEra = 1;
	}
	CvString totalyieldString = "";
	//Let's loop through all cities for this.
	int iLoop;
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity == NULL)
			continue;

		//If we passed ina city, only check that city.
		if(pCity != NULL && pLoopCity != pCity)
			continue;

		CvString yieldString = "";
		CvString cityyieldString = "";
		CvString citynameString = "";
		float fDelay = 0.0f;

		//Get local faith if needed.
		if(bCityFaith)
		{
			eLocalReligion = pCity->GetCityReligions()->GetReligiousMajority();
			//Different faiths at national and local levels? We should check both, because one might be a founder bonus, and the other a follower bonus. Blegh!
			if(eLocalReligion != eReligion)
			{
				pReligion = GC.getGame().GetGameReligions()->GetReligion(eLocalReligion, GetID());
			}
		}
		for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
		{
			eYield = (YieldTypes) iI;

			if(eYield == NO_YIELD)
				continue;
		
			CvYieldInfo* pYieldInfo = GC.getYieldInfo(eYield);
		
			//First let's get our values...
			//Note that many beliefs pass in a city - that's because only holy cities (or capitals for pantheons) should get those bonuses!
			int iValue = 0;
			switch(iType)
			{
				case INSTANT_YIELD_TYPE_BIRTH:
				{
					iValue += pLoopCity->GetYieldFromBirth(eYield) + getYieldFromBirth(eYield);
					if(pReligion)
					{
						iValue += pReligion->m_Beliefs.GetYieldPerBirth(eYield, GetID(), pLoopCity);
					}
					if(pLoopCity->isCapital())
					{
						iValue += getYieldFromBirthCapital(eYield);
					}
					//Scale it here to avoid scaling the growth yield below.
					if(bEraScale)
					{
						iValue *= iEra;
					}

					//And now on growth % bonuses.
					int iCurrentYield = 0;

					if(eYield == YIELD_CULTURE)
					{
						iCurrentYield = pLoopCity->getJONSCulturePerTurn();
					}
					else if (eYield == YIELD_FAITH)
					{
						iCurrentYield = pLoopCity->GetFaithPerTurn();
					}
					else
					{
						iCurrentYield = pLoopCity->getYieldRate(eYield, false);
					}
					if(iCurrentYield != 0)
					{
						iValue += ((iCurrentYield * pLoopCity->GetGrowthExtraYield(eYield)) / 100);
						if(iValue <= 0 && pLoopCity->GetGrowthExtraYield(eYield) > 0)
						{
							iValue = 1;
						}
					}
					break;
				}
				case INSTANT_YIELD_TYPE_ERA_UNLOCK:
				{
					if(pReligion)
					{
						iValue += pReligion->m_Beliefs.GetYieldFromEraUnlock(eYield, GetID(), pLoopCity);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_POLICY_UNLOCK:
				{
					iValue += pLoopCity->GetYieldFromPolicyUnlock(eYield);
					if(pReligion)
					{
						iValue += pReligion->m_Beliefs.GetYieldFromPolicyUnlock(eYield, GetID(), pLoopCity);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_INSTANT:
				{
					if(eBuilding != NO_BUILDING)
					{
						CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
						if(pkBuildingInfo)
						{
							iValue += pkBuildingInfo->GetInstantYield(eYield);
							if(GetPlayerTraits()->IsTechBoostFromCapitalScienceBuildings() && iPassYield > 0 && eYield == YIELD_SCIENCE)
							{
								iValue += iPassYield;
							}
						}
					}
					else 
					{
						if(iPassYield != 0 && !bEvent)
						{
							int iPercent = GetPlayerTraits()->GetGAPToYield(eYield);
							if(iPercent != 0)
							{
								iPassYield *= iPercent;
								iPassYield /= 100;
						
								iValue += iPassYield;
							}
						}
						if(bEvent && ePassYield == eYield)
						{
							iValue += iPassYield;
						}
					}
					break;
				}
				case INSTANT_YIELD_TYPE_TECH:
				{
					iValue +=  pLoopCity->GetYieldFromTech(eYield);
					if(pLoopCity->isCapital())
					{
						iValue += getYieldFromTech(eYield);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_CONSTRUCTION:
				{
					iValue += pLoopCity->GetYieldFromConstruction(eYield) + getYieldFromConstruction(eYield);
					break;
				}
				case INSTANT_YIELD_TYPE_BORDERS:
				{
					iValue += pLoopCity->GetYieldFromBorderGrowth(eYield) + getYieldFromBorderGrowth(eYield);
					if(pReligion)
					{
						iValue += pReligion->m_Beliefs.GetYieldPerBorderGrowth(eYield, GetID());
					}
					break;
				}
				case INSTANT_YIELD_TYPE_PROPOSAL:
				{
					if(pReligion)
					{
						iValue += pReligion->m_Beliefs.GetYieldFromProposal(eYield, GetID(), pLoopCity);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_GP_USE:
				{
					if(pLoopCity->isCapital())
					{
						iValue += getYieldGPExpend(eYield);
						if(eYield == YIELD_GOLD)
						{
							iValue += GetGreatPersonExpendGold();
						}
					}
					if(eGreatPerson != NO_GREATPERSON)
					{
						if(pLoopCity->isCapital())
						{
							iValue += getGreatPersonExpendedYield(eGreatPerson, eYield);
						}
						if(pReligion)
						{
							iValue += pReligion->m_Beliefs.GetYieldFromGPUse(eYield, GetID(), pLoopCity) + pReligion->m_Beliefs.GetGreatPersonExpendedYield(eGreatPerson, eYield, GetID(), pLoopCity);
						}
					}
					if(eYield == YIELD_FAITH)
					{
						if(pReligion)
						{
							iValue += pReligion->m_Beliefs.GetGreatPersonExpendedFaith(GetID(), pLoopCity);
						}
					}
					break;
				}
				case INSTANT_YIELD_TYPE_GP_BORN:
				{
					if(eGreatPerson != NO_GREATPERSON)
					{
						iValue += GetPlayerTraits()->GetGreatPersonBornYield(eGreatPerson, eYield);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_F_CONQUEST:
				{
					if(pLoopCity->isCapital())
					{
						iValue += (getConquerorYield(eYield) + GetPlayerTraits()->GetYieldFromConquest(eYield));
					}
					if(pReligion)
					{
						iValue += pReligion->m_Beliefs.GetYieldFromConquest(eYield, GetID(), pLoopCity);
					}
					if(iPassYield != 0 && iValue != 0)
					{
						iPassYield *= iValue;
					}
					break;
				}
				case INSTANT_YIELD_TYPE_VICTORY:
				{
					iValue += pLoopCity->GetYieldFromVictory(eYield);
					break;
				}
				case INSTANT_YIELD_TYPE_U_PROD:
				{
					iValue += pLoopCity->GetYieldFromUnitProduction(eYield);
					break;
				}
				case INSTANT_YIELD_TYPE_PURCHASE:
				{
					if(iPassYield != 0)
					{
						iValue += ((iPassYield * pLoopCity->GetYieldFromPurchase(eYield)) / 100);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_TILE_PURCHASE:
				{
					iValue += GetPlayerTraits()->GetYieldFromTilePurchase(eYield);
					break;
				}
				case INSTANT_YIELD_TYPE_FOUND:
				{
					if(GetPlayerTraits()->IsReconquista() && GetNumCitiesFounded() <= 1)
					{
						continue;
					}

					iValue += GetPlayerTraits()->GetYieldFromSettle(eYield);
					iValue += getFounderYield(eYield);

					break;
				}
				case INSTANT_YIELD_TYPE_TR_END:
				{
					if(bInternational && (eYield == YIELD_SCIENCE || eYield == YIELD_FOOD || eYield == YIELD_PRODUCTION))
					{
						iValue += GetPlayerTraits()->GetTradeRouteStartYield(eYield);
					}
					else if(!bInternational && (eYield == YIELD_GOLD || eYield == YIELD_CULTURE))
					{
						iValue += GetPlayerTraits()->GetTradeRouteStartYield(eYield);
					}
					else if(eYield >= YIELD_FAITH)
					{
						iValue += GetPlayerTraits()->GetTradeRouteStartYield(eYield);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_CONVERSION:
				{
					iValue += pReligion->m_Beliefs.GetYieldFromConversion(eYield, GetID(), pLoopCity);
					break;
				}
				case INSTANT_YIELD_TYPE_DEATH:
				{
					if(pLoopCity->isCapital())
					{
						iValue += getYieldFromDeath(eYield);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_BULLY:
				{
					iValue += GetYieldFromMinorDemand(eYield);
					break;
				}
				case INSTANT_YIELD_TYPE_SPREAD:
				{
					if(pReligion && pPlot != NULL)
					{
						CvCity* pCity = pPlot->getPlotCity();
						if(pCity == NULL)
						{
							pCity = pPlot->GetAdjacentCity();
						}
						if(pCity != NULL)
						{
							if(!pCity->GetCityReligions()->IsHolyCityForReligion(eReligion))
							{
								iValue += pReligion->m_Beliefs.GetYieldFromSpread(eYield, GetID(), pLoopCity);
							}
							if(eYield == YIELD_SCIENCE && iPassYield > 0)
							{
								ReligionTypes eCurrentReligion = pCity->GetCityReligions()->GetReligiousMajority();
								if(eCurrentReligion != eReligion && eCurrentReligion != NO_RELIGION)
								{
									iValue += (iPassYield * pReligion->m_Beliefs.GetSciencePerOtherReligionFollower(GetID(), pLoopCity));
								}
							}
						}
					}
					break;
				}
				case INSTANT_YIELD_TYPE_F_SPREAD:
				{
					if(ePlayer != NO_PLAYER && ePlayer != GetID())
					{
						if(GET_PLAYER(ePlayer).isMinorCiv() && eYield == YIELD_TOURISM)
						{
							continue;
						}
						if(pReligion)
						{
							iValue += pReligion->m_Beliefs.GetYieldFromForeignSpread(eYield, GetID(), pLoopCity);
						}
					}
					if(iPassYield != 0)
					{
						iValue *= iPassYield;
					}
					break;
				}	
				case INSTANT_YIELD_TYPE_TR_MOVEMENT:
				{
					if(eYield == YIELD_GREAT_ADMIRAL_POINTS && !bDomainSea)
					{
						continue;
					}
					if(eYield == YIELD_GREAT_GENERAL_POINTS && bDomainSea)
					{
						continue;
					}
					iValue += GetPlayerTraits()->GetYieldFromRouteMovement(eYield);
					break;
				}	
			}
			//Now, let's apply these yields here as total yields.
			if(iValue != 0)
			{
				if(eYield != YIELD_POPULATION)
				{
					iValue *= GC.getGame().getGameSpeedInfo().getTrainPercent();
					iValue /= 100;

					//Exclusion for birth yields (as we do it up above to avoid % growth bonus being scaled).
					if(bEraScale && iType != INSTANT_YIELD_TYPE_BIRTH)
					{
						iValue *= iEra;
					}
				}
				switch(eYield)
				{
					case YIELD_FOOD:
					{
						pLoopCity->changeFood(iValue);
						if(pLoopCity->getFood() <= 0)
						{
							pLoopCity->setFood(0);
						}
					}
					break;
					case YIELD_PRODUCTION:
					{
						pLoopCity->changeProduction(iValue);
						if(pLoopCity->getProduction() <= 0)
						{
							pLoopCity->setProduction(0);
						}
					}
					break;
					case YIELD_GOLD:
					{
						GetTreasury()->ChangeGold(iValue);
						if(GetTreasury()->GetGold() <= 0)
						{
							GetTreasury()->SetGold(0);
						}
					}
					break;
					case YIELD_SCIENCE:
					{
						TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
						if(eCurrentTech == NO_TECH)
						{
							changeOverflowResearch(iValue);
							if(getOverflowResearch() <= 0)
							{
								setOverflowResearch(0);
							}
						}
						else
						{
							GET_TEAM(getTeam()).GetTeamTechs()->ChangeResearchProgress(eCurrentTech, iValue, GetID());
							if(GET_TEAM(getTeam()).GetTeamTechs()->GetResearchProgress(eCurrentTech) <= 0)
							{
								GET_TEAM(getTeam()).GetTeamTechs()->SetResearchProgress(eCurrentTech, 0, GetID());
							}
						}
					}
					break;
					case YIELD_CULTURE:
					{
						changeJONSCulture(iValue);
						pLoopCity->ChangeJONSCultureStored(iValue);
						if(pLoopCity->GetJONSCultureStored() <= 0)
						{
							pLoopCity->SetJONSCultureStored(0);
						}
					}
					break;
					case YIELD_FAITH:
					{
						ChangeFaith(iValue);
						if(GetFaith() <= 0)
						{
							SetFaith(0);
						}
					}
					break;
					case YIELD_TOURISM:
					{
						if(ePlayer != NO_PLAYER)
						{
							GetCulture()->ChangeInfluenceOn(ePlayer, iValue);
							if(pPlot != NULL && pPlot->getOwner() != NO_PLAYER && GET_PLAYER(pPlot->getOwner()).isMajorCiv())
							{
								// Show tourism spread
								if (pPlot->GetActiveFogOfWarMode() == FOGOFWARMODE_OFF)
								{
									CvString strInfluenceText;
									InfluenceLevelTypes eLevel = GetCulture()->GetInfluenceLevel(pPlot->getOwner());

									if (eLevel == INFLUENCE_LEVEL_UNKNOWN)
										strInfluenceText = GetLocalizedText( "TXT_KEY_CO_UNKNOWN" );
									else if (eLevel == INFLUENCE_LEVEL_EXOTIC)
										strInfluenceText = GetLocalizedText( "TXT_KEY_CO_EXOTIC");
									else if (eLevel == INFLUENCE_LEVEL_FAMILIAR)
										strInfluenceText = GetLocalizedText( "TXT_KEY_CO_FAMILIAR");
									else if (eLevel == INFLUENCE_LEVEL_POPULAR)
										strInfluenceText = GetLocalizedText( "TXT_KEY_CO_POPULAR");
									else if (eLevel == INFLUENCE_LEVEL_INFLUENTIAL)
										strInfluenceText = GetLocalizedText( "TXT_KEY_CO_INFLUENTIAL");
									else if (eLevel == INFLUENCE_LEVEL_DOMINANT)
										strInfluenceText = GetLocalizedText( "TXT_KEY_CO_DOMINANT");

									char text[256] = {0};
									sprintf_s(text, "[COLOR_WHITE]+%d [ICON_TOURISM][ENDCOLOR]   %s", iValue, strInfluenceText.c_str());
									fDelay += 1.0f;
									DLLUI->AddPopupText(pPlot->getX(), pPlot->getY(), text, fDelay);
								}
							}
						}
						else
						{
							GetCulture()->AddTourismAllKnownCivs(iValue);
						}
					}
					break;
					case YIELD_GOLDEN_AGE_POINTS:
					{
						ChangeGoldenAgeProgressMeter(iValue);
						if(GetGoldenAgeProgressMeter() <= 0)
						{
							SetGoldenAgeProgressMeter(0);
						}
					}
					break;
					case YIELD_GREAT_GENERAL_POINTS:
					{
	#if defined(MOD_UNITS_XP_TIMES_100)
						changeCombatExperienceTimes100(iValue * 100);
						if(getCombatExperienceTimes100() <= 0)
						{
							setCombatExperienceTimes100(0);
						}
	#else
						changeCombatExperience(iValue);
						if(getCombatExperience() <= 0)
						{
							setCombatExperience(0);
						}
	#endif
					}
					break;
					case YIELD_GREAT_ADMIRAL_POINTS:
					{
	#if defined(MOD_UNITS_XP_TIMES_100)
						changeNavalCombatExperienceTimes100(iValue * 100);
						if(getNavalCombatExperienceTimes100() <= 0)
						{
							setNavalCombatExperienceTimes100(0);
						}
	#else
						changeNavalCombatExperience(iValue);
						if(getNavalCombatExperience() <= 0)
						{
							setNavalCombatExperience(0);
						}
	#endif
					}
					break;
					case YIELD_POPULATION:
					{
						if(iValue < 0 && pLoopCity->getPopulation() <= iValue)
						{
							pLoopCity->setPopulation(1);
						}
						else
						{
							pLoopCity->changePopulation(iValue);
						}
					}
					break;
					case YIELD_CULTURE_LOCAL:
					{
						pLoopCity->ChangeJONSCultureStored(iValue);
						if(pLoopCity->GetJONSCultureStored() <= 0)
						{
							pLoopCity->SetJONSCultureStored(0);
						}
					}
					break;
				}
				//And now notifications.
				if(GetID() == GC.getGame().getActivePlayer() && iValue > 0)
				{
					char text[256] = {0};
					fDelay += 0.5f;
					yieldString.Format("%s+%%d[ENDCOLOR] %s", pYieldInfo->getColorString(), pYieldInfo->getIconString());
					sprintf_s(text, yieldString, iValue);
					DLLUI->AddPopupText(pLoopCity->getX(),pLoopCity->getY(), text, fDelay);
					if(citynameString == "")
					{
						citynameString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_CITY", pLoopCity->getNameKey());
					}
					if(cityyieldString != "")
					{
						cityyieldString += ", ";
					}
					cityyieldString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_DETAILS", pYieldInfo->GetDescriptionKey(), pYieldInfo->getIconString(), iValue);
 				}		
			}
		}
		if(citynameString != "" && cityyieldString != "")
		{
			citynameString += cityyieldString;
		}
		if(totalyieldString != "" && citynameString != "")
		{
			totalyieldString += "[NEWLINE]";
		}
		totalyieldString += citynameString;
	}
	CvNotifications* pNotifications = GetNotifications();
	if(!bSuppress && GetID() == GC.getGame().getActivePlayer() && pNotifications && totalyieldString != "")
	{
		Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_INSTANT_YIELD");
		if(pCity != NULL)
		{
			strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_INSTANT_YIELD_IN_CITY");
			strSummary << pCity->getNameKey();
		}
		Localization::String localizedText;
		switch(iType)
		{
			case INSTANT_YIELD_TYPE_BIRTH:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_BIRTH");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_ERA_UNLOCK:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_ERA");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_POLICY_UNLOCK:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_POLICY");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_INSTANT:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_INSTANT");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_TECH:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_TECH");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_CONSTRUCTION:
			{
				if(eBuilding != NO_BUILDING)
				{
					CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
					if(pkBuildingInfo)
					{
						if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
						{
							localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_CONSTRUCTION");
							localizedText << totalyieldString << pkBuildingInfo->GetDescriptionKey();
							//We do this at the player level once per turn.
							addInstantYieldText(iType, localizedText.toUTF8());
						}
						else
						{
							localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
							localizedText << totalyieldString << pkBuildingInfo->GetDescriptionKey();
							//We do this at the player level once per turn.
							addInstantYieldText(iType, localizedText.toUTF8());
						}
					}
				}
				return;
			}
			case INSTANT_YIELD_TYPE_BORDERS:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_BORDERS");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_PROPOSAL:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_GP_USE");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_GP_USE:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_GP_USE");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_GP_BORN:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_GP_BORN");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_F_CONQUEST:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_CONQUEST");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_VICTORY:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_VICTORY");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_U_PROD:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_UNIT_PRODUCTION");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_PURCHASE:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_PURCHASE");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_TILE_PURCHASE:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_TILE_PURCHASE");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_FOUND:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_FOUND");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_TR_END:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_TRADE_ROUTE");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_CONVERSION:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_CONVERSION");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_DEATH:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_DEATH");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_BULLY:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_BULLY");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_SPREAD:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_SPREAD");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_F_SPREAD:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_FOREIGN_SPREAD");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_TR_MOVEMENT:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_TR_MOVEMENT");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
		}
		if(pCity == NULL)
		{
			CvCity* pCapitalCity = getCapitalCity();
			if(pCapitalCity != NULL)
			{
				pNotifications->Add((NotificationTypes)FString::Hash("NOTIFICATION_INSTANT_YIELD"), localizedText.toUTF8(), strSummary.toUTF8(), pCapitalCity->getX(), pCapitalCity->getY(), pCapitalCity->GetID());
			}
		}
		else
		{
			pNotifications->Add((NotificationTypes)FString::Hash("NOTIFICATION_INSTANT_YIELD"), localizedText.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), pCity->GetID());
		}
	}
}
void CvPlayer::addInstantYieldText(InstantYieldType iType, CvString strInstantYield)
{
	VALIDATE_OBJECT
	CvAssertMsg(iType >= 0, "iType expected to be >= 0");
	CvAssertMsg(iType < NUM_INSTANT_YIELD_TYPES, "iType expected to be < NUM_INSTANT_YIELD_TYPES");

	m_aistrInstantYield.setAt(iType, m_aistrInstantYield[iType] + strInstantYield);
}
void CvPlayer::setInstantYieldText(InstantYieldType iType, CvString strInstantYield)
{
	VALIDATE_OBJECT
	CvAssertMsg(iType >= 0, "iType expected to be >= 0");
	CvAssertMsg(iType < NUM_INSTANT_YIELD_TYPES, "iType expected to be < NUM_INSTANT_YIELD_TYPES");
	m_aistrInstantYield.setAt(iType, strInstantYield);
}
CvString CvPlayer::getInstantYieldText(InstantYieldType iType) const
{
	VALIDATE_OBJECT
	CvAssertMsg(iType >= 0, "iType expected to be >= 0");
	CvAssertMsg(iType < NUM_INSTANT_YIELD_TYPES, "iType expected to be < NUM_INSTANT_YIELD_TYPES");
	return m_aistrInstantYield[iType];
}
#endif
//	--------------------------------------------------------------------------------
/// Do effects when a GP is consumed
#if defined(MOD_EVENTS_GREAT_PEOPLE)
void CvPlayer::DoGreatPersonExpended(UnitTypes eGreatPersonUnit, CvUnit* pGreatPersonUnit)
#else
void CvPlayer::DoGreatPersonExpended(UnitTypes eGreatPersonUnit)
#endif
{
	// Gold gained
	int iExpendGold = GetGreatPersonExpendGold();
	if(iExpendGold > 0)
	{
#if defined(MOD_BALANCE_CORE)
		iExpendGold *= GC.getGame().getGameSpeedInfo().getTrainPercent();
		iExpendGold /= 100;
#endif
		GetTreasury()->ChangeGold(iExpendGold);

#if !defined(NO_ACHIEVEMENTS)
		if(isHuman() && !GC.getGame().isGameMultiPlayer() && GET_PLAYER(GC.getGame().getActivePlayer()).isLocalPlayer())
		{
			// Update Steam stat and check achievement
			const int HALICARNASSUS_ACHIEVEMENT_GOLD = 1000;
			int iHalicarnassus = GC.getInfoTypeForString("BUILDINGCLASS_MAUSOLEUM_HALICARNASSUS");
			// Does player have DLC_06, and if so, do they have the Mausoleum of Halicarnassus?
			if(iHalicarnassus != -1 && getBuildingClassCount((BuildingClassTypes)iHalicarnassus) >= 1)
			{
				BuildingTypes eHalicarnassus = (BuildingTypes)GC.getInfoTypeForString("BUILDING_MAUSOLEUM_HALICARNASSUS");
				CvBuildingEntry* pHalicarnassusInfo = GC.getBuildingInfo(eHalicarnassus);
				int iHalicarnassusGold = pHalicarnassusInfo->GetGreatPersonExpendGold();

				int32 iTotalHalicarnassusGold = 0;
				if(gDLL->GetSteamStat(ESTEAMSTAT_HALICARNASSUSGOLDEARNED, &iTotalHalicarnassusGold))
				{
					iTotalHalicarnassusGold += iHalicarnassusGold;
					gDLL->SetSteamStat(ESTEAMSTAT_HALICARNASSUSGOLDEARNED, iTotalHalicarnassusGold);
					if(iTotalHalicarnassusGold >= HALICARNASSUS_ACHIEVEMENT_GOLD)
					{
						gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_HALICARNASSUS_GOLD);
					}
				}
			}
		}
#endif
	}

#if defined(MOD_API_UNIFIED_YIELDS)
#else
	// Faith gained
	ReligionTypes eReligionFounded = GetReligions()->GetReligionCreatedByPlayer();
	if(eReligionFounded > RELIGION_PANTHEON)
	{
		const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eReligionFounded, GetID());
		if(pReligion)
		{
			int iFaith = pReligion->m_Beliefs.GetGreatPersonExpendedFaith();
			if(iFaith > 0)
			{
				iFaith *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iFaith /= 100;
				ChangeFaith(iFaith);
			}
#if defined(MOD_BALANCE_CORE_BELIEFS)
			int iEra = GetCurrentEra();
			if(iEra < 1)
			{
				iEra = 1;
			}
			int iCulture = pReligion->m_Beliefs.GetYieldFromGPUse(YIELD_CULTURE) * iEra;
			if(iCulture > 0)
			{
				changeJONSCulture(iCulture);
				if(GetID() == GC.getGame().getActivePlayer())
				{
					char text[256] = {0};
					fDelay += 0.5f;
					sprintf_s(text, "[COLOR_MAGENTA]+%d[ENDCOLOR][ICON_CULTURE]", iCulture);
					DLLUI->AddPopupText(pGreatPersonUnit->getX(),pGreatPersonUnit->getY(), text, fDelay);
				}
			}
			int iFaith2 = pReligion->m_Beliefs.GetYieldFromGPUse(YIELD_FAITH) * iEra;
			if(iFaith2 > 0)
			{
				ChangeFaith(iFaith2);
				if(GetID() == GC.getGame().getActivePlayer())
				{
					char text[256] = {0};
					fDelay += 0.5f;
					sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_PEACE]", iFaith2);
					DLLUI->AddPopupText(pGreatPersonUnit->getX(),pGreatPersonUnit->getY(), text, fDelay);
				}
			}
			int iGold = pReligion->m_Beliefs.GetYieldFromGPUse(YIELD_GOLD) * iEra;
			if(iGold > 0)
			{
				GetTreasury()->ChangeGold(iGold);
				if(GetID() == GC.getGame().getActivePlayer())
				{
					char text[256] = {0};
					fDelay += 0.5f;
					sprintf_s(text, "[COLOR_YELLOW]+%d[ENDCOLOR][ICON_GOLD]", iGold);
					DLLUI->AddPopupText(pGreatPersonUnit->getX(),pGreatPersonUnit->getY(), text, fDelay);
				}
			}
			int iScience = pReligion->m_Beliefs.GetYieldFromGPUse(YIELD_SCIENCE) * iEra;
			if(iScience > 0)
			{
				TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
				if(eCurrentTech == NO_TECH)
				{
					changeOverflowResearch(iScience);
				}
				else
				{
					GET_TEAM(GET_PLAYER(GetID()).getTeam()).GetTeamTechs()->ChangeResearchProgress(eCurrentTech, iScience, GetID());
				}
				if(GetID() == GC.getGame().getActivePlayer())
				{
					char text[256] = {0};
					fDelay += 0.5f;
					sprintf_s(text, "[COLOR_BLUE]+%d[ENDCOLOR][ICON_RESEARCH]", iScience);
					DLLUI->AddPopupText(pGreatPersonUnit->getX(),pGreatPersonUnit->getY(), text, fDelay);
				}
			}
			int iGA = pReligion->m_Beliefs.GetYieldFromGPUse(YIELD_GOLDEN_AGE_POINTS) * iEra;
			if(iGA > 0)
			{
				ChangeGoldenAgeProgressMeter(iGA);
				if(GetID() == GC.getGame().getActivePlayer())
				{
					char text[256] = {0};
					fDelay += 0.5f;
					sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_GOLDEN_AGE]", iGA);
					DLLUI->AddPopupText(pGreatPersonUnit->getX(),pGreatPersonUnit->getY(), text, fDelay);
				}
			}
#endif
		}
	}
#endif
#if defined(MOD_BALANCE_CORE_POLICIES) || defined(MOD_DIPLOMACY_CITYSTATES)
	//Influence Gained with all CS per expend
	int iExpendInfluence = GetInfluenceGPExpend() + GetGPExpendInfluence(); 
	if(iExpendInfluence > 0)
	{
		for (int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
		{
			PlayerTypes eMinorLoop = (PlayerTypes) iMinorLoop;
			if(eMinorLoop != NO_PLAYER)
			{
				CvPlayer* pMinorLoop = &GET_PLAYER(eMinorLoop);
				if(pMinorLoop->isMinorCiv() && pMinorLoop->isAlive())
				{
					if(GET_TEAM(pMinorLoop->getTeam()).isHasMet(getTeam()))
					{
						pMinorLoop->GetMinorCivAI()->ChangeFriendshipWithMajor(GetID(), iExpendInfluence, false);
					}
				}
			}
		}
	}
	GreatPersonTypes eGreatPerson = GetGreatPersonFromUnitClass(pGreatPersonUnit->getUnitClassType());
	doInstantYield(INSTANT_YIELD_TYPE_GP_USE, false, eGreatPerson);
#endif
#if defined(MOD_EVENTS_GREAT_PEOPLE)
	if (MOD_EVENTS_GREAT_PEOPLE) {
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_GreatPersonExpended, GetID(), pGreatPersonUnit->GetID(), eGreatPersonUnit, pGreatPersonUnit->getX(), pGreatPersonUnit->getY());
	} else {
#endif
	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if (pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(eGreatPersonUnit);

		bool bResult;
		LuaSupport::CallHook(pkScriptSystem, "GreatPersonExpended", args.get(), bResult);
	}
#if defined(MOD_EVENTS_GREAT_PEOPLE)
	}
#endif
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetGreatPersonExpendGold() const
{
	return m_iGreatPersonExpendGold;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeGreatPersonExpendGold(int ichange)
{
	m_iGreatPersonExpendGold += ichange;
}

//	--------------------------------------------------------------------------------
void CvPlayer::recomputeGreatPeopleModifiers()
{
	//=============
	// Initialize
	//=============
	m_iGreatPeopleRateModifier = 0;
	m_iGreatGeneralRateModifier = 0;
	m_iGreatAdmiralRateModifier = 0;
	m_iGreatWriterRateModifier = 0;
	m_iGreatArtistRateModifier = 0;
	m_iGreatMusicianRateModifier = 0;
	m_iGreatMerchantRateModifier = 0;
#if defined(MOD_DIPLOMACY_CITYSTATES)
	m_iGreatDiplomatRateModifier = 0;
#endif
	m_iGreatScientistRateModifier = 0;
	m_iGreatEngineerRateModifier = 0;
	m_iDomesticGreatGeneralRateModifier = 0;

	// Get from traits first
	m_iGreatPeopleRateModifier += m_pTraits->GetGreatPeopleRateModifier();
	m_iGreatGeneralRateModifier += m_pTraits->GetGreatGeneralRateModifier();
	m_iGreatScientistRateModifier += m_pTraits->GetGreatScientistRateModifier();

	// Then get from current policies
	m_iGreatPeopleRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_PERSON_RATE);
	m_iGreatGeneralRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_GENERAL_RATE);
	m_iGreatAdmiralRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_ADMIRAL_RATE);
	m_iGreatWriterRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_WRITER_RATE);
	m_iGreatArtistRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_ARTIST_RATE);
	m_iGreatMusicianRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_MUSICIAN_RATE);
	m_iGreatMerchantRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_MERCHANT_RATE);
#if defined(MOD_DIPLOMACY_CITYSTATES)
	if (MOD_DIPLOMACY_CITYSTATES) {
		m_iGreatDiplomatRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_DIPLOMAT_RATE);
	}
#endif
	m_iGreatScientistRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_SCIENTIST_RATE);
	m_iDomesticGreatGeneralRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_DOMESTIC_GREAT_GENERAL_RATE);

	// Next add in buildings
	m_iGreatPeopleRateModifier += m_iGreatPeopleRateModFromBldgs;
	m_iGreatGeneralRateModifier += m_iGreatGeneralRateModFromBldgs;
	m_iDomesticGreatGeneralRateModifier += m_iDomesticGreatGeneralRateModFromBldgs;

	// Finally anything from friendships
	m_iGreatPeopleRateModifier += GetGreatPeopleRateModFromFriendships();

	// And effects from Leagues
	int iArtsyMod = GC.getGame().GetGameLeagues()->GetArtsyGreatPersonRateModifier(GetID());
	int iScienceyMod = GC.getGame().GetGameLeagues()->GetScienceyGreatPersonRateModifier(GetID());
	if (iArtsyMod != 0)
	{
		m_iGreatWriterRateModifier += iArtsyMod;
		m_iGreatArtistRateModifier += iArtsyMod;
		m_iGreatMusicianRateModifier += iArtsyMod;
	}
	if (iScienceyMod != 0)
	{
		m_iGreatScientistRateModifier += iScienceyMod;
		m_iGreatEngineerRateModifier += iScienceyMod;
		m_iGreatMerchantRateModifier += iScienceyMod;
	}

	// Finally boost domestic general from combat experience
	m_iDomesticGreatGeneralRateModifier += GC.getCOMBAT_EXPERIENCE_IN_BORDERS_PERCENT();
}

//	--------------------------------------------------------------------------------
// Do we have a trait that rewards friendships (or have a friend that does)?
int CvPlayer::GetGreatPeopleRateModFromFriendships() const
{
	int iRtnValue = 0;
	int iTraitMod = GetPlayerTraits()->GetDOFGreatPersonModifier();

	// Have the trait, one for each friend
	if(iTraitMod > 0)
	{
		iRtnValue = GetDiplomacyAI()->GetNumDoF() * iTraitMod;
	}

	// Don't have the trait, just get bonus once if friends with a player that does
	else
	{
		PlayerTypes eLoopPlayer;
		for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			eLoopPlayer = (PlayerTypes) iPlayerLoop;

			if(GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))
			{
				if(GetDiplomacyAI()->IsDoFAccepted(eLoopPlayer))
				{
					int iOthersTraitMod = GET_PLAYER(eLoopPlayer).GetPlayerTraits()->GetDOFGreatPersonModifier();
					if(iOthersTraitMod > 0)
					{
						iRtnValue += iOthersTraitMod;
					}
				}
			}
		}
	}

	return iRtnValue;
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
int CvPlayer::GetGreatScientistBeakerMod() const
{
	return m_iGreatScientistBeakerModifier;
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
void CvPlayer::SetGreatScientistBeakerMod(int iValue)
{
	m_iGreatScientistBeakerModifier = iValue;
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
void CvPlayer::ChangeGreatScientistBeakerMod(int iChange)
{
	SetGreatScientistBeakerMod(GetGreatScientistBeakerMod() + iChange);
}

//////////////////////////////////////////////////////////////////////////
int CvPlayer::GetGreatGeneralCombatBonus() const
{
	return m_iGreatGeneralCombatBonus;
}

//////////////////////////////////////////////////////////////////////////
void CvPlayer::SetGreatGeneralCombatBonus(int iValue)
{
	m_iGreatGeneralCombatBonus = iValue;
}


//////////////////////////////////////////////////////////////////////////
// ***** Great People Spawning *****
//////////////////////////////////////////////////////////////////////////

//	--------------------------------------------------------------------------------
// Figures out how long before we spawn a free Great Person for ePlayer
void CvPlayer::DoSeedGreatPeopleSpawnCounter()
{
	int iNumTurns = /*37*/ GC.getMINOR_TURNS_GREAT_PEOPLE_SPAWN_BASE();

	// Start at -1 since if we only have one ally we don't want to add any more
	int iExtraAllies = -1;

	PlayerTypes eMinor;
	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		eMinor = (PlayerTypes) iMinorLoop;

		// Not alive
		if(!GET_PLAYER(eMinor).isAlive())
			continue;

		if(GET_PLAYER(eMinor).GetMinorCivAI()->GetAlly() == GetID())
			iExtraAllies++;
	}

	if(iExtraAllies > 0)
	{
		int iExtraAlliesChange = iExtraAllies* /*-1*/ GC.getMINOR_ADDITIONAL_ALLIES_GP_CHANGE();

		iExtraAlliesChange = max(/*-10*/ GC.getMAX_MINOR_ADDITIONAL_ALLIES_GP_CHANGE(), iExtraAlliesChange);

		iNumTurns += iExtraAlliesChange;
	}

	int iRand = /*7*/ GC.getMINOR_TURNS_GREAT_PEOPLE_SPAWN_RAND();
	iNumTurns += GC.getGame().getJonRandNum(iRand, "Rand turns for Friendly Minor GreatPeople spawn");

	// If we're biasing the result then decrease the number of turns
	if(!IsAlliesGreatPersonBiasApplied())
	{
		iNumTurns *= /*50*/ GC.getMINOR_TURNS_GREAT_PEOPLE_SPAWN_BIAS_MULTIPLY();
		iNumTurns /= 100;

		SetAlliesGreatPersonBiasApplied(true);
	}

	// Modify for Game Speed
	iNumTurns *= GC.getGame().getGameSpeedInfo().getGreatPeoplePercent();
	iNumTurns /= 100;

	if(iNumTurns < 1)
		iNumTurns = 1;

	SetGreatPeopleSpawnCounter(iNumTurns);
}

//	--------------------------------------------------------------------------------
/// We're now allies with someone, what happens with the GP bonus?
void CvPlayer::DoApplyNewAllyGPBonus()
{
	int iChange = /*-2*/ GC.getMINOR_ADDITIONAL_ALLIES_GP_CHANGE();
	ChangeGreatPeopleSpawnCounter(iChange);

	if(GetGreatPeopleSpawnCounter() < 1)
		SetGreatPeopleSpawnCounter(1);
}

//	--------------------------------------------------------------------------------
// How long before we spawn a free GreatPeople for ePlayer?
int CvPlayer::GetGreatPeopleSpawnCounter()
{
	return m_iGreatPeopleSpawnCounter;
}

//	--------------------------------------------------------------------------------
// Sets how long before we spawn a free GreatPeople for ePlayer
void CvPlayer::SetGreatPeopleSpawnCounter(int iValue)
{
	m_iGreatPeopleSpawnCounter = iValue;
}

//	--------------------------------------------------------------------------------
// Changes how long before we spawn a free GreatPeople for ePlayer
void CvPlayer::ChangeGreatPeopleSpawnCounter(int iChange)
{
	SetGreatPeopleSpawnCounter(GetGreatPeopleSpawnCounter() + iChange);
}

//	--------------------------------------------------------------------------------
/// Create a GreatPeople
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
void CvPlayer::DoSpawnGreatPerson(PlayerTypes eMinor, bool bIsFree)
#else
void CvPlayer::DoSpawnGreatPerson(PlayerTypes eMinor)
#endif
{
	CvAssertMsg(eMinor >= MAX_MAJOR_CIVS, "eMinor is expected to be non-negative (invalid Index)");
	CvAssertMsg(eMinor < MAX_CIV_PLAYERS, "eMinor is expected to be within maximum bounds (invalid Index)");

	// Minor must have Capital
	CvCity* pMinorCapital = GET_PLAYER(eMinor).getCapitalCity();
	if(pMinorCapital == NULL)
	{
		FAssertMsg(false, "MINOR CIV AI: Trying to spawn a GreatPeople for a major civ but the minor has no capital. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
		return;
	}
	// Capital must have a plot
	CvPlot* pMinorPlot = pMinorCapital->plot();
	if(pMinorPlot == NULL)
	{
		CvAssertMsg(false, "Plot for minor civ's capital not found! Please send Anton your save file and version.");
		return;
	}

	// Note: this is the same transport method (though without a delay) as a Militaristic city-state gifting a unit

	CvCity* pMajorCity = GetClosestCity(pMinorPlot);

	int iX = pMinorCapital->getX();
	int iY = pMinorCapital->getY();
	if(pMajorCity != NULL)
	{
		iX = pMajorCity->getX();
		iY = pMajorCity->getY();
	}

	// Pick Great Person type
	UnitTypes eBestUnit = NO_UNIT;
	int iBestScore = -1;
	SpecialUnitTypes eSpecialUnitGreatPerson = (SpecialUnitTypes) GC.getInfoTypeForString("SPECIALUNIT_PEOPLE");

	for(int iUnitLoop = 0; iUnitLoop < GC.getNumUnitInfos(); iUnitLoop++)
	{
		UnitTypes eLoopUnit = (UnitTypes)iUnitLoop;
		CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eLoopUnit);

		if(pkUnitEntry && pkUnitEntry->GetSpecialUnitType() == eSpecialUnitGreatPerson)
		{
			// No prophets
			if(!pkUnitEntry->IsFoundReligion())
			{
				int iScore = GC.getGame().getJonRandNum(100, "Rand");

				if(iScore > iBestScore)
				{
					iBestScore = iScore;
					eBestUnit = eLoopUnit;
				}
			}
		}
	}

	// Spawn GreatPeople
	if(eBestUnit != NO_UNIT)
	{
		CvUnit* pNewGreatPeople = initUnit(eBestUnit, iX, iY);
		CvAssert(pNewGreatPeople);

		if (pNewGreatPeople)
		{
			// Bump up the count
			if(pNewGreatPeople->IsGreatGeneral())
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGreatGeneralsCreated(bIsFree);
#else
				incrementGreatGeneralsCreated();
#endif
			}
			else if(pNewGreatPeople->IsGreatAdmiral())
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGreatAdmiralsCreated(bIsFree);
#else
				incrementGreatAdmiralsCreated();
#endif
			}
			else if (pNewGreatPeople->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_WRITER"))
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGreatWritersCreated(bIsFree);
#else
				incrementGreatWritersCreated();
#endif
			}							
			else if (pNewGreatPeople->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_ARTIST"))
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGreatArtistsCreated(bIsFree);
#else
				incrementGreatArtistsCreated();
#endif
			}							
			else if (pNewGreatPeople->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_MUSICIAN"))
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGreatMusiciansCreated(bIsFree);
#else
				incrementGreatMusiciansCreated();
#endif
			}
#if defined(MOD_DIPLOMACY_CITYSTATES)
			else if (MOD_DIPLOMACY_CITYSTATES && pNewGreatPeople->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_GREAT_DIPLOMAT"))
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGreatDiplomatsCreated(bIsFree);
#else
				incrementGreatDiplomatsCreated();
#endif
			}
#endif
#if defined(MOD_BALANCE_CORE)
			else if (pNewGreatPeople->getUnitInfo().IsGPExtra() == 1)
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGPExtra1Created(bIsFree);
#else
				incrementGPExtra1Created();
#endif
			}
			else if (pNewGreatPeople->getUnitInfo().IsGPExtra() == 2)
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGPExtra2Created(bIsFree);
#else
				incrementGPExtra2Created();
#endif
			}
			else if (pNewGreatPeople->getUnitInfo().IsGPExtra() == 3)
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGPExtra3Created(bIsFree);
#else
				incrementGPExtra3Created();
#endif
			}
			else if (pNewGreatPeople->getUnitInfo().IsGPExtra() == 4)
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGPExtra4Created(bIsFree);
#else
				incrementGPExtra4Created();
#endif
			}
			else if (pNewGreatPeople->getUnitInfo().IsGPExtra() == 5)
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGPExtra5Created(bIsFree);
#else
				incrementGPExtra5Created();
#endif
			}
#endif
			else
			{
#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
				if (MOD_GLOBAL_SEPARATE_GP_COUNTERS) {
					if (pNewGreatPeople->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_MERCHANT")) {
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
						incrementGreatMerchantsCreated(bIsFree);
#else
						incrementGreatMerchantsCreated();
#endif
					} else if (pNewGreatPeople->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_SCIENTIST")) {
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
						incrementGreatScientistsCreated(bIsFree);
#else
						incrementGreatScientistsCreated();
#endif
					} else {
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
						incrementGreatEngineersCreated(bIsFree);
#else
						incrementGreatEngineersCreated();
#endif
					}
				} else
#endif
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGreatPeopleCreated(bIsFree);
#else
				incrementGreatPeopleCreated();
#endif
			}

			if (pNewGreatPeople->IsGreatAdmiral())
			{
				CvPlot* pSpawnPlot = GetGreatAdmiralSpawnPlot(pNewGreatPeople);
				if (pNewGreatPeople->plot() != pSpawnPlot && pSpawnPlot != NULL)
				{
					pNewGreatPeople->setXY(pSpawnPlot->getX(), pSpawnPlot->getY());
				}
			}
			else
			{
				if (!pNewGreatPeople->jumpToNearestValidPlot())
					pNewGreatPeople->kill(false);	// Could not find a spot!
			}

			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_STATE_UNIT_SPAWN");
				strMessage << GET_PLAYER(eMinor).getNameKey();
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_STATE_UNIT_SPAWN");
				strSummary << GET_PLAYER(eMinor).getNameKey();
				pNotifications->Add(NOTIFICATION_MINOR, strMessage.toUTF8(), strSummary.toUTF8(), iX, iY, eMinor);
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Time to spawn a GreatPeople?
void CvPlayer::DoGreatPeopleSpawnTurn()
{
	// Tick down
	if(GetGreatPeopleSpawnCounter() > 0)
	{
		AI_PERF_FORMAT("AI-perf.csv", ("CvPlayer::DoGreatPeopleSpawnTurn, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), getCivilizationShortDescription()) );
		ChangeGreatPeopleSpawnCounter(-1);

		// Time to spawn! - Pick a random allied minor
		if(GetGreatPeopleSpawnCounter() == 0)
		{
			PlayerTypes eBestMinor = NO_PLAYER;
			int iBestScore = -1;
			int iScore;

			PlayerTypes eMinor;
			for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
			{
				eMinor = (PlayerTypes) iMinorLoop;

				// Not alive
				if(!GET_PLAYER(eMinor).isAlive())
					continue;

				// Not an ally
				if(GET_PLAYER(eMinor).GetMinorCivAI()->GetAlly() != GetID())
					continue;

				iScore = GC.getGame().getJonRandNum(100, "Random minor great person gift location.");

				// Best ally yet?
				if(eBestMinor == NO_PLAYER || iScore > iBestScore)
				{
					eBestMinor = eMinor;
					iBestScore = iScore;
				}
			}

			if(eBestMinor != NO_PLAYER)
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				DoSpawnGreatPerson(eBestMinor, MOD_GLOBAL_TRULY_FREE_GP);
#else
				DoSpawnGreatPerson(eBestMinor);
#endif

			// Reseed counter
			DoSeedGreatPeopleSpawnCounter();
		}
	}
}

//	--------------------------------------------------------------------------------
CvCity* CvPlayer::GetGreatPersonSpawnCity(UnitTypes eUnit)
{
	CvCity* pBestCity = getCapitalCity();
	CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eUnit);

	if(pkUnitEntry && pkUnitEntry->GetDomainType() == DOMAIN_SEA)
	{
		int iBestValue = INT_MAX;
		int iLoop;
		for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(!pLoopCity->isCoastal())
			{
				continue;
			}

			int iValue = 4 * GC.getGame().getJonRandNum(getNumCities(), "Great Admiral City Selection");

			for(int i = 0; i < NUM_YIELD_TYPES; i++)
			{
				iValue += pLoopCity->findYieldRateRank((YieldTypes)i);
			}
			iValue += pLoopCity->findPopulationRank();

			if(iValue < iBestValue)
			{
				pBestCity = pLoopCity;
				iBestValue = iValue;
			}
		}
	}

	return pBestCity;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getMaxGlobalBuildingProductionModifier() const
{
	return m_iMaxGlobalBuildingProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMaxGlobalBuildingProductionModifier(int iChange)
{
	m_iMaxGlobalBuildingProductionModifier = (m_iMaxGlobalBuildingProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getMaxTeamBuildingProductionModifier() const
{
	return m_iMaxTeamBuildingProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMaxTeamBuildingProductionModifier(int iChange)
{
	m_iMaxTeamBuildingProductionModifier = (m_iMaxTeamBuildingProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getMaxPlayerBuildingProductionModifier() const
{
	return m_iMaxPlayerBuildingProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMaxPlayerBuildingProductionModifier(int iChange)
{
	m_iMaxPlayerBuildingProductionModifier = (m_iMaxPlayerBuildingProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getFreeExperience() const
{
	return m_iFreeExperience;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeFreeExperienceFromBldgs(int iChange)
{
	m_iFreeExperienceFromBldgs += iChange;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeFreeExperienceFromMinors(int iChange)
{
	m_iFreeExperienceFromMinors += iChange;
}

//	--------------------------------------------------------------------------------
void CvPlayer::recomputeFreeExperience()
{
	m_iFreeExperience = m_iFreeExperienceFromBldgs;
	m_iFreeExperience = m_iFreeExperienceFromMinors;
	m_iFreeExperience += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_FREE_EXPERIENCE);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getFeatureProductionModifier() const
{
	return m_iFeatureProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeFeatureProductionModifier(int iChange)
{
	m_iFeatureProductionModifier = (m_iFeatureProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getWorkerSpeedModifier() const
{
	return m_iWorkerSpeedModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeWorkerSpeedModifier(int iChange)
{
	m_iWorkerSpeedModifier = (m_iWorkerSpeedModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getImprovementCostModifier() const
{
	return m_iImprovementCostModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeImprovementCostModifier(int iChange)
{
	m_iImprovementCostModifier = (m_iImprovementCostModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getImprovementUpgradeRateModifier() const
{
	return m_iImprovementUpgradeRateModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeImprovementUpgradeRateModifier(int iChange)
{
	m_iImprovementUpgradeRateModifier = (m_iImprovementUpgradeRateModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getSpecialistProductionModifier() const
{
	return m_iSpecialistProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeSpecialistProductionModifier(int iChange)
{
	m_iSpecialistProductionModifier = (m_iSpecialistProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getMilitaryProductionModifier() const
{
	return m_iMilitaryProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMilitaryProductionModifier(int iChange)
{
	m_iMilitaryProductionModifier = (m_iMilitaryProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getSpaceProductionModifier() const
{
	return m_iSpaceProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeSpaceProductionModifier(int iChange)
{
	m_iSpaceProductionModifier = (m_iSpaceProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getCityDefenseModifier() const
{
	return m_iCityDefenseModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeCityDefenseModifier(int iChange)
{
	m_iCityDefenseModifier = (m_iCityDefenseModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getUnitFortificationModifier() const
{
	return m_iUnitFortificationModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeUnitFortificationModifier(int iChange)
{
	m_iUnitFortificationModifier = (m_iUnitFortificationModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getUnitBaseHealModifier() const
{
	return m_iUnitBaseHealModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeUnitBaseHealModifier(int iChange)
{
	m_iUnitBaseHealModifier = (m_iUnitBaseHealModifier + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getWonderProductionModifier() const
{
	return m_iWonderProductionModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeWonderProductionModifier(int iChange)
{
	m_iWonderProductionModifier = (m_iWonderProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getSettlerProductionModifier() const
{
	return m_iSettlerProductionModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeSettlerProductionModifier(int iChange)
{
	m_iSettlerProductionModifier = (m_iSettlerProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getCapitalSettlerProductionModifier() const
{
	return m_iCapitalSettlerProductionModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeCapitalSettlerProductionModifier(int iChange)
{
	m_iCapitalSettlerProductionModifier = (m_iCapitalSettlerProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::GetPolicyCostBuildingModifier() const
{
	return m_iPolicyCostBuildingModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangePolicyCostBuildingModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iPolicyCostBuildingModifier = (m_iPolicyCostBuildingModifier + iChange);

		recomputePolicyCostModifier();
		DoUpdateNextPolicyCost();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetPolicyCostMinorCivModifier() const
{
	return m_iPolicyCostMinorCivModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangePolicyCostMinorCivModifier(int iChange)
{
	m_iPolicyCostMinorCivModifier = (m_iPolicyCostMinorCivModifier + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetInfluenceSpreadModifier() const
{
	return m_iInfluenceSpreadModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeInfluenceSpreadModifier(int iChange)
{
	m_iInfluenceSpreadModifier = (m_iInfluenceSpreadModifier + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetExtraVotesPerDiplomat() const
{
	return m_iExtraVotesPerDiplomat;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeExtraVotesPerDiplomat(int iChange)
{
	m_iExtraVotesPerDiplomat += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNumNukeUnits() const
{
	return m_iNumNukeUnits;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeNumNukeUnits(int iChange)
{
	m_iNumNukeUnits = (m_iNumNukeUnits + iChange);
	CvAssert(getNumNukeUnits() >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getNumOutsideUnits()
{
	int iOutsideUnitCount = 0;

	CvUnit* pLoopUnit;
	int iLoop;
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->plot() != NULL)
		{
			if(pLoopUnit->plot()->getOwner() != pLoopUnit->getOwner())
			{
				iOutsideUnitCount++;
			}
		}
	}

	return iOutsideUnitCount;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeNumOutsideUnits(int iChange)
{
	if(iChange != 0)
	{
		m_iNumOutsideUnits += iChange;
		CvAssert(getNumOutsideUnits() >= 0);

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getBaseFreeUnits() const
{
	return m_iBaseFreeUnits;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeBaseFreeUnits(int iChange)
{
	if(iChange != 0)
	{
		m_iBaseFreeUnits = (m_iBaseFreeUnits + iChange);

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetVerifiedOutsideUnitCount()
{
	int iOutsideUnitCount = 0;

	CvUnit* pLoopUnit;
	int iLoop;
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->plot() != NULL)
		{
			if(pLoopUnit->plot()->getOwner() != pLoopUnit->getOwner())
			{
				iOutsideUnitCount++;
			}
		}
	}

	return iOutsideUnitCount;
}


//	--------------------------------------------------------------------------------
int CvPlayer::getGoldPerUnit() const
{
	return getGoldPerUnitTimes100() / 100;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeGoldPerUnit(int iChange)
{
	if(iChange != 0)
	{
		changeGoldPerUnitTimes100(iChange * 100);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGoldPerUnitTimes100() const
{
	return m_iGoldPerUnit;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeGoldPerUnitTimes100(int iChange)
{
	if(iChange != 0)
	{
		m_iGoldPerUnit = (m_iGoldPerUnit + iChange);

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getGoldPerMilitaryUnit() const
{
	return m_iGoldPerMilitaryUnit;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeGoldPerMilitaryUnit(int iChange)
{
	if(iChange != 0)
	{
		m_iGoldPerMilitaryUnit = (m_iGoldPerMilitaryUnit + iChange);

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetImprovementGoldMaintenanceMod() const
{
	return m_iImprovementGoldMaintenanceMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeImprovementGoldMaintenanceMod(int iChange)
{
	if(iChange != 0)
	{
		m_iImprovementGoldMaintenanceMod = (m_iImprovementGoldMaintenanceMod + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetBuildingGoldMaintenanceMod() const
{
	return m_iBuildingGoldMaintenanceMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeBuildingGoldMaintenanceMod(int iChange)
{
	if(iChange != 0)
	{
		m_iBuildingGoldMaintenanceMod = (m_iBuildingGoldMaintenanceMod + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetUnitGoldMaintenanceMod() const
{
	return m_iUnitGoldMaintenanceMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeUnitGoldMaintenanceMod(int iChange)
{
	if(iChange != 0)
	{
		m_iUnitGoldMaintenanceMod = (m_iUnitGoldMaintenanceMod + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetUnitSupplyMod() const
{
	return m_iUnitSupplyMod;
}


//	--------------------------------------------------------------------------------
void CvPlayer::ChangeUnitSupplyMod(int iChange)
{
	if(iChange != 0)
	{
		m_iUnitSupplyMod = (m_iUnitSupplyMod + iChange);
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getExtraUnitCost() const
{
	return m_iExtraUnitCost;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeExtraUnitCost(int iChange)
{
	if(iChange != 0)
	{
		m_iExtraUnitCost = (m_iExtraUnitCost + iChange);

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumMaintenanceFreeUnits(DomainTypes eDomain, bool bOnlyCombatUnits) const
{
	int iNumFreeUnits = 0;

	// Loop through all units to see if any of them are free!
	const CvUnit* pLoopUnit;
	int iLoop;
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if (eDomain != NO_DOMAIN)
		{
			if (pLoopUnit->getDomainType() != eDomain)
			{
				continue;
			}
		}

		if (bOnlyCombatUnits)
		{
			if (!pLoopUnit->IsCombatUnit())
			{
				continue;
			}
		}

		if(pLoopUnit->getUnitInfo().IsNoMaintenance())
		{
			iNumFreeUnits++;
		}
		else if(IsGarrisonFreeMaintenance() && pLoopUnit->IsGarrisoned())
		{
			iNumFreeUnits++;
		}
	}

	return iNumFreeUnits;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNumMilitaryUnits() const
{
	return m_iNumMilitaryUnits;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeNumMilitaryUnits(int iChange)
{
	if(iChange != 0)
	{
		m_iNumMilitaryUnits = (m_iNumMilitaryUnits + iChange);
		CvAssert(getNumMilitaryUnits() >= 0);

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getHappyPerMilitaryUnit() const
{
	return m_iHappyPerMilitaryUnit;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeHappyPerMilitaryUnit(int iChange)
{
	if(iChange != 0)
	{
		m_iHappyPerMilitaryUnit = (m_iHappyPerMilitaryUnit + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getHappinessToCulture() const
{
	return m_iHappinessToCulture;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeHappinessToCulture(int iChange)
{
	if(iChange != 0)
	{
		m_iHappinessToCulture = (m_iHappinessToCulture + iChange);
		CvAssert(getHappinessToCulture() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getHappinessToScience() const
{
	return m_iHappinessToScience;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeHappinessToScience(int iChange)
{
	if(iChange != 0)
	{
		m_iHappinessToScience = (m_iHappinessToScience + iChange);
		CvAssert(getHappinessToScience() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getHalfSpecialistUnhappinessCount() const
{
	return m_iHalfSpecialistUnhappinessCount;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isHalfSpecialistUnhappiness() const
{
	return (getHalfSpecialistUnhappinessCount() > 0);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeHalfSpecialistUnhappinessCount(int iChange)
{
	if(iChange != 0)
	{
		m_iHalfSpecialistUnhappinessCount = (m_iHalfSpecialistUnhappinessCount + iChange);
		CvAssert(getHalfSpecialistUnhappinessCount() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getHalfSpecialistFoodCount() const
{
	return m_iHalfSpecialistFoodCount;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isHalfSpecialistFood() const
{
	return (getHalfSpecialistFoodCount() > 0);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeHalfSpecialistFoodCount(int iChange)
{
	if(iChange != 0)
	{
		m_iHalfSpecialistFoodCount = (m_iHalfSpecialistFoodCount + iChange);
		CvAssert(getHalfSpecialistFoodCount() >= 0);
	}
}

#if defined(MOD_BALANCE_CORE)
	//	--------------------------------------------------------------------------------
int CvPlayer::getHalfSpecialistFoodCapitalCount() const
{
	return m_iHalfSpecialistFoodCapitalCount;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isHalfSpecialistFoodCapital() const
{
	return (getHalfSpecialistFoodCapitalCount() > 0);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeHalfSpecialistFoodCapitalCount(int iChange)
{
	if(iChange != 0)
	{
		m_iHalfSpecialistFoodCapitalCount = (m_iHalfSpecialistFoodCapitalCount + iChange);
		CvAssert(getHalfSpecialistFoodCapitalCount() >= 0);
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetDomainFreeExperiencePerGreatWorkGlobal(DomainTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_DOMAIN_TYPES, "eIndex expected to be < NUM_DOMAIN_TYPES");
	return m_aiDomainFreeExperiencePerGreatWorkGlobal[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::ChangeDomainFreeExperiencePerGreatWorkGlobal(DomainTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_DOMAIN_TYPES, "eIndex expected to be < NUM_DOMAIN_TYPES");
	m_aiDomainFreeExperiencePerGreatWorkGlobal.setAt(eIndex, m_aiDomainFreeExperiencePerGreatWorkGlobal[eIndex] + iChange);
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::getMilitaryFoodProductionCount() const
{
	return m_iMilitaryFoodProductionCount;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isMilitaryFoodProduction() const
{
	return (getMilitaryFoodProductionCount() > 0);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMilitaryFoodProductionCount(int iChange)
{
	if(iChange != 0)
	{
		m_iMilitaryFoodProductionCount = (m_iMilitaryFoodProductionCount + iChange);
		CvAssert(getMilitaryFoodProductionCount() >= 0);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetGoldenAgeCultureBonusDisabledCount() const
{
	return m_iGoldenAgeCultureBonusDisabledCount;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsGoldenAgeCultureBonusDisabled() const
{
	return (GetGoldenAgeCultureBonusDisabledCount() > 0);
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeGoldenAgeCultureBonusDisabledCount(int iChange)
{
	if (iChange != 0)
	{
		m_iGoldenAgeCultureBonusDisabledCount = m_iGoldenAgeCultureBonusDisabledCount + iChange;
		CvAssert(GetGoldenAgeCultureBonusDisabledCount() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetSecondReligionPantheonCount() const
{
	return m_iSecondReligionPantheonCount;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsSecondReligionPantheon() const
{
	return (GetSecondReligionPantheonCount() > 0);
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeSecondReligionPantheonCount(int iChange)
{
	if (iChange != 0)
	{
		m_iSecondReligionPantheonCount = m_iSecondReligionPantheonCount + iChange;
		CvAssert(GetSecondReligionPantheonCount() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetEnablesSSPartHurryCount() const
{
	return m_iEnablesSSPartHurryCount;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsEnablesSSPartHurry() const
{
	return (GetEnablesSSPartHurryCount() > 0);
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeEnablesSSPartHurryCount(int iChange)
{
	if (iChange != 0)
	{
		m_iEnablesSSPartHurryCount = m_iEnablesSSPartHurryCount + iChange;
		CvAssert(GetEnablesSSPartHurryCount() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetEnablesSSPartPurchaseCount() const
{
	return m_iEnablesSSPartPurchaseCount;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsEnablesSSPartPurchase() const
{
	return (GetEnablesSSPartPurchaseCount() > 0);
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeEnablesSSPartPurchaseCount(int iChange)
{
	if (iChange != 0)
	{
		m_iEnablesSSPartPurchaseCount = m_iEnablesSSPartPurchaseCount + iChange;
		CvAssert(GetEnablesSSPartPurchaseCount() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getHighestUnitLevel()	const
{
	return m_iHighestUnitLevel;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setHighestUnitLevel(int iNewValue)
{
	m_iHighestUnitLevel = iNewValue;
	CvAssert(getHighestUnitLevel() >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getMaxConscript() const
{
	return m_iMaxConscript;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMaxConscript(int iChange)
{
	m_iMaxConscript = (m_iMaxConscript + iChange);
	CvAssert(getMaxConscript() >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getConscriptCount() const
{
	return m_iConscriptCount;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setConscriptCount(int iNewValue)
{
	m_iConscriptCount = iNewValue;
	CvAssert(getConscriptCount() >= 0);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeConscriptCount(int iChange)
{
	setConscriptCount(getConscriptCount() + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getOverflowResearch() const
{
#if defined(MOD_BUGFIX_MINOR)
	return getOverflowResearchTimes100() / 100;
#else
	return m_iOverflowResearch / 100;
#endif
}


//	--------------------------------------------------------------------------------
void CvPlayer::setOverflowResearch(int iNewValue)
{
	setOverflowResearchTimes100(iNewValue*100);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeOverflowResearch(int iChange)
{
	changeOverflowResearchTimes100(iChange*100);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getOverflowResearchTimes100() const
{
	return m_iOverflowResearch;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setOverflowResearchTimes100(int iNewValue)
{
	m_iOverflowResearch = iNewValue;
	CvAssert(getOverflowResearchTimes100() >= 0);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeOverflowResearchTimes100(int iChange)
{
	setOverflowResearchTimes100(getOverflowResearchTimes100() + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getExpModifier() const
{
	return m_iExpModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeExpModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iExpModifier += iChange;
		CvAssert(getExpModifier() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getExpInBorderModifier() const
{
	return m_iExpInBorderModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeExpInBorderModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iExpInBorderModifier += iChange;
		CvAssert(getExpInBorderModifier() >= 0);
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getLevelExperienceModifier() const
{
	return m_iLevelExperienceModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeLevelExperienceModifier(int iChange)
{
	m_iLevelExperienceModifier += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getMinorQuestFriendshipMod() const
{
	return m_iMinorQuestFriendshipMod;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMinorQuestFriendshipMod(int iChange)
{
	if(iChange != 0)
	{
		m_iMinorQuestFriendshipMod += iChange;
		CvAssert(getMinorQuestFriendshipMod() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getMinorGoldFriendshipMod() const
{
	return m_iMinorGoldFriendshipMod;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMinorGoldFriendshipMod(int iChange)
{
	if(iChange != 0)
	{
		m_iMinorGoldFriendshipMod += iChange;
		CvAssert(getMinorGoldFriendshipMod() >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// What is the general modifier we get towards the resting Influence point with a city-state? (ex. Social Policies)
/// NOTE: This does not include situation-dependent modifiers (ex. religion or warmongering), which are handled in CvMinorCivAI
int CvPlayer::GetMinorFriendshipAnchorMod() const
{
	return m_iMinorFriendshipMinimum;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetMinorFriendshipAnchorMod(int iValue)
{
	if (iValue < GC.getMINOR_FRIENDSHIP_AT_WAR())
	{
		CvAssertMsg(false, "Minor friendship anchor mod should not be lower than the War friendship level. Please send Anton your save file and version.");
		m_iMinorFriendshipMinimum = GC.getMINOR_FRIENDSHIP_AT_WAR();
		return;
	}

	m_iMinorFriendshipMinimum = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMinorFriendshipAnchorMod(int iChange)
{
	SetMinorFriendshipAnchorMod(GetMinorFriendshipAnchorMod() + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::GetMinorFriendshipDecayMod() const
{
	return m_iMinorFriendshipDecayMod;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeGetMinorFriendshipDecayMod(int iChange)
{
	if(iChange != 0)
	{
		m_iMinorFriendshipDecayMod += iChange;
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsMinorScienceAllies() const
{
	return GetMinorScienceAlliesCount() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetMinorScienceAlliesCount() const
{
	return m_iMinorScienceAlliesCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMinorScienceAlliesCount(int iChange)
{
	if(iChange != 0)
	{
		m_iMinorScienceAlliesCount += iChange;
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsMinorResourceBonus() const
{
	return GetMinorResourceBonusCount() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetMinorResourceBonusCount() const
{
	return m_iMinorResourceBonusCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMinorResourceBonusCount(int iChange)
{
	if(iChange != 0)
	{
		m_iMinorResourceBonusCount += iChange;
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsAbleToAnnexCityStates() const
{
	if (GetAbleToAnnexCityStatesCount() > 0)
		return true;

	if (GetPlayerTraits()->IsAbleToAnnexCityStates())
		return true;

	return false;
}
#if defined(MOD_BALANCE_CORE)
	//JFD
void CvPlayer::SetPiety(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_PietyChanged, GetID(), GetPiety(), iValue);
	if(m_iJFDPiety != iValue)
	{
		m_iJFDPiety = iValue;
	}
}
void CvPlayer::ChangePiety(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_PietyChanged, GetID(), GetPiety(), iValue);
	m_iJFDPiety += iValue;
	if(m_iJFDPiety > GC.getGame().getGameSpeedInfo().getPietyMax())
	{
		m_iJFDPiety = GC.getGame().getGameSpeedInfo().getPietyMax();
	}
	if(m_iJFDPiety < GC.getGame().getGameSpeedInfo().getPietyMin())
	{
		m_iJFDPiety = GC.getGame().getGameSpeedInfo().getPietyMin();
	}
}
int CvPlayer::GetPiety() const
{
	return m_iJFDPiety;
}
int CvPlayer::GetPietyRate() const
{
	return m_iJFDPietyRate;
}
void CvPlayer::SetPietyRate(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_PietyRateChanged, GetID(), GetPietyRate(), iValue);
	if(m_iJFDPietyRate != iValue)
	{
		m_iJFDPietyRate = iValue;
	}
}
void CvPlayer::ChangePietyRate(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_PietyRateChanged, GetID(), GetPietyRate(), iValue);
	m_iJFDPietyRate += iValue;
}
int CvPlayer::GetTurnsSinceConversion() const
{
	return m_iJFDConversionTurn;
}
void CvPlayer::SetTurnsSinceConversion(int iValue)
{
	if(m_iJFDConversionTurn != iValue)
	{
		m_iJFDConversionTurn = iValue;
	}
}
void CvPlayer::DoPiety()
{
	ReligionTypes eReligion = GetReligions()->GetStateReligion();
	if(eReligion == NO_RELIGION)
	{
		return;
	}
	else
	{
		int iRate = GetPietyRate();
		if(iRate != 0)
		{
			ChangePiety(iRate);
		}
	}
}
bool CvPlayer::HasStateReligion()
{
	if(GetReligions()->GetStateReligion() != NO_RELIGION)
	{
		return true;
	}
	return false;
}
bool CvPlayer::HasSecularized() const
{
	return m_bJFDSecularized;
}
void CvPlayer::SetHasSecularized(bool bValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerSecularizes, GetID(), GetReligions()->GetStateReligion(), bValue);
	m_bJFDSecularized = bValue;
}
bool CvPlayer::IsPagan()
{
	if(GetReligions()->HasCreatedPantheon() && !HasStateReligion() && !HasSecularized())
	{
		return true;
	}
	return false;
}

void CvPlayer::ChangeSovereignty(int iValue)
{
	m_iJFDSovereignty += iValue;
}
int CvPlayer::GetSovereignty() const
{
	return m_iJFDSovereignty;
}
void CvPlayer::SetSovereignty(int iValue)
{
	if(m_iJFDSovereignty != iValue)
	{
		m_iJFDSovereignty = iValue;
	}
}

void CvPlayer::SetGovernment(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerAdoptsGovernment, GetID(), iValue);
	if(m_iJFDGovernment != iValue)
	{
		m_iJFDGovernment = iValue;
	}
}
int CvPlayer::GetGovernment() const
{
	return m_iJFDGovernment;
}
bool CvPlayer::HasGovernment()
{
	if(GetGovernment() > -1)
	{
		return true;
	}
	return false;
}

void CvPlayer::ChangeReformCooldown(int iValue)
{
	m_iJFDReformCooldown += iValue;
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_ReformCooldownChanges, GetID(), GetReformCooldown());
}
int CvPlayer::GetReformCooldown() const
{
	return m_iJFDReformCooldown;
}
void CvPlayer::SetReformCooldown(int iValue, bool bNoEvent)
{
	if(m_iJFDReformCooldown != iValue)
	{
		m_iJFDReformCooldown = iValue;
	}
	if(!bNoEvent)
	{
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_ReformCooldownChanges, GetID(), GetReformCooldown());
	}
}

void CvPlayer::ChangeReformCooldownRate(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_ReformCooldownRateChanges, GetID(), iValue);
	m_iJFDReformCooldownRate += iValue;
}
int CvPlayer::GetReformCooldownRate() const
{
	return m_iJFDReformCooldownRate;
}
void CvPlayer::SetReformCooldownRate(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_ReformCooldownRateChanges, GetID(), iValue);
	if(m_iJFDReformCooldownRate != iValue)
	{
		m_iJFDReformCooldownRate = iValue;
	}
}

void CvPlayer::ChangeGovernmentCooldown(int iValue)
{
	m_iJFDGovernmentCooldown += iValue;
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_GovernmentCooldownChanges, GetID(), GetGovernmentCooldown());
}
int CvPlayer::GetGovernmentCooldown() const
{
	return m_iJFDGovernmentCooldown;
}
void CvPlayer::SetGovernmentCooldown(int iValue, bool bNoEvent)
{
	if(m_iJFDGovernmentCooldown != iValue)
	{
		m_iJFDGovernmentCooldown = iValue;
	}
	if(!bNoEvent)
	{
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_GovernmentCooldownChanges, GetID(), GetGovernmentCooldown());
	}
}

void CvPlayer::ChangeGovernmentCooldownRate(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_GovernmentCooldownRateChanges, GetID(), iValue);
	m_iJFDGovernmentCooldownRate += iValue;
}
int CvPlayer::GetGovernmentCooldownRate() const
{
	return m_iJFDGovernmentCooldownRate;
}
void CvPlayer::SetGovernmentCooldownRate(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_GovernmentCooldownRateChanges, GetID(), iValue);
	if(m_iJFDGovernmentCooldownRate != iValue)
	{
		m_iJFDGovernmentCooldownRate = iValue;
	}
}

int CvPlayer::GetPoliticLeader() const
{
	return m_iJFDPoliticLeader;
}
void CvPlayer::SetPoliticLeader(int iID)
{
	m_iJFDPoliticLeader = iID;
}

CvString CvPlayer::GetPoliticLeaderKey() const
{
	return m_strJFDPoliticKey;
}
void CvPlayer::SetPoliticLeaderKey(const char* strKey)
{
	m_strJFDPoliticKey = strKey;
}

CvString CvPlayer::GetLegislatureName() const
{
	return m_strJFDLegislatureName;
}
void CvPlayer::SetLegislatureName(const char* strKey)
{
	m_strJFDLegislatureName = strKey;
}

int CvPlayer::GetPoliticPercent(int iID) const
{
	return m_paiJFDPoliticPercent[iID];
}
void CvPlayer::SetPoliticPercent(int iID, int iValue)
{
	m_paiJFDPoliticPercent.setAt(iID, iValue);
}

void CvPlayer::DoGovernmentCooldown()
{
	if(GetGovernmentCooldown() <= 0)
	{
		return;
	}
	int iRate = GetGovernmentCooldownRate();
	if(iRate != 0)
	{
		ChangeGovernmentCooldown(-iRate);
		if(GetGovernmentCooldown() <= 0)
		{
			SetGovernmentCooldown(0, true);
		}
	}
}
void CvPlayer::DoReformCooldown()
{
	if(GetReformCooldown() <= 0)
	{
		return;
	}
	int iRate = GetReformCooldownRate();
	if(iRate != 0)
	{
		ChangeReformCooldown(-iRate);
		if(GetReformCooldown() <= 0)
		{
			SetReformCooldown(0, true);
		}
	}
}
void CvPlayer::SetCurrency(int iValue)
{
	if(!HasCurrency())
	{
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerAdoptsCurrency, GetID(), iValue, -1);
	}
	else
	{
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerAdoptsCurrency, GetID(), iValue, GetCurrency());
	}
	if(m_iJFDCurrency != iValue)
	{
		m_iJFDCurrency = iValue;
	}
}
int CvPlayer::GetCurrency() const
{
	return m_iJFDCurrency;
}
bool CvPlayer::HasCurrency()
{
	if(GetCurrency() > -1)
	{
		return true;
	}
	return false;
}

CvString CvPlayer::GetCurrencyName() const
{
	return m_strJFDCurrencyName;
}
void CvPlayer::SetCurrencyName(const char* strKey)
{
	m_strJFDCurrencyName = strKey;
}
	//JFD DONE
void CvPlayer::DoArmyDiversity()
{
	//////Let's get sum total of all land military unit AI types and boost the lowest type.
	int iLowest = MAX_INT;
	int iUnitAI = -1;
	m_iUnitDiversity = -1;
	for(int iJ = 0; iJ < NUM_UNITAI_TYPES; iJ++)
	{
		UnitAITypes eUnitAI = (UnitAITypes)iJ;
		if(eUnitAI == NO_UNITAI)
			continue;

		if(eUnitAI == UNITAI_ATTACK || eUnitAI == UNITAI_CITY_BOMBARD || eUnitAI == UNITAI_FAST_ATTACK  || eUnitAI == UNITAI_DEFENSE || eUnitAI == UNITAI_COUNTER || eUnitAI == UNITAI_RANGED)
		{
			int iNumUnits = GetNumUnitsWithUnitAI((UnitAITypes)iJ, true, false);
			if(iNumUnits < iLowest)
			{
				iLowest = iNumUnits;
				iUnitAI = iJ;
			}
		}
	}
	if(iUnitAI != -1)
	{
		m_iUnitDiversity = iUnitAI;
	}
}
int CvPlayer::GetArmyDiversity() const
{
	return m_iUnitDiversity;
}
//	--------------------------------------------------------------------------------
bool CvPlayer::CanArchaeologicalDigTourism() const
{
	if (GetArchaeologicalDigTourism() > 0)
	{
		return true;
	}

	return false;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetArchaeologicalDigTourism() const
{
	return m_iArchaeologicalDigTourism;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeArchaeologicalDigTourism(int iChange)
{
	m_iArchaeologicalDigTourism += iChange;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::CanGoldenAgeTourism() const
{
	if (GetGoldenAgeTourism() > 0)
	{
		return true;
	}

	return false;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetGoldenAgeTourism() const
{
	return m_iGoldenAgeTourism;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeGoldenAgeTourism(int iChange)
{
	m_iGoldenAgeTourism += iChange;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::CanUpgradeCSTerritory() const
{
	if (GetUpgradeCSTerritory() > 0)
	{
		return true;
	}

	return false;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetUpgradeCSTerritory() const
{
	return m_iUpgradeCSTerritory;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeUpgradeCSTerritory(int iChange)
{
	m_iUpgradeCSTerritory += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetRazingSpeedBonus() const
{
	return m_iRazingSpeedBonus;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeRazingSpeedBonus(int iChange)
{
	m_iRazingSpeedBonus += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetNoPartisans() const
{
	return m_iNoPartisans;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNoPartisans(int iChange)
{
	m_iNoPartisans += iChange;
}
//	--------------------------------------------------------------------------------
bool CvPlayer::IsNoPartisans() const
{
	if (GetNoPartisans() > 0)
	{
		return true;
	}

	return false;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetSpawnCooldown() const
{
	return m_iSpawnCooldown;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetSpawnCooldown(int iValue)
{
	m_iSpawnCooldown = iValue;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeSpawnCooldown(int iChange)
{
	m_iSpawnCooldown += iChange;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsDiplomaticMarriage() const
{
	if (GetAbleToMarryCityStatesCount() > 0)
		return true;

	if (GetPlayerTraits()->IsDiplomaticMarriage())
		return true;

	return false;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetAbleToMarryCityStatesCount() const
{
	return m_iAbleToMarryCityStatesCount;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeAbleToMarryCityStatesCount(int iChange)
{
	m_iAbleToMarryCityStatesCount += iChange;
}
//CORPORATIONS
//	--------------------------------------------------------------------------------
int CvPlayer::GetCorporationMaxFranchises() const
{
	return m_iCorporationMaxFranchises;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeCorporationMaxFranchises(int iChange)
{
	m_iCorporationMaxFranchises += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetCorporateFounderID() const
{
	return m_iCorporateFounderID;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetCorporateFounderID(int iChange)
{
	m_iCorporateFounderID = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetCorporateFoundedTurn() const
{
	return m_iCorporateFoundedTurn;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetCorporateFoundedTurn(int iValue)
{
	m_iCorporateFoundedTurn = iValue;
}
void CvPlayer::DoFreedomCorp()
{
	//Are you free enough?!
	if(!IsFreedomCorp())
	{
		return;
	}
	int iFranchises = GetCorporateFranchisesWorldwide();
	int iMax = GetMaxFranchises();

	CvCity* pLoopCity;
	int iLoop;
	BuildingTypes eFreeBuilding = NO_BUILDING;

	if(iFranchises < iMax)
	{
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity != NULL)
			{
				if(pLoopCity->GetFreeBuildingTradeTargetCity() > 0)
				{
					BuildingClassTypes eBuildingClassDestCity = (BuildingClassTypes)pLoopCity->GetFreeBuildingTradeTargetCity();
					CvCivilizationInfo& thisCiv = getCivilizationInfo();
					BuildingTypes eBuildingDestCity = (BuildingTypes)(thisCiv.getCivilizationBuildings(eBuildingClassDestCity));

					if (eBuildingDestCity != NO_BUILDING)
					{
						CvBuildingEntry* pBuildingInfo = GC.getBuildingInfo(eBuildingDestCity);
						if(pBuildingInfo)
						{
							if(pBuildingInfo->GetCorporationID() == GetCorporateFounderID())
							{
								eFreeBuilding = eBuildingDestCity;
								if((GC.getLogging() && GC.getAILogging()))
								{
									CvString strLogString;
									strLogString.Format("Found Corporate Building to seed to Freedom Function: %s", pBuildingInfo->GetText());
									GetHomelandAI()->LogHomelandMessage(strLogString);
								}
								break;
							}
						}
					}
				}
			}
		}
		CvCity* pBestCity = 0;
		int iBestScore = 0;
		CvCity* pCapital = getCapitalCity();
		for (int iLoopPlayer = 0; iLoopPlayer < MAX_CIV_PLAYERS; iLoopPlayer++)
		{
			PlayerTypes ePlayer = (PlayerTypes)iLoopPlayer;
			if(ePlayer != NO_PLAYER && GET_PLAYER(ePlayer).isAlive() && !GET_PLAYER(ePlayer).isBarbarian() && GET_PLAYER(ePlayer).GetID() != GetID())
			{
				CvCity* pLoopCity;
				int iLoop;
				for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))
				{
					if(pLoopCity != NULL)
					{
						if(!pLoopCity->IsFranchised(GetID()))
						{
							int iScore = GC.getGame().getJonRandNum(100, "Random Corp Spread");
							if(GetTrade()->IsConnectedToPlayer(pLoopCity->getOwner()))
							{
								iScore += GC.getGame().getJonRandNum(100, "Random Corp Spread");
							}
							if(pCapital != NULL)
							{
								//Prioritize closer cities first.
								int iDistance = plotDistance(pLoopCity->getX(), pLoopCity->getY(), pCapital->getX(), pCapital->getY());
								iScore -= (iDistance * 5);
							}
							if(iScore > iBestScore)
							{
								iBestScore = iScore;
								pBestCity = pLoopCity;
							}
						}
					}
				}
			}
		}
		if(pBestCity != NULL && iBestScore != 0 && eFreeBuilding != NO_BUILDING)
		{
			int iSpreadChance = GC.getGame().getJonRandNum((1500 + (GetCorporateFranchisesWorldwide() * 10)), "Random Corp Spread");
			if(iSpreadChance <= iBestScore)
			{
				if(pBestCity->GetCityBuildings()->GetNumBuilding(eFreeBuilding) <= 0)
				{
					CvBuildingEntry* pBuildingInfo = GC.getBuildingInfo(eFreeBuilding);
					if(pBuildingInfo)
					{
						pBestCity->GetCityBuildings()->SetNumRealBuilding(eFreeBuilding, 1);
						pBestCity->SetFranchised(GetID(), true);
						iFranchises++;
						// send notification to owner player and target player
						CvNotifications* pNotifications = GetNotifications();
						if(pNotifications && GetID() == GC.getGame().getActivePlayer())
						{
							Localization::String strSummary;
							Localization::String strMessage;

							strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_TRADE_UNIT_CORPORATION_BUILDING_FREEDOM_SUMMARY");
							strSummary << pBuildingInfo->GetTextKey();
							strSummary << pBestCity->getNameKey();
							strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_TRADE_UNIT_CORPORATION_BUILDING_FREEDOM");
							strMessage << pBestCity->getNameKey();
							strMessage << pBuildingInfo->GetTextKey();
							pNotifications->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), pBestCity->getX(), pBestCity->getY(), -1, -1);
						}
						else
						{
							CvNotifications* pNotifications2 = GET_PLAYER(pBestCity->getOwner()).GetNotifications();
							if(pNotifications2 && pBestCity->getOwner() == GC.getGame().getActivePlayer())
							{
								Localization::String strSummary;
								Localization::String strMessage;

								strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_TRADE_UNIT_CORPORATION_BUILDING_FOREIGN_FREEDOM_SUMMARY");
								strSummary << pBuildingInfo->GetTextKey();
								strSummary << pBestCity->getNameKey();
								strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_TRADE_UNIT_CORPORATION_BUILDING_FOREIGN_FREEDOM");
								strMessage << pBestCity->getNameKey();
								strMessage << pBuildingInfo->GetTextKey();
								strMessage << getCivilizationShortDescriptionKey();
								pNotifications2->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), pBestCity->getX(), pBestCity->getY(), -1, -1);
							}
						}
						CalculateCorporateFranchisesWorldwide();

						if(GC.getLogging() && GC.getAILogging())
						{
							CvString strLogString;
							strLogString.Format("Spread Corporate Building via Freedom Function. City: %s. Building: %s.", pBestCity->getName().c_str(), pBuildingInfo->GetText());
							GetHomelandAI()->LogHomelandMessage(strLogString);
						}
					}
				}
			}
		}
	}
}
//	--------------------------------------------------------------------------------
// Returns a string representing our current corporation benefit (if we have one) for the Corporation Overview
CvString CvPlayer::GetCurrentOfficeBenefit() const
{
	int iCorporationID = GetCorporateFounderID();
	if(iCorporationID <= 0)
		return "";

	CvString szOfficeBenefit = "";

	// Find Office building
	CvBuildingEntry* pkOfficeInfo = NULL;
	for(int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo((BuildingTypes) iI);
		if(pkBuildingInfo)
		{
			if(pkBuildingInfo->GetCorporationHQID() == 0 &&								// Not a headquarters
				pkBuildingInfo->GetCorporationID() == iCorporationID &&					// Part of our corporation
				pkBuildingInfo->GetFreeBuildingTradeTargetCity() != NO_BUILDINGCLASS)	// Not a franchise
			{
				pkOfficeInfo = pkBuildingInfo;
				break;
			}
		}
	}

	// No office assigned to this corporation (wth?)
	if(pkOfficeInfo == NULL)
		return "";

	// Calculate what our input into the corporation helper we need
	int iCurrentValue = 0;
	int iNumFranchises = GetCorporateFranchisesWorldwide();
	
	bool bFoundOne = false;

	// Note: only look for one number, if we find one, don't consider others.
	if(iNumFranchises > 0)
	{
		// Civilized Jewelers
		if(pkOfficeInfo->GetCorporationGPChange() > 0)
		{
			iCurrentValue = iNumFranchises * pkOfficeInfo->GetCorporationGPChange();
			bFoundOne = true;
		}

		if(!bFoundOne)
		{
			// Free Resource?
			for(int iI=0; iI < GC.getNumResourceInfos(); iI++)
			{
				ResourceTypes eResource = (ResourceTypes) iI;
				if(pkOfficeInfo->GetCorporationResourceQuantity(eResource) > 0)
				{
					iCurrentValue = iNumFranchises / pkOfficeInfo->GetCorporationResourceQuantity(eResource);
					bFoundOne = true;
					break;
				}
			}
		}

		if(!bFoundOne)
		{
			// Yield Change?
			for(int iI=0; iI < NUM_YIELD_TYPES; iI++)
			{
				YieldTypes eYield = (YieldTypes) iI;
				if(pkOfficeInfo->GetCorporationYieldChange(eYield) > 0)
				{
					iCurrentValue = iNumFranchises * pkOfficeInfo->GetCorporationYieldChange(eYield);
					bFoundOne = true;
					break;
				}
			}	
		}
	}

	szOfficeBenefit = GetLocalizedText(pkOfficeInfo->GetOfficeBenefitHelper(), iCurrentValue);

	return szOfficeBenefit;
}
//	--------------------------------------------------------------------------------
void CvPlayer::CalculateCorporateFranchisesWorldwide()
{
	int iFranchises = 0;
	int iMax = GetMaxFranchises();
	if(IsOrderCorp())
	{
		CvCity* pLoopCity;
		int iLoop;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity != NULL)
			{
				if(pLoopCity->HasOffice())
				{
					iFranchises++;
				}
			}
		}
		if(iFranchises > iMax)
		{
			iFranchises = iMax;
		}
	}
	else if(IsAutocracyCorp())
	{
		int iFranchiseDouble = 0;
		for (int iLoopPlayer = 0; iLoopPlayer < MAX_CIV_PLAYERS; iLoopPlayer++)
		{
			PlayerTypes ePlayer = (PlayerTypes)iLoopPlayer;
			if(ePlayer != NO_PLAYER && GET_PLAYER(ePlayer).isAlive() && !GET_PLAYER(ePlayer).isBarbarian() && GET_PLAYER(ePlayer).GetID() != GetID())
			{
				CvCity* pLoopCity;
				int iLoop;
				for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))
				{
					if(pLoopCity != NULL)
					{
						if(pLoopCity->IsFranchised(GetID()))
						{
							iFranchises++;

							if (GetCulture()->GetInfluenceLevel(ePlayer) >= INFLUENCE_LEVEL_POPULAR)
							{
								iFranchiseDouble++;
							}
						}
					}
				}
			}
		}
		if(iFranchises > iMax)
		{
			iFranchises = iMax;
		}
		iFranchises += iFranchiseDouble;
	}
	else if(IsFreedomCorp())
	{
		for (int iLoopPlayer = 0; iLoopPlayer < MAX_CIV_PLAYERS; iLoopPlayer++)
		{
			PlayerTypes ePlayer = (PlayerTypes)iLoopPlayer;
			if(ePlayer != NO_PLAYER && GET_PLAYER(ePlayer).isAlive() && !GET_PLAYER(ePlayer).isBarbarian() && GET_PLAYER(ePlayer).GetID() != GetID())
			{
				CvCity* pLoopCity;
				int iLoop;
				for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))
				{
					if(pLoopCity != NULL)
					{
						if(pLoopCity->IsFranchised(GetID()))
						{
							iFranchises++;
						}
					}
				}
			}
		}
		if(iFranchises > iMax)
		{
			iFranchises = iMax;
		}
	}
	else
	{
		for (int iLoopPlayer = 0; iLoopPlayer < MAX_CIV_PLAYERS; iLoopPlayer++)
		{
			PlayerTypes ePlayer = (PlayerTypes)iLoopPlayer;
			if(ePlayer != NO_PLAYER && GET_PLAYER(ePlayer).isAlive() && !GET_PLAYER(ePlayer).isBarbarian() && GET_PLAYER(ePlayer).GetID() != GetID())
			{
				CvCity* pLoopCity;
				int iLoop;
				for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))
				{
					if(pLoopCity != NULL)
					{
						if(pLoopCity->IsFranchised(GetID()))
						{
							iFranchises++;
						}
					}
				}
			}
		}
		if(iFranchises > iMax)
		{
			iFranchises = iMax;
		}
	}
	SetCorporateFranchisesWorldwide(iFranchises);
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetCorporateFranchisesWorldwide() const
{
	return m_iCorporateFranchises;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetCorporateFranchisesWorldwide(int iChange)
{
	m_iCorporateFranchises = iChange;
}
int CvPlayer::GetMaxFranchises()
{
	int iBase = GetTrade()->GetNumTradeRoutesPossible();
	iBase *= 2;
	int iMax = (iBase * GC.getMap().getWorldInfo().GetEstimatedNumCities());
	iMax /= 100;
	if(iMax > iBase)
	{
		iMax = iBase;
	}
	int iBonus = 0;
	if(GetCorporationMaxFranchises() > 0)
	{
		iBonus = (iMax * (100 + GetCorporationMaxFranchises()));
		iBonus /= 100;
		iBonus -= iMax;
		if(iBonus <= 0)
		{
			iBonus  = 1;
		}
	}
	iMax += iBonus;
	return iMax;
}
//	--------------------------------------------------------------------------------
bool CvPlayer::AreTradeRoutesInvulnerable() const
{
	return m_bTradeRoutesInvulnerable;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetTradeRoutesInvulnerable(bool bValue)
{
	m_bTradeRoutesInvulnerable = bValue;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeTRSpeedBoost(int iChange)
{
	m_iTRSpeedBoost += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetTRSpeedBoost(int iChange)
{
	m_iTRSpeedBoost = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetTRSpeedBoost() const
{
	return m_iTRSpeedBoost;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeVotesPerGPT(int iChange)
{
	m_iVotesPerGPT += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetVotesPerGPT() const
{
	return m_iVotesPerGPT;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeTRVisionBoost(int iChange)
{
	m_iTRVisionBoost += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetTRVisionBoost(int iChange)
{
	m_iTRVisionBoost = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetTRVisionBoost() const
{
	return m_iTRVisionBoost;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeBuildingMaintenanceMod(int iChange)
{
	m_iBuildingMaintenanceMod += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetBuildingMaintenanceMod(int iChange)
{
	m_iBuildingMaintenanceMod = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetBuildingMaintenanceMod() const
{
	return m_iBuildingMaintenanceMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeEventTourism(int iChange)
{
	m_iEventTourism += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetEventTourism(int iChange)
{
	m_iEventTourism = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetEventTourism() const
{
	return m_iEventTourism;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetGlobalTourismAlreadyReceived(MinorCivQuestTypes eQuest, int iValue)
{
	CvAssertMsg(eQuest >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eQuest < NUM_MINOR_CIV_QUEST_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	if(iValue != 0)
	{
		m_aiGlobalTourismAlreadyReceived.setAt(eQuest, iValue);
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::GlobalTourismAlreadyReceived(MinorCivQuestTypes eQuest) const
{
	CvAssertMsg(eQuest >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eQuest < NUM_MINOR_CIV_QUEST_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	return m_aiGlobalTourismAlreadyReceived[eQuest];
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeEventTourismCS(int iChange)
{
	m_iEventTourismCS += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetEventTourismCS(int iChange)
{
	m_iEventTourismCS = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetEventTourismCS() const
{
	return m_iEventTourismCS;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumHistoricEvents(int iChange)
{
	if(isMinorCiv())
	{
		return;
	}
	m_iNumHistoricEvent += iChange;
	int iValue = m_iNumHistoricEvent;
	if(GC.getLogging() && GC.getAILogging())
	{
		CvString strLogString;
		strLogString.Format("Historic Event completed. Total: %d.", iValue);
		GetHomelandAI()->LogHomelandMessage(strLogString);
	}
	CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			pLoopCity->GetCityCulture()->CalculateBaseTourismBeforeModifiers();
			pLoopCity->GetCityCulture()->CalculateBaseTourism();
		}
	}
	CvCity* pCapital = getCapitalCity();
	int iEventGP = GetPlayerTraits()->GetEventGP();
	if(pCapital != NULL && iEventGP > 0)
	{
		SpecialistTypes eBestSpecialist = NO_SPECIALIST;
		int iBestValue = 0;
		for(int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
		{
			const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iSpecialistLoop);
			CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
			if(pkSpecialistInfo)
			{
				// Does this Specialist spawn a GP?
				if(pkSpecialistInfo->getGreatPeopleUnitClass() != NO_UNITCLASS)
				{
					int iRandom = GC.getGame().getJonRandNum(100, "Random GP value");
					if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_WRITER"))
					{ 
						if(GetCulture()->GetNumAvailableGreatWorkSlots(CvTypes::getGREAT_WORK_SLOT_LITERATURE()) <= 0)
						{
							iRandom /= 2;
						}
					}
					else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_ARTIST"))
					{
						if(GetCulture()->GetNumAvailableGreatWorkSlots(CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT()) <= 0)
						{
							iRandom /= 2;
						}
					}
					else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_MUSICIAN"))
					{
						if(GetCulture()->GetNumAvailableGreatWorkSlots(CvTypes::getGREAT_WORK_SLOT_MUSIC()) <= 0)
						{
							iRandom /= 2;
						}
					}
					//Guarantee at least one.
					if(iRandom == 0)
					{
						iRandom = 1;
					}
					if(iRandom > iBestValue)
					{
						iBestValue = iRandom;
						eBestSpecialist = eSpecialist;
					}			
				}
			}
		}
		if(eBestSpecialist != NO_SPECIALIST)
		{
			CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eBestSpecialist);
			if(pkSpecialistInfo)
			{
				int iGPThreshold = pCapital->GetCityCitizens()->GetSpecialistUpgradeThreshold((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass());
				iGPThreshold *= 100;
				//Get % of threshold for test.
				iGPThreshold *= iEventGP;
				iGPThreshold /= 100;
				
				pCapital->GetCityCitizens()->ChangeSpecialistGreatPersonProgressTimes100(eBestSpecialist, iGPThreshold);
				if(GetID() == GC.getGame().getActivePlayer())
				{
					iGPThreshold /= 100;
					char text[256] = {0};
					float fDelay = 0.5f;
					sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_GREAT_PEOPLE]", iGPThreshold);
					DLLUI->AddPopupText(pCapital->getX(),pCapital->getY(), text, fDelay);
					CvNotifications* pNotification = GetNotifications();
					if(pNotification)
					{
						CvString strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS", iGPThreshold);
						CvString strSummary;
						// Class specific specialist message.
						if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_SCIENTIST"))
						{
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS_SCIENTIST", iGPThreshold);
						}
						else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_WRITER"))
						{ 
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS_WRITER", iGPThreshold);
						}
						else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_ARTIST"))
						{
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS_ARTIST", iGPThreshold);
						}
						else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_MUSICIAN"))
						{
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS_MUSICIAN", iGPThreshold);
						}
						else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_MERCHANT"))
						{
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS_MERCHANT", iGPThreshold);
						}
						else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_ENGINEER"))
						{
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS_ENGINEER", iGPThreshold);
						}
#if defined(MOD_DIPLOMACY_CITYSTATES)
						else if(MOD_DIPLOMACY_CITYSTATES && (UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_GREAT_DIPLOMAT"))
						{
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS_DIPLOMAT", iGPThreshold);
						}
#endif
						strSummary = GetLocalizedText("TXT_KEY_TOURISM_EVENT_SUMMARY_GP_BONUS");
						pNotification->Add(NOTIFICATION_GOLDEN_AGE_BEGUN_ACTIVE_PLAYER, strMessage, strSummary, -1, -1, -1);
					}
				}
			}
		}
	}
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetNumHistoricEvents(int iChange)
{
	m_iNumHistoricEvent = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetNumHistoricEvents() const
{
	return m_iNumHistoricEvent;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeSingleVotes(int iChange)
{
	m_iSingleVotes += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetSingleVotes(int iChange)
{
	m_iSingleVotes = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetSingleVotes() const
{
	return m_iSingleVotes;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMonopolyModFlat(int iChange)
{
	m_iMonopolyModFlat += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetMonopolyModFlat(int iChange)
{
	m_iMonopolyModFlat = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetMonopolyModFlat() const
{
	return m_iMonopolyModFlat;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMonopolyModPercent(int iChange)
{
	m_iMonopolyModPercent += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetMonopolyModPercent(int iChange)
{
	m_iMonopolyModPercent = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetMonopolyModPercent() const
{
	return m_iMonopolyModPercent;
}

/// What are we willing to give/receive for peace with the active human player?
int CvPlayer::GetCachedValueOfPeaceWithHuman()
{
	return m_iCachedValueOfPeaceWithHuman;
}

/// Sets what are we willing to give/receive for peace with the active human player
void CvPlayer::SetCachedValueOfPeaceWithHuman(int iValue)
{
	m_iCachedValueOfPeaceWithHuman = iValue;
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::GetAbleToAnnexCityStatesCount() const
{
	return m_iAbleToAnnexCityStatesCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeAbleToAnnexCityStatesCount(int iChange)
{
	m_iAbleToAnnexCityStatesCount += iChange;
}
#if defined(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS)
//	--------------------------------------------------------------------------------
int CvPlayer::GetPovertyUnhappinessMod() const
{
	return m_iPovertyUnhappinessMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangePovertyUnhappinessMod(int iChange)
{
	m_iPovertyUnhappinessMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetDefenseUnhappinessMod() const
{
	return m_iDefenseUnhappinessMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeDefenseUnhappinessMod(int iChange)
{
	m_iDefenseUnhappinessMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetUnculturedUnhappinessMod() const
{
	return m_iUnculturedUnhappinessMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeUnculturedUnhappinessMod(int iChange)
{
	m_iUnculturedUnhappinessMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetIlliteracyUnhappinessMod() const
{
	return m_iIlliteracyUnhappinessMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeIlliteracyUnhappinessMod(int iChange)
{
	m_iIlliteracyUnhappinessMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetMinorityUnhappinessMod() const
{
	return m_iMinorityUnhappinessMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMinorityUnhappinessMod(int iChange)
{
	m_iMinorityUnhappinessMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetPovertyUnhappinessModCapital() const
{
	return m_iPovertyUnhappinessModCapital;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangePovertyUnhappinessModCapital(int iChange)
{
	m_iPovertyUnhappinessModCapital += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetDefenseUnhappinessModCapital() const
{
	return m_iDefenseUnhappinessModCapital;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeDefenseUnhappinessModCapital(int iChange)
{
	m_iDefenseUnhappinessModCapital += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetUnculturedUnhappinessModCapital() const
{
	return m_iUnculturedUnhappinessModCapital;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeUnculturedUnhappinessModCapital(int iChange)
{
	m_iUnculturedUnhappinessModCapital += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetIlliteracyUnhappinessModCapital() const
{
	return m_iIlliteracyUnhappinessModCapital;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeIlliteracyUnhappinessModCapital(int iChange)
{
	m_iIlliteracyUnhappinessModCapital += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetMinorityUnhappinessModCapital() const
{
	return m_iMinorityUnhappinessModCapital;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMinorityUnhappinessModCapital(int iChange)
{
	m_iMinorityUnhappinessModCapital += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetCapitalUnhappinessModCBP() const
{
	return m_iCapitalUnhappinessModCBP;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeCapitalUnhappinessModCBP(int iChange)
{
	m_iCapitalUnhappinessModCBP += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetPuppetUnhappinessMod() const
{
	return m_iPuppetUnhappinessMod;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangePuppetUnhappinessMod(int iChange)
{
	m_iPuppetUnhappinessMod += iChange;
}
// Specialists
//	--------------------------------------------------------------------------------
int CvPlayer::GetNoUnhappfromXSpecialists() const
{
	return m_iNoUnhappfromXSpecialists;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNoUnhappfromXSpecialists(int iChange)
{
	m_iNoUnhappfromXSpecialists += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetNoUnhappfromXSpecialistsCapital() const
{
	return m_iNoUnhappfromXSpecialistsCapital;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNoUnhappfromXSpecialistsCapital(int iChange)
{
	m_iNoUnhappfromXSpecialistsCapital += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetWarWearinessModifier() const
{
	return m_iWarWearinessModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeWarWearinessModifier(int iChange)
{
	m_iWarWearinessModifier += iChange;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getCultureBombTimer() const
{
	return m_iCultureBombTimer;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setCultureBombTimer(int iNewValue)
{
	if(getCultureBombTimer() != iNewValue)
	{
		m_iCultureBombTimer = iNewValue;
		CvAssert(getCultureBombTimer() >= 0);
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeCultureBombTimer(int iChange)
{
	setCultureBombTimer(getCultureBombTimer() + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getConversionTimer() const
{
	return m_iConversionTimer;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setConversionTimer(int iNewValue)
{
	if(getConversionTimer() != iNewValue)
	{
		m_iConversionTimer = iNewValue;
		CvAssert(getConversionTimer() >= 0);

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(MiscButtons_DIRTY_BIT, true);
		}
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeConversionTimer(int iChange)
{
	setConversionTimer(getConversionTimer() + iChange);
}

//	--------------------------------------------------------------------------------
CvCity* CvPlayer::getCapitalCity()
{
	return getCity(m_iCapitalCityID);
}

//	--------------------------------------------------------------------------------
const CvCity* CvPlayer::getCapitalCity() const
{
	return getCity(m_iCapitalCityID);
}

//	--------------------------------------------------------------------------------
void CvPlayer::setCapitalCity(CvCity* pNewCapitalCity)
{
	CvCity* pOldCapitalCity;

	pOldCapitalCity = getCapitalCity();

	if(pOldCapitalCity != pNewCapitalCity)
	{
		if(pNewCapitalCity != NULL)
		{
			// Need to set our original capital x,y?
			if(GetOriginalCapitalX() == -1 || GetOriginalCapitalY() == -1)
			{
				m_iOriginalCapitalX = pNewCapitalCity->getX();
				m_iOriginalCapitalY = pNewCapitalCity->getY();
			}

			m_iCapitalCityID = pNewCapitalCity->GetID();

			pNewCapitalCity->SetEverCapital(true);
		}
		else
		{
			m_iCapitalCityID = -1;
		}
	}
}

//	--------------------------------------------------------------------------------
/// Where was our original capital located?
int CvPlayer::GetOriginalCapitalX() const
{
	return m_iOriginalCapitalX;
}

//	--------------------------------------------------------------------------------
/// Where was our original capital located?
int CvPlayer::GetOriginalCapitalY() const
{
	return m_iOriginalCapitalY;
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
void CvPlayer::setOriginalCapitalXY(CvCity* pCapitalCity)
{
	if(pCapitalCity != NULL)
	{
		m_iOriginalCapitalX = pCapitalCity->getX();
		m_iOriginalCapitalY = pCapitalCity->getY();
	}
}
#endif
//	--------------------------------------------------------------------------------
/// Have we lost our capital in war?
bool CvPlayer::IsHasLostCapital() const
{
	return m_bLostCapital;
}

//	--------------------------------------------------------------------------------
/// Sets us to having lost our capital in war
void CvPlayer::SetHasLostCapital(bool bValue, PlayerTypes eConqueror)
{
	if(bValue != m_bLostCapital)
	{
		m_bLostCapital = bValue;
		m_eConqueror = eConqueror;

		// Don't really care if a City State lost its capital
		if(!isMinorCiv())
		{
			int iMostOriginalCapitals = 0;
			TeamTypes eWinningTeam = NO_TEAM;
			PlayerTypes eWinningPlayer = NO_PLAYER;

			{
				// Calculate who owns the most original capitals by iterating through all civs 
				// and finding out who owns their original capital.
				typedef std::tr1::array<int, MAX_CIV_TEAMS> CivTeamArray;
				CivTeamArray aTeamCityCount;
				aTeamCityCount.assign(0);

				CvMap& kMap = GC.getMap();
				for (int iLoopPlayer = 0; iLoopPlayer < MAX_MAJOR_CIVS; ++iLoopPlayer)
				{
					const PlayerTypes ePlayer = static_cast<PlayerTypes>(iLoopPlayer);
					CvPlayer& kLoopPlayer = GET_PLAYER(ePlayer);
					if(kLoopPlayer.isEverAlive())
					{
						const int iOriginalCapitalX = kLoopPlayer.GetOriginalCapitalX();
						const int iOriginalCapitalY = kLoopPlayer.GetOriginalCapitalY();
						if(iOriginalCapitalX != -1 && iOriginalCapitalY != -1)
						{
							CvPlot* pkPlot = kMap.plot(iOriginalCapitalX, iOriginalCapitalY);
							if(pkPlot != NULL)
							{
								CvCity* pkCapitalCity = pkPlot->getPlotCity();
								if(pkCapitalCity != NULL)
								{
									const PlayerTypes eCapitalOwner = pkCapitalCity->getOwner();
									if(eCapitalOwner != NO_PLAYER)
									{
										CvPlayer& kCapitalOwnerPlayer = GET_PLAYER(eCapitalOwner);
										aTeamCityCount[kCapitalOwnerPlayer.getTeam()]++;
									}
								}
							}	
						}
					}
				}

				// What's the max count and are they the only team to have the max?
				CivTeamArray::iterator itMax = max_element(aTeamCityCount.begin(), aTeamCityCount.end());
				if(count(aTeamCityCount.begin(), aTeamCityCount.end(), *itMax) == 1)
				{
					eWinningTeam = static_cast<TeamTypes>(itMax - aTeamCityCount.begin());
					iMostOriginalCapitals = *itMax;

					CvTeam& kTeam = GET_TEAM(eWinningTeam);
					eWinningPlayer = kTeam.getLeaderID();
				}			
			}

			// Someone just lost their capital, test to see if someone wins
			if(bValue)
			{
				// slewis - Moved Conquest victory elsewhere so that victory is more accurately awarded
				//GC.getGame().DoTestConquestVictory();

				Localization::String localizedBuffer;
				Localization::String localizedSummary;
				NotificationTypes eNotificationType = NOTIFICATION_CAPITAL_LOST;

				for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
				{
					PlayerTypes ePlayer = (PlayerTypes)ui;
					CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();
					if(!pNotifications)
					{
						continue;
					}

					// Notify Player lost their capital
					if(ePlayer == GetID())
					{
						eNotificationType = NOTIFICATION_CAPITAL_LOST_ACTIVE_PLAYER;
						localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_YOU_LOST_CAPITAL");
						if (eWinningPlayer == ePlayer)
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_LOST_CAPITAL_YOU_WINNING");
							localizedBuffer << iMostOriginalCapitals;
						}
						else if (eWinningTeam != NO_TEAM)
						{
							if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(eWinningTeam))
							{
								if (eWinningPlayer != NO_PLAYER) // there is a winning player
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_LOST_CAPITAL_OTHER_PLAYER_WINNING");
									if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
									}
									else
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
									}
									localizedBuffer << iMostOriginalCapitals;
								}
								else
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_LOST_CAPITAL_TEAM_WINNING");
									localizedBuffer << (int)eWinningTeam;
									localizedBuffer << iMostOriginalCapitals;
								}
							}
							else // if someone is winning
							{
								localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_LOST_CAPITAL_UNMET_WINNING");
								localizedBuffer << iMostOriginalCapitals;
							}
						}
						else // if no one is winning
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_LOST_CAPITAL");
						}
					}
					// Known player
					else if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(getTeam()))
					{
						eNotificationType = NOTIFICATION_CAPITAL_LOST;
						localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_PLAYER_LOST_CAPITAL");
						localizedSummary << getCivilizationShortDescriptionKey();

						if (eWinningTeam != NO_TEAM)
						{
							if (GET_TEAM(eWinningTeam).isHasMet(getTeam()))
							{
								if (eWinningPlayer == GetID())
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL_YOU_WINNING");

									if (GC.getGame().isGameMultiPlayer() && isHuman())
									{
										localizedBuffer << getNickName();
									}
									else
									{
										localizedBuffer << getNameKey();
									}
									localizedBuffer << iMostOriginalCapitals;
								}
								else if (eWinningPlayer != NO_PLAYER)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL_OTHER_WINNING");
									if (GC.getGame().isGameMultiPlayer() && isHuman())
									{
										localizedBuffer << getNickName();
									}
									else
									{
										localizedBuffer << getNameKey();
									}

									if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
									}
									else
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
									}
									localizedBuffer << iMostOriginalCapitals;
								}
								else // if (eWinningTeam != NO_TEAM)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL_TEAM_WINNING");
									if (GC.getGame().isGameMultiPlayer() && isHuman())
									{
										localizedBuffer << getNickName();
									}
									else
									{
										localizedBuffer << getNameKey();
									}

									localizedBuffer << (int)eWinningTeam;
									localizedBuffer << iMostOriginalCapitals;
								}
							}
							else
							{
								localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL_UNMET_WINNING");
								if (GC.getGame().isGameMultiPlayer() && isHuman())
								{
									localizedBuffer << getNickName();
								}
								else
								{
									localizedBuffer << getNameKey();
								}
								localizedBuffer << iMostOriginalCapitals;
							}
						}
						else
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL");
							if (GC.getGame().isGameMultiPlayer() && isHuman())
							{
								localizedBuffer << getNickName();
							}
							else
							{
								localizedBuffer << getNameKey();
							}
						}
					}
					else // unmet player
					{
						eNotificationType = NOTIFICATION_CAPITAL_LOST;
						localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_SOMEONE_LOST_CAPITAL");

						if (eWinningTeam != NO_TEAM)
						{
							if (GET_TEAM(eWinningTeam).isHasMet(getTeam()))
							{
								if (eWinningPlayer == GetID())
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_LOST_CAPITAL_YOU_WINNING");
									localizedBuffer << iMostOriginalCapitals;
								}
								else if (eWinningPlayer != NO_PLAYER)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_LOST_CAPITAL_OTHER_WINNING");
									if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
									}
									else
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
									}
									localizedBuffer << iMostOriginalCapitals;
								}
								else // if (eWinningTeam != NO_TEAM)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_LOST_CAPITAL_TEAM_WINNING");
									localizedBuffer << (int)eWinningTeam;
									localizedBuffer << iMostOriginalCapitals;
								}
							}
							else
							{
								localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_LOST_CAPITAL_UNMET_WINNING");
								localizedBuffer << iMostOriginalCapitals;
							}
						}
						else
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_LOST_CAPITAL");
						}
					}

					pNotifications->Add(eNotificationType, localizedBuffer.toUTF8(), localizedSummary.toUTF8(), -1, -1, -1);
				}

				//replay message
				{
					Localization::String message;
					if (eWinningPlayer != NO_PLAYER)
					{
						message = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL_OTHER_WINNING");
						if (GC.getGame().isGameMultiPlayer() && isHuman())
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNickName();
#else
							localizedBuffer << getNickName();
#endif
						}
						else
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNameKey();
#else
							localizedBuffer << getNameKey();
#endif
						}

						if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
						{
#if defined(MOD_BUGFIX_MINOR)
							message << GET_PLAYER(eWinningPlayer).getNickName();
#else
							localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
#endif
						}
						else
						{
#if defined(MOD_BUGFIX_MINOR)
							message << GET_PLAYER(eWinningPlayer).getNameKey();
#else
							localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
#endif
						}

#if defined(MOD_BUGFIX_MINOR)
						message << iMostOriginalCapitals;
#else
						localizedBuffer << iMostOriginalCapitals;
#endif
					}
					else if (eWinningTeam != NO_TEAM)
					{
						message = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL_TEAM_WINNING");
						if (GC.getGame().isGameMultiPlayer() && isHuman())
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNickName();
#else
							localizedBuffer << getNickName();
#endif
						}
						else
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNameKey();
#else
							localizedBuffer << getNameKey();
#endif
						}

#if defined(MOD_BUGFIX_MINOR)
						message << (int)eWinningTeam;
						message << iMostOriginalCapitals;
#else
						localizedBuffer << (int)eWinningTeam;
						localizedBuffer << iMostOriginalCapitals;
#endif
					}
					else
					{
						message = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL");
						if (GC.getGame().isGameMultiPlayer() && isHuman())
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNickName();
#else
							localizedBuffer << getNickName();
#endif
						}
						else
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNameKey();
#else
							localizedBuffer << getNameKey();
#endif
						}
					}

					CvString translatedMessage = message.toUTF8();
					GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, GetID(), translatedMessage, GetOriginalCapitalX(), GetOriginalCapitalY());
				}					
			}
			// Player recovered capital!
			else
			{
				Localization::String localizedBuffer;
				Localization::String localizedSummary;

				for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
				{
					PlayerTypes ePlayer = (PlayerTypes)ui;
					CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();
					if(!pNotifications)
					{
						continue;
					}

					// Notify Player lost their capital
					if(ePlayer == GetID())
					{
						localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_RECOVERED_CAPITAL");
						if (eWinningPlayer == ePlayer)
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_REGAINED_CAPITAL_YOU_WINNING");
							localizedBuffer << iMostOriginalCapitals;
						}
						else if (GET_TEAM(getTeam()).isHasMet(eWinningTeam))
						{
							if (eWinningPlayer != NO_PLAYER) // there is a winning player
							{
								localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_REGAINED_CAPITAL_OTHER_PLAYER_WINNING");
								if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
								{
									localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
								}
								else
								{
									localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
								}
								localizedBuffer << iMostOriginalCapitals;
							}
							else
							{
								localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_REGAINED_CAPITAL_TEAM_WINNING");
								localizedBuffer << (int)eWinningTeam;
								localizedBuffer << iMostOriginalCapitals;
							}
						}
						else if (eWinningTeam != NO_TEAM) // if someone is winning
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_REGAINED_CAPITAL_UNMET_WINNING");
							localizedBuffer << iMostOriginalCapitals;
						}
						else // if no one is winning
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_RECOVERED_CAPITAL");
						}
					}
					// Known player
					else if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(getTeam()))
					{
						localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_PLAYER_RECOVERED_CAPITAL");
						localizedSummary << getCivilizationShortDescriptionKey();

						if (eWinningTeam != NO_TEAM)
						{
							if (GET_TEAM(eWinningTeam).isHasMet(getTeam()))
							{
								if (eWinningPlayer == ePlayer)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL_YOU_WINNING");
									localizedBuffer << iMostOriginalCapitals;
								}
								else if (eWinningPlayer != NO_PLAYER)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL_OTHER_WINNING");
									if (GC.getGame().isGameMultiPlayer() && isHuman())
									{
										localizedBuffer << getNickName();
									}
									else
									{
										localizedBuffer << getNameKey();
									}

									if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
									}
									else
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
									}
									localizedBuffer << iMostOriginalCapitals;
								}
								else // if (eWinningTeam != NO_TEAM)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL_TEAM_WINNING");
									if (GC.getGame().isGameMultiPlayer() && isHuman())
									{
										localizedBuffer << getNickName();
									}
									else
									{
										localizedBuffer << getNameKey();
									}

									localizedBuffer << (int)eWinningTeam;
									localizedBuffer << iMostOriginalCapitals;
								}
							}
							else
							{
								localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL_UNMET_WINNING");
								if (GC.getGame().isGameMultiPlayer() && isHuman())
								{
									localizedBuffer << getNickName();
								}
								else
								{
									localizedBuffer << getNameKey();
								}
								localizedBuffer << iMostOriginalCapitals;
							}
						}
						else
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL");
							if (GC.getGame().isGameMultiPlayer() && isHuman())
							{
								localizedBuffer << getNickName();
							}
							else
							{
								localizedBuffer << getNameKey();
							}
						}
					}
					else // unmet player
					{
						localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_SOMEONE_RECOVERED_CAPITAL");

						if (eWinningTeam != NO_TEAM)
						{
							if (GET_TEAM(eWinningTeam).isHasMet(getTeam()))
							{
								if (eWinningPlayer == ePlayer)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_REGAINED_CAPITAL_YOU_WINNING");
									localizedBuffer << iMostOriginalCapitals;
								}
								else if (eWinningPlayer != NO_PLAYER)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_REGAINED_CAPITAL_OTHER_WINNING");
									if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
									}
									else
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
									}
									localizedBuffer << iMostOriginalCapitals;
								}
								else // if (eWinningTeam != NO_TEAM)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_REGAINED_CAPITAL_TEAM_WINNING");
									localizedBuffer << (int)eWinningTeam;
									localizedBuffer << iMostOriginalCapitals;
								}
							}
							else
							{
								localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_REGAINED_CAPITAL_UNMET_WINNING");
								localizedBuffer << iMostOriginalCapitals;
							}
						}
						else
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_REGAINED_CAPITAL");
						}
					}

					pNotifications->Add(NOTIFICATION_CAPITAL_RECOVERED, localizedBuffer.toUTF8(), localizedSummary.toUTF8(), -1, -1, -1);
				}

				//replay message
				{
					Localization::String message;
					if (eWinningPlayer != NO_PLAYER)
					{
						message = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL_OTHER_WINNING");
						if (GC.getGame().isGameMultiPlayer() && isHuman())
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNickName();
#else
							localizedBuffer << getNickName();
#endif
						}
						else
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNameKey();
#else
							localizedBuffer << getNameKey();
#endif
						}

						if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
						{
#if defined(MOD_BUGFIX_MINOR)
							message << GET_PLAYER(eWinningPlayer).getNickName();
#else
							localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
#endif
						}
						else
						{
#if defined(MOD_BUGFIX_MINOR)
							message << GET_PLAYER(eWinningPlayer).getNameKey();
#else
							localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
#endif
						}

#if defined(MOD_BUGFIX_MINOR)
						message << iMostOriginalCapitals;
#else
						localizedBuffer << iMostOriginalCapitals;
#endif
					}
					else if (eWinningTeam != NO_TEAM)
					{
						message = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL_TEAM_WINNING");
						if (GC.getGame().isGameMultiPlayer() && isHuman())
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNickName();
#else
							localizedBuffer << getNickName();
#endif
						}
						else
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNameKey();
#else
							localizedBuffer << getNameKey();
#endif
						}

#if defined(MOD_BUGFIX_MINOR)
						message << (int)eWinningTeam;
						message << iMostOriginalCapitals;
#else
						localizedBuffer << (int)eWinningTeam;
						localizedBuffer << iMostOriginalCapitals;
#endif
					}
					else
					{
						message = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL");
						if (GC.getGame().isGameMultiPlayer() && isHuman())
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNickName();
#else
							localizedBuffer << getNickName();
#endif
						}
						else
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNameKey();
#else
							localizedBuffer << getNameKey();
#endif
						}
					}

					CvString translatedMessage = message.toUTF8();
					GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, GetID(), translatedMessage, GetOriginalCapitalX(), GetOriginalCapitalY());
				}					
			}
		}
	}
}


//	--------------------------------------------------------------------------------
/// Player who first captured our capital
PlayerTypes CvPlayer::GetCapitalConqueror() const
{
	return m_eConqueror;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getCitiesLost() const
{
	return m_iCitiesLost;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeCitiesLost(int iChange)
{
	m_iCitiesLost = (m_iCitiesLost + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getPower() const
{
	if(m_iTurnMightRecomputed < GC.getGame().getElapsedGameTurns())
	{
		// more lazy evaluation
		const_cast<CvPlayer*>(this)->m_iTurnMightRecomputed = GC.getGame().getElapsedGameTurns();
		const_cast<CvPlayer*>(this)->m_iMilitaryMight = calculateMilitaryMight();
		const_cast<CvPlayer*>(this)->m_iEconomicMight = calculateEconomicMight();
	}
	return m_iMilitaryMight + m_iEconomicMight;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetMilitaryMight() const
{
	if(m_iTurnMightRecomputed < GC.getGame().getElapsedGameTurns())
	{
		// more lazy evaluation
		const_cast<CvPlayer*>(this)->m_iTurnMightRecomputed = GC.getGame().getElapsedGameTurns();
		const_cast<CvPlayer*>(this)->m_iMilitaryMight = calculateMilitaryMight();
		const_cast<CvPlayer*>(this)->m_iEconomicMight = calculateEconomicMight();
	}
	return m_iMilitaryMight;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetEconomicMight() const
{
	if(m_iTurnMightRecomputed < GC.getGame().getElapsedGameTurns())
	{
		// more lazy evaluation
		const_cast<CvPlayer*>(this)->m_iTurnMightRecomputed = GC.getGame().getElapsedGameTurns();
		const_cast<CvPlayer*>(this)->m_iMilitaryMight = calculateMilitaryMight();
		const_cast<CvPlayer*>(this)->m_iEconomicMight = calculateEconomicMight();
	}
	return m_iEconomicMight;
}

//	--------------------------------------------------------------------------------
int CvPlayer::calculateMilitaryMight() const
{
	int rtnValue = 0;
	const CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		// Current combat strength or bombard strength, whichever is higher
		int iPower =  pLoopUnit->GetPower();
#if !defined(MOD_BALANCE_CORE)
		if (pLoopUnit->getDomainType() == DOMAIN_SEA)
		{
			iPower /= 2;
		}
#endif
		rtnValue += iPower;
	}

#if defined(MOD_BALANCE_CORE_MILITARY)
	if(MOD_BALANCE_CORE_MILITARY && GetAttackBonusTurns() > 3)
	{
		rtnValue = (rtnValue*(100+GC.getPOLICY_ATTACK_BONUS_MOD()))/100;
	}

	//Finally, divide our power by the number of cities we own - the more we have, the less we can defend.
	return int( rtnValue / max(1.f, sqrt((float)(getNumCities() / 3))));
#else

	//Simplistic increase based on player's gold
	//500 gold will increase might by 22%, 2000 by 45%, 8000 gold by 90%
	float fGoldMultiplier = 1.0f + (sqrt((float)GetTreasury()->GetGold()) / 100.0f);
	if(fGoldMultiplier > 2.0f) fGoldMultiplier = 2.0f;
	rtnValue = (int)(rtnValue * fGoldMultiplier);
	return rtnValue;
#endif
}


//	--------------------------------------------------------------------------------
int CvPlayer::calculateEconomicMight() const
{
	int iEconomicMight = 5;
	iEconomicMight += getTotalPopulation();
	iEconomicMight += calculateTotalYield(YIELD_FOOD);
	iEconomicMight += calculateTotalYield(YIELD_PRODUCTION);
	iEconomicMight += calculateTotalYield(YIELD_SCIENCE);
	iEconomicMight += calculateTotalYield(YIELD_GOLD);
	if(IsEmpireUnhappy())
	{
		iEconomicMight += GetExcessHappiness() * 10;
	}

	//Finally, divide our power by the number of cities we own - the more we have, the more our upkeep.
	return int( iEconomicMight / max(1.f, sqrt((float)(getNumCities() / 2))));
}

//	--------------------------------------------------------------------------------
int CvPlayer::calculateProductionMight() const
{
	int iMight = 0;

	const CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iMight += pLoopCity->getRawProductionDifference(/*bIgnoreFood*/ true, /*bOverflow*/ false);
	}

	return iMight;
}

#if defined(MOD_UNITS_XP_TIMES_100)
int CvPlayer::getCombatExperienceTimes100() const
#else
int CvPlayer::getCombatExperience() const
#endif
{
#if defined(MOD_UNITS_XP_TIMES_100)
	return m_iCombatExperienceTimes100;
#else
	return m_iCombatExperience;
#endif
}

//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
#if defined(MOD_UNITS_XP_TIMES_100)
void CvPlayer::setCombatExperienceTimes100(int iExperienceTimes100, CvUnit* pFromUnit)
#else
void CvPlayer::setCombatExperience(int iExperience, CvUnit* pFromUnit)
#endif
#else
#if defined(MOD_UNITS_XP_TIMES_100)
void CvPlayer::setCombatExperienceTimes100(int iExperienceTimes100)
#else
void CvPlayer::setCombatExperience(int iExperience)
#endif
#endif
{

#if defined(MOD_UNITS_XP_TIMES_100)
	CvAssert(iExperienceTimes100 >= 0);
	
	if (iExperienceTimes100 != getCombatExperienceTimes100())
#else
	CvAssert(iExperience >= 0);
	
	if (iExperience != getCombatExperience())
#endif
	{
#if defined(MOD_UNITS_XP_TIMES_100)
		m_iCombatExperienceTimes100 = iExperienceTimes100;
#else
		m_iCombatExperience = iExperience;
#endif

		// Enough XP for a Great General to appear?
		if(!isBarbarian())
		{
#if defined(MOD_UNITS_XP_TIMES_100)
			int iExperienceThresholdTimes100 = greatGeneralThreshold() * 100;
			if (m_iCombatExperienceTimes100 >= iExperienceThresholdTimes100 && iExperienceThresholdTimes100 > 0)
#else
			int iExperienceThreshold = greatGeneralThreshold();
			if (m_iCombatExperience >= iExperienceThreshold && iExperienceThreshold > 0)
#endif
			{
				// create great person
				CvCity* pBestCity = NULL;
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
				if(pFromUnit == NULL)
				{
#endif
					int iBestValue = INT_MAX;
					int iLoop;
					for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						int iValue = 4 * GC.getGame().getJonRandNum(getNumCities(), "Great General City Selection");

						for(int i = 0; i < NUM_YIELD_TYPES; i++)
						{
							iValue += pLoopCity->findYieldRateRank((YieldTypes)i);
						}
						iValue += pLoopCity->findPopulationRank();

						if(iValue < iBestValue)
						{
							pBestCity = pLoopCity;
							iBestValue = iValue;
						}
					}
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
				}
#endif

#if defined(MOD_GLOBAL_LOCAL_GENERALS)
				if(pBestCity || pFromUnit)
#else
				if(pBestCity)
#endif
				{
					// Figure out which Promotion is the one which makes a unit a Great General
					PromotionTypes eGreatGeneralPromotion = NO_PROMOTION;
					for(int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
					{
						const PromotionTypes eLoopPromotion = static_cast<PromotionTypes>(iI);
						CvPromotionEntry* pkPromotionInfo = GC.getPromotionInfo(eLoopPromotion);
						if(pkPromotionInfo)
						{
							if(pkPromotionInfo->IsGreatGeneral())
							{
								eGreatGeneralPromotion = eLoopPromotion;
								break;
							}
						}
					}

					// If GG promotion exists, find a unit which gets it for free (i.e. the Great General unit itself)
					if(eGreatGeneralPromotion != NO_PROMOTION)
					{
						for(int iI = 0; iI < GC.getNumUnitInfos(); iI++)
						{
							const UnitTypes eLoopUnit = static_cast<UnitTypes>(iI);
							CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eLoopUnit);
							if(pkUnitInfo)
							{
								if(pkUnitInfo->GetFreePromotions(eGreatGeneralPromotion))
								{
									// Is this the right unit of this class for this civ?
									const UnitTypes eUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits((UnitClassTypes)pkUnitInfo->GetUnitClassType());

									if(eUnit == eLoopUnit)
									{
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
										if(pFromUnit)
										{
											CUSTOMLOG("Create Great General at (%d, %d) from unit %s", pFromUnit->plot()->getX(), pFromUnit->plot()->getY(), pFromUnit->getName().GetCString());
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
											createGreatGeneral(eUnit, pFromUnit->plot()->getX(), pFromUnit->plot()->getY(), false);
#else
											createGreatGeneral(eUnit, pFromUnit->plot()->getX(), pFromUnit->plot()->getY());
#endif
										}
										else
										{
#endif
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
											pBestCity->createGreatGeneral(eUnit, false);
#else
											pBestCity->createGreatGeneral(eUnit);
#endif
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
										}
#endif
#if defined(MOD_UNITS_XP_TIMES_100)
										setCombatExperienceTimes100(getCombatExperienceTimes100() - iExperienceThresholdTimes100);
#else
										setCombatExperience(getCombatExperience() - iExperienceThreshold);
#endif
										break;
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
#if defined(MOD_UNITS_XP_TIMES_100)
void CvPlayer::changeCombatExperienceTimes100(int iChangeTimes100, CvUnit* pFromUnit)
#else
void CvPlayer::changeCombatExperience(int iChange, CvUnit* pFromUnit)
#endif
#else
#if defined(MOD_UNITS_XP_TIMES_100)
void CvPlayer::changeCombatExperienceTimes100(int iChangeTimes100)
#else
void CvPlayer::changeCombatExperience(int iChange)
#endif
#endif
{
#if defined(MOD_UNITS_XP_TIMES_100)
	if (!MOD_UNITS_XP_TIMES_100) {
		// If NOT using XP times 100, remove any fractional part
		iChangeTimes100 -= (iChangeTimes100 % 100);
	}
	if (getCombatExperienceTimes100() + iChangeTimes100 < 0)
#else
	if (getCombatExperience() + iChange < 0)
#endif
	{
#if defined(MOD_UNITS_XP_TIMES_100)
		setCombatExperienceTimes100(0);
#else
		setCombatExperience(0);
#endif
	}
	else
	{
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
#if defined(MOD_UNITS_XP_TIMES_100)
		setCombatExperienceTimes100(getCombatExperienceTimes100() + iChangeTimes100, pFromUnit);
#else
		setCombatExperience(getCombatExperience() + iChange, pFromUnit);
#endif
#else
#if defined(MOD_UNITS_XP_TIMES_100)
		setCombatExperienceTimes100(getCombatExperienceTimes100() + iChangeTimes100);
#else
		setCombatExperience(getCombatExperience() + iChange);
#endif
#endif
	}

#if defined(MOD_UNITS_XP_TIMES_100)
	m_iLifetimeCombatExperienceTimes100 += iChangeTimes100;
#else
	m_iLifetimeCombatExperience += iChange;
#endif
}

//	--------------------------------------------------------------------------------
#if defined(MOD_UNITS_XP_TIMES_100)
int CvPlayer::getNavalCombatExperienceTimes100() const
#else
int CvPlayer::getNavalCombatExperience() const
#endif
{
#if defined(MOD_UNITS_XP_TIMES_100)
	return m_iNavalCombatExperienceTimes100;
#else
	return m_iNavalCombatExperience;
#endif
}

//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
#if defined(MOD_UNITS_XP_TIMES_100)
void CvPlayer::setNavalCombatExperienceTimes100(int iExperienceTimes100, CvUnit* pFromUnit)
#else
void CvPlayer::setNavalCombatExperience(int iExperience, CvUnit* pFromUnit)
#endif
#else
#if defined(MOD_UNITS_XP_TIMES_100)
void CvPlayer::setNavalCombatExperienceTimes100(int iExperienceTimes100)
#else
void CvPlayer::setNavalCombatExperience(int iExperience)
#endif
#endif
{
#if defined(MOD_UNITS_XP_TIMES_100)
	CvAssert(iExperienceTimes100 >= 0);

	if (iExperienceTimes100 != getNavalCombatExperienceTimes100())
#else
	CvAssert(iExperience >= 0);

	if (iExperience != getNavalCombatExperience())
#endif
	{
#if defined(MOD_UNITS_XP_TIMES_100)
		m_iNavalCombatExperienceTimes100 = iExperienceTimes100;
#else
		m_iNavalCombatExperience = iExperience;
#endif

		// Enough XP for a Great Admiral to appear?
		if(!isBarbarian())
		{
#if defined(MOD_UNITS_XP_TIMES_100)
			int iExperienceThresholdTimes100 = greatAdmiralThreshold() * 100;
			if (m_iNavalCombatExperienceTimes100 >= iExperienceThresholdTimes100 && iExperienceThresholdTimes100 > 0)
#else
			int iExperienceThreshold = greatAdmiralThreshold();
			if (m_iNavalCombatExperience >= iExperienceThreshold && iExperienceThreshold > 0)
#endif
			{
				// create great person
				CvCity* pBestCity = NULL;
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
				if(pFromUnit == NULL)
				{
#endif
					int iBestValue = INT_MAX;
					int iLoop;
					for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if(!pLoopCity->isCoastal())
						{
							continue;
						}

						int iValue = 4 * GC.getGame().getJonRandNum(getNumCities(), "Great Admiral City Selection");

						for(int i = 0; i < NUM_YIELD_TYPES; i++)
						{
							iValue += pLoopCity->findYieldRateRank((YieldTypes)i);
						}
						iValue += pLoopCity->findPopulationRank();

						if(iValue < iBestValue)
						{
							pBestCity = pLoopCity;
							iBestValue = iValue;
						}
					}
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
				}
#endif

#if defined(MOD_GLOBAL_LOCAL_GENERALS)
				if(pBestCity || pFromUnit)
#else
				if(pBestCity)
#endif
				{
					// Figure out which Promotion is the one which makes a unit a Great Admiral
					PromotionTypes eGreatAdmiralPromotion = NO_PROMOTION;
					for(int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
					{
						const PromotionTypes eLoopPromotion = static_cast<PromotionTypes>(iI);
						CvPromotionEntry* pkPromotionInfo = GC.getPromotionInfo(eLoopPromotion);
						if(pkPromotionInfo)
						{
							if(pkPromotionInfo->IsGreatAdmiral())
							{
								eGreatAdmiralPromotion = eLoopPromotion;
							}
						}
					}

					// If GA promotion exists, find a unit which gets it for free (i.e. the Great Admiral unit itself)
					if(eGreatAdmiralPromotion != NO_PROMOTION)
					{
						for(int iI = 0; iI < GC.getNumUnitInfos(); iI++)
						{
							const UnitTypes eLoopUnit = static_cast<UnitTypes>(iI);
							CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eLoopUnit);
							if(pkUnitInfo)
							{
								if(pkUnitInfo->GetFreePromotions(eGreatAdmiralPromotion))
								{
									// Is this the right unit of this class for this civ?
									const UnitTypes eUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits((UnitClassTypes)pkUnitInfo->GetUnitClassType());

									if(eUnit == eLoopUnit)
									{
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
										if(pFromUnit)
										{
											CUSTOMLOG("Create Great Admiral at (%d, %d) from unit %s", pFromUnit->plot()->getX(), pFromUnit->plot()->getY(), pFromUnit->getName().GetCString());
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
											createGreatAdmiral(eUnit, pFromUnit->plot()->getX(), pFromUnit->plot()->getY(), false);
#else
											createGreatAdmiral(eUnit, pFromUnit->plot()->getX(), pFromUnit->plot()->getY());
#endif

#if defined(MOD_PROMOTIONS_FLAGSHIP)
											if (MOD_PROMOTIONS_FLAGSHIP) {
												pFromUnit->setHasPromotion((PromotionTypes)GC.getPROMOTION_FLAGSHIP(), true);
											}
#endif
										}
										else
										{
#endif
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
											pBestCity->createGreatAdmiral(eUnit, false);
#else
											pBestCity->createGreatAdmiral(eUnit);
#endif
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
										}
#endif
#if defined(MOD_UNITS_XP_TIMES_100)
										setNavalCombatExperienceTimes100(getNavalCombatExperienceTimes100() - iExperienceThresholdTimes100);
#else
										setNavalCombatExperience(getNavalCombatExperience() - iExperienceThreshold);
#endif
										break;
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
#if defined(MOD_UNITS_XP_TIMES_100)
void CvPlayer::changeNavalCombatExperienceTimes100(int iChangeTimes100, CvUnit* pFromUnit)
#else
void CvPlayer::changeNavalCombatExperience(int iChange, CvUnit* pFromUnit)
#endif
#else
#if defined(MOD_UNITS_XP_TIMES_100)
void CvPlayer::changeNavalCombatExperienceTimes100(int iChangeTimes100)
#else
void CvPlayer::changeNavalCombatExperience(int iChange)
#endif
#endif
{
#if defined(MOD_UNITS_XP_TIMES_100)
	if (!MOD_UNITS_XP_TIMES_100) {
		// If NOT using XP times 100, remove any fractional part
		iChangeTimes100 -= (iChangeTimes100 % 100);
	}
	if (getNavalCombatExperienceTimes100() + iChangeTimes100 < 0)
#else
	if (getNavalCombatExperience() + iChange < 0)
#endif
	{
#if defined(MOD_UNITS_XP_TIMES_100)
		setNavalCombatExperienceTimes100(0);
#else
		setNavalCombatExperience(0);
#endif
	}
	else
	{
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
#if defined(MOD_UNITS_XP_TIMES_100)
		setNavalCombatExperienceTimes100(getNavalCombatExperienceTimes100() + iChangeTimes100, pFromUnit);
#else
		setNavalCombatExperience(getNavalCombatExperience() + iChange, pFromUnit);
#endif
#else
#if defined(MOD_UNITS_XP_TIMES_100)
		setNavalCombatExperienceTimes100(getNavalCombatExperienceTimes100() + iChangeTimes100);
#else
		setNavalCombatExperience(getNavalCombatExperience() + iChange);
#endif
#endif
	}

#if defined(MOD_UNITS_XP_TIMES_100)
	m_iLifetimeCombatExperienceTimes100 += iChangeTimes100;
#else
	m_iLifetimeCombatExperience += iChange;
#endif
}

//	--------------------------------------------------------------------------------
#if defined(MOD_UNITS_XP_TIMES_100)
int CvPlayer::getLifetimeCombatExperienceTimes100() const
#else
int CvPlayer::getLifetimeCombatExperience() const
#endif
{
#if defined(MOD_UNITS_XP_TIMES_100)
	return m_iLifetimeCombatExperienceTimes100;
#else
	return m_iLifetimeCombatExperience;
#endif
}

#if defined(MOD_GLOBAL_NO_CONQUERED_SPACESHIPS)
//	--------------------------------------------------------------------------------
// Remove all the parts of the spaceship that this player has assembled
void CvPlayer::disassembleSpaceship(CvPlot* pPlot) {
	if (MOD_GLOBAL_NO_CONQUERED_SPACESHIPS && !isMinorCiv() && !isBarbarian()) {
		CUSTOMLOG("Disassemble spaceship for player %i", GetID());
		CvTeam& thisTeam = GET_TEAM(getTeam());

		if (thisTeam.getProjectCount((ProjectTypes) GC.getSPACE_RACE_TRIGGER_PROJECT()) == 1) {
			thisTeam.changeProjectCount((ProjectTypes) GC.getSPACESHIP_CAPSULE(), -1 * thisTeam.getProjectCount((ProjectTypes) GC.getSPACESHIP_CAPSULE()));
			thisTeam.changeProjectCount((ProjectTypes) GC.getSPACESHIP_BOOSTER(), -1 * thisTeam.getProjectCount((ProjectTypes) GC.getSPACESHIP_BOOSTER()));
			thisTeam.changeProjectCount((ProjectTypes) GC.getSPACESHIP_STASIS(), -1 * thisTeam.getProjectCount((ProjectTypes) GC.getSPACESHIP_STASIS()));
			thisTeam.changeProjectCount((ProjectTypes) GC.getSPACESHIP_ENGINE(), -1 * thisTeam.getProjectCount((ProjectTypes) GC.getSPACESHIP_ENGINE()));

			if (pPlot) {
				CUSTOMLOG("Removing launch pad at (%i, %i)", pPlot->getX(), pPlot->getY());
				auto_ptr<ICvPlot1> pDllPlot(new CvDllPlot(pPlot));
				gDLL->GameplaySpaceshipEdited(pDllPlot.get(), 0x0000); // Remove the launch pad
			}
		}
	}
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::getBorderObstacleCount() const
{
	return m_iBorderObstacleCount;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isBorderObstacle() const
{
	return (getBorderObstacleCount() > 0);
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeBorderObstacleCount(int iChange)
{
	if(iChange != 0)
	{
		m_iBorderObstacleCount = (m_iBorderObstacleCount + iChange);
		CvAssert(getBorderObstacleCount() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNetID() const
{
	return CvPreGame::netID(GetID());
}

//	--------------------------------------------------------------------------------
void CvPlayer::setNetID(int iNetID)
{
	CvPreGame::setNetID(GetID(), iNetID);
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isConnected() const
{
	return gDLL->IsPlayerConnected(GetID());
}

//	--------------------------------------------------------------------------------
void CvPlayer::sendTurnReminder()
{
	//Send a game invite to the player if they aren't currently connected to the game.
	gDLL->sendTurnReminder(GetID());

	/* email notifications not implimented.
	if(!getPbemEmailAddress().empty() &&
	        !gDLL->GetPitbossSmtpHost().empty())
	{

	}
	*/
}

//	--------------------------------------------------------------------------------
uint CvPlayer::getStartTime() const
{
	return m_uiStartTime;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setStartTime(uint uiStartTime)
{
	m_uiStartTime = uiStartTime;
}


//	--------------------------------------------------------------------------------
uint CvPlayer::getTotalTimePlayed() const
{
	return ((timeGetTime() - m_uiStartTime)/1000);
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isMinorCiv() const
{
	return CvPreGame::isMinorCiv(m_eID);
}


#if defined(MOD_API_EXTENSIONS)
//	--------------------------------------------------------------------------------
bool CvPlayer::isMajorCiv() const
{
	return GET_TEAM(getTeam()).isMajorCiv();
}
#endif


//	--------------------------------------------------------------------------------
/// Has this player betrayed a Minor Civ he was bullying by declaring war on him?
bool CvPlayer::IsHasBetrayedMinorCiv() const
{
	return m_bHasBetrayedMinorCiv;
}

//	--------------------------------------------------------------------------------
/// Sets this player to have betrayed a Minor Civ he was bullying by declaring war on him
void CvPlayer::SetHasBetrayedMinorCiv(bool bValue)
{
	if(IsHasBetrayedMinorCiv() != bValue)
	{
		m_bHasBetrayedMinorCiv = bValue;
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::setAlive(bool bNewValue, bool bNotify)
{
	CvString strBuffer;
	int iI;

	if(isAlive() != bNewValue)
	{
		m_bAlive = bNewValue;

		GET_TEAM(getTeam()).changeAliveCount((isAlive()) ? 1 : -1);

		GC.getGame().GetGameLeagues()->DoPlayerAliveStatusChanged(GetID());

		// Tell Minor Civ AI what's up so that it knows when to add/remove bonuses for players it's friends with
		if(isMinorCiv())
		{
			GetMinorCivAI()->DoChangeAliveStatus(bNewValue);
		}

		if(isAlive())
		{
			if(!isEverAlive())
			{
				m_bEverAlive = true;

				GET_TEAM(getTeam()).changeEverAliveCount(1);
			}

			if(getNumCities() == 0)
			{
				setFoundedFirstCity(false);
			}

			GET_TEAM(getTeam()).SetKilledByTeam(NO_TEAM);

			if(isSimultaneousTurns() || (GC.getGame().getNumGameTurnActive() == 0) || (GC.getGame().isSimultaneousTeamTurns() && GET_TEAM(getTeam()).isTurnActive()))
			{
				setTurnActive(true);
			}

			gDLL->openSlot(GetID());
		}
		else
		{
			clearResearchQueue();
			killUnits();
			killCities();
			if(CvPreGame::isNetworkMultiplayerGame() && m_eID == GC.getGame().getActivePlayer())
				gDLL->netDisconnect();

			if (!GET_TEAM(getTeam()).isAlive())
			{
				for (int i = 0; i < MAX_TEAMS; i++)
				{
					TeamTypes eTheirTeam = (TeamTypes)i;
					if (getTeam() != eTheirTeam)
					{
						// close both embassies
						GET_TEAM(getTeam()).CloseEmbassyAtTeam(eTheirTeam);
						GET_TEAM(eTheirTeam).CloseEmbassyAtTeam(getTeam());

						// cancel any research agreements
						GET_TEAM(getTeam()).CancelResearchAgreement(eTheirTeam);
						GET_TEAM(eTheirTeam).CancelResearchAgreement(getTeam());

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
						if (MOD_DIPLOMACY_CIV4_FEATURES) {
							GET_TEAM(getTeam()).DoEndVassal(eTheirTeam, true, true);
							GET_TEAM(eTheirTeam).DoEndVassal(getTeam(), true, true);
						}
#endif
					}
				}
			}

			// Reset incoming units
			for(int iLoop = 0; iLoop < MAX_PLAYERS; iLoop++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes) iLoop;
				SetIncomingUnitCountdown(eLoopPlayer, -1);
				SetIncomingUnitType(eLoopPlayer, NO_UNIT);
			}

			GC.getGame().GetGameDeals().DoCancelAllDealsWithPlayer(GetID());

			// Reset relationships with minor civs
			for(int iPlayerLoop = MAX_MAJOR_CIVS; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
			{
				PlayerTypes eOtherPlayer = (PlayerTypes) iPlayerLoop;
				GET_PLAYER(eOtherPlayer).GetMinorCivAI()->ResetFriendshipWithMajor(GetID());
			}

			setTurnActive(false);

			gDLL->closeSlot(GetID());

			if(bNotify && !isBarbarian())
			{
				Localization::String strMessage = Localization::Lookup("TXT_KEY_MISC_CIV_DESTROYED");
				strMessage << getCivilizationAdjectiveKey();
				Localization::String strSummary = Localization::Lookup("TXT_KEY_MISC_CIV_DESTROYED_SHORT");
				strSummary << getCivilizationShortDescriptionKey();

				for(iI = 0; iI < MAX_PLAYERS; iI++)
				{
					const PlayerTypes eOtherPlayer = static_cast<PlayerTypes>(iI);
					CvPlayerAI& kOtherPlayer = GET_PLAYER(eOtherPlayer);

					if(kOtherPlayer.isAlive() && kOtherPlayer.GetNotifications())
					{
						kOtherPlayer.GetNotifications()->Add(NOTIFICATION_PLAYER_KILLED, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, -1);
					}
				}

				GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, GetID(), strMessage.toUTF8(), -1, -1);
			}

			GC.getGame().testVictory();
		}

		GC.getGame().setScoreDirty(true);
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::setBeingResurrected(bool bValue)
{
	if (m_bBeingResurrected != bValue)
	{
		m_bBeingResurrected = bValue;
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::verifyAlive()
{
	bool bKill;

	if(isAlive())
	{
		bKill = false;

		if(!bKill)
		{
			if(!isBarbarian())
			{
				if(getNumCities() == 0 && getAdvancedStartPoints() < 0)
				{
					if((getNumUnits() == 0) || (!(GC.getGame().isOption(GAMEOPTION_COMPLETE_KILLS)) && isFoundedFirstCity()))
					{
						if(!GetPlayerTraits()->IsStaysAliveZeroCities())
						{
							bKill = true;
						}
					}
				}
			}
		}

		if(!bKill)
		{
			if(!isBarbarian())
			{
				if(GC.getGame().getMaxCityElimination() > 0)
				{
					if(getCitiesLost() >= GC.getGame().getMaxCityElimination())
					{
						bKill = true;
					}
				}
			}
		}

		if(bKill)
		{
			setAlive(false, false);
		}
	}
	else
	{
		if((getNumCities() > 0) || (getNumUnits() > 0))
		{
			setAlive(true);
		}
	}
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isTurnActive() const
{
	return m_bTurnActive;
}

//	--------------------------------------------------------------------------------
void CvPlayer::setTurnActiveForPbem(bool bActive)
{
	CvAssertMsg(GC.getGame().isPbem(), "You are using setTurnActiveForPbem. Are you sure you know what you're doing?");

	// does nothing more than to set the member variable before saving the game
	// the rest of the turn will be performed upon loading the game
	// This allows the player to browse the game in paused mode after he has generated the save
	if(isTurnActive() != bActive)
	{
		m_bTurnActive = bActive;
		GC.getGame().changeNumGameTurnActive(isTurnActive() ? 1 : -1, "setTurnActiveForPlayByEmail");
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::setTurnActive(bool bNewValue, bool bDoTurn)
{
	if(isTurnActive() != bNewValue)
	{
		m_bTurnActive = bNewValue;
		DLLUI->PublishEndTurnDirty();

		CvGame& kGame = GC.getGame();

		/////////////////////////////////////////////
		// TURN IS BEGINNING
		/////////////////////////////////////////////

		if(isTurnActive())
		{
			CvAssertMsg(isAlive(), "isAlive is expected to be true");

			setEndTurn(false);

			DoUnitAttrition();

			if(kGame.getActivePlayer() == m_eID)
			{
				CvMap& theMap = GC.getMap();
				theMap.updateDeferredFog();
			}

			if((kGame.isHotSeat() || kGame.isPbem()) && isHuman() && bDoTurn)
			{
				DLLUI->clearEventMessages();

				kGame.setActivePlayer(GetID());
			}

			if(CvPreGame::isPitBoss() && kGame.getActivePlayer() != m_eID && isHuman() && gDLL->IsHost() && !isConnected())
			{//send turn reminder if the player isn't actively connected to the game.
				sendTurnReminder();
			}

			std::ostringstream infoStream;
			infoStream << "setTurnActive() for player ";
			infoStream << (int)GetID();
			infoStream << " ";
			infoStream << getName();
			kGame.changeNumGameTurnActive(1, infoStream.str());

			DLLUI->PublishPlayerTurnStatus(DLLUIClass::TURN_START, GetID());

			if(bDoTurn)
			{
				SetAllUnitsUnprocessed();
				{
					AI_PERF_FORMAT("AI-perf.csv", ("Connections/Gold, Turn %03d, %s", kGame.getElapsedGameTurns(), getCivilizationShortDescription()) );

					// This block all has things which might change based on city connections changing
					m_pCityConnections->Update();
					GetTreasury()->DoUpdateCityConnectionGold();
				}

				{
					AI_PERF_FORMAT("AI-perf.csv", ("Builder Tasking, Turn %03d, %s", kGame.getElapsedGameTurns(), getCivilizationShortDescription()) );

					m_pBuilderTaskingAI->Update();
				}

				if(kGame.isFinalInitialized())
				{
					if(isAlive())
					{
						if(GetDiplomacyRequests())
						{
							GetDiplomacyRequests()->BeginTurn();
						}

						doTurn();

						doTurnUnits();
					}
				}

				if((GetID() == kGame.getActivePlayer()) && (kGame.getElapsedGameTurns() > 0))
				{
					if(kGame.isNetworkMultiPlayer())
					{
						DLLUI->AddMessage(0, GetID(), true, GC.getEVENT_MESSAGE_TIME(), GetLocalizedText("TXT_KEY_MISC_TURN_BEGINS").GetCString(), "AS2D_NEWTURN", MESSAGE_TYPE_DISPLAY_ONLY);
					}
				}

				doWarnings();
			}

#if defined(MOD_ACTIVE_DIPLOMACY)
			if (isHuman())
			{
				// JdH: we just activated a human
				// later the AI players need to try to contact the player
				CvDiplomacyRequests::s_aDiploHumans.push_back(GetID());
			}
#endif

			if(GetID() == kGame.getActivePlayer())
			{
				GetUnitCycler().Rebuild();

				if(DLLUI->GetLengthSelectionList() == 0)
				{
					DLLUI->setCycleSelectionCounter(1);
				}

				DLLUI->setDirty(SelectionCamera_DIRTY_BIT, true);

				// slewis - added this so the tutorial knows when a turn begins
				DLLUI->PublishActivePlayerTurnStart();
			}
			else if(isHuman() && kGame.isGameMultiPlayer())
			{
				DLLUI->PublishRemotePlayerTurnStart();
			}
		}

		/////////////////////////////////////////////
		// TURN IS ENDING
		/////////////////////////////////////////////

		else
		{
#if defined(MOD_EVENTS_RED_TURN)
			if (MOD_EVENTS_RED_TURN)
			// RED <<<<<
			{
				ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
				if(pkScriptSystem)
				{	
					CvLuaArgsHandle args;

					args->Push(GetID());

					bool bResult;
					LuaSupport::CallHook(pkScriptSystem, "PlayerEndTurnInitiated", args.get(), bResult);
				}
			}
			// RED >>>>>
#endif

			CvAssertFmt(GetEndTurnBlockingType() == NO_ENDTURN_BLOCKING_TYPE, "Expecting the end-turn blocking to be NO_ENDTURN_BLOCKING_TYPE, got %d", GetEndTurnBlockingType());
			SetEndTurnBlocking(NO_ENDTURN_BLOCKING_TYPE, -1);	// Make sure this is clear so the UI doesn't block when it is not our turn.

			DoUnitReset();

			if(!isHuman())
			{
				RespositionInvalidUnits();
			}

			if(GetNotifications())
			{
				GetNotifications()->EndOfTurnCleanup();
			}

			if(GetDiplomacyRequests())
			{
				GetDiplomacyRequests()->EndTurn();
			}

			if(GetID() == kGame.getActivePlayer())
			{
				DLLUI->PublishActivePlayerTurnEnd();
			}

			if(!isHuman() || (isHuman() && !isAlive()) || (isHuman() && gDLL->HasReceivedTurnAllComplete(GetID())) || kGame.getAIAutoPlay())
				kGame.changeNumGameTurnActive(-1, std::string("setTurnActive() for player ") + getName());

#if defined(MOD_EVENTS_RED_TURN)
			if (MOD_EVENTS_RED_TURN)
			// RED <<<<<
			{
				ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
				if(pkScriptSystem)
				{	
					CvLuaArgsHandle args;

					args->Push(GetID());

					bool bResult;
					LuaSupport::CallHook(pkScriptSystem, "PlayerEndTurnCompleted", args.get(), bResult);
				}
			}
			// RED >>>>>
#endif

			DLLUI->PublishPlayerTurnStatus(DLLUIClass::TURN_END, GetID());
		}
	}
	else
	{
		CvString logOutput;
		logOutput.Format("SetTurnActive() called without changing the end turn status. Player(%i) OldTurnActive(%i) NewTurnActive(%i)", GetID(), isTurnActive(), bNewValue);
		gDLL->netMessageDebugLog(logOutput);
	}
}

//	----------------------------------------------------------------------------
bool CvPlayer::isSimultaneousTurns() const
{
	if(GC.getGame().isOption(GAMEOPTION_DYNAMIC_TURNS))
	{//in dynamic turns mode, our turn mode varies
		return m_bDynamicTurnsSimultMode;
	}
	else if(GC.getGame().isOption(GAMEOPTION_SIMULTANEOUS_TURNS))
	{
		return true;
	}

	return false;
}


//	----------------------------------------------------------------------------
void CvPlayer::setDynamicTurnsSimultMode(bool simultaneousTurns)
{
	if(simultaneousTurns != m_bDynamicTurnsSimultMode)
	{
		CvNotifications* pNotifications = GetNotifications();
		if (pNotifications)
		{
			NotificationTypes notifyType = NOTIFICATION_TURN_MODE_SEQUENTIAL;
			Localization::String localizedText = Localization::Lookup("TXT_KEY_NOTIFICATION_TURN_MODE_SEQUENTIAL");
			Localization::String localizedTextSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_TURN_MODE_SEQUENTIAL_SUMMARY");
			if(simultaneousTurns)
			{
				notifyType = NOTIFICATION_TURN_MODE_SIMULTANEOUS;
				localizedText = Localization::Lookup("TXT_KEY_NOTIFICATION_TURN_MODE_SIMULTANEOUS");
				localizedTextSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_TURN_MODE_SIMULTANEOUS_SUMMARY");
			}

			pNotifications->Add(notifyType, localizedText.toUTF8(), localizedTextSummary.toUTF8(), -1, -1, -1);
		}

		m_bDynamicTurnsSimultMode = simultaneousTurns;
	}
	
}

//	----------------------------------------------------------------------------
bool CvPlayer::isAutoMoves() const
{
	return m_bAutoMoves;
}

//	----------------------------------------------------------------------------
void CvPlayer::setAutoMoves(bool bNewValue)
{
	if(isAutoMoves() != bNewValue)
	{
		m_bAutoMoves = bNewValue;
		m_bProcessedAutoMoves = false;
	}
}

//	----------------------------------------------------------------------------
bool CvPlayer::hasProcessedAutoMoves() const
{
	return m_bProcessedAutoMoves;
}

//	----------------------------------------------------------------------------
void CvPlayer::setProcessedAutoMoves(bool bNewValue)
{
	if(hasProcessedAutoMoves() != bNewValue)
	{
		m_bProcessedAutoMoves = bNewValue;
	}
}

//	----------------------------------------------------------------------------
bool CvPlayer::isEndTurn() const
{
	return m_bEndTurn;
}

//	------------------------------------------------------------------------------------------------
void CvPlayer::setEndTurn(bool bNewValue)
{
	CvGame& game = GC.getGame();

	if(isSimultaneousTurns()
		&& bNewValue 
		&& game.isNetworkMultiPlayer() 
		&& !gDLL->HasReceivedTurnAllCompleteFromAllPlayers())
	{//When doing simultaneous turns in multiplayer, we don't want anyone to end their turn until everyone has signalled TurnAllComplete.
		// No setting end turn to true until all the players have sent the TurnComplete network message
		return;
	}

	// If this is a remote player in an MP match, don't
	// honor the end of turn request if the player still
	// has units to run the simulation for the turn
	if(!isEndTurn() && isHuman() && GetID() != game.getActivePlayer())
	{
		if(hasBusyUnitOrCity() || (!gDLL->HasReceivedTurnComplete(GetID()) && hasReadyUnit()))
		{
			return;
		}
	}
	else if(!isHuman())
	{
		if(hasBusyUnitOrCity())
		{
			return;
		}
	}

	if(isEndTurn() != bNewValue)
	{
		//  If the game isn't MP and the player has queued popups force him to deal with them first
		if(!GC.getGame().isGameMultiPlayer())
		{
			//if (GC.GetEngineUserInterface()->isPopupQueued())
			//{
			//	GC.GetEngineUserInterface()->setForcePopup(true);
			//	return;
			//}
			//if (GC.GetEngineUserInterface()->isDiploOrPopupWaiting())
			//{
			//	return;
			//}
		}

		CvAssertMsg(isTurnActive(), "isTurnActive is expected to be true");

		m_bEndTurn = bNewValue;

		if(isEndTurn())
		{
			if(!GC.getGame().isOption(GAMEOPTION_DYNAMIC_TURNS) && GC.getGame().isOption(GAMEOPTION_SIMULTANEOUS_TURNS))
			{//fully simultaneous turns only run automoves after every human has moved.
				checkRunAutoMovesForEveryone();
			}
			else
			{
				setAutoMoves(true);
			}
		}
		else
			setAutoMoves(false);
	}
	else
	{
		// This check is here for the AI.  Currently, the setEndTurn(true) never seems to get called for AI players, the automoves are just set directly
		// Why is this?  It would be great if all players were processed the same.
		if(!bNewValue && isAutoMoves())
			setAutoMoves(false);
	}
}

//	---------------------------------------------------------------------------
void CvPlayer::checkRunAutoMovesForEveryone()
{
	bool runAutoMovesForEveryone = true;
	int i = 0;
	for(i = 0; i < MAX_PLAYERS; ++i)
	{
		CvPlayer& p = CvPlayerAI::getPlayer((PlayerTypes)i);
		if(p.isHuman() && !p.isObserver() 
			// Check to see if this human player hasn't gotten to the end turn phase of their turn.  
			// This gets tricky because hot joiners can hop into an ai civ that already finished their turn.
			// When this occurs, the hot joiner will not be turn active, will have already run their automoves,
			// and not have end turn set. (AIs do not set end turn) *sigh*
			// To handle that case, we assume that human players who are not endturn and turn inactive after TurnAllComplete
			// are ready for the human automoves phase.
			&& (!p.isEndTurn()
			&& (!gDLL->HasReceivedTurnAllCompleteFromAllPlayers() || p.isTurnActive()))) 
		{
			runAutoMovesForEveryone = false;
			break;
		}
	}

	if(runAutoMovesForEveryone)
	{
		for(i = 0; i < MAX_PLAYERS; ++i)
		{
			CvPlayer& p = CvPlayerAI::getPlayer((PlayerTypes)i);
			if(p.isHuman())
			{
				p.setAutoMoves(true);
			}
		}
	}
}

//	---------------------------------------------------------------------------
EndTurnBlockingTypes CvPlayer::GetEndTurnBlockingType(void) const
{
	return m_eEndTurnBlockingType;
}

//	---------------------------------------------------------------------------
int CvPlayer::GetEndTurnBlockingNotificationIndex(void) const
{
	return m_iEndTurnBlockingNotificationIndex;
}

//	---------------------------------------------------------------------------
void CvPlayer::SetEndTurnBlocking(EndTurnBlockingTypes eBlockingType, int iNotificationIndex)
{
	bool bFireEvent = false;
	if(m_eEndTurnBlockingType != eBlockingType || m_iEndTurnBlockingNotificationIndex != iNotificationIndex)
	{
		bFireEvent = true;
	}

	EndTurnBlockingTypes ePrevBlockingType = m_eEndTurnBlockingType;
	m_eEndTurnBlockingType = eBlockingType;
	m_iEndTurnBlockingNotificationIndex = iNotificationIndex;

	if(bFireEvent)
	{
		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->SetEndTurnBlockingChanged( ePrevBlockingType, m_eEndTurnBlockingType );
			GC.GetEngineUserInterface()->UpdateEndTurn();
		}
	}
}

//	---------------------------------------------------------------------------
bool CvPlayer::isTurnDone() const
{
	// if this returns true, popups and diplomacy will wait to appear until next turn
	if(!GC.getGame().isPbem() && !GC.getGame().isHotSeat())
	{
		return false;
	}
	if(!isHuman())
	{
		return true;
	}
	if(!isEndTurn())
	{
		return false;
	}
	return (!isAutoMoves());
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isExtendedGame() const
{
	return m_bExtendedGame;
}


//	--------------------------------------------------------------------------------
void CvPlayer::makeExtendedGame()
{
	m_bExtendedGame = true;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isFoundedFirstCity() const
{
	return m_bFoundedFirstCity;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setFoundedFirstCity(bool bNewValue)
{
	if(isFoundedFirstCity() != bNewValue)
	{
		m_bFoundedFirstCity = bNewValue;

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(PercentButtons_DIRTY_BIT, true);
			GC.GetEngineUserInterface()->setDirty(ResearchButtons_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumCitiesFounded() const
{
	return m_iNumCitiesFounded;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumCitiesFounded(int iValue)
{
	m_iNumCitiesFounded += iValue;
}

//	--------------------------------------------------------------------------------
// check to see if we defeated this other player
void CvPlayer::CheckForMurder(PlayerTypes ePossibleVictimPlayer)
{
	// Cache whether the player is human or not.  If the player is killed, the CvPreGame::slotStatus is changed to SS_CLOSED
	// but the slot status is used to determine if the player is human or not, so it looks like it is an AI!
	// This should be fixed, but might have unforeseen ramifications so...
	CvPlayer& kPossibleVictimPlayer = GET_PLAYER(ePossibleVictimPlayer);
	bool bPossibileVictimIsHuman = kPossibleVictimPlayer.isHuman();

	// This may 'kill' the player if it is deemed that he does not have the proper units to stay alive
	kPossibleVictimPlayer.verifyAlive();

	// You... you killed him!
	if(!kPossibleVictimPlayer.isAlive())
	{
		GET_TEAM(kPossibleVictimPlayer.getTeam()).SetKilledByTeam(getTeam());
		kPossibleVictimPlayer.SetEverConqueredBy(m_eID, true);

		// Leader pops up and whines
		if(!CvPreGame::isNetworkMultiplayerGame())		// Not in MP
		{
			if(!bPossibileVictimIsHuman && !kPossibleVictimPlayer.isMinorCiv() && !kPossibleVictimPlayer.isBarbarian())
				kPossibleVictimPlayer.GetDiplomacyAI()->DoKilledByPlayer(GetID());
		}

		// do post-dying clean up
		if (!kPossibleVictimPlayer.isMinorCiv())
		{
			for (uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
			{
				PlayerTypes eCleanupPlayer = (PlayerTypes)ui;
				GET_PLAYER(eCleanupPlayer).GetDiplomacyAI()->KilledPlayerCleanup(kPossibleVictimPlayer.GetID());
			}
		}
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isStrike() const
{
	return m_bStrike;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setStrike(bool bNewValue)
{
	if(m_bStrike != bNewValue)
	{
		m_bStrike = bNewValue;

		if(m_bStrike)
		{
			if(GetID() == GC.getGame().getActivePlayer())
			{
				GC.GetEngineUserInterface()->AddMessage(0, GetID(), false, GC.getEVENT_MESSAGE_TIME(), GetLocalizedText("TXT_KEY_MISC_UNITS_ON_STRIKE").GetCString(), "AS2D_STRIKE", MESSAGE_TYPE_MINOR_EVENT, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_WARNING_TEXT"));

				GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
			}
		}
	}
}


//	--------------------------------------------------------------------------------
/// Is the player is cramped in his current area?
bool CvPlayer::IsCramped() const
{
	return m_bCramped;
}

//	--------------------------------------------------------------------------------
/// Determines if the player is cramped in his current area.  Not a perfect algorithm, as it will double-count Plots shared by different Cities, but it should be good enough
void CvPlayer::DoUpdateCramped()
{
	CvCity* pLoopCity;
	CvPlot* pPlot;

	int iTotalPlotsNearby = 0;
	int iUsablePlotsNearby = 0;

	int iRange = GC.getCRAMPED_RANGE_FROM_CITY();

	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		for(int iX = -iRange; iX <= iRange; iX++)
		{
			for(int iY = -iRange; iY <= iRange; iY++)
			{
				pPlot = plotXYWithRangeCheck(pLoopCity->getX(), pLoopCity->getY(), iX, iY, iRange);

				if(pPlot != NULL)
				{
					// Plot not owned by me
					if(!pPlot->isOwned() || pPlot->getOwner() != GetID())
					{
						iTotalPlotsNearby++;

						// A "good" unowned Plot
						if(!pPlot->isOwned() && pPlot->isValidMovePlot(GetID()) && !pPlot->isWater())
						{
							iUsablePlotsNearby++;
						}
					}
				}
			}
		}
	}

	if(iTotalPlotsNearby > 0)
	{
		if(100 * iUsablePlotsNearby / iTotalPlotsNearby <= GC.getCRAMPED_USABLE_PLOT_PERCENT())	// 20
		{
			m_bCramped = true;
		}
		else
		{
			m_bCramped = false;
		}
	}
}

//	--------------------------------------------------------------------------------
CvHandicapInfo& CvPlayer::getHandicapInfo() const
{
	CvHandicapInfo* pkHandicapInfo = GC.getHandicapInfo(getHandicapType());
	if(pkHandicapInfo == NULL)
	{
		const char* szError = "ERROR: Player does not contain valid handicap!!";
		GC.LogMessage(szError);
		CvAssertMsg(false, szError);
	}

#pragma warning ( push )
#pragma warning ( disable : 6011 ) // Dereferencing NULL pointer
	return *pkHandicapInfo;
#pragma warning ( pop )
}

//	--------------------------------------------------------------------------------
HandicapTypes CvPlayer::getHandicapType() const
{
	return CvPreGame::handicap(GetID());
}

//	--------------------------------------------------------------------------------
CvCivilizationInfo& CvPlayer::getCivilizationInfo() const
{
	CvCivilizationInfo* pkCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
	if(pkCivilizationInfo == NULL)
	{
		const char* szError = "ERROR: Player does not contain valid civilization type!!";
		GC.LogMessage(szError);
		CvAssertMsg(false, szError);
	}

#pragma warning ( push )
#pragma warning ( disable : 6011 ) // Dereferencing NULL pointer
	return *pkCivilizationInfo;
#pragma warning ( pop )
}

//	--------------------------------------------------------------------------------
CivilizationTypes CvPlayer::getCivilizationType() const
{
	return CvPreGame::civilization(GetID());
}


//	--------------------------------------------------------------------------------
CvLeaderHeadInfo& CvPlayer::getLeaderInfo() const
{
	CvLeaderHeadInfo* pkLeaderInfo = GC.getLeaderHeadInfo(getLeaderType());
	if(pkLeaderInfo == NULL)
	{
		const char* szError = "ERROR: Player does not contain valid leader type!!";
		GC.LogMessage(szError);
		CvAssertMsg(false, szError);
	}

#pragma warning ( push )
#pragma warning ( disable : 6011 ) // Dereferencing NULL pointer
	return *pkLeaderInfo;
#pragma warning ( pop )
}

//	--------------------------------------------------------------------------------
LeaderHeadTypes CvPlayer::getLeaderType() const
{
	return CvPreGame::leaderHead(GetID());
}
#if defined(MOD_API_EXTENSIONS)
//	--------------------------------------------------------------------------------
void CvPlayer::setLeaderType(LeaderHeadTypes eNewLeader)
{
    if (isMajorCiv())
	{
		LeaderHeadTypes eOldLeader = getLeaderType();
		
		// Set the new leader type
		CvPreGame::setLeaderHead(GetID(), eNewLeader);
	
		// Update the player's personality
		setPersonalityType(eNewLeader);
	
		// Update the player's traits (Leader_Traits)
		GetPlayerTraits()->Reset();
		GetPlayerTraits()->InitPlayerTraits();
		recomputePolicyCostModifier();
		
		if (!isHuman()) {
			// Update the player's biases (Leader_MajorCivApproachBiases)
			// Nothing to do as they are not cached in CvPlayer
	
			// Update the player's flavours (Leader_Flavors)
			GetFlavorManager()->ChangeLeader(eOldLeader, eNewLeader);
			
			// Update the player's strategies
			// Nothing to do as these will auto-update based on the new flavours at the end of the player's turn
		}
	}
}
#endif

//	--------------------------------------------------------------------------------
LeaderHeadTypes CvPlayer::getPersonalityType() const
{
	return m_ePersonalityType;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setPersonalityType(LeaderHeadTypes eNewValue)
{
	m_ePersonalityType = eNewValue;
}


//	--------------------------------------------------------------------------------
EraTypes CvPlayer::GetCurrentEra() const
{
	return GET_TEAM(getTeam()).GetCurrentEra();
}

//	--------------------------------------------------------------------------------
void CvPlayer::setTeam(TeamTypes eTeam)
{
	CvAssert(eTeam != NO_TEAM);
	CvAssert(getTeam() != NO_TEAM);

	GET_TEAM(getTeam()).changeNumMembers(-1);
	if(isAlive())
	{
		GET_TEAM(getTeam()).changeAliveCount(-1);
	}
	if(isEverAlive())
	{
		GET_TEAM(getTeam()).changeEverAliveCount(-1);
	}
	GET_TEAM(getTeam()).changeNumCities(-(getNumCities()));
	GET_TEAM(getTeam()).changeTotalPopulation(-(getTotalPopulation()));
	GET_TEAM(getTeam()).changeTotalLand(-(getTotalLand()));

#if defined(MOD_BALANCE_CORE)
	GET_TEAM(getTeam()).removePlayer(GetID());
#endif

	CvPreGame::setTeamType(GetID(), eTeam);

#if defined(MOD_BALANCE_CORE)
	GET_TEAM(getTeam()).addPlayer(GetID());
#endif

	GET_TEAM(getTeam()).changeNumMembers(1);
	if(isAlive())
	{
		GET_TEAM(getTeam()).changeAliveCount(1);
	}
	if(isEverAlive())
	{
		GET_TEAM(getTeam()).changeEverAliveCount(1);
	}
	GET_TEAM(getTeam()).changeNumCities(getNumCities());
	GET_TEAM(getTeam()).changeTotalPopulation(getTotalPopulation());
	GET_TEAM(getTeam()).changeTotalLand(getTotalLand());
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsAITeammateOfHuman() const
{
	bool bRtnValue = false;

#if defined(MOD_BALANCE_CORE)
	const std::vector<PlayerTypes>& teammates = GET_TEAM(getTeam()).getPlayers();
	for (size_t i = 0; i < teammates.size(); ++i)
	{
		CvPlayer& player = GET_PLAYER(teammates[i]);
#else
	for(int i = 0; i < MAX_PLAYERS; ++i)
	{
		CvPlayer& player = GET_PLAYER(static_cast<PlayerTypes>(i));
#endif
		if (player.isHuman() && player.isAlive())
		{
			if(player.getTeam() == getTeam())
			{
				bRtnValue = true;
				break;
			}
		}
	}

	return bRtnValue;
}

//	--------------------------------------------------------------------------------
PlayerColorTypes CvPlayer::getPlayerColor() const
{
	return CvPreGame::playerColor(GetID());
}

//	--------------------------------------------------------------------------------
const CvColorA& CvPlayer::getPlayerTextColor() const
{
	CvAssertMsg(getPlayerColor() != NO_PLAYERCOLOR, "getPlayerColor() is not expected to be equal with NO_PLAYERCOLOR");
	CvPlayerColorInfo* pkPlayerColorInfo = GC.GetPlayerColorInfo(getPlayerColor());
	CvColorInfo* pkColorInfo = NULL;
	if(pkPlayerColorInfo)
	{
		ColorTypes eTextColor = static_cast<ColorTypes>(pkPlayerColorInfo->GetColorTypeText());
		pkColorInfo = GC.GetColorInfo(eTextColor);
		if(pkColorInfo)
			return pkColorInfo->GetColor();
	}

	//Default to black text if no color exists.
	static CvColorA black(0,0,0,1.0f);
	return black;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getSeaPlotYield(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiSeaPlotYield[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeSeaPlotYield(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiSeaPlotYield.setAt(eIndex, m_aiSeaPlotYield[eIndex] + iChange);

		updateYield();
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getYieldRateModifier(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldRateModifier[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldRateModifier(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldRateModifier.setAt(eIndex, m_aiYieldRateModifier[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
#if defined(MOD_BALANCE_CORE_POLICIES)
int CvPlayer::GetApproachScratchValue(PlayerTypes ePlayer, MajorCivApproachTypes eMajorCivApproach) const
{
	CvAssertMsg(ePlayer >= 0, "ePlayer expected to be >= 0");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer expected to be < MAX_MAJOR_CIVS");
	CvAssertMsg(eMajorCivApproach >= 0, "eMajorCivApproach expected to be >= 0");
	CvAssertMsg(eMajorCivApproach < NUM_MAJOR_CIV_APPROACHES, "eMajorCivApproach expected to be < NUM_MAJOR_CIV_APPROACHES");
	return  m_ppiApproachScratchValue[ePlayer][eMajorCivApproach];
}
void CvPlayer::SetApproachScratchValue(PlayerTypes ePlayer, MajorCivApproachTypes eMajorCivApproach, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "ePlayer expected to be >= 0");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer expected to be < MAX_MAJOR_CIVS");
	CvAssertMsg(eMajorCivApproach >= 0, "eMajorCivApproach expected to be >= 0");
	CvAssertMsg(eMajorCivApproach < NUM_MAJOR_CIV_APPROACHES, "eMajorCivApproach expected to be < NUM_MAJOR_CIV_APPROACHES");

	if(iValue != 0)
	{
		m_ppiApproachScratchValue[ePlayer][eMajorCivApproach] = iValue;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetTradeReligionModifier() const
{
	return m_iTradeReligionModifier;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeTradeReligionModifier(int iChange)
{
	m_iTradeReligionModifier += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromBirth(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldFromBirth[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromBirth(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldFromBirth.setAt(eIndex, m_aiYieldFromBirth[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromBirthCapital(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldFromBirthCapital[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromBirthCapital(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldFromBirthCapital.setAt(eIndex, m_aiYieldFromBirthCapital[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromDeath(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldFromDeath[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromDeath(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldFromDeath.setAt(eIndex, m_aiYieldFromDeath[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromConstruction(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldFromConstruction[eIndex];
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromConstruction(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldFromConstruction.setAt(eIndex, m_aiYieldFromConstruction[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromTech(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldFromTech[eIndex];
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromTech(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldFromTech.setAt(eIndex, m_aiYieldFromTech[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromBorderGrowth(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldFromBorderGrowth[eIndex];
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromBorderGrowth(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldFromBorderGrowth.setAt(eIndex, m_aiYieldFromBorderGrowth[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::getYieldGPExpend(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldGPExpend[eIndex];
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldGPExpend(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldGPExpend.setAt(eIndex, m_aiYieldGPExpend[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::getConquerorYield(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiConquerorYield[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeConquerorYield(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiConquerorYield.setAt(eIndex, m_aiConquerorYield[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::getFounderYield(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiFounderYield[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeFounderYield(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiFounderYield.setAt(eIndex, m_aiFounderYield[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGoldenAgeYieldMod(YieldTypes eIndex)	const
{
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiGoldenAgeYieldMod[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeGoldenAgeYieldMod(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiGoldenAgeYieldMod.setAt(eIndex, m_aiGoldenAgeYieldMod[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::getReligionYieldRateModifier(YieldTypes eIndex)	const
{
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiReligionYieldRateModifier[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeReligionYieldRateModifier(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiReligionYieldRateModifier.setAt(eIndex, m_aiReligionYieldRateModifier[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetGarrisonsOccupiedUnhapppinessMod() const
{
	return m_iGarrisonsOccupiedUnhapppinessMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGarrisonsOccupiedUnhapppinessMod(int iChange)
{
	m_iGarrisonsOccupiedUnhapppinessMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetBestRangedUnitSpawnSettle() const
{
	return m_iBestRangedUnitSpawnSettle;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeBestRangedUnitSpawnSettle(int iChange)
{
	m_iBestRangedUnitSpawnSettle += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetExtraMoves() const
{
	return m_iExtraMoves;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeExtraMoves(int iChange)
{
	m_iExtraMoves += iChange;
}
//	--------------------------------------------------------------------------------
bool CvPlayer::IsNoUnhappinessExpansion() const
{
	return GetNoUnhappinessExpansion() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNoUnhappinessExpansion() const
{
	return m_iNoUnhappinessExpansion;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNoUnhappinessExpansion(int iChange)
{
	if(iChange != 0)
	{
		m_iNoUnhappinessExpansion += iChange;
	}
}
//	--------------------------------------------------------------------------------
bool CvPlayer::IsNoUnhappyIsolation() const
{
	return GetNoUnhappyIsolation() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNoUnhappyIsolation() const
{
	return m_iNoUnhappyIsolation;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNoUnhappyIsolation(int iChange)
{
	if(iChange != 0)
	{
		m_iNoUnhappyIsolation += iChange;
	}
}
//	--------------------------------------------------------------------------------
bool CvPlayer::IsDoubleBorderGA() const
{
	return GetDoubleBorderGA() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetDoubleBorderGA() const
{
	return m_iDoubleBorderGA;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeDoubleBorderGA(int iChange)
{
	if(iChange != 0)
	{
		m_iDoubleBorderGA += iChange;
	}
}
//Increased influence from CS quests
//	--------------------------------------------------------------------------------
bool CvPlayer::IsIncreasedQuestInfluence() const
{
	return GetIncreasedQuestInfluence() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetIncreasedQuestInfluence() const
{
	return m_iIncreasedQuestInfluence;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeIncreasedQuestInfluence(int iChange)
{
	if(iChange != 0)
	{
		m_iIncreasedQuestInfluence += iChange;
	}
}
//Citadel Boost
//	--------------------------------------------------------------------------------
bool CvPlayer::IsCitadelBoost() const
{
	return GetCitadelBoost() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetCitadelBoost() const
{
	return m_iCitadelBoost;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeCitadelBoost(int iChange)
{
	if(iChange != 0)
	{
		m_iCitadelBoost += iChange;
	}
}

//Puppet Prod Boost
//	--------------------------------------------------------------------------------
bool CvPlayer::IsPuppetProdMod() const
{
	return GetPuppetProdMod() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetPuppetProdMod() const
{
	return m_iPuppetProdMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changePuppetProdMod(int iChange)
{
	if(iChange != 0)
	{
		m_iPuppetProdMod += iChange;
	}
}

//Occupied Prod Boost
//	--------------------------------------------------------------------------------
bool CvPlayer::IsOccupiedProdMod() const
{
	return GetOccupiedProdMod() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetOccupiedProdMod() const
{
	return m_iOccupiedProdMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeOccupiedProdMod(int iChange)
{
	if(iChange != 0)
	{
		m_iOccupiedProdMod += iChange;
	}
}

//Free Gold from Internal Trade Routes
//	--------------------------------------------------------------------------------
bool CvPlayer::IsGoldInternalTrade() const
{
	return GetGoldInternalTrade() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetGoldInternalTrade() const
{
	return m_iGoldInternalTrade;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGoldInternalTrade(int iChange)
{
	if(iChange != 0)
	{
		m_iGoldInternalTrade += iChange;
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetFreeWCVotes() const
{
	return m_iFreeWCVotes;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeFreeWCVotes(int iChange)
{
	m_iFreeWCVotes += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetInfluenceGPExpend() const
{
	return m_iInfluenceGPExpend;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeInfluenceGPExpend(int iChange)
{
	m_iInfluenceGPExpend += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetFreeTradeRoute() const
{
	return m_iFreeTradeRoute;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeFreeTradeRoute(int iChange)
{
	m_iFreeTradeRoute += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetFreeSpy() const
{
	return m_iFreeSpy;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeFreeSpy(int iChange)
{
	m_iFreeSpy += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetReligionDistance() const
{
	return m_iReligionDistance;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeReligionDistance(int iChange)
{
	m_iReligionDistance += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetPressureMod() const
{
	return m_iPressureMod;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changePressureMod(int iChange)
{
	m_iPressureMod += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getBuildingClassCultureChange(BuildingClassTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiBuildingClassCulture[eIndex];
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeBuildingClassCultureChange(BuildingClassTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	m_paiBuildingClassCulture.setAt(eIndex, m_paiBuildingClassCulture[eIndex] + iChange);
	CvAssert(getBuildingClassCultureChange(eIndex) >= 0);
}
#endif
#if defined(MOD_BALANCE_CORE_SPIES)
//	--------------------------------------------------------------------------------
int CvPlayer::GetAdvancedActionGold() const
{
	return m_iAdvancedActionGold;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeAdvancedActionGold(int iChange)
{
	m_iAdvancedActionGold += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::setAdvancedActionGold(int iChange)
{
	m_iAdvancedActionGold = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetAdvancedActionScience() const
{
	return m_iAdvancedActionScience;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeAdvancedActionScience(int iChange)
{
	m_iAdvancedActionScience += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::setAdvancedActionScience(int iChange)
{
	m_iAdvancedActionScience = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetAdvancedActionUnrest() const
{
	return m_iAdvancedActionUnrest;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeAdvancedActionUnrest(int iChange)
{
	m_iAdvancedActionUnrest += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::setAdvancedActionUnrest(int iChange)
{
	m_iAdvancedActionUnrest = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetAdvancedActionRebellion() const
{
	return m_iAdvancedActionRebellion;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeAdvancedActionRebellion(int iChange)
{
	m_iAdvancedActionRebellion += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::setAdvancedActionRebellion(int iChange)
{
	m_iAdvancedActionRebellion = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetAdvancedActionGP() const
{
	return m_iAdvancedActionGP;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeAdvancedActionGP(int iChange)
{
	m_iAdvancedActionGP += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::setAdvancedActionGP(int iChange)
{
	m_iAdvancedActionGP = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetAdvancedActionUnit() const
{
	return m_iAdvancedActionUnit;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeAdvancedActionUnit(int iChange)
{
	m_iAdvancedActionUnit += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::setAdvancedActionUnit(int iChange)
{
	m_iAdvancedActionUnit = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetAdvancedActionWonder() const
{
	return m_iAdvancedActionWonder;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeAdvancedActionWonder(int iChange)
{
	m_iAdvancedActionWonder += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::setAdvancedActionWonder(int iChange)
{
	m_iAdvancedActionWonder = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetAdvancedActionBuilding() const
{
	return m_iAdvancedActionBuilding;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeAdvancedActionBuilding(int iChange)
{
	m_iAdvancedActionBuilding += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::setAdvancedActionBuilding(int iChange)
{
	m_iAdvancedActionBuilding = iChange;
}
//	--------------------------------------------------------------------------------
bool CvPlayer::IsCannotFailSpies() const
{
	return GetCannotFailSpies() > 0;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetCannotFailSpies() const
{
	return m_iCannotFailSpies;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeCannotFailSpies(int iChange)
{
	m_iCannotFailSpies += iChange;
}
//	--------------------------------------------------------------------------------
/// Extra yield for a improvement this city is working?
int CvPlayer::GetImprovementExtraYield(ImprovementTypes eImprovement, YieldTypes eYield) const
{
	CvAssertMsg(eImprovement >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eImprovement < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eYield >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiImprovementYieldChange[eImprovement][eYield];
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeImprovementExtraYield(ImprovementTypes eImprovement, YieldTypes eYield, int iChange)
{
	CvAssertMsg(eImprovement >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eImprovement < GC.getNumImprovementInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eYield >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiImprovementYieldChange[eImprovement];
		yields[eYield] = (m_ppiImprovementYieldChange[eImprovement][eYield] + iChange);
		m_ppiImprovementYieldChange[eImprovement] = yields;
		CvAssert(GetImprovementExtraYield(eImprovement, eYield) >= 0);

		updateYield();
	}
}
#endif
#if defined(MOD_BALANCE_CORE_BUILDING_INVESTMENTS)
//	--------------------------------------------------------------------------------
int CvPlayer::GetInvestmentModifier() const
{
	return m_iInvestmentModifier;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeInvestmentModifier(int iChange)
{
	m_iInvestmentModifier += iChange;
}
int CvPlayer::GetScalingNationalPopulationRequrired(BuildingTypes eBuilding) const
{
	if(eBuilding != NO_BUILDING)
	{
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
		if(pkBuildingInfo)
		{
			int iNationalPop = pkBuildingInfo->GetNationalPopulationRequired();
			if(iNationalPop > 0)
			{
				int iScaler = (getNumCities() * pkBuildingInfo->GetNumCityCostMod());
				iNationalPop *= (100 + iScaler);
				iNationalPop /= 100;
				//If OCC... 1/3 the value, as three cities is 'roughly' average for a game.
				if(GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE))
				{
					iNationalPop /= 3;
				}
				return iNationalPop;
			}
		}
	}
	return 0;
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::getCapitalYieldRateModifier(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiCapitalYieldRateModifier[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeCapitalYieldRateModifier(YieldTypes eIndex, int iChange)
{
	CvCity* pCapitalCity;

	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiCapitalYieldRateModifier.setAt(eIndex, m_aiCapitalYieldRateModifier[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		pCapitalCity = getCapitalCity();
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getExtraYieldThreshold(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiExtraYieldThreshold[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::updateExtraYieldThreshold(YieldTypes eIndex)
{
	int iBestValue;

	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	iBestValue = GetPlayerTraits()->GetExtraYieldThreshold(eIndex);

	if(getExtraYieldThreshold(eIndex) != iBestValue)
	{
		m_aiExtraYieldThreshold.setAt(eIndex, iBestValue);
		CvAssert(getExtraYieldThreshold(eIndex) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetScience() const
{
	return GetScienceTimes100() / 100;
}

//	--------------------------------------------------------------------------------
#if defined(MOD_BALANCE_CORE)
int CvPlayer::GetScienceTimes100(bool bIgnoreHappiness) const
#else
int CvPlayer::GetScienceTimes100() const
#endif
{
	// If we're in anarchy, then no Research is done!
	if(IsAnarchy())
		return 0;

	int iValue = 0;

	// Science from our Cities
	iValue += GetScienceFromCitiesTimes100(false);

#if defined(MOD_API_UNIFIED_YIELDS)
	// Science from religion
	iValue += GetYieldPerTurnFromReligion(YIELD_SCIENCE) * 100;
#endif

#if defined(MOD_API_UNIFIED_YIELDS)
	// Trait bonus which adds Science for trade partners? 
	iValue += GetYieldPerTurnFromTraits(YIELD_SCIENCE) * 100;
#endif

	// Science from other players!
#if defined(MOD_BALANCE_CORE)
	if (!isMinorCiv())
		//avoid pointless recursion
		iValue += GetScienceFromOtherPlayersTimes100();
#else
	iValue += GetScienceFromOtherPlayersTimes100();
#endif

	// Happiness converted to Science? (Policies, etc.)
	iValue += GetScienceFromHappinessTimes100();

	// Research Agreement bonuses
	iValue += GetScienceFromResearchAgreementsTimes100();

	// If we have a negative Treasury + GPT then it gets removed from Science
	iValue += GetScienceFromBudgetDeficitTimes100();

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (MOD_DIPLOMACY_CIV4_FEATURES) {
		// We're a vassal of someone, we get x% of his science
		iValue += (GetYieldPerTurnFromVassals(YIELD_SCIENCE) * 100);
	}
#endif
#if defined(MOD_BALANCE_CORE)
	if(MOD_BALANCE_CORE_MINOR_CIV_GIFT)
	{
		iValue += GetSciencePerTurnFromMinorCivs() * 100;
	}
#endif
#if defined(MOD_DIPLOMACY_CITYSTATES)
	if (MOD_DIPLOMACY_CITYSTATES) {
		//Science Funding Rate Boost
		if(IsLeagueAid())
		{
			int iFreeScience = GetScienceFromCitiesTimes100(false) * GetScienceRateFromLeagueAid();
			iFreeScience /= 100;

			iValue += iFreeScience;
		}
	}
#endif

#if defined(MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	//Mod for national unhappiness
	if(MOD_BALANCE_CORE_HAPPINESS_NATIONAL && !bIgnoreHappiness)
	{
		iValue += GetYieldPerTurnFromHappiness(YIELD_SCIENCE, iValue);
	}
#endif
#if defined(MOD_BALANCE_CORE)
	return max(iValue, 1);
#else
	return max(iValue, 0);
#endif
}

//	--------------------------------------------------------------------------------
/// Where is our Science coming from?
int CvPlayer::GetScienceFromCitiesTimes100(bool bIgnoreTrade) const
{
	int iScience = 0;

	const CvCity* pLoopCity;

	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iScience += pLoopCity->getYieldRateTimes100(YIELD_SCIENCE, bIgnoreTrade);
	}

	return iScience;
}

//	--------------------------------------------------------------------------------
/// Where is our Science coming from?
int CvPlayer::GetScienceFromOtherPlayersTimes100() const
{
	int iScience = 0;

	PlayerTypes ePlayer;
	int iScienceFromPlayer;
	for(int iPlayerLoop = MAX_MAJOR_CIVS; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		ePlayer = (PlayerTypes) iPlayerLoop;

		iScienceFromPlayer = 0;

		if(IsGetsScienceFromPlayer(ePlayer))
		{
			iScienceFromPlayer = GET_PLAYER(ePlayer).GetMinorCivAI()->GetScienceFriendshipBonusTimes100();

			iScience += iScienceFromPlayer;
		}
	}
	return iScience;
}

//	--------------------------------------------------------------------------------
/// Where is our Science coming from?
int CvPlayer::GetScienceFromHappinessTimes100() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS))
	{
		return 0;
	}

	int iScience = 0;

	if(getHappinessToScience() != 0)
	{
		if(GetExcessHappiness() >= 0)
		{
			int iFreeScience = GetScienceFromCitiesTimes100(false) * getHappinessToScience();
			iFreeScience /= 100;

			iScience += iFreeScience;
		}
	}

	return iScience;
}

//	--------------------------------------------------------------------------------
/// Where is our Science coming from?
int CvPlayer::GetScienceFromResearchAgreementsTimes100() const
{
	int iScience = GetScienceFromCitiesTimes100(false);

	int iResearchAgreementBonus = /*0*/ GC.getRESEARCH_AGREEMENT_MOD() * GET_TEAM(getTeam()).GetTotalNumResearchAgreements(); // RAs currently do not have this effect
	iScience *= iResearchAgreementBonus;	// Apply to the % to the current value
	iScience /= 100;

	return iScience;
}

//	--------------------------------------------------------------------------------
/// Where is our Science coming from?
int CvPlayer::GetScienceFromBudgetDeficitTimes100() const
{
	int iScience = 0;
	
	int iMyNum = 0;
	if (iScience > 0)
	{
		iMyNum = -1;
	}


	int iGoldPerTurn = calculateGoldRateTimes100();
	if(GetTreasury()->GetGoldTimes100() + iGoldPerTurn < 0)
	{
		iScience += (GetTreasury()->GetGoldTimes100() + iGoldPerTurn);
	}

	return iScience;
}

//	--------------------------------------------------------------------------------
/// What is the sum of science yield (not counting Research Agreements or Great Scientist bonuses) from the previous N turns?
/// NOTE: This uses the data tracked in recording a replay, so if replays are disabled in the future then this must change!
int CvPlayer::GetScienceYieldFromPreviousTurns(int iGameTurn, int iNumPreviousTurnsToCount)
{
	// Beakers per turn yield is tracked in replay data, so use that
	int iSum = 0;
	for (int iI = 0; iI < iNumPreviousTurnsToCount; iI++)
	{
		int iTurn = iGameTurn - iI;
		if (iTurn < 0)
		{
			break;
		}

		int iTurnScience = getReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_SCIENCEPERTURN"), iTurn);
		if (iTurnScience >= 0)
		{
			iSum += iTurnScience;
		}
		else if (iTurnScience == -1) // No data for this turn (ex. late era start)
		{
			iSum += (3 * GetScience());
		}
	}

	return iSum;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsGetsScienceFromPlayer(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= MAX_MAJOR_CIVS, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");

	// Might have global modifier
	if(IsMinorScienceAllies() && GET_PLAYER(ePlayer).GetMinorCivAI()->IsAllies(GetID()))
	{
		return true;
	}

	return m_pabGetsScienceFromPlayer[ePlayer];
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetGetsScienceFromPlayer(PlayerTypes ePlayer, bool bNewValue)
{
	CvAssertMsg(ePlayer >= MAX_MAJOR_CIVS, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(bNewValue != m_pabGetsScienceFromPlayer[ePlayer])
	{
		m_pabGetsScienceFromPlayer.setAt(ePlayer, bNewValue);
	}
}

//	--------------------------------------------------------------------------------
/// Player spending too much cash?
void CvPlayer::DoDeficit()
{
	int iNumMilitaryUnits = 0;

	CvUnit* pLoopUnit;
	int iLoop;
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->IsCombatUnit())
			iNumMilitaryUnits++;
	}

	// If the player has more units than cities, start disbanding things
#if defined(MOD_BALANCE_CORE)
	if(isMinorCiv())
	{
		return;
	}
	if(iNumMilitaryUnits > max(5, getNumCities()))
#else
	if(iNumMilitaryUnits > getNumCities())
#endif
	{
		if(GC.getGame().getJonRandNum(100, "Disband rand") < 50)
		{
			UnitHandle pLandUnit;
			UnitHandle pNavalUnit;
			int iLandScore = MAX_INT;
			int iNavalScore = MAX_INT;

			// Look for obsolete land units if in deficit or have sufficient units
			if(GetMilitaryAI()->GetLandDefenseState() <= DEFENSE_STATE_NEUTRAL)
			{
				pLandUnit = GetMilitaryAI()->FindBestUnitToScrap(true /*bLand*/, true /*bDeficitForcedDisband*/, iLandScore);
			}

			// Look for obsolete naval units if in deficit or have sufficient units
			if(GetMilitaryAI()->GetNavalDefenseState() <= DEFENSE_STATE_NEUTRAL)
			{
				pNavalUnit = GetMilitaryAI()->FindBestUnitToScrap(false/*bNaval*/, true /*bDeficitForcedDisband*/, iNavalScore);
			}

			if(iLandScore < MAX_INT && (GetMilitaryAI()->GetLandDefenseState() <= GetMilitaryAI()->GetNavalDefenseState() || iLandScore <= iNavalScore))
			{
				if(pLandUnit)
				{
					CvNotifications* pNotifications = GetNotifications();
					if(pNotifications)
					{
						Localization::String locString = Localization::Lookup("TXT_KEY_NTFN_UNIT_DISBANDED");
						Localization::String locSummary = Localization::Lookup("TXT_KEY_NTFN_UNIT_DISBANDED_S");
						pNotifications->Add(NOTIFICATION_UNIT_DIED, locString.toUTF8(), locSummary.toUTF8(), pLandUnit->getX(), pLandUnit->getY(), pLandUnit->getUnitType(), GetID());
					}

					pLandUnit->scrap();
					GetMilitaryAI()->LogDeficitScrapUnit(pLandUnit);
				}
			}
			else if(iNavalScore < MAX_INT)
			{
				if(pNavalUnit)
				{
					CvNotifications* pNotifications = GetNotifications();
					if(pNotifications)
					{
						Localization::String locString = Localization::Lookup("TXT_KEY_NTFN_UNIT_DISBANDED");
						Localization::String locSummary = Localization::Lookup("TXT_KEY_NTFN_UNIT_DISBANDED_S");
						pNotifications->Add(NOTIFICATION_UNIT_DIED, locString.toUTF8(), locSummary.toUTF8(), pNavalUnit->getX(), pNavalUnit->getY(), pNavalUnit->getUnitType(), GetID());
					}

					pNavalUnit->scrap();
					GetMilitaryAI()->LogDeficitScrapUnit(pNavalUnit);
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getSpecialistExtraYield(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiSpecialistExtraYield[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeSpecialistExtraYield(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		// Have to handle Specialists yield update manually here because the "updateYield()" below only accounts for land Yield!

		CvCity* pLoopCity;
		int iLoop;
		int iNumTotalSpecialists = 0;

		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			for(int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
			{
				iNumTotalSpecialists = pLoopCity->GetCityCitizens()->GetSpecialistCount((SpecialistTypes) iSpecialistLoop);
//				iNumTotalSpecialists = pLoopCity->getSpecialistCount((SpecialistTypes) iSpecialistLoop) + pLoopCity->getFreeSpecialistCount((SpecialistTypes) iSpecialistLoop);

				for(int iTempLoop = 0; iTempLoop < iNumTotalSpecialists; iTempLoop++)
				{
					pLoopCity->processSpecialist((SpecialistTypes) iSpecialistLoop, -1);
				}
			}
		}

		m_aiSpecialistExtraYield.setAt(eIndex ,m_aiSpecialistExtraYield[eIndex] + iChange);
		CvAssert(getSpecialistExtraYield(eIndex) >= 0);

		updateYield();

		// Reprocess Specialist AFTER yield change
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			for(int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
			{
				iNumTotalSpecialists = pLoopCity->GetCityCitizens()->GetSpecialistCount((SpecialistTypes) iSpecialistLoop);
//				iNumTotalSpecialists = pLoopCity->getSpecialistCount((SpecialistTypes) iSpecialistLoop) + pLoopCity->getFreeSpecialistCount((SpecialistTypes) iSpecialistLoop);

				for(int iTempLoop = 0; iTempLoop < iNumTotalSpecialists; iTempLoop++)
				{
					pLoopCity->processSpecialist((SpecialistTypes) iSpecialistLoop, 1);
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Returns how "close" we are to another player (useful for diplomacy, war planning, etc.)
PlayerProximityTypes CvPlayer::GetProximityToPlayer(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePlayer < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
	return (PlayerProximityTypes) m_aiProximityToPlayer[ePlayer];
}

//	--------------------------------------------------------------------------------
/// Sets how "close" we are to another player (useful for diplomacy, war planning, etc.)
void CvPlayer::SetProximityToPlayer(PlayerTypes ePlayer, PlayerProximityTypes eProximity)
{
	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePlayer < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");

	CvAssertMsg(GetID() != ePlayer, "Trying to calculate proximity to oneself. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	CvAssertMsg(eProximity >= NO_PLAYER_PROXIMITY, "eIndex is expected to be non-negative (invalid Index)");	// NO_PLAYER_PROXIMITY is valid because some players may have no Cities (e.g. on the first turn)
	CvAssertMsg(eProximity < NUM_PLAYER_PROXIMITIES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if((GC.getLogging() && GC.getAILogging()))
	{
		if(eProximity != m_aiProximityToPlayer[ePlayer])
		{
			// Open the log file
			CvString strFileName = "PlayerProximityLog.csv";
			FILogFile* pLog;
			pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
			CvString strLog, strTemp;

			CvString strPlayerName;
			strPlayerName = getCivilizationShortDescription();
			strLog += strPlayerName;
			strLog += ",";

			strTemp.Format("%d,", GC.getGame().getGameTurn()); // turn
			strLog += strTemp;
			CvString strOtherPlayerName;
			strOtherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
			strLog += strOtherPlayerName;
			strLog += ",";

			switch(m_aiProximityToPlayer[ePlayer])
			{
			case NO_PLAYER_PROXIMITY:
				strLog += "No player proximity,";
				break;
			case PLAYER_PROXIMITY_NEIGHBORS:
				strLog += "Neighbors,";
				break;
			case PLAYER_PROXIMITY_CLOSE:
				strLog += "Close,";
				break;
			case PLAYER_PROXIMITY_FAR:
				strLog += "Far,";
				break;
			case PLAYER_PROXIMITY_DISTANT:
				strLog += "Distant,";
				break;
			}

			strLog += "-->,";

			switch(eProximity)
			{
			case NO_PLAYER_PROXIMITY:
				strLog += "No player proximity,";
				break;
			case PLAYER_PROXIMITY_NEIGHBORS:
				strLog += "Neighbors,";
				break;
			case PLAYER_PROXIMITY_CLOSE:
				strLog += "Close,";
				break;
			case PLAYER_PROXIMITY_FAR:
				strLog += "Far,";
				break;
			case PLAYER_PROXIMITY_DISTANT:
				strLog += "Distant,";
				break;
			}

			pLog->Msg(strLog);
		}
	}

	m_aiProximityToPlayer.setAt(ePlayer, eProximity);
}

//	--------------------------------------------------------------------------------
/// Figure out how "close" we are to another player (useful for diplomacy, war planning, etc.)
void CvPlayer::DoUpdateProximityToPlayer(PlayerTypes ePlayer)
{
	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePlayer < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");

#if !defined(MOD_BALANCE_CORE)
	int iSmallestDistanceBetweenCities = GC.getMap().numPlots();
#endif
	int iAverageDistanceBetweenCities = 0;
#if !defined(MOD_BALANCE_CORE)
	int iNumCityConnections = 0;
#endif

#if !defined(MOD_BALANCE_CORE)
	CvCity* pLoopMyCity;
	CvCity* pLoopTheirCity;

	int iMyCityLoop;
	int iTheirCityLoop;

	int iTempDistance;
#endif

#if defined(MOD_BALANCE_CORE)
	if(GetCenterOfMassEmpire() != NULL && GET_PLAYER(ePlayer).GetCenterOfMassEmpire() != NULL)
	{
		iAverageDistanceBetweenCities = plotDistance(GetCenterOfMassEmpire()->getX(), GetCenterOfMassEmpire()->getY(), GET_PLAYER(ePlayer).GetCenterOfMassEmpire()->getX(), GET_PLAYER(ePlayer).GetCenterOfMassEmpire()->getY());
	}
	else
	{
		SetProximityToPlayer(ePlayer, NO_PLAYER_PROXIMITY);
		return;
	}

	// Seed this value with something reasonable to start.  This will be the value assigned if one player has 0 Cities.
	PlayerProximityTypes eProximity = NO_PLAYER_PROXIMITY;

	if(iAverageDistanceBetweenCities != 0)
	{
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
		if(GC.getMap().GetAIMapHint() & ciMapHint_Naval)
		{
			iAverageDistanceBetweenCities *= 2;
			iAverageDistanceBetweenCities /= 3;
		}
		//If small empire (CS, OCC, etc.), increase the value.
		if(GET_PLAYER(ePlayer).getNumCities() <= 1)
		{
			iAverageDistanceBetweenCities *= 3;
			iAverageDistanceBetweenCities /= 2;
		}
#endif

		// Closest Cities must be within a certain range
		if(iAverageDistanceBetweenCities <= /*7*/ GC.getPROXIMITY_NEIGHBORS_CLOSEST_CITY_REQUIREMENT())
		{
			eProximity = PLAYER_PROXIMITY_NEIGHBORS;
		}
		// If our closest Cities are pretty near one another  and our average is less than the max then we can be considered CLOSE (will also look at City average below)
		else if(iAverageDistanceBetweenCities <= /*10*/ GC.getPROXIMITY_CLOSE_CLOSEST_CITY_POSSIBILITY())
		{
			eProximity = PLAYER_PROXIMITY_CLOSE;
		}
		// If our closest Cities are pretty near one another  and our average is less than the max then we can be considered CLOSE (will also look at City average below)
		else if(iAverageDistanceBetweenCities <= /*14*/ GC.getPROXIMITY_CLOSE_CLOSEST_CITY_POSSIBILITY())
		{
			eProximity = PLAYER_PROXIMITY_CLOSE;
		}
		// If our closest Cities are pretty near one another  and our average is less than the max then we can be considered CLOSE (will also look at City average below)
		else if(iAverageDistanceBetweenCities <= /*20*/ GC.getPROXIMITY_FAR_DISTANCE_MAX())
		{
			eProximity = PLAYER_PROXIMITY_FAR;
		}
		else
		{
			eProximity = PLAYER_PROXIMITY_DISTANT;
		}
	}

	int iNumMajorsLeft = GC.getGame().countMajorCivsAlive();

	// Only two players left, the farthest we can be considered is "Close"
	if(iNumMajorsLeft == 2)
		eProximity = max(eProximity, PLAYER_PROXIMITY_CLOSE);

	// Four or fewer players left, the farthest we can be considered is "Far"
	else if(iNumMajorsLeft <= 4)
		eProximity = max(eProximity, PLAYER_PROXIMITY_FAR);

	SetProximityToPlayer(ePlayer, eProximity);
#else
	// Loop through all of MY Cities
	for(pLoopMyCity = firstCity(&iMyCityLoop); pLoopMyCity != NULL; pLoopMyCity = nextCity(&iMyCityLoop))
	{
		// Loop through all of THEIR Cities
		for(pLoopTheirCity = GET_PLAYER(ePlayer).firstCity(&iTheirCityLoop); pLoopTheirCity != NULL; pLoopTheirCity = GET_PLAYER(ePlayer).nextCity(&iTheirCityLoop))
		{
			iNumCityConnections++;

			// Different area or couldn't find path - get distance the hard way
			//if (!bPathFinderSuccess)
			{
				iTempDistance = plotDistance(pLoopMyCity->getX(), pLoopMyCity->getY(), pLoopTheirCity->getX(), pLoopTheirCity->getY());
			}

			// Smallest distance between any two Cities
			if(iTempDistance < iSmallestDistanceBetweenCities)
			{
				iSmallestDistanceBetweenCities = iTempDistance;
			}

			iAverageDistanceBetweenCities += iTempDistance;
		}
	}

	// Seed this value with something reasonable to start.  This will be the value assigned if one player has 0 Cities.
	PlayerProximityTypes eProximity = NO_PLAYER_PROXIMITY;

	if(iNumCityConnections > 0)
	{
		iAverageDistanceBetweenCities /= iNumCityConnections;

#if defined(MOD_BALANCE_CORE_DIPLOMACY)
		if(GC.getMap().GetAIMapHint() & ciMapHint_Naval)
		{
			iSmallestDistanceBetweenCities /= 2;
		}
#endif

		// Closest Cities must be within a certain range
		if(iSmallestDistanceBetweenCities <= /*7*/ GC.getPROXIMITY_NEIGHBORS_CLOSEST_CITY_REQUIREMENT())
		{
			eProximity = PLAYER_PROXIMITY_NEIGHBORS;
		}
		// If our closest Cities are pretty near one another  and our average is less than the max then we can be considered CLOSE (will also look at City average below)
		else if(iSmallestDistanceBetweenCities <= /*11*/ GC.getPROXIMITY_CLOSE_CLOSEST_CITY_POSSIBILITY())
		{
			eProximity = PLAYER_PROXIMITY_CLOSE;
		}

		// If we've already set ourselves as Neighbors, no need to undo what we just did
		if(eProximity != PLAYER_PROXIMITY_NEIGHBORS)
		{
			int iMapFactor = (GC.getMap().getGridWidth() + GC.getMap().getGridHeight()) / 2;

			// Normally base distance on map size, but cap it at a certain point
			// Close can't be so big that it sits on Far's turf
			int iCloseDistance = iMapFactor* /*25*/ GC.getPROXIMITY_CLOSE_DISTANCE_MAP_MULTIPLIER() / 100;
			if(iCloseDistance > /*20*/ GC.getPROXIMITY_CLOSE_DISTANCE_MAX())
			{
				iCloseDistance = /*20*/ GC.getPROXIMITY_CLOSE_DISTANCE_MAX();
			}
			// Close also can't be so small that it sits on Neighbor's turf
			else if(iCloseDistance < /*10*/ GC.getPROXIMITY_CLOSE_DISTANCE_MIN())
			{
				iCloseDistance = /*10*/ GC.getPROXIMITY_CLOSE_DISTANCE_MIN();
			}

			// Far can't be so big that it sits on Distant's turf
			int iFarDistance = iMapFactor* /*45*/ GC.getPROXIMITY_FAR_DISTANCE_MAP_MULTIPLIER() / 100;
			if(iFarDistance > /*50*/ GC.getPROXIMITY_FAR_DISTANCE_MAX())
			{
				iFarDistance = /*50*/ GC.getPROXIMITY_FAR_DISTANCE_MAX();
			}
			// Far also can't be so small that it sits on Close's turf
			else if(iFarDistance < /*20*/ GC.getPROXIMITY_FAR_DISTANCE_MIN())
			{
				iFarDistance = /*20*/ GC.getPROXIMITY_FAR_DISTANCE_MIN();
			}

			// Close
			if(eProximity == PLAYER_PROXIMITY_CLOSE && iAverageDistanceBetweenCities <= iCloseDistance)
			{
				eProximity = PLAYER_PROXIMITY_CLOSE;
			}
			// Far
			else if(iAverageDistanceBetweenCities <= iFarDistance)
			{
				eProximity = PLAYER_PROXIMITY_FAR;
			}
			// Distant
			else
			{
				eProximity = PLAYER_PROXIMITY_DISTANT;
			}
		}

		// Players NOT on the same landmass - bump up PROXIMITY by one level (unless we're already distant or on a water map)
		if(eProximity != PLAYER_PROXIMITY_DISTANT && !(GC.getMap().GetAIMapHint() & ciMapHint_Naval))
		{
			// Both players have capitals, so we can check their areas to see if they're separated by water
			if(getCapitalCity() != NULL && GET_PLAYER(ePlayer).getCapitalCity() != NULL)
			{
				if(getCapitalCity()->getArea() != GET_PLAYER(ePlayer).getCapitalCity()->getArea())
				{
					eProximity = PlayerProximityTypes(eProximity - 1);
				}
			}
		}
	}

	int iNumMajorsLeft = GC.getGame().countMajorCivsAlive();

	// Only two players left, the farthest we can be considered is "Close"
	if(iNumMajorsLeft == 2)
		eProximity = max(eProximity, PLAYER_PROXIMITY_CLOSE);

	// Four or fewer players left, the farthest we can be considered is "Far"
	else if(iNumMajorsLeft <= 4)
		eProximity = max(eProximity, PLAYER_PROXIMITY_FAR);

	SetProximityToPlayer(ePlayer, eProximity);
#endif
}

//	--------------------------------------------------------------------------------
/// Update the beakers accumulated during the term of RAs
void CvPlayer::UpdateResearchAgreements(int iValue)
{
	PlayerTypes ePlayerLoop;
	TeamTypes eTeamLoop;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		ePlayerLoop = (PlayerTypes) iPlayerLoop;
		eTeamLoop = GET_PLAYER(ePlayerLoop).getTeam();
		if(ePlayerLoop == GetID())
			continue;
		if(eTeamLoop == getTeam())
			continue;

		if(GET_TEAM(getTeam()).IsHasResearchAgreement(eTeamLoop))
		{
			// Note that this increases the counter for all players on the other team,
			// even though the RA was only made with one of them.  This is because
			// RAs, though made with players, are restricted and tracked by 1 per team.
			// This must change if future implementations allow for multiple RAs to be
			// made with a particular team.
			ChangeResearchAgreementCounter(ePlayerLoop, iValue);
		}
		else if(GetResearchAgreementCounter(ePlayerLoop) != 0)
		{
			SetResearchAgreementCounter(ePlayerLoop, 0);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Get the beakers accumulated during the RA with a player
int CvPlayer::GetResearchAgreementCounter(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePlayer < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiResearchAgreementCounter[ePlayer];
}

//	--------------------------------------------------------------------------------
/// Set the beakers accumulated during the RA with a player
void CvPlayer::SetResearchAgreementCounter(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePlayer < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");

	CvAssertMsg(GetID() != ePlayer, "Trying to make a RA Agreement with oneself. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_aiResearchAgreementCounter.setAt(ePlayer, iValue);
}

//	--------------------------------------------------------------------------------
/// Change the beakers accumulated during the RA with a player
void CvPlayer::ChangeResearchAgreementCounter(PlayerTypes ePlayer, int iChange)
{
	SetResearchAgreementCounter(ePlayer, GetResearchAgreementCounter(ePlayer) + iChange);
}

//	--------------------------------------------------------------------------------
/// Someone sent us a present!
void CvPlayer::DoCivilianReturnLogic(bool bReturn, PlayerTypes eToPlayer, int iUnitID)
{
	CvUnit* pUnit = getUnit(iUnitID);
	if(!pUnit)
	{
		return;
	}

	CvPlot* pPlot = pUnit->plot();
	if(!pPlot)
	{
		return;
	}

	// Kill any units this guy is transporting
	IDInfo* pUnitNode = pPlot->headUnitNode();
	while(pUnitNode != NULL)
	{
		CvUnit* pLoopUnit = ::getUnit(*pUnitNode);
		pUnitNode = pPlot->nextUnitNode(pUnitNode);

		if(NULL != pLoopUnit && pLoopUnit->getTransportUnit() == pUnit)
			pLoopUnit->kill(true);
	}

	// What are the details for the new unit?
	UnitTypes eNewUnitType = pUnit->getUnitType();

	if(!bReturn)
		eNewUnitType = pUnit->getCaptureUnitType(getCivilizationType());

	int iX = pUnit->getX();
	int iY = pUnit->getY();

	// Returns to the previous owner
	if(bReturn)
	{
		pUnit->kill(true);
		CvUnit* pNewUnit = GET_PLAYER(eToPlayer).initUnit(eNewUnitType, iX, iY);
		CvAssert(pNewUnit != NULL);
		if (pNewUnit)
		{
			if (!pNewUnit->jumpToNearestValidPlot())
				pNewUnit->kill(false);	// Could not find a spot!
		}

		// Returned to a city-state
		if(GET_PLAYER(eToPlayer).isMinorCiv())
		{
			int iInfluence = /*45*/ GC.getRETURN_CIVILIAN_FRIENDSHIP();
			GET_PLAYER(eToPlayer).GetMinorCivAI()->ChangeFriendshipWithMajor(GetID(), iInfluence);
		}
		// Returned to major power
		else if(!GET_PLAYER(eToPlayer).isHuman())
		{
			GET_PLAYER(eToPlayer).GetDiplomacyAI()->ChangeNumCiviliansReturnedToMe(GetID(), 1);
		}
#if defined(MOD_BALANCE_CORE)
		else if(GET_PLAYER(eToPlayer).isHuman() && pNewUnit)
		{
			CvNotifications* pNotification = GET_PLAYER(eToPlayer).GetNotifications();
			if(pNotification)
			{
				Localization::String localizedText = Localization::Lookup("TXT_KEY_NOTIFICATION_UNIT_RETURNED_AI");
				localizedText << getNameKey() << pNewUnit->getUnitInfo().GetTextKey();
				Localization::String localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_UNIT_RETURNED_AI_SUMMARY");
				localizedSummary << getNameKey() << pNewUnit->getUnitInfo().GetTextKey();
				pNotification->Add(NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER, localizedText.toUTF8(), localizedSummary.toUTF8(), pNewUnit->getX(), pNewUnit->getY(), pNewUnit->getUnitType());
			}
		}
#endif
	}
	// Kept for oneself
	else
	{
		// Make a new unit because the kind we should capture doesn't match (e.g. Settler to Worker)
		if(eNewUnitType != pUnit->getUnitType())
		{
#if defined(MOD_GLOBAL_GRATEFUL_SETTLERS)
			// In OCC games, all captured settlers are converted
			if ((pUnit->isFound() || pUnit->IsFoundAbroad()) && MOD_GLOBAL_GRATEFUL_SETTLERS && !(GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && isHuman())) {
				int iDefectProb = gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_PERCENT", 20);
				int iPercent = 0;

				// Approach is very important
				switch (GetDiplomacyAI()->GetMajorCivApproach(eToPlayer, false)) {
					case MAJOR_CIV_APPROACH_WAR:
						iPercent = iDefectProb * gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_WAR_MULTIPLIER", 0) / gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DIVISOR", 8);
						break;
					case MAJOR_CIV_APPROACH_HOSTILE:
						iPercent = iDefectProb * gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_HOSTILE_MULTIPLIER", 2) / gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DIVISOR", 8);
						break;
					case MAJOR_CIV_APPROACH_GUARDED:
						iPercent = iDefectProb * gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_GUARDED_MULTIPLIER", 4) / gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DIVISOR", 8);
						break;
					case MAJOR_CIV_APPROACH_DECEPTIVE:
						iPercent = iDefectProb * gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DECEPTIVE_MULTIPLIER", 4) / gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DIVISOR", 8);
						break;
					case MAJOR_CIV_APPROACH_AFRAID:
						iPercent = iDefectProb * gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_AFRAID_MULTIPLIER", 4) / gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DIVISOR", 8);
						break;
					case MAJOR_CIV_APPROACH_NEUTRAL:
						iPercent = iDefectProb * gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_NEUTRAL_MULTIPLIER", 6) / gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DIVISOR", 8);
						break;
					case MAJOR_CIV_APPROACH_FRIENDLY:
						iPercent = iDefectProb * gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_FRIENDLY_MULTIPLIER", 10) / gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DIVISOR", 8);
						break;
					default:
						break;
				}

				// Opinion also matters
				switch (GetDiplomacyAI()->GetMajorCivOpinion(eToPlayer)) {
					case MAJOR_CIV_OPINION_ALLY:
						iPercent += iDefectProb * 5 / 4;
						break;
					case MAJOR_CIV_OPINION_FRIEND:
						iPercent += iDefectProb * 1;
						break;
					case MAJOR_CIV_OPINION_FAVORABLE:
						iPercent += iDefectProb * 3 / 4;
						break;
					case MAJOR_CIV_OPINION_NEUTRAL:
						iPercent += iDefectProb * 1 / 2;
						break;
					case MAJOR_CIV_OPINION_COMPETITOR:
						iPercent += iDefectProb * 0;
						break;
					case MAJOR_CIV_OPINION_ENEMY:
						iPercent += iDefectProb * -1;
						break;
					case MAJOR_CIV_OPINION_UNFORGIVABLE:
						iPercent += iDefectProb * -1;
						break;
					default:
						break;
				}

				// Limit the outcome
				iPercent = std::min(50, std::max(5, iPercent));

				// Our masters sent us into a war-zone, we'll stick where we are!
				if (GetDiplomacyAI()->GetNumOurEnemiesPlayerAtWarWith(eToPlayer) > 0) {
					iPercent *= 2;
				}

				// If they will found the second city (ie kudos) multiply by 1.5
				if (getNumCities() == 1) {
					iPercent *= 3;
					iPercent /= 2;
				}

#if defined(MOD_GLOBAL_RELIGIOUS_SETTLERS)
				if (MOD_GLOBAL_RELIGIOUS_SETTLERS) {
					ReligionTypes eReligion = pUnit->GetReligionData()->GetReligion();

					if (eReligion > RELIGION_PANTHEON) {
						const CvReligion* pkReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, NO_PLAYER);

						if (pkReligion) {
							CvPlot* pPlot = GC.getMap().plot(pkReligion->m_iHolyCityX, pkReligion->m_iHolyCityY);

							if (pPlot) {
								CvCity* pHolyCity = pPlot->getPlotCity();

								if (pHolyCity->getOriginalOwner() == GetID()) {
									// Bonus if the liberator founded their holy city
									iPercent += gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_HOLYCITY_FOUNDER", 20);
								} else if (pHolyCity->getOwner() == GetID()) {
									// Serious bad karma if the liberator has captured their holy city
									iPercent += gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_HOLYCITY_OCCUPIER", -20);
								}
							}
						}
					}
				}
#endif

				// Limit the outcome
				iPercent = std::min(80, iPercent);
				
				// Use the popularity difference between the players to skew the probability
				int iSmileRatio = (GetExcessHappiness() * 100) / (std::max(0, GET_PLAYER(eToPlayer).GetExcessHappiness()) + 10);
				iPercent = iPercent * std::min(150, std::max(75, iSmileRatio)) / 100;
				CUSTOMLOG("Settler defect percent: %i (Approach=%i, Opinion=%i)", iPercent, GetDiplomacyAI()->GetMajorCivApproach(eToPlayer, false), GetDiplomacyAI()->GetMajorCivOpinion(eToPlayer));

				if (GC.getGame().getJonRandNum(100, "Settlers defect") < iPercent) {
					if (GC.getGame().getActivePlayer() == GetID()) {
						CvPopupInfo kPopupInfo(BUTTONPOPUP_TEXT);
						strcpy_s(kPopupInfo.szText, "TXT_KEY_GRATEFUL_SETTLERS");
						GC.GetEngineUserInterface()->AddPopup(kPopupInfo);
					}
				} else {
					pUnit->kill(true);
					CvUnit* pNewUnit = initUnit(eNewUnitType, iX, iY);
					CvAssert(pNewUnit != NULL);
					if (pNewUnit)
						pNewUnit->finishMoves();
				}
			} else {
#endif
				pUnit->kill(true);
				CvUnit* pNewUnit = initUnit(eNewUnitType, iX, iY);
				CvAssert(pNewUnit != NULL);
				if (pNewUnit)
					pNewUnit->finishMoves();
#if defined(MOD_GLOBAL_GRATEFUL_SETTLERS)
			}
#endif
		}
	}
}

//	--------------------------------------------------------------------------------
/// Units in the ether coming towards us?
void CvPlayer::DoIncomingUnits()
{
	AI_PERF_FORMAT("AI-perf.csv", ("CvPlayer::DoIncomingUnits, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), getCivilizationShortDescription()) );
	for(int iLoop = 0; iLoop < MAX_PLAYERS; iLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iLoop;
		CvAssertMsg(GetIncomingUnitCountdown(eLoopPlayer) >= -1, "Incoming Unit countdown is an invalid value. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
		if(GetIncomingUnitCountdown(eLoopPlayer) > 0)
		{
			ChangeIncomingUnitCountdown(eLoopPlayer, -1);

			// Time to spawn a new unit
			if(GetIncomingUnitCountdown(eLoopPlayer) == 0)
			{
				// Must have capital to actually spawn unit
				CvCity* pCapital = getCapitalCity();
				if(pCapital)
				{
					CvUnit* pNewUnit = initUnit(GetIncomingUnitType(eLoopPlayer), pCapital->getX(), pCapital->getY());
					CvAssert(pNewUnit);
					if (pNewUnit)
					{
						if(pNewUnit->getDomainType() != DOMAIN_AIR)
						{
							if (!pNewUnit->jumpToNearestValidPlot())
								pNewUnit->kill(false);
						}

						// Gift from a major to a city-state
						if (isMinorCiv() && !GET_PLAYER(eLoopPlayer).isMinorCiv())
						{
							GetMinorCivAI()->DoUnitGiftFromMajor(eLoopPlayer, pNewUnit, /*bDistanceGift*/ true);
						}
					}
				}

				// Reset stuff
				SetIncomingUnitCountdown(eLoopPlayer, -1);
				SetIncomingUnitType(eLoopPlayer, NO_UNIT);
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Someone sent us a present!
void CvPlayer::DoDistanceGift(PlayerTypes eFromPlayer, CvUnit* pUnit)
{
	if(!pUnit)
	{
		return;
	}

	CvPlot* pPlot = pUnit->plot();
	if(!pPlot)
	{
		return;
	}

	// Also add any units this guy is transporting
	IDInfo* pUnitNode = pPlot->headUnitNode();
	while(pUnitNode != NULL)
	{
		CvUnit* pLoopUnit = ::getUnit(*pUnitNode);
		pUnitNode = pPlot->nextUnitNode(pUnitNode);

		if(NULL != pLoopUnit && pLoopUnit->getTransportUnit() == pUnit)
			AddIncomingUnit(eFromPlayer, pLoopUnit);
	}

	AddIncomingUnit(eFromPlayer, pUnit);
}

//	--------------------------------------------------------------------------------
/// Someone sent us a present!
void CvPlayer::AddIncomingUnit(PlayerTypes eFromPlayer, CvUnit* pUnit)
{
	UnitTypes eUnitType = pUnit->getUnitType();

	// Gift to a minor civ for friendship
	if(isMinorCiv() && eFromPlayer < MAX_MAJOR_CIVS)
	{
		CvAssertMsg(GetIncomingUnitType(eFromPlayer) == NO_UNIT, "Adding incoming unit when one is already on its way. Please send Anton your save file and version.");
		CvAssertMsg(GetIncomingUnitCountdown(eFromPlayer) == -1, "Adding incoming unit when one is already on its way. Please send Anton your save file and version.");
		if(GetIncomingUnitCountdown(eFromPlayer) == -1)
		{
			SetIncomingUnitCountdown(eFromPlayer, GC.getMINOR_UNIT_GIFT_TRAVEL_TURNS());
			SetIncomingUnitType(eFromPlayer, eUnitType);
		}

		// Get rid of the old unit
		pUnit->kill(true);
	}
	// Gift from minor civ to this major civ (ex. Austria UA, but NOT Militaristic unit spawning, that is handled elsewhere)
	else if(!isMinorCiv() && GET_PLAYER(eFromPlayer).isMinorCiv())
	{
		int iX = pUnit->getX();
		int iY = pUnit->getY();
		UnitTypes eType = pUnit->getUnitType();

		// Get rid of the old unit
		pUnit->kill(true);

		// Add the new unit in its place
		if(eType != NO_UNIT)
		{
			CvUnit* pNewUnit = initUnit(eType, iX, iY);
			CvAssert(pNewUnit);
			if (pNewUnit)
#if defined(MOD_BUGFIX_MOVE_AFTER_PURCHASE)
			{
				if (!pUnit->getUnitInfo().CanMoveAfterPurchase())
				{
#endif
					pNewUnit->finishMoves();
#if defined(MOD_BUGFIX_MOVE_AFTER_PURCHASE)
				}
			}
#endif
		}
	}
	else
	{
		CvAssertMsg(false, "Unexpected case for adding an incoming unit for this player. Please send Anton your save file and version.");
	}
}

//	--------------------------------------------------------------------------------
/// Units in the ether coming towards us?
UnitTypes CvPlayer::GetIncomingUnitType(PlayerTypes eFromPlayer) const
{
	CvAssertMsg(eFromPlayer >= 0, "eFromPlayer is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFromPlayer < MAX_PLAYERS, "eFromPlayer is expected to be within maximum bounds (invalid Index)");
	return (UnitTypes) m_aiIncomingUnitTypes[eFromPlayer];
}

//	--------------------------------------------------------------------------------
/// Units in the ether coming towards us?
void CvPlayer::SetIncomingUnitType(PlayerTypes eFromPlayer, UnitTypes eUnitType)
{
	CvAssertMsg(eFromPlayer >= 0, "eFromPlayer is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFromPlayer < MAX_PLAYERS, "eFromPlayer is expected to be within maximum bounds (invalid Index)");

	CvAssertMsg(eUnitType >= NO_UNIT, "eUnitType is expected to be non-negative (invalid Index)");
	CvAssertMsg(eUnitType < GC.getNumUnitInfos(), "eUnitType is expected to be within maximum bounds (invalid Index)");

	if(eUnitType != m_aiIncomingUnitTypes[eFromPlayer])
	{
		m_aiIncomingUnitTypes.setAt(eFromPlayer, eUnitType);
	}
}

//	--------------------------------------------------------------------------------
/// Units in the ether coming towards us?
int CvPlayer::GetIncomingUnitCountdown(PlayerTypes eFromPlayer) const
{
	CvAssertMsg(eFromPlayer >= 0, "eFromPlayer is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFromPlayer < MAX_PLAYERS, "eFromPlayer is expected to be within maximum bounds (invalid Index)");
	return m_aiIncomingUnitCountdowns[eFromPlayer];
}

//	--------------------------------------------------------------------------------
/// Units in the ether coming towards us?
void CvPlayer::SetIncomingUnitCountdown(PlayerTypes eFromPlayer, int iNumTurns)
{
	CvAssertMsg(eFromPlayer >= 0, "eFromPlayer is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFromPlayer < MAX_PLAYERS, "eFromPlayer is expected to be within maximum bounds (invalid Index)");

	if(iNumTurns != m_aiIncomingUnitCountdowns[eFromPlayer])
		m_aiIncomingUnitCountdowns.setAt(eFromPlayer, iNumTurns);
}

//	--------------------------------------------------------------------------------
/// Units in the ether coming towards us?
void CvPlayer::ChangeIncomingUnitCountdown(PlayerTypes eFromPlayer, int iChange)
{
	if(iChange != 0)
		SetIncomingUnitCountdown(eFromPlayer, GetIncomingUnitCountdown(eFromPlayer) + iChange);
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isOption(PlayerOptionTypes eID) const
{
	for (PlayerOptionsVector::const_iterator itr = m_aOptions.begin(); itr != m_aOptions.end(); ++itr )
	{
		if ((*itr).first == eID)
			return (*itr).second != 0;
	}
	return false;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setOption(PlayerOptionTypes eID, bool bNewValue)
{
	int iIndex = 0;
	for (PlayerOptionsVector::const_iterator itr = m_aOptions.begin(); itr != m_aOptions.end(); ++itr )
	{
		if ((*itr).first == eID)
		{
			m_aOptions.setAt(iIndex, PlayerOptionEntry((uint)eID, bNewValue?1:0));
			return;
		}
		++iIndex;
	}

	m_aOptions.push_back(PlayerOptionEntry((uint)eID, bNewValue?1:0));
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isPlayable() const
{
	return CvPreGame::isPlayable(GetID());
}

//	--------------------------------------------------------------------------------
void CvPlayer::setPlayable(bool bNewValue)
{
	CvPreGame::setPlayable(GetID(), bNewValue);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNumResourceUsed(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiNumResourceUsed[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeNumResourceUsed(ResourceTypes eIndex, int iChange)
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumResourceInfos());

	if(iChange != 0)
	{
		m_paiNumResourceUsed.setAt(eIndex, m_paiNumResourceUsed[eIndex] + iChange);
	}
#if !defined(MOD_BALANCE_CORE)
	if(iChange > 0)
		DoTestOverResourceNotification(eIndex);
#endif

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	CvAssert(m_paiNumResourceUsed[eIndex] >= 0);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNumResourceTotal(ResourceTypes eIndex, bool bIncludeImport) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	// Mod applied to how much we have?
	CvResourceInfo *pkResource = GC.getResourceInfo(eIndex);
	if (pkResource == NULL)
	{
		return 0;
	}

	int iTotalNumResource = m_paiNumResourceTotal[eIndex];

	if(pkResource->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)
	{
#if defined(MOD_BALANCE_CORE)
		const CvCity* pLoopCity;
		int iLoop;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity != NULL)
			{
				if(pLoopCity->GetCorporationResourceQuantity(eIndex) > 0)
				{
					int iFranchises = GetCorporateFranchisesWorldwide();
					if(iFranchises > 0)
					{
						iTotalNumResource += (iFranchises / pLoopCity->GetCorporationResourceQuantity(eIndex));
					}
				}
			}
		}
#endif
		if(GetStrategicResourceMod() != 0)
		{
			iTotalNumResource *= GetStrategicResourceMod();
			iTotalNumResource /= 100;
		}
	}

	if(bIncludeImport)
	{
		iTotalNumResource += getResourceImport(eIndex);
		iTotalNumResource += getResourceFromMinors(eIndex);
		iTotalNumResource += getResourceSiphoned(eIndex);
	}

	iTotalNumResource -= getResourceExport(eIndex);

	return iTotalNumResource;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeNumResourceTotal(ResourceTypes eIndex, int iChange, bool bIgnoreResourceWarning)
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumResourceInfos());

	if(iChange != 0)
	{
		m_paiNumResourceTotal.setAt(eIndex, m_paiNumResourceTotal[eIndex] + iChange);

#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
		if(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
		{
			CheckForMonopoly(eIndex);
		}
#endif

		// Minors with an Ally give their Resources to their friend (awww)
		if(isMinorCiv())
		{
			PlayerTypes eBestRelationsPlayer = GetMinorCivAI()->GetAlly();

			if(eBestRelationsPlayer != NO_PLAYER)
			{
				ResourceUsageTypes eUsage = GC.getResourceInfo(eIndex)->getResourceUsage();

				if(eUsage == RESOURCEUSAGE_STRATEGIC || eUsage == RESOURCEUSAGE_LUXURY)
				{
					// Someone new is getting the bonus
					if(eBestRelationsPlayer != NO_PLAYER)
					{
						GET_PLAYER(eBestRelationsPlayer).changeResourceFromMinors(eIndex, iChange);
						changeResourceExport(eIndex, iChange);

						CvNotifications* pNotifications = GET_PLAYER(eBestRelationsPlayer).GetNotifications();
						if(pNotifications && !GetMinorCivAI()->IsDisableNotifications())
						{
							Localization::String strMessage;
							Localization::String strSummary;

							// Adding Resources
							if(iChange > 0)
							{
								strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_BFF_NEW_RESOURCE");
								strMessage << getNameKey() << GC.getResourceInfo(eIndex)->GetDescriptionKey();
								strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MINOR_BFF_NEW_RESOURCE");
								strSummary << getNameKey() << GC.getResourceInfo(eIndex)->GetDescriptionKey();
							}
							// Lost Resources
							else
							{
								strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_BFF_LOST_RESOURCE");
								strMessage << getNameKey() << GC.getResourceInfo(eIndex)->GetDescriptionKey();
								strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MINOR_BFF_LOST_RESOURCE");
								strSummary << getNameKey() << GC.getResourceInfo(eIndex)->GetDescriptionKey();
							}

							int iX = -1;
							int iY = -1;

							CvCity* capCity = getCapitalCity();

							if(capCity != NULL)
							{
								iX = capCity->getX();
								iY = capCity->getY();
							}

							pNotifications->Add(NOTIFICATION_MINOR, strMessage.toUTF8(), strSummary.toUTF8(), iX, iY, -1);
						}
					}
				}
			}
		}

		// Any players siphoning resources from us need to be updated as well
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_PLAYERS; iPlayerLoop++)
		{
			GET_PLAYER((PlayerTypes)iPlayerLoop).UpdateResourcesSiphoned();
		}
	}
	if(iChange < 0 && !bIgnoreResourceWarning)
#if !defined(MOD_BALANCE_CORE)
	{
		DoTestOverResourceNotification(eIndex);
	}
#endif

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	CvAssert(m_paiNumResourceTotal[eIndex] >= 0);
}
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
//	--------------------------------------------------------------------------------
int CvPlayer::getResourceOverValue(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiResourceOverValue[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceOverValue(ResourceTypes eIndex, int iChange)
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumResourceInfos());

	if(iChange != 0)
	{
		m_paiResourceOverValue.setAt(eIndex, m_paiResourceOverValue[eIndex] + iChange);
	}

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	CvAssert(m_paiResourceOverValue[eIndex] >= 0);
}
//	--------------------------------------------------------------------------------
void CvPlayer::setResourceOverValue(ResourceTypes eIndex, int iChange)
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumResourceInfos());

	if(iChange != 0)
	{
		m_paiResourceOverValue.setAt(eIndex, m_paiResourceOverValue[eIndex]);
	}

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	CvAssert(m_paiResourceOverValue[eIndex] >= 0);
}


//	--------------------------------------------------------------------------------
bool CvPlayer::HasGlobalMonopoly(ResourceTypes eResource) const
{
	return m_pabHasGlobalMonopoly[eResource];
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetHasGlobalMonopoly(ResourceTypes eResource, bool bNewValue)
{
	if(!MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
		return;

	if(bNewValue != m_pabHasGlobalMonopoly[eResource])
	{
		m_pabHasGlobalMonopoly.setAt(eResource, bNewValue);
	}

	std::vector<ResourceTypes>::iterator it = std::find(m_vResourcesWGlobalMonopoly.begin(),m_vResourcesWGlobalMonopoly.end(),eResource);
	if (bNewValue && it==m_vResourcesWGlobalMonopoly.end())
		m_vResourcesWGlobalMonopoly.push_back(eResource);
	else if (!bNewValue && it!=m_vResourcesWGlobalMonopoly.end())
		m_vResourcesWGlobalMonopoly.erase(it);
}
//	--------------------------------------------------------------------------------
bool CvPlayer::HasStrategicMonopoly(ResourceTypes eResource) const
{
	return m_pabHasStrategicMonopoly[eResource];
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetHasStrategicMonopoly(ResourceTypes eResource, bool bNewValue)
{
	if(!MOD_BALANCE_CORE_RESOURCE_MONOPOLIES_STRATEGIC)
		return;

	if(bNewValue != m_pabHasStrategicMonopoly[eResource])
	{
		m_pabHasStrategicMonopoly.setAt(eResource, bNewValue);
	}

	std::vector<ResourceTypes>::iterator it = std::find(m_vResourcesWStrategicMonopoly.begin(),m_vResourcesWStrategicMonopoly.end(),eResource);
	if (bNewValue && it==m_vResourcesWStrategicMonopoly.end())
		m_vResourcesWStrategicMonopoly.push_back(eResource);
	else if (!bNewValue && it!=m_vResourcesWStrategicMonopoly.end())
		m_vResourcesWStrategicMonopoly.erase(it);
}

//	--------------------------------------------------------------------------------
void CvPlayer::CheckForMonopoly(ResourceTypes eResource)
{
	const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);
	if(pkResourceInfo != NULL)
	{
		if(pkResourceInfo->isMonopoly())
		{
			int iOwnedNumResource = getNumResourceTotal(eResource, false) + getResourceExport(eResource);
			int iTotalNumResource = GC.getMap().getNumResources(eResource);
			bool bGainingBonus = false;
			bool bGainingStrategicBonus = false;
			bool bLosingBonus = false;
			bool bLosingStrategicBonus = false;
			if(iTotalNumResource > 0)
			{
				if(pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_LUXURY)
				{
					//Do we have +50% of this resource under our control?
					if(((iOwnedNumResource * 100) / iTotalNumResource) > GC.getGLOBAL_RESOURCE_MONOPOLY_THRESHOLD())
					{
						if(m_pabHasGlobalMonopoly[eResource] == false)
						{
							bGainingBonus = true;
						}
						SetHasGlobalMonopoly(eResource, true);
					}
					else
					{
						if(m_pabHasGlobalMonopoly[eResource] == true)
						{
							bLosingBonus = true;
						}
						SetHasGlobalMonopoly(eResource, false);
					}
				}
				else if(pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)
				{
					//Do we have +25% of this resource under our control?
					if(((iOwnedNumResource * 100) / iTotalNumResource) > GC.getSTRATEGIC_RESOURCE_MONOPOLY_THRESHOLD())
					{
						if(m_pabHasStrategicMonopoly[eResource] == false)
						{
							bGainingStrategicBonus = true;
						}
						SetHasStrategicMonopoly(eResource, true);
					}
					else
					{
						if(m_pabHasStrategicMonopoly[eResource] == true)
						{
							bLosingStrategicBonus = true;
						}
						SetHasStrategicMonopoly(eResource, false);
					}
					//Do we also have 50% of this resource under our control?
					if(((iOwnedNumResource * 100) / iTotalNumResource) > 50)
					{
						if(m_pabHasGlobalMonopoly[eResource] == false)
						{
							bGainingBonus = true;
						}
						SetHasGlobalMonopoly(eResource, true);
					}
					else
					{
						if(m_pabHasGlobalMonopoly[eResource] == true)
						{
							bLosingBonus = true;
						}
						SetHasGlobalMonopoly(eResource, false);
					}
				}
				CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
				if(pLeague != NULL)
				{
					if (GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(GetID(), eResource))
					{
						if(m_pabHasGlobalMonopoly[eResource] == true)
						{
							bLosingBonus = true;
						}
						SetHasGlobalMonopoly(eResource, false);
					}
				}
			}
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications && MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
			{
				const char* strResourceHelp = pkResourceInfo->GetHelp();

				// Adding Resources
				if(bGainingBonus)
				{
					Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MONOPOLY_GAINED");
					strMessage << pkResourceInfo->GetTextKey();
					strMessage << strResourceHelp;
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MONOPOLY_GAINED");
					strSummary << pkResourceInfo->GetTextKey();
					int iX = -1;
					int iY = -1;

					pNotifications->Add(NOTIFICATION_DISCOVERED_BONUS_RESOURCE, strMessage.toUTF8(), strSummary.toUTF8(), iX, iY, eResource);
					updateYield();
					for(int iPlayer = 0; iPlayer < MAX_PLAYERS; ++iPlayer)
					{
						//Notify human players of this, as they'll care.
						CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iPlayer);
						if(GET_TEAM(kLoopPlayer.getTeam()).isHasMet(getTeam()) && kLoopPlayer.isHuman() && (kLoopPlayer.GetID() != GetID()))
						{
							Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_PLAYER_MONOPOLY_GAINED");
							strMessage << pkResourceInfo->GetTextKey();
							strMessage << strResourceHelp;
							strMessage << getCivilizationInfo().getShortDescriptionKey();
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_OTHER_PLAYER_MONOPOLY_GAINED");
							strSummary << pkResourceInfo->GetTextKey();
							strSummary << getCivilizationInfo().getShortDescriptionKey();
							int iX = -1;
							int iY = -1;

							kLoopPlayer.GetNotifications()->Add(NOTIFICATION_DISCOVERED_BONUS_RESOURCE, strMessage.toUTF8(), strSummary.toUTF8(), iX, iY, eResource);
						}
					}
				}
				// Lost Resources
				else if(bLosingBonus && MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
				{
					Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MONOPOLY_LOST");
					strMessage << pkResourceInfo->GetTextKey();
					strMessage << strResourceHelp;
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MONOPOLY_LOST");
					strSummary << pkResourceInfo->GetTextKey();
					int iX = -1;
					int iY = -1;

					pNotifications->Add(NOTIFICATION_DISCOVERED_BONUS_RESOURCE, strMessage.toUTF8(), strSummary.toUTF8(), iX, iY, eResource);
					updateYield();
				}
				// Adding Resources
				if(bGainingStrategicBonus && MOD_BALANCE_CORE_RESOURCE_MONOPOLIES_STRATEGIC)
				{
					Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_STRATEGIC_MONOPOLY_GAINED");
					strMessage << pkResourceInfo->GetTextKey();
					strMessage << strResourceHelp;
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_STRATEGIC_MONOPOLY_GAINED");
					strSummary << pkResourceInfo->GetTextKey();
					int iX = -1;
					int iY = -1;

					pNotifications->Add(NOTIFICATION_DISCOVERED_BONUS_RESOURCE, strMessage.toUTF8(), strSummary.toUTF8(), iX, iY, eResource);
					updateYield();
					for(int iPlayer = 0; iPlayer < MAX_PLAYERS; ++iPlayer)
					{
						//Notify human players of this, as they'll care.
						CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iPlayer);
						if(GET_TEAM(kLoopPlayer.getTeam()).isHasMet(getTeam()) && kLoopPlayer.isHuman() && (kLoopPlayer.GetID() != GetID()))
						{
							Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_PLAYER_STRATEGIC_MONOPOLY_GAINED");
							strMessage << pkResourceInfo->GetTextKey();
							strMessage << strResourceHelp;
							strMessage << getCivilizationInfo().getShortDescriptionKey();
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_OTHER_PLAYER_STRATEGIC_MONOPOLY_GAINED");
							strSummary << pkResourceInfo->GetTextKey();
							strSummary << getCivilizationInfo().getShortDescriptionKey();
							int iX = -1;
							int iY = -1;

							kLoopPlayer.GetNotifications()->Add(NOTIFICATION_DISCOVERED_BONUS_RESOURCE, strMessage.toUTF8(), strSummary.toUTF8(), iX, iY, eResource);
						}
					}
				}
				// Lost Resources
				else if(bLosingStrategicBonus && MOD_BALANCE_CORE_RESOURCE_MONOPOLIES_STRATEGIC)
				{
					Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_STRATEGIC_MONOPOLY_LOST");
					strMessage << pkResourceInfo->GetTextKey();
					strMessage << strResourceHelp;
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_STRATEGIC_MONOPOLY_LOST");
					strSummary << pkResourceInfo->GetTextKey();
					int iX = -1;
					int iY = -1;

					pNotifications->Add(NOTIFICATION_DISCOVERED_BONUS_RESOURCE, strMessage.toUTF8(), strSummary.toUTF8(), iX, iY, eResource);
					updateYield();
				}
			}
		}
	}
}
#endif
//	--------------------------------------------------------------------------------
/// Get the monopoly percentage owned for eResource.
int CvPlayer::GetMonopolyPercent(ResourceTypes eResource) const
{
	int iOwnedNumResource = getNumResourceTotal(eResource, false) + getResourceExport(eResource);
	int iTotalNumResource = GC.getMap().getNumResources(eResource);

	CvAssertMsg(iTotalNumResource > 0, "iTotalNumResource should be greater than zero!");

	if(iTotalNumResource == 0)
		return 0;

	return (iOwnedNumResource * 100) / iTotalNumResource;
}
//	--------------------------------------------------------------------------------
//	--------------------------------------------------------------------------------
/// Do we get copies of each type of luxury connected by eFromPlayer?
int CvPlayer::getSiphonLuxuryCount(PlayerTypes eFromPlayer) const
{
	CvAssertMsg(eFromPlayer >= 0, "eFromPlayer is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFromPlayer < MAX_PLAYERS, "eFromPlayer is expected to be within maximum bounds (invalid Index)");

	return m_aiSiphonLuxuryCount[eFromPlayer];
}

//	--------------------------------------------------------------------------------
/// Change number of copies we get of luxury types connected by eFromPlayer
void CvPlayer::changeSiphonLuxuryCount(PlayerTypes eFromPlayer, int iChange)
{
	CvAssertMsg(eFromPlayer >= 0, "eFromPlayer is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFromPlayer < MAX_PLAYERS, "eFromPlayer is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiSiphonLuxuryCount.setAt(eFromPlayer, m_aiSiphonLuxuryCount[eFromPlayer] + iChange);
		CvAssert(getSiphonLuxuryCount(eFromPlayer) >= 0);

		UpdateResourcesSiphoned();
	}
}

//	--------------------------------------------------------------------------------
/// Count up the number of resources we have been siphoning from others and compare it to how many 
/// we are now allowed to siphon.  Change our resource count if there is a discrepancy.
void CvPlayer::UpdateResourcesSiphoned()
{
	FStaticVector<int, 64, true, c_eCiv5GameplayDLL> vDeltas;
	
	// Subtract all currently siphoned resources
	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
		vDeltas.push_back(-1 * getResourceSiphoned(eResourceLoop));
	}

	// Add back in valid siphoned resources
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes ePlayerLoop = (PlayerTypes) iPlayerLoop;
		int iSiphonLuxuryCount = getSiphonLuxuryCount(ePlayerLoop);
		if (iSiphonLuxuryCount > 0)
		{
			for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
			{
				ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
				CvResourceInfo* pInfo = GC.getResourceInfo(eResourceLoop);
				// Is it a luxury?
				if (pInfo && pInfo->getResourceUsage() == RESOURCEUSAGE_LUXURY)
				{
					// Do they have at least one of this type, even if it was exported?
					if (GET_PLAYER(ePlayerLoop).getNumResourceTotal(eResourceLoop, /*bIncludeImport*/ false) > 0 || GET_PLAYER(ePlayerLoop).getResourceExport(eResourceLoop) > 0)
					{
						vDeltas[eResourceLoop] += iSiphonLuxuryCount;
					}
				}
			}
		}
	}

	// Propagate any actual changes
	for (uint i = 0; i < vDeltas.size(); i++)
	{
		if (vDeltas[i] != 0)
		{
			ResourceTypes eResource = (ResourceTypes) i;
			changeResourceSiphoned(eResource, vDeltas[i]);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Are we over our resource limit? If so, give out a notification
void CvPlayer::DoTestOverResourceNotification(ResourceTypes eIndex)
{
#if defined(MOD_BALANCE_CORE)
	if((getNumResourceAvailable(eIndex, true) < 0) && (getNumResourceUsed(eIndex) > 0))
#else
	if(getNumResourceAvailable(eIndex, true) < 0)
#endif
	{
#if defined(MOD_BALANCE_CORE)
		//Flip the amount available as our drain pool - helper for cities to prevent empire wide drop.
		setResourceOverValue(eIndex, (getNumResourceAvailable(eIndex, true) * -1));
#endif
		const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eIndex);
		if(pkResourceInfo != NULL && pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)
		{
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_OVER_RESOURCE_LIMIT");
				strText << pkResourceInfo->GetTextKey();
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_OVER_RESOURCE_LIMIT");
				strSummary << pkResourceInfo->GetTextKey();
#if defined(MOD_BALANCE_CORE)
				pNotifications->Add(NOTIFICATION_DISCOVERED_STRATEGIC_RESOURCE, strText.toUTF8(), strSummary.toUTF8(), -1, -1, eIndex);
#else
				pNotifications->Add(NOTIFICATION_DEMAND_RESOURCE, strText.toUTF8(), strSummary.toUTF8(), -1, -1, eIndex);
#endif
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Is our collection of Strategic Resources modified?
int CvPlayer::GetStrategicResourceMod() const
{
	return m_iStrategicResourceMod;
}

//	--------------------------------------------------------------------------------
/// Is our collection of Strategic Resources modified?
void CvPlayer::ChangeStrategicResourceMod(int iChange)
{
	m_iStrategicResourceMod += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNumResourceAvailable(ResourceTypes eIndex, bool bIncludeImport) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return getNumResourceTotal(eIndex, bIncludeImport) - getNumResourceUsed(eIndex);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getResourceGiftedToMinors(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiResourceGiftedToMinors[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceGiftedToMinors(ResourceTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiResourceGiftedToMinors.setAt(eIndex, m_paiResourceGiftedToMinors[eIndex] + iChange);
		CvAssert(getResourceGiftedToMinors(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getResourceExport(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiResourceExport[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceExport(ResourceTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiResourceExport.setAt(eIndex, m_paiResourceExport[eIndex] + iChange);
		CvAssert(getResourceExport(eIndex) >= 0);

		CalculateNetHappiness();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getResourceImport(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiResourceImport[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceImport(ResourceTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiResourceImport.setAt(eIndex, m_paiResourceImport[eIndex] + iChange);
		CvAssert(getResourceImport(eIndex) >= 0);

		CalculateNetHappiness();
		
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getResourceFromMinors(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	int iNumResourceFromMinors = m_paiResourceFromMinors[eIndex];

	// Resource bonus doubles quantity of Resources from Minors (Policies, etc.)
	if(IsMinorResourceBonus())
	{
		iNumResourceFromMinors *= /*200*/ GC.getMINOR_POLICY_RESOURCE_MULTIPLIER();
		iNumResourceFromMinors /= 100;
	}

	return iNumResourceFromMinors;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceFromMinors(ResourceTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiResourceFromMinors.setAt(eIndex, m_paiResourceFromMinors[eIndex] + iChange);
		CvAssert(getResourceFromMinors(eIndex) >= 0);

		CalculateNetHappiness();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getResourceSiphoned(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	int iNumResourceSiphoned = m_paiResourcesSiphoned[eIndex];

	return iNumResourceSiphoned;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceSiphoned(ResourceTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_paiResourcesSiphoned.setAt(eIndex, m_paiResourcesSiphoned[eIndex] + iChange);
		CvAssert(getResourceSiphoned(eIndex) >= 0);

		CalculateNetHappiness();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getResourceInOwnedPlots(ResourceTypes eIndex)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	int iCount = 0;

	// Loop through all plots
	const CvPlotsVector& aiPlots = GetPlots();
	for (uint uiPlotIndex = 0; uiPlotIndex < aiPlots.size(); uiPlotIndex++)
	{
		if (aiPlots[uiPlotIndex] == -1)
			continue;

		CvPlot* pPlot = GC.getMap().plotByIndex(aiPlots[uiPlotIndex]);
		if (pPlot && pPlot->getResourceType(getTeam()) == eIndex)
		{
			iCount++;
		}
	}

	return iCount;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getTotalImprovementsBuilt() const
{
	return m_iTotalImprovementsBuilt;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeTotalImprovementsBuilt(int iChange)
{
	m_iTotalImprovementsBuilt = (m_iTotalImprovementsBuilt + iChange);
	CvAssert(getTotalImprovementsBuilt() >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getImprovementCount(ImprovementTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumImprovementInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiImprovementCount[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeImprovementCount(ImprovementTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumImprovementInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	m_paiImprovementCount.setAt(eIndex, m_paiImprovementCount[eIndex] + iChange);
	CvAssert(getImprovementCount(eIndex) >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getGreatPersonImprovementCount()
{
	int iCount = 0;
	for (int i = 0; i < GC.getNumImprovementInfos(); i++)
	{
		ImprovementTypes e = (ImprovementTypes)i;
		CvImprovementEntry* pInfo = GC.getImprovementInfo(e);
		if (pInfo && pInfo->IsCreatedByGreatPerson())
		{
			iCount += getImprovementCount(e);
		}
	}
	return iCount;
}


//	--------------------------------------------------------------------------------
int CvPlayer::getFreeBuildingCount(BuildingTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiFreeBuildingCount[eIndex];
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isBuildingFree(BuildingTypes eIndex)	const
{
	return (getFreeBuildingCount(eIndex) > 0);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeFreeBuildingCount(BuildingTypes eIndex, int iChange)
{
	CvCity* pLoopCity;
	int iOldFreeBuildingCount;
	int iLoop;

	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		iOldFreeBuildingCount = getFreeBuildingCount(eIndex);

		m_paiFreeBuildingCount.setAt(eIndex, m_paiFreeBuildingCount[eIndex] + iChange);
		CvAssert(getFreeBuildingCount(eIndex) >= 0);

		if(iOldFreeBuildingCount == 0)
		{
			CvAssertMsg(getFreeBuildingCount(eIndex) > 0, "getFreeBuildingCount(eIndex) is expected to be greater than 0");

			for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				pLoopCity->GetCityBuildings()->SetNumFreeBuilding(eIndex, 1);
			}
		}
		else if(getFreeBuildingCount(eIndex) == 0)
		{
			CvAssertMsg(iOldFreeBuildingCount > 0, "iOldFreeBuildingCount is expected to be greater than 0");

			for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				pLoopCity->GetCityBuildings()->SetNumFreeBuilding(eIndex, 0);
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Is ePromotion a free promotion?
int CvPlayer::GetFreePromotionCount(PromotionTypes ePromotion) const
{
	CvAssertMsg(ePromotion >= 0, "ePromotion is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePromotion < GC.getNumPromotionInfos(), "ePromotion is expected to be within maximum bounds (invalid Index)");
	return m_paiFreePromotionCount[ePromotion];
}

//	--------------------------------------------------------------------------------
/// Is ePromotion a free promotion?
bool CvPlayer::IsFreePromotion(PromotionTypes ePromotion)	const
{
	return (GetFreePromotionCount(ePromotion) > 0);
}

//	--------------------------------------------------------------------------------
/// Is ePromotion a free promotion?
void CvPlayer::ChangeFreePromotionCount(PromotionTypes ePromotion, int iChange)
{
	CvAssertMsg(ePromotion >= 0, "ePromotion is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePromotion < GC.getNumPromotionInfos(), "ePromotion is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		bool bWasFree = IsFreePromotion(ePromotion);

		m_paiFreePromotionCount.setAt(ePromotion, m_paiFreePromotionCount[ePromotion] + iChange);

		CvAssert(GetFreePromotionCount(ePromotion) >= 0);

		// This promotion is now set to be free, but wasn't before we called this function
		if(IsFreePromotion(ePromotion) && !bWasFree)
		{
			// Loop through Units
			CvUnit* pLoopUnit;

			int iLoop;
			for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
			{
				// Valid Promotion for this Unit?
				if(::IsPromotionValidForUnitCombatType(ePromotion, pLoopUnit->getUnitType()))
				{
					pLoopUnit->setHasPromotion(ePromotion, true);
				}

				else if(::IsPromotionValidForCivilianUnitType(ePromotion, pLoopUnit->getUnitType()))
				{
					pLoopUnit->setHasPromotion(ePromotion, true);
				}
			}
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getUnitCombatProductionModifiers(UnitCombatTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitCombatClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiUnitCombatProductionModifiers[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeUnitCombatProductionModifiers(UnitCombatTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitCombatClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiUnitCombatProductionModifiers.setAt(eIndex, m_paiUnitCombatProductionModifiers[eIndex] + iChange);
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getUnitCombatFreeExperiences(UnitCombatTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitCombatClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiUnitCombatFreeExperiences[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeUnitCombatFreeExperiences(UnitCombatTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitCombatClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiUnitCombatFreeExperiences.setAt(eIndex, m_paiUnitCombatFreeExperiences[eIndex] + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getUnitClassCount(UnitClassTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiUnitClassCount[eIndex];
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isUnitClassMaxedOut(UnitClassTypes eIndex, int iExtra) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eIndex);
	if(pkUnitClassInfo == NULL)
	{
		return false;
	}

#if defined(MOD_BALANCE_CORE)
	if(isUnitLimitPerCity(eIndex))
	{
		CvAssertMsg(getUnitClassCount(eIndex) <= (getNumCities() * pkUnitClassInfo->getUnitInstancePerCity()), "getUnitInstancePerCity is expected to be less than maximum bound of UnitInstancePerCity (invalid index)");
		return ((getUnitClassCount(eIndex) + iExtra) >= (getNumCities() * pkUnitClassInfo->getUnitInstancePerCity()));
	}
	else if(isNationalUnitClass(eIndex))
	{
		CvAssertMsg(getUnitClassCount(eIndex) <= pkUnitClassInfo->getMaxPlayerInstances(), "getUnitClassCount is expected to be less than maximum bound of MaxPlayerInstances (invalid index)");
		return ((getUnitClassCount(eIndex) + iExtra) >= pkUnitClassInfo->getMaxPlayerInstances());
	}
	else
	{
		return false;
	}
#else
	if(!isNationalUnitClass(eIndex))
	{
		return false;
	}

	CvAssertMsg(getUnitClassCount(eIndex) <= pkUnitClassInfo->getMaxPlayerInstances(), "getUnitClassCount is expected to be less than maximum bound of MaxPlayerInstances (invalid index)");

	return ((getUnitClassCount(eIndex) + iExtra) >= pkUnitClassInfo->getMaxPlayerInstances());
#endif
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeUnitClassCount(UnitClassTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	m_paiUnitClassCount.setAt(eIndex, m_paiUnitClassCount[eIndex] + iChange);
	CvAssert(getUnitClassCount(eIndex) >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getUnitClassMaking(UnitClassTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiUnitClassMaking[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeUnitClassMaking(UnitClassTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiUnitClassMaking.setAt(eIndex, m_paiUnitClassMaking[eIndex] + iChange);
		CvAssert(getUnitClassMaking(eIndex) >= 0);

		CvCivilizationInfo& playerCivilizationInfo = getCivilizationInfo();
		UnitTypes eUnit = static_cast<UnitTypes>(playerCivilizationInfo.getCivilizationUnits(eIndex));
		CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
		if(pkUnitInfo)
		{
			// Builder Limit
			if(pkUnitInfo->GetWorkRate() > 0 && pkUnitInfo->GetDomainType() == DOMAIN_LAND)
			{
				ChangeNumBuilders(iChange);
			}

			// Update the amount of a Resource used up by Units in Production
			for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
			{
				ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);
				CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
				if(pkResource)
				{
					if(pkUnitInfo->GetResourceQuantityRequirement(iResourceLoop) > 0)
					{
						changeNumResourceUsed(eResource, iChange * pkUnitInfo->GetResourceQuantityRequirement(iResourceLoop));
					}
				}
			}

			if(GetID() == GC.getGame().getActivePlayer())
			{
				GC.GetEngineUserInterface()->setDirty(Help_DIRTY_BIT, true);
			}
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getUnitClassCountPlusMaking(UnitClassTypes eIndex) const
{
	return (getUnitClassCount(eIndex) + getUnitClassMaking(eIndex));
}


//	--------------------------------------------------------------------------------
int CvPlayer::getBuildingClassCount(BuildingClassTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiBuildingClassCount[eIndex];
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isBuildingClassMaxedOut(BuildingClassTypes eIndex, int iExtra) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eIndex);
	if(pkBuildingClassInfo == NULL)
	{
		CvAssertMsg(false, "This should never happen...");
		return false;
	}

	if(!isNationalWonderClass(*pkBuildingClassInfo))
	{
		return false;
	}

	CvAssertMsg(getBuildingClassCount(eIndex) <= (pkBuildingClassInfo->getMaxPlayerInstances() + pkBuildingClassInfo->getExtraPlayerInstances()), "BuildingClassCount is expected to be less than or match the number of max player instances plus extra player instances");

	return ((getBuildingClassCount(eIndex) + iExtra) >= (pkBuildingClassInfo->getMaxPlayerInstances() + pkBuildingClassInfo->getExtraPlayerInstances()));
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeBuildingClassCount(BuildingClassTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	m_paiBuildingClassCount.setAt(eIndex, m_paiBuildingClassCount[eIndex] + iChange);
	CvAssert(getBuildingClassCount(eIndex) >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getBuildingClassMaking(BuildingClassTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiBuildingClassMaking[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeBuildingClassMaking(BuildingClassTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiBuildingClassMaking.setAt(eIndex, m_paiBuildingClassMaking[eIndex] + iChange);
		CvAssert(getBuildingClassMaking(eIndex) >= 0);

		const BuildingTypes eBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eIndex);
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
		if(pkBuildingInfo)
		{
			// Update the amount of a Resource used up by Buildings in Production
			for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
			{
				const ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);
				CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);
				if(pkResourceInfo)
				{
					if(pkBuildingInfo->GetResourceQuantityRequirement(iResourceLoop) > 0)
					{
						changeNumResourceUsed(eResource, iChange * pkBuildingInfo->GetResourceQuantityRequirement(iResourceLoop));
					}
				}

			}
		}


		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Help_DIRTY_BIT, true);
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getBuildingClassCountPlusMaking(BuildingClassTypes eIndex) const
{
	return (getBuildingClassCount(eIndex) + getBuildingClassMaking(eIndex));
}


//	--------------------------------------------------------------------------------
// The following two functions are only used to keep track of how many Projects are in progress so we know what each player's Resource situation is
// Check out CvTeam::getProjectMaking() for something used more
int CvPlayer::getProjectMaking(ProjectTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiProjectMaking[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeProjectMaking(ProjectTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiProjectMaking.setAt(eIndex, m_paiProjectMaking[eIndex] + iChange);
		CvAssert(getProjectMaking(eIndex) >= 0);

		// Update the amount of a Resource used up by Projects in Production
		for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
		{
			if(GC.getProjectInfo(eIndex)->GetResourceQuantityRequirement(iResourceLoop) > 0)
			{
				changeNumResourceUsed((ResourceTypes) iResourceLoop, iChange * GC.getProjectInfo(eIndex)->GetResourceQuantityRequirement(iResourceLoop));
			}
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getHurryCount(HurryTypes eIndex) const
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumHurryInfos());
	return m_paiHurryCount[eIndex];
}


//	--------------------------------------------------------------------------------
// Do we have access to this Hurry type?
bool CvPlayer::IsHasAccessToHurry(HurryTypes eIndex) const
{
	return (getHurryCount(eIndex) > 0);
}

//	--------------------------------------------------------------------------------
/// Can we use this Hurry RIGHT NOW?
bool CvPlayer::IsCanHurry(HurryTypes eIndex) const
{
	CvHurryInfo* pkHurryInfo = GC.getHurryInfo(eIndex);
	if(pkHurryInfo == NULL)
		return false;

	int iCost = GetHurryGoldCost(eIndex);

	// Can we pay for this Hurry?
	if(iCost < 0 || GetTreasury()->GetGold() < iCost)
	{
		return false;
	}

	// Science Rushing
	if(pkHurryInfo->getGoldPerBeaker() > 0)
	{
		return true;
	}

	// Culture Rushing
	if(pkHurryInfo->getGoldPerCulture() > 0)
	{
		// If we already have enough Culture for the next Policy, there's nothing to rush!
		if(getNextPolicyCost() > getJONSCulture())
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
/// How much Gold does it cost us to Hurry? (whatever the applicable item is)
int CvPlayer::GetHurryGoldCost(HurryTypes eHurry) const
{
	int iGold = -1;

	CvHurryInfo* pkHurryInfo = GC.getHurryInfo(eHurry);
	if(pkHurryInfo == NULL)
	{
		//This should never happen.
		return -1;
	}

	// Science Rushing
	if(pkHurryInfo->getGoldPerBeaker() > 0)
	{
		TechTypes eTech = GetPlayerTechs()->GetCurrentResearch();

		if(eTech != NO_TECH)
		{
			int iTotalCost = GET_TEAM(getTeam()).GetTeamTechs()->GetResearchCost(eTech);
			int iResearchLeft = GET_TEAM(getTeam()).GetTeamTechs()->GetResearchLeft(eTech);

			// Cost of Gold rushing based on the ORIGINAL Research price
			int iGoldForFullPrice = iTotalCost * pkHurryInfo->getGoldPerBeaker();
			iGoldForFullPrice = (int) pow((double) iGoldForFullPrice, (double) /*1.10f*/ GC.getHURRY_GOLD_TECH_EXPONENT());

			// Figure out the actual cost by comparing what's left to the original Research cost, and multiplying that by the amount to Gold rush the original cost
			iGold = (iGoldForFullPrice * iResearchLeft / iTotalCost);
		}
	}

	// Culture Rushing
	if(pkHurryInfo->getGoldPerCulture() > 0)
	{
		int iCurrentPolicyCost = getNextPolicyCost();

		if(iCurrentPolicyCost > 0)
		{
			int iCultureLeft = iCurrentPolicyCost - getJONSCulture();

			// Cost of Gold rushing based on the ORIGINAL Culture price
			int iGoldForFullPrice = iCurrentPolicyCost * pkHurryInfo->getGoldPerCulture();
			iGoldForFullPrice = (int) pow((double) iGoldForFullPrice, (double) /*1.10f*/ GC.getHURRY_GOLD_CULTURE_EXPONENT());

			// Figure out the actual cost by comparing what's left to the original Culture cost, and multiplying that by the amount to Gold rush the original cost
			iGold = (iGoldForFullPrice * iCultureLeft / iCurrentPolicyCost);
		}
	}

	return iGold;
}

//	--------------------------------------------------------------------------------
/// Hurry something!
void CvPlayer::DoHurry(HurryTypes eIndex)
{
	CvHurryInfo* pkHurryInfo = GC.getHurryInfo(eIndex);
	if(pkHurryInfo)
	{
		if(IsCanHurry(eIndex))
		{
			int iGoldCost = GetHurryGoldCost(eIndex);
			GetTreasury()->ChangeGold(-iGoldCost);

			// Science Rushing
			if(pkHurryInfo->getGoldPerBeaker() > 0)
			{
				TechTypes eTech = GetPlayerTechs()->GetCurrentResearch();

				GET_TEAM(getTeam()).setHasTech(eTech, true, GetID(), false, false);
			}

			// Culture Rushing
			if(pkHurryInfo->getGoldPerCulture() > 0)
			{
				setJONSCulture(getNextPolicyCost());
			}
		}
	}
}


//	--------------------------------------------------------------------------------
bool CvPlayer::canPopRush()
{
	return (m_iPopRushHurryCount > 0);
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeHurryCount(HurryTypes eIndex, int iChange)
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumHurryInfos());

	int oldHurryCount = m_paiHurryCount[eIndex];
	m_paiHurryCount.setAt(eIndex, m_paiHurryCount[eIndex] + iChange);
	CvAssert(getHurryCount(eIndex) >= 0);

	CvHurryInfo* pkHurryInfo = GC.getHurryInfo(eIndex);
	if(pkHurryInfo == NULL)
		return;

	// if we just went from 0 to 1 (or the reverse)
	if((oldHurryCount > 0) != (m_paiHurryCount[eIndex] > 0))
	{
		// does this hurry reduce population?
		if(pkHurryInfo->getProductionPerPopulation() > 0)
		{
			m_iPopRushHurryCount += iChange;
			CvAssert(m_iPopRushHurryCount >= 0);
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getHurryModifier(HurryTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumHurryInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiHurryModifier[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeHurryModifier(HurryTypes eIndex, int iChange)
{
	if(iChange != 0)
	{
		CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
		CvAssertMsg(eIndex < GC.getNumHurryInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
		m_paiHurryModifier.setAt(eIndex, m_paiHurryModifier[eIndex] + iChange);
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::setResearchingTech(TechTypes eIndex, bool bNewValue)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(m_pPlayerTechs->IsResearchingTech(eIndex) != bNewValue)
	{
		GetPlayerTechs()->SetResearchingTech(eIndex, bNewValue);

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Popup_DIRTY_BIT, true); // to check whether we still need the tech chooser popup
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getSpecialistExtraYield(SpecialistTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 expected to be >= 0");
	CvAssertMsg(eIndex1 < GC.getNumSpecialistInfos(), "eIndex1 expected to be < GC.getNumSpecialistInfos()");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 expected to be >= 0");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 expected to be < NUM_YIELD_TYPES");
	return m_ppaaiSpecialistExtraYield[eIndex1][eIndex2];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeSpecialistExtraYield(SpecialistTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 expected to be >= 0");
	CvAssertMsg(eIndex1 < GC.getNumSpecialistInfos(), "eIndex1 expected to be < GC.getNumSpecialistInfos()");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 expected to be >= 0");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 expected to be < NUM_YIELD_TYPES");

	if(iChange != 0)
	{
		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppaaiSpecialistExtraYield[eIndex1];
		yields[eIndex2] = (m_ppaaiSpecialistExtraYield[eIndex1][eIndex2] + iChange);
		m_ppaaiSpecialistExtraYield.setAt(eIndex1, yields);
		CvAssert(getSpecialistExtraYield(eIndex1, eIndex2) >= 0);

		updateExtraSpecialistYield();
	}
}


#if defined(MOD_API_UNIFIED_YIELDS) && defined(MOD_API_PLOT_YIELDS)
//	--------------------------------------------------------------------------------
int CvPlayer::getPlotYieldChange(PlotTypes eIndex1, YieldTypes eIndex2) const
{
	if (MOD_API_PLOT_YIELDS) {
		CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
		CvAssertMsg(eIndex1 < GC.getNumPlotInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
		CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
		CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
		return m_ppiPlotYieldChange[eIndex1][eIndex2];
	} else {
		return 0;
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::changePlotYieldChange(PlotTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	if (MOD_API_PLOT_YIELDS) {
		CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
		CvAssertMsg(eIndex1 < GC.getNumPlotInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
		CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
		CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

		if(iChange != 0)
		{
			CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

			Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiPlotYieldChange[eIndex1];
			yields[eIndex2] = (m_ppiPlotYieldChange[eIndex1][eIndex2] + iChange);
			m_ppiPlotYieldChange[eIndex1] = yields;
			CvAssert(getPlotYieldChange(eIndex1, eIndex2) >= 0);

			updateYield();
		}
	}
}
#endif

#if defined(MOD_API_UNIFIED_YIELDS)
//	--------------------------------------------------------------------------------
int CvPlayer::getFeatureYieldChange(FeatureTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiFeatureYieldChange[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeFeatureYieldChange(FeatureTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiFeatureYieldChange[eIndex1];
		yields[eIndex2] = (m_ppiFeatureYieldChange[eIndex1][eIndex2] + iChange);
		m_ppiFeatureYieldChange[eIndex1] = yields;
		CvAssert(getFeatureYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getCityYieldFromUnimprovedFeature(FeatureTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiCityYieldFromUnimprovedFeature[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeCityYieldFromUnimprovedFeature(FeatureTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number.");

		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiCityYieldFromUnimprovedFeature[eIndex1];
		yields[eIndex2] = (m_ppiCityYieldFromUnimprovedFeature[eIndex1][eIndex2] + iChange);
		m_ppiCityYieldFromUnimprovedFeature[eIndex1] = yields;
		CvAssert(getCityYieldFromUnimprovedFeature(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getUnimprovedFeatureYieldChange(FeatureTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiUnimprovedFeatureYieldChange[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeUnimprovedFeatureYieldChange(FeatureTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number.");

		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiUnimprovedFeatureYieldChange[eIndex1];
		yields[eIndex2] = (m_ppiUnimprovedFeatureYieldChange[eIndex1][eIndex2] + iChange);
		m_ppiUnimprovedFeatureYieldChange[eIndex1] = yields;
		CvAssert(getUnimprovedFeatureYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getResourceYieldChange(ResourceTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumResourceInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiResourceYieldChange[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceYieldChange(ResourceTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumResourceInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiResourceYieldChange[eIndex1];
		yields[eIndex2] = (m_ppiResourceYieldChange[eIndex1][eIndex2] + iChange);
		m_ppiResourceYieldChange[eIndex1] = yields;
		CvAssert(getResourceYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getTerrainYieldChange(TerrainTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumTerrainInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiTerrainYieldChange[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeTerrainYieldChange(TerrainTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumTerrainInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiTerrainYieldChange[eIndex1];
		yields[eIndex2] = (m_ppiTerrainYieldChange[eIndex1][eIndex2] + iChange);
		m_ppiTerrainYieldChange[eIndex1] = yields;
		CvAssert(getTerrainYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getTradeRouteYieldChange(DomainTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumDomainInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiTradeRouteYieldChange[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeTradeRouteYieldChange(DomainTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumDomainInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiTradeRouteYieldChange[eIndex1];
		yields[eIndex2] = (m_ppiTradeRouteYieldChange[eIndex1][eIndex2] + iChange);
		m_ppiTradeRouteYieldChange[eIndex1] = yields;
		CvAssert(getTradeRouteYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getSpecialistYieldChange(SpecialistTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumSpecialistInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiSpecialistYieldChange[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeSpecialistYieldChange(SpecialistTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumSpecialistInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiSpecialistYieldChange[eIndex1];
		yields[eIndex2] = (m_ppiSpecialistYieldChange[eIndex1][eIndex2] + iChange);
		m_ppiSpecialistYieldChange[eIndex1] = yields;
		CvAssert(getSpecialistYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatPersonExpendedYield(GreatPersonTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumGreatPersonInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiGreatPersonExpendedYield[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGreatPersonExpendedYield(GreatPersonTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumGreatPersonInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiGreatPersonExpendedYield[eIndex1];
		yields[eIndex2] = (m_ppiGreatPersonExpendedYield[eIndex1][eIndex2] + iChange);
		m_ppiGreatPersonExpendedYield[eIndex1] = yields;
		CvAssert(GetGreatPersonExpendedYield(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGoldenAgeGreatPersonRateModifier(GreatPersonTypes eGreatPerson) const
{
	CvAssertMsg(eGreatPerson >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eGreatPerson < GC.getNumGreatPersonInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piGoldenAgeGreatPersonRateModifier[eGreatPerson];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGoldenAgeGreatPersonRateModifier(GreatPersonTypes eGreatPerson, int iChange)
{
	CvAssertMsg(eGreatPerson >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eGreatPerson < GC.getNumGreatPersonInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_piGoldenAgeGreatPersonRateModifier[eGreatPerson] += iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetYieldFromKills(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piYieldFromKills[eYield];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromKills(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_piYieldFromKills[eYield] += iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetYieldFromBarbarianKills(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piYieldFromBarbarianKills[eYield];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromBarbarianKills(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_piYieldFromBarbarianKills[eYield] += iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetYieldChangeTradeRoute(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piYieldChangeTradeRoute[eYield];
}

void CvPlayer::ChangeYieldChangeTradeRoute(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_piYieldChangeTradeRoute[eYield] += iChange;

		updateYield();
	}
}

int CvPlayer::GetYieldChangesNaturalWonder(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piYieldChangesNaturalWonder[eYield];
}

void CvPlayer::ChangeYieldChangesNaturalWonder(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_piYieldChangesNaturalWonder[eYield] += iChange;

		updateYield();
	}
}

int CvPlayer::GetYieldChangeWorldWonder(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piYieldChangeWorldWonder[eYield];
}

void CvPlayer::ChangeYieldChangeWorldWonder(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_piYieldChangeWorldWonder[eYield] += iChange;

		updateYield();
	}
}

int CvPlayer::GetYieldFromMinorDemand(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piYieldFromMinorDemand[eYield];
}

void CvPlayer::ChangeYieldFromMinorDemand(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_piYieldFromMinorDemand[eYield] += iChange;
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::getBuildingClassYieldChange(BuildingClassTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumBuildingClassInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiBuildingClassYieldChange[eIndex1][eIndex2];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeBuildingClassYieldChange(BuildingClassTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumBuildingClassInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiBuildingClassYieldChange[eIndex1];
		yields[eIndex2] = (m_ppiBuildingClassYieldChange[eIndex1][eIndex2] + iChange);
		m_ppiBuildingClassYieldChange.setAt(eIndex1, yields);
		CvAssert(getBuildingClassYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getImprovementYieldChange(ImprovementTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumImprovementInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppaaiImprovementYieldChange[eIndex1][eIndex2];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeImprovementYieldChange(ImprovementTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumImprovementInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppaaiImprovementYieldChange[eIndex1];
		yields[eIndex2] = (m_ppaaiImprovementYieldChange[eIndex1][eIndex2] + iChange);
		m_ppaaiImprovementYieldChange.setAt(eIndex1, yields);
		CvAssert(getImprovementYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::removeFromArmy(int iArmyID, int iID)
{
	bool bRemoved = false;
	CvArmyAI* pThisArmyAI = getArmyAI(iArmyID);
	if(pThisArmyAI)
	{
		bRemoved = pThisArmyAI->RemoveUnit(iID);
	}

	return bRemoved;
}


//	---------------------------------------------------------------------------
bool CvPlayer::removeFromArmy(int iID)
{
	CvArmyAI* pLoopArmyAI;
	int iLoop;
	bool bRemoved = false;

	// for all the army AIs
	for(pLoopArmyAI = firstArmyAI(&iLoop); pLoopArmyAI != NULL && !bRemoved; pLoopArmyAI = nextArmyAI(&iLoop))
	{
		// attempt to remove from this army
		bRemoved = removeFromArmy(pLoopArmyAI->GetID(), iID);
	}
	return bRemoved;
}


//	---------------------------------------------------------------------------
//	Finds the path length from this tech type to one you already know
int CvPlayer::findPathLength(TechTypes eTech, bool bCost) const
{
	int i;
	int iNumSteps = 0;
	int iShortestPath = 0;
	int iPathLength = 0;
	TechTypes ePreReq;
	TechTypes eShortestOr;

	CvTechEntry* pkTechInfo = GC.getTechInfo(eTech);
	if(pkTechInfo == NULL)
		return 0;

	if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech(eTech) || m_pPlayerTechs->IsResearchingTech(eTech))
	{
		//	We have this tech, no reason to add this to the pre-reqs
		//	Base case return 0, we know it...
		return 0;
	}

	//	Cycle through the and paths and add up their tech lengths
	for(i = 0; i < GC.getNUM_AND_TECH_PREREQS(); i++)
	{
		ePreReq = (TechTypes)pkTechInfo->GetPrereqAndTechs(i);

		if(ePreReq != NO_TECH)
		{
			iPathLength += findPathLength(ePreReq, bCost);
		}
	}

	eShortestOr = NO_TECH;
	iShortestPath = INT_MAX;
	//	Find the shortest OR tech
	for(i = 0; i < GC.getNUM_OR_TECH_PREREQS(); i++)
	{
		//	Grab the tech
		ePreReq = (TechTypes)pkTechInfo->GetPrereqOrTechs(i);

		//	If this is a valid tech
		if(ePreReq != NO_TECH)
		{
			//	Recursively find the path length (takes into account all ANDs)
			iNumSteps = findPathLength(ePreReq, bCost);

			//	If the prereq is a valid tech and its the current shortest, mark it as such
			if(iNumSteps < iShortestPath)
			{
				eShortestOr = ePreReq;
				iShortestPath = iNumSteps;
			}
		}
	}

	//	If the shortest OR is a valid tech, add the steps to it...
	if(eShortestOr != NO_TECH)
	{
		iPathLength += iShortestPath;
	}

	return (iPathLength + ((bCost) ? GET_TEAM(getTeam()).GetTeamTechs()->GetResearchCost(eTech) : 1));
}


//	--------------------------------------------------------------------------------
//	Function specifically for python/tech chooser screen
int CvPlayer::getQueuePosition(TechTypes eTech) const
{
	int i = 1;
	const CLLNode<TechTypes>* pResearchNode;

	for(pResearchNode = headResearchQueueNode(); pResearchNode; pResearchNode = nextResearchQueueNode(pResearchNode))
	{
		if(pResearchNode->m_data == eTech)
		{
			return i;
		}
		i++;
	}

	return -1;
}


//	--------------------------------------------------------------------------------
void CvPlayer::clearResearchQueue()
{
	int iI;

	m_researchQueue.clear();

	for(iI = 0; iI < GC.getNumTechInfos(); iI++)
	{
		setResearchingTech(((TechTypes)iI), false);
	}

	if(getTeam() == GC.getGame().getActiveTeam())
	{
		GC.GetEngineUserInterface()->setDirty(ResearchButtons_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(Score_DIRTY_BIT, true);
	}
}


//	--------------------------------------------------------------------------------
//	Pushes research onto the queue.  If it is an append if will put it
//	and its pre-reqs into the queue.  If it is not an append it will change
//	research immediately and should be used with clear.  Clear will clear the entire queue.
bool CvPlayer::pushResearch(TechTypes eTech, bool bClear)
{
	int i;
	int iNumSteps;
	int iShortestPath;
	bool bOrPrereqFound;
	TechTypes ePreReq;
	TechTypes eShortestOr;

	CvAssertMsg(eTech != NO_TECH, "Tech is not assigned a valid value");

	CvTechEntry* pkTechInfo = GC.getTechInfo(eTech);
	if(pkTechInfo == NULL)
		return false;


	if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech(eTech) || m_pPlayerTechs->IsResearchingTech(eTech))
	{
		//	We have this tech, no reason to add this to the pre-reqs
		return true;
	}

	if(!GetPlayerTechs()->CanEverResearch(eTech))
	{
		return false;
	}

	//	Pop the entire queue...
	if(bClear)
	{
		clearResearchQueue();
	}

	//	Add in all the pre-reqs for the and techs...
	for(i = 0; i < GC.getNUM_AND_TECH_PREREQS(); i++)
	{
		ePreReq = (TechTypes)pkTechInfo->GetPrereqAndTechs(i);

		if(ePreReq != NO_TECH)
		{
			if(!pushResearch(ePreReq))
			{
				return false;
			}
		}
	}

	// Will return the shortest path of all the or techs.  Tie breaker goes to the first one...
	eShortestOr = NO_TECH;
	iShortestPath = INT_MAX;
	bOrPrereqFound = false;
	//	Cycle through all the OR techs
	for(i = 0; i < GC.getNUM_OR_TECH_PREREQS(); i++)
	{
		ePreReq = (TechTypes)pkTechInfo->GetPrereqOrTechs(i);

		if(ePreReq != NO_TECH)
		{
			bOrPrereqFound = true;

			//	If the pre-req exists, and we have it, it is the shortest path, get out, we're done
			if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech(ePreReq))
			{
				eShortestOr = ePreReq;
				break;
			}

			if(GetPlayerTechs()->CanEverResearch(ePreReq))
			{
				//	Find the length of the path to this pre-req
				iNumSteps = findPathLength(ePreReq);

				//	If this pre-req is a valid tech, and its the shortest current path, set it as such
				if(iNumSteps < iShortestPath)
				{
					eShortestOr = ePreReq;
					iShortestPath = iNumSteps;
				}
			}
		}
	}

	//	If the shortest path tech is valid, push it (and its children) on to the research queue recursively
	if(eShortestOr != NO_TECH)
	{
		if(!pushResearch(eShortestOr))
		{
			return false;
		}
	}
	else if(bOrPrereqFound)
	{
		return false;
	}

	//	Insert this tech at the end of the queue
	m_researchQueue.insertAtEnd(eTech);

	setResearchingTech(eTech, true);

	//	Set the dirty bits
	if(getTeam() == GC.getGame().getActiveTeam())
	{
		GC.GetEngineUserInterface()->setDirty(ResearchButtons_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(Score_DIRTY_BIT, true);
	}
	return true;
}


//	--------------------------------------------------------------------------------
//	If bHead is true we delete the entire queue...
void CvPlayer::popResearch(TechTypes eTech)
{
	CLLNode<TechTypes>* pResearchNode;

	for(pResearchNode = headResearchQueueNode(); pResearchNode; pResearchNode = nextResearchQueueNode(pResearchNode))
	{
		if(pResearchNode->m_data == eTech)
		{
			m_researchQueue.deleteNode(pResearchNode);
			break;
		}
	}

	setResearchingTech(eTech, false);

	if(getTeam() == GC.getGame().getActiveTeam())
	{
		GC.GetEngineUserInterface()->setDirty(ResearchButtons_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(Score_DIRTY_BIT, true);
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getLengthResearchQueue() const
{
	return m_researchQueue.getLength();
}


//	--------------------------------------------------------------------------------
CLLNode<TechTypes>* CvPlayer::nextResearchQueueNode(CLLNode<TechTypes>* pNode)
{
	return m_researchQueue.next(pNode);
}

//	--------------------------------------------------------------------------------
const CLLNode<TechTypes>* CvPlayer::nextResearchQueueNode(const CLLNode<TechTypes>* pNode) const
{
	return m_researchQueue.next(pNode);
}

//	--------------------------------------------------------------------------------
CLLNode<TechTypes>* CvPlayer::headResearchQueueNode()
{
	return m_researchQueue.head();
}

//	--------------------------------------------------------------------------------
const CLLNode<TechTypes>* CvPlayer::headResearchQueueNode() const
{
	return m_researchQueue.head();
}

//	--------------------------------------------------------------------------------
CLLNode<TechTypes>* CvPlayer::tailResearchQueueNode()
{
	return m_researchQueue.tail();
}


//	--------------------------------------------------------------------------------
void CvPlayer::addCityName(const CvString& szName)
{
	m_cityNames.insertAtEnd(szName);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getNumCityNames() const
{
	return m_cityNames.getLength();
}


//	--------------------------------------------------------------------------------
CvString CvPlayer::getCityName(int iIndex) const
{
	CLLNode<CvString>* pCityNameNode;

	pCityNameNode = m_cityNames.nodeNum(iIndex);

	if(pCityNameNode != NULL)
	{
		return pCityNameNode->m_data;
	}
	else
	{
		return "";
	}
}

//	--------------------------------------------------------------------------------
CLLNode<CvString>* CvPlayer::nextCityNameNode(CLLNode<CvString>* pNode)
{
	return m_cityNames.next(pNode);
}

//	--------------------------------------------------------------------------------
const CLLNode<CvString>* CvPlayer::nextCityNameNode(const CLLNode<CvString>* pNode) const
{
	return m_cityNames.next(pNode);
}

//	--------------------------------------------------------------------------------
CLLNode<CvString>* CvPlayer::headCityNameNode()
{
	return m_cityNames.head();
}

//	--------------------------------------------------------------------------------
const CLLNode<CvString>* CvPlayer::headCityNameNode() const
{
	return m_cityNames.head();
}

//	--------------------------------------------------------------------------------
CvCity* CvPlayer::firstCity(int* pIterIdx, bool bRev)
{
	if (bRev)
		*pIterIdx = m_cities.GetCount()-1;
	else
		*pIterIdx = 0;
	return m_cities.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
const CvCity* CvPlayer::firstCity(int* pIterIdx, bool bRev) const
{
	if (bRev)
		*pIterIdx = m_cities.GetCount()-1;
	else
		*pIterIdx = 0;
	return m_cities.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
CvCity* CvPlayer::nextCity(int* pIterIdx, bool bRev)
{
	if (bRev)
		(*pIterIdx)--;
	else
		(*pIterIdx)++;

	return m_cities.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
const CvCity* CvPlayer::nextCity(int* pIterIdx, bool bRev) const
{
	if (bRev)
		(*pIterIdx)--;
	else
		(*pIterIdx)++;

	return m_cities.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
#if defined(MOD_BALANCE_CORE)
CvCity* CvPlayer::nextCity(const CvCity* pCurrent, bool bRev)
{
	int iIdx = m_cities.GetIndexForID(pCurrent->GetID());

	if (iIdx<0)
		return NULL;

	if (bRev)
		iIdx--;
	else
		iIdx++;

	return m_cities.GetAt(iIdx);
}

//	--------------------------------------------------------------------------------
const CvCity* CvPlayer::nextCity(const CvCity* pCurrent, bool bRev) const
{
	int iIdx = m_cities.GetIndexForID(pCurrent->GetID());

	if (iIdx<0)
		return NULL;

	if (bRev)
		iIdx--;
	else
		iIdx++;

	return m_cities.GetAt(iIdx);
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getNumCities() const
{
	return m_cities.GetCount();
}

//	--------------------------------------------------------------------------------
CvCity* CvPlayer::getCity(int iID) const
{
	return(m_cities.Get(iID));
}

//	--------------------------------------------------------------------------------
CvCity* CvPlayer::addCity()
{
	return(m_cities.Add());
}

//	--------------------------------------------------------------------------------
void CvPlayer::deleteCity(int iID)
{
	m_cities.Remove(iID);

#if defined(MOD_BALANCE_CORE_SETTLER)
	SetClosestCityMapDirty();
#endif

#if defined(MOD_BALANCE_CORE)
	int iLoop=0;
	for (CvCity* pCity=firstCity(&iLoop); pCity!=NULL; pCity=nextCity(&iLoop))
		pCity->UpdateClosestFriendlyNeighbors();
#endif
}

#if defined(MOD_BALANCE_CORE)
void CvPlayer::SetClosestCityMapDirty()
{
	if (m_pCityDistance)
		m_pCityDistance->SetDirty();

	GC.getGame().SetClosestCityMapDirty();
}

int CvPlayer::GetCityDistance( const CvPlot* pPlot ) const
{
	if (pPlot && m_pCityDistance)
		return m_pCityDistance->GetClosestFeatureDistance( *pPlot );
	else
		return INT_MAX;
}

CvCity* CvPlayer::GetClosestCity( const CvPlot* pPlot ) const
{
	if (pPlot && m_pCityDistance)
		return getCity(m_pCityDistance->GetClosestFeatureID( *pPlot ));
	else
		return NULL;
}
#endif

//	--------------------------------------------------------------------------------
CvCity* CvPlayer::GetFirstCityWithBuildingClass(BuildingClassTypes eBuildingClass)
{
	CvCity *pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		CvCivilizationInfo& playerCivilizationInfo = getCivilizationInfo();
		BuildingTypes eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings((BuildingClassTypes)eBuildingClass);
		if (eBuilding != NO_BUILDING)
		{
			if (pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
			{
				return pLoopCity;
			}
		}
	}
	return false;
}

//	--------------------------------------------------------------------------------
const CvUnit* CvPlayer::firstUnit(int* pIterIdx, bool bRev) const
{
	if (bRev)
		*pIterIdx = m_units.GetCount()-1;
	else
		*pIterIdx = 0;
	return m_units.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
CvUnit* CvPlayer::firstUnit(int* pIterIdx, bool bRev)
{
	if (bRev)
		*pIterIdx = m_units.GetCount()-1;
	else
		*pIterIdx = 0;
	return m_units.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
const CvUnit* CvPlayer::nextUnit(int* pIterIdx, bool bRev) const
{
	if (bRev)
		(*pIterIdx)--;
	else
		(*pIterIdx)++;
	return m_units.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
CvUnit* CvPlayer::nextUnit(int* pIterIdx, bool bRev)
{
	if (bRev)
		(*pIterIdx)--;
	else
		(*pIterIdx)++;
	return m_units.GetAt(*pIterIdx);
}
#if defined(MOD_BALANCE_CORE)
CvUnit* CvPlayer::nextUnit(const CvUnit* pCurrent, bool bRev)
{
	int iIdx = m_units.GetIndexForID(pCurrent->GetID());

	if (iIdx<0)
		return NULL;

	if (bRev)
		iIdx--;
	else
		iIdx++;

	return m_units.GetAt(iIdx);
}

//	--------------------------------------------------------------------------------
const CvUnit* CvPlayer::nextUnit(const CvCity* pCurrent, bool bRev) const
{
	int iIdx = m_units.GetIndexForID(pCurrent->GetID());

	if (iIdx<0)
		return NULL;

	if (bRev)
		iIdx--;
	else
		iIdx++;

	return m_units.GetAt(iIdx);
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::getNumUnits() const
{
	return m_units.GetCount();
}


//	--------------------------------------------------------------------------------
CvUnit* CvPlayer::getUnit(int iID) const
{
#if defined(MOD_BALANCE_CORE)
	//spread it out a little for an easy breakpoint
	CvUnit* pUnit = m_units.Get(iID);
	return pUnit;
#else
	return (m_units.GetAt(iID));
#endif
}

//	--------------------------------------------------------------------------------
CvUnit* CvPlayer::addUnit()
{
	CvUnit* pResult = m_units.Add();

	//debugging ...
	for (int iIdx = 0; iIdx < m_units.GetCount()-1; iIdx++)
	{
		if (m_units.GetAt(iIdx)==pResult)
			OutputDebugString("inconsistent state: double unit pointer!\n");
	}

	return pResult;
}


//	--------------------------------------------------------------------------------
void CvPlayer::deleteUnit(int iID)
{
	m_units.Remove(iID);
}


//	--------------------------------------------------------------------------------
const CvArmyAI* CvPlayer::firstArmyAI(int* pIterIdx, bool bRev) const
{
	if (bRev)
		*pIterIdx = m_armyAIs.GetCount()-1;
	else
		*pIterIdx = 0;
	return m_armyAIs.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
CvArmyAI* CvPlayer::firstArmyAI(int* pIterIdx, bool bRev)
{
	if (bRev)
		*pIterIdx = m_armyAIs.GetCount()-1;
	else
		*pIterIdx = 0;	
	return m_armyAIs.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
const CvArmyAI* CvPlayer::nextArmyAI(int* pIterIdx, bool bRev) const
{
	if (bRev)
		(*pIterIdx)--;
	else
		(*pIterIdx)++;
	return m_armyAIs.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
CvArmyAI* CvPlayer::nextArmyAI(int* pIterIdx, bool bRev)
{
	if (bRev)
		(*pIterIdx)--;
	else
		(*pIterIdx)++;
	return m_armyAIs.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNumArmyAIs() const
{
	return m_armyAIs.GetCount();
}


//	--------------------------------------------------------------------------------
const CvArmyAI* CvPlayer::getArmyAI(int iID) const
{
	return ((CvArmyAI*)(m_armyAIs.Get(iID)));
}

//	--------------------------------------------------------------------------------
CvArmyAI* CvPlayer::getArmyAI(int iID)
{
	return ((CvArmyAI*)(m_armyAIs.Get(iID)));
}


//	--------------------------------------------------------------------------------
CvArmyAI* CvPlayer::addArmyAI()
{
	return ((CvArmyAI*)(m_armyAIs.Add()));
}


//	--------------------------------------------------------------------------------
void CvPlayer::deleteArmyAI(int iID)
{
	bool bRemoved = m_armyAIs.Remove(iID);
	DEBUG_VARIABLE(bRemoved);
	CvAssertMsg(bRemoved, "could not find army, delete failed");
}


//	--------------------------------------------------------------------------------
const CvAIOperation* CvPlayer::getAIOperation(int iID) const
{
	std::map<int, CvAIOperation*>::const_iterator it = m_AIOperations.find(iID);
	if(it != m_AIOperations.end())
	{
		return it->second;
	}
	return 0;
}

//	--------------------------------------------------------------------------------
CvAIOperation* CvPlayer::getFirstAIOperation()
{
	CvAIOperation* rtnValue = NULL;

	m_CurrentOperation = m_AIOperations.begin();
	if(m_CurrentOperation != m_AIOperations.end())
	{
		rtnValue = m_CurrentOperation->second;
	}
	return rtnValue;
}

//	--------------------------------------------------------------------------------
CvAIOperation* CvPlayer::getNextAIOperation()
{
	CvAIOperation* rtnValue = NULL;

	if(m_CurrentOperation != m_AIOperations.end())
	{
		++m_CurrentOperation;
		if(m_CurrentOperation != m_AIOperations.end())
		{
			rtnValue = m_CurrentOperation->second;
		}
	}
	return rtnValue;
}

//	--------------------------------------------------------------------------------
CvAIOperation* CvPlayer::getAIOperation(int iID)
{
	std::map<int, CvAIOperation*>::iterator it = m_AIOperations.find(iID);
	if(it != m_AIOperations.end())
	{
		return it->second;
	}
	return 0;
}


//	--------------------------------------------------------------------------------
CvAIOperation* CvPlayer::addAIOperation(int OperationType, PlayerTypes eEnemy, int /*iArea*/, CvCity* pTarget, CvCity* pMuster)
{
	CvAIOperation* pNewOperation = CvAIOperation::CreateOperation((AIOperationTypes) OperationType, m_eID);
	if(pNewOperation)
	{
		m_AIOperations.insert(std::make_pair(m_iNextOperationID.get(), pNewOperation));
		pNewOperation->Init(m_iNextOperationID, m_eID, eEnemy, pTarget, pMuster);
		m_iNextOperationID++;
	}
	return pNewOperation;
}

//	--------------------------------------------------------------------------------
void CvPlayer::deleteAIOperation(int iID)
{
	std::map<int, CvAIOperation*>::iterator it = m_AIOperations.find(iID);
	if(it != m_AIOperations.end())
	{
		delete(it->second);
		m_AIOperations.erase(it);
	}
	else
	{
		CvAssertMsg(false, "could not find operation, delete failed");
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::haveAIOperationOfType(int iOperationType, int* piID /* optional return argument */, PlayerTypes eTargetPlayer /* optional additional match criteria */, CvPlot* pTarget /* optional additional match criteria */)
{
	// loop through all entries looking for match
	std::map<int , CvAIOperation*>::iterator iter;
	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
	{
		CvAIOperation* pThisOperation = iter->second;
		if(pThisOperation->GetOperationType() == iOperationType)
		{
			if(eTargetPlayer == NO_PLAYER || eTargetPlayer == pThisOperation->GetEnemy())
			{
				if(pTarget == NULL || pTarget == pThisOperation->GetTargetPlot())
				{
					// Fill in optional parameter (ID) if passed in
					if(piID != NULL)
					{
						*piID = pThisOperation->GetID();
					}
					return true;
				}
			}
		}
	}
	// Fill in optional parameter (ID) if passed in
	if(piID != NULL)
	{
		*piID = -1;
	}
	return false;
}

//	--------------------------------------------------------------------------------
int CvPlayer::numOperationsOfType(int iOperationType)
{
	int iRtnValue = 0;

	std::map<int , CvAIOperation*>::iterator iter;
	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
	{
		CvAIOperation* pThisOperation = iter->second;
		if(pThisOperation->GetOperationType() == iOperationType)
		{
			iRtnValue++;
		}
	}

	return iRtnValue;
}

//	--------------------------------------------------------------------------------
/// Is an existing operation already going after this city?
bool CvPlayer::IsCityAlreadyTargeted(CvCity* pCity, DomainTypes eDomain, int iPercentToTarget, int iIgnoreOperationID) const
{
	CvAIOperation* pOperation;
	std::map<int , CvAIOperation*>::const_iterator iter;

	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
	{
		pOperation = iter->second;

		if(pOperation)
		{
			if(iIgnoreOperationID == -1 || iIgnoreOperationID != pOperation->GetID())
			{
				if(pOperation->PercentFromMusterPointToTarget() < iPercentToTarget)
				{
					if(pOperation->GetTargetPlot() != NULL)
					{
						if(pOperation->GetTargetPlot() == pCity->plot())
						{
							// Naval attacks are mixed land/naval operations
							if((eDomain == NO_DOMAIN || eDomain == DOMAIN_SEA) && pOperation->IsNavalOperation())
							{
								return true;
							}

							if((eDomain == NO_DOMAIN || eDomain == DOMAIN_LAND) && !pOperation->IsNavalOperation())
							{
								return true;
							}
						}
						else if(pOperation->GetTargetPlot()->getWorkingCity() != NULL)
						{
							if(pOperation->GetTargetPlot()->getWorkingCity() == pCity)
							{
								// Naval attacks are mixed land/naval operations
								if((eDomain == NO_DOMAIN || eDomain == DOMAIN_SEA) && pOperation->IsNavalOperation())
								{
									return true;
								}

								if((eDomain == NO_DOMAIN || eDomain == DOMAIN_LAND) && !pOperation->IsNavalOperation())
								{
									return true;
								}
							}
						}
					}
				}
			}
		}
	}

	return false;
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Is an existing operation already starting from this city?
bool CvPlayer::IsMusterCityAlreadyTargeted(CvCity* pCity, DomainTypes eDomain, int iPercentToTarget, int iIgnoreOperationID) const
{
	CvAIOperation* pOperation;
	std::map<int , CvAIOperation*>::const_iterator iter;

	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
	{
		pOperation = iter->second;

		if(pOperation)
		{
			if(iIgnoreOperationID == -1 || iIgnoreOperationID != pOperation->GetID())
			{
				if(pOperation->PercentFromMusterPointToTarget() < iPercentToTarget)
				{
					if(pOperation->GetMusterPlot() != NULL)
					{
						if(pOperation->GetMusterPlot() == pCity->plot())
						{
							// Naval attacks are mixed land/naval operations
							if((eDomain == NO_DOMAIN || eDomain == DOMAIN_SEA) && pOperation->IsNavalOperation())
							{
								return true;
							}

							if((eDomain == NO_DOMAIN || eDomain == DOMAIN_LAND) && !pOperation->IsNavalOperation())
							{
								return true;
							}
						}
						else if(pOperation->GetMusterPlot()->getWorkingCity() != NULL)
						{
							if(pOperation->GetMusterPlot()->getWorkingCity() == pCity)
							{
								// Naval attacks are mixed land/naval operations
								if((eDomain == NO_DOMAIN || eDomain == DOMAIN_SEA) && pOperation->IsNavalOperation())
								{
									return true;
								}

								if((eDomain == NO_DOMAIN || eDomain == DOMAIN_LAND) && !pOperation->IsNavalOperation())
								{
									return true;
								}
							}
						}
					}
				}
			}
		}
	}

	return false;
}
#endif

#if defined(MOD_BALANCE_CORE)
bool CvPlayer::IsPlotTargetedForExplorer(const CvPlot* pPlot, const CvUnit* pIgnoreUnit) const
{
	if (!pPlot)
		return false;

	// Loop through our units
	int iLoop = 0;
	for(const CvUnit* pUnit = firstUnit(&iLoop); pUnit; pUnit = nextUnit(&iLoop))
	{
		if (pUnit==pIgnoreUnit)
			continue;

		if(pUnit->AI_getUnitAIType() == UNITAI_EXPLORE || (pUnit->IsAutomated() && pUnit->GetAutomateType() == AUTOMATE_EXPLORE) )
		{
			CvPlot* pMissionPlot = pUnit->GetMissionAIPlot();
			if (pMissionPlot && ::plotDistance(*pMissionPlot,*pPlot)<3)
				return true;
		}
	}
	return false;
}
#endif

//	--------------------------------------------------------------------------------
/// Are we already sending a settler to this plot (or any plot within 2)
#if defined(MOD_BALANCE_CORE_SETTLER)
bool CvPlayer::IsPlotTargetedForCity(CvPlot *pPlot, CvAIOperation* pOpToIgnore) const
#else
bool CvPlayer::IsPlotTargetedForCity(CvPlot *pPlot) const
#endif
{
	CvAIOperation* pOperation;
	std::map<int , CvAIOperation*>::const_iterator iter;

	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
	{
		pOperation = iter->second;
#if defined(MOD_BALANCE_CORE_SETTLER)
		if(MOD_BALANCE_CORE_SETTLER)
		{
			if(pOperation && pOperation != pOpToIgnore && pOperation->HasTargetPlot())
			{
				switch (pOperation->GetOperationType())
				{
				case AI_OPERATION_FOUND_CITY:
				case AI_OPERATION_NAVAL_COLONIZATION:
				case AI_OPERATION_QUICK_COLONIZE:
					{
						if (plotDistance(pPlot->getX(), pPlot->getY(), pOperation->GetTargetPlot()->getX(), pOperation->GetTargetPlot()->getY()) <= 3)
						{
							return true;
						}
					}
				}
			}
		}
		else
#endif
		if(pOperation)
		{
			switch (pOperation->GetOperationType())
			{
			case AI_OPERATION_FOUND_CITY:
			case AI_OPERATION_NAVAL_COLONIZATION:
			case AI_OPERATION_QUICK_COLONIZE:
				{
					if (plotDistance(pPlot->getX(), pPlot->getY(), pOperation->GetTargetPlot()->getX(), pOperation->GetTargetPlot()->getY()) <= 2)
					{
						return true;
					}
				}
			}
		}
	}
	return false;
}

//	--------------------------------------------------------------------------------
unsigned int CvPlayer::getNumReplayDataSets() const
{
	return m_ReplayDataSets.size();
}

//	--------------------------------------------------------------------------------
const char* CvPlayer::getReplayDataSetName(unsigned int idx) const
{
	if(idx < m_ReplayDataSets.size())
		return m_ReplayDataSets[idx];

	return NULL;
}

//	--------------------------------------------------------------------------------
unsigned int CvPlayer::getReplayDataSetIndex(const char* szDataSetName)
{
	CvString dataSetName = szDataSetName;

	unsigned int idx = 0;
	for(std::vector<CvString>::iterator it = m_ReplayDataSets.begin(); it != m_ReplayDataSets.end(); ++it)
	{
		if((*it) == dataSetName)
			return idx;

		idx++;
	}

	m_ReplayDataSets.push_back(dataSetName);
	m_ReplayDataSetValues.push_back(TurnData());
	return m_ReplayDataSets.size() - 1;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getReplayDataValue(unsigned int uiDataSet, unsigned int uiTurn) const
{
	if(uiDataSet < m_ReplayDataSetValues.size())
	{
		const TurnData& dataSet = m_ReplayDataSetValues[uiDataSet];
		TurnData::const_iterator it = dataSet.find(uiTurn);
		if(it != dataSet.end())
		{
			return (*it).second;
		}
	}

	return -1;
}
//	--------------------------------------------------------------------------------
void CvPlayer::setReplayDataValue(unsigned int uiDataSet, unsigned int uiTurn, int iValue)
{
	if(uiDataSet < m_ReplayDataSetValues.size())
	{
		TurnData& dataSet = m_ReplayDataSetValues[uiDataSet];
		dataSet[uiTurn] = iValue;
	}
}

//	--------------------------------------------------------------------------------
CvPlayer::TurnData CvPlayer::getReplayDataHistory(unsigned int uiDataSet) const
{
	if(uiDataSet < m_ReplayDataSetValues.size())
	{
		return m_ReplayDataSetValues[uiDataSet];
	}

	return CvPlayer::TurnData();
}

//	--------------------------------------------------------------------------------
std::string CvPlayer::getScriptData() const
{
	return m_strScriptData;
}

//	--------------------------------------------------------------------------------
void CvPlayer::setScriptData(std::string strNewValue)
{
	m_strScriptData = strNewValue;
}

//	--------------------------------------------------------------------------------
const CvString& CvPlayer::getPbemEmailAddress() const
{
	return CvPreGame::emailAddress(GetID());
}

//	--------------------------------------------------------------------------------
void CvPlayer::setPbemEmailAddress(const char* szAddress)
{
	CvPreGame::setEmailAddress(GetID(), szAddress);
}

// Protected Functions...

//	--------------------------------------------------------------------------------
void CvPlayer::doResearch()
{
	if(GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))
	{
		return;
	}

	AI_PERF_FORMAT("AI-perf.csv", ("CvPlayer::doResearch, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), getCivilizationShortDescription()) );
	bool bForceResearchChoice;
	int iOverflowResearch;

	if(GetPlayerTechs()->IsResearch())
	{
		bForceResearchChoice = false;

		// Force player to pick Research if he doesn't have anything assigned
		if(GetPlayerTechs()->GetCurrentResearch() == NO_TECH)
		{
			if(GetID() == GC.getGame().getActivePlayer() && GetScienceTimes100() > 0)
			{
				chooseTech();
			}

			if(GC.getGame().getElapsedGameTurns() > 4)
			{
				AI_chooseResearch();

				bForceResearchChoice = true;
			}
		}

		TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
		if(eCurrentTech == NO_TECH)
		{
			int iOverflow = (GetScienceTimes100()) / std::max(1, calculateResearchModifier(eCurrentTech));
			changeOverflowResearchTimes100(iOverflow);
		}
		else
		{
			iOverflowResearch = (getOverflowResearchTimes100() * calculateResearchModifier(eCurrentTech)) / 100;
			setOverflowResearch(0);
			if(GET_TEAM(getTeam()).GetTeamTechs())
			{
				int iBeakersTowardsTechTimes100 = GetScienceTimes100() + iOverflowResearch;
#if defined(MOD_BUGFIX_RESEARCH_OVERFLOW)
				GET_TEAM(getTeam()).GetTeamTechs()->ChangeResearchProgressTimes100(eCurrentTech, iBeakersTowardsTechTimes100, GetID(), iOverflowResearch, calculateResearchModifier(eCurrentTech));
#else
				GET_TEAM(getTeam()).GetTeamTechs()->ChangeResearchProgressTimes100(eCurrentTech, iBeakersTowardsTechTimes100, GetID());
#endif
				UpdateResearchAgreements(GetScienceTimes100() / 100);
			}
		}

		if(bForceResearchChoice)
		{
			clearResearchQueue();
		}
	}
	GetPlayerTechs()->CheckForTechAchievement();

}

//	--------------------------------------------------------------------------------
void CvPlayer::doAdvancedStartAction(AdvancedStartActionTypes eAction, int iX, int iY, int iData, bool bAdd)
{
	CvPlot* pPlot = GC.getMap().plot(iX, iY);

	if(0 == getNumCities())
	{
		switch(eAction)
		{
		case ADVANCEDSTARTACTION_EXIT:
			//Try to build this player's empire
			if(GetID() == GC.getGame().getActivePlayer())
			{
				GC.GetEngineUserInterface()->setBusy(true);
			}
			if(GetID() == GC.getGame().getActivePlayer())
			{
				GC.GetEngineUserInterface()->setBusy(false);
			}
			break;
		case ADVANCEDSTARTACTION_AUTOMATE:
		case ADVANCEDSTARTACTION_CITY:
			break;
		default:
			// The first action must be to place a city
			// so players can lose by spending everything
			return;
		}
	}

	switch(eAction)
	{
	case ADVANCEDSTARTACTION_EXIT:
		GetTreasury()->ChangeGold(getAdvancedStartPoints());
		setAdvancedStartPoints(-1);
		if(GC.getGame().getActivePlayer() == GetID())
		{
			GC.GetEngineUserInterface()->setInAdvancedStart(false);
		}

		if(isHuman())
		{
			int iLoop;
			for(CvCity* pCity = firstCity(&iLoop); NULL != pCity; pCity = nextCity(&iLoop))
			{
				pCity->chooseProduction();
			}

			chooseTech();
		}
		break;
	case ADVANCEDSTARTACTION_AUTOMATE:
		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setBusy(true);
		}
		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setBusy(false);
		}
		break;
	case ADVANCEDSTARTACTION_UNIT:
	{
		if(pPlot == NULL)
			return;

		UnitTypes eUnit = (UnitTypes) iData;
		int iCost = getAdvancedStartUnitCost(eUnit, bAdd, pPlot);

		if(bAdd && iCost < 0)
		{
			return;
		}

		// Add unit to the map
		if(bAdd)
		{
			if(getAdvancedStartPoints() >= iCost)
			{
				CvUnit* pUnit = initUnit(eUnit, iX, iY);
				if(NULL != pUnit)
				{
					pUnit->finishMoves();
					changeAdvancedStartPoints(-iCost);
				}
			}
		}

		// Remove unit from the map
		else
		{
			// If cost is -1 we already know this unit isn't present
			if(iCost != -1)
			{
				IDInfo* pUnitNode = pPlot->headUnitNode();
				while(pUnitNode != NULL)
				{
					CvUnit* pLoopUnit = ::getUnit(*pUnitNode);
					pUnitNode = pPlot->nextUnitNode(pUnitNode);

					if(NULL != pLoopUnit && pLoopUnit->getUnitType() == eUnit)
					{
						pLoopUnit->kill(false);
						changeAdvancedStartPoints(iCost);
						return;
					}
				}
			}

			// Proper unit not found above, delete first found
			IDInfo* pUnitNode = pPlot->headUnitNode();
			if(pUnitNode != NULL)
			{
				CvUnit* pUnit = ::getUnit(*pUnitNode);

				iCost = getAdvancedStartUnitCost(pUnit->getUnitType(), false);
				CvAssertMsg(iCost != -1, "If this is -1 then that means it's going to try to delete a unit which shouldn't exist");
				pUnit->kill(false);
				changeAdvancedStartPoints(iCost);
			}
		}

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Advanced_Start_DIRTY_BIT, true);
		}
	}
	break;
	case ADVANCEDSTARTACTION_CITY:
	{
		if(pPlot == NULL)
			return;

		int iCost = getAdvancedStartCityCost(bAdd, pPlot);

		if(iCost < 0)
		{
			return;
		}

		// Add City to the map
		if(bAdd)
		{
			if(0 == getNumCities())
			{
				PlayerTypes eClosestPlayer = NO_PLAYER;
				int iMinDistance = INT_MAX;
				for(int iPlayer = 0; iPlayer < MAX_CIV_PLAYERS; iPlayer++)
				{
					CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iPlayer);
					if(kPlayer.isAlive())
					{
						if(kPlayer.getTeam() == getTeam())
						{
							if(0 == kPlayer.getNumCities())
							{
								CvAssert(kPlayer.getStartingPlot() != NULL);
								int iDistance = plotDistance(iX, iY, kPlayer.getStartingPlot()->getX(), kPlayer.getStartingPlot()->getY());
								if(iDistance < iMinDistance)
								{
									eClosestPlayer = kPlayer.GetID();
									iMinDistance = iDistance;
								}
							}
						}
					}
				}
				CvAssertMsg(eClosestPlayer != NO_PLAYER, "Self at a minimum should always be valid");
				if(eClosestPlayer != GetID())
				{
					CvPlot* pTempPlot = GET_PLAYER(eClosestPlayer).getStartingPlot();
					GET_PLAYER(eClosestPlayer).setStartingPlot(getStartingPlot());
					setStartingPlot(pTempPlot);
				}
			}
			if(getAdvancedStartPoints() >= iCost || 0 == getNumCities())
			{
				found(iX, iY);
				changeAdvancedStartPoints(-iCost);
				CvCity* pCity = pPlot->getPlotCity();
				if(pCity != NULL)
				{
					if(pCity->getPopulation() > 1)
					{
						pCity->setFood(pCity->growthThreshold() / 2);
					}
				}
			}
		}

		// Remove City from the map
		else
		{
			pPlot->setRouteType(NO_ROUTE);
			pPlot->getPlotCity()->kill();
			pPlot->setImprovementType(NO_IMPROVEMENT);
			changeAdvancedStartPoints(iCost);
		}

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Advanced_Start_DIRTY_BIT, true);
		}
	}
	break;
	case ADVANCEDSTARTACTION_POP:
	{
		if(pPlot == NULL)
			return;

		CvCity* pCity = pPlot->getPlotCity();

		if(pCity != NULL)
		{
			int iCost = getAdvancedStartPopCost(bAdd, pCity);

			if(iCost < 0)
			{
				return;
			}

			// Add Pop to the City
			if(bAdd)
			{
				if(getAdvancedStartPoints() >= iCost)
				{
					pCity->changePopulation(1);
					changeAdvancedStartPoints(-iCost);
					if(pCity->getPopulation() > 1)
					{
						pCity->setFood(pCity->growthThreshold() / 2);
						pCity->setFoodKept((pCity->getFood() * pCity->getMaxFoodKeptPercent()) / 100);
					}
				}
			}

			// Remove Pop from the city
			else
			{
				pCity->changePopulation(-1);
				changeAdvancedStartPoints(iCost);
				if(pCity->getPopulation() == 1)
				{
					pCity->setFood(0);
					pCity->setFoodKept(0);
				}
			}
		}
	}
	break;
	case ADVANCEDSTARTACTION_BUILDING:
	{
		if(pPlot == NULL)
			return;

		CvCity* pCity = pPlot->getPlotCity();

		if(pCity != NULL)
		{
			BuildingTypes eBuilding = (BuildingTypes) iData;

			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
			if(pkBuildingInfo == NULL)
			{
				return;
			}

			int iCost = getAdvancedStartBuildingCost(eBuilding, bAdd, pCity);
			if(iCost < 0)
			{
				return;
			}

			// Add Building to the City
			if(bAdd)
			{
				if(getAdvancedStartPoints() >= iCost)
				{
					pCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, pCity->GetCityBuildings()->GetNumRealBuilding(eBuilding)+1);
					changeAdvancedStartPoints(-iCost);
					if(pkBuildingInfo->GetFoodKept() != 0)
					{
						pCity->setFoodKept((pCity->getFood() * pCity->getMaxFoodKeptPercent()) / 100);
					}
				}
			}

			// Remove Building from the map
			else
			{
				pCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, pCity->GetCityBuildings()->GetNumRealBuilding(eBuilding)-1);
				changeAdvancedStartPoints(iCost);
				if(pkBuildingInfo->GetFoodKept() != 0)
				{
					pCity->setFoodKept((pCity->getFood() * pCity->getMaxFoodKeptPercent()) / 100);
				}
			}
		}

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Advanced_Start_DIRTY_BIT, true);
		}
	}
	break;
	case ADVANCEDSTARTACTION_ROUTE:
	{
		if(pPlot == NULL)
			return;

		RouteTypes eRoute = (RouteTypes) iData;
		int iCost = getAdvancedStartRouteCost(eRoute, bAdd, pPlot);

		if(bAdd && iCost < 0)
		{
			return;
		}

		// Add Route to the plot
		if(bAdd)
		{
			if(getAdvancedStartPoints() >= iCost)
			{
				pPlot->setRouteType(eRoute);
				changeAdvancedStartPoints(-iCost);
			}
		}

		// Remove Route from the Plot
		else
		{
			if(pPlot->getRouteType() != eRoute)
			{
				eRoute = pPlot->getRouteType();
				iCost = getAdvancedStartRouteCost(eRoute, bAdd);
			}

			if(iCost < 0)
			{
				return;
			}

			pPlot->setRouteType(NO_ROUTE);
			changeAdvancedStartPoints(iCost);
		}

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Advanced_Start_DIRTY_BIT, true);
		}
	}
	break;
	case ADVANCEDSTARTACTION_IMPROVEMENT:
	{
		if(pPlot == NULL)
			return;

		ImprovementTypes eImprovement = (ImprovementTypes) iData;
		int iCost = getAdvancedStartImprovementCost(eImprovement, bAdd, pPlot);

		if(bAdd && iCost < 0)
		{
			return;
		}

		// Add Improvement to the plot
		if(bAdd)
		{
			if(getAdvancedStartPoints() >= iCost)
			{
				if(pPlot->getFeatureType() != NO_FEATURE)
				{
					for(int iI = 0; iI < GC.getNumBuildInfos(); ++iI)
					{
						CvBuildInfo* pkBuildInfo = GC.getBuildInfo((BuildTypes) iI);
						if(!pkBuildInfo)
						{
							continue;
						}

						ImprovementTypes eLoopImprovement = ((ImprovementTypes)(pkBuildInfo->getImprovement()));

						if(eImprovement == eLoopImprovement)
						{
							if(pkBuildInfo->isFeatureRemove(pPlot->getFeatureType()) && canBuild(pPlot, (BuildTypes)iI))
							{
								pPlot->setFeatureType(NO_FEATURE);
								break;
							}
						}
					}
				}

				pPlot->setImprovementType(eImprovement, GetID());

				changeAdvancedStartPoints(-iCost);
			}
		}

		// Remove Improvement from the Plot
		else
		{
			if(pPlot->getImprovementType() != eImprovement)
			{
				eImprovement = pPlot->getImprovementType();
				iCost = getAdvancedStartImprovementCost(eImprovement, bAdd, pPlot);
			}

			if(iCost < 0)
			{
				return;
			}

			pPlot->setImprovementType(NO_IMPROVEMENT);
			changeAdvancedStartPoints(iCost);
		}

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Advanced_Start_DIRTY_BIT, true);
		}
	}
	break;
	case ADVANCEDSTARTACTION_TECH:
	{
		TechTypes eTech = (TechTypes) iData;
		int iCost = getAdvancedStartTechCost(eTech, bAdd);

		if(iCost < 0)
		{
			return;
		}

		// Add Tech to team
		if(bAdd)
		{
			if(getAdvancedStartPoints() >= iCost)
			{
				GET_TEAM(getTeam()).setHasTech(eTech, true, GetID(), false, false);
				changeAdvancedStartPoints(-iCost);
			}
		}

		// Remove Tech from the Team
		else
		{
			GET_TEAM(getTeam()).setHasTech(eTech, false, GetID(), false, false);
			changeAdvancedStartPoints(iCost);
		}

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Advanced_Start_DIRTY_BIT, true);
		}
	}
	break;
	case ADVANCEDSTARTACTION_VISIBILITY:
	{
		if(pPlot == NULL)
			return;

		int iCost = getAdvancedStartVisibilityCost(bAdd, pPlot);

		if(iCost < 0)
		{
			return;
		}

		// Add Visibility to the plot
		if(bAdd)
		{
			if(getAdvancedStartPoints() >= iCost)
			{
				pPlot->setRevealed(getTeam(), true, true);
				changeAdvancedStartPoints(-iCost);
			}
		}

		// Remove Visibility from the Plot
		else
		{
			pPlot->setRevealed(getTeam(), false, true);
			changeAdvancedStartPoints(iCost);
		}
	}
	break;
	default:
		CvAssert(false);
		break;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing a unit
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartUnitCost(UnitTypes eUnit, bool bAdd, CvPlot* pPlot)
{
	if(0 == getNumCities())
	{
		return -1;
	}

	CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
	if(pkUnitInfo == NULL)
	{
		return -1;
	}

	int iCost = (getProductionNeeded(eUnit) * pkUnitInfo->GetAdvancedStartCost()) / 100;
	if(iCost < 0)
	{
		return -1;
	}

	if(NULL == pPlot)
	{
		if(bAdd)
		{
			bool bValid = false;
			int iLoop;
			for(CvCity* pLoopCity = firstCity(&iLoop); NULL != pLoopCity; pLoopCity = nextCity(&iLoop))
			{
				if(pLoopCity->canTrain(eUnit))
				{
					bValid = true;
					break;
				}
			}

			if(!bValid)
			{
				return -1;
			}
		}
	}
	else
	{
		CvCity* pCity = NULL;

		if(0 == GC.getADVANCED_START_ALLOW_UNITS_OUTSIDE_CITIES())
		{
			pCity = pPlot->getPlotCity();

			if(NULL == pCity || pCity->getOwner() != GetID())
			{
				return -1;
			}

			iCost *= 100;
			iCost /= std::max(1, 100 + pCity->getProductionModifier(eUnit));
		}
		else
		{
			if(pPlot->getOwner() != GetID())
			{
				return -1;
			}

			iCost *= 100;
			iCost /= std::max(1, 100 + getProductionModifier(eUnit));
		}


		if(bAdd)
		{
			int iMaxUnitsPerCity = GC.getADVANCED_START_MAX_UNITS_PER_CITY();
			if(iMaxUnitsPerCity >= 0)
			{
				if(pkUnitInfo->IsMilitarySupport() && getNumMilitaryUnits() >= iMaxUnitsPerCity * getNumCities())
				{
					return -1;
				}
			}

			if(NULL != pCity)
			{
				if(!pCity->canTrain(eUnit))
				{
					return -1;
				}
			}
			else
			{
				if(!pPlot->canTrain(eUnit, false, false))
				{
					return -1;
				}
				if(!pPlot->isValidMovePlot(GetID()))
				{
					return -1;
				}
			}
		}
		// Must be this unit at plot in order to remove
		else
		{
			bool bUnitFound = false;

			IDInfo* pUnitNode = pPlot->headUnitNode();
			while(pUnitNode != NULL)
			{
				CvUnit* pLoopUnit = ::getUnit(*pUnitNode);
				pUnitNode = pPlot->nextUnitNode(pUnitNode);

				if(NULL != pLoopUnit && pLoopUnit->getUnitType() == eUnit)
				{
					bUnitFound = true;
				}
			}

			if(!bUnitFound)
			{
				return -1;
			}
		}
	}

	return iCost;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing a City
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartCityCost(bool bAdd, CvPlot* pPlot)
{
	int iNumCities = getNumCities();

	int iCost = getNewCityProductionValue();

	if(iCost < 0)
	{
		return -1;
	}

	// Valid plot?
	if(pPlot != NULL)
	{
		// Need valid plot to found on if adding
		if(bAdd)
		{
			if(!canFound(pPlot->getX(), pPlot->getY()))
			{
				return -1;
			}
		}
		// Need your own city present to remove
		else
		{
			if(pPlot->isCity())
			{
				if(pPlot->getPlotCity()->getOwner() != GetID())
				{
					return -1;
				}
			}
			else
			{
				return -1;
			}
		}

		// Is there a distance limit on how far a city can be placed from a player's start/another city?
		if(GC.getADVANCED_START_CITY_PLACEMENT_MAX_RANGE() > 0)
		{
			PlayerTypes eClosestPlayer = NO_PLAYER;
			int iClosestDistance = INT_MAX;

			for(int iPlayer = 0; iPlayer < MAX_CIV_PLAYERS; ++iPlayer)
			{
				CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iPlayer);

				if(kPlayer.isAlive())
				{
					CvPlot* pStartingPlot = kPlayer.getStartingPlot();

					if(NULL != pStartingPlot)
					{
						int iDistance = ::plotDistance(pPlot->getX(), pPlot->getY(), pStartingPlot->getX(), pStartingPlot->getY());
						if(iDistance <= GC.getADVANCED_START_CITY_PLACEMENT_MAX_RANGE())
						{
							if(iDistance < iClosestDistance || (iDistance == iClosestDistance && getTeam() != kPlayer.getTeam()))
							{
								iClosestDistance = iDistance;
								eClosestPlayer = kPlayer.GetID();
							}
						}
					}
				}
			}

			if(NO_PLAYER == eClosestPlayer || GET_PLAYER(eClosestPlayer).getTeam() != getTeam())
			{
				return -1;
			}
			//Only allow founding a city at someone elses start point if
			//We have no cities and they have no cities.
			if((GetID() != eClosestPlayer) && ((getNumCities() > 0) || (GET_PLAYER(eClosestPlayer).getNumCities() > 0)))
			{
				return -1;
			}
		}
	}

	// Increase cost if the XML defines that additional units will cost more
	if(0 != GC.getADVANCED_START_CITY_COST_INCREASE())
	{
		if(!bAdd)
		{
			--iNumCities;
		}

		if(iNumCities > 0)
		{
			iCost *= 100 + GC.getADVANCED_START_CITY_COST_INCREASE() * iNumCities;
			iCost /= 100;
		}
	}

	return iCost;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing Population
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartPopCost(bool bAdd, CvCity* pCity)
{
	if(0 == getNumCities())
	{
		return -1;
	}

	int iCost = (getGrowthThreshold(1) * GC.getADVANCED_START_POPULATION_COST()) / 100;

	if(NULL != pCity)
	{
		if(pCity->getOwner() != GetID())
		{
			return -1;
		}

		int iPopulation = pCity->getPopulation();

		// Need to have Population to remove it
		if(!bAdd)
		{
			--iPopulation;

			if(iPopulation < GC.getINITIAL_CITY_POPULATION() + GC.getGame().getStartEraInfo().getFreePopulation())
			{
				return -1;
			}
		}

		iCost = (getGrowthThreshold(iPopulation) * GC.getADVANCED_START_POPULATION_COST()) / 100;

		// Increase cost if the XML defines that additional Pop will cost more
		if(0 != GC.getADVANCED_START_POPULATION_COST_INCREASE())
		{
			--iPopulation;

			if(iPopulation > 0)
			{
				iCost *= 100 + GC.getADVANCED_START_POPULATION_COST_INCREASE() * iPopulation;
				iCost /= 100;
			}
		}
	}

	return iCost;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing a Building from a city
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartBuildingCost(BuildingTypes eBuilding, bool bAdd, CvCity* pCity)
{
	if(0 == getNumCities())
	{
		return -1;
	}

	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if(pkBuildingInfo == NULL)
	{
		return -1;
	}

	int iCost = getProductionNeeded(eBuilding);

	if(iCost < 0)
	{
		return -1;
	}

	if(pkBuildingInfo->GetFreeStartEra() != NO_ERA && GC.getGame().getStartEra() >=  pkBuildingInfo->GetFreeStartEra())
	{
		// you get this building for free
		return -1;
	}

	if(NULL == pCity)
	{
		if(bAdd)
		{
			bool bValid = false;
			int iLoop;
			for(CvCity* pLoopCity = firstCity(&iLoop); NULL != pLoopCity; pLoopCity = nextCity(&iLoop))
			{
				if(pLoopCity->canConstruct(eBuilding))
				{
					bValid = true;
					break;
				}
			}

			if(!bValid)
			{
				return -1;
			}
		}
	}
	if(NULL != pCity)
	{
		if(pCity->getOwner() != GetID())
		{
			return -1;
		}

		iCost *= 100;
		iCost /= std::max(1, 100 + pCity->getProductionModifier(eBuilding));

		if(bAdd)
		{
			if(!pCity->canConstruct(eBuilding, true, false, false))
			{
				return -1;
			}
		}
		else
		{
			if(pCity->GetCityBuildings()->GetNumRealBuilding(eBuilding) <= 0)
			{
				return -1;
			}

			// Check other buildings in this city and make sure none of them require this one

			// Loop through Buildings to see which are present
			for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
			{
				const BuildingTypes eBuildingLoop = static_cast<BuildingTypes>(iBuildingLoop);
				CvBuildingEntry* pkBuildingLoopInfo = GC.getBuildingInfo(eBuildingLoop);
				if(pkBuildingLoopInfo)
				{
					if(pCity->GetCityBuildings()->GetNumBuilding(eBuildingLoop) > 0)
					{
						// Loop through present Building's requirements
						for(int iBuildingClassPrereqLoop = 0; iBuildingClassPrereqLoop < GC.getNumBuildingClassInfos(); iBuildingClassPrereqLoop++)
						{
							const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iBuildingClassPrereqLoop);
							CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
							if(pkBuildingClassInfo)
							{
								if(pkBuildingLoopInfo->IsBuildingClassNeededInCity(iBuildingClassPrereqLoop))
								{
									if((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(iBuildingClassPrereqLoop)) == eBuilding)
									{
										return -1;
									}
								}
#if defined(MOD_BALANCE_CORE)
								// Does this city have prereq buildings?
								if(MOD_BALANCE_CORE && pkBuildingLoopInfo->IsBuildingClassNeededAnywhere(iBuildingClassPrereqLoop))
								{
									int iNumBuildings = 0;
									BuildingTypes ePrereqBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(iBuildingClassPrereqLoop)));

									if(ePrereqBuilding != NO_BUILDING)
									{
										CvCity* pLoopCity;
										int iLoop;
										for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
										{
											if(pLoopCity->GetCityBuildings()->GetNumBuilding(ePrereqBuilding) > 0)
											{
												iNumBuildings++;
											}
										}
										if(iNumBuildings == 0)
										{
											return -1;
										}
									}
								}
								// Does this city have prereq buildings?
								if(MOD_BALANCE_CORE && pkBuildingLoopInfo->IsBuildingClassNeededNowhere(iBuildingClassPrereqLoop))
								{
									BuildingTypes ePrereqBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(iBuildingClassPrereqLoop)));

									if(ePrereqBuilding != NO_BUILDING)
									{
										CvCity* pLoopCity;
										int iLoop;
										for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
										{
											if(pLoopCity->GetCityBuildings()->GetNumBuilding(ePrereqBuilding) > 0)
											{
												return -1;
											}
										}
									}
								}
#endif
							}
						}
					}
				}
			}
		}
	}

	return iCost;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing Route
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartRouteCost(RouteTypes eRoute, bool bAdd, CvPlot* pPlot)
{
	if(0 == getNumCities())
	{
		return -1;
	}

	if(eRoute == NO_ROUTE)
	{
		return -1;
	}

	CvRouteInfo* pkRouteInfo = GC.getRouteInfo(eRoute);
	if(pkRouteInfo == NULL)
	{
		return -1;
	}

	int iCost = pkRouteInfo->getAdvancedStartCost();

	// This denotes cities may not be purchased through Advanced Start
	if(iCost < 0)
	{
		return -1;
	}

	iCost *= GC.getGame().getGameSpeedInfo().getBuildPercent();
	iCost /= 100;

	// No invalid plots!
	if(pPlot != NULL)
	{
		if(pPlot->isCity())
		{
			return -1;
		}

		if(bAdd)
		{
			if(!pPlot->isValidMovePlot(GetID()) || pPlot->isWater())
			{
				return -1;
			}
			// Can't place twice
			if(pPlot->getRouteType() == eRoute)
			{
				return -1;
			}
		}
		else
		{
			// Need Route to remove it
			if(pPlot->getRouteType() != eRoute)
			{
				return -1;
			}
		}

		// Must be owned by me
		if(pPlot->getOwner() != GetID())
		{
			return -1;
		}
	}

	// Tech requirement
	for(int iBuildLoop = 0; iBuildLoop < GC.getNumBuildInfos(); iBuildLoop++)
	{
		const BuildTypes eBuild = static_cast<BuildTypes>(iBuildLoop);
		CvBuildInfo* pkBuildInfo = GC.getBuildInfo(eBuild);
		if(pkBuildInfo)
		{
			if(pkBuildInfo->getRoute() == eRoute)
			{
				if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkBuildInfo->getTechPrereq())))
				{
					return -1;
				}
#if defined(MOD_BALANCE_CORE)
				else if(MOD_BALANCE_CORE && pkBuildInfo->getTechObsolete() != NO_TECH && (GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkBuildInfo->getTechObsolete())))
				{
					return -1;
				}
#endif
			}
		}
	}

	return iCost;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing Improvement
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartImprovementCost(ImprovementTypes eImprovement, bool bAdd, CvPlot* pPlot)
{
	if(eImprovement == NO_IMPROVEMENT)
	{
		return -1;
	}

	if(0 == getNumCities())
	{
		return -1;
	}

	int iCost = 0;//GC.getImprovementInfo(eImprovement)->GetAdvancedStartCost();

	// This denotes cities may not be purchased through Advanced Start
	if(iCost < 0)
	{
		return -1;
	}

	iCost *= GC.getGame().getGameSpeedInfo().getBuildPercent();
	iCost /= 100;

	// Can this Improvement be on our plot?
	if(pPlot != NULL)
	{
		if(bAdd)
		{
			// Valid Plot
			if(!pPlot->canHaveImprovement(eImprovement, GetID(), false))
			{
				return -1;
			}

			bool bValid = false;

			for(int iI = 0; iI < GC.getNumBuildInfos(); ++iI)
			{
				CvBuildInfo* pkBuildInfo = GC.getBuildInfo((BuildTypes) iI);
				if(!pkBuildInfo)
				{
					continue;
				}
				ImprovementTypes eLoopImprovement = ((ImprovementTypes)(pkBuildInfo->getImprovement()));

				if(eImprovement == eLoopImprovement && canBuild(pPlot, (BuildTypes)iI))
				{
					bValid = true;

					FeatureTypes eFeature = pPlot->getFeatureType();
					if(NO_FEATURE != eFeature && pkBuildInfo->isFeatureRemove(eFeature))
					{
						iCost += GC.getFeatureInfo(eFeature)->getAdvancedStartRemoveCost();
					}

					break;
				}
			}

			if(!bValid)
			{
				return -1;
			}

			// Can't place twice
			if(pPlot->getImprovementType() == eImprovement)
			{
				return -1;
			}
		}
		else
		{
			// Need this improvement in order to remove it
			if(pPlot->getImprovementType() != eImprovement)
			{
				return -1;
			}
		}

		// Must be owned by me
		if(pPlot->getOwner() != GetID())
		{
			return -1;
		}
	}

	// Tech requirement
	for(int iBuildLoop = 0; iBuildLoop < GC.getNumBuildInfos(); iBuildLoop++)
	{
		CvBuildInfo* pkBuildInfo = GC.getBuildInfo((BuildTypes) iBuildLoop);
		if(!pkBuildInfo)
		{
			continue;
		}

		if(pkBuildInfo->getImprovement() == eImprovement)
		{
			if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkBuildInfo->getTechPrereq())))
			{
				return -1;
			}
#if defined(MOD_BALANCE_CORE)
			else if(MOD_BALANCE_CORE && pkBuildInfo->getTechObsolete() != NO_TECH && (GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkBuildInfo->getTechObsolete())))
			{
				return -1;
			}
#endif
		}
	}

	return iCost;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing Tech
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartTechCost(TechTypes eTech, bool bAdd)
{
	if(eTech == NO_TECH)
	{
		return -1;
	}

	if(0 == getNumCities())
	{
		return -1;
	}

	int iCost = (GET_TEAM(getTeam()).GetTeamTechs()->GetResearchCost(eTech) * GC.getTechInfo(eTech)->GetAdvancedStartCost()) / 100;
	if(iCost < 0)
	{
		return -1;
	}

	if(bAdd)
	{
		if(!GetPlayerTechs()->CanResearch(eTech, false))
		{
			return -1;
		}
	}
	else if(!bAdd)
	{
		if(!GET_TEAM(getTeam()).GetTeamTechs()->HasTech(eTech))
		{
			return -1;
		}

		// Search through all techs to see if any of the currently owned ones requires this tech
		for(int iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)
		{
			TechTypes eTechLoop = (TechTypes) iTechLoop;

			if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech(eTechLoop))
			{
				int iPrereqLoop;

				// Or Prereqs
				for(iPrereqLoop = 0; iPrereqLoop < GC.getNUM_OR_TECH_PREREQS(); iPrereqLoop++)
				{
					if(GC.getTechInfo(eTechLoop)->GetPrereqOrTechs(iPrereqLoop) == eTech)
					{
						return -1;
					}
				}

				// And Prereqs
				for(iPrereqLoop = 0; iPrereqLoop < GC.getNUM_AND_TECH_PREREQS(); iPrereqLoop++)
				{
					if(GC.getTechInfo(eTechLoop)->GetPrereqAndTechs(iPrereqLoop) == eTech)
					{
						return -1;
					}
				}
			}
		}

		// If player has placed anything on the map which uses this tech then you cannot remove it
		int iLoop;

		// Units
		CvUnit* pLoopUnit;
		for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		{
			if(pLoopUnit->getUnitInfo().GetPrereqAndTech() == eTech)
			{
				return -1;
			}

			for(int iI = 0; iI < GC.getNUM_UNIT_AND_TECH_PREREQS(); iI++)
			{
				if(pLoopUnit->getUnitInfo().GetPrereqAndTechs(iI) == eTech)
				{
					return -1;
				}
			}
		}

		// Cities
		CvCity* pLoopCity;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			// All Buildings
			for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
			{
				const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
				CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
				if(pkBuildingInfo)
				{
					if(pLoopCity->GetCityBuildings()->GetNumRealBuilding(eBuilding) > 0)
					{
						if(pkBuildingInfo->GetPrereqAndTech() == eTech)
						{
							return -1;
						}

						for(int iI = 0; iI < GC.getNUM_BUILDING_AND_TECH_PREREQS(); iI++)
						{
							if(pkBuildingInfo->GetPrereqAndTechs(iI) == eTech)
							{
								return -1;
							}
						}
					}
				}
			}
		}

	}

	return iCost;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing Visibility
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartVisibilityCost(bool bAdd, CvPlot* pPlot)
{
	if(0 == getNumCities())
	{
		return -1;
	}

	int iNumVisiblePlots = 0;
	int iCost = GC.getADVANCED_START_VISIBILITY_COST();

	// This denotes Visibility may not be purchased through Advanced Start
	if(iCost == -1)
	{
		return -1;
	}

	// Valid Plot?
	if(pPlot != NULL)
	{
		if(bAdd)
		{
			if(pPlot->isRevealed(getTeam()))
			{
				return -1;
			}
			if(!pPlot->isAdjacentRevealed(getTeam()))
			{
				return -1;
			}
		}
		else
		{
			if(!pPlot->isRevealed(getTeam()))
			{
				return -1;
			}
		}
	}

	// Increase cost if the XML defines that additional units will cost more
	if(0 != GC.getADVANCED_START_VISIBILITY_COST_INCREASE())
	{
		const int nPlots = GC.getMap().numPlots();
		for(int iPlotLoop = 0; iPlotLoop < nPlots; iPlotLoop++)
		{
			CvPlot* pMapPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);

			if(pMapPlot->isRevealed(getTeam()))
			{
				++iNumVisiblePlots;
			}
		}

		if(!bAdd)
		{
			--iNumVisiblePlots;
		}

		if(iNumVisiblePlots > 0)
		{
			iCost *= 100 + GC.getADVANCED_START_VISIBILITY_COST_INCREASE() * iNumVisiblePlots;
			iCost /= 100;
		}
	}

	return iCost;
}

//	--------------------------------------------------------------------------------
void CvPlayer::doWarnings()
{
	if(m_eID == GC.getGame().getActivePlayer())
	{
		//update enemy units close to your territory
		int iMaxCount = range(((getNumCities() + 4) / 7), 2, 5);
		for(int iI = 0; iI < GC.getMap().numPlots(); iI++)
		{
			if(iMaxCount == 0)
			{
				break;
			}

			CvPlot* pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

			if(pLoopPlot->isAdjacentPlayer(GetID()))
			{
				if(!(pLoopPlot->isCity()))
				{
					if(pLoopPlot->isVisible(getTeam()))
					{
						CvUnit* pUnit = pLoopPlot->getVisibleEnemyDefender(GetID());
						if(pUnit != NULL)
						{
							CvCity* pNearestCity = GC.getMap().findCity(pLoopPlot->getX(), pLoopPlot->getY(), GetID(), NO_TEAM, !(pLoopPlot->isWater()));

							if(pNearestCity != NULL)
							{
								CvString message = GetLocalizedText("TXT_KEY_MISC_ENEMY_TROOPS_SPOTTED", pNearestCity->getNameKey());
								GC.GetEngineUserInterface()->AddPlotMessage(0, pLoopPlot->GetPlotIndex(), GetID(), true, GC.getEVENT_MESSAGE_TIME(), message);

								iMaxCount--;
							}
						}
					}
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::processPolicies(PolicyTypes ePolicy, int iChange)
{
	int iI, iJ;

	CvPolicyEntry* pPolicy = GC.getPolicyInfo(ePolicy);
	if(pPolicy == NULL)
		return;

#if defined(MOD_TRAITS_OTHER_PREREQS)
	if (MOD_TRAITS_OTHER_PREREQS) {
		GetPlayerTraits()->InitPlayerTraits();
	}
#endif

	const CvPolicyEntry& kPolicy = (*pPolicy);

	ChangeCulturePerWonder(pPolicy->GetCulturePerWonder() * iChange);
	ChangeCultureWonderMultiplier(pPolicy->GetCultureWonderMultiplier() * iChange);
	ChangeCulturePerTechResearched(pPolicy->GetCulturePerTechResearched() * iChange);
	ChangeGoldenAgeMeterMod(pPolicy->GetGoldenAgeMeterMod() * iChange);
	changeGoldenAgeModifier(pPolicy->GetGoldenAgeDurationMod() * iChange);
	changeWorkerSpeedModifier(pPolicy->GetWorkerSpeedModifier() * iChange);
	changeImprovementCostModifier(pPolicy->GetImprovementCostModifier() * iChange);
	changeImprovementUpgradeRateModifier(pPolicy->GetImprovementUpgradeRateModifier() * iChange);
	changeSpecialistProductionModifier(pPolicy->GetSpecialistProductionModifier() * iChange);
	changeMilitaryProductionModifier(pPolicy->GetMilitaryProductionModifier() * iChange);
	changeBaseFreeUnits(pPolicy->GetBaseFreeUnits() * iChange);
	ChangeHappinessPerGarrisonedUnit(pPolicy->GetHappinessPerGarrisonedUnit() * iChange);
	ChangeHappinessPerTradeRoute(pPolicy->GetHappinessPerTradeRoute() * iChange);
	ChangeHappinessPerXPopulation(pPolicy->GetHappinessPerXPopulation() * iChange);
#if defined(MOD_BALANCE_CORE_POLICIES)
	ChangeHappinessPerXPopulationGlobal(pPolicy->GetHappinessPerXPopulationGlobal() * iChange);
	ChangeIdeologyPoint(pPolicy->GetIdeologyPoint() * iChange);
	ChangeEventTourism(pPolicy->GetEventTourism() * iChange);
	ChangeEventTourismCS(pPolicy->GetEventTourismCS() * iChange);
	ChangeMonopolyModFlat(pPolicy->GetMonopolyModFlat() * iChange);
	ChangeMonopolyModPercent(pPolicy->GetMonopolyModPercent() * iChange);
	ChangeCorporationMaxFranchises(pPolicy->GetMaxCorps() * iChange);
	if(pPolicy->IsOrderCorp())
	{
		SetOrderCorp(true);
		CalculateCorporateFranchisesWorldwide();
	}
	if(pPolicy->IsAutocracyCorp())
	{
		SetAutocracyCorp(true);
		CalculateCorporateFranchisesWorldwide();
	}
	if(pPolicy->IsFreedomCorp())
	{
		SetFreedomCorp(true);
		CalculateCorporateFranchisesWorldwide();
	}
	if(pPolicy->IsUpgradeCSTerritory())
	{
		ChangeUpgradeCSTerritory(pPolicy->IsUpgradeCSTerritory() * iChange);
	}
	if(pPolicy->IsArchaeologicalDigTourism())
	{
		ChangeArchaeologicalDigTourism(pPolicy->IsArchaeologicalDigTourism() * iChange);
	}
	if(pPolicy->IsGoldenAgeTourism())
	{
		ChangeGoldenAgeTourism(pPolicy->IsGoldenAgeTourism() * iChange);
	}
	ChangeRazingSpeedBonus(pPolicy->GetRazingSpeedBonus() * iChange);
	ChangeNoPartisans(pPolicy->IsNoPartisans() * iChange);
#endif
	ChangeExtraHappinessPerLuxury(pPolicy->GetExtraHappinessPerLuxury() * iChange);
	ChangeUnhappinessFromUnitsMod(pPolicy->GetUnhappinessFromUnitsMod() * iChange);
	ChangeUnhappinessMod(pPolicy->GetUnhappinessMod() * iChange);
	ChangeCityCountUnhappinessMod(pPolicy->GetCityCountUnhappinessMod() * iChange);
	ChangeOccupiedPopulationUnhappinessMod(pPolicy->GetOccupiedPopulationUnhappinessMod() * iChange);
	ChangeCapitalUnhappinessMod(pPolicy->GetCapitalUnhappinessMod() * iChange);
	ChangeWoundedUnitDamageMod(pPolicy->GetWoundedUnitDamageMod() * iChange);
	ChangeUnitUpgradeCostMod(pPolicy->GetUnitUpgradeCostMod() * iChange);
	ChangeBarbarianCombatBonus(pPolicy->GetBarbarianCombatBonus() * iChange);
	ChangeAlwaysSeeBarbCampsCount(pPolicy->IsAlwaysSeeBarbCamps() * iChange);
	ChangeMaxNumBuilders(pPolicy->GetNumExtraBuilders() * iChange);
	ChangePlotGoldCostMod(pPolicy->GetPlotGoldCostMod() * iChange);
#if defined(MOD_TRAITS_CITY_WORKING) || defined(MOD_BUILDINGS_CITY_WORKING) || defined(MOD_POLICIES_CITY_WORKING) || defined(MOD_TECHS_CITY_WORKING)
	ChangeCityWorkingChange(pPolicy->GetCityWorkingChange() * iChange);
#endif
	ChangePlotCultureCostModifier(pPolicy->GetPlotCultureCostModifier() * iChange);
	ChangePlotCultureExponentModifier(pPolicy->GetPlotCultureExponentModifier() * iChange);
	ChangeNumCitiesPolicyCostDiscount(pPolicy->GetNumCitiesPolicyCostDiscount() * iChange);
	ChangeGarrisonFreeMaintenanceCount(pPolicy->IsGarrisonFreeMaintenance() * iChange);
	ChangeGarrisonedCityRangeStrikeModifier(pPolicy->GetGarrisonedCityRangeStrikeModifier() * iChange);
	ChangeUnitPurchaseCostModifier(pPolicy->GetUnitPurchaseCostModifier() * iChange);
	GetTreasury()->ChangeCityConnectionTradeRouteGoldModifier(pPolicy->GetCityConnectionTradeRouteGoldModifier() * iChange);
	changeGoldPerUnit(pPolicy->GetGoldPerUnit() * iChange);
	changeGoldPerMilitaryUnit(pPolicy->GetGoldPerMilitaryUnit() * iChange);
	ChangeCityStrengthMod(pPolicy->GetCityStrengthMod() * iChange);
	ChangeCityGrowthMod(pPolicy->GetCityGrowthMod() * iChange);
	ChangeCapitalGrowthMod(pPolicy->GetCapitalGrowthMod() * iChange);
	changeSettlerProductionModifier(pPolicy->GetSettlerProductionModifier() * iChange);
	changeCapitalSettlerProductionModifier(pPolicy->GetCapitalSettlerProductionModifier() * iChange);
	ChangeImprovementGoldMaintenanceMod(pPolicy->GetImprovementGoldMaintenanceMod() * iChange);
	ChangeBuildingGoldMaintenanceMod(pPolicy->GetBuildingGoldMaintenanceMod() * iChange);
	ChangeUnitGoldMaintenanceMod(pPolicy->GetUnitGoldMaintenanceMod() * iChange);
	ChangeUnitSupplyMod(pPolicy->GetUnitSupplyMod() * iChange);
	changeHappyPerMilitaryUnit(pPolicy->GetHappyPerMilitaryUnit() * iChange);
	changeHappinessToCulture(pPolicy->GetHappinessToCulture() * iChange);
	changeHappinessToScience(pPolicy->GetHappinessToScience() * iChange);
	changeHalfSpecialistUnhappinessCount((pPolicy->IsHalfSpecialistUnhappiness()) ? iChange : 0);
	changeHalfSpecialistFoodCount((pPolicy->IsHalfSpecialistFood()) ? iChange : 0);
#if defined(MOD_BALANCE_CORE)
	changeHalfSpecialistFoodCapitalCount((pPolicy->IsHalfSpecialistFoodCapital()) ? iChange : 0);
#endif
	changeMilitaryFoodProductionCount((pPolicy->IsMilitaryFoodProduction()) ? iChange : 0);
	ChangeGoldenAgeCultureBonusDisabledCount((pPolicy->IsGoldenAgeCultureBonusDisabled()) ? iChange : 0);
	ChangeSecondReligionPantheonCount((pPolicy->IsSecondReligionPantheon()) ? iChange : 0);
	ChangeEnablesSSPartHurryCount((pPolicy->IsEnablesSSPartHurry()) ? iChange : 0);
	ChangeEnablesSSPartPurchaseCount((pPolicy->IsEnablesSSPartPurchase()) ? iChange : 0);
	changeMaxConscript(getWorldSizeMaxConscript(kPolicy) * iChange);
	changeExpModifier(pPolicy->GetExpModifier() * iChange);
	changeExpInBorderModifier(pPolicy->GetExpInBorderModifier() * iChange);
	changeMinorQuestFriendshipMod(pPolicy->GetMinorQuestFriendshipMod() * iChange);
	changeMinorGoldFriendshipMod(pPolicy->GetMinorGoldFriendshipMod() * iChange);
	ChangeMinorFriendshipAnchorMod(pPolicy->GetMinorFriendshipMinimum() * iChange);
	changeGetMinorFriendshipDecayMod(pPolicy->GetMinorFriendshipDecayMod() * iChange);
	ChangeMinorScienceAlliesCount(pPolicy->IsMinorScienceAllies() * iChange);
	ChangeMinorResourceBonusCount(pPolicy->IsMinorResourceBonus() * iChange);
	ChangeNewCityExtraPopulation(pPolicy->GetNewCityExtraPopulation() * iChange);
	ChangeFreeFoodBox(pPolicy->GetFreeFoodBox() * iChange);
	ChangeStrategicResourceMod(pPolicy->GetStrategicResourceMod() * iChange);
#if defined(MOD_BALANCE_CORE)
	if(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES_STRATEGIC && pPolicy->GetStrategicResourceMod() > 0)
	{
		for(int iLoop = 0; iLoop < GC.getNumResourceInfos(); iLoop++)
		{
			const ResourceTypes eResource = static_cast<ResourceTypes>(iLoop);
			CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
			if(pkResource && pkResource->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)
			{
				CheckForMonopoly(eResource);
			}
		}
	}
#endif
	ChangeAbleToAnnexCityStatesCount((pPolicy->IsAbleToAnnexCityStates()) ? iChange : 0);
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	if(MOD_BALANCE_CORE_HAPPINESS)
	{
		ChangePovertyUnhappinessMod(pPolicy->GetPovertyHappinessChangePolicy() * iChange);
		ChangeDefenseUnhappinessMod(pPolicy->GetDefenseHappinessChangePolicy() * iChange);
		ChangeUnculturedUnhappinessMod(pPolicy->GetUnculturedHappinessChangePolicy() * iChange);
		ChangeIlliteracyUnhappinessMod(pPolicy->GetIlliteracyHappinessChangePolicy() * iChange);
		ChangeMinorityUnhappinessMod(pPolicy->GetMinorityHappinessChangePolicy() * iChange);
		ChangePovertyUnhappinessModCapital(pPolicy->GetPovertyHappinessChangePolicyCapital() * iChange);
		ChangeDefenseUnhappinessModCapital(pPolicy->GetDefenseHappinessChangePolicyCapital() * iChange);
		ChangeUnculturedUnhappinessModCapital(pPolicy->GetUnculturedHappinessChangePolicyCapital() * iChange);
		ChangeIlliteracyUnhappinessModCapital(pPolicy->GetIlliteracyHappinessChangePolicyCapital() * iChange);
		ChangeMinorityUnhappinessModCapital(pPolicy->GetMinorityHappinessChangePolicyCapital() * iChange);
		ChangePuppetUnhappinessMod(pPolicy->GetPuppetUnhappinessMod() * iChange);
		ChangeNoUnhappfromXSpecialists(pPolicy->GetNoUnhappfromXSpecialists() * iChange);
		ChangeNoUnhappfromXSpecialistsCapital(pPolicy->GetNoUnhappfromXSpecialistsCapital() * iChange);
		ChangeWarWearinessModifier(pPolicy->GetWarWearinessModifier() * iChange);
	}
#endif
#if defined(MOD_BALANCE_CORE_POLICIES)
	if(MOD_BALANCE_CORE_POLICIES)
	{
		ChangeNoUnhappinessExpansion(pPolicy->GetNoUnhappinessExpansion() * iChange);
		ChangeNoUnhappyIsolation(pPolicy->GetNoUnhappyIsolation() * iChange);
		ChangeDoubleBorderGA(pPolicy->GetDoubleBorderGA() * iChange);
		changeGarrisonsOccupiedUnhapppinessMod(pPolicy->GetGarrisonsOccupiedUnhapppinessMod() * iChange);
		changeTradeReligionModifier(pPolicy->GetTradeReligionModifier() * iChange);
		changeFreeWCVotes(pPolicy->GetFreeWCVotes() * iChange);
		ChangeIncreasedQuestInfluence(pPolicy->GetIncreasedQuestInfluence() * iChange);
		changeCitadelBoost(pPolicy->GetCitadelBoost() * iChange);
		changePuppetProdMod(pPolicy->GetPuppetProdMod() * iChange);
		changeOccupiedProdMod(pPolicy->GetOccupiedProdMod() * iChange);
		changeGoldInternalTrade(pPolicy->GetInternalTradeGold() * iChange);
		changeInfluenceGPExpend(pPolicy->GetInfluenceGPExpend() * iChange);
		changeFreeTradeRoute(pPolicy->GetFreeTradeRoute() * iChange);
		changeFreeSpy(pPolicy->GetFreeSpy() * iChange);

		changeReligionDistance(pPolicy->GetReligionDistance() * iChange);
		changePressureMod(pPolicy->GetPressureMod() * iChange);

		if(GetFreeSpy() > 0)
		{
			CvPlayerEspionage* pEspionage = GetEspionage();
			CvAssertMsg(pEspionage, "pEspionage is null! What's up with that?!");
			if(pEspionage)
			{
				int iNumSpies = GetFreeSpy();
#if defined(MOD_BALANCE_CORE_SPIES)
				if (MOD_BALANCE_CORE_SPIES) {
					//Optional: Spies scaled for the number of City-States in the game.
					int iNumMinor = ((GC.getGame().GetNumMinorCivsEver() * /*15*/ GC.getBALANCE_SPY_TO_MINOR_RATIO()) / 100);
					if(iNumMinor > 1)
					{
						iNumSpies = iNumMinor;
					}
				}
#endif
				for(int i = 0; i < iNumSpies; i++)
				{
					pEspionage->CreateSpy();
				}
				changeFreeSpy(GetFreeSpy() * -1);
			}
		}
		
		int iLoop;
		CvCity* pLoopCity;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pPolicy->GetFreePopulation() > 0)
			{
				pLoopCity->changePopulation(pPolicy->GetFreePopulation());
			}
		}
		changeExtraMoves(pPolicy->GetExtraMoves() * iChange);

		if(pPolicy->GetBestRangedUnitSpawnSettle() > 0)
		{
			changeBestRangedUnitSpawnSettle(pPolicy->GetBestRangedUnitSpawnSettle() * iChange);
			int iLoop;
			for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				if(pLoopCity == NULL)
				{
					continue;
				}
				if(pLoopCity->getPopulation() < GetBestRangedUnitSpawnSettle())
				{
					continue;
				}
				if(pLoopCity->IsResistance() || pLoopCity->IsRazing())
				{
					continue;
				}
				UnitTypes eBestUnit = NO_UNIT;
				int iStrengthBest = 0;
				// Loop through adding the available units
				for(int iUnitLoop = 0; iUnitLoop < GC.getNumUnitInfos(); iUnitLoop++)
				{
					UnitTypes eLoopUnit = (UnitTypes)iUnitLoop;
					if(eLoopUnit != NO_UNIT)
					{
						CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eLoopUnit);
						if(pkUnitEntry)
						{
							if(!pLoopCity->canTrain(eLoopUnit))
							{
								continue;
							}
							if(pkUnitEntry->GetRangedCombat() > 0)
							{
								continue;
							}
							if(pkUnitEntry->GetDomainType() == DOMAIN_SEA)
							{
								int iChance = GC.getGame().getJonRandNum(100, "Random Boat Chance");
								if(iChance < 50)
								{
									continue;
								}
							}
							bool bBad = false;
							ResourceTypes eResource;
							for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
							{
								eResource = (ResourceTypes) iResourceLoop;
								int iNumResource = pkUnitEntry->GetResourceQuantityRequirement(eResource);
								if (iNumResource > 0)
								{
									bBad = true;
									break;
								}
								if(pkUnitEntry->GetResourceType() == eResource)
								{
									bBad = true;
									break;
								}
							}
							if(bBad)
							{
								continue;
							}
							int iCombatStrength = (pkUnitEntry->GetCombat() + GC.getGame().getJonRandNum(pkUnitEntry->GetCombat(), "Random Unit bump"));
							if(iCombatStrength > iStrengthBest)
							{
								iStrengthBest = iCombatStrength;
								eBestUnit = eLoopUnit;
							}
						}
					}
				}
				if(eBestUnit != NO_UNIT)
				{
					CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eBestUnit);
					if(pkUnitEntry)
					{
						UnitAITypes eUnitAI = pkUnitEntry->GetDefaultUnitAIType();
						int iResult = pLoopCity->CreateUnit(eBestUnit, eUnitAI);

						CvAssertMsg(iResult != -1, "Unable to create unit");

						if (iResult != -1)
						{
							CvUnit* pUnit = getUnit(iResult);
							if (!pUnit->jumpToNearestValidPlot())
							{
								pUnit->kill(false);	// Could not find a valid spot!
							}
							pUnit->setMoves(0);
							CvNotifications* pNotifications = GetNotifications();
							if(pUnit && pNotifications)
							{
								Localization::String localizedText = Localization::Lookup("TXT_KEY_NOTIFICATION_CONSCRIPTION_SPAWN_FIRST");
								localizedText << pLoopCity->getNameKey() << pUnit->getNameKey();
								Localization::String localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CONSCRIPTION_SPAWN_SUMMARY");
								localizedSummary << pLoopCity->getNameKey() << pUnit->getNameKey();
								pNotifications->Add(NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER, localizedText.toUTF8(), localizedSummary.toUTF8(), pUnit->getX(), pUnit->getY(), eBestUnit);
							}
							if(GC.getLogging() && GC.getAILogging())
							{
								CvString strLogString;
								strLogString.Format("Conscripted %s spawned at %s. Came from policy adoption.", pUnit->getName().GetCString(), pLoopCity->getName().GetCString());
								GetHomelandAI()->LogHomelandMessage(strLogString);
							}
						}
					}
				}
			}
		}
	}
#endif
#if defined(MOD_BALANCE_CORE_BUILDING_INVESTMENTS)
	changeInvestmentModifier(pPolicy->GetInvestmentModifier() * iChange);
#endif
	if(pPolicy->IsOneShot())
	{
		if(m_pPlayerPolicies->HasOneShotPolicyFired(ePolicy))
		{
			return;
		}
		else
		{
			m_pPlayerPolicies->SetOneShotPolicyFired(ePolicy,true);
		}
	}

	GetPlayerPolicies()->ChangeNumExtraBranches(pPolicy->GetNumExtraBranches() * iChange);

	ChangeAllFeatureProduction(pPolicy->GetAllFeatureProduction());

	int iMod;
	YieldTypes eYield;

	for(iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		eYield = (YieldTypes) iI;

#if defined(MOD_BALANCE_CORE_POLICIES)
		changeYieldFromBirth(eYield, (pPolicy->GetYieldFromBirth(iI) * iChange));
		changeYieldFromBirthCapital(eYield, (pPolicy->GetYieldFromBirthCapital(iI) * iChange));
		changeYieldFromConstruction(eYield, (pPolicy->GetYieldFromConstruction(iI) * iChange));
		changeYieldFromTech(eYield, (pPolicy->GetYieldFromTech(iI) * iChange));
		changeYieldFromBorderGrowth(eYield, (pPolicy->GetYieldFromBorderGrowth(iI) * iChange));
		changeYieldGPExpend(eYield, (pPolicy->GetYieldGPExpend(iI) * iChange));
		changeConquerorYield(eYield, (pPolicy->GetConquerorYield(iI) * iChange));
		changeReligionYieldRateModifier(eYield, (pPolicy->GetReligionYieldMod(iI) * iChange));
		changeGoldenAgeYieldMod(eYield, (pPolicy->GetGoldenAgeYieldMod(iI) * iChange));
		changeFounderYield(eYield, (pPolicy->GetFounderYield(iI) * iChange));
#endif

		iMod = pPolicy->GetYieldModifier(iI) * iChange;
		if(iMod != 0)
			changeYieldRateModifier(eYield, iMod);

		iMod = pPolicy->GetCityYieldChange(iI) * iChange;
		if(iMod != 0)
#if defined(MOD_BUGFIX_MINOR)
			ChangeCityYieldChangeTimes100(eYield, iMod * 100);
#else
			ChangeCityYieldChange(eYield, iMod * 100);
#endif

		iMod = pPolicy->GetCoastalCityYieldChange(iI) * iChange;
		if(iMod != 0)
			ChangeCoastalCityYieldChange(eYield, iMod);

		iMod = pPolicy->GetCapitalYieldChange(iI) * iChange;
		if(iMod != 0)
#if defined(MOD_BUGFIX_MINOR)
			ChangeCapitalYieldChangeTimes100(eYield, iMod * 100);
#else
			ChangeCapitalYieldChange(eYield, iMod * 100);
#endif

		iMod = pPolicy->GetCapitalYieldPerPopChange(iI) * iChange;
		if(iMod != 0)
			ChangeCapitalYieldPerPopChange(eYield, iMod);

		iMod = pPolicy->GetCapitalYieldModifier(iI) * iChange;
		if(iMod != 0)
			changeCapitalYieldRateModifier(eYield, iMod);

		iMod = pPolicy->GetGreatWorkYieldChange(iI) * iChange;
		if(iMod != 0)
			ChangeGreatWorkYieldChange(eYield, iMod);

		iMod = pPolicy->GetSpecialistExtraYield(iI) * iChange;
		if(iMod != 0)
			changeSpecialistExtraYield(eYield, iMod);

#if defined(MOD_API_UNIFIED_YIELDS)
		iMod = pPolicy->GetYieldFromKills(iI) * iChange;
		if(iMod != 0)
			changeYieldFromKills(eYield, iMod);

		iMod = pPolicy->GetYieldFromBarbarianKills(iI) * iChange;
		if(iMod != 0)
			changeYieldFromBarbarianKills(eYield, iMod);

		iMod = pPolicy->GetYieldChangeTradeRoute(iI) * iChange;
		if(iMod != 0)
			ChangeYieldChangeTradeRoute(eYield, iMod);

		iMod = pPolicy->GetYieldChangesNaturalWonder(iI) * iChange;
		if(iMod != 0)
			ChangeYieldChangesNaturalWonder(eYield, iMod);

		iMod = pPolicy->GetYieldChangeWorldWonder(iI) * iChange;
		if(iMod != 0)
			ChangeYieldChangeWorldWonder(eYield, iMod);

		iMod = pPolicy->GetYieldFromMinorDemand(iI) * iChange;
		if(iMod != 0)
			ChangeYieldFromMinorDemand(eYield, iMod);
#endif
	}

	for(iI = 0; iI < GC.getNumUnitCombatClassInfos(); iI++)
	{
		changeUnitCombatProductionModifiers((UnitCombatTypes)iI, (pPolicy->GetUnitCombatProductionModifiers(iI) * iChange));
		changeUnitCombatFreeExperiences((UnitCombatTypes)iI, (pPolicy->GetUnitCombatFreeExperiences(iI) * iChange));
	}

	for(iI = 0; iI < GC.getNumHurryInfos(); iI++)
	{
		if(GC.getHurryInfo((HurryTypes) iI)->getPolicyPrereq() == ePolicy)
		{
			changeHurryCount(((HurryTypes)iI), iChange);
		}
		{
			changeHurryModifier((HurryTypes) iI, (pPolicy->GetHurryModifier(iI) * iChange));
		}
	}

#if defined(MOD_API_UNIFIED_YIELDS) && defined(MOD_API_PLOT_YIELDS)
	for(iI = 0; iI < GC.getNumPlotInfos(); iI++)
	{
		for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
		{
			changePlotYieldChange(((PlotTypes)iI), ((YieldTypes)iJ), (pPolicy->GetPlotYieldChanges(iI, iJ) * iChange));
		}
	}
#endif

#if defined(MOD_API_UNIFIED_YIELDS)
	for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
	{
		for(iI = 0; iI < GC.getNumFeatureInfos(); iI++)
		{
			changeFeatureYieldChange(((FeatureTypes)iI), ((YieldTypes)iJ), (pPolicy->GetFeatureYieldChanges(iI, iJ) * iChange));
		}

		for(iI = 0; iI < GC.getNumFeatureInfos(); iI++)
		{
			changeCityYieldFromUnimprovedFeature(((FeatureTypes)iI), ((YieldTypes)iJ), (pPolicy->GetCityYieldFromUnimprovedFeature(iI, iJ) * iChange));
			changeUnimprovedFeatureYieldChange(((FeatureTypes)iI), ((YieldTypes)iJ), (pPolicy->GetUnimprovedFeatureYieldChanges(iI, iJ) * iChange));
		}

		for(iI = 0; iI < GC.getNumResourceInfos(); iI++)
		{
			changeResourceYieldChange(((ResourceTypes)iI), ((YieldTypes)iJ), (pPolicy->GetResourceYieldChanges(iI, iJ) * iChange));
		}

		for(iI = 0; iI < GC.getNumTerrainInfos(); iI++)
		{
			changeTerrainYieldChange(((TerrainTypes)iI), ((YieldTypes)iJ), (pPolicy->GetTerrainYieldChanges(iI, iJ) * iChange));
		}

		for(iI = 0; iI < NUM_DOMAIN_TYPES; iI++)
		{
			changeTradeRouteYieldChange(((DomainTypes)iI), ((YieldTypes)iJ), (pPolicy->GetTradeRouteYieldChange(iI, iJ) * iChange));
		}

		for(iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
		{
			changeSpecialistYieldChange(((SpecialistTypes)iI), ((YieldTypes)iJ), (pPolicy->GetSpecialistYieldChanges(iI, iJ) * iChange));
		}

		for(iI = 0; iI < GC.getNumGreatPersonInfos(); iI++)
		{
			changeGreatPersonExpendedYield(((GreatPersonTypes)iI), ((YieldTypes)iJ), (pPolicy->GetGreatPersonExpendedYield(iI, iJ) * iChange));
		}
	}

	for(iI = 0; iI < GC.getNumGreatPersonInfos(); iI++)
	{
		iMod = pPolicy->GetGoldenAgeGreatPersonRateModifier(iI) * iChange;
		if(iMod != 0)
			changeGoldenAgeGreatPersonRateModifier((GreatPersonTypes)iI, iMod);
	}
#endif

	for(iI = 0; iI < GC.getNumImprovementInfos(); iI++)
	{
		for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
		{
			changeImprovementYieldChange(((ImprovementTypes)iI), ((YieldTypes)iJ), (pPolicy->GetImprovementYieldChanges(iI, iJ) * iChange));
		}
	}

	// Free Promotions
	PromotionTypes ePromotion;
	for(iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		ePromotion = (PromotionTypes) iI;

		if(pPolicy->IsFreePromotion(ePromotion))
			ChangeFreePromotionCount(ePromotion, iChange);
	}

	CvCity* pLoopCity;
	PlayerTypes ePlayer;

	// All player Capital Locations Revealed
	if(pPolicy->IsRevealAllCapitals())
	{
		for(iI = 0; iI < MAX_CIV_PLAYERS; iI++)
		{
			ePlayer = (PlayerTypes) iI;

			if(GET_PLAYER(ePlayer).isAlive())
			{
				pLoopCity = GET_PLAYER(ePlayer).getCapitalCity();

				if(pLoopCity != NULL)
				{
					pLoopCity->plot()->setRevealed(getTeam(), true);
				}
			}
		}
	}

	// Friendship Decay for OTHER PLAYERS
	CvNotifications* pNotifications;
	Localization::String locString;
	Localization::String locSummary;

	int iOtherPlayersDecay = pPolicy->GetOtherPlayersMinorFriendshipDecayMod();
	if(iOtherPlayersDecay != 0)
	{
		for(iI = 0; iI < MAX_MAJOR_CIVS; iI++)
		{
			ePlayer = (PlayerTypes) iI;

			if(GET_PLAYER(ePlayer).isEverAlive())
			{
				// Don't hurt us or teammates
				if(GET_PLAYER(ePlayer).getTeam() != getTeam())
				{
#if defined(MOD_BALANCE_CORE)
					if(GET_PLAYER(ePlayer).GetMinorFriendshipDecayMod() <= 0)
					{
						// Send notification to affected players
						locString = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_FRIENDSHIP_DECAY");
						locString << getNameKey();
						locSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MINOR_FRIENDSHIP_DECAY");

						pNotifications = GET_PLAYER(ePlayer).GetNotifications();
						if(pNotifications)
						{
							pNotifications->Add(NOTIFICATION_DIPLOMACY_DECLARATION, locString.toUTF8(), locSummary.toUTF8(), -1, -1, -1);
						}
					}
#endif
					GET_PLAYER(ePlayer).changeGetMinorFriendshipDecayMod(iOtherPlayersDecay * iChange);
#if !defined(MOD_BALANCE_CORE)
					// Send notification to affected players
					locString = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_FRIENDSHIP_DECAY");
					locString << getNameKey();
					locSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MINOR_FRIENDSHIP_DECAY");

					pNotifications = GET_PLAYER(ePlayer).GetNotifications();
					if(pNotifications)
					{
						pNotifications->Add(NOTIFICATION_DIPLOMACY_DECLARATION, locString.toUTF8(), locSummary.toUTF8(), -1, -1, -1);
					}
#endif
				}
			}
		}
	}

	BuildingClassTypes eBuildingClass;
	BuildingTypes eBuilding;
	int iBuildingCount;
	int iYieldMod;
	int iYieldChange;

	// How many cities get free culture buildings?
	int iNumCitiesFreeCultureBuilding = pPolicy->GetNumCitiesFreeCultureBuilding();
	int iNumCitiesFreeFoodBuilding = pPolicy->GetNumCitiesFreeFoodBuilding();

	// Loop through Cities
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(iNumCitiesFreeCultureBuilding > 0)
		{
			BuildingTypes eCultureBuilding = pLoopCity->ChooseFreeCultureBuilding();
			if(eCultureBuilding != NO_BUILDING)
			{
				pLoopCity->GetCityBuildings()->SetNumFreeBuilding(eCultureBuilding, 1);

				if(pLoopCity->getFirstBuildingOrder(eCultureBuilding) == 0)
				{
					pLoopCity->clearOrderQueue();
					pLoopCity->chooseProduction();		// Send a notification to the user that what they were building was given to them, and they need to produce something else.
				}
			}
			else
			{
				pLoopCity->SetOwedCultureBuilding(true);
			}

			// Decrement cities left to get free culture building (at end of loop we'll set the remainder)
			iNumCitiesFreeCultureBuilding--;
		}

		if(iNumCitiesFreeFoodBuilding > 0)
		{
			BuildingTypes eFoodBuilding = pLoopCity->ChooseFreeFoodBuilding();
			if(eFoodBuilding != NO_BUILDING)
			{
				pLoopCity->GetCityBuildings()->SetNumFreeBuilding(eFoodBuilding, 1);

				if(pLoopCity->getFirstBuildingOrder(eFoodBuilding) == 0)
				{
					pLoopCity->clearOrderQueue();
					pLoopCity->chooseProduction();		// Send a notification to the user that what they were building was given to them, and they need to produce something else.
				}
			}
#if defined(MOD_BUGFIX_FREE_FOOD_BUILDING)
			else
			{
				pLoopCity->SetOwedFoodBuilding(true);
			}
#endif

			// Decrement cities left to get free food building (at end of loop we'll set the remainder)
			iNumCitiesFreeFoodBuilding--;
		}

		// Free Culture-per-turn in every City
		int iCityCultureChange = pPolicy->GetCulturePerCity() * iChange;
		if(pLoopCity->HasGarrison())
		{
			iCityCultureChange += (pPolicy->GetCulturePerGarrisonedUnit() * iChange);
		}

		pLoopCity->ChangeJONSCulturePerTurnFromPolicies(iCityCultureChange);
		
#if defined(MOD_API_UNIFIED_YIELDS)
		int iTotalWonders = 0;
#endif

		// Building modifiers
		for(iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
		{
			eBuildingClass = (BuildingClassTypes) iI;

			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
			if(!pkBuildingClassInfo)
			{
				continue;
			}

			eBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

			if(eBuilding != NO_BUILDING)
			{
				CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
				if(pkBuilding)
				{
					iBuildingCount = pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding);

					if(iBuildingCount > 0)
					{
#if defined(MOD_API_UNIFIED_YIELDS)
						if (::isWorldWonderClass(pkBuilding->GetBuildingClassInfo())) 
						{
							iTotalWonders += iBuildingCount;
						}
#endif
						
#if defined(MOD_API_UNIFIED_YIELDS)
						iYieldMod = pPolicy->GetBuildingClassYieldModifiers(eBuildingClass, YIELD_CULTURE);
						if (iYieldMod != 0)
						{
							pLoopCity->changeYieldRateModifier(YIELD_CULTURE, iYieldMod * iBuildingCount * iChange);
						}
						iYieldChange = pPolicy->GetBuildingClassCultureChange(eBuildingClass);
						iYieldChange += pPolicy->GetBuildingClassYieldChanges(eBuildingClass, YIELD_CULTURE);
						if (iYieldChange != 0)
						{
							pLoopCity->ChangeJONSCulturePerTurnFromPolicies(iYieldChange * iBuildingCount * iChange);
#if defined(MOD_BALANCE_CORE_POLICIES)
							pLoopCity->changeBuildingClassCultureChange(eBuildingClass, (iYieldChange * iBuildingCount * iChange));
						}
						//Policy-Religion Fusion Yield Changes
						iYieldChange = pPolicy->GetReligionBuildingYieldMod(eBuildingClass, YIELD_CULTURE);
						if (MOD_BALANCE_CORE_POLICIES && iYieldChange > 0)
						{
							pLoopCity->changeReligionBuildingYieldRateModifier(eBuildingClass, YIELD_CULTURE, (iYieldChange * iBuildingCount * iChange));
#endif
						}
#else
						pLoopCity->ChangeJONSCulturePerTurnFromPolicies(pPolicy->GetBuildingClassCultureChange(eBuildingClass) * iBuildingCount * iChange);
#endif

						// Building Class Yield Stuff
						for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
						{
							switch(iJ)
							{
							case YIELD_CULTURE:
								// Skip, handled above
								break;
							case YIELD_FAITH:
#if defined(MOD_API_UNIFIED_YIELDS)
								{
									eYield = (YieldTypes) iJ;
									iYieldMod = pPolicy->GetBuildingClassYieldModifiers(eBuildingClass, eYield);
									if (iYieldMod != 0)
									{
										pLoopCity->changeYieldRateModifier(eYield, iYieldMod * iBuildingCount * iChange);
									}
									iYieldChange = pPolicy->GetBuildingClassYieldChanges(eBuildingClass, eYield);
									if (iYieldChange != 0)
									{
										pLoopCity->ChangeFaithPerTurnFromPolicies(iYieldChange * iBuildingCount * iChange);
									}
#if defined(MOD_BALANCE_CORE_POLICIES)
									//Policy-Religion Fusion Yield Changes
									iYieldChange = pPolicy->GetReligionBuildingYieldMod(eBuildingClass, eYield);
									if (MOD_BALANCE_CORE_POLICIES && iYieldChange > 0)
									{
										pLoopCity->changeReligionBuildingYieldRateModifier(eBuildingClass, eYield, (iYieldChange * iBuildingCount * iChange));
									}
#endif
								}
#else
								pLoopCity->ChangeFaithPerTurnFromPolicies(pPolicy->GetBuildingClassYieldChanges(eBuildingClass, iJ) * iBuildingCount * iChange);
#endif
								break;
							default:
								{
									eYield = (YieldTypes) iJ;
									iYieldMod = pPolicy->GetBuildingClassYieldModifiers(eBuildingClass, eYield);
#if defined(MOD_BALANCE_CORE)
									if (iYieldMod != 0)
#else
									if (iYieldMod > 0)
#endif
									{
										pLoopCity->changeYieldRateModifier(eYield, iYieldMod * iBuildingCount * iChange);
									}
									iYieldChange = pPolicy->GetBuildingClassYieldChanges(eBuildingClass, eYield);
									if (iYieldChange != 0)
									{
										pLoopCity->ChangeBaseYieldRateFromBuildings(eYield, iYieldChange * iBuildingCount * iChange);
									}
#if defined(MOD_BALANCE_CORE_POLICIES)
									//Policy-Religion Fusion Yield Changes
									iYieldChange = pPolicy->GetReligionBuildingYieldMod(eBuildingClass, eYield);
									if (MOD_BALANCE_CORE_POLICIES && iYieldChange != 0)
									{
										pLoopCity->changeReligionBuildingYieldRateModifier(eBuildingClass, eYield, (iYieldChange * iBuildingCount * iChange));
									}
#endif
								}
							}
						}
					}
				}
			}
		}

#if defined(MOD_API_UNIFIED_YIELDS)
		if (iTotalWonders > 0) {
			for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				YieldTypes eYield = (YieldTypes) iI;
				int iYield = pPolicy->GetYieldChangeWorldWonder(iI);

#if !defined(MOD_API_UNIFIED_YIELDS_CONSOLIDATION)
				if (eYield == YIELD_CULTURE)
				{
					pLoopCity->ChangeJONSCulturePerTurnFromBuildings(iYield * iTotalWonders * iChange);
				}
				else if (eYield == YIELD_FAITH)
				{
					pLoopCity->ChangeFaithPerTurnFromBuildings(iYield * iTotalWonders * iChange);
				}
				else
#endif
				{
					pLoopCity->ChangeBaseYieldRateFromBuildings(eYield, iYield * iTotalWonders * iChange);
				}
			}
		}
#endif
	}
#if defined(MOD_BALANCE_CORE)
	// Free Buildings from Policies
	if(MOD_BALANCE_CORE)
	{
		for(iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
		{
			const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iI);
			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
			if(pkBuildingClassInfo)
			{
				int iNumFreeBuildings = pPolicy->GetFreeChosenBuilding(eBuildingClass);
				if(iNumFreeBuildings > 0)
				{
					const BuildingTypes eBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(pkBuildingClassInfo->GetID())));
					if(NO_BUILDING != eBuilding)
					{
						CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
						if(pkBuildingInfo)
						{
							ChangeNumCitiesFreeChosenBuilding(eBuildingClass, iNumFreeBuildings);
							int iLoopTwo;
							for(pLoopCity = firstCity(&iLoopTwo); pLoopCity != NULL; pLoopCity = nextCity(&iLoopTwo))
							{
								if(pLoopCity->isValidBuildingLocation(eBuilding))
								{
									if(GetNumCitiesFreeChosenBuilding(eBuildingClass) > 0)
									{
										if(pLoopCity->GetCityBuildings()->GetNumRealBuilding(eBuilding) > 0)
										{
											pLoopCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, 0);
										}

										pLoopCity->GetCityBuildings()->SetNumFreeBuilding(eBuilding, 1);

										if(pLoopCity->GetCityBuildings()->GetNumFreeBuilding(eBuilding) > 0)
										{
											ChangeNumCitiesFreeChosenBuilding(eBuildingClass, -1);
										}
										if(pLoopCity->getFirstBuildingOrder(eBuilding) == 0)
										{
											pLoopCity->clearOrderQueue();
											pLoopCity->chooseProduction();
											// Send a notification to the user that what they were building was given to them, and they need to produce something else.
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
#endif

	// Store off number of newly built cities that will get a free building
	ChangeNumCitiesFreeCultureBuilding(iNumCitiesFreeCultureBuilding);
	ChangeNumCitiesFreeFoodBuilding(iNumCitiesFreeFoodBuilding);

	// Not really techs but this is what we use (for now)
	for(iI = 0; iI < GC.getNUM_AND_TECH_PREREQS(); iI++)
	{
		if(pPolicy->GetPolicyDisables(iI) != NO_POLICY)
		{
			if(m_pPlayerPolicies->HasPolicy((PolicyTypes) pPolicy->GetPolicyDisables(iI)))
			{
				setHasPolicy((PolicyTypes) pPolicy->GetPolicyDisables(iI), false);
			}
		}
	}

	// Attack bonus for a period of time
	int iTurns = pPolicy->GetAttackBonusTurns() * iChange;
	if(iTurns > 0)
	{
		ChangeAttackBonusTurns(iTurns);
	}

	// Golden Age!
	int iGoldenAgeTurns = pPolicy->GetGoldenAgeTurns() * iChange;
	if(iGoldenAgeTurns > 0)
	{
		// Player modifier
		int iLengthModifier = getGoldenAgeModifier();
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
		// Do we get increased Golden Ages from a resource monopoly?
		if(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
		{
			for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
			{
				ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
				if(eResourceLoop != NO_RESOURCE)
				{
					CvResourceInfo* pInfo = GC.getResourceInfo(eResourceLoop);
					if (pInfo && pInfo->isMonopoly())
					{
						if(HasGlobalMonopoly(eResourceLoop) && pInfo->getMonopolyGALength() > 0)
						{
							int iTemp = pInfo->getMonopolyGALength();
							iTemp += GetMonopolyModPercent();
							iLengthModifier += iTemp;
						}
					}
				}
			}
		}
#endif
		// Trait modifier
		iLengthModifier += GetPlayerTraits()->GetGoldenAgeDurationModifier();

		if(iLengthModifier > 0)
		{
			iGoldenAgeTurns = iGoldenAgeTurns * (100 + iLengthModifier) / 100;
		}

		// Game Speed mod
		iGoldenAgeTurns *= GC.getGame().getGameSpeedInfo().getGoldenAgePercent();
		iGoldenAgeTurns /= 100;
#if defined(MOD_BALANCE_CORE)
		int iValue = GetGoldenAgeProgressMeter();
		changeGoldenAgeTurns(iGoldenAgeTurns, iValue);
#else
		changeGoldenAgeTurns(iGoldenAgeTurns);
#endif
	}

	// Free Techs
	int iNumFreeTechs = pPolicy->GetNumFreeTechs() * iChange;
	if(iNumFreeTechs > 0)
	{
		if(!isHuman())
		{
			for(iI = 0; iI < iNumFreeTechs; iI++)
			{
				AI_chooseFreeTech();
			}
		}
		else
		{
			CvString strBuffer = GetLocalizedText("TXT_KEY_MISC_COMPLETED_WONDER_CHOOSE_TECH", pPolicy->GetTextKey());
			chooseTech(iNumFreeTechs, strBuffer.GetCString());
		}
	}

	ChangeMedianTechPercentage(pPolicy->GetMedianTechPercentChange());

	// Free Policies
	int iNumFreePolicies = pPolicy->GetNumFreePolicies() * iChange;
	if(iNumFreePolicies > 0)
	{
		ChangeNumFreePolicies(iNumFreePolicies);
	}

	if(pPolicy->IncludesOneShotFreeUnits())
	{
		if(!m_pPlayerPolicies->HaveOneShotFreeUnitsFired(ePolicy))
		{
			m_pPlayerPolicies->SetOneShotFreeUnitsFired(ePolicy,true);

			int iNumFreeGreatPeople = pPolicy->GetNumFreeGreatPeople() * iChange;
			if(iNumFreeGreatPeople > 0)
			{
				ChangeNumFreeGreatPeople(iNumFreeGreatPeople);
			}

			if(getCapitalCity() != NULL)
			{
				int iX = getCapitalCity()->getX();
				int iY = getCapitalCity()->getY();

				for(iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
				{
					const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
					CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
					if(pkUnitClassInfo)
					{
						int iNumFreeUnits = pPolicy->GetNumFreeUnitsByClass(eUnitClass);
						if(iNumFreeUnits > 0)
						{
							const UnitTypes eUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eUnitClass);
							CvUnitEntry* pUnitEntry = GC.getUnitInfo(eUnit);
							if(GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && isHuman() && pUnitEntry != NULL && pUnitEntry->IsFound())
							{
								continue;
							}

							for(int iUnitLoop = 0; iUnitLoop < iNumFreeUnits; iUnitLoop++)
							{
								CvUnit* pNewUnit = NULL;

								// slewis
								// for venice
								if (pUnitEntry->IsFound() && GetPlayerTraits()->IsNoAnnexing())
								{
									// drop a merchant of venice instead
									// find the eUnit replacement that's the merchant of venice
									for(int iVeniceSearch = 0; iVeniceSearch < GC.getNumUnitClassInfos(); iVeniceSearch++)
									{
										const UnitClassTypes eVeniceUnitClass = static_cast<UnitClassTypes>(iVeniceSearch);
										CvUnitClassInfo* pkVeniceUnitClassInfo = GC.getUnitClassInfo(eVeniceUnitClass);
										if(pkVeniceUnitClassInfo)
										{
											const UnitTypes eMerchantOfVeniceUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eVeniceUnitClass);
											if (eMerchantOfVeniceUnit != NO_UNIT)
											{
												CvUnitEntry* pVeniceUnitEntry = GC.getUnitInfo(eMerchantOfVeniceUnit);
												if (pVeniceUnitEntry->IsCanBuyCityState())
												{
													pNewUnit = initUnit(eMerchantOfVeniceUnit, iX, iY);				
													break;
												}
											}
										}
									}
								}
								else
								{
									pNewUnit = initUnit(eUnit, iX, iY);
								}

								CvAssert(pNewUnit);

								if (pNewUnit)
								{
									if(pNewUnit->IsGreatGeneral())
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGreatGeneralsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGreatGeneralsCreated();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
									else if(pNewUnit->IsGreatAdmiral())
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGreatAdmiralsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGreatAdmiralsCreated();
#endif
										CvPlot *pSpawnPlot = GetGreatAdmiralSpawnPlot(pNewUnit);
										if (pNewUnit->plot() != pSpawnPlot)
										{
											pNewUnit->setXY(pSpawnPlot->getX(), pSpawnPlot->getY());
										}
									}
									else if(pNewUnit->getUnitInfo().IsFoundReligion())
									{
										ReligionTypes eReligion = GetReligions()->GetReligionCreatedByPlayer();
										int iReligionSpreads = pNewUnit->getUnitInfo().GetReligionSpreads();
										int iReligiousStrength = pNewUnit->getUnitInfo().GetReligiousStrength();
										if(iReligionSpreads > 0 && eReligion > RELIGION_PANTHEON)
										{
											pNewUnit->GetReligionData()->SetSpreadsLeft(iReligionSpreads);
											pNewUnit->GetReligionData()->SetReligiousStrength(iReligiousStrength);
											pNewUnit->GetReligionData()->SetReligion(eReligion);
										}
									}
									else if (pNewUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_WRITER"))
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGreatWritersCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGreatWritersCreated();
#endif
#if !defined(MOD_BALANCE_CORE)
										if (pNewUnit->getUnitInfo().GetOneShotTourism() > 0)
										{
											pNewUnit->SetTourismBlastStrength(GetCulture()->GetTourismBlastStrength(pNewUnit->getUnitInfo().GetOneShotTourism()));
										}
#endif

										pNewUnit->jumpToNearestValidPlot();
									}							
									else if (pNewUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_ARTIST"))
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGreatArtistsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGreatArtistsCreated();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}							
									else if (pNewUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_MUSICIAN"))
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGreatMusiciansCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGreatMusiciansCreated();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
#if defined(MOD_DIPLOMACY_CITYSTATES)
									else if (MOD_DIPLOMACY_CITYSTATES && pNewUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_GREAT_DIPLOMAT"))
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGreatDiplomatsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGreatDiplomatsCreated();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
#endif
#if defined(MOD_BALANCE_CORE)
									else if (pNewUnit->getUnitInfo().IsGPExtra() == 1)
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGPExtra1Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGPExtra1Created();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
									else if (pNewUnit->getUnitInfo().IsGPExtra() == 2)
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGPExtra2Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGPExtra2Created();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
									else if (pNewUnit->getUnitInfo().IsGPExtra() == 3)
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGPExtra3Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGPExtra3Created();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
									else if (pNewUnit->getUnitInfo().IsGPExtra() == 4)
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGPExtra4Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGPExtra4Created();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
									else if (pNewUnit->getUnitInfo().IsGPExtra() == 5)
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGPExtra5Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGPExtra5Created();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
#endif
									else if(pNewUnit->IsGreatPerson())
									{
#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
										if (MOD_GLOBAL_SEPARATE_GP_COUNTERS) {
											if (pNewUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_MERCHANT")) {
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
												incrementGreatMerchantsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
												incrementGreatMerchantsCreated();
#endif
											} else if (pNewUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_SCIENTIST")) {
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
												incrementGreatScientistsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
												incrementGreatScientistsCreated();
#endif
											} else {
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
												incrementGreatEngineersCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
												incrementGreatEngineersCreated();
#endif
											}
										} else
#endif
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGreatPeopleCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGreatPeopleCreated();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
									else
									{
										pNewUnit->jumpToNearestValidPlot();
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// Great People bonus from Allied city-states
	if(pPolicy->IsMinorGreatPeopleAllies())
	{
		DoAdoptedGreatPersonCityStatePolicy();
	}

	// Add a Reformation belief if eligible
#if defined(MOD_RELIGION_LOCAL_RELIGIONS)
	if (isHuman() && pPolicy->IsAddReformationBelief() && GetReligions()->HasCreatedReligion(true) && !GetReligions()->HasAddedReformationBelief())
#else
	if (isHuman() && pPolicy->IsAddReformationBelief() && GetReligions()->HasCreatedReligion() && !GetReligions()->HasAddedReformationBelief())
#endif
	{
		pNotifications = GetNotifications();
		if(pNotifications)
		{
			CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_ADD_REFORMATION_BELIEF");
			CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_ADD_REFORMATION_BELIEF");
			pNotifications->Add(NOTIFICATION_ADD_REFORMATION_BELIEF, strBuffer, strSummary, -1, -1, -1);
		}
	}

	// if the steal tech faster amount is modified, then update the progress of all spies
	if (pPolicy->GetStealTechFasterModifier() != 0)
	{
		GetEspionage()->UpdateSpies();
	}

	CvPlot *pLoopPlot;
	ResourceTypes eResource;
	for(iI = 0; iI < GC.getMap().numPlots(); iI++)
	{
		pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);
		eResource = pLoopPlot->getResourceType();
		if(eResource != NO_RESOURCE)
		{
			if(GC.getResourceInfo(eResource)->getPolicyReveal() == (int)ePolicy)
			{
				pLoopPlot->updateYield();
				if (pLoopPlot->isRevealed(getTeam()))
				{
					pLoopPlot->setLayoutDirty(true);
				}
			}
		}
	}

	GetTrade()->UpdateTradeConnectionValues();
	recomputeGreatPeopleModifiers();
	recomputePolicyCostModifier();
	recomputeFreeExperience();
#if defined(MOD_BALANCE_CORE)
	CvCity* pLoopCity2;
	int iLoop2;
	for(pLoopCity2 = firstCity(&iLoop2); pLoopCity2 != NULL; pLoopCity2 = nextCity(&iLoop2))
	{
		if(pLoopCity2 != NULL)
		{
			pLoopCity2->UpdateReligion(pLoopCity2->GetCityReligions()->GetReligiousMajority(), true);		
		}
	}
#endif
	CalculateNetHappiness();

	doUpdateBarbarianCampVisibility();

	GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
}

//	--------------------------------------------------------------------------------
/// If we should see where the locations of all current Barb Camps are, do it
void CvPlayer::doUpdateBarbarianCampVisibility()
{
	if(IsAlwaysSeeBarbCamps())
	{
		CvPlot* pPlot;

		ImprovementTypes eImprovement;

		for(int iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); ++iPlotLoop)
		{
			pPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);

			if(pPlot->isRevealed(getTeam()))
			{
				eImprovement = pPlot->getImprovementType();

				// Camp here
				if(eImprovement == GC.getBARBARIAN_CAMP_IMPROVEMENT())
				{
					// We don't see Camp
					if(pPlot->getRevealedImprovementType(getTeam()) != eImprovement)
					{
						pPlot->setRevealedImprovementType(getTeam(), eImprovement);
					}
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isPbemNewTurn() const
{
	return m_bPbemNewTurn;
}

//	--------------------------------------------------------------------------------
void CvPlayer::setPbemNewTurn(bool bNew)
{
	m_bPbemNewTurn = bNew;
}

//	--------------------------------------------------------------------------------
CvEconomicAI* CvPlayer::GetEconomicAI() const
{
	return m_pEconomicAI;
}

//	--------------------------------------------------------------------------------
CvMilitaryAI* CvPlayer::GetMilitaryAI() const
{
	return m_pMilitaryAI;
}

//	--------------------------------------------------------------------------------
CvCitySpecializationAI* CvPlayer::GetCitySpecializationAI() const
{
	return m_pCitySpecializationAI;
}

//	--------------------------------------------------------------------------------
CvWonderProductionAI* CvPlayer::GetWonderProductionAI() const
{
	return m_pWonderProductionAI;
}

//	--------------------------------------------------------------------------------
CvGrandStrategyAI* CvPlayer::GetGrandStrategyAI() const
{
	return m_pGrandStrategyAI;
}

//	--------------------------------------------------------------------------------
CvDiplomacyAI* CvPlayer::GetDiplomacyAI() const
{
	return m_pDiplomacyAI;
}

//	--------------------------------------------------------------------------------
CvPlayerReligions* CvPlayer::GetReligions() const
{
	return m_pReligions;
}

//	--------------------------------------------------------------------------------
CvReligionAI* CvPlayer::GetReligionAI() const
{
	return m_pReligionAI;
}

//	--------------------------------------------------------------------------------
CvMinorCivAI* CvPlayer::GetMinorCivAI() const
{
	return m_pMinorCivAI;
}

//	--------------------------------------------------------------------------------
CvDealAI* CvPlayer::GetDealAI() const
{
	return m_pDealAI;
}

//	--------------------------------------------------------------------------------
/// Get the object that decides what task the builders should perform
CvBuilderTaskingAI* CvPlayer::GetBuilderTaskingAI() const
{
	return m_pBuilderTaskingAI;
}

//	--------------------------------------------------------------------------------
/// Get the city connection that gives you information about the route connections between cities
CvCityConnections* CvPlayer::GetCityConnections() const
{
	return m_pCityConnections;
}

//	--------------------------------------------------------------------------------
/// Get the player's information about their espionage
CvPlayerEspionage* CvPlayer::GetEspionage() const
{
	return m_pEspionage;
}

//	--------------------------------------------------------------------------------
/// Get the player's espionage AI version
CvEspionageAI* CvPlayer::GetEspionageAI() const
{
	return m_pEspionageAI;
}

//	--------------------------------------------------------------------------------
/// Get the player's information about their trade
CvPlayerTrade* CvPlayer::GetTrade() const
{
	return m_pTrade;
}

//	--------------------------------------------------------------------------------
/// Get the player's trade AI version
CvTradeAI* CvPlayer::GetTradeAI() const
{
	return m_pTradeAI;
}

//	--------------------------------------------------------------------------------
/// Get the player's League AI
CvLeagueAI* CvPlayer::GetLeagueAI() const
{
	return m_pLeagueAI;
}

//	--------------------------------------------------------------------------------
CvPlayerCulture* CvPlayer::GetCulture() const
{
	return m_pCulture;
}

//	--------------------------------------------------------------------------------
CvNotifications* CvPlayer::GetNotifications() const
{
	return m_pNotifications;
}

#if defined(MOD_API_EXTENSIONS)
//	--------------------------------------------------------------------------------
int CvPlayer::AddNotification(NotificationTypes eNotificationType, const char* sMessage, const char* sSummary, int iGameDataIndex, int iExtraGameData)
{
  return AddNotification(eNotificationType, sMessage, sSummary, NULL, iGameDataIndex, iExtraGameData);
}

int CvPlayer::AddNotification(NotificationTypes eNotificationType, const char* sMessage, const char* sSummary, CvPlot* pPlot, int iGameDataIndex, int iExtraGameData)
{
  int iNotification = -1;
  
  CvNotifications* pNotifications = GetNotifications();

  if (pNotifications) {
    const int iPlotX = pPlot ? pPlot->getX() : -1;
    const int iPlotY = pPlot ? pPlot->getY() : -1;
	
    iNotification = pNotifications->Add(eNotificationType, sMessage, sSummary, iPlotX, iPlotY, iGameDataIndex, iExtraGameData);
  }
  
  return iNotification;
}
#endif

//	--------------------------------------------------------------------------------
CvTreasury* CvPlayer::GetTreasury() const
{
	return m_pTreasury;
}

//	--------------------------------------------------------------------------------
CvDiplomacyRequests* CvPlayer::GetDiplomacyRequests() const
{
	return m_pDiplomacyRequests;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::HasActiveDiplomacyRequests() const
{
	PlayerTypes ePlayer = GetID();

	// Do I have any?
	CvDiplomacyRequests* pkDiploRequests = GetDiplomacyRequests();
	if(pkDiploRequests && pkDiploRequests->HasActiveRequest())
		return true;

	// Do I have any for others?
	for(int i = 0; i < MAX_PLAYERS; ++i)
	{
		const CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)i);
		if(kPlayer.isAlive())
		{
			pkDiploRequests = kPlayer.GetDiplomacyRequests();
			if(pkDiploRequests)
			{
				if(pkDiploRequests->HasActiveRequestFrom(ePlayer))
					return true;
			}
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
//
// read object from a stream
// used during load
//
void CvPlayer::Read(FDataStream& kStream)
{
	// Init data before load
	reset();

	// Version number to maintain backwards compatibility
	uint uiVersion;
	kStream >> uiVersion;
	MOD_SERIALIZE_INIT_READ(kStream);

#if defined(MOD_BALANCE_CORE)
	kStream >> m_syncArchive;
	//Values below deleted, as they're already in the sync archive! Use the sync archive from now on!
#endif

	m_pPlayerPolicies->Read(kStream);
	m_pEconomicAI->Read(kStream);
	m_pCitySpecializationAI->Read(kStream);
	m_pWonderProductionAI->Read(kStream);
	m_pMilitaryAI->Read(kStream);
	m_pGrandStrategyAI->Read(kStream);
	m_pDiplomacyAI->Read(kStream);
	m_pReligions->Read(kStream);
	m_pReligionAI->Read(kStream);
	m_pPlayerTechs->Read(kStream);
	m_pFlavorManager->Read(kStream);
	m_pTacticalAI->Read(kStream);
	m_pHomelandAI->Read(kStream);
	m_pMinorCivAI->Read(kStream);
	m_pDealAI->Read(kStream);
	m_pBuilderTaskingAI->Read(kStream);
	m_pCityConnections->Read(kStream);
#if defined(MOD_BALANCE_CORE)
	SetDangerPlotsDirty();
#else
	m_pDangerPlots->Read(kStream);
#endif
	m_pTraits->Read(kStream);
	kStream >> *m_pEspionage;
	kStream >> *m_pEspionageAI;
	kStream >> *m_pTrade;
	kStream >> *m_pTradeAI;
	m_pLeagueAI->Read(kStream);
	kStream >> *m_pCulture;

	bool bReadNotifications;
	kStream >> bReadNotifications;
	if(bReadNotifications)
	{
		if (!m_pNotifications)
			m_pNotifications = FNEW(CvNotifications, c_eCiv5GameplayDLL, 0);
		m_pNotifications->Init(GetID());
		m_pNotifications->Read(kStream);
	}
	m_pTreasury->Read(kStream);

	// If this is a real player, hook up the player-level flavor recipients
	if(GetID() != NO_PLAYER)
	{
		SlotStatus s = CvPreGame::slotStatus(GetID());
		if((s == SS_TAKEN || s == SS_COMPUTER) && !isBarbarian())
		{
			m_pFlavorManager->AddFlavorRecipient(m_pPlayerTechs,        false /*bPropogateFlavors*/);
			m_pFlavorManager->AddFlavorRecipient(m_pPlayerPolicies,     false /*bPropogateFlavors*/);
			m_pFlavorManager->AddFlavorRecipient(m_pWonderProductionAI, false /*bPropogateFlavors*/);
		}
	}

	kStream >> m_UnitCycle;
	kStream >> m_researchQueue;

	kStream >> m_eEndTurnBlockingType;
	kStream >> m_iEndTurnBlockingNotificationIndex;

	kStream >> m_cityNames;

	kStream >> m_cities;
#if defined(MOD_BALANCE_CORE_SETTLER)
	SetClosestCityMapDirty();
#endif

	kStream >> m_units;
	kStream >> m_armyAIs;

	{
		m_AIOperations.clear();
		uint iSize;
		int iID;
		int iOperationType;
		kStream >> iSize;
		for(uint i = 0; i < iSize; i++)
		{
			kStream >> iID;
			kStream >> iOperationType;
			CvAIOperation* pThisOperation = CvAIOperation::CreateOperation((AIOperationTypes)iOperationType, m_eID);
			pThisOperation->Read(kStream);
			m_AIOperations.insert(std::make_pair(pThisOperation->GetID(), pThisOperation));
		}
	}

	if (uiVersion <= 10)
	{
		// Unused popup queue
		int iSize;
		kStream >> iSize;
		CvAssert(iSize == 0);
	}

	kStream >> m_ReplayDataSets;
	kStream >> m_ReplayDataSetValues;

	kStream >> m_aVote;
	kStream >> m_aUnitExtraCosts;

	// reading plot values
	{
		m_aiPlots.clear();
		m_aiPlots.push_back_copy(-1, GC.getMap().numPlots());

		// trying to cut down how big saves are
		int iSize;
		kStream >> iSize;
		for(int i = 0; i < iSize; i++)
		{
			kStream >> m_aiPlots[i];
		}
	}

	if(!isBarbarian())
	{
		// Get the NetID from the initialization structure
		setNetID(gDLL->getAssignedNetworkID(GetID()));
	}

	m_bfEverConqueredBy.ClearAll();
	int iSize;
	kStream >> iSize;
	for(int i = 0; i < iSize; i++)
	{
		bool bValue;
		kStream >> bValue;
		if(bValue)
		{
			m_bfEverConqueredBy.SetBit(i);
		}
	}

	kStream >> m_strEmbarkedGraphicOverride;
	m_kPlayerAchievements.Read(kStream);

	if(GetID() < MAX_MAJOR_CIVS)
	{
		if(!m_pDiplomacyRequests)
			m_pDiplomacyRequests = FNEW(CvDiplomacyRequests, c_eCiv5GameplayDLL, 0);
		else
			m_pDiplomacyRequests->Uninit();

		m_pDiplomacyRequests->Init(GetID());
		//m_pDiplomacyRequests->Read(kStream);
	}

	if(m_bTurnActive)
		GC.getGame().changeNumGameTurnActive(1, std::string("setTurnActive() [loading save game] for player ") + getName());

#if defined(MOD_API_UNIFIED_YIELDS) && defined(MOD_API_PLOT_YIELDS)
	// MOD_SERIALIZE_READ - v57/v58/v59 broke the save format  couldn't be helped, but don't make a habit of it!!!
	kStream >> m_ppiPlotYieldChange;
#endif
#if defined(MOD_API_UNIFIED_YIELDS)
	// MOD_SERIALIZE_READ - v57/v58/v59 and v61 broke the save format  couldn't be helped, but don't make a habit of it!!!
	kStream >> m_ppiImprovementYieldChange;
	kStream >> m_ppiFeatureYieldChange;
	kStream >> m_ppiResourceYieldChange;
	kStream >> m_ppiTerrainYieldChange;
	kStream >> m_ppiTradeRouteYieldChange;
	kStream >> m_ppiSpecialistYieldChange;
	kStream >> m_ppiGreatPersonExpendedYield;
	kStream >> m_piGoldenAgeGreatPersonRateModifier;
	kStream >> m_ppiUnimprovedFeatureYieldChange;
	kStream >> m_ppiCityYieldFromUnimprovedFeature;
	kStream >> m_piYieldFromKills;
	kStream >> m_piYieldFromBarbarianKills;
	kStream >> m_piYieldChangeTradeRoute;
	kStream >> m_piYieldChangesNaturalWonder;
	kStream >> m_piYieldChangeWorldWonder;
	kStream >> m_piYieldFromMinorDemand;
	kStream >> m_ppiBuildingClassYieldChange;
	kStream >> m_piCityFeatures;
	kStream >> m_piNumBuildings;
	kStream >> m_ppiApproachScratchValue;
#endif
#if defined(MOD_BALANCE_CORE)
/// MODDED ELEMENTS BELOW
	UpdateAreaEffectUnits();
	GET_TEAM(getTeam()).updateTeamStatus();
	UpdateCurrentAndFutureWars();

	int iLoop=0;
	for (CvCity* pCity=firstCity(&iLoop); pCity!=NULL; pCity=nextCity(&iLoop))
	{
		pCity->GetClosestFriendlyNeighboringCities();
	}
#endif
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	kStream >> m_pabHasGlobalMonopoly;
	kStream >> m_pabHasStrategicMonopoly;

	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		if (MOD_BALANCE_CORE_RESOURCE_MONOPOLIES && m_pabHasGlobalMonopoly[iResourceLoop])
		{
			SetHasGlobalMonopoly((ResourceTypes)iResourceLoop, true);
		}
		if (MOD_BALANCE_CORE_RESOURCE_MONOPOLIES_STRATEGIC && m_pabHasStrategicMonopoly[iResourceLoop])
		{
			SetHasStrategicMonopoly((ResourceTypes)iResourceLoop, true);
		}
	}
	kStream >> m_noSettlingPlots;
#endif
}

//	--------------------------------------------------------------------------------
//
// save object to a stream
// used during save
//
void CvPlayer::Write(FDataStream& kStream) const
{
	//Save version number.  THIS MUST BE FIRST!!
	kStream << g_CurrentCvPlayerVersion;
	MOD_SERIALIZE_INIT_WRITE(kStream);

#if defined(MOD_BALANCE_CORE)
	kStream << m_syncArchive;
	//Values below deleted, as they're already in the sync archive! Use the sync archive from now on!
#endif
	m_pPlayerPolicies->Write(kStream);
	m_pEconomicAI->Write(kStream);
	m_pCitySpecializationAI->Write(kStream);
	m_pWonderProductionAI->Write(kStream);
	m_pMilitaryAI->Write(kStream);
	m_pGrandStrategyAI->Write(kStream);
	m_pDiplomacyAI->Write(kStream);
	m_pReligions->Write(kStream);
	m_pReligionAI->Write(kStream);
	m_pPlayerTechs->Write(kStream);
	m_pFlavorManager->Write(kStream);
	m_pTacticalAI->Write(kStream);
	m_pHomelandAI->Write(kStream);
	m_pMinorCivAI->Write(kStream);
	m_pDealAI->Write(kStream);
	m_pBuilderTaskingAI->Write(kStream);
	m_pCityConnections->Write(kStream);
#if !defined(MOD_BALANCE_CORE)
	m_pDangerPlots->Write(kStream);
#endif
	m_pTraits->Write(kStream);
	kStream << *m_pEspionage;
	kStream << *m_pEspionageAI;
	kStream << *m_pTrade;
	kStream << *m_pTradeAI;
	m_pLeagueAI->Write(kStream);
	kStream << *m_pCulture;

	if(m_pNotifications)
	{
		kStream << true;
		m_pNotifications->Write(kStream);
	}
	else
	{
		kStream << false;
	}
	m_pTreasury->Write(kStream);

	kStream << m_UnitCycle;
	kStream << m_researchQueue;

	kStream << m_eEndTurnBlockingType;
	kStream << m_iEndTurnBlockingNotificationIndex;

	kStream << m_cityNames;
	kStream << m_cities;
	kStream << m_units;
	kStream << m_armyAIs;

	{
		uint iSize = m_AIOperations.size();
		kStream << iSize;
		std::map<int, CvAIOperation*>::const_iterator it;
		for(it = m_AIOperations.begin(); it != m_AIOperations.end(); ++it)
		{
			kStream << it->first;
			CvAIOperation* pThisOperation = it->second;
			kStream << pThisOperation->GetOperationType();
			pThisOperation->Write(kStream);
		}
	}

	kStream << m_ReplayDataSets;
	kStream << m_ReplayDataSetValues;

	kStream << m_aVote;
	kStream << m_aUnitExtraCosts;

	// writing out plot values
	{
		// trying to cut down how big saves are
		int iSize = -1;
		for(int i = m_aiPlots.size() - 1; i >= 0; i--)
		{
			if(m_aiPlots[i] != -1)
			{
				iSize = i + 1;
				break;
			}
		}

		if(iSize < 0)
		{
			iSize = 0;
		}

		kStream << iSize;
		for(int i = 0; i < iSize; i++)
		{
			kStream << m_aiPlots[i];
		}
	}

	// writing out
	{
		int iSize = MAX_PLAYERS;
		kStream << iSize;
		for(int i = 0; i < iSize; i++)
		{
			bool bValue = m_bfEverConqueredBy.GetBit(i);
			kStream << bValue;
		}
	}

	kStream << m_strEmbarkedGraphicOverride;

	m_kPlayerAchievements.Write(kStream);

#if defined(MOD_API_UNIFIED_YIELDS) && defined(MOD_API_PLOT_YIELDS)
	// MOD_SERIALIZE_READ - v57/v58/v59 broke the save format  couldn't be helped, but don't make a habit of it!!!
	kStream << m_ppiPlotYieldChange;
#endif
#if defined(MOD_API_UNIFIED_YIELDS)
	// MOD_SERIALIZE_READ - v57/v58/v59 and v61 broke the save format  couldn't be helped, but don't make a habit of it!!!
	kStream << m_ppiImprovementYieldChange;
	kStream << m_ppiFeatureYieldChange;
	kStream << m_ppiResourceYieldChange;
	kStream << m_ppiTerrainYieldChange;
	kStream << m_ppiTradeRouteYieldChange;
	kStream << m_ppiSpecialistYieldChange;
	kStream << m_ppiGreatPersonExpendedYield;
	kStream << m_piGoldenAgeGreatPersonRateModifier;
	kStream << m_ppiUnimprovedFeatureYieldChange;
	kStream << m_ppiCityYieldFromUnimprovedFeature;
	kStream << m_piYieldFromKills;
	kStream << m_piYieldFromBarbarianKills;
	kStream << m_piYieldChangeTradeRoute;
	kStream << m_piYieldChangesNaturalWonder;
	kStream << m_piYieldChangeWorldWonder;
	kStream << m_piYieldFromMinorDemand;
	kStream << m_ppiBuildingClassYieldChange;
	kStream << m_piCityFeatures;
	kStream << m_piNumBuildings;
	kStream << m_ppiApproachScratchValue;
#endif
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	kStream << m_pabHasGlobalMonopoly;
	kStream << m_pabHasStrategicMonopoly;
	kStream << m_noSettlingPlots;
#endif
}

//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
void CvPlayer::createGreatGeneral(UnitTypes eGreatPersonUnit, int iX, int iY, bool bIsFree)
#else
void CvPlayer::createGreatGeneral(UnitTypes eGreatPersonUnit, int iX, int iY)
#endif
{
	CvUnit* pGreatPeopleUnit = initUnit(eGreatPersonUnit, iX, iY);
	if(NULL == pGreatPeopleUnit)
	{
		CvAssert(false);
		return;
	}

	ChangeNumGreatPeople(1);

#if defined(MOD_GLOBAL_TRULY_FREE_GP)
	incrementGreatGeneralsCreated(bIsFree);
#else
	incrementGreatGeneralsCreated();
#endif

#if defined(MOD_GLOBAL_TRULY_FREE_GP)
	changeGreatGeneralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE() * ((getGreatGeneralsCreated(bIsFree) / 10) + 1));
#else
	changeGreatGeneralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE() * ((getGreatGeneralsCreated() / 10) + 1));
#endif

	for(int iI = 0; iI < MAX_PLAYERS; iI++)
	{
		if(GET_PLAYER((PlayerTypes)iI).getTeam() == getTeam())
		{
#if defined(MOD_BUGFIX_MINOR)
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
			GET_PLAYER((PlayerTypes)iI).changeGreatGeneralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE_TEAM() * ((getGreatGeneralsCreated(bIsFree) / 10) + 1));
#else
			GET_PLAYER((PlayerTypes)iI).changeGreatGeneralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE_TEAM() * ((getGreatGeneralsCreated() / 10) + 1));
#endif
#else
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
			GET_PLAYER((PlayerTypes)iI).changeGreatGeneralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE_TEAM() * ((getGreatPeopleCreated(bIsFree) / 10) + 1));
#else
			GET_PLAYER((PlayerTypes)iI).changeGreatGeneralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE_TEAM() * ((getGreatPeopleCreated() / 10) + 1));
#endif
#endif
		}
	}

#if defined(MOD_GLOBAL_LOCAL_GENERALS)
	CvPlot* pPlot = pGreatPeopleUnit->plot();

	// In rare cases we can gain the general from an embarked unit being attacked, or from a hovering unit over coast
	// so if this plot is water, relocate the Great General
	if (pPlot->isWater()) {
		pGreatPeopleUnit->jumpToNearestValidPlot();
	}
#else
	CvPlot* pPlot = GC.getMap().plot(iX, iY);
#endif

#if !defined(NO_ACHIEVEMENTS)
	//Achievements and Stats
	if(pGreatPeopleUnit->isHuman() && !GC.getGame().isGameMultiPlayer())
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_GREATGENERALS);
		const char* strLeader = GET_PLAYER(pGreatPeopleUnit->getOwner()).getLeaderTypeKey();
		if(strLeader && strcmp(strLeader, "LEADER_WU_ZETIAN") == 0)
		{
			gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_SUNTZU);
		}

		CvAchievementUnlocker::Check_PSG();
	}
#endif
#if defined(MOD_BALANCE_CORE)
	if(GetPlayerTraits()->IsInspirationalLeader() && IsAtWar() && !bIsFree)
	{
		int iLoop;
		CvUnit* pLoopUnit = NULL;
		for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
		{
			if (!pLoopUnit)
			{
				continue;
			}
			if(pLoopUnit->IsCombatUnit() && pLoopUnit->getDomainType() == DOMAIN_LAND)
			{
				pLoopUnit->changeDamage(-pLoopUnit->getDamage());
#if defined(MOD_UNITS_XP_TIMES_100)
				pLoopUnit->changeExperienceTimes100(10 * 100);
#else
				pLoopUnit->changeExperience(10);
#endif
			}
		}
	}
#endif
	// Notification
	if(GetNotifications())
	{
		Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER");
		Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_GREAT_PERSON");
		GetNotifications()->Add(NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER, strText.toUTF8(), strSummary.toUTF8(), pPlot->getX(), pPlot->getY(), eGreatPersonUnit);
	}
}

//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
void CvPlayer::createGreatAdmiral(UnitTypes eGreatPersonUnit, int iX, int iY, bool bIsFree)
#else
void CvPlayer::createGreatAdmiral(UnitTypes eGreatPersonUnit, int iX, int iY)
#endif
{
	CvUnit* pGreatPeopleUnit = initUnit(eGreatPersonUnit, iX, iY);
	if(NULL == pGreatPeopleUnit)
	{
		CvAssert(false);
		return;
	}

	ChangeNumGreatPeople(1);
#if !defined(MOD_GLOBAL_LOCAL_GENERALS)
	CvPlot *pSpawnPlot = GetGreatAdmiralSpawnPlot(pGreatPeopleUnit);
	if (pGreatPeopleUnit->plot() != pSpawnPlot)
	{
		pGreatPeopleUnit->setXY(pSpawnPlot->getX(), pSpawnPlot->getY());
	}
#endif

#if defined(MOD_GLOBAL_TRULY_FREE_GP)
	incrementGreatAdmiralsCreated(bIsFree);
#else
	incrementGreatAdmiralsCreated();
#endif
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
	changeGreatAdmiralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE() * ((getGreatAdmiralsCreated(bIsFree) / 10) + 1));
#else
	changeGreatAdmiralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE() * ((getGreatAdmiralsCreated() / 10) + 1));
#endif

	for(int iI = 0; iI < MAX_PLAYERS; iI++)
	{
		if(GET_PLAYER((PlayerTypes)iI).getTeam() == getTeam())
		{
#if defined(MOD_BUGFIX_MINOR)
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
			GET_PLAYER((PlayerTypes)iI).changeGreatAdmiralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE_TEAM() * ((getGreatAdmiralsCreated(bIsFree) / 10) + 1));
#else
			GET_PLAYER((PlayerTypes)iI).changeGreatAdmiralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE_TEAM() * ((getGreatAdmiralsCreated() / 10) + 1));
#endif
#else
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
			GET_PLAYER((PlayerTypes)iI).changeGreatAdmiralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE_TEAM() * ((getGreatPeopleCreated(bIsFree) / 10) + 1));
#else
			GET_PLAYER((PlayerTypes)iI).changeGreatAdmiralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE_TEAM() * ((getGreatPeopleCreated() / 10) + 1));
#endif
#endif
		}
	}

	CvPlot* pPlot = GC.getMap().plot(iX, iY);

	// Notification
	if(GetNotifications())
	{
		Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER");
		Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_GREAT_PERSON");
		GetNotifications()->Add(NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER, strText.toUTF8(), strSummary.toUTF8(), pPlot->getX(), pPlot->getY(), eGreatPersonUnit);
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::launch(VictoryTypes eVictory)
{
	CvTeam& kTeam = GET_TEAM(getTeam());

	if(!kTeam.canLaunch(eVictory))
	{
		return;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getUnitExtraCost(UnitClassTypes eUnitClass) const
{
	for(std::vector< std::pair<UnitClassTypes, int> >::const_iterator it = m_aUnitExtraCosts.begin(); it != m_aUnitExtraCosts.end(); ++it)
	{
		if((*it).first == eUnitClass)
		{
			return ((*it).second);
		}
	}

	return 0;
}

//	--------------------------------------------------------------------------------
void CvPlayer::setUnitExtraCost(UnitClassTypes eUnitClass, int iCost)
{
	for(std::vector< std::pair<UnitClassTypes, int> >::iterator it = m_aUnitExtraCosts.begin(); it != m_aUnitExtraCosts.end(); ++it)
	{
		if((*it).first == eUnitClass)
		{
			if(0 == iCost)
			{
				m_aUnitExtraCosts.erase(it);
			}
			else
			{
				(*it).second = iCost;
			}
			return;
		}
	}

	if(0 != iCost)
	{
		m_aUnitExtraCosts.push_back(std::make_pair(eUnitClass, iCost));
	}
}

// CACHE: cache frequently used values
///////////////////////////////////////

//	--------------------------------------------------------------------------------
void CvPlayer::invalidatePopulationRankCache()
{
	int iLoop;
	CvCity* pLoopCity;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->invalidatePopulationRankCache();
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::invalidateYieldRankCache(YieldTypes)
{
	int iLoop;
	CvCity* pLoopCity;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->invalidateYieldRankCache();
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::doUpdateCacheOnTurn()
{
#if defined(MOD_BALANCE_CORE)
	struct CompareUnitPowerAscending
	{
		const TContainer<CvUnit>& container;

		CompareUnitPowerAscending(TContainer<CvUnit>& c) : container(c) {}
		bool operator()(int iID1, int iID2)
		{
			return ( container.Get(iID1)->GetPower() > container.Get(iID2)->GetPower() );
		}

	private:
		//need an assignment operator apparently
		CompareUnitPowerAscending& operator=( const CompareUnitPowerAscending& ) { return *this; }
	};

	//this orders units by combat strength
	m_units.OrderByContent( CompareUnitPowerAscending(m_units) );
#endif
}

//	--------------------------------------------------------------------------------
PlayerTypes CvPlayer::pickConqueredCityOwner(const CvCity& kCity) const
{
	PlayerTypes eBestPlayer = kCity.getOriginalOwner();

	if(NO_PLAYER != eBestPlayer)
	{
		CvPlayer& kBestPlayer = GET_PLAYER(eBestPlayer);

		if(kBestPlayer.getTeam() == getTeam())
		{
			return eBestPlayer;
		}
	}

	return GetID();
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canStealTech(PlayerTypes eTarget, TechTypes eTech) const
{
	if(GET_TEAM(GET_PLAYER(eTarget).getTeam()).GetTeamTechs()->HasTech(eTech))
	{
		if(GetPlayerTechs()->CanResearch(eTech))
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canSpyDestroyUnit(PlayerTypes, CvUnit& kUnit) const
{
	if(kUnit.getTeam() == getTeam())
	{
		return false;
	}

	if(kUnit.getUnitInfo().GetProductionCost() <= 0)
	{
		return false;
	}

	if(!kUnit.plot()->isVisible(getTeam()))
	{
		return false;
	}

	return true;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canSpyBribeUnit(PlayerTypes eTarget, CvUnit& kUnit) const
{
	if(!canSpyDestroyUnit(eTarget, kUnit))
	{
		return false;
	}

	// Can't buy units when at war
	if(kUnit.isEnemy(getTeam()))
	{
		return false;
	}

	IDInfo* pUnitNode = kUnit.plot()->headUnitNode();

	while(pUnitNode != NULL)
	{
		CvUnit* pLoopUnit = ::getUnit(*pUnitNode);
		pUnitNode = kUnit.plot()->nextUnitNode(pUnitNode);

		if(NULL != pLoopUnit && pLoopUnit != &kUnit)
		{
			if(pLoopUnit->isEnemy(getTeam()))
			{
				// If we buy the unit, we will be on the same plot as an enemy unit! Not good.
				return false;
			}
		}
	}

	return true;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canSpyDestroyBuilding(PlayerTypes, BuildingTypes eBuilding) const
{
	CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
	if(pkBuilding)
	{
		if(pkBuilding->GetProductionCost() <= 0)
		{
			return false;
		}

		if(::isLimitedWonderClass(pkBuilding->GetBuildingClassInfo()))
		{
			return false;
		}
	}

	return true;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canSpyDestroyProject(PlayerTypes eTarget, ProjectTypes eProject) const
{
	CvProjectEntry& kProject = *GC.getProjectInfo(eProject);
	if(kProject.GetProductionCost() <= 0)
	{
		return false;
	}

	if(GET_TEAM(GET_PLAYER(eTarget).getTeam()).getProjectCount(eProject) <= 0)
	{
		return false;
	}

	if(::isWorldProject(eProject))
	{
		return false;
	}

	if(!kProject.IsSpaceship())
	{
		return false;
	}
	else
	{
		VictoryTypes eVictory = (VictoryTypes)kProject.GetVictoryPrereq();
		if(NO_VICTORY != eVictory)
		{
			// Can't destroy spaceship components if we have already launched
			if(GET_TEAM(GET_PLAYER(eTarget).getTeam()).getVictoryCountdown(eVictory) >= 0)
			{
				return false;
			}
		}
	}

	return true;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNewCityProductionValue() const
{
	if(GC.getSETTLER_PRODUCTION_SPEED() != 0)
	{
		return GC.getSETTLER_PRODUCTION_SPEED();
	}

	int iValue = 0;
	for(int iJ = 0; iJ < GC.getNumBuildingClassInfos(); iJ++)
	{
		const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iJ);
		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
		if(pkBuildingClassInfo)
		{
			const BuildingTypes eBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(iJ)));
			if(NO_BUILDING != eBuilding)
			{
				CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
				if(pkBuildingInfo)
				{
					if(pkBuildingInfo->GetFreeStartEra() != NO_ERA)
					{
						if(GC.getGame().getStartEra() >= pkBuildingInfo->GetFreeStartEra())
						{
							iValue += (100 * getProductionNeeded(eBuilding)) / std::max(1, 100 + getProductionModifier(eBuilding));
						}
					}
				}
			}
		}
	}

	iValue *= 100 + GC.getNEW_CITY_BUILDING_VALUE_MODIFIER();
	iValue /= 100;

	CvGame& kGame = GC.getGame();

	iValue += (GC.getADVANCED_START_CITY_COST() * kGame.getGameSpeedInfo().getGrowthPercent()) / 100;

	int iPopulation = GC.getINITIAL_CITY_POPULATION() + kGame.getStartEraInfo().getFreePopulation();
	for(int i = 1; i <= iPopulation; ++i)
	{
		iValue += (getGrowthThreshold(i) * GC.getADVANCED_START_POPULATION_COST()) / 100;
	}

	return iValue;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGrowthThreshold(int iPopulation) const
{
	CvAssertMsg(iPopulation > 0, "Population of city should be at least 1. Please show Jon this and send your last 5 autosaves.");

	int iThreshold;

	int iBaseThreshold = /*15*/ GC.getBASE_CITY_GROWTH_THRESHOLD();

	int iExtraPopThreshold = int((iPopulation-1) * /*6*/ GC.getCITY_GROWTH_MULTIPLIER());

	iBaseThreshold += iExtraPopThreshold;
	iExtraPopThreshold = (int) pow(double(iPopulation-1), (double) /*1.8*/ GC.getCITY_GROWTH_EXPONENT());

	iThreshold = iBaseThreshold + iExtraPopThreshold;

	if(isMinorCiv())
	{
		iThreshold *= GC.getMINOR_CIV_GROWTH_PERCENT();
		iThreshold /= 100;
	}

	iThreshold *= GC.getGame().getGameSpeedInfo().getGrowthPercent();
	iThreshold /= 100;

	iThreshold *= GC.getGame().getStartEraInfo().getGrowthPercent();
	iThreshold /= 100;

	if(!isHuman() && !IsAITeammateOfHuman() && !isBarbarian())
	{
		iThreshold *= GC.getGame().getHandicapInfo().getAIGrowthPercent();
		iThreshold /= 100;

		iThreshold *= std::max(0, ((GC.getGame().getHandicapInfo().getAIPerEraModifier() * GetCurrentEra()) + 100));
		iThreshold /= 100;
	}

	return std::max(1, iThreshold);
}

//	--------------------------------------------------------------------------------
/// This sets up the m_aiPlots array that is used to contain which plots the player contains
void CvPlayer::InitPlots(void)
{
	int iNumPlots = GC.getMap().getGridHeight() * GC.getMap().getGridHeight();
	// in case we're loading
	if(iNumPlots != m_aiPlots.size())
	{
		m_aiPlots.clear();
		m_aiPlots.push_back_copy(-1, iNumPlots);
	}
}

//	--------------------------------------------------------------------------------
/// This determines what plots the player has under control
void CvPlayer::UpdatePlots(void)
{
	if(m_aiPlots.size() == 0)  // not been inited
	{
		return;
	}

	int iPlotIndex = 0;
	int iMaxNumPlots = (int) m_aiPlots.size();
	while(iPlotIndex < iMaxNumPlots && m_aiPlots[iPlotIndex] != -1)
	{
		m_aiPlots[iPlotIndex] = -1;
		iPlotIndex++;
	}

	int iI;
	CvPlot* pLoopPlot;
	iPlotIndex = 0;
	int iNumPlotsInEntireWorld = GC.getMap().numPlots();
	for(iI = 0; iI < iNumPlotsInEntireWorld; iI++)
	{
		pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);
		if(pLoopPlot->getOwner() != m_eID)
		{
			continue;
		}

		//somebody might have plundered an improvement
		pLoopPlot->updateFreshwater();

		m_aiPlots[iPlotIndex] = iI;
		iPlotIndex++;
	}
}

//	--------------------------------------------------------------------------------
/// Adds a plot at the end of the list
void CvPlayer::AddAPlot(CvPlot* pPlot)
{
	if(!pPlot)
	{
		return;
	}

	if(m_aiPlots.size() == 0)  // not been inited
	{
		return;
	}

	if(pPlot->getOwner() == m_eID)
	{
		return;
	}

	int iPlotIndex = 0;
	int iMaxNumPlots = (int)m_aiPlots.size();
	while(iPlotIndex < iMaxNumPlots && m_aiPlots[iPlotIndex] != -1)
	{
		iPlotIndex++;
	}

	m_aiPlots[iPlotIndex] = GC.getMap().plotNum(pPlot->getX(), pPlot->getY());

}

//	--------------------------------------------------------------------------------
/// Returns the list of the plots the player owns
CvPlotsVector& CvPlayer::GetPlots(void)
{
	return m_aiPlots;
}

//	--------------------------------------------------------------------------------
/// How many plots does this player own?
int CvPlayer::GetNumPlots() const
{
	int iNumPlots = 0;

	CvPlot* pLoopPlot;
	int iNumPlotsInEntireWorld = GC.getMap().numPlots();
	for(int iI = 0; iI < iNumPlotsInEntireWorld; iI++)
	{
		pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

		if(pLoopPlot->getOwner() != m_eID)
			continue;

		iNumPlots++;
	}

	return iNumPlots;
}


//	--------------------------------------------------------------------------------
/// City strength mod (i.e. 100 = strength doubled)
int CvPlayer::GetCityStrengthMod() const
{
	return m_iCityStrengthMod;
}

//	--------------------------------------------------------------------------------
/// Sets City strength mod (i.e. 100 = strength doubled)
void CvPlayer::SetCityStrengthMod(int iValue)
{
	CvAssert(iValue >= 0);
	m_iCityStrengthMod = iValue;

	// Loop through all Cities and update their strength
	CvCity* pLoopCity;
	int iLoop;

	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->updateStrengthValue();
	}
}

//	--------------------------------------------------------------------------------
/// Changes City strength mod (i.e. 100 = strength doubled)
void CvPlayer::ChangeCityStrengthMod(int iChange)
{
	if(iChange != 0)
	{
		SetCityStrengthMod(GetCityStrengthMod() + iChange);
	}
}

//	--------------------------------------------------------------------------------
/// City growth percent mod (i.e. 100 = foodDifference doubled)
int CvPlayer::GetCityGrowthMod() const
{
	return m_iCityGrowthMod;
}

//	--------------------------------------------------------------------------------
/// Sets City growth percent mod (i.e. 100 = foodDifference doubled)
void CvPlayer::SetCityGrowthMod(int iValue)
{
	CvAssert(iValue >= 0);
	m_iCityGrowthMod = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes City growth percent mod (i.e. 100 = foodDifference doubled)
void CvPlayer::ChangeCityGrowthMod(int iChange)
{
	if(iChange != 0)
	{
		SetCityGrowthMod(GetCityGrowthMod() + iChange);
	}
}


//	--------------------------------------------------------------------------------
/// Capital growth percent mod (i.e. 100 = foodDifference doubled)
int CvPlayer::GetCapitalGrowthMod() const
{
	return m_iCapitalGrowthMod;
}

//	--------------------------------------------------------------------------------
/// Sets Capital growth percent mod (i.e. 100 = foodDifference doubled)
void CvPlayer::SetCapitalGrowthMod(int iValue)
{
	CvAssert(iValue >= 0);
	m_iCapitalGrowthMod = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes Capital growth percent mod (i.e. 100 = foodDifference doubled)
void CvPlayer::ChangeCapitalGrowthMod(int iChange)
{
	if(iChange != 0)
	{
		SetCapitalGrowthMod(GetCapitalGrowthMod() + iChange);
	}
}

//	--------------------------------------------------------------------------------
/// How many Plot has this player bought (costs should ramp up as more are purchased)
int CvPlayer::GetNumPlotsBought() const
{
	return m_iNumPlotsBought;
}

//	--------------------------------------------------------------------------------
/// Sets how many Plot has this player bought (costs should ramp up as more are purchased)
void CvPlayer::SetNumPlotsBought(int iValue)
{
	CvAssert(iValue >= 0);
	m_iNumPlotsBought = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes how many Plot has this player bought (costs should ramp up as more are purchased)
void CvPlayer::ChangeNumPlotsBought(int iChange)
{
	if(iChange != 0)
	{
		SetNumPlotsBought(GetNumPlotsBought() + iChange);
	}
}

//	--------------------------------------------------------------------------------
/// Gold cost of buying a new Plot
int CvPlayer::GetBuyPlotCost() const
{
	int iCost = /*50*/ GC.getPLOT_BASE_COST();
	iCost += (/*5*/ GC.getPLOT_ADDITIONAL_COST_PER_PLOT() * GetNumPlotsBought());

	// Cost Mod (Policies, etc.)
	if(GetPlotGoldCostMod() != 0)
	{
		iCost *= (100 + GetPlotGoldCostMod());
		iCost /= 100;
	}

	if(isMinorCiv())
	{
		iCost *= /*200*/ GC.getMINOR_CIV_GOLD_PERCENT();
		iCost /= 100;
	}

	return iCost;
}

//	--------------------------------------------------------------------------------
/// How much of a discount do we have for Plot buying
int CvPlayer::GetPlotGoldCostMod() const
{
	return m_iPlotGoldCostMod;
}

//	--------------------------------------------------------------------------------
/// Changes how much of a discount we have for Plot buying
void CvPlayer::ChangePlotGoldCostMod(int iChange)
{
	if(iChange != 0)
	{
		m_iPlotGoldCostMod += iChange;
	}
}

#if defined(MOD_TRAITS_CITY_WORKING) || defined(MOD_BUILDINGS_CITY_WORKING) || defined(MOD_POLICIES_CITY_WORKING) || defined(MOD_TECHS_CITY_WORKING)
//	--------------------------------------------------------------------------------
/// How many more city rings can we work
int CvPlayer::GetCityWorkingChange() const
{
	return m_iCityWorkingChange;
}

//	--------------------------------------------------------------------------------
/// Changes how many more city rings we can work
void CvPlayer::ChangeCityWorkingChange(int iChange)
{
	if(iChange != 0)
	{
		CvCity* pLoopCity;
		int iLoop;
		
		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
			int iOldPlots = pLoopCity->GetNumWorkablePlots();
			int iNewPlots = pLoopCity->GetNumWorkablePlots(iChange);
			
			for (int iI = std::min(iOldPlots, iNewPlots); iI < std::max(iOldPlots, iNewPlots); ++iI) {
				CvPlot* pLoopPlot = iterateRingPlots(pLoopCity->getX(), pLoopCity->getY(), iI);

				if (pLoopPlot) {
					pLoopPlot->changeCityRadiusCount(iChange);
					pLoopPlot->changePlayerCityRadiusCount(GetID(), iChange);
				}
			}
		}

		m_iCityWorkingChange += iChange;
	}
}
#endif

//	--------------------------------------------------------------------------------
/// How much Culture is required for this City to acquire a new Plot
int CvPlayer::GetPlotCultureCostModifier() const
{
	return m_iPlotCultureCostModifier;
}

//	--------------------------------------------------------------------------------
/// Changes how much Culture is required for this City to acquire a new Plot
void CvPlayer::ChangePlotCultureCostModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iPlotCultureCostModifier += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// How much do we dampen the exponent used to determine Culture needed for a City to acquire a new Plot?
int CvPlayer::GetPlotCultureExponentModifier() const
{
	return m_iPlotCultureExponentModifier;
}

//	--------------------------------------------------------------------------------
/// Changes how much we dampen the exponent used to determine Culture needed for a City to acquire a new Plot?
void CvPlayer::ChangePlotCultureExponentModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iPlotCultureExponentModifier += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// How much do we dampen the growth of policy costs based on number of cities?
int CvPlayer::GetNumCitiesPolicyCostDiscount() const
{
	return m_iNumCitiesPolicyCostDiscount;
}

//	--------------------------------------------------------------------------------
/// Changes how much we dampen the growth of policy costs based on number of cities
void CvPlayer::ChangeNumCitiesPolicyCostDiscount(int iChange)
{
	if(iChange != 0)
	{
		m_iNumCitiesPolicyCostDiscount += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Do we save on unit maintenance for garrisons?
bool CvPlayer::IsGarrisonFreeMaintenance() const
{
	return m_iGarrisonFreeMaintenanceCount > 0;
}

//	--------------------------------------------------------------------------------
/// Changes setting on unit maintenance for garrisons
void CvPlayer::ChangeGarrisonFreeMaintenanceCount(int iChange)
{
	if(iChange != 0)
	{
		m_iGarrisonFreeMaintenanceCount += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Increase in city range strike due to garrison
int CvPlayer::GetGarrisonedCityRangeStrikeModifier() const
{
	return m_iGarrisonedCityRangeStrikeModifier;
}

//	--------------------------------------------------------------------------------
/// Changes increase in city range strike due to garrison
void CvPlayer::ChangeGarrisonedCityRangeStrikeModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iGarrisonedCityRangeStrikeModifier += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Cost of purchasing units modified?
int CvPlayer::GetUnitPurchaseCostModifier() const
{
	return m_iUnitPurchaseCostModifier;
}

//	--------------------------------------------------------------------------------
/// Cost of purchasing units modified?
void CvPlayer::ChangeUnitPurchaseCostModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iUnitPurchaseCostModifier += iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetPlotDanger(const CvPlot& pPlot, const CvUnit* pUnit, AirActionType iAirAction) const
{
	return m_pDangerPlots->GetDanger(pPlot, pUnit, iAirAction);
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetPlotDanger(const CvPlot& pPlot, CvCity* pCity, const CvUnit* pPretendGarrison) const
{
	return m_pDangerPlots->GetDanger(pPlot, pCity, pPretendGarrison);
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetPlotDanger(const CvPlot& pPlot, PlayerTypes ePlayer) const
{
	return m_pDangerPlots->GetDanger(pPlot, ePlayer == NO_PLAYER ? GetID() : ePlayer );
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsPlotUnderImmediateThreat(const CvPlot& pPlot, PlayerTypes ePlayer) const
{
	return m_pDangerPlots->IsUnderImmediateThreat(pPlot, ePlayer == NO_PLAYER ? GetID() : ePlayer );
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsPlotUnderImmediateThreat(const CvPlot& pPlot, const CvUnit* pUnit) const
{
	return m_pDangerPlots->IsUnderImmediateThreat(pPlot, pUnit);
}

std::vector<CvUnit*> CvPlayer::GetPossibleAttackers(const CvPlot& Plot) const
{
	return m_pDangerPlots->GetPossibleAttackers(Plot);
}

bool CvPlayer::IsKnownAttacker(const CvUnit* pAttacker) const
{
	if (pAttacker)
		return m_pDangerPlots->IsKnownAttacker(pAttacker->getOwner(), pAttacker->GetID());

	return false;
}

void CvPlayer::AddKnownAttacker(const CvUnit* pAttacker)
{
	if (pAttacker)
		m_pDangerPlots->AddKnownAttacker(pAttacker->getOwner(), pAttacker->GetID());
}

//	--------------------------------------------------------------------------------
/// Find closest city to a plot (within specified search radius)
CvCity* CvPlayer::GetClosestCity(const CvPlot* pPlot, int iSearchRadius, bool bSameArea )
{
	if (!pPlot)
		return NULL;

	CvCity* pClosestCity = NULL;
	int iBestDistance = INT_MAX;

	int iLoop;
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		//need to check area
		if (bSameArea)
		{
			if (pPlot->isWater())
			{
				if (!pLoopCity->isCoastal())
					continue;
				if (pPlot->area()!=pLoopCity->waterArea())
					continue;
			}
			else
			{
				if (pPlot->getArea()!=pLoopCity->getArea())
					continue;
			}
		}

		int iDistance = plotDistance(pPlot->getX(), pPlot->getY(), pLoopCity->getX(), pLoopCity->getY());
		if(iDistance < iBestDistance && iDistance <= iSearchRadius)
		{
			pClosestCity = pLoopCity;
			iBestDistance = iDistance;
		}
	}

	return pClosestCity;
}

//	--------------------------------------------------------------------------------
// How many Puppet Cities does this player own
int CvPlayer::GetNumPuppetCities() const
{
	int iNum = 0;

	const CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity->IsPuppet())
		{
			iNum++;
		}
	}

	return iNum;
}
#if defined(MOD_DIPLOMACY_CITYSTATES_RESOLUTIONS) || defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
// How many other Capital Cities does this player own
int CvPlayer::GetNumCapitalCities() const
{
	int iNum = 0;

	const CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity->IsOriginalMajorCapital() && !pLoopCity->isCapital())
		{
			iNum++;
		}
	}

	return iNum;
}
#endif

#if defined(MOD_BALANCE_CORE_MILITARY)
int CvPlayer::GetFractionOriginalCapitalsUnderControl() const
{
	return m_iFractionOriginalCapitalsUnderControl;
}

void CvPlayer::UpdateFractionOriginalCapitalsUnderControl()
{
	m_iFractionOriginalCapitalsUnderControl = 0;

	int iLoop;
	int iOCCount = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		//don't count our own capital!
		if(pLoopCity->IsOriginalMajorCapital() && !pLoopCity->isCapital())
			iOCCount++;

	if(iOCCount > 0)
	{
		int iCivCount = 0;
		for (int iLoopPlayer = 0; iLoopPlayer < MAX_PLAYERS; iLoopPlayer++)
		{
			CvPlayer &kPlayer = GET_PLAYER((PlayerTypes)iLoopPlayer);
			if (kPlayer.isEverAlive() && !kPlayer.isMinorCiv())
				iCivCount++;
		}

		m_iFractionOriginalCapitalsUnderControl = iOCCount * 100 / iCivCount;
	}
}

void CvPlayer::UpdateAreaEffectUnits(bool bCheckSpecialPlotAsWell)
{
	//great generals/admirals
	m_unitsAreaEffectPositive.clear();
	//maori warrior et al
	m_unitsAreaEffectNegative.clear();
	//moai et al
	m_plotsAreaEffectPositiveFromTraits.clear();

	// Loop through our units
	int iLoop;
	CvUnit* pLoopUnit = NULL;
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if (!pLoopUnit)
			continue;
		
		if (pLoopUnit->IsGreatGeneral() || pLoopUnit->IsGreatAdmiral() || pLoopUnit->IsCityAttackSupport())
			m_unitsAreaEffectPositive.push_back( pLoopUnit->GetID() );

		if (pLoopUnit->getNearbyEnemyCombatMod() < 0)
			m_unitsAreaEffectNegative.push_back( pLoopUnit->GetID() );
	}

	// Loop through our plots
	ImprovementTypes iTraitImprovement = GetPlayerTraits()->GetCombatBonusImprovementType();
	if (bCheckSpecialPlotAsWell && iTraitImprovement!=NO_IMPROVEMENT)
	{
		for(int iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)
		{
			CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);
			if (pPlot && pPlot->getOwner()==GetID() && pPlot->getImprovementType()==iTraitImprovement )
				m_plotsAreaEffectPositiveFromTraits.push_back( iPlotLoop );
		}
	}
	//Looks for Natural Wonders
	if(bCheckSpecialPlotAsWell && GetPlayerTraits()->IsCombatBoostNearNaturalWonder())
	{
		for(int iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)
		{
			CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);
			if (pPlot && pPlot->getOwner()==GetID() && pPlot->IsNaturalWonder() )
				m_plotsAreaEffectPositiveFromTraits.push_back( iPlotLoop );
		}
	}
}

const std::vector<int>& CvPlayer::GetAreaEffectPositiveUnits() const
{
	return m_unitsAreaEffectPositive;
}

const std::vector<int>& CvPlayer::GetAreaEffectNegativeUnits() const
{
	return m_unitsAreaEffectNegative;
}

const std::vector<int>& CvPlayer::GetAreaEffectPositiveFromTraitsPlots() const
{
	return m_plotsAreaEffectPositiveFromTraits;
}

void CvPlayer::UpdateCurrentAndFutureWars()
{
	//cache the wars we have going - ignore barbarians
	m_playersWeAreAtWarWith.clear();
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_PLAYERS-1; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		if(GET_PLAYER(eLoopPlayer).isAlive() && GET_TEAM(getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
			m_playersWeAreAtWarWith.push_back( eLoopPlayer );
	}

	//see if we're not at war yet but war is coming
	m_playersAtWarWithInFuture.clear();
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		if(GET_PLAYER(eLoopPlayer).isAlive() && !GET_PLAYER(eLoopPlayer).isBarbarian() && !IsAtWarWith(eLoopPlayer) )
		{
			bool bWarMayBeComing = false;

			//do we want to start a war?
			if(GetDiplomacyAI()->IsMusteringForAttack(eLoopPlayer) || GetMilitaryAI()->GetSneakAttackOperation(eLoopPlayer) != NULL)
				bWarMayBeComing = true;

			//do they want to start a war?
			AggressivePostureTypes eMilitaryPosture = GetDiplomacyAI()->GetMilitaryAggressivePosture(eLoopPlayer);
			ThreatTypes eWarmongerThreat = GetDiplomacyAI()->GetWarmongerThreat(eLoopPlayer);
			if (eMilitaryPosture == AGGRESSIVE_POSTURE_INCREDIBLE || eWarmongerThreat == THREAT_SEVERE || eWarmongerThreat == THREAT_CRITICAL)
				bWarMayBeComing = true;

			//how is the general diplomatic climate?
			MajorCivApproachTypes eApproach = GetDiplomacyAI()->GetMajorCivApproach(eLoopPlayer, /*bHideTrueFeelings*/ false);
			MajorCivOpinionTypes eOpinion = GetDiplomacyAI()->GetMajorCivOpinion(eLoopPlayer);
			if(eApproach == MAJOR_CIV_APPROACH_HOSTILE || eApproach == MAJOR_CIV_APPROACH_WAR || 
				eApproach == MAJOR_CIV_APPROACH_AFRAID || eOpinion == MAJOR_CIV_OPINION_ENEMY)
				bWarMayBeComing = true;

			if (bWarMayBeComing)
				m_playersAtWarWithInFuture.push_back(eLoopPlayer);
		}
	}

}
#endif

//	--------------------------------------------------------------------------------
// How many Cities does this player have for policy/tech cost purposes?
int CvPlayer::GetMaxEffectiveCities(bool bIncludePuppets)
{
	int iNumCities = getNumCities();

	// Don't count puppet Cities
	int iNumPuppetCities = GetNumPuppetCities();
	iNumCities -= iNumPuppetCities;

	// Don't count cities where the player hasn't decided yet what to do with them or ones that are currently being razed
	int iNumLimboCities = 0;
	const CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity->IsIgnoreCityForHappiness() || pLoopCity->IsRazing())
		{
			iNumLimboCities++;
		}
	}
	iNumCities -= iNumLimboCities;

	if(iNumCities == 0)	// If we don't pretend the player has at least one city it screws up the math
		iNumCities = 1;

	// Update member variable
	m_iMaxEffectiveCities = (m_iMaxEffectiveCities > iNumCities) ? m_iMaxEffectiveCities : iNumCities;

	if (bIncludePuppets)
	{
		return m_iMaxEffectiveCities + iNumPuppetCities;
	}

	return m_iMaxEffectiveCities;
}
//	--------------------------------------------------------------------------------
/// How many Natural Wonders has this player found in its area?
int CvPlayer::GetNumNaturalWondersDiscoveredInArea() const
{
	return m_iNumNaturalWondersDiscoveredInArea;
}

//	--------------------------------------------------------------------------------
/// Sets how many Natural Wonders has this player found in its area
void CvPlayer::SetNumNaturalWondersDiscoveredInArea(int iValue)
{
	m_iNumNaturalWondersDiscoveredInArea = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes many Natural Wonders has this player found in its area
void CvPlayer::ChangeNumNaturalWondersDiscoveredInArea(int iChange)
{
	SetNumNaturalWondersDiscoveredInArea(GetNumNaturalWondersDiscoveredInArea() + iChange);
}

//	--------------------------------------------------------------------------------
/// Calculates how many Natural Wonders are in plots this player owns
int CvPlayer::GetNumNaturalWondersInOwnedPlots()
{
	int iValue = 0;
	CvPlotsVector& aiPlots = GetPlots();
	for(uint ui = 0; ui < aiPlots.size(); ui++)
	{
		// at the end of the plot list
		if(aiPlots[ui] == -1)
		{
			break;
		}

		CvPlot* pPlot = GC.getMap().plotByIndex(aiPlots[ui]);
		if (pPlot && pPlot->IsNaturalWonder())
		{
			iValue++;
		}
	}
	return iValue;
}

//	--------------------------------------------------------------------------------
#if defined(MOD_BALANCE_CORE)
/// How good was the last city?
void CvPlayer::SetFoundValueOfCapital(int iValue)
{
	if(m_iFoundValueOfCapital != iValue)
		m_iFoundValueOfCapital = iValue;
}

//	--------------------------------------------------------------------------------
/// How good was the last city?
int CvPlayer::GetFoundValueOfCapital() const
{
	return m_iFoundValueOfCapital;
}

bool CvPlayer::HaveGoodSettlePlot(int iAreaID) const
{
	// Check if there are good plots to settle somewhere
	int iRefValue = ((GetFoundValueOfCapital() * GC.getAI_STRATEGY_EARLY_EXPANSION_RELATIVE_TILE_QUALITY()) / 100);
	int iFirstArea, iSecondArea;
	if (iAreaID==-1)
		return GetBestSettleAreas(iRefValue, iFirstArea, iSecondArea) > 0; 
	else
	{
		GetBestSettleAreas(iRefValue, iFirstArea, iSecondArea);
		return (iFirstArea == iAreaID || iSecondArea == iAreaID);
	}
}

#endif
//	--------------------------------------------------------------------------------
/// How long ago did this guy last settle a city?
int CvPlayer::GetTurnsSinceSettledLastCity() const
{
	return m_iTurnsSinceSettledLastCity;
}

//	--------------------------------------------------------------------------------
/// How long ago did this guy last settle a city?
void CvPlayer::SetTurnsSinceSettledLastCity(int iValue)
{
	if(m_iTurnsSinceSettledLastCity != iValue)
		m_iTurnsSinceSettledLastCity = iValue;
}

//	--------------------------------------------------------------------------------
/// How long ago did this guy last settle a city?
void CvPlayer::ChangeTurnsSinceSettledLastCity(int iChange)
{
	if(iChange != 0)
		SetTurnsSinceSettledLastCity(GetTurnsSinceSettledLastCity() + iChange);
}

//	--------------------------------------------------------------------------------
/// Find best continents to settle next two cities; returns number found over minimum
int CvPlayer::GetBestSettleAreas(int iMinScore, int& iFirstArea, int& iSecondArea) const
{
	CvArea* pLoopArea;
	int iLoop;
	int iBestScore = 0;	//default score of each area is zero, so we have to be better
	int iSecondBestScore = 0;
	int iBestArea = -1;
	int iSecondBestArea = -1;
	int iNumFound = 0;
	int iScore;

	CvMap& theMap = GC.getMap();

	// Find best two scores above minimum
	for(pLoopArea = theMap.firstArea(&iLoop); pLoopArea != NULL; pLoopArea = theMap.nextArea(&iLoop))
	{
		if(!pLoopArea->isWater() && pLoopArea->getNumRevealedTiles(getTeam()) >= min(4, pLoopArea->getNumTiles()) )
		{
			iScore = pLoopArea->getTotalFoundValue();

			if(iScore >= iMinScore)
			{
				//we have to watch for overflow ...
				iScore = (iScore >> 2); 

				EconomicAIStrategyTypes eStrategyExpandToOtherContinents = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_EXPAND_TO_OTHER_CONTINENTS");
				if(eStrategyExpandToOtherContinents != NO_ECONOMICAISTRATEGY)
				{
					if (GetEconomicAI()->IsUsingStrategy(eStrategyExpandToOtherContinents))
					{
						if (getCapitalCity() && pLoopArea->GetID() != getCapitalCity()->getArea())
						{
							iScore *= 2;
						}
					}
				}

				int iPlayers = 0;
				for(int iPlayer = 0; iPlayer < MAX_PLAYERS; ++iPlayer)
				{
					CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iPlayer);
					if((kLoopPlayer.GetID() != -1) && !kLoopPlayer.isMinorCiv())
					{
						if(pLoopArea->getCitiesPerPlayer(kLoopPlayer.GetID()) > 0)
						{
							iPlayers += pLoopArea->getCitiesPerPlayer(kLoopPlayer.GetID());
						}
					}
				}
				iScore /= max(1, iPlayers);

				if(iScore > iBestScore)
				{
					// Already have a best area?  If so demote to 2nd
					if(iBestScore > iMinScore)
					{
						iSecondBestScore = iBestScore;
						iSecondBestArea = iBestArea;
					}
					iBestArea = pLoopArea->GetID();
					iBestScore = iScore;
				}

				else if(iScore > iSecondBestScore)
				{
					iSecondBestArea = pLoopArea->GetID();
					iSecondBestScore = iScore;
				}
			}
		}
	}

	// Return data
	iFirstArea = iBestArea;
	iSecondArea = iSecondBestArea;

	if(iSecondArea != -1)
	{
		iNumFound = 2;
	}
	else if(iFirstArea != -1)
	{
		iNumFound = 1;
	}
	return iNumFound;
}

//	--------------------------------------------------------------------------------
/// Find the best spot in the entire world for this unit to settle
ostream& operator<<(ostream& os, const CvPlot* pPlot)
{
	if (pPlot)
	    os << pPlot->getX() << "," << pPlot->getY() << "," << pPlot->getTerrainType() << "," << pPlot->getPlotType() << "," \
			<< pPlot->getFeatureType() << "," << pPlot->getOwner() << "," << pPlot->getArea();
    return os;
}

CvPlot* CvPlayer::GetBestSettlePlot(const CvUnit* pUnit, int iTargetArea, bool& bIsSafe, CvAIOperation* pOpToIgnore, bool bForceLogging) const
{
	std::vector<SPlotWithScore> vSettlePlots;

	//play it safe
	bIsSafe = false;

	//--------
	bool bLogging = (GC.getLogging() && GC.getAILogging()) || bForceLogging; 
	std::stringstream dump;
	int iDanger=0, iFertility=0;

#if defined(MOD_BALANCE_CORE_MILITARY_LOGGING)
	bLogging &= MOD_BALANCE_CORE_MILITARY_LOGGING;
#endif
	//--------

	PlayerTypes eOwner = pUnit ? pUnit->getOwner() : GetID();
	TeamTypes eTeam = pUnit ? pUnit->getTeam() : getTeam();

	int iBestArea, iSecondBestArea;
	//start with a predefined base value
	int iBestFoundValue = GC.getAI_STRATEGY_MINIMUM_SETTLE_FERTILITY();

	int iNumSettleAreas = GET_PLAYER(GetID()).GetBestSettleAreas(iBestFoundValue, iBestArea, iSecondBestArea);
	if(iNumSettleAreas == 0)
	{
		return NULL;
	}

	if(pUnit)
	{
		int iTurnsWaiting = (GC.getGame().getGameTurn() - pUnit->getGameTurnCreated());
		iBestFoundValue -= (iTurnsWaiting * 200);
	}

	//prefer settling close in the beginning
	int iTimeOffset = (30 * GC.getGame().getGameTurn()) / max(500, GC.getGame().getMaxTurns());

	//basic search area around existing cities. value at eval distance is scaled to zero.
	int iEvalDistance = 12 + iTimeOffset;
	if(IsCramped())
		iEvalDistance += iTimeOffset;

	//if we want to go to other continents, we need a very large search radius
	EconomicAIStrategyTypes eStrategyExpandToOtherContinents = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_EXPAND_TO_OTHER_CONTINENTS");
	EconomicAIStrategyTypes eStrategyReallyExpandToOtherContinents = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_REALLY_EXPAND_TO_OTHER_CONTINENTS");
	bool bWantOffshore = GetEconomicAI()->IsUsingStrategy(eStrategyReallyExpandToOtherContinents) && GetEconomicAI()->IsUsingStrategy(eStrategyExpandToOtherContinents);

	CvMap& kMap = GC.getMap();
	int iNumPlots = kMap.numPlots();
	for(int iPlotLoop = 0; iPlotLoop < iNumPlots; iPlotLoop++)
	{
		CvPlot* pPlot = kMap.plotByIndexUnchecked(iPlotLoop);

		if(!pPlot)
		{
			continue;
		}

		if (bLogging)
		{
			iDanger = GetPlotDanger(*pPlot);
			iFertility = GC.getGame().GetSettlerSiteEvaluator()->PlotFertilityValue(pPlot,true);
		}

		if(!pPlot->isRevealed(getTeam()))
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",0," << iDanger << "," << iFertility << ",-1" << ",0" << std::endl;
			//--------------
			continue;
		}

		if(iTargetArea != -1 && pPlot->getArea() != iTargetArea)
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",1," << iDanger << "," << iFertility << ",-1" << ",-6" << std::endl;
			//--------------
			continue;
		}

		if(pPlot->getOwner() != NO_PLAYER && pPlot->getOwner() != eOwner)
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",1," << iDanger << "," << iFertility << ",-1" << ",-2" << std::endl;
			//--------------
			continue;
		}

		if(pPlot->IsAdjacentOwnedByOtherTeam(eTeam))
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",1," << iDanger << "," << iFertility << ",-1" << ",-2" << std::endl;
			//--------------
			continue;
		}

		for (std::vector<PlayerTypes>::const_iterator it = m_playersWeAreAtWarWith.begin(); it != m_playersWeAreAtWarWith.end(); ++it)
		{
			if(!GET_PLAYER(*it).isBarbarian())
			{
				if(pPlot->IsHomeFrontForPlayer(*it))
				{
					//--------------
					if (bLogging) 
					dump << pPlot << ",1," << iDanger << "," << iFertility << ",-1" << ",-2" << std::endl;
					//--------------
					continue;
				}
			}
		}

		if(pUnit && (!pUnit->canFound(pPlot) || !pUnit->canMoveInto(*pPlot)))
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",1," << iDanger << "," << iFertility << ",-1" << ",-1" << std::endl;
			//--------------
			continue;
		}

		if (IsPlotTargetedForCity(pPlot,pOpToIgnore))
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",1," << iDanger << "," << iFertility << ",-1" << ",-3" << std::endl;
			//--------------
			continue;
		}

		if(pUnit && pPlot->getArea() != pUnit->getArea() && !GET_TEAM(GET_PLAYER(GetID()).getTeam()).canEmbark())
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",1," << iDanger << "," << iFertility << ",-1" << ",-4" << std::endl;
			//--------------
			continue;
		}

		//check for new continent
		const CvArea* pArea = GC.getMap().getArea(pPlot->getArea());
		const CvCity* pCapital = getCapitalCity();
		bool bNewContinent = (pArea && pArea->getCitiesPerPlayer(GetID()) == 0);
		bool bOffshore = (pArea && pCapital && pArea->GetID() != pCapital->plot()->getArea());

		//take into account distance from existing cities
		int iUnitDistance = pUnit ? plotDistance(pUnit->getX(),pUnit->getY(),pPlot->getX(),pPlot->getY()) : INT_MAX;
		int iRelevantDistance = min(iUnitDistance,GetCityDistance(pPlot));
		int iScale = MapToPercent( iRelevantDistance, iEvalDistance, GC.getSETTLER_DISTANCE_DROPOFF_MODIFIER() );

		//on a new continent we want to settle along the coast
		if (bNewContinent && !pPlot->isCoastalLand())
			iScale = 1;

		//if we want offshore expansion, distance doesn't matter, use a flat scale
		if (bWantOffshore)
			iScale = bOffshore ? 100 : 1;

		if (iScale==0)
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",1," << iDanger << "," << iFertility << ",0" << ",-5" << std::endl;
			//--------------
			continue;
		}

		//finally no more obstacles
		int iValue = 0;
		if (bLogging) 
		{
			CvString strDebug;
			iValue = GC.getGame().GetSettlerSiteEvaluator()->PlotFoundValue(pPlot, this, NO_YIELD, bNewContinent, &strDebug);
			//--------------
			dump << pPlot << ",1," << iDanger << "," << iFertility << "," << iScale << "," << iValue << "," << strDebug.c_str() << std::endl;
			//--------------
		}
		else
		{
			//with caching
			iValue = pPlot->getFoundValue(eOwner);
		}

		//factor in the distance
		iValue = (iValue*iScale)/100;

		if (iValue>0)
			vSettlePlots.push_back( SPlotWithScore(pPlot,iValue) );
	}

#if defined(MOD_BALANCE_CORE_MILITARY_LOGGING)
	if (bLogging) 
	{
		std::stringstream ss;
		ss << "CitySites_" << getCivilizationAdjective() << "_" << std::setfill('0') << std::setw(3) << GC.getGame().getGameTurn() << ".txt";
		FILogFile* pLog=LOGFILEMGR.GetLog( ss.str().c_str(), FILogFile::kDontTimeStamp );
		pLog->Msg( "#x,y,terrain,plotype,feature,owner,area,revealed,danger,fertility,distancescale,value,comments\n" );
		pLog->Msg( dump.str().c_str() );
		pLog->Close();
	}
#endif

	if (vSettlePlots.empty())
		return 0;

	//order by increasing score
	std::stable_sort( vSettlePlots.begin(), vSettlePlots.end() );
	//delete all but the best
	SPlotWithScore ref = vSettlePlots.back();
	ref.score = int(ref.score * 0.8f);
	std::vector<SPlotWithScore>::iterator cutoff = std::upper_bound( vSettlePlots.begin(), vSettlePlots.end(), ref );
	//reverse so best comes first
	vSettlePlots.erase( vSettlePlots.begin(), cutoff );
	std::reverse( vSettlePlots.begin(), vSettlePlots.end() );

	//AI cheating here ... check if a settler would likely be captured
	std::vector<CvPlot*> vBadPlots;
	for(int iI = 0; iI < iNumPlots; iI++)
	{
		CvPlot *pPlot = kMap.plotByIndexUnchecked(iI);

		if(iTargetArea!=-1 && pPlot->getArea()!=iTargetArea)
			continue;

		if(pPlot->getImprovementType()==(ImprovementTypes)GC.getBARBARIAN_CAMP_IMPROVEMENT())
		{
			vBadPlots.push_back(pPlot);
			continue;
		}

		if(pPlot->getNumUnits() > 0)
		{
			IDInfo* pUnitNode = pPlot->headUnitNode();
			while(pUnitNode != NULL)
			{
				CvUnit* pLoopUnit = ::getUnit(*pUnitNode);
				pUnitNode = pPlot->nextUnitNode(pUnitNode);

				if(pLoopUnit && pLoopUnit->IsCombatUnit() && pLoopUnit->isEnemy(getTeam()))
				{
					vBadPlots.push_back(pPlot);
					break;
				}
			}
		}
	}

	//by default we return the best plot whether it's safe or not
	//however, if we find a safe plot which is only marginally worse, return that one
	CvPlot* pBestFoundPlot = NULL;
	bool pBestPlotSafe = false;

	for (size_t i=0; i<vSettlePlots.size(); i++)
	{
		bool isDangerous = false;

		//if it's too far from our existing cities, it's dangerous
		int iDistance = GetCityDistance(pUnit->plot());
		if (iDistance>8)
			isDangerous = true;
		else
		{
			//check if it's too close to an enemy
			for (size_t j=0; j<vBadPlots.size(); j++)
			{
				if (vSettlePlots[i].pPlot->getArea() != vBadPlots[j]->getArea())
					continue;

				int iDistanceToDanger = plotDistance(*(vSettlePlots[i].pPlot),*(vBadPlots[j]));
				int iDistanceToSettler = plotDistance(*(vSettlePlots[i].pPlot),*(pUnit->plot()));
				if (iDistanceToDanger<5 && iDistanceToSettler>1)
				{
					isDangerous = true;
					break;
				}
			}
		}

		//could be close but take many turns to get there ...
		if (!isDangerous)
		{
			CvPlot* pMusterPlot = GetClosestCity(pUnit->plot())->plot();
			CvPlot* pTestPlot = vSettlePlots[i].pPlot;

			//if the muster plot is more than 10 turns away it's unsafe by definition
			SPathFinderUserData data(pUnit,0,10);
			if (! GC.GetPathFinder().DoesPathExist(pMusterPlot,pTestPlot,data) )
				isDangerous = true;
		}

		if (pBestFoundPlot==NULL)
		{
			//first iteration
			pBestFoundPlot = vSettlePlots[i].pPlot;
			pBestPlotSafe = !isDangerous;
		}
		else
		{
			//later iteration
			if (!isDangerous)
			{
				//hooray! we found an alternative
				pBestFoundPlot = vSettlePlots[i].pPlot;
				pBestPlotSafe = true;
				break;
			}
		}
	}

	bIsSafe = pBestPlotSafe;
	return pBestFoundPlot;
}

//	--------------------------------------------------------------------------------
/// How many Wonders has this Player constructed?
int CvPlayer::GetNumWonders() const
{
	return m_iNumWonders;
}

//	--------------------------------------------------------------------------------
/// Changes how many Wonders this Player has constructed
void CvPlayer::ChangeNumWonders(int iValue)
{
	if(iValue != 0)
	{
		m_iNumWonders += iValue;
	}
}

//	--------------------------------------------------------------------------------
/// How many Policies has this Player constructed?
int CvPlayer::GetNumPolicies() const
{
	return m_iNumPolicies;
}

//	--------------------------------------------------------------------------------
/// Changes how many Policies this Player has constructed
void CvPlayer::ChangeNumPolicies(int iValue)
{
	if(iValue != 0)
	{
		m_iNumPolicies += iValue;
	}
}

//	--------------------------------------------------------------------------------
/// How many GreatPeople has this Player constructed?
int CvPlayer::GetNumGreatPeople() const
{
	return m_iNumGreatPeople;
}

//	--------------------------------------------------------------------------------
/// Changes how many GreatPeople this Player has constructed
void CvPlayer::ChangeNumGreatPeople(int iValue)
{
	if(iValue != 0)
	{
		m_iNumGreatPeople += iValue;
	}
}

//	--------------------------------------------------------------------------------
/// Special ability where city-states gift great people
void CvPlayer::DoAdoptedGreatPersonCityStatePolicy()
{
	// Loop through all minors and if they're allies, seed the GP counter
	PlayerTypes eMinor;
	for(int iPlayerLoop = MAX_MAJOR_CIVS; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		eMinor = (PlayerTypes) iPlayerLoop;

		if(GET_PLAYER(eMinor).isEverAlive())
		{
			if(GET_PLAYER(eMinor).GetMinorCivAI()->GetAlly() == GetID())
			{
				DoSeedGreatPeopleSpawnCounter();

				break;
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Special ability where city-states gift great people
bool CvPlayer::IsAlliesGreatPersonBiasApplied() const
{
	return m_bAlliesGreatPersonBiasApplied;
}

//	--------------------------------------------------------------------------------
/// Special ability where city-states gift great people
void CvPlayer::SetAlliesGreatPersonBiasApplied(bool bValue)
{
	if(m_bAlliesGreatPersonBiasApplied != bValue)
	{
		m_bAlliesGreatPersonBiasApplied = bValue;
	}
}

//	--------------------------------------------------------------------------------
/// Has this player picked up a Religion yet
bool CvPlayer::IsHasAdoptedStateReligion() const
{
	return m_bHasAdoptedStateReligion;
}

//	--------------------------------------------------------------------------------
/// Sets this player picked up a Religion yet
void CvPlayer::SetHasAdoptedStateReligion(bool bValue)
{
	if(m_bHasAdoptedStateReligion != bValue)
	{
		m_bHasAdoptedStateReligion = bValue;
	}
}

//	--------------------------------------------------------------------------------
/// Number of Cities in the empire with our State Religion
int CvPlayer::GetNumCitiesWithStateReligion()
{
	int iNumCitiesWithStateReligion = 0;

	int iLoopCity;
	CvCity* pLoopCity = NULL;
	// Look at all of our Cities to see if they have our Religion
	for(pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity))
	{
		if(pLoopCity->GetPlayersReligion() == GetID())
		{
			iNumCitiesWithStateReligion++;
		}
	}

	return iNumCitiesWithStateReligion;
}

//	--------------------------------------------------------------------------------
/// Where was this player's Religion adopted
CvCity* CvPlayer::GetHolyCity()
{
	return getCity(m_iHolyCityID);
}

//	--------------------------------------------------------------------------------
/// Sets where this player's Religion adopted
void CvPlayer::SetHolyCity(int iCityID)
{
	// This should only be set once under normal circumstances
	CvAssert(m_iHolyCityID == -1);

	m_iHolyCityID = iCityID;
}

//	--------------------------------------------------------------------------------
PromotionTypes CvPlayer::GetEmbarkationPromotion() const
{
	if(GET_TEAM(getTeam()).canDefensiveEmbark())
	{
		return (PromotionTypes)GC.getPROMOTION_DEFENSIVE_EMBARKATION();
	}

	if(m_pTraits)
	{
		if(m_pTraits->IsEmbarkedAllWater())
		{
			return (PromotionTypes)GC.getPROMOTION_ALLWATER_EMBARKATION();
		}
	}

	return (PromotionTypes)GC.getPROMOTION_EMBARKATION();
}

#if defined(MOD_PROMOTIONS_DEEP_WATER_EMBARKATION)
//	--------------------------------------------------------------------------------
PromotionTypes CvPlayer::GetDeepWaterEmbarkationPromotion() const
{
	if (MOD_PROMOTIONS_DEEP_WATER_EMBARKATION) {
		if(GET_TEAM(getTeam()).canDefensiveEmbark())
		{
			return (PromotionTypes)GC.getPROMOTION_DEFENSIVE_DEEPWATER_EMBARKATION();
		}

		return (PromotionTypes)GC.getPROMOTION_DEEPWATER_EMBARKATION();
	} else {
		return GetEmbarkationPromotion();
	}
}
#endif

//	--------------------------------------------------------------------------------
/// Provide Notification about someone adopting a new Religon
void CvPlayer::DoAnnounceReligionAdoption()
{
	CvCity* pHolyCity = GetHolyCity();

	for(int iI = 0; iI < MAX_PLAYERS; iI++)
	{
		CvPlayerAI& thisPlayer = GET_PLAYER((PlayerTypes)iI);
		if(thisPlayer.isHuman() && thisPlayer.isAlive() && thisPlayer.GetNotifications())
		{
			int iX = -1;
			int iY = -1;

			Localization::String localizedText;

			// Active Player
			if(GC.getGame().getActivePlayer() == GetID())
			{
				iX = pHolyCity->getX();
				iY = pHolyCity->getY();
				localizedText = Localization::Lookup("TXT_KEY_MISC_RELIGION_ADOPTED_YOU");
				localizedText << pHolyCity->getNameKey() << GetStateReligionKey();
			}
			// Met Player
			else if(GET_TEAM(GC.getGame().getActiveTeam()).isHasMet(thisPlayer.getTeam()))
			{
				localizedText = Localization::Lookup("TXT_KEY_MISC_RELIGION_ADOPTED_ANOTHER_PLAYER");
				localizedText << GET_PLAYER(pHolyCity->getOwner()).getNameKey() << GetStateReligionKey();

				// We've seen this player's City
				if(pHolyCity->isRevealed(thisPlayer.getTeam(), false))
				{
					iX = pHolyCity->getX();
					iY = pHolyCity->getY();
				}
			}
			// Unmet Player
			else
			{
				localizedText = Localization::Lookup("TXT_KEY_MISC_RELIGION_ADOPTED_UNKNOWN");
			}

#if defined(MOD_API_EXTENSIONS)
			thisPlayer.GetNotifications()->Add(NOTIFICATION_RELIGION_RACE, localizedText.toUTF8(), localizedText.toUTF8(), iX, iY, GetReligions()->GetReligionCreatedByPlayer(), -1);
#else
			thisPlayer.GetNotifications()->Add(NOTIFICATION_RELIGION_RACE, localizedText.toUTF8(), localizedText.toUTF8(), iX, iY, -1);
#endif
		}
	}
}

bool CvPlayer::IsAllowedToTradeWith(PlayerTypes eOtherPlayer)
{
	if (GC.getGame().GetGameLeagues()->IsTradeEmbargoed(GetID(), eOtherPlayer) && eOtherPlayer != m_eID)
	{
		return false;
	}

#if defined(MOD_DIPLOMACY_CITYSTATES_RESOLUTIONS)
	if (MOD_DIPLOMACY_CITYSTATES_RESOLUTIONS && GC.getGame().GetGameLeagues()->IsIdeologyEmbargoed(GetID(), eOtherPlayer) && eOtherPlayer != m_eID)
	{
		return false;
	}
#endif
	return true;
}

bool CvPlayer::CanCrossOcean() const
{
	return GET_TEAM(getTeam()).canEmbarkAllWaterPassage() || GetPlayerTraits()->IsEmbarkedAllWater();
}
bool CvPlayer::CanCrossMountain() const
{
	return GetPlayerTraits()->IsAbleToCrossMountainsWithGreatGeneral() || GetPlayerTraits()->IsMountainPass();
}
bool CvPlayer::CanCrossIce() const
{
	return GetPlayerTraits()->IsAbleToCrossIce();
}

//////////////////////////////////////////////////////////////////////////
// Tutorial Stuff...
//////////////////////////////////////////////////////////////////////////

//	--------------------------------------------------------------------------------
bool CvPlayer::GetEverPoppedGoody()
{
	return m_bEverPoppedGoody;
}

//	--------------------------------------------------------------------------------
CvPlot* CvPlayer::GetClosestGoodyPlot(bool bStopAfterFindingFirst)
{
#if defined(MOD_CORE_ALTERNATIVE_EXPLORE_SCORE)
	CvPlot* pResultPlot = NULL;
	int iShortestPath = INT_MAX;

	// cycle through goodies
	for(int i = 0; i < GC.getMap().numPlots(); i++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(i);
#else
	FFastVector<int> aiGoodyPlots = GetEconomicAI()->GetGoodyHutPlots();

	CvPlot* pResultPlot = NULL;
	int iShortestPath = INT_MAX;

	// cycle through goodies
	for(uint uiGoodyIndex = 0; uiGoodyIndex < aiGoodyPlots.size(); uiGoodyIndex++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndex(aiGoodyPlots[uiGoodyIndex]);
#endif
		if(!pPlot || !pPlot->isGoody(getTeam()))
		{
			continue;
		}

		// cycle through units
		int iUnitLoop;
		CvUnit* pLoopUnit = NULL;

		// Setup m_units
		for(pLoopUnit = firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iUnitLoop))
		{
			if(!pLoopUnit)
			{
				continue;
			}

			if(pPlot->getArea() != pLoopUnit->getArea() && !pLoopUnit->CanEverEmbark())
			{
				continue;
			}

			int iReturnValue = INT_MAX;
			bool bResult = pLoopUnit->GeneratePath(pPlot, CvUnit::MOVEFLAG_IGNORE_DANGER, iShortestPath, &iReturnValue);

			if(bResult)
			{
				if(iReturnValue < iShortestPath)
				{
					pResultPlot = pPlot;
					iShortestPath = iReturnValue;
				}

				if(bStopAfterFindingFirst)
				{
					return pPlot;
				}
			}
		}
	}

	return pResultPlot;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::GetPlotHasOrder(CvPlot* pPlot)
{
	if(!pPlot)
	{
		return false;
	}

	int iLoopUnit;
	for(CvUnit* pLoopUnit = firstUnit(&iLoopUnit); pLoopUnit; pLoopUnit = nextUnit(&iLoopUnit))
	{
		CvPlot* pMissionPlot = pLoopUnit->GetMissionAIPlot();
		if(NULL != pMissionPlot && pMissionPlot->getX() == pPlot->getX() && pMissionPlot->getY() == pPlot->getY())
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::GetAnyUnitHasOrderToGoody()
{
#if defined(MOD_CORE_ALTERNATIVE_EXPLORE_SCORE)
	// cycle through goodies
	for(int i = 0; i < GC.getMap().numPlots(); i++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(i);
#else

	FFastVector<int> aiGoodyPlots = GetEconomicAI()->GetGoodyHutPlots();

	// cycle through goodies
	for(uint uiGoodyIndex = 0; uiGoodyIndex < aiGoodyPlots.size(); uiGoodyIndex++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndex(aiGoodyPlots[uiGoodyIndex]);
#endif
		if(!pPlot)
		{
			continue;
		}

		if(!pPlot->isGoody(getTeam()))
		{
			continue;
		}

		if(GetPlotHasOrder(pPlot))
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::GetEverTrainedBuilder()
{
	return m_bEverTrainedBuilder;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumFreeTechs() const
{
	return m_iFreeTechCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumFreeTechs(int iValue)
{
	m_iFreeTechCount = iValue;
	if(GetID() == GC.getGame().getActivePlayer())
	{
		GC.GetEngineUserInterface()->setDirty(ResearchButtons_DIRTY_BIT, true);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetMedianTechPercentage() const
{
	return m_iMedianTechPercentage;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMedianTechPercentage(int iValue)
{
	m_iMedianTechPercentage += iValue;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumFreePolicies() const
{
	return m_iNumFreePolicies;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumFreePolicies(int iValue)
{
	// Increase count of free Policies we've ever had
	int iDifference = iValue - m_iNumFreePolicies;
	if(iDifference > 0)
	{
		ChangeNumFreePoliciesEver(iDifference);
	}

	m_iNumFreePolicies = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumFreePolicies(int iChange)
{
	SetNumFreePolicies(GetNumFreePolicies() + iChange);

	if(iChange > 0 && getNumCities() > 0)
	{
		CvNotifications* pNotifications = GetNotifications();
		if(pNotifications)
		{
			CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_FREE_POLICY");
			CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_FREE_POLICY_SUMMARY");
			pNotifications->Add(NOTIFICATION_FREE_POLICY, strBuffer, strSummary, -1, -1, -1);
		}

	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumFreeTenets() const
{
	return m_iNumFreeTenets;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumFreeTenets(int iValue, bool bCountAsFreePolicies)
{
	// Increase count of free Policies we've ever had
	int iDifference = iValue - m_iNumFreeTenets;
	if (bCountAsFreePolicies && iDifference > 0)
	{
		ChangeNumFreePoliciesEver(iDifference);
	}

	m_iNumFreeTenets = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumFreeTenets(int iChange, bool bCountAsFreePolicies)
{
	SetNumFreeTenets(GetNumFreeTenets() + iChange, bCountAsFreePolicies);

	if(iChange > 0 && getNumCities() > 0)
	{
		CvNotifications* pNotifications = GetNotifications();
		if(pNotifications)
		{
			CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_FREE_POLICY");
			CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_FREE_POLICY_SUMMARY");
			pNotifications->Add(NOTIFICATION_FREE_POLICY, strBuffer, strSummary, -1, -1, -1);
		}

	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumFreeGreatPeople() const
{
	return m_iNumFreeGreatPeople;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumFreeGreatPeople(int iValue)
{
	m_iNumFreeGreatPeople = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumFreeGreatPeople(int iChange)
{
	m_iNumFreeGreatPeople = GetNumFreeGreatPeople() + iChange;
	if(iChange > 0)
	{
		if(isHuman())
		{
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				CvString strBuffer = GetLocalizedText("TXT_KEY_CHOOSE_FREE_GREAT_PERSON");
				CvString strSummary = GetLocalizedText("TXT_KEY_CHOOSE_FREE_GREAT_PERSON_TT");
				pNotifications->Add(NOTIFICATION_FREE_GREAT_PERSON, strSummary.c_str(), strBuffer.c_str(), -1, -1, -1);
			}
		}
		else
		{
			for(int iI = 0; iI < iChange; iI++)
			{
				AI_chooseFreeGreatPerson();
			}
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumMayaBoosts() const
{
	return m_iNumMayaBoosts;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumMayaBoosts(int iValue)
{
	m_iNumMayaBoosts = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumMayaBoosts(int iChange)
{
	m_iNumMayaBoosts = GetNumMayaBoosts() + iChange;
	if(iChange > 0)
	{
		if(isHuman())
		{
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_MAYA_LONG_COUNT");
				CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_MAYA_LONG_COUNT_TT");
				pNotifications->Add(NOTIFICATION_MAYA_LONG_COUNT, strSummary.c_str(), strBuffer.c_str(), -1, -1, -1);
			}
		}
		else
		{
			for(int iI = 0; iI < iChange; iI++)
			{
				GetPlayerTraits()->ChooseMayaBoost();
			}
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumFaithGreatPeople() const
{
	return m_iNumFaithGreatPeople;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumFaithGreatPeople(int iValue)
{
	m_iNumFaithGreatPeople = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumFaithGreatPeople(int iChange)
{
	m_iNumFaithGreatPeople = GetNumFaithGreatPeople() + iChange;
	if(iChange > 0)
	{
		if(isHuman())
		{
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_FAITH_GREAT_PERSON");
				CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_FAITH_GREAT_PERSON_TT");
				pNotifications->Add(NOTIFICATION_FAITH_GREAT_PERSON, strSummary.c_str(), strBuffer.c_str(), -1, -1, -1);
			}
		}
		else
		{
			for(int iI = 0; iI < iChange; iI++)
			{
				AI_chooseFreeGreatPerson();
			}
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetNumArchaeologyChoices() const
{
	return m_iNumArchaeologyChoices;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumArchaeologyChoices(int iValue)
{
	m_iNumArchaeologyChoices = iValue;
}

//	--------------------------------------------------------------------------------
FaithPurchaseTypes CvPlayer::GetFaithPurchaseType() const
{
	return m_eFaithPurchaseType;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetFaithPurchaseType(FaithPurchaseTypes eType)
{
	m_eFaithPurchaseType = eType;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetFaithPurchaseIndex() const
{
	return m_iFaithPurchaseIndex;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetFaithPurchaseIndex(int iIndex)
{
	m_iFaithPurchaseIndex = iIndex;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumFreePoliciesEver() const
{
	return m_iNumFreePoliciesEver;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumFreePoliciesEver(int iValue)
{
	m_iNumFreePoliciesEver = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumFreePoliciesEver(int iChange)
{
	SetNumFreePoliciesEver(GetNumFreePoliciesEver() + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetLastSliceMoved() const
{
	return m_iLastSliceMoved;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetLastSliceMoved(int iValue)
{
	m_iLastSliceMoved = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetEverConqueredBy(PlayerTypes ePlayer, bool bValue)
{
	if(bValue)
	{
		m_bfEverConqueredBy.SetBit(ePlayer);
	}
	else
	{
		m_bfEverConqueredBy.ClearBit(ePlayer);
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsEverConqueredBy(PlayerTypes ePlayer)
{
	return m_bfEverConqueredBy.GetBit(ePlayer);
}

//	------------------------------------------------------------------------------------------------
const FAutoArchive& CvPlayer::getSyncArchive() const
{
	return m_syncArchive;
}

//	--------------------------------------------------------------------------------
FAutoArchive& CvPlayer::getSyncArchive()
{
	return m_syncArchive;
}

//	-----------------------------------------------------------------------------------------------
bool CvPlayer::isLocalPlayer() const
{
	return (GC.getGame().getActivePlayer() == GetID());
}

//	-----------------------------------------------------------------------------------------------
void CvPlayer::disconnected()
{
	bool isMultiplayer = GC.getGame().isGameMultiPlayer();
	if(isMultiplayer && isHuman() && !isLocalPlayer())
	{
			//log message for debugging the occasional lack of disconnect notification when Steam p2p connections timeout. - bolson 1/10/13
			FILogFile* logFile = LOGFILEMGR.GetLog("net_message_debug.log", 0);
			if(logFile)
			{
				logFile->DebugMsg("Attempted to post notification for player disconnect event.  Player(%i)", GetID());
			}

			CvNotifications* pNotifications = GET_PLAYER(GC.getGame().getActivePlayer()).GetNotifications();
			if(pNotifications){
				if(gDLL->IsPlayerKicked(GetID())){
					Localization::String kickedMsg = Localization::Lookup("TXT_KEY_PLAYER_KICKED");
					kickedMsg << getNameKey();
					pNotifications->Add(NOTIFICATION_PLAYER_KICKED, kickedMsg.toUTF8(), kickedMsg.toUTF8(), -1, -1, GetID());
				}
				else{
					Localization::String disconnectString = Localization::Lookup("TXT_KEY_PLAYER_DISCONNECTED");
					disconnectString << getNameKey();

					if(CvPreGame::isPitBoss()){
						disconnectString = Localization::Lookup("TXT_KEY_PLAYER_DISCONNECTED_PITBOSS");
						disconnectString << getNameKey();	
					}

					pNotifications->Add(NOTIFICATION_PLAYER_DISCONNECTED, disconnectString.toUTF8(), disconnectString.toUTF8(), -1, -1, GetID());
				}
			}

		if(!isObserver() && (!CvPreGame::isPitBoss() || gDLL->IsPlayerKicked(GetID())))
		{
			// JAR : First pass, automatically fall back to CPU so the
			// game can continue. Todo : add popup on host asking whether
			// the AI should take over or everyone should wait for the
			// player to reconnect
			CvPreGame::setSlotStatus(GetID(), SS_COMPUTER);
			CvPreGame::VerifyHandicap(GetID());	//Changing the handicap because we're switching to AI

			// Load leaderhead for this new AI player
			gDLL->NotifySpecificAILeaderInGame(GetID());
			
			if(!GC.getGame().isOption(GAMEOPTION_DYNAMIC_TURNS) && GC.getGame().isOption(GAMEOPTION_SIMULTANEOUS_TURNS))
			{//When in fully simultaneous turn mode, having a player disconnect might trigger the automove phase for all human players.
				checkRunAutoMovesForEveryone();
			}
		}
	}
}
//	-----------------------------------------------------------------------------------------------
void CvPlayer::reconnected()
{
	//Preserve observer status for the connecting human player's slot.
	if(CvPreGame::slotStatus(GetID()) != SS_OBSERVER){
		CvPreGame::setSlotStatus(GetID(), SS_TAKEN);
	}

	CvPreGame::VerifyHandicap(GetID()); //verify the handicap because we might have replaced an ai.

	CvGame& kGame = GC.getGame();
	bool isMultiplayer = kGame.isGameMultiPlayer();

	if(isMultiplayer && !isLocalPlayer())
	{
		FAutoArchive& archive = getSyncArchive();
		archive.clearDelta();

		Localization::String connectString = Localization::Lookup("TXT_KEY_PLAYER_CONNECTING");
		connectString << getNameKey();

		CvNotifications* pNotifications = GET_PLAYER(kGame.getActivePlayer()).GetNotifications();
		if(pNotifications)
		{
			pNotifications->Add(NOTIFICATION_PLAYER_CONNECTING, connectString.toUTF8(), connectString.toUTF8(), -1, -1, GetID());
		}
	}
}
//	-----------------------------------------------------------------------------------------------
bool CvPlayer::hasBusyUnitUpdatesRemaining() const
{
	return m_endTurnBusyUnitUpdatesLeft > 0;
}

//	-----------------------------------------------------------------------------------------------
void CvPlayer::setBusyUnitUpdatesRemaining(int iUpdateCount)
{
	m_endTurnBusyUnitUpdatesLeft = iUpdateCount;
}

//	-----------------------------------------------------------------------------------------------
const char* const CvPlayer::getNickName() const
{
	return CvPreGame::nicknameDisplayed(GetID()).c_str();
}

//	-----------------------------------------------------------------------------------------------
bool CvPlayer::hasUnitsThatNeedAIUpdate() const
{
	const CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(!pLoopUnit->TurnProcessed() &&
		        (pLoopUnit->IsAutomated() &&
		         pLoopUnit->AI_getUnitAIType() != UNITAI_UNKNOWN &&
		         pLoopUnit->canMove()))
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
std::string CvPlayer::debugDump(const FAutoVariableBase&) const
{
	std::string result = "Game Turn : ";
	char gameTurnBuffer[8] = {0};
	int gameTurn = GC.getGame().getGameTurn();
	sprintf_s(gameTurnBuffer, "%d\0", gameTurn);
	result += gameTurnBuffer;
	return result;
}

//	--------------------------------------------------------------------------------
std::string CvPlayer::stackTraceRemark(const FAutoVariableBase& var) const
{
	std::string result = debugDump(var);
	if(&var == &m_aOptions)
	{//detail output for player options array.
		result += "\nPlayer Options:";
		for (PlayerOptionsVector::const_iterator itr = m_aOptions.begin(); itr != m_aOptions.end(); ++itr )
		{
			CvString curOptionsStr;
			curOptionsStr.Format("\n%u, %d", itr->first, itr->second);
			result += curOptionsStr;
		}
		result += "\n";
	}
	return result;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::hasTurnTimerExpired()
{//Indicates if this player's turn time has elapsed.
	return GC.getGame().hasTurnTimerExpired(GetID());
}

//	--------------------------------------------------------------------------------
void CvPlayer::doArmySize()
{
#if !defined(NO_ACHIEVEMENTS)
	int numUnits = 0;
	int32 nLargestArmy = 0;
	int iI;

	for(iI = 0; iI < NUM_UNITAI_TYPES; iI++)
	{
		if((UnitAITypes)iI == UNITAI_ARTIST ||(UnitAITypes)iI == UNITAI_ENGINEER || (UnitAITypes)iI == UNITAI_UNKNOWN ||
		        (UnitAITypes)iI == UNITAI_GENERAL || (UnitAITypes)iI == UNITAI_SETTLE || (UnitAITypes)iI == UNITAI_WORKER ||
		        (UnitAITypes)iI == UNITAI_SCIENTIST || (UnitAITypes)iI == UNITAI_MERCHANT || (UnitAITypes)iI == UNITAI_WORKER_SEA ||
		        (UnitAITypes)iI == UNITAI_SPACESHIP_PART || (UnitAITypes)iI == UNITAI_TREASURE || (UnitAITypes)iI == UNITAI_PROPHET ||
		        (UnitAITypes)iI == UNITAI_MISSIONARY || (UnitAITypes)iI == UNITAI_INQUISITOR || (UnitAITypes)iI == UNITAI_ADMIRAL ||
#if defined(MOD_DIPLOMACY_CITYSTATES) 
				(MOD_DIPLOMACY_CITYSTATES && ((UnitAITypes)iI == UNITAI_DIPLOMAT || (UnitAITypes)iI == UNITAI_MESSENGER)) ||
#endif
				(UnitAITypes)iI == UNITAI_WRITER || (UnitAITypes)iI == UNITAI_MUSICIAN)
		{
			continue;
		}
		else
		{
			numUnits += GetNumUnitsWithUnitAI((UnitAITypes)iI, false, true);
		}
	}
	gDLL->GetSteamStat(ESTEAMSTAT_STANDINGARMY, &nLargestArmy);

	if(nLargestArmy < numUnits)
	{
		gDLL->SetSteamStat(ESTEAMSTAT_STANDINGARMY, numUnits);

		CvAchievementUnlocker::Check_PSG();
	}
#endif
}

//	--------------------------------------------------------------------------------
void CvPlayer::checkInitialTurnAIProcessed()
{
	int turn = GC.getGame().getGameTurn();
	if(m_lastGameTurnInitialAIProcessed != turn)
	{
		//Note: Players that are not turn active at the beginning of the game turn will 
		//process their AI when they are turn active.  However, they should still 
		//act like their initial AI has been processed.
		if(!isTurnActive() || !hasUnitsThatNeedAIUpdate())
		{
			m_lastGameTurnInitialAIProcessed = turn;
			if(GC.getGame().getActivePlayer() == GetID())
				gDLL->sendPlayerInitialAIProcessed();
		}
	}
}

//------------------------------------------------------------------------------
void CvPlayer::GatherPerTurnReplayStats(int iGameTurn)
{
	AI_PERF_FORMAT("AI-perf.csv", ("CvPlayer::GatherPerTurnReplayStats, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), getCivilizationShortDescription()) );
#if !defined(FINAL_RELEASE)
	cvStopWatch watch("Replay Stat Recording");
#endif
	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());

		bool bResult;
		LuaSupport::CallHook(pkScriptSystem, "GatherPerTurnReplayStats", args.get(), bResult);
	}

	//Only record the following statistics if the player is alive.
	if(isAlive())
	{
		//	Production Per Turn
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_PRODUCTIONPERTURN"), iGameTurn, calculateTotalYield(YIELD_PRODUCTION));
		// 	Gold
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_TOTALGOLD"), iGameTurn, GetTreasury()->GetGold());
		// 	Gold per Turn
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_GOLDPERTURN"), iGameTurn, calculateTotalYield(YIELD_GOLD));
		// 	Num Cities
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_CITYCOUNT"), iGameTurn, getNumCities());

		//	Number of Techs known
		CvTeam& team = GET_TEAM(getTeam());
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_TECHSKNOWN"), iGameTurn, team.GetTeamTechs()->GetNumTechsKnown());

		// 	Science per Turn
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_SCIENCEPERTURN"), iGameTurn, calculateTotalYield(YIELD_SCIENCE));
		// antonjs: This data is also used to calculate Great Scientist and Research Agreement beaker bonuses. If replay data changes
		// or is disabled, CvPlayer::GetScienceYieldFromPreviousTurns must also change.

		// 	Total Culture
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_TOTALCULTURE"), iGameTurn, getJONSCulture());

		// 	Culture per turn
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_CULTUREPERTURN"), iGameTurn, GetTotalJONSCulturePerTurn());

		// 	Happiness
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_EXCESSHAPINESS"), iGameTurn, GetExcessHappiness());
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_HAPPINESS"), iGameTurn, GetHappiness());
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_UNHAPPINESS"), iGameTurn, GetUnhappiness());

		// 	Golden Age turns
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_GOLDENAGETURNS"), iGameTurn, getGoldenAgeTurns());

		// 	Population
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_POPULATION"), iGameTurn, getTotalPopulation());

		// 	Food Per Turn
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_FOODPERTURN"), iGameTurn, calculateTotalYield(YIELD_FOOD));

		//	Total Land
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_TOTALLAND"), iGameTurn, getTotalLand());

		CvTreasury* pkTreasury = GetTreasury();
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_GPTCITYCONNECTIONS"), iGameTurn, pkTreasury->GetCityConnectionGold());
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_GPTINTERNATIONALTRADE"), iGameTurn, pkTreasury->GetGoldPerTurnFromTradeRoutes());
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_GPTDEALS"), iGameTurn, pkTreasury->GetGoldPerTurnFromDiplomacy());
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_UNITMAINTENANCE"), iGameTurn, pkTreasury->GetExpensePerTurnUnitMaintenance());
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_BUILDINGMAINTENANCE"), iGameTurn, pkTreasury->GetBuildingGoldMaintenance());
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_IMPROVEMENTMAINTENANCE"), iGameTurn, pkTreasury->GetImprovementGoldMaintenance());
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_NUMBEROFPOLICIES"), iGameTurn, GetPlayerPolicies()->GetNumPoliciesOwned());

		// workers
		int iWorkerCount = 0;
		CvUnit* pLoopUnit;
		int iLoopUnit;
		for(pLoopUnit = firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoopUnit))
		{
			if(pLoopUnit->AI_getUnitAIType() == UNITAI_WORKER)
			{
				iWorkerCount++;
			}
		}
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_NUMBEROFWORKERS"), iGameTurn, iWorkerCount);


		// go through all the plots the player has under their control
		CvPlotsVector& aiPlots = GetPlots();

		// worked tiles
		int iWorkedTiles = 0;
		int iImprovedTiles = 0;
		for(uint uiPlotIndex = 0; uiPlotIndex < aiPlots.size(); uiPlotIndex++)
		{
			// when we encounter the first plot that is invalid, the rest of the list will be invalid
			if(aiPlots[uiPlotIndex] == -1)
			{
				break;
			}

			CvPlot* pPlot = GC.getMap().plotByIndex(aiPlots[uiPlotIndex]);
			if(!pPlot)
			{
				continue;
			}

			// plot has city in it, don't count
			if(pPlot->getPlotCity())
			{
				continue;
			}

			if(pPlot->isBeingWorked())
			{
				iWorkedTiles++;
			}

			if(pPlot->getImprovementType() != NO_IMPROVEMENT)
			{
				iImprovedTiles++;
			}
		}

		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_IMPROVEDTILES"), iGameTurn, iImprovedTiles);
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_WORKEDTILES"), iGameTurn, iWorkedTiles);
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_NUMBEROFWORKERS"), iGameTurn, iWorkerCount);


		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_MILITARYMIGHT"), iGameTurn, GetMilitaryMight());
	}
}

//	---------------------------------------------------------------------------
//	If the active player is in the end-turn processing phase, attempt to cancel that.
//	This should be called when something occurs that could happen during the end-turn
//	that may need the players attention this turn.
//	Ex.  A player's unit auto-moves into a goody hut plot.
bool CancelActivePlayerEndTurn()
{
	CvPlayer& kActivePlayer = GET_PLAYER(GC.getGame().getActivePlayer());

	if(kActivePlayer.isLocalPlayer() && kActivePlayer.isEndTurn())
	{
		if (gDLL->sendTurnUnready())	// This will see if we can actually do the unready, sometimes you can't in MP games.
		{
			kActivePlayer.setEndTurn(false);
			return true;
		}
		return false;
	}
	return true;
}

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
//	--------------------------------------------------------------------------------
///	Get the amount of Happiness we're getting from our vassals
int CvPlayer::GetHappinessFromVassals() const
{
	int iHappiness = 0;

	PlayerTypes ePlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		ePlayer = (PlayerTypes) iPlayerLoop;
		if(GetID() != ePlayer && GET_PLAYER(ePlayer).isAlive())
		{
			iHappiness += GetHappinessFromVassal(ePlayer);
		}
	}

	return iHappiness;
}
//	--------------------------------------------------------------------------------
/// Happiness from a Vassal
int CvPlayer::GetHappinessFromVassal(PlayerTypes ePlayer) const
{
	// Do not evaluate dead players (prevents crash)
	if (!GET_PLAYER(ePlayer).isAlive()) return 0;
	
	int iAmount = 0;
	if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassal(getTeam()))
	{
		iAmount += GET_PLAYER(ePlayer).GetExcessHappiness() * GC.getVASSAL_HAPPINESS_PERCENT();
		iAmount /= 100;
	}
	return iAmount;
}
//	--------------------------------------------------------------------------------
/// Special bonus for having a vassal
int CvPlayer::GetYieldPerTurnFromVassals(YieldTypes eYield) const
{
	int iFreeYield = 0;
	int iYield = 0;
	PlayerTypes ePlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		ePlayer = (PlayerTypes) iPlayerLoop;
		
		// ePlayer vassal of ours?
		if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassal(getTeam()))
		{
			iFreeYield = 0;
			switch(eYield)
			{
				// We now collect gold from taxes
				case YIELD_GOLD:
					//iFreeYield = GET_PLAYER(ePlayer).calculateGoldRate();
					//iFreeYield *= /*33*/GC.getVASSALAGE_FREE_YIELD_FROM_VASSAL_PERCENT();
					//iFreeYield /= 100;
					break;

				case YIELD_CULTURE:
					if (eYield == YIELD_CULTURE && (GC.getGame().isOption(GAMEOPTION_NO_POLICIES)))
					{
						return 0;
					}
					iFreeYield = GET_PLAYER(ePlayer).GetTotalJONSCulturePerTurn();
					iFreeYield *= /*33*/GC.getVASSALAGE_FREE_YIELD_FROM_VASSAL_PERCENT();
					iFreeYield /= 100;

					break;

				case YIELD_FAITH:
					if (eYield == YIELD_FAITH && (GC.getGame().isOption(GAMEOPTION_NO_RELIGION)))
					{
						return 0;
					}
					iFreeYield = GET_PLAYER(ePlayer).GetTotalFaithPerTurn();
					iFreeYield *= /*33*/GC.getVASSALAGE_FREE_YIELD_FROM_VASSAL_PERCENT();
					iFreeYield /= 100;
					break;
				case YIELD_SCIENCE:
					if (eYield == YIELD_SCIENCE && (GC.getGame().isOption(GAMEOPTION_NO_SCIENCE)))
					{
						return 0;
					}
					iFreeYield = GET_PLAYER(ePlayer).GetScience();
					iFreeYield *= /*33*/GC.getVASSALAGE_FREE_YIELD_FROM_VASSAL_PERCENT();
					iFreeYield /= 100;
					break;
			}

			iYield += iFreeYield;
		}
	}
	return iYield;
}
//	--------------------------------------------------------------------------------
// Score from Vassals: 50% percent
int CvPlayer::GetScoreFromVassals() const
{
	int iScore = 0;
	PlayerTypes ePlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		ePlayer = (PlayerTypes) iPlayerLoop;
		iScore += GetScoreFromVassal(ePlayer);
	}

	return iScore;
}
//	--------------------------------------------------------------------------------
// Score from vassal
int CvPlayer::GetScoreFromVassal(PlayerTypes ePlayer) const
{
	int iScore = 0;

	if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassal(getTeam()))
	{
		iScore = GET_PLAYER(ePlayer).GetScoreFromLand() + GET_PLAYER(ePlayer).GetScoreFromPopulation();
		iScore *= /*20*/ GC.getVASSAL_SCORE_PERCENT();
		iScore /= 100;
	}

	return iScore;
}
// ------------------------

//	--------------------------------------------------------------------------------
int CvPlayer::GetVassalGoldMaintenanceMod() const
{
	return m_iVassalGoldMaintenanceMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetVassalGoldMaintenanceMod(int iValue)
{
	m_iVassalGoldMaintenanceMod = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeVassalGoldMaintenanceMod(int iChange)
{
	if(iChange != 0)
	{
		m_iVassalGoldMaintenanceMod = (m_iVassalGoldMaintenanceMod + iChange);
	}
}

//	--------------------------------------------------------------------------------
// Generate tooltip displayed for whether or not our vassal can declare independence from us
CvString CvPlayer::GetVassalIndependenceTooltipAsMaster(PlayerTypes ePlayer) const
{
	CvTeam& kVassalTeam = GET_TEAM(GET_PLAYER(ePlayer).getTeam());

	TeamTypes eMaster = kVassalTeam.GetMaster();
	if(eMaster != getTeam())
		return "";

	CvTeam& kMasterTeam = GET_TEAM(eMaster);
	
	CvString szTooltip = "";
	
	szTooltip += GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_TT") + "[NEWLINE][NEWLINE]";

	bool bVoluntary = kVassalTeam.IsVoluntaryVassal(getTeam());
	bool bSatisfied = false;

	int iMinimumVassalTurns = bVoluntary ? GC.getGame().getGameSpeedInfo().getMinimumVoluntaryVassalTurns() : GC.getGame().getGameSpeedInfo().getMinimumVassalTurns();

	int iNumTurnsIsVassal = kVassalTeam.GetNumTurnsIsVassal();

	bSatisfied = (iNumTurnsIsVassal >= iMinimumVassalTurns);
	szTooltip += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_TURNS_TT", iMinimumVassalTurns) + "[ENDCOLOR][NEWLINE]";
	
	// Rules only for capitulated vassals
	if(!bVoluntary)
	{
		CvString szTemp = "";
		bool bAnySatisfied = false;

		int iNumCitiesWhenVassalMade = kVassalTeam.getNumCitiesWhenVassalMade();
		int iPopulationWhenVassalMade = kVassalTeam.getTotalPopulationWhenVassalMade();

		int iCityPercent = 0;
		int iPopPercent = 0;

		iCityPercent = kVassalTeam.getNumCities() * 100 / std::max(1, iNumCitiesWhenVassalMade);
		iPopPercent = kVassalTeam.getTotalPopulation() * 100 / std::max(1, iPopulationWhenVassalMade);

		bSatisfied = iCityPercent <= GC.getVASSALAGE_VASSAL_LOST_CITIES_THRESHOLD();
		bAnySatisfied = bAnySatisfied || bSatisfied;
		szTemp += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_CITY_PERCENT_TT", GC.getVASSALAGE_VASSAL_LOST_CITIES_THRESHOLD(),iCityPercent) + "[ENDCOLOR][NEWLINE]";

		bSatisfied = iPopPercent >= GC.getVASSALAGE_VASSAL_POPULATION_THRESHOLD();
		bAnySatisfied = bAnySatisfied || bSatisfied;
		szTemp += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_CITY_PERCENT_TT", GC.getVASSALAGE_VASSAL_POPULATION_THRESHOLD(), iPopPercent) + "[ENDCOLOR][NEWLINE]";
		
		int iMasterCityPercent = 0;
		int iMasterPopPercent = 0;

		iMasterCityPercent = kVassalTeam.getNumCities() * 100 / std::max(1, kMasterTeam.getNumCities());
		iMasterPopPercent = kVassalTeam.getTotalPopulation() * 100 / std::max(1, kMasterTeam.getTotalPopulation());

		bSatisfied = iMasterCityPercent >= GC.getVASSALAGE_VASSAL_MASTER_CITY_PERCENT_THRESHOLD() && iMasterPopPercent >= GC.getVASSALAGE_VASSAL_MASTER_POP_PERCENT_THRESHOLD();
		bAnySatisfied = bAnySatisfied || bSatisfied;
		szTemp += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_MASTER_PERCENT_TT", GC.getVASSALAGE_VASSAL_MASTER_CITY_PERCENT_THRESHOLD(), GC.getVASSALAGE_VASSAL_MASTER_POP_PERCENT_THRESHOLD(), iMasterCityPercent, iMasterPopPercent) + "[ENDCOLOR][NEWLINE]";

		szTooltip += (bAnySatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_OR_HEADER_TT") + "[NEWLINE]";
		szTooltip += szTemp;
	}

	return szTooltip;
}

// Generate tooltip displayed for whether or not we can declare independence from master
CvString CvPlayer::GetVassalIndependenceTooltipAsVassal() const
{
	CvTeam& kVassalTeam = GET_TEAM(getTeam());

	TeamTypes eMaster = kVassalTeam.GetMaster();
	if(eMaster == NO_TEAM)
		return "";

	CvTeam& kMasterTeam = GET_TEAM(eMaster);
	
	CvString szTooltip = "";
	
	szTooltip += GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_MASTER_TT") + "[NEWLINE][NEWLINE]";

	bool bVoluntary = kVassalTeam.IsVoluntaryVassal(getTeam());
	bool bSatisfied = false;

	int iMinimumVassalTurns = bVoluntary ? GC.getGame().getGameSpeedInfo().getMinimumVoluntaryVassalTurns() : GC.getGame().getGameSpeedInfo().getMinimumVassalTurns();

	int iNumTurnsIsVassal = kVassalTeam.GetNumTurnsIsVassal();

	bSatisfied = (iNumTurnsIsVassal >= iMinimumVassalTurns);
	szTooltip += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_TURNS_TT", iMinimumVassalTurns) + "[ENDCOLOR][NEWLINE]";
	
	// Rules only for capitulated vassals
	if(!bVoluntary)
	{
		CvString szTemp = "";
		bool bAnySatisfied = false;

		int iNumCitiesWhenVassalMade = kVassalTeam.getNumCitiesWhenVassalMade();
		int iPopulationWhenVassalMade = kVassalTeam.getTotalPopulationWhenVassalMade();

		int iCityPercent = 0;
		int iPopPercent = 0;

		iCityPercent = kVassalTeam.getNumCities() * 100 / std::max(1, iNumCitiesWhenVassalMade);
		iPopPercent = kVassalTeam.getTotalPopulation() * 100 / std::max(1, iPopulationWhenVassalMade);

		bSatisfied = iCityPercent <= GC.getVASSALAGE_VASSAL_LOST_CITIES_THRESHOLD();
		bAnySatisfied = bAnySatisfied || bSatisfied;
		szTemp += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_CITY_PERCENT_TT", GC.getVASSALAGE_VASSAL_LOST_CITIES_THRESHOLD(),iCityPercent) + "[ENDCOLOR][NEWLINE]";

		bSatisfied = iPopPercent >= GC.getVASSALAGE_VASSAL_POPULATION_THRESHOLD();
		bAnySatisfied = bAnySatisfied || bSatisfied;
		szTemp += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_CITY_PERCENT_TT", GC.getVASSALAGE_VASSAL_POPULATION_THRESHOLD(), iPopPercent) + "[ENDCOLOR][NEWLINE]";
		
		int iMasterCityPercent = 0;
		int iMasterPopPercent = 0;

		iMasterCityPercent = kVassalTeam.getNumCities() * 100 / std::max(1, kMasterTeam.getNumCities());
		iMasterPopPercent = kVassalTeam.getTotalPopulation() * 100 / std::max(1, kMasterTeam.getTotalPopulation());

		bSatisfied = iMasterCityPercent >= GC.getVASSALAGE_VASSAL_MASTER_CITY_PERCENT_THRESHOLD() && iMasterPopPercent >= GC.getVASSALAGE_VASSAL_MASTER_POP_PERCENT_THRESHOLD();
		bAnySatisfied = bAnySatisfied || bSatisfied;
		szTemp += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_MASTER_PERCENT_TT", GC.getVASSALAGE_VASSAL_MASTER_CITY_PERCENT_THRESHOLD(), GC.getVASSALAGE_VASSAL_MASTER_POP_PERCENT_THRESHOLD(), iMasterCityPercent, iMasterPopPercent) + "[ENDCOLOR][NEWLINE]";

		szTooltip += (bAnySatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_OR_HEADER_TT") + "[NEWLINE]";
		szTooltip += szTemp;
	}

	return szTooltip;
}

#endif

#if defined(MOD_BALANCE_CORE)
int CvPlayer::GetScoreFromMinorAllies() const
{
	int iScore = (GC.getGame().GetNumMinorCivsEver() * 20);
	int iMaxMinorCivs = 0;
	int iMinorAllies = 0;
	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		PlayerTypes eMinor = (PlayerTypes) iMinorLoop;
		if(GET_PLAYER(eMinor).isAlive())
		{
			iMaxMinorCivs++;
		}
		if(GET_PLAYER(eMinor).GetMinorCivAI()->IsAllies(GetID()))
		{
			iMinorAllies++;
		}
	}
	if(iMaxMinorCivs > 0)
	{
		int iPercentage = ((iMinorAllies * 100) / iMaxMinorCivs);
		iScore = ((iPercentage * iScore) / 100);
		return iScore;
	}
	return 0;
}
int CvPlayer::GetScoreFromMilitarySize() const
{
	return (GetMilitaryMight() / 10);
}
#endif

#if defined(MOD_API_EXTENSIONS)
//	----------------------------------------------------------------------------
bool CvPlayer::HasBelief(BeliefTypes iBeliefType) const
{
	const ReligionTypes iReligion = GetReligions()->GetReligionCreatedByPlayer(true);
	const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(iReligion, GetID());

	return (pReligion && pReligion->m_Beliefs.HasBelief(iBeliefType));
}

bool CvPlayer::HasBuilding(BuildingTypes iBuildingType)
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasBuilding(iBuildingType)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasBuildingClass(BuildingClassTypes iBuildingClassType)
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasBuildingClass(iBuildingClassType)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasAnyWonder()
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasAnyWonder()) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasWonder(BuildingTypes iBuildingType)
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasWonder(iBuildingType)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::IsCivilization(CivilizationTypes iCivilizationType) const
{
	return (getCivilizationType() == iCivilizationType);
}

bool CvPlayer::IsInEra(EraTypes iEraType) const
{
	return (GET_TEAM(getTeam()).GetCurrentEra() == iEraType);
}

bool CvPlayer::HasReachedEra(EraTypes iEraType) const
{
	return (GET_TEAM(getTeam()).GetCurrentEra() >= iEraType);
}

bool CvPlayer::HasAnyNaturalWonder()
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasAnyNaturalWonder()) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasNaturalWonder(FeatureTypes iFeatureType)
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasNaturalWonder(iFeatureType)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasPolicy(PolicyTypes iPolicyType) const
{
	return GetPlayerPolicies()->HasPolicy(iPolicyType);
}

bool CvPlayer::HasTenet(PolicyTypes iPolicyType) const
{
	return HasPolicy(iPolicyType);
}

bool CvPlayer::HasPolicyBranch(PolicyBranchTypes iPolicyBranchType) const
{
	return GetPlayerPolicies()->IsPolicyBranchUnlocked(iPolicyBranchType);
}

bool CvPlayer::HasIdeology(PolicyBranchTypes iPolicyBranchType) const
{
	return HasPolicyBranch(iPolicyBranchType);
}

bool CvPlayer::HasProject(ProjectTypes iProjectType) const
{
	return (GET_TEAM(getTeam()).getProjectCount(iProjectType) > 0);
}

bool CvPlayer::IsAtPeace() const
{
	return !IsAtWar();
}

bool CvPlayer::IsAtPeaceAllMajors() const
{
	return !IsAtWarAnyMajor();
}

bool CvPlayer::IsAtPeaceAllMinors() const
{
	return !IsAtWarAnyMinor();
}

bool CvPlayer::IsAtPeaceWith(PlayerTypes iPlayer) const
{
	return !IsAtWarWith(iPlayer);
}

bool CvPlayer::IsAtWar() const
{
	//reference is important! otherwise the destructor will be called
	CvTeam& kTeam = GET_TEAM(getTeam());

	//ignore the barbarian team here!
	for (int iTeam = 0; iTeam < (MAX_TEAMS-1); iTeam++) {
		if (GET_TEAM((TeamTypes)iTeam).isAlive() && kTeam.isAtWar((TeamTypes)iTeam)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::IsAtWarAnyMajor() const
{
	//reference is important! otherwise the destructor will be called
	CvTeam& kTeam = GET_TEAM(getTeam());

	for (int iTeam = 0; iTeam < (MAX_TEAMS-1); iTeam++) {
		if (GET_TEAM((TeamTypes)iTeam).isAlive() && GET_TEAM((TeamTypes)iTeam).isMajorCiv() && kTeam.isAtWar((TeamTypes)iTeam)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::IsAtWarAnyMinor() const
{
	//reference is important! otherwise the destructor will be called
	CvTeam& kTeam = GET_TEAM(getTeam());

	for (int iTeam = 0; iTeam < (MAX_TEAMS-1); iTeam++) {
		if (GET_TEAM((TeamTypes)iTeam).isAlive() && GET_TEAM((TeamTypes)iTeam).isMinorCiv() && kTeam.isAtWar((TeamTypes)iTeam)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::IsAtWarWith(PlayerTypes iPlayer) const
{
	return GET_TEAM(getTeam()).isAtWar(GET_PLAYER(iPlayer).getTeam());
}

bool CvPlayer::HasPantheon() const
{
	return GetReligions()->HasCreatedPantheon();
}

bool CvPlayer::HasAnyReligion() const
{
	return GetReligions()->HasCreatedReligion();
}

bool CvPlayer::HasReligion(ReligionTypes iReligionType) const
{
	return (GetReligions()->GetReligionCreatedByPlayer() == iReligionType);
}

bool CvPlayer::HasEnhancedReligion() const
{
	const ReligionTypes eReligion = GetReligions()->GetReligionCreatedByPlayer();
	const CvReligion* pMyReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, GetID());

	return (pMyReligion && pMyReligion->m_bEnhanced);
}

bool CvPlayer::IsConnectedTo(PlayerTypes iPlayer)
{
	return IsCapitalConnectedToPlayer(iPlayer);
}

bool CvPlayer::HasSpecialistSlot(SpecialistTypes iSpecialistType)
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasSpecialistSlot(iSpecialistType)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasSpecialist(SpecialistTypes iSpecialistType)
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasSpecialist(iSpecialistType)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasTech(TechTypes iTechType) const
{
	return GET_TEAM(getTeam()).GetTeamTechs()->HasTech(iTechType);
}

bool CvPlayer::HasAnyDomesticTradeRoute() const
{
	int iOwner = GetID();
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute)) {
			continue;
		}

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));

		if (pConnection->m_eOriginOwner == iOwner && pConnection->m_eDestOwner == iOwner) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasAnyInternationalTradeRoute() const
{
	int iOwner = GetID();
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute)) {
			continue;
		}

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));

		if ((pConnection->m_eOriginOwner == iOwner && pConnection->m_eDestOwner   != iOwner) ||
		    (pConnection->m_eDestOwner   == iOwner && pConnection->m_eOriginOwner != iOwner)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasAnyTradeRoute() const
{
	int iOwner = GetID();
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute)) {
			continue;
		}

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));

		if (pConnection->m_eOriginOwner == iOwner || pConnection->m_eDestOwner == iOwner) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasAnyTradeRouteWith(PlayerTypes iPlayer) const
{
	int iOwner = GetID();
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute)) {
			continue;
		}

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));

		if ((pConnection->m_eOriginOwner == iOwner && pConnection->m_eDestOwner   == iPlayer) ||
		    (pConnection->m_eDestOwner   == iOwner && pConnection->m_eOriginOwner == iPlayer)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasUnit(UnitTypes iUnitType)
{
	int iLoopUnit;

	for (CvUnit* pLoopUnit = firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoopUnit)) {
		if (!pLoopUnit->isDelayedDeath()) {
			if (pLoopUnit->IsUnit(iUnitType)) {
				return true;
			}
		}
	}

	return false;
}

bool CvPlayer::HasUnitClass(UnitClassTypes iUnitClassType)
{
	int iLoopUnit;

	for (CvUnit* pLoopUnit = firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoopUnit)) {
		if (!pLoopUnit->isDelayedDeath()) {
			if (pLoopUnit->IsUnitClass(iUnitClassType)) {
				return true;
			}
		}
	}

	return false;
}

bool CvPlayer::HasTrait(TraitTypes eTrait) const
{
	return GetPlayerTraits()->HasTrait(eTrait);
}

bool CvPlayer::HasAnyHolyCity()
{
	int iLoop;

	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		if (pLoopCity->GetCityReligions()->IsHolyCityAnyReligion()) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasHolyCity(ReligionTypes eReligion)
{
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		if (pLoopCity->GetCityReligions()->IsHolyCityForReligion(eReligion)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasCapturedHolyCity(ReligionTypes eReligion)
{
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		if (pLoopCity->GetCityReligions()->IsHolyCityForReligion(eReligion)) {
			return (pLoopCity->getOriginalOwner() != GetID());
		}
	}

	return false;
}

bool CvPlayer::HasEmbassyWith(PlayerTypes eOtherPlayer) const
{
	if (eOtherPlayer >= 0 && eOtherPlayer < MAX_MAJOR_CIVS) {
		CvPlayer& kOtherPlayer = GET_PLAYER(eOtherPlayer);

		return (kOtherPlayer.isAlive() && GET_TEAM(getTeam()).HasEmbassyAtTeam(kOtherPlayer.getTeam()));
	}

	return false;
}

void CvPlayer::DoForceDefPact(PlayerTypes eOtherPlayer)
{
	CvTeam& pOtherTeam = GET_TEAM(GET_PLAYER(eOtherPlayer).getTeam());

	GET_TEAM(getTeam()).SetHasDefensivePact(pOtherTeam.GetID(), true);
	pOtherTeam.SetHasDefensivePact(getTeam(), true);
}
int CvPlayer::CountAllFeature(FeatureTypes iFeatureType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountFeature(iFeatureType);
	}
	
	return iCount;
}

int CvPlayer::CountAllWorkedFeature(FeatureTypes iFeatureType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountWorkedFeature(iFeatureType);
	}
	
	return iCount;
}

int CvPlayer::CountAllImprovement(ImprovementTypes iImprovementType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountImprovement(iImprovementType);
	}
	
	return iCount;
}

int CvPlayer::CountAllWorkedImprovement(ImprovementTypes iImprovementType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountWorkedImprovement(iImprovementType);
	}
	
	return iCount;
}

int CvPlayer::CountAllPlotType(PlotTypes iPlotType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountPlotType(iPlotType);
	}
	
	return iCount;
}

int CvPlayer::CountAllWorkedPlotType(PlotTypes iPlotType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountWorkedPlotType(iPlotType);
	}
	
	return iCount;
}

int CvPlayer::CountAllResource(ResourceTypes iResourceType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountResource(iResourceType);
	}
	
	return iCount;
}

int CvPlayer::CountAllWorkedResource(ResourceTypes iResourceType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountWorkedResource(iResourceType);
	}
	
	return iCount;
}

int CvPlayer::CountAllTerrain(TerrainTypes iTerrainType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountTerrain(iTerrainType);
	}
	
	return iCount;
}

int CvPlayer::CountAllWorkedTerrain(TerrainTypes iTerrainType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountWorkedTerrain(iTerrainType);
	}
	
	return iCount;
}
#endif

void CvPlayer::updatePlotFoundValues()
{
	m_iPlotFoundValues.clear();

	// Set all area fertilities to 0
	int iLoop = 0;
	for (CvArea* pLoopArea = GC.getMap().firstArea(&iLoop); pLoopArea != NULL; pLoopArea = GC.getMap().nextArea(&iLoop))
	{
		pLoopArea->setTotalFoundValue(0);
	}

	//don't need to update if never going to settle
	if (isBarbarian())
		return;

	//don't need to update if never going to settle again
	bool bVenice = GetPlayerTraits()->IsNoAnnexing();
	if (isMinorCiv() || bVenice)
	{
		if (GetNumCitiesFounded()>0)
			return;
	}

	// important preparation
	GC.getGame().GetSettlerSiteEvaluator()->ComputeFlavorMultipliers(this);

	// first pass: precalculate found values
	CvSiteEvaluatorForSettler* pCalc = GC.getGame().GetSettlerSiteEvaluator();
	m_iPlotFoundValues.resize(GC.getMap().numPlots(), -1);
	for (int iI = 0; iI < GC.getMap().numPlots(); iI++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iI);
		if (pPlot->isRevealed(getTeam()))
			m_iPlotFoundValues[iI] = pCalc->PlotFoundValue(pPlot, this);
	}

	// second pass: non-maxima suppression and aggregation
	int iGoodEnoughToBeWorthOurTime = GC.getAI_STRATEGY_MINIMUM_SETTLE_FERTILITY();
	for (int iI = 0; iI < GC.getMap().numPlots(); iI++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iI);
		int iRefValue = m_iPlotFoundValues[iI];

		if (iRefValue < iGoodEnoughToBeWorthOurTime)
			continue;

		CvPlot** aPlotsToCheck = GC.getMap().getNeighborsUnchecked(pPlot);
		for (int iCount = 0; iCount<NUM_DIRECTION_TYPES; iCount++)
		{
			CvPlot* pLoopPlot = aPlotsToCheck[iCount];

			if (pLoopPlot == NULL)
				continue;

			if (m_iPlotFoundValues[pLoopPlot->GetPlotIndex()] > iRefValue)
			{
				//this is not a local maximum
				pPlot = NULL;
				break;
			}
		}

		if (pPlot)
		{
			CvArea* pLoopArea = GC.getMap().getArea(pPlot->getArea());
			if (pLoopArea && !pLoopArea->isWater() && (pLoopArea->getNumTiles() > 0))
			{
				int newValue = pLoopArea->getTotalFoundValue() + iRefValue;
				pLoopArea->setTotalFoundValue(newValue);
			}
		}
	}
}

int CvPlayer::getPlotFoundValue(int iX, int iY)
{
	size_t iIndex = (size_t)GC.getMap().plotNum(iX,iY);

	if (iIndex<m_iPlotFoundValues.size())
		return m_iPlotFoundValues[iIndex];
	else
		return 0;
}

void CvPlayer::setPlotFoundValue(int iX, int iY, int iValue)
{
	size_t iIndex = (size_t)GC.getMap().plotNum(iX, iY);

	if (iIndex<m_iPlotFoundValues.size())
		m_iPlotFoundValues[iIndex] = iValue;
}
