/*	-------------------------------------------------------------------------------------------------------
	� 1991-2012 Take-Two Interactive Software and its subsidiaries.  Developed by Firaxis Games.  
	Sid Meier's Civilization V, Civ, Civilization, 2K Games, Firaxis Games, Take-Two Interactive Software 
	and their respective logos are all trademarks of Take-Two interactive Software, Inc.  
	All other marks and trademarks are the property of their respective owners.  
	All rights reserved. 
	------------------------------------------------------------------------------------------------------- */

#include "CvGameCoreDLLPCH.h"
#include "CvGlobals.h"
#include "CvArea.h"
#include "CvMap.h"
#include "CvPlot.h"
#include "CvRandom.h"
#include "CvTeam.h"
#include "CvGameCoreUtils.h"
#include "CvPlayerAI.h"
#include "CvPlayer.h"
#include "CvGameCoreUtils.h"
#include "CvInfos.h"
#include "CvAStar.h"
#include "CvGameTextMgr.h"
#include "CvDiplomacyAI.h"
#include "CvEconomicAI.h"
#include "CvMilitaryAI.h"
#include "CvCitySpecializationAI.h"
#include "CvWonderProductionAI.h"
#include "CvGrandStrategyAI.h"
#include "CvDiplomacyAI.h"
#include "CvTechAI.h"
#include "CvFlavorManager.h"
#include "CvHomelandAI.h"
#include "CvMinorCivAI.h"
#include "CvDealAI.h"
#include "CvImprovementClasses.h"
#include "CvBuilderTaskingAI.h"
#include "CvDangerPlots.h"
#if defined(MOD_BALANCE_CORE)
#include "CvDistanceMap.h"
#include "CvBarbarians.h"
#endif
#include "CvGoodyHuts.h"
#include "CvCityConnections.h"
#include "CvNotifications.h"
#include "CvDiplomacyRequests.h"
#include "cvStopWatch.h"
#include "CvTypes.h"
#if defined(MOD_BUGFIX_NO_PUPPET_CAPITALS)
#include "CvEnums.h"
#endif

#include "ICvDLLUserInterface.h"
#include "CvEnumSerialization.h"
#include "FStlContainerSerialization.h"
#include <sstream>
#if defined(MOD_BALANCE_CORE)
#include <iomanip>
#endif

#include "CvInternalGameCoreUtils.h"
#include "CvAchievementUnlocker.h"
#include "CvInfosSerializationHelper.h"

#include "CvDllCity.h"
#if defined(MOD_GLOBAL_NO_CONQUERED_SPACESHIPS)
#include "CvDllPlot.h"
#endif
#include "CvGoodyHuts.h"

#include "CvDllNetMessageExt.h"
// Include this after all other headers.
#define LINT_WARNINGS_ONLY
#include "LintFree.h"

//------------------------------------------------------------------------------
// CvPlayer Version History
// Version 1 
//	 * CvPlayer save version reset for expansion pack 2.
//------------------------------------------------------------------------------
const int g_CurrentCvPlayerVersion = 16;

//Simply empty check utility.
bool isEmpty(const char* szString)
{
	return szString == NULL || szString[0] == '\0';
}

//	--------------------------------------------------------------------------------
// Public Functions...
namespace FSerialization
{
void SyncPlayer()
{
	if(GC.getGame().isNetworkMultiPlayer())
	{
		PlayerTypes eAuthoritativePlayerID = GC.getGame().getActivePlayer();
		CvPlayer& authoritativePlayer = GET_PLAYER(eAuthoritativePlayerID);
		const FAutoArchive& archive = authoritativePlayer.getSyncArchive();
		if(archive.hasDeltas())
		{
			FMemoryStream ms;
			std::vector<std::pair<std::string, std::string> > callStacks;
			archive.saveDelta(ms, callStacks);
			gDLL->sendPlayerSyncCheck(eAuthoritativePlayerID, ms, callStacks);
		}

		// host is authoritative for AI players

		if(gDLL->IsHost())
		{
			for(int i = 0; i < MAX_PLAYERS; ++i)
			{
				CvPlayer& player = GET_PLAYER(static_cast<PlayerTypes>(i));
				if(!player.isHuman() && player.isAlive())
				{
					const FAutoArchive& aiArchive = player.getSyncArchive();
					FMemoryStream ms;
					std::vector<std::pair<std::string, std::string> > callStacks;
					aiArchive.saveDelta(ms, callStacks);
					gDLL->sendPlayerSyncCheck(static_cast<PlayerTypes>(i), ms, callStacks);
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
// clears ALL deltas for ALL players
void ClearPlayerDeltas()
{
	int i = 0;
	for(i = 0; i < MAX_PLAYERS; ++i)
	{
		CvPlayer& player = GET_PLAYER(static_cast<PlayerTypes>(i));
		FAutoArchive& archive = player.getSyncArchive();
		archive.clearDelta();
	}
}
}

//	--------------------------------------------------------------------------------
CvPlayer::CvPlayer() :
	m_syncArchive(*this)
	, m_iStartingX("CvPlayer::m_iStartingX", m_syncArchive)
	, m_iStartingY("CvPlayer::m_iStartingY", m_syncArchive)
	, m_iTotalPopulation("CvPlayer::m_iTotalPopulation", m_syncArchive, true)
	, m_iTotalLand("CvPlayer::m_iTotalLand", m_syncArchive)
	, m_iTotalLandScored("CvPlayer::m_iTotalLandScored", m_syncArchive)
	, m_iJONSCulturePerTurnForFree("CvPlayer::m_iJONSCulturePerTurnForFree", m_syncArchive)
	, m_iJONSCulturePerTurnFromMinorCivs("CvPlayer::m_iJONSCulturePerTurnFromMinorCivs", m_syncArchive)
	, m_iJONSCultureCityModifier("CvPlayer::m_iJONSCultureCityModifier", m_syncArchive)
	, m_iJONSCulture("CvPlayer::m_iJONSCulture", m_syncArchive, true)
	, m_iJONSCultureEverGenerated("CvPlayer::m_iJONSCultureEverGenerated", m_syncArchive)
	, m_iCulturePerWonder("CvPlayer::m_iCulturePerWonder", m_syncArchive)
	, m_iCultureWonderMultiplier("CvPlayer::m_iCultureWonderMultiplier", m_syncArchive)
	, m_iCulturePerTechResearched("CvPlayer::m_iCulturePerTechResearched", m_syncArchive)
	, m_iFaith("CvPlayer::m_iFaith", m_syncArchive)
	, m_iFaithEverGenerated("CvPlayer::m_iFaithEverGenerated", m_syncArchive)
	, m_iHappiness("CvPlayer::m_iHappiness", m_syncArchive)
	, m_iUprisingCounter("CvPlayer::m_iUprisingCounter", m_syncArchive)
	, m_iExtraHappinessPerLuxury("CvPlayer::m_iExtraHappinessPerLuxury", m_syncArchive)
	, m_iUnhappinessFromUnits("CvPlayer::m_iUnhappinessFromUnits", m_syncArchive)
	, m_iUnhappinessFromUnitsMod("CvPlayer::m_iUnhappinessFromUnitsMod", m_syncArchive)
	, m_iUnhappinessMod("CvPlayer::m_iUnhappinessMod", m_syncArchive)
	, m_iCityCountUnhappinessMod("CvPlayer::m_iCityCountUnhappinessMod", m_syncArchive)
	, m_iOccupiedPopulationUnhappinessMod("CvPlayer::m_iOccupiedPopulationUnhappinessMod", m_syncArchive)
	, m_iCapitalUnhappinessMod("CvPlayer::m_iCapitalUnhappinessMod", m_syncArchive)
	, m_iCityRevoltCounter("CvPlayer::m_iCityRevoltCounter", m_syncArchive)
	, m_iHappinessPerGarrisonedUnitCount("CvPlayer::m_iHappinessPerGarrisonedUnitCount", m_syncArchive)
	, m_iHappinessPerTradeRouteCount("CvPlayer::m_iHappinessPerTradeRouteCount", m_syncArchive)
	, m_iHappinessPerXPopulation("CvPlayer::m_iHappinessPerXPopulation", m_syncArchive)
	, m_iHappinessFromLeagues("CvPlayer::m_iHappinessFromLeagues", m_syncArchive)
	, m_iEspionageModifier("CvPlayer::m_iEspionageModifier", m_syncArchive)
	, m_iSpyStartingRank("CvPlayer::m_iSpyStartingRank", m_syncArchive)
	, m_iExtraLeagueVotes("CvPlayer::m_iExtraLeagueVotes", m_syncArchive)
	, m_iSpecialPolicyBuildingHappiness("CvPlayer::m_iSpecialPolicyBuildingHappiness", m_syncArchive)
	, m_iWoundedUnitDamageMod("CvPlayer::m_iWoundedUnitDamageMod", m_syncArchive)
	, m_iUnitUpgradeCostMod("CvPlayer::m_iUnitUpgradeCostMod", m_syncArchive)
	, m_iBarbarianCombatBonus("CvPlayer::m_iBarbarianCombatBonus", m_syncArchive)
	, m_iAlwaysSeeBarbCampsCount("CvPlayer::m_iAlwaysSeeBarbCampsCount", m_syncArchive)
	, m_iHappinessFromBuildings("CvPlayer::m_iHappinessFromBuildings", m_syncArchive)
	, m_iHappinessPerCity("CvPlayer::m_iHappinessPerCity", m_syncArchive)
	, m_iHappinessPerXPolicies("CvPlayer::m_iHappinessPerXPolicies", m_syncArchive)
	, m_iExtraHappinessPerXPoliciesFromPolicies("CvPlayer::m_iExtraHappinessPerXPoliciesFromPolicies", m_syncArchive)
	, m_iHappinessPerXGreatWorks("CvPlayer::m_iHappinessPerXGreatWorks", m_syncArchive)
	, m_iAdvancedStartPoints("CvPlayer::m_iAdvancedStartPoints", m_syncArchive)
	, m_iAttackBonusTurns("CvPlayer::m_iAttackBonusTurns", m_syncArchive)
	, m_iCultureBonusTurns("CvPlayer::m_iCultureBonusTurns", m_syncArchive)
	, m_iTourismBonusTurns("CvPlayer::m_iTourismBonusTurns", m_syncArchive)
	, m_iGoldenAgeProgressMeter("CvPlayer::m_iGoldenAgeProgressMeter", m_syncArchive, true)
	, m_iGoldenAgeMeterMod("CvPlayer::m_iGoldenAgeMeterMod", m_syncArchive)
	, m_iNumGoldenAges("CvPlayer::m_iNumGoldenAges", m_syncArchive)
	, m_iGoldenAgeTurns("CvPlayer::m_iGoldenAgeTurns", m_syncArchive)
	, m_iNumUnitGoldenAges("CvPlayer::m_iNumUnitGoldenAges", m_syncArchive)
	, m_iStrikeTurns("CvPlayer::m_iStrikeTurns", m_syncArchive)
	, m_iGoldenAgeModifier("CvPlayer::m_iGoldenAgeModifier", m_syncArchive)
	, m_iGreatPeopleCreated("CvPlayer::m_iGreatPeopleCreated", m_syncArchive)
	, m_iGreatGeneralsCreated("CvPlayer::m_iGreatGeneralsCreated", m_syncArchive)
	, m_iGreatAdmiralsCreated("CvPlayer::m_iGreatAdmiralsCreated", m_syncArchive)
	, m_iGreatWritersCreated("CvPlayer::m_iGreatWritersCreated", m_syncArchive)
	, m_iGreatArtistsCreated("CvPlayer::m_iGreatArtistsCreated", m_syncArchive)
	, m_iGreatMusiciansCreated("CvPlayer::m_iGreatMusiciansCreated", m_syncArchive)
	, m_iMerchantsFromFaith("CvPlayer::m_iMerchantsFromFaith", m_syncArchive)
	, m_iScientistsFromFaith("CvPlayer::m_iScientistsFromFaith", m_syncArchive)
	, m_iWritersFromFaith("CvPlayer::m_iWritersFromFaith", m_syncArchive)
	, m_iArtistsFromFaith("CvPlayer::m_iArtistsFromFaith", m_syncArchive)
	, m_iMusiciansFromFaith("CvPlayer::m_iMusiciansFromFaith", m_syncArchive)
	, m_iGeneralsFromFaith("CvPlayer::m_iGeneralsFromFaith", m_syncArchive)
	, m_iAdmiralsFromFaith("CvPlayer::m_iAdmiralsFromFaith", m_syncArchive)
	, m_iEngineersFromFaith("CvPlayer::m_iEngineersFromFaith", m_syncArchive)
	, m_iGreatPeopleThresholdModifier("CvPlayer::m_iGreatPeopleThresholdModifier", m_syncArchive)
	, m_iGreatGeneralsThresholdModifier("CvPlayer::m_iGreatGeneralsThresholdModifier", m_syncArchive)
	, m_iGreatAdmiralsThresholdModifier("CvPlayer::m_iGreatAdmiralsThresholdModifier", m_syncArchive)
	, m_iGreatGeneralCombatBonus("CvPlayer::m_iGreatGeneralCombatBonus", m_syncArchive)
	, m_iAnarchyNumTurns("CvPlayer::m_iAnarchyNumTurns", m_syncArchive)
	, m_iPolicyCostModifier("CvPlayer::m_iPolicyCostModifier", m_syncArchive)
	, m_iGreatPeopleRateModifier("CvPlayer::m_iGreatPeopleRateModifier", m_syncArchive)
	, m_iGreatPeopleRateModFromBldgs("CvPlayer::m_iGreatPeopleRateModFromBldgs", m_syncArchive)
	, m_iGreatGeneralRateModifier("CvPlayer::m_iGreatGeneralRateModifier", m_syncArchive)
	, m_iGreatGeneralRateModFromBldgs("CvPlayer::m_iGreatGeneralRateModFromBldgs", m_syncArchive)
	, m_iDomesticGreatGeneralRateModifier("CvPlayer::m_iDomesticGreatGeneralRateModifier", m_syncArchive)
	, m_iDomesticGreatGeneralRateModFromBldgs("CvPlayer::m_iDomesticGreatGeneralRateModFromBldgs", m_syncArchive)
	, m_iGreatAdmiralRateModifier("CvPlayer::m_iGreatAdmiralRateModifier", m_syncArchive)
	, m_iGreatWriterRateModifier("CvPlayer::m_iGreatWriterRateModifier", m_syncArchive)
	, m_iGreatArtistRateModifier("CvPlayer::m_iGreatArtistRateModifier", m_syncArchive)
	, m_iGreatMusicianRateModifier("CvPlayer::m_iGreatMusicianRateModifier", m_syncArchive)
	, m_iGreatMerchantRateModifier("CvPlayer::m_iGreatMerchantRateModifier", m_syncArchive)
	, m_iGreatDiplomatRateModifier("CvPlayer::m_iGreatDiplomatRateModifier", m_syncArchive)
	, m_iGreatScientistRateModifier("CvPlayer::m_iGreatScientistRateModifier", m_syncArchive)
	, m_iGreatScientistBeakerModifier("CvPlayer::m_iGreatScientistBeakerModifier", m_syncArchive)
	, m_iGreatEngineerHurryMod("CvPlayer::m_iGreatEngineerHurryMod", m_syncArchive)
	, m_iTechCostXCitiesModifier("CvPlayer::m_iTechCostXCitiesModifier", m_syncArchive)
	, m_iTourismCostXCitiesMod("CvPlayer::m_iTourismCostXCitiesMod", m_syncArchive)
	, m_iGreatEngineerRateModifier("CvPlayer::m_iGreatEngineerRateModifier", m_syncArchive)
	, m_iGreatPersonExpendGold("CvPlayer::m_iGreatPersonExpendGold", m_syncArchive)
	, m_iMaxGlobalBuildingProductionModifier("CvPlayer::m_iMaxGlobalBuildingProductionModifier", m_syncArchive)
	, m_iMaxTeamBuildingProductionModifier("CvPlayer::m_iMaxTeamBuildingProductionModifier", m_syncArchive)
	, m_iMaxPlayerBuildingProductionModifier("CvPlayer::m_iMaxPlayerBuildingProductionModifier", m_syncArchive)
	, m_iFreeExperience("CvPlayer::m_iFreeExperience", m_syncArchive)
	, m_iFreeExperienceFromBldgs("CvPlayer::m_iFreeExperienceFromBldgs", m_syncArchive)
	, m_iFreeExperienceFromMinors("CvPlayer::m_iFreeExperienceFromMinors", m_syncArchive)
	, m_iFeatureProductionModifier("CvPlayer::m_iFeatureProductionModifier", m_syncArchive)
	, m_iWorkerSpeedModifier("CvPlayer::m_iWorkerSpeedModifier", m_syncArchive)
	, m_iImprovementCostModifier("CvPlayer::m_iImprovementCostModifier", m_syncArchive)
	, m_iImprovementUpgradeRateModifier("CvPlayer::m_iImprovementUpgradeRateModifier", m_syncArchive)
	, m_iSpecialistProductionModifier("CvPlayer::m_iSpecialistProductionModifier", m_syncArchive)
	, m_iMilitaryProductionModifier("CvPlayer::m_iMilitaryProductionModifier", m_syncArchive)
	, m_iSpaceProductionModifier("CvPlayer::m_iSpaceProductionModifier", m_syncArchive)
	, m_iCityDefenseModifier("CvPlayer::m_iCityDefenseModifier", m_syncArchive)
	, m_iUnitFortificationModifier("CvPlayer::m_iUnitFortificationModifier", m_syncArchive)
	, m_iUnitBaseHealModifier("CvPlayer::m_iUnitBaseHealModifier", m_syncArchive)
	, m_iWonderProductionModifier("CvPlayer::m_iWonderProductionModifier", m_syncArchive)
	, m_iSettlerProductionModifier("CvPlayer::m_iSettlerProductionModifier", m_syncArchive)
	, m_iCapitalSettlerProductionModifier("CvPlayer::m_iCapitalSettlerProductionModifier", m_syncArchive)
	, m_iUnitProductionMaintenanceMod("CvPlayer::m_iUnitProductionMaintenanceMod", m_syncArchive)
	, m_iUnitGrowthMaintenanceMod("CvPlayer::m_iUnitGrowthMaintenanceMod", m_syncArchive)
	, m_iPolicyCostBuildingModifier("CvPlayer::m_iPolicyCostBuildingModifier", m_syncArchive)
	, m_iPolicyCostMinorCivModifier("CvPlayer::m_iPolicyCostMinorCivModifier", m_syncArchive)
	, m_iInfluenceSpreadModifier("CvPlayer::m_iInfluenceSpreadModifier", m_syncArchive)
	, m_iExtraVotesPerDiplomat("CvPlayer::m_iExtraVotesPerDiplomat", m_syncArchive)
	, m_iNumNukeUnits("CvPlayer::m_iNumNukeUnits", m_syncArchive)
	, m_iNumOutsideUnits("CvPlayer::m_iNumOutsideUnits", m_syncArchive, true)
	, m_iBaseFreeUnits("CvPlayer::m_iBaseFreeUnits", m_syncArchive)
	, m_iBaseFreeMilitaryUnits("CvPlayer::m_iBaseFreeMilitaryUnits", m_syncArchive)
	, m_iFreeUnitsPopulationPercent("CvPlayer::m_iFreeUnitsPopulationPercent", m_syncArchive)
	, m_iFreeMilitaryUnitsPopulationPercent("CvPlayer::m_iFreeMilitaryUnitsPopulationPercent", m_syncArchive)
	, m_iGoldPerUnit("CvPlayer::m_iGoldPerUnit", m_syncArchive)
	, m_iGoldPerMilitaryUnit("CvPlayer::m_iGoldPerMilitaryUnit", m_syncArchive)
	, m_iImprovementGoldMaintenanceMod("CvPlayer::m_iImprovementGoldMaintenanceMod", m_syncArchive)
#if defined(MOD_CIV6_WORKER)
	, m_iRouteBuilderCostMod("CvPlayer::m_iRouteBuilderCostMod", m_syncArchive)
#endif
	, m_iBuildingGoldMaintenanceMod("CvPlayer::m_iBuildingGoldMaintenanceMod", m_syncArchive)
	, m_iUnitGoldMaintenanceMod("CvPlayer::m_iUnitGoldMaintenanceMod", m_syncArchive)
	, m_iUnitSupplyMod("CvPlayer::m_iUnitSupplyMod", m_syncArchive)
	, m_iExtraUnitCost("CvPlayer::m_iExtraUnitCost", m_syncArchive)
	, m_iNumMilitaryUnits("CvPlayer::m_iNumMilitaryUnits", m_syncArchive)
	, m_iHappyPerMilitaryUnit("CvPlayer::m_iHappyPerMilitaryUnit", m_syncArchive)
	, m_iHappinessToCulture("CvPlayer::m_iHappinessToCulture", m_syncArchive)
	, m_iHappinessToScience("CvPlayer::m_iHappinessToScience", m_syncArchive)
	, m_iHalfSpecialistUnhappinessCount("CvPlayer::m_iHalfSpecialistUnhappinessCount", m_syncArchive)
	, m_iHalfSpecialistFoodCount("CvPlayer::m_iHalfSpecialistFoodCount", m_syncArchive)
	, m_iMilitaryFoodProductionCount("CvPlayer::m_iMilitaryFoodProductionCount", m_syncArchive)
	, m_iGoldenAgeCultureBonusDisabledCount("CvPlayer::m_iGoldenAgeCultureBonusDisabledCount", m_syncArchive)
	, m_iNumMissionarySpreads("CvPlayer::m_iNumMissionarySpreads", m_syncArchive)
	, m_iSecondReligionPantheonCount("CvPlayer::m_iSecondReligionPantheonCount", m_syncArchive)
	, m_iEnablesSSPartHurryCount("CvPlayer::m_iEnablesSSPartHurryCount", m_syncArchive)
	, m_iEnablesSSPartPurchaseCount("CvPlayer::m_iEnablesSSPartPurchaseCount", m_syncArchive)
	, m_iConscriptCount("CvPlayer::m_iConscriptCount", m_syncArchive)
	, m_iMaxConscript("CvPlayer::m_iMaxConscript", m_syncArchive)
	, m_iHighestUnitLevel("CvPlayer::m_iHighestUnitLevel", m_syncArchive)
	, m_iOverflowResearch("CvPlayer::m_iOverflowResearch", m_syncArchive, true)
	, m_iExpModifier("CvPlayer::m_iExpModifier", m_syncArchive)
	, m_iExpInBorderModifier("CvPlayer::m_iExpInBorderModifier", m_syncArchive)
	, m_iLevelExperienceModifier("CvPlayer::m_iLevelExperienceModifier", m_syncArchive)
	, m_iMinorQuestFriendshipMod("CvPlayer::m_iMinorQuestFriendshipMod", m_syncArchive)
	, m_iMinorGoldFriendshipMod("CvPlayer::m_iMinorGoldFriendshipMod", m_syncArchive)
	, m_iMinorFriendshipMinimum("CvPlayer::m_iMinorFriendshipMinimum", m_syncArchive)
	, m_iMinorFriendshipDecayMod("CvPlayer::m_iMinorFriendshipDecayMod", m_syncArchive)
	, m_iMinorScienceAlliesCount("CvPlayer::m_iMinorScienceAlliesCount", m_syncArchive)
	, m_iMinorResourceBonusCount("CvPlayer::m_iMinorResourceBonusCount", m_syncArchive)
	, m_iAbleToAnnexCityStatesCount("CvPlayer::m_iAbleToAnnexCityStatesCount", m_syncArchive)
	, m_iOnlyTradeSameIdeology("CvPlayer::m_iOnlyTradeSameIdeology", m_syncArchive)
	, m_iFreeSpecialist("CvPlayer::m_iFreeSpecialist", m_syncArchive)
	, m_iCultureBombTimer("CvPlayer::m_iCultureBombTimer", m_syncArchive)
	, m_iConversionTimer("CvPlayer::m_iConversionTimer", m_syncArchive)
	, m_iCapitalCityID("CvPlayer::m_iCapitalCityID", m_syncArchive)
	, m_iCitiesLost("CvPlayer::m_iCitiesLost", m_syncArchive)
	, m_iMilitaryMight("CvPlayer::m_iMilitaryMight", m_syncArchive)
	, m_iEconomicMight("CvPlayer::m_iEconomicMight", m_syncArchive)
	, m_iProductionMight("CvPlayer::m_iProductionMight", m_syncArchive)
	, m_iTurnMightRecomputed("CvPlayer::m_iTurnMightRecomputed", m_syncArchive)
	, m_iNewCityExtraPopulation("CvPlayer::m_iNewCityExtraPopulation", m_syncArchive)
	, m_iFreeFoodBox("CvPlayer::m_iFreeFoodBox", m_syncArchive)
	, m_iScenarioScore1("CvPlayer::m_iScenarioScore1", m_syncArchive)
	, m_iScenarioScore2("CvPlayer::m_iScenarioScore2", m_syncArchive)
	, m_iScenarioScore3("CvPlayer::m_iScenarioScore3", m_syncArchive)
	, m_iScenarioScore4("CvPlayer::m_iScenarioScore4", m_syncArchive)
	, m_iScoreFromFutureTech("CvPlayer::m_iScoreFromFutureTech", m_syncArchive)
	, m_iCombatExperience("CvPlayer::m_iCombatExperience", m_syncArchive)
	, m_iLifetimeCombatExperience("CvPlayer::m_iLifetimeCombatExperience", m_syncArchive)
	, m_iNavalCombatExperience("CvPlayer::m_iNavalCombatExperience", m_syncArchive)
#if defined(MOD_UNITS_XP_TIMES_100)
	, m_iCombatExperienceTimes100("CvPlayer::m_iCombatExperienceTimes100", m_syncArchive)
	, m_iLifetimeCombatExperienceTimes100("CvPlayer::m_iLifetimeCombatExperienceTimes100", m_syncArchive)
	, m_iNavalCombatExperienceTimes100("CvPlayer::m_iNavalCombatExperienceTimes100", m_syncArchive)
#endif
	, m_iBorderObstacleCount("CvPlayer::m_iBorderObstacleCount", m_syncArchive)
#if defined(HH_MOD_BUILDINGS_FRUITLESS_PILLAGE)
	, m_iBorderGainlessPillageCount("CvPlayer::m_iBorderGainlessPillageCount", m_syncArchive)
#endif
	, m_iPopRushHurryCount("CvPlayer::m_iPopRushHurryCount", m_syncArchive)
	, m_iTotalImprovementsBuilt("CvPlayer::m_iTotalImprovementsBuilt", m_syncArchive)
	, m_iNextOperationID("CvPlayer::m_iNextOperationID", m_syncArchive)
	, m_iCostNextPolicy("CvPlayer::m_iCostNextPolicy", m_syncArchive)
	, m_iNumBuilders("CvPlayer::m_iNumBuilders", m_syncArchive, true)
	, m_iMaxNumBuilders("CvPlayer::m_iMaxNumBuilders", m_syncArchive)
	, m_iCityStrengthMod("CvPlayer::m_iCityStrengthMod", m_syncArchive)
	, m_iCityGrowthMod("CvPlayer::m_iCityGrowthMod", m_syncArchive)
	, m_iCapitalGrowthMod("CvPlayer::m_iCapitalGrowthMod", m_syncArchive)
	, m_iNumPlotsBought("CvPlayer::m_iNumPlotsBought", m_syncArchive)
	, m_iPlotGoldCostMod("CvPlayer::m_iPlotGoldCostMod", m_syncArchive)
	, m_iPlotCultureCostModifier("CvPlayer::m_iPlotCultureCostModifier", m_syncArchive)
	, m_iPlotCultureExponentModifier("CvPlayer::m_iPlotCultureExponentModifier", m_syncArchive)
	, m_iNumCitiesPolicyCostDiscount("CvPlayer::m_iNumCitiesPolicyCostDiscount", m_syncArchive)
	, m_iGarrisonedCityRangeStrikeModifier("CvPlayer::m_iGarrisonedCityRangeStrikeModifier", m_syncArchive)
	, m_iGarrisonFreeMaintenanceCount("CvPlayer::m_iGarrisonFreeMaintenanceCount", m_syncArchive)
	, m_iNumCitiesFreeCultureBuilding("CvPlayer::m_iNumCitiesFreeCultureBuilding", m_syncArchive)
	, m_iNumCitiesFreeFoodBuilding("CvPlayer::m_iNumCitiesFreeFoodBuilding", m_syncArchive)
	, m_iUnitPurchaseCostModifier("CvPlayer::m_iUnitPurchaseCostModifier", m_syncArchive)
	, m_iAllFeatureProduction("CvPlayer::m_iAllFeatureProduction", m_syncArchive)
	, m_iCityDistanceHighwaterMark("CvPlayer::m_iCityDistanceHighwaterMark", m_syncArchive)
	, m_iOriginalCapitalX("CvPlayer::m_iOriginalCapitalX", m_syncArchive)
	, m_iOriginalCapitalY("CvPlayer::m_iOriginalCapitalY", m_syncArchive)
	, m_iHolyCityX("CvPlayer::m_iHolyCityX", m_syncArchive)
	, m_iHolyCityY("CvPlayer::m_iHolyCityY", m_syncArchive)
	, m_iNumWonders("CvPlayer::m_iNumWonders", m_syncArchive)
	, m_iNumPolicies("CvPlayer::m_iNumPolicies", m_syncArchive)
	, m_iNumGreatPeople("CvPlayer::m_iNumGreatPeople", m_syncArchive)
	, m_uiStartTime("CvPlayer::m_uiStartTime", m_syncArchive)  // XXX save these?
	, m_bHasUUPeriod("CvPlayer::m_bHasUUPeriod", m_syncArchive)
	, m_bHasBetrayedMinorCiv("CvPlayer::m_bHasBetrayedMinorCiv", m_syncArchive)
	, m_bAlive("CvPlayer::m_bAlive", m_syncArchive)
	, m_bEverAlive("CvPlayer::m_bEverAlive", m_syncArchive)
	, m_bPotentiallyAlive("CvPlayer::m_bPotentiallyAlive", m_syncArchive)
	, m_bBeingResurrected("CvPlayer::m_bBeingResurrected", m_syncArchive, false, false)
	, m_bTurnActive("CvPlayer::m_bTurnActive", m_syncArchive, false, true)
	, m_bAutoMoves("CvPlayer::m_bAutoMoves", m_syncArchive, false, true)
	, m_bEndTurn("CvPlayer::m_bEndTurn", m_syncArchive, false, true)
	, m_bDynamicTurnsSimultMode("CvPlayer::m_bDynamicTurnsSimultMode", m_syncArchive, true, false)
	, m_bPbemNewTurn("CvPlayer::m_bPbemNewTurn", m_syncArchive)
	, m_bExtendedGame("CvPlayer::m_bExtendedGame", m_syncArchive)
	, m_bFoundedFirstCity("CvPlayer::m_bFoundedFirstCity", m_syncArchive)
	, m_iNumCitiesFounded("CvPlayer::m_iNumCitiesFounded", m_syncArchive)
	, m_bStrike("CvPlayer::m_bStrike", m_syncArchive)
	, m_bCramped("CvPlayer::m_bCramped", m_syncArchive)
	, m_bLostCapital("CvPlayer::m_bLostCapital", m_syncArchive)
	, m_eConqueror("CvPlayer::m_eConqueror", m_syncArchive, NO_PLAYER)
	, m_bLostHolyCity("CvPlayer::m_bLostHolyCity", m_syncArchive)
	, m_eHolyCityConqueror("CvPlayer::m_eHolyCityConqueror", m_syncArchive, NO_PLAYER)
	, m_bHasAdoptedStateReligion("CvPlayer::m_bHasAdoptedStateReligion", m_syncArchive)
	, m_bAlliesGreatPersonBiasApplied("CvPlayer::m_bAlliesGreatPersonBiasApplied", m_syncArchive)
	, m_eID("CvPlayer::m_eID", m_syncArchive)
	, m_ePersonalityType("CvPlayer::m_ePersonalityType", m_syncArchive)
	, m_aiCityYieldChange("CvPlayer::m_aiCityYieldChange", m_syncArchive)
	, m_aiCoastalCityYieldChange("CvPlayer::m_aiCoastalCityYieldChange", m_syncArchive)
	, m_aiCapitalYieldChange("CvPlayer::m_aiCapitalYieldChange", m_syncArchive)
	, m_aiCapitalYieldPerPopChange("CvPlayer::m_aiCapitalYieldPerPopChange", m_syncArchive)
	, m_aiCapitalYieldPerPopChangeEmpire("CvPlayer::m_aiCapitalYieldPerPopChangeEmpire", m_syncArchive)
	, m_aiSeaPlotYield("CvPlayer::m_aiSeaPlotYield", m_syncArchive)
	, m_aiYieldRateModifier("CvPlayer::m_aiYieldRateModifier", m_syncArchive)
	, m_aiCapitalYieldRateModifier("CvPlayer::m_aiCapitalYieldRateModifier", m_syncArchive)
	, m_aiExtraYieldThreshold("CvPlayer::m_aiExtraYieldThreshold", m_syncArchive)
	, m_aiSpecialistExtraYield("CvPlayer::m_aiSpecialistExtraYield", m_syncArchive)
	, m_aiProximityToPlayer("CvPlayer::m_aiProximityToPlayer", m_syncArchive, true)
	, m_aiResearchAgreementCounter("CvPlayer::m_aiResearchAgreementCounter", m_syncArchive)
	, m_aiIncomingUnitTypes("CvPlayer::m_aiIncomingUnitTypes", m_syncArchive, true)
	, m_aiIncomingUnitCountdowns("CvPlayer::m_aiIncomingUnitCountdowns", m_syncArchive, true)
	, m_aiMinorFriendshipAnchors("CvPlayer::m_aiMinorFriendshipAnchors", m_syncArchive, true)
	, m_aiSiphonLuxuryCount("CvPlayer::m_aiSiphonLuxuryCount", m_syncArchive)
	, m_aiGreatWorkYieldChange("CvPlayer::m_aiGreatWorkYieldChange", m_syncArchive)
	, m_aOptions("CvPlayer::m_aOptions", m_syncArchive, true)
	, m_strReligionKey("CvPlayer::m_strReligionKey", m_syncArchive)
	, m_strScriptData("CvPlayer::m_strScriptData", m_syncArchive)
	, m_paiNumResourceUsed("CvPlayer::m_paiNumResourceUsed", m_syncArchive)
	, m_paiNumResourceTotal("CvPlayer::m_paiNumResourceTotal", m_syncArchive)
	, m_paiResourceGiftedToMinors("CvPlayer::m_paiResourceGiftedToMinors", m_syncArchive)
	, m_paiResourceExport("CvPlayer::m_paiResourceExport", m_syncArchive)
	, m_paiResourceImport("CvPlayer::m_paiResourceImport", m_syncArchive)
	, m_paiResourceFromMinors("CvPlayer::m_paiResourceFromMinors", m_syncArchive)
	, m_paiResourcesSiphoned("CvPlayer::m_paiResourcesSiphoned", m_syncArchive)
	, m_paiImprovementCount("CvPlayer::m_paiImprovementCount", m_syncArchive)
#if defined(MOD_BALANCE_CORE)
	, m_paiTotalImprovementsBuilt("CvPlayer::m_paiTotalImprovementsBuilt", m_syncArchive)
#endif
	, m_paiFreeBuildingCount("CvPlayer::m_paiFreeBuildingCount", m_syncArchive)
	, m_paiFreePromotionCount("CvPlayer::m_paiFreePromotionCount", m_syncArchive)
	, m_paiUnitCombatProductionModifiers("CvPlayer::m_paiUnitCombatProductionModifiers", m_syncArchive)
	, m_paiUnitCombatFreeExperiences("CvPlayer::m_paiUnitCombatFreeExperiences", m_syncArchive)
	, m_paiUnitClassCount("CvPlayer::m_paiUnitClassCount", m_syncArchive, true)
	, m_paiUnitClassMaking("CvPlayer::m_paiUnitClassMaking", m_syncArchive, true)
	, m_paiBuildingClassCount("CvPlayer::m_paiBuildingClassCount", m_syncArchive)
	, m_paiBuildingClassMaking("CvPlayer::m_paiBuildingClassMaking", m_syncArchive, true)
	, m_paiProjectMaking("CvPlayer::m_paiProjectMaking", m_syncArchive)
	, m_paiHurryCount("CvPlayer::m_paiHurryCount", m_syncArchive)
	, m_paiHurryModifier("CvPlayer::m_paiHurryModifier", m_syncArchive)
	, m_pabLoyalMember("CvPlayer::m_pabLoyalMember", m_syncArchive)
	, m_pabGetsScienceFromPlayer("CvPlayer::m_pabGetsScienceFromPlayer", m_syncArchive)
	, m_ppaaiSpecialistExtraYield("CvPlayer::m_ppaaiSpecialistExtraYield", m_syncArchive)
	, m_ppaaiImprovementYieldChange("CvPlayer::m_ppaaiImprovementYieldChange", m_syncArchive)
	, m_ppaaiBuildingClassYieldMod("CvPlayer::m_ppaaiBuildingClassYieldMod", m_syncArchive)
	, m_bEverPoppedGoody("CvPlayer::m_bEverPoppedGoody", m_syncArchive)
	, m_bEverTrainedBuilder("CvPlayer::m_bEverTrainedBuilder", m_syncArchive)
	, m_iCityConnectionHappiness("CvPlayer::m_iCityConnectionHappiness", m_syncArchive)
	, m_iHolyCityID("CvPlayer::m_iHolyCityID", m_syncArchive)
	, m_iTurnsSinceSettledLastCity("CvPlayer::m_iTurnsSinceSettledLastCity", m_syncArchive)
	, m_iNumNaturalWondersDiscoveredInArea("CvPlayer::m_iNumNaturalWondersDiscoveredInArea", m_syncArchive)
	, m_iStrategicResourceMod("CvPlayer::m_iStrategicResourceMod", m_syncArchive)
	, m_iSpecialistCultureChange("CvPlayer::m_iSpecialistCultureChange", m_syncArchive)
	, m_iGreatPeopleSpawnCounter("CvPlayer::m_iGreatPeopleSpawnCounter", m_syncArchive)
	, m_iFreeTechCount("CvPlayer::m_iFreeTechCount", m_syncArchive, true)
	, m_iMedianTechPercentage("CvPlayer::m_iMedianTechPercentage", m_syncArchive, 50)
	, m_iNumFreePolicies("CvPlayer::m_iNumFreePolicies", m_syncArchive)
	, m_iNumFreePoliciesEver("CvPlayer::m_iNumFreePoliciesEver", m_syncArchive)
	, m_iNumFreeTenets("CvPlayer::m_iNumFreeTenets", m_syncArchive)
	, m_iMaxEffectiveCities("CvPlayer::m_iMaxEffectiveCities", m_syncArchive, 1)
	, m_iLastSliceMoved("CvPlayer::m_iLastSliceMoved", m_syncArchive)
	, m_eEndTurnBlockingType(NO_ENDTURN_BLOCKING_TYPE)
	, m_iEndTurnBlockingNotificationIndex(0)
	, m_activeWaitingForEndTurnMessage(false)
	, m_endTurnBusyUnitUpdatesLeft(0)
	, m_lastGameTurnInitialAIProcessed(-1)
	, m_iNumFreeGreatPeople("CvPlayer::m_iNumFreeGreatPeople", m_syncArchive)
	, m_iNumMayaBoosts("CvPlayer::m_iNumMayaBoosts", m_syncArchive)
	, m_iNumFaithGreatPeople("CvPlayer::m_iNumFaithGreatPeople", m_syncArchive)
	, m_iNumArchaeologyChoices("CvPlayer::m_iNumArchaeologyChoices", m_syncArchive)
	, m_eFaithPurchaseType(NO_AUTOMATIC_FAITH_PURCHASE)
	, m_iFaithPurchaseIndex("CvPlayer::m_iFaithPurchaseIndex", m_syncArchive)
	, m_bProcessedAutoMoves(false)
	, m_kPlayerAchievements(*this)
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	, m_aiDomainDiversity("CvPlayer::m_aiDomainDiversity", m_syncArchive)
	, m_aiCityYieldModFromMonopoly("CvPlayer::m_aiCityYieldModFromMonopoly", m_syncArchive)
	, m_paiNumCivsConstructingWonder("CvPlayer::m_paiNumCivsConstructingWonder", m_syncArchive)
	, m_iUnhappiness("CvPlayer::m_iUnhappiness", m_syncArchive)
	, m_iHappinessTotal("CvPlayer::m_iHappinessTotal", m_syncArchive)
	, m_iChangePovertyUnhappinessGlobal("CvPlayer::m_iChangePovertyUnhappinessGlobal", m_syncArchive)
	, m_iChangeDefenseUnhappinessGlobal("CvPlayer::m_iChangeDefenseUnhappinessGlobal", m_syncArchive)
	, m_iChangeUnculturedUnhappinessGlobal("CvPlayer::m_iChangeUnculturedUnhappinessGlobal", m_syncArchive)
	, m_iChangeIlliteracyUnhappinessGlobal("CvPlayer::m_iChangeIlliteracyUnhappinessGlobal", m_syncArchive)
	, m_iChangeMinorityUnhappinessGlobal("CvPlayer::m_iChangeMinorityUnhappinessGlobal", m_syncArchive)
	, m_iLandmarksTourismPercentGlobal("CvPlayer::m_iLandmarksTourismPercentGlobal", m_syncArchive)
	, m_iGreatWorksTourismModifierGlobal("CvPlayer::m_iGreatWorksTourismModifierGlobal", m_syncArchive)
	, m_bAllowsProductionTradeRoutesGlobal("CvPlayer::m_bAllowsProductionTradeRoutesGlobal", m_syncArchive)
	, m_bAllowsFoodTradeRoutesGlobal("CvPlayer::m_bAllowsFoodTradeRoutesGlobal", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE)
	, m_iCenterOfMassX("CvPlayer::m_iCenterOfMassX", m_syncArchive)
	, m_iCenterOfMassY("CvPlayer::m_iCenterOfMassY", m_syncArchive)
	, m_iReferenceFoundValue("CvPlayer::m_iReferenceFoundValue", m_syncArchive)
	, m_iReformationFollowerReduction("CvPlayer::m_iReformationFollowerReduction", m_syncArchive)
	, m_bIsReformation("CvPlayer::m_bIsReformation", m_syncArchive)
	, m_iSupplyFreeUnits("CvPlayer::m_iFreeUnits", m_syncArchive)
	, m_viInstantYieldsTotal("CvPlayer::m_viInstantYieldsTotal", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE_POLICIES)
	, m_iHappinessPerXPopulationGlobal("CvPlayer::m_iHappinessPerXPopulationGlobal", m_syncArchive)
	, m_iIdeologyPoint("CvPlayer::m_iIdeologyPoint", m_syncArchive)
	, m_iNoXPLossUnitPurchase("CvPlayer::m_iNoXPLossUnitPurchase", m_syncArchive)
	, m_iXCSAlliesLowersPolicyNeedWonders("CvPlayer::m_iXCSAlliesLowersPolicyNeedWonders", m_syncArchive)
	, m_iHappinessFromMinorCivs("CvPlayer::m_iHappinessFromMinorCivs", m_syncArchive)
	, m_iPositiveWarScoreTourismMod("CvPlayer::m_iPositiveWarScoreTourismMod", m_syncArchive)
	, m_iIsNoCSDecayAtWar("CvPlayer::m_iIsNoCSDecayAtWar", m_syncArchive)
	, m_iCanBullyFriendlyCS("CvPlayer::m_iCanBullyFriendlyCS", m_syncArchive)
	, m_iBullyGlobalCSReduction("CvPlayer::m_iBullyGlobalCSReduction", m_syncArchive)
#endif
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	, m_iIsVassalsNoRebel("CvPlayer::m_iIsVassalsNoRebel", m_syncArchive)
	, m_iVassalCSBonusModifier("CvPlayer::m_iVassalCSBonusModifier", m_syncArchive)
#endif
#if defined(MOD_RELIGION_CONVERSION_MODIFIERS)
	, m_iConversionModifier("CvPlayer::m_iConversionModifier", m_syncArchive)
#endif
#if defined(MOD_DIPLOMACY_CITYSTATES)
	, m_iImprovementLeagueVotes("CvPlayer::m_iImprovementLeagueVotes", m_syncArchive)
	, m_iFaithToVotes("CvPlayer::m_iFaithToVotes", m_syncArchive)
	, m_iCapitalsToVotes("CvPlayer::m_iCapitalsToVotes", m_syncArchive)
	, m_iDoFToVotes("CvPlayer::m_iDoFToVotes", m_syncArchive)
	, m_iRAToVotes("CvPlayer::m_iRAToVotes", m_syncArchive)
	, m_iDefensePactsToVotes("CvPlayer::m_iDefensePactsToVotes", m_syncArchive)
	, m_iGPExpendInfluence("CvPlayer::m_iGPExpendInfluence", m_syncArchive)
	, m_bIsLeagueAid("CvPlayer::m_bIsLeagueAid", m_syncArchive)
	, m_bIsLeagueScholar("CvPlayer::m_bIsLeagueScholar", m_syncArchive)
	, m_bIsLeagueArt("CvPlayer::m_bIsLeagueArt", m_syncArchive)
	, m_iScienceRateFromLeague("CvPlayer::m_iScienceRateFromLeague", m_syncArchive)
	, m_iScienceRateFromLeagueAid("CvPlayer::m_iScienceRateFromLeagueAid", m_syncArchive)
	, m_iLeagueCultureCityModifier("CvPlayer::m_iLeagueCultureCityModifier", m_syncArchive)
#endif
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
	, m_iProductionBonusTurnsConquest("CvPlayer::m_iProductionBonusTurnsConquest", m_syncArchive)
	, m_iCultureBonusTurnsConquest("CvPlayer::m_iCultureBonusTurnsConquest", m_syncArchive)
	, m_iFreeGreatPeopleCreated("CvPlayer::m_iFreeGreatPeopleCreated", m_syncArchive)
	, m_iFreeGreatGeneralsCreated("CvPlayer::m_iFreeGreatGeneralsCreated", m_syncArchive)
	, m_iFreeGreatAdmiralsCreated("CvPlayer::m_iFreeGreatAdmiralsCreated", m_syncArchive)
#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
	, m_iFreeGreatMerchantsCreated("CvPlayer::m_iFreeGreatMerchantsCreated", m_syncArchive)
	, m_iFreeGreatScientistsCreated("CvPlayer::m_iFreeGreatScientistsCreated", m_syncArchive)
	, m_iFreeGreatEngineersCreated("CvPlayer::m_iFreeGreatEngineersCreated", m_syncArchive)
#endif
	, m_iFreeGreatWritersCreated("CvPlayer::m_iFreeGreatWritersCreated", m_syncArchive)
	, m_iFreeGreatArtistsCreated("CvPlayer::m_iFreeGreatArtistsCreated", m_syncArchive)
	, m_iFreeGreatMusiciansCreated("CvPlayer::m_iFreeGreatMusiciansCreated", m_syncArchive)
#if defined(MOD_DIPLOMACY_CITYSTATES)
	, m_iFreeGreatDiplomatsCreated("CvPlayer::m_iFreeGreatDiplomatsCreated", m_syncArchive)
#endif
#endif
#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
	, m_iGPExtra1Created("CvPlayer::m_iGPExtra1Created", m_syncArchive)
	, m_iGPExtra2Created("CvPlayer::m_iGPExtra2Created", m_syncArchive)
	, m_iGPExtra3Created("CvPlayer::m_iGPExtra3Created", m_syncArchive)
	, m_iGPExtra4Created("CvPlayer::m_iGPExtra4Created", m_syncArchive)
	, m_iGPExtra5Created("CvPlayer::m_iGPExtra5Created", m_syncArchive)
	, m_iGPExtra1FromFaith("CvPlayer::m_iGPExtra1FromFaith", m_syncArchive)
	, m_iGPExtra2FromFaith("CvPlayer::m_iGPExtra2FromFaith", m_syncArchive)
	, m_iGPExtra3FromFaith("CvPlayer::m_iGPExtra3FromFaith", m_syncArchive)
	, m_iGPExtra4FromFaith("CvPlayer::m_iGPExtra4FromFaith", m_syncArchive)
	, m_iGPExtra5FromFaith("CvPlayer::m_iGPExtra5FromFaith", m_syncArchive)
	, m_iFreeGPExtra1Created("CvPlayer::m_iFreeGPExtra1Created", m_syncArchive)
	, m_iFreeGPExtra2Created("CvPlayer::m_iFreeGPExtra2Created", m_syncArchive)
	, m_iFreeGPExtra3Created("CvPlayer::m_iFreeGPExtra3Created", m_syncArchive)
	, m_iFreeGPExtra4Created("CvPlayer::m_iFreeGPExtra4Created", m_syncArchive)
	, m_iFreeGPExtra5Created("CvPlayer::m_iFreeGPExtra5Created", m_syncArchive)
	, m_iGreatMerchantsCreated("CvPlayer::m_iGreatMerchantsCreated", m_syncArchive)
	, m_iGreatScientistsCreated("CvPlayer::m_iGreatScientistsCreated", m_syncArchive)
	, m_iGreatEngineersCreated("CvPlayer::m_iGreatEngineersCreated", m_syncArchive)
#endif
#if defined(MOD_DIPLOMACY_CITYSTATES)
	, m_iGreatDiplomatsCreated("CvPlayer::m_iGreatDiplomatsCreated", m_syncArchive)
	, m_iDiplomatsFromFaith("CvPlayer::m_iDiplomatsFromFaith", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE)
	, m_iHalfSpecialistFoodCapitalCount("CvPlayer::m_iHalfSpecialistFoodCapitalCount", m_syncArchive)
	, m_iTradeRouteLandDistanceModifier("CvPlayer::m_iTradeRouteLandDistanceModifier", m_syncArchive)
	, m_iTradeRouteSeaDistanceModifier("CvPlayer::m_iTradeRouteSeaDistanceModifier", m_syncArchive)
	, m_bNullifyInfluenceModifier("CvPlayer::m_bNullifyInfluenceModifier", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE)
	, m_aistrInstantYield("CvPlayer::m_aistrInstantYield", m_syncArchive)
	, m_aistrInstantGreatPersonProgress("CvPlayer::m_aistrInstantGreatPersonProgress", m_syncArchive)
	, m_iJFDCurrency("CvPlayer::m_iJFDCurrency", m_syncArchive)
	, m_iJFDProsperity("CvPlayer::m_iJFDProsperity", m_syncArchive)
	, m_strJFDCurrencyName("CvPlayer::m_strJFDCurrencyName", m_syncArchive)
	, m_strJFDLegislatureName("CvPlayer::m_strJFDLegislatureName", m_syncArchive)
	, m_strJFDPoliticKey("CvPlayer::m_strJFDPoliticKey", m_syncArchive)
	, m_iJFDPoliticLeader("CvPlayer::m_iJFDPoliticLeader", m_syncArchive)
	, m_iJFDSovereignty("CvPlayer::m_iJFDSovereignty", m_syncArchive)
	, m_iJFDGovernment("CvPlayer::m_iJFDGovernment", m_syncArchive)
	, m_iJFDReformCooldown("CvPlayer::m_iJFDReformCooldown", m_syncArchive)
	, m_iJFDGovernmentCooldown("CvPlayer::m_iJFDGovernmentCooldown", m_syncArchive)
	, m_iJFDReformCooldownRate("CvPlayer::m_iJFDReformCooldownRate", m_syncArchive)
	, m_iJFDGovernmentCooldownRate("CvPlayer::m_iJFDGovernmentCooldownRate", m_syncArchive)
	, m_iJFDPiety("CvPlayer::m_iJFDPiety", m_syncArchive)
	, m_iJFDPietyRate("CvPlayer::m_iJFDPietyRate", m_syncArchive)
	, m_iJFDConversionTurn("CvPlayer::m_iJFDConversionTurn", m_syncArchive)
	, m_bJFDSecularized("CvPlayer::m_bJFDSecularized", m_syncArchive)
	, m_abActiveContract("CvPlayer::m_abActiveContract", m_syncArchive)
	, m_iUpgradeCSVassalTerritory("CvPlayer::m_iUpgradeCSVassalTerritory", m_syncArchive)
	, m_iArchaeologicalDigTourism("CvPlayer::m_iArchaeologicalDigTourism", m_syncArchive)
	, m_iGoldenAgeTourism("CvPlayer::m_iGoldenAgeTourism", m_syncArchive)
	, m_iExtraCultureandScienceTradeRoutes("CvPlayer::m_iExtraCultureandScienceTradeRoutes", m_syncArchive)
	, m_iRazingSpeedBonus("CvPlayer::m_iRazingSpeedBonus", m_syncArchive)
	, m_iNoPartisans("CvPlayer::m_iNoPartisans", m_syncArchive)
	, m_iSpawnCooldown("CvPlayer::m_iSpawnCooldown", m_syncArchive)
	, m_iAbleToMarryCityStatesCount("CvPlayer::m_iAbleToMarryCityStatesCount", m_syncArchive)
	, m_bTradeRoutesInvulnerable("CvPlayer::m_bTradeRoutesInvulnerable", m_syncArchive)
	, m_iTRSpeedBoost("CvPlayer::m_iTRSpeedBoost", m_syncArchive)
	, m_iVotesPerGPT("CvPlayer::m_iVotesPerGPT", m_syncArchive)
	, m_iTRVisionBoost("CvPlayer::m_iTRVisionBoost", m_syncArchive)
	, m_iBuildingMaintenanceMod("CvPlayer::m_iBuildingMaintenanceMod", m_syncArchive)
	, m_iEventTourism("CvPlayer::m_iEventTourism", m_syncArchive)
	, m_iEventTourismCS("CvPlayer::m_iEventTourismCS", m_syncArchive)
	, m_iNumHistoricEvent("CvPlayer::m_iNumHistoricEvent", m_syncArchive)
	, m_iSingleVotes("CvPlayer::m_iSingleVotes", m_syncArchive)
	, m_iMonopolyModFlat("CvPlayer::m_iMonopolyModFlat", m_syncArchive)
	, m_iMonopolyModPercent("CvPlayer::m_iMonopolyModPercent", m_syncArchive)
	, m_iCachedValueOfPeaceWithHuman("CvPlayer::m_iCachedValueOfPeaceWithHuman", m_syncArchive)
	, m_iFaithPurchaseCooldown("CvPlayer::m_iFaithPurchaseCooldown", m_syncArchive)
	, m_iCSAllies("CvPlayer::m_iCSAllies", m_syncArchive)
	, m_iCSFriends("CvPlayer::m_iCSFriends", m_syncArchive)
	, m_iCitiesFeatureSurrounded("CvPlayer::m_iCitiesFeatureSurrounded", m_syncArchive)
	, m_aiBestMilitaryCombatClassCity("CvPlayer::m_aiBestMilitaryCombatClassCity", m_syncArchive)
	, m_aiBestMilitaryDomainCity("CvPlayer::m_aiBestMilitaryDomainCity", m_syncArchive)
	, m_aiEventChoiceDuration("CvPlayer::m_aiEventChoiceDuration", m_syncArchive)
	, m_aiEventIncrement("CvPlayer::m_aiEventIncrement", m_syncArchive)
	, m_abEventActive("CvPlayer::m_abEventActive", m_syncArchive)
	, m_abEventChoiceActive("CvPlayer::m_abEventChoiceActive", m_syncArchive)
	, m_aiEventCooldown("CvPlayer::m_aiEventCooldown", m_syncArchive)
	, m_abEventChoiceFired("CvPlayer::m_abEventChoiceFired", m_syncArchive)
	, m_abEventFired("CvPlayer::m_abEventFired", m_syncArchive)
	, m_iPlayerEventCooldown("CvPlayer::m_iPlayerEventCooldown", m_syncArchive)
	, m_abNWOwned("CvPlayer::m_abNWOwned", m_syncArchive)
	, m_paiUnitClassProductionModifiers("CvPlayer::m_paiUnitClassProductionModifiers", m_syncArchive)
	, m_iExtraSupplyPerPopulation("CvPlayer::m_iExtraSupplyPerPopulation", m_syncArchive)
	, m_iCitySupplyFlatGlobal("CvPlayer::m_iCitySupplyFlatGlobal", m_syncArchive)
	, m_iMissionaryExtraStrength("CvPlayer::m_iMissionaryExtraStrength", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	, m_iPovertyUnhappinessMod("CvPlayer::m_iPovertyUnhappinessMod", m_syncArchive)
	, m_iDefenseUnhappinessMod("CvPlayer::m_iDefenseUnhappinessMod", m_syncArchive)
	, m_iUnculturedUnhappinessMod("CvPlayer::m_iUnculturedUnhappinessMod", m_syncArchive)
	, m_iIlliteracyUnhappinessMod("CvPlayer::m_iIlliteracyUnhappinessMod", m_syncArchive)
	, m_iMinorityUnhappinessMod("CvPlayer::m_iMinorityUnhappinessMod", m_syncArchive)
	, m_iPovertyUnhappinessModCapital("CvPlayer::m_iPovertyUnhappinessModCapital", m_syncArchive)
	, m_iDefenseUnhappinessModCapital("CvPlayer::m_iDefenseUnhappinessModCapital", m_syncArchive)
	, m_iUnculturedUnhappinessModCapital("CvPlayer::m_iUnculturedUnhappinessModCapital", m_syncArchive)
	, m_iIlliteracyUnhappinessModCapital("CvPlayer::m_iIlliteracyUnhappinessModCapital", m_syncArchive)
	, m_iMinorityUnhappinessModCapital("CvPlayer::m_iMinorityUnhappinessModCapital", m_syncArchive)
	, m_iPuppetUnhappinessMod("CvPlayer::m_iPuppetUnhappinessMod", m_syncArchive)
	, m_iCapitalUnhappinessModCBP("CvPlayer::m_iCapitalUnhappinessModCBP", m_syncArchive)
	, m_iNoUnhappfromXSpecialists("CvPlayer::m_iNoUnhappfromXSpecialists", m_syncArchive)
	, m_iHappfromXSpecialists("CvPlayer::m_iHappfromXSpecialists", m_syncArchive)
	, m_iNoUnhappfromXSpecialistsCapital("CvPlayer::m_iNoUnhappfromXSpecialistsCapital", m_syncArchive)
	, m_iSpecialistFoodChange("CvPlayer::m_iSpecialistFoodChange", m_syncArchive)
	, m_iWarWearinessModifier("CvPlayer::m_iWarWearinessModifier", m_syncArchive)
	, m_iWarScoreModifier("CvPlayer::m_iWarScoreModifier", m_syncArchive)
#endif
#if defined(MOD_TRAITS_CITY_WORKING) || defined(MOD_BUILDINGS_CITY_WORKING) || defined(MOD_POLICIES_CITY_WORKING) || defined(MOD_TECHS_CITY_WORKING)
	, m_iCityWorkingChange("CvPlayer::m_iCityWorkingChange", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE_POLICIES)
	, m_paiJFDPoliticPercent("CvPlayer::m_paiJFDPoliticPercent", m_syncArchive)
	, m_paiResourceFromCSAlliances("CvPlayer::m_paiResourceFromCSAlliances", m_syncArchive)
	, m_paiResourceOverValue("CvPlayer::m_paiResourceOverValue", m_syncArchive)
	, m_aiGlobalTourismAlreadyReceived("CvPlayer::m_aiGlobalTourismAlreadyReceived", m_syncArchive)
	, m_aiYieldFromMinors("CvPlayer::m_aiYieldFromMinors", m_syncArchive)
	, m_aiYieldFromBirth("CvPlayer::m_aiYieldFromBirth", m_syncArchive)
	, m_aiYieldFromBirthCapital("CvPlayer::m_aiYieldFromBirthCapital", m_syncArchive)
	, m_aiYieldFromBirthRetroactive("CvPlayer::m_aiYieldFromBirthRetroactive", m_syncArchive)
	, m_aiYieldFromBirthCapitalRetroactive("CvPlayer::m_aiYieldFromBirthCapitalRetroactive", m_syncArchive)
	, m_aiYieldFromDeath("CvPlayer::m_aiYieldFromDeath", m_syncArchive)
	, m_aiYieldFromConstruction("CvPlayer::m_aiYieldFromConstruction", m_syncArchive)
	, m_aiYieldFromwonderConstruction("CvPlayer::m_aiYieldFromwonderConstruction", m_syncArchive)
	, m_aiYieldFromTech("CvPlayer::m_aiYieldFromTech", m_syncArchive)
	, m_aiYieldFromBorderGrowth("CvPlayer::m_aiYieldFromBorderGrowth", m_syncArchive)
	, m_aiYieldGPExpend("CvPlayer::m_aiYieldGPExpend", m_syncArchive)
	, m_aiConquerorYield("CvPlayer::m_aiConquerorYield", m_syncArchive)
	, m_aiFounderYield("CvPlayer::m_aiFounderYield", m_syncArchive)
	, m_aiArtifactYieldBonus("CvPlayer::m_aiArtifactYieldBonus", m_syncArchive)
	, m_aiArtYieldBonus("CvPlayer::m_aiArtYieldBonus", m_syncArchive)
	, m_aiMusicYieldBonus("CvPlayer::m_aiMusicYieldBonus", m_syncArchive)
	, m_aiLitYieldBonus("CvPlayer::m_aiLitYieldBonus", m_syncArchive)
	, m_aiFilmYieldBonus("CvPlayer::m_aiFilmYieldBonus", m_syncArchive)
	, m_aiRelicYieldBonus("CvPlayer::m_aiRelicYieldBonus", m_syncArchive)
	, m_aiReligionYieldRateModifier("CvPlayer::m_aiReligionYieldRateModifier", m_syncArchive)
	, m_aiGoldenAgeYieldMod("CvPlayer::m_aiGoldenAgeYieldMod", m_syncArchive)
	, m_aiYieldFromNonSpecialistCitizens("CvPlayer::m_aiYieldFromNonSpecialistCitizens", m_syncArchive)
	, m_aiYieldModifierFromGreatWorks("CvPlayer::m_aiYieldModifierFromGreatWorks", m_syncArchive)
	, m_aiYieldModifierFromActiveSpies("CvPlayer::m_aiYieldModifierFromActiveSpies", m_syncArchive)
	, m_aiYieldFromDelegateCount("CvPlayer::m_aiYieldFromDelegateCount", m_syncArchive)
	, m_paiBuildingClassCulture("CvPlayer::m_paiBuildingClassCulture", m_syncArchive)
	, m_aiDomainFreeExperiencePerGreatWorkGlobal("CvPlayer::m_aiDomainFreeExperiencePerGreatWorkGlobal", m_syncArchive)
	, m_iGarrisonsOccupiedUnhapppinessMod("CvPlayer::m_iGarrisonsOccupiedUnhapppinessMod", m_syncArchive)
	, m_iXPopulationConscription("CvPlayer::m_iXPopulationConscription", m_syncArchive)
	, m_iExtraMoves("CvPlayer::m_iExtraMoves", m_syncArchive)
	, m_iNoUnhappinessExpansion("CvPlayer::m_iNoUnhappinessExpansion", m_syncArchive)
	, m_iNoUnhappyIsolation("CvPlayer::m_iNoUnhappyIsolation", m_syncArchive)
	, m_iDoubleBorderGA("CvPlayer::m_iDoubleBorderGA", m_syncArchive)
	, m_iIncreasedQuestInfluence("CvPlayer::m_iIncreasedQuestInfluence", m_syncArchive)
	, m_iCultureBombBoost("CvPlayer::m_iCultureBombBoost", m_syncArchive)
	, m_iPuppetProdMod("CvPlayer::m_iPuppetProdMod", m_syncArchive)
	, m_iOccupiedProdMod("CvPlayer::m_iOccupiedProdMod", m_syncArchive)
	, m_iGoldInternalTrade("CvPlayer::m_iGoldInternalTrade", m_syncArchive)
	, m_iFreeWCVotes("CvPlayer::m_iFreeWCVotes", m_syncArchive)
	, m_iInfluenceGPExpend("CvPlayer::m_iInfluenceGPExpend", m_syncArchive)
	, m_iFreeTradeRoute("CvPlayer::m_iFreeTradeRoute", m_syncArchive)
	, m_iFreeSpy("CvPlayer::m_iFreeSpy", m_syncArchive)
	, m_iReligionDistance("CvPlayer::m_iReligionDistance", m_syncArchive)
	, m_iPressureMod("CvPlayer::m_iPressureMod", m_syncArchive)
	, m_iTradeReligionModifier("CvPlayer::m_iTradeReligionModifier", m_syncArchive)
	, m_iCityStateCombatModifier("CvPlayer::m_iCityStateCombatModifier", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE_SPIES)
	, m_iAdvancedActionGold("CvPlayer::m_iAdvancedActionGold", m_syncArchive)
	, m_iAdvancedActionScience("CvPlayer::m_iAdvancedActionScience", m_syncArchive)
	, m_iAdvancedActionUnrest("CvPlayer::m_iAdvancedActionUnrest", m_syncArchive)
	, m_iAdvancedActionRebellion("CvPlayer::m_iAdvancedActionRebellion", m_syncArchive)
	, m_iAdvancedActionGP("CvPlayer::m_iAdvancedActionGP", m_syncArchive)
	, m_iAdvancedActionUnit("CvPlayer::m_iAdvancedActionUnit", m_syncArchive)
	, m_iAdvancedActionWonder("CvPlayer::m_iAdvancedActionWonder", m_syncArchive)
	, m_iAdvancedActionBuilding("CvPlayer::m_iAdvancedActionBuilding", m_syncArchive)
	, m_iCannotFailSpies("CvPlayer::m_iCannotFailSpies", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE_BUILDING_INVESTMENTS)
	, m_iInvestmentModifier("CvPlayer::m_iInvestmentModifier", m_syncArchive)
	, m_iMissionInfluenceModifier("CvPlayer::m_iMissionInfluenceModifier", m_syncArchive)
	, m_iHappinessPerActiveTradeRoute("CvPlayer::m_iHappinessPerActiveTradeRoute", m_syncArchive)
	, m_iCSResourcesCountMonopolies("CvPlayer::m_iCSResourcesCountMonopolies", m_syncArchive)
	, m_iConquestPerEraBuildingProductionMod("CvPlayer::m_iConquestPerEraBuildingProductionMod", m_syncArchive)
	, m_iAdmiralLuxuryBonus("CvPlayer::m_iAdmiralLuxuryBonus", m_syncArchive)
	, m_iPuppetYieldPenaltyMod("CvPlayer::m_iPuppetYieldPenaltyMod", m_syncArchive)
	, m_iNeedsModifierFromAirUnits("CvPlayer::m_iNeedsModifierFromAirUnits", m_syncArchive)
	, m_iFlatDefenseFromAirUnits("CvPlayer::m_iFlatDefenseFromAirUnits", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE)
	, m_paiNumCitiesFreeChosenBuilding("CvPlayer::m_paiNumCitiesFreeChosenBuilding", m_syncArchive)
	, m_pabFreeChosenBuildingNewCity("CvPlayer::m_pabFreeChosenBuildingNewCity", m_syncArchive)
	, m_pabAllCityFreeBuilding("CvPlayer::m_pabAllCityFreeBuilding", m_syncArchive)
	, m_pabNewFoundCityFreeUnit("CvPlayer::m_pabNewFoundCityFreeUnit", m_syncArchive)
	, m_pabNewFoundCityFreeBuilding("CvPlayer::m_pabNewFoundCityFreeBuilding", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	, m_pabHasGlobalMonopoly("CvPlayer::m_pabHasGlobalMonopoly", m_syncArchive)
	, m_pabHasStrategicMonopoly("CvPlayer::m_pabHasStrategicMonopoly", m_syncArchive)
#endif
#if defined(MOD_API_UNIFIED_YIELDS)
	, m_piGoldenAgeGreatPersonRateModifier(NULL)
	, m_piYieldFromKills(NULL)
	, m_piYieldFromBarbarianKills(NULL)
	, m_piYieldChangeTradeRoute(NULL)
	, m_piYieldChangesNaturalWonder(NULL)
	, m_piYieldChangeWorldWonder(NULL)
	, m_piYieldFromMinorDemand(NULL)
	, m_piYieldFromWLTKD(NULL)
	, m_piCityFeatures(NULL)
	, m_piNumBuildings(NULL)
	, m_piNumBuildingsInPuppets(NULL)
	, m_ppiBuildingClassYieldChange("CvPlayer::m_ppiBuildingClassYieldChange", m_syncArchive)
#endif
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	, m_bVassalLevy("CvPlayer::m_bVassalLevy", m_syncArchive)
	, m_iVassalGoldMaintenanceMod("CvPlayer::m_iVassalGoldMaintenanceMod", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE_SETTLER)
	, m_iFoundValueOfCapital("CvPlayer::m_iFoundValueOfCapital", m_syncArchive)
#endif
#if defined(MOD_BALANCE_CORE_MILITARY)
	, m_iFractionOriginalCapitalsUnderControl("CvPlayer::m_iFractionOriginalCapitalsUnderControl", m_syncArchive)
	, m_iAvgUnitExp100("CvPlayer::m_iAvgUnitExp100", m_syncArchive)
#endif
#if defined(MOD_BATTLE_ROYALE)
	, m_iNumMilitarySeaUnits("CvPlayer::m_iNumMilitarySeaUnits", m_syncArchive)
	, m_iNumMilitaryAirUnits("CvPlayer::m_iNumMilitaryAirUnits", m_syncArchive)
	, m_iNumMilitaryLandUnits("CvPlayer::m_iNumMilitaryLandUnits", m_syncArchive)
	, m_iMilitarySeaMight("CvPlayer::m_iMilitarySeaMight", m_syncArchive)
	, m_iMilitaryAirMight("CvPlayer::m_iMilitaryAirMight", m_syncArchive)
	, m_iMilitaryLandMight("CvPlayer::m_iMilitaryLandMight", m_syncArchive)
#endif
{
	m_pPlayerPolicies = FNEW(CvPlayerPolicies, c_eCiv5GameplayDLL, 0);
	m_pEconomicAI = FNEW(CvEconomicAI, c_eCiv5GameplayDLL, 0);
	m_pMilitaryAI = FNEW(CvMilitaryAI, c_eCiv5GameplayDLL, 0);
	m_pCitySpecializationAI = FNEW(CvCitySpecializationAI, c_eCiv5GameplayDLL, 0);
	m_pWonderProductionAI = FNEW(CvWonderProductionAI(this, GC.GetGameBuildings()), c_eCiv5GameplayDLL, 0);
	m_pGrandStrategyAI = FNEW(CvGrandStrategyAI, c_eCiv5GameplayDLL, 0);
	m_pDiplomacyAI = FNEW(CvDiplomacyAI, c_eCiv5GameplayDLL, 0);
	m_pReligions = FNEW(CvPlayerReligions, c_eCiv5GameplayDLL, 0);
	m_pReligionAI = FNEW(CvReligionAI, c_eCiv5GameplayDLL, 0);
#if defined(MOD_BALANCE_CORE)
	m_pCorporations = FNEW(CvPlayerCorporations, c_eCiv5GameplayDLL, 0);
	m_pContracts = FNEW(CvPlayerContracts, c_eCiv5GameplayDLL, 0);
#endif
	m_pPlayerTechs = FNEW(CvPlayerTechs, c_eCiv5GameplayDLL, 0);
	m_pFlavorManager = FNEW(CvFlavorManager, c_eCiv5GameplayDLL, 0);
	m_pTacticalAI = FNEW(CvTacticalAI, c_eCiv5GameplayDLL, 0);
	m_pHomelandAI = FNEW(CvHomelandAI, c_eCiv5GameplayDLL, 0);
	m_pMinorCivAI = FNEW(CvMinorCivAI, c_eCiv5GameplayDLL, 0);
	m_pDealAI = FNEW(CvDealAI, c_eCiv5GameplayDLL, 0);
	m_pBuilderTaskingAI = FNEW(CvBuilderTaskingAI, c_eCiv5GameplayDLL, 0);
	m_pDangerPlots = FNEW(CvDangerPlots, c_eCiv5GameplayDLL, 0);
#if defined(MOD_BALANCE_CORE_SETTLER)
	m_pCityDistanceTurns = FNEW(CvDistanceMapTurns, c_eCiv5GameplayDLL, 0);
	m_pCityDistancePlots = FNEW(CvDistanceMapPlots, c_eCiv5GameplayDLL, 0);
#endif
	m_pCityConnections = FNEW(CvCityConnections, c_eCiv5GameplayDLL, 0);
	m_pTreasury = FNEW(CvTreasury, c_eCiv5GameplayDLL, 0);
	m_pTraits = FNEW(CvPlayerTraits, c_eCiv5GameplayDLL, 0);
	m_pEspionage = FNEW(CvPlayerEspionage, c_eCiv5GameplayDLL, 0);
	m_pEspionageAI = FNEW(CvEspionageAI, c_eCiv5GameplayDLL, 0);
	m_pTrade = FNEW(CvPlayerTrade, c_eCiv5GameplayDLL, 0);
	m_pTradeAI = FNEW(CvTradeAI, c_eCiv5GameplayDLL, 0);
	m_pLeagueAI = FNEW(CvLeagueAI, c_eCiv5GameplayDLL, 0);
	m_pCulture = FNEW(CvPlayerCulture, c_eCiv5GameplayDLL, 0);

	m_pNotifications = NULL;
	m_pDiplomacyRequests = NULL;

	m_iNextOperationID = 0;

	m_aiPlots.clear();
	m_bfEverConqueredBy.ClearAll();

	m_aiGreatWorkYieldChange.clear();
	m_aiSiphonLuxuryCount.clear();

	reset(NO_PLAYER, true);
}
//	--------------------------------------------------------------------------------
CvPlayer::~CvPlayer()
{
#if defined(MOD_BALANCE_CORE) && defined(MOD_UNIT_KILL_STATS)
	if (isMajorCiv() && GC.getAILogging())
		GC.getMap().ExportUnitKillCount(GetID());
#endif

	uninit();

	SAFE_DELETE(m_pDangerPlots);
#if defined(MOD_BALANCE_CORE_SETTLER)
	SAFE_DELETE(m_pCityDistanceTurns);
	SAFE_DELETE(m_pCityDistancePlots);
#endif
	SAFE_DELETE(m_pPlayerPolicies);
	SAFE_DELETE(m_pEconomicAI);
	SAFE_DELETE(m_pMilitaryAI);
	SAFE_DELETE(m_pCitySpecializationAI);
	SAFE_DELETE(m_pWonderProductionAI);
	SAFE_DELETE(m_pGrandStrategyAI);
	SAFE_DELETE(m_pDiplomacyAI);
	SAFE_DELETE(m_pReligions);
	SAFE_DELETE(m_pReligionAI);
	SAFE_DELETE(m_pPlayerTechs);
	SAFE_DELETE(m_pFlavorManager);
	SAFE_DELETE(m_pTacticalAI);
	SAFE_DELETE(m_pHomelandAI);
	SAFE_DELETE(m_pMinorCivAI);
	SAFE_DELETE(m_pDealAI);
	SAFE_DELETE(m_pBuilderTaskingAI);
	SAFE_DELETE(m_pCityConnections);
	SAFE_DELETE(m_pNotifications);
	SAFE_DELETE(m_pDiplomacyRequests);
	SAFE_DELETE(m_pTreasury);
	SAFE_DELETE(m_pTraits);
	SAFE_DELETE(m_pEspionage);
	SAFE_DELETE(m_pEspionageAI);
	SAFE_DELETE(m_pTrade);
	SAFE_DELETE(m_pTradeAI);
	SAFE_DELETE(m_pLeagueAI);
#if defined(MOD_BALANCE_CORE)
	SAFE_DELETE(m_pCorporations);
	SAFE_DELETE(m_pContracts);
#endif
}


//	--------------------------------------------------------------------------------
void CvPlayer::init(PlayerTypes eID)
{
	LeaderHeadTypes eBestPersonality;
	int iValue;
	int iBestValue;
	int iI, iJ;

	// only allocate notifications for civs that players can play as
	if(eID < MAX_MAJOR_CIVS)
	{
		if (!m_pNotifications)
			m_pNotifications = FNEW(CvNotifications, c_eCiv5GameplayDLL, 0);
		if (!m_pDiplomacyRequests)
			m_pDiplomacyRequests = FNEW(CvDiplomacyRequests, c_eCiv5GameplayDLL, 0);
	}

	//--------------------------------
	// Init saved data
	reset(eID);

	//--------------------------------
	// Init containers
	m_cities.RemoveAll();

	m_units.RemoveAll();

	m_armyAIs.RemoveAll();

	m_AIOperations.clear();

	//--------------------------------
	// Init non-saved data
	setupGraphical();

	//--------------------------------
	// Init other game data
	CvAssert(getTeam() != NO_TEAM);
	GET_TEAM(getTeam()).changeNumMembers(1);

	PlayerTypes p = GetID();
	SlotStatus s = CvPreGame::slotStatus(p);

#if defined(MOD_BALANCE_CORE)
	if (!GET_TEAM(getTeam()).addPlayer( GetID() ))
		GET_TEAM(getTeam()).changeNumMembers(-1);

	//minors can become free cities...but we have to make sure the UI can know this.
	if (eID >= MAX_MAJOR_CIVS && eID < MAX_CIV_PLAYERS && s == SS_CLOSED && CvPreGame::isMinorCiv(eID))
	{
		m_bPotentiallyAlive = true;
	}
#endif

	
	if((s == SS_TAKEN) || (s == SS_COMPUTER))
	{
		setAlive(true);

		if(GC.getGame().isOption(GAMEOPTION_RANDOM_PERSONALITIES))
		{
			if(!isBarbarian() && !isMinorCiv())
			{
				iBestValue = 0;
				eBestPersonality = NO_LEADER;

				for(iI = 0; iI < GC.getNumLeaderHeadInfos(); iI++)
				{
					if(iI != GC.getBARBARIAN_LEADER() && iI != GC.getMINOR_CIVILIZATION())
					{
						iValue = (1 + GC.getGame().getJonRandNum(10000, "Choosing Personality"));

						for(iJ = 0; iJ < MAX_CIV_PLAYERS; iJ++)
						{
							if(GET_PLAYER((PlayerTypes)iJ).isAlive())
							{
								if(GET_PLAYER((PlayerTypes)iJ).getPersonalityType() == ((LeaderHeadTypes)iI))
								{
									iValue /= 2;
								}
							}
						}

						if(iValue > iBestValue)
						{
							iBestValue = iValue;
							eBestPersonality = ((LeaderHeadTypes)iI);
						}
					}
				}

				if(eBestPersonality != NO_LEADER)
				{
					setPersonalityType(eBestPersonality);
				}
			}
		}

		CvAssert(m_pTraits);
		m_pTraits->InitPlayerTraits();

		// Special handling for the Polynesian trait's overriding of embarked unit graphics
		if(m_pTraits->IsEmbarkedAllWater())
		{
			SetEmbarkedGraphicOverride("ART_DEF_UNIT_U_POLYNESIAN_WAR_CANOE");
		}
		else if(m_pTraits->IsEmbarkedToLandFlatCost())
		{
			SetEmbarkedGraphicOverride("ART_DEF_UNIT_U_DANISH_LONGBOAT");
		}

		changeGoldPerUnitTimes100(GC.getINITIAL_GOLD_PER_UNIT_TIMES_100());

		ChangeMaxNumBuilders(GC.getDEFAULT_MAX_NUM_BUILDERS());

		changeLevelExperienceModifier(GetPlayerTraits()->GetLevelExperienceModifier());
		changeMaxGlobalBuildingProductionModifier(GetPlayerTraits()->GetMaxGlobalBuildingProductionModifier());
		changeMaxTeamBuildingProductionModifier(GetPlayerTraits()->GetMaxTeamBuildingProductionModifier());
		changeMaxPlayerBuildingProductionModifier(GetPlayerTraits()->GetMaxPlayerBuildingProductionModifier());
		ChangePlotGoldCostMod(GetPlayerTraits()->GetPlotBuyCostModifier());
#if defined(MOD_TRAITS_CITY_WORKING)
		ChangeCityWorkingChange(GetPlayerTraits()->GetCityWorkingChange());
#endif
		ChangePlotCultureCostModifier(GetPlayerTraits()->GetPlotCultureCostModifier());
		GetTreasury()->ChangeCityConnectionTradeRouteGoldChange(GetPlayerTraits()->GetCityConnectionTradeRouteChange());
		changeWonderProductionModifier(GetPlayerTraits()->GetWonderProductionModifier());
		ChangeImprovementGoldMaintenanceMod(GetPlayerTraits()->GetImprovementMaintenanceModifier());

		for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
		{
#if defined(MOD_BUGFIX_MINOR)
			ChangeCityYieldChangeTimes100((YieldTypes)iJ, 100 * GetPlayerTraits()->GetFreeCityYield((YieldTypes)iJ));
#else
			ChangeCityYieldChange((YieldTypes)iJ, 100 * GetPlayerTraits()->GetFreeCityYield((YieldTypes)iJ));
#endif
			changeYieldRateModifier((YieldTypes)iJ, GetPlayerTraits()->GetYieldRateModifier((YieldTypes)iJ));
		}

		recomputeGreatPeopleModifiers();

		for(iI = 0; iI < NUM_YIELD_TYPES; iI++)
		{
			updateExtraYieldThreshold((YieldTypes)iI);
		}
#if defined(MOD_BALANCE_CORE_SETTLER_ADVANCED)
		int iBuildingMid = 0;
		int iBuildingLate = 0;
#endif
#if defined(MOD_BALANCE_CORE)
		if(GetAdvancedActionGold() < 4)
		{
			changeAdvancedActionGold(4);
		}
		if(GetAdvancedActionScience() < 4)
		{
			changeAdvancedActionScience(4);
		}
		if(GetAdvancedActionUnrest() < 2)
		{
			changeAdvancedActionUnrest(2);
		}
		if(GetAdvancedActionRebellion() < 2)
		{
			changeAdvancedActionRebellion(2);
		}
		if(GetAdvancedActionGP() < 2)
		{
			changeAdvancedActionGP(2);
		}
		if(GetAdvancedActionWonder() < 2)
		{
			changeAdvancedActionWonder(2);
		}
		if(GetAdvancedActionBuilding() < 2)
		{
			changeAdvancedActionBuilding(2);
		}
		if(GetPlayerTraits()->GetEventTourismBoost() > 0)
		{
			ChangeEventTourism(GetPlayerTraits()->GetEventTourismBoost());
		}
		if(GetPlayerTraits()->GetStartingSpyRank() > 0)
		{
			ChangeStartingSpyRank(GetPlayerTraits()->GetStartingSpyRank());
		}
		if(GetPlayerTraits()->GetQuestYieldModifier() > 0)
		{
			ChangeIncreasedQuestInfluence(GetPlayerTraits()->GetQuestYieldModifier());
		}
#endif
		const CvCivilizationInfo& playerCivilizationInfo = getCivilizationInfo();
#if defined(MOD_BALANCE_CORE_SETTLER_ADVANCED)
		if(MOD_BALANCE_CORE_SETTLER_ADVANCED)
		{
			for(iI = 0; iI < GC.getNumUnitClassInfos(); ++iI)
			{
				const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
				CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
				if(pkUnitClassInfo != NULL)
				{
					const UnitTypes eUnit = ((UnitTypes)(playerCivilizationInfo.getCivilizationUnits(iI)));
					if(NO_UNIT != eUnit)
					{
						CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
						if(pkUnitInfo->IsFoodProduction() && (pkUnitInfo->IsFoundMid()))
						{
							for(int iJ = 0; iJ < GC.getNumBuildingClassInfos(); iJ++)
							{
								const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iJ);
								CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
								if(pkBuildingClassInfo)
								{
									const BuildingTypes eBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(iJ)));
									if(NO_BUILDING != eBuilding)
									{
										CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
										if(pkBuildingInfo)
										{
											if(pkUnitInfo->GetBuildOnFound(iJ))
											{
												iBuildingMid++;
											}
										}
									}
								}
							}
						}
						if(pkUnitInfo->IsFoodProduction() && (pkUnitInfo->IsFoundLate()))
						{
							for(int iJ = 0; iJ < GC.getNumBuildingClassInfos(); iJ++)
							{
								const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iJ);
								CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
								if(pkBuildingClassInfo)
								{
									const BuildingTypes eBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(iJ)));
									if(NO_BUILDING != eBuilding)
									{
										CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
										if(pkBuildingInfo)
										{
											if(pkUnitInfo->GetBuildOnFound(iJ))
											{
												iBuildingLate++;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
#endif
		for(iI = 0; iI < GC.getNumUnitClassInfos(); ++iI)
		{
			const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
			CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
			if(pkUnitClassInfo != NULL)
			{
				const UnitTypes eUnit = ((UnitTypes)(playerCivilizationInfo.getCivilizationUnits(iI)));
				if(NO_UNIT != eUnit)
				{
					CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
#if defined(MOD_BALANCE_CORE_SETTLER_ADVANCED)
					if(pkUnitInfo != NULL && pkUnitInfo->IsFoundLate())
					{
						if(iBuildingMid > 0 && pkUnitInfo->IsFoodProduction())
						{
							setUnitExtraCost(eUnitClass, (40 * iBuildingLate));
						}
					}
					else if(pkUnitInfo != NULL && pkUnitInfo->IsFoundMid())
					{
						if(iBuildingMid > 0 && pkUnitInfo->IsFoodProduction())
						{
							setUnitExtraCost(eUnitClass, (40 * iBuildingMid));
						}
					}
					else
#endif
					if(NULL != pkUnitInfo && pkUnitInfo->IsFound())
					{
						setUnitExtraCost(eUnitClass, getNewCityProductionValue());
					}
				}
			}
		}

		BuildingTypes eFreeBuilding = GetPlayerTraits()->GetFreeBuilding();
		if(eFreeBuilding != NO_BUILDING)
		{
#if defined(MOD_BALANCE_CORE)
			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eFreeBuilding);
			if(pkBuildingInfo)
			{
				int iNumBuilding = GetPlayerTraits()->GetNumFreeBuildings();
				if(iNumBuilding > 0)
				{
					ChangeNumCitiesFreeChosenBuilding((BuildingClassTypes)pkBuildingInfo->GetBuildingClassType(), iNumBuilding);
				}
				else
				{
					changeFreeBuildingCount(eFreeBuilding, 1);
				}
			}
#else
					changeFreeBuildingCount(eFreeBuilding, 1);
#endif
		}

		SetGreatGeneralCombatBonus(GC.getGREAT_GENERAL_STRENGTH_MOD());
	}
#if defined(MOD_BALANCE_CORE)
	if(MOD_BALANCE_CORE_SPIES_ADVANCED)
	{
		setAdvancedActionGold(16);
		setAdvancedActionScience(14);
		setAdvancedActionUnrest(6);
		setAdvancedActionRebellion(4);
		setAdvancedActionGP(8);
		setAdvancedActionUnit(10);
		setAdvancedActionWonder(2);
		setAdvancedActionBuilding(12);
	}
	GET_TEAM(getTeam()).DoUpdateBestRoute();
#endif

	m_aiPlots.clear();
	m_bfEverConqueredBy.ClearAll();

	AI_init();
}


//	--------------------------------------------------------------------------------
void CvPlayer::uninit()
{
	m_units.RemoveAll();
	m_cities.RemoveAll();

	m_paiNumResourceUsed.clear();
	m_paiNumResourceTotal.clear();
	m_paiResourceGiftedToMinors.clear();
	m_paiResourceExport.clear();
	m_paiResourceImport.clear();
	m_paiResourceFromMinors.clear();
	m_paiResourcesSiphoned.clear();
	m_paiImprovementCount.clear();
#if defined(MOD_BALANCE_CORE)
	m_paiTotalImprovementsBuilt.clear();
#endif
	m_paiFreeBuildingCount.clear();
	m_paiFreePromotionCount.clear();
	m_paiUnitCombatProductionModifiers.clear();
	m_paiUnitCombatFreeExperiences.clear();
	m_paiUnitClassCount.clear();
	m_paiUnitClassMaking.clear();
	m_paiBuildingClassCount.clear();
	m_paiBuildingClassMaking.clear();
	m_paiProjectMaking.clear();
	m_paiHurryCount.clear();
	m_paiHurryModifier.clear();
#if defined(MOD_BALANCE_CORE)
	m_paiNumCitiesFreeChosenBuilding.clear();
	m_aistrInstantYield.clear();
	m_aistrInstantGreatPersonProgress.clear();
	m_paiNumCivsConstructingWonder.clear();
	m_pabFreeChosenBuildingNewCity.clear();
	m_pabAllCityFreeBuilding.clear();
	m_pabNewFoundCityFreeUnit.clear();
	m_pabNewFoundCityFreeBuilding.clear();
#endif
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	m_pabHasGlobalMonopoly.clear();
	m_pabHasStrategicMonopoly.clear();
	m_vResourcesWGlobalMonopoly.clear();
	m_vResourcesWStrategicMonopoly.clear();
#endif
	m_pabLoyalMember.clear();
	m_pabGetsScienceFromPlayer.clear();

	m_pPlayerPolicies->Uninit();
	m_pEconomicAI->Uninit();
	m_pMilitaryAI->Uninit();
	m_pCitySpecializationAI->Uninit();
	m_pWonderProductionAI->Uninit();
	m_pGrandStrategyAI->Uninit();
	m_pDiplomacyAI->Uninit();
	m_pReligions->Uninit();
	m_pReligionAI->Uninit();
#if defined(MOD_BALANCE_CORE)
	m_pCorporations->Uninit();
	m_pContracts->Uninit();
#endif
	m_pEspionage->Uninit();
	m_pEspionageAI->Uninit();
	m_pTrade->Uninit();
	m_pTradeAI->Uninit();
	m_pLeagueAI->Uninit();
	m_pPlayerTechs->Uninit();
	m_pFlavorManager->Uninit();
	m_pTacticalAI->Uninit();
	m_pHomelandAI->Uninit();
	m_pMinorCivAI->Uninit();
	m_pDealAI->Uninit();
	m_pBuilderTaskingAI->Uninit();
	m_pCityConnections->Reset();
	if(m_pNotifications)
	{
		m_pNotifications->Uninit();
	}
	if(m_pDiplomacyRequests)
	{
		m_pDiplomacyRequests->Uninit();
	}
	m_pTreasury->Uninit();
	m_pTraits->Uninit();

	if(m_pDangerPlots)
	{
		m_pDangerPlots->Uninit();
	}

#if defined(MOD_BALANCE_CORE_SETTLER)
	m_pCityDistanceTurns->Reset();
	m_pCityDistancePlots->Reset();
#endif

	m_ppaaiSpecialistExtraYield.clear();
#if defined(MOD_API_UNIFIED_YIELDS) && defined(MOD_API_PLOT_YIELDS)
	m_ppiPlotYieldChange.clear();
#endif
#if defined(MOD_API_UNIFIED_YIELDS)
	m_ppiInstantYieldHistoryValues.clear();
	m_ppiImprovementYieldChange.clear();
	m_ppiFeatureYieldChange.clear();
	m_ppiResourceYieldChange.clear();
	m_ppiTerrainYieldChange.clear();
	m_ppiTradeRouteYieldChange.clear();
	m_ppiSpecialistYieldChange.clear();
	m_ppiGreatPersonExpendedYield.clear();
	m_piGoldenAgeGreatPersonRateModifier.clear();
	m_ppiUnimprovedFeatureYieldChange.clear();
	m_ppiCityYieldFromUnimprovedFeature.clear();
	m_piYieldFromKills.clear();
	m_piYieldFromBarbarianKills.clear();
	m_ppiBuildingClassYieldChange.clear();
	m_ppiApproachScratchValue.clear();
#endif
	m_ppaaiImprovementYieldChange.clear();
	m_ppaaiBuildingClassYieldMod.clear();

	m_researchQueue.clear();
	m_cityNames.clear();

	// loop through all entries freeing them up
	std::map<int , CvAIOperation*>::iterator iter;
	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
	{
		delete(iter->second);
	}
	m_AIOperations.clear();

	m_aiPlots.clear();
	m_bfEverConqueredBy.ClearAll();

	FAutoArchive& archive = getSyncArchive();
	archive.clearDelta();

	m_iStartingX = INVALID_PLOT_COORD;
	m_iStartingY = INVALID_PLOT_COORD;
	m_iTotalPopulation = 0;
	m_iTotalLand = 0;
	m_iTotalLandScored = 0;
	m_iCityConnectionHappiness = 0;
	m_iJONSCulturePerTurnForFree = 0;
	m_iJONSCulturePerTurnFromMinorCivs = 0;
	m_iJONSCultureCityModifier = 0;
	m_iJONSCulture = 0;
	m_iJONSCultureEverGenerated = 0;
	m_iCulturePerWonder = 0;
	m_iCultureWonderMultiplier = 0;
	m_iCulturePerTechResearched = 0;
	m_iFaith = 0;
	m_iFaithEverGenerated = 0;
	m_iHappiness = 0;
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	m_iUnhappiness = 0;
	m_iHappinessTotal = 0;
	m_iChangePovertyUnhappinessGlobal = 0;
	m_iChangeDefenseUnhappinessGlobal = 0;
	m_iChangeUnculturedUnhappinessGlobal = 0;
	m_iChangeIlliteracyUnhappinessGlobal = 0;
	m_iChangeMinorityUnhappinessGlobal = 0;
	m_iLandmarksTourismPercentGlobal = 0;
	m_iGreatWorksTourismModifierGlobal = 0;
#endif
#if defined(MOD_BALANCE_CORE)
	m_iCenterOfMassX = 0;
	m_iCenterOfMassY = 0;
	m_iReferenceFoundValue = 50000;
	m_iReformationFollowerReduction = 0;
	m_bIsReformation = false;
#endif
	m_iUprisingCounter = 0;
	m_iExtraHappinessPerLuxury = 0;
	m_iUnhappinessFromUnits = 0;
	m_iUnhappinessFromUnitsMod = 0;
	m_iUnhappinessMod = 0;
	m_iCityCountUnhappinessMod = 0;
	m_iOccupiedPopulationUnhappinessMod = 0;
	m_iCapitalUnhappinessMod = 0;
	m_iCityRevoltCounter = 0;
	m_iHappinessPerGarrisonedUnitCount = 0;
	m_iHappinessPerTradeRouteCount = 0;
	m_iHappinessPerXPopulation = 0;
#if defined(MOD_BALANCE_CORE_POLICIES)
	m_iHappinessPerXPopulationGlobal = 0;
	m_iIdeologyPoint = 0;
	m_iNoXPLossUnitPurchase = 0;
	m_iXCSAlliesLowersPolicyNeedWonders = 0;
	m_iHappinessFromMinorCivs = 0;
	m_iPositiveWarScoreTourismMod = 0;
	m_iIsNoCSDecayAtWar = 0;
	m_iCanBullyFriendlyCS = 0;
	m_iBullyGlobalCSReduction = 0;
#endif
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	m_iIsVassalsNoRebel = 0;
	m_iVassalCSBonusModifier = 0;
#endif
	m_iHappinessFromLeagues = 0;
	m_iEspionageModifier = 0;
	m_iSpyStartingRank = 0;
#if defined(MOD_RELIGION_CONVERSION_MODIFIERS)
	m_iConversionModifier = 0;
#endif
	m_iExtraLeagueVotes = 0;
#if defined(MOD_DIPLOMACY_CITYSTATES)
	m_iImprovementLeagueVotes = 0;
	m_iFaithToVotes = 0;
	m_iCapitalsToVotes = 0;
	m_iDoFToVotes = 0;
	m_iRAToVotes = 0;
	m_iDefensePactsToVotes = 0;
	m_iGPExpendInfluence = 0;
	m_bIsLeagueAid = false;
	m_bIsLeagueScholar = false;
	m_bIsLeagueArt = false;
	m_iScienceRateFromLeague = 0;
	m_iScienceRateFromLeagueAid = 0;
	m_iLeagueCultureCityModifier = 0;
#endif
	m_iSpecialPolicyBuildingHappiness = 0;
	m_iWoundedUnitDamageMod = 0;
	m_iUnitUpgradeCostMod = 0;
	m_iBarbarianCombatBonus = 0;
	m_iAlwaysSeeBarbCampsCount = 0;
	m_iHappinessFromBuildings = 0;
	m_iHappinessPerCity = 0;
	m_iHappinessPerXPolicies = 0;
	m_iExtraHappinessPerXPoliciesFromPolicies = 0;
	m_iHappinessPerXGreatWorks = 0;
	m_iAdvancedStartPoints = -1;
	m_iAttackBonusTurns = 0;
	m_iCultureBonusTurns = 0;
	m_iTourismBonusTurns = 0;
	m_iGoldenAgeProgressMeter = 0;
	m_iGoldenAgeMeterMod = 0;
	m_iNumGoldenAges = 0;
	m_iGoldenAgeTurns = 0;
	m_iNumUnitGoldenAges = 0;
	m_iStrikeTurns = 0;
	m_iGoldenAgeModifier = 0;
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
	m_iProductionBonusTurnsConquest = 0;
	m_iCultureBonusTurnsConquest = 0;
	m_iFreeGreatPeopleCreated = 0;
	m_iFreeGreatGeneralsCreated = 0;
	m_iFreeGreatAdmiralsCreated = 0;
#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
	m_iFreeGreatMerchantsCreated = 0;
	m_iFreeGreatScientistsCreated = 0;
	m_iFreeGreatEngineersCreated = 0;
#endif
	m_iFreeGreatWritersCreated = 0;
	m_iFreeGreatArtistsCreated = 0;
	m_iFreeGreatMusiciansCreated = 0;
#if defined(MOD_DIPLOMACY_CITYSTATES)
	m_iFreeGreatDiplomatsCreated = 0;
#endif
#endif
	m_iGreatPeopleCreated = 0;
	m_iGreatGeneralsCreated = 0;
	m_iGreatAdmiralsCreated = 0;
#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
	m_iGPExtra1Created = 0;
	m_iGPExtra2Created = 0;
	m_iGPExtra3Created = 0;
	m_iGPExtra4Created = 0;
	m_iGPExtra5Created = 0;
	m_iFreeGPExtra1Created = 0;
	m_iFreeGPExtra2Created = 0;
	m_iFreeGPExtra3Created = 0;
	m_iFreeGPExtra4Created = 0;
	m_iFreeGPExtra5Created = 0;
	m_iGPExtra1FromFaith = 0;
	m_iGPExtra2FromFaith = 0;
	m_iGPExtra3FromFaith = 0;
	m_iGPExtra4FromFaith = 0;
	m_iGPExtra5FromFaith = 0;
	m_iGreatMerchantsCreated = 0;
	m_iGreatScientistsCreated = 0;
	m_iGreatEngineersCreated = 0;
#endif
	m_iGreatWritersCreated = 0;
	m_iGreatArtistsCreated = 0;
	m_iGreatMusiciansCreated = 0;
#if defined(MOD_DIPLOMACY_CITYSTATES)
	m_iGreatDiplomatsCreated = 0;
	m_iDiplomatsFromFaith = 0;
#endif
	m_iMerchantsFromFaith = 0;
	m_iScientistsFromFaith = 0;
	m_iWritersFromFaith = 0;
	m_iArtistsFromFaith = 0;
	m_iMusiciansFromFaith = 0;
	m_iGeneralsFromFaith = 0;
	m_iAdmiralsFromFaith = 0;
	m_iEngineersFromFaith = 0;
	m_iGreatPeopleThresholdModifier = 0;
	m_iGreatGeneralsThresholdModifier = 0;
	m_iGreatAdmiralsThresholdModifier = 0;
	m_iGreatGeneralCombatBonus = 0;
	m_iAnarchyNumTurns = 0;
	m_iPolicyCostModifier = 0;
	m_iGreatPeopleRateModifier = 0;
	m_iGreatPeopleRateModFromBldgs = 0;
	m_iGreatGeneralRateModifier = 0;
	m_iGreatGeneralRateModFromBldgs = 0;
	m_iDomesticGreatGeneralRateModifier = 0;
	m_iDomesticGreatGeneralRateModFromBldgs = 0;
	m_iGreatAdmiralRateModifier = 0;
	m_iGreatWriterRateModifier = 0;
	m_iGreatArtistRateModifier = 0;
	m_iGreatMusicianRateModifier = 0;
	m_iGreatMerchantRateModifier = 0;
#if defined(MOD_DIPLOMACY_CITYSTATES)
	m_iGreatDiplomatRateModifier = 0;
#endif
	m_iGreatScientistRateModifier = 0;
	m_iGreatScientistBeakerModifier = 0;
	m_iGreatEngineerHurryMod = 0;
	m_iTechCostXCitiesModifier = 0;
	m_iTourismCostXCitiesMod = 0;
	m_iGreatEngineerRateModifier = 0;
	m_iGreatPersonExpendGold = 0;
	m_iMaxGlobalBuildingProductionModifier = 0;
	m_iMaxTeamBuildingProductionModifier = 0;
	m_iMaxPlayerBuildingProductionModifier = 0;
	m_iFreeExperience = 0;
	m_iFreeExperienceFromBldgs = 0;
	m_iFreeExperienceFromMinors = 0;
	m_iFeatureProductionModifier = 0;
	m_iWorkerSpeedModifier = 0;
	m_iImprovementCostModifier = 0;
	m_iImprovementUpgradeRateModifier = 0;
	m_iSpecialistProductionModifier = 0;
	m_iMilitaryProductionModifier = 0;
	m_iSpaceProductionModifier = 0;
	m_iCityDefenseModifier = 0;
	m_iUnitFortificationModifier = 0;
	m_iUnitBaseHealModifier = 0;
	m_iWonderProductionModifier = 0;
	m_iSettlerProductionModifier = 0;
	m_iCapitalSettlerProductionModifier = 0;
	m_iUnitProductionMaintenanceMod = 0;
	m_iUnitGrowthMaintenanceMod = 0;
	m_iPolicyCostBuildingModifier = 0;
	m_iPolicyCostMinorCivModifier = 0;
	m_iInfluenceSpreadModifier = 0;
	m_iExtraVotesPerDiplomat = 0;
	m_iNumNukeUnits = 0;
	m_iNumOutsideUnits = 0;
	m_iBaseFreeUnits = 0;
	m_iBaseFreeMilitaryUnits = 0;
	m_iFreeUnitsPopulationPercent = 0;
	m_iFreeMilitaryUnitsPopulationPercent = 0;
	m_iGoldPerUnit = 0;
	m_iGoldPerMilitaryUnit = 0;
	m_iImprovementGoldMaintenanceMod = 0;
#if defined(MOD_CIV6_WORKER)
	m_iRouteBuilderCostMod = 0;
#endif
	m_iBuildingGoldMaintenanceMod = 0;
	m_iUnitGoldMaintenanceMod = 0;
	m_iUnitSupplyMod = 0;
	m_iExtraUnitCost = 0;
	m_iNumMilitaryUnits = 0;
	m_iHappyPerMilitaryUnit = 0;
	m_iHappinessToCulture = 0;
	m_iHappinessToScience = 0;
	m_iHalfSpecialistUnhappinessCount = 0;
	m_iHalfSpecialistFoodCount = 0;
#if defined(MOD_BALANCE_CORE)
	m_iHalfSpecialistFoodCapitalCount = 0;
	m_iTradeRouteLandDistanceModifier = 0;
	m_iTradeRouteSeaDistanceModifier = 0;
	m_bNullifyInfluenceModifier = false;
#endif
	m_iMilitaryFoodProductionCount = 0;
	m_iGoldenAgeCultureBonusDisabledCount = 0;
	m_iNumMissionarySpreads = 0;
	m_iSecondReligionPantheonCount = 0;
	m_iEnablesSSPartHurryCount = 0;
	m_iEnablesSSPartPurchaseCount = 0;
	m_iConscriptCount = 0;
	m_iMaxConscript = 0;
	m_iHighestUnitLevel = 1;
	m_iOverflowResearch = 0;
	m_iExpModifier = 0;
	m_iExpInBorderModifier = 0;
	m_iLevelExperienceModifier = 0;
	m_iMinorQuestFriendshipMod = 0;
	m_iMinorGoldFriendshipMod = 0;
	m_iMinorFriendshipMinimum = 0;
	m_iMinorFriendshipDecayMod = 0;
	m_iMinorScienceAlliesCount = 0;
	m_iMinorResourceBonusCount = 0;
	m_iAbleToAnnexCityStatesCount = 0;
	m_iOnlyTradeSameIdeology = 0;
#if defined(MOD_BALANCE_CORE)
	m_iSupplyFreeUnits = 0;
	m_strJFDCurrencyName = "";
	m_iJFDCurrency = -1;
	m_iJFDProsperity = 0;
	m_strJFDLegislatureName = "";
	m_strJFDPoliticKey = "";
	m_iJFDPoliticLeader = 0;
	m_iJFDSovereignty = 0;
	m_iJFDGovernment = -1;
	m_iJFDReformCooldown = 0;
	m_iJFDGovernmentCooldown = 0;
	m_iJFDGovernmentCooldownRate = 0;
	m_iJFDReformCooldownRate = 0;
	m_iJFDPiety = 0;
	m_iJFDPietyRate = 0;
	m_iJFDConversionTurn = 0;
	m_bJFDSecularized = false;
	m_iUpgradeCSVassalTerritory = 0;
	m_iArchaeologicalDigTourism = 0;
	m_iGoldenAgeTourism = 0;
	m_iExtraCultureandScienceTradeRoutes = 0;
	m_iRazingSpeedBonus = 0;
	m_iNoPartisans = 0;
	m_iSpawnCooldown = 0;
	m_iAbleToMarryCityStatesCount = 0;
	m_bTradeRoutesInvulnerable = false;
	m_iTRSpeedBoost = 0;
	m_iVotesPerGPT = 0;
	m_iTRVisionBoost = 0;
	m_iBuildingMaintenanceMod = 0;
	m_iEventTourism = 0;
	m_iEventTourismCS = 0;
	m_iNumHistoricEvent = 0;
	m_iSingleVotes = 0;
	m_iMonopolyModFlat = 0;
	m_iMonopolyModPercent = 0;
	m_iCachedValueOfPeaceWithHuman = 0;
	m_iFaithPurchaseCooldown = 0;
	m_iCSAllies = 0;
	m_iCSFriends = 0;
	m_iCitiesFeatureSurrounded = 0;
#endif
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	m_iPovertyUnhappinessMod = 0;
	m_iDefenseUnhappinessMod = 0;
	m_iUnculturedUnhappinessMod = 0;
	m_iIlliteracyUnhappinessMod = 0;
	m_iMinorityUnhappinessMod = 0;
	m_iPovertyUnhappinessModCapital = 0;
	m_iDefenseUnhappinessModCapital = 0;
	m_iUnculturedUnhappinessModCapital = 0;
	m_iIlliteracyUnhappinessModCapital = 0;
	m_iMinorityUnhappinessModCapital = 0;
	m_iPuppetUnhappinessMod = 0;
	m_iCapitalUnhappinessModCBP = 0;
	m_iNoUnhappfromXSpecialists = 0;
	m_iHappfromXSpecialists = 0;
	m_iNoUnhappfromXSpecialistsCapital = 0;
	m_iSpecialistFoodChange = 0;
	m_iWarWearinessModifier = 0;
	m_iWarScoreModifier = 0;
	m_iPlayerEventCooldown = 0;
	m_iExtraSupplyPerPopulation = 0;
	m_iCitySupplyFlatGlobal = 0;
	m_iMissionaryExtraStrength = 0;
#endif
#if defined(MOD_BALANCE_CORE_POLICIES)
	m_iGarrisonsOccupiedUnhapppinessMod = 0;
	m_iXPopulationConscription = 0;
	m_iExtraMoves = 0;
	m_iNoUnhappinessExpansion = 0;
	m_iNoUnhappyIsolation = 0;
	m_iDoubleBorderGA = 0;
	m_iIncreasedQuestInfluence = 0;
	m_iCultureBombBoost = 0;
	m_iPuppetProdMod = 0;
	m_iOccupiedProdMod = 0;
	m_iGoldInternalTrade = 0;
	m_iFreeWCVotes = 0;
	m_iInfluenceGPExpend = 0;
	m_iFreeTradeRoute = 0;
	m_iFreeSpy = 0;
	m_iReligionDistance = 0;
	m_iPressureMod = 0;
	m_iTradeReligionModifier = 0;
	m_iCityStateCombatModifier = 0;
#endif
#if defined(MOD_BALANCE_CORE_SPIES)
	m_iAdvancedActionGold = 0;
	m_iAdvancedActionScience = 0;
	m_iAdvancedActionUnrest = 0;
	m_iAdvancedActionRebellion = 0;
	m_iAdvancedActionGP = 0;
	m_iAdvancedActionUnit = 0;
	m_iAdvancedActionWonder = 0;
	m_iAdvancedActionBuilding = 0;
	m_iCannotFailSpies = 0;
#endif
#if defined(MOD_BALANCE_CORE_BUILDING_INVESTMENTS)
	m_iInvestmentModifier = 0;
	m_bAllowsProductionTradeRoutesGlobal = false;
	m_bAllowsFoodTradeRoutesGlobal = false;
	m_iMissionInfluenceModifier = 0;
	m_iHappinessPerActiveTradeRoute = 0;
	m_iCSResourcesCountMonopolies = 0;
	m_iConquestPerEraBuildingProductionMod = 0;
	m_iAdmiralLuxuryBonus = 0;
	m_iPuppetYieldPenaltyMod = 0;
	m_iNeedsModifierFromAirUnits = 0;
	m_iFlatDefenseFromAirUnits = 0;
#endif
	m_iCultureBombTimer = 0;
	m_iConversionTimer = 0;
	m_iCapitalCityID = -1;
	m_iCitiesLost = 0;
	m_iMilitaryMight = 0;
	m_iEconomicMight = 0;
	m_iProductionMight = 0;
	m_iTurnMightRecomputed = -1;
	m_iNewCityExtraPopulation = 0;
	m_iFreeFoodBox = 0;
	m_iScenarioScore1 = 0;
	m_iScenarioScore2 = 0;
	m_iScenarioScore3 = 0;
	m_iScenarioScore4 = 0;
	m_iScoreFromFutureTech = 0;
	m_iCombatExperience = 0;
	m_iLifetimeCombatExperience = 0;
	m_iNavalCombatExperience = 0;
#if defined(MOD_UNITS_XP_TIMES_100)
	m_iCombatExperienceTimes100 = 0;
	m_iLifetimeCombatExperienceTimes100 = 0;
	m_iNavalCombatExperienceTimes100 = 0;
#endif
	m_iBorderObstacleCount = 0;
#if defined(HH_MOD_BUILDINGS_FRUITLESS_PILLAGE)
	m_iBorderGainlessPillageCount = 0;
#endif
	m_iPopRushHurryCount = 0;
	m_uiStartTime = 0;
	m_bHasUUPeriod = false;
	m_iTotalImprovementsBuilt = 0;
	m_iNextOperationID = 0;
	m_iCostNextPolicy = 0;
	m_iNumBuilders = 0;
	m_iMaxNumBuilders = 0;
	m_iCityStrengthMod = 0;
	m_iCityGrowthMod = 0;
	m_iCapitalGrowthMod = 0;
	m_iNumPlotsBought = 0;
	m_iPlotGoldCostMod = 0;
#if defined(MOD_TRAITS_CITY_WORKING) || defined(MOD_BUILDINGS_CITY_WORKING) || defined(MOD_POLICIES_CITY_WORKING) || defined(MOD_TECHS_CITY_WORKING)
	m_iCityWorkingChange = 0;
#endif
	m_iPlotCultureCostModifier = 0;
	m_iPlotCultureExponentModifier = 0;
	m_iNumCitiesPolicyCostDiscount = 0;
	m_iGarrisonedCityRangeStrikeModifier = 0;
	m_iGarrisonFreeMaintenanceCount = 0;
	m_iNumCitiesFreeCultureBuilding = 0;
	m_iNumCitiesFreeFoodBuilding = 0;
	m_iUnitPurchaseCostModifier = 0;
	m_iAllFeatureProduction = 0;
	m_iCityDistanceHighwaterMark = 1;
	m_iOriginalCapitalX = -1;
	m_iOriginalCapitalY = -1;
	m_iHolyCityX = -1;
	m_iHolyCityY = -1;
	m_iNumWonders = 0;
	m_iNumPolicies = 0;
	m_iNumGreatPeople = 0;
	m_iHolyCityID = -1;
	m_iTurnsSinceSettledLastCity = -1;
	m_iNumNaturalWondersDiscoveredInArea = 0;
	m_iStrategicResourceMod = 0;
	m_iSpecialistCultureChange = 0;
	m_iGreatPeopleSpawnCounter = 0;
	m_iFreeTechCount = 0;
	m_iMedianTechPercentage = 50;
	m_iNumFreePolicies = 0;
	m_iNumFreePoliciesEver = 0;
	m_iNumFreeTenets = 0;
	m_iNumFreeGreatPeople = 0;
	m_iNumMayaBoosts = 0;
	m_iNumFaithGreatPeople = 0;
	m_iNumArchaeologyChoices = 0;
	m_eFaithPurchaseType = NO_AUTOMATIC_FAITH_PURCHASE;
	m_iFaithPurchaseIndex = 0;
	m_iMaxEffectiveCities = 1;
	m_iLastSliceMoved = 0;

	m_bHasBetrayedMinorCiv = false;
	m_bAlive = false;
	m_bEverAlive = false;
	m_bPotentiallyAlive = false;
	m_bBeingResurrected = false;
	m_bTurnActive = false;
	m_bAutoMoves = false;
	m_bProcessedAutoMoves = false;
	m_bEndTurn = false;
	m_bDynamicTurnsSimultMode = true;
	m_bPbemNewTurn = false;
	m_bExtendedGame = false;
	m_bFoundedFirstCity = false;
	m_iNumCitiesFounded = 0;
	m_bStrike = false;
	m_bCramped = false;
	m_bLostCapital = false;
	m_eConqueror = NO_PLAYER;
	m_bLostHolyCity = false;
	m_eHolyCityConqueror = NO_PLAYER;
	m_bHasAdoptedStateReligion = false;
	m_bAlliesGreatPersonBiasApplied = false;
	m_lastGameTurnInitialAIProcessed = -1;

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	m_bVassalLevy = false;
	m_iVassalGoldMaintenanceMod = 0;
#endif
#if defined(MOD_BATTLE_ROYALE)
	m_iNumMilitarySeaUnits = 0;
	m_iNumMilitaryAirUnits = 0; 
	m_iNumMilitaryLandUnits = 0;
	m_iMilitarySeaMight = 0;
	m_iMilitaryAirMight = 0;
	m_iMilitaryLandMight = 0;
#endif

	m_eID = NO_PLAYER;
}


//	--------------------------------------------------------------------------------
// FUNCTION: reset()
// Initializes data members that are serialized.
void CvPlayer::reset(PlayerTypes eID, bool bConstructorCall)
{
	m_syncArchive.reset();
	//--------------------------------
	// Uninit class
	uninit();

	m_eID = eID;
	if(m_eID != NO_PLAYER)
	{
		m_ePersonalityType = CvPreGame::leaderHead(m_eID); //??? Is this repeated data???
	}
	else
	{
		m_ePersonalityType = NO_LEADER;
	}

	// tutorial info
	m_bEverPoppedGoody = false;

	// lazy update scheme ...
	m_iPlotFoundValuesUpdateTurn = -1;

	m_aiCityYieldChange.clear();
	m_aiCityYieldChange.resize(NUM_YIELD_TYPES, 0);

	m_aiCoastalCityYieldChange.clear();
	m_aiCoastalCityYieldChange.resize(NUM_YIELD_TYPES, 0);

	m_aiCapitalYieldChange.clear();
	m_aiCapitalYieldChange.resize(NUM_YIELD_TYPES, 0);

	m_aiCapitalYieldPerPopChange.clear();
	m_aiCapitalYieldPerPopChange.resize(NUM_YIELD_TYPES, 0);

	m_aiCapitalYieldPerPopChangeEmpire.clear();
	m_aiCapitalYieldPerPopChangeEmpire.resize(NUM_YIELD_TYPES, 0);

	m_aiSeaPlotYield.clear();
	m_aiSeaPlotYield.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldRateModifier.clear();
	m_aiYieldRateModifier.resize(NUM_YIELD_TYPES, 0);

#if defined(MOD_BALANCE_CORE_POLICIES)
	m_aiGlobalTourismAlreadyReceived.clear();
	m_aiGlobalTourismAlreadyReceived.resize(NUM_MINOR_CIV_QUEST_TYPES, 0);

	m_aiYieldFromMinors.clear();
	m_aiYieldFromMinors.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromBirth.clear();
	m_aiYieldFromBirth.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromBirthCapital.clear();
	m_aiYieldFromBirthCapital.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromBirthRetroactive.clear();
	m_aiYieldFromBirthRetroactive.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromBirthCapitalRetroactive.clear();
	m_aiYieldFromBirthCapitalRetroactive.resize(NUM_YIELD_TYPES, 0);
	
	m_aiYieldFromDeath.clear();
	m_aiYieldFromDeath.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromConstruction.clear();
	m_aiYieldFromConstruction.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromwonderConstruction.clear();
	m_aiYieldFromwonderConstruction.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromTech.clear();
	m_aiYieldFromTech.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromBorderGrowth.clear();
	m_aiYieldFromBorderGrowth.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldGPExpend.clear();
	m_aiYieldGPExpend.resize(NUM_YIELD_TYPES, 0);

	m_aiConquerorYield.clear();
	m_aiConquerorYield.resize(NUM_YIELD_TYPES, 0);

	m_aiFounderYield.clear();
	m_aiFounderYield.resize(NUM_YIELD_TYPES, 0);

	m_aiArtifactYieldBonus.clear();
	m_aiArtifactYieldBonus.resize(NUM_YIELD_TYPES, 0);

	m_aiArtYieldBonus.clear();
	m_aiArtYieldBonus.resize(NUM_YIELD_TYPES, 0);

	m_aiMusicYieldBonus.clear();
	m_aiMusicYieldBonus.resize(NUM_YIELD_TYPES, 0);

	m_aiLitYieldBonus.clear();
	m_aiLitYieldBonus.resize(NUM_YIELD_TYPES, 0);	

	m_aiFilmYieldBonus.clear();
	m_aiFilmYieldBonus.resize(NUM_YIELD_TYPES, 0);

	m_aiRelicYieldBonus.clear();
	m_aiRelicYieldBonus.resize(NUM_YIELD_TYPES, 0);

	m_aiReligionYieldRateModifier.clear();
	m_aiReligionYieldRateModifier.resize(NUM_YIELD_TYPES, 0);

	m_aiGoldenAgeYieldMod.clear();
	m_aiGoldenAgeYieldMod.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromNonSpecialistCitizens.clear();
	m_aiYieldFromNonSpecialistCitizens.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldModifierFromGreatWorks.clear();
	m_aiYieldModifierFromGreatWorks.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldModifierFromActiveSpies.clear();
	m_aiYieldModifierFromActiveSpies.resize(NUM_YIELD_TYPES, 0);

	m_aiYieldFromDelegateCount.clear();
	m_aiYieldFromDelegateCount.resize(NUM_YIELD_TYPES, 0);

	m_aiDomainFreeExperiencePerGreatWorkGlobal.clear();
	m_aiDomainFreeExperiencePerGreatWorkGlobal.resize(NUM_DOMAIN_TYPES, 0);

	m_aiBestMilitaryCombatClassCity.clear();
	m_aiBestMilitaryCombatClassCity.resize(GC.getNumUnitCombatClassInfos(), 0);

	m_aiBestMilitaryDomainCity.clear();
	m_aiBestMilitaryDomainCity.resize(NUM_DOMAIN_TYPES, 0);

	m_aiEventChoiceDuration.clear();
	m_aiEventChoiceDuration.resize(GC.getNumEventChoiceInfos(), 0);

	m_aiEventIncrement.clear();
	m_aiEventIncrement.resize(GC.getNumEventInfos(), 0);

	m_aiEventCooldown.clear();
	m_aiEventCooldown.resize(GC.getNumEventInfos(), 0);

	m_abEventActive.clear();
	m_abEventActive.resize(GC.getNumEventInfos(), false);

	m_abEventChoiceActive.clear();
	m_abEventChoiceActive.resize(GC.getNumEventChoiceInfos(), false);

	m_abEventFired.clear();
	m_abEventFired.resize(GC.getNumEventInfos(), false);

	m_abEventChoiceFired.clear();
	m_abEventChoiceFired.resize(GC.getNumEventChoiceInfos(), false);

	m_abNWOwned.clear();
	m_abNWOwned.resize(GC.getNumFeatureInfos(), false);

	m_paiUnitClassProductionModifiers.clear();
	m_paiUnitClassProductionModifiers.resize(GC.getNumUnitClassInfos(), 0);

	m_aiCityYieldModFromMonopoly.clear();
	m_aiCityYieldModFromMonopoly.resize(NUM_YIELD_TYPES, 0);

	m_aiDomainDiversity.clear();
	m_aiDomainDiversity.resize(NUM_DOMAIN_TYPES, -1);

	m_abActiveContract.clear();
	m_abActiveContract.resize(GC.getNumContractInfos(), false);

	m_aistrInstantYield.clear();
	m_aistrInstantYield.resize(NUM_INSTANT_YIELD_TYPES);

	m_aistrInstantGreatPersonProgress.clear();
	m_aistrInstantGreatPersonProgress.resize(NUM_INSTANT_YIELD_TYPES);

	m_viInstantYieldsTotal.clear();
	m_viInstantYieldsTotal.resize(NUM_YIELD_TYPES, 0);

#endif

	m_aiCapitalYieldRateModifier.clear();
	m_aiCapitalYieldRateModifier.resize(NUM_YIELD_TYPES, 0);

	m_aiGreatWorkYieldChange.clear();
	m_aiGreatWorkYieldChange.resize(NUM_YIELD_TYPES, 0);

	m_aiExtraYieldThreshold.clear();
	m_aiExtraYieldThreshold.resize(NUM_YIELD_TYPES, 0);

	m_aiSpecialistExtraYield.clear();
	m_aiSpecialistExtraYield.resize(NUM_YIELD_TYPES, 0);

	m_aiProximityToPlayer.clear();
	m_aiProximityToPlayer.resize(MAX_PLAYERS, 0);

	m_aiResearchAgreementCounter.clear();
	m_aiResearchAgreementCounter.resize(MAX_PLAYERS, 0);

	m_aiIncomingUnitTypes.clear();
	m_aiIncomingUnitTypes.resize(MAX_PLAYERS, NO_UNIT);

	m_aiIncomingUnitCountdowns.clear();
	m_aiIncomingUnitCountdowns.resize(MAX_PLAYERS, -1);

	m_aiMinorFriendshipAnchors.clear();
	m_aiMinorFriendshipAnchors.resize(MAX_PLAYERS, 0);

	m_aiSiphonLuxuryCount.clear();
	m_aiSiphonLuxuryCount.resize(MAX_PLAYERS, 0);

	m_aOptions.clear();

	m_strReligionKey = "";
	m_strScriptData = "";
	m_strEmbarkedGraphicOverride = "";

	if(!bConstructorCall)
	{
		//important, do this first
		m_cities.RemoveAll();
		m_units.RemoveAll();
		m_armyAIs.RemoveAll();

		// loop through all entries freeing them up
		std::map<int , CvAIOperation*>::iterator iter;
		for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
			delete(iter->second);
		m_AIOperations.clear();

		CvAssertMsg(0 < GC.getNumResourceInfos(), "GC.getNumResourceInfos() is not greater than zero but it is used to allocate memory in CvPlayer::reset");
		m_paiNumResourceUsed.clear();
		m_paiNumResourceUsed.resize(GC.getNumResourceInfos(), 0);

		m_paiNumResourceTotal.clear();
		m_paiNumResourceTotal.resize(GC.getNumResourceInfos(), 0);

		m_paiResourceGiftedToMinors.clear();
		m_paiResourceGiftedToMinors.resize(GC.getNumResourceInfos(), 0);

		m_paiResourceExport.clear();
		m_paiResourceExport.resize(GC.getNumResourceInfos(), 0);

		m_paiResourceImport.clear();
		m_paiResourceImport.resize(GC.getNumResourceInfos(), 0);

		m_paiResourceFromMinors.clear();
		m_paiResourceFromMinors.resize(GC.getNumResourceInfos(), 0);

		m_paiResourcesSiphoned.clear();
		m_paiResourcesSiphoned.resize(GC.getNumResourceInfos(), 0);

		CvAssertMsg(0 < GC.getNumImprovementInfos(), "GC.getNumImprovementInfos() is not greater than zero but it is used to allocate memory in CvPlayer::reset");
		m_paiImprovementCount.clear();
		m_paiImprovementCount.resize(GC.getNumImprovementInfos(), 0);

#if defined(MOD_BALANCE_CORE)
		CvAssertMsg(0 < GC.getNumImprovementInfos(), "GC.getNumImprovementInfos() is not greater than zero but it is used to allocate memory in CvPlayer::reset");
		m_paiTotalImprovementsBuilt.clear();
		m_paiTotalImprovementsBuilt.resize(GC.getNumImprovementInfos(), 0);
#endif

		m_paiUnitCombatProductionModifiers.clear();
		m_paiUnitCombatProductionModifiers.resize(GC.getNumUnitCombatClassInfos(), 0);

		m_paiUnitCombatFreeExperiences.clear();
		m_paiUnitCombatFreeExperiences.resize(GC.getNumUnitCombatClassInfos(), 0);

		m_paiFreeBuildingCount.clear();
		m_paiFreeBuildingCount.resize(GC.getNumBuildingInfos(), 0);

		m_paiFreePromotionCount.clear();
		m_paiFreePromotionCount.resize(GC.getNumPromotionInfos(), 0);

		m_paiUnitClassCount.clear();
		m_paiUnitClassCount.resize(GC.getNumUnitClassInfos(), 0);

		m_paiUnitClassMaking.clear();
		m_paiUnitClassMaking.resize(GC.getNumUnitClassInfos(), 0);

		m_paiBuildingClassCount.clear();
		m_paiBuildingClassCount.resize(GC.getNumBuildingClassInfos(), 0);

		m_paiBuildingClassMaking.clear();
		m_paiBuildingClassMaking.resize(GC.getNumBuildingClassInfos(), 0);

		m_paiProjectMaking.clear();
		m_paiProjectMaking.resize(GC.getNumProjectInfos(), 0);

		m_paiHurryCount.clear();
		m_paiHurryCount.resize(GC.getNumHurryInfos(), 0);

		m_paiHurryModifier.clear();
		m_paiHurryModifier.resize(GC.getNumHurryInfos(), 0);
#if defined(MOD_BALANCE_CORE)
		m_paiJFDPoliticPercent.clear();
		m_paiJFDPoliticPercent.resize(MAX_CIV_PLAYERS, 0);

		m_paiResourceFromCSAlliances.clear();
		m_paiResourceFromCSAlliances.resize(GC.getNumResourceInfos(), 0);

		m_paiResourceOverValue.clear();
		m_paiResourceOverValue.resize(GC.getNumResourceInfos(), 0);

		m_paiNumCitiesFreeChosenBuilding.clear();
		m_paiNumCitiesFreeChosenBuilding.resize(GC.getNumBuildingClassInfos(), 0);

		m_pabFreeChosenBuildingNewCity.clear();
		m_pabFreeChosenBuildingNewCity.resize(GC.getNumBuildingClassInfos(), false);

		m_pabAllCityFreeBuilding.clear();
		m_pabAllCityFreeBuilding.resize(GC.getNumBuildingClassInfos(), false);

		m_pabNewFoundCityFreeUnit.clear();
		m_pabNewFoundCityFreeUnit.resize(GC.getNumUnitClassInfos(), false);

		m_pabNewFoundCityFreeBuilding.clear();
		m_pabNewFoundCityFreeBuilding.resize(GC.getNumBuildingClassInfos(), false);

		m_paiNumCivsConstructingWonder.clear();
		m_paiNumCivsConstructingWonder.resize(GC.getNumBuildingInfos(), 0);

		m_paiBuildingClassCulture.clear();
		m_paiBuildingClassCulture.resize(GC.getNumBuildingClassInfos(), 0);
#endif
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
		m_pabHasGlobalMonopoly.clear();
		m_pabHasGlobalMonopoly.resize(GC.getNumResourceInfos(), false);
		m_pabHasStrategicMonopoly.clear();
		m_pabHasStrategicMonopoly.resize(GC.getNumResourceInfos(), false);
		m_vResourcesWGlobalMonopoly.clear();
		m_vResourcesWStrategicMonopoly.clear();
#endif
		m_pabLoyalMember.clear();
		m_pabLoyalMember.resize(GC.getNumVoteSourceInfos(), true);

		m_pabGetsScienceFromPlayer.clear();
		m_pabGetsScienceFromPlayer.resize(MAX_CIV_PLAYERS, false);

		m_pEconomicAI->Init(GC.GetGameEconomicAIStrategies(), this);
		m_pMilitaryAI->Init(GC.GetGameMilitaryAIStrategies(), this, GetDiplomacyAI());
		m_pCitySpecializationAI->Init(GC.GetGameCitySpecializations(), this);
		m_pWonderProductionAI->Init(GC.GetGameBuildings(), this, false);
		m_pGrandStrategyAI->Init(GC.GetGameAIGrandStrategies(), this);
		m_pDiplomacyAI->Init(this);
		m_pReligions->Init(this);
		m_pReligionAI->Init(GC.GetGameBeliefs(), this);
#if defined(MOD_BALANCE_CORE)
		m_pCorporations->Init(this);
		m_pContracts->Init(this);
#endif
		m_pPlayerTechs->Init(GC.GetGameTechs(), this, false);
		m_pPlayerPolicies->Init(GC.GetGamePolicies(), this, false);
		m_pTacticalAI->Init(this);
		m_pHomelandAI->Init(this);
		m_pMinorCivAI->Init(this);
		m_pDealAI->Init(this);
		m_pBuilderTaskingAI->Init(this);
		m_pCityConnections->Init(this);
		if(m_pNotifications)
		{
			m_pNotifications->Init(eID);
		}
		if(m_pDiplomacyRequests)
		{
			m_pDiplomacyRequests->Init(eID);
		}
		m_pDangerPlots->Init(eID, false /*bAllocate*/);

#if defined(MOD_BALANCE_CORE_SETTLER)
		m_pCityDistanceTurns->SetPlayer(eID);
		m_pCityDistancePlots->SetPlayer(eID);
#endif

		m_pTreasury->Init(this);
		m_pTraits->Init(GC.GetGameTraits(), this);
		m_pEspionage->Init(this);
		m_pEspionageAI->Init(this);
		m_pTrade->Init(this);
		m_pTradeAI->Init(this);
		m_pLeagueAI->Init(this);
		m_pCulture->Init(this);

		// Set up flavor manager
		m_pFlavorManager->Init(this);

		// And if this is a real player, hook up the player-level flavor recipients
		PlayerTypes p = GetID();
		if(p != NO_PLAYER)
		{
			SlotStatus s = CvPreGame::slotStatus(p);
			if((s == SS_TAKEN || s == SS_COMPUTER) && !isBarbarian())
			{
				m_pFlavorManager->AddFlavorRecipient(m_pPlayerTechs);
				m_pFlavorManager->AddFlavorRecipient(m_pPlayerPolicies);
				m_pFlavorManager->AddFlavorRecipient(m_pWonderProductionAI);
			}
		}

		Firaxis::Array< int, NUM_YIELD_TYPES > yield;
		for(unsigned int j = 0; j < NUM_YIELD_TYPES; ++j)
		{
			yield[j] = 0;
		}

		m_ppaaiSpecialistExtraYield.clear();
		m_ppaaiSpecialistExtraYield.resize(GC.getNumSpecialistInfos());
		for(unsigned int i = 0; i < m_ppaaiSpecialistExtraYield.size(); ++i)
		{
			m_ppaaiSpecialistExtraYield.setAt(i, yield);
		}

#if defined(MOD_API_UNIFIED_YIELDS) && defined(MOD_API_PLOT_YIELDS)
		m_ppiPlotYieldChange.clear();
		m_ppiPlotYieldChange.resize(GC.getNumPlotInfos());
		for(unsigned int i = 0; i < m_ppiPlotYieldChange.size(); ++i)
		{
			m_ppiPlotYieldChange[i] = yield;
		}
#endif

#if defined(MOD_API_UNIFIED_YIELDS)
		m_ppiInstantYieldHistoryValues.clear();
		m_ppiInstantYieldHistoryValues.resize(GC.getGame().getEstimateEndTurn());
		for (unsigned int i = 0; i < m_ppiInstantYieldHistoryValues.size(); ++i)
		{
			m_ppiInstantYieldHistoryValues[i] = yield;
		}

		m_ppiImprovementYieldChange.clear();
		m_ppiImprovementYieldChange.resize(GC.getNumImprovementInfos());
		for(unsigned int i = 0; i < m_ppiImprovementYieldChange.size(); ++i)
		{
			m_ppiImprovementYieldChange[i] = yield;
		}

		m_ppiFeatureYieldChange.clear();
		m_ppiFeatureYieldChange.resize(GC.getNumFeatureInfos());
		for(unsigned int i = 0; i < m_ppiFeatureYieldChange.size(); ++i)
		{
			m_ppiFeatureYieldChange[i] = yield;
		}
		
		m_ppiResourceYieldChange.clear();
		m_ppiResourceYieldChange.resize(GC.getNumResourceInfos());
		for(unsigned int i = 0; i < m_ppiResourceYieldChange.size(); ++i)
		{
			m_ppiResourceYieldChange[i] = yield;
		}
		
		m_ppiTerrainYieldChange.clear();
		m_ppiTerrainYieldChange.resize(GC.getNumTerrainInfos());
		for(unsigned int i = 0; i < m_ppiTerrainYieldChange.size(); ++i)
		{
			m_ppiTerrainYieldChange[i] = yield;
		}
		
		m_ppiTradeRouteYieldChange.clear();
		m_ppiTradeRouteYieldChange.resize(NUM_DOMAIN_TYPES);
		for(unsigned int i = 0; i < m_ppiTradeRouteYieldChange.size(); ++i)
		{
			m_ppiTradeRouteYieldChange[i] = yield;
		}
		
		m_ppiSpecialistYieldChange.clear();
		m_ppiSpecialistYieldChange.resize(GC.getNumSpecialistInfos());
		for(unsigned int i = 0; i < m_ppiSpecialistYieldChange.size(); ++i)
		{
			m_ppiSpecialistYieldChange[i] = yield;
		}
		
		m_ppiGreatPersonExpendedYield.clear();
		m_ppiGreatPersonExpendedYield.resize(GC.getNumGreatPersonInfos());
		for(unsigned int i = 0; i < m_ppiGreatPersonExpendedYield.size(); ++i)
		{
			m_ppiGreatPersonExpendedYield[i] = yield;
		}
		
		m_piGoldenAgeGreatPersonRateModifier.clear();
		m_piGoldenAgeGreatPersonRateModifier.resize(GC.getNumGreatPersonInfos(), 0);

		m_ppiUnimprovedFeatureYieldChange.clear();
		m_ppiUnimprovedFeatureYieldChange.resize(GC.getNumFeatureInfos());
		for(unsigned int i = 0; i < m_ppiUnimprovedFeatureYieldChange.size(); ++i)
		{
			m_ppiUnimprovedFeatureYieldChange[i] = yield;
		}
		
		m_ppiCityYieldFromUnimprovedFeature.clear();
		m_ppiCityYieldFromUnimprovedFeature.resize(GC.getNumFeatureInfos());
		for(unsigned int i = 0; i < m_ppiCityYieldFromUnimprovedFeature.size(); ++i)
		{
			m_ppiCityYieldFromUnimprovedFeature[i] = yield;
		}
		
		m_piYieldFromKills.clear();
		m_piYieldFromKills.resize(NUM_YIELD_TYPES, 0);

		m_piYieldFromBarbarianKills.clear();
		m_piYieldFromBarbarianKills.resize(NUM_YIELD_TYPES, 0);

		m_piYieldChangeTradeRoute.clear();
		m_piYieldChangeTradeRoute.resize(NUM_YIELD_TYPES, 0);

		m_piYieldChangesNaturalWonder.clear();
		m_piYieldChangesNaturalWonder.resize(NUM_YIELD_TYPES, 0);

		m_piYieldChangeWorldWonder.clear();
		m_piYieldChangeWorldWonder.resize(NUM_YIELD_TYPES, 0);

		m_piYieldFromMinorDemand.clear();
		m_piYieldFromMinorDemand.resize(NUM_YIELD_TYPES, 0);

		m_piYieldFromWLTKD.clear();
		m_piYieldFromWLTKD.resize(NUM_YIELD_TYPES, 0);

		m_piCityFeatures.clear();
		m_piCityFeatures.resize(GC.getNumFeatureInfos(), 0);

		m_piNumBuildings.clear();
		m_piNumBuildings.resize(GC.getNumBuildingInfos(), 0);

		m_piNumBuildingsInPuppets.clear();
		m_piNumBuildingsInPuppets.resize(GC.getNumBuildingInfos(), 0);

		m_ppiBuildingClassYieldChange.clear();
		m_ppiBuildingClassYieldChange.resize(GC.getNumBuildingClassInfos());
		for(unsigned int i = 0; i < m_ppiBuildingClassYieldChange.size(); ++i)
		{
			m_ppiBuildingClassYieldChange.setAt(i, yield);
		}
#endif

		m_ppaaiImprovementYieldChange.clear();
		m_ppaaiImprovementYieldChange.resize(GC.getNumImprovementInfos());
		for(unsigned int i = 0; i < m_ppaaiImprovementYieldChange.size(); ++i)
		{
			m_ppaaiImprovementYieldChange.setAt(i, yield);
		}

		m_ppaaiBuildingClassYieldMod.clear();
		m_ppaaiBuildingClassYieldMod.resize(GC.getNumBuildingClassInfos());
		for(unsigned int i = 0; i < m_ppaaiBuildingClassYieldMod.size(); ++i)
		{
			m_ppaaiBuildingClassYieldMod.setAt(i, yield);
		}
#if defined(MOD_BALANCE_CORE)
		m_ppiApproachScratchValue.clear();
		m_ppiApproachScratchValue.resize(MAX_MAJOR_CIVS);
		for(unsigned int i = 0; i < m_ppiApproachScratchValue.size(); ++i)
		{
			for(int iJ = 0; iJ < NUM_MAJOR_CIV_APPROACHES; ++iJ)
			{
				m_ppiApproachScratchValue[i][iJ] = 0;
			}
		}
#endif

		m_aVote.clear();
		m_aUnitExtraCosts.clear();

		AI_reset();
	}

	m_iNumUnitsSuppliedCached = -1;
}

//	--------------------------------------------------------------------------------
/// This is called after the map and other game constructs have been setup and just before the game starts.
void CvPlayer::gameStartInit()
{
#if defined(MOD_BALANCE_CORE)
	//make sure the non-serialized infos are up to date
	m_pDangerPlots->Init(GetID(), true);
	m_pCityDistanceTurns->SetPlayer(GetID());
	m_pCityDistancePlots->SetPlayer(GetID());
#else
	// if the game is loaded, don't init the danger plots. This was already done in the serialization process.
	if(CvPreGame::gameStartType() != GAME_LOADED)
	{
		if(!GC.GetEngineUserInterface()->IsLoadedGame())
		{
			InitDangerPlots(); // moved this up because everyone should have danger plots inited. This is bad because saved games get much bigger for no reason.
		}
	}
#endif
	verifyAlive();
	if(!isAlive())
	{
		return;
	}

	if(!GC.GetEngineUserInterface()->IsLoadedGame())
	{
		UpdatePlots();
	}
}


//////////////////////////////////////
// graphical only setup
//////////////////////////////////////
void CvPlayer::setupGraphical()
{
	CvCity* pLoopCity;
	CvUnit* pLoopUnit;

	// Setup m_cities
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->setupGraphical();
	}

	// Setup m_units
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		pLoopUnit->setupGraphical();
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::initFreeState(CvGameInitialItemsOverrides& kOverrides)
{
	const CvHandicapInfo& kHandicapInfo = getHandicapInfo();

	// Starting Gold
	if(kOverrides.GrantInitialGoldPerPlayer[GetID()])
	{
		int iInitialGold = kHandicapInfo.getStartingGold() + GC.getGame().getStartEraInfo().getStartingGold();
		iInitialGold *= GC.getGame().getGameSpeedInfo().getTrainPercent();
		iInitialGold /= 100;
		GetTreasury()->SetGold(iInitialGold);
	}

	// Free Culture
	if(kOverrides.GrantInitialCulturePerPlayer[GetID()])
	{
		int iInitialCulture = kHandicapInfo.getStartingPolicyPoints() + GC.getGame().getStartEraInfo().getStartingCulture();
		iInitialCulture *= GC.getGame().getGameSpeedInfo().getTrainPercent();
		iInitialCulture /= 100;
		setJONSCulture(iInitialCulture);

		 // I think policy points is a better name than Jon's Culture, don't you?
		ChangeJONSCulturePerTurnForFree(kHandicapInfo.getFreeCulturePerTurn()); // No, IMNSHO ;P
	}
	// Extra Happiness from Luxuries
	ChangeExtraHappinessPerLuxury(kHandicapInfo.getExtraHappinessPerLuxury());

	// Free starting Resources
	for(int iLoop = 0; iLoop < GC.getNumResourceInfos(); iLoop++)
	{
		const ResourceTypes eResource = static_cast<ResourceTypes>(iLoop);
		CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
		if(pkResource)
		{
			if(pkResource->getStartingResourceQuantity() != 0)
			{
				changeNumResourceTotal(eResource, pkResource->getStartingResourceQuantity());
			}
		}

	}

	CalculateNetHappiness();

	clearResearchQueue();
}

//	--------------------------------------------------------------------------------
void CvPlayer::initFreeUnits(CvGameInitialItemsOverrides& /*kOverrides*/)
{
	UnitTypes eLoopUnit;
	int iFreeCount;
	int iDefaultAI;
	int iI, iJ;

	const CvEraInfo& gameStartEra = GC.getGame().getStartEraInfo();
	const CvHandicapInfo& gameHandicap = GC.getGame().getHandicapInfo();
	const CvHandicapInfo& playerHandicap = getHandicapInfo();
	const CvCivilizationInfo& playerCivilization = getCivilizationInfo();
#if defined(MOD_BALANCE_CORE)
	int iFree = 0;
#endif
	for(iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
	{
		const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
		CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
		if(pkUnitClassInfo)
		{
			eLoopUnit = (UnitTypes)playerCivilization.getCivilizationUnits(iI);

			if(eLoopUnit != NO_UNIT)
			{
				iFreeCount = playerCivilization.getCivilizationFreeUnitsClass(iI);
				iDefaultAI = playerCivilization.getCivilizationFreeUnitsDefaultUnitAI(iI);
#if defined(MOD_BALANCE_CORE)
				if(!canTrain(eLoopUnit) && iDefaultAI != UNITAI_SETTLE) 
				{
					// Loop through adding the available units
					for(int iUnitLoop = 0; iUnitLoop < GC.GetGameUnits()->GetNumUnits(); iUnitLoop++)
					{
						const UnitTypes eUnit = static_cast<UnitTypes>(iUnitLoop);
						CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
						if(pkUnitInfo)
						{
							// Make sure this unit can be built now
							if(canTrain(eUnit))
							{
								// Make sure it matches the requested unit AI type
								if(pkUnitInfo->GetDefaultUnitAIType() == iDefaultAI)
								{
									eLoopUnit = eUnit;
									break;
								}
							}
						}
					}
				}
#endif
				iFreeCount *= (gameStartEra.getStartingUnitMultiplier() + ((!isHuman()) ? gameHandicap.getAIStartingUnitMultiplier() : 0));

				// City states only get 1 of something
				if(isMinorCiv() && iFreeCount > 1)
					iFreeCount = 1;

				for(iJ = 0; iJ < iFreeCount; iJ++)
				{
					addFreeUnit(eLoopUnit,(UnitAITypes)iDefaultAI);
#if defined(MOD_BALANCE_CORE)
					if(iDefaultAI != UNITAI_SETTLE)
					{
						iFree++;
					}
#endif
				}
			}
		}
	}

	// Trait units
	int iUnitClass = GetPlayerTraits()->GetFirstFreeUnit(NO_TECH);
	while(iUnitClass != NO_UNITCLASS)
	{
		eLoopUnit = (UnitTypes)playerCivilization.getCivilizationUnits(iUnitClass);
		iDefaultAI = GC.GetGameUnits()->GetEntry(eLoopUnit)->GetDefaultUnitAIType();
		addFreeUnit(eLoopUnit,(UnitAITypes)iDefaultAI);

		// Another?
		iUnitClass = GetPlayerTraits()->GetNextFreeUnit();
	}

	// Defensive units
	iFreeCount = gameStartEra.getStartingDefenseUnits();
	iFreeCount += playerHandicap.getStartingDefenseUnits();
	if(!isHuman())
		iFreeCount += gameHandicap.getAIStartingDefenseUnits();
#if defined(MOD_BALANCE_CORE)
	iFreeCount -= iFree;
#endif
	if(iFreeCount > 0 && !isMinorCiv())
		addFreeUnitAI(UNITAI_DEFENSE, iFreeCount);

	// Worker units
	iFreeCount = gameStartEra.getStartingWorkerUnits();
	iFreeCount += playerHandicap.getStartingWorkerUnits();

	if(!isHuman())
		iFreeCount += gameHandicap.getAIStartingWorkerUnits();

	if(iFreeCount > 0 && !isMinorCiv())
		addFreeUnitAI(UNITAI_WORKER, iFreeCount);

	// Explore units
	iFreeCount = gameStartEra.getStartingExploreUnits();
	iFreeCount += playerHandicap.getStartingExploreUnits();

	if(!isHuman())
		iFreeCount += gameHandicap.getAIStartingExploreUnits();

	if(iFreeCount > 0 && !isMinorCiv())
		addFreeUnitAI(UNITAI_EXPLORE, iFreeCount);

#if defined(MOD_BALANCE_CORE)
	//Minor Civ Units
	if(isMinorCiv())
	{
		iFreeCount = gameStartEra.getStartingMinorDefenseUnits();
		iFreeCount += gameHandicap.getStartingMinorDefenseUnits();
		if(iFreeCount > 0)
		{
			addFreeUnitAI(UNITAI_DEFENSE, iFreeCount);
		}
	}
#endif
	// If we only have one military unit and it's on defense then change its AI to explore
	if(GetNumUnitsWithUnitAI(UNITAI_EXPLORE) == 0)
	{
#if defined(MOD_BALANCE_CORE)
		if(!isMinorCiv())
		{
#endif
		int iLoop;
		CvUnit* pLoopUnit;
		for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		{
			if(pLoopUnit->AI_getUnitAIType() == UNITAI_DEFENSE)
			{
				pLoopUnit->AI_setUnitAIType(UNITAI_EXPLORE);
				break;
			}
		}
#if defined(MOD_BALANCE_CORE)
		}
#endif
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::addFreeUnitAI(UnitAITypes eUnitAI, int iCount)
{
	int iI;

	UnitTypes eBestUnit = NO_UNIT;
	int iBestValue = 0;

	const CvCivilizationInfo& playerCivilzationInfo = getCivilizationInfo();
	for(iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
	{
		const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
		CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
		if(pkUnitClassInfo)
		{
			UnitTypes eLoopUnit = (UnitTypes)playerCivilzationInfo.getCivilizationUnits(iI);
			if(eLoopUnit != NO_UNIT)
			{
				CvUnitEntry* pUnitInfo = GC.getUnitInfo(eLoopUnit);
				if(pUnitInfo != NULL)
				{
					if(canTrain(eLoopUnit))
					{
						bool bValid = true;
						for(int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
						{
							const ResourceTypes eResource = static_cast<ResourceTypes>(iJ);
							CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
							if(pkResource)
							{
								if(pUnitInfo->GetResourceQuantityRequirement(iJ) > 0)
								{
									bValid = false;
								}
							}
						}

						if(bValid)
						{
							int iValue = 0;

							// Default unit AI matches
							if(pUnitInfo->GetDefaultUnitAIType() == eUnitAI)
								iValue += (pUnitInfo->GetProductionCost() * 2);
							// Not default, but still possible
							else if(pUnitInfo->GetUnitAIType(eUnitAI))
								iValue += (pUnitInfo->GetProductionCost());

							if(iValue > iBestValue)
							{
								eBestUnit = eLoopUnit;
								iBestValue = iValue;
							}
						}
					}
				}
			}
		}

	}

	if(eBestUnit != NO_UNIT)
	{
		for(iI = 0; iI < iCount; iI++)
		{
			addFreeUnit(eBestUnit, eUnitAI);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Returns plot where new unit was created
CvPlot* CvPlayer::addFreeUnit(UnitTypes eUnit, UnitAITypes eUnitAI)
{
	CvPlot* pStartingPlot;
#if defined(MOD_BUGFIX_FREE_RELIGIOUS_UNITS)
	CvPlot* pBestPlot = NULL;
#else
	CvPlot* pBestPlot;
#endif
	CvPlot* pLoopPlot;
	CvPlot* pReturnValuePlot = NULL;

	CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
	if(pkUnitInfo == NULL)
		return pReturnValuePlot;

#if defined(MOD_BUGFIX_FREE_RELIGIOUS_UNITS)
	// If pkUnitInfo is a religious unit AND the player has founded a religion, it MUST be dropped in the player's holy city
	if ((pkUnitInfo->IsSpreadReligion() || pkUnitInfo->IsRemoveHeresy()) && GetReligions()->HasCreatedReligion()) {
		CvCity* pHolyCity = GetHolyCity();
		if (pHolyCity && pHolyCity->getOwner() == GetID()) {
			// We have a holy city and we still own it
			pBestPlot = pHolyCity->plot();
		} else {
			// Ummm, our holy city either doesn't exist (maybe a mod razed it), or it belongs to someone else, better just drop this dude in the capital
			pBestPlot = getCapitalCity()->plot();
		}
	}
#endif

	if (isHuman() && GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE))
	{
		if((eUnitAI == UNITAI_SETTLE) || (pkUnitInfo->GetDefaultUnitAIType() == UNITAI_SETTLE))
		{
			if(GetNumUnitsWithUnitAI(UNITAI_SETTLE) >= 1)
			{
				return pReturnValuePlot;
			}
		}
	}

	// slewis
	// If we're Venice
	if (GetPlayerTraits()->IsNoAnnexing())
	{
		// if we're trying to drop a settler
		if((eUnitAI == UNITAI_SETTLE) || (pkUnitInfo->GetDefaultUnitAIType() == UNITAI_SETTLE))
		{
			// if we already have a settler
			if(GetNumUnitsWithUnitAI(UNITAI_SETTLE) >= 1)
			{
				// drop a merchant of venice instead
				// find the eUnit replacement that's the merchant of venice
				for(int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
				{
					const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
					CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
					if(pkUnitClassInfo)
					{
						const UnitTypes eLocalUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eUnitClass);
						if (eLocalUnit != NO_UNIT)
						{
							CvUnitEntry* pUnitEntry = GC.getUnitInfo(eLocalUnit);
							if (pUnitEntry->IsCanBuyCityState())
							{
								// replacing the parameters
								eUnit = eLocalUnit;
								eUnitAI = (UnitAITypes)pkUnitInfo->GetDefaultUnitAIType();
								break;
							}
						}
					}
				}
			}
		}	
	}

	CvCity* pCapital = getCapitalCity();

	if(pCapital)
	{
		pStartingPlot = pCapital->plot();
	}
	else
	{
		pStartingPlot = getStartingPlot();
	}

	if(pStartingPlot != NULL)
	{
#if defined(MOD_BUGFIX_FREE_RELIGIOUS_UNITS)
		// If pBestPlot is not NULL, don't do any of this, as we have already determined the best plot
		if (pBestPlot == NULL) {
#else
			pBestPlot = NULL;
#endif

			if (true) //isHuman())
			{
				if (!(pkUnitInfo->IsFound()))
				{
					DirectionTypes eDirection;

					bool bDirectionValid;

					int iCount = 0;

					// Find a random direction
					do
					{
						bDirectionValid = true;

						eDirection = (DirectionTypes)GC.getGame().getJonRandNum(NUM_DIRECTION_TYPES, "Placing Starting Units");

						if (bDirectionValid)
						{
							pLoopPlot = plotDirection(pStartingPlot->getX(), pStartingPlot->getY(), eDirection);

#if defined(MOD_BUGFIX_NAVAL_FREE_UNITS)
							if (pkUnitInfo->GetDomainType() == DOMAIN_SEA) {
								if (pLoopPlot != NULL && pLoopPlot->isWater()) {
									if (!pLoopPlot->isImpassable()) {
										if (!(pLoopPlot->isUnit())) {
											pBestPlot = pLoopPlot;
											break;
										}
									}
								}
							}
							else {
#endif
								if (pLoopPlot != NULL && pLoopPlot->getArea() == pStartingPlot->getArea())
								{
									if (!pLoopPlot->isImpassable() && !pLoopPlot->isMountain())
									{
										if (!(pLoopPlot->isUnit()))
										{
											if (!(pLoopPlot->isGoody()))
											{
												pBestPlot = pLoopPlot;
												break;
											}
										}
									}
								}
#if defined(MOD_BUGFIX_NAVAL_FREE_UNITS)
							}
#endif
						}

						// Emergency escape.  Should only really break on Debug Micro map or something really funky
						iCount++;
					} while (iCount < 1000);
				}
			}

			if (pBestPlot == NULL)
			{
				pBestPlot = pStartingPlot;
			}
#if defined(MOD_BUGFIX_FREE_RELIGIOUS_UNITS)
		}
#endif

		CvUnit* pNewUnit = initUnit(eUnit, pBestPlot->getX(), pBestPlot->getY(), eUnitAI);
		if(getCapitalCity())
		{
			getCapitalCity()->addProductionExperience(pNewUnit);
		}
		CvAssert(pNewUnit != NULL);
		if (pNewUnit == NULL)
			return NULL;
#if defined(MOD_BALANCE_CORE)
		if(pNewUnit->isWLKTKDOnBirth())
		{
			CvCity* pLoopCity;
			int iLoop;
			for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				if(pLoopCity != NULL && pLoopCity->getOwner() == GetID())
				{
					int iWLTKD = (GC.getCITY_RESOURCE_WLTKD_TURNS() / 3);

					iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
					iWLTKD /= 100;

					if (iWLTKD > 0)
					{
						pLoopCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
						CvNotifications* pNotifications = GetNotifications();
						if (pNotifications)
						{
							Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UNIT");
							strText << pNewUnit->getNameKey() << pLoopCity->getNameKey();
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UNIT");
							strSummary << pLoopCity->getNameKey();
							pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pLoopCity->getX(), pLoopCity->getY(), -1);
						}
					}
				}
			}
		}
		if(pNewUnit->isGoldenAgeOnBirth())
		{
			int iGoldenAgeTurns = getGoldenAgeLength();
			int iValue = GetGoldenAgeProgressMeter();
			changeGoldenAgeTurns(iGoldenAgeTurns, iValue);
		}
		if(pNewUnit->isCultureBoost())
		{
			int iValue = GetTotalJONSCulturePerTurn() * 4;
			changeJONSCulture(iValue);
			if(getCapitalCity() != NULL)
			{
				getCapitalCity()->ChangeJONSCultureStored(iValue);
			}
			CvNotifications* pNotifications = GetNotifications();
			if (pNotifications)
			{
				Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CULTURE_UNIT");
				strText << pNewUnit->getNameKey();
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CULTURE_UNIT");
				strSummary << pNewUnit->getNameKey();
				pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pNewUnit->getX(), pNewUnit->getY(), -1);
			}
		}
		if(pNewUnit->getUnitInfo().IsSpreadReligion())
		{
			ReligionTypes eReligion = GetReligions()->GetReligionCreatedByPlayer();
			if(eReligion == NO_RELIGION)
			{
				eReligion = GetReligions()->GetReligionInMostCities();
			}
			int iReligionSpreads = pNewUnit->getUnitInfo().GetReligionSpreads();
			int iReligiousStrength = pNewUnit->getUnitInfo().GetReligiousStrength();
#if defined(MOD_BALANCE_CORE)
			iReligiousStrength *= (100 + GetPlayerTraits()->GetExtraMissionaryStrength());
			iReligiousStrength /= 100;
#endif
			if(iReligionSpreads > 0 && eReligion > RELIGION_PANTHEON)
			{
#if defined(MOD_BUGFIX_EXTRA_MISSIONARY_SPREADS)
				if (MOD_BUGFIX_EXTRA_MISSIONARY_SPREADS)
				{
					if (GetHolyCity() && GetHolyCity()->getOwner() == GetID())
					{
						pNewUnit->GetReligionData()->SetSpreadsLeft(iReligionSpreads + GetHolyCity()->GetCityBuildings()->GetMissionaryExtraSpreads() + GetNumMissionarySpreads());
					}
					else if (getCapitalCity())
					{
						pNewUnit->GetReligionData()->SetSpreadsLeft(iReligionSpreads + getCapitalCity()->GetCityBuildings()->GetMissionaryExtraSpreads() + GetNumMissionarySpreads());
					}
					else
					{
						pNewUnit->GetReligionData()->SetSpreadsLeft(iReligionSpreads);
					}
				}
				else
				{
					pNewUnit->GetReligionData()->SetSpreadsLeft(iReligionSpreads);
				}
#else
				pNewUnit->GetReligionData()->SetSpreadsLeft(iReligionSpreads);
#endif
				pNewUnit->GetReligionData()->SetReligiousStrength(iReligiousStrength);
				pNewUnit->GetReligionData()->SetReligion(eReligion);
			}
		}
#endif
		// Don't stack any units
		if(pBestPlot->getNumUnits() > 1)
		{
			if (!pNewUnit->jumpToNearestValidPlot())
			{
				// Could not find a spot for the unit
				pNewUnit->kill(false);		
				return NULL;
			}
		}
		pReturnValuePlot = pNewUnit->plot();
	}

	return pReturnValuePlot;
}


//	--------------------------------------------------------------------------------
#if defined(MOD_API_EXTENSIONS) && defined(MOD_BALANCE_CORE)
CvCity* CvPlayer::initCity(int iX, int iY, bool bBumpUnits, bool bInitialFounding, ReligionTypes eInitialReligion, const char* szName, CvUnitEntry* pkSettlerUnitEntry)
#elif defined(MOD_API_EXTENSIONS)
CvCity* CvPlayer::initCity(int iX, int iY, bool bBumpUnits, bool bInitialFounding, ReligionTypes eInitialReligion, const char* szName)
#elif defined(MOD_BALANCE_CORE)
CvCity* CvPlayer::initCity(int iX, int iY, bool bBumpUnits, bool bInitialFounding, CvUnitEntry* pkSettlerUnitEntry)
#else
CvCity* CvPlayer::initCity(int iX, int iY, bool bBumpUnits, bool bInitialFounding)
#endif
{
	CvCity* pNewCity = addCity();

	CvAssertMsg(pNewCity != NULL, "City is not assigned a valid value");
	if(pNewCity != NULL)
	{
		CvAssertMsg(!(GC.getMap().plot(iX, iY)->isCity()), "No city is expected at this plot when initializing new city");
#if defined(MOD_API_EXTENSIONS) && defined(MOD_BALANCE_CORE)
		pNewCity->init(pNewCity->GetID(), GetID(), iX, iY, bBumpUnits, bInitialFounding, eInitialReligion, szName, pkSettlerUnitEntry);
#elif defined(MOD_API_EXTENSIONS)
		pNewCity->init(pNewCity->GetID(), GetID(), iX, iY, bBumpUnits, bInitialFounding, eInitialReligion, szName);
#elif defined(MOD_BALANCE_CORE)
		pNewCity->init(pNewCity->GetID(), GetID(), iX, iY, bBumpUnits, bInitialFounding, pkSettlerUnitEntry);
#else
		pNewCity->init(pNewCity->GetID(), GetID(), iX, iY, bBumpUnits, bInitialFounding);
#endif
		pNewCity->GetCityStrategyAI()->UpdateFlavorsForNewCity();
		pNewCity->DoUpdateCheapestPlotInfluenceDistance();

#if defined(MOD_BALANCE_CORE_SETTLER)
		SetClosestCityMapDirty();
#endif

#if defined(MOD_BALANCE_CORE)
		int iLoop=0;
		for (CvCity* pCity=firstCity(&iLoop); pCity!=NULL; pCity=nextCity(&iLoop))
			pCity->UpdateClosestFriendlyNeighbors();
#endif
	}

	return pNewCity;
}

//	--------------------------------------------------------------------------------
// NOTE: bGift set to true if the city is given as a gift, as in the case for trades and Austria UA of annexing city-states
#if defined(MOD_API_EXTENSIONS)
#if defined(MOD_GLOBAL_VENICE_KEEPS_RESOURCES)
CvCity* CvPlayer::acquireCity(CvCity* pOldCity, bool bConquest, bool bGift, bool bVenice)
#else
CvCity* CvPlayer::acquireCity(CvCity* pOldCity, bool bConquest, bool bGift)
#endif
#else
#if defined(MOD_GLOBAL_VENICE_KEEPS_RESOURCES)
void CvPlayer::acquireCity(CvCity* pOldCity, bool bConquest, bool bGift, bool bVenice)
#else
void CvPlayer::acquireCity(CvCity* pOldCity, bool bConquest, bool bGift)
#endif
#endif
{
	if(pOldCity == NULL)
#if defined(MOD_API_EXTENSIONS)
		return NULL;
#else
		return;
#endif

	IDInfo* pUnitNode;
	CvCity* pNewCity;
	CvUnit* pLoopUnit;
	CvPlot* pCityPlot;

	CvString strBuffer;
	CvString strName;
	bool abEverOwned[MAX_PLAYERS];
	PlayerTypes eOldOwner;
	PlayerTypes eOriginalOwner;
	BuildingTypes eBuilding;
	bool bRecapture;
	int iCaptureGold;
	int iCaptureCulture;
	int iCaptureGreatWorks;
	int iGameTurnFounded;
	int iPopulation;
	int iHighestPopulation;
	int iOldPopulation;
	int iBattleDamage;
	int iI;
	FFastSmallFixedList<IDInfo, 25, true, c_eCiv5GameplayDLL > oldUnits;
	CvCityReligions tempReligions;
	bool bIsMinorCivBuyout = (pOldCity->GetPlayer()->isMinorCiv() && bGift && (IsAbleToAnnexCityStates() || GetPlayerTraits()->IsNoAnnexing())); // Austria and Venice UA

	pCityPlot = pOldCity->plot();

	pUnitNode = pCityPlot->headUnitNode();

	while(pUnitNode != NULL)
	{
		oldUnits.insertAtEnd(pUnitNode);
		pUnitNode = pCityPlot->nextUnitNode((IDInfo*)pUnitNode);
	}

	pUnitNode = oldUnits.head();

	while(pUnitNode != NULL)
	{
		pLoopUnit = ::getUnit(*pUnitNode);
		pUnitNode = oldUnits.next(pUnitNode);

		if(pLoopUnit && pLoopUnit->getTeam() != getTeam())
		{
			if(pLoopUnit->IsImmobile() && !pLoopUnit->isCargo())
			{
				pLoopUnit->kill(false, GetID());
#if defined(MOD_API_EXTENSIONS)
				DoUnitKilledCombat(NULL, pLoopUnit->getOwner(), pLoopUnit->getUnitType());
#else
				DoUnitKilledCombat(pLoopUnit->getOwner(), pLoopUnit->getUnitType());
#endif
			}
		}
	}
	if(bConquest)
	{
#if defined(MOD_BALANCE_CORE)
		if(!isHuman())
		{
			GetDiplomacyAI()->SetPlayerNumTurnsSinceCityCapture(pOldCity->getOwner(), 0);
		}
		GET_PLAYER(pOldCity->getOwner()).GetDiplomacyAI()->SetPlayerNumTurnsSinceCityCapture(GetID(), 0);
#endif
#if defined(MOD_BALANCE_CORE)
		if (pOldCity->GetCityReligions()->IsHolyCityAnyReligion())
		{
			UpdateReligion();
		}

#endif
		CvNotifications* pNotifications = GET_PLAYER(pOldCity->getOwner()).GetNotifications();
		if(pNotifications)
		{
			Localization::String locString = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_LOST");
			locString << pOldCity->getNameKey() << getNameKey();
			Localization::String locSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_LOST");
			locSummary << pOldCity->getNameKey();

#if defined(MOD_BALANCE_CORE)
			if(pOldCity->GetCityReligions()->IsHolyCityAnyReligion())
			{
				ReligionTypes eReligion = pOldCity->GetCityReligions()->GetReligionForHolyCity();
				const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, NO_PLAYER);
				if(pReligion)
				{
					CvString szReligionName = pReligion->GetName();
					locString = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_LOST_HOLY");
					locString << pOldCity->getNameKey() << getNameKey() << szReligionName;
					locSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_LOST_HOLY");
					locSummary << pOldCity->getNameKey();
				}
			}

#endif
			pNotifications->Add(NOTIFICATION_CITY_LOST, locString.toUTF8(), locSummary.toUTF8(), pOldCity->getX(), pOldCity->getY(), -1);
		}
#if defined(MOD_DIPLOMACY_CITYSTATES_QUESTS)
		if(MOD_DIPLOMACY_CITYSTATES_QUESTS && pOldCity->isBarbarian())
		{
			CvBarbarians::DoBarbCityCleared(pOldCity->plot());
		}
#endif

		if(!isBarbarian() && !pOldCity->isBarbarian())
		{
			int iDefaultCityValue = /*150*/ GC.getWAR_DAMAGE_LEVEL_CITY_WEIGHT();

			// Notify Diplo AI that damage has been done
			int iValue = iDefaultCityValue;
			iValue += pOldCity->getPopulation() * /*100*/ GC.getWAR_DAMAGE_LEVEL_INVOLVED_CITY_POP_MULTIPLIER();
			if (pOldCity->IsOriginalCapital())
			{
				iValue *= 3;
				iValue /= 2;
			}
#if defined(MOD_BALANCE_CORE)
			if(pOldCity->getNumWorldWonders() > 0)
			{
				iValue += (pOldCity->getNumWorldWonders() * /*100*/ GC.getWAR_DAMAGE_LEVEL_INVOLVED_CITY_POP_MULTIPLIER());
			}

			int iNumTimesOwned(pOldCity->GetNumTimesOwned(GetID()));
			if (iNumTimesOwned > 1)
			{
				iValue /= (iNumTimesOwned * 3);
			}
#endif

			int iWarscoremod = GetWarScoreModifier();
			if (iWarscoremod != 0)
			{
				iValue *= (iWarscoremod + 100);
				iValue /= 100;
			}

			// My viewpoint
			GetDiplomacyAI()->ChangeOtherPlayerWarValueLost(pOldCity->getOwner(), GetID(), iValue);
			// Bad guy's viewpoint
			GET_PLAYER(pOldCity->getOwner()).GetDiplomacyAI()->ChangeWarValueLost(GetID(), iValue);

			// zero out any liberation credit since we just captured a city from them
			PlayerTypes ePlayer;
			CvDiplomacyAI* pOldOwnerDiploAI = GET_PLAYER(pOldCity->getOwner()).GetDiplomacyAI();
			int iNumLiberatedCities = pOldOwnerDiploAI->GetNumCitiesLiberated(GetID());
			pOldOwnerDiploAI->ChangeNumCitiesLiberated(GetID(), -iNumLiberatedCities);

			iValue = iDefaultCityValue;
			iValue += pOldCity->getPopulation() * /*120*/ GC.getWAR_DAMAGE_LEVEL_UNINVOLVED_CITY_POP_MULTIPLIER();

			// Now update everyone else in the world, but use a different multiplier (since they don't have complete info on the situation - they don't know when Units are killed)
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
			{
				ePlayer = (PlayerTypes) iPlayerLoop;

				// Not us and not the player we acquired City from
				if(ePlayer != GetID() && ePlayer != pOldCity->getOwner())
				{
					GET_PLAYER(ePlayer).GetDiplomacyAI()->ChangeOtherPlayerWarValueLost(pOldCity->getOwner(), GetID(), iValue);
				}
			}

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
			if (MOD_DIPLOMACY_CIV4_FEATURES) {
				// Only on conquest
				if(bConquest) {
					// Vassalage stuff
					TeamTypes eMaster = GET_TEAM(GET_PLAYER(pOldCity->getOwner()).getTeam()).GetMaster();
					if(eMaster != NO_TEAM) {
						for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
						{
							ePlayer = (PlayerTypes) iPlayerLoop;
						
							if(GET_PLAYER(ePlayer).getTeam() == eMaster) {
								// This team was the master of the loser's team
								if(GET_PLAYER(pOldCity->getOwner()).getTeam() == eMaster)
								{
									// Master's failed protect score goes up for Vassal
									GET_PLAYER(pOldCity->getOwner()).GetDiplomacyAI()->ChangeVassalFailedProtectValue(ePlayer, iValue);
								}

								// Notify Diplo AI that our master has killed a city in a civ near our empire
								// Conquering team is the master
								if(getTeam() == eMaster)
								{
									// Old city was neighbors to us
									if(GET_PLAYER(ePlayer).GetProximityToPlayer(pOldCity->getOwner()) <= PLAYER_PROXIMITY_CLOSE)
									{
										// Master protected us against our enemy!
										GET_PLAYER(ePlayer).GetDiplomacyAI()->ChangeVassalProtectValue(GetID(), iValue);
									}
								}
							}
						}
					}
				}
			}
#endif
		}

		GetMilitaryAI()->LogCityCaptured(pOldCity, pOldCity->getOwner());
	}

#if defined(MOD_BALANCE_CORE)
	// Check if we want to keep this city - compare yields with our capital
	bool bAllowRaze = true;
	CvCity* pCapital = getCapitalCity();
	if (pCapital)
	{
		int iGoodCategories = 0;
		for (int i = 0; i < 6; i++)
			if (pOldCity->getYieldRateTimes100((YieldTypes)i, true) * 2 > pCapital->getYieldRateTimes100((YieldTypes)i, true))
				iGoodCategories++;

		bAllowRaze = (iGoodCategories < 3);
	}

	// Remove Corporation from this city if acquired to another player by any means
	if (pOldCity->getOwner() != NO_PLAYER && pOldCity->getOwner() != GetID())
	{
		GET_PLAYER(pOldCity->getOwner()).GetCorporations()->ClearCorporationFromCity(pOldCity);
	}
	if (GET_PLAYER(pOldCity->getOwner()).isMinorCiv())
	{
		GET_PLAYER(pOldCity->getOwner()).GetMinorCivAI()->DoUpdateAlliesResourceBonus(GET_PLAYER(pOldCity->getOwner()).GetMinorCivAI()->GetAlly(), GET_PLAYER(pOldCity->getOwner()).GetMinorCivAI()->GetAlly());
	}
#endif

	if(pOldCity->getOriginalOwner() == pOldCity->getOwner())
	{
		GET_PLAYER(pOldCity->getOriginalOwner()).changeCitiesLost(1);
	}
	else if(pOldCity->getOriginalOwner() == GetID())
	{
		GET_PLAYER(pOldCity->getOriginalOwner()).changeCitiesLost(-1);
	}

	if(bConquest)
	{
		if(GetID() == GC.getGame().getActivePlayer())
		{
			strBuffer = GetLocalizedText("TXT_KEY_MISC_CAPTURED_CITY", pOldCity->getNameKey()).GetCString();
			GC.GetEngineUserInterface()->AddCityMessage(0, pOldCity->GetIDInfo(), GetID(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_CITYCAPTURE", MESSAGE_TYPE_MAJOR_EVENT, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pOldCity->getX(), pOldCity->getY(), true, true*/);
		}

		strName.Format("%s (%s)", pOldCity->getName().GetCString(), GET_PLAYER(pOldCity->getOwner()).getName());

		for(iI = 0; iI < MAX_PLAYERS; iI++)
		{
			if((PlayerTypes)iI == GC.getGame().getActivePlayer())
			{
				if(GET_PLAYER((PlayerTypes)iI).isAlive())
				{
					if(iI != GetID())
					{
						if(pOldCity->isRevealed(GET_PLAYER((PlayerTypes)iI).getTeam(), false))
						{
							strBuffer = GetLocalizedText("TXT_KEY_MISC_CITY_CAPTURED_BY", strName.GetCString(), getCivilizationShortDescriptionKey());
							GC.GetEngineUserInterface()->AddCityMessage(0, pOldCity->GetIDInfo(), ((PlayerTypes)iI), false, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_CITYCAPTURED", MESSAGE_TYPE_MAJOR_EVENT, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pOldCity->getX(), pOldCity->getY(), true, true*/);
						}
					}
				}
			}
		}

		strBuffer = GetLocalizedText("TXT_KEY_MISC_CITY_WAS_CAPTURED_BY", strName.GetCString(), getCivilizationShortDescriptionKey());
		GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, GetID(), strBuffer, pOldCity->getX(), pOldCity->getY());

#ifndef FINAL_RELEASE
		OutputDebugString("\n"); OutputDebugString(strBuffer); OutputDebugString("\n\n");
#endif
#if defined(MOD_BALANCE_CORE)
		CvNotifications* pNotifications2 = GetNotifications();
		if(pNotifications2)
		{
			if(pOldCity->GetCityReligions()->IsHolyCityAnyReligion())
			{
				ReligionTypes eReligion = pOldCity->GetCityReligions()->GetReligionForHolyCity();
				const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, NO_PLAYER);
				if(pReligion)
				{
					CvString szReligionName = pReligion->GetName();
					Localization::String locString = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_GAINED_HOLY");
					locString << pOldCity->getNameKey() << szReligionName;
					Localization::String locSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_GAINED_HOLY");
					locSummary << pOldCity->getNameKey();

					pNotifications2->Add(NOTIFICATION_CAPITAL_RECOVERED, locString.toUTF8(), locSummary.toUTF8(), pOldCity->getX(), pOldCity->getY(), -1);
				}
			}
		}
#endif
	}

	iCaptureGold = 0;
	iCaptureCulture = 0;
	iCaptureGreatWorks = 0;

	if(bConquest)
	{
		iCaptureGold = 0;

		iCaptureGold += GC.getBASE_CAPTURE_GOLD();
		iCaptureGold += (pOldCity->getPopulation() * GC.getCAPTURE_GOLD_PER_POPULATION());
		iCaptureGold += GC.getGame().getSmallFakeRandNum(GC.getCAPTURE_GOLD_RAND1(), pOldCity->plot()->GetPlotIndex()) * 2;
		iCaptureGold += GC.getGame().getSmallFakeRandNum(GC.getCAPTURE_GOLD_RAND2(), GET_PLAYER(pOldCity->getOwner()).getGlobalAverage(YIELD_CULTURE)) * 2;

		if(GC.getCAPTURE_GOLD_MAX_TURNS() > 0)
		{
			iCaptureGold *= range((GC.getGame().getGameTurn() - pOldCity->getGameTurnAcquired()), 0, GC.getCAPTURE_GOLD_MAX_TURNS());
			iCaptureGold /= GC.getCAPTURE_GOLD_MAX_TURNS();
		}

		iCaptureGold *= (100 + pOldCity->getCapturePlunderModifier()) / 100;
		iCaptureGold *= (100 + GetPlayerTraits()->GetPlunderModifier()) / 100;
	}

	GetTreasury()->ChangeGold(iCaptureGold);

	if(bConquest)
	{
		iCaptureCulture = pOldCity->getJONSCulturePerTurn();
		iCaptureCulture *= GetPlayerPolicies()->GetNumericModifier(POLICYMOD_CULTURAL_PLUNDER_MULTIPLIER);

		if(iCaptureCulture > 0)
		{
			changeJONSCulture(iCaptureCulture);
		}
	}

	if(bConquest)
	{
		if (GetPlayerTraits()->IsTechFromCityConquer())
		{
			// Will this be the first time we have owned this city?
			if (!pOldCity->isEverOwned(GetID()))
			{
#if defined(MOD_ALTERNATE_ASSYRIA_TRAIT)
				if(MOD_ALTERNATE_ASSYRIA_TRAIT)
				{
					if(!isHuman())
					{
						AI_chooseFreeTech();
					}
					else
					{
						const char* strTargetNameKey = pOldCity->getNameKey();
						Localization::String localizedText = Localization::Lookup("TXT_KEY_SCIENCE_BOOST_CONQUEST_ASSYRIA");
						localizedText << strTargetNameKey;
						chooseTech(1, localizedText.toUTF8());
					}
				}
				else
					DoTechFromCityConquer(pOldCity);
#else
				DoTechFromCityConquer(pOldCity);
#endif
			}
		}
#if defined(MOD_BALANCE_CORE)
		if(GetPlayerTraits()->IsConquestOfTheWorld())
		{
			if (!pOldCity->isEverOwned(GetID()))
			{
				int iValue = GetGoldenAgeProgressMeter();
				if(isGoldenAge())
				{
					changeGoldenAgeTurns(3, iValue);
				}
				else
				{
					changeGoldenAgeTurns(5, iValue);
				}
			}
		}
#endif
	}
#if defined(MOD_BALANCE_CORE)
	if (!pOldCity->isEverOwned(GetID()))
	{
		int iExtraTerritoryClaim = GetPlayerTraits()->GetExtraConqueredCityTerritoryClaimRange();
		for (int i = 0; i < iExtraTerritoryClaim; i++)
		{
			CvPlot* pPlotToAcquire = pOldCity->GetNextBuyablePlot(false);

			// maybe the player owns ALL of the plots or there are none available?
			if(pPlotToAcquire)
			{
				pOldCity->DoAcquirePlot(pPlotToAcquire->getX(), pPlotToAcquire->getY());
			}
		}
	}
#endif
#if defined(MOD_BALANCE_CORE)
	if(bConquest && MOD_BALANCE_CORE)
	{
		// Will this be the first time we have owned this city?
		if (!pOldCity->isEverOwned(GetID()))
		{
			if (GetPlayerTraits()->GetCultureBonusModifierConquest() > 0)
			{
				int iValue = (pOldCity->getPopulation() / 2);
				iValue *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iValue /= 100;
				if (iValue > 0)
				{
					ChangeCultureBonusTurnsConquest(iValue);
					if (GetID() == GC.getGame().getActivePlayer())
					{
						Localization::String strMessage;
						Localization::String strSummary;
						strMessage = Localization::Lookup("TXT_KEY_CULTURE_BOOST_ART");
						strMessage << iValue;
						strMessage << pOldCity->getNameKey();
						strMessage << GetPlayerTraits()->GetCultureBonusModifierConquest();
						strSummary = Localization::Lookup("TXT_KEY_CULTURE_BOOST_ART_SUMMARY");

						CvNotifications* pNotification = GetNotifications();
						if (pNotification)
						{
							pNotification->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), pOldCity->getX(), pOldCity->getY(), (int)pOldCity->GetID(), GetID());
						}
					}
					if ((GC.getLogging() && GC.getAILogging()))
					{
						CvGameCulture *pCulture = GC.getGame().GetGameCulture();
						if (pCulture)
						{
							CvString strLogString;
							strLogString.Format("Conquest culture boost: %d", (pOldCity->getPopulation() / 2));
							GetHomelandAI()->LogHomelandMessage(strLogString);
						}
					}
				}
			}
			if (GetPlayerTraits()->GetProductionBonusModifierConquest() > 0)
			{
				int iValue = (pOldCity->getPopulation() / 2);
				iValue *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iValue /= 100;
				if (iValue > 0)
				{
					ChangeProductionBonusTurnsConquest(iValue);
					if (GetID() == GC.getGame().getActivePlayer())
					{
						Localization::String strMessage;
						Localization::String strSummary;
						strMessage = Localization::Lookup("TXT_KEY_PRODUCTION_BOOST_ART");
						strMessage << (pOldCity->getPopulation() / 2);
						strMessage << pOldCity->getNameKey();
						strMessage << GetPlayerTraits()->GetProductionBonusModifierConquest();
						strSummary = Localization::Lookup("TXT_KEY_PRODUCTION_BOOST_ART_SUMMARY");

						CvNotifications* pNotification = GetNotifications();
						if (pNotification)
						{
							pNotification->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), pOldCity->getX(), pOldCity->getY(), (int)pOldCity->GetID(), GetID());
						}
					}
					if ((GC.getLogging() && GC.getAILogging()))
					{
						CvGameCulture *pCulture = GC.getGame().GetGameCulture();
						if (pCulture)
						{
							CvString strLogString;
							strLogString.Format("Conquest production boost: %d", (pOldCity->getPopulation() / 2));
							GetHomelandAI()->LogHomelandMessage(strLogString);
						}
					}
				}
			}
			if (GetPlayerTraits()->IsFreeGreatWorkOnConquest())
			{
				DoFreeGreatWorkOnConquest(pOldCity->getOwner(), pOldCity);
			}
			if (GetPlayerTraits()->GetCityConquestGWAM() > 0)
			{
				doInstantGWAM(NO_GREATPERSON, pOldCity->getName(), true);
			}
#if defined(MOD_BALANCE_CORE)
			if (GetPlayerTraits()->IsExpansionWLTKD())
			{
				int iWLTKD = (GC.getCITY_RESOURCE_WLTKD_TURNS() / 3);

				iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iWLTKD /= 100;

				if (iWLTKD > 0)
				{
					CvCity* pLoopCity;
					int iCityLoop;

					// Loop through owner's cities.
					for (pLoopCity = firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = nextCity(&iCityLoop))
					{
						if (pLoopCity != NULL)
						{
							pLoopCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
						}
					}
					CvNotifications* pNotifications = GetNotifications();
					if (pNotifications)
					{
						Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UA_CITY_CONQUEST");
						strText << iWLTKD << GetPlayerTraits()->GetGrowthBoon();
						Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UA_CITY_CONQUEST");
						pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pOldCity->getX(), pOldCity->getY(), -1);
					}
				}
			}
#endif
		}
	}
#endif
#if defined(MOD_BALANCE_CORE_BELIEFS)
	if(bConquest)
	{
		if (!pOldCity->isEverOwned(GetID()))
		{
			int iScaler = pOldCity->getPopulation() / 3;
			if(iScaler <= 0)
			{
				iScaler = 1;
			}
			doInstantYield(INSTANT_YIELD_TYPE_F_CONQUEST, false, NO_GREATPERSON, NO_BUILDING, iScaler, true, NO_PLAYER, NULL, false, NULL, false, true, false, NO_YIELD, NULL, NO_TERRAIN, NULL, pOldCity);

			if(MOD_BALANCE_CORE_LUXURIES_TRAIT && !isMinorCiv() && !isBarbarian() && (GetPlayerTraits()->GetUniqueLuxuryQuantity() > 0))
			{
				GetPlayerTraits()->AddUniqueLuxuriesAround(pOldCity, GetPlayerTraits()->GetUniqueLuxuryQuantity());
			}
		}
		if(MOD_BALANCE_CORE_AFRAID_ANNEX)
		{
			if(GetPlayerTraits()->IsBullyAnnex() && !bGift)
			{
				if(pOldCity->GetPlayer()->isMinorCiv() && !pOldCity->isEverOwned(GetID()))
				{
					//int iGoldenAge = pOldCity->getPopulation() * 20;
					//ChangeGoldenAgeProgressMeter(iGoldenAge);
					//do we get a lump some of yields from this?
					if (GetPlayerTraits()->GetBullyYieldMultiplierAnnex() != 0)
					{
						MinorCivTraitTypes eTrait = pOldCity->GetPlayer()->GetMinorCivAI()->GetTrait();

						switch (eTrait)
						{
						case(MINOR_CIV_TRAIT_CULTURED) :
						{
							int iYield = pOldCity->GetPlayer()->GetMinorCivAI()->GetYieldTheftAmount(GetID(), YIELD_CULTURE);
							iYield *= GetPlayerTraits()->GetBullyYieldMultiplierAnnex();
							iYield /= 100;
							doInstantYield(INSTANT_YIELD_TYPE_BULLY, true, NO_GREATPERSON, NO_BUILDING, iYield, true, NO_PLAYER, NULL, false, getCapitalCity(), false, true, false, YIELD_CULTURE);
							break;
						}
						case(MINOR_CIV_TRAIT_MARITIME) :
						{
							int iYield = pOldCity->GetPlayer()->GetMinorCivAI()->GetYieldTheftAmount(GetID(), YIELD_FOOD);
							iYield *= GetPlayerTraits()->GetBullyYieldMultiplierAnnex();
							iYield /= 100;
							doInstantYield(INSTANT_YIELD_TYPE_BULLY, true, NO_GREATPERSON, NO_BUILDING, iYield, true, NO_PLAYER, NULL, false, getCapitalCity(), false, true, false, YIELD_FOOD);
							break;
						}
						case(MINOR_CIV_TRAIT_MERCANTILE) :
						{
							int iYield = pOldCity->GetPlayer()->GetMinorCivAI()->GetYieldTheftAmount(GetID(), YIELD_GOLD);
							iYield *= GetPlayerTraits()->GetBullyYieldMultiplierAnnex();
							iYield /= 100;
							doInstantYield(INSTANT_YIELD_TYPE_BULLY, true, NO_GREATPERSON, NO_BUILDING, iYield, true, NO_PLAYER, NULL, false, getCapitalCity(), false, true, false, YIELD_GOLD);
							break;
						}
						case(MINOR_CIV_TRAIT_MILITARISTIC) :
						{
							int iYield = pOldCity->GetPlayer()->GetMinorCivAI()->GetYieldTheftAmount(GetID(), YIELD_SCIENCE);
							iYield *= GetPlayerTraits()->GetBullyYieldMultiplierAnnex();
							iYield /= 100;
							doInstantYield(INSTANT_YIELD_TYPE_BULLY, true, NO_GREATPERSON, NO_BUILDING, iYield, true, NO_PLAYER, NULL, false, getCapitalCity(), false, true, false, YIELD_SCIENCE);
							break;
						}
						case(MINOR_CIV_TRAIT_RELIGIOUS) :
						{
							int iYield = pOldCity->GetPlayer()->GetMinorCivAI()->GetYieldTheftAmount(GetID(), YIELD_FAITH);
							iYield *= GetPlayerTraits()->GetBullyYieldMultiplierAnnex();
							iYield /= 100;
							doInstantYield(INSTANT_YIELD_TYPE_BULLY, true, NO_GREATPERSON, NO_BUILDING, iYield, true, NO_PLAYER, NULL, false, getCapitalCity(), false, true, false, YIELD_FAITH);
							break;
						}
						}
					}
				}
			}
		}
	}
#endif

	// slewis - warmonger calculations
	if (bConquest)
	{
#if defined(MOD_DIPLOMACY_CITYSTATES_QUESTS)
		if(!isMinorCiv() && !isBarbarian())
#else
		if(!isMinorCiv())
#endif
		{
			bool bDoWarmonger = true;

			// Don't award warmongering if you're conquering a city you owned back
			if (pOldCity->getOriginalOwner() == GetID())
			{
				bDoWarmonger = false;
			}
#if defined(MOD_BALANCE_CORE)
			// Don't award warmongering if you're conquering a city that you were the last to own.
			if (pOldCity->getPreviousOwner() == GetID())
			{
				bDoWarmonger = false;
			}
			//Captured a city from barbs? Everyone likes that!
			if(GET_PLAYER(pOldCity->getOwner()).isBarbarian())
			{
				bDoWarmonger = false;
			}
			PlayerTypes eLiberatedPlayer = NO_PLAYER;

			// Captured someone's city that didn't originally belong to us - Liberate a player?
			eOldOwner = pOldCity->getOwner();
			if(pOldCity->getOriginalOwner() != eOldOwner && pOldCity->getOriginalOwner() != GetID())
			{
				eLiberatedPlayer = pOldCity->getOriginalOwner();
				if (IsAtWarWith(eLiberatedPlayer) && pOldCity->getOriginalOwner() != pOldCity->getPreviousOwner() && pOldCity->getPreviousOwner() != NO_PLAYER)
				{
					if (GET_PLAYER(pOldCity->getPreviousOwner()).isMinorCiv())
					{
						eLiberatedPlayer = pOldCity->getPreviousOwner();
					}
				}
				if(eLiberatedPlayer != NO_PLAYER)
				{
					if (CanLiberatePlayerCity(eLiberatedPlayer))
					{
						bDoWarmonger = false;
						pOldCity->SetNoWarmonger(true);
					}
				}
			}
#endif

			if (bDoWarmonger)
			{
				CvDiplomacyAIHelpers::ApplyWarmongerPenalties(GetID(), pOldCity->getOwner(), pOldCity->isCapital(), pOldCity);
#if defined(MOD_BALANCE_CORE)
				pOldCity->SetNoWarmonger(false);
#endif
			}
		}
	}
#if defined(MOD_BALANCE_CORE)
	//Let's not slaughter citizens in a city we've owned before.
	bool bSlaughter = true;
	if(bConquest)
	{
		//Our city originally? Don't slaughter.
		if(pOldCity->getOriginalOwner() == GetID())
		{
			bSlaughter = false;
		}
		//We are liberators, so don't slaughter.
		if(pOldCity->isBarbarian())
		{
			bSlaughter = false;
		}
		//Recently captured and still in resistance? Don't slaughter.
		if(pOldCity->IsResistance() || pOldCity->IsRazing())
		{
			bSlaughter = false;
		}
	}
#endif
	int iNumBuildingInfos = GC.getNumBuildingInfos();
	std::vector<int> paiNumRealBuilding(iNumBuildingInfos, 0);
	std::vector<int> paiNumFreeBuilding(iNumBuildingInfos, 0);
	std::vector<int> paiBuildingOriginalOwner(iNumBuildingInfos, 0);
	std::vector<int> paiBuildingOriginalTime(iNumBuildingInfos, 0);
#if defined(MOD_BALANCE_CORE)
	int iNumReligions = GC.getNumReligionInfos();
	std::vector<bool> pabAdoptionBonus(iNumReligions, false);
#endif
	struct CopyGreatWorkData
	{
		int m_iGreatWork;
		BuildingTypes m_eBuildingType;
		int m_iSlot;
		bool m_bTransferred;
	};
	std::vector<CopyGreatWorkData> paGreatWorkData;
	int iOldCityX = pOldCity->getX();
	int iOldCityY = pOldCity->getY();
	eOldOwner = pOldCity->getOwner();
	eOriginalOwner = pOldCity->getOriginalOwner();
	iGameTurnFounded = pOldCity->getGameTurnFounded();
	iPopulation = pOldCity->getPopulation();
	iOldPopulation = iPopulation;
	iHighestPopulation = pOldCity->getHighestPopulation();
	strName = pOldCity->getNameKey();
	int iOldCultureLevel = pOldCity->GetJONSCultureLevel();
	bool bHasMadeAttack = pOldCity->isMadeAttack();
#if defined(MOD_BALANCE_CORE)
	bool bNeedsWarmonger = pOldCity->IsNoWarmongerYet();
#endif

	tempReligions.Init(pOldCity);
	tempReligions.Copy(pOldCity->GetCityReligions());

	iBattleDamage = pOldCity->getDamage();

	// Traded cities between humans don't heal (an exploit would be to trade a city back and forth between teammates to get an instant heal.)
	if(!bGift || !isHuman() || !GET_PLAYER(pOldCity->getOwner()).isHuman())
	{
		int iBattleDamgeThreshold = pOldCity->GetMaxHitPoints() * /*50*/ GC.getCITY_CAPTURE_DAMAGE_PERCENT();
		iBattleDamgeThreshold /= 100;

		if(iBattleDamage > iBattleDamgeThreshold)
		{
			iBattleDamage = iBattleDamgeThreshold;
		}
	}

	for(iI = 0; iI < MAX_PLAYERS; iI++)
	{
		abEverOwned[iI] = pOldCity->isEverOwned((PlayerTypes)iI);
	}

	abEverOwned[GetID()] = true;
#if defined(MOD_BALANCE_CORE)
	bool abTraded[MAX_PLAYERS];
	int aiNumTimesOwned[MAX_PLAYERS];
	for(iI = 0; iI < MAX_PLAYERS; iI++)
	{
		abTraded[iI] = pOldCity->IsTraded((PlayerTypes)iI);
		aiNumTimesOwned[iI] = pOldCity->GetNumTimesOwned((PlayerTypes)iI);
	}
	for(iI = 0; iI < GC.getNumReligionInfos(); iI++)
	{
		ReligionTypes eReligion = (ReligionTypes)iI;
		CvReligionEntry* pEntry = GC.getReligionInfo(eReligion);
		if(!pEntry)
		{
			continue;
		}
		if(eReligion == RELIGION_PANTHEON)
			continue;

		pabAdoptionBonus[eReligion] = pOldCity->HasPaidAdoptionBonus(eReligion);
	}
#endif

	for(iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		paiNumRealBuilding[iI] = pOldCity->GetCityBuildings()->GetNumRealBuilding((BuildingTypes)iI);
		paiNumFreeBuilding[iI] = pOldCity->GetCityBuildings()->GetNumFreeBuilding((BuildingTypes)iI);
		paiBuildingOriginalOwner[iI] = pOldCity->GetCityBuildings()->GetBuildingOriginalOwner((BuildingTypes)iI);
		paiBuildingOriginalTime[iI] = pOldCity->GetCityBuildings()->GetBuildingOriginalTime((BuildingTypes)iI);

		if (pOldCity->GetCityBuildings()->GetNumBuilding((BuildingTypes)iI) > 0)
		{
			CvBuildingEntry *pkBuilding = GC.getBuildingInfo((BuildingTypes)iI);
			if (pkBuilding)
			{
				for (int jJ = 0; jJ < pkBuilding->GetGreatWorkCount(); jJ++)
				{
					int iGreatWork = pOldCity->GetCityBuildings()->GetBuildingGreatWork((BuildingClassTypes)pkBuilding->GetBuildingClassType(), jJ);
					if (iGreatWork != NO_GREAT_WORK)
					{
						CopyGreatWorkData kData;
						kData.m_iGreatWork = iGreatWork;
						kData.m_eBuildingType = (BuildingTypes)iI;
						kData.m_iSlot = jJ;
						kData.m_bTransferred = false;
						paGreatWorkData.push_back(kData);

						CvPlayer &kOldCityPlayer = GET_PLAYER(pOldCity->getOriginalOwner());
						if (kOldCityPlayer.GetCulture()->GetSwappableWritingIndex() == iGreatWork)
						{
							kOldCityPlayer.GetCulture()->SetSwappableWritingIndex(-1);
						}
						if (kOldCityPlayer.GetCulture()->GetSwappableArtifactIndex() == iGreatWork)
						{
							kOldCityPlayer.GetCulture()->SetSwappableArtifactIndex(-1);
						}
						if (kOldCityPlayer.GetCulture()->GetSwappableArtIndex() == iGreatWork)
						{
							kOldCityPlayer.GetCulture()->SetSwappableArtIndex(-1);
						}
						if (kOldCityPlayer.GetCulture()->GetSwappableMusicIndex() == iGreatWork)
						{
							kOldCityPlayer.GetCulture()->SetSwappableMusicIndex(-1);
						}
					}
				}
			}
		}
	}

	std::vector<BuildingYieldChange> aBuildingYieldChange;
	for(iI = 0; iI < GC.getNumBuildingClassInfos(); ++iI)
	{
		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo((BuildingClassTypes)iI);
		if(!pkBuildingClassInfo)
		{
			continue;
		}

		for(int iYield = 0; iYield < NUM_YIELD_TYPES; ++iYield)
		{
			BuildingYieldChange kChange;
			kChange.eBuildingClass = (BuildingClassTypes)iI;
			kChange.eYield = (YieldTypes)iYield;
			kChange.iChange = pOldCity->GetCityBuildings()->GetBuildingYieldChange((BuildingClassTypes)iI, (YieldTypes)iYield);
			if(0 != kChange.iChange)
			{
				aBuildingYieldChange.push_back(kChange);
			}
		}
	}

	bRecapture = false; //((eHighestCulturePlayer != NO_PLAYER) ? (GET_PLAYER(eHighestCulturePlayer).getTeam() == getTeam()) : false);

	// Returning spies back to pool
	CvCityEspionage* pOldCityEspionage = pOldCity->GetCityEspionage();
	if(pOldCityEspionage)
	{
		for(int i = 0; i < MAX_MAJOR_CIVS; i++)
		{
			int iAssignedSpy = pOldCityEspionage->m_aiSpyAssignment[i];
			// if there is a spy in the city
			if(iAssignedSpy != -1)
			{
				CvNotifications* pNotifications = GET_PLAYER((PlayerTypes)i).GetNotifications();
				if(pNotifications)
				{
					CvPlayerEspionage* pEspionage = GET_PLAYER((PlayerTypes)i).GetEspionage();
					CvEspionageSpy* pSpy = &(pEspionage->m_aSpyList[iAssignedSpy]);

					Localization::String strSummary;
					Localization::String strNotification;
					if(bConquest)
					{
						strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SPY_EVICTED_CONQUEST_S");
						if(((PlayerTypes)i) == GetID())
						{
							strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_EVICTED_CONQUEST_YOU");
							strNotification << pEspionage->GetSpyRankName(pSpy->m_eRank);
#if defined(MOD_BUGFIX_SPY_NAMES)
							strNotification << pSpy->GetSpyName(&GET_PLAYER((PlayerTypes)i));
#else
							strNotification << GET_PLAYER((PlayerTypes)i).getCivilizationInfo().getSpyNames(pSpy->m_iName);
#endif
							strNotification << pOldCity->getNameKey();
						}
						else
						{
							strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_EVICTED_CONQUEST");
							strNotification << pEspionage->GetSpyRankName(pSpy->m_eRank);
#if defined(MOD_BUGFIX_SPY_NAMES)
							strNotification << pSpy->GetSpyName(&GET_PLAYER((PlayerTypes)i));
#else
							strNotification << GET_PLAYER((PlayerTypes)i).getCivilizationInfo().getSpyNames(pSpy->m_iName);
#endif
							strNotification << pOldCity->getNameKey();
							strNotification << getCivilizationInfo().getShortDescriptionKey();
						}
					}
					else
					{
						strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SPY_EVICTED_TRADE_S");
						if(((PlayerTypes)i) == GetID())
						{
							strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_EVICTED_TRADE_YOU");
							strNotification << pEspionage->GetSpyRankName(pSpy->m_eRank);
#if defined(MOD_BUGFIX_SPY_NAMES)
							strNotification << pSpy->GetSpyName(&GET_PLAYER((PlayerTypes)i));
#else
							strNotification << GET_PLAYER((PlayerTypes)i).getCivilizationInfo().getSpyNames(pSpy->m_iName);
#endif
							strNotification << pOldCity->getNameKey();
						}
						else
						{
							strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_SPY_EVICTED_TRADE");
							strNotification << pEspionage->GetSpyRankName(pSpy->m_eRank);
#if defined(MOD_BUGFIX_SPY_NAMES)
							strNotification << pSpy->GetSpyName(&GET_PLAYER((PlayerTypes)i));
#else
							strNotification << GET_PLAYER((PlayerTypes)i).getCivilizationInfo().getSpyNames(pSpy->m_iName);
#endif
							strNotification << pOldCity->getNameKey();
							strNotification << getCivilizationInfo().getShortDescriptionKey();
						}
					}

					pNotifications->Add(NOTIFICATION_SPY_EVICTED, strNotification.toUTF8(), strSummary.toUTF8(), -1, -1, pOldCity->getOwner());
				}

				GET_PLAYER((PlayerTypes)i).GetEspionage()->ExtractSpyFromCity(iAssignedSpy);
				// create notifications indicating what has happened with the spy
			}
		}
	}

	GC.getGame().GetGameTrade()->ClearAllCityTradeRoutes(pCityPlot);

	bool bCapital = pOldCity->isCapital();

	// find the plot
	FStaticVector<int, 121, true, c_eCiv5GameplayDLL, 0> aiPurchasedPlotX;
	FStaticVector<int, 121, true, c_eCiv5GameplayDLL, 0> aiPurchasedPlotY;
	const int iMaxRange = /*5*/ GC.getMAXIMUM_ACQUIRE_PLOT_DISTANCE();

	for(int iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);
		if(pLoopPlot && pLoopPlot->GetCityPurchaseOwner() == eOldOwner && pLoopPlot->GetCityPurchaseID() == pOldCity->GetID())
		{
			aiPurchasedPlotX.push_back(pLoopPlot->getX());
			aiPurchasedPlotY.push_back(pLoopPlot->getY());
			pLoopPlot->ClearCityPurchaseInfo();
		}
	}

	int iOldCityRings = pOldCity->getWorkPlotDistance();

#if defined(MOD_GLOBAL_VENICE_KEEPS_RESOURCES)
	pOldCity->PreKill(bVenice);
#else
	pOldCity->PreKill();
#endif

	{
		auto_ptr<ICvCity1> pkDllOldCity(new CvDllCity(pOldCity));
		gDLL->GameplayCityCaptured(pkDllOldCity.get(), GetID());
	}

	GET_PLAYER(eOldOwner).deleteCity(pOldCity->GetID());
	// adapted from PostKill()

	GC.getGame().addReplayMessage(REPLAY_MESSAGE_CITY_CAPTURED, m_eID, "", pCityPlot->getX(), pCityPlot->getY());

	PlayerTypes ePlayer;
	// Update Proximity between this Player and all others
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		ePlayer = (PlayerTypes) iPlayerLoop;

		if(ePlayer != m_eID)
		{
			if(GET_PLAYER(ePlayer).isAlive())
			{
				GET_PLAYER(m_eID).DoUpdateProximityToPlayer(ePlayer);
				GET_PLAYER(ePlayer).DoUpdateProximityToPlayer(m_eID);
			}
		}
	}

	GC.getMap().updateOwningCity(pCityPlot,iOldCityRings*2);
	// Lost the capital!
	if(bCapital)
	{
#if defined(MOD_GLOBAL_NO_CONQUERED_SPACESHIPS)
		GET_PLAYER(eOldOwner).disassembleSpaceship(pCityPlot);
#endif
		GET_PLAYER(eOldOwner).findNewCapital();
		GET_TEAM(getTeam()).resetVictoryProgress();
	}

	GC.GetEngineUserInterface()->setDirty(NationalBorders_DIRTY_BIT, true);
	// end adapted from PostKill()

#if defined(MOD_API_EXTENSIONS)
	pNewCity = initCity(pCityPlot->getX(), pCityPlot->getY(), !bConquest, (!bConquest && !bGift), NO_RELIGION, strName.c_str());
#else
	pNewCity = initCity(pCityPlot->getX(), pCityPlot->getY(), !bConquest, (!bConquest && !bGift));
#endif

	CvAssertMsg(pNewCity != NULL, "NewCity is not assigned a valid value");

#ifdef _MSC_VER
#pragma warning ( push )
#pragma warning ( disable : 6011 ) 
#endif

	// For buyouts, set it up like a new city founded by this player, to avoid liberation later on etc.
	if(bIsMinorCivBuyout)
	{
#if defined(MOD_GLOBAL_CS_LIBERATE_AFTER_BUYOUT)
		if (MOD_GLOBAL_CS_LIBERATE_AFTER_BUYOUT)
		{
			pNewCity->setPreviousOwner(eOldOwner);
			pNewCity->setOriginalOwner(eOriginalOwner);
			pNewCity->setGameTurnFounded(iGameTurnFounded);
		}
		else
		{
#endif
			pNewCity->setPreviousOwner(NO_PLAYER);
			pNewCity->setOriginalOwner(m_eID);
			pNewCity->setGameTurnFounded(GC.getGame().getGameTurn());
#if defined(MOD_GLOBAL_CS_LIBERATE_AFTER_BUYOUT)
		}
#endif

		AwardFreeBuildings(pNewCity);
	}
	// Otherwise, set it up using the data from the old city
	else
	{
		pNewCity->setPreviousOwner(eOldOwner);
		pNewCity->setOriginalOwner(eOriginalOwner);
		pNewCity->setGameTurnFounded(iGameTurnFounded);
	}

	// Population change for capturing a city
#if defined(MOD_BALANCE_CORE)
	if(!bRecapture && bConquest && bSlaughter)	
#else
	if(!bRecapture && bConquest)	// Don't drop it if we're recapturing our own City
#endif
	{
		int iPercentPopulationRetained = /*50*/ GC.getCITY_CAPTURE_POPULATION_PERCENT();
		int iInfluenceReduction = GetCulture()->GetInfluenceCityConquestReduction(eOldOwner);
		iPercentPopulationRetained += (iInfluenceReduction * (100 - iPercentPopulationRetained) / 100);

		iPopulation = max(1, iPopulation * iPercentPopulationRetained / 100);
	}
#if defined(MOD_BALANCE_CORE)
	pNewCity->setPopulation(iPopulation, true, true);
#else
	pNewCity->setPopulation(iPopulation);
#endif
	pNewCity->setHighestPopulation(iHighestPopulation);
	pNewCity->setName(strName);
	pNewCity->setNeverLost(false);
	pNewCity->setDamage(iBattleDamage,true);
	pNewCity->setMadeAttack(bHasMadeAttack);
#if defined(MOD_BALANCE_CORE)
	pNewCity->SetNoWarmonger(bNeedsWarmonger);
#endif

	for(iI = 0; iI < MAX_PLAYERS; iI++)
	{
		pNewCity->setEverOwned(((PlayerTypes)iI), abEverOwned[iI]);
#if defined(MOD_BALANCE_CORE)
		if((PlayerTypes)iI != NO_PLAYER)
		{
			GET_PLAYER((PlayerTypes)iI).GetCorporations()->ClearCorporationFromCity(pNewCity);
		}
#endif
#if defined(MOD_BALANCE_CORE)
		pNewCity->SetTraded(((PlayerTypes)iI), abTraded[iI]);
		pNewCity->SetNumTimesOwned(((PlayerTypes)iI), aiNumTimesOwned[iI]);
#endif
	}
#if defined(MOD_BALANCE_CORE)
	for (iI = 0; iI < GC.getNumReligionInfos(); iI++)
	{
		ReligionTypes eReligion = (ReligionTypes)iI;
		CvReligionEntry* pEntry = GC.getReligionInfo(eReligion);
		if (!pEntry)
		{
			continue;
		}
		if (eReligion == RELIGION_PANTHEON)
			continue;

		pNewCity->SetPaidAdoptionBonus(eReligion, pabAdoptionBonus[eReligion]);
	}
#endif
	//I've traded for this? I don't want to give away again
	if (bGift)
		pNewCity->SetTraded( GetID(), true);

	pNewCity->SetJONSCultureLevel(iOldCultureLevel);
	pNewCity->GetCityReligions()->Copy(&tempReligions);
	pNewCity->GetCityReligions()->RemoveFormerPantheon();

	if(bCapital)
	{
		GET_PLAYER(eOldOwner).SetHasLostCapital(true, m_eID);
	}


	if (pNewCity->GetCityReligions()->IsHolyCityAnyReligion())
	{
		ReligionTypes eReligion = pNewCity->GetCityReligions()->GetReligionForHolyCity();
		const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, NO_PLAYER);
		if (pReligion && pReligion->m_eFounder == eOldOwner)
		{
			GET_PLAYER(eOldOwner).SetHasLostHolyCity(true, m_eID);
			GET_PLAYER(eOldOwner).SetLostHolyCityXY(pNewCity->getX(), pNewCity->getY());
		}
	}

	const CvCivilizationInfo& playerCivilizationInfo = getCivilizationInfo();
#if defined(MOD_BALANCE_CORE)
	if(GetPlayerTraits()->IsReconquista())
	{
		ReligionTypes eReligion = GetReligions()->GetReligionCreatedByPlayer(false);
		if(eReligion != NO_RELIGION)
		{
			pNewCity->GetCityReligions()->AdoptReligionFully(eReligion);
		}
		else
		{
			eReligion = GetReligions()->GetReligionInMostCities();
			if(eReligion != NO_RELIGION)
			{
				pNewCity->GetCityReligions()->AdoptReligionFully(eReligion);
			}
		}
	}
#endif
#if !defined(NO_ACHIEVEMENTS)
	if(bConquest && !GC.getGame().isGameMultiPlayer() && isHuman())
	{
		const char* szCivKey = getCivilizationTypeKey();

		// Check for Kris Swordsman achievement
		if(strcmp(szCivKey, "CIVILIZATION_INDONESIA") == 0)
		{
			CvUnit *pConqueringUnit = pCityPlot->getUnitByIndex(0);
			if (pConqueringUnit->getUnitType() == (UnitTypes)GC.getInfoTypeForString("UNIT_KRIS_SWORDSMAN", true))
			{
				PromotionTypes ePromotion = (PromotionTypes)GC.getInfoTypeForString("PROMOTION_ENEMY_BLADE", true);
				if (pConqueringUnit->isHasPromotion(ePromotion))
				{
					gDLL->UnlockAchievement(ACHIEVEMENT_XP2_21);
				}
			}
		}

		// Check for Rome conquering Statue of Zeus Achievement
		bool bUsingXP1Scenario1 = gDLL->IsModActivated(CIV5_XP1_SCENARIO1_MODID);
		bool bUsingXP1Scenario2 = gDLL->IsModActivated(CIV5_XP1_SCENARIO2_MODID);
		bool bUsingXP2Scenario1 = gDLL->IsModActivated(CIV5_XP2_SCENARIO1_MODID);

		const char* szNameKey = pNewCity->getNameKey();
		if(bUsingXP2Scenario1)
		{
			if(strcmp(szCivKey, "CIVILIZATION_ENGLAND") == 0)
			{
				if(strcmp(szNameKey, "TXT_KEY_CIVIL_WAR_SCENARIO_CITY_NAME_GETTYSBURG") == 0)
				{
					CvUnit *pConqueringUnit = pCityPlot->getUnitByIndex(0);
					PromotionTypes ePromotion = (PromotionTypes)GC.getInfoTypeForString("PROMOTION_PICKETT", true);
					if (pConqueringUnit->isHasPromotion(ePromotion))
					{
						gDLL->UnlockAchievement(ACHIEVEMENT_XP2_59);
					}
				}
			}
		}

		if(bUsingXP1Scenario1)
		{
			const HandicapTypes eCurrentHandicap = GC.getGame().getHandicapType();
			HandicapTypes eEmporerHandicap = NO_HANDICAP;
			HandicapTypes eDeityHandicap = NO_HANDICAP;

			const int numHandicapInfos = GC.getNumHandicapInfos();
			for(int i = 0; i < numHandicapInfos; ++i)
			{
				const HandicapTypes eHandicap = static_cast<HandicapTypes>(i);
				CvHandicapInfo* pkInfo = GC.getHandicapInfo(eHandicap);
				if(pkInfo != NULL)
				{
					if(strcmp(pkInfo->GetType(), "HANDICAP_EMPEROR") == 0)
					{
						eEmporerHandicap = eHandicap;
					}
					else if(strcmp(pkInfo->GetType(), "HANDICAP_DEITY") == 0)
					{
						eDeityHandicap = eHandicap;
					}
				}
			}

			if(szCivKey && szNameKey)
			{
				if(strcmp(szCivKey, "CIVILIZATION_ENGLAND") == 0)
				{
					if(strcmp(szNameKey, "TXT_KEY_CITYSTATE_JERUSALEM") == 0)
					{
						if(eCurrentHandicap >= eEmporerHandicap)
						{
							gDLL->UnlockAchievement(ACHIEVEMENT_XP1_39);
						}
					}
				}
				else if(strcmp(szCivKey, "CIVILIZATION_OTTOMAN") == 0)
				{
					if(strcmp(szNameKey, "TXT_KEY_CITY_NAME_CONSTANTINOPLE") == 0)
					{
						if(eCurrentHandicap >= eDeityHandicap)
						{
							gDLL->UnlockAchievement(ACHIEVEMENT_XP1_40);
						}
					}
				}
			}	
		}

		if(bUsingXP1Scenario2)
		{
			bool bHasConstantinople = false;
			bool bHasRome = false;

			if(strcmp(szNameKey, "TXT_KEY_CITY_NAME_CONSTANTINOPLE") == 0)
			{
				bHasConstantinople = true;

				if(pNewCity->getOriginalOwner() != GetID())
				{
					gDLL->UnlockAchievement(ACHIEVEMENT_XP1_47);
				}
			}
			else if(strcmp(szNameKey, "TXT_KEY_CITY_NAME_ROME") == 0)
			{
				bHasRome = true;
			}

			if(bHasConstantinople || bHasRome)
			{
				int iLoop = 0;
				for(CvCity* pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
				{
					const char* szOtherNameKey = pCity->getNameKey();
					if(strcmp(szOtherNameKey, "TXT_KEY_CITY_NAME_CONSTANTINOPLE") == 0)
					{
						bHasConstantinople = true;
					}
					else if(strcmp(szOtherNameKey, "TXT_KEY_CITY_NAME_ROME") == 0)
					{
						bHasRome = true;
					}
				}
			}

			if(bHasRome && bHasConstantinople)
			{
				gDLL->UnlockAchievement(ACHIEVEMENT_XP1_48);
			}

			if(strcmp(getCivilizationTypeKey(), "CIVILIZATION_CELTS") == 0)
			{
				//Did we cap what was originally a sassinid city?
				typedef std::pair<int,int> Location;
				typedef std::tr1::array<Location, 7> SassanidCityArray;
				SassanidCityArray SassanidCities = {
					Location(87,17), //Ctesiphon
					Location(85,20), //Singara
					Location(81,21), //Nisibis
					Location(79,24), //Amida
					Location(82,28), //Thospia
					Location(81,33), //Anium
					Location(87,33), //Artaxata
				};
				
				int iNewPlotX = pNewCity->getX();
				int iNewPlotY = pNewCity->getY();

				//Test if we still own each city.
				for(SassanidCityArray::iterator it = SassanidCities.begin(); it != SassanidCities.end(); ++it)
				{
					if(it->first == iNewPlotX && it->second == iNewPlotY)
					{
						gDLL->UnlockAchievement(ACHIEVEMENT_XP1_51);

					}
				}
			}

		}
	}
#endif
#if defined(MOD_BALANCE_CORE)
	if(bConquest && !bGift)
	{
#endif
	std::vector<BuildingTypes> freeConquestBuildings = m_pPlayerPolicies->GetFreeBuildingsOnConquest();
	for(iI = 0; iI < (int)freeConquestBuildings.size(); iI++)
	{
		const BuildingTypes eLoopBuilding = freeConquestBuildings[iI];
		if (eLoopBuilding != NO_BUILDING)
		{
			CvBuildingEntry* pkLoopBuildingInfo = GC.getBuildingInfo(eLoopBuilding);
			if(pkLoopBuildingInfo)
			{
				if (eLoopBuilding == pkLoopBuildingInfo->GetID())
				{
#if defined(MOD_BUGFIX_BUILDINGCLASS_NOT_BUILDING)
					BuildingTypes eFreeBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(pkLoopBuildingInfo->GetBuildingClassType());
					pNewCity->GetCityBuildings()->SetNumRealBuilding(eFreeBuilding, 0);
					pNewCity->GetCityBuildings()->SetNumFreeBuilding(eFreeBuilding, 1);
#else
					pNewCity->GetCityBuildings()->SetNumFreeBuilding(eLoopBuilding, 1);
#endif
				}
			}
		}
	}
#if defined(MOD_BALANCE_CORE)
	}
	// Free Buildings from Policies
	if(MOD_BALANCE_CORE)
	{
		for(iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
		{
			const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iI);
			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
			if(pkBuildingClassInfo)
			{
				int iNumFreeBuildings = GetNumCitiesFreeChosenBuilding(eBuildingClass);
				if (iNumFreeBuildings > 0 || IsFreeChosenBuildingNewCity(eBuildingClass) || IsFreeBuildingAllCity(eBuildingClass))
				{
					const BuildingTypes eBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(pkBuildingClassInfo->GetID())));
					if(NO_BUILDING != eBuilding)
					{
						CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
						if(pkBuildingInfo)
						{
							if(pNewCity->isValidBuildingLocation(eBuilding))
							{
								if(pNewCity->GetCityBuildings()->GetNumRealBuilding(eBuilding) > 0)
								{
									pNewCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, 0);
								}

								pNewCity->GetCityBuildings()->SetNumFreeBuilding(eBuilding, 1);

								if(pNewCity->GetCityBuildings()->GetNumFreeBuilding(eBuilding) > 0)
								{
									ChangeNumCitiesFreeChosenBuilding(eBuildingClass, -1);
								}
							}
						}
					}
				}
			}
		}
	}
#endif
	BuildingTypes eTraitFreeBuilding = GetPlayerTraits()->GetFreeBuildingOnConquest();
	for(iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		const BuildingTypes eLoopBuilding = static_cast<BuildingTypes>(iI);
		CvBuildingEntry* pkLoopBuildingInfo = GC.getBuildingInfo(eLoopBuilding);
		if(pkLoopBuildingInfo)
		{
			const CvBuildingClassInfo& kLoopBuildingClassInfo = pkLoopBuildingInfo->GetBuildingClassInfo();

			int iNum = 0;

			if(eTraitFreeBuilding == pkLoopBuildingInfo->GetID())
			{
				pNewCity->GetCityBuildings()->SetNumFreeBuilding(eTraitFreeBuilding, 1);
			}

			if (GetPlayerTraits()->IsKeepConqueredBuildings() && paiNumFreeBuilding[iI] > 0)
			{
				const BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkLoopBuildingInfo->GetBuildingClassType();
				if (::isWorldWonderClass(kLoopBuildingClassInfo))
				{
					eBuilding = eLoopBuilding;
				}
#if defined(MOD_BALANCE_CORE)
				else if (GetPlayerTraits()->IsKeepConqueredBuildings())
				{
					//If we keep buildings, but we have a replacement, grab the replacement instead.
					if (playerCivilizationInfo.isCivilizationBuildingOverridden(eBuildingClass))
					{
						eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings(eBuildingClass);
					}
					else
					{
						eBuilding = eLoopBuilding;
					}
				}
#endif
				else
				{
					eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings(eBuildingClass);
				}

				if (eBuilding != NO_BUILDING)
				{
					if (!IsValidBuildingForPlayer(pNewCity, eBuilding, bGift, bRecapture))
						continue;

					CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
					if (pkBuildingInfo)
					{
						iNum += paiNumFreeBuilding[iI];

						pNewCity->GetCityBuildings()->SetNumFreeBuilding(eBuilding, iNum);

						if (pkBuildingInfo->GetGreatWorkCount() > 0)
						{
							for (unsigned int jJ = 0; jJ < paGreatWorkData.size(); jJ++)
							{
								if (paGreatWorkData[jJ].m_eBuildingType == iI)
								{
									pNewCity->GetCityBuildings()->SetBuildingGreatWork(eBuildingClass, paGreatWorkData[jJ].m_iSlot, paGreatWorkData[jJ].m_iGreatWork);
									paGreatWorkData[jJ].m_bTransferred = true;
									iCaptureGreatWorks++;
								}
							}
						}
					}
				}
			}

			else if(paiNumRealBuilding[iI] > 0)
			{
				const BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkLoopBuildingInfo->GetBuildingClassType();
				if(::isWorldWonderClass(kLoopBuildingClassInfo))
				{
					eBuilding = eLoopBuilding;
				}
#if defined(MOD_BALANCE_CORE)
				else if(GetPlayerTraits()->IsKeepConqueredBuildings())
				{
					//If we keep buildings, but we have a replacement, grab the replacement instead.
					if (playerCivilizationInfo.isCivilizationBuildingOverridden(eBuildingClass))
					{
						eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings(eBuildingClass);
					}
					else
					{
						eBuilding = eLoopBuilding;
					}
				}
#endif
				else
				{
					eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings(eBuildingClass);
				}

				if(eBuilding != NO_BUILDING)
				{
					if (!IsValidBuildingForPlayer(pNewCity, eBuilding, bGift, bRecapture))
						continue;

					CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
					if(pkBuildingInfo)
					{
						iNum += paiNumRealBuilding[iI];

#if !defined(NO_ACHIEVEMENTS)
						// Check for Tomb Raider Achievement
						if(bConquest && !GC.getGame().isGameMultiPlayer() && pkLoopBuildingInfo->GetType() && _stricmp(pkLoopBuildingInfo->GetType(), "BUILDING_BURIAL_TOMB") == 0 && isHuman())
						{
							if(iCaptureGold > 0)  //Need to actually pillage something from the 'tomb'
							{
								gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_TOMBRAIDER);
							}
						}
#endif

#if !defined(NO_ACHIEVEMENTS)
						// Check for Rome conquering Statue of Zeus Achievement
						if(bConquest && !GC.getGame().isGameMultiPlayer() && pkLoopBuildingInfo->GetType() && _stricmp(pkLoopBuildingInfo->GetType(), "BUILDING_STATUE_ZEUS") == 0 && isHuman())
						{
							const char* pkCivKey = getCivilizationTypeKey();
							if(pkCivKey && strcmp(pkCivKey, "CIVILIZATION_ROME") == 0)
							{
								gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_ROME_GETS_ZEUS);
							}
						}
#endif

						pNewCity->GetCityBuildings()->SetNumRealBuildingTimed(eBuilding, iNum, false, ((PlayerTypes)(paiBuildingOriginalOwner[iI])), paiBuildingOriginalTime[iI]);

						if (iNum > 0)
						{
							if (pkBuildingInfo->GetGreatWorkCount() > 0)
							{
								for (unsigned int jJ=0; jJ < paGreatWorkData.size(); jJ++)
								{
									if (paGreatWorkData[jJ].m_eBuildingType == iI)
									{
										pNewCity->GetCityBuildings()->SetBuildingGreatWork(eBuildingClass, paGreatWorkData[jJ].m_iSlot, paGreatWorkData[jJ].m_iGreatWork);
										paGreatWorkData[jJ].m_bTransferred = true;
										iCaptureGreatWorks++;
									}
								}
							}
						}
					}
				}
			}
		}
	}
	for(std::vector<BuildingYieldChange>::iterator it = aBuildingYieldChange.begin(); it != aBuildingYieldChange.end(); ++it)
	{
		pNewCity->GetCityBuildings()->SetBuildingYieldChange((*it).eBuildingClass, (*it).eYield, (*it).iChange);
	}

	// Distribute any remaining Great Works to other buildings
	for (unsigned int jJ=0; jJ < paGreatWorkData.size(); jJ++)
	{
		if (!paGreatWorkData[jJ].m_bTransferred)
		{
			BuildingClassTypes eBuildingClass = NO_BUILDINGCLASS; // Passed by reference below
			int iSlot = -1; // Passed by reference below
			GreatWorkType eType = GC.getGame().GetGameCulture()->m_CurrentGreatWorks[paGreatWorkData[jJ].m_iGreatWork].m_eType;
			GreatWorkSlotType eGreatWorkSlot = CultureHelpers::GetGreatWorkSlot(eType);
			if (pNewCity->GetCityBuildings()->GetNextAvailableGreatWorkSlot(eGreatWorkSlot, &eBuildingClass, &iSlot))
			{
				pNewCity->GetCityBuildings()->SetBuildingGreatWork(eBuildingClass, iSlot, paGreatWorkData[jJ].m_iGreatWork);
				paGreatWorkData[jJ].m_bTransferred = true;
				iCaptureGreatWorks++;
			}
			else
			{
				BuildingClassTypes eGWBuildingClass;
				int iGWSlot;
				CvCity *pGWCity = GetCulture()->GetClosestAvailableGreatWorkSlot(pCityPlot->getX(), pCityPlot->getY(), eGreatWorkSlot, &eGWBuildingClass, &iGWSlot);
				if (pGWCity)
				{
					pGWCity->GetCityBuildings()->SetBuildingGreatWork(eGWBuildingClass, iGWSlot, paGreatWorkData[jJ].m_iGreatWork);
					paGreatWorkData[jJ].m_bTransferred = true;
					iCaptureGreatWorks++;
				}
			}
		}
	}

	// Did we re-acquire our Capital?
	if(pCityPlot->getX() == GetOriginalCapitalX() && pCityPlot->getY() == GetOriginalCapitalY())
	{
		SetHasLostCapital(false, NO_PLAYER);

		const BuildingTypes eCapitalBuilding = (BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(GC.getCAPITAL_BUILDINGCLASS()));
		if(eCapitalBuilding != NO_BUILDING)
		{
#if defined(MOD_EVENTS_CITY_CAPITAL)
			CvCity* pOldCapital = getCapitalCity();
			if (pOldCapital != NULL)
#else
			if (getCapitalCity() != NULL)
#endif
			{
				pOldCapital->GetCityBuildings()->SetNumRealBuilding(eCapitalBuilding, 0);
#if defined(MOD_BALANCE_CORE)
				if (GetPlayerTraits()->IsNoAnnexing())
				{
					pOldCapital->SetPuppet(true);
				}
#endif
			}
			CvAssertMsg(!(pNewCity->GetCityBuildings()->GetNumRealBuilding(eCapitalBuilding)), "(pBestCity->getNumRealBuilding(eCapitalBuilding)) did not return false as expected");
			pNewCity->GetCityBuildings()->SetNumRealBuilding(eCapitalBuilding, 1);

#if defined(MOD_BALANCE_CORE)
			//Check for policies that add capital buildings and move them over.
			for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
			{
				const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iI);
				CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
				if (pkBuildingClassInfo)
				{
					int iNumFreeBuildings = GetNumCitiesFreeChosenBuilding(eBuildingClass);
					if (iNumFreeBuildings > 0 || IsFreeChosenBuildingNewCity(eBuildingClass) || IsFreeBuildingAllCity(eBuildingClass))
					{
						const BuildingTypes eBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(pkBuildingClassInfo->GetID())));
						if (NO_BUILDING != eBuilding)
						{
							CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
							if (pkBuildingInfo && pkBuildingInfo->IsCapitalOnly())
							{
								pNewCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, 1);
								if (pOldCapital != NULL)
								{
									pOldCapital->GetCityBuildings()->SetNumRealBuilding(eBuilding, 0);
								}
							}
						}
					}
				}
			}
#endif

#if defined(MOD_EVENTS_CITY_CAPITAL)
			if (MOD_EVENTS_CITY_CAPITAL) {
				GAMEEVENTINVOKE_HOOK(GAMEEVENT_CapitalChanged, GetID(), pNewCity->GetID(), (pOldCapital ? pOldCapital->GetID() : -1));
			}
#endif
		}
	}
#if defined(MOD_BALANCE_CORE_EVENTS)
	if (MOD_BALANCE_CORE_EVENTS)
	{
		CheckActivePlayerEvents(pNewCity);
	}
#endif
	if (pNewCity->getX() == GET_PLAYER(eOldOwner).GetLostHolyCityX() && pNewCity->getY() == GET_PLAYER(eOldOwner).GetLostHolyCityY())
	{
		GET_PLAYER(eOldOwner).SetHasLostHolyCity(false, NO_PLAYER);
		GET_PLAYER(eOldOwner).SetLostHolyCityXY(-1, -1);
	}

	// slewis - moved this here so that conquest victory is tested with each city capture
	GC.getGame().DoTestConquestVictory();

	GC.getMap().updateOwningCity(pCityPlot,pNewCity->getWorkPlotDistance()*2);
	if(bConquest)
	{
		for(int iDX = -iMaxRange; iDX <= iMaxRange; iDX++)
		{
			for(int iDY = -iMaxRange; iDY <= iMaxRange; iDY++)
			{
				CvPlot* pLoopPlot = plotXYWithRangeCheck(iOldCityX, iOldCityY, iDX, iDY, iMaxRange);
				if(pLoopPlot)
				{
					pLoopPlot->verifyUnitValidPlot();
				}
			}
		}

#if !defined(NO_ACHIEVEMENTS)
		// Check for Askia Achievement
		if(isHuman() && !CvPreGame::isNetworkMultiplayerGame())
		{
			const char* pkLeaderKey = getLeaderTypeKey();
			if(pkLeaderKey && strcmp(pkLeaderKey, "LEADER_ASKIA") == 0)
			{
				CvCity* pkCaptialCity = getCapitalCity();
				if(pkCaptialCity != NULL)	// Shouldn't be NULL, but...
				{
					CvPlot* pkCapitalPlot = pkCaptialCity->plot();
					CvPlot* pkNewCityPlot = pNewCity->plot();
					if(pkCapitalPlot && pkNewCityPlot)
					{
						// Get the area each plot is located in.
						CvArea* pkCapitalArea = pkCapitalPlot->area();
						CvArea* pkNewCityArea = pkNewCityPlot->area();

						if(pkCapitalArea && pkNewCityArea)
						{
							// The area the new city is locate on has to be of a certain size to qualify so that tiny islands are not included
#define ACHIEVEMENT_MIN_CONTINENT_SIZE	8
							if(pkNewCityArea->GetID() != pkCapitalArea->GetID() && pkNewCityArea->getNumTiles() >= ACHIEVEMENT_MIN_CONTINENT_SIZE)
							{
								gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_WARCANOE);
							}
						}
					}
				}
			}
		}
#endif
	}

	pCityPlot->setRevealed(GET_PLAYER(eOldOwner).getTeam(), true);

	// If the old owner is "killed," then notify everyone's Grand Strategy AI
	if(GET_PLAYER(eOldOwner).getNumCities() == 0 && !GET_PLAYER(eOldOwner).GetPlayerTraits()->IsStaysAliveZeroCities() && !bIsMinorCivBuyout)
	{
		if(!isMinorCiv() && !isBarbarian())
		{
			for(int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)
			{
				if(GetID() != iMajorLoop && GET_PLAYER((PlayerTypes) iMajorLoop).isAlive())
				{
					// Have I met the player who killed the guy?
					if(GET_TEAM(GET_PLAYER((PlayerTypes) iMajorLoop).getTeam()).isHasMet(getTeam()))
					{
						GET_PLAYER((PlayerTypes) iMajorLoop).GetDiplomacyAI()->DoPlayerKilledSomeone(GetID(), eOldOwner);
					}
				}
			}

#if defined(MOD_DIPLOMACY_CITYSTATES)
			//Let's give the Embassies of the defeated player to the new player
			if(MOD_DIPLOMACY_CITYSTATES && GET_PLAYER(eOldOwner).GetImprovementLeagueVotes() > 0)
			{
				int iEmbassyVotes = GET_PLAYER(eOldOwner).GetImprovementLeagueVotes();
				ChangeImprovementLeagueVotes(iEmbassyVotes);
			}
#endif
		}
	}
#if defined(MOD_DIPLOMACY_CITYSTATES)
	if(GET_PLAYER(eOldOwner).isMinorCiv() && GET_PLAYER(eOldOwner).getNumCities() == 0)
	{
		for(int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)
		{
			PlayerTypes ePlayer = (PlayerTypes)iMajorLoop;
			if(ePlayer != NO_PLAYER && !GET_PLAYER(ePlayer).isMinorCiv())
			{
				if(GET_PLAYER(eOldOwner).GetIncomingUnitCountdown(ePlayer) > 0)
				{
					// Must have capital to actually spawn unit
					CvCity* pCapital = GET_PLAYER(ePlayer).getCapitalCity();
					if(pCapital)
					{
						if(GET_PLAYER(eOldOwner).GetIncomingUnitType(ePlayer) != NO_UNIT)
						{
							CvUnit* pNewUnit = GET_PLAYER(ePlayer).initUnit(GET_PLAYER(eOldOwner).GetIncomingUnitType(ePlayer), pCapital->getX(), pCapital->getY());
							CvAssert(pNewUnit);
							if (pNewUnit)
							{
								if(pNewUnit->getDomainType() != DOMAIN_AIR)
								{
									if (!pNewUnit->jumpToNearestValidPlot())
									{
										pNewUnit->kill(false);
									}
								}
								CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();
								if(pNotifications && ePlayer == GC.getGame().getActivePlayer())
								{
									Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CS_GIFT_RETURNED_SUMMARY");
									strSummary <<  GET_PLAYER(eOldOwner).getCivilizationShortDescriptionKey();
									Localization::String strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_CS_GIFT_RETURNED");
									strNotification <<  GET_PLAYER(eOldOwner).getNameKey();
									strNotification <<  pNewUnit->getNameKey();
									pNotifications->Add(NOTIFICATION_GENERIC, strNotification.toUTF8(), strSummary.toUTF8(), pCapital->getX(), pCapital->getY(), -1);
								}
							}
						}
					}
				}
				GET_PLAYER(eOldOwner).GetMinorCivAI()->SetJerk(GET_PLAYER((PlayerTypes) iMajorLoop).getTeam(), 0);
			}
		}
	}			
#endif
	// If not, old owner should look at city specializations
	else
	{
		GET_PLAYER(eOldOwner).GetCitySpecializationAI()->SetSpecializationsDirty(SPECIALIZATION_UPDATE_MY_CITY_CAPTURED);
	}

	// Do the same for the new owner
	GetCitySpecializationAI()->SetSpecializationsDirty(SPECIALIZATION_UPDATE_ENEMY_CITY_CAPTURED);

	bool bDisbanded = false;

	// In OCC games, all captured cities are toast
	if (isHuman() && GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE))
	{
		bDisbanded = true;
		disband(pNewCity);
		// disband will delete the city
		pNewCity = NULL;

		// Set the plots to no owner
		for(uint ui = 0; ui < aiPurchasedPlotX.size(); ui++)
		{
			CvPlot* pPlot = GC.getMap().plot(aiPurchasedPlotX[ui], aiPurchasedPlotY[ui]);
			pPlot->setOwner(NO_PLAYER, -1, /*bCheckUnits*/ true, /*bUpdateResources*/ true);
		}

	}
	else //if (bConquest)
	{
		// Set the plots to the new owner, now, we may be flipping it to a liberated player and we need to pass on the information.
		for(uint ui = 0; ui < aiPurchasedPlotX.size(); ui++)
		{
			CvPlot* pPlot = GC.getMap().plot(aiPurchasedPlotX[ui], aiPurchasedPlotY[ui]);
			if(pPlot->getOwner() != pNewCity->getOwner())
				pPlot->setOwner(pNewCity->getOwner(), /*iAcquireCityID*/ pNewCity->GetID(), /*bCheckUnits*/ true, /*bUpdateResources*/ true);
		}

		// Is this City being Occupied?
		if(pNewCity->getOriginalOwner() != GetID())
		{
			pNewCity->SetOccupied(true);

			if (!bGift)
			{
				int iInfluenceReduction = GetCulture()->GetInfluenceCityConquestReduction(eOldOwner);
#if defined(MOD_BALANCE_CORE)
				int iResistanceTurns = (((pNewCity->getPopulation() * 2) / 3) * (100 - iInfluenceReduction)) / 100;
				if (iResistanceTurns <= 0)
				{
					iResistanceTurns = 1;
				}
#else
				int iResistanceTurns = pNewCity->getPopulation() * (100 - iInfluenceReduction) / 100;
#endif

				if (iResistanceTurns > 0)
				{
					pNewCity->ChangeResistanceTurns(iResistanceTurns);
				}
			}
		}

		long lResult = 0;

		if(lResult == 0)
		{
			PlayerTypes eLiberatedPlayer = NO_PLAYER;

			// Captured someone's city that didn't originally belong to us - Liberate a player?
			if(pNewCity->getOriginalOwner() != eOldOwner && pNewCity->getOriginalOwner() != GetID())
			{
				eLiberatedPlayer = pNewCity->getOriginalOwner();
				if(!CanLiberatePlayerCity(eLiberatedPlayer))
				{
					eLiberatedPlayer = NO_PLAYER;
				}
			}

#if defined(MOD_BUGFIX_VENICE_PUPPETS_CAPITAL)
			// Venice MUST liberate their own capital
			if (GetPlayerTraits()->IsNoAnnexing() && pNewCity->getX() == GetOriginalCapitalX() && pNewCity->getY() == GetOriginalCapitalY())
			{
				if (iCaptureGold > 0 || iCaptureCulture > 0 || iCaptureGreatWorks > 0) {
					if (iCaptureCulture == 0 && iCaptureGreatWorks == 0) {
						strBuffer = GetLocalizedText("TXT_KEY_POPUP_GOLD_CITY_CAPTURE", iCaptureGold, pNewCity->getNameKey());
					} else {
						strBuffer = GetLocalizedText("TXT_KEY_POPUP_GOLD_AND_CULTURE_CITY_CAPTURE", iCaptureGold, iCaptureCulture, iCaptureGreatWorks, pNewCity->getNameKey());
					}
					GC.GetEngineUserInterface()->AddCityMessage(0, pNewCity->GetIDInfo(), GetID(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer);
				}
			}
			else
#endif
			// AI decides what to do with a City
			if(!isHuman())
			{
#if defined(MOD_BALANCE_CORE)
				AI_conquerCity(pNewCity, eOldOwner, bGift, bAllowRaze); // could delete the pointer...
#else
				AI_conquerCity(pNewCity, eOldOwner); // could delete the pointer...
#endif
				// So we will check to see if the plot still contains the city.
				CvCity* pkCurrentCity = pCityPlot->getPlotCity();
				if (pkCurrentCity == NULL || pNewCity != pkCurrentCity || pkCurrentCity->getOwner() != GetID())
				{
					// The city is gone or is not ours anymore (we gave it away)
					pNewCity = NULL;
				}
			}

			// Human decides what to do with a City
			else if(!GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS))
			{
				// Used to display info for annex/puppet/raze popup - turned off in DoPuppet and DoAnnex
				pNewCity->SetIgnoreCityForHappiness(true);
				if (GetPlayerTraits()->IsNoAnnexing() && bIsMinorCivBuyout)
				{
					pNewCity->DoCreatePuppet();
				}
				else if (pNewCity->getOriginalOwner() != GetID() || GetPlayerTraits()->IsNoAnnexing() || bIsMinorCivBuyout)
				{
					if(GC.getGame().getActivePlayer() == GetID())
					{
						int iTemp[5] = { pNewCity->GetID(), iCaptureGold, iCaptureCulture, iCaptureGreatWorks, eLiberatedPlayer };
						bool bTemp[2] = { bIsMinorCivBuyout, bConquest };
						GC.GetEngineUserInterface()->AddPopup(BUTTONPOPUP_CITY_CAPTURED, POPUP_PARAM_INT_ARRAY(iTemp), POPUP_PARAM_BOOL_ARRAY(bTemp));
						// We are adding a popup that the player must make a choice in, make sure they are not in the end-turn phase.
						CancelActivePlayerEndTurn();
					}
				}
				else
				{
					pNewCity->SetIgnoreCityForHappiness(false);
				}
			}

			// No choice but to capture it, tell about pillage gold (if any)
			else if(iCaptureGold > 0 || iCaptureCulture > 0 || iCaptureGreatWorks > 0)
			{
				if (iCaptureCulture == 0 && iCaptureGreatWorks == 0)
				{
					strBuffer = GetLocalizedText("TXT_KEY_POPUP_GOLD_CITY_CAPTURE", iCaptureGold, pNewCity->getNameKey());
					GC.GetEngineUserInterface()->AddCityMessage(0, pNewCity->GetIDInfo(), GetID(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer);
				}
				else
				{
					strBuffer = GetLocalizedText("TXT_KEY_POPUP_GOLD_AND_CULTURE_CITY_CAPTURE", iCaptureGold, iCaptureCulture, iCaptureGreatWorks, pNewCity->getNameKey());
					GC.GetEngineUserInterface()->AddCityMessage(0, pNewCity->GetIDInfo(), GetID(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer);

				}
			}
		}
	}
	// Be careful below here, pNewCity can be NULL.
	CheckForMurder(eOldOwner);

	if(GC.getGame().getActiveTeam() == GET_PLAYER(eOldOwner).getTeam())
	{
		CvMap& theMap = GC.getMap();
		theMap.updateDeferredFog();
	}
#if defined(MOD_DIPLOMACY_CITYSTATES_QUESTS)
	if(pNewCity != NULL && pNewCity->getOwner() == BARBARIAN_PLAYER)
	{
		CvBarbarians::DoCityActivationNotice(pNewCity->plot());
	}
#endif
#if defined(MOD_BALANCE_CORE)
	UnitTypes eFreeUnitConquest = GetPlayerTraits()->GetFreeUnitOnConquest();
	if(eFreeUnitConquest != NO_UNIT)
	{
		if(pNewCity != NULL)
		{
			if(pNewCity->GetNumTimesOwned(GetID()) <= 1 && canTrain(eFreeUnitConquest))
			{
				CvUnit* pkUnit = initUnit(eFreeUnitConquest, pNewCity->getX(), pNewCity->getY());
				CvCity* pCapital = getCapitalCity();
				bool bJumpSuccess = pkUnit->jumpToNearestValidPlot();
				if (bJumpSuccess && pCapital != NULL)
				{
					pCapital->addProductionExperience(pkUnit);
				}
				else
				{
					pkUnit->kill(false);
				}
			}
		}
	}
#endif
	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem && pNewCity != NULL)
	{
		CvLuaArgsHandle args;
		args->Push(eOldOwner);
		args->Push(bCapital);
		args->Push(pNewCity->getX());
		args->Push(pNewCity->getY());
		args->Push(GetID());
		args->Push(iOldPopulation);
		args->Push(bConquest);
		args->Push((int)paGreatWorkData.size());
		args->Push(iCaptureGreatWorks);

		bool bResult;
		LuaSupport::CallHook(pkScriptSystem, "CityCaptureComplete", args.get(), bResult);
	}

#if defined(MOD_API_EXTENSIONS)
		return pNewCity;
#endif
#ifdef _MSC_VER
#pragma warning ( pop ) // restore warning level suppressed for pNewCity null check
#endif// _MSC_VER
}
bool CvPlayer::IsValidBuildingForPlayer(CvCity* pCity, BuildingTypes eBuilding, bool bGift, bool bRecapture)
{
	CvBuildingEntry* pkLoopBuildingInfo = GC.getBuildingInfo(eBuilding);
	if (!pkLoopBuildingInfo)
		return false;

	if (pkLoopBuildingInfo->IsDummy())
		return false;

	if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_ConquerorValidBuilding, pCity->getOwner(), pCity->GetID(), GetID(), eBuilding) == GAMEEVENTRETURN_FALSE) {
		return false;
	}

	const CvBuildingClassInfo& pkClassInfo = pkLoopBuildingInfo->GetBuildingClassInfo();

	bool bIsNationalWonder = ::isNationalWonderClass(pkClassInfo);
	bool bCivUnique = pkClassInfo.getDefaultBuildingIndex() != eBuilding;
	bool bProductionMaxed = isProductionMaxedBuildingClass((BuildingClassTypes)pkLoopBuildingInfo->GetBuildingClassType(), true);

	if (GetPlayerTraits()->IsKeepConqueredBuildings())
	{
		if (!bCivUnique)
		{
			if (bIsNationalWonder || bProductionMaxed)
				return false;
		}
		else
		{
			if (bIsNationalWonder && getNumBuildings(eBuilding) > 0)
				return false;
			else if (bProductionMaxed)
				return false;
		}
	}
	else
	{
		if (pkLoopBuildingInfo->IsNeverCapture() || bProductionMaxed || bIsNationalWonder)
			return false;

		if (bGift || bRecapture)
			return true;

		int iConquestChance = GC.getGame().getSmallFakeRandNum(34, *pCity->plot()) + GC.getGame().getSmallFakeRandNum(34, pkLoopBuildingInfo->GetID()) + GC.getGame().getSmallFakeRandNum(32, GC.getGame().GetCultureAverage());

		return iConquestChance <= pkLoopBuildingInfo->GetConquestProbability();
	}

	return true;
}

//	--------------------------------------------------------------------------------
void CvPlayer::killCities()
{
	//can't kill the cities directly because that invalidates the iterator
	std::vector<int> citiesToKill;

	int iLoop;
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		citiesToKill.push_back(pLoopCity->GetID());
	}

	for (std::vector<int>::iterator it=citiesToKill.begin(); it!=citiesToKill.end(); ++it)
	{
		CvCity* pLoopCity = getCity(*it);
		pLoopCity->kill(false);
	}
}

const int RESERVE_TOP_X_NAMES = 5;	/// Never steal one of the first 5 names

//	--------------------------------------------------------------------------------
CvString CvPlayer::getNewCityName() const
{
	const CLLNode<CvString>* pNode;
	CvString strName;

	for(pNode = headCityNameNode(); (pNode != NULL); pNode = nextCityNameNode(pNode))
	{
		strName = pNode->m_data;
		if(isCityNameValid(strName, true))
		{
			strName = pNode->m_data;
			break;
		}
	}

	if(strName.IsEmpty())
	{
		getCivilizationCityName(strName, getCivilizationType());
	}

	if(strName.IsEmpty())
	{
		// Pick a name from another civ in the game
		int iPlayersAlive = 0;
		for(int iI = 0; iI < MAX_PLAYERS; iI++)
		{
			const PlayerTypes ePlayer = static_cast<PlayerTypes>(iI);
			CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);
			if(ePlayer != GetID() && kPlayer.isAlive() && !kPlayer.isMinorCiv() && !kPlayer.isBarbarian())
			{
				iPlayersAlive++;
			}
		}

		int iChosenPlayer = GC.getGame().getJonRandNum(iPlayersAlive, "Random Player To Steal City Name");

		int iPlayersFound = 0;
		for(int iI = 0; iI < MAX_PLAYERS; iI++)
		{
			const PlayerTypes ePlayer = static_cast<PlayerTypes>(iI);
			CvPlayerAI &kPlayer = GET_PLAYER(ePlayer);
			if(ePlayer != GetID() && kPlayer.isAlive() && !kPlayer.isMinorCiv() && !kPlayer.isBarbarian())
			{
				if(iPlayersFound == iChosenPlayer)
				{
					strName = GetBorrowedCityName(kPlayer.getCivilizationType());			
					break;
				}
				else
				{
					iPlayersFound++;
				}
			}
		}
	}

	if(strName.IsEmpty())
	{
		// Pick a name from another civ in the DATABASE
		int iCivsInDB = 0;
		for(int iI = 0; iI < GC.getNumCivilizationInfos(); iI++)
		{
			const CivilizationTypes eCiv = static_cast<CivilizationTypes>(iI);

			CvCivilizationInfo* pkCivilizationInfo = GC.getCivilizationInfo(eCiv);
			if(pkCivilizationInfo != NULL && pkCivilizationInfo->getNumCityNames() > RESERVE_TOP_X_NAMES)
			{
				iCivsInDB++;
			}
		}

		int iChosenCiv = GC.getGame().getJonRandNum(iCivsInDB, "Random Civ To Steal City Name");

		int iCivsFound = 0;
		for(int iI = 0; iI < GC.getNumCivilizationInfos(); iI++)
		{
			const CivilizationTypes eCiv = static_cast<CivilizationTypes>(iI);

			CvCivilizationInfo* pkCivilizationInfo = GC.getCivilizationInfo(eCiv);
			if (pkCivilizationInfo != NULL && pkCivilizationInfo->getNumCityNames() > RESERVE_TOP_X_NAMES)
			{
				if (iCivsFound == iChosenCiv)
				{
					strName = GetBorrowedCityName(eCiv);
					break;
				}
				else
				{
					iCivsFound++;
				}
			}
		}
	}

	if(strName.IsEmpty())
	{
		strName = "TXT_KEY_CITY";
	}

	return strName;
}

//	--------------------------------------------------------------------------------
CvString CvPlayer::GetBorrowedCityName(CivilizationTypes eCivToBorrowFrom) const
{
	CvString szRtnValue;
	CvCivilizationInfo *pCivInfo = GC.getCivilizationInfo(eCivToBorrowFrom);

	if (pCivInfo)
	{
		int iRange = pCivInfo->getNumCityNames() - RESERVE_TOP_X_NAMES;
		int iRandOffset = GC.getGame().getJonRandNum(iRange, "Random City Name To Steal");
		for(int iI = 0; iI < iRange; iI++)     
		{
			CvString strCityName = pCivInfo->getCityNames(RESERVE_TOP_X_NAMES + ((iI + iRandOffset) % iRange));
			szRtnValue = GetLocalizedText(strCityName.c_str());

			if(isCityNameValid(szRtnValue, true))
			{
				break;
			}
		}
	}

	return szRtnValue;

}

//	--------------------------------------------------------------------------------
void CvPlayer::getCivilizationCityName(CvString& szBuffer, CivilizationTypes eCivilization) const
{
	int iRandOffset;
	int iLoopName;

	CvCivilizationInfo* pkCivilizationInfo = GC.getCivilizationInfo(eCivilization);
	if(pkCivilizationInfo == NULL)
	{
		//This should never happen.
		return;
	}

	if(isBarbarian())
	{
		iRandOffset = GC.getGame().getJonRandNum(pkCivilizationInfo->getNumCityNames(), "Random Barb Name");
	}
	else
	{
		iRandOffset = 0;
	}

	// Minor Civs use special lists
	if(isMinorCiv())
	{
		CvMinorCivInfo* pkMinorCivInfo = GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType());
		if(pkMinorCivInfo)
		{
			CvMinorCivInfo& kMinorCivInfo = *pkMinorCivInfo;
			for(int iI = 0; iI < kMinorCivInfo.getNumCityNames(); iI++)
			{
				iLoopName = ((iI + iRandOffset) % kMinorCivInfo.getNumCityNames());

				const CvString strCityName = kMinorCivInfo.getCityNames(iLoopName);
				CvString strName = GetLocalizedText(strCityName.c_str());

				if(isCityNameValid(strName, true))
				{
					szBuffer = strCityName;
					break;
				}
			}
		}
	}
	else
	{
		const CvCivilizationInfo& kCivInfo = *pkCivilizationInfo;
		for(int iI = 0; iI < kCivInfo.getNumCityNames(); iI++)
		{
			iLoopName = ((iI + iRandOffset) % kCivInfo.getNumCityNames());

			const CvString strCityName = kCivInfo.getCityNames(iLoopName);
			CvString strName = GetLocalizedText(strCityName.c_str());

			if(isCityNameValid(strName, true))
			{
				szBuffer = strCityName;
				break;
			}
		}
	}
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isCityNameValid(CvString& szName, bool bTestDestroyed) const
{
	const CvCity* pLoopCity;
	int iLoop;

	if(bTestDestroyed)
	{
		if(GC.getGame().isDestroyedCityName(szName))
		{
			return false;
		}

		for(int iPlayer = 0; iPlayer < MAX_PLAYERS; ++iPlayer)
		{
			CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iPlayer);
			for(pLoopCity = kLoopPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kLoopPlayer.nextCity(&iLoop))
			{
				if(pLoopCity->getName() == szName)
				{
					return false;
				}
			}
		}
	}
	else
	{
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity->getName() == szName)
			{
				return false;
			}
		}
	}

	return true;
}

//	--------------------------------------------------------------------------------
/// How far out this player may buy plots
int CvPlayer::getBuyPlotDistance() const
{
	int iDistance = GC.getMAXIMUM_BUY_PLOT_DISTANCE();
	
	iDistance = std::min(MAX_CITY_RADIUS, std::max(getWorkPlotDistance(), iDistance));
	return iDistance;
}

//	--------------------------------------------------------------------------------
/// How far out this player may work plots
int CvPlayer::getWorkPlotDistance() const
{
	int iDistance = GC.getMAXIMUM_WORK_PLOT_DISTANCE();
	
#if defined(MOD_TRAITS_CITY_WORKING) || defined(MOD_BUILDINGS_CITY_WORKING) || defined(MOD_POLICIES_CITY_WORKING)
	// Change distance based on traits, policies, wonders, etc
	iDistance += GetCityWorkingChange();
#endif
#if defined(MOD_TECHS_CITY_WORKING)
	// Change distance based on techs, etc
	if (getTeam()!=NO_TEAM)
		iDistance += GET_TEAM(getTeam()).GetCityWorkingChange();
#endif
	
	iDistance = std::min(MAX_CITY_RADIUS, std::max(MIN_CITY_RADIUS, iDistance));
	return iDistance;
}

//	--------------------------------------------------------------------------------
/// How many plots a generic city may work
int CvPlayer::GetNumWorkablePlots() const
{
	return ((6 * (1+getWorkPlotDistance()) * getWorkPlotDistance() / 2) + 1);
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// This player liberates iOldCityID and gives it back to ePlayer
void CvPlayer::DoRevolutionPlayer(PlayerTypes ePlayer, int iOldCityID)
{
	CvCity* pCity = getCity(iOldCityID);
	CvAssert(pCity);
	if (!pCity)
		return;

	if(ePlayer == NO_PLAYER)
	{
		return;
	}

	if (GC.getLogging() && GC.getAILogging() && pCity != NULL)
	{
		CvString playerName;
		FILogFile* pLog;
		CvString strBaseString;
		CvString strOutBuf;
		CvString strFileName = "CityRevolutions.csv";
		playerName = getCivilizationShortDescription();
		pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";
		strOutBuf.Format("Revolution! Civ Liberated and %s restored to %s", pCity->getName().GetCString(), GET_PLAYER(ePlayer).getName());
		strBaseString += strOutBuf;
		pLog->Msg(strBaseString);
	}

	DoLiberatePlayer(ePlayer, pCity->GetID(), true);
}
CvPlot* CvPlayer::GetCenterOfMassEmpire() const
{
	if(m_iCenterOfMassX == -1 || m_iCenterOfMassY == -1)
	{
		return NULL;
	}
	//this handles wrapped coordinates
	CvPlot* pRtnValue = GC.getMap().plot(m_iCenterOfMassX, m_iCenterOfMassY);
	
	return pRtnValue;
}
void CvPlayer::SetCenterOfMassEmpire()
{
	int iTotalX = 0;
	int iTotalY = 0;
	int iNumCities = 0;

	int iLoop;
	CvCity* pCity = firstCity(&iLoop);

	if (!pCity)
		return;

	int iTotalX2 = 0;
	int iTotalY2 = 0;
	int iWorldWidth = GC.getMap().getGridWidth();
	int iWorldHeight = GC.getMap().getGridHeight();

	//the first unit is our reference ...
	int iRefX = pCity->getX();
	int iRefY = pCity->getY();
	iNumCities++;
	pCity = nextCity(&iLoop);

	while(pCity)
	{
		if(pCity->IsPuppet())
		{
			pCity = nextCity(&iLoop);
			continue;
		}

		int iDX = pCity->getX() - iRefX;
		int iDY = pCity->getY() - iRefY;

		if (GC.getMap().isWrapX())
		{
			if( iDX > +(iWorldWidth / 2))
				iDX -= iWorldWidth;
			if( iDX < -(iWorldWidth / 2))
				iDX += iWorldWidth;
		}
		if (GC.getMap().isWrapY())
		{
			if( iDY > +(iWorldHeight / 2))
				iDY -= iWorldHeight;
			if( iDY < -(iWorldHeight / 2))
				iDY += iWorldHeight;
		}

		iTotalX += iDX;
		iTotalY += iDY;
		iTotalX2 += iDX*iDX;
		iTotalY2 += iDY*iDY;
		iNumCities++;

		pCity = nextCity(&iLoop);
	}

	if (iNumCities==0)
		return;

	//finally, compute average (with rounding)
	int iAvgX = (iTotalX + (iNumCities / 2)) / iNumCities + iRefX;
	int iAvgY = (iTotalY + (iNumCities / 2)) / iNumCities + iRefY;

	m_iCenterOfMassX = iAvgX;
	m_iCenterOfMassY = iAvgY;
}

void CvPlayer::UpdateCityThreatCriteria()
{
	//What are you doing here? Get out!
	if(isMinorCiv() || isBarbarian() || isHuman())
		return;

	if(getNumCities() <= 1)
		return;

	//Reset the critera.
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->SetThreatRank(-1);
		pLoopCity->SetCoastalThreatRank(-1);
	}

	//
	vector<CvCity*> threatenedCities = GetMilitaryAI()->GetThreatenedCities(true);
	for(int i = 0; i < (int)threatenedCities.size(); i++)
		threatenedCities[i]->SetThreatRank(i);

	vector<CvCity*> threatenedCoastalCities = GetMilitaryAI()->GetThreatenedCities(true, true);
	for (int i = 0; i < (int)threatenedCoastalCities.size(); i++)
		threatenedCoastalCities[i]->SetCoastalThreatRank(i);
}

CvCity* CvPlayer::GetThreatenedCityByRank(int iRank, bool bCoastalOnly)
{
	int iLoop;
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (bCoastalOnly)
		{
			if (pLoopCity->GetCoastalThreatRank() == iRank)
				return pLoopCity;
		}
		else if (pLoopCity->GetThreatRank() == iRank)
		{
			return pLoopCity;
		}
	}

	return NULL;
}

void CvPlayer::UpdateBestMilitaryCities()
{
	//What are you doing here? Get out!
	if(isMinorCiv() || isBarbarian())
		return;

	//First let's test domain, then we'll test combat class.
	CvCity* pLoopCity = NULL;
	int iLoop;

	//Unitcombat Value - let's find the best unitcombat class city (includes promotions for unit combat classes below).
	for(int iI = 0; iI < GC.getNumUnitCombatClassInfos(); iI++)
	{
		int iBestCombatClassValue = 0;
		const UnitCombatTypes eUnitCombatClass = static_cast<UnitCombatTypes>(iI);
		CvBaseInfo* pkUnitCombatClassInfo = GC.getUnitCombatClassInfo(eUnitCombatClass);
		if(pkUnitCombatClassInfo)
		{
			CvCity* pBestCombatClassCity = NULL;
			for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				//Production is king, and also our base value.
				int iCombatClassValue = (pLoopCity->getYieldRate(YIELD_PRODUCTION, false) / 5);

				//Also get our XP boosts local to this city.
				iCombatClassValue += pLoopCity->getFreeExperience();

				if(pLoopCity->getUnitCombatFreeExperience(eUnitCombatClass) > 0)
				{
					iCombatClassValue += max(1, pLoopCity->getUnitCombatFreeExperience(eUnitCombatClass));
				}
				if(pLoopCity->getUnitCombatProductionModifier(eUnitCombatClass) > 0)
				{
					iCombatClassValue += max(1, pLoopCity->getUnitCombatProductionModifier(eUnitCombatClass));
				}
				//Promotion Bonus
				for(int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
				{
					const PromotionTypes ePromotion = static_cast<PromotionTypes>(iI);
					CvPromotionEntry* pkPromotionInfo = GC.getPromotionInfo(ePromotion);
					if(pkPromotionInfo)
					{
						if(pLoopCity->isFreePromotion(ePromotion))
						{
							if(pkPromotionInfo->GetUnitCombatClass(eUnitCombatClass))
							{
								iCombatClassValue += 50;
							}
						}
					}
				}
				if(iCombatClassValue > iBestCombatClassValue)
				{
					iBestCombatClassValue = iCombatClassValue;
					pBestCombatClassCity = pLoopCity;
				}
			}
			if(pBestCombatClassCity != NULL && pBestCombatClassCity != GetBestMilitaryCity(eUnitCombatClass, NO_DOMAIN))
			{
				SetBestMilitaryCityCombatClass(pBestCombatClassCity->GetID(), eUnitCombatClass);
				if(GC.getLogging() && GC.getAILogging())
				{
					CvString strCity = pBestCombatClassCity->getName();
					CvString strLogString;
					strLogString.Format("***************** New Military Combat Class City Chosen for class %d: %s. ****************", eUnitCombatClass, strCity.c_str());
					GetHomelandAI()->LogHomelandMessage(strLogString);
				}
			}
		}
	}

	//Domain Value - let's get the city with the higher # of domain bonuses, and make it our best domain city.
	for (int iDomainLoop = 0; iDomainLoop < NUM_DOMAIN_TYPES; iDomainLoop++)
	{
		int iBestDomainValue = 0;
		DomainTypes eTestDomain = (DomainTypes)iDomainLoop;
		if (eTestDomain != NO_DOMAIN)
		{
			CvCity* pBestDomainCity = NULL;
			for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				//Production is king, and also our base value.
				int iDomainValue = (pLoopCity->getYieldRate(YIELD_PRODUCTION, false) / 5);

				//Also get our XP boosts local to this city.
				iDomainValue += pLoopCity->getFreeExperience();

				if (pLoopCity->getDomainFreeExperience(eTestDomain) > 0)
				{
					iDomainValue += max(1, pLoopCity->getDomainFreeExperience(eTestDomain));
				}
				if (pLoopCity->getDomainFreeExperienceFromGreatWorks(eTestDomain) > 0)
				{
					iDomainValue += max(1, pLoopCity->getDomainFreeExperienceFromGreatWorks(eTestDomain));
				}
				if (pLoopCity->getDomainFreeExperienceFromGreatWorksGlobal(eTestDomain) > 0)
				{
					iDomainValue += max(1, pLoopCity->getDomainFreeExperienceFromGreatWorksGlobal(eTestDomain));
				}
				if (pLoopCity->getDomainProductionModifier(eTestDomain) > 0)
				{
					iDomainValue += max(1, pLoopCity->getDomainProductionModifier(eTestDomain));
				}

				//Let's try to synergize our domain and combat class productions in the same cities.
				for (int iI = 0; iI < GC.getNumUnitCombatClassInfos(); iI++)
				{
					const UnitCombatTypes eUnitCombatClass = static_cast<UnitCombatTypes>(iI);
					CvBaseInfo* pkUnitCombatClassInfo = GC.getUnitCombatClassInfo(eUnitCombatClass);
					if (pkUnitCombatClassInfo)
					{
						if (GetBestMilitaryCity(eUnitCombatClass, NO_DOMAIN) == pLoopCity)
						{
							iDomainValue *= 2;
						}
					}
				}
				if (iDomainValue > iBestDomainValue)
				{
					iBestDomainValue = iDomainValue;
					pBestDomainCity = pLoopCity;
				}
			}
			if (pBestDomainCity != NULL && pBestDomainCity != GetBestMilitaryCity(NO_UNITCOMBAT, eTestDomain))
			{
				if (GC.getLogging() && GC.getAILogging())
				{
					CvString strCity = pBestDomainCity->getName();
					CvString strLogString;
					strLogString.Format("***************** New Military Domain City Chosen for domain %d: %s. ****************", eTestDomain, strCity.c_str());
					GetHomelandAI()->LogHomelandMessage(strLogString);
				}
				SetBestMilitaryCityDomain(pBestDomainCity->GetID(), eTestDomain);
			}
		}
	}
}
void CvPlayer::SetBestMilitaryCityDomain(int iValue, DomainTypes eDomain)
{
	VALIDATE_OBJECT
	CvAssertMsg(eDomain >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eDomain < NUM_DOMAIN_TYPES, "eIndex1 is expected to be within maximum bounds (invalid Index)");
	m_aiBestMilitaryDomainCity.setAt(eDomain, iValue);
}
void CvPlayer::SetBestMilitaryCityCombatClass(int iValue, UnitCombatTypes eUnitCombat)
{
	VALIDATE_OBJECT
	CvAssertMsg(eUnitCombat >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eUnitCombat < GC.getNumUnitCombatClassInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	m_aiBestMilitaryCombatClassCity.setAt(eUnitCombat, iValue);
}
CvCity* CvPlayer::GetBestMilitaryCity(UnitCombatTypes eUnitCombat, DomainTypes eDomain)
{
	if(eUnitCombat != NO_UNITCOMBAT)
	{
		return getCity(m_aiBestMilitaryCombatClassCity[eUnitCombat]);
	}
	else if(eDomain != NO_DOMAIN)
	{
		return getCity(m_aiBestMilitaryDomainCity[eDomain]);
	}
	else
	{
		return NULL;
	}
}
#endif
#if defined(MOD_BALANCE_CORE_EVENTS)
int CvPlayer::GetEventChoiceDuration(EventChoiceTypes eEventChoice) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEventChoice >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEventChoice < GC.getNumEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	return m_aiEventChoiceDuration[eEventChoice];
}
void CvPlayer::ChangeEventChoiceDuration(EventChoiceTypes eEventChoice,int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEventChoice >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEventChoice < GC.getNumEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	if(iValue != 0)
	{
		m_aiEventChoiceDuration.setAt(eEventChoice, m_aiEventChoiceDuration[eEventChoice] + iValue);
	}
}
void CvPlayer::SetEventChoiceDuration(EventChoiceTypes eEventChoice,int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEventChoice >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEventChoice < GC.getNumEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	m_aiEventChoiceDuration.setAt(eEventChoice, iValue);
}
int CvPlayer::GetEventIncrement(EventTypes eEvent) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	return m_aiEventIncrement[eEvent];
}
void CvPlayer::IncrementEvent(EventTypes eEvent, int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	if(iValue != 0)
	{
		m_aiEventIncrement.setAt(eEvent, m_aiEventIncrement[eEvent] + iValue);
	}
}
int CvPlayer::GetPlayerEventCooldown() const
{
	VALIDATE_OBJECT
	return m_iPlayerEventCooldown;
}
void CvPlayer::ChangePlayerEventCooldown(int iValue)
{
	VALIDATE_OBJECT
	if(iValue != 0)
	{
		m_iPlayerEventCooldown += iValue;
	}
}
int CvPlayer::GetEventCooldown(EventTypes eEvent) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	return m_aiEventCooldown[eEvent];
}
void CvPlayer::ChangeEventCooldown(EventTypes eEvent,int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	if(iValue != 0)
	{
		m_aiEventCooldown.setAt(eEvent, m_aiEventCooldown[eEvent] + iValue);
	}
}
void CvPlayer::SetEventCooldown(EventTypes eEvent,int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	m_aiEventCooldown.setAt(eEvent, iValue);
}

void CvPlayer::SetEventActive(EventTypes eEvent, bool bValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	m_abEventActive.setAt(eEvent, bValue);
}
bool CvPlayer::IsEventActive(EventTypes eEvent) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	return m_abEventActive[eEvent];
}
void CvPlayer::SetEventChoiceActive(EventChoiceTypes eEventChoice, bool bValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEventChoice >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEventChoice < GC.getNumEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	m_abEventChoiceActive.setAt(eEventChoice, bValue);
}
bool CvPlayer::IsEventChoiceActive(EventChoiceTypes eEventChoice) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEventChoice >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEventChoice < GC.getNumEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	return m_abEventChoiceActive[eEventChoice];
}
void CvPlayer::SetEventChoiceFired(EventChoiceTypes eEvent, bool bValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	m_abEventChoiceFired.setAt(eEvent, bValue);
}
bool CvPlayer::IsEventChoiceFired(EventChoiceTypes eEvent) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	return m_abEventChoiceFired[eEvent];
}
void CvPlayer::SetEventFired(EventTypes eEvent, bool bValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	m_abEventFired.setAt(eEvent, bValue);
}
bool CvPlayer::IsEventFired(EventTypes eEvent) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	return m_abEventFired[eEvent];
}
void CvPlayer::DoEvents()
{
	//Minors? Barbs? Get out!
	if(isMinorCiv() || isBarbarian())
		return;

	//Event Choice Duration First - if we're in one, let's do the countdown now.
	//We need to do this first so we can cancel the event(s).
	for(int iLoop = 0; iLoop < GC.getNumEventChoiceInfos(); iLoop++)
	{
		EventChoiceTypes eEventChoice = (EventChoiceTypes)iLoop;
		if(eEventChoice != NO_EVENT_CHOICE)
		{
			if(GetEventChoiceDuration(eEventChoice) > 0)
			{
				ChangeEventChoiceDuration(eEventChoice, -1);
				if(GC.getLogging())
				{
					CvModEventChoiceInfo* pkEventInfo = GC.getEventChoiceInfo(eEventChoice);
					if(pkEventInfo != NULL)
					{
						CvString playerName;
						FILogFile* pLog;
						CvString strBaseString;
						CvString strOutBuf;
						CvString strFileName = "EventLogging.csv";
						playerName = getCivilizationShortDescription();
						pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
						strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
						strBaseString += playerName + ", ";
						strOutBuf.Format("Event Choice Cooldown: %s Changing Value by -1. Cooldown Remaining: %d", pkEventInfo->GetDescription(), GetEventChoiceDuration(eEventChoice));
						strBaseString += strOutBuf;
						pLog->Msg(strBaseString);
					}
				}
				if(GetEventChoiceDuration(eEventChoice) == 0)
				{
					DoCancelEventChoice(eEventChoice);
				}
			}
		}
	}

	if (GetPlayerEventCooldown() > 0)
	{
		if (GC.getLogging())
		{
			CvString playerName;
			FILogFile* pLog;
			CvString strBaseString;
			CvString strOutBuf;
			CvString strFileName = "EventLogging.csv";
			playerName = getCivilizationShortDescription();
			pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			strBaseString += playerName + ", ";
			strOutBuf.Format("Player Event: Global Cooldown Active. Cooldown: %d", GetPlayerEventCooldown());
			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}
		ChangePlayerEventCooldown(-1);
	}

	//Let's loop through all events.
	CvWeightedVector<int> veValidEvents;

	for(int iLoop = 0; iLoop < GC.getNumEventInfos(); iLoop++)
	{
		EventTypes eEvent = (EventTypes)iLoop;
		if (eEvent != NO_EVENT)
		{
			CvModEventInfo* pkEventInfo = GC.getEventInfo(eEvent);
			if (pkEventInfo == NULL)
			{
				continue;
			}

			if (pkEventInfo->getRandomChance() == -1)
				continue;

			if (pkEventInfo->isOneShot() && IsEventFired(eEvent))
				continue;

			//Lua Hook
			if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_EventCanTake, GetID(), eEvent) == GAMEEVENTRETURN_FALSE)
			{
				continue;
			}

			//Global Cooldown Second - if we've had this event recently, let's check this.
			if (GetEventCooldown(eEvent) > 0)
			{
				if (GC.getLogging())
				{
					CvModEventInfo* pkEventInfo = GC.getEventInfo(eEvent);
					if (pkEventInfo != NULL)
					{
						CvString playerName;
						FILogFile* pLog;
						CvString strBaseString;
						CvString strOutBuf;
						CvString strFileName = "EventLogging.csv";
						playerName = getCivilizationShortDescription();
						pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
						strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
						strBaseString += playerName + ", ";
						strOutBuf.Format("Player Event: %s. Cooldown Active. Cooldown: %d", pkEventInfo->GetDescription(), GetEventCooldown(eEvent));
						strBaseString += strOutBuf;
						pLog->Msg(strBaseString);
					}
				}
				ChangeEventCooldown(eEvent, -1);
				continue;
			}

			if (GetPlayerEventCooldown() > 0 && !pkEventInfo->IgnoresGlobalCooldown())
			{
				continue;
			}

			//most expensive check last
			if (IsEventValid(eEvent))
			{
				veValidEvents.push_back(eEvent, (pkEventInfo->getRandomChance() + GetEventIncrement(eEvent)));
			}
		}
	}

	EventTypes eChosenEvent = NO_EVENT;

	if(veValidEvents.size() > 0)
	{
		veValidEvents.SortItems();
		if(GC.getLogging())
		{
			CvString strBaseString;
			CvString strOutBuf;
			CvString strFileName = "EventLogging.csv";
			CvString playerName = getCivilizationShortDescription();
			FILogFile* pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			strBaseString += playerName + ", ";
			strOutBuf.Format("Found %d Events for seeding", veValidEvents.size());
			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}

		int iRandIndex = GC.getGame().getJonRandNum(1000, "Picking random event for player.");

		//which one is it?
		int iWeight = 0;
		for (int iLoop = 0; iLoop < veValidEvents.size(); iLoop++)
		{
			EventTypes eEvent = (EventTypes)veValidEvents.GetElement(iLoop);
			CvModEventInfo* pkEventInfo = GC.getEventInfo(eEvent);
			if (!pkEventInfo)
				continue;

			iWeight = veValidEvents.GetWeight(iLoop);
			if (iRandIndex < iWeight)
			{
				eChosenEvent = eEvent;
				break;
			}
		}

		if (eChosenEvent != NO_EVENT)
		{
			CvModEventInfo* pkEventInfo = GC.getEventInfo(eChosenEvent);
			if (pkEventInfo != NULL)
			{
				for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
				{
					PlayerTypes ePlayer = (PlayerTypes)iPlayerLoop;
					if (ePlayer != NO_PLAYER && GET_PLAYER(ePlayer).isAlive())
					{
						//Not global?
						if (!pkEventInfo->isGlobal() && ePlayer != GetID())
							continue;

						GET_PLAYER(ePlayer).DoStartEvent(eChosenEvent);

						//reset probability
						IncrementEvent(eChosenEvent, -GetEventIncrement(eChosenEvent));
						if (GC.getLogging())
						{
							CvString strBaseString;
							CvString strOutBuf;
							CvString strFileName = "EventLogging.csv";
							CvString playerName = getCivilizationShortDescription();
							FILogFile* pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
							strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
							strBaseString += playerName + ", ";
							strOutBuf.Format("Resetting event chance for: %s", pkEventInfo->GetDescription());
							strBaseString += strOutBuf;
							pLog->Msg(strBaseString);
						}
					}
				}
			}
		}
	}

	for (int iLoop = 0; iLoop < veValidEvents.size(); iLoop++)
	{
		EventTypes eEvent = (EventTypes)veValidEvents.GetElement(iLoop);
		if (eEvent != NO_EVENT)
		{
			CvModEventInfo* pkEventInfo = GC.getEventInfo(eEvent);
			if (!pkEventInfo)
				continue;

			//But not for the one we just did!
			if (eChosenEvent == eEvent)
				continue;

			//make it more likely
			if (pkEventInfo->getRandomChanceDelta() > 0)
			{
				IncrementEvent(eEvent, pkEventInfo->getRandomChanceDelta());
				if (GC.getLogging())
				{
					CvString strBaseString;
					CvString strOutBuf;
					CvString strFileName = "EventLogging.csv";
					CvString playerName = getCivilizationShortDescription();
					FILogFile* pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
					strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
					strBaseString += playerName + ", ";
					strOutBuf.Format("Incrementing event chance for: %s, Increment: %d", pkEventInfo->GetDescription(), GetEventIncrement(eEvent));
					strBaseString += strOutBuf;
					pLog->Msg(strBaseString);
				}
			}
		}
	}
}

bool CvPlayer::IsEventValid(EventTypes eEvent)
{
	CvModEventInfo* pkEventInfo = GC.getEventInfo(eEvent);
	if(pkEventInfo == NULL)
	{
		return false;
	}

	//Lua Hook
	if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_EventCanActivate, GetID(), eEvent) == GAMEEVENTRETURN_FALSE) 
	{
		return false;
	}

	EventClassTypes eEventClass = (EventClassTypes)pkEventInfo->getEventClass();
	if (eEventClass != NO_EVENT_CLASS)
	{
		if (eEventClass == EVENT_CLASS_GOOD)
		{
			if (GC.getGame().isOption(GAMEOPTION_GOOD_EVENTS_OFF))
				return false;
		}
		else if (eEventClass == EVENT_CLASS_BAD)
		{
			if (GC.getGame().isOption(GAMEOPTION_BAD_EVENTS_OFF))
				return false;
		}
		else if (eEventClass == EVENT_CLASS_NEUTRAL)
		{
			if (GC.getGame().isOption(GAMEOPTION_NEUTRAL_EVENTS_OFF))
				return false;
		}
		else if (eEventClass == EVENT_CLASS_TRADE)
		{
			if (GC.getGame().isOption(GAMEOPTION_TRADE_EVENTS_OFF))
				return false;
		}
		else if (eEventClass == EVENT_CLASS_CIV_SPECIFIC)
		{
			if (GC.getGame().isOption(GAMEOPTION_CIV_SPECIFIC_EVENTS_OFF))
				return false;
		}
	}
		
	//Let's narrow down all events here!
	if(pkEventInfo->getPrereqTech() != -1 && !GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
		return false;

	if(pkEventInfo->getObsoleteTech() != -1 && GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
		return false;

	if(pkEventInfo->getRequiredEra() != -1 && GetCurrentEra() < (EraTypes)pkEventInfo->getRequiredEra())
		return false;

	if(pkEventInfo->getObsoleteEra() != -1 && GetCurrentEra() >= (EraTypes)pkEventInfo->getObsoleteEra())
		return false;

	if(pkEventInfo->getMinimumNationalPopulation() > 0 && getTotalPopulation() < pkEventInfo->getMinimumNationalPopulation())
		return false;

	if(pkEventInfo->getMinimumNumberCities() > 0 && getNumCities() < pkEventInfo->getMinimumNumberCities())
		return false;

	if(pkEventInfo->getRequiredCiv() != -1 && getCivilizationType() != (CivilizationTypes)pkEventInfo->getRequiredCiv())
		return false;

	if(pkEventInfo->getRequiredPolicy() != -1 && !GetPlayerPolicies()->HasPolicy((PolicyTypes)pkEventInfo->getRequiredPolicy()))
		return false;

	if(pkEventInfo->getRequiredIdeology() != -1 && GetPlayerPolicies()->GetLateGamePolicyTree() != (PolicyBranchTypes)pkEventInfo->getRequiredIdeology())
		return false;

	if(pkEventInfo->hasStateReligion() && GetReligions()->GetStateReligion() == NO_RELIGION)
		return false;

	if(pkEventInfo->hasPantheon() && GetReligions()->GetReligionCreatedByPlayer(true) != RELIGION_PANTHEON)
		return false;

	if(pkEventInfo->isUnhappy() && !IsEmpireUnhappy())
		return false;

	if(pkEventInfo->isSuperUnhappy() && !IsEmpireSuperUnhappy())
		return false;

	if(pkEventInfo->isRequiresIdeology() && GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
		return false;

	if(pkEventInfo->isRequiresWar() && GetMilitaryAI()->GetNumberCivsAtWarWith(false) <= 0)
		return false;

	//Let's do our linker checks here.
	for(int iI = 0; iI <= pkEventInfo->GetNumLinkers(); iI++)
	{
		CvEventLinkingInfo *pLinkerInfo = pkEventInfo->GetLinkerInfo(iI);
		if(pLinkerInfo)
		{
			EventTypes eLinkerEvent = (EventTypes)pLinkerInfo->GetLinkingEvent();
			EventChoiceTypes eLinkerEventChoice = (EventChoiceTypes)pLinkerInfo->GetLinkingEventChoice();
			CityEventTypes eLinkerCityEvent = (CityEventTypes)pLinkerInfo->GetCityLinkingEvent();
			CityEventChoiceTypes eLinkerCityEventChoice = (CityEventChoiceTypes)pLinkerInfo->GetCityLinkingEventChoice();

			PlayerTypes ePlayer;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				ePlayer = (PlayerTypes) iPlayerLoop;
				if(ePlayer == NO_PLAYER)
					continue;

				CvPlayer &kPlayer2 = GET_PLAYER(ePlayer);

				if(!pLinkerInfo->CheckOtherPlayers() && ePlayer != GetID())
					continue;

				if(eLinkerEvent != NO_EVENT)
				{
					bool bActive = (kPlayer2.GetEventCooldown(eLinkerEvent) > 0 || kPlayer2.IsEventFired(eLinkerEvent));
					if(bActive != pLinkerInfo->CheckForActive())
						return false;
				}

				if(eLinkerEventChoice != NO_EVENT_CHOICE)
				{
					bool bActive = (kPlayer2.GetEventChoiceDuration(eLinkerEventChoice) > 0 || kPlayer2.IsEventChoiceFired(eLinkerEventChoice));
					if(bActive != pLinkerInfo->CheckForActive())
						return false;
				}

				if(eLinkerCityEvent != NO_EVENT_CITY || eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
				{
					int iLoop;
					CvCity* pLoopCity;
					for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))
					{
						if(eLinkerCityEvent != NO_EVENT_CITY)
						{
							bool bActive = (pLoopCity->GetEventCooldown(eLinkerCityEvent) > 0 || pLoopCity->IsEventFired(eLinkerCityEvent));
							if(bActive != pLinkerInfo->CheckForActive())
								return false;
						}

						if(eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
						{
							bool bActive = (pLoopCity->GetEventChoiceDuration(eLinkerCityEventChoice) > 0 || pLoopCity->IsEventChoiceFired(eLinkerCityEventChoice));
							if(bActive != pLinkerInfo->CheckForActive())
								return false;
						}
					}
				}
			}
		}
	}

	if(pkEventInfo->getRequiredStateReligion() != -1)
	{
		if(GetReligions()->GetStateReligion() != pkEventInfo->getRequiredStateReligion())
			return false;
	}

	if(!pkEventInfo->isRequiresHolyCity() && pkEventInfo->getRequiredReligion() != -1)
	{
		if((GetReligions()->GetCurrentReligion(false) != (ReligionTypes)pkEventInfo->getRequiredReligion()) && (GetReligions()->GetReligionInMostCities() != (ReligionTypes)pkEventInfo->getRequiredReligion()))
			return false;
	}

	if(pkEventInfo->hasMetAnotherCiv())
	{
		if(GET_TEAM(getTeam()).getHasMetCivCount(true) <= 0)
			return false;
	}

	if(MOD_DIPLOMACY_CIV4_FEATURES && pkEventInfo->isMaster() && GET_TEAM(getTeam()).GetNumVassals() <= 0)
		return false;

	if(MOD_DIPLOMACY_CIV4_FEATURES && pkEventInfo->isVassal() && !GET_TEAM(getTeam()).IsVassalOfSomeone())
		return false;

	if(pkEventInfo->isTradeCapped() && GetTrade()->GetNumTradeUnitsRemaining(true) <= 0)
		return false;


	if(pkEventInfo->getUnitTypeRequired() != -1)
	{
		bool bHas = false;
		CvUnit* pLoopUnit;
		int iLoop;
		for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		{
			if(pLoopUnit != NULL && pLoopUnit->getUnitClassType() == (UnitClassTypes)pkEventInfo->getUnitTypeRequired())
			{
				bHas = true;
				break;
			}
		}
		if(!bHas)
		{
			return false;
		}
	}

	if(pkEventInfo->isRequiresHolyCity())
	{
		bool bHas = false;
		CvCity* pCity = NULL;
		int iLoop;
		for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
		{
			if(pkEventInfo->getRequiredReligion() != -1)
			{
				if(pCity != NULL && pCity->GetCityReligions()->IsHolyCityForReligion((ReligionTypes)pkEventInfo->getRequiredReligion()))
				{
					bHas = true;
					break;
				}
			}
			else
			{
				if(pCity != NULL && pCity->GetCityReligions()->IsHolyCityAnyReligion())
				{
					bHas = true;
					break;
				}
			}
		}
		if(!bHas)
		{
			return false;
		}
	}
	if(pkEventInfo->getNumCoastalRequired() > 0)
	{
		bool bHas = false;
		CvCity* pCity = NULL;
		int iLoop;
		int iNumCoastal = 0;
		for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
		{
			if(pCity != NULL && pCity->isCoastal())
			{
				iNumCoastal++;
			}
			if(iNumCoastal >= pkEventInfo->getNumCoastalRequired())
			{
				bHas = true;
				break;
			}
		}
		if(!bHas)
		{
			return false;
		}
	}

	if(pkEventInfo->isRequiresWarMinor())
	{
		bool bHas = false;
		for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			// Is this a player we have relations with?
			if(GET_PLAYER(eLoopPlayer).isBarbarian())
			{
				continue;
			}
			if(!GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				continue;
			}
			if(eLoopPlayer != GetID())
			{
				if(GET_TEAM(getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
				{
					bHas = true;
					break;
				}
			}
		}
		if(!bHas)
		{
			return false;
		}
	}
	bool bHas = true;
	for(int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
	{
		const ResourceTypes eResource = static_cast<ResourceTypes>(iJ);
		CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
		if(pkResource)
		{
			if(pkEventInfo->getResourceRequired(eResource) > 0)
			{
				if(getNumResourceTotal(eResource, false) < pkEventInfo->getResourceRequired(eResource))
				{
					bHas = false;
					break;
				}
			}
		}
	}
	if(!bHas)
	{
		return false;
	}
	for(int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
	{
		const FeatureTypes eFeature = static_cast<FeatureTypes>(iJ);
		CvFeatureInfo* pkFeature = GC.getFeatureInfo(eFeature);
		if(pkFeature)
		{
			if(pkEventInfo->getFeatureRequired(eFeature) > 0)
			{
				bool bHas = false;
				CvCity* pCity = NULL;
				int iLoop;
				int iNeeded = pkEventInfo->getFeatureRequired(eFeature);
				int iHave = 0;
				for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
				{

					if(pCity != NULL && pCity->HasFeature(eFeature))
					{
						iHave++;
					}
					if(iHave >= iNeeded)
					{
						bHas = true;
						break;
					}
				}
				if(!bHas)
				{
					return false;
				}
			}
		}
	}

	if(pkEventInfo->getBuildingRequired() != -1)
	{
		BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventInfo->getBuildingRequired();
		if(eBuildingClass != NO_BUILDINGCLASS)
		{
			bool bHas = false;
			CvCity* pCity = NULL;
			int iLoop;
			for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
			{
				if(pCity != NULL && pCity->GetCityBuildings()->GetNumBuildingClass(eBuildingClass) > 0)
				{
					bHas = true;
					break;
				}
			}
			if(!bHas)
			{
				return false;
			}
		}
	}
	if(pkEventInfo->getBuildingLimiter() != -1)
	{
		BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventInfo->getBuildingLimiter();
		if(eBuildingClass != NO_BUILDINGCLASS)
		{
			bool bHas = false;
			CvCity* pCity = NULL;
			int iLoop;
			for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
			{
				if(pCity != NULL && pCity->GetCityBuildings()->GetNumBuildingClass(eBuildingClass) > 0)
				{
					bHas = true;
					break;
				}
			}
			if(bHas)
			{
				return false;
			}
		}
	}
	if(pkEventInfo->getRequiredImprovement() != -1)
	{
		ImprovementTypes eImprovement = (ImprovementTypes)pkEventInfo->getRequiredImprovement();
		if(eImprovement != NO_IMPROVEMENT)
		{
			bool bHas = false;
			CvPlot* pLoopPlot;
			int iNumPlotsInEntireWorld = GC.getMap().numPlots();
			for(int iI = 0; iI < iNumPlotsInEntireWorld; iI++)
			{
				pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

				if(pLoopPlot == NULL)
					return false;

				if(pLoopPlot->getOwner() == GetID() && pLoopPlot->getImprovementType() == eImprovement)
				{
					bHas = true;
					break;
				}
			}
			if(!bHas)
			{
				return false;
			}
		}
	}
	//Check our minimum yields - this looks at stored values, not yields per turn.
	bHas = true;
	for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes)iI;
		if(eYield == NO_YIELD)
			return false;
							
		int iNeededYield = pkEventInfo->getYieldMinimum(eYield);
		iNeededYield *= GC.getGame().getGameSpeedInfo().getTrainPercent();
		iNeededYield /= 100;
		if(pkEventInfo->isEraScaling())
		{
			int iEra = GetCurrentEra();
			if(iEra <= 0)
			{
				iEra = 1;
			}
			iNeededYield *= iEra;
		}
		if(iNeededYield != 0)
		{
			if(eYield == YIELD_GOLD)
			{
				if(iNeededYield > GetTreasury()->GetGold())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_SCIENCE)
			{
				TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
				int iTech = 0;
				if(eCurrentTech != NO_TECH)
				{
					iTech = GetPlayerTechs()->GetResearchProgress(eCurrentTech);
				}
				if(iNeededYield > iTech)
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_FAITH)
			{
				if(iNeededYield > GetFaith())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_GOLDEN_AGE_POINTS)
			{
				if(iNeededYield > GetGoldenAgeProgressMeter())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_CULTURE)
			{
				if(iNeededYield > getJONSCulture())
				{
					bHas = false;
					break;
				}
			}
		}
	}
	if(!bHas)
	{
		return false;
	}

	if(pkEventInfo->isInDebt() && GetTreasury()->GetGold() > 0)
		return false;

	if(pkEventInfo->isLosingMoney() && GetTreasury()->CalculateBaseNetGold() > 0)
		return false;

	return true;
}
bool CvPlayer::IsEventChoiceValid(EventChoiceTypes eChosenEventChoice, EventTypes eParentEvent)
{
	if(eChosenEventChoice == NO_EVENT_CHOICE)
		return false;

	CvModEventChoiceInfo* pkEventInfo = GC.getEventChoiceInfo(eChosenEventChoice);
	if(pkEventInfo == NULL)
	{
		return false;
	}

	//Exploit checks.
	if (isEndTurn())
	{
		// Not sure what the exploits are in particular but global events are fired outside of human turns so we can't return here
		if(!GC.getGame().isNetworkMultiPlayer()) // check simul/hybrid turns instead maybe? not sure yet.
			return false;
	}

	if(!IsEventActive(eParentEvent))
		return false;

	//Lua Hook
	if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_EventChoiceCanTake, GetID(), eChosenEventChoice) == GAMEEVENTRETURN_FALSE) {
		return false;
	}

	if(!pkEventInfo->isParentEvent(eParentEvent))
		return false;

	if(pkEventInfo->isOneShot() && IsEventChoiceFired(eChosenEventChoice))
		return false;

	//Event Choice already active for this event? Abort!
	if(GetEventChoiceDuration(eChosenEventChoice) > 0)
	{
		if(GC.getLogging())
		{
			CvString playerName;
			FILogFile* pLog;
			CvString strBaseString;
			CvString strOutBuf;
			CvString strFileName = "EventLogging.csv";
			playerName = getCivilizationShortDescription();
			pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			strBaseString += playerName + ", ";
			strOutBuf.Format("Event choice already active for player, skipping: %s, Event: %s. Cooldown: %d", pkEventInfo->GetDescription(), pkEventInfo->GetDescription(), GetEventChoiceDuration(eChosenEventChoice));
			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}
		return false;
	}

	//Let's narrow down all events here!
	if(pkEventInfo->getPrereqTech() != -1 && !GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
		return false;

	if(pkEventInfo->getObsoleteTech() != -1 && GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
		return false;

	if(pkEventInfo->getRequiredEra() != -1 && GetCurrentEra() < (EraTypes)pkEventInfo->getRequiredEra())
		return false;

	if(pkEventInfo->getObsoleteEra() != -1 && GetCurrentEra() >= (EraTypes)pkEventInfo->getObsoleteEra())
		return false;

	if(pkEventInfo->getMinimumNationalPopulation() > 0 && getTotalPopulation() < pkEventInfo->getMinimumNationalPopulation())
		return false;

	if(pkEventInfo->getMinimumNumberCities() > 0 && getNumCities() < pkEventInfo->getMinimumNumberCities())
		return false;

	if(pkEventInfo->getRequiredCiv() != -1 && getCivilizationType() != (CivilizationTypes)pkEventInfo->getRequiredCiv())
		return false;

	if(pkEventInfo->getRequiredPolicy() != -1 && !GetPlayerPolicies()->HasPolicy((PolicyTypes)pkEventInfo->getRequiredPolicy()))
		return false;

	if(pkEventInfo->getRequiredIdeology() != -1 && GetPlayerPolicies()->GetLateGamePolicyTree() != (PolicyBranchTypes)pkEventInfo->getRequiredIdeology())
		return false;

	if(pkEventInfo->hasStateReligion() && GetReligions()->GetStateReligion() == NO_RELIGION)
		return false;

	if(pkEventInfo->hasPantheon() && GetReligions()->GetReligionCreatedByPlayer(true) != RELIGION_PANTHEON)
		return false;

	if(pkEventInfo->isUnhappy() && !IsEmpireUnhappy())
		return false;

	if(pkEventInfo->isSuperUnhappy() && !IsEmpireSuperUnhappy())
		return false;

	if(pkEventInfo->isRequiresIdeology() && GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
		return false;

	if(pkEventInfo->isRequiresWar() && GetMilitaryAI()->GetNumberCivsAtWarWith(false) <= 0)
		return false;

	if(pkEventInfo->getRequiredStateReligion() != -1)
	{
		if(GetReligions()->GetStateReligion() != pkEventInfo->getRequiredStateReligion())
			return false;
	}

	if(!pkEventInfo->isRequiresHolyCity() && pkEventInfo->getRequiredReligion() != -1)
	{
		if((GetReligions()->GetCurrentReligion(false) != (ReligionTypes)pkEventInfo->getRequiredReligion()) && (GetReligions()->GetReligionInMostCities() != (ReligionTypes)pkEventInfo->getRequiredReligion()))
			return false;
	}

	//Let's do our linker checks here.
	for(int iI = 0; iI <= pkEventInfo->GetNumLinkers(); iI++)
	{
		CvEventChoiceLinkingInfo *pLinkerInfo = pkEventInfo->GetLinkerInfo(iI);
		if(pLinkerInfo)
		{
			EventTypes eLinkerEvent = (EventTypes)pLinkerInfo->GetLinkingEvent();
			EventChoiceTypes eLinkerEventChoice = (EventChoiceTypes)pLinkerInfo->GetLinkingEventChoice();
			CityEventTypes eLinkerCityEvent = (CityEventTypes)pLinkerInfo->GetCityLinkingEvent();
			CityEventChoiceTypes eLinkerCityEventChoice = (CityEventChoiceTypes)pLinkerInfo->GetCityLinkingEventChoice();

			PlayerTypes ePlayer;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				ePlayer = (PlayerTypes) iPlayerLoop;
				if(ePlayer == NO_PLAYER)
					continue;

				CvPlayer &kPlayer2 = GET_PLAYER(ePlayer);

				if(!pLinkerInfo->CheckOtherPlayers() && ePlayer != GetID())
					continue;

				if(eLinkerEvent != NO_EVENT)
				{
					bool bActive = (kPlayer2.GetEventCooldown(eLinkerEvent) > 0 || kPlayer2.IsEventFired(eLinkerEvent));
					if(bActive != pLinkerInfo->CheckForActive())
						return false;
				}

				if(eLinkerEventChoice != NO_EVENT_CHOICE)
				{
					bool bActive = (kPlayer2.GetEventChoiceDuration(eLinkerEventChoice) > 0 || kPlayer2.IsEventChoiceFired(eLinkerEventChoice));
					if(bActive != pLinkerInfo->CheckForActive())
						return false;
				}

				if(eLinkerCityEvent != NO_EVENT_CITY || eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
				{
					int iLoop;
					CvCity* pLoopCity;
					for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))
					{
						if(eLinkerCityEvent != NO_EVENT_CITY)
						{
							bool bActive = (pLoopCity->GetEventCooldown(eLinkerCityEvent) > 0 || pLoopCity->IsEventFired(eLinkerCityEvent));
							if(bActive != pLinkerInfo->CheckForActive())
								return false;
						}

						if(eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
						{
							bool bActive = (pLoopCity->GetEventChoiceDuration(eLinkerCityEventChoice) > 0 || pLoopCity->IsEventChoiceFired(eLinkerCityEventChoice));
							if(bActive != pLinkerInfo->CheckForActive())
								return false;
						}
					}
				}
			}
		}
	}

	if(pkEventInfo->hasMetAnotherCiv())
	{
		if(GET_TEAM(getTeam()).getHasMetCivCount(true) <= 0)
			return false;
	}

	if(MOD_DIPLOMACY_CIV4_FEATURES && pkEventInfo->isMaster() && GET_TEAM(getTeam()).GetNumVassals() <= 0)
		return false;

	if(MOD_DIPLOMACY_CIV4_FEATURES && pkEventInfo->isVassal() && !GET_TEAM(getTeam()).IsVassalOfSomeone())
		return false;

	if(pkEventInfo->isTradeCapped() && GetTrade()->GetNumTradeUnitsRemaining(true) <= 0)
		return false;

	if(pkEventInfo->getUnitTypeRequired() != -1)
	{
		bool bHas = false;
		CvUnit* pLoopUnit;
		int iLoop;
		for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		{
			if(pLoopUnit != NULL && pLoopUnit->getUnitClassType() == (UnitClassTypes)pkEventInfo->getUnitTypeRequired())
			{
				bHas = true;
				break;
			}
		}
		if(!bHas)
		{
			return false;
		}
	}


	if(pkEventInfo->isRequiresHolyCity())
	{
		bool bHas = false;
		CvCity* pCity = NULL;
		int iLoop;
		for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
		{
			if(pkEventInfo->getRequiredReligion() != -1)
			{
				if(pCity != NULL && pCity->GetCityReligions()->IsHolyCityForReligion((ReligionTypes)pkEventInfo->getRequiredReligion()))
				{
					bHas = true;
					break;
				}
			}
			else
			{
				if(pCity != NULL && pCity->GetCityReligions()->IsHolyCityAnyReligion())
				{
					bHas = true;
					break;
				}
			}
		}
		if(!bHas)
		{
			return false;
		}
	}
	if(pkEventInfo->getNumCoastalRequired() > 0)
	{
		bool bHas = false;
		CvCity* pCity = NULL;
		int iLoop;
		int iNumCoastal = 0;
		for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
		{
			if(pCity != NULL && pCity->isCoastal())
			{
				iNumCoastal++;
			}
			if(iNumCoastal >= pkEventInfo->getNumCoastalRequired())
			{
				bHas = true;
				break;
			}
		}
		if(!bHas)
		{
			return false;
		}
	}

	if(pkEventInfo->isRequiresWarMinor())
	{
		bool bHas = false;
		for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			// Is this a player we have relations with?
			if(GET_PLAYER(eLoopPlayer).isBarbarian())
			{
				continue;
			}
			if(!GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				continue;
			}
			if(eLoopPlayer != GetID())
			{
				if(GET_TEAM(getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
				{
					bHas = true;
					break;
				}
			}
		}
		if(!bHas)
		{
			return false;
		}
	}
	bool bHas = true;
	for(int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
	{
		const ResourceTypes eResource = static_cast<ResourceTypes>(iJ);
		CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
		if(pkResource)
		{
			if(pkEventInfo->getResourceRequired(eResource) > 0)
			{
				if(getNumResourceTotal(eResource, false) < pkEventInfo->getResourceRequired(eResource))
				{
					bHas = false;
					break;
				}
			}
		}
	}
	if(!bHas)
	{
		return false;
	}
	for(int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
	{
		const FeatureTypes eFeature = static_cast<FeatureTypes>(iJ);
		CvFeatureInfo* pkFeature = GC.getFeatureInfo(eFeature);
		if(pkFeature)
		{
			if(pkEventInfo->getFeatureRequired(eFeature) > 0)
			{
				bool bHas = false;
				CvCity* pCity = NULL;
				int iLoop;
				int iNeeded = pkEventInfo->getFeatureRequired(eFeature);
				int iHave = 0;
				for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
				{

					if(pCity != NULL && pCity->HasFeature(eFeature))
					{
						iHave++;
					}
					if(iHave >= iNeeded)
					{
						bHas = true;
						break;
					}
				}
				if(!bHas)
				{
					return false;
				}
			}
		}
	}
	if(pkEventInfo->getBuildingRequired() != -1)
	{
		BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventInfo->getBuildingRequired();
		if(eBuildingClass != NO_BUILDINGCLASS)
		{
			bool bHas = false;
			CvCity* pCity = NULL;
			int iLoop;
			for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
			{
				if(pCity != NULL && pCity->GetCityBuildings()->GetNumBuildingClass(eBuildingClass) > 0)
				{
					bHas = true;
					break;
				}
			}
			if(!bHas)
			{
				return false;
			}
		}
	}
	if(pkEventInfo->getBuildingLimiter() != -1)
	{
		BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventInfo->getBuildingLimiter();
		if(eBuildingClass != NO_BUILDINGCLASS)
		{
			bool bHas = false;
			CvCity* pCity = NULL;
			int iLoop;
			for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
			{
				if(pCity != NULL && pCity->GetCityBuildings()->GetNumBuildingClass(eBuildingClass) > 0)
				{
					bHas = true;
					break;
				}
			}
			if(bHas)
			{
				return false;
			}
		}
	}
	if(pkEventInfo->getRequiredImprovement() != -1)
	{
		ImprovementTypes eImprovement = (ImprovementTypes)pkEventInfo->getRequiredImprovement();
		if(eImprovement != NO_IMPROVEMENT)
		{
			bool bHas = false;
			CvPlot* pLoopPlot;
			int iNumPlotsInEntireWorld = GC.getMap().numPlots();
			for(int iI = 0; iI < iNumPlotsInEntireWorld; iI++)
			{
				pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

				if(pLoopPlot == NULL)
					continue;

				if(pLoopPlot->getOwner() == GetID() && pLoopPlot->getImprovementType() == eImprovement)
				{
					bHas = true;
					break;
				}
			}
			if(!bHas)
			{
				return false;
			}
		}
	}
	//Check our minimum yields - this looks at stored values, not yields per turn.
	bHas = true;
	for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes)iI;
		if(eYield == NO_YIELD)
			continue;
							
		int iNeededYield = pkEventInfo->getYieldMinimum(eYield);
		if(pkEventInfo->getPreCheckEventYield(eYield) != 0)
		{
			if(iNeededYield < pkEventInfo->getPreCheckEventYield(eYield))
			{
				iNeededYield = pkEventInfo->getPreCheckEventYield(eYield);
			}
		}
		iNeededYield *= GC.getGame().getGameSpeedInfo().getTrainPercent();
		iNeededYield /= 100;
		if(pkEventInfo->IsEraScaling())
		{
			int iEra = GetCurrentEra();
			if(iEra <= 0)
			{
				iEra = 1;
			}
			iNeededYield *= iEra;
		}
		if(iNeededYield != 0)
		{
			if(eYield == YIELD_GOLD)
			{
				if(iNeededYield > GetTreasury()->GetGold())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_SCIENCE)
			{
				TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
				int iTech = 0;
				if(eCurrentTech != NO_TECH)
				{
					iTech = GetPlayerTechs()->GetResearchProgress(eCurrentTech);
				}
				if(iNeededYield > iTech)
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_FAITH)
			{
				if(iNeededYield > GetFaith())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_GOLDEN_AGE_POINTS)
			{
				if(iNeededYield > GetGoldenAgeProgressMeter())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_CULTURE)
			{
				if(iNeededYield > getJONSCulture())
				{
					bHas = false;
					break;
				}
			}
		}
	}
	if(!bHas)
	{
		return false;
	}

	if(pkEventInfo->isInDebt() && GetTreasury()->GetGold() > 0)
		return false;

	if(pkEventInfo->isLosingMoney() && GetTreasury()->CalculateBaseNetGold() > 0)
		return false;

	return true;
}
void CvPlayer::DoStartEvent(EventTypes eChosenEvent)
{
	if(eChosenEvent != NO_EVENT)
	{
		CvModEventInfo* pkEventInfo = GC.getEventInfo(eChosenEvent);
		if(pkEventInfo != NULL)
		{
			//Set true so we know we're doing an event right now.
			SetEventActive(eChosenEvent, true);
	
			//Set oneshot stuff so this event can't fire ever again.
			if(pkEventInfo->isOneShot())
			{
				SetEventFired(eChosenEvent, true);
			}

			//Lua Hook
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_EventActivated, GetID(), eChosenEvent);

			//Gamespeed.
			int iEventDuration = pkEventInfo->getCooldown();
			iEventDuration *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iEventDuration /= 100;
			ChangeEventCooldown(eChosenEvent, iEventDuration);
			if(GC.getLogging())
			{
				CvString playerName;
				FILogFile* pLog;
				CvString strBaseString;
				CvString strOutBuf;
				CvString strFileName = "EventLogging.csv";
				playerName = getCivilizationShortDescription();
				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				strBaseString += playerName + ", ";
				strOutBuf.Format("Event started for player: %s. Cooldown: %d", pkEventInfo->GetDescription(), iEventDuration);
				strBaseString += strOutBuf;
				pLog->Msg(strBaseString);
			}
			int iNumEvents = 0;
			EventChoiceTypes eEventChoice = NO_EVENT_CHOICE;
			for(int iLoop = 0; iLoop < GC.getNumEventChoiceInfos(); iLoop++)
			{
				eEventChoice = (EventChoiceTypes)iLoop;
				if(eEventChoice != NO_EVENT_CHOICE)
				{
					CvModEventChoiceInfo* pkEventChoiceInfo = GC.getEventChoiceInfo(eEventChoice);
					if(pkEventChoiceInfo != NULL)
					{
						if(IsEventChoiceValid(eEventChoice, eChosenEvent))
						{
							iNumEvents++;
							if(pkEventInfo->getNumChoices() == 1)
							{
								DoEventChoice(eEventChoice, eChosenEvent);
								if(isHuman())
								{
									CvPopupInfo kPopupInfo(BUTTONPOPUP_MODDER_9, eEventChoice, GetID());
									GC.GetEngineUserInterface()->AddPopup(kPopupInfo);
								}
								return;
							}
						}
					}
				}
			}
			if(iNumEvents > 0 && pkEventInfo->getNumChoices() > 1)
			{
				if(isHuman())
				{
					CvNotifications* pNotifications = GetNotifications();
					if(pNotifications)
					{
						CvString strBuffer = GetLocalizedText("TXT_KEY_CHOOSE_EVENT_CHOICE");
						CvString strSummary = GetLocalizedText("TXT_KEY_CHOOSE_EVENT_CHOICE_TT");
						pNotifications->Add((NotificationTypes)FString::Hash("NOTIFICATION_EVENT_CHOICE"), strSummary.c_str(), strBuffer.c_str(), -1, -1, eChosenEvent);
					}
				}
				else
				{
					//Lua Hook
					if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_OverrideAIEvent, GetID(), eChosenEvent) == GAMEEVENTRETURN_TRUE) 
					{
						return;
					}

					AI_DoEventChoice(eChosenEvent);
				}
			}
		}
	}
}
void CvPlayer::DoCancelEventChoice(EventChoiceTypes eChosenEventChoice)
{
	if(eChosenEventChoice == NO_EVENT_CHOICE)
		return;

	CvModEventChoiceInfo* pkEventChoiceInfo = GC.getEventChoiceInfo(eChosenEventChoice);
	if(pkEventChoiceInfo != NULL)
	{
		//Lua Hook
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_EventChoiceEnded, GetID(), eChosenEventChoice);

		bool bChanged = false;
		if(GC.getLogging())
		{
			CvString playerName;
			FILogFile* pLog;
			CvString strBaseString;
			CvString strOutBuf;
			CvString strFileName = "EventLogging.csv";
			playerName = getCivilizationShortDescription();
			pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			strBaseString += playerName + ", ";
			strOutBuf.Format("Event choice ended for player: %s", pkEventChoiceInfo->GetDescription());
			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}
		//Let's make sure this is at zero.
		ChangeEventChoiceDuration(eChosenEventChoice, -GetEventChoiceDuration(eChosenEventChoice));
					
		//Let's only deduct if we actually started this event and it expires.
		if(IsEventChoiceActive(eChosenEventChoice) && pkEventChoiceInfo->Expires())
		{
			if(pkEventChoiceInfo->getEventPolicy() != -1)
			{
				PolicyTypes ePolicy = (PolicyTypes)pkEventChoiceInfo->getEventPolicy();
				if(ePolicy != -1)
				{
					setHasPolicy(ePolicy, false, true);
					bChanged = true;
				}
			}
			if(pkEventChoiceInfo->getEventTech() != -1)
			{
				TechTypes eTech = (TechTypes)pkEventChoiceInfo->getEventTech();
				if(eTech != -1)
				{
					GET_TEAM(getTeam()).GetTeamTechs()->SetHasTech(eTech, false);
				}
			}
			if(pkEventChoiceInfo->getEventBuilding() != -1)
			{
				BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventChoiceInfo->getEventBuilding();
				if(eBuildingClass != -1)
				{
					const CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
	
					if (pkBuildingClassInfo)
					{
						CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
		
						if (pCivilizationInfo != NULL)
						{
							BuildingTypes eBuildingType = (BuildingTypes) pCivilizationInfo->getCivilizationBuildings(eBuildingClass);
							CvCity *pLoopCity;
							int iLoop;
							for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
								{
									continue;
								}
								if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
								{
									continue;
								}
								pLoopCity->GetCityBuildings()->SetNumRealBuilding(eBuildingType, 0);
								bChanged = true;
							}
						}
					}
				}
			}
			if(pkEventChoiceInfo->getEventPromotion() != -1)
			{
				PromotionTypes ePromotion = (PromotionTypes)pkEventChoiceInfo->getEventPromotion();
				if(ePromotion != -1)
				{
					CvUnit* pLoopUnit;
					int iLoop;
					for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
					{
						if(pLoopUnit->getUnitType() != NO_UNIT)
						{
							if(::IsPromotionValidForUnitCombatType(ePromotion, pLoopUnit->getUnitType()))
							{
								pLoopUnit->setHasPromotion(ePromotion, false);
								bChanged = true;
							}
						}
					}
					ChangeFreePromotionCount(ePromotion, -1);
				}
			}
			for(int iI = 0; iI < GC.getNumResourceInfos(); iI++)
			{
				ResourceTypes eResource = (ResourceTypes)iI;
				if(eResource != NO_RESOURCE)
				{
					int iBonus = pkEventChoiceInfo->getEventResourceChange(eResource);
					iBonus *= -1;
					if(iBonus != 0)
					{
						changeNumResourceTotal(eResource, iBonus);
						bChanged = true;
					}
				}
			}
			if(pkEventChoiceInfo->getPlayerHappiness() != 0)
			{
				if(getCapitalCity() != NULL)
				{
					getCapitalCity()->ChangeEventHappiness(pkEventChoiceInfo->getPlayerHappiness() * -1);
					bChanged = true;
				}
			}
			if(pkEventChoiceInfo->getCityHappinessGlobal() != 0)
			{
				CvCity *pLoopCity;
				int iLoop;
				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
					{
						continue;
					}
					if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
					{
						continue;
					}
					pLoopCity->ChangeEventHappiness(pkEventChoiceInfo->getCityHappinessGlobal() * -1);
					bChanged = true;
				}
			}
			for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				YieldTypes eYield = (YieldTypes)iI;
				if(eYield == NO_YIELD)
					continue;

				if(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS)
				{
					int iUnhappinessNeedMod = pkEventChoiceInfo->getCityUnhappinessNeedMod(eYield);
					if(iUnhappinessNeedMod != 0)
					{
						iUnhappinessNeedMod *= -1;
						if(eYield == YIELD_GOLD)
						{
							ChangePovertyUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_CULTURE)
						{
							ChangeUnculturedUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_PRODUCTION)
						{
							ChangeDefenseUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_SCIENCE)
						{
							ChangeIlliteracyUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_FAITH)
						{
							ChangeMinorityUnhappinessGlobal(iUnhappinessNeedMod);
						}
					}
				}

				int iYieldChange = pkEventChoiceInfo->getCityYield(eYield);
				if(iYieldChange != 0)
				{
					if(pkEventChoiceInfo->IsEraScaling())
					{
						int iEra = GetCurrentEra();
						if(iEra <= 0)
						{
							iEra = 1;
						}
						iYieldChange *= iEra;
					}
					CvCity *pLoopCity;
					int iLoop;
					for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
						{
							continue;
						}
						if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
						{
							continue;
						}
						pLoopCity->ChangeEventCityYield(eYield, iYieldChange * -1);
						bChanged = true;
					}
				}
				// Building modifiers
				for(int iJ = 0; iJ < GC.getNumBuildingClassInfos(); iJ++)
				{
					BuildingClassTypes eBuildingClass = (BuildingClassTypes) iJ;

					CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
					if(!pkBuildingClassInfo)
					{
						continue;
					}
					if(pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield) != 0)
					{
						BuildingTypes eBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

						if(eBuilding != NO_BUILDING)
						{
							CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
							if(pkBuilding)
							{
								CvCity *pLoopCity;
								int iLoop;
								for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
								{
									if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
									{
										continue;
									}
									if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
									{
										continue;
									}
									int iBuildingCount = pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding);

									pLoopCity->ChangeEventBuildingClassYield(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield) * -1);
									bChanged = true;
									if(iBuildingCount > 0)
									{
										pLoopCity->ChangeBaseYieldRateFromBuildings(eYield, pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield) * -1);
									}
								}
							}
						}
					}
					if(pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield) != 0)
					{
						BuildingTypes eBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

						if(eBuilding != NO_BUILDING)
						{
							CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
							if(pkBuilding)
							{
								CvCity *pLoopCity;
								int iLoop;
								for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
								{
									if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
									{
										continue;
									}
									if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
									{
										continue;
									}
									int iBuildingCount = pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding);
									pLoopCity->ChangeEventBuildingClassYieldModifier(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield) * -1);
									bChanged = true;
									if(iBuildingCount > 0)
									{
										pLoopCity->changeYieldRateModifier(eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield) * -1);
									}
								}
							}
						}
					}
				}
				for(int iJ = 0; iJ < GC.getNumImprovementInfos(); iJ++)
				{
					ImprovementTypes eImprovement = (ImprovementTypes)iJ;
					if(eImprovement != NO_IMPROVEMENT && pkEventChoiceInfo->getImprovementYield(eImprovement, eYield) != 0)
					{
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
							{
								continue;
							}
							if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
							{
								continue;
							}
							pLoopCity->ChangeEventImprovementYield(eImprovement, eYield, pkEventChoiceInfo->getImprovementYield(eImprovement, eYield) * -1);
						}
						bChanged = true;
					}
				}
				for(int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
				{
					FeatureTypes eFeature = (FeatureTypes)iJ;
					if(eFeature != NO_FEATURE && pkEventChoiceInfo->getFeatureYield(eFeature, eYield) != 0)
					{
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
							{
								continue;
							}
							if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
							{
								continue;
							}
							pLoopCity->ChangeEventFeatureYield(eFeature, eYield, pkEventChoiceInfo->getFeatureYield(eFeature, eYield) * -1);
						}
						bChanged = true;
					}
				}
				for(int iJ = 0; iJ < GC.getNumTerrainInfos(); iJ++)
				{
					TerrainTypes eTerrain = (TerrainTypes)iJ;
					if(eTerrain != NO_TERRAIN && pkEventChoiceInfo->getTerrainYield(eTerrain, eYield) != 0)
					{
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
							{
								continue;
							}
							if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
							{
								continue;
							}
							pLoopCity->ChangeEventTerrainYield(eTerrain, eYield, pkEventChoiceInfo->getTerrainYield(eTerrain, eYield) * -1);
						}
						bChanged = true;
					}
				}
				for(int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
				{
					ResourceTypes eResource = (ResourceTypes)iJ;
					if(eResource != NO_RESOURCE && pkEventChoiceInfo->getResourceYield(eResource, eYield) != 0)
					{
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
							{
								continue;
							}
							if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
							{
								continue;
							}
							pLoopCity->ChangeEventResourceYield(eResource, eYield, pkEventChoiceInfo->getResourceYield(eResource, eYield) * -1);
						}
						bChanged = true;
					}
				}
				for(int iJ = 0; iJ < GC.getNumSpecialistInfos(); iJ++)
				{
					const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iJ);
					CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
					if(pkSpecialistInfo)
					{
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
							{
								continue;
							}
							if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
							{
								continue;
							}
							pLoopCity->ChangeEventSpecialistYield(eSpecialist, eYield, pkEventChoiceInfo->getGlobalSpecialistYieldChange(eSpecialist, eYield) * -1);
						}
						bChanged = true;
					}
				}
			}
		}
		if(bChanged)
		{
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications && GC.getGame().getActivePlayer() == GetID())
			{
				Localization::String strMessage;
				Localization::String strSummary;
				strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_EVENT_HAS_ENDED");
				strMessage << GetScaledHelpText(eChosenEventChoice, true);
				strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_EVENT_HAS_ENDED_T");

				pNotifications->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, -1, GetID());
			}
			CvCity* pLoopCity;
			int iLoop;
			for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				if(pLoopCity != NULL)
				{
					if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
					{
						continue;
					}
					if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
					{
						continue;
					}
					for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
					{
						YieldTypes eYield = (YieldTypes) iI;
						if(eYield == NO_YIELD)
							continue;

						pLoopCity->UpdateSpecialReligionYields(eYield);
						pLoopCity->UpdateCityYields(eYield);
					}
					pLoopCity->UpdateReligion(pLoopCity->GetCityReligions()->GetReligiousMajority());
					CalculateNetHappiness();
					pLoopCity->GetCityCulture()->CalculateBaseTourismBeforeModifiers();
					pLoopCity->GetCityCulture()->CalculateBaseTourism();
				}
			}
		}
		if (!pkEventChoiceInfo->isOneShot())
		{
			//Set it false here so we know the event choice is over now.
			SetEventChoiceActive(eChosenEventChoice, false);
		}
	}
}
CvString CvPlayer::GetScaledHelpText(EventChoiceTypes eEventChoice, bool bYieldsOnly)
{
	CvString CoreYieldTip = "";
	CvModEventChoiceInfo* pkEventChoiceInfo = GC.getEventChoiceInfo(eEventChoice);
	if(pkEventChoiceInfo == NULL)
	{
		return "";
	}
	Localization::String localizedCoreText;
	if(bYieldsOnly)
	{
		localizedCoreText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION");
	}
	else
	{
		localizedCoreText = Localization::Lookup(pkEventChoiceInfo->GetHelp());
	}

	int iEra = GetCurrentEra();
	if(iEra <= 0)
	{
		iEra = 1;
	}
	CvString yieldCostTip = "";
	CvString yieldInstantTip = "";
	CvString yieldCityTip = "";
	CvString turnsTip = "";
				
	for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eIndex = (YieldTypes)iI;
		if(eIndex == NO_YIELD)
		{
			continue;
		}
		CvYieldInfo* pYield = GC.getYieldInfo(eIndex);
		if(pYield)
		{
			int iPreValue = pkEventChoiceInfo->getPreCheckEventYield(eIndex);
			if(pkEventChoiceInfo->IsEraScaling())
			{
				iPreValue *= iEra;
			}
			iPreValue *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iPreValue /= 100;
			if(iPreValue != 0)
			{
				iPreValue *= -1;
				if(yieldCostTip != "")
				{
					yieldCostTip += ", ";
				}
				Localization::String localizedCostText;
				if(bYieldsOnly)
				{
					localizedCostText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_SPENT");
				}
				else
				{
					localizedCostText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED");
				}
				localizedCostText << pYield->GetDescription();
				localizedCostText << pYield->getIconString();
				localizedCostText << iPreValue;

				const char* const localized = localizedCostText.toUTF8();
				if(localized)
				{
					yieldCostTip += localized;
				}
			}
			int iYieldValue = pkEventChoiceInfo->getEventYield(eIndex);
			if(pkEventChoiceInfo->IsEraScaling())
			{
				iYieldValue *= iEra;
			}
			iYieldValue *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iYieldValue /= 100;
			if(iYieldValue != 0)
			{
				if(yieldInstantTip != "")
				{
					yieldInstantTip += ", ";
				}
				Localization::String localizedEventText;
				if(bYieldsOnly)
				{
					localizedEventText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_INSTANT");
				}
				else
				{
					localizedEventText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED");
				}
				localizedEventText << pYield->GetDescription();
				localizedEventText << pYield->getIconString();
				localizedEventText << iYieldValue;

				const char* const localized = localizedEventText.toUTF8();
				if(localized)
				{
					yieldInstantTip += localized;
				}
			}
			int iCityValue = pkEventChoiceInfo->getCityYield(eIndex);
			if(pkEventChoiceInfo->IsEraScaling())
			{
				iCityValue *= iEra;
			}
			if(iCityValue != 0)
			{
				if(yieldCityTip != "")
				{
					yieldCityTip += ", ";
				}
				Localization::String localizedCityText;
				if(bYieldsOnly)
				{
					localizedCityText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_CITY");
				}
				else
				{
					localizedCityText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED");
				}
				localizedCityText << pYield->GetDescription();
				localizedCityText << pYield->getIconString();
				localizedCityText << iCityValue;

				const char* const localized = localizedCityText.toUTF8();
				if(localized)
				{
					yieldCityTip += localized;
				}
			}
		}
	}
	localizedCoreText << yieldCostTip;
	localizedCoreText << yieldInstantTip;
	localizedCoreText << yieldCityTip;

	//Duration
	int iDuration = pkEventChoiceInfo->getEventDuration();
	if(iDuration > 0)
	{
		iDuration *= GC.getGame().getGameSpeedInfo().getTrainPercent();
		iDuration /= 100;
		Localization::String localizedDurationText;
		if(bYieldsOnly)
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_TURNS");
		}
		else
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_YIELD_DURATION");
		}
		localizedDurationText << iDuration;
		const char* const localized = localizedDurationText.toUTF8();
		if(localized)
		{
			turnsTip += localized;
		}
	}
	localizedCoreText << turnsTip;

	const char* const finallocalized = localizedCoreText.toUTF8();
	if(finallocalized)
	{
		CoreYieldTip = finallocalized;
	}
	return CoreYieldTip.c_str();
}
CvString CvPlayer::GetDisabledTooltip(EventChoiceTypes eChosenEventChoice)
{
	CvString DisabledTT = Localization::Lookup("TXT_KEY_EVENT_DISABLED_REASONS_HEADER").toUTF8();
	Localization::String localizedDurationText;

	if(eChosenEventChoice == NO_EVENT_CHOICE)
		return "";

	CvModEventChoiceInfo* pkEventInfo = GC.getEventChoiceInfo(eChosenEventChoice);
	if(pkEventInfo == NULL)
	{
		return "";
	}

	CvString strOverrideText = GetLocalizedText(pkEventInfo->getDisabledTooltip());
	if(strOverrideText != "")
	{
		return strOverrideText.c_str();
	}

	//Lua Hook
	if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_EventChoiceCanTake, GetID(), eChosenEventChoice) == GAMEEVENTRETURN_FALSE) 
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_DISABLED_LUA");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->isOneShot() && IsEventChoiceFired(eChosenEventChoice))
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_ONESHOT");
		DisabledTT += localizedDurationText.toUTF8();
	}

	//Event Choice already active for this event? Abort!
	if(GetEventChoiceDuration(eChosenEventChoice) > 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_ACTIVE");
		DisabledTT += localizedDurationText.toUTF8();
	}

	//Let's narrow down all events here!
	if(pkEventInfo->getPrereqTech() != -1 && !GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_TECH");
		localizedDurationText << GC.getTechInfo((TechTypes)pkEventInfo->getPrereqTech())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->getObsoleteTech() != -1 && GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getObsoleteTech()))
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_OBSOLETE_TECH");
		localizedDurationText << GC.getTechInfo((TechTypes)pkEventInfo->getObsoleteTech())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->getRequiredEra() != -1 && GetCurrentEra() < (EraTypes)pkEventInfo->getRequiredEra())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ERA");
		localizedDurationText << GC.getEraInfo((EraTypes)pkEventInfo->getRequiredEra())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->getObsoleteEra() != -1 && GetCurrentEra() >= (EraTypes)pkEventInfo->getObsoleteEra())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_OBSOLETE_ERA");
		localizedDurationText << GC.getEraInfo((EraTypes)pkEventInfo->getObsoleteEra())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->getMinimumNationalPopulation() > 0 && getTotalPopulation() < pkEventInfo->getMinimumNationalPopulation())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_POP_NATIONAL");
		localizedDurationText << pkEventInfo->getMinimumNationalPopulation();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->getMinimumNumberCities() > 0 && getNumCities() < pkEventInfo->getMinimumNumberCities())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_CITIES");
		localizedDurationText << pkEventInfo->getMinimumNumberCities();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->getRequiredCiv() != -1 && getCivilizationType() != (CivilizationTypes)pkEventInfo->getRequiredCiv())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_CIV");
		localizedDurationText << GC.getCivilizationInfo((CivilizationTypes)pkEventInfo->getRequiredCiv())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->getRequiredPolicy() != -1 && !GetPlayerPolicies()->HasPolicy((PolicyTypes)pkEventInfo->getRequiredPolicy()))
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_POLICY");
		localizedDurationText << GC.getPolicyInfo((PolicyTypes)pkEventInfo->getRequiredPolicy())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->getRequiredIdeology() != -1 && GetPlayerPolicies()->GetLateGamePolicyTree() != (PolicyBranchTypes)pkEventInfo->getRequiredIdeology())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_IDEOLOGY");
		localizedDurationText << GC.getPolicyBranchInfo((PolicyBranchTypes)pkEventInfo->getRequiredIdeology())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->hasStateReligion() && GetReligions()->GetStateReligion() == NO_RELIGION)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ANY_STATE_RELIGION");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->hasPantheon() && GetReligions()->GetReligionCreatedByPlayer(true) != RELIGION_PANTHEON)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ANY_PANTHEON");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->isUnhappy() && !IsEmpireUnhappy())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_UNHAPPY");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->isSuperUnhappy() && !IsEmpireSuperUnhappy())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_SUPER_UNHAPPY");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->isRequiresIdeology() && GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ANY_IDEOLOGY");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->isRequiresWar() && GetMilitaryAI()->GetNumberCivsAtWarWith(false) <= 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_WAR_MAJOR");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->getRequiredStateReligion() != -1)
	{
		if(GetReligions()->GetStateReligion() != pkEventInfo->getRequiredStateReligion())
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_SPECIFIC_STATE_RELIGION");
			localizedDurationText << GC.getReligionInfo((ReligionTypes)pkEventInfo->getRequiredStateReligion())->GetDescription();
			DisabledTT += localizedDurationText.toUTF8();
		}
	}

	if(!pkEventInfo->isRequiresHolyCity() && pkEventInfo->getRequiredReligion() != -1)
	{
		if((GetReligions()->GetCurrentReligion(false) != (ReligionTypes)pkEventInfo->getRequiredReligion()) && (GetReligions()->GetReligionInMostCities() != (ReligionTypes)pkEventInfo->getRequiredReligion()))
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_SPECIFIC_RELIGION");
			localizedDurationText << GC.getReligionInfo((ReligionTypes)pkEventInfo->getRequiredReligion())->GetDescription();
			DisabledTT += localizedDurationText.toUTF8();
		}
	}

	//Let's do our linker checks here.
	for(int iI = 0; iI <= pkEventInfo->GetNumLinkers(); iI++)
	{
		CvEventChoiceLinkingInfo *pLinkerInfo = pkEventInfo->GetLinkerInfo(iI);
		if(pLinkerInfo)
		{
			EventTypes eLinkerEvent = (EventTypes)pLinkerInfo->GetLinkingEvent();
			EventChoiceTypes eLinkerEventChoice = (EventChoiceTypes)pLinkerInfo->GetLinkingEventChoice();
			CityEventTypes eLinkerCityEvent = (CityEventTypes)pLinkerInfo->GetCityLinkingEvent();
			CityEventChoiceTypes eLinkerCityEventChoice = (CityEventChoiceTypes)pLinkerInfo->GetCityLinkingEventChoice();

			PlayerTypes ePlayer;

			bool bEventFound = false;
			bool bEventChoiceFound = false;
			bool bCityEventFound = false;
			bool bCityEventChoiceFound = false;
			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				ePlayer = (PlayerTypes) iPlayerLoop;
				if(ePlayer == NO_PLAYER)
					continue;

				if(!pLinkerInfo->CheckOtherPlayers() && ePlayer != GetID())
					continue;

				if(eLinkerEvent != NO_EVENT && !bEventFound)
				{
					bool bActive = (GetEventCooldown(eLinkerEvent) > 0 || IsEventFired(eLinkerEvent));
					if(bActive != pLinkerInfo->CheckForActive())
					{
						if(bActive)
						{
							if(pLinkerInfo->CheckOtherPlayers())
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_EVENT_ACTIVE");
							}
							else
							{	
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ACTIVE_EVENT");
							}
						}
						else
						{
							if(pLinkerInfo->CheckOtherPlayers())
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_EVENT_NO_ACTIVE");
							}
							else
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NO_ACTIVE_PLAYER_EVENT");
								
							}
						}
						localizedDurationText << GC.getEventInfo(eLinkerEvent)->GetDescription();
						DisabledTT += localizedDurationText.toUTF8();
						bEventFound = true;
					}
				}

				if(eLinkerEventChoice != NO_EVENT_CHOICE && !bEventChoiceFound)
				{
					bool bActive = (GetEventChoiceDuration(eLinkerEventChoice) > 0 || IsEventChoiceFired(eLinkerEventChoice));
					if(bActive != pLinkerInfo->CheckForActive())
					{
						if(bActive)
						{
							if(pLinkerInfo->CheckOtherPlayers())
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_EVENT_CHOICE_ACTIVE");

							}
							else
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ACTIVE_EVENT_CHOICE");
							}
						}
						else
						{
							if(pLinkerInfo->CheckOtherPlayers())
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_NO_EVENT_CHOICE_ACTIVE");
							}
							else
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NO_ACTIVE_PLAYER_EVENT_CHOICE");
							}
						}
						localizedDurationText << GC.getEventChoiceInfo(eLinkerEventChoice)->GetDescription();
						DisabledTT += localizedDurationText.toUTF8();
						bEventChoiceFound = true;
						break;
					}
				}

				if(eLinkerCityEvent != NO_EVENT_CITY || eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
				{
					int iLoop;
					CvCity* pLoopCity;
					for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))
					{
						if(eLinkerCityEvent != NO_EVENT_CITY && !bCityEventFound)
						{
							bool bActive = (pLoopCity->GetEventCooldown(eLinkerCityEvent) > 0 || pLoopCity->IsEventFired(eLinkerCityEvent));
							if(bActive != pLinkerInfo->CheckForActive())
							{
								if(bActive)
								{
									if(pLinkerInfo->CheckOtherPlayers())
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_CITY_EVENT_ACTIVE");
									}
									else
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ACTIVE_CITY_EVENT");
									}
								}
								else
								{
									if(pLinkerInfo->CheckOtherPlayers())
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_NO_CITY_EVENT_ACTIVE");
									}
									else
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NO_ACTIVE_CITY_EVENT");
									}
								}
								localizedDurationText << GC.getCityEventInfo(eLinkerCityEvent)->GetDescription();
								DisabledTT += localizedDurationText.toUTF8();
								bCityEventFound = true;
								break;
							}
						}

						if(!bCityEventChoiceFound && eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
						{
							bool bActive = (pLoopCity->GetEventChoiceDuration(eLinkerCityEventChoice) > 0 || pLoopCity->IsEventChoiceFired(eLinkerCityEventChoice));
							if(bActive != pLinkerInfo->CheckForActive())
							{
								if(bActive)
								{
									if(pLinkerInfo->CheckOtherPlayers())
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_CITY_EVENT_CHOICE_ACTIVE");
									}
									else
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ACTIVE_CITY_EVENT_CHOICE");
									}
								}
								else
								{
									if(pLinkerInfo->CheckOtherPlayers())
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_CITY_EVENT_CHOICE_NO_ACTIVE");
									}
									else
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NO_ACTIVE_CITY_EVENT_CHOICE");
									}
								}
								localizedDurationText << GC.getCityEventChoiceInfo(eLinkerCityEventChoice)->GetDescription();
								DisabledTT += localizedDurationText.toUTF8();
								bCityEventChoiceFound = true;
								break;
							}
						}
					}
				}
			}
		}
	}

	if(pkEventInfo->hasMetAnotherCiv())
	{
		if(GET_TEAM(getTeam()).getHasMetCivCount(true) <= 0)
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_MET_OTHER_CIV");
			DisabledTT += localizedDurationText.toUTF8();
		}
	}

	if(MOD_DIPLOMACY_CIV4_FEATURES && pkEventInfo->isMaster() && GET_TEAM(getTeam()).GetNumVassals() <= 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_VASSAL");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(MOD_DIPLOMACY_CIV4_FEATURES && pkEventInfo->isVassal() && !GET_TEAM(getTeam()).IsVassalOfSomeone())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_BE_VASSAL");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->isTradeCapped() && GetTrade()->GetNumTradeUnitsRemaining(true) <= 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_TRADE_SLOT");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->getUnitTypeRequired() != -1)
	{
		bool bHas = false;
		CvUnit* pLoopUnit;
		int iLoop;
		for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		{
			if(pLoopUnit != NULL && pLoopUnit->getUnitClassType() == (UnitClassTypes)pkEventInfo->getUnitTypeRequired())
			{
				bHas = true;
				break;
			}
		}
		if(!bHas)
		{
			CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());

			if (pCivilizationInfo != NULL)
			{
				UnitTypes eUnitType = (UnitTypes)pCivilizationInfo->getCivilizationUnits((UnitClassTypes)pkEventInfo->getUnitTypeRequired());
				if (eUnitType != NO_UNIT)
				{
					localizedDurationText = Localization::Lookup("TXT_KEY_NEED_UNITCLASS_TYPE");
					localizedDurationText << GC.getUnitInfo(eUnitType)->GetDescription();
					DisabledTT += localizedDurationText.toUTF8();
				}
			}
		}
	}


	if(pkEventInfo->isRequiresHolyCity())
	{
		bool bHas = false;
		bool bSpecific = false;
		CvCity* pCity = NULL;
		int iLoop;
		for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
		{
			if(pkEventInfo->getRequiredReligion() != -1)
			{
				if(pCity != NULL && pCity->GetCityReligions()->IsHolyCityForReligion((ReligionTypes)pkEventInfo->getRequiredReligion()))
				{
					bHas = true;
					bSpecific = true;
					break;
				}
			}
			else
			{
				if(pCity != NULL && pCity->GetCityReligions()->IsHolyCityAnyReligion())
				{
					bHas = true;
					break;
				}
			}
		}
		if(!bHas && !bSpecific)
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_HOLY_CITY");
			DisabledTT += localizedDurationText.toUTF8();
		}
		if(!bHas && bSpecific)
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_HOLY_CITY_SPECIFIC");
			DisabledTT += localizedDurationText.toUTF8();
		}
	}
	if(pkEventInfo->getNumCoastalRequired() > 0)
	{
		bool bHas = false;
		CvCity* pCity = NULL;
		int iLoop;
		int iNumCoastal = 0;
		for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
		{
			if(pCity != NULL && pCity->isCoastal())
			{
				iNumCoastal++;
			}
			if(iNumCoastal >= pkEventInfo->getNumCoastalRequired())
			{
				bHas = true;
				break;
			}
		}
		if(!bHas)
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_COASTAL_CITIES");
			localizedDurationText << pkEventInfo->getNumCoastalRequired();
			DisabledTT += localizedDurationText.toUTF8();
		}
	}

	if(pkEventInfo->isRequiresWarMinor())
	{
		bool bHas = false;
		for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

			// Is this a player we have relations with?
			if(GET_PLAYER(eLoopPlayer).isBarbarian())
			{
				continue;
			}
			if(!GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				continue;
			}
			if(eLoopPlayer != GetID())
			{
				if(GET_TEAM(getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
				{
					bHas = true;
					break;
				}
			}
		}
		if(!bHas)
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_WAR_MINOR");
			DisabledTT += localizedDurationText.toUTF8();
		}
	}
	for(int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
	{
		const ResourceTypes eResource = static_cast<ResourceTypes>(iJ);
		CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
		if(pkResource)
		{
			if(pkEventInfo->getResourceRequired(eResource) > 0)
			{
				if(getNumResourceTotal(eResource, false) < pkEventInfo->getResourceRequired(eResource))
				{
					localizedDurationText = Localization::Lookup("TXT_KEY_NEED_RESOURCE");
					localizedDurationText << pkResource->GetDescription();
					DisabledTT += localizedDurationText.toUTF8();
				}
			}
		}
	}
	bool bHas = true;
	for(int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
	{
		const FeatureTypes eFeature = static_cast<FeatureTypes>(iJ);
		CvFeatureInfo* pkFeature = GC.getFeatureInfo(eFeature);
		if(pkFeature)
		{
			if(pkEventInfo->getFeatureRequired(eFeature) > 0)
			{
				CvCity* pCity = NULL;
				int iLoop;
				int iNeeded = pkEventInfo->getFeatureRequired(eFeature);
				int iHave = 0;
				for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
				{

					if(pCity != NULL && pCity->HasFeature(eFeature))
					{
						iHave++;
					}
				}
				if(iHave < iNeeded)
				{
					localizedDurationText = Localization::Lookup("TXT_KEY_NEED_FEATURE");
					localizedDurationText << pkFeature->GetDescription();
					DisabledTT += localizedDurationText.toUTF8();
				}
			}
		}
	}
	if(pkEventInfo->getBuildingRequired() != -1)
	{
		BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventInfo->getBuildingRequired();
		if(eBuildingClass != NO_BUILDINGCLASS)
		{
			bool bHas = false;
			CvCity* pCity = NULL;
			int iLoop;
			for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
			{
				if(pCity != NULL && pCity->GetCityBuildings()->GetNumBuildingClass(eBuildingClass) > 0)
				{
					bHas = true;
					break;
				}
			}
			if(!bHas)
			{
				CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());

				if (pCivilizationInfo != NULL)
				{
					BuildingTypes eBuildingType = (BuildingTypes)pCivilizationInfo->getCivilizationBuildings((BuildingClassTypes)pkEventInfo->getBuildingRequired());
					if (eBuildingType != NO_BUILDING)
					{
						localizedDurationText = Localization::Lookup("TXT_KEY_NEED_BUILDING_CLASS");
						localizedDurationText << GC.getBuildingInfo(eBuildingType)->GetDescription();
						DisabledTT += localizedDurationText.toUTF8();
					}
				}
			}
		}
	}
	if(pkEventInfo->getBuildingLimiter() != -1)
	{
		BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventInfo->getBuildingLimiter();
		if(eBuildingClass != NO_BUILDINGCLASS)
		{
			bool bHas = false;
			CvCity* pCity = NULL;
			int iLoop;
			for(pCity = firstCity(&iLoop); pCity != NULL; pCity = nextCity(&iLoop))
			{
				if(pCity != NULL && pCity->GetCityBuildings()->GetNumBuildingClass(eBuildingClass) > 0)
				{
					bHas = true;
					break;
				}
			}
			if(bHas)
			{
				CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());

				if (pCivilizationInfo != NULL)
				{
					BuildingTypes eBuildingType = (BuildingTypes)pCivilizationInfo->getCivilizationBuildings((BuildingClassTypes)pkEventInfo->getBuildingLimiter());
					if (eBuildingType != NO_BUILDING)
					{
						localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NO_BUILDING_CLASS");
						localizedDurationText << GC.getBuildingInfo(eBuildingType)->GetDescription();
						DisabledTT += localizedDurationText.toUTF8();
					}
				}
			}
		}
	}
	if(pkEventInfo->getRequiredImprovement() != -1)
	{
		ImprovementTypes eImprovement = (ImprovementTypes)pkEventInfo->getRequiredImprovement();
		if(eImprovement != NO_IMPROVEMENT)
		{
			bool bHas = false;
			// go through all the plots the player has under their control
			for (PlotIndexContainer::const_iterator it = m_aiPlots.begin(); it != m_aiPlots.end(); ++it)
			{
				CvPlot* pPlot = GC.getMap().plotByIndex(*it);
				if (!pPlot)
				{
					continue;
				}

				if(pPlot->getOwner() == GetID() && pPlot->getImprovementType() == eImprovement)
				{
					bHas = true;
					break;
				}
			}
			if(!bHas)
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_NEED_IMPROVEMENT");
				localizedDurationText << GC.getImprovementInfo((ImprovementTypes)pkEventInfo->getRequiredImprovement())->GetDescription();
				DisabledTT += localizedDurationText.toUTF8();
			}
		}
	}
	//Check our minimum yields - this looks at stored values, not yields per turn.
	bHas = true;
	for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes)iI;
		if(eYield == NO_YIELD)
			continue;
							
		int iNeededYield = pkEventInfo->getYieldMinimum(eYield);
		if(pkEventInfo->getPreCheckEventYield(eYield) != 0)
		{
			if(iNeededYield < pkEventInfo->getPreCheckEventYield(eYield))
			{
				iNeededYield = pkEventInfo->getPreCheckEventYield(eYield);
			}
		}
		iNeededYield *= GC.getGame().getGameSpeedInfo().getTrainPercent();
		iNeededYield /= 100;
		if(pkEventInfo->IsEraScaling())
		{
			int iEra = GetCurrentEra();
			if(iEra <= 0)
			{
				iEra = 1;
			}
			iNeededYield *= iEra;
		}
		if(iNeededYield != 0)
		{
			if(eYield == YIELD_GOLD)
			{
				if(iNeededYield > GetTreasury()->GetGold())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_SCIENCE)
			{
				TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
				int iTech = 0;
				if(eCurrentTech != NO_TECH)
				{
					iTech = GetPlayerTechs()->GetResearchProgress(eCurrentTech);
				}
				if(iNeededYield > iTech)
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_FAITH)
			{
				if(iNeededYield > GetFaith())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_GOLDEN_AGE_POINTS)
			{
				if(iNeededYield > GetGoldenAgeProgressMeter())
				{
					bHas = false;
					break;
				}
			}
			else if(eYield == YIELD_CULTURE)
			{
				if(iNeededYield > getJONSCulture())
				{
					bHas = false;
					break;
				}
			}
		}
	}
	if(!bHas)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_YIELDS");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->isInDebt() && GetTreasury()->GetGold() > 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_DEBT");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if(pkEventInfo->isLosingMoney() && GetTreasury()->CalculateBaseNetGold() > 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NEGATIVE_GPT");
		DisabledTT += localizedDurationText.toUTF8();
	}

	return DisabledTT.c_str();
}
//Let's look for global events that affect a city being built/captured.
void CvPlayer::CheckActivePlayerEvents(CvCity* pCity)
{
	if(pCity == NULL)
		return;

	//Event Choice Duration First - if we're in one, let's do the countdown now.
	//We need to do this first so we can cancel the event(s).
	for(int iLoop = 0; iLoop < GC.getNumEventChoiceInfos(); iLoop++)
	{
		EventChoiceTypes eEventChoice = (EventChoiceTypes)iLoop;
		if(eEventChoice != NO_EVENT_CHOICE)
		{
			if(GetEventChoiceDuration(eEventChoice) > 0 || IsEventChoiceFired(eEventChoice))
			{
				DoEventSyncChoices(eEventChoice, pCity);
			}
		}
	}
}
//Let's grab all the global events that affect cities.
void CvPlayer::DoEventSyncChoices(EventChoiceTypes eEventChoice, CvCity* pCity)
{
	if(eEventChoice != NO_EVENT_CHOICE)
	{
		CvModEventChoiceInfo* pkEventChoiceInfo = GC.getEventChoiceInfo(eEventChoice);
		if(pkEventChoiceInfo != NULL)
		{
			if(pkEventChoiceInfo->getEventChance() <= 0)
			{
				if(pkEventChoiceInfo->getEventBuilding() != -1)
				{
					BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventChoiceInfo->getEventBuilding();
					if(eBuildingClass != NO_BUILDINGCLASS)
					{
						const CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
	
						if (pkBuildingClassInfo)
						{
							CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
		
							if (pCivilizationInfo != NULL)
							{
								BuildingTypes eBuildingType = (BuildingTypes) pCivilizationInfo->getCivilizationBuildings(eBuildingClass);
								if(eBuildingType != NO_BUILDING)
								{
									CvCity *pLoopCity;
									int iLoop;
									for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
									{
										if(pLoopCity != pCity)
											continue;

										if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
										{
											continue;
										}

										if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
										{
											continue;
										}

										pLoopCity->GetCityBuildings()->SetNumRealBuilding(eBuildingType, 1);
									}
								}
							}
						}
					}
				}
				for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
				{
					YieldTypes eYield = (YieldTypes)iI;
					if(eYield == NO_YIELD)
						continue;
					int iYieldChange = pkEventChoiceInfo->getCityYield(eYield);
					if(iYieldChange != 0)
					{
						if(pkEventChoiceInfo->IsEraScaling())
						{
							int iEra = GetCurrentEra();
							if(iEra <= 0)
							{
								iEra = 1;
							}
							iYieldChange *= iEra;
						}
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pLoopCity != pCity)
								continue;

							if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
							{
								continue;
							}
							if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
							{
								continue;
							}
							pLoopCity->ChangeEventCityYield(eYield, iYieldChange);
						}
					}
					// Building modifiers
					for(int iJ = 0; iJ < GC.getNumBuildingClassInfos(); iJ++)
					{
						BuildingClassTypes eBuildingClass = (BuildingClassTypes) iJ;

						CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
						if(!pkBuildingClassInfo)
						{
							continue;
						}
						if(pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield) != 0)
						{
							BuildingTypes eBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

							if(eBuilding != NO_BUILDING)
							{
								CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
								if(pkBuilding)
								{
									CvCity *pLoopCity;
									int iLoop;
									for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
									{
										if(pLoopCity != pCity)
											continue;

										if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
										{
											continue;
										}
										if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
										{
											continue;
										}
										int iBuildingCount = pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding);

										pLoopCity->ChangeEventBuildingClassYield(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield));
										if(iBuildingCount > 0)
										{
											pLoopCity->ChangeBaseYieldRateFromBuildings(eYield, pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield));
										}
									}
								}
							}
						}
						if(pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield) != 0)
						{
							BuildingTypes eBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

							if(eBuilding != NO_BUILDING)
							{
								CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
								if(pkBuilding)
								{
									CvCity *pLoopCity;
									int iLoop;
									for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
									{
										if(pLoopCity != pCity)
											continue;

										if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
										{
											continue;
										}
										if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
										{
											continue;
										}
										int iBuildingCount = pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding);

										pLoopCity->ChangeEventBuildingClassYieldModifier(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield));
										if(iBuildingCount > 0)
										{
											pLoopCity->changeYieldRateModifier(eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield));
										}
									}
								}
							}
						}
					}
					for(int iJ = 0; iJ < GC.getNumImprovementInfos(); iJ++)
					{
						ImprovementTypes eImprovement = (ImprovementTypes)iJ;
						if(eImprovement != NO_IMPROVEMENT && pkEventChoiceInfo->getImprovementYield(eImprovement, eYield) != 0)
						{
							CvCity *pLoopCity;
							int iLoop;
							for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								if(pLoopCity != pCity)
									continue;

								if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
								{
									continue;
								}
								if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
								{
									continue;
								}
								pLoopCity->ChangeEventImprovementYield(eImprovement, eYield, pkEventChoiceInfo->getImprovementYield(eImprovement, eYield));
							}
						}
					}
					for(int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
					{
						FeatureTypes eFeature = (FeatureTypes)iJ;
						if(eFeature != NO_FEATURE && pkEventChoiceInfo->getFeatureYield(eFeature, eYield) != 0)
						{
							CvCity *pLoopCity;
							int iLoop;
							for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								if(pLoopCity != pCity)
									continue;

								if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
								{
									continue;
								}
								if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
								{
									continue;
								}
								pLoopCity->ChangeEventFeatureYield(eFeature, eYield, pkEventChoiceInfo->getFeatureYield(eFeature, eYield));
							}
						}
					}
					for(int iJ = 0; iJ < GC.getNumTerrainInfos(); iJ++)
					{
						TerrainTypes eTerrain = (TerrainTypes)iJ;
						if(eTerrain != NO_TERRAIN && pkEventChoiceInfo->getTerrainYield(eTerrain, eYield) != 0)
						{
							CvCity *pLoopCity;
							int iLoop;
							for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								if(pLoopCity != pCity)
									continue;

								if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
								{
									continue;
								}
								if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
								{
									continue;
								}
								pLoopCity->ChangeEventTerrainYield(eTerrain, eYield, pkEventChoiceInfo->getTerrainYield(eTerrain, eYield));
							}
						}
					}
					for(int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
					{
						ResourceTypes eResource = (ResourceTypes)iJ;
						if(eResource != NO_RESOURCE && pkEventChoiceInfo->getResourceYield(eResource, eYield) != 0)
						{
							CvCity *pLoopCity;
							int iLoop;
							for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								if(pLoopCity != pCity)
									continue;

								if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
								{
									continue;
								}
								if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
								{
									continue;
								}
								pLoopCity->ChangeEventResourceYield(eResource, eYield, pkEventChoiceInfo->getResourceYield(eResource, eYield));
							}
						}
					}
					for(int iJ = 0; iJ < GC.getNumSpecialistInfos(); iJ++)
					{
						const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iJ);
						CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
						if(pkSpecialistInfo)
						{
							CvCity *pLoopCity;
							int iLoop;
							for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								if(pLoopCity != pCity)
									continue;

								if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
								{
									continue;
								}
								if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
								{
									continue;
								}
								pLoopCity->ChangeEventSpecialistYield(eSpecialist, eYield, pkEventChoiceInfo->getGlobalSpecialistYieldChange(eSpecialist, eYield));
							}
						}
					}
				}
				if(pkEventChoiceInfo->getCityHappinessGlobal() != 0)
				{
					CvCity *pLoopCity;
					int iLoop;
					for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if(pLoopCity != pCity)
							continue;

						if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
						{
							continue;
						}
						if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
						{
							continue;
						}
						pLoopCity->ChangeEventHappiness(pkEventChoiceInfo->getCityHappinessGlobal());
					}
				}
				CvCity* pLoopCity;
				int iLoop;
				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if(pLoopCity != NULL)
					{
						if(pLoopCity != pCity)
							continue;

						if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
						{
							continue;
						}
						if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
						{
							continue;
						}
						for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
						{
							YieldTypes eYield = (YieldTypes) iI;
							if(eYield == NO_YIELD)
								continue;

							pLoopCity->UpdateSpecialReligionYields(eYield);
							pLoopCity->UpdateCityYields(eYield);
						}
						pLoopCity->UpdateReligion(pLoopCity->GetCityReligions()->GetReligiousMajority());
						CalculateNetHappiness();
						pLoopCity->GetCityCulture()->CalculateBaseTourismBeforeModifiers();
						pLoopCity->GetCityCulture()->CalculateBaseTourism();
					}
				}
			}
		}
	}
}
void CvPlayer::DoEventChoice(EventChoiceTypes eEventChoice, EventTypes eEvent, bool bSendMsg)
{
	if (GC.getGame().isNetworkMultiPlayer() && bSendMsg && isHuman()) {
		NetMessageExt::Send::DoEventChoice(GetID(), eEventChoice, eEvent);
		return;
	}
	if(eEventChoice != NO_EVENT_CHOICE)
	{
		CvModEventChoiceInfo* pkEventChoiceInfo = GC.getEventChoiceInfo(eEventChoice);
		if(pkEventChoiceInfo != NULL)
		{
			//Set oneshot stuff so this event can't fire ever again.
			if(pkEventChoiceInfo->isOneShot())
			{
				SetEventChoiceFired(eEventChoice, true);
			}
			//Set false so we know we've completed the city event.
			//Loop through all city events and set any related to this to false, just to be sure.
			//This is purely for the notification system to keep the icon from disappearing until a choice has been made.
			if(eEvent == NO_EVENT)
			{
				for(int iLoop = 0; iLoop < GC.getNumEventInfos(); iLoop++)
				{
					EventTypes eEvent = (EventTypes)iLoop;
					if(eEvent != NO_EVENT)
					{
						if(pkEventChoiceInfo->isParentEvent(eEvent))
						{
							SetEventActive(eEvent, false);
						}
					}
				}
			}
			else
			{
				SetEventActive(eEvent, false);
			}
			//Lua Hook
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_EventChoiceActivated, GetID(), eEventChoice);

			if(GC.getLogging())
			{
				CvString playerName;
				FILogFile* pLog;
				CvString strBaseString;
				CvString strOutBuf;
				CvString strFileName = "EventLogging.csv";
				playerName = getCivilizationShortDescription();
				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				strBaseString += playerName + ", ";
				strOutBuf.Format("Event choice chosen by player: %s", pkEventChoiceInfo->GetDescription());
				strBaseString += strOutBuf;
				pLog->Msg(strBaseString);
			}
			//Set the cooldown for all events.
			if(pkEventChoiceInfo->getEventDuration() > 0)
			{
				//Gamespeed.
				int iEventDuration = pkEventChoiceInfo->getEventDuration();
				iEventDuration *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iEventDuration /= 100;
				ChangeEventChoiceDuration(eEventChoice, iEventDuration);
			}
			//Do the cost first, as that goes through whether or not the event succeeds!
			for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				YieldTypes eYield = (YieldTypes)iI;
				if(eYield == NO_YIELD)
					continue;
							
				int iPassYield = pkEventChoiceInfo->getPreCheckEventYield(eYield);
				if(iPassYield != 0)
				{
					iPassYield *= -1;
					CvCity* pCity = getCapitalCity();
					if(pCity != NULL)
					{
						doInstantYield(INSTANT_YIELD_TYPE_INSTANT, false, NO_GREATPERSON, NO_BUILDING, iPassYield, pkEventChoiceInfo->IsEraScaling(), NO_PLAYER, NULL, true, pCity, false, true, true, eYield);
					}
				}
			}
			//Let's see if it even happens.
			if(pkEventChoiceInfo->getEventChance() > 0)
			{
				int iRandom = GC.getGame().getJonRandNum(100, "Random Event Chance");
				int iLimit = pkEventChoiceInfo->getEventChance();
				if(iRandom < iLimit)
				{
					//Notify if it did not work.
					CvNotifications* pNotifications = GetNotifications();
					if(pNotifications && GC.getGame().getActivePlayer() == GetID())
					{
						for(int iLoop = 0; iLoop < GC.getNumCityEventInfos(); iLoop++)
						{
							EventTypes eEvent = (EventTypes)iLoop;
							if(eEvent != NO_EVENT)
							{
								if(pkEventChoiceInfo->isParentEvent(eEvent))
								{
									CvModEventInfo* pkEventInfo = GC.getEventInfo(eEvent);
									if(pkEventInfo != NULL)
									{
										Localization::String strMessage;
										Localization::String strSummary;
										strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_EVENT_FAILED");
										strMessage << pkEventChoiceInfo->GetDescription();
										strMessage << GetScaledHelpText(eEventChoice, false);
										strMessage << pkEventInfo->GetDescription();
										strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_EVENT_FAILED_T");
										strSummary << pkEventInfo->GetDescription();

										pNotifications->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, -1, GetID());
										break;
									}
								}
							}
						}
					}
					return;
				}
			}
			//Succeeded? Set event choice active here so we know to deduct it later.
			SetEventChoiceActive(eEventChoice, true);

			//Now on to the actions themselves.
			if (pkEventChoiceInfo->getEventPolicy() != -1)
			{
				PolicyTypes ePolicy = (PolicyTypes)pkEventChoiceInfo->getEventPolicy();
				if(ePolicy != -1)
				{
					setHasPolicy(ePolicy, true, true);
				}
			}
			if(pkEventChoiceInfo->getEventTech() != -1)
			{
				TechTypes eTech = (TechTypes)pkEventChoiceInfo->getEventTech();
				if(eTech != -1)
				{
					GET_TEAM(getTeam()).GetTeamTechs()->SetHasTech(eTech, true);
				}
			}
			if(pkEventChoiceInfo->getEventBuilding() != -1)
			{
				BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventChoiceInfo->getEventBuilding();
				if(eBuildingClass != NO_BUILDINGCLASS)
				{
					const CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
	
					if (pkBuildingClassInfo)
					{
						CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
		
						if (pCivilizationInfo != NULL)
						{
							BuildingTypes eBuildingType = (BuildingTypes) pCivilizationInfo->getCivilizationBuildings(eBuildingClass);
							if(eBuildingType != NO_BUILDING)
							{
								CvCity *pLoopCity;
								int iLoop;
								for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
								{
									if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
									{
										continue;
									}

									if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
									{
										continue;
									}

									pLoopCity->GetCityBuildings()->SetNumRealBuilding(eBuildingType, 1, true);
								}
							}
						}
					}
				}
			}
			if(pkEventChoiceInfo->getEventPromotion() != -1)
			{
				PromotionTypes ePromotion = (PromotionTypes)pkEventChoiceInfo->getEventPromotion();
				if(ePromotion != -1)
				{
					CvUnit* pLoopUnit;
					int iLoop;
					for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
					{
						if(pLoopUnit->getUnitType() != NO_UNIT)
						{
							if(::IsPromotionValidForUnitCombatType(ePromotion, pLoopUnit->getUnitType()))
							{
								if(pLoopUnit->HasPromotion(ePromotion))
								{
#if defined(MOD_UNITS_XP_TIMES_100)
									pLoopUnit->changeExperienceTimes100(15 * 100);
#else
									pLoopUnit->changeExperience(15);
#endif
								}
								else
								{
									pLoopUnit->setHasPromotion(ePromotion, true);
								}
							}
						}
					}
					ChangeFreePromotionCount(ePromotion, 1);
				}
			}
			for(int iI = 0; iI < GC.getNumResourceInfos(); iI++)
			{
				ResourceTypes eResource = (ResourceTypes)iI;
				if(eResource != NO_RESOURCE)
				{
					int iBonus = pkEventChoiceInfo->getEventResourceChange(eResource);
					if(iBonus != 0)
					{
						changeNumResourceTotal(eResource, iBonus);
					}
				}
			}
			for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				YieldTypes eYield = (YieldTypes)iI;
				if(eYield == NO_YIELD)
					continue;

				if(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS)
				{
					int iUnhappinessNeedMod = pkEventChoiceInfo->getCityUnhappinessNeedMod(eYield);
					if(iUnhappinessNeedMod != 0)
					{
						if(eYield == YIELD_GOLD)
						{
							ChangePovertyUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_CULTURE)
						{
							ChangeUnculturedUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_PRODUCTION)
						{
							ChangeDefenseUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_SCIENCE)
						{
							ChangeIlliteracyUnhappinessGlobal(iUnhappinessNeedMod);
						}
						else if(eYield == YIELD_FAITH)
						{
							ChangeMinorityUnhappinessGlobal(iUnhappinessNeedMod);
						}
					}
				}

				int iYieldChange = pkEventChoiceInfo->getCityYield(eYield);
				if(iYieldChange != 0)
				{
					if(pkEventChoiceInfo->IsEraScaling())
					{
						int iEra = GetCurrentEra();
						if(iEra <= 0)
						{
							iEra = 1;
						}
						iYieldChange *= iEra;
					}
					CvCity *pLoopCity;
					int iLoop;
					for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
						{
							continue;
						}
						if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
						{
							continue;
						}
						pLoopCity->ChangeEventCityYield(eYield, iYieldChange);
					}
				}
				// Building modifiers
				for(int iJ = 0; iJ < GC.getNumBuildingClassInfos(); iJ++)
				{
					BuildingClassTypes eBuildingClass = (BuildingClassTypes) iJ;

					CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
					if(!pkBuildingClassInfo)
					{
						continue;
					}
					if(pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield) != 0)
					{
						BuildingTypes eBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

						if(eBuilding != NO_BUILDING)
						{
							CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
							if(pkBuilding)
							{
								CvCity *pLoopCity;
								int iLoop;
								for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
								{
									if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
									{
										continue;
									}
									if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
									{
										continue;
									}
									int iBuildingCount = pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding);

									pLoopCity->ChangeEventBuildingClassYield(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield));
									if(iBuildingCount > 0)
									{
										pLoopCity->ChangeBaseYieldRateFromBuildings(eYield, pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield));
									}
								}
							}
						}
					}
					if(pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield) != 0)
					{
						BuildingTypes eBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

						if(eBuilding != NO_BUILDING)
						{
							CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
							if(pkBuilding)
							{
								CvCity *pLoopCity;
								int iLoop;
								for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
								{
									if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
									{
										continue;
									}
									if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
									{
										continue;
									}
									int iBuildingCount = pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding);

									pLoopCity->ChangeEventBuildingClassYieldModifier(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield));
									if(iBuildingCount > 0)
									{
										pLoopCity->changeYieldRateModifier(eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield));
									}
								}
							}
						}
					}
				}
							
				int iPassYield = pkEventChoiceInfo->getEventYield(eYield);
				if(iPassYield != 0)
				{
					CvCity *pLoopCity;
					int iLoop;
					for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if(!pkEventChoiceInfo->isInstantYieldAllCities() && !pLoopCity->isCapital())
							continue;

						doInstantYield(INSTANT_YIELD_TYPE_INSTANT, false, NO_GREATPERSON, NO_BUILDING, iPassYield, pkEventChoiceInfo->IsEraScaling(), NO_PLAYER, NULL, true, pLoopCity, false, true, true, eYield);
					}
				}
				for(int iJ = 0; iJ < GC.getNumImprovementInfos(); iJ++)
				{
					ImprovementTypes eImprovement = (ImprovementTypes)iJ;
					if(eImprovement != NO_IMPROVEMENT && pkEventChoiceInfo->getImprovementYield(eImprovement, eYield) != 0)
					{
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
							{
								continue;
							}
							if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
							{
								continue;
							}
							pLoopCity->ChangeEventImprovementYield(eImprovement, eYield, pkEventChoiceInfo->getImprovementYield(eImprovement, eYield));
						}
					}
				}
				for(int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
				{
					FeatureTypes eFeature = (FeatureTypes)iJ;
					if(eFeature != NO_FEATURE && pkEventChoiceInfo->getFeatureYield(eFeature, eYield) != 0)
					{
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
							{
								continue;
							}
							if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
							{
								continue;
							}
							pLoopCity->ChangeEventFeatureYield(eFeature, eYield, pkEventChoiceInfo->getFeatureYield(eFeature, eYield));
						}
					}
				}
				for(int iJ = 0; iJ < GC.getNumTerrainInfos(); iJ++)
				{
					TerrainTypes eTerrain = (TerrainTypes)iJ;
					if(eTerrain != NO_TERRAIN && pkEventChoiceInfo->getTerrainYield(eTerrain, eYield) != 0)
					{
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
							{
								continue;
							}
							if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
							{
								continue;
							}
							pLoopCity->ChangeEventTerrainYield(eTerrain, eYield, pkEventChoiceInfo->getTerrainYield(eTerrain, eYield));
						}
					}
				}
				for(int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
				{
					ResourceTypes eResource = (ResourceTypes)iJ;
					if(eResource != NO_RESOURCE && pkEventChoiceInfo->getResourceYield(eResource, eYield) != 0)
					{
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
							{
								continue;
							}
							if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
							{
								continue;
							}
							pLoopCity->ChangeEventResourceYield(eResource, eYield, pkEventChoiceInfo->getResourceYield(eResource, eYield));
						}
					}
				}
				for(int iJ = 0; iJ < GC.getNumSpecialistInfos(); iJ++)
				{
					const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iJ);
					CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
					if(pkSpecialistInfo)
					{
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
							{
								continue;
							}
							if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
							{
								continue;
							}
							pLoopCity->ChangeEventSpecialistYield(eSpecialist, eYield, pkEventChoiceInfo->getGlobalSpecialistYieldChange(eSpecialist, eYield));
						}
					}
				}
			}
			if(pkEventChoiceInfo->getGoldenAgeTurns() > 0)
			{
				int iTurns = pkEventChoiceInfo->getGoldenAgeTurns();
				iTurns *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iTurns /= 100;
				changeGoldenAgeTurns(max(1, iTurns), true);
			}
			if(pkEventChoiceInfo->getNumFreeGreatPeople() > 0)
			{
				ChangeNumFreeGreatPeople(pkEventChoiceInfo->getNumFreeGreatPeople());
			}
			if(pkEventChoiceInfo->getNumFreePolicies() > 0)
			{
				ChangeNumFreePolicies(pkEventChoiceInfo->getNumFreePolicies());
			}
			if(pkEventChoiceInfo->getNumFreeTechs() > 0)
			{
				SetNumFreeTechs(GetNumFreeTechs() + pkEventChoiceInfo->getNumFreeTechs());
			}
			if(pkEventChoiceInfo->getPlayerHappiness() != 0)
			{
				if(getCapitalCity() != NULL)
				{
					getCapitalCity()->ChangeEventHappiness(pkEventChoiceInfo->getPlayerHappiness());
				}
			}
			if(pkEventChoiceInfo->getCityHappinessGlobal() != 0)
			{
				CvCity *pLoopCity;
				int iLoop;
				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
					{
						continue;
					}
					if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
					{
						continue;
					}
					pLoopCity->ChangeEventHappiness(pkEventChoiceInfo->getCityHappinessGlobal());
				}
			}
			if(pkEventChoiceInfo->getRandomBarbs() > 0)
			{
				// In hundreds
				int iNumRebels = pkEventChoiceInfo->getRandomBarbs();

				CvCity *pLoopCity;
				int iLoop;
				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					// Found a place to set up an uprising?
					if(pLoopCity != NULL)
					{
						if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
						{
							continue;
						}
						if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
						{
							continue;
						}
						GC.getGame().DoSpawnUnitsAroundTargetCity(BARBARIAN_PLAYER, pLoopCity, iNumRebels, false, false, false, false);
					}
				}
			}
			if(pkEventChoiceInfo->getFreeScaledUnits() > 0)
			{
				// In hundreds
				int iNumRecruits = pkEventChoiceInfo->getFreeScaledUnits();

				CvCity *pLoopCity;
				int iLoop;
				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					// Found a place to set up an uprising?
					if(pLoopCity != NULL)
					{
						if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
						{
							continue;
						}
						if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
						{
							continue;
						}

						GC.getGame().DoSpawnUnitsAroundTargetCity(GetID(), pLoopCity, iNumRecruits, true, false, false, true);
					}
				}
			}
			for(int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
			{
				const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
				CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
				if(pkUnitClassInfo)
				{
					if(pkEventChoiceInfo->getNumFreeUnits((UnitClassTypes)iI) <= 0)
						continue;

					CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
		
					if (pCivilizationInfo != NULL)
					{
						const UnitTypes eLoopUnit = (UnitTypes) pCivilizationInfo->getCivilizationUnits(iI);
						if(eLoopUnit != NO_UNIT)
						{
							CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eLoopUnit);
							if(pkUnitEntry)
							{
								CvCity *pLoopCity;
								int iLoop;
								for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
								{
									if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
									{
										continue;
									}
									if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
									{
										continue;
									}
									for(int iJ = 0; iJ < pkEventChoiceInfo->getNumFreeUnits((UnitClassTypes)iI); iJ++)
									{
										UnitAITypes eUnitAI = pkUnitEntry->GetDefaultUnitAIType();
										int iResult = pLoopCity->CreateUnit(eLoopUnit, eUnitAI);

										CvAssertMsg(iResult != -1, "Unable to create unit");

										if (iResult != -1)
										{
											CvUnit* pUnit = getUnit(iResult);
											if (!pUnit->IsCivilianUnit() && !pUnit->jumpToNearestValidPlot())
											{
												pUnit->kill(false);	// Could not find a valid spot!
											}
											else
											{
												pUnit->finishMoves();
												//Lua Hook
												GAMEEVENTINVOKE_HOOK(GAMEEVENT_EventUnitCreated, GetID(), eEventChoice, pUnit);
											}
										}
									}
								}
							}
						}
					}
				}
			}
			for(int iI = 0; iI < GC.getNumUnitInfos(); iI++)
			{
				const UnitTypes eUnit = static_cast<UnitTypes>(iI);
				CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eUnit);
				if(pkUnitEntry)
				{
					if(pkEventChoiceInfo->getNumFreeSpecificUnits((UnitTypes)iI) <= 0)
						continue;
	
					for(int iJ = 0; iJ < pkEventChoiceInfo->getNumFreeSpecificUnits((UnitTypes)iI); iJ++)
					{
						UnitAITypes eUnitAI = pkUnitEntry->GetDefaultUnitAIType();
						CvCity *pLoopCity;
						int iLoop;
						for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
						{
							if(pLoopCity != NULL)
							{
								if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
								{
									continue;
								}
								if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
								{
									continue;
								}
								int iResult = pLoopCity->CreateUnit(eUnit, eUnitAI);

								CvAssertMsg(iResult != -1, "Unable to create unit");

								if (iResult != -1)
								{
									CvUnit* pUnit = getUnit(iResult);
									if (!pUnit->IsCivilianUnit() && !pUnit->jumpToNearestValidPlot())
									{
										pUnit->kill(false);	// Could not find a valid spot!
									}
									else
									{
										pUnit->finishMoves();
										//Lua Hook
										GAMEEVENTINVOKE_HOOK(GAMEEVENT_EventUnitCreated, GetID(), eEventChoice, pUnit);
									}
								}
							}
						}
					}
				}
			}
			for(int iI = 0; iI < GC.getNumReligionInfos(); iI++)
			{
				ReligionTypes eReligion = (ReligionTypes)iI;
				if(eReligion == NO_RELIGION)
					continue;

				int iPercent = (ReligionTypes)pkEventChoiceInfo->getEventConvertReligionPercent(iI);
				if(iPercent > 0)
				{
					CvCity *pLoopCity;
					int iLoop;
					for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
						{
							continue;
						}
						if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
						{
							continue;
						}
						pLoopCity->GetCityReligions()->ConvertPercentForcedFollowers(eReligion, iPercent);
					}
				}
				int iPop = (ReligionTypes)pkEventChoiceInfo->getEventConvertReligion(iI);
				if(iPop > 0)
				{
					CvCity *pLoopCity;
					int iLoop;
					for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
						{
							continue;
						}
						if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
						{
							continue;
						}
						pLoopCity->GetCityReligions()->ConvertNumberFollowers(eReligion, iPop);
					}
				}
			}
			if(pkEventChoiceInfo->getResistanceTurns() > 0)
			{
				int iTurns = pkEventChoiceInfo->getResistanceTurns();
				iTurns *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iTurns /= 100;
				CvCity *pLoopCity;
				int iLoop;
				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
					{
						continue;
					}
					if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
					{
						continue;
					}
					pLoopCity->ChangeResistanceTurns(max(1, iTurns));
				}
			}
			if(pkEventChoiceInfo->getWLTKD() > 0)
			{
				int iTurns = pkEventChoiceInfo->getWLTKD();
				iTurns *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iTurns /= 100;
				CvCity *pLoopCity;
				int iLoop;
				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
					{
						continue;
					}
					if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
					{
						continue;
					}
					pLoopCity->ChangeWeLoveTheKingDayCounter(max(1, iTurns));
				}
			}

			//Let's do our notification stuff here.
			for(int iI = 0; iI < pkEventChoiceInfo->GetNumNotifications(); iI++)
			{
				CvString strNotificationString = pkEventChoiceInfo->GetNotificationInfo(iI)->GetNotificationString();		
				if(strNotificationString != NULL && strNotificationString != "")
				{
					NotificationTypes eNotificationType = (NotificationTypes)FString::Hash(strNotificationString);
					
					if(eNotificationType != NO_NOTIFICATION_TYPE)
					{
						Localization::String strMessage;
						Localization::String strSummary;
						strSummary = Localization::Lookup(pkEventChoiceInfo->GetNotificationInfo(iI)->GetShortDescription());
						strSummary << getCivilizationShortDescriptionKey();
						strSummary << getCivilizationDescription();
						strSummary << getName();
						strMessage = Localization::Lookup(pkEventChoiceInfo->GetNotificationInfo(iI)->GetDescription());
						strMessage << getCivilizationShortDescriptionKey();
						strMessage << getCivilizationDescription();
						strMessage << getName();
						strMessage << GetScaledHelpText(eEventChoice, true);
						bool bGlobal = pkEventChoiceInfo->GetNotificationInfo(iI)->IsWorldEvent();
						for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
						{
							PlayerTypes ePlayer = (PlayerTypes) iPlayerLoop;
							if(ePlayer != NO_PLAYER && GET_PLAYER(ePlayer).isMajorCiv())
							{
								//Not global? Skip all but me.
								if(!bGlobal && ePlayer != GetID())
									continue;

								//Global? Seed only to known players.
								if(bGlobal && ePlayer != GetID() && !GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(getTeam()))
									continue;

								//Send out notifications!
								CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();
								if(pNotifications && GC.getGame().getActivePlayer() == ePlayer)
								{
									if(pkEventChoiceInfo->GetNotificationInfo(iI)->IsNeedPlayerID())
									{
										pNotifications->Add(eNotificationType, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, GetID(), pkEventChoiceInfo->GetNotificationInfo(iI)->GetVariable2());
									}
									else
									{
										pNotifications->Add(eNotificationType, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, pkEventChoiceInfo->GetNotificationInfo(iI)->GetVariable1(), pkEventChoiceInfo->GetNotificationInfo(iI)->GetVariable2());
									}
								}
							}
						}
					}
				}
			}
			CvCity* pLoopCity;
			int iLoop;
			for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				if(pLoopCity != NULL)
				{
					if(pkEventChoiceInfo->isCoastalOnly() && !pLoopCity->isCoastal())
					{
						continue;
					}
					if(pkEventChoiceInfo->isCapitalEffectOnly() && !pLoopCity->isCapital())
					{
						continue;
					}
					for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
					{
						YieldTypes eYield = (YieldTypes) iI;
						if(eYield == NO_YIELD)
							continue;

						pLoopCity->UpdateSpecialReligionYields(eYield);
						pLoopCity->UpdateCityYields(eYield);
					}
					pLoopCity->UpdateReligion(pLoopCity->GetCityReligions()->GetReligiousMajority());
					CalculateNetHappiness();
					pLoopCity->GetCityCulture()->CalculateBaseTourismBeforeModifiers();
					pLoopCity->GetCityCulture()->CalculateBaseTourism();
				}
			}
		}
	}
}
#endif
//	--------------------------------------------------------------------------------
/// This player liberates iOldCityID and gives it back to ePlayer
void CvPlayer::DoLiberatePlayer(PlayerTypes ePlayer, int iOldCityID, bool bForced)
{
	CvCity* pCity = getCity(iOldCityID);
	CvAssert(pCity);
	if (!pCity)
		return;

	PlayerTypes eOldOwner = pCity->getOwner();
	CvPlot* pPlot = pCity->plot();

#if defined(MOD_BALANCE_CORE)
	if(ePlayer == NO_PLAYER || GET_PLAYER(ePlayer).isBarbarian())
	{
		ePlayer = pCity->getOriginalOwner();
	}
	if(ePlayer == NO_PLAYER)
	{
		return;
	}
#endif

	// Set that this team has been liberated
	TeamTypes eTeam = getTeam();
	TeamTypes eLiberatedTeam = GET_PLAYER(ePlayer).getTeam();

	// Who originally took out this team?
	TeamTypes eConquerorTeam = GET_TEAM(eLiberatedTeam).GetKilledByTeam();

	if (!GET_PLAYER(ePlayer).isAlive())
	{
		GET_PLAYER(ePlayer).setBeingResurrected(true);
		if (!bForced)
		{
			GET_TEAM(eLiberatedTeam).SetLiberatedByTeam(eTeam);
		}

		// Put everyone at peace with this guy
		for (int iOtherTeamLoop = 0; iOtherTeamLoop < MAX_CIV_TEAMS; iOtherTeamLoop++)
		{
			if (eLiberatedTeam != iOtherTeamLoop)
			{
#if defined(MOD_EVENTS_WAR_AND_PEACE)
				GET_TEAM(eLiberatedTeam).makePeace((TeamTypes)iOtherTeamLoop, /*bBumpUnits*/false, /*bSuppressNotification*/true, GetID());
#else
				GET_TEAM(eLiberatedTeam).makePeace((TeamTypes) iOtherTeamLoop, /*bBumpUnits*/false, /*bSuppressNotification*/true);
#endif
			}
		}
	
		if (!GET_PLAYER(ePlayer).isMinorCiv())
		{
			// add notification
			Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_CIV_RESURRECTED");
			strMessage << getCivilizationShortDescriptionKey(); // LIBERATING CIV NAME
			strMessage << pCity->getNameKey(); // CITY NAME
			strMessage << GET_PLAYER(ePlayer).getCivilizationAdjectiveKey(); // LIBERATED CIV NAME
			strMessage << GET_PLAYER(ePlayer).getCivilizationDescriptionKey();// LIBERATED CIV NAME
			Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CIV_RESURRECTED_SHORT");
			if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(ePlayer).isHuman())
			{
				strSummary << GET_PLAYER(ePlayer).getNickName();
			}
			else
			{
				strSummary << GET_PLAYER(ePlayer).getNameKey();
			}
			if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(m_eID).isHuman())
			{
				strSummary << GET_PLAYER(m_eID).getNickName();
			}
			else
			{
				strSummary << GET_PLAYER(m_eID).getNameKey();
			}			

			for(int iI = 0; iI < MAX_PLAYERS; iI++)
			{
				const PlayerTypes eOtherPlayer = static_cast<PlayerTypes>(iI);
				CvPlayerAI& kOtherPlayer = GET_PLAYER(eOtherPlayer);
				if(kOtherPlayer.isAlive() && kOtherPlayer.GetNotifications() && iI != m_eID)
				{
					kOtherPlayer.GetNotifications()->Add(NOTIFICATION_RESURRECTED_MAJOR_CIV, strMessage.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), -1);
				}
			}

			CvString temp = strMessage.toUTF8();
			GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, m_eID, temp);
		}
	}
	else
	{
		if (!bForced)
		{
			GET_PLAYER(ePlayer).GetDiplomacyAI()->ChangeNumCitiesLiberated(m_eID, 1);
#if defined(MOD_BALANCE_CORE)
			GET_PLAYER(ePlayer).GetDiplomacyAI()->SetLiberatedCitiesTurn(m_eID, GC.getGame().getGameTurn());
#endif
		}
		if (!GET_PLAYER(ePlayer).isMinorCiv())
		{
			// add notification
			Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_LIBERATED");
			if(GC.getGame().isGameMultiPlayer() && isHuman())
			{
				strMessage << getNickName();
			}
			else
			{
				strMessage << getNameKey();
			}
			strMessage << pCity->getNameKey(); // CITY NAME
			strMessage << GET_PLAYER(ePlayer).getCivilizationShortDescriptionKey();// RESTORED CIV NAME
			Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CIV_LIBERATED_SHORT");
			strSummary << pCity->getNameKey();
			if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(ePlayer).isHuman())
			{
				strSummary << GET_PLAYER(ePlayer).getNickName();
			}
			else
			{
				strSummary << GET_PLAYER(ePlayer).getNameKey();
			}

			for(int iI = 0; iI < MAX_PLAYERS; iI++)
			{
				const PlayerTypes eOtherPlayer = static_cast<PlayerTypes>(iI);
				CvPlayerAI& kOtherPlayer = GET_PLAYER(eOtherPlayer);
				if(kOtherPlayer.isAlive() && kOtherPlayer.GetNotifications() && iI != m_eID)
				{
					kOtherPlayer.GetNotifications()->Add(NOTIFICATION_LIBERATED_MAJOR_CITY, strMessage.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), -1);
				}
			}
		}
	}

	// Give the city back to the liberated player
#if defined(MOD_API_EXTENSIONS)
	CvCity* pNewCity = GET_PLAYER(ePlayer).acquireCity(pCity, false, true);
#else
	GET_PLAYER(ePlayer).acquireCity(pCity, false, true);
#endif

	if (!GET_PLAYER(ePlayer).isMinorCiv())
	{
		// slewis - if the player we're liberating the city for is dead, give the liberating player a resurrection mark in the once-defeated player's book
		if (!GET_PLAYER(ePlayer).isAlive())
		{
			CvDiplomacyAI* pDiploAI = GET_PLAYER(ePlayer).GetDiplomacyAI();
			PlayerTypes eMePlayer = GetID();
			if (!bForced)
			{
				pDiploAI->SetResurrectedBy(eMePlayer, true);
			}
			pDiploAI->SetLandDisputeLevel(eMePlayer, DISPUTE_LEVEL_NONE);
			pDiploAI->SetWonderDisputeLevel(eMePlayer, DISPUTE_LEVEL_NONE);
			pDiploAI->SetMinorCivDisputeLevel(eMePlayer, DISPUTE_LEVEL_NONE);
			pDiploAI->SetWarmongerThreat(eMePlayer, THREAT_NONE);

			pDiploAI->SetPlayerNoSettleRequestCounter(eMePlayer, -1);
			pDiploAI->SetPlayerStopSpyingRequestCounter(eMePlayer, -1);
			pDiploAI->SetDemandCounter(eMePlayer, -1);
			pDiploAI->ChangeNumTimesCultureBombed(eMePlayer, -pDiploAI->GetNumTimesCultureBombed(eMePlayer));
			pDiploAI->ChangeNegativeReligiousConversionPoints(eMePlayer, -pDiploAI->GetNegativeReligiousConversionPoints(eMePlayer));
			pDiploAI->ChangeNegativeArchaeologyPoints(eMePlayer, -pDiploAI->GetNegativeArchaeologyPoints(eMePlayer));

			pDiploAI->ChangeNumTimesRobbedBy(eMePlayer, -pDiploAI->GetNumTimesRobbedBy(eMePlayer));
			pDiploAI->SetPlayerBrokenMilitaryPromise(eMePlayer, false);
			pDiploAI->SetPlayerIgnoredMilitaryPromise(eMePlayer, false);
			pDiploAI->SetBrokenBorderPromiseValue(eMePlayer, 0);
			pDiploAI->SetIgnoredBorderPromiseValue(eMePlayer, 0);
			pDiploAI->SetBrokenExpansionPromiseValue(eMePlayer, 0);
			pDiploAI->SetIgnoredExpansionPromiseValue(eMePlayer, 0);

			pDiploAI->SetPlayerBrokenAttackCityStatePromise(eMePlayer, false);
			pDiploAI->SetPlayerIgnoredAttackCityStatePromise(eMePlayer, false);
			pDiploAI->SetPlayerBrokenBullyCityStatePromise(eMePlayer, false);
			pDiploAI->SetPlayerIgnoredBullyCityStatePromise(eMePlayer, false);

			pDiploAI->SetPlayerBrokenNoConvertPromise(eMePlayer, false);
			pDiploAI->SetPlayerIgnoredNoConvertPromise(eMePlayer, false);

			pDiploAI->SetPlayerBrokenNoDiggingPromise(eMePlayer, false);
			pDiploAI->SetPlayerIgnoredNoDiggingPromise(eMePlayer, false);

			pDiploAI->SetPlayerBrokenSpyPromise(eMePlayer, false);
			pDiploAI->SetPlayerIgnoredSpyPromise(eMePlayer, false);

			pDiploAI->SetPlayerBrokenCoopWarPromise(eMePlayer, false);

			pDiploAI->SetOtherPlayerNumProtectedMinorsKilled(eMePlayer, 0);
			pDiploAI->SetOtherPlayerNumProtectedMinorsAttacked(eMePlayer, 0);
			pDiploAI->SetOtherPlayerNumProtectedMinorsBullied(eMePlayer, 0);
			pDiploAI->SetOtherPlayerTurnsSinceSidedWithProtectedMinor(eMePlayer, -1);

			pDiploAI->SetFriendDenouncedUs(eMePlayer, false);
			pDiploAI->SetDenouncedPlayer(eMePlayer, false); // forget any denouncing
			GetDiplomacyAI()->SetDenouncedPlayer(ePlayer, false); // forget any denouncing
			pDiploAI->SetFriendDeclaredWarOnUs(eMePlayer, false);

			pDiploAI->ChangeNumTimesNuked(eMePlayer, -pDiploAI->GetNumTimesNuked(eMePlayer));
		}
	}

	// Now verify the player is alive
	if (!GET_TEAM(getTeam()).isHasMet(GET_PLAYER(ePlayer).getTeam()))
	{
		GET_TEAM(getTeam()).makeHasMet(GET_PLAYER(ePlayer).getTeam(), true);
	}
	GET_PLAYER(ePlayer).verifyAlive();
	GET_PLAYER(ePlayer).setBeingResurrected(false);

	if (!bForced)
	{
		// Is this a Minor we have liberated?
#if defined(MOD_BALANCE_CORE)
		if (GET_PLAYER(ePlayer).isMinorCiv() && !GET_PLAYER(ePlayer).isBarbarian())
#else
		if(GET_PLAYER(ePlayer).isMinorCiv())
#endif
		{
			GET_PLAYER(ePlayer).GetMinorCivAI()->DoLiberationByMajor(eOldOwner, eConquerorTeam);
		}
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		else if (MOD_DIPLOMACY_CIV4_FEATURES && GET_PLAYER(ePlayer).isMajorCiv() && GET_TEAM(eLiberatedTeam).GetLiberatedByTeam() == getTeam())
		{
			if (!GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassal(getTeam()))
			{
				GET_TEAM(GET_PLAYER(ePlayer).getTeam()).SetNumTurnsIsVassal(-1);
				GET_TEAM(GET_PLAYER(ePlayer).getTeam()).SetNumTurnsSinceVassalEnded(getTeam(), -1);
				GET_TEAM(GET_PLAYER(ePlayer).getTeam()).DoBecomeVassal(getTeam(), true);
			}
		}
	}
#endif

	// slewis
	// negate warmonger
	if (!bForced)
	{
		for (int iMajorLoop = 0; iMajorLoop < MAX_MAJOR_CIVS; iMajorLoop++)
		{
			PlayerTypes eMajor = (PlayerTypes)iMajorLoop;
			if (GetID() != eMajor && GET_PLAYER(eMajor).isAlive())
			{
				// Have I met the player who conquered the city?
				if (GET_TEAM(GET_PLAYER(eMajor).getTeam()).isHasMet(getTeam()))
				{
#if defined(MOD_CONFIG_AI_IN_XML)
					int iWarmongerOffset = CvDiplomacyAIHelpers::GetPlayerCaresValue(GetID(), ePlayer, pNewCity->isCapital() ? true : false, pNewCity, GetID(), true);
					GET_PLAYER(eMajor).GetDiplomacyAI()->ChangeOtherPlayerWarmongerAmountTimes100(GetID(), -iWarmongerOffset);
#else
					int iNumCities = max(GET_PLAYER(ePlayer).getNumCities(), 1);
					int iWarmongerOffset = CvDiplomacyAIHelpers::GetWarmongerOffset(iNumCities, GET_PLAYER(ePlayer).isMinorCiv());
					GET_PLAYER(eMajor).GetDiplomacyAI()->ChangeOtherPlayerWarmongerAmount(GetID(), -iWarmongerOffset);
#endif
				}
			}
		}

		GetCulture()->SetWarWeariness(GetCulture()->GetWarWeariness() / 4);
	}

	// Move Units from player that don't belong here
	if(pPlot->getNumUnits() > 0)
	{
		// Get the current list of units because we will possibly be moving them out of the plot's list
		IDInfoVector currentUnits;
		if (pPlot->getUnits(&currentUnits) > 0)
		{
			for(IDInfoVector::const_iterator itr = currentUnits.begin(); itr != currentUnits.end(); ++itr)
			{
				CvUnit* pLoopUnit = (CvUnit*)GetPlayerUnit(*itr);

				if(pLoopUnit && pLoopUnit->getOwner() == eOldOwner)
				{
					pLoopUnit->finishMoves();
					if (!pLoopUnit->jumpToNearestValidPlot())
						pLoopUnit->kill(false);
				}
			}
		}
	}

#if defined(MOD_EVENTS_LIBERATION)
	if (MOD_EVENTS_LIBERATION) {
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerLiberated, GetID(), ePlayer, pNewCity->GetID());
	}
#endif

#if defined(MOD_DIPLOMACY_CITYSTATES)
	//Let's give the Embassies of the defeated player back to the liberated player
	if(MOD_DIPLOMACY_CITYSTATES && GET_PLAYER(ePlayer).GetImprovementLeagueVotes() > 0)
	{
		for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			ePlayer = (PlayerTypes) iPlayerLoop;
			if(ePlayer != NO_PLAYER && GET_PLAYER(ePlayer).getTeam() == eConquerorTeam)
			{
				int iEmbassyVotes = GET_PLAYER(ePlayer).GetImprovementLeagueVotes();
				GET_PLAYER(ePlayer).ChangeImprovementLeagueVotes(-iEmbassyVotes);
			}
		}
	}
#endif
}

//	--------------------------------------------------------------------------------
bool CvPlayer::CanLiberatePlayer(PlayerTypes ePlayer)
{
	// Other Player must be dead now
	if(GET_PLAYER(ePlayer).isAlive())
	{
		return false;
	}

	if(GET_PLAYER(ePlayer).IsEverConqueredBy(m_eID))
	{
		return false;
	}

	if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetKilledByTeam() == getTeam())
	{
		return false;
	}
	
#if defined(MOD_EVENTS_LIBERATION)
	if (MOD_EVENTS_LIBERATION) {
		if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_PlayerCanLiberate, GetID(), ePlayer) == GAMEEVENTRETURN_FALSE) {
			return false;
		}
	}
#endif

	return true;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::CanLiberatePlayerCity(PlayerTypes ePlayer)
{
	if (!GET_PLAYER(ePlayer).isAlive())
	{
		return CanLiberatePlayer(ePlayer);
	}

	return IsAtPeaceWith(ePlayer);
}

//	--------------------------------------------------------------------------------
#if defined(MOD_BALANCE_CORE_JFD)
CvUnit* CvPlayer::initUnit(UnitTypes eUnit, int iX, int iY, UnitAITypes eUnitAI, DirectionTypes eFacingDirection, bool bNoMove, bool bSetupGraphical, int iMapLayer /* = 0 */, int iNumGoodyHutsPopped, ContractTypes eContract, bool bHistoric)
#else
CvUnit* CvPlayer::initUnit(UnitTypes eUnit, int iX, int iY, UnitAITypes eUnitAI, DirectionTypes eFacingDirection, bool bNoMove, bool bSetupGraphical, int iMapLayer /* = 0 */, int iNumGoodyHutsPopped)
#endif
{
	CvAssertMsg(eUnit != NO_UNIT, "Unit is not assigned a valid value");
	if (eUnit == NO_UNIT)
		return NULL;

	CvUnitEntry* pkUnitDef = GC.getUnitInfo(eUnit);
	CvAssertFmt(pkUnitDef != NULL, "Trying to create unit of type %d, which does not exist", eUnit);
	if (pkUnitDef == NULL)
		return NULL;

	if (isMajorCiv() && pkUnitDef->IsMilitarySupport() && GetNumUnitsOutOfSupply() > 4)
	{
		OutputDebugString("Creating unit over supply limit\n");
	}

	CvUnit* pUnit = addUnit();
	CvAssertMsg(pUnit != NULL, "Unit is not assigned a valid value");
	if(NULL != pUnit)
	{
#if defined(MOD_BALANCE_CORE_JFD)
		pUnit->init(pUnit->GetID(), eUnit, ((eUnitAI == NO_UNITAI) ? pkUnitDef->GetDefaultUnitAIType() : eUnitAI), GetID(), iX, iY, eFacingDirection, bNoMove, bSetupGraphical, iMapLayer, iNumGoodyHutsPopped, eContract, bHistoric);
#else
		pUnit->init(pUnit->GetID(), eUnit, ((eUnitAI == NO_UNITAI) ? pkUnitDef->GetDefaultUnitAIType() : eUnitAI), GetID(), iX, iY, eFacingDirection, bNoMove, bSetupGraphical, iMapLayer, iNumGoodyHutsPopped);
#endif
#if !defined(NO_TUTORIALS)
		// slewis - added for the tutorial
		if(pUnit->getUnitInfo().GetWorkRate() > 0 && pUnit->getUnitInfo().GetDomainType() == DOMAIN_LAND)
		{
			m_bEverTrainedBuilder = true;
		}
		// end added for the tutorial
#endif
	}

	m_kPlayerAchievements.AddUnit(pUnit);
	return pUnit;
}
CvUnit* CvPlayer::initUnitWithNameOffset(UnitTypes eUnit, int nameOffset, int iX, int iY, UnitAITypes eUnitAI, DirectionTypes eFacingDirection, bool bNoMove, bool bSetupGraphical, int iMapLayer /* = 0 */, int iNumGoodyHutsPopped, ContractTypes eContract, bool bHistoric)
{
	CvAssertMsg(eUnit != NO_UNIT, "Unit is not assigned a valid value");
	if (eUnit == NO_UNIT)
		return NULL;

	CvUnitEntry* pkUnitDef = GC.getUnitInfo(eUnit);
	CvAssertFmt(pkUnitDef != NULL, "Trying to create unit of type %d, which does not exist", eUnit);
	if (pkUnitDef == NULL)
		return NULL;

	CvUnit* pUnit = addUnit();
	CvAssertMsg(pUnit != NULL, "Unit is not assigned a valid value");
	if(NULL != pUnit)
	{
		pUnit->initWithNameOffset(pUnit->GetID(), eUnit, nameOffset, ((eUnitAI == NO_UNITAI) ? pkUnitDef->GetDefaultUnitAIType() : eUnitAI), GetID(), iX, iY, eFacingDirection, bNoMove, bSetupGraphical, iMapLayer, iNumGoodyHutsPopped, eContract, bHistoric);

#if !defined(NO_TUTORIALS)
		// slewis - added for the tutorial
		if(pUnit->getUnitInfo().GetWorkRate() > 0 && pUnit->getUnitInfo().GetDomainType() == DOMAIN_LAND)
		{
			m_bEverTrainedBuilder = true;
		}
		// end added for the tutorial
#endif
	}

	m_kPlayerAchievements.AddUnit(pUnit);

	return pUnit;
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
CvUnit* CvPlayer::initNamedUnit(UnitTypes eUnit, const char* strKey, int iX, int iY, UnitAITypes eUnitAI, DirectionTypes eFacingDirection, bool bNoMove, bool bSetupGraphical, int iMapLayer /* = 0 */, int iNumGoodyHutsPopped)
{
	CvAssertMsg(eUnit != NO_UNIT, "Unit is not assigned a valid value");
	if (eUnit == NO_UNIT)
		return NULL;

	CvUnitEntry* pkUnitDef = GC.getUnitInfo(eUnit);
	CvAssertFmt(pkUnitDef != NULL, "Trying to create unit of type %d, which does not exist", eUnit);
	if (pkUnitDef == NULL)
		return NULL;

	if(strKey == NULL)
		return NULL;

	CvString strName = strKey;
	if(GC.getGame().isGreatPersonBorn(strName))
	{
		return NULL;
	}

	CvUnit* pUnit = addUnit();
	CvAssertMsg(pUnit != NULL, "Unit is not assigned a valid value");
	if (NULL != pUnit)
	{
		pUnit->initWithNameOffset(pUnit->GetID(), eUnit, -1, ((eUnitAI == NO_UNITAI) ? pkUnitDef->GetDefaultUnitAIType() : eUnitAI), GetID(), iX, iY, eFacingDirection, bNoMove, bSetupGraphical, iMapLayer, iNumGoodyHutsPopped, NO_CONTRACT, true, true);

#if !defined(NO_TUTORIALS)
		// slewis - added for the tutorial
		if (pUnit->getUnitInfo().GetWorkRate() > 0 && pUnit->getUnitInfo().GetDomainType() == DOMAIN_LAND)
		{
			m_bEverTrainedBuilder = true;
		}
		// end added for the tutorial
#endif

		pUnit->SetGreatWork(NO_GREAT_WORK);
#if !defined(MOD_GLOBAL_NO_LOST_GREATWORKS)
		int iUnitName = GC.getGame().getUnitCreatedCount(getUnitType());
		int iNumNames = pUnit->getUnitInfo().GetNumUnitNames();
		if (iUnitName < iNumNames)
#endif
		{
			if (strKey != NULL)
			{
				CvString strName = strKey;
				int iNumNames = pUnit->getUnitInfo().GetNumUnitNames();
				for (int iI = 0; iI < iNumNames; iI++)
				{
					CvString strOtherName = pUnit->getUnitInfo().GetUnitNames(iI);
					if (strOtherName == strName)
					{
						pUnit->setName(strName);
						pUnit->SetGreatWork(pUnit->getUnitInfo().GetGreatWorks(iI));
						GC.getGame().addGreatPersonBornName(strName);
#if defined(MOD_GLOBAL_NO_LOST_GREATWORKS)
						if (MOD_GLOBAL_NO_LOST_GREATWORKS)
						{
							// setName strips undesirable characters, but we stored those into the list of GPs born, so we need to keep the original name
							pUnit->setGreatName(strName);
						}
#endif
						break;
					}
				}
			}
		}
	}

	m_kPlayerAchievements.AddUnit(pUnit);

	return pUnit;
}
#endif
//	--------------------------------------------------------------------------------
void CvPlayer::disbandUnit(bool)
{
	CvUnit* pLoopUnit;
	CvUnit* pBestUnit;
	char szBuffer[1024];
	const size_t lenBuffer = 1024;
	int iValue;
	int iBestValue;
	int iLoop;

	iBestValue = INT_MAX;
	pBestUnit = NULL;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(!(pLoopUnit->hasCargo()))
		{
			if(!(pLoopUnit->isGoldenAge()))
			{
				if(pLoopUnit->getUnitInfo().GetProductionCost() > 0)
				{
					{
						iValue = (10000 + GC.getGame().getSmallFakeRandNum(1000, pLoopUnit->GetID() + iLoop));

						iValue += (pLoopUnit->getUnitInfo().GetProductionCost() * 5);

#if defined(MOD_UNITS_XP_TIMES_100)
						iValue += (pLoopUnit->getExperienceTimes100() / 100 * 20);
#else
						iValue += (pLoopUnit->getExperience() * 20);
#endif
						iValue += (pLoopUnit->getLevel() * 100);

						if(pLoopUnit->IsGarrisoned())
						{
							iValue *= 2;
						}

						if(pLoopUnit->plot()->getTeam() == pLoopUnit->getTeam())
						{
							iValue *= 3;
						}

						switch(pLoopUnit->AI_getUnitAIType())
						{
						case UNITAI_UNKNOWN:
							break;

						case UNITAI_SETTLE:
							iValue *= 20;
							break;

						case UNITAI_WORKER:
							iValue *= 10;
							break;

						case UNITAI_ATTACK:
						case UNITAI_CITY_BOMBARD:
						case UNITAI_FAST_ATTACK:
						case UNITAI_DEFENSE:
						case UNITAI_COUNTER:
							iValue *= 2;
							break;

						case UNITAI_RANGED:
						case UNITAI_CITY_SPECIAL:
						case UNITAI_PARADROP:
							iValue *= 6;
							break;

						case UNITAI_EXPLORE:
							iValue *= 15;
							break;

						case UNITAI_ARTIST:
						case UNITAI_SCIENTIST:
						case UNITAI_GENERAL:
						case UNITAI_MERCHANT:
#if defined(MOD_DIPLOMACY_CITYSTATES)
						case UNITAI_DIPLOMAT:
						case UNITAI_MESSENGER:
#endif
						case UNITAI_ENGINEER:
						case UNITAI_SPACESHIP_PART:
						case UNITAI_TREASURE:
						case UNITAI_PROPHET:
						case UNITAI_MISSIONARY:
						case UNITAI_INQUISITOR:
						case UNITAI_ADMIRAL:
						case UNITAI_WRITER:
						case UNITAI_MUSICIAN:
							break;

						case UNITAI_ICBM:
							iValue *= 4;
							break;

						case UNITAI_WORKER_SEA:
							iValue *= 18;
							break;

						case UNITAI_ATTACK_SEA:
						case UNITAI_RESERVE_SEA:
						case UNITAI_ESCORT_SEA:
							break;

						case UNITAI_EXPLORE_SEA:
							iValue *= 25;
							break;

						case UNITAI_ASSAULT_SEA:
						case UNITAI_SETTLER_SEA:
						case UNITAI_CARRIER_SEA:
						case UNITAI_MISSILE_CARRIER_SEA:
							iValue *= 5;
							break;

						case UNITAI_PIRATE_SEA:
						case UNITAI_ATTACK_AIR:
							break;

						case UNITAI_DEFENSE_AIR:
						case UNITAI_CARRIER_AIR:
						case UNITAI_MISSILE_AIR:
							iValue *= 3;
							break;

						default:
							CvAssert(false);
							break;
						}

						if(pLoopUnit->getUnitInfo().GetExtraMaintenanceCost() > 0)
						{
							iValue /= (pLoopUnit->getUnitInfo().GetExtraMaintenanceCost() + 1);
						}

						if(iValue < iBestValue)
						{
							iBestValue = iValue;
							pBestUnit = pLoopUnit;
						}
					}
				}
			}
		}
	}

	if(pBestUnit != NULL)
	{
		if(GetID() == GC.getGame().getActivePlayer())
		{
			sprintf_s(szBuffer, lenBuffer, GetLocalizedText("TXT_KEY_MISC_UNIT_DISBANDED_NO_MONEY", pBestUnit->getNameKey()).GetCString());
			GC.GetEngineUserInterface()->AddUnitMessage(0, pBestUnit->GetIDInfo(), GetID(), false, GC.getEVENT_MESSAGE_TIME(), szBuffer);//, "AS2D_UNITDISBANDED", MESSAGE_TYPE_MINOR_EVENT, pBestUnit->getUnitInfo().GetButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pBestUnit->getX(), pBestUnit->getY(), true, true);
		}

		CvAssert(!(pBestUnit->isGoldenAge()));

		pBestUnit->kill(false);
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::killUnits()
{
	//can't kill the units directly because that invalidates the iterator
	std::vector<int> unitsToKill;

	int iLoop;
	for(CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		unitsToKill.push_back(pLoopUnit->GetID());
	}

	//debugging ...
	for (std::vector<int>::iterator it = unitsToKill.begin(); it != unitsToKill.end(); ++it)
	{
		if (std::count(unitsToKill.begin(), unitsToKill.end(),*it)>1)
			OutputDebugString("inconsistent state: non-unique unit ID to kill!\n");
	}

	for (std::vector<int>::iterator it=unitsToKill.begin(); it!=unitsToKill.end(); ++it)
	{
		CvUnit* pLoopUnit = getUnit(*it);
		if (pLoopUnit)
			pLoopUnit->kill(false);
	}
}

#if defined(MOD_API_EXTENSIONS) || defined(MOD_BUGFIX_UNITCLASS_NOT_UNIT)
//	--------------------------------------------------------------------------------
// Given a unit class, get the players specific unit of that class
UnitTypes CvPlayer::GetSpecificUnitType(const char* szUnitClass, bool hideAssert)
{
	UnitTypes eUnitType = NO_UNIT;
	UnitClassTypes eUnitClassType = (UnitClassTypes) GC.getInfoTypeForString(szUnitClass, hideAssert);

	const CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClassType);
	
	if (pkUnitClassInfo)
	{
		CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
		
		if (pCivilizationInfo != NULL)
		{
			eUnitType = (UnitTypes) pCivilizationInfo->getCivilizationUnits(eUnitClassType);
		}
		else
		{
			eUnitType = (UnitTypes) pkUnitClassInfo->getDefaultUnitIndex();
		}
	}
	
	if (!isMinorCiv() && !isBarbarian()) {
		if (eUnitType == NO_UNIT) {
			CUSTOMLOG("GetSpecificUnitType for player %s: %s is UNKNOWN!!!", getName(), szUnitClass);
		} else {
			// CUSTOMLOG("GetSpecificUnitType for player %s: %s is %s", getName(), szUnitClass, GC.getUnitInfo(eUnitType)->GetType());
		}
	}

	return eUnitType;
}
#endif

#if defined(MOD_API_EXTENSIONS) || defined(MOD_BUGFIX_BUILDINGCLASS_NOT_BUILDING)
//	--------------------------------------------------------------------------------
// Given a building class, get the players specific building of that class
BuildingTypes CvPlayer::GetSpecificBuildingType(const char* szBuildingClass, bool hideAssert)
{
	BuildingTypes eBuildingType = NO_BUILDING;
	BuildingClassTypes eBuildingClassType = (BuildingClassTypes) GC.getInfoTypeForString(szBuildingClass, hideAssert);

	const CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClassType);
	
	if (pkBuildingClassInfo)
	{
		CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
		
		if (pCivilizationInfo != NULL)
		{
			eBuildingType = (BuildingTypes) pCivilizationInfo->getCivilizationBuildings(eBuildingClassType);
		}
		else
		{
			eBuildingType = (BuildingTypes) pkBuildingClassInfo->getDefaultBuildingIndex();
		}
	}
	
	if (!isMinorCiv() && !isBarbarian()) {
		if (eBuildingType == NO_BUILDING) {
			CUSTOMLOG("GetSpecificBuildingType for player %s: %s is UNKNOWN!!!", getName(), szBuildingClass);
		} else {
			// CUSTOMLOG("GetSpecificBuildingType for player %s: %s is %s", getName(), szBuildingClass, GC.getBuildingInfo(eBuildingType)->GetType());
		}
	}

	return eBuildingType;
}
#endif

//	--------------------------------------------------------------------------------
CvPlot *CvPlayer::GetGreatAdmiralSpawnPlot (CvUnit *pUnit)
{
	CvPlot *pInitialPlot = pUnit->plot();

	// Is this a friendly coastal city, if so we'll go with that
	CvCity *pInitialCity = pInitialPlot->getPlotCity();
	if (pInitialCity && pInitialCity->isCoastal())
	{
		// Equal okay checking this plot because this is where the unit is right now
#if defined(MOD_GLOBAL_STACKING_RULES)
		if (pInitialPlot->getMaxFriendlyUnitsOfType(pUnit) <= pInitialPlot->getUnitLimit())
#else
		if (pInitialPlot->getMaxFriendlyUnitsOfType(pUnit) <= GC.getPLOT_UNIT_LIMIT())
#endif
		{
			return pInitialPlot;
		}
	}

	// Otherwise let's look at all our other cities
	CvCity *pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (pLoopCity != pInitialCity)
		{
			if (pLoopCity->isCoastal())
			{
#if defined(MOD_GLOBAL_STACKING_RULES)
				if (pLoopCity->plot()->getMaxFriendlyUnitsOfType(pUnit) < pLoopCity->plot()->getUnitLimit())
#else
				if (pLoopCity->plot()->getMaxFriendlyUnitsOfType(pUnit) < GC.getPLOT_UNIT_LIMIT())
#endif
				{
					return pLoopCity->plot();
				}
			}
		}
	}

	// Don't have a coastal city, look for water plot THAT ISN'T A LAKE closest to our capital that isn't owned by an enemy
	int iCapitalX;
	int iCapitalY;
	CvCity *pCapital = getCapitalCity();
	if (pCapital)
	{
		iCapitalX = pCapital->getX();
		iCapitalY = pCapital->getY();

		CvPlot *pBestPlot = NULL;
		int iBestDistance = MAX_INT;

		for (int iI = 0; iI < GC.getMap().numPlots(); iI++)
		{
			CvPlot *pPlot = GC.getMap().plotByIndexUnchecked(iI);
			if (pPlot != NULL)
			{
				if (pPlot->isWater() && !pPlot->isLake())
				{
					if (pPlot->IsFriendlyTerritory(GetID()) || !pPlot->isOwned())
					{
#if defined(MOD_GLOBAL_STACKING_RULES)
						if (pPlot->getMaxFriendlyUnitsOfType(pUnit) < pPlot->getUnitLimit())
#else
						if (pPlot->getMaxFriendlyUnitsOfType(pUnit) < GC.getPLOT_UNIT_LIMIT())
#endif
						{
							int iDistance = plotDistance(iCapitalX, iCapitalY, pPlot->getX(), pPlot->getY());
							if (iDistance < iBestDistance)
							{
								pBestPlot = pPlot;
								iBestDistance = iDistance;
							}
						}
					}
				}
			}
		}

		if (pBestPlot)
		{
			return pBestPlot;
		}

		// Now we'll even accept a lake
		for (int iI = 0; iI < GC.getMap().numPlots(); iI++)
		{
			CvPlot *pPlot = GC.getMap().plotByIndexUnchecked(iI);
			if (pPlot != NULL)
			{
				if (pPlot->isWater())
				{
					if (pPlot->IsFriendlyTerritory(GetID()) || !pPlot->isOwned())
					{
#if defined(MOD_GLOBAL_STACKING_RULES)
						if (pPlot->getMaxFriendlyUnitsOfType(pUnit) < pPlot->getUnitLimit())
#else
						if (pPlot->getMaxFriendlyUnitsOfType(pUnit) < GC.getPLOT_UNIT_LIMIT())
#endif
						{
							int iDistance = plotDistance(iCapitalX, iCapitalY, pPlot->getX(), pPlot->getY());
							if (iDistance < iBestDistance)
							{
								pBestPlot = pPlot;
								iBestDistance = iDistance;
							}
						}
					}
				}
			}
		}
		if (pBestPlot)
		{
			return pBestPlot;
		}
	}

	CvAssertMsg (false, "Could not find valid plot for Great Admiral - placing on land");

	return pInitialPlot;
}


//	--------------------------------------------------------------------------------
/// The number of Builders a player has
int CvPlayer::GetNumBuilders() const
{
	return m_iNumBuilders;
}

//	--------------------------------------------------------------------------------
/// Sets the number of Builders a player has
void CvPlayer::SetNumBuilders(int iNum)
{
	if(GetNumBuilders() != iNum)
	{
		m_iNumBuilders = iNum;
	}
}

//	--------------------------------------------------------------------------------
/// Changes the number of Builders a player has
void CvPlayer::ChangeNumBuilders(int iChange)
{
	if(iChange != 0)
	{
		SetNumBuilders(GetNumBuilders() + iChange);
	}
}


//	--------------------------------------------------------------------------------
/// The maximum number of Builders a player can Train
int CvPlayer::GetMaxNumBuilders() const
{
	return m_iMaxNumBuilders;
}

//	--------------------------------------------------------------------------------
/// Sets the maximum number of Builders a player can Train
void CvPlayer::SetMaxNumBuilders(int iNum)
{
	if(GetMaxNumBuilders() != iNum)
	{
		m_iMaxNumBuilders = iNum;
	}
}

//	--------------------------------------------------------------------------------
/// Changes the maximum number of Builders a player can Train
void CvPlayer::ChangeMaxNumBuilders(int iChange)
{
	if(iChange != 0)
	{
		SetMaxNumBuilders(GetMaxNumBuilders() + iChange);
	}
}


//	--------------------------------------------------------------------------------
/// Returns number of Units a player has with a particular UnitAI.  The second argument allows you to check whether or not to include Units currently being trained in Cities.
int CvPlayer::GetNumUnitsWithUnitAI(UnitAITypes eUnitAIType, bool bIncludeBeingTrained, bool bIncludeWater)
{
	int iNumUnits = 0;

	CvUnit* pLoopUnit;
	CvCity* pLoopCity;
	int iLoop;

	// Current Units
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		// Don't include Water Units if we don't want them
		if(pLoopUnit->getDomainType() != DOMAIN_SEA || bIncludeWater)
		{
			if(pLoopUnit->AI_getUnitAIType() == eUnitAIType)
			{
				iNumUnits++;
			}
		}
	}

	// Units being trained now
	if(bIncludeBeingTrained)
	{
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity->isProductionUnit())
			{
				CvUnitEntry* pkUnitEntry = GC.getUnitInfo(pLoopCity->getProductionUnit());
				if(pkUnitEntry)
				{
					// Don't include Water Units if we don't want them
					if(pkUnitEntry->GetDomainType() != DOMAIN_SEA || bIncludeWater)
					{
						if(pkUnitEntry->GetDefaultUnitAIType() == eUnitAIType)
						{
							iNumUnits++;
						}
					}
				}
			}
		}
	}

	return iNumUnits;
}

//	--------------------------------------------------------------------------------
/// Returns number of Units a player has of a particular domain.  The second argument allows you to check whether or not to include civilians.
int CvPlayer::GetNumUnitsWithDomain(DomainTypes eDomain, bool bMilitaryOnly)
{
	int iNumUnits = 0;

	CvUnit* pLoopUnit;
	int iLoop;

	// Current Units
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->getDomainType() == eDomain)
		{
			if(!bMilitaryOnly || pLoopUnit->IsCombatUnit())
			{
				iNumUnits++;
			}
		}
	}

	return iNumUnits;
}

//	-----------------------------------------------------------------------------------------------
int CvPlayer::GetNumUnitsWithUnitCombat(UnitCombatTypes eUnitCombat)
{
	int iNumUnits = 0;

	CvUnit* pLoopUnit;
	int iLoop;

	// Current Units
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->getUnitCombatType() == eUnitCombat)
		{
			iNumUnits++;
		}
	}

	return iNumUnits;
}

//	-----------------------------------------------------------------------------------------------
void CvPlayer::UpdateDangerPlots(bool bKeepKnownUnits)
{
	m_pDangerPlots->UpdateDanger(bKeepKnownUnits);
}

//	-----------------------------------------------------------------------------------------------
void CvPlayer::SetDangerPlotsDirty()
{
	m_pDangerPlots->SetDirty();
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isHuman() const
{
	if(GetID() == NO_PLAYER)
	{
		return false;
	}

	return CvPreGame::isHuman(GetID());
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isObserver() const
{
	if(GetID() == NO_PLAYER)
	{
		return false;
	}

	return CvPreGame::slotStatus(GetID()) == SS_OBSERVER;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isBarbarian() const
{
	return (GetID() == BARBARIAN_PLAYER);
}

//	--------------------------------------------------------------------------------
void CvPlayer::doBarbarianRansom(int iOption, int iUnitID)
{
	CvUnit* pUnit = getUnit(iUnitID);

	// Pay the Price
	if(iOption == 0)
	{
		int iNumGoldStolen = GC.getBARBARIAN_UNIT_GOLD_RANSOM();	// 100

		if(iNumGoldStolen > GetTreasury()->GetGold())
		{
			iNumGoldStolen = GetTreasury()->GetGold();
		}

		// Unit is ransomed for Gold
		GetTreasury()->ChangeGold(-iNumGoldStolen);
	}
	// Leave them to the Barbs
	else if(iOption == 1)
	{
		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->AddUnitMessage(0, pUnit->GetIDInfo(), GetID(), true, GC.getEVENT_MESSAGE_TIME(), GetLocalizedText("TXT_KEY_MISC_YOU_UNIT_RANSOM_KILL_BY_BARBARIANS", pUnit->getNameKey()));//,GC.getEraInfo(GC.getGame().getCurrentEra())->getAudioUnitDefeatScript(), MESSAGE_TYPE_INFO, pUnit->getUnitInfo().GetButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pUnit->getX(), pUnit->getY(), true, true);
		}

		pUnit->kill(true, BARBARIAN_PLAYER);
	}
}

//	-----------------------------------------------------------------------------------------------
const char* CvPlayer::getName() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->GetDescription();
	}

	if(GC.getGame().isMPOption(MPOPTION_ANONYMOUS) && isAlive() && GC.getGame().getGameState() == GAMESTATE_ON)
	{
		return getLeaderInfo().GetDescription();
	}

	if(GC.getGame().isGameMultiPlayer() && isHuman())
	{
		const CvString& szDisplayName = CvPreGame::nicknameDisplayed(GetID());
		if(szDisplayName.GetLength())
			return szDisplayName.c_str();
	}
	
	const CvString& szPlayerName = CvPreGame::leaderName(GetID());
	if(szPlayerName.GetLength() == 0)
	{
		return getLeaderInfo().GetDescription();
	}

	return szPlayerName.c_str();
}

//	-----------------------------------------------------------------------------------------------
const char* CvPlayer::getNameKey() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->GetTextKey();
	}

	if(GC.getGame().isMPOption(MPOPTION_ANONYMOUS) && isAlive())
	{
		return getLeaderInfo().GetTextKey();
	}

	if(GC.getGame().isGameMultiPlayer() && isHuman())
	{
		// No, this won't be a 'key', but it should just pass through the lookup code and display as is.
		const CvString& szDisplayName = CvPreGame::nicknameDisplayed(GetID());
		if(szDisplayName.GetLength())
			return szDisplayName.c_str();
	}

	const CvString& szPlayerName = CvPreGame::leaderNameKey(GetID());
	if(szPlayerName.GetLength() == 0)
	{
		return getLeaderInfo().GetTextKey();
	}

	return szPlayerName.c_str();
}


//	--------------------------------------------------------------------------------
const char* CvPlayer::getCivilizationDescription() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->GetDescription();
	}
	else if(CvPreGame::civilizationDescription(GetID()).GetLength() == 0)
	{
		return GC.getCivilizationInfo(getCivilizationType()) ? getCivilizationInfo().GetDescription() : "unknown";
	}
	else
	{
		return CvPreGame::civilizationDescription(GetID()).c_str();
	}
}


//	--------------------------------------------------------------------------------
const char* CvPlayer::getCivilizationDescriptionKey() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->GetTextKey();
	}
	else if(CvPreGame::civilizationDescriptionKey(GetID()).GetLength() == 0)
	{
		return GC.getCivilizationInfo(getCivilizationType()) ? getCivilizationInfo().GetTextKey() : "TXT_UNKNOWN";
	}
	else
	{
		return CvPreGame::civilizationDescriptionKey(GetID()).c_str();
	}
}


//	--------------------------------------------------------------------------------
const char* CvPlayer::getCivilizationShortDescription() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->getShortDescription();
	}
	else if(CvPreGame::civilizationShortDescription(GetID()).GetLength() == 0)
	{
		return GC.getCivilizationInfo(getCivilizationType()) ? getCivilizationInfo().getShortDescription() : "unknown";
	}
	else
	{
		return CvPreGame::civilizationShortDescription(GetID()).c_str();
	}
}


//	--------------------------------------------------------------------------------
const char* CvPlayer::getCivilizationShortDescriptionKey() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->getShortDescriptionKey();
	}
	else if(CvPreGame::civilizationShortDescriptionKey(GetID()).GetLength() == 0)
	{
		return GC.getCivilizationInfo(getCivilizationType()) ? getCivilizationInfo().getShortDescriptionKey() : "TXT_UNKNOWN";
	}
	else
	{
		return CvPreGame::civilizationShortDescriptionKey(GetID()).c_str();
	}
}


//	--------------------------------------------------------------------------------
const char* CvPlayer::getCivilizationAdjective() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->getAdjective();
	}
	else if(CvPreGame::civilizationAdjective(GetID()).GetLength() == 0)
	{
		return GC.getCivilizationInfo(getCivilizationType()) ? getCivilizationInfo().getAdjective() : "unknown";
	}
	else
	{
		return CvPreGame::civilizationAdjective(GetID()).c_str();
	}
}

//	--------------------------------------------------------------------------------
const char* CvPlayer::getCivilizationAdjectiveKey() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->getAdjectiveKeyWide();
	}
	else if(CvPreGame::civilizationAdjectiveKey(GetID()).GetLength() == 0)
	{
		return GC.getCivilizationInfo(getCivilizationType()) ? getCivilizationInfo().getAdjectiveKey() : "TXT_UNKNOWN";
	}
	else
	{
		return CvPreGame::civilizationAdjectiveKey(GetID()).c_str();
	}
}

//	--------------------------------------------------------------------------------
const char* CvPlayer::getCivilizationTypeKey() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->GetType();
	}
	else
	{
		return getCivilizationInfo().GetType();
	}
}

//	--------------------------------------------------------------------------------
const char* CvPlayer::getLeaderTypeKey() const
{
	if(isMinorCiv())
	{
		return GC.getMinorCivInfo(GetMinorCivAI()->GetMinorCivType())->GetType();
	}
	else
	{
		return getLeaderInfo().GetType();
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isWhiteFlag() const
{
	return CvPreGame::isWhiteFlag(GetID());
}


//	--------------------------------------------------------------------------------
const char* CvPlayer::GetStateReligionName() const
{
	return GetLocalizedText(m_strReligionKey.get());
}

//	--------------------------------------------------------------------------------
CvString CvPlayer::GetStateReligionKey() const
{
	return m_strReligionKey.get();
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetStateReligionKey(const char* strKey)
{
	m_strReligionKey = strKey;
}


//	--------------------------------------------------------------------------------
const CvString CvPlayer::getWorstEnemyName() const
{
	TeamTypes eWorstEnemy;

	eWorstEnemy = NO_TEAM;

	if(eWorstEnemy != NO_TEAM)
	{
		return GET_TEAM(eWorstEnemy).getName();
	}

	return "";
}


//	--------------------------------------------------------------------------------
ArtStyleTypes CvPlayer::getArtStyleType() const
{
	if(CvPreGame::artStyle(GetID()) == NO_ARTSTYLE)
	{
		return ((ArtStyleTypes)(getCivilizationInfo().getArtStyleType()));
	}
	else
	{
		return CvPreGame::artStyle(GetID());
	}
}

//	---------------------------------------------------------------------------
void CvPlayer::doTurn()
{
	// Time building of these maps
	AI_PERF_FORMAT("AI-perf.csv", ("CvPlayer::doTurn(), Turn %d, %s", GC.getGame().getGameTurn(), getCivilizationShortDescription()));

	CvAssertMsg(isAlive(), "isAlive is expected to be true");

	//cache reset
	m_iNumUnitsSuppliedCached = -1;

	AI_doTurnPre();

	if(getCultureBombTimer() > 0)
		changeCultureBombTimer(-1);

	if(getConversionTimer() > 0)
		changeConversionTimer(-1);

	if(GetTurnsSinceSettledLastCity() >= 0)
		ChangeTurnsSinceSettledLastCity(1);

	setConscriptCount(0);
#if defined(MOD_BALANCE_CORE)
	if (MOD_DIPLOMACY_CIV4_FEATURES)
		DoVassalLevy();

	SetHasUUPeriod();

	if(MOD_BALANCE_CORE_JFD)
	{
		GetContracts()->DoTurn();
	}
	GET_TEAM(getTeam()).updateTeamStatus();
	UpdateBestMilitaryCities();
	
	if(GetFaithPurchaseCooldown() > 0)
	{
		ChangeFaithPurchaseCooldown(-1);
	}
	if(MOD_BALANCE_CORE && !isMinorCiv() && !isBarbarian())
	{
		for (int i = 0; i < NUM_DOMAIN_TYPES; i++)
		{
			DoDiversity((DomainTypes)i);
		}

		RefreshCSAlliesFriends();
		UpdateHappinessFromMinorCivs();
#endif
		DoUpdateCramped();

		DoUpdateUprisings();
		DoUpdateCityRevolts();
		CalculateNetHappiness();
		SetBestWonderCities();

#if defined(MOD_BALANCE_CORE_HAPPINESS)
		if(MOD_BALANCE_CORE_HAPPINESS)
		{
			if(GC.getLogging() && GC.getAILogging())
			{
				CvString playerName;
				FILogFile* pLog;
				CvString strBaseString;
				CvString strOutBuf;
				CvString strFileName = "PlayerHappinessStats.csv";
				playerName = getCivilizationShortDescription();
				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				strBaseString += playerName + ", ";
				strOutBuf.Format("TotalHappiness: %d, GoldU: %d, DefenseU: %d, ScienceU: %d, CultureU: %d, War Weariness: %d, Supply: %d, Use: %d", 
					GetExcessHappiness() , getUnhappinessFromCityGold(), getUnhappinessFromCityDefense(), getUnhappinessFromCityScience(), 
					getUnhappinessFromCityCulture(), GetUnhappinessFromWarWeariness(), GetNumUnitsSupplied(), GetNumUnitsToSupply());
				strBaseString += strOutBuf;
				pLog->Msg(strBaseString);
			}
		}
#endif
#if defined(MOD_BALANCE_CORE)
		//Reset every turn for CS events.
		for(int iQuestLoop = 0; iQuestLoop < NUM_MINOR_CIV_QUEST_TYPES; iQuestLoop++)
		{
			SetGlobalTourismAlreadyReceived((MinorCivQuestTypes)iQuestLoop, 0);
		}

		GetCorporations()->DoTurn();
	
		//Reset for reevaluation of citystrategy AI
		countCitiesFeatureSurrounded(true);
#endif
#if defined(MOD_BALANCE_CORE_AFRAID_ANNEX)
		if(MOD_BALANCE_CORE_AFRAID_ANNEX)
		{
			if(GetPlayerTraits()->IsBullyAnnex() && !IsEmpireVeryUnhappy() && !isHuman())
			{
				PlayerTypes eLoopPlayer;
				for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
				{
					eLoopPlayer = (PlayerTypes) iPlayerLoop;
					if(GET_PLAYER(eLoopPlayer).isMinorCiv() && GET_PLAYER(eLoopPlayer).isAlive())
					{
						if(GET_PLAYER(eLoopPlayer).GetMinorCivAI()->CanMajorBullyUnit(GetID()))
						{
							GC.getGame().DoMinorBullyUnit(GetID(), eLoopPlayer);
						}
					}
				}
			}
		}
#endif
		if(GetPlayerTraits()->IsEndOfMayaLongCount())
		{
			ChangeNumMayaBoosts(1);
		}
#if defined(MOD_BALANCE_CORE)
		if(GetPlayerTraits()->IsTradeRouteMinorInfluenceAdmiralPoints())
		{
			DoTradeInfluenceAP();
		}
	}
#endif
	bool bHasActiveDiploRequest = false;
	if(isAlive())
	{
		if(!isBarbarian())
		{
			if(!isMinorCiv())
			{
				GetTrade()->DoTurn();
				GetMilitaryAI()->ResetCounters();
				GetGrandStrategyAI()->DoTurn();
#if defined(MOD_ACTIVE_DIPLOMACY)
				if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
				{
					GetDiplomacyAI()->DoTurn(DIPLO_AI_PLAYERS);
				}
				else
				{
					if(GC.getGame().isHotSeat() && !isHuman())
					{
						// In Hotseat, AIs only do their diplomacy pass for other AIs on their turn
						// Diplomacy toward a human is done at the beginning of the humans turn.
						GetDiplomacyAI()->DoTurn(DIPLO_AI_PLAYERS);		// Do diplomacy for toward everyone
					}
					else
						GetDiplomacyAI()->DoTurn(DIPLO_ALL_PLAYERS);	// Do diplomacy for toward everyone

					if (!isHuman())
						bHasActiveDiploRequest = CvDiplomacyRequests::HasActiveDiploRequestWithHuman(GetID());
				}
#else
				if(GC.getGame().isHotSeat() && !isHuman())
				{
					// In Hotseat, AIs only do their diplomacy pass for other AIs on their turn
					// Diplomacy toward a human is done at the beginning of the humans turn.
					GetDiplomacyAI()->DoTurn(CvDiplomacyAI::DIPLO_AI_PLAYERS);		// Do diplomacy for toward everyone
				}
				else
					GetDiplomacyAI()->DoTurn(CvDiplomacyAI::DIPLO_ALL_PLAYERS);	// Do diplomacy for toward everyone

				if (!isHuman())
					bHasActiveDiploRequest = CvDiplomacyRequests::HasActiveDiploRequestWithHuman(GetID());
#endif
			}
		}
	}
#if defined(MOD_BALANCE_CORE)
	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
		if (eResourceLoop != NO_RESOURCE)
		{
			DoTestOverResourceNotification(eResourceLoop);
		}
	}
#endif

	if(isHuman() && !GC.getGame().isGameMultiPlayer())
		checkArmySizeAchievement();

	if( (bHasActiveDiploRequest || GC.GetEngineUserInterface()->isDiploActive()) && !GC.getGame().isGameMultiPlayer() && !isHuman())
	{
		GC.getGame().SetWaitingForBlockingInput(m_eID);
	}
	else
	{
#if defined(MOD_BALANCE_CORE)
		UpdateCityThreatCriteria();
#endif
		doTurnPostDiplomacy();
	}
#if defined(MOD_BALANCE_CORE)
	if(MOD_BALANCE_CORE_JFD)
	{
		DoPiety();
		DoReformCooldown();
		DoGovernmentCooldown();
	}
#endif
#if defined(MOD_BALANCE_CORE_EVENTS)
	if(MOD_BALANCE_CORE_EVENTS)
	{
		if(GC.getGame().isOption(GAMEOPTION_EVENTS))
		{
			DoEvents();
		}
	}
#endif
#if defined(MOD_BALANCE_CORE)
	for (int iInstantYield = 0; iInstantYield < NUM_INSTANT_YIELD_TYPES; iInstantYield++)
	{
		InstantYieldType eInstantYield = (InstantYieldType)iInstantYield;
		if(eInstantYield != NO_INSTANT_YIELD_TYPE && getInstantYieldText(eInstantYield) != "" && getInstantYieldText(eInstantYield) != NULL)
		{
			// Instant yield
			Localization::String strInstantYield = Localization::Lookup(getInstantYieldText(eInstantYield));
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_INSTANT_YIELD_EMPIRE");
				pNotifications->Add((NotificationTypes)FString::Hash("NOTIFICATION_INSTANT_YIELD"), strInstantYield.toUTF8(), strSummary.toUTF8(), -1, -1, GetID());
			}
			setInstantYieldText(eInstantYield, "");
			// Instant great person progress
			Localization::String strInstantGreatPersonProgress = Localization::Lookup(getInstantGreatPersonProgressText(eInstantYield));
			/*if (pNotifications) // Can't get this to work correctly for some reason
			{
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_GREAT_PERSON_PROGRESS_EMPIRE");
				pNotifications->Add((NotificationTypes)FString::Hash("NOTIFICATION_INSTANT_YIELD"), strInstantGreatPersonProgress.toUTF8(), strSummary.toUTF8(), -1, -1, GetID());
			}*/
			setInstantGreatPersonProgressText(eInstantYield, "");
		}
	}
#endif

	//note that this isn't actually the end of the turn - AI_unitUpdate is called later
	AI_doTurnPost();

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());

		bool bResult;
		LuaSupport::CallHook(pkScriptSystem, "PlayerDoTurn", args.get(), bResult);
	}

	m_kPlayerAchievements.StartTurn();
}

//	--------------------------------------------------------------------------------
void CvPlayer::doTurnPostDiplomacy()
{
	CvGame& kGame = GC.getGame();

	if(isAlive())
	{
		{
			AI_PERF_FORMAT("AI-perf.csv", ("Plots/Danger, Turn %03d, %s", kGame.getElapsedGameTurns(), getCivilizationShortDescription()) );

			UpdatePlots();
			UpdateDangerPlots(false);
			GetTacticalAI()->GetTacticalAnalysisMap()->Invalidate(); // Invalidating so that it will be updated even if already (possible erroneously) updated in UpdatdCityThreatCriteria with stale data.
			GetTacticalAI()->GetTacticalAnalysisMap()->Refresh(true);
			UpdateMilitaryStats();
			UpdateAreaEffectUnits();
			UpdateAreaEffectPlots();
			GET_TEAM(getTeam()).ClearWarDeclarationCache();
			UpdateCurrentAndFutureWars();

			if (0)
			{
				m_pCityDistanceTurns->Dump( CvString::format("c:\\temp\\CityDistanceTurns_Player%d.csv", m_eID.get()).c_str() );
				m_pCityDistancePlots->Dump( CvString::format("c:\\temp\\CityDistancePlots_Player%d.csv", m_eID.get()).c_str() );
			}
		}

		if(!isBarbarian())
		{
			GetEconomicAI()->DoTurn();
			GetMilitaryAI()->DoTurn();
#if defined(MOD_BALANCE_CORE)
			if(MOD_BALANCE_CORE && !isMinorCiv())
			{
#endif
			GetReligionAI()->DoTurn();
			GetTradeAI()->DoTurn();
			GetCitySpecializationAI()->DoTurn();
			GetLeagueAI()->DoTurn();
#if defined(MOD_BALANCE_CORE)
			}
#endif
		}

		if(isMinorCiv())
		{
			GetMinorCivAI()->DoTurn();
		}
	}

	// Temporary boosts
	if(GetAttackBonusTurns() > 0)
	{
		ChangeAttackBonusTurns(-1);
	}
	if(GetCultureBonusTurns() > 0)
	{
		ChangeCultureBonusTurns(-1);
	}
	if(GetTourismBonusTurns() > 0)
	{
		ChangeTourismBonusTurns(-1);
	}
#if defined(MOD_BALANCE_CORE)
	if(GetCultureBonusTurnsConquest() > 0)
	{
		ChangeCultureBonusTurnsConquest(-1);
	}
	if (GetProductionBonusTurnsConquest() > 0)
	{
		ChangeProductionBonusTurnsConquest(-1);
	}
#endif

#if defined(MOD_DIPLOMACY_CITYSTATES)
	if(MOD_DIPLOMACY_CITYSTATES && (!isMinorCiv() && !isBarbarian()))
	{
		DoProcessVotes();
		ProcessLeagueResolutions();
	}
#endif
#if defined(MOD_BALANCE_CORE_YIELDS)
	if(MOD_BALANCE_CORE_YIELDS)
	{
		DoChangeGreatGeneralRate();
		DoChangeGreatAdmiralRate();
	}
#endif

	// Golden Age
	DoProcessGoldenAge();

	// Great People gifts from Allied City States (if we have that policy)
	DoGreatPeopleSpawnTurn();

	// Do turn for all Cities
	{
		AI_PERF_FORMAT("AI-perf.csv", ("Do City Turns, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), getCivilizationShortDescription()) );
		if(getNumCities() > 0)
		{
			int iLoop = 0;
			for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				pLoopCity->doTurn();
			}
		}
	}

	// Gold
	GetTreasury()->DoGold();

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	// Tax out from after we've calculated our gold for this turn
	GetTreasury()->CalculateExpensePerTurnFromVassalTaxes();
#endif
	// Culture

	// Prevent exploits in turn timed MP games - no accumulation of culture if player hasn't picked yet
	GetCulture()->SetLastTurnLifetimeCulture(GetJONSCultureEverGenerated());
	GetCulture()->SetLastTurnCPT(GetJONSCultureEverGenerated() - GetCulture()->GetLastTurnLifetimeCulture());
	if(kGame.isOption(GAMEOPTION_END_TURN_TIMER_ENABLED))
	{
		if(getJONSCulture() < getNextPolicyCost())
			changeJONSCulture(GetTotalJONSCulturePerTurn());
	}
	else
	{
		changeJONSCulture(GetTotalJONSCulturePerTurn());
	}

	// Compute the cost of policies for this turn
	DoUpdateNextPolicyCost();

	// if this is the human player, have the popup come up so that he can choose a new policy
	if(isAlive() && isHuman() && getNumCities() > 0)
	{
		if(!GC.GetEngineUserInterface()->IsPolicyNotificationSeen())
		{
			if(getNextPolicyCost() <= getJONSCulture() && GetPlayerPolicies()->GetNumPoliciesCanBeAdopted() > 0)
			{
				CvNotifications* pNotifications = GetNotifications();
				if(pNotifications)
				{
					CvString strBuffer;

					if(kGame.isOption(GAMEOPTION_POLICY_SAVING))
						strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_ENOUGH_CULTURE_FOR_POLICY_DISMISS");
					else
						strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_ENOUGH_CULTURE_FOR_POLICY");

					CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_ENOUGH_CULTURE_FOR_POLICY");
					pNotifications->Add(NOTIFICATION_POLICY, strBuffer, strSummary, -1, -1, -1);
				}
			}
		}

		if (GetPlayerPolicies()->IsTimeToChooseIdeology() && GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
		{
#if defined(MOD_BALANCE_CORE)
			if(GetPlayerTraits()->IsAdoptionFreeTech())
			{
				CvString strBuffer = GetLocalizedText("TXT_KEY_MISC_CHOSE_IDEOLOGY_UA_CHOOSE_TECH");
				chooseTech(1, strBuffer.GetCString());
			}
#endif
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				CvString strBuffer;
#if defined(MOD_CONFIG_GAME_IN_XML)
				if (GetCurrentEra() > GD_INT_GET(IDEOLOGY_START_ERA))
#else
				if (GetCurrentEra() > GC.getInfoTypeForString("ERA_INDUSTRIAL"))
#endif
				{
					strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_CHOOSE_IDEOLOGY_ERA");
				}
				else
				{
					strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_CHOOSE_IDEOLOGY_FACTORIES");
				}
				CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_CHOOSE_IDEOLOGY");
				pNotifications->Add(NOTIFICATION_CHOOSE_IDEOLOGY, strBuffer, strSummary, -1, -1, GetID());
			}
		}
	}

	if (isAlive() && getNumCities() > 0 && !isHuman() && !isMinorCiv())
	{
		if (GetPlayerPolicies()->IsTimeToChooseIdeology() && GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
		{
#if defined(MOD_BALANCE_CORE)
			if(GetPlayerTraits()->IsAdoptionFreeTech())
			{
				AI_chooseFreeTech();
			}
#endif
			AI_PERF_FORMAT("AI-perf.csv", ("DoChooseIdeology, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), getCivilizationShortDescription()) );
			GetPlayerPolicies()->DoChooseIdeology();
		}
	}

	if (!isBarbarian() && !isHuman() && !isMinorCiv())
	{
		AI_PERF_FORMAT("AI-perf.csv", ("DoPolicyAI, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), getCivilizationShortDescription()) );
		GetPlayerPolicies()->DoPolicyAI();
	}

	// Science
	doResearch();

	GetEspionage()->DoTurn();
#if defined(MOD_BALANCE_CORE)
	if(MOD_BALANCE_CORE && !isMinorCiv())
	{
#endif
	// Faith
	CvGameReligions* pGameReligions = kGame.GetGameReligions();
	pGameReligions->DoPlayerTurn(*this);

	// Leagues
	CvGameLeagues* pGameLeagues = kGame.GetGameLeagues();
	pGameLeagues->DoPlayerTurn(*this);

	// Anarchy counter
	if(GetAnarchyNumTurns() > 0)
		ChangeAnarchyNumTurns(-1);
#if defined(MOD_BALANCE_CORE)
	}
#endif
	DoIncomingUnits();

	const int iGameTurn = kGame.getGameTurn();

	GatherPerTurnReplayStats(iGameTurn);

	GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
}

//	--------------------------------------------------------------------------------
void CvPlayer::doTurnUnits()
{
	CvUnit* pLoopUnit;
	int iLoop;

	AI_doTurnUnitsPre();

	// Tactical AI
	m_pTacticalAI->DoTurn();

	// Homeland AI
	m_pHomelandAI->DoTurn();

	// Start: old unit AI processing
	for(int iPass = 0; iPass < 4; iPass++)
	{
		for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		{
			switch(pLoopUnit->getDomainType())
			{
			case DOMAIN_AIR:
				if(iPass == 1)
				{
					pLoopUnit->doTurn();
				}
				break;
			case DOMAIN_SEA:
				if(iPass == 2)
				{
					pLoopUnit->doTurn();
				}
				break;
			case DOMAIN_LAND:
				if(iPass == 3)
				{
					pLoopUnit->doTurn();
				}
				break;
			case DOMAIN_IMMOBILE:
				if(iPass == 0)
				{
					pLoopUnit->doTurn();
				}
				break;
			case NO_DOMAIN:
				CvAssertMsg(false, "Unit with no Domain");
				break;
			default:
				if(iPass == 3)
				{
					pLoopUnit->doTurn();
				}
				break;
			}
		}
	}

	if(GetID() == GC.getGame().getActivePlayer())
	{
		GC.GetEngineUserInterface()->setDirty(Waypoints_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(SelectionButtons_DIRTY_BIT, true);
	}

	GC.GetEngineUserInterface()->setDirty(UnitInfo_DIRTY_BIT, true);

	AI_doTurnUnitsPost();
}

//	--------------------------------------------------------------------------------
/// Indicate that the AI has not processed any units yet
void CvPlayer::SetAllUnitsUnprocessed()
{
	int iLoop;
	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		pLoopUnit->SetTurnProcessed(false);

#if defined(MOD_CORE_PER_TURN_DAMAGE)
		pLoopUnit->flipDamageReceivedPerTurn();
#endif
	}


#if defined(MOD_CORE_PER_TURN_DAMAGE)
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->flipDamageReceivedPerTurn();
	}
#endif
}

//	--------------------------------------------------------------------------------
/// Units heal and then get their movement back
void CvPlayer::DoUnitReset()
{
	int iLoop;
	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		// First heal the unit
		pLoopUnit->doHeal();

		// then damage it again
		int iCitadelDamage = pLoopUnit->plot()->GetDangerPlotDamage(pLoopUnit->getOwner());
		if (iCitadelDamage != 0 && !pLoopUnit->isInvisible(NO_TEAM, false, false))
		{
			
			pLoopUnit->changeDamage(iCitadelDamage, NO_PLAYER, /*fAdditionalTextDelay*/ 0.5f);
#if defined(MOD_CORE_PER_TURN_DAMAGE)
			pLoopUnit->addDamageReceivedThisTurn(iCitadelDamage);
#endif
		}

		// Bonus for entrenched units
		if (!pLoopUnit->hasMoved() && pLoopUnit->canFortify(pLoopUnit->plot()))
			pLoopUnit->SetFortified(true);

		// Finally (now that healing is done), restore movement points
		pLoopUnit->restoreFullMoves();

		// Archaeologist can't move on turn he finishes a dig (while waiting for user to decide his next action)
		if (pLoopUnit->AI_getUnitAIType() == UNITAI_ARCHAEOLOGIST)
		{
			CvPlayer &kPlayer = GET_PLAYER(pLoopUnit->getOwner());
			if (kPlayer.GetCulture()->HasDigCompleteHere(pLoopUnit->plot()))
			{
				pLoopUnit->finishMoves();
			}
		}

		pLoopUnit->SetIgnoreDangerWakeup(false);
		pLoopUnit->setMadeAttack(false);
		pLoopUnit->setMadeInterception(false);

		if(!isHuman())
		{
			const MissionData* pkMissionData = pLoopUnit->GetHeadMissionData();
			if(pkMissionData)
			{
				if(pkMissionData->eMissionType == CvTypes::getMISSION_RANGE_ATTACK() ||
				        pkMissionData->eMissionType == CvTypes::getMISSION_AIRSTRIKE() ||
				        pkMissionData->eMissionType == CvTypes::getMISSION_AIR_SWEEP() ||
				        pkMissionData->eMissionType == CvTypes::getMISSION_NUKE())
				{
					CvAssertMsg(0, "An AI unit has a combat mission queued at the end of its turn.");
					pLoopUnit->ClearMissionQueue();	// Clear the whole thing, the AI will re-evaluate next turn.
				}
			}
		}
	}
}

void CvPlayer::ResetReachablePlotsForAllUnits()
{
	int iLoop;
	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		pLoopUnit->ClearReachablePlots();
}


//	--------------------------------------------------------------------------------
/// Damage units from attrition (start of turn so we can get notifications)
void CvPlayer::DoUnitAttrition()
{
	int iLoop;
	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		pLoopUnit->DoAttrition();
}

//	--------------------------------------------------------------------------------
void CvPlayer::RespositionInvalidUnits()
{
	int iLoop;
	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(!pLoopUnit)
		{
			continue;
		}

		if(pLoopUnit->isDelayedDeath())
		{
			continue;
		}

		if(pLoopUnit->isCargo())
		{
			continue;
		}

		if(pLoopUnit->isInCombat())
		{
			continue;
		}

		CvPlot* pPlot = pLoopUnit->plot();
		if(!pPlot)
		{
			continue;
		}

#if defined(MOD_GLOBAL_STACKING_RULES)
		if(pPlot->getMaxFriendlyUnitsOfType(pLoopUnit) > pPlot->getUnitLimit())
#else
		if(pPlot->getMaxFriendlyUnitsOfType(pLoopUnit) > GC.getPLOT_UNIT_LIMIT())
#endif
		{
			if (!pLoopUnit->jumpToNearestValidPlot())
				pLoopUnit->kill(false);	// Could not find a valid location!
		}
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::updateYield()
{
	// This will go through all of the plots and update the yield if the player owns it.
	// The plot will not contribute to the player's yield unless it is worked by a city.
	// Previously this would just go through all the plots the city can work (3 rings around it)
	// but all plots have their yields updated on load and not updating them here could lead to 
	// a visual discrepancy.
	CvMap& kMap = GC.getMap();
	int iNumPlots = kMap.numPlots();
	PlayerTypes ePlayer = GetID();
	for (int iI = 0; iI < iNumPlots; iI++)
	{
		CvPlot* pkPlot = kMap.plotByIndexUnchecked(iI);
		if (pkPlot->getOwner() == ePlayer)
			pkPlot->updateYield();
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::updateExtraSpecialistYield()
{
	int iLoop;
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->updateExtraSpecialistYield();
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::updateCityPlotYield()
{
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->plot()->updateYield();
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::updateCitySight(bool bIncrement)
{
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->plot()->updateSight(bIncrement);
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::UpdateNotifications()
{
	if(GetNotifications())
	{
		GetNotifications()->Update();
	}

	if(GetDiplomacyRequests())
	{
		GetDiplomacyRequests()->Update();
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::UpdateReligion()
{
	CalculateNetHappiness();

#if defined(MOD_BALANCE_CORE)
	int iLoop;
	CvCity* pLoopCity;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
		{
			YieldTypes eYield = (YieldTypes)iI;
			if(eYield == NO_YIELD)
				continue;

			pLoopCity->UpdateSpecialReligionYields(eYield);
		}
	}
	GC.getGame().GetGameReligions()->DoUpdateReligion(GetID());
#endif
}

//	--------------------------------------------------------------------------------
void CvPlayer::updateTimers()
{
	int iLoop;
	m_endTurnBusyUnitUpdatesLeft--;

	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
		pLoopUnit->UpdateMission();

	//unit cleanup - this should probably also be done in a two-pass scheme like below
	//but since it's too involved to change that now, we do the ugly loop to make sure we didn't skip a unit
	bool bKilledAtLeastOne = false;
	bool bKilledOneThisPass = false;
	do
	{
		bKilledOneThisPass = false;
		for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
			bKilledOneThisPass |= pLoopUnit->doDelayedDeath();
		bKilledAtLeastOne |= bKilledOneThisPass;
	} while (bKilledOneThisPass);

#if defined(MOD_CORE_DELAYED_VISIBILITY)
	//force explicit visibility update for killed units
	if (bKilledAtLeastOne)
		for (int iI = 0; iI < GC.getMap().numPlots(); iI++)
			GC.getMap().plotByIndexUnchecked(iI)->flipVisibility(getTeam());
#endif

	GetDiplomacyAI()->update();
}

//	--------------------------------------------------------------------------------
bool CvPlayer::hasPromotableUnit() const
{
	const CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->isPromotionReady() && !pLoopUnit->isDelayedDeath())
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::hasReadyUnit() const
{
	const CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->ReadyToMove() && !pLoopUnit->isDelayedDeath())
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetCountReadyUnits() const
{
	int iRtnValue = 0;
	const CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->ReadyToMove() && !pLoopUnit->isDelayedDeath() && !pLoopUnit->TurnProcessed())
		{
			iRtnValue++;
		}
	}

	return iRtnValue;
}

//	--------------------------------------------------------------------------------
const CvUnit* CvPlayer::GetFirstReadyUnit() const
{
	const CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->ReadyToMove() && !pLoopUnit->isDelayedDeath() && !pLoopUnit->TurnProcessed())
		{
			return pLoopUnit;
		}
	}

	return NULL;
}

//	--------------------------------------------------------------------------------
void CvPlayer::EndTurnsForReadyUnits()
{
	CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->ReadyToMove() && !pLoopUnit->isDelayedDeath() && !pLoopUnit->TurnProcessed())
		{
			pLoopUnit->PushMission(CvTypes::getMISSION_SKIP());
			pLoopUnit->SetTurnProcessed(true);
#if defined(MOD_BALANCE_CORE)
			if(GC.getLogging() && GC.getAILogging())
			{
				CvString strCiv = GET_PLAYER(pLoopUnit->getOwner()).getCivilizationAdjective();
				CvString strLogString;
				strLogString.Format("Warning: Forcing turn end for %s %s at %d,d", strCiv.c_str(), pLoopUnit->getName().c_str(), pLoopUnit->getX(), pLoopUnit->getY() );
				GetHomelandAI()->LogHomelandMessage(strLogString);
			}
#endif
		}
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::hasAutoUnit() const
{
	const CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->ReadyToAuto())
		{
			return true;
		}
	}

	return false;
}

//	----------------------------------------------------------------------------
bool CvPlayer::hasBusyUnit() const
{
	const CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->IsBusy())
		{
			return true;
		}
	}

	return false;
}

//	----------------------------------------------------------------------------
bool CvPlayer::hasBusyCity() const
{
	const CvCity* pLoopCity;
	int iLoop;

	for(pLoopCity = firstCity(&iLoop); pLoopCity; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity->IsBusy())
		{
			return true;
		}
	}

	return false;
}

//	----------------------------------------------------------------------------
const CvCity* CvPlayer::getBusyCity() const
{
	const CvCity* pLoopCity;
	int iLoop;

	for(pLoopCity = firstCity(&iLoop); pLoopCity; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity->IsBusy())
		{
			return pLoopCity;
		}
	}

	return false;
}

//	----------------------------------------------------------------------------
bool CvPlayer::hasBusyUnitOrCity() const
{
	if(hasBusyUnit())
		return true;
	return hasBusyCity();
}

//	--------------------------------------------------------------------------------
const CvUnit* CvPlayer::getBusyUnit() const
{
	const CvUnit* result = NULL;
	int iLoop;
	for(const CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->IsBusy())
		{
			result = pLoopUnit;
		}
	}
	return result;
}


//	--------------------------------------------------------------------------------
void CvPlayer::chooseTech(int iDiscover, const char* strText, TechTypes iTechJustDiscovered)
{
	if(GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))
	{
		return;
	}

	if(iDiscover > 0)
	{
		SetNumFreeTechs(GetNumFreeTechs()+iDiscover);
	}

	if(iDiscover > 0)
	{
		CvNotifications* pNotifications = GetNotifications();
		if(pNotifications)
		{
			pNotifications->Add(NOTIFICATION_FREE_TECH, strText, strText, -1, -1, iDiscover, iTechJustDiscovered);
		}
	}
	else if(strText == 0 || strText[0] == 0)
	{
		CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_NEW_RESEARCH");
		CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_NEW_RESEARCH");
		CvNotifications* pNotifications = GetNotifications();
		if(pNotifications)
		{
			pNotifications->Add(NOTIFICATION_TECH, strBuffer, strSummary, -1, -1, iDiscover, iTechJustDiscovered);
		}
	}
	else
	{
		CvNotifications* pNotifications = GetNotifications();
		if(pNotifications)
		{
			pNotifications->Add(NOTIFICATION_TECH, strText, strText, -1, -1, iDiscover, iTechJustDiscovered);
		}
	}
}

//////////////////////////////////////////////////////////////////////////
// Civ 5 Score
//////////////////////////////////////////////////////////////////////////

//	--------------------------------------------------------------------------------
/// What is this player's score?
int CvPlayer::GetScore(bool bFinal, bool bWinner) const
{
	if(!isAlive())
		return 0;

	if(GET_TEAM(getTeam()).getNumMembers() == 0)
		return 0;

	int iScore = 0;

	iScore += GetScoreFromCities();
	iScore += GetScoreFromPopulation();
	iScore += GetScoreFromLand();
	iScore += GetScoreFromWonders();
	iScore += GetScoreFromPolicies();
	iScore += GetScoreFromGreatWorks();
	iScore += GetScoreFromReligion();
	iScore += GetScoreFromTechs();
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (MOD_DIPLOMACY_CIV4_FEATURES) {
		iScore += GetScoreFromVassals();
	}
#endif
#if defined(MOD_BALANCE_CORE)
	iScore += GetScoreFromMinorAllies();
	iScore += GetScoreFromMilitarySize();
#endif
	iScore += GetScoreFromFutureTech();
	iScore += GetScoreFromScenario1();
	iScore += GetScoreFromScenario2();
	iScore += GetScoreFromScenario3();
	iScore += GetScoreFromScenario4();

	// If the game is over, we apply a mod to the value, rewarding players who finish early
	if(bFinal && bWinner)
	{
		int iGameProgressPercent = 100 * GC.getGame().getGameTurn() / GC.getGame().getEstimateEndTurn();
		iGameProgressPercent = iGameProgressPercent < 1 ? 1 : iGameProgressPercent;
		iScore *= 100;
		iScore /= iGameProgressPercent;
	}

	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from Cities: 10 per city (with mod for map size)
int CvPlayer::GetScoreFromCities() const
{
	int iScore = getNumCities() * /*10*/ GC.getSCORE_CITY_MULTIPLIER();

	iScore *= GC.getGame().GetMapScoreMod();
	iScore /= 100;

	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from Population: 6 per pop (with mod for map size)
int CvPlayer::GetScoreFromPopulation() const
{
	int iScore = getTotalPopulation() * /*4*/ GC.getSCORE_POPULATION_MULTIPLIER();

	iScore *= GC.getGame().GetMapScoreMod();
	iScore /= 100;

	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from Land: 6 per plot (with mod for map size)
int CvPlayer::GetScoreFromLand() const
{
	int iScore = getTotalLand() * /*1*/ GC.getSCORE_LAND_MULTIPLIER();

	iScore *= GC.getGame().GetMapScoreMod();
	iScore /= 100;

	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from world wonders
int CvPlayer::GetScoreFromWonders() const
{
	int iScore = GetNumWonders() * /*25*/ GC.getSCORE_WONDER_MULTIPLIER();
	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from policies
int CvPlayer::GetScoreFromPolicies() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_POLICIES))
	{
		return 0;
	}
#if defined(MOD_BUGFIX_DUMMY_POLICIES)
	int iScore = GetPlayerPolicies()->GetNumPoliciesOwned(MOD_BUGFIX_DUMMY_POLICIES) * /*4*/ GC.getSCORE_POLICY_MULTIPLIER();
#else
	int iScore = GetPlayerPolicies()->GetNumPoliciesOwned() * /*4*/ GC.getSCORE_POLICY_MULTIPLIER();
#endif
	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from world wonders: 40 per
int CvPlayer::GetScoreFromGreatWorks() const
{
	int iScore = GetCulture()->GetNumGreatWorks() * /*4*/ GC.getSCORE_GREAT_WORK_MULTIPLIER();
	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from world wonders: 40 per
int CvPlayer::GetScoreFromReligion() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_RELIGION))
	{
		return 0;
	}
	int iScore = 0;
	CvGameReligions *pGameReligions = GC.getGame().GetGameReligions();
	ReligionTypes eReligion = GetReligions()->GetReligionCreatedByPlayer();
	if (eReligion > RELIGION_PANTHEON)
	{
		const CvReligion *pReligion = pGameReligions->GetReligion(eReligion, GetID());
		iScore += pReligion->m_Beliefs.GetNumBeliefs() * /*20*/ GC.getSCORE_BELIEF_MULTIPLIER();
		iScore += pGameReligions->GetNumCitiesFollowing(eReligion) * /*1*/ GC.getSCORE_RELIGION_CITIES_MULTIPLIER();
	}
	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from Tech: 4 per
int CvPlayer::GetScoreFromTechs() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))
	{
		return 0;
	}

	// Normally we recompute it each time
	int iScore = GET_TEAM(getTeam()).GetTeamTechs()->GetNumTechsKnown() * /*4*/ GC.getSCORE_TECH_MULTIPLIER();
	return iScore;
}

//	--------------------------------------------------------------------------------
// Score from Future Tech: 10 per
int CvPlayer::GetScoreFromFutureTech() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))
	{
		return 0;
	}

	return m_iScoreFromFutureTech;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeScoreFromFutureTech(int iChange)
{
	if(iChange != 0)
		m_iScoreFromFutureTech += iChange;
}

//	--------------------------------------------------------------------------------
// Score from scenario-specific items
int CvPlayer::GetScoreFromScenario1() const
{
	return m_iScenarioScore1;
}
void CvPlayer::ChangeScoreFromScenario1(int iChange)
{
	if(iChange != 0)
		m_iScenarioScore1 += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetScoreFromScenario2() const
{
	return m_iScenarioScore2;
}
void CvPlayer::ChangeScoreFromScenario2(int iChange)
{
	if(iChange != 0)
		m_iScenarioScore2 += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetScoreFromScenario3() const
{
	return m_iScenarioScore3;
}
void CvPlayer::ChangeScoreFromScenario3(int iChange)
{
	if(iChange != 0)
		m_iScenarioScore3 += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetScoreFromScenario4() const
{
	return m_iScenarioScore4;
}
void CvPlayer::ChangeScoreFromScenario4(int iChange)
{
	if(iChange != 0)
		m_iScenarioScore4 += iChange;
}

//////////////////////////////////////////////////////////////////////////
// End Civ 5 Score
//////////////////////////////////////////////////////////////////////////

//	--------------------------------------------------------------------------------
#if defined(MOD_BALANCE_CORE)
int CvPlayer::countCityFeatures(FeatureTypes eFeature, bool bReset) const
#else
int CvPlayer::countCityFeatures(FeatureTypes eFeature) const
#endif
{
	int iCount = 0;
#if defined(MOD_BALANCE_CORE)
	if(bReset)
	{
#endif
	const CvCity* pLoopCity;
	const CvPlot* pLoopPlot;
	int iLoop;
	int iI;

	iCount = 0;

	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{

		for(iI = 0; iI < pLoopCity->GetNumWorkablePlots(); iI++)
		{
			pLoopPlot = iterateRingPlots(pLoopCity->getX(), pLoopCity->getY(), iI);

			if(pLoopPlot != NULL)
			{
				if(pLoopPlot->getFeatureType() == eFeature)
				{
					iCount++;
				}
			}
		}
	}
#if defined(MOD_BALANCE_CORE)
		GET_PLAYER(GetID()).setCityFeatures(eFeature, iCount);
		return 0;
	}
	else
	{
		return getCityFeatures(eFeature);
	}
#endif
}


//	--------------------------------------------------------------------------------
int CvPlayer::countNumBuildingsInPuppets(BuildingTypes eBuilding, bool bReset) const
{
	int iCount = 0;
	if (bReset)
	{
		const CvCity* pLoopCity;

		int iLoop;

		iCount = 0;

		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if (!pLoopCity->IsPuppet())
				continue;

			if (pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
			{
				iCount += pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding);
			}
		}
		GET_PLAYER(GetID()).setNumBuildingsInPuppets(eBuilding, iCount);
		return iCount;
	}
	else
	{
		return getNumBuildingsInPuppets(eBuilding);
	}
}
#if defined(MOD_BALANCE_CORE)
int CvPlayer::countNumBuildings(BuildingTypes eBuilding, bool bReset) const
#else
int CvPlayer::countNumBuildings(BuildingTypes eBuilding) const
#endif
{
	int iCount = 0;
#if defined(MOD_BALANCE_CORE)
	if(bReset)
	{
#endif
	const CvCity* pLoopCity;
	
	int iLoop;

	iCount = 0;

	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
		{
			iCount += pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding);
		}
	}
#if defined(MOD_BALANCE_CORE)
		GET_PLAYER(GetID()).setNumBuildings(eBuilding, iCount);
		return iCount;
	}
	else
	{
		return getNumBuildings(eBuilding);
	}
#endif
}

//	--------------------------------------------------------------------------------
/// How many cities in the empire surrounded by features?
#if defined(MOD_BALANCE_CORE)
int CvPlayer::countCitiesFeatureSurrounded(bool bReset) const
#else
int CvPlayer::countCitiesFeatureSurrounded() const
#endif
{
	int iCount = 0;
#if defined(MOD_BALANCE_CORE)
	if(bReset)
	{
#endif
	const CvCity* pLoopCity;
	
	int iLoop;

	iCount = 0;

	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity->IsFeatureSurrounded())
			iCount ++;
	}
#if defined(MOD_BALANCE_CORE)
		GET_PLAYER(GetID()).setCitiesFeatureSurrounded(iCount);
		return 0;
	}
	else
	{
		return getCitiesFeatureSurrounded();
	}
#endif
}
#if defined(MOD_BALANCE_CORE)
void CvPlayer::setCityFeatures(FeatureTypes eFeature, int iValue)
{
	CvAssertMsg(eFeature >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFeature < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	
	m_piCityFeatures[eFeature] = iValue;
}
int CvPlayer::getCityFeatures(FeatureTypes eFeature) const
{
	CvAssertMsg(eFeature >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFeature < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	return m_piCityFeatures[eFeature];
}
void CvPlayer::setNumBuildings(BuildingTypes eBuilding, int iValue)
{
	CvAssertMsg(eBuilding >= 0, "eBuilding is expected to be non-negative (invalid Index)");
	CvAssertMsg(eBuilding < GC.getNumBuildingInfos(), "eBuilding is expected to be within maximum bounds (invalid Index)");

	m_piNumBuildings[eBuilding] = iValue;
}
int CvPlayer::getNumBuildings(BuildingTypes eBuilding) const
{
	CvAssertMsg(eBuilding >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eBuilding < GC.getNumBuildingInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	return m_piNumBuildings[eBuilding];
}

void CvPlayer::setNumBuildingsInPuppets(BuildingTypes eBuilding, int iValue)
{
	CvAssertMsg(eBuilding >= 0, "eBuilding is expected to be non-negative (invalid Index)");
	CvAssertMsg(eBuilding < GC.getNumBuildingInfos(), "eBuilding is expected to be within maximum bounds (invalid Index)");

	m_piNumBuildingsInPuppets[eBuilding] = iValue;
}
int CvPlayer::getNumBuildingsInPuppets(BuildingTypes eBuilding) const
{
	CvAssertMsg(eBuilding >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eBuilding < GC.getNumBuildingInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	return m_piNumBuildingsInPuppets[eBuilding];
}

void CvPlayer::setCitiesFeatureSurrounded(int iValue)
{
	m_iCitiesFeatureSurrounded = iValue;
}
int CvPlayer::getCitiesFeatureSurrounded() const
{
	return m_iCitiesFeatureSurrounded;
}
#endif

//	--------------------------------------------------------------------------------
bool CvPlayer::IsCityConnectedToCity(CvCity* pCity1, CvCity* pCity2, RouteTypes eRestrictRoute, bool bIgnoreHarbors, SPath* pPathOut)
{
	if (!pCity1 || !pCity2)
		return false;

	return IsPlotConnectedToPlot(m_eID, pCity1->plot(), pCity2->plot(), eRestrictRoute, bIgnoreHarbors, pPathOut);
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsCapitalConnectedToPlayer(PlayerTypes ePlayer)
{
	// everybody needs to be alive!
	if(!isAlive() || !(GET_PLAYER(ePlayer).isAlive()))
	{
		return false;
	}

	CvCity* pOtherPlayerCapital = GET_PLAYER(ePlayer).getCapitalCity();
	if(pOtherPlayerCapital == NULL)
	{
		return false;
	}

	CvCity* pPlayerCapital = getCapitalCity();
	if(pPlayerCapital == NULL)
	{
		return false;
	}

	return IsPlotConnectedToPlot(m_eID, pPlayerCapital->plot(), pOtherPlayerCapital->plot());
}

//	--------------------------------------------------------------------------------
void CvPlayer::findNewCapital()
{
	int iLoop;

	BuildingTypes eCapitalBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(GC.getCAPITAL_BUILDINGCLASS())));
	if(eCapitalBuilding == NO_BUILDING)
	{
		return;
	}

	CvCity* pOldCapital = getCapitalCity();
	int iBestValue = 0;
	CvCity* pBestCity = NULL;

	CvCity* pLoopCity;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != pOldCapital)
		{
			if(0 == pLoopCity->GetCityBuildings()->GetNumRealBuilding(eCapitalBuilding))
			{
#if defined(MOD_BUGFIX_NO_PUPPET_CAPITALS)
				// First pass, exclude cities in resistance, puppets, and those burning to the ground
				if (!(pLoopCity->IsResistance() || pLoopCity->IsPuppet() || pLoopCity->IsRazing()))
				{
#endif
					int iValue = (pLoopCity->getPopulation() * 4);

					int iYieldValueTimes100 = pLoopCity->getYieldRateTimes100(YIELD_FOOD, false);
					iYieldValueTimes100 += (pLoopCity->getYieldRateTimes100(YIELD_PRODUCTION, false) * 3);
					iYieldValueTimes100 += (pLoopCity->getYieldRateTimes100(YIELD_GOLD, false) * 2);
					iValue += (iYieldValueTimes100 / 100);

					iValue += (pLoopCity->getNumGreatPeople() * 2);

					if (iValue > iBestValue)
					{
						iBestValue = iValue;
						pBestCity = pLoopCity;
					}
#if defined(MOD_BUGFIX_NO_PUPPET_CAPITALS)
				}
#endif
			}
		}
	}

#if defined(MOD_BUGFIX_NO_PUPPET_CAPITALS)
	if (pBestCity == NULL)
	{
		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if (pLoopCity != pOldCapital)
			{
				if (0 == pLoopCity->GetCityBuildings()->GetNumRealBuilding(eCapitalBuilding))
				{
					int iValue = 0;

					// Second pass, consider only those we ignored first time
					if (pLoopCity->IsResistance())
					{
						// We'll take a city in resistance (ie one we have decided to assimilate) over all others
						iValue = pLoopCity->getPopulation() + 500;
					}
					else if (pLoopCity->IsPuppet())
					{
						// We'll take a puppet city next, at least we're not burning it to the ground!
						iValue = pLoopCity->getPopulation() + 250;
					}
					else if (pLoopCity->IsRazing())
					{
						// Might be an idea to stop the burning!
						iValue = pLoopCity->getPopulation();
					}

					if (iValue > iBestValue)
					{
						iBestValue = iValue;
						pBestCity = pLoopCity;
					}
				}
			}
		}
	}
#endif

	if (pBestCity != NULL)
	{
		if (pOldCapital != NULL)
		{
			pOldCapital->GetCityBuildings()->SetNumRealBuilding(eCapitalBuilding, 0);
		}
		CvAssertMsg(!(pBestCity->GetCityBuildings()->GetNumRealBuilding(eCapitalBuilding)), "(pBestCity->getNumRealBuilding(eCapitalBuilding)) did not return false as expected");
		pBestCity->GetCityBuildings()->SetNumRealBuilding(eCapitalBuilding, 1);

#if defined(MOD_BALANCE_CORE)
		for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
		{
			const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iI);
			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
			if (pkBuildingClassInfo)
			{
				int iNumFreeBuildings = GetNumCitiesFreeChosenBuilding(eBuildingClass);
				if (iNumFreeBuildings > 0 || IsFreeChosenBuildingNewCity(eBuildingClass) || IsFreeBuildingAllCity(eBuildingClass))
				{
					const BuildingTypes eBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(pkBuildingClassInfo->GetID())));
					if (NO_BUILDING != eBuilding)
					{
						CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
						if (pkBuildingInfo && pkBuildingInfo->IsCapitalOnly())
						{
							pBestCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, 1);
						}
					}
				}
			}
		}
#endif

#if defined(MOD_EVENTS_CITY_CAPITAL)
		if (MOD_EVENTS_CITY_CAPITAL) {
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_CapitalChanged, GetID(), pBestCity->GetID(), (pOldCapital ? pOldCapital->GetID() : -1));
		}
#endif

#if defined(MOD_BUGFIX_NO_PUPPET_CAPITALS)
		if (pBestCity->IsPuppet())
		{
			gDLL->sendDoTask(pBestCity->GetID(), TASK_ANNEX_PUPPET, -1, -1, false, false, false, false);
		}
		else if (pBestCity->IsRazing() && !isHuman())
		{
			// For the AI, we'll stop burining our new capital!
			gDLL->sendDoTask(pBestCity->GetID(), TASK_UNRAZE, -1, -1, false, false, false, false);
		}
#endif

#if defined(MOD_GLOBAL_NO_CONQUERED_SPACESHIPS)
		if (MOD_GLOBAL_NO_CONQUERED_SPACESHIPS && !isMinorCiv() && !isBarbarian()) {
			// Rebuild the spaceship launch pad
			CvTeam& thisTeam = GET_TEAM(getTeam());

			if (thisTeam.getProjectCount((ProjectTypes)GC.getSPACE_RACE_TRIGGER_PROJECT()) == 1) {
				if (isAlive()) {
					CUSTOMLOG("Rebuilding launch pad at (%i, %i)", pBestCity->getX(), pBestCity->getY());
					auto_ptr<ICvPlot1> pDllPlot(new CvDllPlot(pBestCity->plot()));
					gDLL->GameplaySpaceshipEdited(pDllPlot.get(), 0x0001); // Display just the launch pad
				}
			}
		}
#endif
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canRaze(CvCity* pCity, bool bIgnoreCapitals) const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_CITY_RAZING))
	{
		return false;
	}

	// If we don't own this city right now then we can't raze it!
	if(pCity->getOwner() != GetID())
	{
		return false;
	}

	// Can't raze a city that originally belonged to us
	if(pCity->getOriginalOwner() == GetID())
	{
		return false;
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(pCity->getOwner());
		args->Push(pCity->GetID());

		bool bResult = false;
		if(LuaSupport::CallTestAll(pkScriptSystem, "CanRazeOverride", args.get(), bResult))
		{
			// Check the result.
			if(bResult == true)
			{
				return true;
			}
		}
	}

#if defined(MOD_EVENTS_CITY_RAZING)
	if (MOD_EVENTS_CITY_RAZING) {
		// Note the subtle difference between CanRazeOverride and PlayerCanRaze, the former needs everyone to agree, the latter anyone
		if (GAMEEVENTINVOKE_TESTANY(GAMEEVENT_PlayerCanRaze, pCity->getOwner(), pCity->GetID()) == GAMEEVENTRETURN_TRUE) {
			return true;
		}
	}
#endif

	// No razing of capitals
	CvPlayer* pOriginalOwner = &GET_PLAYER(pCity->getOriginalOwner());
	bool bOriginalCapital =	pCity->getX() == pOriginalOwner->GetOriginalCapitalX() &&
	                        pCity->getY() == pOriginalOwner->GetOriginalCapitalY();

	if(!bIgnoreCapitals && bOriginalCapital)
	{
		return false;
	}

	// No razing of Holy Cities
	if (pCity->GetCityReligions()->IsHolyCityAnyReligion())
	{
		return false;
	}

	// No razing of cities with unique luxuries
	ResourceTypes eResource = pCity->plot()->getResourceType();
	if (eResource != NO_RESOURCE)
	{
		CvResourceInfo *pkResource = GC.getResourceInfo(eResource);
		if (pkResource && pkResource->GetRequiredCivilization() != NO_CIVILIZATION)
		{
			return false;
		}
	}

	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(pCity->getOwner());
		args->Push(pCity->GetID());

		bool bResult = false;
		if(LuaSupport::CallTestAll(pkScriptSystem, "CanRaze", args.get(), bResult))
		{
			// Check the result.
			if(bResult == false)
			{
				return false;
			}
		}
	}

	return true;
}


//	--------------------------------------------------------------------------------
void CvPlayer::raze(CvCity* pCity)
{
	char szBuffer[1024];
	const size_t lenBuffer = 1024;
	int iI;

	if(!canRaze(pCity))
	{
		return;
	}

	CvAssert(pCity->getOwner() == GetID());

	if(GetID() == GC.getGame().getActivePlayer())
	{
		sprintf_s(szBuffer, lenBuffer, GetLocalizedText("TXT_KEY_MISC_DESTROYED_CITY", pCity->getNameKey()).GetCString());
		GC.GetEngineUserInterface()->AddCityMessage(0, pCity->GetIDInfo(), GetID(), true, GC.getEVENT_MESSAGE_TIME(), szBuffer/*, "AS2D_CITYRAZE", MESSAGE_TYPE_MAJOR_EVENT, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_GREEN"), pCity->getX(), pCity->getY(), true, true*/);

	}

	for(iI = 0; iI < MAX_PLAYERS; iI++)
	{
		if(GET_PLAYER((PlayerTypes)iI).isAlive())
		{
			if(iI != GetID() && iI == GC.getGame().getActivePlayer())
			{
				if(pCity->isRevealed(GET_PLAYER((PlayerTypes)iI).getTeam(), false))
				{
					sprintf_s(szBuffer, lenBuffer, GetLocalizedText("TXT_KEY_MISC_CITY_HAS_BEEN_RAZED_BY", pCity->getNameKey(), getCivilizationDescriptionKey()).GetCString());
					GC.GetEngineUserInterface()->AddCityMessage(0, pCity->GetIDInfo(), ((PlayerTypes)iI), false, GC.getEVENT_MESSAGE_TIME(), szBuffer/*, "AS2D_CITYRAZED", MESSAGE_TYPE_MAJOR_EVENT, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), pCity->getX(), pCity->getY(), true, true*/);
				}
			}
		}
	}

	sprintf_s(szBuffer, lenBuffer, GetLocalizedText("TXT_KEY_MISC_CITY_RAZED_BY", pCity->getNameKey(), getCivilizationShortDescriptionKey()).GetCString());
	GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, GetID(), szBuffer, pCity->getX(), pCity->getY());

	pCity->SetIgnoreCityForHappiness(false);

	CalculateNetHappiness();

#if defined(MOD_BALANCE_CORE)
	if(pCity->IsNoWarmongerYet())
	{
		PlayerTypes eFormerOwner = pCity->getPreviousOwner();
		if(eFormerOwner != NO_PLAYER)
		{
			CvDiplomacyAIHelpers::ApplyWarmongerPenalties(GetID(), eFormerOwner, pCity->IsOriginalMajorCapital(), pCity);
			pCity->SetNoWarmonger(false);
		}
	}
#endif
	int iPopulationDrop = 1;
	iPopulationDrop *= (100 + GetPlayerTraits()->GetRazeSpeedModifier() + GetRazingSpeedBonus());
	iPopulationDrop /= 100;

	int iTurnsToRaze = pCity->getPopulation();
	if(iPopulationDrop > 0)
	{
		iTurnsToRaze = (iTurnsToRaze + iPopulationDrop - 1) / iPopulationDrop;
	}

	pCity->ChangeRazingTurns(iTurnsToRaze);

	DoUpdateNextPolicyCost();

	// Update City UI
	if(GetID() == GC.getGame().getActivePlayer())
	{
		GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::unraze(CvCity* pCity)
{
	if (GetPlayerTraits()->IsNoAnnexing())
	{
		pCity->DoCreatePuppet();
	}
	else
	{
		pCity->DoAnnex();
	}

	pCity->ChangeRazingTurns(-pCity->GetRazingTurns());

	DoUpdateNextPolicyCost();

	// Update City UI
	if(GetID() == GC.getGame().getActivePlayer())
	{
		GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
	}
}



//	--------------------------------------------------------------------------------
void CvPlayer::disband(CvCity* pCity)
{
	CvPlot* pPlot = pCity->plot();

	if(getNumCities() == 1)
	{
		setFoundedFirstCity(false);
	}

	GC.getGame().addDestroyedCityName(pCity->getNameKey());

	for(int eBuildingType = 0; eBuildingType < GC.getNumBuildingInfos(); eBuildingType++)
	{
		CvBuildingEntry* buildingInfo = GC.getBuildingInfo((BuildingTypes) eBuildingType);
		if(buildingInfo)
		{
			// if this building exists
			int iExists = pCity->GetCityBuildings()->GetNumRealBuilding((BuildingTypes) eBuildingType);
			int iPreferredPosition = buildingInfo->GetPreferredDisplayPosition();
			if(iPreferredPosition > 0)
			{
				auto_ptr<ICvCity1> pDllCity(new CvDllCity(pCity));

				if(iExists > 0)
				{
					// kill the wonder
					GC.GetEngineUserInterface()->AddDeferredWonderCommand(WONDER_REMOVED, pDllCity.get(), (BuildingTypes) eBuildingType, 0);
				}
				else
				{
					// else if we are currently in the process of building this wonder
					if(pCity->getProductionBuilding() == eBuildingType)
					{
						// kill the half built wonder
						if(isWorldWonderClass(buildingInfo->GetBuildingClassInfo()))
						{
							GC.GetEngineUserInterface()->AddDeferredWonderCommand(WONDER_REMOVED, pDllCity.get(), (BuildingTypes) eBuildingType, 0);
						}
					}
				}
			}
		}
	}

	{
		auto_ptr<ICvCity1> pkDllCity(new CvDllCity(pCity));
		gDLL->GameplayCitySetDamage(pkDllCity.get(), 0, pCity->getDamage());
		gDLL->GameplayCityDestroyed(pkDllCity.get(), NO_PLAYER);
	}

	pCity->kill();

	if(pPlot)
	{
		IDInfoVector currentUnits;
		if (pPlot->getUnits(&currentUnits) > 0)
		{
			for (IDInfoVector::const_iterator itr = currentUnits.begin(); itr != currentUnits.end(); ++itr)
			{
				CvUnit* pUnit = ::getUnit(*itr);

				if(pUnit && !pPlot->isValidDomainForLocation(*pUnit))
				{
					if (!pUnit->jumpToNearestValidPlot())
						pUnit->kill(false);
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Is a Particular Goody ID a valid Goody for a certain plot?
bool CvPlayer::canReceiveGoody(CvPlot* pPlot, GoodyTypes eGoody, CvUnit* pUnit) const
{
	CvCity* pCity;
	UnitTypes eUnit;
	bool bTechFound;
	int iI;

	Database::SingleResult kResult;
	CvGoodyInfo kGoodyInfo;
	const bool bResult = DB.SelectAt(kResult, "GoodyHuts", eGoody);
	DEBUG_VARIABLE(bResult);
	CvAssertMsg(bResult, "Cannot find goody info.");
	kGoodyInfo.CacheResult(kResult);

#if defined(MOD_EVENTS_GOODY_CHOICE)
	if (MOD_EVENTS_GOODY_CHOICE) {
		bool bPick = (pUnit && pUnit->isHasPromotion((PromotionTypes)GC.getPROMOTION_GOODY_HUT_PICKER()));
		int iUnit = pUnit ? pUnit->GetID() : -1;
		if (GAMEEVENTINVOKE_TESTANY(GAMEEVENT_GoodyHutCanNotReceive, GetID(), iUnit, eGoody, bPick) == GAMEEVENTRETURN_TRUE) {
			return false;
		}
	}
#endif

	if(!CvGoodyHuts::IsCanPlayerReceiveGoody(GetID(), eGoody))
	{
		return false;
	}

	// No XP in first 10 turns
	if(kGoodyInfo.getExperience() > 0)
	{
		if((pUnit == NULL) || !(pUnit->canAcquirePromotionAny()) || (GC.getGame().getElapsedGameTurns() < 10))
		{
			return false;
		}

		if (MOD_BALANCE_CORE_MINOR_CIV_GIFT && pUnit->IsGainsXPFromScouting())
			return false;
	}

	// Unit Healing
	if(kGoodyInfo.getDamagePrereq() > 0)
	{
		if((pUnit == NULL) || (pUnit->getDamage() < ((pUnit->GetMaxHitPoints() * kGoodyInfo.getDamagePrereq()) / 100)))
		{
			return false;
		}
	}

	// Early pantheon
	if(kGoodyInfo.isPantheonFaith())
	{
		if(GC.getGame().getElapsedGameTurns() < 20)
		{
			return false;
		}
		else
		{
			return (!GetReligions()->HasCreatedPantheon() && !GetReligions()->HasCreatedReligion());
		}
	}

	// Faith toward Great Prophet
	if(kGoodyInfo.getProphetPercent() > 0)
	{
		if(GC.getGame().getElapsedGameTurns() < 20)
		{
			return false;
		}
		else
		{
			return (GetReligions()->HasCreatedPantheon() && !GetReligions()->HasCreatedReligion());
		}
	}

	// Population
	if(kGoodyInfo.getPopulation() > 0)
	{
		if(getNumCities() == 0)
		{
			return false;
		}

		// Don't give more Population if we're already over our Pop limit
		if(IsEmpireUnhappy())
		{
			return false;
		}
	}
#if defined(MOD_BALANCE_CORE)
	//Golden Age
	if(kGoodyInfo.getGoldenAge() > 0)
	{
		if(GetNumGoldenAges() <= 0)
		{
			return false;
		}
	}
	//Free Tiles
	if(kGoodyInfo.getFreeTiles() > 0 && pPlot != NULL)
	{
		int iDistance;
		int iBestCityDistance = -1;
		CvCity* pBestCity = NULL;

		CvCity* pLoopCity;
		int iLoop;
		// Find the closest City to us to add a Pop point to
		for(pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
		{
			iDistance = plotDistance(pPlot->getX(), pPlot->getY(), pLoopCity->getX(), pLoopCity->getY());

			if(iBestCityDistance == -1 || iDistance < iBestCityDistance)
			{
				iBestCityDistance = iDistance;
				pBestCity = pLoopCity;
			}
		}

		if(pBestCity == NULL)
		{
			return false;
		}
	}
	if (kGoodyInfo.getMapRange() > 0 && kGoodyInfo.getMapOffset() > 0)
	{
		if (pUnit == NULL)
			return false;

		if (MOD_BALANCE_CORE_MINOR_CIV_GIFT && !pUnit->IsGainsXPFromScouting())
			return false;
	}
	if(pPlot == NULL && kGoodyInfo.getMapRange() > 0 && kGoodyInfo.getMapOffset() > 0)
	{
		return false;
	}
	if (pPlot != NULL && kGoodyInfo.getMapRange() > 0 && kGoodyInfo.getMapOffset() > 0)
	{
		bool bGood = false;
		int iOffset = kGoodyInfo.getMapOffset();
		int iDX, iDY;
		for(iDX = -(iOffset); iDX <= iOffset; iDX++)
		{
			for(iDY = -(iOffset); iDY <= iOffset; iDY++)
			{
				CvPlot* pLoopPlot = plotXYWithRangeCheck(pPlot->getX(), pPlot->getY(), iDX, iDY, iOffset);

				if(pLoopPlot != NULL)
				{
					if(!(pLoopPlot->isRevealed(getTeam())))
					{
						if(pLoopPlot->isCity() && pLoopPlot->getOwner() != GetID() && pLoopPlot->getOwner() != NO_PLAYER)
						{
							bGood = true;
							break;
						}
					}
				}
			}
		}
		if(!bGood)
		{
			return false;
		}
	}
#endif

	// Reveal Nearby Barbs
	if(kGoodyInfo.getRevealNearbyBarbariansRange() > 0)
	{
		int iDX, iDY;
		int iBarbCampDistance = kGoodyInfo.getRevealNearbyBarbariansRange();
		CvPlot* pNearbyPlot;

		int iNumCampsFound = 0;

		ImprovementTypes barbCampType = (ImprovementTypes) GC.getBARBARIAN_CAMP_IMPROVEMENT();

		// Look at nearby Plots to make sure another camp isn't too close
		for(iDX = -(iBarbCampDistance); iDX <= iBarbCampDistance; iDX++)
		{
			for(iDY = -(iBarbCampDistance); iDY <= iBarbCampDistance; iDY++)
			{
				pNearbyPlot = plotXY(pPlot->getX(), pPlot->getY(), iDX, iDY);

				if(pNearbyPlot != NULL)
				{
					if(plotDistance(pNearbyPlot->getX(), pNearbyPlot->getY(), pPlot->getX(), pPlot->getY()) <= iBarbCampDistance)
					{
						if(pNearbyPlot->getImprovementType() == barbCampType)
						{
							iNumCampsFound++;
						}
					}
				}
			}
		}

		// Needs to be at least 2 nearby Camps
		if(iNumCampsFound < 2)
		{
			return false;
		}
	}

	// Reveal Unknown Resource
	if(kGoodyInfo.isRevealUnknownResource())
	{
		// Can't get this if you have no Capital City
		if(getCapitalCity() == NULL)
		{
			return false;
		}

		CvResourceInfo* pResource;
		ResourceClassTypes eResourceClassBonus = (ResourceClassTypes) GC.getInfoTypeForString("RESOURCECLASS_BONUS");

		bool bPlayerDoesntKnowOfResource = false;

		int iNumResourceInfos = GC.getNumResourceInfos();
		for(int iResourceLoop = 0; iResourceLoop < iNumResourceInfos; iResourceLoop++)
		{
			pResource = GC.getResourceInfo((ResourceTypes) iResourceLoop);

			// No "Bonus" Resources (that only give Yield), because those are lame to get from a Hut
			if(pResource != NULL && pResource->getResourceClassType() != eResourceClassBonus)
			{
				if(!GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes) pResource->getTechReveal()))
				{
					bPlayerDoesntKnowOfResource = true;
				}
			}
		}

		// If the player already knows where all the Resources are then there's no point in this Goody
		if(!bPlayerDoesntKnowOfResource)
		{
			return false;
		}
	}

	// Unit Upgrade
	if(kGoodyInfo.isUpgradeUnit())
	{
		if(pUnit == NULL)
		{
			return false;
		}

		if(pUnit->IsHasBeenPromotedFromGoody())
		{
			return false;
		}

		UnitClassTypes eUpgradeUnitClass = (UnitClassTypes) GC.getUnitInfo(pUnit->getUnitType())->GetGoodyHutUpgradeUnitClass();

		if(eUpgradeUnitClass == NO_UNITCLASS)
		{
			return false;
		}

		UnitTypes eUpgradeUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eUpgradeUnitClass);

		if(eUpgradeUnit == NO_UNIT)
		{
			return false;
		}
	}

	// Tech
	if(kGoodyInfo.isTech())
	{
		bTechFound = false;

		int iNumTechInfos = GC.getNumTechInfos();
		for(iI = 0; iI < iNumTechInfos; iI++)
		{
			const TechTypes eTech = static_cast<TechTypes>(iI);
			CvTechEntry* pkTech = GC.getTechInfo(eTech);
			if(pkTech != NULL && pkTech->IsGoodyTech())
			{
				if(GetPlayerTechs()->CanResearch(eTech))
				{
#if defined(MOD_BALANCE_CORE)
					if(MOD_BALANCE_CORE && GetPlayerTechs()->GetCurrentResearch() != eTech)
					{
#endif
					bool bUseTech = true;
					ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
					if (pkScriptSystem) 
					{
						CvLuaArgsHandle args;
						args->Push(GetID());
						args->Push(eTech);

						// Attempt to execute the game events.
						// Will return false if there are no registered listeners.
						bool bScriptResult = false;
						if (LuaSupport::CallTestAll(pkScriptSystem, "GoodyHutCanResearch", args.get(), bScriptResult)) 
						{
							bUseTech = bResult;
						}
					}

					if(bUseTech)
					{
						bTechFound = true;
					}
					break;
#if defined(MOD_BALANCE_CORE)
					}
#endif
				}
			}
		}

		if(!bTechFound)
		{
			return false;
		}
	}

	///////////////////////////////////////
	///////////////////////////////////////
	// Bad Goodies follow beneath this line
	///////////////////////////////////////
	///////////////////////////////////////

	if(kGoodyInfo.isBad())
	{
		if((pUnit == NULL) || pUnit->isNoBadGoodies())
		{
			return false;
		}
	}

	if(kGoodyInfo.getUnitClassType() != NO_UNITCLASS)
	{
		eUnit = ((UnitTypes)(getCivilizationInfo().getCivilizationUnits(kGoodyInfo.getUnitClassType())));

		if(eUnit == NO_UNIT)
		{
			return false;
		}

		CvUnitEntry* pUnitInfo = GC.getUnitInfo(eUnit);
		if(pUnitInfo == NULL)
		{
			return false;
		}

		// No combat units in MP in the first 20 turns
		if(pUnitInfo->GetCombat() > 0)
		{
			if(GC.getGame().isGameMultiPlayer() || (GC.getGame().getElapsedGameTurns() < 20))
			{
				return false;
			}
		}

		// Builders
		if(pUnitInfo->GetWorkRate() > 0)
		{
			// Max limit
			if(GetMaxNumBuilders() > -1 && GetNumBuilders() >= GetMaxNumBuilders())
			{
				return false;
			}

			bool bHasTechWhichUnlocksImprovement = false;

			// Need a tech which unlocks something to do
			int iNumTechInfos = GC.getNumTechInfos();
			int iNumBuildInfos = GC.getNumBuildInfos();
			for(int iTechLoop = 0; iTechLoop < iNumTechInfos; iTechLoop++)
			{
				if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes) iTechLoop))
				{
					// Look at Builds
					for(int iBuildLoop = 0; iBuildLoop < iNumBuildInfos; iBuildLoop++)
					{
						CvBuildInfo* pkBuildInfo = GC.getBuildInfo((BuildTypes) iBuildLoop);
						if(!pkBuildInfo)
						{
							continue;
						}
						if(pkBuildInfo->getTechPrereq() == (TechTypes) iTechLoop)
						{
							if(pkBuildInfo->getImprovement() != NO_IMPROVEMENT || pkBuildInfo->getRoute() != NO_ROUTE)
							{
								bHasTechWhichUnlocksImprovement = true;
								break;
							}
						}
					}
				}
				// Already found something
				if(bHasTechWhichUnlocksImprovement)
				{
					break;
				}
			}

			// Player doesn't have any Tech which allows Improvements
			if(!bHasTechWhichUnlocksImprovement)
			{
				return false;
			}
		}

		// OCC games - no Settlers
		if(GetPlayerTraits()->IsNoAnnexing() || (GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && isHuman()))
		{
			if(pUnitInfo->IsFound() || pUnitInfo->IsFoundAbroad())
			{
				return false;
			}
		}
	}

	// Barbarians
	if(kGoodyInfo.getBarbarianUnitClass() != NO_UNITCLASS)
	{
		if(GC.getGame().isOption(GAMEOPTION_NO_BARBARIANS))
		{
			return false;
		}

		if(getNumCities() == 0)
		{
			return false;
		}

		if(getNumCities() == 1)
		{
			pCity = GC.getMap().findCity(pPlot->getX(), pPlot->getY(), NO_PLAYER, getTeam());

			if(pCity != NULL)
			{
				if(plotDistance(pPlot->getX(), pPlot->getY(), pCity->getX(), pCity->getY()) <= (8 - getNumCities()))
				{
					return false;
				}
			}
		}
	}

	return true;
}


//	--------------------------------------------------------------------------------
void CvPlayer::receiveGoody(CvPlot* pPlot, GoodyTypes eGoody, CvUnit* pUnit)
{
	CvPlot* pLoopPlot;
	CvPlot* pBestPlot = NULL;
	CvString strBuffer;
	CvString strTempBuffer;
	TechTypes eBestTech;
	UnitTypes eUnit;
	int iGold = 0;
	int iOffset;
	int iRange;
	int iBarbCount;
	int iValue;
	int iBestValue;
	int iPass;
	int iDX, iDY;
	int iI;

	int iEra = MOD_BALANCE_CORE_DIPLOMACY_ADVANCED ? GetCurrentEra() : 1;
	if (iEra <= 0)
		iEra = 1;

	CvAssertMsg(canReceiveGoody(pPlot, eGoody, pUnit), "Instance is expected to be able to recieve goody");

	Database::SingleResult kResult;
	CvGoodyInfo kGoodyInfo;
	const bool bResult = DB.SelectAt(kResult, "GoodyHuts", eGoody);
	DEBUG_VARIABLE(bResult);
	CvAssertMsg(bResult, "Cannot find goody info.");
	kGoodyInfo.CacheResult(kResult);

	CvGoodyHuts::DoPlayerReceivedGoody(GetID(), eGoody);

	strBuffer = kGoodyInfo.GetDescription();

	// Gold
	if (kGoodyInfo.getNumGoldRandRolls() > 0 && kGoodyInfo.getGoldRandAmount() > 0)
	{
		iGold = kGoodyInfo.getGold() + (kGoodyInfo.getNumGoldRandRolls() * GC.getGame().getSmallFakeRandNum(kGoodyInfo.getGoldRandAmount(), *pPlot));
	}

	int iGoodyModifier = pUnit != NULL ? pUnit->getUnitInfo().GetGoodyModifier() + pUnit->GetGoodyHutYieldBonus() : 0;

	if (iGoodyModifier != 0)
	{
		iGold *= (100 + iGoodyModifier);
		iGold /= 100;
	}
	if(iGold != 0)
	{
		iGold *= iEra;
		GetTreasury()->ChangeGold(iGold);
		changeInstantYieldValue(YIELD_GOLD, iGold);
		strBuffer += " ";
		strBuffer += GetLocalizedText("TXT_KEY_MISC_RECEIVED_GOLD", iGold);
	}

	// Population
	if(kGoodyInfo.getPopulation() > 0)
	{
		int iDistance;
		int iBestCityDistance = -1;
		CvCity* pBestCity = NULL;

		CvCity* pLoopCity;
		int iLoop;
		// Find the closest City to us to add a Pop point to
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			iDistance = plotDistance(pPlot->getX(), pPlot->getY(), pLoopCity->getX(), pLoopCity->getY());

			if(iBestCityDistance == -1 || iDistance < iBestCityDistance)
			{
				iBestCityDistance = iDistance;
				pBestCity = pLoopCity;
			}
		}

		int iPop = kGoodyInfo.getPopulation() * iEra;

		if(pBestCity != NULL)
		{
			pBestCity->changePopulation(iPop);
		}
	}
#if defined(MOD_BALANCE_CORE)
	// Production
	int iProduction = 0;
	if(MOD_BALANCE_CORE && kGoodyInfo.getProduction() > 0)
	{
		iProduction = kGoodyInfo.getProduction();
		iProduction *= GC.getGame().getGameSpeedInfo().getTrainPercent();
		iProduction /= 100;

		if (pUnit != NULL && iGoodyModifier != 0)
		{
			iProduction *= (100 + iGoodyModifier);
			iProduction /= 100;
		}

		iProduction *= iEra;

		int iDistance;
		int iBestCityDistance = -1;
		CvCity* pBestCity = NULL;

		CvCity* pLoopCity;
		int iLoop;
		// Find the closest City to us to add a Pop point to
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			iDistance = plotDistance(pPlot->getX(), pPlot->getY(), pLoopCity->getX(), pLoopCity->getY());

			if(iBestCityDistance == -1 || iDistance < iBestCityDistance)
			{
				iBestCityDistance = iDistance;
				pBestCity = pLoopCity;
			}
		}

		if(pBestCity != NULL)
		{
			pBestCity->changeProduction(iProduction);
			changeInstantYieldValue(YIELD_PRODUCTION, iProduction);
#if defined(MOD_BUGFIX_GOODY_HUT_MESSAGES)
			strBuffer += GetLocalizedText("TXT_KEY_GOODY_PRODUCTION", iProduction);
#endif
		}
	}
	// Golden Age Points
	int iGoldenAge = kGoodyInfo.getGoldenAge();
	if(iGoldenAge > 0 && GetNumGoldenAges() > 0)
	{
		// Game Speed Mod
		iGoldenAge *= GC.getGame().getGameSpeedInfo().getCulturePercent();
		iGoldenAge /= 100;

		if (pUnit != NULL && iGoodyModifier != 0)
		{
			iGoldenAge *= (100 + iGoodyModifier);
			iGoldenAge /= 100;
		}

		iGoldenAge *= iEra;

		ChangeGoldenAgeProgressMeter(iGoldenAge);

		changeInstantYieldValue(YIELD_GOLDEN_AGE_POINTS, iGoldenAge);
	}
	//Free Tiles
	int iFreeTiles = kGoodyInfo.getFreeTiles();
	if(iFreeTiles > 0)
	{
		int iDistance;
		int iBestCityDistance = -1;
		CvCity* pBestCity = NULL;

		CvCity* pLoopCity;
		int iLoop;
		// Find the closest City to us to add a Pop point to
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			iDistance = plotDistance(pPlot->getX(), pPlot->getY(), pLoopCity->getX(), pLoopCity->getY());

			if(iBestCityDistance == -1 || iDistance < iBestCityDistance)
			{
				iBestCityDistance = iDistance;
				pBestCity = pLoopCity;
			}
		}

		if(pBestCity != NULL)
		{

			if (pUnit != NULL && iGoodyModifier != 0)
			{
				iFreeTiles *= (100 + iGoodyModifier);
				iFreeTiles /= 100;
			}

			if(iFreeTiles > 0)
			{
				for (int i = 0; i < iFreeTiles; i++)
				{
					CvPlot* pPlotToAcquire = pBestCity->GetNextBuyablePlot(false);
					// maybe the player owns ALL of the plots or there are none available?
					if(pPlotToAcquire)
					{
						pBestCity->DoAcquirePlot(pPlotToAcquire->getX(), pPlotToAcquire->getY());
					}
				}
			}
		}
	}
#endif
	// Culture
	int iCulture = kGoodyInfo.getCulture();
	if(iCulture > 0)
	{
		// Game Speed Mod
		iCulture *= GC.getGame().getGameSpeedInfo().getCulturePercent();
		iCulture /= 100;

		if (pUnit != NULL && iGoodyModifier != 0)
		{
			iCulture *= (100 + iGoodyModifier);
			iCulture /= 100;
		}
#if defined(MOD_BALANCE_CORE_BARBARIAN_THEFT)
		if (MOD_BALANCE_CORE_BARBARIAN_THEFT)
		{
			iCulture *= max(1, (GetPlayerPolicies()->GetNumPoliciesOwned(true, true) / 2));
		}
#endif

		iCulture *= iEra;

		changeJONSCulture(iCulture);

#if defined(MOD_BUGFIX_GOODY_HUT_MESSAGES)
		strBuffer += " ";
		strBuffer += GetLocalizedText("TXT_KEY_MISC_RECEIVED_CULTURE", iCulture);
#endif

		changeInstantYieldValue(YIELD_CULTURE, iCulture);
	}

	// Faith
	int iFaith = kGoodyInfo.getFaith();
	if(iFaith > 0)
	{
		// Game Speed Mod
		iFaith *= GC.getGame().getGameSpeedInfo().getFaithPercent();
		iFaith /= 100;

		if (pUnit != NULL && iGoodyModifier != 0)
		{
			iFaith *= (100 + iGoodyModifier);
			iFaith /= 100;
		}

		iFaith *= iEra;

		ChangeFaith(iFaith);

		changeInstantYieldValue(YIELD_FAITH, iFaith);

#if defined(MOD_BUGFIX_GOODY_HUT_MESSAGES)
		strBuffer += " ";
		strBuffer += GetLocalizedText("TXT_KEY_MISC_RECEIVED_FAITH", iFaith);
#endif
	}

	// Faith for pantheon
	bool bPantheon = kGoodyInfo.isPantheonFaith();
	if(bPantheon)
	{
		// Enough so still get a pantheon if 3 civs pop this in same turn
		iFaith = GC.getGame().GetGameReligions()->GetMinimumFaithNextPantheon() + 2 * GC.getRELIGION_GAME_FAITH_DELTA_NEXT_PANTHEON();
		int iDivisor = /*10*/ GC.getGOLD_PURCHASE_VISIBLE_DIVISOR();
		iFaith /= iDivisor;
		iFaith *= iDivisor;

		if (pUnit != NULL && iGoodyModifier != 0)
		{
			iFaith *= (100 + iGoodyModifier);
			iFaith /= 100;
		}

		iFaith *= iEra;

		ChangeFaith(iFaith);

		changeInstantYieldValue(YIELD_FAITH, iFaith);

#if defined(MOD_BUGFIX_GOODY_HUT_MESSAGES)
		strBuffer += " ";
		strBuffer += GetLocalizedText("TXT_KEY_MISC_RECEIVED_FAITH", iFaith);
#endif
	}

	// Faith for percent of great prophet
	int iProphetPercent = kGoodyInfo.getProphetPercent();
	if(iProphetPercent > 0)
	{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
		iFaith = GetReligions()->GetCostNextProphet(false /*bIncludeBeliefDiscounts*/, true /*bAdjustForSpeedDifficulty*/, MOD_GLOBAL_TRULY_FREE_GP) * iProphetPercent / 100;
#else
		iFaith = GetReligions()->GetCostNextProphet(false /*bIncludeBeliefDiscounts*/, true /*bAdjustForSpeedDifficulty*/) * iProphetPercent / 100;
#endif
		int iDivisor = /*10*/ GC.getGOLD_PURCHASE_VISIBLE_DIVISOR();
		iFaith /= iDivisor;
		iFaith *= (iDivisor / 2);

		iFaith *= iEra;

		ChangeFaith(iFaith);

		changeInstantYieldValue(YIELD_FAITH, iFaith);

#if defined(MOD_BUGFIX_GOODY_HUT_MESSAGES)
		strBuffer += " ";
		strBuffer += GetLocalizedText("TXT_KEY_MISC_RECEIVED_FAITH", iFaith);
#endif
	}

	// Reveal Nearby Barbs
	if(kGoodyInfo.getRevealNearbyBarbariansRange() > 0)
	{
		// Look at nearby Plots to make sure another camp isn't too close
		const int iBarbCampDistance = kGoodyInfo.getRevealNearbyBarbariansRange();
		for(iDX = -(iBarbCampDistance); iDX <= iBarbCampDistance; iDX++)
		{
			for(iDY = -(iBarbCampDistance); iDY <= iBarbCampDistance; iDY++)
			{
				CvPlot* pNearbyBarbarianPlot = plotXY(pPlot->getX(), pPlot->getY(), iDX, iDY);
				if(pNearbyBarbarianPlot != NULL)
				{
					if(plotDistance(pNearbyBarbarianPlot->getX(), pNearbyBarbarianPlot->getY(), pPlot->getX(), pPlot->getY()) <= iBarbCampDistance)
					{
						if(pNearbyBarbarianPlot->getImprovementType() == GC.getBARBARIAN_CAMP_IMPROVEMENT())
						{
							// Reveal Plot
							pNearbyBarbarianPlot->setRevealed(getTeam(), true);
							// Reveal Barb Camp here
							pNearbyBarbarianPlot->setRevealedImprovementType(getTeam(), pNearbyBarbarianPlot->getImprovementType());
						}
					}
				}
			}
		}
	}

	// Map
	iRange = kGoodyInfo.getMapRange();

	if(iRange > 0)
	{
		iOffset = kGoodyInfo.getMapOffset();

		if(iOffset > 0)
		{
			iBestValue = 0;
			pBestPlot = NULL;

			int iRandLimit;

			for(iDX = -(iOffset); iDX <= iOffset; iDX++)
			{
				for(iDY = -(iOffset); iDY <= iOffset; iDY++)
				{
					pLoopPlot = plotXYWithRangeCheck(pPlot->getX(), pPlot->getY(), iDX, iDY, iOffset);

					if(pLoopPlot != NULL)
					{
						if(!(pLoopPlot->isRevealed(getTeam())))
						{
							// Avoid water plots!
#if defined(MOD_BALANCE_CORE)
							//Let's reveal cities instead.
							if(pLoopPlot->isCity() && pLoopPlot->getOwner() != GetID() && pLoopPlot->getOwner() != NO_PLAYER)
							{
								iRandLimit = 0;
								if(GET_PLAYER(pLoopPlot->getOwner()).isMajorCiv())
								{
									iRandLimit += 10000;
								}
								else if(GET_PLAYER(pLoopPlot->getOwner()).isMinorCiv())
								{
									iRandLimit += 1000;
								}

#else
							if(pPlot->isWater())
								iRandLimit = 10;
							else
								iRandLimit = 10000;
#endif
							iValue = (1 + GC.getGame().getSmallFakeRandNum(iRandLimit, *pLoopPlot));

							iValue *= plotDistance(pPlot->getX(), pPlot->getY(), pLoopPlot->getX(), pLoopPlot->getY());

							if(iValue > iBestValue)
							{
								iBestValue = iValue;
								pBestPlot = pLoopPlot;
							}
#if defined(MOD_BALANCE_CORE)
							}
#endif
						}
					}
				}
			}
		}

		if(pBestPlot == NULL)
		{
			pBestPlot = pPlot;
		}

		int iNumPlotsRevealed = 0;
		for(iDX = -(iRange); iDX <= iRange; iDX++)
		{
			for(iDY = -(iRange); iDY <= iRange; iDY++)
			{
				pLoopPlot = plotXY(pBestPlot->getX(), pBestPlot->getY(), iDX, iDY);

				if(pLoopPlot != NULL)
				{
					if(plotDistance(pBestPlot->getX(), pBestPlot->getY(), pLoopPlot->getX(), pLoopPlot->getY()) <= iRange)
					{
						if(GC.getGame().getSmallFakeRandNum(100, *pLoopPlot) < kGoodyInfo.getMapProb())
						{
							pLoopPlot->setRevealed(getTeam(), true);
							iNumPlotsRevealed++;
						}
					}
				}
			}
		}
		if (pUnit != NULL && pUnit->IsGainsXPFromScouting())
		{
#if defined(MOD_UNITS_XP_TIMES_100)
			pUnit->changeExperienceTimes100(iNumPlotsRevealed * 100);
#else
			pUnit->changeExperience(iNumPlotsRevealed);
#endif
		}
	}

	// Experience
	if(pUnit != NULL)
	{
#if defined(MOD_UNITS_XP_TIMES_100)
		int iExperience = kGoodyInfo.getExperience() * 100;
		if (pUnit != NULL && iGoodyModifier  != 0)
		{
			iExperience *= (100 + iGoodyModifier);
			iExperience /= 100;
		}
		pUnit->changeExperienceTimes100(iExperience);
#else
		int iExperience = kGoodyInfo.getExperience();
		if (pUnit != NULL && iGoodyModifier != 0)
		{
			iExperience *= (100 + iGoodyModifier);
			iExperience /= 100;
		}
		pUnit->changeExperience(iExperience;
#endif
	}

	// Unit Heal
	if(pUnit != NULL)
	{
		pUnit->changeDamage(-(kGoodyInfo.getHealing()));
	}

	// Reveal Unknown Resource
	if(kGoodyInfo.isRevealUnknownResource())
	{
		if(getCapitalCity() != NULL)
		{
			CvCity* pCapital = getCapitalCity();

			CvPlot* pResourcePlot;
			int iResourceDistance;
			TechTypes eRevealTech;
			int iResourceCost;
			int iBestResourceCost = -1;
			ResourceTypes eResource;
			ResourceTypes eBestResource = NO_RESOURCE;
			CvPlot* pBestResourcePlot = NULL;

			ResourceClassTypes eResourceClassBonus;

			// Look at Resources on all Plots
			for(int iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)
			{
				pResourcePlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);
				eResource = pResourcePlot->getResourceType();

				if(eResource != NO_RESOURCE)
				{
					CvResourceInfo& pResource = *GC.getResourceInfo(eResource);
					eResourceClassBonus = (ResourceClassTypes) GC.getInfoTypeForString("RESOURCECLASS_BONUS");

					// No "Bonus" Resources (that only give Yield), because those are lame to get from a Hut
					if(pResource.getResourceClassType() != eResourceClassBonus)
					{
						// Can't be on a Plot that we've already force-revealed!
						if(!pResourcePlot->IsResourceForceReveal(getTeam()))
						{
							// Must be a Resource we don't already see
							eRevealTech = (TechTypes) pResource.getTechReveal();
							if(!GET_TEAM(getTeam()).GetTeamTechs()->HasTech(eRevealTech))
							{
								iResourceDistance = plotDistance(pResourcePlot->getX(), pResourcePlot->getY(), pCapital->getX(), pCapital->getY());

								// Must be within 10 plots of our Capital
								if(iResourceDistance <= 10)
								{
									iResourceCost = GC.getTechInfo(eRevealTech)->GetResearchCost();

									// Find the one with the cheapest Tech (or pick one if we haven't identified one yet)
									if(iBestResourceCost == -1 || iResourceCost < iBestResourceCost)
									{
										iBestResourceCost = iResourceCost;
										eBestResource = eResource;
										pBestResourcePlot = pResourcePlot;
									}
								}
							}
						}
					}
				}
			}

			CvAssert(pBestResourcePlot);

			// Did we find something to show?
			if(pBestResourcePlot != NULL)
			{
				pBestResourcePlot->setRevealed(getTeam(), true);
				pBestResourcePlot->SetResourceForceReveal(getTeam(), true);
				//pBestPlot->updateFog();

				if(getTeam() == GC.getGame().getActiveTeam())
				{
					pBestResourcePlot->setLayoutDirty(true);
				}

				// Also reveal adjacent Plots
				CvPlot* pAdjacentPlot;
				for(int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; iDirectionLoop++)
				{
					pAdjacentPlot = plotDirection(pBestResourcePlot->getX(), pBestResourcePlot->getY(), ((DirectionTypes) iDirectionLoop));

					if(pAdjacentPlot != NULL)
					{
						pAdjacentPlot->setRevealed(getTeam(), true);
					}
				}

				CvString strTempString;
				strTempString.Format(" (%s)", GC.getResourceInfo(eBestResource)->GetDescription());
				strBuffer += strTempString;
			}
		}
	}

	// Unit Upgrade
	if(kGoodyInfo.isUpgradeUnit())
	{
		UnitClassTypes eUpgradeUnitClass = NO_UNITCLASS;
		UnitTypes eUpgradeUnit = NO_UNIT;

		if(pUnit != NULL)
		{
			eUpgradeUnitClass = (UnitClassTypes) pUnit->getUnitInfo().GetGoodyHutUpgradeUnitClass();
			eUpgradeUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eUpgradeUnitClass);
		}
		
		if(eUpgradeUnit != NO_UNIT)
		{
			// Add new upgrade Unit

			// if we promoted an scouting unit from a goody hut, turn him into whatever the new unit's default AI is if it is not a suitable explorer anymore
			UnitAITypes currentAIDefault = pUnit->AI_getUnitAIType();
			UnitAITypes newAIDefault = GC.getUnitInfo(eUpgradeUnit)->GetDefaultUnitAIType();
			if(currentAIDefault == UNITAI_EXPLORE)
			{
				if(newAIDefault == UNITAI_EXPLORE || newAIDefault == UNITAI_ATTACK || newAIDefault == UNITAI_DEFENSE || newAIDefault == UNITAI_FAST_ATTACK || newAIDefault == UNITAI_COUNTER)
				{
					newAIDefault = UNITAI_EXPLORE;
				}
			}

			CvUnit* pNewUnit = initUnit(eUpgradeUnit, pPlot->getX(), pPlot->getY(), newAIDefault, NO_DIRECTION, false, false, 0, pUnit->GetNumGoodyHutsPopped());
			pUnit->finishMoves();
			pUnit->SetBeenPromotedFromGoody(true);

			CvAssert(pNewUnit);
			if (pNewUnit != NULL)
			{
#if defined(MOD_EVENTS_UNIT_UPGRADES)
			// MUST call the event before convert() as that kills the old unit
			if (MOD_EVENTS_UNIT_UPGRADES) {
				GAMEEVENTINVOKE_HOOK(GAMEEVENT_UnitUpgraded, GetID(), pUnit->GetID(), pNewUnit->GetID(), true);
			} else {
#endif
				ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
				if (pkScriptSystem)
				{
					CvLuaArgsHandle args;
					args->Push(GetID());
					args->Push(pUnit->GetID());
					args->Push(pNewUnit->GetID());
					args->Push(true); // bGoodyHut

					bool bScriptResult;
					LuaSupport::CallHook(pkScriptSystem, "UnitUpgraded", args.get(), bScriptResult);
				}
#if defined(MOD_EVENTS_UNIT_UPGRADES)
			}
#endif

				pNewUnit->convert(pUnit, true);
				pNewUnit->setupGraphical();
			}
			else
				pUnit->kill(false);

			// Since the old unit died, it will block the goody reward popup unless we call this
			GC.GetEngineUserInterface()->SetDontShowPopups(false);
		}
	}

	// Tech
	if(kGoodyInfo.isTech())
	{
		iBestValue = 0;
		eBestTech = NO_TECH;

		for(iI = 0; iI < GC.getNumTechInfos(); iI++)
		{
			const TechTypes eTech = static_cast<TechTypes>(iI);
			CvTechEntry* pkTech = GC.getTechInfo(eTech);
			if(pkTech != NULL && pkTech->IsGoodyTech())
			{
				if(GetPlayerTechs()->CanResearch(eTech))
				{
					bool bUseTech = true;

#if defined(MOD_EVENTS_GOODY_TECH)
					if (MOD_EVENTS_GOODY_TECH) {
						if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_GoodyHutCanResearch, GetID(), iI) == GAMEEVENTRETURN_FALSE) {
							bUseTech = false;
						}
					} else {
#endif
					ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
					if (pkScriptSystem)
					{
						CvLuaArgsHandle args;
						args->Push(GetID());
						args->Push(eTech);

						// Attempt to execute the game events.
						// Will return false if there are no registered listeners.
						bool bScriptResult = false;
						if (LuaSupport::CallTestAll(pkScriptSystem, "GoodyHutCanResearch", args.get(), bScriptResult))
						{
							bUseTech = bScriptResult;
						}
					}
#if defined(MOD_EVENTS_GOODY_TECH)
					}
#endif
#if defined(MOD_BALANCE_CORE)
					//Are we already researching a tech? No value here.
					if(MOD_BALANCE_CORE && GetPlayerTechs()->GetCurrentResearch() == eTech)
					{
						bUseTech = false;
					}
#endif
					if(bUseTech)
					{
						iValue = (1 + GC.getGame().getSmallFakeRandNum(10, iI));

						if(iValue > iBestValue)
						{
							iBestValue = iValue;
							eBestTech = eTech;
						}
					}
				}
			}
		}

		CvAssertMsg(eBestTech != NO_TECH, "BestTech is not assigned a valid value");

#if defined(MOD_EVENTS_GOODY_TECH)
		if (MOD_EVENTS_GOODY_TECH) {
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_GoodyHutTechResearched, GetID(), eBestTech);
		} else {
#endif
		ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
		if (pkScriptSystem) 
		{
			CvLuaArgsHandle args;
			args->Push(GetID());
			args->Push(eBestTech);

			bool bScriptResult;
			LuaSupport::CallHook(pkScriptSystem, "GoodyHutTechResearched", args.get(), bScriptResult);
		}
#if defined(MOD_EVENTS_GOODY_TECH)
		}
#endif

		GET_TEAM(getTeam()).setHasTech(eBestTech, true, GetID(), true, true);
		GET_TEAM(getTeam()).GetTeamTechs()->SetNoTradeTech(eBestTech, true);
	}

	// Units
	if(kGoodyInfo.getUnitClassType() != NO_UNITCLASS)
	{
		eUnit = (UnitTypes)getCivilizationInfo().getCivilizationUnits(kGoodyInfo.getUnitClassType());

		if(eUnit != NO_UNIT)
		{
			CvUnit* pNewUnit = initUnit(eUnit, pPlot->getX(), pPlot->getY());
			// see if there is an open spot to put him - no over-stacking allowed!
			if(pNewUnit && pUnit && pUnit->AreUnitsOfSameType(*pNewUnit))  // pUnit isn't in this plot yet (if it even exists) so we can't check on if we are over-stacked directly
			{
				pBestPlot = NULL;
				iBestValue = INT_MAX;
				const int iPopRange = 2;
				for(iDX = -(iPopRange); iDX <= iPopRange; iDX++)
				{
					for(iDY = -(iPopRange); iDY <= iPopRange; iDY++)
					{
						pLoopPlot	= plotXYWithRangeCheck(pPlot->getX(), pPlot->getY(), iDX, iDY, iPopRange);
						if(pLoopPlot != NULL)
						{
							if(pLoopPlot->isValidDomainForLocation(*pNewUnit) && pNewUnit->isMatchingDomain(pLoopPlot))
							{
								if(pNewUnit->canMoveInto(*pLoopPlot))
								{
#if defined(MOD_GLOBAL_STACKING_RULES)
									if(pLoopPlot->getMaxFriendlyUnitsOfType(pUnit) < pLoopPlot->getUnitLimit())
#else
									if(pLoopPlot->getMaxFriendlyUnitsOfType(pUnit) < GC.getPLOT_UNIT_LIMIT())
#endif
									{
										if(pNewUnit->canEnterTerritory(pLoopPlot->getTeam()) && !pNewUnit->isEnemy(pLoopPlot->getTeam(), pLoopPlot))
										{
											if((pNewUnit->getDomainType() != DOMAIN_AIR) || pLoopPlot->isFriendlyCity(*pNewUnit, true))
											{
												if(pLoopPlot->isRevealed(getTeam()))
												{
													iValue = 1 + GC.getGame().getSmallFakeRandNum(6, *pLoopPlot); // okay, I'll admit it, not a great heuristic

													if(plotDistance(pPlot->getX(),pPlot->getY(),pLoopPlot->getX(),pLoopPlot->getY()) > 1)
													{
														iValue += 12;
													}

													if(pLoopPlot->area() != pPlot->area())  // jumped to a different land mass, cool
													{
														iValue *= 10;
													}

													if(iValue < iBestValue)
													{
														iBestValue = iValue;
														pBestPlot = pLoopPlot;
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				if(pBestPlot != NULL)
				{
					bool bVis = pBestPlot->isVisibleToWatchingHuman();
					pNewUnit->setXY(pBestPlot->getX(), pBestPlot->getY(), false, true, true && bVis, true);
					pNewUnit->SetPosition(pBestPlot);	// Need this to put the unit in the right spot graphically
					pNewUnit->finishMoves();
				}
				else
				{
					pNewUnit->kill(false);
				}
			}
		}
	}

	// Barbarians
	if(kGoodyInfo.getBarbarianUnitClass() != NO_UNITCLASS)
	{
		iBarbCount = 0;

		eUnit = (UnitTypes)GET_PLAYER(BARBARIAN_PLAYER).getCivilizationInfo().getCivilizationUnits(kGoodyInfo.getBarbarianUnitClass());

		if(eUnit != NO_UNIT)
		{
			for(iPass = 0; iPass < 10; iPass++)
			{
				if(iBarbCount < kGoodyInfo.getMinBarbarians())
				{
					for(iI = 0; iI < NUM_DIRECTION_TYPES; iI++)
					{
						pLoopPlot = plotDirection(pPlot->getX(), pPlot->getY(), ((DirectionTypes)iI));

						if(pLoopPlot != NULL)
						{
							if(pLoopPlot->getArea() == pPlot->getArea())
							{
								if(pLoopPlot->isValidMovePlot(GetID()) && !pLoopPlot->isCity())
								{
									if(pLoopPlot->getNumUnits() == 0)
									{
										if((iPass > 0) || (GC.getGame().getSmallFakeRandNum(10, *pLoopPlot) * 10 < kGoodyInfo.getBarbarianUnitProb()))
										{
											GET_PLAYER(BARBARIAN_PLAYER).initUnit(eUnit, pLoopPlot->getX(), pLoopPlot->getY(), ((pLoopPlot->isWater()) ? UNITAI_ATTACK_SEA : UNITAI_ATTACK));
											iBarbCount++;

											if((iPass > 0) && (iBarbCount == kGoodyInfo.getMinBarbarians()))
											{
												break;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if(!strBuffer.empty() && GC.getGame().getActivePlayer() == GetID())
	{
		GC.GetEngineUserInterface()->AddPlotMessage(0, pPlot->GetPlotIndex(), GetID(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer);
	}

	// If it's the active player then show the popup
	if(GetID() == GC.getGame().getActivePlayer())
	{
		GC.getMap().updateDeferredFog();

		bool bDontShowRewardPopup = GC.GetEngineUserInterface()->IsOptionNoRewardPopups();

		// Don't show in MP, or if the player has turned it off
#if defined(MOD_API_EXTENSIONS)
		if(!GC.getGame().isReallyNetworkMultiPlayer() && !bDontShowRewardPopup)
#else
		if(!GC.getGame().isNetworkMultiPlayer() && !bDontShowRewardPopup)	// KWG: Candidate for !GC.getGame().isOption(GAMEOPTION_SIMULTANEOUS_TURNS)
#endif
		{
			int iSpecialValue = 0;

			if(iGold > 0)
				iSpecialValue = iGold;
			else if(iCulture > 0)
				iSpecialValue = iCulture;
			else if(iFaith > 0)
				iSpecialValue = iFaith;
#if defined(MOD_BALANCE_CORE)
			else if(iProduction > 0)
				iSpecialValue = iProduction;
#endif

			CvPopupInfo kPopupInfo(BUTTONPOPUP_GOODY_HUT_REWARD, eGoody, iSpecialValue);
			GC.GetEngineUserInterface()->AddPopup(kPopupInfo);
			// We are adding a popup that the player must make a choice in, make sure they are not in the end-turn phase.
			CancelActivePlayerEndTurn();
		}
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::doGoody(CvPlot* pPlot, CvUnit* pUnit)
{
	const CvHandicapInfo& playerHandicapInfo = getHandicapInfo();

	GoodyTypes eGoody;

	CvAssertMsg(pPlot->isGoody(), "pPlot->isGoody is expected to be true");

	if(!isBarbarian())
	{
		m_bEverPoppedGoody = true;
		pPlot->removeGoody();

		// Minors don't get Goodies :(
		if(isMinorCiv())
		{
			return;
		}

		// Need to have Goodies in the Handicap file to pick from
		if(playerHandicapInfo.getNumGoodies() > 0)
		{
			// Make a list of valid Goodies to pick randomly from
			int iValidGoodiesLoop;
			bool bValid;

			std::vector<GoodyTypes> avValidGoodies;
			for(int iGoodyLoop = 0; iGoodyLoop < playerHandicapInfo.getNumGoodies(); iGoodyLoop++)
			{
				eGoody = (GoodyTypes) playerHandicapInfo.getGoodies(iGoodyLoop);
				bValid = false;

				// Check to see if we've already verified this Goody is valid (since there can be multiples in the vector)
				for(iValidGoodiesLoop = 0; iValidGoodiesLoop < (int) avValidGoodies.size(); iValidGoodiesLoop++)
				{
					if(avValidGoodies[iValidGoodiesLoop] == eGoody)
					{
						avValidGoodies.push_back(eGoody);
						bValid = true;
						break;
					}
				}

				if(bValid)
					continue;

				if(canReceiveGoody(pPlot, eGoody, pUnit))
				{
					avValidGoodies.push_back(eGoody);
				}
			}

#if defined(MOD_GLOBAL_ANYTIME_GOODY_GOLD)
			// Any valid Goodies?  If not, add back the gold goody hut(s)
			if(MOD_GLOBAL_ANYTIME_GOODY_GOLD && avValidGoodies.size() == 0)
			{
				for(int iGoodyLoop = 0; iGoodyLoop < playerHandicapInfo.getNumGoodies(); iGoodyLoop++)
				{
					eGoody = (GoodyTypes) playerHandicapInfo.getGoodies(iGoodyLoop);

					Database::SingleResult kResult;
					const bool bResult = DB.SelectAt(kResult, "GoodyHuts", eGoody);
					DEBUG_VARIABLE(bResult);
					CvAssertMsg(bResult, "Cannot find goody info.");

					CvGoodyInfo kGoodyInfo;
					kGoodyInfo.CacheResult(kResult);

					if (kGoodyInfo.getGold() > 0)
					{
						avValidGoodies.push_back(eGoody);
					}
				}
			}
#endif

			// Any valid Goodies?
			if(avValidGoodies.size() > 0)
			{
#if defined(MOD_BUGFIX_MINOR)
				// Fix the bug where the AI won't get anything for Goody Hut pickers!!!
				if (pUnit && pUnit->isHasPromotion((PromotionTypes)GC.getPROMOTION_GOODY_HUT_PICKER()) && GET_PLAYER(pUnit->getOwner()).isHuman())
#else
				if (pUnit && pUnit->isHasPromotion((PromotionTypes)GC.getPROMOTION_GOODY_HUT_PICKER()))
#endif
				{
					if (GC.getGame().getActivePlayer() == GetID())

					{
						CvPopupInfo kPopupInfo(BUTTONPOPUP_CHOOSE_GOODY_HUT_REWARD, GetID(), pUnit->GetID());
						GC.GetEngineUserInterface()->AddPopup(kPopupInfo);
						// We are adding a popup that the player must make a choice in, make sure they are not in the end-turn phase.
#if defined(MOD_BUGFIX_MINOR)
						if (!GC.getGame().isReallyNetworkMultiPlayer())
						{
							CancelActivePlayerEndTurn();
						}
#else
						CancelActivePlayerEndTurn();
#endif
					}
				}
				else
				{
#if defined(MOD_CORE_REDUCE_RANDOMNESS)
					int iRand = GC.getGame().getSmallFakeRandNum(avValidGoodies.size(),*pPlot);
#else
					int iRand = GC.getGame().getJonRandNum(avValidGoodies.size(), "Picking a Goody result");
#endif
					eGoody = (GoodyTypes) avValidGoodies[iRand];
					receiveGoody(pPlot, eGoody, pUnit);
#if defined(MOD_EVENTS_GOODY_CHOICE)
					if (MOD_EVENTS_GOODY_CHOICE)
						//   GameEvents.GoodyHutReceivedBonus.Add(function(iPlayer, iUnit, eGoody, iX, iY) end)
						GAMEEVENTINVOKE_HOOK(GAMEEVENT_GoodyHutReceivedBonus, GetID(), pUnit ? pUnit->GetID() : -1, eGoody, pPlot->getX(), pPlot->getY());
#endif
				}
				
#if !defined(NO_ACHIEVEMENTS)
				if (pUnit && isHuman() && !GC.getGame().isGameMultiPlayer())
				{
					pUnit->ChangeNumGoodyHutsPopped(pUnit->GetNumGoodyHutsPopped() + 1);
					if (pUnit->isHasPromotion((PromotionTypes)GC.getPROMOTION_GOODY_HUT_PICKER()) && pUnit->GetNumGoodyHutsPopped() >= 5)
					{
						gDLL->UnlockAchievement(ACHIEVEMENT_XP2_25);
					}
				}
#endif
			}

			pPlot->AddArchaeologicalRecord(CvTypes::getARTIFACT_ANCIENT_RUIN(), m_eID, NO_PLAYER);
		}
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::AwardFreeBuildings(CvCity* pCity)
{
	int iNumFreeCultureBuildings = GetNumCitiesFreeCultureBuilding();
	if(iNumFreeCultureBuildings > 0)
	{
		BuildingTypes eBuilding = pCity->ChooseFreeCultureBuilding();
		if(eBuilding != NO_BUILDING)
		{
			pCity->GetCityBuildings()->SetNumFreeBuilding(eBuilding, 1);
		}
		else
		{
			pCity->SetOwedCultureBuilding(true);
		}

		ChangeNumCitiesFreeCultureBuilding(-1);
	}

	int iNumFreeFoodBuildings = GetNumCitiesFreeFoodBuilding();
	if(iNumFreeFoodBuildings > 0)
	{
		BuildingTypes eBuilding = pCity->ChooseFreeFoodBuilding();
		if(eBuilding != NO_BUILDING)
		{
			pCity->GetCityBuildings()->SetNumFreeBuilding(eBuilding, 1);
		}
#if defined(MOD_BUGFIX_FREE_FOOD_BUILDING)
		else
		{
			pCity->SetOwedFoodBuilding(true);
		}
#endif

		ChangeNumCitiesFreeFoodBuilding(-1);
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNoSettling(int iPlotIndex)
{
	m_noSettlingPlots.insert(iPlotIndex);
}
bool CvPlayer::IsNoSettling(int iPlotIndex) const
{
	return m_noSettlingPlots.find(iPlotIndex)!= m_noSettlingPlots.end();
}
void CvPlayer::ClearNoSettling()
{
	m_noSettlingPlots.clear();
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canFound(int iX, int iY) const
{
	return canFound(iX,iY,false,false,NULL);
}

bool CvPlayer::canFound(int iX, int iY, bool bIgnoreDistanceToExistingCities, bool bIgnoreHappiness, const CvUnit* pUnit) const
{
	CvPlot* pPlot = GC.getMap().plot(iX, iY);

#if defined(MOD_EVENTS_CITY_FOUNDING)
	if (MOD_EVENTS_CITY_FOUNDING) {
		if (GAMEEVENTINVOKE_TESTANY(GAMEEVENT_PlayerCanFoundCityRegardless, GetID(), iX, iY) == GAMEEVENTRETURN_TRUE) {
			return true;
		}
	}
#endif

#if defined(MOD_EVENTS_CITY_FOUNDING)
	if (MOD_EVENTS_CITY_FOUNDING) {
		if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_PlayerCanFoundCity, GetID(), iX, iY) == GAMEEVENTRETURN_FALSE) {
			return false;
		}
	}
#endif

	// Has the AI agreed to not settle here?
	if(IsNoSettling(pPlot->GetPlotIndex()))
		return false;

	// Haxor for Venice to prevent secondary founding
	if (GetPlayerTraits()->IsNoAnnexing() && getCapitalCity())
	{
		return false;
	}

	// Settlers cannot found cities while empire is very unhappy
	if(!bIgnoreHappiness && IsEmpireVeryUnhappy())
		return false;

	return GC.getGame().GetSettlerSiteEvaluator()->CanFound(pPlot, this, bIgnoreDistanceToExistingCities, pUnit);
}

//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_RELIGIOUS_SETTLERS) && defined(MOD_BALANCE_CORE)
void CvPlayer::found(int iX, int iY, ReligionTypes eReligion, bool bForce, CvUnitEntry* pkSettlerUnitEntry)
#elif defined(MOD_GLOBAL_RELIGIOUS_SETTLERS)
void CvPlayer::found(int iX, int iY, ReligionTypes eReligion, bool bForce)
#elif defined(MOD_BALANCE_CORE)
void CvPlayer::found(int iX, int iY, CvUnitEntry* pkSettlerUnitEntry = NULL)
#else
void CvPlayer::found(int iX, int iY)
#endif
{
	if(!bForce && !canFound(iX, iY))
	{
		return;
	}

	SetTurnsSinceSettledLastCity(0);

#if defined(MOD_GLOBAL_RELIGIOUS_SETTLERS) && defined(MOD_API_EXTENSIONS) && defined(MOD_BALANCE_CORE)
	CvCity* pCity = initCity(iX, iY, true, true, eReligion, NULL, pkSettlerUnitEntry);
#elif defined(MOD_GLOBAL_RELIGIOUS_SETTLERS) && defined(MOD_API_EXTENSIONS)
	CvCity* pCity = initCity(iX, iY, true, true, eReligion);
#elif defined(MOD_BALANCE_CORE)
	CvCity* pCity = initCity(iX, iY, pkSettlerUnitEntry);
#else
	CvCity* pCity = initCity(iX, iY);
#endif
	CvAssertMsg(pCity != NULL, "City is not assigned a valid value");
	if(pCity == NULL)
		return;

	int iExtraTerritoryClaim = GetPlayerTraits()->GetExtraFoundedCityTerritoryClaimRange();
	for (int i = 0; i < iExtraTerritoryClaim; i++)
	{
		CvPlot* pPlotToAcquire = pCity->GetNextBuyablePlot(false);

		// maybe the player owns ALL of the plots or there are none available?
		if(pPlotToAcquire)
		{
			pCity->DoAcquirePlot(pPlotToAcquire->getX(), pPlotToAcquire->getY());
		}
	}
#if defined(MOD_BALANCE_CORE)
	if(MOD_BALANCE_CORE && !isMinorCiv() && (GetNumCitiesFounded() <= 1))
	{
		if(GetPlayerTraits()->IsPopulationBoostReligion())
		{
			int iFaith = GC.getGame().GetGameReligions()->GetMinimumFaithNextPantheon();
			SetFaith(iFaith);
			if(GC.getGame().GetGameReligions()->CanCreatePantheon(GetID(), true) == 0)
			{
				// Create the pantheon
				if(isHuman())
				{
					//If the player is human then a net message will be received which will pick the pantheon.
					CvNotifications* pNotifications = GetNotifications();
					if(pNotifications)
					{
						CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_ENOUGH_FAITH_FOR_PANTHEON");

						CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_ENOUGH_FAITH_FOR_PANTHEON");
						pNotifications->Add(NOTIFICATION_FOUND_PANTHEON, strBuffer, strSummary, -1, -1, -1);
					}
				}
				else
				{
	#if defined(MOD_EVENTS_ACQUIRE_BELIEFS)
					const BeliefTypes eBelief = GetReligionAI()->ChoosePantheonBelief(GetID());
	#else
					const BeliefTypes eBelief = owningPlayer.GetReligionAI()->ChoosePantheonBelief();
	#endif

					GC.getGame().GetGameReligions()->FoundPantheon(GetID(), eBelief);
				}
			}
		}
	}
#endif
	for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
	{
		const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iI);
		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
		if(pkBuildingClassInfo)
		{
			const BuildingTypes eLoopBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(iI)));
			if(eLoopBuilding != NO_BUILDING)
			{
				CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eLoopBuilding);
				if(pkBuildingInfo)
				{
					if(pkBuildingInfo->GetFreeStartEra() != NO_ERA)
					{
						if(GC.getGame().getStartEra() >= pkBuildingInfo->GetFreeStartEra())
						{
							if(pCity->canConstruct(eLoopBuilding))
							{
								pCity->GetCityBuildings()->SetNumRealBuilding(eLoopBuilding, 1);

#if defined(MOD_EVENTS_CITY)
								if (MOD_EVENTS_CITY)
								{
									GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityConstructed, pCity->getOwner(), pCity->GetID(), eLoopBuilding, false, false);
								}
#endif
							}
						}
					}
				}
			}
		}
	}

	AwardFreeBuildings(pCity);

	DoUpdateNextPolicyCost();

	if(isHuman() && getAdvancedStartPoints() < 0)
	{
		// Human player is prompted to choose production BEFORE the AI runs for the turn.
		// So we'll force the AI strategies on the city now, just after it is founded.
		// And if the very first turn, we haven't even run player strategies once yet, so do that too.
		if(GC.getGame().getGameTurn() == 0)
		{
			this->GetEconomicAI()->DoTurn();
			this->GetMilitaryAI()->DoTurn();
			this->GetReligionAI()->DoTurn();
			this->GetEspionageAI()->DoTurn();
			this->GetTradeAI()->DoTurn();
		}
		pCity->GetCityStrategyAI()->DoTurn();
		pCity->chooseProduction();
		pCity->doFoundMessage();

		// If this is the first city (or we still aren't getting tech for some other reason notify the player)
		if(GetPlayerTechs()->GetCurrentResearch() == NO_TECH && GetScienceTimes100() > 0)
		{
			if(GetID() == GC.getGame().getActivePlayer())
			{
				chooseTech();
			}
		}
	}
	else
	{
		pCity->doFoundMessage();

		// AI civ, may need to redo city specializations
		GetCitySpecializationAI()->SetSpecializationsDirty(SPECIALIZATION_UPDATE_CITY_FOUNDED);
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(pCity->getX());
		args->Push(pCity->getY());
		
		bool bResult;
		LuaSupport::CallHook(pkScriptSystem, "PlayerCityFounded", args.get(), bResult);
	}
}

#if defined(MOD_BALANCE_CORE_SETTLER)
void CvPlayer::cityBoost(int iX, int iY, CvUnitEntry* pkUnitEntry, int iExtraPlots, int iPopChange, int iFoodPercent)
{
	//Advanced Settler Buildings
	if(pkUnitEntry && !isMinorCiv() && !isBarbarian())
	{
		CvPlot* pPlot = GC.getMap().plot(iX, iY);
		CvCity* pCity = pPlot ? pPlot->getPlotCity() : NULL;

		if(!pCity)
			return;

		const int iNumBuildingClassInfos = GC.getNumBuildingClassInfos();
		const CvCivilizationInfo& thisCivilization = getCivilizationInfo();
		for(int iBuildingClassLoop = 0; iBuildingClassLoop < iNumBuildingClassInfos; iBuildingClassLoop++)
		{
			const BuildingClassTypes eBuildingClass = (BuildingClassTypes) iBuildingClassLoop;
			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
			if(!pkBuildingClassInfo)
			{
				continue;
			}
			if(pkUnitEntry->GetBuildOnFound(eBuildingClass))
			{
				const BuildingTypes eFreeBuilding = (BuildingTypes)(thisCivilization.getCivilizationBuildings(eBuildingClass));
				if(pCity->isValidBuildingLocation(eFreeBuilding))
				{
					pCity->GetCityBuildings()->SetNumRealBuilding(eFreeBuilding, 1, true);
				}
			}
		}

		pCity->setPopulation(GetNewCityExtraPopulation() + iPopChange, true, true);

		//25% food, to prevent instant-starvation
		pCity->changeFood((pCity->growthThreshold() * iFoodPercent / 100));

		//And a little territory to boot
		for (int i = 0; i < iExtraPlots; i++)
		{
			CvPlot* pPlotToAcquire = pCity->GetNextBuyablePlot(false);

			// maybe the player owns ALL of the plots or there are none available?
			if(pPlotToAcquire)
			{
				pCity->DoAcquirePlot(pPlotToAcquire->getX(), pPlotToAcquire->getY());
			}
		}
	}
}
#endif

//	--------------------------------------------------------------------------------
bool CvPlayer::canTrain(UnitTypes eUnit, bool bContinue, bool bTestVisible, bool bIgnoreCost, bool bIgnoreUniqueUnitStatus, CvString* toolTipSink) const
{
	CvUnitEntry* pUnitInfoPtr = GC.getUnitInfo(eUnit);
	if(pUnitInfoPtr == NULL)
		return false;

	CvUnitEntry& pUnitInfo = *pUnitInfoPtr;

	const UnitClassTypes eUnitClass = (UnitClassTypes) pUnitInfo.GetUnitClassType();
	if(eUnitClass == NO_UNITCLASS)
	{
		return false;
	}

	CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
	if(pkUnitClassInfo == NULL)
	{
		return false;
	}

	if (GetPlayerTraits()->NoTrain(eUnitClass))
	{
		return false;
	}
#if defined(MOD_BALANCE_CORE_MINOR_CIV_GIFT)
	if(MOD_BALANCE_CORE_MINOR_CIV_GIFT && pUnitInfo.IsMinorCivGift() && !isBarbarian())
	{
		return false;
	}
#endif
#if defined(MOD_BALANCE_CORE_MILITARY)
	if(MOD_BALANCE_CORE_MILITARY && !isHuman())
	{
		if (((pUnitInfo.GetCombat() > 0) || (pUnitInfo.GetRangedCombat() > 0)) && !isBarbarian() && GetNumUnitsOutOfSupply() > 15)
		{
			return false;
		}
	}
#endif
	// Should we check whether this Unit has been blocked out by the civ XML?
	if(!bIgnoreUniqueUnitStatus)
	{
		UnitTypes eThisPlayersUnitType = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eUnitClass);

		// If the player isn't allowed to train this Unit (via XML) then return false
		if(eThisPlayersUnitType != eUnit)
		{
			return false;
		}
	}

	if(!bIgnoreCost)
	{
		if(pUnitInfo.GetProductionCost() == -1)
		{
			return false;
		}
	}
#if defined(MOD_BALANCE_CORE)
	ResourceTypes eResource = (ResourceTypes)pUnitInfo.GetResourceType();
	if (MOD_BALANCE_CORE && eResource != NO_RESOURCE && !isBarbarian())
	{
		if (getNumResourceTotal(eResource, true) <= 0)
		{
			return false;
		}
	}

	if(pUnitInfo.IsWarOnly())
	{
		if(!IsAtWarAnyMajor())
		{
			return false;
		}
	}
#endif

	// One City Challenge
	if(pUnitInfo.IsFound() || pUnitInfo.IsFoundAbroad())
	{
		if(GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && isHuman())
		{
			return false;
		}
	}
	
	//Policy Requirement
	PolicyTypes ePolicy = (PolicyTypes)pUnitInfo.GetPolicyType();
	if (ePolicy != NO_POLICY)
	{
		if (!GetPlayerPolicies()->HasPolicy(ePolicy))
		{
			return false;
		}
	}


	if (GC.getGame().isOption(GAMEOPTION_NO_RELIGION))
	{
		if (pUnitInfo.IsFoundReligion() || pUnitInfo.IsSpreadReligion() || pUnitInfo.IsRemoveHeresy())
		{
			return false;
		}
	}

	if(!bContinue)
	{
		if(!bTestVisible)
		{
			// Builder Limit
			if(pUnitInfo.GetWorkRate() > 0 && pUnitInfo.GetDomainType() == DOMAIN_LAND)
			{
				if(GetMaxNumBuilders() > -1 && GetNumBuilders() >= GetMaxNumBuilders())
				{
					return false;
				}
			}
		}
	}

	// Tech requirements
	if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pUnitInfo.GetPrereqAndTech()))))
	{
		return false;
	}

	int iI;
	for(iI = 0; iI < GC.getNUM_UNIT_AND_TECH_PREREQS(); iI++)
	{
		if(pUnitInfo.GetPrereqAndTechs(iI) != NO_TECH)
		{
			if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pUnitInfo.GetPrereqAndTechs(iI)))))
			{
				return false;
			}
		}
	}

	// Obsolete Tech
	if((TechTypes)pUnitInfo.GetObsoleteTech() != NO_TECH)
	{
		if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pUnitInfo.GetObsoleteTech())))
		{
			return false;
		}
	}

	// Game Unit Class Max
	if(GC.getGame().isUnitClassMaxedOut(eUnitClass))
	{
		return false;
	}

	// Team Unit Class Max
	if(GET_TEAM(getTeam()).isUnitClassMaxedOut(eUnitClass))
	{
		return false;
	}

	// Player Unit Class Max
	if(isUnitClassMaxedOut(eUnitClass))
	{
		return false;
	}

	// Spaceship part we already have?
	ProjectTypes eProject = (ProjectTypes) pUnitInfo.GetSpaceshipProject();
	if(eProject != NO_PROJECT)
	{
		if(GET_TEAM(getTeam()).isProjectMaxedOut(eProject))
			return false;

		int iUnitAndProjectCount = GET_TEAM(getTeam()).getProjectCount(eProject) + getUnitClassCount(eUnitClass) + GET_TEAM(getTeam()).getUnitClassMaking(eUnitClass) + ((bContinue) ? -1 : 0);
		if(iUnitAndProjectCount >= pkUnitClassInfo->getMaxPlayerInstances())
		{
			return false;
		}
	}

	if(!bTestVisible)
	{
#if defined(MOD_BALANCE_CORE_MILITARY)
		if (MOD_BALANCE_CORE_MILITARY && pUnitInfo.GetCombat() > 0 && !isBarbarian() && GetNumUnitsOutOfSupply() > 15)
		{
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_NO_SUPPLY");
			if(toolTipSink == NULL)
			return false;
		}
#endif
		// Settlers
		if(pUnitInfo.IsFound() || pUnitInfo.IsFoundAbroad())
		{
			if(IsEmpireVeryUnhappy() && GC.getVERY_UNHAPPY_CANT_TRAIN_SETTLERS() == 1)
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_VERY_UNHAPPY_SETTLERS");
				if(toolTipSink == NULL)
					return false;
			}
		}

		// Project required?
		ProjectTypes ePrereqProject = (ProjectTypes) pUnitInfo.GetProjectPrereq();
		if(ePrereqProject != NO_PROJECT)
		{
			CvProjectEntry* pkProjectInfo = GC.getProjectInfo(ePrereqProject);
			if(pkProjectInfo)
			{
				if(GET_TEAM(getTeam()).getProjectCount(ePrereqProject) == 0)
				{
					GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_UNIT_PROJECT_REQUIRED", pkProjectInfo->GetDescription());
					if(toolTipSink == NULL)
						return false;
				}
			}
		}

		// Resource Requirements
		for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
		{
			const ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);
			CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);
			if(pkResourceInfo)
			{
				const int iNumResource = pUnitInfo.GetResourceQuantityRequirement(eResource);

				if(iNumResource > 0)
				{
					// Starting project, need enough Resources plus some to start
					if(!bContinue && getNumResourceAvailable(eResource) < iNumResource)
					{
						GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_UNIT_LACKS_RESOURCES", pkResourceInfo->GetIconString(), pkResourceInfo->GetTextKey(), iNumResource);
						if(toolTipSink == NULL)
							return false;
					}
					// Continuing project, need enough Resources
					else if(bContinue && (getNumResourceAvailable(eResource) < 0))
					{
						GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_UNIT_LACKS_RESOURCES", pkResourceInfo->GetIconString(), pkResourceInfo->GetTextKey(), iNumResource);
						if(toolTipSink == NULL)
							return false;
					}
				}
			}

		}

		if(GC.getGame().isUnitClassMaxedOut(eUnitClass, (GET_TEAM(getTeam()).getUnitClassMaking(eUnitClass) + ((bContinue) ? -1 : 0))))
		{
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_GAME_COUNT_MAX", "", "", pkUnitClassInfo->getMaxTeamInstances());
			if(toolTipSink == NULL)
				return false;
		}

		if(GET_TEAM(getTeam()).isUnitClassMaxedOut(eUnitClass, (GET_TEAM(getTeam()).getUnitClassMaking(eUnitClass) + ((bContinue) ? -1 : 0))))
		{
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_TEAM_COUNT_MAX", "", "", pkUnitClassInfo->getMaxTeamInstances());
			if(toolTipSink == NULL)
				return false;
		}

		if(isUnitClassMaxedOut(eUnitClass, (getUnitClassMaking(eUnitClass) + ((bContinue) ? -1 : 0))))
		{
#if defined(MOD_BALANCE_CORE)
			if(isNationalUnitClass(eUnitClass))
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_PLAYER_COUNT_MAX", "", "", pkUnitClassInfo->getMaxPlayerInstances());
				if(toolTipSink == NULL)
					return false;
			}
			if(isUnitLimitPerCity(eUnitClass))
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_PLAYER_CITY_COUNT_MAX", "", "", (getNumCities() * pkUnitClassInfo->getUnitInstancePerCity()));
				if(toolTipSink == NULL)
					return false;
			}
#else
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_PLAYER_COUNT_MAX", "", "", pkUnitClassInfo->getMaxPlayerInstances());
			if(toolTipSink == NULL)
				return false;
#endif
		}

		if(GC.getGame().isNoNukes() || !GC.getGame().isNukesValid())
		{
			if(pUnitInfo.GetNukeDamageLevel() != -1)
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_NUKES");
				if(toolTipSink == NULL)
					return false;
			}
		}

		if(pUnitInfo.GetNukeDamageLevel() != -1)
		{
			if(GC.getGame().GetGameLeagues()->IsNoTrainingNuclearWeapons(GetID()))
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_NUKES_BY_RESOLUTION");
				if(toolTipSink == NULL)
					return false;
			}
		}

		if(pUnitInfo.GetSpecialUnitType() != NO_SPECIALUNIT)
		{
			if(!(GC.getGame().isSpecialUnitValid((SpecialUnitTypes)(pUnitInfo.GetSpecialUnitType()))))
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_SPECIAL_UNIT");
				if(toolTipSink == NULL)
					return false;
			}
		}

		if (pUnitInfo.IsTrade())
		{
			if (GetTrade()->GetNumTradeUnitsRemaining(!bContinue) <= 0)
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_TRADE_UNIT_CONSTRUCTION_NO_EXTRA_SLOTS");
				if (toolTipSink == NULL)
					return false;			
			}

			DomainTypes eDomain = (DomainTypes)pUnitInfo.GetDomainType();
			if (!GetTrade()->CanCreateTradeRoute(eDomain))
			{
				if (eDomain == DOMAIN_LAND)
				{
					GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_TRADE_UNIT_CONSTRUCTION_NONE_OF_TYPE_LAND");
				}
				else if (eDomain == DOMAIN_SEA)
				{
					GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_TRADE_UNIT_CONSTRUCTION_NONE_OF_TYPE_SEA");
				}
				if (toolTipSink == NULL)
					return false;
			}
		}
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(eUnit);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if(LuaSupport::CallTestAll(pkScriptSystem, "PlayerCanTrain", args.get(), bResult))
		{
			// Check the result.
			if(bResult == false)
			{
				return false;
			}
		}
	}

	return true;
}

#if defined(MOD_BALANCE_CORE)
bool CvPlayer::canBarbariansTrain(UnitTypes eUnit, bool bIgnoreUniqueUnitStatus, ResourceTypes eResourceNearby) const
{
	CvUnitEntry* pUnitInfoPtr = GC.getUnitInfo(eUnit);
	if (pUnitInfoPtr == NULL)
		return false;

	CvUnitEntry& pUnitInfo = *pUnitInfoPtr;

	const UnitClassTypes eUnitClass = (UnitClassTypes)pUnitInfo.GetUnitClassType();
	if (eUnitClass == NO_UNITCLASS)
	{
		return false;
	}

	CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
	if (pkUnitClassInfo == NULL)
	{
		return false;
	}

	if (GetPlayerTraits()->NoTrain(eUnitClass))
	{
		return false;
	}

	// Should we check whether this Unit has been blocked out by the civ XML?
	if (!bIgnoreUniqueUnitStatus)
	{
		UnitTypes eThisPlayersUnitType = (UnitTypes)getCivilizationInfo().getCivilizationUnits(eUnitClass);

		// If the player isn't allowed to train this Unit (via XML) then return false
		if (eThisPlayersUnitType != eUnit)
		{
			return false;
		}
	}

	if (pUnitInfo.GetProductionCost() == -1)
	{
		return false;
	}

	//Policy Requirement
	PolicyTypes ePolicy = (PolicyTypes)pUnitInfo.GetPolicyType();
	if (ePolicy != NO_POLICY)
	{
		if (!GetPlayerPolicies()->HasPolicy(ePolicy))
		{
			return false;
		}
	}

	if (pUnitInfo.IsFoundReligion() || pUnitInfo.IsSpreadReligion() || pUnitInfo.IsRemoveHeresy())
	{
		return false;
	}
	// Builder Limit
	if (pUnitInfo.GetWorkRate() > 0 && pUnitInfo.GetDomainType() == DOMAIN_LAND)
	{
		return false;
	}

	// Tech requirements
	if (!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pUnitInfo.GetPrereqAndTech()))))
	{
		return false;
	}

	int iI;
	for (iI = 0; iI < GC.getNUM_UNIT_AND_TECH_PREREQS(); iI++)
	{
		if (pUnitInfo.GetPrereqAndTechs(iI) != NO_TECH)
		{
			if (!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pUnitInfo.GetPrereqAndTechs(iI)))))
			{
				return false;
			}
		}
	}

	// Obsolete Tech
	if ((TechTypes)pUnitInfo.GetObsoleteTech() != NO_TECH)
	{
		if (GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pUnitInfo.GetObsoleteTech())))
		{
			return false;
		}
	}

	// Game Unit Class Max
	if (GC.getGame().isUnitClassMaxedOut(eUnitClass))
	{
		return false;
	}

	// Team Unit Class Max
	if (GET_TEAM(getTeam()).isUnitClassMaxedOut(eUnitClass))
	{
		return false;
	}

	// Player Unit Class Max
	if (isUnitClassMaxedOut(eUnitClass))
	{
		return false;
	}

	// Spaceship part we already have?
	ProjectTypes eProject = (ProjectTypes)pUnitInfo.GetSpaceshipProject();
	if (eProject != NO_PROJECT)
	{
		return false;
	}

	// Settlers
	if (pUnitInfo.IsFound() || pUnitInfo.IsFoundAbroad())
	{
		return false;
	}

	// Project required?
	ProjectTypes ePrereqProject = (ProjectTypes)pUnitInfo.GetProjectPrereq();
	if (ePrereqProject != NO_PROJECT)
	{
		return false;
	}

	// Resource Requirements
	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		const ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);
		CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);
		if (pkResourceInfo)
		{
			const int iNumResource = pUnitInfo.GetResourceQuantityRequirement(eResource);

			if (iNumResource > 0 && eResource != eResourceNearby)
			{
				return false;
			}
		}

	}

	if (pUnitInfo.GetNukeDamageLevel() != -1)
	{
		return false;
	}
	//Had to set it this way because Barbarian land units are "SPECIALUNIT_CARGO_ARMY" in MOD_CARGO_SHIPS. Need to be able to spawn them.
	SpecialUnitTypes eSpedcialPeople = (SpecialUnitTypes) GC.getInfoTypeForString("SPECIALUNIT_PEOPLE");
	SpecialUnitTypes eSpedcialFighter = (SpecialUnitTypes) GC.getInfoTypeForString("SPECIALUNIT_FIGHTER");
	SpecialUnitTypes eSpedcialStealth = (SpecialUnitTypes) GC.getInfoTypeForString("SPECIALUNIT_STEALTH");
	SpecialUnitTypes eSpedcialMissile = (SpecialUnitTypes) GC.getInfoTypeForString("SPECIALUNIT_MISSILE");
	if ((pUnitInfo.GetSpecialUnitType() == eSpedcialPeople) || (pUnitInfo.GetSpecialUnitType() == eSpedcialFighter) || (pUnitInfo.GetSpecialUnitType() == eSpedcialStealth) || (pUnitInfo.GetSpecialUnitType() == eSpedcialMissile))
	{
		return false;
	}

	if (pUnitInfo.IsTrade())
	{
		return false;
	}

	return true;
}
#endif
//	--------------------------------------------------------------------------------
bool CvPlayer::canConstruct(BuildingTypes eBuilding, bool bContinue, bool bTestVisible, bool bIgnoreCost, CvString* toolTipSink) const
{
	std::vector<int> vTotalBuildingCount( GC.getNumBuildingInfos(), 0);
	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity && !pLoopCity->IsPuppet())
		{
			const std::vector<BuildingTypes>& vBuildings = pLoopCity->GetCityBuildings()->GetAllBuildingsHere();
			for (size_t i=0; i<vBuildings.size(); i++)
				vTotalBuildingCount[ vBuildings[i] ]++;
		}
	}

	return canConstruct(eBuilding,vTotalBuildingCount,bContinue,bTestVisible,bIgnoreCost,toolTipSink);
}

bool CvPlayer::canConstruct(BuildingTypes eBuilding, const std::vector<int>& vPreExistingBuildings, bool bContinue, bool bTestVisible, bool bIgnoreCost, CvString* toolTipSink) const
{
	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if(pkBuildingInfo == NULL)
		return false;

	// Don't allow a city to consider an espionage building if they are playing a non-espionage game
	if (pkBuildingInfo->IsEspionage() && pkBuildingInfo->GetDefenseHappinessChangeBuilding() == 0 && pkBuildingInfo->GetDefenseHappinessChangeBuildingGlobal() == 0 && GC.getGame().isOption(GAMEOPTION_NO_ESPIONAGE))
	{
		return false;
	}

	CvBuildingEntry& pBuildingInfo = *pkBuildingInfo;

	int iI;
	CvTeam& currentTeam = GET_TEAM(getTeam());

	const BuildingClassTypes eBuildingClass = ((BuildingClassTypes)(pBuildingInfo.GetBuildingClassType()));
	const CvBuildingClassInfo& kBuildingClass = pkBuildingInfo->GetBuildingClassInfo();

	// Checks to make sure civilization doesn't have an override that prevents construction of this building
	if(getCivilizationInfo().getCivilizationBuildings(eBuildingClass) != eBuilding)
	{
		return false;
	}

	if(!bIgnoreCost)
	{
		if(pBuildingInfo.GetProductionCost() == -1)
		{
			return false;
		}
	}

	PolicyBranchTypes eBranch = (PolicyBranchTypes)pBuildingInfo.GetPolicyBranchType();
	if (eBranch != NO_POLICY_BRANCH_TYPE)
	{
		if (!GetPlayerPolicies()->IsPolicyBranchUnlocked(eBranch))
		{
			return false;
		}
	}
#if defined(MOD_BALANCE_CORE_POLICIES)
	PolicyTypes ePolicy = (PolicyTypes)pBuildingInfo.GetPolicyType();
	if (MOD_BALANCE_CORE_POLICIES && ePolicy != NO_POLICY)
	{
		if (!GetPlayerPolicies()->HasPolicy(ePolicy))
		{
			return false;
		}
	}
#endif
#if defined(MOD_BALANCE_CORE)
	ResourceTypes eResource = (ResourceTypes)pBuildingInfo.GetResourceType();
	if (MOD_BALANCE_CORE && eResource != NO_RESOURCE)
	{
		if (getNumResourceTotal(eResource, true) <= 0)
		{
			return false;
		}
	}
#endif
	if(!(currentTeam.GetTeamTechs()->HasTech((TechTypes)(pBuildingInfo.GetPrereqAndTech()))))
	{
		return false;
	}
	for(iI = 0; iI < GC.getNUM_BUILDING_AND_TECH_PREREQS(); iI++)
	{
		if(pBuildingInfo.GetPrereqAndTechs(iI) != NO_TECH)
		{
			if(!(currentTeam.GetTeamTechs()->HasTech((TechTypes)(pBuildingInfo.GetPrereqAndTechs(iI)))))
			{
				return false;
			}
		}
	}

	if(currentTeam.isObsoleteBuilding(eBuilding))
	{
		return false;
	}

	// Building upgrade to another type
	BuildingClassTypes eReplacementBuildingClass = (BuildingClassTypes) pBuildingInfo.GetReplacementBuildingClass();

	if(eReplacementBuildingClass != NO_BUILDINGCLASS)
	{
		BuildingTypes eUpgradeBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(eReplacementBuildingClass)));

		if(canConstruct(eUpgradeBuilding))
		{
			return false;
		}
	}

	if(pBuildingInfo.GetVictoryPrereq() != NO_VICTORY)
	{
		if(!(GC.getGame().isVictoryValid((VictoryTypes)(pBuildingInfo.GetVictoryPrereq()))))
		{
			return false;
		}

		if(isMinorCiv())
		{
			return false;
		}

		if(currentTeam.getVictoryCountdown((VictoryTypes)pBuildingInfo.GetVictoryPrereq()) >= 0)
		{
			return false;
		}
	}

	if(pBuildingInfo.GetMaxStartEra() != NO_ERA)
	{
		if(GC.getGame().getStartEra() > pBuildingInfo.GetMaxStartEra())
		{
			return false;
		}
	}

	if(GC.getGame().isBuildingClassMaxedOut(eBuildingClass))
	{
		return false;
	}

	if(currentTeam.isBuildingClassMaxedOut(eBuildingClass))
	{
		return false;
	}

	if(isBuildingClassMaxedOut(eBuildingClass))
	{
		return false;
	}

	if (pBuildingInfo.GetNumRequiredTier3Tenets() > 0)
	{
		PolicyBranchTypes eIdeology = GetPlayerPolicies()->GetLateGamePolicyTree();
		if (eIdeology == NO_POLICY_BRANCH_TYPE)
			return false;
	}
	

	///////////////////////////////////////////////////////////////////////////////////
	// Everything above this is what is checked to see if Building shows up in the list of construction items
	///////////////////////////////////////////////////////////////////////////////////

	if(!bTestVisible)
	{
		if (pBuildingInfo.GetNumRequiredTier3Tenets() > 0)
		{
			PolicyBranchTypes eIdeology = GetPlayerPolicies()->GetLateGamePolicyTree();

			int iNumTenets = GetPlayerPolicies()->GetNumTenetsOfLevel(eIdeology, 3);
			if (iNumTenets < pBuildingInfo.GetNumRequiredTier3Tenets())
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_TENETS_COUNT_NEEDED", pkBuildingInfo->GetTextKey(), "", pBuildingInfo.GetNumRequiredTier3Tenets() - iNumTenets);

				if (toolTipSink == NULL)
					return false;
			}
		}

		// Num buildings in the empire... uhhh, how is this different from the very last check in this function? (JON: It doesn't appear to be used, but I can't say for sure :)
		const CvCivilizationInfo& civilizationInfo = getCivilizationInfo();
		int numBuildingClassInfos = GC.getNumBuildingClassInfos();

		for(iI = 0; iI < numBuildingClassInfos; iI++)
		{
			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo((BuildingClassTypes)iI);
			if(!pkBuildingClassInfo)
			{
				continue;
			}

			BuildingTypes ePrereqBuilding = (BuildingTypes)civilizationInfo.getCivilizationBuildings(iI);

			if(NO_BUILDING != ePrereqBuilding && currentTeam.isObsoleteBuilding(ePrereqBuilding))
			{
				CvBuildingEntry* pkPrereqBuilding = GC.getBuildingInfo(ePrereqBuilding);
				if(pkPrereqBuilding)
				{
					int iNumHave = getBuildingClassCount((BuildingClassTypes)iI);

					int iNumNeeded = getBuildingClassPrereqBuilding(eBuilding, (BuildingClassTypes)iI, 0);

					if(iNumHave < iNumNeeded)
					{
						GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_COUNT_NEEDED", pkPrereqBuilding->GetTextKey(), "", iNumNeeded - iNumHave);

						if(toolTipSink == NULL)
							return false;
					}
				}
			}
		}

		// Resource Requirements
		for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
		{
			const ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);
			CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
			if(pkResource)
			{
				int iNumResource = pBuildingInfo.GetResourceQuantityRequirement(eResource);
				if(iNumResource > 0)
				{
					if(bContinue)
						iNumResource = 0;

					if(getNumResourceAvailable(eResource) < iNumResource)
					{
						GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_LACKS_RESOURCES", pkResource->GetIconString(), pkResource->GetTextKey(), iNumResource);
						if(toolTipSink == NULL)
							return false;
					}
				}
			}
		}

		if(GC.getGame().isBuildingClassMaxedOut(eBuildingClass, (currentTeam.getBuildingClassMaking(eBuildingClass) + ((bContinue) ? -1 : 0))))
		{
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_GAME_COUNT_MAX", "", "", kBuildingClass.getMaxGlobalInstances());
			if(toolTipSink == NULL)
				return false;
		}

		if(currentTeam.isBuildingClassMaxedOut(eBuildingClass, (currentTeam.getBuildingClassMaking(eBuildingClass) + ((bContinue) ? -1 : 0))))
		{
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_TEAM_COUNT_MAX", "", "", kBuildingClass.getMaxTeamInstances());
			if(toolTipSink == NULL)
				return false;
		}

		if(isBuildingClassMaxedOut(eBuildingClass, (getBuildingClassMaking(eBuildingClass) + ((bContinue) ? -1 : 0))))
		{
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_PLAYER_COUNT_MAX", "", "", kBuildingClass.getMaxPlayerInstances());
			if(toolTipSink == NULL)
				return false;
		}

		if(getNumCities() < pBuildingInfo.GetNumCitiesPrereq())
		{
			return false;
		}

		if(getHighestUnitLevel() < pBuildingInfo.GetUnitLevelPrereq())
		{
			return false;
		}
#if defined(MOD_BALANCE_CORE)
		if(GetPlayerPolicies() && !isMinorCiv() && !isBarbarian())
		{
			bool IgnoreRequirements = false;
			CvGameReligions* pReligions = GC.getGame().GetGameReligions();
			ReligionTypes eFoundedReligion = pReligions->GetFounderBenefitsReligion(GetID());
			if (eFoundedReligion == NO_RELIGION)
			{
				eFoundedReligion = GetReligions()->GetReligionInMostCities();
			}
			if (eFoundedReligion != NO_RELIGION)
			{
				const CvReligion* pReligion = pReligions->GetReligion(eFoundedReligion, GetID());
				if (pReligion)
				{
					// Depends on era of wonder
					EraTypes eEra;
					TechTypes eTech = (TechTypes)pBuildingInfo.GetPrereqAndTech();
					if (eTech != NO_TECH)
					{
						CvTechEntry* pEntry = GC.GetGameTechs()->GetEntry(eTech);
						if (pEntry)
						{
							eEra = (EraTypes)pEntry->GetEra();
							if (eEra != NO_ERA)
							{
								CvCity* pHolyCity = NULL;
								CvPlot* pHolyCityPlot = GC.getMap().plot(pReligion->m_iHolyCityX, pReligion->m_iHolyCityY);
								if (pHolyCityPlot)
								{
									pHolyCity = pHolyCityPlot->getPlotCity();
								}
								if (pHolyCity == NULL)
								{
									pHolyCity = GET_PLAYER(GetID()).getCapitalCity();
								}
								IgnoreRequirements = pReligion->m_Beliefs.IsIgnorePolicyRequirements(eEra, GetID(), pHolyCity);
							}
						}
					}
				}
			}
			if (!IgnoreRequirements)
			{
				//If # of policies will do it, then we need to see the either/or here.
				if (pBuildingInfo.GetNumPoliciesNeeded() > 0)
				{
					int iNumPolicies = GetPlayerPolicies()->GetNumPoliciesOwned(true);
					int iCSPolicyReduction = GetCSAlliesLowersPolicyNeedWonders();
					if (iCSPolicyReduction > 0)
					{
						int iNumAllies = GetNumCSAllies();
						iNumPolicies += (iNumAllies / iCSPolicyReduction);
					}
					if (eFoundedReligion != NO_RELIGION)
					{
						const CvReligion* pReligion = pReligions->GetReligion(eFoundedReligion, GetID());
						if (pReligion)
						{
							CvCity* pHolyCity = NULL;
							CvPlot* pHolyCityPlot = GC.getMap().plot(pReligion->m_iHolyCityX, pReligion->m_iHolyCityY);
							if (pHolyCityPlot)
							{
								pHolyCity = pHolyCityPlot->getPlotCity();
							}
							if (pHolyCity == NULL)
							{
								pHolyCity = GET_PLAYER(GetID()).getCapitalCity();
							}
							int iReligionPolicyReduction = pReligion->m_Beliefs.GetPolicyReductionWonderXFollowerCities(GetID(), pHolyCity);
							if (iReligionPolicyReduction > 0)
							{
								int iNumFollowerCities = pReligions->GetNumCitiesFollowing(eFoundedReligion);
								if (iNumFollowerCities > 0)
								{
									iNumPolicies += (iNumFollowerCities / iReligionPolicyReduction);
								}
							}
						}
					}				
					if (iNumPolicies < pBuildingInfo.GetNumPoliciesNeeded())
					{
						GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_NEED_POLICIES", pkBuildingInfo->GetTextKey(), "", pBuildingInfo.GetNumPoliciesNeeded() - iNumPolicies);
						if (toolTipSink == NULL)
							return false;
					}
				}
			}
		}
#endif

#if defined(MOD_BALANCE_CORE_POP_REQ_BUILDINGS)
		//Requires a certain population size, nationally.
		if(MOD_BALANCE_CORE_POP_REQ_BUILDINGS)
		{
			int iPopRequired = GetScalingNationalPopulationRequrired(eBuilding);
			if(iPopRequired > 0)
			{
				int iCurrentPop = getTotalPopulation();
				if(iCurrentPop < iPopRequired)
				{
					GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_NEED_NATIONAL_POP", pkBuildingInfo->GetTextKey(), "", iPopRequired - iCurrentPop);
					if(toolTipSink == NULL)
					return false;
				}
			}
		}
#endif
#if defined(MOD_BALANCE_CORE_FOLLOWER_POP_WONDER)
		//Requires a certain religion follower size, either nationally or globally.
		if(MOD_BALANCE_CORE_FOLLOWER_POP_WONDER)
		{
			CvGameReligions* pReligions = GC.getGame().GetGameReligions();
			ReligionTypes eFoundedReligion = pReligions->GetFounderBenefitsReligion(GetID());
			if (eFoundedReligion == NO_RELIGION)
			{
				eFoundedReligion = GetReligions()->GetReligionInMostCities();
			}
			if(eFoundedReligion != NO_RELIGION)
			{
				const CvReligion* pReligion = pReligions->GetReligion(eFoundedReligion, GetID());
				if(pReligion)
				{
					if (pkBuildingInfo->GetNationalFollowerPopRequired() > 0)
					{
						CvCity* pHolyCity = NULL;
						CvPlot* pHolyCityPlot = GC.getMap().plot(pReligion->m_iHolyCityX, pReligion->m_iHolyCityY);
						if (pHolyCityPlot)
						{
							pHolyCity = pHolyCityPlot->getPlotCity();
						}
						if (pHolyCity == NULL)
						{
							pHolyCity = GET_PLAYER(GetID()).getCapitalCity();
						}
						if (pReligion->m_Beliefs.IsBuildingClassEnabled(eBuildingClass, GetID(), pHolyCity, true))
						{
							int iPopRequired = pkBuildingInfo->GetNationalFollowerPopRequired();
							int iLoop;
							int iCurrentPop = 0;
							CvCity* pLoopCity;
							for (pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
							{
								iCurrentPop += pLoopCity->GetCityReligions()->GetNumFollowers(eFoundedReligion);
							}
							if (iCurrentPop < iPopRequired)
							{
								GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_NEED_FOLLOWER_POP", pkBuildingInfo->GetTextKey(), "", iPopRequired - iCurrentPop);
								if (toolTipSink == NULL)
									return false;
							}
						}
					}
					if(pkBuildingInfo->GetGlobalFollowerPopRequired() > 0)
					{
						CvCity* pHolyCity = NULL;
						CvPlot* pHolyCityPlot = GC.getMap().plot(pReligion->m_iHolyCityX, pReligion->m_iHolyCityY);
						if (pHolyCityPlot)
						{
							pHolyCity = pHolyCityPlot->getPlotCity();
						}
						if (pHolyCity == NULL)
						{
							pHolyCity = GET_PLAYER(GetID()).getCapitalCity();
						}
						if (pReligion->m_Beliefs.IsBuildingClassEnabled(eBuildingClass, GetID(), pHolyCity))
						{
							int iPopRequiredPercent = pkBuildingInfo->GetGlobalFollowerPopRequired();
							iPopRequiredPercent -= GetReformationFollowerReduction();
							if (GC.getMap().getWorldInfo().getReformationPercent() > 0)
							{
								iPopRequiredPercent *= GC.getMap().getWorldInfo().getReformationPercent();
								iPopRequiredPercent /= 100;
							}

							int iCurrentPop = pReligions->GetNumFollowers(eFoundedReligion);
							int iCurrentPopPercent = (iCurrentPop * 100) / GC.getGame().getTotalPopulation();

							if (iCurrentPopPercent < iPopRequiredPercent)
							{
								int iPercentage = iPopRequiredPercent - iCurrentPopPercent;
								GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_NEED_GLOBAL_FOLLOWER_POP", pkBuildingInfo->GetTextKey(), "", iPercentage);
								if (toolTipSink == NULL)
									return false;
							}
						}
					}
				}
			}
		}
#endif

		BuildingTypes ePrereqBuilding;
		int iNumNeeded;
		for(iI = 0; iI < numBuildingClassInfos; iI++)
		{
			iNumNeeded = getBuildingClassPrereqBuilding(eBuilding, ((BuildingClassTypes)iI), bContinue);
			//int iNumHave = getBuildingClassCount((BuildingClassTypes)iI);
			ePrereqBuilding = (BuildingTypes) civilizationInfo.getCivilizationBuildings(iI);
			if(NO_BUILDING != ePrereqBuilding)
			{
				CvBuildingEntry* pkPrereqBuilding = GC.getBuildingInfo(ePrereqBuilding);
				if(pkPrereqBuilding)
				{
					int iNumHave = vPreExistingBuildings[ePrereqBuilding];
					if(iNumHave < iNumNeeded)
					{
						ePrereqBuilding = (BuildingTypes) civilizationInfo.getCivilizationBuildings(iI);

						GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_COUNT_NEEDED", pkPrereqBuilding->GetTextKey(), "", iNumNeeded - iNumHave);

						if(toolTipSink == NULL)
							return false;

						// If we have less than 5 to go, list what cities need them
						int iNonPuppetCities = getNumCities() - GetNumPuppetCities();
						if(iNumNeeded == iNonPuppetCities && iNumNeeded - iNumHave < 5)
						{
							(*toolTipSink) += "[NEWLINE]";

							int iLoop=0;
							for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
							{
								if(pLoopCity && !pLoopCity->IsPuppet() && pLoopCity->GetCityBuildings()->GetNumBuilding(ePrereqBuilding) == 0)
								{
									(*toolTipSink) += pLoopCity->getName();
									(*toolTipSink) += " ";
								}
							}
						}
					}
				}
			}
		}
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(eBuilding);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if(LuaSupport::CallTestAll(pkScriptSystem, "PlayerCanConstruct", args.get(), bResult))
		{
			// Check the result.
			if(bResult == false)
			{
				return false;
			}
		}
	}

	return true;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::canCreate(ProjectTypes eProject, bool bContinue, bool bTestVisible) const
{
	CvProjectEntry* pkProjectInfo = GC.getProjectInfo(eProject);
	if(!pkProjectInfo)
	{
		return false;
	}

	CvProjectEntry& pProjectInfo = *pkProjectInfo;

	int iI;

	// No projects for barbs
	if(isBarbarian())
	{
		return false;
	}

	// no minors either
	if(isMinorCiv())
	{
		return false;
	}

	// If cost is -1 then that means it can't be built
	if(pProjectInfo.GetProductionCost() == -1)
	{
		return false;
	}

	// Tech requirement
	if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pProjectInfo.GetTechPrereq()))))
	{
		return false;
	}

	// Policy branch requirement?
	if(pProjectInfo.GetCultureBranchesRequired() > 0)
	{
		if(GetPlayerPolicies()->GetNumPolicyBranchesFinished() < pProjectInfo.GetCultureBranchesRequired())
		{
			return false;
		}
	}

	// Requires a particular victory condition to be enabled?
	if(pProjectInfo.GetVictoryPrereq() != NO_VICTORY)
	{
		if(!(GC.getGame().isVictoryValid((VictoryTypes)(pProjectInfo.GetVictoryPrereq()))))
		{
			return false;
		}

		if(isMinorCiv())
		{
			return false;
		}

		if(GET_TEAM(getTeam()).getVictoryCountdown((VictoryTypes)pProjectInfo.GetVictoryPrereq()) >= 0)
		{
			return false;
		}
	}

	if(GC.getGame().isProjectMaxedOut(eProject))
	{
		return false;
	}

	if(GET_TEAM(getTeam()).isProjectMaxedOut(eProject))
	{
		return false;
	}

	if (pProjectInfo.GetNumRequiredTier3Tenets())
	{
		PolicyBranchTypes eIdeology = GetPlayerPolicies()->GetLateGamePolicyTree();
		if (eIdeology == NO_POLICY_BRANCH_TYPE)
			return false;

		int iNumTenets = GetPlayerPolicies()->GetNumTenetsOfLevel(eIdeology, 3);
		if (iNumTenets < pProjectInfo.GetNumRequiredTier3Tenets())
			return false;
	}

	if(!bTestVisible)
	{
		if (pProjectInfo.InfluenceAllRequired())
		{
			if (GetCulture()->GetNumCivsInfluentialOn() < GC.getGame().GetGameCulture()->GetNumCivsInfluentialForWin())
				return false;
		}

		if (pProjectInfo.IdeologyRequired())
		{
			if (GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
				return false;
			else if (GetCulture()->GetPublicOpinionType() > PUBLIC_OPINION_CONTENT)
				return false;
		}

		// Resource Requirements
		ResourceTypes eResource;
		int iNumResource;
		for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
		{
			eResource = (ResourceTypes) iResourceLoop;
			iNumResource = pProjectInfo.GetResourceQuantityRequirement(eResource);

			if(iNumResource > 0)
			{
				if(getNumResourceAvailable(eResource) < iNumResource)
				{
					return false;
				}
			}
		}

		if(GC.getGame().isProjectMaxedOut(eProject, (GET_TEAM(getTeam()).getProjectMaking(eProject) + ((bContinue) ? -1 : 0))))
		{
			return false;
		}

		if(GET_TEAM(getTeam()).isProjectMaxedOut(eProject, (GET_TEAM(getTeam()).getProjectMaking(eProject) + ((bContinue) ? -1 : 0))))
		{
			return false;
		}

		// Nukes disabled? (by UN or something)
		if(GC.getGame().isNoNukes())
		{
			if(pProjectInfo.IsAllowsNukes())
			{
				for(iI = 0; iI < GC.getNumUnitInfos(); iI++)
				{
					CvUnitEntry* pkUnitEntry = GC.getUnitInfo((UnitTypes)iI);
					if(pkUnitEntry && pkUnitEntry->GetNukeDamageLevel() != -1)
					{
						return false;
					}
				}
			}
		}

		if(pProjectInfo.GetAnyoneProjectPrereq() != NO_PROJECT)
		{
			if(GC.getGame().getProjectCreatedCount((ProjectTypes)(pProjectInfo.GetAnyoneProjectPrereq())) == 0)
			{
				return false;
			}
		}

		for(iI = 0; iI < GC.getNumProjectInfos(); iI++)
		{
			if(GET_TEAM(getTeam()).getProjectCount((ProjectTypes)iI) < pProjectInfo.GetProjectsNeeded(iI))
			{
				return false;
			}
		}
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(eProject);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if(LuaSupport::CallTestAll(pkScriptSystem, "PlayerCanCreate", args.get(), bResult))
		{
			// Check the result.
			if(bResult == false)
			{
				return false;
			}
		}
	}

	return true;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::canPrepare(SpecialistTypes eSpecialist, bool) const
{
	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(eSpecialist);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if(LuaSupport::CallTestAll(pkScriptSystem, "PlayerCanPrepare", args.get(), bResult))
		{
			// Check the result.
			if(bResult == false)
			{
				return false;
			}
		}
	}


	return false;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::canMaintain(ProcessTypes eProcess, bool) const
{
	// Check to see if it exists, scenarios can remove them and leave holes in the list.
	const CvProcessInfo* pkProcessInfo = GC.getProcessInfo(eProcess);
	if (!pkProcessInfo)
		return false;

	if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pkProcessInfo->getTechPrereq()))))
	{
		return false;
	}

	for(int iI = 0; iI < GC.getNumLeagueProjectInfos(); iI++)
	{
		LeagueProjectTypes eLeagueProject = (LeagueProjectTypes) iI;
		CvLeagueProjectEntry* pInfo = GC.getLeagueProjectInfo(eLeagueProject);
		if (pInfo && pInfo->GetProcess() == eProcess)
		{
			if (!GC.getGame().GetGameLeagues()->CanContributeToLeagueProject(GetID(), eLeagueProject))
			{
				return false;
			}
		}
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(eProcess);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if(LuaSupport::CallTestAll(pkScriptSystem, "PlayerCanMaintain", args.get(), bResult))
		{
			// Check the result.
			if(bResult == false)
			{
				return false;
			}
		}
	}

	return true;
}

//	--------------------------------------------------------------------------------
/// Can we purchase this unit or building in any of our cities?
bool CvPlayer::IsCanPurchaseAnyCity(bool bTestPurchaseCost, bool bTestTrainable, UnitTypes eUnit, BuildingTypes eBuilding, YieldTypes ePurchaseYield)
{
	int iLoop;
	CvCity *pLoopCity;

	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (pLoopCity->IsCanPurchase(bTestPurchaseCost, bTestTrainable, eUnit, eBuilding, NO_PROJECT, ePurchaseYield))
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isProductionMaxedUnitClass(UnitClassTypes eUnitClass) const
{
	if(eUnitClass == NO_UNITCLASS)
	{
		return false;
	}

	if(GC.getGame().isUnitClassMaxedOut(eUnitClass))
	{
		return true;
	}

	if(GET_TEAM(getTeam()).isUnitClassMaxedOut(eUnitClass))
	{
		return true;
	}

	if(isUnitClassMaxedOut(eUnitClass))
	{
		return true;
	}

	return false;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isProductionMaxedBuildingClass(BuildingClassTypes eBuildingClass, bool bAcquireCity) const
{
	if(eBuildingClass == NO_BUILDINGCLASS)
	{
		return false;
	}

	CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
	if(pkBuildingClassInfo == NULL)
	{
		return false;
	}

	if(!bAcquireCity)
	{
		if(GC.getGame().isBuildingClassMaxedOut(eBuildingClass))
		{
			return true;
		}
	}

	if(GET_TEAM(getTeam()).isBuildingClassMaxedOut(eBuildingClass))
	{
		return true;
	}

	if(isBuildingClassMaxedOut(eBuildingClass, ((bAcquireCity) ? pkBuildingClassInfo->getExtraPlayerInstances() : 0)))
	{
		return true;
	}

	return false;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isProductionMaxedProject(ProjectTypes eProject) const
{
	if(eProject == NO_PROJECT)
	{
		return false;
	}

	if(GC.getGame().isProjectMaxedOut(eProject))
	{
		return true;
	}

	if(GET_TEAM(getTeam()).isProjectMaxedOut(eProject))
	{
		return true;
	}

	return false;
}


//	--------------------------------------------------------------------------------
int CvPlayer::getProductionNeeded(UnitTypes eUnit) const
{
	CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eUnit);

	CvAssertMsg(pkUnitEntry, "This should never be hit");
	if(pkUnitEntry == NULL)
		return 0;

	UnitClassTypes eUnitClass = (UnitClassTypes)pkUnitEntry->GetUnitClassType();
	CvAssert(NO_UNITCLASS != eUnitClass);

	CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
	CvAssert(pkUnitClassInfo);
	if(pkUnitClassInfo == NULL)
		return 0;

	int iProductionNeeded = pkUnitEntry->GetProductionCost();
	iProductionNeeded *= 100 + getUnitClassCount(eUnitClass) * pkUnitClassInfo->getInstanceCostModifier();
	iProductionNeeded /= 100;

	if(isMinorCiv())
	{
		iProductionNeeded *= GC.getMINOR_CIV_PRODUCTION_PERCENT();
		iProductionNeeded /= 100;
	}

	iProductionNeeded *= GC.getUNIT_PRODUCTION_PERCENT();
	iProductionNeeded /= 100;

	iProductionNeeded *= GC.getGame().getGameSpeedInfo().getTrainPercent();
	iProductionNeeded /= 100;

	iProductionNeeded *= GC.getGame().getStartEraInfo().getTrainPercent();
	iProductionNeeded /= 100;

#if defined(MOD_BALANCE_DYNAMIC_UNIT_SUPPLY)
	if (MOD_BALANCE_DYNAMIC_UNIT_SUPPLY && (pkUnitEntry->GetCombat() > 0 || pkUnitEntry->GetRangedCombat() > 0))
	{
		int iWarWeariness = GetCulture()->GetWarWeariness();
		int iMod = (100 + min(75, iWarWeariness));
		iProductionNeeded *= iMod;
		iProductionNeeded /= 100;
	}
#endif

	if(!isHuman() && !IsAITeammateOfHuman() && !isBarbarian())
	{
		if(isWorldUnitClass(eUnitClass))
		{
			iProductionNeeded *= GC.getGame().getHandicapInfo().getAIWorldTrainPercent();
			iProductionNeeded /= 100;
		}
		else
		{
			iProductionNeeded *= GC.getGame().getHandicapInfo().getAITrainPercent();
			iProductionNeeded /= 100;
		}

		iProductionNeeded *= std::max(0, ((GC.getGame().getHandicapInfo().getAIPerEraModifier() * GetCurrentEra()) + 100));
		iProductionNeeded /= 100;
	}

	iProductionNeeded += getUnitExtraCost(eUnitClass);

	return std::max(1, iProductionNeeded);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getProductionNeeded(BuildingTypes eBuilding) const
{
	int iProductionNeeded;

	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if(pkBuildingInfo == NULL)
	{
		//This should never happen.
		return 1;
	}

	iProductionNeeded = pkBuildingInfo->GetProductionCost();

	int iProductionModifier = 0;

	if(pkBuildingInfo->GetNumCityCostMod() > 0 && getNumCities() > 0)
	{
		iProductionModifier += (pkBuildingInfo->GetNumCityCostMod() * getNumCities());
	}
#if defined(MOD_BALANCE_CORE_WONDER_COST_INCREASE)
	if(MOD_BALANCE_CORE_WONDER_COST_INCREASE && isWorldWonderClass(pkBuildingInfo->GetBuildingClassInfo()))
	{
		const CvCity* pLoopCity;
		int iLoop;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity->getNumWorldWonders() > 0)
			{
				for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
				{
					const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
					CvBuildingEntry* pkeBuildingInfo = GC.getBuildingInfo(eBuilding);
				
					// Has this Building
					if(pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
					{
						if(isWorldWonderClass(pkeBuildingInfo->GetBuildingClassInfo()))
						{
							if (pkeBuildingInfo->GetPrereqAndTech() == NO_TECH)
								continue;

							CvTechEntry* pkTechInfo = GC.getTechInfo((TechTypes)pkeBuildingInfo->GetPrereqAndTech());
							if (pkTechInfo)
							{
								// Loop through all eras and apply Building production mod based on how much time has passed
								EraTypes eBuildingUnlockedEra = (EraTypes)pkTechInfo->GetEra();

								if (eBuildingUnlockedEra == NO_ERA)
									continue;

								int iEraDivisor = GetCurrentEra() - eBuildingUnlockedEra;
								switch (iEraDivisor)
								{
								case 0:
									iProductionModifier += GC.getBALANCE_CORE_WORLD_WONDER_SAME_ERA_COST_MODIFIER();
									break;
								case 1:
									iProductionModifier += GC.getBALANCE_CORE_WORLD_WONDER_PREVIOUS_ERA_COST_MODIFIER();
									break;
								case 2:
									iProductionModifier += GC.getBALANCE_CORE_WORLD_WONDER_EARLIER_ERA_COST_MODIFIER();
									break;
								}
							}
						}
					}
				}
			}
		}
	}
#endif

	if(isMinorCiv())
	{
		iProductionModifier += GC.getMINOR_CIV_PRODUCTION_PERCENT() - 100;
	}

	iProductionModifier += GC.getBUILDING_PRODUCTION_PERCENT() - 100;

	iProductionModifier += GC.getGame().getGameSpeedInfo().getConstructPercent() - 100;

	iProductionModifier += GC.getGame().getStartEraInfo().getConstructPercent() - 100;

	if(pkBuildingInfo->GetPrereqAndTech() != NO_TECH)
	{
		CvTechEntry* pkTechInfo = GC.getTechInfo((TechTypes)pkBuildingInfo->GetPrereqAndTech());
		if(pkTechInfo)
		{
			// Loop through all eras and apply Building production mod based on how much time has passed
			int iTotalEraMod = 0;
			EraTypes eBuildingUnlockedEra = (EraTypes) pkTechInfo->GetEra();

			if(eBuildingUnlockedEra < GetCurrentEra())
			{
				for(int iLoop = eBuildingUnlockedEra; iLoop < GetCurrentEra(); iLoop++)
				{
					CvAssertMsg(iLoop >= 0, "Loop should be within era bounds");
					CvAssertMsg(iLoop <GC.getNumEraInfos(), "Loop should be within era bounds");

					if(iLoop >= 0 && iLoop < GC.getNumEraInfos())
					{
						CvEraInfo* pkEraInfo = GC.getEraInfo((EraTypes)iLoop);
						if(pkEraInfo)
						{
							iTotalEraMod += pkEraInfo->getLaterEraBuildingConstructMod();
						}
					}
				}

				iProductionModifier += iTotalEraMod;
			}
		}
	}
	else
	{
		int iTotalEraMod = 0;
		for (int iLoop = 0; iLoop < GetCurrentEra(); iLoop++)
		{
			CvAssertMsg(iLoop >= 0, "Loop should be within era bounds");
			CvAssertMsg(iLoop <GC.getNumEraInfos(), "Loop should be within era bounds");

			if (iLoop >= 0 && iLoop < GC.getNumEraInfos())
			{
				CvEraInfo* pkEraInfo = GC.getEraInfo((EraTypes)iLoop);
				if (pkEraInfo)
				{
					iTotalEraMod += pkEraInfo->getLaterEraBuildingConstructMod();
				}
			}
		}

		iProductionModifier += iTotalEraMod;
	}

	if(!isHuman() && !IsAITeammateOfHuman() && !isBarbarian())
	{
		if(isWorldWonderClass(pkBuildingInfo->GetBuildingClassInfo()))
		{
			iProductionModifier += GC.getGame().getHandicapInfo().getAIWorldConstructPercent() - 100;
		}
		else
		{
			iProductionModifier += GC.getGame().getHandicapInfo().getAIConstructPercent() - 100;
		}

		iProductionModifier += std::max(0, ((GC.getGame().getHandicapInfo().getAIPerEraModifier() * GetCurrentEra()) + 100)) - 100;
	}

	iProductionNeeded *= (100 + iProductionModifier);
	iProductionNeeded /= 100;

	return std::max(1, iProductionNeeded);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getProductionNeeded(ProjectTypes eProject) const
{
	int iProductionNeeded;

	iProductionNeeded = GC.getProjectInfo(eProject)->GetProductionCost();

	if(isMinorCiv())
	{
		iProductionNeeded *= GC.getMINOR_CIV_PRODUCTION_PERCENT();
		iProductionNeeded /= 100;
	}

	iProductionNeeded *= GC.getPROJECT_PRODUCTION_PERCENT();
	iProductionNeeded /= 100;

	iProductionNeeded *= GC.getGame().getGameSpeedInfo().getCreatePercent();
	iProductionNeeded /= 100;

	iProductionNeeded *= GC.getGame().getStartEraInfo().getCreatePercent();
	iProductionNeeded /= 100;

	if(!isHuman() && !IsAITeammateOfHuman() && !isBarbarian())
	{
		if(isWorldProject(eProject))
		{
			iProductionNeeded *= GC.getGame().getHandicapInfo().getAIWorldCreatePercent();
			iProductionNeeded /= 100;
		}
		else
		{
			iProductionNeeded *= GC.getGame().getHandicapInfo().getAICreatePercent();
			iProductionNeeded /= 100;
		}

		iProductionNeeded *= std::max(0, ((GC.getGame().getHandicapInfo().getAIPerEraModifier() * GetCurrentEra()) + 100));
		iProductionNeeded /= 100;
	}

	return std::max(1, iProductionNeeded);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionNeeded(SpecialistTypes eSpecialist) const
{
	CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
	if(pkSpecialistInfo == NULL)
	{
		//This should never happen! If this does, fix the calling function!
		CvAssert(pkSpecialistInfo);
		return 0;
	}

	int iProductionNeeded;
	iProductionNeeded = pkSpecialistInfo->getCost();

	if(isMinorCiv())
	{
		iProductionNeeded *= GC.getMINOR_CIV_PRODUCTION_PERCENT();
		iProductionNeeded /= 100;
	}

	iProductionNeeded *= GC.getGame().getGameSpeedInfo().getCreatePercent();
	iProductionNeeded /= 100;

	iProductionNeeded *= GC.getGame().getStartEraInfo().getCreatePercent();
	iProductionNeeded /= 100;

	return std::max(1, iProductionNeeded);
}

#if defined(MOD_PROCESS_STOCKPILE)
//	--------------------------------------------------------------------------------
int CvPlayer::getMaxStockpile() const
{
	// The default of 30 hammers means a city can stockpile between 15% and 30% of the production of a World Wonder
	int iProdPerEra = gCustomMods.getOption("PROCESS_STOCKPILE_PER_ERA", 30);
	// Adjust for game speed
	iProdPerEra *= GC.getGame().getGameSpeedInfo().getConstructPercent();

	return ((GetCurrentEra() + 1) * iProdPerEra) / 100;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionModifier(CvString* toolTipSink) const
{
	int iMultiplier = 0;

	int iTempMod;

	// Unit Supply
	iTempMod = GetUnitProductionMaintenanceMod();
	iMultiplier += iTempMod;
	GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_UNIT_SUPPLY", iTempMod);

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionModifier(UnitTypes eUnit, CvString* toolTipSink) const
{
	int iMultiplier = getProductionModifier(toolTipSink);
	int iTempMod;

	CvUnitEntry* pUnitEntry = GC.getUnitInfo(eUnit);

	if(pUnitEntry)
	{
		// Military bonus
		if(pUnitEntry->IsMilitaryProduction())
		{
			iTempMod = getMilitaryProductionModifier();
			iMultiplier += iTempMod;
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_MILITARY_PLAYER", iTempMod);
		}

		// Settler bonus
		if(pUnitEntry->IsFound())
		{
			iTempMod = getSettlerProductionModifier();
			iMultiplier += iTempMod;
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_SETTLER_PLAYER", iTempMod);
		}

		// Unit Combat class bonus
		if(pUnitEntry->GetUnitCombatType() != NO_UNITCOMBAT)
		{
			iTempMod = getUnitCombatProductionModifiers((UnitCombatTypes) pUnitEntry->GetUnitCombatType());
			iMultiplier += iTempMod;
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_UNIT_COBMAT_CLASS_PLAYER", iTempMod);
		}

		// Trait bonus
		CvPlayerTraits* pPlayerTraits = GetPlayerTraits();
		std::vector<TraitTypes> vTraits = pPlayerTraits->GetPotentiallyActiveTraits();
		for(size_t iI = 0; iI < vTraits.size(); iI++)
		{
			if(pPlayerTraits->HasTrait(vTraits[iI]))
			{
				iMultiplier += pUnitEntry->GetProductionTraits(iI);

				if(pUnitEntry->GetSpecialUnitType() != NO_SPECIALUNIT)
				{
					CvSpecialUnitInfo* pkSpecialUnitInfo = GC.getSpecialUnitInfo((SpecialUnitTypes) pUnitEntry->GetSpecialUnitType());
					if(pkSpecialUnitInfo)
					{
						iTempMod = pkSpecialUnitInfo->getProductionTraits(iI);
						iMultiplier += iTempMod;
						GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_UNIT_TRAIT", iTempMod);
					}
				}
			}
		}
	}

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionModifier(BuildingTypes eBuilding, CvString* toolTipSink) const
{
	int iMultiplier = getProductionModifier(toolTipSink);
	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if(pkBuildingInfo == NULL)
	{
		return iMultiplier;
	}

	CvGame& kGame = GC.getGame();
	const CvBuildingClassInfo& kBuildingClassInfo = pkBuildingInfo->GetBuildingClassInfo();

	int iTempMod;

	CvPlayerTraits* pPlayerTraits = GetPlayerTraits();
	std::vector<TraitTypes> vTraits = pPlayerTraits->GetPotentiallyActiveTraits();
	for(size_t iI = 0; iI < vTraits.size(); iI++)
	{
		if(pPlayerTraits->HasTrait(vTraits[iI]))
		{
			iTempMod = pkBuildingInfo->GetProductionTraits(iI);
			iMultiplier += iTempMod;
			kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_BUILDING_TRAIT", iTempMod);
		}
	}

	// World Wonder
	if(::isWorldWonderClass(kBuildingClassInfo))
	{
		iTempMod = getMaxGlobalBuildingProductionModifier();
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WORLD_WONDER_PLAYER", iTempMod);
		iTempMod = m_pPlayerPolicies->GetNumericModifier(POLICYMOD_WONDER_PRODUCTION_MODIFIER);
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_POLICY", iTempMod);
	}

	// Team Wonder
	else if(::isTeamWonderClass(kBuildingClassInfo))
	{
		iTempMod = getMaxTeamBuildingProductionModifier();
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_TEAM_WONDER_PLAYER", iTempMod);
		iTempMod = m_pPlayerPolicies->GetNumericModifier(POLICYMOD_WONDER_PRODUCTION_MODIFIER);
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_POLICY", iTempMod);
	}

	// National Wonder
	else if(::isNationalWonderClass(kBuildingClassInfo))
	{
		iTempMod = getMaxPlayerBuildingProductionModifier();
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_NATIONAL_WONDER_PLAYER", iTempMod);
		iTempMod = m_pPlayerPolicies->GetNumericModifier(POLICYMOD_WONDER_PRODUCTION_MODIFIER);
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_POLICY", iTempMod);
	}

	// Normal Building
	else
	{
		iTempMod = m_pPlayerPolicies->GetNumericModifier(POLICYMOD_BUILDING_PRODUCTION_MODIFIER);
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_BUILDING_POLICY_PLAYER", iTempMod);
	}

	// Religion
	if(pkBuildingInfo->IsReligious())
	{
		iTempMod = m_pPlayerPolicies->GetNumericModifier(POLICYMOD_RELIGION_PRODUCTION_MODIFIER);
		iMultiplier += iTempMod;
		kGame.BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_RELIGION_PLAYER", iTempMod);
	}

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionModifier(ProjectTypes eProject, CvString* toolTipSink) const
{
	int iMultiplier = getProductionModifier(toolTipSink);
	int iTempMod;

	if(GC.getProjectInfo(eProject)->IsSpaceship())
	{
		iTempMod = getSpaceProductionModifier();
		iMultiplier += iTempMod;
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_SPACE_PLAYER", iTempMod);
	}

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionModifier(SpecialistTypes, CvString* toolTipSink) const
{
	int iMultiplier = getProductionModifier(toolTipSink);
	int iTempMod;

	iTempMod = getSpecialistProductionModifier();
	iMultiplier += iTempMod;
	GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_SPECIALIST_PLAYER", iTempMod);

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getProductionModifier(ProcessTypes /*eProcess*/, CvString* toolTipSink) const
{
	int iMultiplier = getProductionModifier(toolTipSink);

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getBuildingClassPrereqBuilding(BuildingTypes eBuilding, BuildingClassTypes ePrereqBuildingClass, int iExtra) const
{
	CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
	if(pkBuilding == NULL)
	{
		CvAssertMsg(pkBuilding, "Should never happen...");
		return -1;
	}

	int iPrereqs = pkBuilding->GetPrereqNumOfBuildingClass(ePrereqBuildingClass);

	// dont bother with the rest of the calcs if we have no prereqs
	if(iPrereqs == 0)
	{
		return 0;
	}
	// -1 means Building is needed in all Cities
	else if(iPrereqs == -1)
	{
#if defined(MOD_BUILDINGS_NW_EXCLUDE_RAZING)
		BuildingTypes ePrereqBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(ePrereqBuildingClass);
#endif
		int iNonPuppetCities = 0;
		int iLoop = 0;
		const CvCity* pLoopCity = NULL;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity && !pLoopCity->IsPuppet())
			{
#if defined(MOD_BUILDINGS_NW_EXCLUDE_RAZING)
				// Don't count this city if it is being razed and doesn't already have the pre-req building
				if (!(MOD_BUILDINGS_NW_EXCLUDE_RAZING && pLoopCity->IsRazing() && pLoopCity->GetCityBuildings()->GetNumBuilding(ePrereqBuilding) == 0))
#endif
				iNonPuppetCities++;
			}
		}

		return iNonPuppetCities;
	}
	else
	{
		iPrereqs *= std::max(0, GC.getMap().getWorldInfo().getBuildingClassPrereqModifier() + 100);
		iPrereqs /= 100;
	}

	if(!isLimitedWonderClass(pkBuilding->GetBuildingClassInfo()))
	{
		BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkBuilding->GetBuildingClassType();
		iPrereqs *= (getBuildingClassCount(eBuildingClass) + iExtra + 1);
	}

	bool OCC = GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE);
	if (OCC && isHuman())
	{
		iPrereqs = std::min(1, iPrereqs);
	}
#if defined(MOD_BALANCE_CORE)
	//Poor Venice got ignored here...
	if (MOD_BALANCE_CORE && OCC || GET_PLAYER(GetID()).GetPlayerTraits()->IsNoAnnexing())
	{
		iPrereqs = std::min(1, iPrereqs);
	}
#endif

	return iPrereqs;
}


//	--------------------------------------------------------------------------------
void CvPlayer::removeBuildingClass(BuildingClassTypes eBuildingClass)
{
	CvCity* pLoopCity;
	BuildingTypes eBuilding;
	int iLoop;

	eBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(eBuildingClass)));

	if(eBuilding != NO_BUILDING)
	{
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity->GetCityBuildings()->GetNumRealBuilding(eBuilding) > 0)
			{
				pLoopCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, 0);
				break;
			}
		}
	}
}

//	--------------------------------------------------------------------------------
// What is the effect of a building on the player?
void CvPlayer::processBuilding(BuildingTypes eBuilding, int iChange, bool bFirst, CvArea* pArea)
{
	int iI, iJ;

	CvBuildingEntry* pBuildingInfo = GC.getBuildingInfo(eBuilding);
	if(pBuildingInfo == NULL)
		return;

	// One-shot items
	if(bFirst && iChange > 0)
	{
		// Free Policies
		int iFreePolicies = pBuildingInfo->GetFreePolicies();
		if(iFreePolicies > 0)
			ChangeNumFreePolicies(iFreePolicies);

		int iFreeGreatPeople = pBuildingInfo->GetFreeGreatPeople();
		if(iFreeGreatPeople > 0)
			ChangeNumFreeGreatPeople(iFreeGreatPeople);

		// Golden Age
		if(pBuildingInfo->IsGoldenAge())
		{
			int iGoldenAgeTurns = getGoldenAgeLength();
#if defined(MOD_BALANCE_CORE)
			int iValue = GetGoldenAgeProgressMeter();
			changeGoldenAgeTurns(iGoldenAgeTurns, iValue, true);
#else
			changeGoldenAgeTurns(iGoldenAgeTurns);
#endif
		}

		// Global Pop change
		if(pBuildingInfo->GetGlobalPopulationChange() != 0)
		{
			CvCity* pLoopCity;
			int iLoop;

			for(iI = 0; iI < MAX_PLAYERS; iI++)
			{
				if(GET_PLAYER((PlayerTypes)iI).isAlive())
				{
					if(GET_PLAYER((PlayerTypes)iI).getTeam() == getTeam())
					{
						if(pBuildingInfo->IsTeamShare() || (iI == GetID()))
						{
							for(pLoopCity = GET_PLAYER((PlayerTypes)iI).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER((PlayerTypes)iI).nextCity(&iLoop))
							{
								pLoopCity->setPopulation(std::max(1, (pLoopCity->getPopulation() + iChange * GC.getBuildingInfo(eBuilding)->GetGlobalPopulationChange())));
							}
						}
					}
				}
			}
		}

		// Free techs
		if(pBuildingInfo->GetFreeTechs() > 0)
		{
			if(!isHuman())
			{
				for(iI = 0; iI < pBuildingInfo->GetFreeTechs(); iI++)
				{
					for(int iLoop = 0; iLoop < iChange; iLoop++)
						AI_chooseFreeTech();
				}
			}
			else
			{
				Localization::String localizedText = Localization::Lookup("TXT_KEY_MISC_COMPLETED_WONDER_CHOOSE_TECH");
				localizedText << pBuildingInfo->GetTextKey();
				chooseTech(pBuildingInfo->GetFreeTechs() * iChange, localizedText.toUTF8());
			}
		}
		if(pBuildingInfo->GetMedianTechPercentChange() > 0)
		{
			ChangeMedianTechPercentage(pBuildingInfo->GetMedianTechPercentChange());
		}

		if(pBuildingInfo->GetExtraSpies() > 0)
		{
			CvPlayerEspionage* pEspionage = GetEspionage();
			CvAssertMsg(pEspionage, "pEspionage is null! What's up with that?!");
			if(pEspionage)
			{
				int iNumSpies = pBuildingInfo->GetExtraSpies();
#if defined(MOD_BALANCE_CORE_SPIES)
				if (MOD_BALANCE_CORE_SPIES) {
					//Optional: Spies scaled for the number of City-States in the game.
					int iNumMinor = ((GC.getGame().GetNumMinorCivsEver() * /*15*/ GC.getBALANCE_SPY_TO_MINOR_RATIO()) / 100);
					if(iNumMinor > 1)
					{
						iNumSpies += iNumMinor;
					}
				}
#endif
				for(int i = 0; i < iNumSpies; i++)
				{
					pEspionage->CreateSpy();
				}
			}
		}

		if(pBuildingInfo->GetInstantSpyRankChange() > 0)
		{
			CvPlayerEspionage* pEspionage = GetEspionage();
			CvAssertMsg(pEspionage, "pEspionage is null! What's up with that?!");
			if(pEspionage)
			{
				for(uint ui = 0; ui < pEspionage->m_aSpyList.size(); ui++)
				{
					pEspionage->LevelUpSpy(ui);
				}
			}
		}

		if(pBuildingInfo->GetSpyRankChange() > 0)
		{
			ChangeStartingSpyRank(pBuildingInfo->GetSpyRankChange());
		}

		// Free Gold
		if(pBuildingInfo->GetGold() > 0)
			GetTreasury()->ChangeGold(pBuildingInfo->GetGold());

		// Instant Friendship change with all Minors
		int iMinorFriendshipChange = pBuildingInfo->GetMinorFriendshipChange();
		if(iMinorFriendshipChange != 0)
		{
			int iNewValue;
			iMinorFriendshipChange += 100;	// Make it a mod

			for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
			{
				iNewValue = GET_PLAYER((PlayerTypes) iMinorLoop).GetMinorCivAI()->GetBaseFriendshipWithMajorTimes100(GetID());
				iNewValue *= iMinorFriendshipChange;
				iNewValue /= 100;

				GET_PLAYER((PlayerTypes) iMinorLoop).GetMinorCivAI()->SetFriendshipWithMajorTimes100(GetID(), iNewValue);
			}
		}
	}
#if defined(MOD_BALANCE_CORE)
	for(int iDomains = 0; iDomains < NUM_DOMAIN_TYPES; iDomains++)
	{
		if((DomainTypes)iDomains != NO_DOMAIN)
		{
			if(pBuildingInfo->GetDomainFreeExperiencePerGreatWorkGlobal(iDomains) > 0)
			{
				ChangeDomainFreeExperiencePerGreatWorkGlobal((DomainTypes)iDomains, pBuildingInfo->GetDomainFreeExperiencePerGreatWorkGlobal(iDomains));
			}
		}
	}

	ChangeReformationFollowerReduction(pBuildingInfo->GetReformationFollowerReduction() * iChange);
	ChangeNumMissionarySpreads(pBuildingInfo->GetExtraMissionarySpreadsGlobal() * iChange);

	if (pBuildingInfo->NullifyInfluenceModifier())
	{
		if (iChange > 0)
			SetNullifyInfluenceModifier(true);
		else
			SetNullifyInfluenceModifier(false);
	}

	if(pBuildingInfo->IsSecondaryPantheon())
	{
		ChangeSecondReligionPantheonCount((pBuildingInfo->IsSecondaryPantheon()) ? iChange : 0);
	}
	if(pBuildingInfo->GetTRSpeedBoost() != 0)
	{
		ChangeTRSpeedBoost(pBuildingInfo->GetTRSpeedBoost() * iChange);
	}
	if(pBuildingInfo->GetTRVisionBoost() != 0)
	{
		ChangeTRVisionBoost(pBuildingInfo->GetTRVisionBoost() * iChange);
	}
	if(pBuildingInfo->GetVotesPerGPT() != 0)
	{
		ChangeVotesPerGPT(pBuildingInfo->GetVotesPerGPT() * iChange);
	}
	if(pBuildingInfo->GetGlobalBuildingGoldMaintenanceMod() != 0)
	{
		ChangeBuildingMaintenanceMod(pBuildingInfo->GetGlobalBuildingGoldMaintenanceMod() * iChange);
	}
	if(pBuildingInfo->GetEventTourism() != 0)
	{
		ChangeEventTourism(pBuildingInfo->GetEventTourism() * iChange);
	}
	if(pBuildingInfo->GetSingleVotes() > 0)
	{
		ChangeSingleVotes(pBuildingInfo->GetSingleVotes() * iChange);
	}

	if (pBuildingInfo->GetExtraMissionaryStrength() != 0)
	{
		ChangeMissionaryExtraStrength(pBuildingInfo->GetExtraMissionaryStrength() * iChange);
	}

	if(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS && pBuildingInfo->GetPovertyHappinessChangeBuildingGlobal() != 0)
	{
		ChangePovertyUnhappinessGlobal(pBuildingInfo->GetPovertyHappinessChangeBuildingGlobal() * iChange);
	}
	if(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS && pBuildingInfo->GetDefenseHappinessChangeBuildingGlobal() != 0)
	{
		ChangeDefenseUnhappinessGlobal(pBuildingInfo->GetDefenseHappinessChangeBuildingGlobal() * iChange);
	}
	if(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS && pBuildingInfo->GetIlliteracyHappinessChangeBuildingGlobal() != 0)
	{
		ChangeIlliteracyUnhappinessGlobal(pBuildingInfo->GetIlliteracyHappinessChangeBuildingGlobal() * iChange);
	}
	if(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS && pBuildingInfo->GetUnculturedHappinessChangeBuildingGlobal() != 0)
	{
		ChangeUnculturedUnhappinessGlobal(pBuildingInfo->GetUnculturedHappinessChangeBuildingGlobal() * iChange);
	}
	if(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS && pBuildingInfo->GetMinorityHappinessChangeBuildingGlobal() != 0)
	{
		ChangeMinorityUnhappinessGlobal(pBuildingInfo->GetMinorityHappinessChangeBuildingGlobal() * iChange);
	}
	ChangeLandmarksTourismPercentGlobal(pBuildingInfo->GetLandmarksTourismPercentGlobal() * iChange);
	ChangeGreatWorksTourismModifierGlobal(pBuildingInfo->GetGreatWorksTourismModifierGlobal() * iChange);

	ChangeExtraSupplyPerPopulation(pBuildingInfo->GetCitySupplyModifierGlobal() * iChange);
	changeCitySupplyFlatGlobal(pBuildingInfo->GetCitySupplyFlatGlobal() * iChange);

	if (pBuildingInfo->AllowsProductionTradeRoutesGlobal())
	{
		if (iChange > 0)
			SetProductionRoutesAllCities(true);
		else
			SetProductionRoutesAllCities(false);
	}
	if (pBuildingInfo->AllowsFoodTradeRoutesGlobal())
	{
		if (iChange > 0)
			SetFoodRoutesAllCities(true);
		else
			SetFoodRoutesAllCities(false);
	}
#endif

	if(pBuildingInfo->GetFreeBuildingClass() != NO_BUILDINGCLASS)
	{
		BuildingTypes eFreeBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(pBuildingInfo->GetFreeBuildingClass());
		changeFreeBuildingCount(eFreeBuilding, iChange);
	}

	// Unit upgrade cost mod
	ChangeUnitUpgradeCostMod(pBuildingInfo->GetUnitUpgradeCostMod() * iChange);

	// Policy cost mod
	ChangePolicyCostBuildingModifier(pBuildingInfo->GetPolicyCostModifier() * iChange);

	// Border growth mods
	ChangePlotCultureCostModifier(pBuildingInfo->GetGlobalPlotCultureCostModifier() * iChange);
	ChangePlotGoldCostMod(pBuildingInfo->GetGlobalPlotBuyCostModifier() * iChange);
#if defined(MOD_BUILDINGS_CITY_WORKING)
	ChangeCityWorkingChange(pBuildingInfo->GetGlobalCityWorkingChange() * iChange);
#endif

	// City Culture Mod
	ChangeJONSCultureCityModifier(pBuildingInfo->GetGlobalCultureRateModifier() * iChange);

	// Trade route gold modifier
	GetTreasury()->ChangeCityConnectionTradeRouteGoldModifier(pBuildingInfo->GetCityConnectionTradeRouteModifier() * iChange);

	// Free Promotion
	PromotionTypes eFreePromotion = (PromotionTypes) pBuildingInfo->GetFreePromotion();
	if(eFreePromotion != NO_PROMOTION)
		ChangeFreePromotionCount(eFreePromotion, iChange);

	// Free Promotion Removed
	PromotionTypes eFreePromotionRemoved = (PromotionTypes) pBuildingInfo->GetFreePromotionRemoved();
	if(eFreePromotionRemoved != NO_PROMOTION)
		ChangeFreePromotionCount(eFreePromotionRemoved, -iChange);

	// Extra Happiness Per City
	ChangeExtraHappinessPerCity(pBuildingInfo->GetHappinessPerCity() * iChange);

	// Extra Happiness Per Policy
	ChangeExtraHappinessPerXPolicies(pBuildingInfo->GetHappinessPerXPolicies() * iChange);

	// City Count Unhappiness Mod
	ChangeCityCountUnhappinessMod(pBuildingInfo->GetCityCountUnhappinessMod() * iChange);

	// Hurries
	for(iI = 0; iI < GC.getNumHurryInfos(); iI++)
	{
		changeHurryModifier((HurryTypes) iI, (pBuildingInfo->GetHurryModifier(iI) * iChange));
	}

	changeGreatPeopleRateModFromBldgs(pBuildingInfo->GetGlobalGreatPeopleRateModifier() * iChange);
	changeGreatGeneralRateModFromBldgs(pBuildingInfo->GetGreatGeneralRateModifier() * iChange);
	ChangeGreatScientistBeakerMod(pBuildingInfo->GetGreatScientistBeakerModifier() * iChange);
	ChangeGreatPersonExpendGold(pBuildingInfo->GetGreatPersonExpendGold() * iChange);
#if defined(MOD_DIPLOMACY_CITYSTATES)
	if (MOD_DIPLOMACY_CITYSTATES) ChangeGPExpendInfluence(pBuildingInfo->GetGPExpendInfluence() * iChange);
#endif
	recomputeGreatPeopleModifiers();

	changeGoldenAgeModifier(pBuildingInfo->GetGoldenAgeModifier() * iChange);
	changeFreeExperienceFromBldgs(pBuildingInfo->GetGlobalFreeExperience() * iChange);
	changeWorkerSpeedModifier(pBuildingInfo->GetWorkerSpeedModifier() * iChange);
	ChangeSpecialistCultureChange(pBuildingInfo->GetSpecialistExtraCulture() * iChange);
	changeBorderObstacleCount(pBuildingInfo->IsPlayerBorderObstacle() * iChange);

#if defined(HH_MOD_BUILDINGS_FRUITLESS_PILLAGE)
	changeBorderGainlessPillageCount(pBuildingInfo->IsPlayerBorderGainlessPillage() * iChange);
#endif
	changeSpaceProductionModifier(pBuildingInfo->GetGlobalSpaceProductionModifier() * iChange);

	for(iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		pArea->changeYieldRateModifier(GetID(), ((YieldTypes)iI), (pBuildingInfo->GetAreaYieldModifier(iI) * iChange));
		changeYieldRateModifier(((YieldTypes)iI), (pBuildingInfo->GetGlobalYieldModifier(iI) * iChange));
#if defined(MOD_BALANCE_CORE_POLICIES)
		changeYieldFromDeath(((YieldTypes)iI), (pBuildingInfo->GetYieldFromDeath(iI) * iChange));
#endif
#if defined(MOD_BALANCE_CORE)
		changeYieldGPExpend(((YieldTypes)iI), (pBuildingInfo->GetYieldFromGPExpend(iI) * iChange));
		int iMod = pBuildingInfo->GetGreatWorkYieldChange(iI) * iChange;
		if(iMod != 0)
		{
			ChangeGreatWorkYieldChange((YieldTypes)iI, iMod);
		}
#endif
	}

	for(iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
	{
		for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
		{
			changeSpecialistExtraYield(((SpecialistTypes)iI), ((YieldTypes)iJ), (pBuildingInfo->GetSpecialistYieldChange(iI, iJ) * iChange));
		}
	}

	int iOldEspionageModifier = GetEspionageModifier();
	ChangeEspionageModifier(pBuildingInfo->GetGlobalEspionageModifier() * iChange);
	if(iOldEspionageModifier != GetEspionageModifier())
	{
		int iLoop;
		CvCity* pLoopCity;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
			{
				PlayerTypes ePlayer = (PlayerTypes)ui;
				GET_PLAYER(ePlayer).GetEspionage()->UpdateCity(pLoopCity);
			}
		}
	}

	ChangeExtraLeagueVotes(pBuildingInfo->GetExtraLeagueVotes() * iChange);
#if defined(MOD_BALANCE_CORE_SPIES)
	if(MOD_BALANCE_CORE_SPIES)
	{
		if(pBuildingInfo->GetAdvancedActionGold() > 0)
		{
			changeAdvancedActionGold(pBuildingInfo->GetAdvancedActionGold() * iChange);
		}
		if(pBuildingInfo->GetAdvancedActionScience() > 0)
		{
			changeAdvancedActionScience(pBuildingInfo->GetAdvancedActionScience() * iChange);
		}
		if(pBuildingInfo->GetAdvancedActionUnrest() > 0)
		{
			changeAdvancedActionUnrest(pBuildingInfo->GetAdvancedActionUnrest() * iChange);
		}
		if(pBuildingInfo->GetAdvancedActionRebellion() > 0)
		{
			changeAdvancedActionRebellion(pBuildingInfo->GetAdvancedActionRebellion() * iChange);
		}
		if(pBuildingInfo->GetAdvancedActionGP() > 0)
		{
			changeAdvancedActionGP(pBuildingInfo->GetAdvancedActionGP() * iChange);
		}
		if(pBuildingInfo->GetAdvancedActionUnit() > 0)
		{
			changeAdvancedActionUnit(pBuildingInfo->GetAdvancedActionUnit() * iChange);
		}
		if(pBuildingInfo->GetAdvancedActionWonder() > 0)
		{
			changeAdvancedActionWonder(pBuildingInfo->GetAdvancedActionWonder() * iChange);
		}
		if(pBuildingInfo->GetAdvancedActionBuilding() > 0)
		{
			changeAdvancedActionBuilding(pBuildingInfo->GetAdvancedActionBuilding() * iChange);
		}
		if(pBuildingInfo->GetCannotFailSpies() > 0)
		{
			changeCannotFailSpies(pBuildingInfo->GetCannotFailSpies() * iChange);
		}
	}
	for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
	{
		YieldTypes eYield = (YieldTypes) iJ;
		for(int iK = 0; iK < GC.getNumImprovementInfos(); iK++)
		{
			ImprovementTypes eImprovement = (ImprovementTypes)iK;
			if(eImprovement != NO_IMPROVEMENT)
			{
				int iYieldChange = pBuildingInfo->GetImprovementYieldChangeGlobal(eImprovement, eYield);
				if(iYieldChange != 0)
				{
					ChangeImprovementExtraYield(eImprovement, eYield, (iYieldChange * iChange));
				}
			}
		}
	}

#endif
	// Loop through Cities
	int iLoop;
	CvCity* pLoopCity;
	int iBuildingCount;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		// Building modifiers
		BuildingClassTypes eBuildingClass;
		for(iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
		{
			eBuildingClass = (BuildingClassTypes) iI;

			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
			if(!pkBuildingClassInfo)
			{
				continue;
			}

			BuildingTypes eTestBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

			if(eTestBuilding != NO_BUILDING)
			{
				CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eTestBuilding);
				if(pkBuilding)
				{
					iBuildingCount = pLoopCity->GetCityBuildings()->GetNumBuilding(eTestBuilding);
					if(iBuildingCount > 0)
					{
#if !defined(MOD_API_UNIFIED_YIELDS_CONSOLIDATION)
						pLoopCity->ChangeJONSCulturePerTurnFromBuildings(pBuildingInfo->GetBuildingClassYieldChange(eBuildingClass, YIELD_CULTURE) * iBuildingCount * iChange);
#endif

						// Building Class Yield Stuff
						for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
						{
#if !defined(MOD_API_UNIFIED_YIELDS_CONSOLIDATION)
							switch(iJ)
							{
							case YIELD_CULTURE:
							{
								// Skip, handled above
								break;
							}
							case YIELD_FAITH:
							{
								pLoopCity->ChangeFaithPerTurnFromBuildings(pBuildingInfo->GetBuildingClassYieldChange(eBuildingClass, iJ) * iBuildingCount * iChange);
								break;
							}
							default:
							{
#endif
								YieldTypes eYield = (YieldTypes) iJ;
								int iYieldChange = pBuildingInfo->GetBuildingClassYieldChange(eBuildingClass, eYield);
								if(iYieldChange > 0)
								{
									pLoopCity->ChangeBaseYieldRateFromBuildings(eYield, iYieldChange * iBuildingCount * iChange);
								}

								int iYieldMod = pBuildingInfo->GetBuildingClassYieldModifier(eBuildingClass, eYield);
								if (iYieldMod != 0)
								{
									pLoopCity->changeYieldRateModifier(eYield, iYieldMod * iBuildingCount * iChange);
								}
#if !defined(MOD_API_UNIFIED_YIELDS_CONSOLIDATION)
							}
							}
#endif
						}
					}
				}

			}
		}
	}
#if defined(MOD_BALANCE_CORE)
	//Refresh cache data.
	countNumBuildings(eBuilding, true);
	countNumBuildingsInPuppets(eBuilding, true);
	DoUpdateHappinessFromBuildings(); // fix for 3939, this function needs player's building count already updated!
#endif
}

//	--------------------------------------------------------------------------------
/// Get yield change from buildings for a specific building class
int CvPlayer::GetBuildingClassYieldChange(BuildingClassTypes eBuildingClass, YieldTypes eYieldType)
{
	int rtnValue = 0;

	CvBuildingXMLEntries* pBuildings = GC.GetGameBuildings();

	if(pBuildings)
	{
		for(int i = 0; i < pBuildings->GetNumBuildings(); i++)
		{
			// Do we have this building anywhere in empire?
			int iNum = countNumBuildings((BuildingTypes)i);

			if(iNum > 0)
			{
				CvBuildingEntry* pEntry = pBuildings->GetEntry(i);
				if(pEntry)
				{
					rtnValue += (pEntry->GetBuildingClassYieldChange(eBuildingClass, eYieldType) * iNum);
				}
			}
		}
	}

#if defined(MOD_BALANCE_CORE)
	CorporationTypes eCorporation = GetCorporations()->GetFoundedCorporation();
	if (eCorporation != NO_CORPORATION)
	{
		CvCorporationEntry* pkCorporation = GC.getCorporationInfo(eCorporation);
		if (pkCorporation)
		{
			rtnValue += pkCorporation->GetBuildingClassYieldChange(eBuildingClass, eYieldType);
		}
	}
#endif

	return rtnValue;
}

//	--------------------------------------------------------------------------------
/// Get yield change from buildings for a specific building class
int CvPlayer::GetBuildingClassYieldModifier(BuildingClassTypes eBuildingClass, YieldTypes eYieldType)
{
	int rtnValue = 0;

	CvBuildingXMLEntries* pBuildings = GC.GetGameBuildings();

	if (pBuildings)
	{
		for (int i = 0; i < pBuildings->GetNumBuildings(); i++)
		{
			// Do we have this building anywhere in empire?
			int iNum = countNumBuildings((BuildingTypes)i);

			if (iNum > 0)
			{
				CvBuildingEntry* pEntry = pBuildings->GetEntry(i);
				if (pEntry)
				{
					rtnValue += (pEntry->GetBuildingClassYieldModifier(eBuildingClass, eYieldType) * iNum);
				}
			}
		}
	}

	return rtnValue;
}

//	--------------------------------------------------------------------------------
/// Can we eBuild on pPlot?
bool CvPlayer::canBuild(const CvPlot* pPlot, BuildTypes eBuild, bool bTestEra, bool bTestVisible, bool bTestGold, bool bTestPlotOwner) const
{
	if(!(pPlot->canBuild(eBuild, GetID(), bTestVisible, bTestPlotOwner)))
	{
		return false;
	}

	if(GC.getBuildInfo(eBuild)->getTechPrereq() != NO_TECH)
	{
		if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)GC.getBuildInfo(eBuild)->getTechPrereq())))
		{
			if((!bTestEra && !bTestVisible) || ((GetCurrentEra() + 1) < GC.getTechInfo((TechTypes) GC.getBuildInfo(eBuild)->getTechPrereq())->GetEra()))
			{
				return false;
			}
		}
	}
#if defined(MOD_BALANCE_CORE)
	if(MOD_BALANCE_CORE && GC.getBuildInfo(eBuild)->getTechObsolete() != NO_TECH)
	{
		if((GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)GC.getBuildInfo(eBuild)->getTechObsolete())))
		{
			return false;
		}
	}
#endif


	// Is this an improvement that is only useable by a specific civ?
	ImprovementTypes eImprovement = (ImprovementTypes)GC.getBuildInfo(eBuild)->getImprovement();
	if(eImprovement != NO_IMPROVEMENT)
	{
		CvImprovementEntry* pkEntry = GC.getImprovementInfo(eImprovement);
		if(pkEntry->IsSpecificCivRequired())
		{
			CivilizationTypes eCiv = pkEntry->GetRequiredCivilization();
			if(eCiv != getCivilizationType())
			{
				return false;
			}
		}
	}

	if(!bTestVisible)
	{
		if(IsBuildBlockedByFeature(eBuild, pPlot->getFeatureType()))
		{
			return false;
		}

		if(bTestGold)
		{
			if(std::max(0, GetTreasury()->GetGold()) < getBuildCost(pPlot, eBuild))
			{
				return false;
			}
		}
	}

	return true;
}

//	--------------------------------------------------------------------------------
/// Are we prevented from eBuild-ing because of a Feature on this plot?
bool CvPlayer::IsBuildBlockedByFeature(BuildTypes eBuild, FeatureTypes eFeature) const
{
	// No Feature here to block us
	if(eFeature == NO_FEATURE)
	{
		return false;
	}

	// Build does not remove the Feature on pPlot
	if(!GC.getBuildInfo(eBuild)->isFeatureRemove(eFeature))
	{
		return false;
	}

	TechTypes ePrereqTech = (TechTypes) GC.getBuildInfo(eBuild)->getFeatureTech(eFeature);

	// Clearing Feature doesn't require any Tech, so we can do it right now if we have to
	if(ePrereqTech == NO_TECH)
	{
		return false;
	}

	// Clearing eFeature requires a Tech, but we have it
	if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech(ePrereqTech))
	{
		return false;
	}

	// Feature is blocking us!
	return true;
}

//	--------------------------------------------------------------------------------
// Returns the cost
int CvPlayer::getBuildCost(const CvPlot* pPlot, BuildTypes eBuild) const
{
	CvAssert(eBuild >= 0 && eBuild < GC.getNumBuildInfos());


	CvBuildInfo* pkBuildInfo = GC.getBuildInfo(eBuild);
	if(pkBuildInfo == NULL)
	{
		return 0;
	}

	if(pPlot->getBuildProgress(eBuild) > 0)
	{
		return 0;
	}

	if(pPlot->getRouteType() != NO_ROUTE && pPlot->getRouteType() == pkBuildInfo->getRoute() && pPlot->IsRoutePillaged())
	{
		return 0;
	}

	int iBuildCost = pkBuildInfo->getCost();

	// Cost increases as more Improvements are built
	iBuildCost += (getTotalImprovementsBuilt() * pkBuildInfo->getCostIncreasePerImprovement());

	iBuildCost *= (100 + getImprovementCostModifier());
	iBuildCost /= 100;

	if(pPlot->getFeatureType() != NO_FEATURE)
	{
		iBuildCost += pkBuildInfo->getFeatureCost(pPlot->getFeatureType());
	}

	iBuildCost *= getHandicapInfo().getImprovementCostPercent();
	iBuildCost /= 100;

	iBuildCost *= GC.getGame().getGameSpeedInfo().getImprovementPercent();
	iBuildCost /= 100;

	return std::max(0, iBuildCost);
}


//	--------------------------------------------------------------------------------
RouteTypes CvPlayer::getBestRoute(CvPlot* pPlot) const
{
	if (pPlot==NULL)
		return GET_TEAM(getTeam()).GetBestPossibleRoute();

	RouteTypes eRoute;
	RouteTypes eBestRoute;
	int iValue;
	int iBestValue;
	int iI;

	iBestValue = 0;
	eBestRoute = NO_ROUTE;

	for(iI = 0; iI < GC.getNumBuildInfos(); iI++)
	{
		const BuildTypes eBuild = static_cast<BuildTypes>(iI);
		CvBuildInfo* pkBuildInfo = GC.getBuildInfo(eBuild);
		if(pkBuildInfo)
		{
			eRoute = ((RouteTypes)(pkBuildInfo->getRoute()));
			if(eRoute != NO_ROUTE)
			{
				CvRouteInfo* pkRouteInfo = GC.getRouteInfo(eRoute);
				if(pkRouteInfo)
				{
					if( (pPlot->getRouteType() == eRoute) || canBuild(pPlot, eBuild) )
					{
#if defined(MOD_BALANCE_CORE)
						if(MOD_BALANCE_CORE && pkBuildInfo->getTechObsolete() == NO_TECH)
						{
							iValue = pkRouteInfo->getValue();
						}
						else if(MOD_BALANCE_CORE && !GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(pkBuildInfo->getTechObsolete())))
						{
							iValue = pkRouteInfo->getValue();
						}
						else
						{
							iValue = 0;
						}
#else
						iValue = pkRouteInfo->getValue();
#endif
						if(iValue > iBestValue)
						{
							iBestValue = iValue;
							eBestRoute = eRoute;
						}

					}
				}
			}
		}
	}

	return eBestRoute;
}


//	--------------------------------------------------------------------------------
int CvPlayer::getImprovementUpgradeRate() const
{
	int iRate;

	iRate = 100; // XXX

	iRate *= std::max(0, (getImprovementUpgradeRateModifier() + 100));
	iRate /= 100;

	return iRate;
}

//	--------------------------------------------------------------------------------
/// How much Production do we get from removing ANY Feature in the game? (Policy Bonus)
int CvPlayer::GetAllFeatureProduction() const
{
	return m_iAllFeatureProduction;
}

//	--------------------------------------------------------------------------------
/// Changes how much Production we get from removing ANY Feature in the game (Policy Bonus)
void CvPlayer::ChangeAllFeatureProduction(int iChange)
{
	if(iChange != 0)
	{
		m_iAllFeatureProduction += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// How far a tile is from a city (1-3) This is used to determine camera zoom on the city view
int CvPlayer::GetCityDistanceHighwaterMark() const
{
	return m_iCityDistanceHighwaterMark;
}

//	--------------------------------------------------------------------------------
/// Set how far a tile is from a city (1-3) This is used to determine camera zoom on the city view
void CvPlayer::SetCityDistanceHighwaterMark(int iNewValue)
{
	m_iCityDistanceHighwaterMark = iNewValue;
}


//	--------------------------------------------------------------------------------
int CvPlayer::calculateTotalYield(YieldTypes eYield) const
{
#if defined(MOD_API_UNIFIED_YIELDS)
	// This is based on the switch in CvEconomicAI::LogMonitor() that calls different methods for culture and faith
	// I've added this here as a "safe guard"
	if (eYield == YIELD_CULTURE)
	{
		return GetTotalJONSCulturePerTurn() + m_viInstantYieldsTotal[YIELD_CULTURE] / (GC.getGame().getElapsedGameTurns() + 1);
	}
	else if (eYield == YIELD_FAITH)
	{
		return GetTotalFaithPerTurn() + m_viInstantYieldsTotal[YIELD_FAITH] / (GC.getGame().getElapsedGameTurns() + 1);
	}
	else if (eYield == YIELD_TOURISM)
	{
		return GetCulture()->GetTourism() / 100 + m_viInstantYieldsTotal[YIELD_TOURISM] / (GC.getGame().getElapsedGameTurns() + 1);
	}
#endif

	const CvCity* pLoopCity;
	int iTotalYield = 0;
	int iLoop = 0;

	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iTotalYield += pLoopCity->getYieldRateTimes100(eYield, false);
	}

	//average accumulated instant yields over elapsed turns
	iTotalYield += (m_viInstantYieldsTotal[eYield] * 100) / (GC.getGame().getElapsedGameTurns() + 1);

	return iTotalYield / 100;
}

//	--------------------------------------------------------------------------------
/// How much does Production is being eaten up by Units? (cached)
int CvPlayer::GetUnitProductionMaintenanceMod() const
{
	// Kind of a cop-out, but it fixes some bugs for now
	return calculateUnitProductionMaintenanceMod();
}

//	--------------------------------------------------------------------------------
/// How much does Production is being eaten up by Units? (update cache)
void CvPlayer::UpdateUnitProductionMaintenanceMod()
{
	m_iUnitProductionMaintenanceMod = calculateUnitProductionMaintenanceMod();

	if(GetID() == GC.getGame().getActivePlayer())
	{
		GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
	}
}

//	--------------------------------------------------------------------------------
/// How much does Production is being eaten up by Units?
int CvPlayer::calculateUnitProductionMaintenanceMod() const
{
	int iPaidUnits = GetNumUnitsOutOfSupply();

	// Example: Player can support 8 Units, he has 12. 4 * 10 means he loses 40% of his Production
	int iNormal = 10;
#if defined(MOD_BALANCE_DYNAMIC_UNIT_SUPPLY)
	if (MOD_BALANCE_DYNAMIC_UNIT_SUPPLY)
	{
		iNormal = 5;
	}
#endif
	int iMaintenanceMod = min(/*70*/ GC.getMAX_UNIT_SUPPLY_PRODMOD(), iPaidUnits * iNormal);
	iMaintenanceMod = -iMaintenanceMod;

	return iMaintenanceMod;
}

//	--------------------------------------------------------------------------------
/// How much does Production is being eaten up by Units? (cached)
int CvPlayer::GetUnitGrowthMaintenanceMod() const
{
	// Kind of a cop-out, but it fixes some bugs for now
	return calculateUnitGrowthMaintenanceMod();
}

//	--------------------------------------------------------------------------------
/// How much does Production is being eaten up by Units? (update cache)
void CvPlayer::UpdateUnitGrowthMaintenanceMod()
{
	m_iUnitGrowthMaintenanceMod = calculateUnitGrowthMaintenanceMod();

	if (GetID() == GC.getGame().getActivePlayer())
	{
		GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
	}
}

//	--------------------------------------------------------------------------------
/// How much does Production is being eaten up by Units?
int CvPlayer::calculateUnitGrowthMaintenanceMod() const
{
	int iPaidUnits = GetNumUnitsOutOfSupply();

	// Example: Player can support 8 Units, he has 12. 4 * 10 means he loses 40% of his Production
	int iMaintenanceMod = min(/*70*/ GC.getMAX_UNIT_SUPPLY_PRODMOD(), iPaidUnits * 5);
	iMaintenanceMod = -iMaintenanceMod;

	return iMaintenanceMod;
}

//	--------------------------------------------------------------------------------
/// How many Units can we support for free without paying Production?
int CvPlayer::GetNumUnitsSupplied() const
{
	if (m_iNumUnitsSuppliedCached == -1)
	{

		int iFreeUnits = GetNumUnitsSuppliedByHandicap();
		iFreeUnits += GetNumUnitsSuppliedByCities();
		iFreeUnits += GetNumUnitsSuppliedByPopulation();
#if defined(MOD_BALANCE_DYNAMIC_UNIT_SUPPLY)
		if (MOD_BALANCE_DYNAMIC_UNIT_SUPPLY)
		{
			int iWarWeariness = GetCulture()->GetWarWeariness();
			int iMod = (100 - min(75, iWarWeariness));
			iFreeUnits *= iMod;
			iFreeUnits /= 100;
		}
#endif

		if (!isMinorCiv() && !isHuman() && !IsAITeammateOfHuman())
		{
			int iMod = (100 + GC.getGame().getHandicapInfo().getAIUnitSupplyPercent());
			iFreeUnits *= iMod;
			iFreeUnits /= 100;
		}

		m_iNumUnitsSuppliedCached = max(0,iFreeUnits);
	}

	return m_iNumUnitsSuppliedCached;
}

//	--------------------------------------------------------------------------------
/// Units supplied from Difficulty Level
int CvPlayer::GetNumUnitsSuppliedByHandicap(bool bIgnoreReduction) const
{
#if defined(MOD_TRAITS_EXTRA_SUPPLY)
	int iSupply = getHandicapInfo().getProductionFreeUnits() + m_pTraits->GetExtraSupply();
	if (MOD_BALANCE_DYNAMIC_UNIT_SUPPLY)
	{
		if (!bIgnoreReduction)
		{
			iSupply -= GetCurrentEra();
			if (iSupply <= 0)
				iSupply = 0;
		}
	}
	// Don't need a test here for MOD_TRAITS_EXTRA_SUPPLY being enabled, as if it isn't GetExtraSupply() will return 0
	return iSupply;
#else
	return getHandicapInfo().getProductionFreeUnits();
#endif
}

//	--------------------------------------------------------------------------------
/// Units supplied from Difficulty Level
int CvPlayer::GetNumUnitsSuppliedByCities(bool bIgnoreReduction) const
{
	if (MOD_BALANCE_DYNAMIC_UNIT_SUPPLY)
	{
		int iStartingSupply = getHandicapInfo().getProductionFreeUnitsPerCity();
		
		int iValue = m_pTraits->GetExtraSupply();
		const CvCity* pLoopCity;
		int iLoop;
		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			int iSupply = (iStartingSupply + pLoopCity->getCitySupplyFlat() + getCitySupplyFlatGlobal());
			iValue += iSupply;
		}

		if (!bIgnoreReduction)
		{
			int iTechProgress = (GET_TEAM(getTeam()).GetTeamTechs()->GetNumTechsKnown() * 100) / GC.getNumTechInfos();
			iTechProgress *= 5;
			iTechProgress /= 6;

			iValue *= 100;
			iValue /= (100 + iTechProgress);
		}
		if (iValue < 0)
			return 0;
		
		return iValue;
	}
#if defined(MOD_TRAITS_EXTRA_SUPPLY)
	// Don't need a test here for MOD_TRAITS_EXTRA_SUPPLY being enabled, as if it isn't GetExtraSupply() will return 0
	return ((getHandicapInfo().getProductionFreeUnitsPerCity() + m_pTraits->GetExtraSupply()) * getNumCities());
#else
	return getHandicapInfo().getProductionFreeUnitsPerCity() * getNumCities();
#endif
}

//	--------------------------------------------------------------------------------
/// Units supplied from Difficulty Level
int CvPlayer::GetNumUnitsSuppliedByPopulation(bool bIgnoreReduction) const
{
#if defined(MOD_TRAITS_EXTRA_SUPPLY)
	if (MOD_BALANCE_DYNAMIC_UNIT_SUPPLY)
	{
		int iStartingSupply = getHandicapInfo().getProductionFreeUnitsPopulationPercent();
		
		int iValue = 0;
		const CvCity* pLoopCity;
		int iLoop;
		
		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			int iPopulation = 0;
			int iSupply = (iStartingSupply + pLoopCity->getCitySupplyModifier() + m_pTraits->GetExtraSupplyPerPopulation() + GetExtraSupplyPerPopulation());
			if (pLoopCity->IsPuppet() && !GetPlayerTraits()->IsNoAnnexing())
			{
				iPopulation = (pLoopCity->getPopulation() / 2) * 100;
			}
			else
			{
				iPopulation = pLoopCity->getPopulation() * 100;
			}

			iValue += ((iPopulation * iSupply) / 100);
		}

		if (!bIgnoreReduction)
		{
			int iTechProgress = (GET_TEAM(getTeam()).GetTeamTechs()->GetNumTechsKnown() * 100) / GC.getNumTechInfos();
			iTechProgress *= 7;
				
			iValue *= 100;
			iValue /= (100 + iTechProgress);
		}

		iValue /= 100;

		if (iValue < 0)
			return 0;

		return iValue; 
	}
	// Don't need a test here for MOD_TRAITS_EXTRA_SUPPLY being enabled, as if it isn't GetExtraSupply() will return 0
	return getTotalPopulation() * (m_pTraits->GetExtraSupplyPerPopulation() + GetExtraSupplyPerPopulation() + getHandicapInfo().getProductionFreeUnitsPopulationPercent()) / 100;
#else
	return getTotalPopulation() * getHandicapInfo().getProductionFreeUnitsPopulationPercent() / 100;
#endif
}

//	--------------------------------------------------------------------------------
/// How much Units are eating Production?
int CvPlayer::GetNumUnitsOutOfSupply() const
{
	int iNumUnitsToSupply = getNumMilitaryUnits() - getNumUnitsSupplyFree();
	return std::max(0, iNumUnitsToSupply - GetNumUnitsSupplied());
}

#if defined(MOD_BALANCE_CORE)
int CvPlayer::GetNumUnitsToSupply() const
{
	return getNumMilitaryUnits() - getNumUnitsSupplyFree();
}

//these are mercenaries etc
int CvPlayer::getNumUnitsSupplyFree() const
{
	return m_iSupplyFreeUnits;
}

void CvPlayer::changeNumUnitsSupplyFree(int iValue)
{
	if (iValue != 0)
	{
		m_iSupplyFreeUnits += iValue;
	}
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::calculateUnitCost() const
{
	int iFreeUnits;
	int iPaidUnits;
	int iBaseUnitCost;
	int iExtraCost;

	return GetTreasury()->CalculateUnitCost(iFreeUnits, iPaidUnits, iBaseUnitCost, iExtraCost);
}

//	--------------------------------------------------------------------------------
int CvPlayer::calculateUnitSupply() const
{
	int iPaidUnits;
	int iBaseSupplyCost;

	return GetTreasury()->CalculateUnitSupply(iPaidUnits, iBaseSupplyCost);
}

//	--------------------------------------------------------------------------------
int CvPlayer::calculateResearchModifier(TechTypes eTech)
{
	int iModifier = 100;

	if(NO_TECH == eTech)
	{
		return iModifier;
	}

	int iKnownCount = 0;
	int iPossibleKnownCount = 0;
	for(int iI = 0; iI < MAX_CIV_TEAMS; iI++)
	{
		CvTeam& kLoopTeam = GET_TEAM((TeamTypes)iI);
		if(kLoopTeam.isAlive() && !kLoopTeam.isMinorCiv())
		{
#if defined(MOD_DIPLOMACY_TECH_BONUSES)
			bool bCouldBorrowTech;
			
			if (MOD_DIPLOMACY_TECH_BONUSES)
			{
#if defined(MOD_API_EXTENSIONS)
				if (GetEspionage()->GetNumSpies() > 0)
				{
					// We've got spies!  So we need one in a capital of a player in the other team
					bCouldBorrowTech = GET_TEAM(getTeam()).HasSpyAtTeam((TeamTypes)iI);
				}
				else
#endif
				{
					// No spies yet, so use embassy status
					bCouldBorrowTech = GET_TEAM(getTeam()).HasEmbassyAtTeam((TeamTypes)iI);
				}
			}
			else
			{
				bCouldBorrowTech = GET_TEAM(getTeam()).isHasMet((TeamTypes)iI);
			}
			
			if(bCouldBorrowTech)
#else
			if(GET_TEAM(getTeam()).isHasMet((TeamTypes)iI))
#endif
			{
				if(kLoopTeam.GetTeamTechs()->HasTech(eTech))
				{
					iKnownCount++;
				}
			}
			iPossibleKnownCount++;
		}
	}
	if(iPossibleKnownCount > 0)
	{
		iModifier += (GC.getTECH_COST_TOTAL_KNOWN_TEAM_MODIFIER() * iKnownCount) / iPossibleKnownCount;
	}

	int iPossiblePaths = 0;
	int iUnknownPaths = 0;
	for(int iI = 0; iI < GC.getNUM_OR_TECH_PREREQS(); iI++)
	{
		if(GC.getTechInfo(eTech)->GetPrereqOrTechs(iI) != NO_TECH)
		{
			if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)(GC.getTechInfo(eTech)->GetPrereqOrTechs(iI)))))
			{
				iUnknownPaths++;
			}

			iPossiblePaths++;
		}
	}
	CvAssertMsg(iPossiblePaths >= iUnknownPaths, "The number of possible paths is expected to match or exceed the number of unknown ones");
	iModifier += (iPossiblePaths - iUnknownPaths) * GC.getTECH_COST_KNOWN_PREREQ_MODIFIER();

	// Leagues mod
	int iLeaguesMod = GC.getGame().GetGameLeagues()->GetResearchMod(GetID(), eTech);
	if (iLeaguesMod != 0)
	{
#if defined(MOD_DIPLOMACY_CITYSTATES_RESOLUTIONS)
		if(MOD_DIPLOMACY_CITYSTATES_RESOLUTIONS && (!isMinorCiv() && !isBarbarian()))
		{
			//Research bonus for city-state alliances
			PlayerTypes eMinor;
			int iMinorAllies = 0;
			int iLeaguesAidScience = 0;
			for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
			{
				eMinor = (PlayerTypes) iMinorLoop;
				if(GET_PLAYER(eMinor).GetMinorCivAI()->IsAllies(GetID()))
				{
					iMinorAllies++;
				}
			}
			if(iMinorAllies > 0)
			{
				//+5% Science per ally.
				iLeaguesAidScience += min(50, (iMinorAllies * /*5*/ GC.getSCHOLAR_MINOR_ALLY_MULTIPLIER()));
				SetScienceRateFromMinorAllies(iLeaguesAidScience);
				iLeaguesMod += GetScienceRateFromMinorAllies();
			}
			else
			{
				SetScienceRateFromMinorAllies(0);
			}
		}
#endif
		iModifier *= (100 + iLeaguesMod);
		iModifier /= 100;
	}

	return iModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::calculateGoldRate() const
{
	return calculateGoldRateTimes100() / 100;
}


//	--------------------------------------------------------------------------------
int CvPlayer::calculateGoldRateTimes100() const
{
	// If we're in anarchy, then no Gold is collected!
	if(IsAnarchy())
	{
		return 0;
	}

	int iRate = 0;

	iRate = GetTreasury()->CalculateBaseNetGoldTimes100();

	return iRate;
}

//	--------------------------------------------------------------------------------
int CvPlayer::unitsRequiredForGoldenAge() const
{
	return (GC.getBASE_GOLDEN_AGE_UNITS() + (getNumUnitGoldenAges() * GC.getGOLDEN_AGE_UNITS_MULTIPLIER()));
}


//	--------------------------------------------------------------------------------
int CvPlayer::unitsGoldenAgeCapable() const
{
	const CvUnit* pLoopUnit;
	int iCount;
	int iLoop;

	iCount = 0;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->isGoldenAge())
		{
			iCount++;
		}
	}

	return iCount;
}


//	--------------------------------------------------------------------------------
int CvPlayer::unitsGoldenAgeReady() const
{
	const CvUnit* pLoopUnit;
	bool* pabUnitUsed;
	int iCount;
	int iLoop;
	int iI;

	pabUnitUsed = FNEW(bool[GC.getNumUnitInfos()], c_eCiv5GameplayDLL, 0);

	for(iI = 0; iI < GC.getNumUnitInfos(); iI++)
	{
		pabUnitUsed[iI] = false;
	}

	iCount = 0;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(!(pabUnitUsed[pLoopUnit->getUnitType()]))
		{
			if(pLoopUnit->isGoldenAge())
			{
				pabUnitUsed[pLoopUnit->getUnitType()] = true;
				iCount++;
			}
		}
	}

	SAFE_DELETE_ARRAY(pabUnitUsed);

	return iCount;
}

//	--------------------------------------------------------------------------------
int CvPlayer::greatGeneralThreshold() const
{
	int iThreshold;

	iThreshold = ((/*200*/ GC.getGREAT_GENERALS_THRESHOLD() * std::max(0, (getGreatGeneralsThresholdModifier() + 100))) / 100);

	UnitClassTypes eUnitClassGeneral = (UnitClassTypes)GC.getInfoTypeForString("UNITCLASS_GREAT_GENERAL");
	int iMod = GetPlayerTraits()->GetGreatPersonCostReduction(GetGreatPersonFromUnitClass(eUnitClassGeneral));
	if (iMod != 0)
	{
		iThreshold *= (100 + iMod);
		iThreshold /= 100;
	}

	iThreshold *= GC.getGame().getGameSpeedInfo().getTrainPercent();
	iThreshold /= 100;

	return std::max(1, iThreshold);
}

//	--------------------------------------------------------------------------------
int CvPlayer::greatAdmiralThreshold() const
{
	int iThreshold;

	iThreshold = ((/*200*/ GC.getGREAT_GENERALS_THRESHOLD() * std::max(0, (getGreatAdmiralsThresholdModifier() + 100))) / 100);

	UnitClassTypes eUnitClassAdmiral = (UnitClassTypes)GC.getInfoTypeForString("UNITCLASS_GREAT_ADMIRAL");
	int iMod = GetPlayerTraits()->GetGreatPersonCostReduction(GetGreatPersonFromUnitClass(eUnitClassAdmiral));
	if (iMod != 0)
	{
		iThreshold *= (100 + iMod);
		iThreshold /= 100;
	}

	iThreshold *= GC.getGame().getGameSpeedInfo().getTrainPercent();
	iThreshold /= 100;

	return std::max(1, iThreshold);
}

//	--------------------------------------------------------------------------------
int CvPlayer::specialistYield(SpecialistTypes eSpecialist, YieldTypes eYield) const
{
	CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
	if(pkSpecialistInfo == NULL)
	{
		//This function REQUIRES a valid specialist info.
		CvAssert(pkSpecialistInfo);
		return 0;
	}

	int iRtnValue = pkSpecialistInfo->getYieldChange(eYield) + getSpecialistExtraYield(eSpecialist, eYield) + GetPlayerTraits()->GetSpecialistYieldChange(eSpecialist, eYield);
#if defined(MOD_API_UNIFIED_YIELDS)
	iRtnValue += getSpecialistYieldChange(eSpecialist, eYield);
#endif

	if (eSpecialist != GC.getDEFAULT_SPECIALIST())
	{
		iRtnValue += getSpecialistExtraYield(eYield);
	}
	return (iRtnValue);
}

//	--------------------------------------------------------------------------------
/// How much additional Yield does every City produce?
#if defined(MOD_BUGFIX_MINOR)
int CvPlayer::GetCityYieldChangeTimes100(YieldTypes eYield) const
#else
int CvPlayer::GetCityYieldChange(YieldTypes eYield) const
#endif
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiCityYieldChange[eYield];
}

//	--------------------------------------------------------------------------------
/// Changes how much additional Yield every City produces
#if defined(MOD_BUGFIX_MINOR)
void CvPlayer::ChangeCityYieldChangeTimes100(YieldTypes eYield, int iChange)
#else
void CvPlayer::ChangeCityYieldChange(YieldTypes eYield, int iChange)
#endif
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiCityYieldChange.setAt(eYield, m_aiCityYieldChange[eYield] + iChange);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
/// How much additional Yield do coastal Cities produce?
int CvPlayer::GetCoastalCityYieldChange(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiCoastalCityYieldChange[eYield];
}

//	--------------------------------------------------------------------------------
/// Changes how much additional Yield coastal Cities produce
void CvPlayer::ChangeCoastalCityYieldChange(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiCoastalCityYieldChange.setAt(eYield, m_aiCoastalCityYieldChange[eYield] + iChange);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
/// How much additional Yield does the Capital produce?
#if defined(MOD_BUGFIX_MINOR)
int CvPlayer::GetCapitalYieldChangeTimes100(YieldTypes eYield) const
#else
int CvPlayer::GetCapitalYieldChange(YieldTypes eYield) const
#endif
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiCapitalYieldChange[eYield];
}

//	--------------------------------------------------------------------------------
/// Changes how much additional Yield the Capital produces
#if defined(MOD_BUGFIX_MINOR)
void CvPlayer::ChangeCapitalYieldChangeTimes100(YieldTypes eYield, int iChange)
#else
void CvPlayer::ChangeCapitalYieldChange(YieldTypes eYield, int iChange)
#endif
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiCapitalYieldChange.setAt(eYield, m_aiCapitalYieldChange[eYield] + iChange);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
/// How much additional Yield does the Capital produce per pop?
int CvPlayer::GetCapitalYieldPerPopChange(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiCapitalYieldPerPopChange[eYield];
}

//	--------------------------------------------------------------------------------
/// Changes how much additional Yield the Capital produces per pop
void CvPlayer::ChangeCapitalYieldPerPopChange(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiCapitalYieldPerPopChange.setAt(eYield, m_aiCapitalYieldPerPopChange[eYield] + iChange);

		updateYield();
	}
}


//	--------------------------------------------------------------------------------
/// How much additional Yield does the Capital produce per pop?
int CvPlayer::GetCapitalYieldPerPopChangeEmpire(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiCapitalYieldPerPopChangeEmpire[eYield];
}

//	--------------------------------------------------------------------------------
/// Changes how much additional Yield the Capital produces per pop
void CvPlayer::ChangeCapitalYieldPerPopChangeEmpire(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiCapitalYieldPerPopChangeEmpire.setAt(eYield, m_aiCapitalYieldPerPopChangeEmpire[eYield] + iChange);

		updateYield();
	}
}


//	--------------------------------------------------------------------------------
/// How much additional Yield does a Great Work produce?
int CvPlayer::GetGreatWorkYieldChange(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiGreatWorkYieldChange[eYield];
}

//	--------------------------------------------------------------------------------
/// Changes how much additional Yield a Great Work produces
void CvPlayer::ChangeGreatWorkYieldChange(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiGreatWorkYieldChange.setAt(eYield, m_aiGreatWorkYieldChange[eYield] + iChange);
	}
}

//	--------------------------------------------------------------------------------
CvPlot* CvPlayer::getStartingPlot() const
{
	return GC.getMap().plotCheckInvalid(m_iStartingX, m_iStartingY);
}


//	--------------------------------------------------------------------------------
void CvPlayer::setStartingPlot(CvPlot* pNewValue)
{
	CvPlot* pOldStartingPlot;

	pOldStartingPlot = getStartingPlot();

	if(pOldStartingPlot != pNewValue)
	{
		if(pOldStartingPlot != NULL)
		{
			pOldStartingPlot->area()->changeNumStartingPlots(-1);
		}

		if(pNewValue == NULL)
		{
			m_iStartingX = INVALID_PLOT_COORD;
			m_iStartingY = INVALID_PLOT_COORD;
		}
		else
		{
			m_iStartingX = pNewValue->getX();
			m_iStartingY = pNewValue->getY();

			getStartingPlot()->setStartingPlot(true);

			CvArea* pArea = getStartingPlot()->area();
			if(pArea != NULL)
				pArea->changeNumStartingPlots(1);
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getTotalPopulation() const
{
	return m_iTotalPopulation;
}


//	--------------------------------------------------------------------------------
float CvPlayer::getAveragePopulation() const
{
	if(getNumCities() == 0)
	{
		return 0;
	}

	return getTotalPopulation() / (float)getNumCities();
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeTotalPopulation(int iChange)
{
	m_iTotalPopulation = (m_iTotalPopulation + iChange);
	CvAssert(getTotalPopulation() >= 0);
}


//	--------------------------------------------------------------------------------
long CvPlayer::getRealPopulation() const
{
	const CvCity* pLoopCity;
	__int64 iTotalPopulation = 0;
	int iLoop = 0;

	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iTotalPopulation += pLoopCity->getRealPopulation();
	}

	if(iTotalPopulation > INT_MAX)
	{
		iTotalPopulation = INT_MAX;
	}

	return ((long)(iTotalPopulation));
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNewCityExtraPopulation() const
{
	return m_iNewCityExtraPopulation;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNewCityExtraPopulation(int iChange)
{
	if(iChange != 0)
	{
		m_iNewCityExtraPopulation += iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetFreeFoodBox() const
{
	return m_iFreeFoodBox;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeFreeFoodBox(int iChange)
{
	if(iChange != 0)
	{
		m_iFreeFoodBox += iChange;
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getTotalLand() const
{
	return m_iTotalLand;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeTotalLand(int iChange)
{
	m_iTotalLand = (m_iTotalLand + iChange);
	CvAssert(getTotalLand() >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getTotalLandScored() const
{
	return m_iTotalLandScored;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeTotalLandScored(int iChange)
{
	if(iChange != 0)
	{
		m_iTotalLandScored = (m_iTotalLandScored + iChange);
		CvAssert(getTotalLandScored() >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Total culture per turn
#if defined(MOD_BALANCE_CORE)
int CvPlayer::GetTotalJONSCulturePerTurn(bool bIgnoreHappiness) const
#else
int CvPlayer::GetTotalJONSCulturePerTurn() const
#endif
{
	if(GC.getGame().isOption(GAMEOPTION_NO_POLICIES))
	{
		return 0;
	}

	// No culture during Anarchy
	if(IsAnarchy())
	{
		return 0;
	}

	int iCulturePerTurn = 0;

	// Culture per turn from Cities
	iCulturePerTurn += GetJONSCulturePerTurnFromCities();

	// Special bonus which adds excess Happiness to Culture?
	iCulturePerTurn += GetJONSCulturePerTurnFromExcessHappiness();

	// Trait bonus which adds Culture for trade partners? 
	iCulturePerTurn += GetJONSCulturePerTurnFromTraits();

	// Free culture that's part of the player
	iCulturePerTurn += GetJONSCulturePerTurnForFree();

	// Culture from Minor Civs
	iCulturePerTurn += GetCulturePerTurnFromMinorCivs();

	// Culture from Religion
	iCulturePerTurn += GetCulturePerTurnFromReligion();
	
	// Temporary boost from bonus turns
	iCulturePerTurn += GetCulturePerTurnFromBonusTurns();

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (MOD_DIPLOMACY_CIV4_FEATURES) {
		// We're a vassal of someone, we get x% of his science
		iCulturePerTurn += (GetYieldPerTurnFromVassals(YIELD_CULTURE));
	}

	if (MOD_BALANCE_CORE_JFD)
	{
		iCulturePerTurn += GetYieldPerTurnFromMinors(YIELD_CULTURE);
	}
#endif

	// Golden Age bonus
	if (isGoldenAge() && !IsGoldenAgeCultureBonusDisabled())
	{
		iCulturePerTurn += ((iCulturePerTurn * GC.getGOLDEN_AGE_CULTURE_MODIFIER()) / 100);
	}
#if defined(MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	if(MOD_BALANCE_CORE_HAPPINESS_NATIONAL && !bIgnoreHappiness)
	{
		iCulturePerTurn += GetYieldPerTurnFromHappiness(YIELD_CULTURE, iCulturePerTurn);
	}
#endif

	return iCulturePerTurn;
}

//	--------------------------------------------------------------------------------
/// Culture per turn from Cities
int CvPlayer::GetJONSCulturePerTurnFromCities() const
{
	int iCulturePerTurn = 0;

	// Add in culture from Cities
	const CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iCulturePerTurn += pLoopCity->getJONSCulturePerTurn();
	}

	return iCulturePerTurn;
}

//	--------------------------------------------------------------------------------
/// Special bonus which adds excess Happiness to Culture?
int CvPlayer::GetJONSCulturePerTurnFromExcessHappiness() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS))
	{
		return 0;
	}

	if(getHappinessToCulture() != 0)
	{
		if(GetExcessHappiness() > 0)
		{
			int iFreeCulture = GetExcessHappiness() * getHappinessToCulture();
			iFreeCulture /= 100;

			return iFreeCulture;
		}
	}

	return 0;
}

//	--------------------------------------------------------------------------------
/// Trait bonus which adds Culture for trade partners? //ADDED: Culture from resources exported/imported
int CvPlayer::GetJONSCulturePerTurnFromTraits() const
{
#if defined(MOD_API_UNIFIED_YIELDS)
	return (GetYieldPerTurnFromTraits(YIELD_CULTURE) + GetYieldPerTurnFromResources(YIELD_CULTURE, true, true));
#else
	return GetPlayerTraits()->GetYieldChangePerTradePartner(YIELD_CULTURE) * GetTrade()->GetNumDifferentTradingPartners();
#endif
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Yield per turn from resources imported/exported
int CvPlayer::GetYieldPerTurnFromResources(YieldTypes eYield, bool bExported, bool bImported) const
{
	int iExport = 0;
	int iImport = 0;
	int iTotal = 0;
	int iEra = GetCurrentEra();
	if(iEra < 1)
	{
		iEra = 1;
	}
	//Let's get our total imports/exports
	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
		CvResourceInfo* pInfo = GC.getResourceInfo(eResourceLoop);
		// Is it a luxury?
		if (pInfo && pInfo->getResourceUsage() == RESOURCEUSAGE_LUXURY)
		{
			if(getResourceExport(eResourceLoop) > 0)
			{
				iExport++;
			}
			if(getResourceImport(eResourceLoop) > 0)
			{
				iImport++;
			}
			else if(getResourceFromMinors(eResourceLoop) > 0)
			{
				iImport++;
			}
			else if(getResourceSiphoned(eResourceLoop) > 0)
			{
				iImport++;
			}
		}
	}
	if(bExported)
	{
		if(GetPlayerTraits()->GetYieldFromExport(eYield) > 0)
		{
			iTotal += (iEra * iExport * GetPlayerTraits()->GetYieldFromExport(eYield));
		}
	}
	if(bImported)
	{
		if(GetPlayerTraits()->GetYieldFromImport(eYield) > 0)
		{
			iTotal += (iEra * iImport * GetPlayerTraits()->GetYieldFromImport(eYield));
		}
	}

	return iTotal;
}
#endif
//	--------------------------------------------------------------------------------
/// Culture per turn player starts with for free
int CvPlayer::GetJONSCulturePerTurnForFree() const
{
	return m_iJONSCulturePerTurnForFree;
}

//	--------------------------------------------------------------------------------
/// Culture per turn player starts with for free
void CvPlayer::ChangeJONSCulturePerTurnForFree(int iChange)
{
	if(iChange != 0)
		m_iJONSCulturePerTurnForFree += iChange;

	if(GC.getGame().getActivePlayer() == GetID())
	{
		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
	}
}

//	--------------------------------------------------------------------------------
/// DEPRECATED, use GetCulturePerTurnFromMinorCivs() instead
int CvPlayer::GetJONSCulturePerTurnFromMinorCivs() const
{
	return GetCulturePerTurnFromMinorCivs();
}

//	--------------------------------------------------------------------------------
/// DEPRECATED, value is now changed within CvMinorCivAI
void CvPlayer::ChangeJONSCulturePerTurnFromMinorCivs(int /*iChange*/)
{
	CvAssertMsg(false, "ChangeJONSCulturePerTurnFromMinorCivs called, but Anton meant to disable it");
}

//	--------------------------------------------------------------------------------
/// Culture per turn from all minor civs
int CvPlayer::GetCulturePerTurnFromMinorCivs() const
{
	int iAmount = 0;
	PlayerTypes eMinor;
	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		eMinor = (PlayerTypes) iMinorLoop;
		iAmount += GetCulturePerTurnFromMinor(eMinor);
	}

	return iAmount;
}

//	--------------------------------------------------------------------------------
// Culture per turn from a minor civ
int CvPlayer::GetCulturePerTurnFromMinor(PlayerTypes eMinor) const
{
	int iAmount = 0;

	if(GET_PLAYER(eMinor).isAlive())
	{
		// Includes flat bonus and any bonus from cultural buildings
		iAmount += GET_PLAYER(eMinor).GetMinorCivAI()->GetCurrentCultureBonus(GetID());
	}

	return iAmount;
}

//	--------------------------------------------------------------------------------
/// Culture per turn from religion
int CvPlayer::GetCulturePerTurnFromReligion() const
{
	int iOtherCulturePerTurn = 0;
	int iReligionCulturePerTurn = 0;

	// Start by seeing how much the other types are bringing in
	iOtherCulturePerTurn += GetJONSCulturePerTurnFromCities();
	iOtherCulturePerTurn += GetJONSCulturePerTurnFromExcessHappiness();
	iOtherCulturePerTurn += GetJONSCulturePerTurnForFree();
	iOtherCulturePerTurn += GetCulturePerTurnFromMinorCivs();

	// Founder beliefs
	CvGameReligions* pReligions = GC.getGame().GetGameReligions();
	ReligionTypes eFoundedReligion = GC.getGame().GetGameReligions()->GetFounderBenefitsReligion(GetID());
	if(eFoundedReligion == NO_RELIGION)
	{
		eFoundedReligion = GetReligions()->GetReligionInMostCities();
	}
	if(eFoundedReligion != NO_RELIGION)
	{
		const CvReligion* pReligion = pReligions->GetReligion(eFoundedReligion, NO_PLAYER);
		if(pReligion)
		{
#if defined(MOD_API_UNIFIED_YIELDS)
			iReligionCulturePerTurn += GetYieldPerTurnFromReligion(YIELD_CULTURE);
#else
			iReligionCulturePerTurn += pReligion->m_Beliefs.GetHolyCityYieldChange(YIELD_CULTURE);

			int iTemp = pReligion->m_Beliefs.GetYieldChangePerForeignCity(YIELD_CULTURE);
			if (iTemp > 0)
			{
				iReligionCulturePerTurn += (iTemp * GetReligions()->GetNumForeignCitiesFollowing());
			}

			iTemp = pReligion->m_Beliefs.GetYieldChangePerXForeignFollowers(YIELD_CULTURE);
			if (iTemp > 0)
			{
				int iFollowers = GetReligions()->GetNumForeignFollowers(false /*bAtPeace*/);
				if (iFollowers > 0)
				{
					iReligionCulturePerTurn += (iFollowers / iTemp);
				}
			}
#endif
			bool bAtPeace = GET_TEAM(getTeam()).getAtWarCount(false) == 0;
			CvCity* pHolyCity = NULL;
			CvPlot* pHolyCityPlot = GC.getMap().plot(pReligion->m_iHolyCityX, pReligion->m_iHolyCityY);
			if (pHolyCityPlot)
			{
				pHolyCity = pHolyCityPlot->getPlotCity();
			}
			int iMod = pReligion->m_Beliefs.GetPlayerCultureModifier(bAtPeace, GetID(), pHolyCity, true);

			if (iMod != 0)
			{
				iReligionCulturePerTurn += ((iReligionCulturePerTurn + iOtherCulturePerTurn) * iMod) / 100;
			}
			return iReligionCulturePerTurn;
		}
	}
	return 0;
}

//	--------------------------------------------------------------------------------
/// Culture from Bonus Turns
int CvPlayer::GetCulturePerTurnFromBonusTurns() const
{
	int iValue = 0;

	int iCulturePerTurn = 0;
	if (GetCultureBonusTurns() > 0 || GetCultureBonusTurnsConquest() > 0)
	{
		// Culture per turn from Cities
		iCulturePerTurn += GetJONSCulturePerTurnFromCities();

		// Special bonus which adds excess Happiness to Culture?
		iCulturePerTurn += GetJONSCulturePerTurnFromExcessHappiness();

		// Trait bonus which adds Culture for trade partners? 
		iCulturePerTurn += GetJONSCulturePerTurnFromTraits();

		// Free culture that's part of the player
		iCulturePerTurn += GetJONSCulturePerTurnForFree();

		// Culture from Minor Civs
		iCulturePerTurn += GetCulturePerTurnFromMinorCivs();

		// Culture from Religion
		iCulturePerTurn += GetCulturePerTurnFromReligion();

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		if (MOD_DIPLOMACY_CIV4_FEATURES) {
			// We're a vassal of someone, we get x% of his science
			iCulturePerTurn += (GetYieldPerTurnFromVassals(YIELD_CULTURE));
		}

		if (MOD_BALANCE_CORE_JFD)
		{
			iCulturePerTurn += GetYieldPerTurnFromMinors(YIELD_CULTURE);
		}
#endif

		// Golden Age bonus
		if (isGoldenAge() && !IsGoldenAgeCultureBonusDisabled())
		{
			iCulturePerTurn += ((iCulturePerTurn * GC.getGOLDEN_AGE_CULTURE_MODIFIER()) / 100);
		}
#if defined(MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
		if (MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
		{
			iCulturePerTurn += GetYieldPerTurnFromHappiness(YIELD_CULTURE, iCulturePerTurn);
		}
#endif
	}

	if (GetCultureBonusTurns() > 0)
	{
		iValue += ((iCulturePerTurn * GC.getTEMPORARY_CULTURE_BOOST_MOD()) / 100);
	}
#if defined(MOD_BALANCE_CORE)
	if (GetCultureBonusTurnsConquest() > 0)
	{
		iValue += ((iCulturePerTurn * GetPlayerTraits()->GetCultureBonusModifierConquest()) / 100);
	}	
#endif

	return iValue;
}

//	--------------------------------------------------------------------------------
/// Modifier for all Cities' culture
int CvPlayer::GetJONSCultureCityModifier() const
{
	return m_iJONSCultureCityModifier;
}

//	--------------------------------------------------------------------------------
/// Modifier for all Cities' culture
void CvPlayer::ChangeJONSCultureCityModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iJONSCultureCityModifier += iChange;

		if(GC.getGame().getActivePlayer() == GetID())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

#if defined(MOD_DIPLOMACY_CITYSTATES)
//	--------------------------------------------------------------------------------
/// Modifier for all Cities' culture
int CvPlayer::GetLeagueCultureCityModifier() const
{
	return m_iLeagueCultureCityModifier;
}

//	--------------------------------------------------------------------------------
/// Modifier for all Cities' culture
void CvPlayer::ChangeLeagueCultureCityModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iLeagueCultureCityModifier += iChange;

		if(GC.getGame().getActivePlayer() == GetID())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getJONSCulture() const
{
	// City States can't pick Policies, sorry!
	if(isMinorCiv())
		return 0;

	if(GC.getGame().isOption(GAMEOPTION_NO_POLICIES))
	{
		return 0;
	}

	return m_iJONSCulture;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setJONSCulture(int iNewValue)
{
	if(getJONSCulture() != iNewValue)
	{
		// Add to the total we've ever had
		if(iNewValue > m_iJONSCulture)
		{
			ChangeJONSCultureEverGenerated(iNewValue - m_iJONSCulture);
		}

		m_iJONSCulture = iNewValue;

		if(GC.getGame().getActivePlayer() == GetID())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeJONSCulture(int iChange)
{
	setJONSCulture(getJONSCulture() + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::GetJONSCultureEverGenerated() const
{
	return m_iJONSCultureEverGenerated;
}


//	--------------------------------------------------------------------------------
void CvPlayer::SetJONSCultureEverGenerated(int iNewValue)
{
	if(GetJONSCultureEverGenerated() != iNewValue)
	{
		m_iJONSCultureEverGenerated = iNewValue;
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeJONSCultureEverGenerated(int iChange)
{
	SetJONSCultureEverGenerated(GetJONSCultureEverGenerated() + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::GetJONSCulturePerCityPerTurn() const
{
	int iCulture = GetJONSCultureEverGenerated();
	int iNumCities = getNumCities();

	// Puppet Cities don't count
	iNumCities -= GetNumPuppetCities();

	int iNumTurns = GC.getGame().getElapsedGameTurns();

	if(iNumTurns == 0)
	{
		iNumTurns = 1;
	}

	int iCulturePerCityPerTurn = 100 * iCulture / iNumCities / iNumTurns;
	return iCulturePerCityPerTurn;
}

//	--------------------------------------------------------------------------------
/// Amount of extra Culture per Wonder
int CvPlayer::GetCulturePerWonder() const
{
	return m_iCulturePerWonder;
}

//	--------------------------------------------------------------------------------
/// Changes amount of extra Culture per Wonder
void CvPlayer::ChangeCulturePerWonder(int iChange)
{
	if(iChange != 0)
	{
		m_iCulturePerWonder += iChange;

		int iTotalCultureChange;

		// Loop through all Cities and change how much Culture they produce based on how many Wonders they have
		CvCity* pLoopCity;
		int iLoop;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			iTotalCultureChange = pLoopCity->getNumWorldWonders() * iChange;
			pLoopCity->ChangeJONSCulturePerTurnFromPolicies(iTotalCultureChange);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Culture multiplier for having a world wonder
int CvPlayer::GetCultureWonderMultiplier() const
{
	return m_iCultureWonderMultiplier;
}

//	--------------------------------------------------------------------------------
/// Changes amount of extra Culture per Wonder
void CvPlayer::ChangeCultureWonderMultiplier(int iChange)
{
	if(iChange != 0)
		m_iCultureWonderMultiplier += iChange;
}

//	--------------------------------------------------------------------------------
/// Amount of Culture provided for each Tech Researched
int CvPlayer::GetCulturePerTechResearched() const
{
	return m_iCulturePerTechResearched;
}

//	--------------------------------------------------------------------------------
/// Changes amount of Culture provided for each Tech Researched
void CvPlayer::ChangeCulturePerTechResearched(int iChange)
{
	if(iChange != 0)
	{
		m_iCulturePerTechResearched += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Specialist Culture Modifier
int CvPlayer::GetSpecialistCultureChange() const
{
	return m_iSpecialistCultureChange;
}

//	--------------------------------------------------------------------------------
/// Specialist Culture Modifier
void CvPlayer::ChangeSpecialistCultureChange(int iChange)
{
	if(iChange != 0)
	{
		CvCity* pLoopCity;
		int iLoop;

		int iTotalCulture = 0;

		SpecialistTypes eSpecialist;
		int iSpecialistLoop;
		int iSpecialistCount;

		// Undo old culture
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			for(iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
			{
				eSpecialist = (SpecialistTypes) iSpecialistLoop;
				iSpecialistCount = pLoopCity->GetCityCitizens()->GetSpecialistCount(eSpecialist);
				iTotalCulture += (iSpecialistCount * pLoopCity->GetCultureFromSpecialist(eSpecialist));
			}

			pLoopCity->ChangeJONSCulturePerTurnFromSpecialists(-iTotalCulture);
		}

		// CHANGE VALUE
		m_iSpecialistCultureChange += iChange;

		iTotalCulture = 0;

		// Apply new culture
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			for(iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
			{
				eSpecialist = (SpecialistTypes) iSpecialistLoop;
				iSpecialistCount = pLoopCity->GetCityCitizens()->GetSpecialistCount(eSpecialist);
				iTotalCulture += (iSpecialistCount * pLoopCity->GetCultureFromSpecialist(eSpecialist));
			}

			pLoopCity->ChangeJONSCulturePerTurnFromSpecialists(iTotalCulture);
		}
	}
}

//	--------------------------------------------------------------------------------
/// What is the sum of culture yield from the previous N turns?
/// NOTE: This uses the data tracked in recording a replay, so if replays are disabled in the future then this must change!
int CvPlayer::GetCultureYieldFromPreviousTurns(int iGameTurn, int iNumPreviousTurnsToCount)
{
	// Culture per turn yield is tracked in replay data, so use that
	int iSum = 0;
	for (int iI = 1; iI < iNumPreviousTurnsToCount+1; iI++)
	{
		int iTurn = iGameTurn - iI;
		if (iTurn < 0)
		{
			break;
		}

		int iTurnCulture = getReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_CULTUREPERTURN"), iTurn);
		if (iTurnCulture >= 0)
		{
			iSum += iTurnCulture;
		}
		else if (iTurnCulture == -1) // No data for this turn (ex. late era start)
		{
			iSum += (3 * GetTotalJONSCulturePerTurn());
		}
	}

	return iSum;
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// What is the sum of tourism yield from the previous N turns?
/// NOTE: This uses the data tracked in recording a replay, so if replays are disabled in the future then this must change!
int CvPlayer::GetTourismYieldFromPreviousTurns(int iGameTurn, int iNumPreviousTurnsToCount)
{
	// Culture per turn yield is tracked in replay data, so use that
	int iSum = 0;
	for (int iI = 1; iI < iNumPreviousTurnsToCount+1; iI++)
	{
		int iTurn = iGameTurn - iI;
		if (iTurn < 0)
		{
			break;
		}

		int iTurnTourism = getReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_TOURISMPERTURN"), iTurn);
		if (iTurnTourism >= 0)
		{
			iSum += iTurnTourism;
		}
		else if (iTurnTourism == -1) // No data for this turn (ex. late era start)
		{
			iSum += (3 * GetCulture()->GetTourism() / 100);
		}
	}

	return iSum;
}
#endif

//	--------------------------------------------------------------------------------
/// Cities remaining to get a free culture building
int CvPlayer::GetNumCitiesFreeCultureBuilding() const
{
	return m_iNumCitiesFreeCultureBuilding;
}

//	--------------------------------------------------------------------------------
/// Changes number of cities remaining to get a free culture building
void CvPlayer::ChangeNumCitiesFreeCultureBuilding(int iChange)
{
	if(iChange != 0)
		m_iNumCitiesFreeCultureBuilding += iChange;
}

//	--------------------------------------------------------------------------------
/// Cities remaining to get a free culture building
int CvPlayer::GetNumCitiesFreeFoodBuilding() const
{
	return m_iNumCitiesFreeFoodBuilding;
}

//	--------------------------------------------------------------------------------
/// Changes number of cities remaining to get a free culture building
void CvPlayer::ChangeNumCitiesFreeFoodBuilding(int iChange)
{
	if(iChange != 0)
		m_iNumCitiesFreeFoodBuilding += iChange;
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Cities remaining to get a free building
int CvPlayer::GetNumCitiesFreeChosenBuilding(BuildingClassTypes eBuildingClass) const
{
	CvAssertMsg(eBuildingClass < GC.getNumBuildingClassInfos(), "Index out of bounds");
	CvAssertMsg(eBuildingClass > -1, "Index out of bounds");
	return m_paiNumCitiesFreeChosenBuilding[eBuildingClass];
}

//	--------------------------------------------------------------------------------
/// Changes number of cities remaining to get a free building
void CvPlayer::ChangeNumCitiesFreeChosenBuilding(BuildingClassTypes eBuildingClass, int iChange)
{
	m_paiNumCitiesFreeChosenBuilding.setAt(eBuildingClass, (m_paiNumCitiesFreeChosenBuilding[eBuildingClass] + iChange));
}
/// New Founded City waiting to get a free unit?
bool CvPlayer::IsFreeUnitNewFoundCity(UnitClassTypes eUnitClass) const
{
	CvAssertMsg(eUnitClass < GC.getNumUnitClassInfos(), "Index out of bounds");
	CvAssertMsg(eUnitClass > -1, "Index out of bounds");
	return m_pabNewFoundCityFreeUnit[eUnitClass];
}
//	--------------------------------------------------------------------------------
/// Changes number of newly founded cities to get a free building
void CvPlayer::ChangeNewFoundCityFreeUnit(UnitClassTypes eUnitClass, bool bValue)
{
	m_pabNewFoundCityFreeUnit.setAt(eUnitClass, bValue);
}
/// New Founded City waiting to get a free building?
bool CvPlayer::IsFreeBuildingNewFoundCity(BuildingClassTypes eBuildingClass) const
{
	CvAssertMsg(eBuildingClass < GC.getNumBuildingClassInfos(), "Index out of bounds");
	CvAssertMsg(eBuildingClass > -1, "Index out of bounds");
	return m_pabNewFoundCityFreeBuilding[eBuildingClass];
}
//	--------------------------------------------------------------------------------
/// Changes number of newly founded cities to get a free building
void CvPlayer::ChangeNewFoundCityFreeBuilding(BuildingClassTypes eBuildingClass, bool bValue)
{
	m_pabNewFoundCityFreeBuilding.setAt(eBuildingClass, bValue);
}
/// Cities remaining to get a free building
bool CvPlayer::IsFreeChosenBuildingNewCity(BuildingClassTypes eBuildingClass) const
{
	CvAssertMsg(eBuildingClass < GC.getNumBuildingClassInfos(), "Index out of bounds");
	CvAssertMsg(eBuildingClass > -1, "Index out of bounds");
	return m_pabFreeChosenBuildingNewCity[eBuildingClass];
}

//	--------------------------------------------------------------------------------
/// Changes number of new cities remaining to get a free building
void CvPlayer::ChangeFreeChosenBuildingNewCity(BuildingClassTypes eBuildingClass, bool bValue)
{
	m_pabFreeChosenBuildingNewCity.setAt(eBuildingClass, bValue);
}
// City waiting to get a free building?
bool CvPlayer::IsFreeBuildingAllCity(BuildingClassTypes eBuildingClass) const
{
	CvAssertMsg(eBuildingClass < GC.getNumBuildingClassInfos(), "Index out of bounds");
	CvAssertMsg(eBuildingClass > -1, "Index out of bounds");
	return m_pabAllCityFreeBuilding[eBuildingClass];
}
// Change Cities that get a Free building
void CvPlayer::ChangeAllCityFreeBuilding(BuildingClassTypes eBuildingClass, bool bValue)
{
	m_pabAllCityFreeBuilding.setAt(eBuildingClass, bValue);
}

/// Reformation Unlock
void CvPlayer::SetReformation(bool bValue)
{
	if(m_bIsReformation != bValue)
	{
		m_bIsReformation = bValue;
	}
}

bool CvPlayer::IsReformation() const
{
	return m_bIsReformation;
}

int CvPlayer::GetReformationFollowerReduction() const
{
	return m_iReformationFollowerReduction;
}

void CvPlayer::ChangeReformationFollowerReduction(int iValue)
{
	m_iReformationFollowerReduction += iValue;
}
#endif
//	--------------------------------------------------------------------------------
/// Handle earning yields from a combat win
#if defined(MOD_API_UNIFIED_YIELDS)
void CvPlayer::DoYieldsFromKill(CvUnit* pAttackingUnit, CvUnit* pDefendingUnit, int iX, int iY)
#else
void CvPlayer::DoYieldsFromKill(UnitTypes eAttackingUnitType, UnitTypes eKilledUnitType, int iX, int iY, bool bWasBarbarian)
#endif
{
#if defined(MOD_API_UNIFIED_YIELDS)
	UnitTypes eKilledUnitType = pDefendingUnit->getUnitType();
#endif

#if defined(MOD_API_EXTENSIONS)
	DoUnresearchedTechBonusFromKill(pDefendingUnit, eKilledUnitType, iX, iY);
#else
	DoUnresearchedTechBonusFromKill(eKilledUnitType, iX, iY);
#endif
#if defined(MOD_BALANCE_CORE)
	//Bonus resource in a city every time you win a battle. (Rome UB)
	if (MOD_BALANCE_CORE && pDefendingUnit != NULL && pDefendingUnit->IsCombatUnit())
	{
		bool bSea = false; 
		if(pDefendingUnit->getDomainType() == DOMAIN_SEA)
		{
			bSea = true;
		}
		doInstantYield(INSTANT_YIELD_TYPE_VICTORY, false, NO_GREATPERSON, NO_BUILDING, 0, true, NO_PLAYER, NULL, false, NULL, bSea);
	}
#endif
	for(int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)
	{
#if defined(MOD_API_UNIFIED_YIELDS)
#if defined(MOD_API_EXTENSIONS)
		DoYieldBonusFromKill((YieldTypes)iYield, pAttackingUnit, pDefendingUnit, eKilledUnitType, iX, iY, pDefendingUnit->isBarbarian());
#else
		DoYieldBonusFromKill((YieldTypes)iYield, pAttackingUnit, eKilledUnitType, iX, iY, pDefendingUnit->isBarbarian());
#endif
#else
#if defined(MOD_API_EXTENSIONS)
		DoYieldBonusFromKill((YieldTypes)iYield, eAttackingUnitType, pDefendingUnit, eKilledUnitType, iX, iY, bWasBarbarian);
#else
		DoYieldBonusFromKill((YieldTypes)iYield, eAttackingUnitType, eKilledUnitType, iX, iY, bWasBarbarian);
#endif
#endif
	}
}

//	--------------------------------------------------------------------------------
/// Apply and show a yield bonus from a combat win
/// If a bonus is applied, iNumBonuses must be incremented to stagger the UI text with other bonuses
#if defined(MOD_API_UNIFIED_YIELDS)
#if defined(MOD_API_EXTENSIONS)
void CvPlayer::DoYieldBonusFromKill(YieldTypes eYield, CvUnit* pAttackingUnit, CvUnit* pKilledUnit, UnitTypes eKilledUnitType, int iX, int iY, bool bWasBarbarian)
#else
void CvPlayer::DoYieldBonusFromKill(YieldTypes eYield, CvUnit* pAttackingUnit, UnitTypes eKilledUnitType, int iX, int iY, bool bWasBarbarian)
#endif
#else
#if defined(MOD_API_EXTENSIONS)
void CvPlayer::DoYieldBonusFromKill(YieldTypes eYield, UnitTypes eAttackingUnitType, CvUnit* pKilledUnit, UnitTypes eKilledUnitType, int iX, int iY, bool bWasBarbarian)
#else
void CvPlayer::DoYieldBonusFromKill(YieldTypes eYield, UnitTypes eAttackingUnitType, UnitTypes eKilledUnitType, int iX, int iY, bool bWasBarbarian)
#endif
#endif
{
	int iValue = 0;

	CvAssertMsg(eKilledUnitType != NO_UNIT, "Killed unit's type is NO_TYPE. Please send Anton your save file and version.");
	if (eKilledUnitType == NO_UNIT) return;

	CvUnitEntry* pkKilledUnitInfo = GC.getUnitInfo(eKilledUnitType);
	if(pkKilledUnitInfo)
	{
#if defined(MOD_API_EXTENSIONS)
		int iCombatStrength = pKilledUnit ? max(pKilledUnit->GetBaseCombatStrength(), pKilledUnit->GetBaseRangedCombatStrength()) : max(pkKilledUnitInfo->GetCombat(), pkKilledUnitInfo->GetRangedCombat());
#else
		int iCombatStrength = max(pkKilledUnitInfo->GetCombat(), pkKilledUnitInfo->GetRangedCombat());
#endif
		if(iCombatStrength > 0)
		{	
			switch(eYield)
			{
			case YIELD_FOOD:
			case YIELD_PRODUCTION:
				// Not supported, local to a city
#if defined(MOD_BALANCE_CORE)
				break;
#else
				return;
#endif

			case YIELD_GOLD:
				iValue += GetPlayerPolicies()->GetNumericModifier(POLICYMOD_GOLD_FROM_KILLS);
				break;

			case YIELD_CULTURE:
				iValue += GetPlayerTraits()->GetCultureFromKills();
				iValue += GetPlayerPolicies()->GetNumericModifier(POLICYMOD_CULTURE_FROM_KILLS);

				// Do we get it for barbarians?
				if(bWasBarbarian)
				{
					iValue += GetPlayerPolicies()->GetNumericModifier(POLICYMOD_CULTURE_FROM_BARBARIAN_KILLS);
				}
				break;

			case YIELD_FAITH:
				iValue += GetPlayerTraits()->GetFaithFromKills();

				if (eYield == YIELD_FAITH && (GC.getGame().isOption(GAMEOPTION_NO_RELIGION)))
				{
					return;
				}
				break;
			case YIELD_SCIENCE:
				break;
#if defined(MOD_API_UNIFIED_YIELDS_TOURISM)
			case YIELD_TOURISM:
				// Not supported, as not accumulated turn-on-turn
				break;
#endif
#if defined(MOD_API_UNIFIED_YIELDS_GOLDEN_AGE)
			case YIELD_GOLDEN_AGE_POINTS:
				break;
#endif
			}

#if defined(MOD_API_UNIFIED_YIELDS)
			iValue += GetYieldFromKills(eYield);
			iValue += GetPlayerTraits()->GetYieldFromKills(eYield);
			
			if (bWasBarbarian) {
				iValue += GetYieldFromBarbarianKills(eYield);
				iValue += GetPlayerTraits()->GetYieldFromBarbarianKills(eYield);
			}

			ReligionTypes eReligion = GC.getGame().GetGameReligions()->GetFounderBenefitsReligion(GetID());
			if (eReligion == NO_RELIGION)
			{
				eReligion = GetReligions()->GetReligionInMostCities();
			}
			if (eReligion != NO_RELIGION)
			{
				const CvReligion* pMyReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, GetID());
				if (pMyReligion) 
				{
					CvCity* pHolyCity = NULL;
					CvPlot* pHolyCityPlot = GC.getMap().plot(pMyReligion->m_iHolyCityX, pMyReligion->m_iHolyCityY);
					if (pHolyCityPlot)
					{
						pHolyCity = pHolyCityPlot->getPlotCity();
					}
					if (pHolyCity == NULL)
					{
						pHolyCity = getCapitalCity();
					}

					iValue += pMyReligion->m_Beliefs.GetYieldFromKills(eYield, GetID(), pHolyCity, true);

					if (bWasBarbarian) 
					{
						iValue += pMyReligion->m_Beliefs.GetYieldFromBarbarianKills(eYield, GetID(), pHolyCity, true);
					}
				}
			}
#endif

			iValue += GC.getGame().GetGameReligions()->GetBeliefYieldForKill(eYield, iX, iY, GetID());

#if defined(MOD_API_UNIFIED_YIELDS)
			if(pAttackingUnit != NULL)
#else
			if(eAttackingUnitType != NO_UNIT)
#endif
			{
#if defined(MOD_API_UNIFIED_YIELDS)
				UnitTypes eAttackingUnitType = pAttackingUnit->getUnitType();
#endif
				CvUnitEntry* pkAttackingUnitInfo = GC.getUnitInfo(eAttackingUnitType);
				if(pkAttackingUnitInfo)
				{
					iValue += pkAttackingUnitInfo->GetYieldFromKills(eYield);

#if defined(MOD_API_UNIFIED_YIELDS)
					iValue += pAttackingUnit->getYieldFromKills(eYield);
					
					// Do we get it for barbarians?
					if(bWasBarbarian)
					{
						iValue += pkAttackingUnitInfo->GetYieldFromBarbarianKills(eYield);
						iValue += pAttackingUnit->getYieldFromBarbarianKills(eYield);
					}
#endif
				}
			}
#if defined(MOD_BALANCE_CORE)
			CvCity* pCity = getCapitalCity();
#endif
			iValue = (iValue * iCombatStrength) / 100;
#if defined(MOD_BALANCE_CORE)
			iValue *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iValue /= 100;
#endif
			if(iValue > 0)
			{
				switch (eYield)
				{
				case YIELD_GOLD:
					GetTreasury()->ChangeGold(iValue);
					break;
				case YIELD_CULTURE:
					changeJONSCulture(iValue);
#if defined(MOD_BALANCE_CORE)
					if (getCapitalCity() != NULL)
					{
						getCapitalCity()->ChangeJONSCultureStored(iValue);
					}
#endif
					break;
				case YIELD_FAITH:
					ChangeFaith(iValue);
					break;
#if defined(MOD_API_UNIFIED_YIELDS)
				case YIELD_GOLDEN_AGE_POINTS:
					ChangeGoldenAgeProgressMeter(iValue);
					break;
#endif
#if defined(MOD_BALANCE_CORE)
				case YIELD_FOOD:
					if (pCity != NULL)
					{
						pCity->changeFood(iValue);
					}
					break;
				case YIELD_PRODUCTION:
					if (pCity != NULL)
					{
						pCity->changeProduction(iValue);
					}
					break;
#endif
				case YIELD_GREAT_ADMIRAL_POINTS:
#if defined(MOD_UNITS_XP_TIMES_100)
					changeNavalCombatExperienceTimes100(iValue * 100);
#else
					changeNavalCombatExperience(iValue);
#endif
					break;

				case YIELD_GREAT_GENERAL_POINTS:
#if defined(MOD_UNITS_XP_TIMES_100)
					changeCombatExperienceTimes100(iValue * 100);
#else
					changeCombatExperience(iValue);
#endif
					break;
				case YIELD_SCIENCE:
					TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
					if (eCurrentTech == NO_TECH)
					{
						changeOverflowResearch(iValue);
					}
					else
					{
						GET_TEAM(getTeam()).GetTeamTechs()->ChangeResearchProgress(eCurrentTech, iValue, GetID());
					}
					break;
				}
				ReportYieldFromKill(eYield, iValue, iX, iY);
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Apply and show a bonus towards unresearched tech when we defeat a unit of that tech
/// If a bonus is applied, iNumBonuses must be incremented to stagger the UI text with other bonuses
#if defined(MOD_API_EXTENSIONS)
void CvPlayer::DoUnresearchedTechBonusFromKill(CvUnit* pKilledUnit, UnitTypes eKilledUnitType, int iX, int iY)
#else
void CvPlayer::DoUnresearchedTechBonusFromKill(UnitTypes eKilledUnitType, int iX, int iY)
#endif
{
	CvAssertMsg(eKilledUnitType != NO_UNIT, "Killed unit's type is NO_TYPE. Please send Anton your save file and version.");
	if (eKilledUnitType == NO_UNIT) return;

	int iPercent = GetPlayerTraits()->GetUnresearchedTechBonusFromKills();

	if (iPercent > 0)
	{
		int iValue = 0;

		CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eKilledUnitType);
		if(pkUnitInfo)
		{
			TechTypes ePrereq = (TechTypes) pkUnitInfo->GetPrereqAndTech();
			if (ePrereq != NO_TECH)
			{
				CvTechEntry* pkTechInfo = GC.getTechInfo(ePrereq);
				if (pkTechInfo && !GET_TEAM(getTeam()).GetTeamTechs()->HasTech(ePrereq))
				{
#if defined(MOD_API_EXTENSIONS)
					int iCombatStrength = pKilledUnit ? max(pKilledUnit->GetBaseCombatStrength(), pKilledUnit->GetBaseRangedCombatStrength()) : max(pkUnitInfo->GetCombat(), pkUnitInfo->GetRangedCombat());
#else
					int iCombatStrength = max(pkUnitInfo->GetCombat(), pkUnitInfo->GetRangedCombat());
#endif
					if (iCombatStrength > 0)
					{
						int iTechCost = GetPlayerTechs()->GetResearchCost(ePrereq);
						iValue = (iTechCost * iPercent) / 100;

						// Cannot be greater than the tech's cost
						int iRemainingCost = iTechCost - GetPlayerTechs()->GetResearchProgress(ePrereq);
						if (iValue > iRemainingCost)
						{
							iValue = iRemainingCost;
						}

						if (iValue > 0)
						{
							GET_TEAM(getTeam()).GetTeamTechs()->ChangeResearchProgress(ePrereq, iValue, GetID());
							ReportYieldFromKill(YIELD_SCIENCE, iValue, iX, iY);
						}
					}
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Show earning a yield from combat wins
void CvPlayer::ReportYieldFromKill(YieldTypes eYield, int iValue, int iX, int iY)
{
	CvString yieldString;
	if(iValue > 0)
	{
#if defined(MOD_API_UNIFIED_YIELDS)
		CvYieldInfo* pYieldInfo = GC.getYieldInfo(eYield);
		yieldString.Format("%s+%%d[ENDCOLOR]%s", pYieldInfo->getColorString(), pYieldInfo->getIconString());
#else

		switch(eYield)
		{
		case YIELD_GOLD:
			yieldString = "[COLOR_YELLOW]+%d[ENDCOLOR][ICON_GOLD]";
			break;
		case YIELD_CULTURE:
			yieldString = "[COLOR_MAGENTA]+%d[ENDCOLOR][ICON_CULTURE]";
			break;
		case YIELD_FAITH:
			yieldString = "[COLOR_WHITE]+%d[ENDCOLOR][ICON_PEACE]";
			break;
		case YIELD_SCIENCE:
			yieldString = "[COLOR_BLUE]+%d[ENDCOLOR][ICON_RESEARCH]";
			break;
		case YIELD_FOOD:
			yieldString = "[COLOR_GREEN]+%d[ENDCOLOR][ICON_FOOD]";
			break;
		case YIELD_PRODUCTION:
			yieldString = "[COLOR_YELLOW]+%d[ENDCOLOR][ICON_PRODUCTION]";
			break;
		default:
			// Not supported
			return;
		}
#endif

		if(GetID() == GC.getGame().getActivePlayer())
		{
			char text[256] = {0};
			sprintf_s(text, yieldString, iValue);
			SHOW_PLOT_POPUP(GC.getMap().plot(iX, iY), NO_PLAYER, text);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Each a technology from conquering a city
void CvPlayer::DoTechFromCityConquer(CvCity* pConqueredCity)
{
	PlayerTypes eOpponent = pConqueredCity->getOwner();
	FStaticVector<TechTypes, 128, true, c_eCiv5GameplayDLL> vePossibleTechs;
	int iCheapestTechCost = MAX_INT;
	for (int i = 0; i < GC.getNumTechInfos(); i++)
	{
		TechTypes e = (TechTypes) i;
		CvTechEntry* pInfo = GC.getTechInfo(e);
		if (pInfo)
		{
			// They have it
			if (GET_TEAM(GET_PLAYER(eOpponent).getTeam()).GetTeamTechs()->HasTech(e))
			{
				// We don't
				if (!GET_TEAM(getTeam()).GetTeamTechs()->HasTech(e))
				{
					// But we could
					if (GetPlayerTechs()->CanResearch(e))
					{
						if (pInfo->GetResearchCost() < iCheapestTechCost)
						{
							iCheapestTechCost = pInfo->GetResearchCost();
							vePossibleTechs.clear();
							vePossibleTechs.push_back(e);
						}
						else if (pInfo->GetResearchCost() == iCheapestTechCost)
						{
							vePossibleTechs.push_back(e);
						}
					}
				}
			}
		}
	}

	if (!vePossibleTechs.empty())
	{
		int iRoll = GC.getGame().getSmallFakeRandNum((int)vePossibleTechs.size(), GET_PLAYER(pConqueredCity->getOwner()).getGlobalAverage(YIELD_CULTURE));
		TechTypes eFreeTech = vePossibleTechs[iRoll];
		CvAssert(eFreeTech != NO_TECH)
		if (eFreeTech != NO_TECH)
		{
			GET_TEAM(getTeam()).setHasTech(eFreeTech, true, GetID(), true, true);
			GET_TEAM(getTeam()).GetTeamTechs()->SetNoTradeTech(eFreeTech, true);
		}
	}
#if defined(MOD_BALANCE_CORE)
	else
	{
		int iEra = GetCurrentEra();
		if(iEra <= 1)
		{
			iEra = 1;
		}
		const char* strTargetNameKey = pConqueredCity->getNameKey();
		TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
		int iValue = (pConqueredCity->getPopulation() * 20 * iEra);
		iValue *= GC.getGame().getGameSpeedInfo().getTrainPercent();
		iValue /= 100;
		if(eCurrentTech == NO_TECH)
		{
			changeOverflowResearch(iValue);
		}
		else
		{
			GET_TEAM(GET_PLAYER(GetID()).getTeam()).GetTeamTechs()->ChangeResearchProgress(eCurrentTech, iValue, GetID());
		}
		if(GetID() == GC.getGame().getActivePlayer())
		{
			Localization::String strMessage;
			Localization::String strSummary;
			strMessage = Localization::Lookup("TXT_KEY_SCIENCE_BOOST_CONQUEST");
			strMessage << iValue;
			strMessage << strTargetNameKey;
			strSummary = Localization::Lookup("TXT_KEY_SCIENCE_BOOST_CONQUEST_SUMMARY");

			CvNotifications* pNotification = GetNotifications();
			if(pNotification)
			{
				pNotification->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), pConqueredCity->getX(), pConqueredCity->getY(), (int) pConqueredCity->GetID(), GetID());
			}
		}
	}
#endif
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Generate a random great work on city conquest
void CvPlayer::DoFreeGreatWorkOnConquest(PlayerTypes ePlayer, CvCity* pCity)
{
	GreatWorkSlotType eArtArtifactSlot = CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT();
	GreatWorkSlotType eMusicSlot = CvTypes::getGREAT_WORK_SLOT_MUSIC();
	GreatWorkSlotType eWritingSlot = CvTypes::getGREAT_WORK_SLOT_LITERATURE();

	int iOpenSlots = 0;
	int iStuffStolen = 0;
	CvWeightedVector<int, SAFE_ESTIMATE_NUM_BUILDINGS, true> artChoices;
	const char* strTargetNameKey = pCity->getNameKey();
	const CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iOpenSlots += pLoopCity->GetCityBuildings()->GetNumAvailableGreatWorkSlots(eArtArtifactSlot);
		iOpenSlots += pLoopCity->GetCityBuildings()->GetNumAvailableGreatWorkSlots(eMusicSlot);
		iOpenSlots += pLoopCity->GetCityBuildings()->GetNumAvailableGreatWorkSlots(eWritingSlot);
	}
	if (GET_PLAYER(ePlayer).isAlive() && !GET_PLAYER(ePlayer).isMinorCiv() && !GET_PLAYER(ePlayer).isBarbarian())
	{
		if (iOpenSlots > 0)
		{
			int iCityLoop;
			CvCity* pPlayerCity = NULL;
			int iGreatWorkIndex;
			for (pPlayerCity = GET_PLAYER(ePlayer).firstCity(&iCityLoop); pPlayerCity != NULL; pPlayerCity = GET_PLAYER(ePlayer).nextCity(&iCityLoop))
			{
				if (pPlayerCity != NULL && pPlayerCity != pCity)
				{
					int iDistance = plotDistance(pCity->getX(), pCity->getY(), pPlayerCity->getX(), pPlayerCity->getY());
					if (iDistance > 0)
					{
						for (int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
						{
							const CvCivilizationInfo& playerCivilizationInfo = GET_PLAYER(ePlayer).getCivilizationInfo();
							BuildingTypes eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings((BuildingClassTypes)iBuildingClassLoop);
							if (eBuilding != NO_BUILDING)
							{
								CvBuildingEntry *pkBuilding = GC.getBuildingInfo(eBuilding);
								if (pkBuilding)
								{
									if (pPlayerCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0 && (pkBuilding->GetGreatWorkSlotType() == eArtArtifactSlot || pkBuilding->GetGreatWorkSlotType() == eMusicSlot || pkBuilding->GetGreatWorkSlotType() == eWritingSlot))
									{
										int iNumSlots = pkBuilding->GetGreatWorkCount();
										if (iNumSlots > 0)
										{
											for (int iI = 0; iI < iNumSlots; iI++)
											{
												iGreatWorkIndex = pPlayerCity->GetCityBuildings()->GetBuildingGreatWork((BuildingClassTypes)iBuildingClassLoop, iI);
												if (iGreatWorkIndex != -1 && !GetCulture()->ControlsGreatWork(iGreatWorkIndex))
												{
													artChoices.push_back(iGreatWorkIndex, iDistance);
													if ((GC.getLogging() && GC.getAILogging()))
													{
														CvGameCulture *pCulture = GC.getGame().GetGameCulture();
														if (pCulture)
														{
															CvString strLogString;
															strLogString.Format("Found Great Work for Conquest Plunder: %d, Distance: %d, Name: %s", iGreatWorkIndex, iDistance, pCulture->GetGreatWorkName(iGreatWorkIndex).GetCString());
															GetHomelandAI()->LogHomelandMessage(strLogString);
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			artChoices.SortItems();
			int iNotificationArtwork = -1;
			if (artChoices.size() > 0)
			{
				int iPlunder = GC.getGame().getSmallFakeRandNum(max(1, (iOpenSlots / 5)), GET_PLAYER(pCity->getOwner()).getGlobalAverage(YIELD_CULTURE));
				if (iPlunder <= 2)
				{
					iPlunder = 2;
				}
				if (iPlunder > artChoices.size())
				{
					iPlunder = artChoices.size();
				}
				if ((GC.getLogging() && GC.getAILogging()))
				{
					CvString strLogString;
					strLogString.Format("Number of Great Works to steal for Conquest Plunder: %d", iPlunder);
					GetHomelandAI()->LogHomelandMessage(strLogString);
				}
				for (int iGrab = 0; iGrab < artChoices.size(); iGrab++)
				{
					if (iStuffStolen >= iPlunder)
					{
						break;
					}
					int iCityLoop;
					CvCity* pPlayerCity = NULL;
					int iGreatWorkIndex;
					for (pPlayerCity = GET_PLAYER(ePlayer).firstCity(&iCityLoop); pPlayerCity != NULL; pPlayerCity = GET_PLAYER(ePlayer).nextCity(&iCityLoop))
					{
						if (iStuffStolen >= iPlunder)
						{
							break;
						}
						if (pPlayerCity != NULL && pPlayerCity != pCity)
						{
							for (int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
							{
								if (iStuffStolen >= iPlunder)
								{
									break;
								}
								const CvCivilizationInfo& playerCivilizationInfo = GET_PLAYER(ePlayer).getCivilizationInfo();
								BuildingTypes eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings((BuildingClassTypes)iBuildingClassLoop);
								if (eBuilding != NO_BUILDING)
								{
									CvBuildingEntry *pkBuilding = GC.getBuildingInfo(eBuilding);
									if (pkBuilding)
									{
										if (pPlayerCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0 && (pkBuilding->GetGreatWorkSlotType() == eArtArtifactSlot || pkBuilding->GetGreatWorkSlotType() == eMusicSlot || pkBuilding->GetGreatWorkSlotType() == eWritingSlot))
										{
											int iNumSlots = pkBuilding->GetGreatWorkCount();
											if (iNumSlots > 0)
											{
												for (int iI = 0; iI < iNumSlots; iI++)
												{
													if (iStuffStolen >= iPlunder)
													{
														break;
													}
													iGreatWorkIndex = pPlayerCity->GetCityBuildings()->GetBuildingGreatWork((BuildingClassTypes)iBuildingClassLoop, iI);
													if (iGreatWorkIndex == artChoices.GetElement(iGrab))
													{
														iNotificationArtwork = iGreatWorkIndex;
														// and create great work at home
														BuildingClassTypes eGWBuildingClass;
														int iGWSlot;
														CvCity *pArtCity = GetCulture()->GetClosestAvailableGreatWorkSlot(pPlayerCity->getX(), pPlayerCity->getY(), pkBuilding->GetGreatWorkSlotType(), &eGWBuildingClass, &iGWSlot);
														if (pArtCity)
														{
															// remove existing great works
															pPlayerCity->GetCityBuildings()->SetBuildingGreatWork((BuildingClassTypes)iBuildingClassLoop, iI, -1);
															pArtCity->GetCityBuildings()->SetBuildingGreatWork(eGWBuildingClass, iGWSlot, iGreatWorkIndex);
															iStuffStolen++;
															if ((GC.getLogging() && GC.getAILogging()))
															{
																CvGameCulture *pCulture = GC.getGame().GetGameCulture();
																if (pCulture)
																{
																	CvString strLogString;
																	strLogString.Format("Great Work STOLEN for Conquest Plunder: %s. Number stolen: %d. Max to steal: %d", pCulture->GetGreatWorkName(iGreatWorkIndex).GetCString(), iStuffStolen, iPlunder);
																	GetHomelandAI()->LogHomelandMessage(strLogString);
																}
															}
															if (GetID() == GC.getGame().getActivePlayer())
															{
																CvPopupInfo kPopup(BUTTONPOPUP_GREAT_WORK_COMPLETED_ACTIVE_PLAYER, iGreatWorkIndex);
																GC.GetEngineUserInterface()->AddPopup(kPopup);
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			if (iStuffStolen > 0)
			{
				if (GetID() == GC.getGame().getActivePlayer())
				{
					Localization::String strMessage;
					Localization::String strSummary;
					strMessage = Localization::Lookup("TXT_KEY_ART_STOLEN");
					strMessage << iStuffStolen;
					strMessage << strTargetNameKey;
					strSummary = Localization::Lookup("TXT_KEY_ART_STOLEN_SUMMARY");

					CvNotifications* pNotification = GetNotifications();
					if (pNotification)
					{
						pNotification->Add(NOTIFICATION_GREAT_WORK_COMPLETED_ACTIVE_PLAYER, strMessage.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), iNotificationArtwork, GET_PLAYER(ePlayer).GetID());
					}
				}
				if (ePlayer == GC.getGame().getActivePlayer())
				{
					Localization::String strMessage;
					Localization::String strSummary;
					strMessage = Localization::Lookup("TXT_KEY_ART_PLUNDERED");
					strMessage << iStuffStolen;
					strMessage << strTargetNameKey;
					strSummary = Localization::Lookup("TXT_KEY_ART_PLUNDERED_SUMMARY");

					CvNotifications* pNotification = GET_PLAYER(ePlayer).GetNotifications();
					if (pNotification)
					{
						pNotification->Add(NOTIFICATION_GREAT_WORK_COMPLETED_ACTIVE_PLAYER, strMessage.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), iNotificationArtwork, pCity->getOwner());
					}
				}
			}
		}
	}
}
void CvPlayer::DoWarVictoryBonuses()
{
	int iTurns = GetPlayerTraits()->GetGoldenAgeFromVictory();
	if(iTurns > 0)
	{
		if(iTurns < GC.getGame().goldenAgeLength())
		{
			iTurns = GC.getGame().goldenAgeLength();
		}
		// Player modifier
		int iLengthModifier = getGoldenAgeModifier();

		// Trait modifier
		iLengthModifier += GetPlayerTraits()->GetGoldenAgeDurationModifier();

#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
		// Do we get increased Golden Ages from a resource monopoly?
		if(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
		{
			for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
			{
				ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
				if(eResourceLoop != NO_RESOURCE)
				{
					CvResourceInfo* pInfo = GC.getResourceInfo(eResourceLoop);
					if (pInfo && pInfo->isMonopoly())
					{
						if(HasGlobalMonopoly(eResourceLoop) && pInfo->getMonopolyGALength() > 0)
						{
							int iTemp = pInfo->getMonopolyGALength();
							iTemp += GetMonopolyModPercent();
							iLengthModifier += iTemp;
						}
					}
				}
			}
		}
#endif
		if(iLengthModifier != 0)
		{
			iTurns = iTurns * (100 + iLengthModifier) / 100;
		}
		int iValue = GetGoldenAgeProgressMeter();
		changeGoldenAgeTurns(iTurns, iValue, true);
	}

	int iTourism = GetHistoricEventTourism(HISTORIC_EVENT_WAR);
	ChangeNumHistoricEvents(HISTORIC_EVENT_WAR, 1);
	// Culture boost based on previous turns
	if(iTourism > 0)
	{
		GetCulture()->AddTourismAllKnownCivsWithModifiers(iTourism);
		if(GetID() == GC.getGame().getActivePlayer())
		{
			CvCity* pCity = getCapitalCity();
			if(pCity != NULL)
			{
				char text[256] = {0};
				sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_TOURISM]", iTourism);
				SHOW_PLOT_POPUP(pCity->plot(), GetID(), text);

				CvNotifications* pNotification = GetNotifications();
				if(pNotification)
				{
					CvString strMessage;
					CvString strSummary;
					strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_WAR", iTourism);
					strSummary = GetLocalizedText("TXT_KEY_TOURISM_EVENT_SUMMARY");
					pNotification->Add(NOTIFICATION_CULTURE_VICTORY_SOMEONE_INFLUENTIAL, strMessage, strSummary, pCity->getX(), pCity->getY(), GetID());
				}
			}
		}
	}
}
int CvPlayer::DoDifficultyBonus(HistoricEventTypes eHistoricEvent)
{
	if (eHistoricEvent == HISTORIC_EVENT_DIG || eHistoricEvent == HISTORIC_EVENT_TRADE_CS)
		return 0;

	int iEra = GetCurrentEra();
	if(iEra <= 0)
	{
		iEra = 1;
	}
	int iHandicapBase = 0;
	int iHandicapA = 0;
	int iHandicapB = 0;
	int iHandicapC = 0;
	int iYieldHandicap = 0;
	CvHandicapInfo* pHandicapInfo = GC.getHandicapInfo(GC.getGame().getHandicapType());
	if(pHandicapInfo)
	{
		iHandicapBase = pHandicapInfo->getAIDifficultyBonusBase();
		iHandicapA = pHandicapInfo->getAIDifficultyBonusEarly();
		iHandicapB = pHandicapInfo->getAIDifficultyBonusMid();
		iHandicapC = pHandicapInfo->getAIDifficultyBonusLate();
		iYieldHandicap = iHandicapBase * ((iHandicapC * iEra * iEra) + (iHandicapB * iEra) + iHandicapA) / 100;
	}
	if (iYieldHandicap > 0)
	{	
		if (eHistoricEvent == HISTORIC_EVENT_ERA)
			iYieldHandicap *= 2;
		else if (eHistoricEvent == HISTORIC_EVENT_GP)
			iYieldHandicap /= 3;
		else if (eHistoricEvent != NO_HISTORIC_EVENT_TYPE)
			iYieldHandicap /= 2;

		bool IncludeCities = true;
		if (eHistoricEvent == HISTORIC_EVENT_GP ||
			eHistoricEvent == HISTORIC_EVENT_WONDER ||
			eHistoricEvent == HISTORIC_EVENT_TRADE_LAND ||
			eHistoricEvent == HISTORIC_EVENT_TRADE_SEA)
		{
			IncludeCities = false;
		}

		if (IncludeCities)
		{
			int iLoop;
			CvCity* pLoopCity;
			for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				if (pLoopCity != NULL)
				{
					pLoopCity->changeFood(iYieldHandicap);
					pLoopCity->changeProduction(iYieldHandicap);
				}
			}
		}

		GetTreasury()->ChangeGold(iYieldHandicap);
		ChangeGoldenAgeProgressMeter(iYieldHandicap);
		changeJONSCulture(iYieldHandicap / 2);
		
		TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
		if(eCurrentTech == NO_TECH)
		{
			changeOverflowResearch(iYieldHandicap);
		}
		else
		{
			GET_TEAM(getTeam()).GetTeamTechs()->ChangeResearchProgress(eCurrentTech, iYieldHandicap, GetID());
		}	
	}
	return iYieldHandicap;
}
#endif
#if defined(MOD_API_UNIFIED_YIELDS)
//	--------------------------------------------------------------------------------
/// Yield per turn from Religion
int CvPlayer::GetYieldPerTurnFromReligion(YieldTypes) const
{
	return 0;
}

//	--------------------------------------------------------------------------------
/// Trait bonus which adds Faith for trade partners? 
int CvPlayer::GetYieldPerTurnFromTraits(YieldTypes eYield) const
{
	if (!MOD_BALANCE_YIELD_SCALE_ERA)
		return GetPlayerTraits()->GetYieldChangePerTradePartner(eYield) * GetTrade()->GetNumDifferentTradingPartners();

	return 0;
}
#endif

//	--------------------------------------------------------------------------------
/// Total faith per turn
#if defined(MOD_BALANCE_CORE)
	int CvPlayer::GetTotalFaithPerTurn(bool bIgnoreHappiness ) const
#else
int CvPlayer::GetTotalFaithPerTurn() const
#endif
{
	int iFaithPerTurn = 0;

	// If we're in anarchy, then no Faith is generated!
	if (IsAnarchy())
		return 0;
#if defined(MOD_BALANCE_CORE)
	//No barbs or minors, please!
	if (isBarbarian() || isMinorCiv())
		return 0;
#endif

	// Faith per turn from Cities
	iFaithPerTurn += GetFaithPerTurnFromCities();

#if defined(MOD_API_UNIFIED_YIELDS)
	// Trait bonus which adds Faith for trade partners? 
	iFaithPerTurn += GetYieldPerTurnFromTraits(YIELD_FAITH);
#endif

	// Faith per turn from Minor Civs
	iFaithPerTurn += GetFaithPerTurnFromMinorCivs();

	// Faith per turn from Religion (Founder beliefs)
	iFaithPerTurn += GetFaithPerTurnFromReligion();

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (MOD_DIPLOMACY_CIV4_FEATURES) {
		// We're a vassal of someone, we get x% of his faith
		iFaithPerTurn += (GetYieldPerTurnFromVassals(YIELD_FAITH));
	}

	if (MOD_BALANCE_CORE_JFD)
	{
		iFaithPerTurn += GetYieldPerTurnFromMinors(YIELD_FAITH);
	}
#endif

#if defined(MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	if(!bIgnoreHappiness && MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	{
		iFaithPerTurn += GetYieldPerTurnFromHappiness(YIELD_FAITH, iFaithPerTurn);
	}
#endif

	return iFaithPerTurn;
}

//	--------------------------------------------------------------------------------
/// Faith per turn from Cities
int CvPlayer::GetFaithPerTurnFromCities() const
{
	int iFaithPerTurn = 0;

	// Add in culture from Cities
	const CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iFaithPerTurn += pLoopCity->GetFaithPerTurn();
	}

	return iFaithPerTurn;
}

//	--------------------------------------------------------------------------------
/// Faith per turn from Minor Civs
int CvPlayer::GetFaithPerTurnFromMinorCivs() const
{
	int iFaithPerTurn = 0;
	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		iFaithPerTurn += GetFaithPerTurnFromMinor((PlayerTypes)iMinorLoop);
	}
	return iFaithPerTurn;
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Gold per turn from Minor Civs
int CvPlayer::GetGoldPerTurnFromMinorCivs() const
{
	int iFaithPerTurn = 0;
	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		iFaithPerTurn += GetGoldPerTurnFromMinor((PlayerTypes)iMinorLoop);
	}
	return iFaithPerTurn;
}
//	--------------------------------------------------------------------------------
/// Science per turn from Minor Civs
int CvPlayer::GetSciencePerTurnFromMinorCivs() const
{
	int iFaithPerTurn = 0;
	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		iFaithPerTurn += GetSciencePerTurnFromMinor((PlayerTypes)iMinorLoop);
	}
	return iFaithPerTurn;
}
//	--------------------------------------------------------------------------------
/// Gold per turn from a Minor Civ
int CvPlayer::GetGoldPerTurnFromMinor(PlayerTypes eMinor) const
{
	int iGoldPerTurn = 0;

	if(GET_PLAYER(eMinor).isAlive())
	{
		iGoldPerTurn += GET_PLAYER(eMinor).GetMinorCivAI()->GetCurrentGoldBonus(GetID());
	}

	return iGoldPerTurn;
}
//	--------------------------------------------------------------------------------
/// Science per turn from a Minor Civ
int CvPlayer::GetSciencePerTurnFromMinor(PlayerTypes eMinor) const
{
	int iSciencePerTurn = 0;

	if(GET_PLAYER(eMinor).isAlive())
	{
		iSciencePerTurn += GET_PLAYER(eMinor).GetMinorCivAI()->GetCurrentScienceBonus(GetID());
	}

	return iSciencePerTurn;
}

int CvPlayer::GetYieldPerTurnFromMinors(YieldTypes eYield) const
{
	return m_aiYieldFromMinors[eYield];
}
void CvPlayer::SetYieldPerTurnFromMinors(YieldTypes eYield, int iValue)
{
	if (iValue != m_aiYieldFromMinors[eYield])
	{
		m_aiYieldFromMinors.setAt(eYield, iValue);
	}
}
#endif
//	--------------------------------------------------------------------------------
/// Faith per turn from a Minor Civ
int CvPlayer::GetFaithPerTurnFromMinor(PlayerTypes eMinor) const
{
	int iFaithPerTurn = 0;

	if(GET_PLAYER(eMinor).isAlive())
	{
		iFaithPerTurn += GET_PLAYER(eMinor).GetMinorCivAI()->GetCurrentFaithBonus(GetID());
	}

	return iFaithPerTurn;
}

//	--------------------------------------------------------------------------------
/// Faith per turn from Religion
int CvPlayer::GetFaithPerTurnFromReligion() const
{
	int iFaithPerTurn = 0;
#if defined(MOD_API_UNIFIED_YIELDS)
	iFaithPerTurn += GetYieldPerTurnFromReligion(YIELD_FAITH);
#else
	// Founder beliefs
	CvGameReligions* pReligions = GC.getGame().GetGameReligions();
	ReligionTypes eFoundedReligion = GetReligions()->GetReligionInMostCities();
	if(eFoundedReligion != NO_RELIGION)
	{
		const CvReligion* pReligion = pReligions->GetReligion(eFoundedReligion, NO_PLAYER);
		if(pReligion)
		{
			iFaithPerTurn += pReligion->m_Beliefs.GetHolyCityYieldChange(YIELD_FAITH);

			int iTemp = pReligion->m_Beliefs.GetYieldChangePerForeignCity(YIELD_FAITH);
			if (iTemp > 0)
			{
				iFaithPerTurn += (iTemp * GetReligions()->GetNumForeignCitiesFollowing());
			}

			iTemp = pReligion->m_Beliefs.GetYieldChangePerXForeignFollowers(YIELD_FAITH);
			if (iTemp > 0)
			{
				int iFollowers = GetReligions()->GetNumForeignFollowers(false /*bAtPeace*/);
				if (iFollowers > 0)
				{
					iFaithPerTurn += (iTemp / iFollowers);
				}
			}
		}
	}
#endif
	return iFaithPerTurn;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetFaith() const
{
	return m_iFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetFaith(int iNewValue)
{
	if(GC.getGame().isOption(GAMEOPTION_NO_RELIGION))
	{
		return;
	}

	if(GetFaith() != iNewValue)
	{
		// Add to the total we've ever had
		if(iNewValue > m_iFaith)
		{
			ChangeFaithEverGenerated(iNewValue - m_iFaith);
		}

		m_iFaith = iNewValue;

		if(GC.getGame().getActivePlayer() == GetID())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeFaith(int iChange)
{
	if(GC.getGame().isOption(GAMEOPTION_NO_RELIGION))
	{
		return;
	}

	SetFaith(GetFaith() + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetFaithEverGenerated() const
{
	return m_iFaithEverGenerated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetFaithEverGenerated(int iNewValue)
{
	if(m_iFaithEverGenerated != iNewValue)
		m_iFaithEverGenerated = iNewValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeFaithEverGenerated(int iChange)
{
	SetFaithEverGenerated(GetFaithEverGenerated() + iChange);
}

//	--------------------------------------------------------------------------------
/// Updates how much Happiness we have
void CvPlayer::DoUpdateTotalHappiness()
{
	// Start level
	m_iHappiness = getHandicapInfo().getHappinessDefault();

#if defined(MOD_BALANCE_CORE)
	// Gamespeed Bonus level
	if(MOD_BALANCE_CORE)
	{
		m_iHappiness += GC.getGame().getGameSpeedInfo().GetStartingHappiness();
	}
#endif
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	// Gamespeed Bonus level
	if(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	{
		m_iHappiness += GetHappinessFromResourceMonopolies();
	}
#endif
#if defined(MOD_BALANCE_CORE_HAPPINESS_LUXURY)
	if(MOD_BALANCE_CORE_HAPPINESS_LUXURY)
	{
		m_iHappiness += GetBonusHappinessFromLuxuries();
	}
#endif
	// Increase from Luxury Resources
	m_iHappiness += GetHappinessFromResources();

	// Happiness bonus for multiple Resource types
	m_iHappiness += GetHappinessFromResourceVariety();

	// Increase from Local City Happiness
	m_iHappiness += GetHappinessFromCities();

	// Increase from buildings
	m_iHappiness += GetHappinessFromBuildings();

	// Increase from policies
	m_iHappiness += GetHappinessFromPolicies();

	// Increase from num cities (player based, for buildings and such)
	m_iHappiness += getNumCities() * m_iHappinessPerCity;

	// Increase from Religion
	m_iHappiness += GetHappinessFromReligion();

	// Increase from Natural Wonders
	m_iHappiness += GetHappinessFromNaturalWonders();

	// Friendship with Minors can provide Happiness
	m_iHappiness += GetHappinessFromMinorCivs();

	// Increase from Leagues
	m_iHappiness += GetHappinessFromLeagues();

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (MOD_DIPLOMACY_CIV4_FEATURES) {
		// Increase from Vassals
		m_iHappiness += GetHappinessFromVassals();
	}
#endif
#if defined(MOD_BALANCE_CORE_EVENTS)
	CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		m_iHappiness += pLoopCity->GetEventHappiness();
	}
#endif

	// Increase for each City connected to Capital with a Trade Route
	DoUpdateCityConnectionHappiness();
	m_iHappiness += GetHappinessFromTradeRoutes();

#if !defined(NO_ACHIEVEMENTS)
	if(isLocalPlayer() && GetExcessHappiness() >= 100)
	{
		gDLL->UnlockAchievement(ACHIEVEMENT_XP2_45);
	}
#endif

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
}

//	--------------------------------------------------------------------------------
/// How much Happiness we have
int CvPlayer::GetHappiness() const
{
	return m_iHappiness;
}

//	--------------------------------------------------------------------------------
/// Sets how much Happiness we have
void CvPlayer::SetHappiness(int iNewValue)
{
	if(GetHappiness() != iNewValue)
	{
		m_iHappiness = iNewValue;
	}
}

/// Sets how much Unhappiness we have
void CvPlayer::SetUnhappiness(int iNewValue)
{
	if(m_iUnhappiness != iNewValue)
	{
		m_iUnhappiness = iNewValue;
	}
}
int CvPlayer::GetUnhappiness() const
{
	return m_iUnhappiness;
}

void CvPlayer::CalculateNetHappiness()
{
	//Not active player, or a barb, or a minor? Get out!
	if(isMinorCiv() || isBarbarian())
	{
		return;
	}

	//reset this as well, when a building is constructed or a policy adopted
	m_iNumUnitsSuppliedCached = -1;

	DoUpdateTotalHappiness();
	DoUpdateTotalUnhappiness();

	int iHappiness = GetHappiness();
	int iUnhappiness = GetUnhappiness();

	int iDiff = (iHappiness-iUnhappiness);
	if (iDiff != m_iHappinessTotal)
	{
		m_iHappinessTotal = iDiff;
		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
	}
}

#if defined(MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
int CvPlayer::GetYieldPerTurnFromHappiness(YieldTypes eYield, int iValue) const
{
	//Mechanic to allow for growth malus from happiness/unhappiness.
	int iHappiness = GetExcessHappiness();

	//If Happiness is greater than or over threshold, calculate city bonus mod.
	if(iHappiness >= GC.getBALANCE_HAPPINESS_THRESHOLD())
	{
		iHappiness = (iHappiness - GC.getBALANCE_HAPPINESS_THRESHOLD());
		//Are there minimums/maximums for the bonus? Restrict this value.
		if(iHappiness >= GC.getBALANCE_HAPPINESS_BONUS_MAXIMUM())
		{
			iHappiness = GC.getBALANCE_HAPPINESS_BONUS_MAXIMUM();
		}
		else if(iHappiness <= GC.getBALANCE_HAPPINESS_BONUS_MINIMUM())
		{
			iHappiness = GC.getBALANCE_HAPPINESS_BONUS_MINIMUM();
		}
		
	}
	//If happiness is less than the main threshold, calculate city penalty mod.
	else if(iHappiness < GC.getBALANCE_HAPPINESS_THRESHOLD())
	{
		//Are there minimums/maximums for the penalty? Restrict this value.
		if(iHappiness >= GC.getBALANCE_HAPPINESS_PENALTY_MINIMUM())
		{
			iHappiness = GC.getBALANCE_HAPPINESS_PENALTY_MINIMUM();
		}
		else if(iHappiness <= GC.getBALANCE_HAPPINESS_PENALTY_MAXIMUM())
		{
			iHappiness = GC.getBALANCE_HAPPINESS_PENALTY_MAXIMUM();
		}
	}
	if(iHappiness != 0)
	{
		//Mechanic to allow for growth malus from happiness/unhappiness.
		if(eYield == YIELD_GOLD)
		{
			iValue = ((iValue * /*3*/ GC.getBALANCE_HAPPINESS_GOLD_MODIFIER() * iHappiness) / 100);
			return iValue;
		}
		else if(eYield == YIELD_FAITH)
		{
			iValue = ((iValue * /*3*/ GC.getBALANCE_HAPPINESS_FAITH_MODIFIER() * iHappiness) / 100);
			return iValue;
		}
		else if(eYield == YIELD_CULTURE)
		{
			iValue = ((iValue * /*3*/ GC.getBALANCE_HAPPINESS_CULTURE_MODIFIER() * iHappiness) / 100);
			return iValue;
		}
		else if(eYield == YIELD_SCIENCE)
		{
			iValue = ((iValue * /*3*/ GC.getBALANCE_HAPPINESS_SCIENCE_MODIFIER() * iHappiness) / 100);
			return iValue;
		}
	}
	return 0;
}
	//LUA Functions
int CvPlayer::CalculateUnhappinessTooltip(YieldTypes eYield) const
{
	//Mechanic to allow for growth malus from happiness/unhappiness.
	int iHappiness = GetExcessHappiness();

	//If Happiness is greater than or over threshold, calculate city bonus mod.
	if(iHappiness >= GC.getBALANCE_HAPPINESS_THRESHOLD())
	{
		iHappiness = (iHappiness - GC.getBALANCE_HAPPINESS_THRESHOLD());
		//Are there minimums/maximums for the bonus? Restrict this value.
		if(iHappiness > GC.getBALANCE_HAPPINESS_BONUS_MAXIMUM())
		{
			iHappiness = GC.getBALANCE_HAPPINESS_BONUS_MAXIMUM();
		}
		else if(iHappiness < GC.getBALANCE_HAPPINESS_BONUS_MINIMUM())
		{
			iHappiness = GC.getBALANCE_HAPPINESS_BONUS_MINIMUM();
		}
	}
	//If happiness is less than the main threshold, calculate city penalty mod.
	else if(iHappiness < GC.getBALANCE_HAPPINESS_THRESHOLD())
	{
		//Are there minimums/maximums for the penalty? Restrict this value.
		if(iHappiness > GC.getBALANCE_HAPPINESS_PENALTY_MINIMUM())
		{
			iHappiness = GC.getBALANCE_HAPPINESS_PENALTY_MINIMUM();
		}
		else if(iHappiness < GC.getBALANCE_HAPPINESS_PENALTY_MAXIMUM())
		{
			iHappiness = GC.getBALANCE_HAPPINESS_PENALTY_MAXIMUM();
		}			
	}
	if(iHappiness != 0)
	{
		//Mechanic to allow for growth malus from happiness/unhappiness.
		if(eYield == YIELD_GOLD)
		{
			int iValue = GetTreasury()->CalculateGrossGoldTimes100(true);
			iValue = ((iValue * /*3*/ GC.getBALANCE_HAPPINESS_GOLD_MODIFIER() * iHappiness) / 100);
			return iValue;
		}
		else if(eYield == YIELD_FAITH)
		{
			int iValue = GetTotalFaithPerTurn(true);
			iValue = ((iValue * /*3*/ GC.getBALANCE_HAPPINESS_FAITH_MODIFIER() * iHappiness) / 100);
			return iValue;
		}
		else if(eYield == YIELD_CULTURE)
		{
			int iValue = GetTotalJONSCulturePerTurn(true);
			iValue = ((iValue * /*3*/ GC.getBALANCE_HAPPINESS_CULTURE_MODIFIER() * iHappiness) / 100);
			return iValue;
		}
		else if(eYield == YIELD_SCIENCE)
		{
			int iValue = GetScienceTimes100(true);
			iValue = ((iValue * /*3*/ GC.getBALANCE_HAPPINESS_SCIENCE_MODIFIER() * iHappiness) / 100);
			return iValue;
		}
	}

	return 0;
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvPlayer::GetPovertyUnhappinessGlobal() const
{
	return m_iChangePovertyUnhappinessGlobal;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangePovertyUnhappinessGlobal(int iChange)
{
	m_iChangePovertyUnhappinessGlobal += iChange;
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvPlayer::GetDefenseUnhappinessGlobal() const
{
	return m_iChangeDefenseUnhappinessGlobal;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangeDefenseUnhappinessGlobal(int iChange)
{
	m_iChangeDefenseUnhappinessGlobal += iChange;
}
/// Extra yield from building
int CvPlayer::GetUnculturedUnhappinessGlobal() const
{
	return m_iChangeUnculturedUnhappinessGlobal;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangeUnculturedUnhappinessGlobal(int iChange)
{
	m_iChangeUnculturedUnhappinessGlobal += iChange;
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvPlayer::GetIlliteracyUnhappinessGlobal() const
{
	return m_iChangeIlliteracyUnhappinessGlobal;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangeIlliteracyUnhappinessGlobal(int iChange)
{
	m_iChangeIlliteracyUnhappinessGlobal += iChange;
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvPlayer::GetMinorityUnhappinessGlobal() const
{
	return m_iChangeMinorityUnhappinessGlobal;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangeMinorityUnhappinessGlobal(int iChange)
{
	m_iChangeMinorityUnhappinessGlobal += iChange;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvPlayer::GetLandmarksTourismPercentGlobal() const
{
	return m_iLandmarksTourismPercentGlobal;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangeLandmarksTourismPercentGlobal(int iChange)
{
	m_iLandmarksTourismPercentGlobal += iChange;
}


//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvPlayer::GetGreatWorksTourismModifierGlobal() const
{
	return m_iGreatWorksTourismModifierGlobal;
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvPlayer::ChangeGreatWorksTourismModifierGlobal(int iChange)
{
	m_iGreatWorksTourismModifierGlobal += iChange;
}
#endif

//	--------------------------------------------------------------------------------
/// How much over our Happiness limit are we?
int CvPlayer::GetExcessHappiness() const
{
	if(isMinorCiv() || isBarbarian())
	{
		return 0;
	}
	return m_iHappinessTotal;
}

//	--------------------------------------------------------------------------------
/// Has the player passed the Happiness limit?
bool CvPlayer::IsEmpireUnhappy() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS))
	{
		return false;
	}
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	if(MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	{
		//Mechanic to allow for varied effects of happiness/unhappiness.
		int iHappiness = GetExcessHappiness();
		if(iHappiness < GC.getBALANCE_HAPPINESS_THRESHOLD_MAIN())
		{
			return true;
		}
	}
	else
	{
#endif
	if(GetExcessHappiness() < 0)
	{
		return true;
	}
#if defined(MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	}
#endif
	return false;
}

//	--------------------------------------------------------------------------------
/// Is the empire REALLY unhappy? (other penalties)
bool CvPlayer::IsEmpireVeryUnhappy() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS))
	{
		return false;
	}
#if defined(MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	if(MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	{
		//Mechanic to allow for varied effects of happiness/unhappiness.
		int iHappiness = GetExcessHappiness();
		if(iHappiness <= (/*-10*/ GC.getVERY_UNHAPPY_THRESHOLD() + GC.getBALANCE_HAPPINESS_THRESHOLD_MAIN()))
		{
			return true;
		}
	}
	else
	{
#endif
	if(GetExcessHappiness() <= /*-10*/ GC.getVERY_UNHAPPY_THRESHOLD())
	{
		return true;
	}
#if defined(MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	}
#endif
	return false;
}

//	--------------------------------------------------------------------------------
/// Is the empire SUPER unhappy? (leads to revolts)
bool CvPlayer::IsEmpireSuperUnhappy() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS))
	{
		return false;
	}
#if defined(MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	if(MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	{
		//Mechanic to allow for varied effects of happiness/unhappiness.
		int iHappiness = GetExcessHappiness();
		if(iHappiness <= (/*-20*/ GC.getSUPER_UNHAPPY_THRESHOLD() + GC.getBALANCE_HAPPINESS_THRESHOLD_MAIN()))
		{
			return true;
		}
	}
	else
	{
#endif
	if(GetExcessHappiness() <= /*-20*/ GC.getSUPER_UNHAPPY_THRESHOLD())
	{
		return true;
	}
#if defined(MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	}
#endif
	return false;
}

//	--------------------------------------------------------------------------------
/// Uprisings pop up if the empire is Very Unhappy
void CvPlayer::DoUpdateUprisings()
{
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	//Revolts only happen if super unhappy.
	if(MOD_BALANCE_CORE_HAPPINESS && IsEmpireSuperUnhappy())
	{
		// If we're very unhappy, make the counter wind down
		if(GetUprisingCounter() > 0)
		{
			ChangeUprisingCounter(-1);

			// Time's up!
			if(GetUprisingCounter() == 0)
			{
				DoUprising();
				DoResetUprisingCounter(/*bFirstTime*/ false);
			}
		}
		// Very Unhappy for the first time - seed the counter
		else
		{
			DoResetUprisingCounter(/*bFirstTime*/ true);
		}
	}
	else
#endif
	if(IsEmpireSuperUnhappy())
	{
		// If we're very unhappy, make the counter wind down
		if(GetUprisingCounter() > 0)
		{
			ChangeUprisingCounter(-1);

			// Time's up!
			if(GetUprisingCounter() == 0)
			{
				DoUprising();
				DoResetUprisingCounter(/*bFirstTime*/ false);
			}
		}
		// Very Unhappy for the first time - seed the counter
		else
		{
			DoResetUprisingCounter(/*bFirstTime*/ true);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Uprising countdown - get
int CvPlayer::GetUprisingCounter() const
{
	return m_iUprisingCounter;
}

//	--------------------------------------------------------------------------------
/// Uprising countdown - set
void CvPlayer::SetUprisingCounter(int iValue)
{
	m_iUprisingCounter = iValue;
}

//	--------------------------------------------------------------------------------
/// Uprising countdown - change
void CvPlayer::ChangeUprisingCounter(int iChange)
{
	SetUprisingCounter(GetUprisingCounter() + iChange);
}

//	--------------------------------------------------------------------------------
/// Uprising countdown - seed
void CvPlayer::DoResetUprisingCounter(bool bFirstTime)
{
	int iTurns = /*4*/ GC.getUPRISING_COUNTER_MIN();
	CvGame& theGame = GC.getGame();
	int iExtra = theGame.getSmallFakeRandNum(/*3*/ GC.getUPRISING_COUNTER_POSSIBLE(), getGlobalAverage(YIELD_CULTURE));
	iTurns += iExtra;

	// Game speed mod
	int iMod = theGame.getGameSpeedInfo().getTrainPercent();
	// Only LENGTHEN time between rebels
	if(iMod > 100)
	{
		iTurns *= iMod;
		iTurns /= 100;
	}

	if(bFirstTime)
		iTurns /= 2;

	if(iTurns <= 0)
		iTurns = 1;

	SetUprisingCounter(iTurns);
}

//	--------------------------------------------------------------------------------
// Fire off an uprising somewhere
void CvPlayer::DoUprising()
{
	// In hundreds
	int iNumRebels = /*100*/ GC.getUPRISING_NUM_BASE();
	int iExtraRoll = getNumCities() - 1;
	iExtraRoll += GC.getGame().getSmallFakeRandNum(iExtraRoll, getGlobalAverage(YIELD_CULTURE)) * /*20*/ GC.getUPRISING_NUM_CITY_COUNT();
	iNumRebels += iExtraRoll;
	iNumRebels /= 100;

	// Find a random city to pop up a bad man
	CvCity* pBestCity = NULL;
	int iBestWeight = 0;

	CvCity* pLoopCity;
	int iLoop;
	CvGame& theGame = GC.getGame();
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		int iTempWeight = pLoopCity->getPopulation();
		iTempWeight += theGame.getSmallFakeRandNum(10, getGlobalAverage(YIELD_CULTURE) + pLoopCity->plot()->GetPlotIndex());

		if(iTempWeight > iBestWeight)
		{
			iBestWeight = iTempWeight;
			pBestCity = pLoopCity;
		}
	}

	// Found a place to set up an uprising?
	if(pBestCity != NULL)
	{
		int iBestPlot = -1;
		int iBestPlotWeight = -1;
		CvPlot* pPlot;

		CvCityCitizens* pCitizens = pBestCity->GetCityCitizens();

		// Start at 1, since ID 0 is the city plot itself

		for(int iPlotLoop = 1; iPlotLoop < pBestCity->GetNumWorkablePlots(); iPlotLoop++)
		{
			pPlot = pCitizens->GetCityPlotFromIndex(iPlotLoop);

			if(!pPlot)		// Should be valid, but make sure
				continue;

			// Can't be impassable
			if(!pPlot->isValidMovePlot(GetID()))
				continue;

			// Can't be water
			if(pPlot->isWater())
				continue;

			// Can't be ANOTHER city
			if(pPlot->isCity())
				continue;

			// Don't place on a plot where a unit is already standing
			if(pPlot->getNumUnits() > 0)
				continue;

			int iTempWeight = theGame.getSmallFakeRandNum(10, getGlobalAverage(YIELD_CULTURE) + iPlotLoop);

			// Add weight if there's an improvement here!
			if(pPlot->getImprovementType() != NO_IMPROVEMENT)
			{
				iTempWeight += 4;

				// If also a a resource, even more weight!
				if(pPlot->getResourceType(getTeam()) != NO_RESOURCE)
					iTempWeight += 3;
			}

			// Add weight if there's a defensive bonus for this plot
			if(pPlot->defenseModifier(BARBARIAN_TEAM, false, false))
				iTempWeight += 4;

			// Don't pick plots that aren't ours
			if(pPlot->getOwner() != GetID())
				iTempWeight = -1;

			if(iTempWeight > iBestPlotWeight)
			{
				iBestPlotWeight = iTempWeight;
				iBestPlot = iPlotLoop;
			}
		}

		// Found valid plot
		if(iBestPlot != -1)
		{
			// Make barbs able to enter ANYONE'S territory
			theGame.SetBarbarianReleaseTurn(0);

			pPlot = pCitizens->GetCityPlotFromIndex(iBestPlot);

			// Pick a unit type
			UnitTypes eUnit = theGame.GetRandomSpawnUnitType(GetID(), /*bIncludeUUs*/ false, /*bIncludeRanged*/ false);

			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_REBELS");
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_REBELS_SUMMARY");
				pNotifications->Add(NOTIFICATION_REBELS, strMessage.toUTF8(), strSummary.toUTF8(), pPlot->getX(), pPlot->getY(), eUnit, BARBARIAN_PLAYER);
			}

			// Init unit
			GET_PLAYER(BARBARIAN_PLAYER).initUnit(eUnit, pPlot->getX(), pPlot->getY());
			iNumRebels--;	// Reduce the count since we just added the seed rebel

			// Loop until all rebels are placed
			do
			{
				iNumRebels--;

				// Init unit
				CvUnit* pUnit = GET_PLAYER(BARBARIAN_PLAYER).initUnit(eUnit, pPlot->getX(), pPlot->getY());
				CvAssert(pUnit);
				if (pUnit)
				{
					if (!pUnit->jumpToNearestValidPlotWithinRange(5))
						pUnit->kill(false);		// Could not find a spot!
				}
			}
			while(iNumRebels > 0);
		}
	}
}

//	--------------------------------------------------------------------------------
/// City can revolt if the empire is Super Unhappy
void CvPlayer::DoUpdateCityRevolts()
{
	int iPublicUnhappiness = 0;
	if (GetCulture()->GetPublicOpinionUnhappiness() > 0 || IsEmpireSuperUnhappy())
	{
		iPublicUnhappiness = 1;
	}
	if (IsEmpireVeryUnhappy() && iPublicUnhappiness > 0)
	{
		if(GetCityRevoltCounter() > 0)
		{
			ChangeCityRevoltCounter(-iPublicUnhappiness);

			// Time's up!
			if(GetCityRevoltCounter() == 0)
			{
				DoCityRevolt();
				SetCityRevoltCounter(0);
			}
			else
			{
				CvCity *pMostUnhappyCity = GetMostUnhappyCity();
				PlayerTypes eRecipient = GetMostUnhappyCityRecipient(pMostUnhappyCity);
				if (pMostUnhappyCity != NULL && eRecipient != NO_PLAYER)
				{
					if (GET_PLAYER(eRecipient).isAlive())
					{
						CvNotifications* pNotifications = GetNotifications();
						if (pNotifications && isHuman())
						{
							Localization::String strMessage = GetLocalizedText("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLT", GetCityRevoltCounter(), pMostUnhappyCity->getName(), GET_PLAYER(eRecipient).getCivilizationShortDescription());
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLT_SUMMARY");
							pNotifications->Add(NOTIFICATION_CITY_REVOLT_POSSIBLE, strMessage.toUTF8(), strSummary.toUTF8(), pMostUnhappyCity->getX(), pMostUnhappyCity->getY(), -1);
						}
					}
					else if (GET_PLAYER(eRecipient).isEverAlive())
					{
						CvNotifications* pNotifications = GetNotifications();
						if (pNotifications && isHuman())
						{
							Localization::String strMessage = GetLocalizedText("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLUTION_CP", GetCityRevoltCounter(), pMostUnhappyCity->getName(), GET_PLAYER(eRecipient).getCivilizationShortDescription());
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLUTION_CP_SUMMARY");
							pNotifications->Add(NOTIFICATION_CITY_REVOLT_POSSIBLE, strMessage.toUTF8(), strSummary.toUTF8(), pMostUnhappyCity->getX(), pMostUnhappyCity->getY(), -1);
						}
					}
					else
					{
						CvNotifications* pNotifications = GetNotifications();
						if (pNotifications && isHuman())
						{
							Localization::String strMessage = GetLocalizedText("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLUTION_CP_FREE_CITY", GetCityRevoltCounter(), pMostUnhappyCity->getName());
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLUTION_CP_SUMMARY");
							pNotifications->Add(NOTIFICATION_CITY_REVOLT_POSSIBLE, strMessage.toUTF8(), strSummary.toUTF8(), pMostUnhappyCity->getX(), pMostUnhappyCity->getY(), -1);
						}
					}
				}
			}
		}
		// Super Unhappy for the first time - seed the counter
		else
		{
			DoResetCityRevoltCounter();
		}
	}
	else
	{
		SetCityRevoltCounter(-1);
	}
}

//	--------------------------------------------------------------------------------
/// City revolt countdown - get
int CvPlayer::GetCityRevoltCounter() const
{
	return m_iCityRevoltCounter;
}

//	--------------------------------------------------------------------------------
/// City revolt countdown - set
void CvPlayer::SetCityRevoltCounter(int iValue)
{
	if (iValue != m_iCityRevoltCounter)
		m_iCityRevoltCounter = iValue;
}

//	--------------------------------------------------------------------------------
/// City revolt countdown - change
void CvPlayer::ChangeCityRevoltCounter(int iChange)
{
	SetCityRevoltCounter(GetCityRevoltCounter() + iChange);

	if ((GC.getLogging() && GC.getAILogging()))
	{
		int Counter = m_iCityRevoltCounter;
		CvString strLogString;
		strLogString.Format("CP - Countdown for City Revolt CONTINUES - %d turns.", Counter);

		CvString strTemp;

		CvString strFileName = "CityRevolutions.csv";
		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

		CvString strPlayerName;
		strPlayerName = getCivilizationShortDescription();
		strTemp += strPlayerName;
		strTemp += ", ";

		CvString strTurn;

		strTurn.Format("%d, ", GC.getGame().getGameTurn()); // turn
		strTemp += strTurn;

		strTemp += strLogString;

		pLog->Msg(strTemp);
	}
}

//	--------------------------------------------------------------------------------
/// City revolt countdown - seed
void CvPlayer::DoResetCityRevoltCounter()
{
	int iTurns = /*5*/ GC.getREVOLT_COUNTER_MIN();
	CvGame& theGame = GC.getGame();

	// Game speed mod
	int iMod = theGame.getGameSpeedInfo().getTrainPercent();
	// Only LENGTHEN time between rebels
	if(iMod > 100)
	{
		iTurns *= iMod;
		iTurns /= 100;
	}

	if(iTurns <= 0)
		iTurns = 1;

	CvCity *pMostUnhappyCity = GetMostUnhappyCity();
	PlayerTypes eRecipient = GetMostUnhappyCityRecipient(pMostUnhappyCity);
	if(pMostUnhappyCity != NULL && eRecipient != NO_PLAYER)
	{
		SetCityRevoltCounter(iTurns);

		if (GET_PLAYER(eRecipient).isAlive())
		{
			CvNotifications* pNotifications = GetNotifications();
			if (pNotifications && isHuman())
			{
				Localization::String strMessage = GetLocalizedText("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLT", iTurns, pMostUnhappyCity->getName(), GET_PLAYER(eRecipient).getCivilizationShortDescription());
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLT_SUMMARY");
				pNotifications->Add(NOTIFICATION_CITY_REVOLT_POSSIBLE, strMessage.toUTF8(), strSummary.toUTF8(), pMostUnhappyCity->getX(), pMostUnhappyCity->getY(), -1);
			}

			if ((GC.getLogging() && GC.getAILogging()))
			{
				CvString strLogString;
				strLogString.Format("CP - Countdown for City Revolt BEGINS - %s, will go to %s in %d turns.", pMostUnhappyCity->getName().GetCString(), GET_PLAYER(eRecipient).getCivilizationShortDescription(), iTurns);

				CvString strTemp;

				CvString strFileName = "CityRevolutions.csv";
				FILogFile* pLog;
				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

				CvString strPlayerName;
				strPlayerName = getCivilizationShortDescription();
				strTemp += strPlayerName;
				strTemp += ", ";

				CvString strTurn;

				strTurn.Format("%d, ", GC.getGame().getGameTurn()); // turn
				strTemp += strTurn;

				strTemp += strLogString;

				pLog->Msg(strTemp);
			}
		}
		else if (GET_PLAYER(eRecipient).isEverAlive())
		{
			CvNotifications* pNotifications = GetNotifications();
			if (pNotifications && isHuman())
			{
				Localization::String strMessage = GetLocalizedText("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLUTION_CP", iTurns, pMostUnhappyCity->getName(), GET_PLAYER(eRecipient).getCivilizationShortDescription());
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLUTION_CP_SUMMARY");
				pNotifications->Add(NOTIFICATION_CITY_REVOLT_POSSIBLE, strMessage.toUTF8(), strSummary.toUTF8(), pMostUnhappyCity->getX(), pMostUnhappyCity->getY(), -1);
			}

			if ((GC.getLogging() && GC.getAILogging()))
			{
				CvString strLogString;
				strLogString.Format("CP - Countdown for City Revolt BEGINS - %s, will go to DEAD PLAYER %s in %d turns.", pMostUnhappyCity->getName().GetCString(), GET_PLAYER(eRecipient).getName(), iTurns);

				CvString strTemp;

				CvString strFileName = "CityRevolutions.csv";
				FILogFile* pLog;
				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

				CvString strPlayerName;
				strPlayerName = getCivilizationShortDescription();
				strTemp += strPlayerName;
				strTemp += ", ";

				CvString strTurn;

				strTurn.Format("%d, ", GC.getGame().getGameTurn()); // turn
				strTemp += strTurn;

				strTemp += strLogString;

				pLog->Msg(strTemp);
			}
		}
		else
		{
			CvNotifications* pNotifications = GetNotifications();
			if (pNotifications && isHuman())
			{
				Localization::String strMessage = GetLocalizedText("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLUTION_CP_FREE_CITY", iTurns, pMostUnhappyCity->getName());
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_POSSIBLE_CITY_REVOLUTION_CP_SUMMARY");
				pNotifications->Add(NOTIFICATION_CITY_REVOLT_POSSIBLE, strMessage.toUTF8(), strSummary.toUTF8(), pMostUnhappyCity->getX(), pMostUnhappyCity->getY(), -1);
			}

			if ((GC.getLogging() && GC.getAILogging()))
			{
				CvString strLogString;
				strLogString.Format("CP - Countdown for City Revolt BEGINS - %s, will go to FREE CITY PLAYER in %d turns.", pMostUnhappyCity->getName().GetCString(), iTurns);

				CvString strTemp;

				CvString strFileName = "CityRevolutions.csv";
				FILogFile* pLog;
				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

				CvString strPlayerName;
				strPlayerName = getCivilizationShortDescription();
				strTemp += strPlayerName;
				strTemp += ", ";

				CvString strTurn;

				strTurn.Format("%d, ", GC.getGame().getGameTurn()); // turn
				strTemp += strTurn;

				strTemp += strLogString;

				pLog->Msg(strTemp);
			}
		}
	}
}

//	--------------------------------------------------------------------------------
// Fire off a city revolt somewhere
void CvPlayer::DoCityRevolt()
{
	CvCity *pMostUnhappyCity = GetMostUnhappyCity();
	PlayerTypes eRecipient = GetMostUnhappyCityRecipient(pMostUnhappyCity);
	if(pMostUnhappyCity != NULL && eRecipient != NO_PLAYER)
	{
#if defined(MOD_BALANCE_CORE)
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityFlipped, pMostUnhappyCity, eRecipient, pMostUnhappyCity->getOwner());
#endif
		if (!GET_PLAYER(eRecipient).isAlive())
		{ 
			if (GET_PLAYER(eRecipient).isEverAlive())
			{
				PlayerTypes eOldPlayer = pMostUnhappyCity->getOriginalOwner();
				if (eOldPlayer != NO_PLAYER && !GET_PLAYER(eOldPlayer).isAlive())
				{
					DoRevolutionPlayer(eOldPlayer, pMostUnhappyCity->GetID());
				}
			}
			else
			{
				const CvString strCityName = pMostUnhappyCity->getName();
				const char* charCityName = pMostUnhappyCity->getName().GetCString();
				if (GC.getGame().CreateFreeCityPlayer(pMostUnhappyCity))
				{
					CvPlayer &kRecipient = GET_PLAYER(eRecipient);
					for (int iNotifyLoop = 0; iNotifyLoop < MAX_MAJOR_CIVS; ++iNotifyLoop){
						PlayerTypes eNotifyPlayer = (PlayerTypes)iNotifyLoop;
						CvPlayerAI& kCurNotifyPlayer = GET_PLAYER(eNotifyPlayer);
						CvNotifications* pNotifications = kCurNotifyPlayer.GetNotifications();
						if (pNotifications)
						{
							Localization::String strMessage;
							if (eNotifyPlayer == GetID())
							{
								strMessage = GetLocalizedText("TXT_KEY_NOTIFICATION_CITY_REVOLT_FREE_CITY", strCityName, kRecipient.getCivilizationShortDescription());
							}
							else
							{
								strMessage = GetLocalizedText("TXT_KEY_NOTIFICATION_OTHER_PLAYER_CITY_REVOLT_FREE_CITY", getCivilizationAdjective(), strCityName, kRecipient.getCivilizationShortDescription());
							}
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_REVOLT_SUMMARY");
							pNotifications->Add(NOTIFICATION_CITY_REVOLT, strMessage.toUTF8(), strSummary.toUTF8(), GET_PLAYER(eRecipient).getCapitalCity()->getX(), GET_PLAYER(eRecipient).getCapitalCity()->getY(), -1);
						}
					}

					if (GC.getLogging() && GC.getAILogging() && pMostUnhappyCity != NULL)
					{
						CvString playerName;
						FILogFile* pLog;
						CvString strBaseString;
						CvString strOutBuf;
						CvString strFileName = "CityRevolutions.csv";
						playerName = getCivilizationShortDescription();
						pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
						strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
						strBaseString += playerName + ", ";
						strOutBuf.Format("Defection! %s ceded to new FREE CITY of %s", charCityName, kRecipient.getName());
						strBaseString += strOutBuf;
						pLog->Msg(strBaseString);
					}
				}
			}
		}
		else
		{
			CvPlayer &kRecipient = GET_PLAYER(eRecipient);
			for (int iNotifyLoop = 0; iNotifyLoop < MAX_MAJOR_CIVS; ++iNotifyLoop){
				PlayerTypes eNotifyPlayer = (PlayerTypes)iNotifyLoop;
				CvPlayerAI& kCurNotifyPlayer = GET_PLAYER(eNotifyPlayer);
				CvNotifications* pNotifications = kCurNotifyPlayer.GetNotifications();
				if (pNotifications)
				{
					Localization::String strMessage;
					if (eNotifyPlayer == GetID())
					{
						strMessage = GetLocalizedText("TXT_KEY_NOTIFICATION_CITY_REVOLT", pMostUnhappyCity->getName(), kRecipient.getCivilizationShortDescription());
					}
					else
					{
						strMessage = GetLocalizedText("TXT_KEY_NOTIFICATION_OTHER_PLAYER_CITY_REVOLT", getCivilizationAdjective(), pMostUnhappyCity->getName(), kRecipient.getCivilizationShortDescription());
					}
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_REVOLT_SUMMARY");
					pNotifications->Add(NOTIFICATION_CITY_REVOLT, strMessage.toUTF8(), strSummary.toUTF8(), pMostUnhappyCity->getX(), pMostUnhappyCity->getY(), -1);
				}
			}

			if (GC.getLogging() && GC.getAILogging() && pMostUnhappyCity != NULL)
			{
				CvString playerName;
				FILogFile* pLog;
				CvString strBaseString;
				CvString strOutBuf;
				CvString strFileName = "CityRevolutions.csv";
				playerName = getCivilizationShortDescription();
				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				strBaseString += playerName + ", ";
				strOutBuf.Format("Defection! %s ceded to %s", pMostUnhappyCity->getName().GetCString(), kRecipient.getName());
				strBaseString += strOutBuf;
				pLog->Msg(strBaseString);
			}

			// get the plot before transferring ownership
			CvPlot *pPlot = pMostUnhappyCity->plot();
			kRecipient.acquireCity(pMostUnhappyCity, false/*bConquest*/, true/*bGift*/);
			pMostUnhappyCity = NULL; //no longer valid

			 // Move Units from player that don't belong here
			if (pPlot->getNumUnits() > 0)
			{
				// Get the current list of units because we will possibly be moving them out of the plot's list
				IDInfoVector currentUnits;
				if (pPlot->getUnits(&currentUnits) > 0)
				{
					for (IDInfoVector::const_iterator itr = currentUnits.begin(); itr != currentUnits.end(); ++itr)
					{
						CvUnit* pLoopUnit = (CvUnit*)GetPlayerUnit(*itr);

						if (pLoopUnit && pLoopUnit->getOwner() == GetID())
						{
							pLoopUnit->finishMoves();
							if (!pLoopUnit->jumpToNearestValidPlot())
								pLoopUnit->kill(false);
						}
					}
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
// Calculate city that will want to revolt
CvCity *CvPlayer::GetMostUnhappyCity()
{
	CvCity *pRtnValue = NULL;
	int iHighestUnhappiness = -1;

	if (getNumCities() > 1)
	{
		PolicyBranchTypes ePreferredIdeology = GetCulture()->GetPublicOpinionPreferredIdeology();

		int iLoop;
		CvCity* pLoopCity;
		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if (pLoopCity->isCapital())
				continue;

			if (pLoopCity->IsOriginalMajorCapital())
				continue;

			// mind the sign change
			int iUnhappiness = -1 * pLoopCity->getHappinessDelta(); 

			if (iUnhappiness <= 0)
				continue;

			// Look at each civ
			for (int iLoopPlayer = 0; iLoopPlayer < MAX_CIV_PLAYERS; iLoopPlayer++)
			{
				CvPlayer &kPlayer = GET_PLAYER((PlayerTypes)iLoopPlayer);
				if (iLoopPlayer != GetID())
				{		
					PolicyBranchTypes eOtherCivIdeology = NO_POLICY_BRANCH_TYPE;
					int iCulturalDominanceOverUs = 0;
					if (kPlayer.isAlive() && !kPlayer.isMinorCiv())
					{
						if (eOtherCivIdeology != NO_POLICY_BRANCH_TYPE && eOtherCivIdeology == ePreferredIdeology)
						{
							iUnhappiness *= 20;
						}
						iCulturalDominanceOverUs = kPlayer.GetCulture()->GetInfluenceLevel(GetID()) - GetCulture()->GetInfluenceLevel((PlayerTypes)iLoopPlayer);
					}
					else
					{
						if (!kPlayer.isAlive() && kPlayer.isMinorCiv())
						{
							iCulturalDominanceOverUs = 5;
						}
						else if (!kPlayer.isAlive())
						{
							iCulturalDominanceOverUs = 5;
						}
					}
					// Find how far their capital is from this city
					int iX = kPlayer.GetOriginalCapitalX();
					int iY = kPlayer.GetOriginalCapitalY();
					int iCapitalDistance = plotDistance(pLoopCity->getX(), pLoopCity->getY(), iX, iY);

					int iDistanceFactor = 100 - iCapitalDistance;
					if (iDistanceFactor <= 0)
						iDistanceFactor = 1;

					iDistanceFactor = (int)sqrt((float)iDistanceFactor);
					iUnhappiness += (iDistanceFactor * iCulturalDominanceOverUs);
				}
			}

			if (pLoopCity->getOriginalOwner() == GetID())
				iUnhappiness /= 4;

			if (pLoopCity->IsPuppet())
				iUnhappiness *= 2;

			int iCapitalDistance = plotDistance(pLoopCity->getX(), pLoopCity->getY(), getCapitalCity()->getX(), getCapitalCity()->getY());

			int iDistanceFactor = 100 - iCapitalDistance;
			if (iDistanceFactor <= 0)
				iDistanceFactor = 1;

			iUnhappiness += iDistanceFactor / 10;

			int iModifier = 0;
			if (GAMEEVENTINVOKE_VALUE(iModifier, GAMEEVENT_CityFlipChance, pLoopCity->GetID(), GetID()) == GAMEEVENTRETURN_VALUE) {
				if (iModifier != 0) {
					iUnhappiness += iModifier;
				}
			}

			if (iUnhappiness > iHighestUnhappiness)
			{
				iHighestUnhappiness = iUnhappiness;
				pRtnValue = pLoopCity;
			}
		}
	}

	return pRtnValue;
}

// Calculate player that will receive city if it revolts
PlayerTypes CvPlayer::GetMostUnhappyCityRecipient(CvCity* pMostUnhappyCity)
{
	PlayerTypes eRtnValue = NO_PLAYER;
	int iBestValue = 0;

	if (pMostUnhappyCity != NULL)
	{
		if (!GET_PLAYER(pMostUnhappyCity->getOriginalOwner()).isAlive())
			return pMostUnhappyCity->getOriginalOwner();

		if (pMostUnhappyCity->getOriginalOwner() != pMostUnhappyCity->getOwner())
			return pMostUnhappyCity->getOriginalOwner();

		PolicyBranchTypes ePreferredIdeology = GetCulture()->GetPublicOpinionPreferredIdeology();

		//doesn't happen if we're influenced by someone
		if (ePreferredIdeology == NO_POLICY_BRANCH_TYPE || ePreferredIdeology == GetPlayerPolicies()->GetLateGamePolicyTree())
		{
			if (GC.getGame().CreateFreeCityPlayer(pMostUnhappyCity, true))
			{
				PlayerTypes ePotentialFreeCityPlayer = GC.getGame().GetPotentialFreeCityPlayer(pMostUnhappyCity);
				if (ePotentialFreeCityPlayer != NO_PLAYER && GC.getGame().GetPotentialFreeCityTeam(pMostUnhappyCity) != NO_TEAM)
					return ePotentialFreeCityPlayer;
			}
		}

		// Look at each civ
		for (int iLoopPlayer = 0; iLoopPlayer < MAX_MAJOR_CIVS; iLoopPlayer++)
		{
			CvPlayer &kPlayer = GET_PLAYER((PlayerTypes)iLoopPlayer);
			if (iLoopPlayer != GetID())
			{
				if (kPlayer.isAlive() && !kPlayer.isMinorCiv() && kPlayer.getCapitalCity() != NULL)
				{
					if (kPlayer.IsEmpireSuperUnhappy())
						continue;

					PublicOpinionTypes eOpinionInMyCiv = GetCulture()->GetPublicOpinionType();
					int iCulturalDominanceOverUs = kPlayer.GetCulture()->GetInfluenceLevel(GetID()) - GetCulture()->GetInfluenceLevel((PlayerTypes)iLoopPlayer);
					if (eOpinionInMyCiv == PUBLIC_OPINION_REVOLUTIONARY_WAVE || (IsEmpireSuperUnhappy() && iCulturalDominanceOverUs > 1))
					{
						int iValue = 1000;
						if (iCulturalDominanceOverUs > 0)
						{
							iValue *= iCulturalDominanceOverUs+1;
						}
						// Find how far their capital is from this city
						int iCapitalDistance = plotDistance(pMostUnhappyCity->getX(), pMostUnhappyCity->getY(), kPlayer.getCapitalCity()->getX(), kPlayer.getCapitalCity()->getY());

						iValue -= iCapitalDistance * 2;

						PolicyBranchTypes eOtherCivIdeology = kPlayer.GetPlayerPolicies()->GetLateGamePolicyTree();
						if (eOtherCivIdeology != NO_POLICY_BRANCH_TYPE && eOtherCivIdeology == ePreferredIdeology)
							iValue *= 3;

						int iModifier = 0;
						if (GAMEEVENTINVOKE_VALUE(iModifier, GAMEEVENT_CityFlipRecipientChance, pMostUnhappyCity->GetID(), GetID(), (PlayerTypes)iLoopPlayer) == GAMEEVENTRETURN_VALUE) {
							if (iModifier != 0) {
								iValue += iModifier;
							}
						}

						if (iValue > iBestValue)
						{
							iBestValue = iValue;
							eRtnValue = (PlayerTypes)iLoopPlayer;
						}
					}
				}
			}
		}
	}

	return eRtnValue;
}

//	--------------------------------------------------------------------------------
/// Returns the amount of Happiness being added by Policies
int CvPlayer::GetHappinessFromPolicies() const
{
	int iHappiness = m_pPlayerPolicies->GetNumericModifier(POLICYMOD_EXTRA_HAPPINESS);
	iHappiness += (getNumCities() * m_pPlayerPolicies->GetNumericModifier(POLICYMOD_EXTRA_HAPPINESS_PER_CITY));

#ifdef HH_MOD_NATURAL_WONDER_MODULARITY
	/*
	see CvPlayer::GetHappinessFromNaturalWonders()
	*/
#endif

	int iHappinessPerXPopulation;
#if defined(MOD_BALANCE_CORE_POLICIES)
	int m_iHappinessPerXPopulationGlobal;
	m_iHappinessPerXPopulationGlobal = GetHappinessPerXPopulationGlobal();
#endif
	iHappinessPerXPopulation = GetHappinessPerXPopulation();

	if(iHappinessPerXPopulation > 0)
	{
		const CvCity* pLoopCity;
		int iLoop;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity && !pLoopCity->IsPuppet())
			{
				int iExtraHappiness = pLoopCity->getPopulation() / iHappinessPerXPopulation;

				iHappiness += iExtraHappiness;
			}
		}
	}
#if defined(MOD_BALANCE_CORE_POLICIES)
	if(MOD_BALANCE_CORE_POLICIES && m_iHappinessPerXPopulationGlobal > 0)
	{
		int iTotalPop = getTotalPopulation();
		if(iTotalPop > 0)
		{
			int iExtraHappinessGlobal = (iTotalPop / m_iHappinessPerXPopulationGlobal);
			iHappiness += iExtraHappinessGlobal;
		}
	}

	if (GetHappinessPerActiveTradeRoute() > 0)
	{
		iHappiness += (GetTrade()->GetNumberOfTradeRoutes() * GetHappinessPerActiveTradeRoute());
	}

	if (GetExtraHappinessPerXPoliciesFromPolicies() > 0)
	{
		iHappiness += GetPlayerPolicies()->GetNumPoliciesOwned() / GetExtraHappinessPerXPoliciesFromPolicies();
	}
#endif

	return iHappiness;
}

//	--------------------------------------------------------------------------------
/// Returns the amount of Local Happiness generated in the cities
int CvPlayer::GetHappinessFromCities() const
{
	int iHappiness = 0;

	const CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (pLoopCity->IsPuppet() && MOD_BALANCE_CORE_PUPPET_CHANGES)
			continue;

		iHappiness += pLoopCity->GetLocalHappiness();
	}

	return iHappiness;
}

//	--------------------------------------------------------------------------------
/// Returns the amount of Global Happiness being added by Buildings
int CvPlayer::GetHappinessFromBuildings() const
{
	return m_iHappinessFromBuildings;
}
void CvPlayer::DoUpdateHappinessFromBuildings()
{
	int iHappiness = 0;
	BuildingClassTypes eBuildingClass;

	// Building Class Mods
	int iSpecialBuildingHappiness = 0;
	for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
	{
		eBuildingClass = (BuildingClassTypes) iI;

		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
		if(!pkBuildingClassInfo)
		{
			continue;
		}

		BuildingTypes eBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eBuildingClass);
		int iNumTotal = countNumBuildings(eBuilding) - (MOD_BALANCE_CORE_PUPPET_CHANGES ? countNumBuildingsInPuppets(eBuilding) : 0);
		if (eBuilding != NO_BUILDING && iNumTotal > 0)
		{
			CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
			if(pkBuilding)
			{
				for(int jJ = 0; jJ < GC.getNumBuildingClassInfos(); jJ++)
				{
					BuildingClassTypes eBuildingClassThatGivesHappiness = (BuildingClassTypes) jJ;
					int iHappinessPerBuilding = pkBuilding->GetBuildingClassHappiness(eBuildingClassThatGivesHappiness);
					if(iHappinessPerBuilding > 0)
					{
						BuildingTypes eBuildingThatGivesHappiness = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eBuildingClassThatGivesHappiness);
						if(eBuildingThatGivesHappiness != NO_BUILDING)
						{
							int iNumTotal2 = countNumBuildings(eBuildingThatGivesHappiness) - (MOD_BALANCE_CORE_PUPPET_CHANGES ? countNumBuildingsInPuppets(eBuildingThatGivesHappiness) : 0);

							iSpecialBuildingHappiness += iHappinessPerBuilding * iNumTotal2;
						}
					}
				}
			}
		}
	}
	iHappiness += iSpecialBuildingHappiness;

	const CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (pLoopCity->IsPuppet() && MOD_BALANCE_CORE_PUPPET_CHANGES)
			continue;

		iHappiness += pLoopCity->GetHappinessFromBuildings();
	}

	// Increase from num policies -- MOVE THIS CODE (and provide a new tool tip string) if we ever get happiness per X policies to something beside a building
	if (m_iHappinessPerXPolicies > 0)
	{
		iHappiness += GetPlayerPolicies()->GetNumPoliciesOwned() / m_iHappinessPerXPolicies;
	}
	if (m_iHappinessFromBuildings != iHappiness)
	{
		m_iHappinessFromBuildings = iHappiness;
	}
}

//	--------------------------------------------------------------------------------
/// Returns the amount of extra Happiness per City
int CvPlayer::GetExtraHappinessPerCity() const
{
	return m_iHappinessPerCity;
}

//	--------------------------------------------------------------------------------
/// Changes amount of extra Happiness per City
void CvPlayer::ChangeExtraHappinessPerCity(int iChange)
{
	CvAssertMsg(m_iHappinessPerCity >= 0, "Count of buildings helping Happiness is corrupted");

	if(iChange != 0)
		m_iHappinessPerCity += iChange;
}

//	--------------------------------------------------------------------------------
/// Returns the amount of extra Happiness per City
int CvPlayer::GetExtraHappinessPerXPolicies() const
{
	return m_iHappinessPerXPolicies;
}

//	--------------------------------------------------------------------------------
/// Changes amount of extra Happiness per City
void CvPlayer::ChangeExtraHappinessPerXPolicies(int iChange)
{
	CvAssertMsg(m_iHappinessPerXPolicies >= 0, "Count of extra happiness per buildings is corrupted");

	if(iChange != 0)
		m_iHappinessPerXPolicies += iChange;
}

/// Returns the amount of extra Happiness per City
int CvPlayer::GetExtraHappinessPerXPoliciesFromPolicies() const
{
	return m_iExtraHappinessPerXPoliciesFromPolicies;
}

//	--------------------------------------------------------------------------------
/// Changes amount of extra Happiness per City
void CvPlayer::ChangeExtraHappinessPerXPoliciesFromPolicies(int iChange)
{
	CvAssertMsg(m_iExtraHappinessPerXPoliciesFromPolicies >= 0, "Count of extra happiness per buildings is corrupted");

	if (iChange != 0)
		m_iExtraHappinessPerXPoliciesFromPolicies += iChange;
}

/// Returns the amount of extra Happiness per City
int CvPlayer::GetHappinessPerXGreatWorks() const
{
	return m_iHappinessPerXGreatWorks;
}

//	--------------------------------------------------------------------------------
/// Changes amount of extra Happiness per City
void CvPlayer::ChangeHappinessPerXGreatWorks(int iChange)
{
	CvAssertMsg(m_iHappinessPerXGreatWorks  >= 0, "Count of extra happiness per buildings is corrupted");

	if (iChange != 0)
		m_iHappinessPerXGreatWorks += iChange;
}
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
int CvPlayer::GetHappinessFromResourceMonopolies() const
{
	int iTotalHappiness = 0;
	// Do we get increased Happiness from a resource monopoly?
	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
		CvResourceInfo* pInfo = GC.getResourceInfo(eResourceLoop);
		if (pInfo && pInfo->isMonopoly())
		{
			if(HasGlobalMonopoly(eResourceLoop) && pInfo->getMonopolyHappiness() > 0)
			{
				int iTemp = pInfo->getMonopolyHappiness();
				iTemp += GetMonopolyModFlat();
				iTotalHappiness += iTemp;
			}
		}
	}
	return iTotalHappiness;
}
#endif
//	--------------------------------------------------------------------------------
/// Total amount of Happiness gained from Resources
int CvPlayer::GetHappinessFromResources() const
{
	int iTotalHappiness = 0;

	// Check all connected Resources
	for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResource = (ResourceTypes) iResourceLoop;

		int iBaseHappiness = GetHappinessFromLuxury(eResource);
		if(iBaseHappiness)
		{
			// Resource bonus from Minors, and this is a Luxury we're getting from one (Policies, etc.)
			if(IsMinorResourceBonus() && getResourceFromMinors(eResource) > 0)
			{
				iBaseHappiness *= /*150*/ GC.getMINOR_POLICY_RESOURCE_HAPPINESS_MULTIPLIER();
				iBaseHappiness /= 100;
			}

			iTotalHappiness += iBaseHappiness;
			iTotalHappiness += GetExtraHappinessPerLuxury();
		}
	}

	return iTotalHappiness;
}

//	--------------------------------------------------------------------------------
/// Amount of Happiness from having a variety of Luxuries
int CvPlayer::GetHappinessFromResourceVariety() const
{
	int iMultipleLuxuriesBonus = /*1*/ GC.getHAPPINESS_PER_EXTRA_LUXURY();
	if (iMultipleLuxuriesBonus == 0)
		return 0;

	// Check all connected Resources
	int iNumHappinessResources = 0;
	for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResource = (ResourceTypes) iResourceLoop;
		if(GetHappinessFromLuxury(eResource) > 0)
		{
			iNumHappinessResources++;
		}
	}

	if(iNumHappinessResources > 1)
	{
		return (iNumHappinessResources-1) * iMultipleLuxuriesBonus;
	}

	return 0;
}


//	--------------------------------------------------------------------------------
/// Total amount of Happiness gained from Religion
int CvPlayer::GetHappinessFromReligion()
{
	int iHappinessFromReligion = 0;
	CvGameReligions* pReligions = GC.getGame().GetGameReligions();

	// Founder beliefs
	ReligionTypes eFoundedReligion = GC.getGame().GetGameReligions()->GetFounderBenefitsReligion(GetID());
	if(eFoundedReligion == NO_RELIGION)
	{
		eFoundedReligion = GetReligions()->GetReligionInMostCities();
	}
	if(eFoundedReligion != NO_RELIGION)
	{
		const CvReligion* pReligion = pReligions->GetReligion(eFoundedReligion, GetID());
		if (pReligion)
		{
			CvCity* pHolyCity = NULL;
			CvPlot* pHolyCityPlot = GC.getMap().plot(pReligion->m_iHolyCityX, pReligion->m_iHolyCityY);
			if (pHolyCityPlot)
			{
				pHolyCity = pHolyCityPlot->getPlotCity();
			}

			bool bAtPeace = GET_TEAM(getTeam()).getAtWarCount(false) == 0;
			iHappinessFromReligion += pReligion->m_Beliefs.GetPlayerHappiness(bAtPeace, GetID(), pHolyCity, true);

			float iHappinessPerFollowingCity = pReligion->m_Beliefs.GetHappinessPerFollowingCity(GetID(), pHolyCity, true);
			iHappinessFromReligion += (int)((float)pReligions->GetNumCitiesFollowing(eFoundedReligion) * iHappinessPerFollowingCity);

			int iHappinessPerXPeacefulForeignFollowers = pReligion->m_Beliefs.GetHappinessPerXPeacefulForeignFollowers(GetID(), pHolyCity, true);
			if (iHappinessPerXPeacefulForeignFollowers > 0)
			{
				iHappinessFromReligion += GetReligions()->GetNumForeignFollowers(true, /*bAtPeace */eFoundedReligion) / iHappinessPerXPeacefulForeignFollowers;
			}
#if defined(MOD_BALANCE_CORE_BELIEFS)
			int iPantheon = 0;
			if (pHolyCity == NULL)
			{
				pHolyCity = getCapitalCity();
			}
			int iHappiness = pReligion->m_Beliefs.GetHappinessPerPantheon(GetID(), pHolyCity, true);
			if (iHappiness > 0)
			{
				iPantheon = GC.getGame().GetGameReligions()->GetNumPantheonsCreated();
				if (iPantheon > 0)
				{
					if (iPantheon > 8)
					{
						iPantheon = 8;
					}
					iHappinessFromReligion += (iPantheon * iHappiness);
				}
			}
			iHappiness = pReligion->m_Beliefs.GetFullyConvertedHappiness(GetID(), pHolyCity, true);
			if (iHappiness > 0)
			{
				int iLoop;
				for (const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if (pLoopCity == NULL)
						continue;

					if (pLoopCity->GetCityReligions()->GetFollowersOtherReligions(eFoundedReligion) > 0)
						continue;

					iHappinessFromReligion += iHappiness;
				}
			}
			int iSpyHappiness = pReligion->m_Beliefs.GetHappinessFromForeignSpies(GetID(), pHolyCity, true);
			if (iSpyHappiness > 0)
			{
				int numForeignSpies = 0;
				CvPlayerEspionage* pEspionage = GetEspionage();
				if (pEspionage)
				{
					for (uint ui = 0; ui < pEspionage->m_aSpyList.size(); ui++)
					{
						if (pEspionage->m_aSpyList[ui].m_eSpyState == SPY_STATE_DEAD)
							continue;

						if (pEspionage->m_aSpyList[ui].m_eSpyState == SPY_STATE_TRAVELLING)
							continue;

						CvPlot* pPlot = GC.getMap().plot(pEspionage->m_aSpyList[ui].m_iCityX, pEspionage->m_aSpyList[ui].m_iCityY);
						if (pPlot == NULL)
							continue;

						CvCity* pSpyCity = pPlot->getPlotCity();

						if (pSpyCity == NULL)
							continue;

						if (pSpyCity->getOwner() == GetID())
							continue;

						numForeignSpies++;
					}
				}
				iHappinessFromReligion += numForeignSpies * iSpyHappiness;
			}
			
#endif
		}
	}

	return iHappinessFromReligion;
}

//	--------------------------------------------------------------------------------
// Happiness from finding Natural Wonders
int CvPlayer::GetHappinessFromNaturalWonders() const
{
	int iNumWonders = GET_TEAM(getTeam()).GetNumNaturalWondersDiscovered();

	int iHappiness = iNumWonders* /*1*/ GC.getHAPPINESS_PER_NATURAL_WONDER();
	
#if defined(HH_MOD_NATURAL_WONDER_MODULARITY)
	int iBonusHappiness = iNumWonders* (m_pPlayerPolicies->GetNumericModifier(POLICYMOD_EXTRA_NATURALWONDER_HAPPINESS));
	iHappiness += iBonusHappiness;
#endif

	// Trait boosts this further?
	if(m_pTraits->GetNaturalWonderHappinessModifier() > 0)
	{
		iHappiness *= (100 + m_pTraits->GetNaturalWonderHappinessModifier());
		iHappiness /= 100;
	}

#if defined(MOD_BALANCE_CORE)
	for (int iI = 0; iI < GC.getNumFeatureInfos(); iI++)
	{
		FeatureTypes eFeature = (FeatureTypes)iI;
		if (eFeature == NO_FEATURE)
			continue;

		if (!IsNWOwned(eFeature))
			continue;

		int iPlotHappiness = GC.getFeatureInfo(eFeature)->getInBorderHappiness();

		if (iPlotHappiness > 0)
		{
			// Trait boosts this further?
			if (m_pTraits->GetNaturalWonderYieldModifier() > 0)
			{
				iPlotHappiness *= (100 + m_pTraits->GetNaturalWonderYieldModifier());
				iPlotHappiness /= 100;
			}

			iHappiness += iPlotHappiness;
		}
	}
#else
	for(int iI = 0; iI < GC.getMap().numPlots(); iI++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iI);
		if(pPlot == NULL)
		{
			continue;
		}

		if(pPlot->getOwner() != m_eID)
		{
			continue;
		}

		FeatureTypes eFeature = pPlot->getFeatureType();
		if(eFeature == NO_FEATURE)
		{
			continue;
		}

		int iPlotHappiness = GC.getFeatureInfo(eFeature)->getInBorderHappiness();

		if(iPlotHappiness > 0)
		{
			// Trait boosts this further?
			if(m_pTraits->GetNaturalWonderYieldModifier() > 0)
			{
				iPlotHappiness *= (100 + m_pTraits->GetNaturalWonderYieldModifier());
				iPlotHappiness /= 100;
			}

			iHappiness += iPlotHappiness;
		}
	}
#endif
	return iHappiness;
}
#if defined(MOD_BALANCE_CORE)
void CvPlayer::SetNWOwned(FeatureTypes eFeature, bool bValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eFeature >= 0, "eFeature is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFeature < GC.getNumFeatureInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");


	if (m_abNWOwned[eFeature] != bValue)
	{
		m_abNWOwned.setAt(eFeature, bValue);
	}
}
bool CvPlayer::IsNWOwned(FeatureTypes eFeature) const
{
	return m_abNWOwned[eFeature];
}

void CvPlayer::ChangeUnitClassProductionModifier(UnitClassTypes eUnitClass, int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eUnitClass >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eUnitClass < GC.getNumUnitClassInfos(), "eUnitClass expected to be < GC.getNumUnitClassInfos()");
	m_paiUnitClassProductionModifiers.setAt(eUnitClass, m_paiUnitClassProductionModifiers[eUnitClass] + iValue);
}
int CvPlayer::GetUnitClassProductionModifier(UnitClassTypes eUnitClass) const
{
	VALIDATE_OBJECT
		CvAssertMsg(eUnitClass >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eUnitClass < GC.getNumUnitClassInfos(), "eUnitClass expected to be < GC.getNumUnitClassInfos()");
	return m_paiUnitClassProductionModifiers[eUnitClass];
}
#endif
//	--------------------------------------------------------------------------------
/// Extra Happiness from every connected Luxury
int CvPlayer::GetExtraHappinessPerLuxury() const
{
	return m_iExtraHappinessPerLuxury;
}

//	--------------------------------------------------------------------------------
/// Change Extra Happiness from every connected Luxury
void CvPlayer::ChangeExtraHappinessPerLuxury(int iChange)
{
	//antonjs: consider: this check wasn't here before, maybe we shouldn't have it in case mods, scenarios use luxuries in a unique malus way
	//CvAssertMsg(m_iExtraHappinessPerLuxury + iChange >= 0, "Net extra happiness per luxury not expected to be negative!");
	// slewis - Hey Anton, I removed this because it was complaining during my awesome Fall of Rome scenario.
	m_iExtraHappinessPerLuxury += iChange;
}
#if defined(MOD_BALANCE_CORE_HAPPINESS)
//	--------------------------------------------------------------------------------
int CvPlayer::getGlobalAverage(YieldTypes eYield) const
{	
	int iYield = 0;

	if(eYield == YIELD_CULTURE)
	{
		iYield = GC.getGame().GetCultureAverage();
	}
	else if(eYield == YIELD_SCIENCE)
	{
		iYield = GC.getGame().GetScienceAverage();
	}
	else if(eYield == YIELD_PRODUCTION)
	{
		iYield = GC.getGame().GetDefenseAverage();
	}
	else if(eYield == YIELD_GOLD)
	{
		iYield = GC.getGame().GetGoldAverage();
	}

	return iYield;
}
#endif

#if defined(MOD_BALANCE_CORE_HAPPINESS_LUXURY)
//	--------------------------------------------------------------------------------
int CvPlayer::GetPlayerHappinessLuxuryPopulationFactor1000() const
{
	//todo: add traits and policy effects here
	return GC.getBALANCE_HAPPINESS_LUXURY_POP_SCALER();
}

int CvPlayer::GetPlayerHappinessLuxuryCountFactor1000() const
{
	//todo: add traits and policy effects here
	return GC.getBALANCE_HAPPINESS_LUXURY_COUNT_SCALER();
}

int CvPlayer::GetBonusHappinessFromLuxuries() const
{
	int iTotalResourceWeight = 0;
	int iCurrentWeight = 1000;
	for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResource = (ResourceTypes) iResourceLoop;
		if(eResource != NO_RESOURCE && GetHappinessFromLuxury(eResource) > 0)
		{
			iTotalResourceWeight += iCurrentWeight;
			iCurrentWeight = (iCurrentWeight*GetPlayerHappinessLuxuryCountFactor1000()) / 1000; //reduce the weight for each additional luxury
		}
	}

	//scaler is in 1/1000th
	return int(0.5f + iTotalResourceWeight / 1000.f * getAveragePopulation() * GetPlayerHappinessLuxuryPopulationFactor1000() / 1000.f );
}

int CvPlayer::GetBonusHappinessFromLuxuriesGradient() const
{
	int iCurrentWeight = 1000;
	for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResource = (ResourceTypes) iResourceLoop;
		if(eResource != NO_RESOURCE && GetHappinessFromLuxury(eResource) > 0)
		{
			iCurrentWeight = (iCurrentWeight*GetPlayerHappinessLuxuryCountFactor1000()) / 1000; //reduce the weight for each additional luxury
		}
	}

	//scaler is in 1/1000th
	return int(0.5f + iCurrentWeight / 1000.f * getAveragePopulation() * GetPlayerHappinessLuxuryPopulationFactor1000() / 1000.f );
}
#endif

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvPlayer::GetUnhappinessFromWarWeariness() const
{
	int iWarWeariness = GetCulture()->GetWarWeariness();

	if (iWarWeariness <= 0)
		return 0;

	int iTechProgress = (GET_TEAM(getTeam()).GetTeamTechs()->GetNumTechsKnown() * 100) / GC.getNumTechInfos();
	iTechProgress /= 2;

	int iPop = (getTotalPopulation() / 2);

	iWarWeariness *= (iTechProgress + iPop);
	iWarWeariness /= 100;

	//Never more than 5% of pop...
	if (iWarWeariness > (iPop / 5))
	{
		iWarWeariness = (iPop / 5);
	}

	//Always at least one just in case.
	if (iWarWeariness <= 0)
		iWarWeariness = 1;
	
	return iWarWeariness;
}
#endif
//	--------------------------------------------------------------------------------
/// How much happiness credit for having this resource as a luxury?
int CvPlayer::GetHappinessFromLuxury(ResourceTypes eResource) const
{
	if (GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(GetID(), eResource))
		return 0;

	CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);
	if(pkResourceInfo)
	{
		// Only look at Luxuries
		if(pkResourceInfo->getResourceUsage() != RESOURCEUSAGE_LUXURY)
		{
			return 0;
		}

		// Any extras?
		else if(getNumResourceAvailable(eResource, /*bIncludeImport*/ true) > 0)
		{
			return pkResourceInfo->getHappiness();
		}

		else if(GetPlayerTraits()->GetLuxuryHappinessRetention() > 0)
		{
			if(getResourceExport(eResource) > 0)
			{
				return ((pkResourceInfo->getHappiness() * GetPlayerTraits()->GetLuxuryHappinessRetention()) / 100);
			}
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
/// How much Unhappiness are Units producing?
int CvPlayer::GetUnhappinessFromUnits() const
{
	int iUnhappinessFromUnits = m_iUnhappinessFromUnits;

	int iFreeUnitUnhappiness = /*0*/ GC.getFREE_UNIT_HAPPINESS();
	if(iFreeUnitUnhappiness != 0)
	{
#if defined(MOD_API_EXTENSIONS)
		// If unhappy is 2 and free happy is 4, we need to subtract 2
		// If unhappy is 5 and free happy is 4, we need to subtract 4 --> these two make "the min of unhappy and free happy"
		// If unhappy is -2 and free happy is 4, we need to subtract 0 --> this one adds "the previous figure not to be negative"
		iUnhappinessFromUnits -= std::max(0, std::min(iUnhappinessFromUnits, iFreeUnitUnhappiness));
#else
		iUnhappinessFromUnits -= iFreeUnitUnhappiness;
#endif
	}

#if !defined(MOD_API_EXTENSIONS)
	// Can't be less than 0
	if(iUnhappinessFromUnits < 0)
	{
		iUnhappinessFromUnits = 0;
	}
#endif

#if defined(MOD_API_EXTENSIONS)
	if(iUnhappinessFromUnits > 0 && GetUnhappinessFromUnitsMod() != 0)
#else
	if(GetUnhappinessFromUnitsMod() != 0)
#endif
	{
		iUnhappinessFromUnits *= (100 + GetUnhappinessFromUnitsMod());
		iUnhappinessFromUnits /= 100;
	}

	return iUnhappinessFromUnits;
}

//	--------------------------------------------------------------------------------
/// Changes how much Happiness Units produce
void CvPlayer::ChangeUnhappinessFromUnits(int iChange)
{
	m_iUnhappinessFromUnits += iChange;
}

//	--------------------------------------------------------------------------------
/// How much of our Happiness is being used up? (Population + Units)
int CvPlayer::DoUpdateTotalUnhappiness(CvCity* pAssumeCityAnnexed, CvCity* pAssumeCityPuppeted)
{

#if defined(MOD_BALANCE_CORE_HAPPINESS)
	if(isMinorCiv() || isBarbarian())
	{
		return 0;
	}
#endif
	int iUnhappiness = 0;

	// City Count Unhappiness
	iUnhappiness += GetUnhappinessFromCityCount(pAssumeCityAnnexed, pAssumeCityPuppeted);

	// Occupied City Count Unhappiness
	iUnhappiness += GetUnhappinessFromCapturedCityCount(pAssumeCityAnnexed, pAssumeCityPuppeted);

	// City Population Unhappiness
	iUnhappiness += GetUnhappinessFromCityPopulation(pAssumeCityAnnexed, pAssumeCityPuppeted);

	// Occupied City Population Unhappiness
	iUnhappiness += GetUnhappinessFromOccupiedCities(pAssumeCityAnnexed, pAssumeCityPuppeted);

	// Unit Unhappiness (Builders)
	iUnhappiness += GetUnhappinessFromUnits();

	iUnhappiness /= 100;

	iUnhappiness += GetCulture()->GetPublicOpinionUnhappiness();

#if defined(MOD_BALANCE_CORE_HAPPINESS)
	if(MOD_BALANCE_CORE_HAPPINESS && !isMinorCiv() && !isBarbarian())
	{
		iUnhappiness += GetUnhappinessFromWarWeariness();

		//These values should return either a positive number, or zero.
		iUnhappiness += (GetUnhappinessFromCitySpecialists(pAssumeCityAnnexed, pAssumeCityPuppeted) / 100);
		iUnhappiness += getUnhappinessFromCitizenNeeds();
	}
#endif

	// AI gets reduced Unhappiness on higher levels
	if(!isHuman() && !IsAITeammateOfHuman())
	{
		iUnhappiness *= GC.getGame().getHandicapInfo().getAIUnhappinessPercent();
		iUnhappiness /= 100;
	}

	SetUnhappiness(iUnhappiness);
	return iUnhappiness;
}

//	--------------------------------------------------------------------------------
/// Used for providing info to the player
int CvPlayer::GetUnhappinessFromCityForUI(CvCity* pCity) const
{
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	if(MOD_BALANCE_CORE_HAPPINESS && (isMinorCiv() || isBarbarian()))
	{
		return 0;
	}

	if (pCity->IsPuppet() && MOD_BALANCE_CORE_PUPPET_CHANGES)
	{
		if (pCity->IsRazing() || pCity->IsResistance())
			return pCity->getPopulation() / 2;
		else
			return pCity->getPopulation() / max(1, GC.getBALANCE_HAPPINESS_PUPPET_THRESHOLD_MOD());
	}

#endif
	int iNumCitiesUnhappinessTimes100 = 0;
	int iPopulationUnhappinessTimes100 = 0;

	int iPopulation = pCity->getPopulation() * 100;

	// No Unhappiness from Specialist Pop? (Policies, etc.)
	if(isHalfSpecialistUnhappiness())
	{
		int iSpecialistCount = pCity->GetCityCitizens()->GetTotalSpecialistCount() * 100;
		iPopulation -= (iSpecialistCount / 2);
	}

	// Occupied?
	if(pCity->IsOccupied() && !pCity->IsIgnoreCityForHappiness())
	{
#if defined(MOD_BALANCE_CORE_HAPPINESS)
		if(MOD_BALANCE_CORE_HAPPINESS)
		{
			//Workaround for odd LUA.
			if(pCity->IsNoOccupiedUnhappiness())
			{
				iNumCitiesUnhappinessTimes100 += (100 * /*2*/ GC.getUNHAPPINESS_PER_CITY());
				iPopulationUnhappinessTimes100 += (iPopulation* /*1*/ GC.getUNHAPPINESS_PER_POPULATION());

				if(pCity->isCapital() && GetCapitalUnhappinessMod() != 0)
				{
					iPopulationUnhappinessTimes100 *= (100 + GetCapitalUnhappinessMod());
					iPopulationUnhappinessTimes100 /= 100;
				}
				if(pCity->GetLocalUnhappinessMod() != 0)
				{
					iPopulationUnhappinessTimes100 *= (100 + pCity->GetLocalUnhappinessMod());
					iPopulationUnhappinessTimes100 /= 100;
				}

				iPopulationUnhappinessTimes100 *= (100 + GetUnhappinessMod());
				iPopulationUnhappinessTimes100 /= 100;

				iPopulationUnhappinessTimes100 *= 100 + GetPlayerTraits()->GetPopulationUnhappinessModifier();
				iPopulationUnhappinessTimes100 /= 100;

					// Population Handicap mod
				iPopulationUnhappinessTimes100 *= getHandicapInfo().getPopulationUnhappinessMod();
				iPopulationUnhappinessTimes100 /= 100;

				// City Count Player mod
				int iMod = 0;
				iMod += GetCityCountUnhappinessMod();
				iMod += GetPlayerTraits()->GetCityUnhappinessModifier();

				iNumCitiesUnhappinessTimes100 *= (100 + iMod);
				iNumCitiesUnhappinessTimes100 /= 100;

				// City Count Handicap mod
				iNumCitiesUnhappinessTimes100 *= getHandicapInfo().getNumCitiesUnhappinessMod();
				iNumCitiesUnhappinessTimes100 /= 100;

				// City Count Map size mod
				iNumCitiesUnhappinessTimes100 *= GC.getMap().getWorldInfo().getNumCitiesUnhappinessPercent();
				iNumCitiesUnhappinessTimes100 /= 100;

				return iNumCitiesUnhappinessTimes100 + iPopulationUnhappinessTimes100;
			}
		}
#endif
		iNumCitiesUnhappinessTimes100 += (100 * /*5*/ GC.getUNHAPPINESS_PER_CAPTURED_CITY());
		iPopulationUnhappinessTimes100 += int(iPopulation* /*1.34f*/ GC.getUNHAPPINESS_PER_OCCUPIED_POPULATION());

		// Mod (Policies, etc.)
		if(GetOccupiedPopulationUnhappinessMod() != 0)
		{
			iPopulationUnhappinessTimes100 *= (100 + GetOccupiedPopulationUnhappinessMod());
			iPopulationUnhappinessTimes100 /= 100;
		}
	}
	// Normal City
	else
	{
		iNumCitiesUnhappinessTimes100 += (100 * /*2*/ GC.getUNHAPPINESS_PER_CITY());
		iPopulationUnhappinessTimes100 += (iPopulation* /*1*/ GC.getUNHAPPINESS_PER_POPULATION());

		if(pCity->isCapital() && GetCapitalUnhappinessMod() != 0)
		{
			iPopulationUnhappinessTimes100 *= (100 + GetCapitalUnhappinessMod());
			iPopulationUnhappinessTimes100 /= 100;
		}
#if defined(MOD_BALANCE_CORE)
		if(pCity->GetLocalUnhappinessMod() != 0)
		{
			iPopulationUnhappinessTimes100 *= (100 + pCity->GetLocalUnhappinessMod());
			iPopulationUnhappinessTimes100 /= 100;
		}
#endif

		iPopulationUnhappinessTimes100 *= (100 + GetUnhappinessMod());
		iPopulationUnhappinessTimes100 /= 100;

		iPopulationUnhappinessTimes100 *= 100 + GetPlayerTraits()->GetPopulationUnhappinessModifier();
		iPopulationUnhappinessTimes100 /= 100;
	}

	// Population Handicap mod
	iPopulationUnhappinessTimes100 *= getHandicapInfo().getPopulationUnhappinessMod();
	iPopulationUnhappinessTimes100 /= 100;

	// City Count Player mod
	int iMod = 0;
	iMod += GetCityCountUnhappinessMod();
	iMod += GetPlayerTraits()->GetCityUnhappinessModifier();

	iNumCitiesUnhappinessTimes100 *= (100 + iMod);
	iNumCitiesUnhappinessTimes100 /= 100;

	// City Count Handicap mod
	iNumCitiesUnhappinessTimes100 *= getHandicapInfo().getNumCitiesUnhappinessMod();
	iNumCitiesUnhappinessTimes100 /= 100;

	// City Count Map size mod
	iNumCitiesUnhappinessTimes100 *= GC.getMap().getWorldInfo().getNumCitiesUnhappinessPercent();
	iNumCitiesUnhappinessTimes100 /= 100;

	return iNumCitiesUnhappinessTimes100 + iPopulationUnhappinessTimes100;
}

//	--------------------------------------------------------------------------------
/// Unhappiness from number of Cities
int CvPlayer::GetUnhappinessFromCityCount(CvCity* pAssumeCityAnnexed, CvCity* pAssumeCityPuppeted) const
{
	int iUnhappiness = 0;
	int iUnhappinessPerCity = /*2*/ GC.getUNHAPPINESS_PER_CITY() * 100;

	bool bCityValid;

	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		bCityValid = false;

		// Assume city is puppeted, and counts
		if(pLoopCity == pAssumeCityPuppeted)
			bCityValid = true;
		// Assume city is annexed, and does NOT count
		else if(pLoopCity == pAssumeCityAnnexed)
			bCityValid = false;
		// Assume city doesn't exist, and does NOT count
		else if(pLoopCity->IsIgnoreCityForHappiness())
			bCityValid = false;
		// Normal city
		else if(!pLoopCity->IsOccupied() || pLoopCity->IsNoOccupiedUnhappiness())
			bCityValid = true;
#if defined(MOD_BALANCE_CORE_HAPPINESS)
		if(MOD_BALANCE_CORE_HAPPINESS)
		{
			//Tradition policy bonus - Capital grants no founding unhappiness.
			if(pLoopCity->isCapital() && GetCapitalUnhappinessMod() != 0)
			{
				bCityValid = false;
			}
		}
#endif
#if defined(MOD_BALANCE_CORE_POLICIES)
		if(MOD_BALANCE_CORE_POLICIES)
		{
			//Expansion policy bonus - Cities grant no unhappiness from expansion.
			if(IsNoUnhappinessExpansion())
			{
				bCityValid = false;
			}
		}
#endif
		if(bCityValid)
			iUnhappiness += iUnhappinessPerCity;
	}

	// Player count mod
	int iMod = 0;
	iMod += GetCityCountUnhappinessMod();
	iMod += GetPlayerTraits()->GetCityUnhappinessModifier();

	iUnhappiness *= (100 + iMod);
	iUnhappiness /= 100;

	// Handicap mod
	iUnhappiness *= getHandicapInfo().getNumCitiesUnhappinessMod();
	iUnhappiness /= 100;

	// Map size mod
	iUnhappiness *= GC.getMap().getWorldInfo().getNumCitiesUnhappinessPercent();
	iUnhappiness /= 100;

	return iUnhappiness;
}

//	--------------------------------------------------------------------------------
/// Unhappiness from number of Captured Cities
int CvPlayer::GetUnhappinessFromCapturedCityCount(CvCity* pAssumeCityAnnexed, CvCity* pAssumeCityPuppeted) const
{
	int iUnhappiness = 0;
	int iUnhappinessPerCapturedCity = /*5*/ GC.getUNHAPPINESS_PER_CAPTURED_CITY() * 100;

	bool bCityValid;

	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		bCityValid = false;

		// Assume city is puppeted, and does NOT count
		if(pLoopCity == pAssumeCityPuppeted)
			bCityValid = false;
		// Assume city is annexed, and counts
		else if(pLoopCity == pAssumeCityAnnexed)
			bCityValid = true;
		// Assume city doesn't exist, and does NOT count
		else if(pLoopCity->IsIgnoreCityForHappiness())
			bCityValid = false;
		// Occupied city
		else if(pLoopCity->IsOccupied() && !pLoopCity->IsNoOccupiedUnhappiness())
			bCityValid = true;

		// Extra Unhappiness from Occupied Cities
		if(bCityValid)
			iUnhappiness += iUnhappinessPerCapturedCity;
	}

	// Player count mod
	int iMod = 0;
	iMod += GetCityCountUnhappinessMod();
	iMod += GetPlayerTraits()->GetCityUnhappinessModifier();

	iUnhappiness *= (100 + iMod);
	iUnhappiness /= 100;

	// Handicap mod
	iUnhappiness *= getHandicapInfo().getNumCitiesUnhappinessMod();
	iUnhappiness /= 100;

	// Map size mod
	iUnhappiness *= GC.getMap().getWorldInfo().getNumCitiesUnhappinessPercent();
	iUnhappiness /= 100;

	return iUnhappiness;
}

//	--------------------------------------------------------------------------------
/// Unhappiness from City Population
int CvPlayer::GetUnhappinessFromCityPopulation(CvCity* pAssumeCityAnnexed, CvCity* pAssumeCityPuppeted) const
{

#if defined(MOD_BALANCE_CORE_HAPPINESS)
	if(MOD_BALANCE_CORE_HAPPINESS)
	{
		return 0;
	}
#endif
	int iUnhappiness = 0;
	int iUnhappinessFromThisCity;

	int iUnhappinessPerPop = /*1*/ GC.getUNHAPPINESS_PER_POPULATION() * 100;
	int iPopulation;
	int iSpecialistCount;

	bool bCityValid;

	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		bCityValid = false;

		// Assume pLoopCity is Annexed, and does NOT count
		if(pLoopCity == pAssumeCityAnnexed)
			bCityValid = false;
		// Assume that pLoopCity is a Puppet and IS counted here
		else if(pLoopCity == pAssumeCityPuppeted)
			bCityValid = true;
		// Assume city doesn't exist, and does NOT count
		else if(pLoopCity->IsIgnoreCityForHappiness())
			bCityValid = false;
		// Occupied Cities don't get counted here (see the next function)
		else if(!pLoopCity->IsOccupied() || pLoopCity->IsNoOccupiedUnhappiness())
			bCityValid = true;

		if(bCityValid)
		{
			iPopulation = pLoopCity->getPopulation();

			// No Unhappiness from Specialist Pop? (Policies, etc.)
			if(isHalfSpecialistUnhappiness())
			{
				iSpecialistCount = pLoopCity->GetCityCitizens()->GetTotalSpecialistCount();
				iSpecialistCount++; // Round up
				iPopulation -= (iSpecialistCount / 2);
			}

			iUnhappinessFromThisCity = iPopulation * iUnhappinessPerPop;

			if(pLoopCity->isCapital() && GetCapitalUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + GetCapitalUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#if defined(MOD_BALANCE_CORE)
			if(pLoopCity->GetLocalUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + pLoopCity->GetLocalUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#endif

			iUnhappiness += iUnhappinessFromThisCity;
		}
	}

	iUnhappiness *= (100 + GetUnhappinessMod());
	iUnhappiness /= 100;

	iUnhappiness *= 100 + GetPlayerTraits()->GetPopulationUnhappinessModifier();
	iUnhappiness /= 100;

	// Handicap mod
	iUnhappiness *= getHandicapInfo().getPopulationUnhappinessMod();
	iUnhappiness /= 100;

	return iUnhappiness;
}

//	--------------------------------------------------------------------------------
/// Unhappiness from Puppet City Population
int CvPlayer::GetUnhappinessFromPuppetCityPopulation() const
{
	int iLoop = 0;
	if (MOD_BALANCE_CORE_PUPPET_CHANGES)
	{
		int iTotal = 0;
		for (const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if (pLoopCity->IsRazing() || pLoopCity->IsResistance())
				continue;
			if (!pLoopCity->IsPuppet())
				continue;
			else
				iTotal += pLoopCity->getPopulation() / max(1, GC.getBALANCE_HAPPINESS_PUPPET_THRESHOLD_MOD());
		}
		return iTotal;
	}

	int iUnhappiness = 0;
	int iUnhappinessPerPop = GC.getUNHAPPINESS_PER_POPULATION() * 100;	
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		bool bCityValid = false;

		if(pLoopCity->IsPuppet())
			bCityValid = true;

		// Assume city doesn't exist, and does NOT count
		if(pLoopCity->IsIgnoreCityForHappiness())
			bCityValid = false;

		if(bCityValid)
		{
			int iPopulation = pLoopCity->getPopulation();

			// No Unhappiness from Specialist Pop? (Policies, etc.)
			// slewis - 2013.5.7 
			// This function, along with GetUnhappinessFromCitySpecialists, is only called through the UI to reflect 
			// to the player what's going on with their happiness. So I removed the effect that specialists have on 
			// puppeted cities and let the GetUnhappinessFromCitySpecialists correct that problem.

			/*if(isHalfSpecialistUnhappiness())
			{
				int iSpecialistCount = pLoopCity->GetCityCitizens()->GetTotalSpecialistCount();
				iSpecialistCount++; // Round up
				iPopulation -= (iSpecialistCount / 2);
			}*/
			iPopulation -= pLoopCity->GetCityCitizens()->GetTotalSpecialistCount();

			int iUnhappinessFromThisCity = iPopulation * iUnhappinessPerPop;

			if(pLoopCity->isCapital() && GetCapitalUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + GetCapitalUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#if defined(MOD_BALANCE_CORE)
			if(pLoopCity->GetLocalUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + pLoopCity->GetLocalUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#endif

			iUnhappiness += iUnhappinessFromThisCity;
		}
	}

	iUnhappiness *= (100 + GetUnhappinessMod());
	iUnhappiness /= 100;

	iUnhappiness *= 100 + GetPlayerTraits()->GetPopulationUnhappinessModifier();
	iUnhappiness /= 100;

	// Handicap mod
	iUnhappiness *= getHandicapInfo().getPopulationUnhappinessMod();
	iUnhappiness /= 100;

	return iUnhappiness;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetUnhappinessFromCitySpecialists(CvCity* pAssumeCityAnnexed, CvCity* pAssumeCityPuppeted) const
{
	int iUnhappiness = 0;
	int iUnhappinessFromThisCity;
	int iUnhappinessPerPop = /*1*/ GC.getUNHAPPINESS_PER_POPULATION() * 100;
	int iPopulation;

	bool bCityValid;

	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		bCityValid = false;

		// Assume pLoopCity is Annexed, and does NOT count
		if(pLoopCity == pAssumeCityAnnexed)
			bCityValid = false;
		// Assume that pLoopCity is a Puppet and IS counted here
		else if(pLoopCity == pAssumeCityPuppeted)
			bCityValid = true;
		// Assume city doesn't exist, and does NOT count
		else if(pLoopCity->IsIgnoreCityForHappiness())
			bCityValid = false;
		// Occupied Cities don't get counted here (see the next function)
		else if(!pLoopCity->IsOccupied() || pLoopCity->IsNoOccupiedUnhappiness())
			bCityValid = true;

		if (pLoopCity->IsPuppet() && MOD_BALANCE_CORE_PUPPET_CHANGES)
			bCityValid = false;

		if(bCityValid)
		{
			iPopulation = pLoopCity->GetCityCitizens()->GetTotalSpecialistCount();

#if defined(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS)
			//Less unhappiness from specialists....
			if (MOD_BALANCE_CORE_HAPPINESS_MODIFIERS)
			{
				iUnhappinessPerPop = /*25*/ GC.getBALANCE_UNHAPPINESS_PER_SPECIALIST();
				int iNoHappinessSpecialists = 0;
				if (iPopulation > 0)
				{
					//...in capital?
					if (pLoopCity->isCapital())
					{
						iNoHappinessSpecialists += GetNoUnhappfromXSpecialistsCapital();
					}
					//...elsewhere?	
					iNoHappinessSpecialists += GetNoUnhappfromXSpecialists();
				}
				//Can't give more free happiness than specialists.
				if (iNoHappinessSpecialists > iPopulation)
				{
					iNoHappinessSpecialists = iPopulation;
				}
				if (iNoHappinessSpecialists > 0)
				{
					iPopulation -= iNoHappinessSpecialists;
				}
			}
#endif

			// No Unhappiness from Specialist Pop? (Policies, etc.)
			if(isHalfSpecialistUnhappiness())
			{
				iPopulation++; // Round up
				iPopulation /= 2;
			}

			iUnhappinessFromThisCity = iPopulation * iUnhappinessPerPop;

#if defined(MOD_BALANCE_CORE_HAPPINESS)
			if(MOD_BALANCE_CORE_HAPPINESS)
			{
				iUnhappiness += iUnhappinessFromThisCity;
			}
			if(!MOD_BALANCE_CORE_HAPPINESS)
			{
//Took these away as they were making specialists do weird things.
#endif
			if(pLoopCity->isCapital() && GetCapitalUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + GetCapitalUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#if defined(MOD_BALANCE_CORE)
			if(pLoopCity->GetLocalUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + pLoopCity->GetLocalUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#endif

			iUnhappiness += iUnhappinessFromThisCity;
#if defined(MOD_BALANCE_CORE_HAPPINESS)
			}
#endif
		}
	}
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	if(!MOD_BALANCE_CORE_HAPPINESS)
	{
#endif
	iUnhappiness *= (100 + GetUnhappinessMod());
	iUnhappiness /= 100;

	iUnhappiness *= 100 + GetPlayerTraits()->GetPopulationUnhappinessModifier();
	iUnhappiness /= 100;

	// Handicap mod
	iUnhappiness *= getHandicapInfo().getPopulationUnhappinessMod();
	iUnhappiness /= 100;

#if defined(MOD_BALANCE_CORE_HAPPINESS)
	}
#endif
	return iUnhappiness;
}

//	--------------------------------------------------------------------------------
/// Unhappiness from City Population in Occupied Cities
int CvPlayer::GetUnhappinessFromOccupiedCities(CvCity* pAssumeCityAnnexed, CvCity* pAssumeCityPuppeted) const
{
	int iUnhappiness = 0;
	int iUnhappinessFromThisCity;

	double fUnhappinessPerPop = /*1.34f*/ GC.getUNHAPPINESS_PER_OCCUPIED_POPULATION() * 100;
	int iPopulation;
	int iSpecialistCount;

	bool bCityValid;
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	bool bIsResistance;
#endif
	int iLoop;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		bCityValid = false;
#if defined(MOD_BALANCE_CORE_HAPPINESS)
		bIsResistance = false;
#endif
		// Assume pLoopCity is Annexed, and counts
		if(pLoopCity == pAssumeCityAnnexed)
			bCityValid = true;
		// Assume that pLoopCity is a Puppet and does NOT count
		else if(pLoopCity == pAssumeCityPuppeted)
			bCityValid = false;
		// Assume city doesn't exist, and does NOT count
		else if(pLoopCity->IsIgnoreCityForHappiness())
			bCityValid = false;
		// Occupied Cities
		else if(pLoopCity->IsOccupied() && !pLoopCity->IsNoOccupiedUnhappiness())
			bCityValid = true;
#if defined(MOD_BALANCE_CORE_HAPPINESS)
		if(MOD_BALANCE_CORE_HAPPINESS && (pLoopCity->IsResistance() || pLoopCity->IsRazing()))
		{
			bCityValid = true;
			bIsResistance = true;
		}
#endif

		if(bCityValid)
		{
			iPopulation = pLoopCity->getPopulation();
#if defined(MOD_BALANCE_CORE_HAPPINESS)
			if(MOD_BALANCE_CORE_HAPPINESS && bIsResistance)
			{
				iPopulation /= 2;
			}
#endif
			// No Unhappiness from Specialist Pop? (Policies, etc.)
			if(isHalfSpecialistUnhappiness())
			{
				iSpecialistCount = pLoopCity->GetCityCitizens()->GetTotalSpecialistCount();
				iSpecialistCount++; // Round up
				iPopulation -= (iSpecialistCount / 2);
			}

			iUnhappinessFromThisCity = int(double(iPopulation) * fUnhappinessPerPop);

			// Mod (Policies, etc.)
			if(GetOccupiedPopulationUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + GetOccupiedPopulationUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#if defined(MOD_BALANCE_CORE_POLICIES)
			if(MOD_BALANCE_CORE_POLICIES && GetGarrisonsOccupiedUnhapppinessMod() != 0)
			{
				if(pLoopCity->HasGarrison())
				{
					iUnhappinessFromThisCity *= (100 + GetGarrisonsOccupiedUnhapppinessMod());
					iUnhappinessFromThisCity /= 100;
				}
			}
#endif

			iUnhappiness += iUnhappinessFromThisCity;
		}
	}

	// Handicap mod
	iUnhappiness *= getHandicapInfo().getPopulationUnhappinessMod();
	iUnhappiness /= 100;

	return iUnhappiness;
}

//	--------------------------------------------------------------------------------
/// Unhappiness from Units Percent (50 = 50% of normal)
int CvPlayer::GetUnhappinessFromUnitsMod() const
{
	return m_iUnhappinessFromUnitsMod;
}

//	--------------------------------------------------------------------------------
/// Change Unhappiness from Units Percent (50 = 50% of normal)
void CvPlayer::ChangeUnhappinessFromUnitsMod(int iChange)
{
	if(iChange != 0)
	{
		m_iUnhappinessFromUnitsMod += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Unhappiness Mod (-50 = 50% of normal)
int CvPlayer::GetUnhappinessMod() const
{
	return m_iUnhappinessMod;
}

//	--------------------------------------------------------------------------------
/// Change Unhappiness Mod (-50 = 50% of normal)
void CvPlayer::ChangeUnhappinessMod(int iChange)
{
	if(iChange != 0)
	{
		m_iUnhappinessMod += iChange;
	}
}
#if defined(MOD_BALANCE_CORE_HAPPINESS)
int CvPlayer::getUnhappinessFromCitizenNeeds() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			if (pLoopCity->IsPuppet() && MOD_BALANCE_CORE_PUPPET_CHANGES)
				continue;

			iUnhappiness += pLoopCity->getUnhappinessAggregated();
		}
	}
	return iUnhappiness;
}

int CvPlayer::getUnhappinessFromCityCulture() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			if (pLoopCity->IsPuppet() && MOD_BALANCE_CORE_PUPPET_CHANGES)
				continue;

			iUnhappiness += pLoopCity->getUnhappinessFromCulture();
		}
	}
	return iUnhappiness;
}
int CvPlayer::getUnhappinessFromCityScience() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			if (pLoopCity->IsPuppet() && MOD_BALANCE_CORE_PUPPET_CHANGES)
				continue;

			iUnhappiness += pLoopCity->getUnhappinessFromScience();
		}
	}
	return iUnhappiness;
}
int CvPlayer::getUnhappinessFromCityDefense() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			if (pLoopCity->IsPuppet() && MOD_BALANCE_CORE_PUPPET_CHANGES)
				continue;

			iUnhappiness += pLoopCity->getUnhappinessFromDefense();
		}		
	}
	return iUnhappiness;
}
int CvPlayer::getUnhappinessFromCityGold() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			if (pLoopCity->IsPuppet() && MOD_BALANCE_CORE_PUPPET_CHANGES)
				continue;

			iUnhappiness += pLoopCity->getUnhappinessFromGold();
		}
	}
	return iUnhappiness;
}
int CvPlayer::getUnhappinessFromCityConnection() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			if (pLoopCity->IsPuppet() && MOD_BALANCE_CORE_PUPPET_CHANGES)
				continue;

			iUnhappiness += pLoopCity->getUnhappinessFromConnection();
		}
	}
	return iUnhappiness;
}
int CvPlayer::getUnhappinessFromCityPillaged() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			if (pLoopCity->IsPuppet() && MOD_BALANCE_CORE_PUPPET_CHANGES)
				continue;

			iUnhappiness += pLoopCity->getUnhappinessFromPillaged();
		}
	}
	return iUnhappiness;
}
int CvPlayer::getUnhappinessFromCityStarving() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			if (pLoopCity->IsPuppet() && MOD_BALANCE_CORE_PUPPET_CHANGES)
				continue;

			iUnhappiness += pLoopCity->getUnhappinessFromStarving();
		}
	}
	return iUnhappiness;
}
int CvPlayer::getUnhappinessFromCityMinority() const
{
	int iUnhappiness = 0;
	int iLoop = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			if (pLoopCity->IsPuppet() && MOD_BALANCE_CORE_PUPPET_CHANGES)
				continue;

			iUnhappiness += pLoopCity->getUnhappinessFromReligion();
		}
	}
	return iUnhappiness;
}
#endif

//	--------------------------------------------------------------------------------
/// City Count Unhappiness Mod (-50 = 50% of normal)
int CvPlayer::GetCityCountUnhappinessMod() const
{
	return m_iCityCountUnhappinessMod;
}

//	--------------------------------------------------------------------------------
/// Change City Count Unhappiness Mod (-50 = 50% of normal)
void CvPlayer::ChangeCityCountUnhappinessMod(int iChange)
{
	if(iChange != 0)
	{
		m_iCityCountUnhappinessMod += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Occupied Population Unhappiness Mod (-50 = 50% of normal)
int CvPlayer::GetOccupiedPopulationUnhappinessMod() const
{
	return m_iOccupiedPopulationUnhappinessMod;
}

//	--------------------------------------------------------------------------------
/// Occupied Population Count Unhappiness Mod (-50 = 50% of normal)
void CvPlayer::ChangeOccupiedPopulationUnhappinessMod(int iChange)
{
	if(iChange != 0)
	{
		m_iOccupiedPopulationUnhappinessMod += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Unhappiness from Capital Mod (-50 = 50% of normal)
int CvPlayer::GetCapitalUnhappinessMod() const
{
	return m_iCapitalUnhappinessMod;
}

//	--------------------------------------------------------------------------------
/// Change Unhappiness from Capital Mod (-50 = 50% of normal)
void CvPlayer::ChangeCapitalUnhappinessMod(int iChange)
{
	if(iChange != 0)
	{
		m_iCapitalUnhappinessMod += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// How much Happiness are we getting from Units being Garrisoned in Cities?
int CvPlayer::GetHappinessPerGarrisonedUnit() const
{
	return m_iHappinessPerGarrisonedUnitCount;
}

//	--------------------------------------------------------------------------------
/// Set the amount of Happiness we're getting from Units being Garrisoned in Cities
void CvPlayer::SetHappinessPerGarrisonedUnit(int iValue)
{
	m_iHappinessPerGarrisonedUnitCount = iValue;
}

//	--------------------------------------------------------------------------------
/// Change the amount of Happiness we're getting from Units being Garrisoned in Cities
void CvPlayer::ChangeHappinessPerGarrisonedUnit(int iChange)
{
	SetHappinessPerGarrisonedUnit(m_iHappinessPerGarrisonedUnitCount + iChange);
}

//	--------------------------------------------------------------------------------
/// Returns cached amount of Happiness being brought in for having Cities connected via a Route
int CvPlayer::GetHappinessFromTradeRoutes() const
{
	return m_iCityConnectionHappiness;
}

//	--------------------------------------------------------------------------------
/// How much Happiness coming from Trade Routes?
void CvPlayer::DoUpdateCityConnectionHappiness()
{
	int iHappinessPerTradeRoute = GetHappinessPerTradeRoute();

	int iNumCities = 0;
	if(iHappinessPerTradeRoute != 0)
	{
		CvCity* pCapitalCity = getCapitalCity();

		// Must have a capital before we can check if other Cities are connected to it!
		if(pCapitalCity != NULL && getNumCities() > 1)
		{
			CvCity* pLoopCity;

			int iLoop;
			for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				if(pLoopCity != pCapitalCity)
				{
					if(pLoopCity->IsConnectedToCapital())
					{
						iNumCities++;
					}
				}
			}
		}
	}
	m_iCityConnectionHappiness = iHappinessPerTradeRoute * iNumCities / 100;	// Bring it out of hundreds
}

//	--------------------------------------------------------------------------------
/// How muchHappiness are we getting from Trade Routes?
int CvPlayer::GetHappinessPerTradeRoute() const
{
	return m_iHappinessPerTradeRouteCount;
}

//	--------------------------------------------------------------------------------
/// Set the amont of Happiness we're getting from Trade Routes
void CvPlayer::SetHappinessPerTradeRoute(int iValue)
{
	m_iHappinessPerTradeRouteCount = iValue;
}

//	--------------------------------------------------------------------------------
/// Change the amont of Happiness we're getting from Trade Routes
void CvPlayer::ChangeHappinessPerTradeRoute(int iChange)
{
	SetHappinessPerTradeRoute(m_iHappinessPerTradeRouteCount + iChange);
}

//	--------------------------------------------------------------------------------
/// How much Happiness are we getting from large cities?
int CvPlayer::GetHappinessPerXPopulation() const
{
	return m_iHappinessPerXPopulation;
}

//	--------------------------------------------------------------------------------
/// Set the amount of Happiness we're getting from large cities
void CvPlayer::SetHappinessPerXPopulation(int iValue)
{
	m_iHappinessPerXPopulation = iValue;
}

//	--------------------------------------------------------------------------------
/// Change the amount of Happiness we're getting from large cities
void CvPlayer::ChangeHappinessPerXPopulation(int iChange)
{
	SetHappinessPerXPopulation(m_iHappinessPerXPopulation + iChange);
}
#if defined(MOD_BALANCE_CORE_POLICIES)
//	--------------------------------------------------------------------------------
/// How much Happiness are we getting from large empires?
int CvPlayer::GetHappinessPerXPopulationGlobal() const
{
	return m_iHappinessPerXPopulationGlobal;
}

//	--------------------------------------------------------------------------------
/// Set the amount of Happiness we're getting from large empires
void CvPlayer::SetHappinessPerXPopulationGlobal(int iValue)
{
	m_iHappinessPerXPopulationGlobal = iValue;
}

//	--------------------------------------------------------------------------------
/// Change the amount of Happiness we're getting from large empires
void CvPlayer::ChangeHappinessPerXPopulationGlobal(int iChange)
{
	SetHappinessPerXPopulationGlobal(m_iHappinessPerXPopulationGlobal + iChange);
}
/// How much Happiness are we getting from large empires?
int CvPlayer::GetIdeologyPoint() const
{
	return m_iIdeologyPoint;
}

//	--------------------------------------------------------------------------------
/// Set the amount of Happiness we're getting from large empires
void CvPlayer::SetIdeologyPoint(int iValue)
{
	m_iIdeologyPoint = iValue;
}

//	--------------------------------------------------------------------------------

void CvPlayer::ChangeIdeologyPoint(int iChange)
{
	SetIdeologyPoint(m_iIdeologyPoint + iChange);
}



/// How much Happiness are we getting from large empires?
int CvPlayer::GetNoXPLossUnitPurchase() const
{
	return m_iNoXPLossUnitPurchase;
}

//	--------------------------------------------------------------------------------

void CvPlayer::SetNoXPLossUnitPurchase(int iValue)
{
	m_iNoXPLossUnitPurchase = iValue;
}

//	
void CvPlayer::ChangeNoXPLossUnitPurchase(int iChange)
{
	SetNoXPLossUnitPurchase(m_iNoXPLossUnitPurchase + iChange);
}


/// How much Happiness are we getting from large empires?
int CvPlayer::GetCSAlliesLowersPolicyNeedWonders() const
{
	return m_iXCSAlliesLowersPolicyNeedWonders;
}

void CvPlayer::ChangePositiveWarScoreTourismMod(int iChange)
{
	if (iChange != 0)
	{
		m_iPositiveWarScoreTourismMod += iChange;
	}
}
int CvPlayer::GetPositiveWarScoreTourismMod() const
{
	return m_iPositiveWarScoreTourismMod;
}

void CvPlayer::ChangeIsNoCSDecayAtWar(int iValue)
{
	if (iValue != 0)
	{
		m_iIsNoCSDecayAtWar += iValue;
	}
}
bool CvPlayer::IsNoCSDecayAtWar() const
{
	return (m_iIsNoCSDecayAtWar > 0);
}
void CvPlayer::ChangeCanBullyFriendlyCS(int iValue)
{
	if (iValue != 0)
	{
		m_iCanBullyFriendlyCS += iValue;
	}
}
bool CvPlayer::IsCanBullyFriendlyCS() const
{
	return (m_iCanBullyFriendlyCS > 0);
}
void CvPlayer::ChangeBullyGlobalCSReduction(int iValue)
{
	if (iValue != 0)
	{
		m_iBullyGlobalCSReduction += iValue;
	}
}
int CvPlayer::GetBullyGlobalCSReduction() const
{
	return m_iBullyGlobalCSReduction;
}
#endif

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
void CvPlayer::ChangeIsVassalsNoRebel(int iValue)
{
	if (iValue != 0)
	{
		m_iIsVassalsNoRebel += iValue;
	}
}
bool CvPlayer::IsVassalsNoRebel() const
{
	return (m_iIsVassalsNoRebel > 0);
}

void CvPlayer::ChangeVassalCSBonusModifier(int iValue)
{
	if (iValue != 0)
	{
		m_iVassalCSBonusModifier += iValue;
	}
}
int CvPlayer::GetVassalCSBonusModifier() const
{
	return m_iVassalCSBonusModifier;
}
#endif
//	--------------------------------------------------------------------------------
/// Change the amount of Happiness we're getting from large empires
void CvPlayer::ChangeCSAlliesLowersPolicyNeedWonders(int iChange)
{
	if(iChange != 0)
	{
		m_iXCSAlliesLowersPolicyNeedWonders += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Happiness from Minors
int CvPlayer::GetHappinessFromMinorCivs() const
{
	return m_iHappinessFromMinorCivs;
}

void CvPlayer::UpdateHappinessFromMinorCivs()
{
	int iHappiness = 0;
	PlayerTypes eMinor;
	for (int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		eMinor = (PlayerTypes)iMinorLoop;
		iHappiness += GetHappinessFromMinor(eMinor);
	}
	m_iHappinessFromMinorCivs = iHappiness;
}

//	--------------------------------------------------------------------------------
/// Happiness from a Minor
int CvPlayer::GetHappinessFromMinor(PlayerTypes eMinor) const
{
	int iAmount = 0;

	if(GET_PLAYER(eMinor).isAlive())
	{
		// Includes flat bonus and any per luxury bonus
		iAmount += GET_PLAYER(eMinor).GetMinorCivAI()->GetCurrentHappinessBonus(GetID());
	}

	return iAmount;
}

//	--------------------------------------------------------------------------------
/// Happiness from Leagues
int CvPlayer::GetHappinessFromLeagues() const
{
	return m_iHappinessFromLeagues;
}

//	--------------------------------------------------------------------------------
/// Happiness from Leagues
void CvPlayer::SetHappinessFromLeagues(int iValue)
{
	m_iHappinessFromLeagues = iValue;
}

//	--------------------------------------------------------------------------------
/// Happiness from Leagues
void CvPlayer::ChangeHappinessFromLeagues(int iChange)
{
	SetHappinessFromLeagues(GetHappinessFromLeagues() + iChange);
}

//	--------------------------------------------------------------------------------
/// Get the global modifier on the espionage progress rate
int CvPlayer::GetEspionageModifier() const
{
	return m_iEspionageModifier;
}

//	--------------------------------------------------------------------------------
/// Change the global modifier on the espionage progress rate
void CvPlayer::ChangeEspionageModifier(int iChange)
{
	m_iEspionageModifier = (m_iEspionageModifier + iChange);
}

//	--------------------------------------------------------------------------------
/// At what rank do spies start the game at?
int CvPlayer::GetStartingSpyRank() const
{
	if(m_iSpyStartingRank > SPY_RANK_SPECIAL_AGENT)
	{
		return SPY_RANK_SPECIAL_AGENT;
	}
	return m_iSpyStartingRank;
}

//	--------------------------------------------------------------------------------
/// Change the rank that spies start the game at
void CvPlayer::ChangeStartingSpyRank(int iChange)
{
	m_iSpyStartingRank = (m_iSpyStartingRank + iChange);
}

#if defined(MOD_RELIGION_CONVERSION_MODIFIERS)
//	--------------------------------------------------------------------------------
/// Get the global modifier on the conversion progress rate
int CvPlayer::GetConversionModifier() const
{
	return m_iConversionModifier;
}

//	--------------------------------------------------------------------------------
/// Change the global modifier on the conversion progress rate
void CvPlayer::ChangeConversionModifier(int iChange)
{
	m_iConversionModifier = (m_iConversionModifier + iChange);
}
#endif

//	--------------------------------------------------------------------------------
/// Extra league votes
int CvPlayer::GetExtraLeagueVotes() const
{
	return m_iExtraLeagueVotes;
}

#if defined(MOD_DIPLOMACY_CITYSTATES)
//	--------------------------------------------------------------------------------
/// Extra league votes from faith
int CvPlayer::GetFaithToVotes() const
{
	return m_iFaithToVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from faith
void CvPlayer::ChangeFaithToVotes(int iChange)
{
	m_iFaithToVotes = iChange;
	CvAssert(m_iFaithToVotes >= 0);
	if (m_iFaithToVotes < 0)
	{
		m_iFaithToVotes = 0;
	}
}

//	--------------------------------------------------------------------------------
/// Extra league votes from faith
int CvPlayer::TestFaithToVotes(int iChange)
{
	int iFaithVotes = 0;
	int iFollowers = 0;
	int iTotalFaithVotes = 0;
	CvGameReligions* pReligions = GC.getGame().GetGameReligions();

	// Number of Cities Following Religion
	ReligionTypes eFoundedReligion = pReligions->GetFounderBenefitsReligion(GetID());
	if(eFoundedReligion != NO_RELIGION)
	{
		if(iChange > 0)
		{
			iFaithVotes = iChange;
			iFollowers = pReligions->GetNumCitiesFollowing(eFoundedReligion);
			int iMaxVotes = pReligions->GetNumReligionsFounded();
			iTotalFaithVotes = (iFollowers / iFaithVotes);
			//Never fewer than one vote.
			if(iTotalFaithVotes < 1)
			{
				iTotalFaithVotes = 1;
			}
			//No more votes than religions in the game - this should scale votes much better.
			else if(iTotalFaithVotes > iMaxVotes)
			{
				iTotalFaithVotes = iMaxVotes;
			}
		}
	}
	return iTotalFaithVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from conquered capitals
int CvPlayer::GetCapitalsToVotes() const
{
	return m_iCapitalsToVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from conquered capitals
void CvPlayer::ChangeCapitalsToVotes(int iChange)
{
	m_iCapitalsToVotes = iChange;
	CvAssert(m_iCapitalsToVotes >= 0);
	if (m_iCapitalsToVotes < 0)
	{
		m_iCapitalsToVotes = 0;
	}
}

//	--------------------------------------------------------------------------------
/// Extra league votes from conquered capitals
int CvPlayer::TestCapitalsToVotes(int iChange)
{
	int iCapitalVotes = 0;

	if(iChange > 0)
	{
		iCapitalVotes = (GetNumCapitalCities() * iChange);
	}
	return iCapitalVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from DoF
int CvPlayer::GetDoFToVotes() const
{
	return m_iDoFToVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from DoF
void CvPlayer::ChangeDoFToVotes(int iChange)
{
	m_iDoFToVotes = iChange;
	CvAssert(m_iDoFToVotes >= 0);
	if (m_iDoFToVotes < 0)
	{
		m_iDoFToVotes = 0;
	}
}

//	--------------------------------------------------------------------------------
/// Extra league votes from DoF
int CvPlayer::TestDoFToVotes(int iChange)
{
	int iDoFToVotes = 0;
	
	if(iChange > 0)
	{
		iDoFToVotes = ((GetDiplomacyAI()->GetNumDoF() / 2) * iChange);
	}
	
	return iDoFToVotes;

}

//	--------------------------------------------------------------------------------
/// Extra league votes from RA
int CvPlayer::GetRAToVotes() const
{
	return m_iRAToVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from RA
void CvPlayer::ChangeRAToVotes(int iChange)
{
	m_iRAToVotes = iChange;
	CvAssert(m_iRAToVotes >= 0);
	if (m_iRAToVotes < 0)
	{
		m_iRAToVotes = 0;
	}
}

//	--------------------------------------------------------------------------------
/// Extra league votes from RA
int CvPlayer::TestRAToVotes(int iChange)
{
	int iRAToVotes = 0;
	
	if(iChange > 0)
	{
		iRAToVotes = (GetDiplomacyAI()->GetNumRA() * iChange);
	}
	
	return iRAToVotes;
}
//	--------------------------------------------------------------------------------
/// Extra league votes from RA
int CvPlayer::GetDefensePactsToVotes() const
{
	return m_iDefensePactsToVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from RA
void CvPlayer::ChangeDefensePactsToVotes(int iChange)
{
	m_iDefensePactsToVotes = iChange;
	CvAssert(m_iDefensePactsToVotes >= 0);
	if (m_iDefensePactsToVotes < 0)
	{
		m_iDefensePactsToVotes = 0;
	}
}
//	--------------------------------------------------------------------------------
/// Extra league votes from Defense Pacts
int CvPlayer::TestDefensePactsToVotes(int iChange)
{
	int iDefensePactsToVotes = 0;
	
	if(iChange > 0)
	{
		iDefensePactsToVotes = (GetDiplomacyAI()->GetNumDefensePacts() * iChange);
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
		if (MOD_DIPLOMACY_CIV4_FEATURES)
		{
			iDefensePactsToVotes += GET_TEAM(getTeam()).GetNumVassals();
		}
#endif
	}
	
	return iDefensePactsToVotes;
}

//	--------------------------------------------------------------------------------
/// Extra influence from GPs
int CvPlayer::GetGPExpendInfluence() const
{
	return m_iGPExpendInfluence;
}

//	--------------------------------------------------------------------------------
/// Extra influence from GPs
void CvPlayer::ChangeGPExpendInfluence(int iChange)
{
	m_iGPExpendInfluence += iChange;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from embassy
int CvPlayer::GetImprovementLeagueVotes() const
{
	return m_iImprovementLeagueVotes;
}

//	--------------------------------------------------------------------------------
/// Extra league votes from embassy
void CvPlayer::ChangeImprovementLeagueVotes(int iChange)
{
	m_iImprovementLeagueVotes += iChange;
	CvAssert(m_iImprovementLeagueVotes >= 0);
	if (m_iImprovementLeagueVotes < 0)
	{
		m_iImprovementLeagueVotes = 0;
	}
}

/// League Bonuses for Poor Players
void CvPlayer::SetLeagueArt(bool bValue)
{
	if(m_bIsLeagueArt != bValue)
	{
		m_bIsLeagueArt = bValue;
	}
}

bool CvPlayer::IsLeagueArt() const
{
	return m_bIsLeagueArt;
}

/// League Bonuses for Poor Players
void CvPlayer::SetLeagueScholar(bool bValue)
{
	if(m_bIsLeagueScholar != bValue)
	{
		m_bIsLeagueScholar = bValue;
	}
}

bool CvPlayer::IsLeagueScholar() const
{
	return m_bIsLeagueScholar;
}


/// League Bonuses for Poor Players
void CvPlayer::SetLeagueAid(bool bValue)
{
	if(m_bIsLeagueAid != bValue)
	{
		m_bIsLeagueAid = bValue;
	}
}

bool CvPlayer::IsLeagueAid() const
{
	return m_bIsLeagueAid;
}

/// Process League Bonuses for Poor Players
void CvPlayer::ProcessLeagueResolutions()
{
	CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
	if(pLeague == NULL)
	{
		return;
	}
	if(IsLeagueAid())
	{
		if ( pLeague->GetArtsyGreatPersonRateModifier() > 0)
		{
			//Production and Culture
#if defined(MOD_BALANCE_CORE)
			if(AidRankGeneric(1) == GetID()) // calculate only Culture related score
#else
			if(AidRank() == GetID())
#endif
			{
#if defined(MOD_BALANCE_CORE)
				// calculate modifier that is actually related to Resolution's ArtsyGreatPersonRateMod parameter
				int iScoreMod = pLeague->GetArtsyGreatPersonRateModifier() * ScoreDifferencePercent(1) / 100;
#endif
				CvCity* pLoopCity;
				int iLoop;
				int iAid = 0;
				for(pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
				{
#if defined(MOD_BALANCE_CORE)
					int iAid = (iScoreMod - pLoopCity->GetTotalArtsyAid());
#else
					int iAid = (ScoreDifference() - pLoopCity->GetTotalArtsyAid());
#endif
					if(iAid != 0)
					{
						pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_PRODUCTION, iAid);

						pLoopCity->ChangeTotalArtsyAid(iAid);
					}

				}
#if defined(MOD_BALANCE_CORE)
				iAid = iScoreMod - GetLeagueCultureCityModifier();
#else
				iAid = ScoreDifference() - GetLeagueCultureCityModifier();
#endif
				if(iAid != 0)
				{
					ChangeLeagueCultureCityModifier(iAid);
				}
			}
			//Remove bonuses from filty first-worlders.
#if defined(MOD_BALANCE_CORE)
			if(AidRankGeneric(1) != GetID()) // calculate only Culture related score
#else
			if(AidRank() != GetID())
#endif
			{
				CvCity* pLoopCity;
				int iLoop;
				for(pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
				{
					if(pLoopCity->GetTotalArtsyAid() != 0)
					{

						pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_PRODUCTION, pLoopCity->GetTotalArtsyAid() * -1);

						pLoopCity->SetTotalArtsyAid(0);
					}
				}
				if(GetLeagueCultureCityModifier() != 0)
				{
					ChangeLeagueCultureCityModifier(GetLeagueCultureCityModifier() * -1);
				}
			}
		}
		else if (pLeague && pLeague->GetScienceyGreatPersonRateModifier() > 0)
		{
			//Food and Research
#if defined(MOD_BALANCE_CORE)
			if(AidRankGeneric(2) == GetID()) // calculate only Research related score
#else
			if(AidRank() == GetID())
#endif
			{
#if defined(MOD_BALANCE_CORE)
				// calculate modifier that is actually related to Resolution's ScienceyGreatPersonRateMod parameter
				int iScoreMod = pLeague->GetScienceyGreatPersonRateModifier() * ScoreDifferencePercent(2) / 100;
#endif
				CvCity* pLoopCity;
				int iLoop;
				int iAid = 0;
				for(pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
				{
#if defined(MOD_BALANCE_CORE)
					iAid = (iScoreMod - pLoopCity->GetTotalScienceyAid());
#else
					iAid = (ScoreDifference() - pLoopCity->GetTotalScienceyAid());
#endif
					if(iAid != 0)
					{
						pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_FOOD, iAid);

						pLoopCity->ChangeTotalScienceyAid(iAid);
					}
				}
				//Global
#if defined(MOD_BALANCE_CORE)
				iAid = (iScoreMod - GetScienceRateFromLeagueAid());
#else
				iAid = (ScoreDifference() - GetScienceRateFromLeagueAid());
#endif
				if(iAid != 0)
				{
					ChangeScienceRateFromLeagueAid(iAid);
				}
			}
			//Remove bonuses from filty first-worlders.
#if defined(MOD_BALANCE_CORE)
			if(AidRankGeneric(2) != GetID()) // calculate only Research related score
#else
			if(AidRank() != GetID())
#endif
			{
				CvCity* pLoopCity;
				int iLoop;
				for(pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
				{
					if(pLoopCity->GetTotalScienceyAid() != 0)
					{	
						pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_FOOD, (pLoopCity->GetTotalScienceyAid() * -1));

						pLoopCity->SetTotalScienceyAid(0);
					}
				}
				//Global
				if(GetScienceRateFromLeagueAid() != 0)
				{
					ChangeScienceRateFromLeagueAid(GetScienceRateFromLeagueAid() * -1);
				}
			}
		}
	}
	else if(!IsLeagueAid())
	{
		CvCity* pLoopCity;
		int iLoop;
		for(pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
		{
			if(pLoopCity->GetTotalScienceyAid() != 0)
			{	
				pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_FOOD, (pLoopCity->GetTotalScienceyAid() * -1));

				pLoopCity->SetTotalScienceyAid(0);
			}
			if(pLoopCity->GetTotalArtsyAid() != 0)
			{
				pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_PRODUCTION, pLoopCity->GetTotalArtsyAid() * -1);

				pLoopCity->SetTotalArtsyAid(0);
			}
		}
		//Global
		if(GetScienceRateFromLeagueAid() != 0)
		{
			ChangeScienceRateFromLeagueAid(GetScienceRateFromLeagueAid() * -1);
		}
		if(GetLeagueCultureCityModifier() != 0)
		{
			ChangeLeagueCultureCityModifier(GetLeagueCultureCityModifier() * -1);
		}
	}
	if(IsLeagueArt())
	{
		//Extra Science From League (Art)
		if(pLeague->GetWorldWonderYieldChange(YIELD_CULTURE) > 0)
		{
			CvCity* pLoopCity;
			int iLoop;
			for(pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
			{
				int iSciencePerWork = GET_PLAYER(GetID()).GetGreatWorkYieldChange(YIELD_SCIENCE);
				int iTotalScienceFromArt = (pLoopCity->GetCityCulture()->GetNumGreatWorks() * iSciencePerWork);
				int iAid = iTotalScienceFromArt - pLoopCity->GetBaseYieldRateFromLeague(YIELD_SCIENCE);
				if(iAid != 0)
				{
					pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_SCIENCE, iAid);
				}
			}
		}
	}
	else if(!IsLeagueArt())
	{
		CvCity* pLoopCity;
		int iLoop;
		for(pLoopCity = GET_PLAYER(GetID()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iLoop))
		{
			if(pLoopCity->GetBaseYieldRateFromLeague(YIELD_SCIENCE) != 0)
			{
				pLoopCity->ChangeBaseYieldRateFromLeague(YIELD_SCIENCE, (pLoopCity->GetBaseYieldRateFromLeague(YIELD_SCIENCE) * -1));
			}
		}
	}
}
#if defined(MOD_BALANCE_CORE)
//	League Bonuses for Poor Players - modified version of CvPlayer::AidRank()
//	Calculates if the player is below median score depending on type of score
//	eType 0 total score, 1 art, 2 science
PlayerTypes CvPlayer::AidRankGeneric(int eType)
{
	int iRank = 0;
	int iMajorCivs = 0;
	CvWeightedVector<PlayerTypes, MAX_CIV_PLAYERS, true> veMajorRankings;
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		CvPlayer* pMajorLoop = &GET_PLAYER(eLoopPlayer);
	
		if(pMajorLoop->isAlive() && !pMajorLoop->isMinorCiv())
		{
			switch(eType)
			{
			case 1:
				iRank = pMajorLoop->GetScoreFromPolicies() + pMajorLoop->GetScoreFromGreatWorks();
				break;
			case 2:
				iRank = pMajorLoop->GetScoreFromTechs() + pMajorLoop->GetScoreFromFutureTech();
				break;
			default:
				iRank = pMajorLoop->GetScore();
			}
			if(iRank > 0)
			{
				veMajorRankings.push_back(eLoopPlayer, iRank);
				iMajorCivs++;
			}
		}
	}

	//Find the median of the Civs.
	int iTopTier = (iMajorCivs / 2);
	if(iTopTier <= 0)
	{
		iTopTier = 1;
	}

	veMajorRankings.SortItems();
	if(veMajorRankings.size() != 0)
	{
		for(int iRanking = 0; iRanking < veMajorRankings.size(); iRanking++)
		{
			if(veMajorRankings.GetElement(iRanking) == GetID())
			{
				//Are we in the bottom 50% of Civs? If so, we need aid!
				if(iRanking >= iTopTier)
				{
					return GetID();
				}
			}
		}
	}
	return NO_PLAYER;
}
#endif
/// League Bonuses for Poor Players
PlayerTypes CvPlayer::AidRank()
{
#if defined(MOD_BALANCE_CORE)
	return AidRankGeneric();
#else
	int iRank = 0;
	int iMajorCivs = 0;
	CvWeightedVector<PlayerTypes, MAX_CIV_PLAYERS, true> veMajorRankings;
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		CvPlayer* pMajorLoop = &GET_PLAYER(eLoopPlayer);
	
		if(pMajorLoop->isAlive() && !pMajorLoop->isMinorCiv())
		{
			iRank = pMajorLoop->GetScore();

			if(iRank > 0)
			{
				veMajorRankings.push_back(eLoopPlayer, iRank);
				iMajorCivs++;
			}
		}
	}

	//Find the median of the Civs.
	int iTopTier = (iMajorCivs / 2);
	if(iTopTier <= 0)
	{
		iTopTier = 1;
	}

	veMajorRankings.SortItems();
	if(veMajorRankings.size() != 0)
	{
		for(int iRanking = 0; iRanking < veMajorRankings.size(); iRanking++)
		{
			if(veMajorRankings.GetElement(iRanking) == GetID())
			{
				//Are we in the bottom 50% of Civs? If so, we need aid!
				if(iRanking >= iTopTier)
				{
					return GetID();
				}
			}
		}
	}
	return NO_PLAYER;
#endif
}
#if defined(MOD_BALANCE_CORE)
//	League Bonuses for Poor Players - modified version of CvPlayer::ScoreDifference()
//	Calculates difference between player's score and best score using percentage scale
//	0% - best score, 100% - worst score
int CvPlayer::ScoreDifferencePercent(int eType)
{
	int iScore = 0;
	int iBestScore = 0;
	int iWorstScore = INT_MAX;
	int iPlayerScore = 0;
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		CvPlayer* pMajorLoop = &GET_PLAYER(eLoopPlayer);
		if(pMajorLoop->isAlive() && !pMajorLoop->isMinorCiv())
		{
			switch(eType)
			{
			case 1:
				iScore = pMajorLoop->GetScoreFromPolicies() + pMajorLoop->GetScoreFromGreatWorks();
				break;
			case 2:
				iScore = pMajorLoop->GetScoreFromTechs() + pMajorLoop->GetScoreFromFutureTech();
				break;
			default:
				iScore = pMajorLoop->GetScore();
			}
			if(iScore > iBestScore) iBestScore = iScore;
			if(iScore < iWorstScore) iWorstScore = iScore;
			if(GetID() == eLoopPlayer) iPlayerScore = iScore;
		}
	}
	if(iBestScore == 0) return 0; // nothing to scale
	// rescale to 0..100
	return MapToPercent(iPlayerScore, iBestScore, iWorstScore);
}
#endif
/// League Bonuses for Poor Players
int CvPlayer::ScoreDifference()
{
	int iScore = 0;
	int iBestScore = 0;
	int iMajors = 0;
	int iPlayerScore = 0;
	int iDifference = 0;
	PlayerTypes eLoopPlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		eLoopPlayer = (PlayerTypes) iPlayerLoop;
		CvPlayer* pMajorLoop = &GET_PLAYER(eLoopPlayer);

		if(pMajorLoop->isAlive() && !pMajorLoop->isMinorCiv())
		{
			iScore = pMajorLoop->GetScore();
			iMajors++;

			if(iScore > iBestScore)
			{
				iBestScore = iScore;
			}
		}
	}
	if(iBestScore > 0)
	{
		iPlayerScore = GET_PLAYER(GetID()).GetScore();
		iDifference = iBestScore - iPlayerScore;
		int iMax = /*30*/ GC.getLEAGUE_AID_MAX();
		int iMin = /*10*/ (GC.getLEAGUE_AID_MAX() / 3);

		//Bring down to % value.
		iDifference /= 50;
		//Never lower than 10%
		if(iDifference < iMin)
		{
			iDifference = iMin;
		}
		//Never higher than 30%
		if(iDifference > iMax)
		{
			iDifference = iMax;
		}
	}
	return iDifference;
}

//	--------------------------------------------------------------------------------
/// Extra science from CS
int CvPlayer::GetScienceRateFromMinorAllies() const
{
	return m_iScienceRateFromLeague;
}

//	--------------------------------------------------------------------------------
/// Extra science from CS
void CvPlayer::ChangeScienceRateFromMinorAllies(int iChange)
{
	SetScienceRateFromMinorAllies(GetScienceRateFromMinorAllies() + iChange);
}

/// Extra science from CS
void CvPlayer::SetScienceRateFromMinorAllies(int iValue)
{
	if(GetScienceRateFromMinorAllies() != iValue)
		m_iScienceRateFromLeague = iValue;
}

//	--------------------------------------------------------------------------------
/// Extra science from aid
int CvPlayer::GetScienceRateFromLeagueAid() const
{
	return m_iScienceRateFromLeagueAid;
}

//	--------------------------------------------------------------------------------
/// Extra science from aid
void CvPlayer::ChangeScienceRateFromLeagueAid(int iChange)
{
	SetScienceRateFromLeagueAid(GetScienceRateFromLeagueAid() + iChange);
}
//	--------------------------------------------------------------------------------
/// Extra science from aid
void CvPlayer::SetScienceRateFromLeagueAid(int iValue)
{
	if(GetScienceRateFromLeagueAid() != iValue)
		m_iScienceRateFromLeagueAid = iValue;
}
#endif

//	--------------------------------------------------------------------------------
/// Extra league votes
void CvPlayer::ChangeExtraLeagueVotes(int iChange)
{
	m_iExtraLeagueVotes += iChange;
	CvAssert(m_iExtraLeagueVotes >= 0);
	if (m_iExtraLeagueVotes < 0)
	{
		m_iExtraLeagueVotes = 0;
	}
}

//	--------------------------------------------------------------------------------
/// How much weaker do Units get when wounded?
int CvPlayer::GetWoundedUnitDamageMod() const
{
	return m_iWoundedUnitDamageMod;
}

//	--------------------------------------------------------------------------------
/// How much weaker do Units get when wounded?
void CvPlayer::SetWoundedUnitDamageMod(int iValue)
{
	m_iWoundedUnitDamageMod = iValue;

	if(m_iWoundedUnitDamageMod < /*50*/ -GC.getWOUNDED_DAMAGE_MULTIPLIER())
	{
		m_iWoundedUnitDamageMod = /*50*/ -GC.getWOUNDED_DAMAGE_MULTIPLIER();
	}
}

//	--------------------------------------------------------------------------------
/// How much weaker do Units get when wounded?
void CvPlayer::ChangeWoundedUnitDamageMod(int iChange)
{
	SetWoundedUnitDamageMod(m_iWoundedUnitDamageMod + iChange);
}

//	--------------------------------------------------------------------------------
/// Unit upgrade cost mod
int CvPlayer::GetUnitUpgradeCostMod() const
{
	return m_iUnitUpgradeCostMod;
}

//	--------------------------------------------------------------------------------
/// Unit upgrade cost mod
void CvPlayer::SetUnitUpgradeCostMod(int iValue)
{
	m_iUnitUpgradeCostMod = iValue;

	if(m_iUnitUpgradeCostMod < /*-75*/ GC.getUNIT_UPGRADE_COST_DISCOUNT_MAX())
		m_iUnitUpgradeCostMod = /*-75*/ GC.getUNIT_UPGRADE_COST_DISCOUNT_MAX();
}

//	--------------------------------------------------------------------------------
/// Unit upgrade cost mod
void CvPlayer::ChangeUnitUpgradeCostMod(int iChange)
{
	SetUnitUpgradeCostMod(m_iUnitUpgradeCostMod + iChange);
}

//	--------------------------------------------------------------------------------
/// How much of a combat bonus do we get VS Barbarian Units?
int CvPlayer::GetBarbarianCombatBonus() const
{
	return m_iBarbarianCombatBonus;
}

//	--------------------------------------------------------------------------------
/// Sets how much of a combat bonus we get VS Barbarian Units
void CvPlayer::SetBarbarianCombatBonus(int iValue)
{
	m_iBarbarianCombatBonus = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes how much of a combat bonus we get VS Barbarian Units
void CvPlayer::ChangeBarbarianCombatBonus(int iChange)
{
	SetBarbarianCombatBonus(m_iBarbarianCombatBonus + iChange);
}

//	--------------------------------------------------------------------------------
/// Do we always see where Barb Camps appear?
bool CvPlayer::IsAlwaysSeeBarbCamps() const
{
	return m_iAlwaysSeeBarbCampsCount > 0;
}

//	--------------------------------------------------------------------------------
/// Sets if we always see where Barb Camps appear
void CvPlayer::SetAlwaysSeeBarbCampsCount(int iValue)
{
	m_iAlwaysSeeBarbCampsCount = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes if we always see where Barb Camps appear
void CvPlayer::ChangeAlwaysSeeBarbCampsCount(int iChange)
{
	SetAlwaysSeeBarbCampsCount(m_iAlwaysSeeBarbCampsCount + iChange);
}

//	--------------------------------------------------------------------------------
CvPlayerTechs* CvPlayer::GetPlayerTechs() const
{
	return m_pPlayerTechs;
}

//	--------------------------------------------------------------------------------
CvPlayerPolicies* CvPlayer::GetPlayerPolicies() const
{
	return m_pPlayerPolicies;
}

//	--------------------------------------------------------------------------------
CvPlayerTraits* CvPlayer::GetPlayerTraits() const
{
	return m_pTraits;
}

//	--------------------------------------------------------------------------------
CvFlavorManager* CvPlayer::GetFlavorManager() const
{
	return m_pFlavorManager;
}

//	--------------------------------------------------------------------------------
CvTacticalAI* CvPlayer::GetTacticalAI() const
{
	return m_pTacticalAI;
}

//	--------------------------------------------------------------------------------
CvHomelandAI* CvPlayer::GetHomelandAI() const
{
	return m_pHomelandAI;
}

#if defined(MOD_API_EXTENSIONS)
bool CvPlayer::grantPolicy(PolicyTypes iPolicy, bool bFree)
{
	if (!HasPolicy(iPolicy)) {
		setHasPolicy(iPolicy, true, bFree);
		
		return true;
	}
	
	return false;
}

bool CvPlayer::revokePolicy(PolicyTypes iPolicy)
{
	if (HasPolicy(iPolicy)) {
		setHasPolicy(iPolicy, false, m_pPlayerPolicies->IsFreePolicy(iPolicy));
		
		return true;
	}
	
	return false;
}

bool CvPlayer::swapPolicy(PolicyTypes iNewPolicy, PolicyTypes iOldPolicy)
{
	bool bWasFree = m_pPlayerPolicies->IsFreePolicy(iOldPolicy);
	
	if (!HasPolicy(iNewPolicy) && revokePolicy(iOldPolicy)) {
		return grantPolicy(iNewPolicy, bWasFree);
	}
	
	return false;
}
#endif

//	--------------------------------------------------------------------------------
#if defined(MOD_API_EXTENSIONS)
void CvPlayer::setHasPolicy(PolicyTypes eIndex, bool bNewValue, bool bFree)
#else
void CvPlayer::setHasPolicy(PolicyTypes eIndex, bool bNewValue)
#endif
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumPolicyInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	
	if(m_pPlayerPolicies->HasPolicy(eIndex) != bNewValue)
	{
#if defined(MOD_API_EXTENSIONS)
		m_pPlayerPolicies->SetPolicy(eIndex, bNewValue, bFree);
#else
		m_pPlayerPolicies->SetPolicy(eIndex, bNewValue);
#endif
		processPolicies(eIndex, bNewValue ? 1 : -1);
#if defined(MOD_BALANCE_CORE)
		GetPlayerPolicies()->ClearCache();
#endif
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNextPolicyCost() const
{
	return m_iCostNextPolicy;
}

//	--------------------------------------------------------------------------------
void CvPlayer::DoUpdateNextPolicyCost()
{
	m_iCostNextPolicy = GetPlayerPolicies()->GetNextPolicyCost();
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canAdoptPolicy(PolicyTypes eIndex) const
{
	return GetPlayerPolicies()->CanAdoptPolicy(eIndex);
}

//	--------------------------------------------------------------------------------
void CvPlayer::doAdoptPolicy(PolicyTypes ePolicy)
{
	CvPolicyEntry* pkPolicyInfo = GC.getPolicyInfo(ePolicy);
	CvAssert(pkPolicyInfo != NULL);
	if(pkPolicyInfo == NULL)
		return;

	// Can we actually adopt this?
	if(!canAdoptPolicy(ePolicy))
		return;

	bool bTenet = pkPolicyInfo->GetLevel() > 0;

	// Pay Culture cost - if applicable
	if (bTenet && GetNumFreeTenets() > 0)
	{
		ChangeNumFreeTenets(-1, false);
	}
	else if (GetNumFreePolicies() > 0)
	{
		ChangeNumFreePolicies(-1);
	}
	else
	{
		changeJONSCulture(-getNextPolicyCost());
	}

	setHasPolicy(ePolicy, true);

	// Update cost if trying to buy another policy this turn
	DoUpdateNextPolicyCost();

	// Branch unlocked
	PolicyBranchTypes ePolicyBranch = (PolicyBranchTypes) pkPolicyInfo->GetPolicyBranchType();
	GetPlayerPolicies()->SetPolicyBranchUnlocked(ePolicyBranch, true, false);

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	// This Dirty bit must only be set when changing something for the active player
	if(GC.getGame().getActivePlayer() == GetID())
	{
		GC.GetEngineUserInterface()->setDirty(Policies_DIRTY_BIT, true);
	}
#if defined(MOD_BALANCE_CORE)
	CvCity* pCapital = getCapitalCity();
	int iPolicyGEorGM = GetPlayerTraits()->GetPolicyGEorGM();
	if (iPolicyGEorGM > 0 && pCapital != NULL)
	{
		doPolicyGEorGM(iPolicyGEorGM);
	}
	int iLoop;
	doInstantYield(INSTANT_YIELD_TYPE_POLICY_UNLOCK, false, NO_GREATPERSON, NO_BUILDING, 0, false);
	doInstantGreatPersonProgress(INSTANT_YIELD_TYPE_POLICY_UNLOCK);

	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) 
	{
		pLoopCity->GetCityCitizens()->SetDirty(true);
	}
#endif

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(ePolicy);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		LuaSupport::CallHook(pkScriptSystem, "PlayerAdoptPolicy", args.get(), bResult);
	}

	updateYield();		// Policies can change the yield
}

//	--------------------------------------------------------------------------------
/// Empire in Anarchy?
bool CvPlayer::IsAnarchy() const
{
	return GetAnarchyNumTurns() > 0;
}

//	--------------------------------------------------------------------------------
/// Empire in Anarchy?
int CvPlayer::GetAnarchyNumTurns() const
{
	return m_iAnarchyNumTurns;
}

//	--------------------------------------------------------------------------------
/// Empire in Anarchy?
void CvPlayer::SetAnarchyNumTurns(int iValue)
{
	if(iValue != GetAnarchyNumTurns())
	{
		m_iAnarchyNumTurns = iValue;

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Empire in Anarchy?
void CvPlayer::ChangeAnarchyNumTurns(int iChange)
{
	SetAnarchyNumTurns(GetAnarchyNumTurns() + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getAdvancedStartPoints() const
{
	return m_iAdvancedStartPoints;
}

//	--------------------------------------------------------------------------------
void CvPlayer::setAdvancedStartPoints(int iNewValue)
{
	if(getAdvancedStartPoints() != iNewValue)
	{
		m_iAdvancedStartPoints = iNewValue;

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(MiscButtons_DIRTY_BIT, true);
			GC.GetEngineUserInterface()->setDirty(SelectionButtons_DIRTY_BIT, true);
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeAdvancedStartPoints(int iChange)
{
	setAdvancedStartPoints(getAdvancedStartPoints() + iChange);
}


//	--------------------------------------------------------------------------------
// Get Attack Bonus for a certain period of time
int CvPlayer::GetAttackBonusTurns() const
{
	return m_iAttackBonusTurns;
}

//	--------------------------------------------------------------------------------
// Set Attack Bonus for a certain period of time
void CvPlayer::ChangeAttackBonusTurns(int iChange)
{
	if(iChange != 0)
	{
		m_iAttackBonusTurns += iChange;
	}
}

//	--------------------------------------------------------------------------------
// Get Culture Bonus for a certain period of time
int CvPlayer::GetCultureBonusTurns() const
{
	return m_iCultureBonusTurns;
}

//	--------------------------------------------------------------------------------
// Set Culture Bonus for a certain period of time
void CvPlayer::ChangeCultureBonusTurns(int iChange)
{
	if (iChange != 0)
	{
		m_iCultureBonusTurns += iChange;
	}
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
// Get Culture Bonus for a certain period of time
int CvPlayer::GetCultureBonusTurnsConquest() const
{
	return m_iCultureBonusTurnsConquest;
}

//	--------------------------------------------------------------------------------
// Set Culture Bonus for a certain period of time
void CvPlayer::ChangeCultureBonusTurnsConquest(int iChange)
{
	if (iChange != 0)
	{
		m_iCultureBonusTurnsConquest += iChange;
	}
}

//	--------------------------------------------------------------------------------
// Get Culture Bonus for a certain period of time
int CvPlayer::GetProductionBonusTurnsConquest() const
{
	return m_iProductionBonusTurnsConquest;
}

//	--------------------------------------------------------------------------------
// Set Culture Bonus for a certain period of time
void CvPlayer::ChangeProductionBonusTurnsConquest(int iChange)
{
	if (iChange != 0)
	{
		m_iProductionBonusTurnsConquest += iChange;
	}
}
#endif
//	--------------------------------------------------------------------------------
// Get Tourism Bonus for a certain period of time
int CvPlayer::GetTourismBonusTurns() const
{
	return m_iTourismBonusTurns;
}

//	--------------------------------------------------------------------------------
// Set Tourism Bonus for a certain period of time
void CvPlayer::ChangeTourismBonusTurns(int iChange)
{
	if (iChange != 0)
	{
		m_iTourismBonusTurns += iChange;
	}
}

#if defined(MOD_DIPLOMACY_CITYSTATES)
//	--------------------------------------------------------------------------------
void CvPlayer::DoProcessVotes()
{
	if(GC.getGame().isOption(GAMEOPTION_NO_LEAGUES))
	{
		return;
	}
	ChangeFaithToVotes(0);
	ChangeCapitalsToVotes(0);
	ChangeDoFToVotes(0);
	ChangeRAToVotes(0);
	ChangeDefensePactsToVotes(0);

	// Minors and Barbs don't matter
	if(!isMinorCiv() && !isBarbarian())
	{
		// Loop through Cities
		int iLoop;
		CvCity* pLoopCity;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
			{
				const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
				CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
			
				// Has this Building
				if(pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
				{
					if(pkBuildingInfo->GetFaithToVotes() > 0)
					{
						int iTestFaith = TestFaithToVotes(pkBuildingInfo->GetFaithToVotes());
						ChangeFaithToVotes(iTestFaith);
					}
					if(pkBuildingInfo->GetCapitalsToVotes() > 0)
					{
						int iTestCapital = TestCapitalsToVotes(pkBuildingInfo->GetCapitalsToVotes());
						ChangeCapitalsToVotes(iTestCapital);	
					}
					if(pkBuildingInfo->GetDoFToVotes() > 0)
					{
						int iTestDoF = TestDoFToVotes(pkBuildingInfo->GetDoFToVotes());
						ChangeDoFToVotes(iTestDoF);
					}
					if(pkBuildingInfo->GetRAToVotes() > 0)
					{
						int iTestRA = TestRAToVotes(pkBuildingInfo->GetRAToVotes());
						ChangeRAToVotes(iTestRA);
					}
					if(pkBuildingInfo->GetDPToVotes() > 0)
					{
						int iTestDP = TestDefensePactsToVotes(pkBuildingInfo->GetDPToVotes());
						ChangeDefensePactsToVotes(iTestDP);
					}
				}
			}
		}
	}
}
#endif
#if defined(MOD_BALANCE_CORE_YIELDS)
void CvPlayer::DoChangeGreatGeneralRate()
{
	//Check for buildings and beliefs that add Great General points.
	int iLoop;
	int iGreatGeneralPoints = 0;

	UnitClassTypes eUnitClassGeneral = (UnitClassTypes)GC.getInfoTypeForString("UNITCLASS_GREAT_GENERAL");
	GreatPersonTypes eGreatPerson = GetGreatPersonFromUnitClass(eUnitClassGeneral);
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			iGreatGeneralPoints += pLoopCity->getYieldRate(YIELD_GREAT_GENERAL_POINTS, false);

			const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(pLoopCity->GetCityReligions()->GetReligiousMajority(), pLoopCity->getOwner());
			if(pReligion)
			{
				int iReligionYieldChange = pReligion->m_Beliefs.GetCityYieldChange(pLoopCity->getPopulation(), YIELD_GREAT_GENERAL_POINTS, GetID(), pLoopCity);
				if(iReligionYieldChange > 0)
				{
					iGreatGeneralPoints += iReligionYieldChange;
				}
				BeliefTypes eSecondaryPantheon = pLoopCity->GetCityReligions()->GetSecondaryReligionPantheonBelief();
				if (eSecondaryPantheon != NO_BELIEF && pLoopCity->getPopulation() >= GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetMinPopulation())
				{
					iReligionYieldChange = GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetCityYieldChange(YIELD_GREAT_GENERAL_POINTS);
					if(iReligionYieldChange > 0)
					{
						iGreatGeneralPoints += iReligionYieldChange;
					}
				}
				if (eGreatPerson != NO_GREATPERSON)
				{
					iGreatGeneralPoints += pReligion->m_Beliefs.GetGreatPersonPoints(eGreatPerson, pLoopCity->getOwner(), pLoopCity, true);
				}
			}
		}
	}
	//Check for policies that add Great General points.
	for(int iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)
	{
		PolicyTypes pPolicy = (PolicyTypes)iPolicyLoop;
		CvPolicyEntry* pkPolicyInfo = GC.getPolicyInfo(pPolicy);
		if(pkPolicyInfo)
		{
			if(GetPlayerPolicies()->HasPolicy(pPolicy) && !GetPlayerPolicies()->IsPolicyBlocked(pPolicy))
			{
				if(pkPolicyInfo->GetCityYieldChange(YIELD_GREAT_GENERAL_POINTS) > 0)
				{
					for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if(pLoopCity != NULL)
						{
							iGreatGeneralPoints += pkPolicyInfo->GetCityYieldChange(YIELD_GREAT_GENERAL_POINTS);
						}
					}
				}
			}
		}
	}
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
#if defined(MOD_UNITS_XP_TIMES_100)
	changeCombatExperienceTimes100(iGreatGeneralPoints * 100);
#else
	changeCombatExperience(iGreatGeneralPoints);
#endif
#else
#if defined(MOD_UNITS_XP_TIMES_100)
	changeCombatExperienceTimes100(iGreatGeneralPoints * 100);
#else
	changeCombatExperience(iGreatGeneralPoints);
#endif
#endif
}
void CvPlayer::DoChangeGreatAdmiralRate()
{
	//Check for buildings and beliefs that add Great General points.
	int iLoop;
	int iGreatAdmiralPoints = 0;

	UnitClassTypes eUnitClassAdmiral = (UnitClassTypes)GC.getInfoTypeForString("UNITCLASS_GREAT_ADMIRAL");
	GreatPersonTypes eGreatPerson = GetGreatPersonFromUnitClass(eUnitClassAdmiral);

	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			iGreatAdmiralPoints += pLoopCity->getYieldRate(YIELD_GREAT_ADMIRAL_POINTS, false);
			
			const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(pLoopCity->GetCityReligions()->GetReligiousMajority(), pLoopCity->getOwner());
			if(pReligion)
			{
				int iReligionYieldChange = pReligion->m_Beliefs.GetCityYieldChange(pLoopCity->getPopulation(), YIELD_GREAT_ADMIRAL_POINTS, GetID(), pLoopCity);
				if(iReligionYieldChange > 0)
				{
					iGreatAdmiralPoints += iReligionYieldChange;
				}
				BeliefTypes eSecondaryPantheon = pLoopCity->GetCityReligions()->GetSecondaryReligionPantheonBelief();
				if (eSecondaryPantheon != NO_BELIEF && pLoopCity->getPopulation() >= GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetMinPopulation())
				{
					iReligionYieldChange = GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetCityYieldChange(YIELD_GREAT_ADMIRAL_POINTS);
					if(iReligionYieldChange > 0)
					{
						iGreatAdmiralPoints += iReligionYieldChange;
					}
				}

				if (eGreatPerson != NO_GREATPERSON)
				{
					iGreatAdmiralPoints += pReligion->m_Beliefs.GetGreatPersonPoints(eGreatPerson, pLoopCity->getOwner(), pLoopCity, true);
				}
			}
		}
	}
	//Check for policies that add Great General points.
	for(int iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)
	{
		PolicyTypes pPolicy = (PolicyTypes)iPolicyLoop;
		CvPolicyEntry* pkPolicyInfo = GC.getPolicyInfo(pPolicy);
		if(pkPolicyInfo)
		{
			if(GetPlayerPolicies()->HasPolicy(pPolicy) && !GetPlayerPolicies()->IsPolicyBlocked(pPolicy))
			{
				if(pkPolicyInfo->GetCityYieldChange(YIELD_GREAT_GENERAL_POINTS) > 0)
				{
					for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if(pLoopCity != NULL)
						{
							iGreatAdmiralPoints += pkPolicyInfo->GetCityYieldChange(YIELD_GREAT_ADMIRAL_POINTS);
						}
					}
				}
			}
		}
	}
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
#if defined(MOD_UNITS_XP_TIMES_100)
	changeNavalCombatExperienceTimes100(iGreatAdmiralPoints * 100);
#else
	changeNavalCombatExperience(iGreatAdmiralPoints);
#endif
#else
#if defined(MOD_UNITS_XP_TIMES_100)
	changeNavalCombatExperienceTimes100(iGreatAdmiralPoints * 100);
#else
	changeNavalCombatExperience(iGreatAdmiralPoints);
#endif
#endif
}
#endif
//	--------------------------------------------------------------------------------
/// Update all Golden-Age related stuff
void CvPlayer::DoProcessGoldenAge()
{
	if(GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS))
	{
		return;
	}

	// Minors and Barbs can't get GAs
	if(!isMinorCiv() && !isBarbarian())
	{
		// Already in a GA - don't decrement counter while in Anarchy
		if(getGoldenAgeTurns() > 0)
		{
			if(!IsAnarchy())
			{
				changeGoldenAgeTurns(-1);
			}
		}
#if defined(MOD_BALANCE_CORE)
		if (MOD_BALANCE_CORE_HAPPINESS_NATIONAL || getGoldenAgeTurns() <= 0)
#else
		// Not in GA
		else
		{
#endif
			// Note: This will actually REDUCE the GA meter if the player is running in the red
			ChangeGoldenAgeProgressMeter(GetExcessHappiness());
			
#if defined(MOD_API_UNIFIED_YIELDS_GOLDEN_AGE)
			ChangeGoldenAgeProgressMeter(GetGoldenAgePointsFromEmpire());
#endif
#if defined(MOD_BALANCE_CORE)
			if(getGoldenAgeTurns() <= 0)
			{
#endif
			// Enough GA Progress to trigger new GA?
			if(GetGoldenAgeProgressMeter() >= GetGoldenAgeProgressThreshold())
			{
				int iOverflow = GetGoldenAgeProgressMeter() - GetGoldenAgeProgressThreshold();
#if defined(MOD_BALANCE_CORE)
				int iValue = GetGoldenAgeProgressMeter();
#endif
				SetGoldenAgeProgressMeter(iOverflow);
				
				int iLength = getGoldenAgeLength();
#if defined(MOD_BALANCE_CORE)
				changeGoldenAgeTurns(iLength, iValue);
#else
				changeGoldenAgeTurns(iLength);
#endif

				// If it's the active player then show the popup
				if(GetID() == GC.getGame().getActivePlayer())
				{
					// Don't show in MP
					if(!GC.getGame().isNetworkMultiPlayer())	// KWG: Candidate for !GC.getGame().isOption(GAMEOPTION_SIMULTANEOUS_TURNS)
					{
						CvPopupInfo kPopupInfo(BUTTONPOPUP_GOLDEN_AGE_REWARD);
						GC.GetEngineUserInterface()->AddPopup(kPopupInfo);
					}
				}
			}
#if defined(MOD_BALANCE_CORE)
			}
#endif
#if !defined(MOD_BALANCE_CORE)
		}
#endif
	}
}
#if defined(MOD_BALANCE_CORE)
int CvPlayer::GetGoldenAgePointsFromEmpire()
{
	int iGAPoints = 0;
	// GA points from religion
	iGAPoints += GetYieldPerTurnFromReligion(YIELD_GOLDEN_AGE_POINTS);

	// Trait bonus which adds GA points for trade partners? 
	iGAPoints +=  GetYieldPerTurnFromTraits(YIELD_GOLDEN_AGE_POINTS);

	iGAPoints += GetGoldenAgePointsFromCities();

	if (MOD_BALANCE_CORE_JFD)
	{
		iGAPoints += GetYieldPerTurnFromMinors(YIELD_GOLDEN_AGE_POINTS);
	}

	return iGAPoints;
}

int CvPlayer::GetGoldenAgePointsFromCities()
{
	int iGAPoints = 0;
	// Add in all the GA points from city yields
	CvCity* pLoopCity;
	int iLoop;
	int iYield = 0;
	int iCityYield = 0;
	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iGAPoints += pLoopCity->getYieldRate(YIELD_GOLDEN_AGE_POINTS, false);
		if (GetPlayerTraits()->GetTourismToGAP() > 0)
		{
			iCityYield += pLoopCity->GetBaseTourism();
		}
	}

	iCityYield /= 100;
	iYield += iCityYield;
	if (GetPlayerTraits()->GetGoldToGAP() > 0)
	{
		iYield += GetTreasury()->CalculateBaseNetGold();
	}
	iYield *= (GetPlayerTraits()->GetTourismToGAP() + GetPlayerTraits()->GetGoldToGAP());
	iYield /= 100;
	if (iYield > 0)
	{
		iGAPoints += iYield;
	}
	
	return iGAPoints;
}
#endif
//	--------------------------------------------------------------------------------
/// How much do we need in the GA meter to trigger the next one?
int CvPlayer::GetGoldenAgeProgressThreshold() const
{
	int iThreshold = /*500*/ GC.getGOLDEN_AGE_BASE_THRESHOLD_HAPPINESS();
	iThreshold += GetNumGoldenAges() * /*500*/ GC.getGOLDEN_AGE_EACH_GA_ADDITIONAL_HAPPINESS();

	// Increase cost based on the # of cities in the empire
	int iCostExtra = int(iThreshold * (getNumCities() - 1) * /*0.02*/ GC.getGOLDEN_AGE_THRESHOLD_CITY_MULTIPLIER());
	iThreshold += iCostExtra;

	if(GetGoldenAgeMeterMod() != 0)
	{
		iThreshold *= (100 + GetGoldenAgeMeterMod());
		iThreshold /= 100;
	}

	// Game Speed Mod
	iThreshold *= GC.getGame().getGameSpeedInfo().getGreatPeoplePercent();
	iThreshold /= 100;

	// Make the number nice to look at
	int iVisibleDivisor = /*5*/ GC.getGOLDEN_AGE_VISIBLE_THRESHOLD_DIVISOR();
	iThreshold /= iVisibleDivisor;
	iThreshold *= iVisibleDivisor;

	return iThreshold;
}

//	--------------------------------------------------------------------------------
/// What is our progress towards the next GA?
int CvPlayer::GetGoldenAgeProgressMeter() const
{
	return m_iGoldenAgeProgressMeter;
}

//	--------------------------------------------------------------------------------
/// Sets what is our progress towards the next GA
void CvPlayer::SetGoldenAgeProgressMeter(int iValue)
{
	m_iGoldenAgeProgressMeter = iValue;

	if(m_iGoldenAgeProgressMeter < 0)
	{
		m_iGoldenAgeProgressMeter = 0;
	}

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
}

//	--------------------------------------------------------------------------------
/// Changes what is our progress towards the next GA
void CvPlayer::ChangeGoldenAgeProgressMeter(int iChange)
{
	if (MOD_BALANCE_NO_GAP_DURING_GA && isGoldenAge())
	{
		return;
	}
	SetGoldenAgeProgressMeter(GetGoldenAgeProgressMeter() + iChange);

}

//	--------------------------------------------------------------------------------
/// Modifier for how big the GA meter is (-50 = 50% of normal)
int CvPlayer::GetGoldenAgeMeterMod() const
{
	return m_iGoldenAgeMeterMod;
}

//	--------------------------------------------------------------------------------
/// Sets Modifier for how big the GA meter is (-50 = 50% of normal)
void CvPlayer::SetGoldenAgeMeterMod(int iValue)
{
	m_iGoldenAgeMeterMod = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes Modifier for how big the GA meter is (-50 = 50% of normal)
void CvPlayer::ChangeGoldenAgeMeterMod(int iChange)
{
	SetGoldenAgeMeterMod(GetGoldenAgeMeterMod() + iChange);
}

//	--------------------------------------------------------------------------------
/// How many GAs have we had in this game?
int CvPlayer::GetNumGoldenAges() const
{
	return m_iNumGoldenAges;
}

//	--------------------------------------------------------------------------------
/// Sets how many GAs have we had in this game
void CvPlayer::SetNumGoldenAges(int iValue)
{
	m_iNumGoldenAges = iValue;

#if !defined(NO_ACHIEVEMENTS)
	if(iValue > 0 && isHuman() && !GC.getGame().isGameMultiPlayer()&& GET_PLAYER(GC.getGame().getActivePlayer()).isLocalPlayer())
	{
		gDLL->UnlockAchievement(ACHIEVEMENT_GOLDEN_AGE);

		const char* strLeader = getLeaderTypeKey();
		if(m_iNumGoldenAges >=5 && NULL != strLeader && strcmp(strLeader, "LEADER_DARIUS") == 0)
		{
			gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_ARCHAEMENNID);
		}
	}
#endif
}

//	--------------------------------------------------------------------------------
/// Changes how many GAs have we had in this game
void CvPlayer::ChangeNumGoldenAges(int iChange)
{
	SetNumGoldenAges(GetNumGoldenAges() + iChange);
}

//	--------------------------------------------------------------------------------
/// How many turns left in GA? (0 if not in GA)
int CvPlayer::getGoldenAgeTurns() const
{
	return m_iGoldenAgeTurns;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isGoldenAge() const
{
	return (getGoldenAgeTurns() > 0);
}

//	--------------------------------------------------------------------------------
#if defined(MOD_BALANCE_CORE)
void CvPlayer::changeGoldenAgeTurns(int iChange, int iValue, bool bFree)
#else
void CvPlayer::changeGoldenAgeTurns(int iChange)
#endif
{
	Localization::String locString;
	Localization::String locSummaryString;

	bool bOldGoldenAge;

	if(iChange != 0)
	{
		bOldGoldenAge = isGoldenAge();

		m_iGoldenAgeTurns = (m_iGoldenAgeTurns + iChange);
		CvAssert(getGoldenAgeTurns() >= 0);

		if(bOldGoldenAge != isGoldenAge())
		{
			GC.getMap().updateYield();	// Do the entire map, so that any potential golden age bonus is reflected in the yield icons.

			if(isGoldenAge())
			{
				if (!bFree)
				{
					ChangeNumGoldenAges(1);
				}
			}
			else
			{
				gDLL->GameplayGoldenAgeEnded();

#if defined(MOD_EVENTS_GOLDEN_AGE)
				if (MOD_EVENTS_GOLDEN_AGE) {
					GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerGoldenAge, GetID(), false, 0);
				}
#endif
#if defined(MOD_BALANCE_CORE)
				CvCity* pLoopCity;
				int iLoop;
				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if(pLoopCity != NULL)
					{
						pLoopCity->GetCityCulture()->CalculateBaseTourismBeforeModifiers();
						pLoopCity->GetCityCulture()->CalculateBaseTourism();
					}
				}
				ChangeGarrisonedCityRangeStrikeModifier(GetPlayerTraits()->GetGoldenAgeGarrisonedCityRangeStrikeModifier() * -1);
#endif
			}

			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				NotificationTypes eNotification = NO_NOTIFICATION_TYPE;

				if(isGoldenAge())
				{
					eNotification = NOTIFICATION_GOLDEN_AGE_BEGUN_ACTIVE_PLAYER;
					locString = Localization::Lookup("TXT_KEY_NOTIFICATION_GOLDEN_AGE_BEGUN_ACTIVE_PLAYER");
					locSummaryString = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_GOLDEN_AGE_BEGUN_ACTIVE_PLAYER");
				}
				else
				{
					eNotification = NOTIFICATION_GOLDEN_AGE_ENDED_ACTIVE_PLAYER;
					locString = Localization::Lookup("TXT_KEY_NOTIFICATION_GOLDEN_AGE_ENDED_ACTIVE_PLAYER");
					locSummaryString = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_GOLDEN_AGE_ENDED_ACTIVE_PLAYER");
				}

				pNotifications->Add(eNotification, locString.toUTF8(), locSummaryString.toUTF8(), -1, -1, -1);
			}
		}

		if (iChange > 0)
		{
#if defined(MOD_BALANCE_CORE)
			//Instant Boost
			CvCity* pCapitalCity = getCapitalCity();
			if (pCapitalCity != NULL)
			{
				doInstantYield(INSTANT_YIELD_TYPE_INSTANT, false, NO_GREATPERSON, NO_BUILDING, iValue, false, NO_PLAYER, NULL, false, pCapitalCity);
			}
#endif

#if defined(MOD_BALANCE_CORE)
			if (GetGoldenAgeTourism() > 0)
			{
				int iTourism = GetHistoricEventTourism(HISTORIC_EVENT_GA);
				ChangeNumHistoricEvents(HISTORIC_EVENT_GA, 1);
				// Culture boost based on previous turns
				if (iTourism > 0)
				{
					GetCulture()->AddTourismAllKnownCivsWithModifiers(iTourism);
					CvCity* pCapitalCity = getCapitalCity();

					if (GetID() == GC.getGame().getActivePlayer())
					{
						if (pCapitalCity != NULL)
						{
							char text[256] = { 0 };
							sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_TOURISM]", iTourism);
							SHOW_PLOT_POPUP(pCapitalCity->plot(), GetID(), text);

							CvNotifications* pNotification = GetNotifications();
							if (pNotification)
							{
								CvString strMessage;
								CvString strSummary;
								strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GOLDEN_AGE", iTourism);
								strSummary = GetLocalizedText("TXT_KEY_TOURISM_EVENT_SUMMARY");
								pNotification->Add(NOTIFICATION_CULTURE_VICTORY_SOMEONE_INFLUENTIAL, strMessage, strSummary, pCapitalCity->getX(), pCapitalCity->getY(), GetID());
							}
						}
					}
				}
			}
			if (GetPlayerTraits()->GetWLTKDGATimer() > 0)
			{
				int iValue2 = GetPlayerTraits()->GetWLTKDGATimer();
				iValue2 *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iValue2 /= 100;
				int iLoop;
				for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if (pLoopCity != NULL)
					{
						pLoopCity->ChangeWeLoveTheKingDayCounter(iValue2);
					}
				}
				CvNotifications* pNotification = GetNotifications();
				if (pNotification)
				{
					CvString strMessage;
					CvString strSummary;
					strMessage = GetLocalizedText("TXT_KEY_CARNAVAL_WLTKD", iValue2);
					strSummary = GetLocalizedText("TXT_KEY_CARNAVAL_WLTKD_S");
					pNotification->Add(NOTIFICATION_GENERIC, strMessage, strSummary, -1, -1, GetID());
				}
			}
			if (GetPlayerTraits()->GetGoldenAgeGarrisonedCityRangeStrikeModifier() > 0)
			{
				ChangeGarrisonedCityRangeStrikeModifier(GetPlayerTraits()->GetGoldenAgeGarrisonedCityRangeStrikeModifier() * 1);
			}
#endif

			locString = Localization::Lookup("TXT_KEY_NOTIFICATION_GOLDEN_AGE_BEGUN");
			locString << getCivilizationAdjectiveKey();
			GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, GetID(), locString.toUTF8(), -1, -1);

			gDLL->GameplayGoldenAgeStarted();

#if defined(MOD_EVENTS_GOLDEN_AGE)
			if (MOD_EVENTS_GOLDEN_AGE) {
				GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerGoldenAge, GetID(), true, iChange);
			}
#endif
#if defined(MOD_BALANCE_CORE)
			CvCity* pLoopCity;
			int iLoop;
			for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				if (pLoopCity != NULL)
				{
					pLoopCity->GetCityCulture()->CalculateBaseTourismBeforeModifiers();
					pLoopCity->GetCityCulture()->CalculateBaseTourism();
				}
			}
#endif
		}

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGoldenAgeLength() const
{
	int iTurns = GC.getGame().goldenAgeLength();

	// Player modifier
	int iLengthModifier = getGoldenAgeModifier();

	// Trait modifier
	iLengthModifier += GetPlayerTraits()->GetGoldenAgeDurationModifier();

#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	// Do we get increased Golden Ages from a resource monopoly?
	if(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	{
		for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
		{
			ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
			if(eResourceLoop != NO_RESOURCE)
			{
				CvResourceInfo* pInfo = GC.getResourceInfo(eResourceLoop);
				if (pInfo && pInfo->isMonopoly())
				{
					if(HasGlobalMonopoly(eResourceLoop) && pInfo->getMonopolyGALength() > 0)
					{
						int iTemp = pInfo->getMonopolyGALength();
						iTemp += GetMonopolyModPercent();
						iLengthModifier += iTemp;
					}
				}
			}
		}
	}
#endif
#if defined(MOD_BALANCE_CORE)
	if(iLengthModifier != 0)
#else
	if(iLengthModifier > 0)
#endif
	{
		iTurns = iTurns * (100 + iLengthModifier) / 100;
	}

	return iTurns;
}

//	--------------------------------------------------------------------------------

#if defined(MOD_BALANCE_CORE)
int CvPlayer::getGoldenAgeLengthModifier() const // JJ: A way to get the golden age modifier only, in case your iTurn is not GC.getGame().goldenAgeLength()
{

	// Player modifier
	int iLengthModifier = getGoldenAgeModifier();

	// Trait modifier
	iLengthModifier += GetPlayerTraits()->GetGoldenAgeDurationModifier();

#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	// Do we get increased Golden Ages from a resource monopoly?
	if(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	{
		for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
		{
			ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
			if(eResourceLoop != NO_RESOURCE)
			{
				CvResourceInfo* pInfo = GC.getResourceInfo(eResourceLoop);
				if (pInfo && pInfo->isMonopoly())
				{
					if(HasGlobalMonopoly(eResourceLoop) && pInfo->getMonopolyGALength() > 0)
					{
						int iTemp = pInfo->getMonopolyGALength();
						iTemp += GetMonopolyModPercent();
						iLengthModifier += iTemp;
					}
				}
			}
		}
	}
#endif

	return iLengthModifier;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getNumUnitGoldenAges() const
{
	return m_iNumUnitGoldenAges;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeNumUnitGoldenAges(int iChange)
{
	m_iNumUnitGoldenAges = (m_iNumUnitGoldenAges + iChange);
	CvAssert(getNumUnitGoldenAges() >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getStrikeTurns() const
{
	return m_iStrikeTurns;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeStrikeTurns(int iChange)
{
	m_iStrikeTurns = (m_iStrikeTurns + iChange);
	CvAssert(getStrikeTurns() >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getGoldenAgeModifier() const
{
	return m_iGoldenAgeModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGoldenAgeModifier(int iChange)
{
	m_iGoldenAgeModifier += iChange;
}

#if defined(MOD_GLOBAL_TRULY_FREE_GP)
//	--------------------------------------------------------------------------------
int CvPlayer::getGreatPeopleCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatPeopleCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatPeopleCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatPeopleCreated(bool bIsFree)
{
	m_iGreatPeopleCreated++;
	if (bIsFree) m_iFreeGreatPeopleCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatGeneralsCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatGeneralsCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatGeneralsCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatGeneralsCreated(bool bIsFree)
{
	m_iGreatGeneralsCreated++;
	if (bIsFree) m_iFreeGreatGeneralsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatAdmiralsCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatAdmiralsCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatAdmiralsCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatAdmiralsCreated(bool bIsFree)
{
	m_iGreatAdmiralsCreated++;
	if (bIsFree) m_iFreeGreatAdmiralsCreated++;
}

#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
//	--------------------------------------------------------------------------------
int CvPlayer::getGreatMerchantsCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatMerchantsCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatMerchantsCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatMerchantsCreated(bool bIsFree)
{
	m_iGreatMerchantsCreated++;
	if (bIsFree) m_iFreeGreatMerchantsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatScientistsCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatScientistsCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatScientistsCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatScientistsCreated(bool bIsFree)
{
	m_iGreatScientistsCreated++;
	if (bIsFree) m_iFreeGreatScientistsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatEngineersCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatEngineersCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatEngineersCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatEngineersCreated(bool bIsFree)
{
	m_iGreatEngineersCreated++;
	if (bIsFree) m_iFreeGreatEngineersCreated++;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatWritersCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatWritersCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatWritersCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatWritersCreated(bool bIsFree)
{
	m_iGreatWritersCreated++;
	if (bIsFree) m_iFreeGreatWritersCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatArtistsCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatArtistsCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatArtistsCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatArtistsCreated(bool bIsFree)
{
	m_iGreatArtistsCreated++;
	if (bIsFree) m_iFreeGreatArtistsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatMusiciansCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatMusiciansCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatMusiciansCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatMusiciansCreated(bool bIsFree)
{
	m_iGreatMusiciansCreated++;
	if (bIsFree) m_iFreeGreatMusiciansCreated++;
}

#if defined(MOD_DIPLOMACY_CITYSTATES)
//	--------------------------------------------------------------------------------
int CvPlayer::getGreatDiplomatsCreated(bool bExcludeFree) const
{
	int iCount = m_iGreatDiplomatsCreated;
	if (bExcludeFree) iCount -= m_iFreeGreatDiplomatsCreated;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatDiplomatsCreated(bool bIsFree)
{
	m_iGreatDiplomatsCreated++;
	if (bIsFree) m_iFreeGreatDiplomatsCreated++;
}
#endif
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra1Created(bool bExcludeFree) const
{
	int iCount = m_iGPExtra1Created;
	if (bExcludeFree) iCount -= m_iFreeGPExtra1Created;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra1Created(bool bIsFree)
{
	m_iGPExtra1Created++;
	if (bIsFree) m_iFreeGPExtra1Created++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra2Created(bool bExcludeFree) const
{
	int iCount = m_iGPExtra2Created;
	if (bExcludeFree) iCount -= m_iFreeGPExtra2Created;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra2Created(bool bIsFree)
{
	m_iGPExtra2Created++;
	if (bIsFree) m_iFreeGPExtra2Created++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra3Created(bool bExcludeFree) const
{
	int iCount = m_iGPExtra3Created;
	if (bExcludeFree) iCount -= m_iFreeGPExtra3Created;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra3Created(bool bIsFree)
{
	m_iGPExtra3Created++;
	if (bIsFree) m_iFreeGPExtra3Created++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra4Created(bool bExcludeFree) const
{
	int iCount = m_iGPExtra4Created;
	if (bExcludeFree) iCount -= m_iFreeGPExtra4Created;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra4Created(bool bIsFree)
{
	m_iGPExtra4Created++;
	if (bIsFree) m_iFreeGPExtra4Created++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra5Created(bool bExcludeFree) const
{
	int iCount = m_iGPExtra5Created;
	if (bExcludeFree) iCount -= m_iFreeGPExtra5Created;
	return iCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra5Created(bool bIsFree)
{
	m_iGPExtra5Created++;
	if (bIsFree) m_iFreeGPExtra5Created++;
}
#endif
#else
//	--------------------------------------------------------------------------------
int CvPlayer::getGreatPeopleCreated() const
{
	return m_iGreatPeopleCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatPeopleCreated()
{
	m_iGreatPeopleCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatGeneralsCreated() const
{
	return m_iGreatGeneralsCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatGeneralsCreated()
{
	m_iGreatGeneralsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatAdmiralsCreated() const
{
	return m_iGreatAdmiralsCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatAdmiralsCreated()
{
	m_iGreatAdmiralsCreated++;
}

#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
//	--------------------------------------------------------------------------------
int CvPlayer::getGreatMerchantsCreated() const
{
	return m_iGreatMerchantsCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatMerchantsCreated()
{
	m_iGreatMerchantsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatScientistsCreated() const
{
	return m_iGreatScientistsCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatScientistsCreated()
{
	m_iGreatScientistsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatEngineersCreated() const
{
	return m_iGreatEngineersCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatEngineersCreated()
{
	m_iGreatEngineersCreated++;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatWritersCreated() const
{
	return m_iGreatWritersCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatWritersCreated()
{
	m_iGreatWritersCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatArtistsCreated() const
{
	return m_iGreatArtistsCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatArtistsCreated()
{
	m_iGreatArtistsCreated++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatMusiciansCreated() const
{
	return m_iGreatMusiciansCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatMusiciansCreated()
{
	m_iGreatMusiciansCreated++;
}

#if defined(MOD_DIPLOMACY_CITYSTATES)
//	--------------------------------------------------------------------------------
int CvPlayer::getGreatDiplomatsCreated() const
{
	return m_iGreatDiplomatsCreated;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGreatDiplomatsCreated()
{
	m_iGreatDiplomatsCreated++;
}
#endif
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getMerchantsFromFaith() const
{
	return m_iMerchantsFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementMerchantsFromFaith()
{
	m_iMerchantsFromFaith++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getScientistsFromFaith() const
{
	return m_iScientistsFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementScientistsFromFaith()
{
	m_iScientistsFromFaith++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getWritersFromFaith() const
{
	return m_iWritersFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementWritersFromFaith()
{
	m_iWritersFromFaith++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getArtistsFromFaith() const
{
	return m_iArtistsFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementArtistsFromFaith()
{
	m_iArtistsFromFaith++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getMusiciansFromFaith() const
{
	return m_iMusiciansFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementMusiciansFromFaith()
{
	m_iMusiciansFromFaith++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGeneralsFromFaith() const
{
	return m_iGeneralsFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGeneralsFromFaith()
{
	m_iGeneralsFromFaith++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getAdmiralsFromFaith() const
{
	return m_iAdmiralsFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementAdmiralsFromFaith()
{
	m_iAdmiralsFromFaith++;
}

#if defined(MOD_DIPLOMACY_CITYSTATES)
//	--------------------------------------------------------------------------------
int CvPlayer::getDiplomatsFromFaith() const
{
	return m_iDiplomatsFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementDiplomatsFromFaith()
{
	m_iDiplomatsFromFaith++;
}
#endif
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra1FromFaith() const
{
	return m_iGPExtra1FromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra1FromFaith()
{
	m_iGPExtra1FromFaith++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra2FromFaith() const
{
	return m_iGPExtra2FromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra2FromFaith()
{
	m_iGPExtra2FromFaith++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra3FromFaith() const
{
	return m_iGPExtra3FromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra3FromFaith()
{
	m_iGPExtra3FromFaith++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra4FromFaith() const
{
	return m_iGPExtra4FromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra4FromFaith()
{
	m_iGPExtra4FromFaith++;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getGPExtra5FromFaith() const
{
	return m_iGPExtra5FromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementGPExtra5FromFaith()
{
	m_iGPExtra5FromFaith++;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getEngineersFromFaith() const
{
	return m_iEngineersFromFaith;
}

//	--------------------------------------------------------------------------------
void CvPlayer::incrementEngineersFromFaith()
{
	m_iEngineersFromFaith++;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatPeopleThresholdModifier() const
{
	return m_iGreatPeopleThresholdModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGreatPeopleThresholdModifier(int iChange)
{
	m_iGreatPeopleThresholdModifier = (m_iGreatPeopleThresholdModifier + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatGeneralsThresholdModifier() const
{
	return m_iGreatGeneralsThresholdModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGreatGeneralsThresholdModifier(int iChange)
{
	m_iGreatGeneralsThresholdModifier += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatAdmiralsThresholdModifier() const
{
	return m_iGreatAdmiralsThresholdModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGreatAdmiralsThresholdModifier(int iChange)
{
	m_iGreatAdmiralsThresholdModifier += iChange;
}


//	--------------------------------------------------------------------------------
int CvPlayer::getPolicyCostModifier() const
{
	return m_iPolicyCostModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::recomputePolicyCostModifier()
{
	int iCost = m_pPlayerPolicies->GetNumericModifier(POLICYMOD_POLICY_COST_MODIFIER);
	iCost += GetPolicyCostBuildingModifier();
	iCost += GetPolicyCostMinorCivModifier();
	iCost += GetPlayerTraits()->GetPolicyCostModifier();

	if(iCost < /*-75*/ GC.getPOLICY_COST_DISCOUNT_MAX())
		iCost = /*-75*/ GC.getPOLICY_COST_DISCOUNT_MAX();

	m_iPolicyCostModifier = iCost;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatPeopleRateModifier() const
{
	return m_iGreatPeopleRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatGeneralRateModifier() const
{
	return m_iGreatGeneralRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatAdmiralRateModifier() const
{
	return m_iGreatAdmiralRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatWriterRateModifier() const
{
	return m_iGreatWriterRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatArtistRateModifier() const
{
	return m_iGreatArtistRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatMusicianRateModifier() const
{
	return m_iGreatMusicianRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatMerchantRateModifier() const
{
	return m_iGreatMerchantRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatScientistRateModifier() const
{
	return m_iGreatScientistRateModifier;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatEngineerRateModifier() const
{
	return m_iGreatEngineerRateModifier;
}

#if defined(MOD_DIPLOMACY_CITYSTATES)
//	--------------------------------------------------------------------------------
int CvPlayer::getGreatDiplomatRateModifier() const
{
	return m_iGreatDiplomatRateModifier;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getDomesticGreatGeneralRateModifier() const
{
	return m_iDomesticGreatGeneralRateModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGreatPeopleRateModFromBldgs(int ichange)
{
	m_iGreatPeopleRateModFromBldgs += ichange;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGreatGeneralRateModFromBldgs(int ichange)
{
	m_iGreatGeneralRateModFromBldgs += ichange;
}

//	--------------------------------------------------------------------------------
/// Do effects when a unit is killed in combat
#if defined(MOD_API_EXTENSIONS)
void CvPlayer::DoUnitKilledCombat(CvUnit* pKillingUnit, PlayerTypes eKilledPlayer, UnitTypes eUnitType)
#else
void CvPlayer::DoUnitKilledCombat(PlayerTypes eKilledPlayer, UnitTypes eUnitType)
#endif
{
	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(eKilledPlayer);
		args->Push(eUnitType);
#if defined(MOD_API_EXTENSIONS)
		args->Push(pKillingUnit ? pKillingUnit->GetID() : -1);
#endif

		bool bResult;
		LuaSupport::CallHook(pkScriptSystem, "UnitKilledInCombat", args.get(), bResult);
	}
}
#if defined(MOD_BALANCE_CORE)
void CvPlayer::doInstantYield(InstantYieldType iType, bool bCityFaith, GreatPersonTypes eGreatPerson, BuildingTypes eBuilding, int iPassYield, bool bEraScale, PlayerTypes ePlayer, CvPlot* pPlot, bool bSuppress, CvCity* pCity, bool bDomainSea, bool bInternational, bool bEvent, YieldTypes ePassYield, CvUnit* pUnit, TerrainTypes ePassTerrain, CvMinorCivQuest* pQuestData, CvCity* pOtherCity)
{
	//No minors or barbs here, please!
	if(isMinorCiv() || isBarbarian())
		return;

	YieldTypes eYield;
	TerrainTypes eTerrain;

	ReligionTypes eReligion = NO_RELIGION;
	ReligionTypes eLocalReligion = NO_RELIGION;
	eReligion = GC.getGame().GetGameReligions()->GetFounderBenefitsReligion(GetID());
	if(eReligion == NO_RELIGION)
	{
		eReligion = GetReligions()->GetReligionInMostCities();
	}

	const CvReligion* pReligion = NULL;
	if(eReligion != NO_RELIGION)
	{
		//Let's check for holy city status - if this isn't our holy city, let's send the boosts there instead.
		pReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, GetID());
	}
	int iEra = 0;
	iEra = GetCurrentEra();
	if(iEra <= 0)
	{
		iEra = 1;
	}

	int iNumFollowerCities = 0;
	int iNumFollowers = 0;
	if (eReligion > RELIGION_PANTHEON)
	{
		iNumFollowerCities = GC.getGame().GetGameReligions()->GetNumCitiesFollowing(eReligion);
		iNumFollowers = GC.getGame().GetGameReligions()->GetNumFollowers(eReligion);
	}
	else if (eReligion == RELIGION_PANTHEON)
	{
		iNumFollowerCities = GC.getGame().GetGameReligions()->GetNumDomesticCitiesFollowing(eReligion, GetID());
		iNumFollowers = GC.getGame().GetGameReligions()->GetNumFollowers(eReligion, GetID());
	}

	CvString totalyieldString = "";
	//Let's loop through all cities for this.
	int iLoop;
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity == NULL)
			continue;

		//If we passed in a city, only check that city.
		if (pCity != NULL && pLoopCity != pCity)
			continue;

		CvString yieldString = "";
		CvString cityyieldString = "";
		CvString citynameString = "";

		//Get local faith if needed.
		if(bCityFaith)
		{
			eLocalReligion = pCity->GetCityReligions()->GetReligiousMajority();
			//Different faiths at national and local levels? We should check both, because one might be a founder bonus, and the other a follower bonus. Blegh!
			if(eLocalReligion != eReligion)
			{
				pReligion = GC.getGame().GetGameReligions()->GetReligion(eLocalReligion, GetID());
				eReligion = eLocalReligion;

				if (eReligion > RELIGION_PANTHEON)
				{
					iNumFollowerCities = GC.getGame().GetGameReligions()->GetNumCitiesFollowing(eReligion);
					iNumFollowers = GC.getGame().GetGameReligions()->GetNumFollowers(eReligion);
				}
				else if (eReligion == RELIGION_PANTHEON)
				{
					iNumFollowerCities = GC.getGame().GetGameReligions()->GetNumDomesticCitiesFollowing(eReligion, GetID());
					iNumFollowers = GC.getGame().GetGameReligions()->GetNumFollowers(eReligion, GetID());
				}
			}
		}

		
		for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)
		{
			eYield = (YieldTypes) iI;

			if(eYield == NO_YIELD)
				continue;
		
			CvYieldInfo* pYieldInfo = GC.getYieldInfo(eYield);
		
			//First let's get our values...
			//Note that many beliefs pass in a city - that's because only holy cities (or capitals for pantheons) should get those bonuses!
			int iValue = 0;
			switch(iType)
			{
				case INSTANT_YIELD_TYPE_MINOR_QUEST_REWARD:
				{
					if (eYield != ePassYield)
						continue;

					iValue += iPassYield;
				}
				case INSTANT_YIELD_TYPE_BIRTH:
				{
					iValue += pLoopCity->GetYieldFromBirth(eYield) + getYieldFromBirth(eYield);
					if(pReligion)
					{
						iValue += pReligion->m_Beliefs.GetYieldPerBirth(eYield, GetID(), pLoopCity);
					}
					if(pLoopCity->isCapital())
					{
						iValue += getYieldFromBirthCapital(eYield);
					}
					//Scale it here to avoid scaling the growth yield below.
					if(MOD_BALANCE_CORE_NEW_GP_ATTRIBUTES && bEraScale)
					{
						iValue *= iEra;
					}

					//And now on growth % bonuses.
					int iCurrentYield = 0;

					if(eYield == YIELD_CULTURE)
					{
						iCurrentYield = pLoopCity->getJONSCulturePerTurn();
					}
					else if (eYield == YIELD_FAITH)
					{
						iCurrentYield = pLoopCity->GetFaithPerTurn();
					}
					else
					{
						iCurrentYield = pLoopCity->getYieldRate(eYield, false);
					}
					if(iCurrentYield != 0)
					{
						iValue += ((iCurrentYield * pLoopCity->GetGrowthExtraYield(eYield)) / 100);
						if(iValue <= 0 && pLoopCity->GetGrowthExtraYield(eYield) > 0)
						{
							iValue = 1;
						}
					}
					break;
				}
				case INSTANT_YIELD_TYPE_BIRTH_RETROACTIVE:
				{
					iValue += getYieldFromBirthRetroactive(eYield) * iPassYield;
					
					if (pLoopCity->isCapital())
					{
						iValue += getYieldFromBirthCapitalRetroactive(eYield) * iPassYield;
					}
					break;
				}
				case INSTANT_YIELD_TYPE_ERA_UNLOCK:
				{
					if(pReligion)
					{
						
						iValue += pReligion->m_Beliefs.GetYieldFromEraUnlock(eYield, GetID(), pLoopCity, true) * pReligion->m_Beliefs.GetCityScalerLimiter(iNumFollowerCities);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_POLICY_UNLOCK:
				{
					int iScaleValue = pLoopCity->GetYieldFromPolicyUnlock(eYield);
					//Scale it here to avoid scaling the growth yield below.
					if (MOD_BALANCE_CORE_NEW_GP_ATTRIBUTES)
					{
						iScaleValue *= iEra;
					}
					iValue += iScaleValue;

					if(pReligion)
					{
						iValue += pReligion->m_Beliefs.GetYieldFromPolicyUnlock(eYield, GetID(), pLoopCity, true) * pReligion->m_Beliefs.GetFollowerScalerLimiter(iNumFollowers);
					}
					
					break;
				}
				case INSTANT_YIELD_TYPE_INSTANT:
				{
					if(eBuilding != NO_BUILDING)
					{
						CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
						if(pkBuildingInfo)
						{
							iValue += pkBuildingInfo->GetInstantYield(eYield);
							if(GetPlayerTraits()->IsTechBoostFromCapitalScienceBuildings() && iPassYield > 0 && eYield == YIELD_SCIENCE)
							{
								iValue += iPassYield;
							}
						}
					}
					else 
					{
						if(iPassYield != 0 && !bEvent)
						{
							int iPercent = GetPlayerTraits()->GetGAPToYield(eYield);
							if(iPercent != 0)
							{
								iPassYield *= iPercent;
								iPassYield /= 100;
						
								iValue += iPassYield;
							}
						}
						if(bEvent && ePassYield == eYield)
						{
							iValue += iPassYield;
						}
					}
					break;
				}
				case INSTANT_YIELD_TYPE_TECH:
				{
					iValue +=  pLoopCity->GetYieldFromTech(eYield);
					if(pLoopCity->isCapital())
					{
						iValue += getYieldFromTech(eYield);
					}
					break;
				}

				case INSTANT_YIELD_TYPE_SPY_ATTACK:
				{
					iValue += pLoopCity->GetYieldFromSpyAttack(eYield);
					if (iValue != 0)
					{
						if (iPassYield == 0)
							iValue /= 4;
						else
							iValue *= iPassYield;
					}
					break;
				}
				case INSTANT_YIELD_TYPE_SPY_DEFENSE:
				{
					iValue += pLoopCity->GetYieldFromSpyDefense(eYield);
					if (iValue != 0)
					{
						if (iPassYield == 0)
							iValue /= 4;
						else
							iValue *= iPassYield;
					}
					break;
				}
				case INSTANT_YIELD_TYPE_DELEGATES:
				{
					if (pLoopCity->isCapital())
					{
						iValue += (getYieldFromDelegateCount(eYield) * iPassYield);
					}
					break;
				}			
				
				case INSTANT_YIELD_TYPE_CONSTRUCTION:
				{
					iValue += pLoopCity->GetYieldFromConstruction(eYield) + getYieldFromConstruction(eYield);
					break;
				}
				case INSTANT_YIELD_TYPE_CONSTRUCTION_WONDER:
				{
					iValue += getYieldFromwonderConstruction(eYield);
					break;
				}
				case INSTANT_YIELD_TYPE_BORDERS:
				{
					int iScaleValue = pLoopCity->GetYieldFromBorderGrowth(eYield) + getYieldFromBorderGrowth(eYield) + GetPlayerTraits()->GetYieldFromTileEarn(eYield);

					iScaleValue *= iEra;

					iValue += iScaleValue;

					if(pReligion)
					{
						iValue += pReligion->m_Beliefs.GetYieldPerBorderGrowth(eYield, GetID(), pLoopCity);
					}
					for(int iI = 0; iI < GC.getNumTerrainInfos(); iI++)
					{
						eTerrain = (TerrainTypes) iI;

						if(eTerrain == NO_TERRAIN)
							continue;
						if(eTerrain == ePassTerrain)
						{
							iScaleValue = GetPlayerTraits()->GetYieldChangeFromTileEarnTerrainType(eTerrain, eYield);
							iScaleValue *= iEra;
							iValue += iScaleValue;
						}
					}
					break;
				}
				case INSTANT_YIELD_TYPE_PROPOSAL:
				{
					if(pReligion)
					{
						iValue += pReligion->m_Beliefs.GetYieldFromProposal(eYield, GetID(), pLoopCity, true);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_GP_USE:
				{
					if(pLoopCity->isCapital())
					{
						iValue += getYieldGPExpend(eYield);
						if(eYield == YIELD_GOLD)
						{
							iValue += GetGreatPersonExpendGold();
						}
					}
					if(eGreatPerson != NO_GREATPERSON)
					{
						if(pLoopCity->isCapital())
						{
							iValue += getGreatPersonExpendedYield(eGreatPerson, eYield);
							//Scale it here to avoid scaling the growth yield below.
							if (bEraScale)
							{
								iValue *= iEra;
							}
						}
						if(pReligion)
						{
							iValue += (pReligion->m_Beliefs.GetYieldFromGPUse(eYield, GetID(), pLoopCity, true) + pReligion->m_Beliefs.GetGreatPersonExpendedYield(eGreatPerson, eYield, GetID(), pLoopCity, true)) * pReligion->m_Beliefs.GetCityScalerLimiter(iNumFollowerCities);
						}
					}
					if(eYield == YIELD_FAITH)
					{
						if(pReligion)
						{
							iValue += pReligion->m_Beliefs.GetGreatPersonExpendedFaith(GetID(), pLoopCity, true);
							//Scale it here to avoid scaling the growth yield below.
							if (bEraScale)
							{
								iValue *= iEra;
							}
						}
					}
					break;
				}
				case INSTANT_YIELD_TYPE_GP_BORN:
				{
					if(eGreatPerson != NO_GREATPERSON)
					{
						iValue += GetPlayerTraits()->GetGreatPersonBornYield(eGreatPerson, eYield);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_F_CONQUEST:
				{
					if (pLoopCity->isCapital())
					{
						iValue += (getConquerorYield(eYield) + GetPlayerTraits()->GetYieldFromConquest(eYield));
					}
					if (pReligion)
					{
						iValue += pReligion->m_Beliefs.GetYieldFromConquest(eYield, GetID(), pLoopCity, true);
					}
					if (iPassYield != 0 && iValue != 0)
					{
						iValue *= iPassYield;
					}

					if (pLoopCity->isCapital() && pOtherCity != NULL)
					{
						for (int iI = 0; iI < GC.getNumTerrainInfos(); iI++)
						{
							eTerrain = (TerrainTypes)iI;

							if (eTerrain != NO_TERRAIN)
							{
								int iTraitValue = GetPlayerTraits()->GetYieldChangeFromTileConquest(eTerrain, eYield);

								if (iTraitValue <= 0)
									continue;

								int iNumTiles = pOtherCity->CountAllOwnedTerrain(eTerrain);
								if (iNumTiles > 0)
								{
									iValue += (iTraitValue * iNumTiles);
								}
							}
						}
					}
					break;
				}
				case INSTANT_YIELD_TYPE_VICTORY:
				{
					if(eYield == YIELD_GREAT_ADMIRAL_POINTS && !bDomainSea)
					{
						continue;
					}
					if(eYield == YIELD_GREAT_GENERAL_POINTS && bDomainSea)
					{
						continue;
					}
					iValue += pLoopCity->GetYieldFromVictory(eYield);
					break;
				}
				case INSTANT_YIELD_TYPE_PILLAGE:
				{
					iValue += pLoopCity->GetYieldFromPillage(eYield);
					break;
				}
				
				case INSTANT_YIELD_TYPE_U_PROD:
				{
					if (pLoopCity->GetYieldFromUnitProduction(eYield) > 0)
					{
						int iBonus = iPassYield;
						iBonus *= pLoopCity->GetYieldFromUnitProduction(eYield);
						iBonus /= 100;

						iValue += iBonus;
					}
					break;
				}
				case INSTANT_YIELD_TYPE_PURCHASE:
				{
					if(iPassYield != 0)
					{
						iValue += ((iPassYield * pLoopCity->GetYieldFromPurchase(eYield)) / 100);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_TILE_PURCHASE:
				{
					iValue += GetPlayerTraits()->GetYieldFromTilePurchase(eYield);
					for (int iI = 0; iI < GC.getNumTerrainInfos(); iI++)
					{
						eTerrain = (TerrainTypes)iI;

						if (eTerrain == NO_TERRAIN)
							continue;
						if (eTerrain == ePassTerrain)
						{
							iValue += GetPlayerTraits()->GetYieldChangeFromTilePurchaseTerrainType(eTerrain, eYield);
						}
					}
					break;
				}
				case INSTANT_YIELD_TYPE_FOUND:
				{
					iValue += GetPlayerTraits()->GetYieldFromSettle(eYield);
					iValue += getFounderYield(eYield);
					for (int iI = 0; iI < GC.getNumTerrainInfos(); iI++)
					{
						eTerrain = (TerrainTypes)iI;

						if (eTerrain != NO_TERRAIN && pCity != NULL)
						{
							int iTraitValue = GetPlayerTraits()->GetYieldChangeFromTileSettle(eTerrain, eYield);

							if (iTraitValue <= 0)
								continue;

							int iNumTiles = pCity->CountTerrain(eTerrain);
							if (iNumTiles > 0)
							{
								iValue += (iTraitValue * iNumTiles);
							}
						}
					}
					break;
				}
				case INSTANT_YIELD_TYPE_TR_END:
				{
					if(bInternational && (eYield == YIELD_SCIENCE || eYield == YIELD_FOOD || eYield == YIELD_PRODUCTION))
					{
						iValue += GetPlayerTraits()->GetTradeRouteStartYield(eYield);
					}
					else if(!bInternational && (eYield == YIELD_GOLD || eYield == YIELD_CULTURE))
					{
						iValue += GetPlayerTraits()->GetTradeRouteStartYield(eYield);
					}
					else if(eYield >= YIELD_FAITH)
					{
						iValue += GetPlayerTraits()->GetTradeRouteStartYield(eYield);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_CONVERSION:
				{
					int iBaseValue = pReligion->m_Beliefs.GetYieldFromConversion(eYield, GetID(), pLoopCity, true);
					if (iBaseValue != 0)
					{
						int iTempValue = iBaseValue;
						iTempValue *= (100 + pReligion->m_Beliefs.GetCityScalerLimiter(iNumFollowerCities) * pReligion->m_Beliefs.GetCityScalerLimiter(iNumFollowerCities));
						iTempValue /= 100;

						iBaseValue += iTempValue;
					}

					iValue += iBaseValue;
					break;
				}
				case INSTANT_YIELD_TYPE_DEATH:
				{
					if(pLoopCity->isCapital())
					{
						iValue += getYieldFromDeath(eYield);
					}
					break;
				}
				case INSTANT_YIELD_TYPE_BULLY:
				{
					if (eYield != ePassYield)
					continue;

					if (iPassYield == 0)
						iValue += GetYieldFromMinorDemand(eYield);
					else
						iValue += iPassYield;
					break;
				}
				case INSTANT_YIELD_TYPE_SPREAD:
				{
					if(pReligion && pPlot != NULL)
					{
						CvCity* pCity = pPlot->getPlotCity();
						if(pCity == NULL)
						{
							pCity = pPlot->GetAdjacentCity();
						}
						if(pCity != NULL)
						{
							if(!pCity->GetCityReligions()->IsHolyCityForReligion(eReligion))
							{
								iValue += pReligion->m_Beliefs.GetYieldFromSpread(eYield, GetID(), pLoopCity, true) * max(1, iPassYield+1);
							}
						}
					}
					break;
				}
				case INSTANT_YIELD_TYPE_F_SPREAD:
				{
					if(ePlayer != NO_PLAYER && ePlayer != GetID())
					{
						if(GET_PLAYER(ePlayer).isMinorCiv() && eYield == YIELD_TOURISM)
						{
							continue;
						}
						if(pReligion)
						{
							int iTempValue = pReligion->m_Beliefs.GetYieldFromForeignSpread(eYield, GetID(), pLoopCity, true);
							iTempValue *= max(1, iPassYield+1);

							iValue += iTempValue;
						}
						CvCity* pCity = pPlot->getPlotCity();
						if (pCity == NULL)
						{
							pCity = pPlot->GetAdjacentCity();
						}
						if (pCity != NULL)
						{
							if (eYield == YIELD_SCIENCE && iPassYield > 0)
							{
								ReligionTypes eCurrentReligion = pCity->GetCityReligions()->GetReligiousMajority();
								if (eCurrentReligion != eReligion)
								{
									iValue += (iPassYield * pReligion->m_Beliefs.GetSciencePerOtherReligionFollower(GetID(), pLoopCity, true));
								}
							}
						}
					}
					
					break;
				}	
				case INSTANT_YIELD_TYPE_TR_MOVEMENT:
				{
					if(eYield == YIELD_GREAT_ADMIRAL_POINTS && !bDomainSea)
					{
						continue;
					}
					if(eYield == YIELD_GREAT_GENERAL_POINTS && bDomainSea)
					{
						continue;
					}
					iValue += GetPlayerTraits()->GetYieldFromRouteMovement(eYield);
					break;
				}
				case INSTANT_YIELD_TYPE_SCOUTING:
				{
					if(pUnit == NULL)
						continue;

					if(eYield == YIELD_GREAT_ADMIRAL_POINTS && !bDomainSea)
					{
						continue;
					}
					if(eYield == YIELD_GREAT_GENERAL_POINTS && bDomainSea)
					{
						continue;
					}
					iValue += (pUnit->getYieldFromScouting(eYield) * pUnit->GetNumTilesRevealedThisTurn());
					break;
				}
				case INSTANT_YIELD_TYPE_LEVEL_UP:
				{
					if(pUnit == NULL)
						continue;

					if(eYield == YIELD_GREAT_ADMIRAL_POINTS && !bDomainSea)
					{
						continue;
					}
					if(eYield == YIELD_GREAT_GENERAL_POINTS && bDomainSea)
					{
						continue;
					}

					int iLevelUpYield = pLoopCity->GetYieldFromUnitLevelUp(eYield) + GetPlayerTraits()->GetYieldFromLevelUp(eYield);

					if (iPassYield != 0 && iLevelUpYield > 0)
					{
						int iMetric = ((((iPassYield * iPassYield) - (2 * iPassYield) + 1)) * iLevelUpYield);
						if (iMetric <= 0)
							iMetric = 1;

						iValue += iMetric;
					}
					break;
				}
				case INSTANT_YIELD_TYPE_CULTURE_BOMB:
				{
					if (eYield != ePassYield)
						continue;

					iValue += iPassYield;

					break;
				}

				case INSTANT_YIELD_TYPE_REMOVE_HERESY:
				{
					if (pReligion)
					{
						iValue += pReligion->m_Beliefs.GetYieldFromRemoveHeresy(eYield, GetID(), pLoopCity, true);
						iValue *= 100;
						iValue /= max(1, iEra * 50);
						if (iValue <= 0)
							iValue = 0;
					}

					break;
				}
				
			}
			//Now, let's apply these yields here as total yields.
			if(iValue != 0)
			{
				//Exclusions
				if(eYield != YIELD_POPULATION)
				{
					if (iType != INSTANT_YIELD_TYPE_TR_MOVEMENT && iType != INSTANT_YIELD_TYPE_PURCHASE && iType != INSTANT_YIELD_TYPE_U_PROD && iType != INSTANT_YIELD_TYPE_MINOR_QUEST_REWARD)
					{
						if (ePlayer == NO_PLAYER && eYield == YIELD_TOURISM)
						{
							//nothing
						}
						else
						{
							iValue *= GC.getGame().getGameSpeedInfo().getTrainPercent();
							iValue /= 100;
						}
					}

					//Exclusion for birth yields and GP expense and policy unlocks (as we do it up above to avoid % growth and religion bonuses from being scaled).
					if (bEraScale && iType != INSTANT_YIELD_TYPE_BIRTH && iType != INSTANT_YIELD_TYPE_GP_USE && iType != INSTANT_YIELD_TYPE_POLICY_UNLOCK && iType != INSTANT_YIELD_TYPE_BORDERS && iType != INSTANT_YIELD_TYPE_REMOVE_HERESY)
					{
						iValue *= iEra;
					}
				}

				//keep track of what we're doing
				m_viInstantYieldsTotal.setAt(eYield, m_viInstantYieldsTotal[eYield] + iValue);

				switch(eYield)
				{
					case YIELD_FOOD:
					{
						pLoopCity->changeFood(iValue);
						if(pLoopCity->getFood() <= 0)
						{
							pLoopCity->setFood(0);
						}
					}
					break;
					case YIELD_PRODUCTION:
					{
						if ((pLoopCity->getProduction() < pLoopCity->getProductionNeeded()) && pLoopCity->isProduction())
						{
							pLoopCity->changeProduction(iValue);
						}
						else
						{
							pLoopCity->changeOverflowProduction(iValue);
						}
						if (pLoopCity->getProduction() <= 0)
						{
							pLoopCity->setProduction(0);
						}
					}
					break;
					case YIELD_GOLD:
					{
						GetTreasury()->ChangeGold(iValue);
						if(GetTreasury()->GetGold() <= 0)
						{
							GetTreasury()->SetGold(0);
						}
					}
					break;
					case YIELD_SCIENCE:
					{
						TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
						if(eCurrentTech == NO_TECH)
						{
							changeOverflowResearch(iValue);
							if(getOverflowResearch() <= 0)
							{
								setOverflowResearch(0);
							}
						}
						else
						{
							GET_TEAM(getTeam()).GetTeamTechs()->ChangeResearchProgress(eCurrentTech, iValue, GetID());
							if(GET_TEAM(getTeam()).GetTeamTechs()->GetResearchProgress(eCurrentTech) <= 0)
							{
								GET_TEAM(getTeam()).GetTeamTechs()->SetResearchProgress(eCurrentTech, 0, GetID());
							}
						}
					}
					break;
					case YIELD_CULTURE:
					{
						changeJONSCulture(iValue);
						pLoopCity->ChangeJONSCultureStored(iValue);
						if(pLoopCity->GetJONSCultureStored() <= 0)
						{
							pLoopCity->SetJONSCultureStored(0);
						}
					}
					break;
					case YIELD_FAITH:
					{
						ChangeFaith(iValue);
						if(GetFaith() <= 0)
						{
							SetFaith(0);
						}
					}
					break;
					case YIELD_TOURISM:
					{
						if(ePlayer != NO_PLAYER)
						{
							GetCulture()->ChangeInfluenceOn(ePlayer, iValue);
							changeInstantYieldValue(eYield, iValue);
							if(pPlot != NULL && pPlot->getOwner() != NO_PLAYER && GET_PLAYER(pPlot->getOwner()).isMajorCiv())
							{
								// Show tourism spread
								if (pPlot->GetActiveFogOfWarMode() == FOGOFWARMODE_OFF)
								{
									CvString strInfluenceText;
									InfluenceLevelTypes eLevel = GetCulture()->GetInfluenceLevel(pPlot->getOwner());

									if (eLevel == INFLUENCE_LEVEL_UNKNOWN)
										strInfluenceText = GetLocalizedText( "TXT_KEY_CO_UNKNOWN" );
									else if (eLevel == INFLUENCE_LEVEL_EXOTIC)
										strInfluenceText = GetLocalizedText( "TXT_KEY_CO_EXOTIC");
									else if (eLevel == INFLUENCE_LEVEL_FAMILIAR)
										strInfluenceText = GetLocalizedText( "TXT_KEY_CO_FAMILIAR");
									else if (eLevel == INFLUENCE_LEVEL_POPULAR)
										strInfluenceText = GetLocalizedText( "TXT_KEY_CO_POPULAR");
									else if (eLevel == INFLUENCE_LEVEL_INFLUENTIAL)
										strInfluenceText = GetLocalizedText( "TXT_KEY_CO_INFLUENTIAL");
									else if (eLevel == INFLUENCE_LEVEL_DOMINANT)
										strInfluenceText = GetLocalizedText( "TXT_KEY_CO_DOMINANT");

									char text[256] = {0};
									sprintf_s(text, "[COLOR_WHITE]+%d [ICON_TOURISM][ENDCOLOR]   %s", iValue, strInfluenceText.c_str());
									SHOW_PLOT_POPUP(pPlot, GetID(), text);
								}
							}
						}
						else
						{
							GetCulture()->AddTourismAllKnownCivsWithModifiers(iValue);
						}
					}
					break;
					case YIELD_GOLDEN_AGE_POINTS:
					{
						ChangeGoldenAgeProgressMeter(iValue);
						if(GetGoldenAgeProgressMeter() <= 0)
						{
							SetGoldenAgeProgressMeter(0);
						}
					}
					break;
					case YIELD_GREAT_GENERAL_POINTS:
					{
	#if defined(MOD_UNITS_XP_TIMES_100)
						changeCombatExperienceTimes100(iValue * 100);
						if(getCombatExperienceTimes100() <= 0)
						{
							setCombatExperienceTimes100(0);
						}
	#else
						changeCombatExperience(iValue);
						if(getCombatExperience() <= 0)
						{
							setCombatExperience(0);
						}
	#endif
					}
					break;
					case YIELD_GREAT_ADMIRAL_POINTS:
					{
	#if defined(MOD_UNITS_XP_TIMES_100)
						changeNavalCombatExperienceTimes100(iValue * 100);
						if(getNavalCombatExperienceTimes100() <= 0)
						{
							setNavalCombatExperienceTimes100(0);
						}
	#else
						changeNavalCombatExperience(iValue);
						if(getNavalCombatExperience() <= 0)
						{
							setNavalCombatExperience(0);
						}
	#endif
					}
					break;
					case YIELD_POPULATION:
					{
						if(iValue < 0 && pLoopCity->getPopulation() <= iValue)
						{
							pLoopCity->setPopulation(1);
						}
						else
						{
							pLoopCity->changePopulation(iValue);
						}
					}
					break;
					case YIELD_CULTURE_LOCAL:
					{
						if (iType == INSTANT_YIELD_TYPE_MINOR_QUEST_REWARD)
						{
							getCapitalCity()->ChangeUnmoddedHappinessFromBuildings(iValue);
						}
						else
						{
							pLoopCity->ChangeJONSCultureStored(iValue);
							if (pLoopCity->GetJONSCultureStored() <= 0)
							{
								pLoopCity->SetJONSCultureStored(0);
							}
						}
					}
					break;
				}
				//And now notifications.
				if(GetID() == GC.getGame().getActivePlayer() && iValue > 0)
				{
					char text[256] = {0};
					
					yieldString.Format("%s+%%d[ENDCOLOR] %s", pYieldInfo->getColorString(), pYieldInfo->getIconString());
					sprintf_s(text, yieldString, iValue);
					SHOW_PLOT_POPUP(pLoopCity->plot(), GetID(), text);

					if(citynameString == "")
					{
						citynameString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_CITY", pLoopCity->getNameKey());
					}
					if(cityyieldString != "")
					{
						cityyieldString += ", ";
					}
					if (iType == INSTANT_YIELD_TYPE_MINOR_QUEST_REWARD)
					{
						if (eYield == YIELD_CULTURE_LOCAL)
						{
							cityyieldString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_DETAILS_HAPPINESS", iValue);
						}
						else if (eYield == YIELD_JFD_LOYALTY)
						{
							cityyieldString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_DETAILS_INFLUENCE", iValue);
						}
						else if (eYield == YIELD_JFD_SOVEREIGNTY)
						{
							cityyieldString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_DETAILS_EXPERIENCE", iValue);
						}
						else if (eYield == YIELD_JFD_HEALTH && pCity == NULL)
						{
							cityyieldString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_DETAILS_GPP_GLOBAL", iValue);
						}
						else if (eYield == YIELD_JFD_HEALTH)
						{
							cityyieldString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_DETAILS_GPP", iValue);
						}
						else
						{
							cityyieldString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_DETAILS", pYieldInfo->GetDescriptionKey(), pYieldInfo->getIconString(), iValue);
						}
					}
					else
					{
						cityyieldString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_DETAILS", pYieldInfo->GetDescriptionKey(), pYieldInfo->getIconString(), iValue);
					}
 				}

				//store off this data
				if (eYield != YIELD_TOURISM)
				{
					changeInstantYieldValue(eYield, iValue);
				}
			}
		}
		if(citynameString != "" && cityyieldString != "")
		{
			citynameString += cityyieldString;
		}
		if(totalyieldString != "" && citynameString != "")
		{
			totalyieldString += "[NEWLINE]";
		}
		totalyieldString += citynameString;
	}
	CvNotifications* pNotifications = GetNotifications();
	if(!bSuppress && GetID() == GC.getGame().getActivePlayer() && pNotifications && totalyieldString != "")
	{
		Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_INSTANT_YIELD");
		if(pCity != NULL)
		{
			strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_INSTANT_YIELD_IN_CITY");
			strSummary << pCity->getNameKey();
		}
		Localization::String localizedText;
		switch(iType)
		{
			case INSTANT_YIELD_TYPE_MINOR_QUEST_REWARD:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					CvString MoreData = NULL;
					if (pQuestData != NULL)
					{
						const char* MinorName = GET_PLAYER(pQuestData->GetMinor()).getNameKey();
						switch (pQuestData->GetType())
						{
						case MINOR_CIV_QUEST_ROUTE:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_ROUTE_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_KILL_CAMP:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_KILL_CAMP_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_CONNECT_RESOURCE:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_CONNECT_RESOURCE_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_CONSTRUCT_WONDER:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_CONSTRUCT_WONDER_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_GREAT_PERSON:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_GREAT_PERSON_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_KILL_CITY_STATE:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_KILL_CITY_STATE_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_FIND_PLAYER:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_FIND_PLAYER_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_FIND_NATURAL_WONDER:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_FIND_NATURAL_WONDER_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_GIVE_GOLD:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_GIVE_GOLD_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_PLEDGE_TO_PROTECT:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_PLEDGE_TO_PROTECT_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_CONTEST_CULTURE:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_CONTEST_CULTURE_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_CONTEST_FAITH:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_CONTEST_FAITH_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_CONTEST_TECHS:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_CONTEST_TECHS_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_INVEST:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_INVEST_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_BULLY_CITY_STATE:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_BULLY_CITY_STATE_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_DENOUNCE_MAJOR:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_DENOUNCE_MAJOR_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_SPREAD_RELIGION:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_SPREAD_RELIGION_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_TRADE_ROUTE:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_TRADE_ROUTE_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_WAR:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_WAR_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_CONSTRUCT_NATIONAL_WONDER:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_CONSTRUCT_NATIONAL_WONDER_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_FIND_CITY_STATE:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_FIND_CITY_STATE_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_INFLUENCE:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_INFLUENCE_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_CONTEST_TOURISM:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_CONTEST_TOURISM_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_ARCHAEOLOGY:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_ARCHAEOLOGY_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_CIRCUMNAVIGATION:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_CIRCUMNAVIGATION_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_LIBERATION:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_LIBERATION_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_HORDE:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_HORDE_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_REBELLION:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_REBELLION_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_DISCOVER_PLOT:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_DISCOVER_PLOT_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_BUILD_X_BUILDINGS:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_BUILD_X_BUILDINGS_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_UNIT_STEAL_FROM:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_UNIT_STEAL_FROM_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_UNIT_COUP_CITY:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_UNIT_COUP_CITY_NAME", MinorName);
							break;
						case MINOR_CIV_QUEST_UNIT_GET_CITY:
							MoreData = GetLocalizedText("TXT_KEY_MINOR_CIV_QUEST_UNIT_GET_CITY_NAME", MinorName);
							break;
						}
					}

					if (MoreData != NULL)
					{
						localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_MINOR_QUEST");
						localizedText << MoreData;
						localizedText << totalyieldString;
						//We do this at the player level once per turn.
						addInstantYieldText(iType, localizedText.toUTF8());
					}
					else
					{
						localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_MINOR_QUEST");
						localizedText << "";
						localizedText << totalyieldString;
						//We do this at the player level once per turn.
						addInstantYieldText(iType, localizedText.toUTF8());
					}
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_BIRTH:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_BIRTH");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_BIRTH_RETROACTIVE:
			{
				if (getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_BIRTH_RETROACTIVE");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_ERA_UNLOCK:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_ERA");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_POLICY_UNLOCK:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_POLICY");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_INSTANT:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_INSTANT");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_TECH:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_TECH");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_CONSTRUCTION:
			case INSTANT_YIELD_TYPE_CONSTRUCTION_WONDER:
			{
				if(eBuilding != NO_BUILDING)
				{
					CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
					if(pkBuildingInfo)
					{
						if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
						{
							localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_CONSTRUCTION");
							localizedText << totalyieldString << pkBuildingInfo->GetDescriptionKey();
							//We do this at the player level once per turn.
							addInstantYieldText(iType, localizedText.toUTF8());
						}
						else
						{
							localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
							localizedText << totalyieldString << pkBuildingInfo->GetDescriptionKey();
							//We do this at the player level once per turn.
							addInstantYieldText(iType, localizedText.toUTF8());
						}
					}
				}
				return;
			}
			case INSTANT_YIELD_TYPE_BORDERS:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_BORDERS");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_PROPOSAL:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_PROPOSAL");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_GP_USE:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_GP_USE");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_GP_BORN:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_GP_BORN");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_F_CONQUEST:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_CONQUEST");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_VICTORY:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_VICTORY");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_PILLAGE:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_PILLAGE");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_U_PROD:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_UNIT_PRODUCTION");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_PURCHASE:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_PURCHASE");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_TILE_PURCHASE:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_TILE_PURCHASE");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_FOUND:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_FOUND");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_TR_END:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_TRADE_ROUTE");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_CONVERSION:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_CONVERSION");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_DEATH:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_DEATH");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_BULLY:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_BULLY");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_SPREAD:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_SPREAD");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_F_SPREAD:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_FOREIGN_SPREAD");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_DELEGATES:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_DELEGATES");
				localizedText << totalyieldString;
				break;
			}
			case INSTANT_YIELD_TYPE_SPY_DEFENSE:
			case INSTANT_YIELD_TYPE_SPY_ATTACK:
			{
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_SPIES");
				localizedText << totalyieldString;
				break;
			}
			
			case INSTANT_YIELD_TYPE_TR_MOVEMENT:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_TR_MOVEMENT");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_SCOUTING:
			{
				if(getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_SCOUTING");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_LEVEL_UP:
			{
				if(pUnit != NULL)
				{
					CvUnitEntry* pkUnitInfo = GC.getUnitInfo(pUnit->getUnitType());
					if(pkUnitInfo)
					{
						localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_LEVEL_UP");
						localizedText << totalyieldString;
						localizedText << pkUnitInfo->GetDescriptionKey();
						break;
					}
				}
			}	
			case INSTANT_YIELD_TYPE_CULTURE_BOMB:
			{
				if (getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_CULTURE_BOMB");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			case INSTANT_YIELD_TYPE_REMOVE_HERESY:
			{
				if (getInstantYieldText(iType) == "" || getInstantYieldText(iType) == NULL)
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_REMOVE_HERESY");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalyieldString;
					//We do this at the player level once per turn.
					addInstantYieldText(iType, localizedText.toUTF8());
				}
				return;
			}
			
		}
		if(pCity == NULL)
		{
			CvCity* pCapitalCity = getCapitalCity();
			if(pCapitalCity != NULL)
			{
				pNotifications->Add((NotificationTypes)FString::Hash("NOTIFICATION_INSTANT_YIELD"), localizedText.toUTF8(), strSummary.toUTF8(), pCapitalCity->getX(), pCapitalCity->getY(), pCapitalCity->GetID());
			}
		}
		else
		{
			pNotifications->Add((NotificationTypes)FString::Hash("NOTIFICATION_INSTANT_YIELD"), localizedText.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), pCity->GetID());
		}
	}
}
void CvPlayer::addInstantYieldText(InstantYieldType iType, CvString strInstantYield)
{
	VALIDATE_OBJECT
	CvAssertMsg(iType >= 0, "iType expected to be >= 0");
	CvAssertMsg(iType < NUM_INSTANT_YIELD_TYPES, "iType expected to be < NUM_INSTANT_YIELD_TYPES");

	m_aistrInstantYield.setAt(iType, m_aistrInstantYield[iType] + strInstantYield);
}
void CvPlayer::setInstantYieldText(InstantYieldType iType, CvString strInstantYield)
{
	VALIDATE_OBJECT
	CvAssertMsg(iType >= 0, "iType expected to be >= 0");
	CvAssertMsg(iType < NUM_INSTANT_YIELD_TYPES, "iType expected to be < NUM_INSTANT_YIELD_TYPES");
	m_aistrInstantYield.setAt(iType, strInstantYield);
}
CvString CvPlayer::getInstantYieldText(InstantYieldType iType) const
{
	VALIDATE_OBJECT
	CvAssertMsg(iType >= 0, "iType expected to be >= 0");
	CvAssertMsg(iType < NUM_INSTANT_YIELD_TYPES, "iType expected to be < NUM_INSTANT_YIELD_TYPES");
	return m_aistrInstantYield[iType];
}
void CvPlayer::doInstantGWAM(GreatPersonTypes eGreatPerson, CvString strName, bool bConquest)
{
	CvCity* pCapital = getCapitalCity();
	int iEventGP = 0;
	if (bConquest)
		iEventGP += GetPlayerTraits()->GetCityConquestGWAM();
	else
		iEventGP += GetPlayerTraits()->GetGreatPersonGWAM(eGreatPerson);

	if (pCapital != NULL && iEventGP > 0)
	{
		int iGPWriter = 0;
		int iGPArtist = 0;
		int iGPMusician = 0;
		for (int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
		{
			const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iSpecialistLoop);
			CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
			if (pkSpecialistInfo)
			{
				if ((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_WRITER"))
				{
					iGPWriter = pCapital->GetCityCitizens()->GetSpecialistUpgradeThreshold((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass());
					iGPWriter *= 100;
					//Get % of threshold for test.
					iGPWriter *= iEventGP;
					iGPWriter /= 100;

					pCapital->GetCityCitizens()->ChangeSpecialistGreatPersonProgressTimes100(eSpecialist, iGPWriter, true);
				}
				if ((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_ARTIST"))
				{
					iGPArtist = pCapital->GetCityCitizens()->GetSpecialistUpgradeThreshold((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass());
					iGPArtist *= 100;
					//Get % of threshold for test.
					iGPArtist *= iEventGP;
					iGPArtist /= 100;

					pCapital->GetCityCitizens()->ChangeSpecialistGreatPersonProgressTimes100(eSpecialist, iGPArtist, true);

				}
				if ((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_MUSICIAN"))
				{
					iGPMusician = pCapital->GetCityCitizens()->GetSpecialistUpgradeThreshold((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass());
					iGPMusician *= 100;
					//Get % of threshold for test.
					iGPMusician *= iEventGP;
					iGPMusician /= 100;

					pCapital->GetCityCitizens()->ChangeSpecialistGreatPersonProgressTimes100(eSpecialist, iGPMusician, true);
				}
			}
		}
		if (GetID() == GC.getGame().getActivePlayer())
		{
			iGPWriter /= 100;
			iGPArtist /= 100;
			iGPMusician /= 100;
			CvNotifications* pNotification = GetNotifications();
			if (pNotification)
			{
				Localization::String strMessage = "";
				if (bConquest)
				{
					strMessage = Localization::Lookup("TXT_KEY_TOURISM_EVENT_GWAM_BONUS_CONQUEST");
					strMessage << iGPWriter;
					strMessage << iGPArtist;
					strMessage << iGPMusician;
					strMessage << strName.c_str();
				}
				else
				{
					strMessage = Localization::Lookup("TXT_KEY_TOURISM_EVENT_GWAM_BONUS_SAKOKU");
					strMessage << iGPWriter;
					strMessage << iGPArtist;
					strMessage << iGPMusician;
					strMessage << strName.c_str();
				}
				
				Localization::String strSummary = "";
				if (bConquest)
					strSummary = Localization::Lookup("TXT_KEY_TOURISM_EVENT_GWAM_BONUS_CONQUEST_S");
				else
					strSummary = Localization::Lookup("TXT_KEY_TOURISM_EVENT_GWAM_BONUS_SAKOKU_S");

				pNotification->Add(NOTIFICATION_GOLDEN_AGE_BEGUN_ACTIVE_PLAYER, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, -1);
			}
		}
	}
}
//	--------------------------------------------------------------------------------
void CvPlayer::doPolicyGEorGM(int iPolicyGEorGM)
{
	CvCity* pLoopCity;
	CvCity* pCapital = getCapitalCity();
	int iLoop;
	int iEra = GetCurrentEra();
	if (iEra < 1)
	{
		iEra = 1;
	}
	int iValue = iPolicyGEorGM * iEra;
	iValue *= GC.getGame().getGameSpeedInfo().getTrainPercent(); // Game speed mod (note that TrainPercent is a percentage value, will need to divide by 100)
	SpecialistTypes eBestSpecialist = NO_SPECIALIST;
	int iRandom = GC.getGame().getSmallFakeRandNum(100, getGlobalAverage(YIELD_CULTURE));
	if (iRandom <= 33)
	{
		eBestSpecialist = (SpecialistTypes)GC.getInfoTypeForString("SPECIALIST_ENGINEER");
	}
	else if (iRandom > 34 && iRandom <= 66)
	{
		eBestSpecialist = (SpecialistTypes)GC.getInfoTypeForString("SPECIALIST_SCIENTIST");
	}
	else if (iRandom > 66)
	{
		eBestSpecialist = (SpecialistTypes)GC.getInfoTypeForString("SPECIALIST_MERCHANT");
	}
	if (eBestSpecialist != NULL && pCapital != NULL)
	{
		CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eBestSpecialist);
		if (pkSpecialistInfo)
		{
			int iGPThreshold = pCapital->GetCityCitizens()->GetSpecialistUpgradeThreshold((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass());
			iGPThreshold *= 100;
			//Get % of threshold for test.
			iGPThreshold *= iPolicyGEorGM;
			iGPThreshold /= 100;
			int iGPThresholdString = iGPThreshold / 100;

			for (pLoopCity = this->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = this->nextCity(&iLoop))
			{
				if (eBestSpecialist == (SpecialistTypes)GC.getInfoTypeForString("SPECIALIST_ENGINEER"))
				{
					pLoopCity->changeProduction((iValue * 2) / 100); // Production yield is 2x of science. Dividing by 100 here to minimise rounding error.
				}
				else if (eBestSpecialist == (SpecialistTypes)GC.getInfoTypeForString("SPECIALIST_MERCHANT"))
				{
					this->GetTreasury()->ChangeGold((iValue * 4) / 100); // Gold yield is 4x of science, 2x of production. Dividing by 100 here to minimise rounding error.
				}
				else if (eBestSpecialist == (SpecialistTypes)GC.getInfoTypeForString("SPECIALIST_SCIENTIST"))
				{
					TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
					if (eCurrentTech == NO_TECH)
					{
						changeOverflowResearch(iValue / 100); // Dividing by 100 here to minimise rounding error.
						if (getOverflowResearch() <= 0)
						{
							setOverflowResearch(0);
						}
					}
					else
					{
						GET_TEAM(getTeam()).GetTeamTechs()->ChangeResearchProgress(eCurrentTech, (iValue / 100), GetID()); // Dividing by 100 here to minimise rounding error.
						if (GET_TEAM(getTeam()).GetTeamTechs()->GetResearchProgress(eCurrentTech) <= 0)
						{
							GET_TEAM(getTeam()).GetTeamTechs()->SetResearchProgress(eCurrentTech, 0, GetID());
						}
					}
				}
				pLoopCity->GetCityCitizens()->ChangeSpecialistGreatPersonProgressTimes100(eBestSpecialist, iGPThreshold, true);
				if (GetID() == GC.getGame().getActivePlayer()) // The popup shows the specific great person type's icon
				{
					if (eBestSpecialist == (SpecialistTypes)GC.getInfoTypeForString("SPECIALIST_ENGINEER"))
					{
						char text[256] = { 0 };

						sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_GREAT_ENGINEER]", iGPThresholdString);
						SHOW_PLOT_POPUP(pLoopCity->plot(), GetID(),  text);
						char text2[256] = { 0 };
						sprintf_s(text2, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_PRODUCTION]", (iValue * 2 / 100));
						SHOW_PLOT_POPUP(pLoopCity->plot(), GetID(),  text2);
					}
					else if (eBestSpecialist == (SpecialistTypes)GC.getInfoTypeForString("SPECIALIST_MERCHANT"))
					{
						char text[256] = { 0 };

						sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_GREAT_MERCHANT]", iGPThresholdString);
						SHOW_PLOT_POPUP(pLoopCity->plot(), GetID(),  text);
						char text2[256] = { 0 };
						sprintf_s(text2, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_GOLD]", (iValue * 4 / 100));
						SHOW_PLOT_POPUP(pLoopCity->plot(), GetID(),  text2);
					}
					else if (eBestSpecialist == (SpecialistTypes)GC.getInfoTypeForString("SPECIALIST_SCIENTIST"))
					{
						char text[256] = { 0 };

						sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_GREAT_SCIENTIST]", iGPThresholdString);
						SHOW_PLOT_POPUP(pLoopCity->plot(), GetID(),  text);
						char text2[256] = { 0 };
						sprintf_s(text2, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_RESEARCH]", (iValue / 100));
						SHOW_PLOT_POPUP(pLoopCity->plot(), GetID(),  text2);
					}
				}
			} //end of for loop
			if (GetID() == GC.getGame().getActivePlayer()) // Moved notification outside of for loop as it was flooding the screen
			{
				CvNotifications* pNotification = GetNotifications();
				if (pNotification)
				{
					CvString strMessage = GetLocalizedText("TXT_KEY_POLICY_ADOPT_GP_BONUS", iGPThresholdString);
					CvString strSummary;
					// Class specific specialist message
					if ((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_MERCHANT"))
					{
						strMessage = GetLocalizedText("TXT_KEY_POLICY_ADOPT_GP_BONUS_MERCHANT", iGPThresholdString, (iValue * 4 / 100));
					}
					else if ((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_ENGINEER"))
					{
						strMessage = GetLocalizedText("TXT_KEY_POLICY_ADOPT_GP_BONUS_ENGINEER", iGPThresholdString, (iValue * 2 / 100));
					}
					else if ((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_SCIENTIST"))
					{
						strMessage = GetLocalizedText("TXT_KEY_POLICY_ADOPT_GP_BONUS_SCIENTIST", iGPThresholdString, (iValue / 100));
					}
					strSummary = GetLocalizedText("TXT_KEY_POLICY_ADOPT_SUMMARY_GP_BONUS");
					pNotification->Add(NOTIFICATION_GOLDEN_AGE_BEGUN_ACTIVE_PLAYER, strMessage, strSummary, -1, -1, -1);
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::doInstantGreatPersonProgress(InstantYieldType iType, bool bSuppress, CvCity* pCity)
{
	CvCity* pLoopCity;
	CvCity* pCapital = getCapitalCity();
	int iLoop;
	CvString totalgpString = "";

	for (pLoopCity = this->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = this->nextCity(&iLoop))
	{
		if (pLoopCity == NULL)
			continue;

		//If we passed in a city, only check that city.
		if (pCity != NULL && pLoopCity != pCity)
			continue;

		// Puppets are not supposed to get GP points
		if (MOD_BALANCE_CORE_PUPPET_CHANGES && pLoopCity->IsPuppet())
			continue;

		CvString gpString = "";
		CvString citygpString = "";
		CvString citynameString = "";

		SpecialistTypes eSpecialist;

		for (int iGreatPersonTypes = 0; iGreatPersonTypes < GC.getNumGreatPersonInfos(); iGreatPersonTypes++)
		{
			GreatPersonTypes eGreatPerson = (GreatPersonTypes)iGreatPersonTypes;
			if (eGreatPerson == NULL || pCapital == NULL)
				continue;

			eSpecialist = (SpecialistTypes)GC.getGreatPersonInfo(eGreatPerson)->GetSpecialistType();
			if (eSpecialist == NULL)
				continue;

			// 1st step: Get the percent to progress towards the next GP
			int iValue = 0;
			switch (iType)
			{
				case INSTANT_YIELD_TYPE_POLICY_UNLOCK:
				{
					if (pLoopCity->isCapital() == true)
					{
						iValue += GetPlayerTraits()->GetGreatPersonProgressFromPolicyUnlock(eGreatPerson);
					}
					break;
				}
			}

			// 2nd step: Apply the desired amount of GP points to the loop city
			if (iValue != 0)
			{
				CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
				if (pkSpecialistInfo)
				{
					int iGPThreshold = pCapital->GetCityCitizens()->GetSpecialistUpgradeThreshold((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass());
					iGPThreshold *= 100;
					//Get % of threshold for test.
					iGPThreshold *= iValue;
					iGPThreshold /= 100;
					int iGPThresholdString = iGPThreshold / 100;
					CvGreatPersonInfo* pGreatPerson = GC.getGreatPersonInfo(eGreatPerson);
					pLoopCity->GetCityCitizens()->ChangeSpecialistGreatPersonProgressTimes100(eSpecialist, iGPThreshold, false); // Dont spawn the GP yet, so the points given to all cities remain the same
					// 3rd step: Notifications
					if (GetID() == GC.getGame().getActivePlayer() && iValue > 0)
					{
						char text[256] = { 0 };
						
						gpString.Format("%s+%%d[ENDCOLOR] %s", "[COLOR_WHITE]", pGreatPerson->GetIconString());
						sprintf_s(text, gpString, iGPThresholdString);
						SHOW_PLOT_POPUP(pLoopCity->plot(), GetID(),  text);
					}
					if (citynameString == "")
					{
						citynameString += GetLocalizedText("TXT_KEY_INSTANT_YIELD_CITY", pLoopCity->getNameKey());
					}
					if (citygpString != "")
					{
						citygpString += ", ";
					}
					citygpString += GetLocalizedText("TXT_KEY_INSTANT_GREAT_PERSON_PROGRESS_DETAILS", pGreatPerson->GetDescriptionKey(), pGreatPerson->GetIconString(), iGPThresholdString);
				}
			}
		}
		if (citynameString != "" && citygpString != "")
		{
			citynameString += citygpString;
		}
		if (totalgpString != "" && citynameString != "")
		{
			totalgpString += "[NEWLINE]";
		}
		totalgpString += citynameString;
	}
	CvNotifications* pNotifications = GetNotifications();
	if (!bSuppress && GetID() == GC.getGame().getActivePlayer() && pNotifications && totalgpString != "")
	{
		Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_GREAT_PERSON_PROGRESS");
		if (pCity != NULL)
		{
			strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_GREAT_PERSON_PROGRESS_IN_CITY");
			strSummary << pCity->getNameKey();
		}
		Localization::String localizedText;
		switch (iType)
		{
			case INSTANT_YIELD_TYPE_POLICY_UNLOCK:
			{
				/*if (getInstantGreatPersonProgressText(iType) == "" || getInstantGreatPersonProgressText(iType) == NULL) // Can't get this to work correctly for some reason
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_POLICY");
					localizedText << totalgpString;
					//We do this at the player level once per turn.
					addInstantGreatPersonProgressText(iType, localizedText.toUTF8());
				}
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_INSTANT_ADDENDUM");
					localizedText << totalgpString;
					//We do this at the player level once per turn.
					addInstantGreatPersonProgressText(iType, localizedText.toUTF8());
				}
				return;*/
				localizedText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_POLICY");
				localizedText << totalgpString;
				break;
			}
		}
		if (pCity == NULL)
		{
			if (pCapital != NULL)
			{
				pNotifications->Add((NotificationTypes)FString::Hash("NOTIFICATION_INSTANT_YIELD"), localizedText.toUTF8(), strSummary.toUTF8(), pCapital->getX(), pCapital->getY(), pCapital->GetID());
			}
		}
		else
		{
			pNotifications->Add((NotificationTypes)FString::Hash("NOTIFICATION_INSTANT_YIELD"), localizedText.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), pCity->GetID());
		}
	}
	// 4th step: Loop through all cities again to check for GP spawns
	for (pLoopCity = this->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = this->nextCity(&iLoop))
	{
		if (pLoopCity == NULL)
			continue;
		for (int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
		{
			const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iSpecialistLoop);
			CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
			if (pkSpecialistInfo)
			{
				int iCheckGPThreshold = pLoopCity->GetCityCitizens()->GetSpecialistUpgradeThreshold((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass());
				// Enough to spawn a GP?
				if (pLoopCity->GetCityCitizens()->GetSpecialistGreatPersonProgress(eSpecialist) >= iCheckGPThreshold)
				{
					// No Minors
					if (!GET_PLAYER(pLoopCity->getOwner()).isMinorCiv())
					{
						// Reset progress on this Specialist
						pLoopCity->GetCityCitizens()->DoResetSpecialistGreatPersonProgressTimes100(eSpecialist, (iCheckGPThreshold * 100));

						// Now... actually create the GP!
						const UnitClassTypes eUnitClass = (UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass();
						const CivilizationTypes eCivilization = pLoopCity->getCivilizationType();
						CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(eCivilization);
						if (pCivilizationInfo != NULL)
						{
							UnitTypes eUnit = (UnitTypes)pCivilizationInfo->getCivilizationUnits(eUnitClass);

#if defined(MOD_GLOBAL_TRULY_FREE_GP)
							pLoopCity->GetCityCitizens()->DoSpawnGreatPerson(eUnit, true, false, false);
#else
							pLoopCity->GetCityCitizens()->DoSpawnGreatPerson(eUnit, true, false);
#endif
						}
					}
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::addInstantGreatPersonProgressText(InstantYieldType iType, CvString strInstantYield)
{
	VALIDATE_OBJECT
	CvAssertMsg(iType >= 0, "iType expected to be >= 0");
	CvAssertMsg(iType < NUM_INSTANT_YIELD_TYPES, "iType expected to be < NUM_INSTANT_YIELD_TYPES");

	m_aistrInstantGreatPersonProgress.setAt(iType, m_aistrInstantGreatPersonProgress[iType] + strInstantYield);
}
void CvPlayer::setInstantGreatPersonProgressText(InstantYieldType iType, CvString strInstantYield)
{
	VALIDATE_OBJECT
	CvAssertMsg(iType >= 0, "iType expected to be >= 0");
	CvAssertMsg(iType < NUM_INSTANT_YIELD_TYPES, "iType expected to be < NUM_INSTANT_YIELD_TYPES");
	m_aistrInstantGreatPersonProgress.setAt(iType, strInstantYield);
}
CvString CvPlayer::getInstantGreatPersonProgressText(InstantYieldType iType) const
{
	VALIDATE_OBJECT
	CvAssertMsg(iType >= 0, "iType expected to be >= 0");
	CvAssertMsg(iType < NUM_INSTANT_YIELD_TYPES, "iType expected to be < NUM_INSTANT_YIELD_TYPES");
	return m_aistrInstantGreatPersonProgress[iType];
}
#endif
//	--------------------------------------------------------------------------------
/// Do effects when a GP is consumed
#if defined(MOD_EVENTS_GREAT_PEOPLE)
void CvPlayer::DoGreatPersonExpended(UnitTypes eGreatPersonUnit, CvUnit* pGreatPersonUnit)
#else
void CvPlayer::DoGreatPersonExpended(UnitTypes eGreatPersonUnit)
#endif
{
	// Gold gained
	int iExpendGold = GetGreatPersonExpendGold();
	if(iExpendGold > 0)
	{
#if defined(MOD_BALANCE_CORE)
		iExpendGold *= GC.getGame().getGameSpeedInfo().getTrainPercent();
		iExpendGold /= 100;
#endif
		GetTreasury()->ChangeGold(iExpendGold);

#if !defined(NO_ACHIEVEMENTS)
		if(isHuman() && !GC.getGame().isGameMultiPlayer() && GET_PLAYER(GC.getGame().getActivePlayer()).isLocalPlayer())
		{
			// Update Steam stat and check achievement
			const int HALICARNASSUS_ACHIEVEMENT_GOLD = 1000;
			int iHalicarnassus = GC.getInfoTypeForString("BUILDINGCLASS_MAUSOLEUM_HALICARNASSUS");
			// Does player have DLC_06, and if so, do they have the Mausoleum of Halicarnassus?
			if(iHalicarnassus != -1 && getBuildingClassCount((BuildingClassTypes)iHalicarnassus) >= 1)
			{
				BuildingTypes eHalicarnassus = (BuildingTypes)GC.getInfoTypeForString("BUILDING_MAUSOLEUM_HALICARNASSUS");
				CvBuildingEntry* pHalicarnassusInfo = GC.getBuildingInfo(eHalicarnassus);
				int iHalicarnassusGold = pHalicarnassusInfo->GetGreatPersonExpendGold();

				int32 iTotalHalicarnassusGold = 0;
				if(gDLL->GetSteamStat(ESTEAMSTAT_HALICARNASSUSGOLDEARNED, &iTotalHalicarnassusGold))
				{
					iTotalHalicarnassusGold += iHalicarnassusGold;
					gDLL->SetSteamStat(ESTEAMSTAT_HALICARNASSUSGOLDEARNED, iTotalHalicarnassusGold);
					if(iTotalHalicarnassusGold >= HALICARNASSUS_ACHIEVEMENT_GOLD)
					{
						gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_HALICARNASSUS_GOLD);
					}
				}
			}
		}
#endif
	}

	if (pGreatPersonUnit)
	{
		//admiral grants a resource
		for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
		{
			int Gained = pGreatPersonUnit->getUnitInfo().GetResourceQuantityExpended((ResourceTypes)iResourceLoop);
			if (Gained != 0)
				changeNumResourceTotal((ResourceTypes)iResourceLoop, Gained);
		}

		//general grants supply points
		int iSupply = pGreatPersonUnit->getUnitInfo().GetSupplyCapBoost() + pGreatPersonUnit->GetMilitaryCapChange();
		if (iSupply > 0 && getCapitalCity() != NULL)
		{
			getCapitalCity()->changeCitySupplyFlat(iSupply);
			m_iNumUnitsSuppliedCached = -1; //force recalculation

			if (GetID() == GC.getGame().getActivePlayer())
			{
				char text[256] = { 0 };

				sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_WAR]", iSupply);
				SHOW_PLOT_POPUP( pGreatPersonUnit->plot(), GetID(), text);

				CvNotifications* pNotification = GetNotifications();
				if (pNotification)
				{
					CvString strMessage;
					CvString strSummary;
					strMessage = GetLocalizedText("TXT_KEY_UNIT_EXPENDED_SUPPLY", getNameKey(), iSupply);
					strSummary = GetLocalizedText("TXT_KEY_UNIT_EXPENDED_SUPPLY_S");
					pNotification->Add(NOTIFICATION_GENERIC, strMessage, strSummary, pGreatPersonUnit->getX(), pGreatPersonUnit->getY(), GetID());
				}
			}
		}
	}

#if defined(MOD_API_UNIFIED_YIELDS)
#else
	// Faith gained
	ReligionTypes eReligionFounded = GetReligions()->GetReligionCreatedByPlayer();
	if(eReligionFounded > RELIGION_PANTHEON)
	{
		const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eReligionFounded, GetID());
		if(pReligion)
		{
			int iFaith = pReligion->m_Beliefs.GetGreatPersonExpendedFaith();
			if(iFaith > 0)
			{
				iFaith *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iFaith /= 100;
				ChangeFaith(iFaith);
			}
#if defined(MOD_BALANCE_CORE_BELIEFS)
			int iEra = GetCurrentEra();
			if(iEra < 1)
			{
				iEra = 1;
			}
			int iCulture = pReligion->m_Beliefs.GetYieldFromGPUse(YIELD_CULTURE) * iEra;
			if(iCulture > 0)
			{
				changeJONSCulture(iCulture);
				if(GetID() == GC.getGame().getActivePlayer())
				{
					char text[256] = {0};
					
					sprintf_s(text, "[COLOR_MAGENTA]+%d[ENDCOLOR][ICON_CULTURE]", iCulture);
					DLLUI->AddPopupText(pGreatPersonUnit->getX(),pGreatPersonUnit->getY(), text);
				}
			}
			int iFaith2 = pReligion->m_Beliefs.GetYieldFromGPUse(YIELD_FAITH) * iEra;
			if(iFaith2 > 0)
			{
				ChangeFaith(iFaith2);
				if(GetID() == GC.getGame().getActivePlayer())
				{
					char text[256] = {0};
					
					sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_PEACE]", iFaith2);
					DLLUI->AddPopupText(pGreatPersonUnit->getX(),pGreatPersonUnit->getY(), text);
				}
			}
			int iGold = pReligion->m_Beliefs.GetYieldFromGPUse(YIELD_GOLD) * iEra;
			if(iGold > 0)
			{
				GetTreasury()->ChangeGold(iGold);
				if(GetID() == GC.getGame().getActivePlayer())
				{
					char text[256] = {0};
					
					sprintf_s(text, "[COLOR_YELLOW]+%d[ENDCOLOR][ICON_GOLD]", iGold);
					DLLUI->AddPopupText(pGreatPersonUnit->getX(),pGreatPersonUnit->getY(), text);
				}
			}
			int iScience = pReligion->m_Beliefs.GetYieldFromGPUse(YIELD_SCIENCE) * iEra;
			if(iScience > 0)
			{
				TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
				if(eCurrentTech == NO_TECH)
				{
					changeOverflowResearch(iScience);
				}
				else
				{
					GET_TEAM(GET_PLAYER(GetID()).getTeam()).GetTeamTechs()->ChangeResearchProgress(eCurrentTech, iScience, GetID());
				}
				if(GetID() == GC.getGame().getActivePlayer())
				{
					char text[256] = {0};
					
					sprintf_s(text, "[COLOR_BLUE]+%d[ENDCOLOR][ICON_RESEARCH]", iScience);
					DLLUI->AddPopupText(pGreatPersonUnit->getX(),pGreatPersonUnit->getY(), text);
				}
			}
			int iGA = pReligion->m_Beliefs.GetYieldFromGPUse(YIELD_GOLDEN_AGE_POINTS) * iEra;
			if(iGA > 0)
			{
				ChangeGoldenAgeProgressMeter(iGA);
				if(GetID() == GC.getGame().getActivePlayer())
				{
					char text[256] = {0};
					
					sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_GOLDEN_AGE]", iGA);
					DLLUI->AddPopupText(pGreatPersonUnit->getX(),pGreatPersonUnit->getY(), text);
				}
			}
#endif
		}
	}
#endif

#if defined(MOD_BALANCE_CORE_POLICIES) || defined(MOD_DIPLOMACY_CITYSTATES)
	//Influence Gained with all CS per expend
	int iExpendInfluence = GetInfluenceGPExpend() + GetGPExpendInfluence(); 
	if(iExpendInfluence > 0)
	{
		for (int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
		{
			PlayerTypes eMinorLoop = (PlayerTypes) iMinorLoop;
			if(eMinorLoop != NO_PLAYER)
			{
				CvPlayer* pMinorLoop = &GET_PLAYER(eMinorLoop);
				if(pMinorLoop->isMinorCiv() && pMinorLoop->isAlive())
				{
					if(GET_TEAM(pMinorLoop->getTeam()).isHasMet(getTeam()))
					{
						pMinorLoop->GetMinorCivAI()->ChangeFriendshipWithMajor(GetID(), iExpendInfluence, false);
					}
				}
			}
		}
	}
	GreatPersonTypes eGreatPerson = GetGreatPersonFromUnitClass(pGreatPersonUnit->getUnitClassType());
	doInstantYield(INSTANT_YIELD_TYPE_GP_USE, false, eGreatPerson);
#endif

#if defined(MOD_EVENTS_GREAT_PEOPLE)
	if (MOD_EVENTS_GREAT_PEOPLE) {
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_GreatPersonExpended, GetID(), pGreatPersonUnit->GetID(), eGreatPersonUnit, pGreatPersonUnit->getX(), pGreatPersonUnit->getY());
	} else {
#endif
	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if (pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());
		args->Push(eGreatPersonUnit);

		bool bResult;
		LuaSupport::CallHook(pkScriptSystem, "GreatPersonExpended", args.get(), bResult);
	}
#if defined(MOD_EVENTS_GREAT_PEOPLE)
	}
#endif
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetGreatPersonExpendGold() const
{
	return m_iGreatPersonExpendGold;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeGreatPersonExpendGold(int ichange)
{
	m_iGreatPersonExpendGold += ichange;
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
//	Calculate score-scaled ArtsyGreatPersonRateModifier
int CvPlayer::getArtsyGreatPersonRateModifier()
{
	int iArtsyMod = GC.getGame().GetGameLeagues()->GetArtsyGreatPersonRateModifier(GetID());
	if(iArtsyMod == 0) return 0;
	// scale GPP the same way as yields; tricky part is for negatives!
	if(iArtsyMod > 0)
		iArtsyMod *= ScoreDifferencePercent(1);
	else
		iArtsyMod *= (100-ScoreDifferencePercent(1));
	iArtsyMod /= 100;
	return iArtsyMod;
}
//	Calculate score-scaled ScienceyGreatPersonRateModifier
int CvPlayer::getScienceyGreatPersonRateModifier()
{
	int iScienceyMod = GC.getGame().GetGameLeagues()->GetScienceyGreatPersonRateModifier(GetID());
	if(iScienceyMod == 0) return 0;
	// scale GPP the same way as yields; tricky part is for negatives!
	if(iScienceyMod > 0)
		iScienceyMod *= ScoreDifferencePercent(2);
	else
		iScienceyMod *= (100-ScoreDifferencePercent(2));
	iScienceyMod /= 100;
	return iScienceyMod;
}
#endif

//	--------------------------------------------------------------------------------
void CvPlayer::recomputeGreatPeopleModifiers()
{
	//=============
	// Initialize
	//=============
	m_iGreatPeopleRateModifier = 0;
	m_iGreatGeneralRateModifier = 0;
	m_iGreatAdmiralRateModifier = 0;
	m_iGreatWriterRateModifier = 0;
	m_iGreatArtistRateModifier = 0;
	m_iGreatMusicianRateModifier = 0;
	m_iGreatMerchantRateModifier = 0;
#if defined(MOD_DIPLOMACY_CITYSTATES)
	m_iGreatDiplomatRateModifier = 0;
#endif
	m_iGreatScientistRateModifier = 0;
	m_iGreatEngineerRateModifier = 0;
	m_iDomesticGreatGeneralRateModifier = 0;

	// Get from traits first
	m_iGreatPeopleRateModifier += m_pTraits->GetGreatPeopleRateModifier();
	m_iGreatGeneralRateModifier += m_pTraits->GetGreatGeneralRateModifier();
	m_iGreatScientistRateModifier += m_pTraits->GetGreatScientistRateModifier();
#if defined(MOD_BALANCE_CORE)
	m_iGreatGeneralRateModifier += (m_pTraits->GetGGGARateFromDenunciationsAndWars()) * (GetDiplomacyAI()->GetNumDenouncements() + GET_TEAM(getTeam()).getAtWarCount(true));
	m_iGreatAdmiralRateModifier += (m_pTraits->GetGGGARateFromDenunciationsAndWars()) * (GetDiplomacyAI()->GetNumDenouncements() + GET_TEAM(getTeam()).getAtWarCount(true));
#endif

	// Then get from current policies
	m_iGreatPeopleRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_PERSON_RATE);
	m_iGreatGeneralRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_GENERAL_RATE);
	m_iGreatAdmiralRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_ADMIRAL_RATE);
	m_iGreatWriterRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_WRITER_RATE);
	m_iGreatArtistRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_ARTIST_RATE);
	m_iGreatMusicianRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_MUSICIAN_RATE);
	m_iGreatMerchantRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_MERCHANT_RATE);
#if defined(MOD_BALANCE_CORE)
	m_iGreatEngineerRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_ENGINEER_RATE);
#endif
#if defined(MOD_DIPLOMACY_CITYSTATES)
	if (MOD_DIPLOMACY_CITYSTATES) {
		m_iGreatDiplomatRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_DIPLOMAT_RATE);
	}
#endif
	m_iGreatScientistRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_GREAT_SCIENTIST_RATE);
	m_iDomesticGreatGeneralRateModifier += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_DOMESTIC_GREAT_GENERAL_RATE);

	// Next add in buildings
	m_iGreatPeopleRateModifier += m_iGreatPeopleRateModFromBldgs;
	m_iGreatGeneralRateModifier += m_iGreatGeneralRateModFromBldgs;
	m_iDomesticGreatGeneralRateModifier += m_iDomesticGreatGeneralRateModFromBldgs;

	// Finally anything from friendships
	m_iGreatPeopleRateModifier += GetGreatPeopleRateModFromFriendships();

	// And effects from Leagues
#if defined(MOD_BALANCE_CORE)
	int iArtsyMod = getArtsyGreatPersonRateModifier();
	int iScienceyMod = getScienceyGreatPersonRateModifier();
#else
	int iArtsyMod = GC.getGame().GetGameLeagues()->GetArtsyGreatPersonRateModifier(GetID());
	int iScienceyMod = GC.getGame().GetGameLeagues()->GetScienceyGreatPersonRateModifier(GetID());
#endif
	if (iArtsyMod != 0)
	{
		m_iGreatWriterRateModifier += iArtsyMod;
		m_iGreatArtistRateModifier += iArtsyMod;
		m_iGreatMusicianRateModifier += iArtsyMod;
	}
	if (iScienceyMod != 0)
	{
		m_iGreatScientistRateModifier += iScienceyMod;
		m_iGreatEngineerRateModifier += iScienceyMod;
		m_iGreatMerchantRateModifier += iScienceyMod;
	}

	// Finally boost domestic general from combat experience
	m_iDomesticGreatGeneralRateModifier += GC.getCOMBAT_EXPERIENCE_IN_BORDERS_PERCENT();
}

//	--------------------------------------------------------------------------------
// Do we have a trait that rewards friendships (or have a friend that does)?
int CvPlayer::GetGreatPeopleRateModFromFriendships() const
{
	int iRtnValue = 0;
	int iTraitMod = GetPlayerTraits()->GetDOFGreatPersonModifier();

	// Have the trait, one for each friend
	if(iTraitMod > 0)
	{
		iRtnValue = GetDiplomacyAI()->GetNumDoF() * iTraitMod;
	}

	// Don't have the trait, just get bonus once if friends with a player that does
	else
	{
		PlayerTypes eLoopPlayer;
		for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			eLoopPlayer = (PlayerTypes) iPlayerLoop;

			if(GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))
			{
				if(GetDiplomacyAI()->IsDoFAccepted(eLoopPlayer))
				{
					int iOthersTraitMod = GET_PLAYER(eLoopPlayer).GetPlayerTraits()->GetDOFGreatPersonModifier();
					if(iOthersTraitMod > 0)
					{
						iRtnValue += iOthersTraitMod;
					}
				}
			}
		}
	}

	return iRtnValue;
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
int CvPlayer::GetGreatScientistBeakerMod() const
{
	return m_iGreatScientistBeakerModifier;
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
void CvPlayer::SetGreatScientistBeakerMod(int iValue)
{
	m_iGreatScientistBeakerModifier = iValue;
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
void CvPlayer::ChangeGreatScientistBeakerMod(int iChange)
{
	SetGreatScientistBeakerMod(GetGreatScientistBeakerMod() + iChange);
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
int CvPlayer::GetGreatEngineerHurryMod() const
{
	return m_iGreatEngineerHurryMod;
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
void CvPlayer::SetGreatEngineerHurryMod(int iValue)
{
	m_iGreatEngineerHurryMod = iValue;
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
void CvPlayer::ChangeGreatEngineerHurryMod(int iChange)
{
	SetGreatEngineerHurryMod(GetGreatEngineerHurryMod() + iChange);
}


//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
int CvPlayer::GetTechCostXCitiesModifier() const
{
	return m_iTechCostXCitiesModifier;
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
void CvPlayer::SetTechCostXCitiesModifier(int iValue)
{
	m_iTechCostXCitiesModifier = iValue;
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
void CvPlayer::ChangeTechCostXCitiesModifier(int iChange)
{
	SetTechCostXCitiesModifier(GetTechCostXCitiesModifier() + iChange);
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
int CvPlayer::GetTourismCostXCitiesMod() const
{
	return m_iTourismCostXCitiesMod;
}

//	--------------------------------------------------------------------------------
// Do we get extra beakers from using Great Scientists?
void CvPlayer::ChangeTourismCostXCitiesMod(int iChange)
{
	m_iTourismCostXCitiesMod += iChange;
}



//////////////////////////////////////////////////////////////////////////
int CvPlayer::GetGreatGeneralCombatBonus() const
{
	return m_iGreatGeneralCombatBonus;
}

//////////////////////////////////////////////////////////////////////////
void CvPlayer::SetGreatGeneralCombatBonus(int iValue)
{
	m_iGreatGeneralCombatBonus = iValue;
}

void CvPlayer::ChangeGreatGeneralCombatBonus(int iValue)
{
	m_iGreatGeneralCombatBonus += iValue;
}


//////////////////////////////////////////////////////////////////////////
// ***** Great People Spawning *****
//////////////////////////////////////////////////////////////////////////

//	--------------------------------------------------------------------------------
// Figures out how long before we spawn a free Great Person for ePlayer
void CvPlayer::DoSeedGreatPeopleSpawnCounter()
{
	int iNumTurns = /*37*/ GC.getMINOR_TURNS_GREAT_PEOPLE_SPAWN_BASE();

	// Start at -1 since if we only have one ally we don't want to add any more
	int iExtraAllies = -1;

	PlayerTypes eMinor;
	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		eMinor = (PlayerTypes) iMinorLoop;

		// Not alive
		if(!GET_PLAYER(eMinor).isAlive())
			continue;

		if(GET_PLAYER(eMinor).GetMinorCivAI()->GetAlly() == GetID())
			iExtraAllies++;
	}

	if(iExtraAllies > 0)
	{
		int iExtraAlliesChange = iExtraAllies* /*-1*/ GC.getMINOR_ADDITIONAL_ALLIES_GP_CHANGE();

		iExtraAlliesChange = max(/*-10*/ GC.getMAX_MINOR_ADDITIONAL_ALLIES_GP_CHANGE(), iExtraAlliesChange);

		iNumTurns += iExtraAlliesChange;
	}

	int iRand = /*7*/ GC.getMINOR_TURNS_GREAT_PEOPLE_SPAWN_RAND();
	iNumTurns += GC.getGame().getSmallFakeRandNum(iRand, getGlobalAverage(YIELD_CULTURE));

	// If we're biasing the result then decrease the number of turns
	if(!IsAlliesGreatPersonBiasApplied())
	{
		iNumTurns *= /*50*/ GC.getMINOR_TURNS_GREAT_PEOPLE_SPAWN_BIAS_MULTIPLY();
		iNumTurns /= 100;

		SetAlliesGreatPersonBiasApplied(true);
	}

	// Modify for Game Speed
	iNumTurns *= GC.getGame().getGameSpeedInfo().getGreatPeoplePercent();
	iNumTurns /= 100;

	if(iNumTurns < 1)
		iNumTurns = 1;

	SetGreatPeopleSpawnCounter(iNumTurns);
}

//	--------------------------------------------------------------------------------
/// We're now allies with someone, what happens with the GP bonus?
void CvPlayer::DoApplyNewAllyGPBonus()
{
	int iChange = /*-2*/ GC.getMINOR_ADDITIONAL_ALLIES_GP_CHANGE();
	ChangeGreatPeopleSpawnCounter(iChange);

	if(GetGreatPeopleSpawnCounter() < 1)
		SetGreatPeopleSpawnCounter(1);
}

//	--------------------------------------------------------------------------------
// How long before we spawn a free GreatPeople for ePlayer?
int CvPlayer::GetGreatPeopleSpawnCounter()
{
	return m_iGreatPeopleSpawnCounter;
}

//	--------------------------------------------------------------------------------
// Sets how long before we spawn a free GreatPeople for ePlayer
void CvPlayer::SetGreatPeopleSpawnCounter(int iValue)
{
	m_iGreatPeopleSpawnCounter = iValue;
}

//	--------------------------------------------------------------------------------
// Changes how long before we spawn a free GreatPeople for ePlayer
void CvPlayer::ChangeGreatPeopleSpawnCounter(int iChange)
{
	SetGreatPeopleSpawnCounter(GetGreatPeopleSpawnCounter() + iChange);
}

//	--------------------------------------------------------------------------------
/// Create a GreatPeople
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
void CvPlayer::DoSpawnGreatPerson(PlayerTypes eMinor, bool bIsFree)
#else
void CvPlayer::DoSpawnGreatPerson(PlayerTypes eMinor)
#endif
{
	CvAssertMsg(eMinor >= MAX_MAJOR_CIVS, "eMinor is expected to be non-negative (invalid Index)");
	CvAssertMsg(eMinor < MAX_CIV_PLAYERS, "eMinor is expected to be within maximum bounds (invalid Index)");

	// Minor must have Capital
	CvCity* pMinorCapital = GET_PLAYER(eMinor).getCapitalCity();
	if(pMinorCapital == NULL)
	{
		FAssertMsg(false, "MINOR CIV AI: Trying to spawn a GreatPeople for a major civ but the minor has no capital. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
		return;
	}
	// Capital must have a plot
	CvPlot* pMinorPlot = pMinorCapital->plot();
	if(pMinorPlot == NULL)
	{
		CvAssertMsg(false, "Plot for minor civ's capital not found! Please send Anton your save file and version.");
		return;
	}

	// Note: this is the same transport method (though without a delay) as a Militaristic city-state gifting a unit
	CvCity* pMajorCity = GetClosestCityByEstimatedTurns(pMinorPlot);
	if (pMajorCity == NULL && getCapitalCity() != NULL)
	{
		pMajorCity = getCapitalCity();
	}
	int iX = pMinorCapital->getX();
	int iY = pMinorCapital->getY();
	if(pMajorCity != NULL)
	{
		iX = pMajorCity->getX();
		iY = pMajorCity->getY();
	}

	// Pick Great Person type
	UnitTypes eBestUnit = NO_UNIT;
	int iBestScore = -1;
	SpecialUnitTypes eSpecialUnitGreatPerson = (SpecialUnitTypes) GC.getInfoTypeForString("SPECIALUNIT_PEOPLE");

	for(int iUnitLoop = 0; iUnitLoop < GC.getNumUnitInfos(); iUnitLoop++)
	{
		UnitTypes eLoopUnit = (UnitTypes)iUnitLoop;
		CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eLoopUnit);

		if(pkUnitEntry && pkUnitEntry->GetSpecialUnitType() == eSpecialUnitGreatPerson)
		{
			// No prophets
			if(!pkUnitEntry->IsFoundReligion())
			{
				int iScore = GC.getGame().getSmallFakeRandNum(100, getGlobalAverage(YIELD_CULTURE) + iX + iY);

				if(iScore > iBestScore)
				{
					iBestScore = iScore;
					eBestUnit = eLoopUnit;
				}
			}
		}
	}

	// Spawn GreatPeople
	if(eBestUnit != NO_UNIT)
	{
		CvUnit* pNewGreatPeople = initUnit(eBestUnit, iX, iY);
		CvAssert(pNewGreatPeople);

		if (pNewGreatPeople)
		{
#if defined(MOD_BALANCE_CORE)
			if (GetPlayerTraits()->IsGPWLTKD())
			{
				CvCity* pCity = pNewGreatPeople->plot()->getOwningCity();
				if (pCity != NULL && pCity->getOwner() == GetID())
				{
					int iWLTKD = (GC.getCITY_RESOURCE_WLTKD_TURNS() / 3);

					iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
					iWLTKD /= 100;

					if (iWLTKD > 0)
					{
						pCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
						CvNotifications* pNotifications = GetNotifications();
						if (pNotifications)
						{
							Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UA");
							strText << pNewGreatPeople->getNameKey() << pCity->getNameKey();
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UA");
							strSummary << pCity->getNameKey();
							pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), -1);
						}
					}
				}
			}
			if(pNewGreatPeople->isWLKTKDOnBirth())
			{
				CvCity* pLoopCity;
				int iLoop;
				for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
				{
					if(pLoopCity != NULL && pLoopCity->getOwner() == GetID())
					{
						int iWLTKD = (GC.getCITY_RESOURCE_WLTKD_TURNS() / 3);

						iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
						iWLTKD /= 100;

						if (iWLTKD > 0)
						{
							pLoopCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
							CvNotifications* pNotifications = GetNotifications();
							if (pNotifications)
							{
								Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UNIT");
								strText << pNewGreatPeople->getNameKey() << pLoopCity->getNameKey();
								Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UNIT");
								strSummary << pLoopCity->getNameKey();
								pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pLoopCity->getX(), pLoopCity->getY(), -1);
							}
						}
					}
				}
			}
			if(pNewGreatPeople->isGoldenAgeOnBirth())
			{
				int iGoldenAgeTurns = getGoldenAgeLength();
				int iValue = GetGoldenAgeProgressMeter();
				changeGoldenAgeTurns(iGoldenAgeTurns, iValue);
			}
			if(pNewGreatPeople->isCultureBoost())
			{
				int iValue = GetTotalJONSCulturePerTurn() * 4;
				changeJONSCulture(iValue);
				if(getCapitalCity() != NULL)
				{
					getCapitalCity()->ChangeJONSCultureStored(iValue);
				}
				CvNotifications* pNotifications = GetNotifications();
				if (pNotifications)
				{
					Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CULTURE_UNIT");
					strText << pNewGreatPeople->getNameKey();
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CULTURE_UNIT");
					strSummary << pNewGreatPeople->getNameKey();
					pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pNewGreatPeople->getX(), pNewGreatPeople->getY(), -1);
				}
			}
#endif
			// Bump up the count
			if(pNewGreatPeople->IsGreatGeneral())
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGreatGeneralsCreated(bIsFree);
#else
				incrementGreatGeneralsCreated();
#endif
			}
			else if(pNewGreatPeople->IsGreatAdmiral())
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGreatAdmiralsCreated(bIsFree);
#else
				incrementGreatAdmiralsCreated();
#endif
			}
			else if (pNewGreatPeople->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_WRITER"))
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGreatWritersCreated(bIsFree);
#else
				incrementGreatWritersCreated();
#endif
			}							
			else if (pNewGreatPeople->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_ARTIST"))
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGreatArtistsCreated(bIsFree);
#else
				incrementGreatArtistsCreated();
#endif
			}							
			else if (pNewGreatPeople->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_MUSICIAN"))
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGreatMusiciansCreated(bIsFree);
#else
				incrementGreatMusiciansCreated();
#endif
			}
#if defined(MOD_DIPLOMACY_CITYSTATES)
			else if (MOD_DIPLOMACY_CITYSTATES && pNewGreatPeople->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_GREAT_DIPLOMAT"))
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGreatDiplomatsCreated(bIsFree);
#else
				incrementGreatDiplomatsCreated();
#endif
			}
#endif
#if defined(MOD_BALANCE_CORE)
			else if (pNewGreatPeople->getUnitInfo().IsGPExtra() == 1)
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGPExtra1Created(bIsFree);
#else
				incrementGPExtra1Created();
#endif
			}
			else if (pNewGreatPeople->getUnitInfo().IsGPExtra() == 2)
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGPExtra2Created(bIsFree);
#else
				incrementGPExtra2Created();
#endif
			}
			else if (pNewGreatPeople->getUnitInfo().IsGPExtra() == 3)
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGPExtra3Created(bIsFree);
#else
				incrementGPExtra3Created();
#endif
			}
			else if (pNewGreatPeople->getUnitInfo().IsGPExtra() == 4)
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGPExtra4Created(bIsFree);
#else
				incrementGPExtra4Created();
#endif
			}
			else if (pNewGreatPeople->getUnitInfo().IsGPExtra() == 5)
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				incrementGPExtra5Created(bIsFree);
#else
				incrementGPExtra5Created();
#endif
			}
#endif
			else
			{
#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
				if (MOD_GLOBAL_SEPARATE_GP_COUNTERS)
				{
					if (pNewGreatPeople->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_MERCHANT"))
					{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
						incrementGreatMerchantsCreated(bIsFree);
#else
						incrementGreatMerchantsCreated();
#endif
					}
					else if (pNewGreatPeople->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_SCIENTIST"))
					{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
						incrementGreatScientistsCreated(bIsFree);
#else
						incrementGreatScientistsCreated();
#endif
					}
					else
					{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
						incrementGreatEngineersCreated(bIsFree);
#else
						incrementGreatEngineersCreated();
#endif
					}
				}
				else
#endif
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
					incrementGreatPeopleCreated(bIsFree);
#else
					incrementGreatPeopleCreated();
#endif
			}

			if (pNewGreatPeople->IsGreatAdmiral())
			{
				CvPlot* pSpawnPlot = GetGreatAdmiralSpawnPlot(pNewGreatPeople);
				if (pNewGreatPeople->plot() != pSpawnPlot && pSpawnPlot != NULL)
				{
					pNewGreatPeople->setXY(pSpawnPlot->getX(), pSpawnPlot->getY());
				}
			}
			else
			{
				if (!pNewGreatPeople->jumpToNearestValidPlot())
					pNewGreatPeople->kill(false);	// Could not find a spot!
			}

			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_STATE_UNIT_SPAWN");
				strMessage << GET_PLAYER(eMinor).getNameKey();
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_STATE_UNIT_SPAWN");
				strSummary << GET_PLAYER(eMinor).getNameKey();
				pNotifications->Add(NOTIFICATION_MINOR, strMessage.toUTF8(), strSummary.toUTF8(), iX, iY, eMinor);
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Time to spawn a GreatPeople?
void CvPlayer::DoGreatPeopleSpawnTurn()
{
	// Tick down
	if(GetGreatPeopleSpawnCounter() > 0)
	{
		AI_PERF_FORMAT("AI-perf.csv", ("CvPlayer::DoGreatPeopleSpawnTurn, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), getCivilizationShortDescription()) );
		ChangeGreatPeopleSpawnCounter(-1);

		// Time to spawn! - Pick a random allied minor
		if(GetGreatPeopleSpawnCounter() == 0)
		{
			PlayerTypes eBestMinor = NO_PLAYER;
			int iBestScore = -1;
			int iScore;

			PlayerTypes eMinor;
			for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
			{
				eMinor = (PlayerTypes) iMinorLoop;

				// Not alive
				if(!GET_PLAYER(eMinor).isAlive())
					continue;

				// Not an ally
				if(GET_PLAYER(eMinor).GetMinorCivAI()->GetAlly() != GetID())
					continue;

				iScore = GC.getGame().getSmallFakeRandNum(100, getGlobalAverage(YIELD_CULTURE) + iMinorLoop);

				// Best ally yet?
				if(eBestMinor == NO_PLAYER || iScore > iBestScore)
				{
					eBestMinor = eMinor;
					iBestScore = iScore;
				}
			}

			if(eBestMinor != NO_PLAYER)
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				DoSpawnGreatPerson(eBestMinor, MOD_GLOBAL_TRULY_FREE_GP);
#else
				DoSpawnGreatPerson(eBestMinor);
#endif

			// Reseed counter
			DoSeedGreatPeopleSpawnCounter();
		}
	}
}

//	--------------------------------------------------------------------------------
CvCity* CvPlayer::GetGreatPersonSpawnCity(UnitTypes eUnit)
{
	CvCity* pBestCity = getCapitalCity();
	CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eUnit);

	if(pkUnitEntry && pkUnitEntry->GetDomainType() == DOMAIN_SEA)
	{
		int iBestValue = INT_MAX;
		int iLoop;
		for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(!pLoopCity->isCoastal())
			{
				continue;
			}

			int iValue = 4 * GC.getGame().getSmallFakeRandNum(getNumCities(), getGlobalAverage(YIELD_CULTURE) + iLoop);

			for(int i = 0; i < NUM_YIELD_TYPES; i++)
			{
				iValue += pLoopCity->findYieldRateRank((YieldTypes)i);
			}
			iValue += pLoopCity->findPopulationRank();

			if(iValue < iBestValue)
			{
				pBestCity = pLoopCity;
				iBestValue = iValue;
			}
		}
	}

	return pBestCity;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getMaxGlobalBuildingProductionModifier() const
{
	return m_iMaxGlobalBuildingProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMaxGlobalBuildingProductionModifier(int iChange)
{
	m_iMaxGlobalBuildingProductionModifier = (m_iMaxGlobalBuildingProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getMaxTeamBuildingProductionModifier() const
{
	return m_iMaxTeamBuildingProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMaxTeamBuildingProductionModifier(int iChange)
{
	m_iMaxTeamBuildingProductionModifier = (m_iMaxTeamBuildingProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getMaxPlayerBuildingProductionModifier() const
{
	return m_iMaxPlayerBuildingProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMaxPlayerBuildingProductionModifier(int iChange)
{
	m_iMaxPlayerBuildingProductionModifier = (m_iMaxPlayerBuildingProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getFreeExperience() const
{
	return m_iFreeExperience;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeFreeExperienceFromBldgs(int iChange)
{
	m_iFreeExperienceFromBldgs += iChange;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeFreeExperienceFromMinors(int iChange)
{
	m_iFreeExperienceFromMinors += iChange;
}

//	--------------------------------------------------------------------------------
void CvPlayer::recomputeFreeExperience()
{
	m_iFreeExperience = m_iFreeExperienceFromBldgs;
	m_iFreeExperience = m_iFreeExperienceFromMinors;
	m_iFreeExperience += m_pPlayerPolicies->GetNumericModifier(POLICYMOD_FREE_EXPERIENCE);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getFeatureProductionModifier() const
{
	return m_iFeatureProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeFeatureProductionModifier(int iChange)
{
	m_iFeatureProductionModifier = (m_iFeatureProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getWorkerSpeedModifier() const
{
	return m_iWorkerSpeedModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeWorkerSpeedModifier(int iChange)
{
	m_iWorkerSpeedModifier = (m_iWorkerSpeedModifier + iChange);
}

#if defined(MOD_CIV6_WORKER)
//	--------------------------------------------------------------------------------
int  CvPlayer::GetImprovementBuilderCost(BuildTypes iBuild) const
{
	//get the build
	if (iBuild >= 0 && iBuild < GC.getNumBuildInfos())
	{
		CvBuildInfo* pkBuildInfo = GC.getBuildInfo((BuildTypes)iBuild);
		int buildercost = pkBuildInfo->getBuilderCost();

		//if road, use RouteBuilderCostMod
		if (pkBuildInfo->getRoute() != NO_ROUTE)
		{
			buildercost *= 100 + GetRouteBuilderCostMod();
			buildercost /= 100;
		}

		return buildercost;
	}
	return 0;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getImprovementCostModifier() const
{
	return m_iImprovementCostModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeImprovementCostModifier(int iChange)
{
	m_iImprovementCostModifier = (m_iImprovementCostModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getImprovementUpgradeRateModifier() const
{
	return m_iImprovementUpgradeRateModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeImprovementUpgradeRateModifier(int iChange)
{
	m_iImprovementUpgradeRateModifier = (m_iImprovementUpgradeRateModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getSpecialistProductionModifier() const
{
	return m_iSpecialistProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeSpecialistProductionModifier(int iChange)
{
	m_iSpecialistProductionModifier = (m_iSpecialistProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getMilitaryProductionModifier() const
{
	return m_iMilitaryProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMilitaryProductionModifier(int iChange)
{
	m_iMilitaryProductionModifier = (m_iMilitaryProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getSpaceProductionModifier() const
{
	return m_iSpaceProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeSpaceProductionModifier(int iChange)
{
	m_iSpaceProductionModifier = (m_iSpaceProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getCityDefenseModifier() const
{
	return m_iCityDefenseModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeCityDefenseModifier(int iChange)
{
	m_iCityDefenseModifier = (m_iCityDefenseModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getUnitFortificationModifier() const
{
	return m_iUnitFortificationModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeUnitFortificationModifier(int iChange)
{
	m_iUnitFortificationModifier = (m_iUnitFortificationModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getUnitBaseHealModifier() const
{
	return m_iUnitBaseHealModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeUnitBaseHealModifier(int iChange)
{
	m_iUnitBaseHealModifier = (m_iUnitBaseHealModifier + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getWonderProductionModifier() const
{
	return m_iWonderProductionModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeWonderProductionModifier(int iChange)
{
	m_iWonderProductionModifier = (m_iWonderProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getSettlerProductionModifier() const
{
	return m_iSettlerProductionModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeSettlerProductionModifier(int iChange)
{
	m_iSettlerProductionModifier = (m_iSettlerProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getCapitalSettlerProductionModifier() const
{
	return m_iCapitalSettlerProductionModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeCapitalSettlerProductionModifier(int iChange)
{
	m_iCapitalSettlerProductionModifier = (m_iCapitalSettlerProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::GetPolicyCostBuildingModifier() const
{
	return m_iPolicyCostBuildingModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangePolicyCostBuildingModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iPolicyCostBuildingModifier = (m_iPolicyCostBuildingModifier + iChange);

		recomputePolicyCostModifier();
		DoUpdateNextPolicyCost();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetPolicyCostMinorCivModifier() const
{
	return m_iPolicyCostMinorCivModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangePolicyCostMinorCivModifier(int iChange)
{
	m_iPolicyCostMinorCivModifier = (m_iPolicyCostMinorCivModifier + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetInfluenceSpreadModifier() const
{
	return m_iInfluenceSpreadModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeInfluenceSpreadModifier(int iChange)
{
	m_iInfluenceSpreadModifier = (m_iInfluenceSpreadModifier + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetExtraVotesPerDiplomat() const
{
	return m_iExtraVotesPerDiplomat;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeExtraVotesPerDiplomat(int iChange)
{
	m_iExtraVotesPerDiplomat += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNumNukeUnits() const
{
	return m_iNumNukeUnits;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeNumNukeUnits(int iChange)
{
	m_iNumNukeUnits = (m_iNumNukeUnits + iChange);
	CvAssert(getNumNukeUnits() >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getNumOutsideUnits()
{
	int iOutsideUnitCount = 0;

	CvUnit* pLoopUnit;
	int iLoop;
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->plot() != NULL)
		{
			if(pLoopUnit->plot()->getOwner() != pLoopUnit->getOwner())
			{
				iOutsideUnitCount++;
			}
		}
	}

	return iOutsideUnitCount;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeNumOutsideUnits(int iChange)
{
	if(iChange != 0)
	{
		m_iNumOutsideUnits += iChange;
		CvAssert(getNumOutsideUnits() >= 0);

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getBaseFreeUnits() const
{
	return m_iBaseFreeUnits;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeBaseFreeUnits(int iChange)
{
	if(iChange != 0)
	{
		m_iBaseFreeUnits = (m_iBaseFreeUnits + iChange);

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetVerifiedOutsideUnitCount()
{
	int iOutsideUnitCount = 0;

	CvUnit* pLoopUnit;
	int iLoop;
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->plot() != NULL)
		{
			if(pLoopUnit->plot()->getOwner() != pLoopUnit->getOwner())
			{
				iOutsideUnitCount++;
			}
		}
	}

	return iOutsideUnitCount;
}


//	--------------------------------------------------------------------------------
int CvPlayer::getGoldPerUnit() const
{
	return getGoldPerUnitTimes100() / 100;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeGoldPerUnit(int iChange)
{
	if(iChange != 0)
	{
		changeGoldPerUnitTimes100(iChange * 100);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGoldPerUnitTimes100() const
{
	return m_iGoldPerUnit;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeGoldPerUnitTimes100(int iChange)
{
	if(iChange != 0)
	{
		m_iGoldPerUnit = (m_iGoldPerUnit + iChange);

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getGoldPerMilitaryUnit() const
{
	return m_iGoldPerMilitaryUnit;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeGoldPerMilitaryUnit(int iChange)
{
	if(iChange != 0)
	{
		m_iGoldPerMilitaryUnit = (m_iGoldPerMilitaryUnit + iChange);

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetImprovementGoldMaintenanceMod() const
{
	return m_iImprovementGoldMaintenanceMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeImprovementGoldMaintenanceMod(int iChange)
{
	if(iChange != 0)
	{
		m_iImprovementGoldMaintenanceMod = (m_iImprovementGoldMaintenanceMod + iChange);
	}
}

#if defined(MOD_CIV6_WORKER)
//	--------------------------------------------------------------------------------
int CvPlayer::GetRouteBuilderCostMod() const
{
	return m_iRouteBuilderCostMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeRouteBuilderCostMod(int iChange)
{
	if (iChange != 0)
	{
		m_iRouteBuilderCostMod = (m_iRouteBuilderCostMod + iChange);
	}
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::GetBuildingGoldMaintenanceMod() const
{
	return m_iBuildingGoldMaintenanceMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeBuildingGoldMaintenanceMod(int iChange)
{
	if(iChange != 0)
	{
		m_iBuildingGoldMaintenanceMod = (m_iBuildingGoldMaintenanceMod + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetUnitGoldMaintenanceMod() const
{
	return m_iUnitGoldMaintenanceMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeUnitGoldMaintenanceMod(int iChange)
{
	if(iChange != 0)
	{
		m_iUnitGoldMaintenanceMod = (m_iUnitGoldMaintenanceMod + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetUnitSupplyMod() const
{
	return m_iUnitSupplyMod;
}


//	--------------------------------------------------------------------------------
void CvPlayer::ChangeUnitSupplyMod(int iChange)
{
	if(iChange != 0)
	{
		m_iUnitSupplyMod = (m_iUnitSupplyMod + iChange);
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getExtraUnitCost() const
{
	return m_iExtraUnitCost;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeExtraUnitCost(int iChange)
{
	if(iChange != 0)
	{
		m_iExtraUnitCost = (m_iExtraUnitCost + iChange);

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumMaintenanceFreeUnits(DomainTypes eDomain, bool bOnlyCombatUnits) const
{
	int iNumFreeUnits = 0;

	// Loop through all units to see if any of them are free!
	const CvUnit* pLoopUnit;
	int iLoop;
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if (eDomain != NO_DOMAIN)
		{
			if (pLoopUnit->getDomainType() != eDomain)
			{
				continue;
			}
		}

		if (bOnlyCombatUnits)
		{
			if (!pLoopUnit->IsCombatUnit())
			{
				continue;
			}
		}

		if(pLoopUnit->IsNoMaintenance())
		{
			iNumFreeUnits++;
		}
		else if(IsGarrisonFreeMaintenance() && pLoopUnit->IsGarrisoned())
		{
			iNumFreeUnits++;
		}
#if defined(MOD_BALANCE_CORE_JFD)
		if(MOD_BALANCE_CORE_JFD && pLoopUnit->isContractUnit())
		{
			iNumFreeUnits++;
		}
#endif
	}

	return iNumFreeUnits;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNumMilitaryUnits() const
{
	return m_iNumMilitaryUnits;
}
#if defined(MOD_BATTLE_ROYALE)
//  ----------------------------------------------------------------------------------
int CvPlayer::getNumMilitarySeaUnits() const
{
	return m_iNumMilitarySeaUnits;
}

int CvPlayer::getNumMilitaryAirUnits() const
{
	return m_iNumMilitaryAirUnits;
}

int CvPlayer::getNumMilitaryLandUnits() const
{
	return m_iNumMilitaryLandUnits;
}
#endif


//	--------------------------------------------------------------------------------
#if defined(MOD_BATTLE_ROYALE)
void CvPlayer::changeNumMilitaryUnits(int iChange, DomainTypes eDomain)
#else
void CvPlayer::changeNumMilitaryUnits(int iChange)
#endif
{
	if(iChange != 0)
	{
		m_iNumMilitaryUnits = (m_iNumMilitaryUnits + iChange);
		CvAssert(getNumMilitaryUnits() >= 0);

#if defined(MOD_BATTLE_ROYALE)
		switch (eDomain)
		{
		case NO_DOMAIN:
			break;
		case DOMAIN_SEA:
			m_iNumMilitarySeaUnits = (m_iNumMilitarySeaUnits + iChange);
			CvAssert(getNumMilitarySeaUnits() >= 0);
			break;
		case DOMAIN_AIR:
			m_iNumMilitaryAirUnits = (m_iNumMilitaryAirUnits + iChange);
			CvAssert(getNumMilitaryAirUnits() >= 0);
			break;
		case DOMAIN_LAND:
			m_iNumMilitaryLandUnits = (m_iNumMilitaryLandUnits + iChange);
			CvAssert(getNumMilitarySeaUnits() >= 0);
			break;
		case DOMAIN_IMMOBILE:
			break;
		case DOMAIN_HOVER:
			break;
		default:
			break;
		}
#endif
		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getHappyPerMilitaryUnit() const
{
	return m_iHappyPerMilitaryUnit;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeHappyPerMilitaryUnit(int iChange)
{
	if(iChange != 0)
	{
		m_iHappyPerMilitaryUnit = (m_iHappyPerMilitaryUnit + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getHappinessToCulture() const
{
	return m_iHappinessToCulture;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeHappinessToCulture(int iChange)
{
	if(iChange != 0)
	{
		m_iHappinessToCulture = (m_iHappinessToCulture + iChange);
		CvAssert(getHappinessToCulture() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getHappinessToScience() const
{
	return m_iHappinessToScience;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeHappinessToScience(int iChange)
{
	if(iChange != 0)
	{
		m_iHappinessToScience = (m_iHappinessToScience + iChange);
		CvAssert(getHappinessToScience() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getHalfSpecialistUnhappinessCount() const
{
	return m_iHalfSpecialistUnhappinessCount;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isHalfSpecialistUnhappiness() const
{
	return (getHalfSpecialistUnhappinessCount() > 0);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeHalfSpecialistUnhappinessCount(int iChange)
{
	if(iChange != 0)
	{
		m_iHalfSpecialistUnhappinessCount = (m_iHalfSpecialistUnhappinessCount + iChange);
		CvAssert(getHalfSpecialistUnhappinessCount() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getHalfSpecialistFoodCount() const
{
	return m_iHalfSpecialistFoodCount;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isHalfSpecialistFood() const
{
	return (getHalfSpecialistFoodCount() > 0);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeHalfSpecialistFoodCount(int iChange)
{
	if(iChange != 0)
	{
		m_iHalfSpecialistFoodCount = (m_iHalfSpecialistFoodCount + iChange);
		CvAssert(getHalfSpecialistFoodCount() >= 0);
	}
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvPlayer::getHalfSpecialistFoodCapitalCount() const
{
	return m_iHalfSpecialistFoodCapitalCount;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isHalfSpecialistFoodCapital() const
{
	return (getHalfSpecialistFoodCapitalCount() > 0);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeHalfSpecialistFoodCapitalCount(int iChange)
{
	if(iChange != 0)
	{
		m_iHalfSpecialistFoodCapitalCount = (m_iHalfSpecialistFoodCapitalCount + iChange);
		CvAssert(getHalfSpecialistFoodCapitalCount() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getTradeRouteLandDistanceModifier() const
{
	return m_iTradeRouteLandDistanceModifier;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeTradeRouteLandDistanceModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iTradeRouteLandDistanceModifier = (m_iTradeRouteLandDistanceModifier + iChange);
		CvAssert(getTradeRouteLandDistanceModifier() >= 0);
	}
}
int CvPlayer::getTradeRouteSeaDistanceModifier() const
{
	return m_iTradeRouteSeaDistanceModifier;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeTradeRouteSeaDistanceModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iTradeRouteSeaDistanceModifier = (m_iTradeRouteSeaDistanceModifier + iChange);
		CvAssert(getTradeRouteSeaDistanceModifier() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetDomainFreeExperiencePerGreatWorkGlobal(DomainTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_DOMAIN_TYPES, "eIndex expected to be < NUM_DOMAIN_TYPES");
	return m_aiDomainFreeExperiencePerGreatWorkGlobal[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::ChangeDomainFreeExperiencePerGreatWorkGlobal(DomainTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_DOMAIN_TYPES, "eIndex expected to be < NUM_DOMAIN_TYPES");
	m_aiDomainFreeExperiencePerGreatWorkGlobal.setAt(eIndex, m_aiDomainFreeExperiencePerGreatWorkGlobal[eIndex] + iChange);
}

void CvPlayer::SetNullifyInfluenceModifier(bool bValue)
{
	if (bValue != m_bNullifyInfluenceModifier)
		m_bNullifyInfluenceModifier = bValue;
}
bool CvPlayer::IsNullifyInfluenceModifier() const
{
	return m_bNullifyInfluenceModifier;
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::getMilitaryFoodProductionCount() const
{
	return m_iMilitaryFoodProductionCount;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isMilitaryFoodProduction() const
{
	return (getMilitaryFoodProductionCount() > 0);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMilitaryFoodProductionCount(int iChange)
{
	if(iChange != 0)
	{
		m_iMilitaryFoodProductionCount = (m_iMilitaryFoodProductionCount + iChange);
		CvAssert(getMilitaryFoodProductionCount() >= 0);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetGoldenAgeCultureBonusDisabledCount() const
{
	return m_iGoldenAgeCultureBonusDisabledCount;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsGoldenAgeCultureBonusDisabled() const
{
	return (GetGoldenAgeCultureBonusDisabledCount() > 0);
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeGoldenAgeCultureBonusDisabledCount(int iChange)
{
	if (iChange != 0)
	{
		m_iGoldenAgeCultureBonusDisabledCount = m_iGoldenAgeCultureBonusDisabledCount + iChange;
		CvAssert(GetGoldenAgeCultureBonusDisabledCount() >= 0);
	}
}

void CvPlayer::ChangeNumMissionarySpreads(int iChange)
{
	m_iNumMissionarySpreads += iChange;

	if (iChange > 0)
	{
		int iUnitLoop;
		for (CvUnit* pLoopUnit = firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iUnitLoop))
		{
			if (pLoopUnit->GetReligionData() == NULL)
				continue;

			if (pLoopUnit->IsGreatPerson())
				continue;

			if (pLoopUnit->GetReligionData()->GetSpreadsLeft() <= 0)
				continue;

			pLoopUnit->GetReligionData()->SetSpreadsLeft(pLoopUnit->GetReligionData()->GetSpreadsLeft() + iChange);
		}
	}
}
int CvPlayer::GetNumMissionarySpreads() const
{
	return m_iNumMissionarySpreads;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetSecondReligionPantheonCount() const
{
	return m_iSecondReligionPantheonCount;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsSecondReligionPantheon() const
{
	return (GetSecondReligionPantheonCount() > 0);
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeSecondReligionPantheonCount(int iChange)
{
	if (iChange != 0)
	{
		m_iSecondReligionPantheonCount = m_iSecondReligionPantheonCount + iChange;
		CvAssert(GetSecondReligionPantheonCount() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetEnablesSSPartHurryCount() const
{
	return m_iEnablesSSPartHurryCount;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsEnablesSSPartHurry() const
{
	return (GetEnablesSSPartHurryCount() > 0);
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeEnablesSSPartHurryCount(int iChange)
{
	if (iChange != 0)
	{
		m_iEnablesSSPartHurryCount = m_iEnablesSSPartHurryCount + iChange;
		CvAssert(GetEnablesSSPartHurryCount() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetEnablesSSPartPurchaseCount() const
{
	return m_iEnablesSSPartPurchaseCount;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsEnablesSSPartPurchase() const
{
	return (GetEnablesSSPartPurchaseCount() > 0);
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeEnablesSSPartPurchaseCount(int iChange)
{
	if (iChange != 0)
	{
		m_iEnablesSSPartPurchaseCount = m_iEnablesSSPartPurchaseCount + iChange;
		CvAssert(GetEnablesSSPartPurchaseCount() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getHighestUnitLevel()	const
{
	return m_iHighestUnitLevel;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setHighestUnitLevel(int iNewValue)
{
	m_iHighestUnitLevel = iNewValue;
	CvAssert(getHighestUnitLevel() >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getMaxConscript() const
{
	return m_iMaxConscript;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMaxConscript(int iChange)
{
	m_iMaxConscript = (m_iMaxConscript + iChange);
	CvAssert(getMaxConscript() >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getConscriptCount() const
{
	return m_iConscriptCount;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setConscriptCount(int iNewValue)
{
	m_iConscriptCount = iNewValue;
	CvAssert(getConscriptCount() >= 0);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeConscriptCount(int iChange)
{
	setConscriptCount(getConscriptCount() + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getOverflowResearch() const
{
#if defined(MOD_BUGFIX_MINOR)
	return getOverflowResearchTimes100() / 100;
#else
	return m_iOverflowResearch / 100;
#endif
}


//	--------------------------------------------------------------------------------
void CvPlayer::setOverflowResearch(int iNewValue)
{
	setOverflowResearchTimes100(iNewValue*100);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeOverflowResearch(int iChange)
{
	changeOverflowResearchTimes100(iChange*100);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getOverflowResearchTimes100() const
{
	return m_iOverflowResearch;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setOverflowResearchTimes100(int iNewValue)
{
	m_iOverflowResearch = iNewValue;
	CvAssert(getOverflowResearchTimes100() >= 0);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeOverflowResearchTimes100(int iChange)
{
	setOverflowResearchTimes100(getOverflowResearchTimes100() + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getExpModifier() const
{
	return m_iExpModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeExpModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iExpModifier += iChange;
		CvAssert(getExpModifier() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getExpInBorderModifier() const
{
	return m_iExpInBorderModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeExpInBorderModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iExpInBorderModifier += iChange;
		CvAssert(getExpInBorderModifier() >= 0);
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getLevelExperienceModifier() const
{
	return m_iLevelExperienceModifier;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeLevelExperienceModifier(int iChange)
{
	m_iLevelExperienceModifier += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getMinorQuestFriendshipMod() const
{
	return m_iMinorQuestFriendshipMod;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMinorQuestFriendshipMod(int iChange)
{
	if(iChange != 0)
	{
		m_iMinorQuestFriendshipMod += iChange;
		CvAssert(getMinorQuestFriendshipMod() >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getMinorGoldFriendshipMod() const
{
	return m_iMinorGoldFriendshipMod;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeMinorGoldFriendshipMod(int iChange)
{
	if(iChange != 0)
	{
		m_iMinorGoldFriendshipMod += iChange;
		CvAssert(getMinorGoldFriendshipMod() >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// What is the general modifier we get towards the resting Influence point with a city-state? (ex. Social Policies)
/// NOTE: This does not include situation-dependent modifiers (ex. religion or warmongering), which are handled in CvMinorCivAI
int CvPlayer::GetMinorFriendshipAnchorMod() const
{
	return m_iMinorFriendshipMinimum;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetMinorFriendshipAnchorMod(int iValue)
{
	if (iValue < GC.getMINOR_FRIENDSHIP_AT_WAR())
	{
		CvAssertMsg(false, "Minor friendship anchor mod should not be lower than the War friendship level. Please send Anton your save file and version.");
		m_iMinorFriendshipMinimum = GC.getMINOR_FRIENDSHIP_AT_WAR();
		return;
	}

	m_iMinorFriendshipMinimum = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMinorFriendshipAnchorMod(int iChange)
{
	SetMinorFriendshipAnchorMod(GetMinorFriendshipAnchorMod() + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::GetMinorFriendshipDecayMod() const
{
	return m_iMinorFriendshipDecayMod;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeGetMinorFriendshipDecayMod(int iChange)
{
	if(iChange != 0)
	{
		m_iMinorFriendshipDecayMod += iChange;
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsMinorScienceAllies() const
{
	return GetMinorScienceAlliesCount() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetMinorScienceAlliesCount() const
{
	return m_iMinorScienceAlliesCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMinorScienceAlliesCount(int iChange)
{
	if(iChange != 0)
	{
		m_iMinorScienceAlliesCount += iChange;
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsMinorResourceBonus() const
{
	return GetMinorResourceBonusCount() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetMinorResourceBonusCount() const
{
	return m_iMinorResourceBonusCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMinorResourceBonusCount(int iChange)
{
	if(iChange != 0)
	{
		m_iMinorResourceBonusCount += iChange;
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsAbleToAnnexCityStates() const
{
	if (GetAbleToAnnexCityStatesCount() > 0)
		return true;

	if (GetPlayerTraits()->IsAbleToAnnexCityStates())
		return true;

	return false;
}
#if defined(MOD_BALANCE_CORE)
	//JFD
void CvPlayer::SetPiety(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_PietyChanged, GetID(), GetPiety(), iValue);
	if(m_iJFDPiety != iValue)
	{
		m_iJFDPiety = iValue;
	}
}
void CvPlayer::ChangePiety(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_PietyChanged, GetID(), GetPiety(), iValue);
	m_iJFDPiety += iValue;
	if(m_iJFDPiety > GC.getGame().getGameSpeedInfo().getPietyMax())
	{
		m_iJFDPiety = GC.getGame().getGameSpeedInfo().getPietyMax();
	}
	if(m_iJFDPiety < GC.getGame().getGameSpeedInfo().getPietyMin())
	{
		m_iJFDPiety = GC.getGame().getGameSpeedInfo().getPietyMin();
	}
}
int CvPlayer::GetPiety() const
{
	return m_iJFDPiety;
}
int CvPlayer::GetPietyRate() const
{
	return m_iJFDPietyRate;
}
void CvPlayer::SetPietyRate(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_PietyRateChanged, GetID(), GetPietyRate(), iValue);
	if(m_iJFDPietyRate != iValue)
	{
		m_iJFDPietyRate = iValue;
	}
}
void CvPlayer::ChangePietyRate(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_PietyRateChanged, GetID(), GetPietyRate(), iValue);
	m_iJFDPietyRate += iValue;
}
int CvPlayer::GetTurnsSinceConversion() const
{
	return m_iJFDConversionTurn;
}
void CvPlayer::SetTurnsSinceConversion(int iValue)
{
	if(m_iJFDConversionTurn != iValue)
	{
		m_iJFDConversionTurn = iValue;
	}
}
void CvPlayer::DoPiety()
{
	ReligionTypes eReligion = GetReligions()->GetStateReligion();
	if(eReligion == NO_RELIGION)
	{
		return;
	}
	else
	{
		int iRate = GetPietyRate();
		if(iRate != 0)
		{
			ChangePiety(iRate);
		}
	}
}
bool CvPlayer::HasStateReligion()
{
	if(GetReligions()->GetStateReligion() != NO_RELIGION)
	{
		return true;
	}
	return false;
}
bool CvPlayer::HasSecularized() const
{
	return m_bJFDSecularized;
}
void CvPlayer::SetHasSecularized(bool bValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerSecularizes, GetID(), GetReligions()->GetStateReligion(), bValue);
	m_bJFDSecularized = bValue;
}
bool CvPlayer::IsPagan()
{
	if(GetReligions()->HasCreatedPantheon() && !HasStateReligion() && !HasSecularized())
	{
		return true;
	}
	return false;
}

void CvPlayer::ChangeSovereignty(int iValue)
{
	m_iJFDSovereignty += iValue;
}
int CvPlayer::GetSovereignty() const
{
	return m_iJFDSovereignty;
}
void CvPlayer::SetSovereignty(int iValue)
{
	if(m_iJFDSovereignty != iValue)
	{
		m_iJFDSovereignty = iValue;
	}
}

void CvPlayer::SetGovernment(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerAdoptsGovernment, GetID(), iValue);
	if(m_iJFDGovernment != iValue)
	{
		m_iJFDGovernment = iValue;
	}
}
int CvPlayer::GetGovernment() const
{
	return m_iJFDGovernment;
}
bool CvPlayer::HasGovernment()
{
	if(GetGovernment() > -1)
	{
		return true;
	}
	return false;
}

void CvPlayer::ChangeReformCooldown(int iValue)
{
	m_iJFDReformCooldown += iValue;
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_ReformCooldownChanges, GetID(), GetReformCooldown());
}
int CvPlayer::GetReformCooldown() const
{
	return m_iJFDReformCooldown;
}
void CvPlayer::SetReformCooldown(int iValue, bool bNoEvent)
{
	if(m_iJFDReformCooldown != iValue)
	{
		m_iJFDReformCooldown = iValue;
	}
	if(!bNoEvent)
	{
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_ReformCooldownChanges, GetID(), GetReformCooldown());
	}
}

void CvPlayer::ChangeReformCooldownRate(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_ReformCooldownRateChanges, GetID(), iValue);
	m_iJFDReformCooldownRate += iValue;
}
int CvPlayer::GetReformCooldownRate() const
{
	return m_iJFDReformCooldownRate;
}
void CvPlayer::SetReformCooldownRate(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_ReformCooldownRateChanges, GetID(), iValue);
	if(m_iJFDReformCooldownRate != iValue)
	{
		m_iJFDReformCooldownRate = iValue;
	}
}

void CvPlayer::ChangeGovernmentCooldown(int iValue)
{
	m_iJFDGovernmentCooldown += iValue;
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_GovernmentCooldownChanges, GetID(), GetGovernmentCooldown());
}
int CvPlayer::GetGovernmentCooldown() const
{
	return m_iJFDGovernmentCooldown;
}
void CvPlayer::SetGovernmentCooldown(int iValue, bool bNoEvent)
{
	if(m_iJFDGovernmentCooldown != iValue)
	{
		m_iJFDGovernmentCooldown = iValue;
	}
	if(!bNoEvent)
	{
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_GovernmentCooldownChanges, GetID(), GetGovernmentCooldown());
	}
}

void CvPlayer::ChangeGovernmentCooldownRate(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_GovernmentCooldownRateChanges, GetID(), iValue);
	m_iJFDGovernmentCooldownRate += iValue;
}
int CvPlayer::GetGovernmentCooldownRate() const
{
	return m_iJFDGovernmentCooldownRate;
}
void CvPlayer::SetGovernmentCooldownRate(int iValue)
{
	GAMEEVENTINVOKE_HOOK(GAMEEVENT_GovernmentCooldownRateChanges, GetID(), iValue);
	if(m_iJFDGovernmentCooldownRate != iValue)
	{
		m_iJFDGovernmentCooldownRate = iValue;
	}
}

int CvPlayer::GetPoliticLeader() const
{
	return m_iJFDPoliticLeader;
}
void CvPlayer::SetPoliticLeader(int iID)
{
	m_iJFDPoliticLeader = iID;
}

CvString CvPlayer::GetPoliticLeaderKey() const
{
	return m_strJFDPoliticKey;
}
void CvPlayer::SetPoliticLeaderKey(const char* strKey)
{
	m_strJFDPoliticKey = strKey;
}

CvString CvPlayer::GetLegislatureName() const
{
	return m_strJFDLegislatureName;
}
void CvPlayer::SetLegislatureName(const char* strKey)
{
	m_strJFDLegislatureName = strKey;
}

int CvPlayer::GetPoliticPercent(int iID) const
{
	return m_paiJFDPoliticPercent[iID];
}
void CvPlayer::SetPoliticPercent(int iID, int iValue)
{
	m_paiJFDPoliticPercent.setAt(iID, iValue);
}

void CvPlayer::DoGovernmentCooldown()
{
	if(GetGovernmentCooldown() <= 0)
	{
		return;
	}
	int iRate = GetGovernmentCooldownRate();
	if(iRate != 0)
	{
		ChangeGovernmentCooldown(-iRate);
		if(GetGovernmentCooldown() <= 0)
		{
			SetGovernmentCooldown(0, true);
		}
	}
}
void CvPlayer::DoReformCooldown()
{
	if(GetReformCooldown() <= 0)
	{
		return;
	}
	int iRate = GetReformCooldownRate();
	if(iRate != 0)
	{
		ChangeReformCooldown(-iRate);
		if(GetReformCooldown() <= 0)
		{
			SetReformCooldown(0, true);
		}
	}
}
void CvPlayer::SetCurrency(int iValue)
{
	if(!HasCurrency())
	{
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerAdoptsCurrency, GetID(), iValue, -1);
	}
	else
	{
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_PlayerAdoptsCurrency, GetID(), iValue, GetCurrency());
	}
	if(m_iJFDCurrency != iValue)
	{
		m_iJFDCurrency = iValue;
	}
}
int CvPlayer::GetCurrency() const
{
	return m_iJFDCurrency;
}
bool CvPlayer::HasCurrency()
{
	if(GetCurrency() > -1)
	{
		return true;
	}
	return false;
}

CvString CvPlayer::GetCurrencyName() const
{
	return m_strJFDCurrencyName;
}
void CvPlayer::SetCurrencyName(const char* strKey)
{
	m_strJFDCurrencyName = strKey;
}

void CvPlayer::SetProsperityScore(int iValue)
{
	if(m_iJFDProsperity != iValue)
	{
		m_iJFDProsperity = iValue;
	}
}
int CvPlayer::GetProsperityScore() const
{
	return m_iJFDProsperity;
}

bool CvPlayer::PlayerHasContract(ContractTypes eContract) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eContract >= 0, "eContract expected to be >= 0");
	CvAssertMsg(eContract < GC.getNumContractInfos(), "eContract expected to be < GC.GetNumContractInfos()");
	return m_abActiveContract[eContract];
}
void CvPlayer::SetActiveContract(ContractTypes eContract, bool bValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eContract >= 0, "eContract expected to be >= 0");
	CvAssertMsg(eContract < GC.getNumContractInfos(), "eContract expected to be < GC.GetNumContractInfos()");
	if (m_abActiveContract[eContract] != bValue)
	{
		m_abActiveContract.setAt(eContract, bValue);
	}
}

//JFD DONE
void CvPlayer::DoDiversity(DomainTypes eDomain)
{
	//////Let's get sum total of all land military unit AI types and boost the lowest type.
	int iLowest = MAX_INT;
	int iUnitAI = -1;

	CvWeightedVector<UnitAITypes, NUM_UNITAI_TYPES, true> veAITypeTotals;

	for (int iI = 0; iI < GC.getNumUnitInfos(); iI++)
	{
		const UnitTypes eLoopUnit = static_cast<UnitTypes>(iI);
		CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eLoopUnit);
		if (pkUnitInfo)
		{
			if (pkUnitInfo->GetCombat() <= 0 && pkUnitInfo->GetRangedCombat() <= 0)
				continue;

			if (pkUnitInfo->GetDomainType() != eDomain)
				continue;

			if (!canTrain(eLoopUnit))
				continue;

			int iNumUnits = GetNumUnitsWithUnitAI(pkUnitInfo->GetDefaultUnitAIType(), true, eDomain == DOMAIN_SEA);

			veAITypeTotals.push_back(pkUnitInfo->GetDefaultUnitAIType(), iNumUnits);
		}
	}

	veAITypeTotals.SortItems();
	for (int i = 0; i < veAITypeTotals.size(); i++)
	{
		UnitAITypes UnitAI = (UnitAITypes)veAITypeTotals.GetElement(i);
		int iNumUnits = veAITypeTotals.GetWeight(i);
		if (iNumUnits < iLowest)
		{
			iLowest = iNumUnits;
			iUnitAI = (int)UnitAI;
		}
	}

	if (iUnitAI != m_aiDomainDiversity[eDomain])
	{
		if (GC.getLogging() && GC.getAILogging())
		{
			CvString strLogString;
			CvString strAI;
			getUnitAIString(strAI, (UnitAITypes)iUnitAI);

			switch (eDomain)
			{
			case DOMAIN_LAND:
				strLogString.Format("ARMY DIVERSITY CHANGE! WE NEED: ");
				break;
			case DOMAIN_SEA:
				strLogString.Format("NAVY DIVERSITY CHANGE! WE NEED: ");
				break;
			case DOMAIN_AIR:
				strLogString.Format("AIR DIVERSITY CHANGE! WE NEED: ");
				break;
			}
			strLogString += strAI;
			GetHomelandAI()->LogHomelandMessage(strLogString);
		}

		m_aiDomainDiversity.setAt(eDomain, iUnitAI);
	}
}
int CvPlayer::GetDiversity(DomainTypes eDomain) const
{
	return m_aiDomainDiversity[eDomain];
}

int CvPlayer::GetDominationResistance(PlayerTypes ePlayer)
{
	if (ePlayer == NO_PLAYER)
		return 0;

	int iHandicap = 5;
	if (GET_PLAYER(ePlayer).isHuman())
	{
		iHandicap = GC.getGame().getHandicapInfo().getAIDifficultyBonusBase();
	}

	int iMaxThreshold = GC.getWARMONGER_THREAT_CRITICAL_THRESHOLD() * 200;
	iMaxThreshold /= max(1, iHandicap);

	int iResistance = GetDiplomacyAI()->GetOtherPlayerWarmongerAmount(ePlayer);
	iResistance *= 100;
	iResistance /= max(1, iMaxThreshold);

	return min((iHandicap * iHandicap), iResistance);
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetArchaeologicalDigTourism() const
{
	return m_iArchaeologicalDigTourism;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeArchaeologicalDigTourism(int iChange)
{
	m_iArchaeologicalDigTourism += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetGoldenAgeTourism() const
{
	return m_iGoldenAgeTourism;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeGoldenAgeTourism(int iChange)
{
	m_iGoldenAgeTourism += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetExtraCultureandScienceTradeRoutes() const
{
	return m_iExtraCultureandScienceTradeRoutes;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeExtraCultureandScienceTradeRoutes(int iChange)
{
	m_iExtraCultureandScienceTradeRoutes += iChange;
}



//	--------------------------------------------------------------------------------
bool CvPlayer::CanUpgradeCSVassalTerritory() const
{
	if (GetUpgradeCSVassalTerritory() > 0)
	{
		return true;
	}

	return false;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetUpgradeCSVassalTerritory() const
{
	return m_iUpgradeCSVassalTerritory;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeUpgradeCSVassalTerritory(int iChange)
{
	m_iUpgradeCSVassalTerritory += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetRazingSpeedBonus() const
{
	return m_iRazingSpeedBonus;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeRazingSpeedBonus(int iChange)
{
	m_iRazingSpeedBonus += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetNoPartisans() const
{
	return m_iNoPartisans;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNoPartisans(int iChange)
{
	m_iNoPartisans += iChange;
}
//	--------------------------------------------------------------------------------
bool CvPlayer::IsNoPartisans() const
{
	if (GetNoPartisans() > 0)
	{
		return true;
	}

	return false;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetSpawnCooldown() const
{
	return m_iSpawnCooldown;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetSpawnCooldown(int iValue)
{
	m_iSpawnCooldown = iValue;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeSpawnCooldown(int iChange)
{
	m_iSpawnCooldown += iChange;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsDiplomaticMarriage() const
{
	if (GetAbleToMarryCityStatesCount() > 0)
		return true;

	if (GetPlayerTraits()->IsDiplomaticMarriage())
		return true;

	return false;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetAbleToMarryCityStatesCount() const
{
	return m_iAbleToMarryCityStatesCount;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeAbleToMarryCityStatesCount(int iChange)
{
	m_iAbleToMarryCityStatesCount += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeTRSpeedBoost(int iChange)
{
	m_iTRSpeedBoost += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetTRSpeedBoost(int iChange)
{
	m_iTRSpeedBoost = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetTRSpeedBoost() const
{
	return m_iTRSpeedBoost;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeVotesPerGPT(int iChange)
{
	m_iVotesPerGPT += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetVotesPerGPT() const
{
	return m_iVotesPerGPT;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeTRVisionBoost(int iChange)
{
	m_iTRVisionBoost += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetTRVisionBoost(int iChange)
{
	m_iTRVisionBoost = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetTRVisionBoost() const
{
	return m_iTRVisionBoost;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeBuildingMaintenanceMod(int iChange)
{
	m_iBuildingMaintenanceMod += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetBuildingMaintenanceMod(int iChange)
{
	m_iBuildingMaintenanceMod = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetBuildingMaintenanceMod() const
{
	return m_iBuildingMaintenanceMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeEventTourism(int iChange)
{
	m_iEventTourism += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetEventTourism(int iChange)
{
	m_iEventTourism = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetEventTourism() const
{
	return m_iEventTourism;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetGlobalTourismAlreadyReceived(MinorCivQuestTypes eQuest, int iValue)
{
	CvAssertMsg(eQuest >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eQuest < NUM_MINOR_CIV_QUEST_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	if(iValue != 0)
	{
		m_aiGlobalTourismAlreadyReceived.setAt(eQuest, iValue);
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::GlobalTourismAlreadyReceived(MinorCivQuestTypes eQuest) const
{
	CvAssertMsg(eQuest >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eQuest < NUM_MINOR_CIV_QUEST_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	return m_aiGlobalTourismAlreadyReceived[eQuest];
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeEventTourismCS(int iChange)
{
	m_iEventTourismCS += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetEventTourismCS(int iChange)
{
	m_iEventTourismCS = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetEventTourismCS() const
{
	return m_iEventTourismCS;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumHistoricEvents(HistoricEventTypes eHistoricEvent, int iChange)
{
	if(isMinorCiv())
	{
		return;
	}
	m_iNumHistoricEvent += iChange;
	CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity != NULL)
		{
			pLoopCity->GetCityCulture()->CalculateBaseTourismBeforeModifiers();
			pLoopCity->GetCityCulture()->CalculateBaseTourism();
		}
	}
	CvCity* pCapital = getCapitalCity();
	int iEventGP = GetPlayerTraits()->GetEventGP();
	if(pCapital != NULL && iEventGP > 0)
	{
		vector<SpecialistTypes> vPossibleSpecialists;
		for (int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
		{
			const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iSpecialistLoop);
			CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
			if (pkSpecialistInfo)
			{
				// Does this Specialist spawn a GP?
				if (pkSpecialistInfo->getGreatPeopleUnitClass() != NO_UNITCLASS)
				{
					vPossibleSpecialists.push_back(eSpecialist);

					//boost the chance if we have a slot for the corresponding great work
					if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_WRITER"))
					{ 
						if(GetCulture()->GetNumAvailableGreatWorkSlots(CvTypes::getGREAT_WORK_SLOT_LITERATURE()) > 0)
						{
							vPossibleSpecialists.push_back(eSpecialist);
						}
					}
					else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_ARTIST"))
					{
						if(GetCulture()->GetNumAvailableGreatWorkSlots(CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT()) > 0)
						{
							vPossibleSpecialists.push_back(eSpecialist);
						}
					}
					else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_MUSICIAN"))
					{
						if(GetCulture()->GetNumAvailableGreatWorkSlots(CvTypes::getGREAT_WORK_SLOT_MUSIC()) > 0)
						{
							vPossibleSpecialists.push_back(eSpecialist);
						}
					}
				}
			}
		}

		//choose one
		int iChoice = GC.getGame().getSmallFakeRandNum(vPossibleSpecialists.size(), getGlobalAverage(YIELD_CULTURE) + GC.getGame().getNumCities() + m_iNumHistoricEvent);
		SpecialistTypes eBestSpecialist = vPossibleSpecialists.empty() ? NO_SPECIALIST : vPossibleSpecialists[iChoice];
		if(eBestSpecialist != NO_SPECIALIST)
		{
			CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eBestSpecialist);
			if(pkSpecialistInfo)
			{
				int iGPThreshold = pCapital->GetCityCitizens()->GetSpecialistUpgradeThreshold((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass());
				iGPThreshold *= 100;
				//Get % of threshold for test.
				iGPThreshold *= iEventGP;
				iGPThreshold /= 100;
				
				pCapital->GetCityCitizens()->ChangeSpecialistGreatPersonProgressTimes100(eBestSpecialist, iGPThreshold, true);
				if(GetID() == GC.getGame().getActivePlayer())
				{
					iGPThreshold /= 100;
					char text[256] = {0};
					sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_GREAT_PEOPLE]", iGPThreshold);
					SHOW_PLOT_POPUP(pCapital->plot(), GetID(), text);
					CvNotifications* pNotification = GetNotifications();
					if(pNotification)
					{
						CvString strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS", iGPThreshold);
						CvString strSummary;
						// Class specific specialist message.
						if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_SCIENTIST"))
						{
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS_SCIENTIST", iGPThreshold);
						}
						else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_WRITER"))
						{ 
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS_WRITER", iGPThreshold);
						}
						else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_ARTIST"))
						{
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS_ARTIST", iGPThreshold);
						}
						else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_MUSICIAN"))
						{
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS_MUSICIAN", iGPThreshold);
						}
						else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_MERCHANT"))
						{
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS_MERCHANT", iGPThreshold);
						}
						else if((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_ENGINEER"))
						{
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS_ENGINEER", iGPThreshold);
						}
#if defined(MOD_DIPLOMACY_CITYSTATES)
						else if(MOD_DIPLOMACY_CITYSTATES && (UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass() == GC.getInfoTypeForString("UNITCLASS_GREAT_DIPLOMAT"))
						{
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_GP_BONUS_DIPLOMAT", iGPThreshold);
						}
#endif
						strSummary = GetLocalizedText("TXT_KEY_TOURISM_EVENT_SUMMARY_GP_BONUS");
						pNotification->Add(NOTIFICATION_GOLDEN_AGE_BEGUN_ACTIVE_PLAYER, strMessage, strSummary, -1, -1, -1);
					}
				}
			}
		}
	}
#if defined(MOD_BALANCE_CORE_DIFFICULTY)
	if (MOD_BALANCE_CORE_DIFFICULTY && !isMinorCiv() && !isHuman() && getNumCities() > 1)
	{
		int iYieldHandicap = DoDifficultyBonus(eHistoricEvent);
		if ((GC.getLogging() && GC.getAILogging()))
		{
			if (GC.getLogging() && GC.getAILogging())
			{
				CvString strLogString;
				int EventID = (int)eHistoricEvent;
				strLogString.Format("CBP AI DIFFICULTY BONUS FROM HISTORIC EVENT %d: Received Handicap Bonus (%d in Yields).", EventID, iYieldHandicap);

				CvString strTemp;

				CvString strFileName = "DifficultyHandicapLog.csv";
				FILogFile* pLog;
				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

				CvString strPlayerName;
				strPlayerName = getCivilizationShortDescription();
				strTemp += strPlayerName;
				strTemp += ", ";

				CvString strTurn;

				strTurn.Format("%d, ", GC.getGame().getGameTurn()); // turn
				strTemp += strTurn;

				strTemp += strLogString;

				pLog->Msg(strTemp);
			}
		}
	}
#endif
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetNumHistoricEvents(int iChange)
{
	m_iNumHistoricEvent = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetNumHistoricEvents() const
{
	return m_iNumHistoricEvent;
}
int CvPlayer::GetHistoricEventTourism(HistoricEventTypes eHistoricEvent, CvCity* pCity)
{

	int iTourism = 0;

	CvString strLogString; 
	
	switch (eHistoricEvent)
	{
	case HISTORIC_EVENT_GP:
		if (GC.getLogging() && GC.getAILogging())
		{
			strLogString.Format("Great Person Historic Event triggered.");
		}
		iTourism = GetEventTourism();
		break;
	case HISTORIC_EVENT_ERA:
		if (GC.getLogging() && GC.getAILogging())
		{
			strLogString.Format("Era Change Historic Event triggered.");
		}
		iTourism = GetEventTourism();
		break;
	case HISTORIC_EVENT_WAR:
		if (GC.getLogging() && GC.getAILogging())
		{
			strLogString.Format("War Historic Event triggered.");
		}
		iTourism = GetEventTourism();
		break;
	case HISTORIC_EVENT_WONDER:
		if (GC.getLogging() && GC.getAILogging())
		{
			strLogString.Format("Wonder Historic Event triggered.");
		}
		iTourism = GetEventTourism();
		break;
	case HISTORIC_EVENT_DIG:
		if (GC.getLogging() && GC.getAILogging())
		{
			strLogString.Format("Archaeological Dig Historic Event triggered.");
		}
		iTourism = GetArchaeologicalDigTourism();
		break;
	case HISTORIC_EVENT_TRADE_CS:
		if (GC.getLogging() && GC.getAILogging())
		{
			strLogString.Format("City-State Trade Historic Event triggered.");
		}
		iTourism = GetEventTourismCS();
		break;
	case HISTORIC_EVENT_GA:
		if (GC.getLogging() && GC.getAILogging())
		{
			strLogString.Format("Golden Age Historic Event triggered.");
		}
		iTourism = GetGoldenAgeTourism();
		break;
	case HISTORIC_EVENT_TRADE_LAND:
		if (GC.getLogging() && GC.getAILogging())
		{
			strLogString.Format("Land Trade Specific Event triggered.");
		}
		if (pCity != NULL)
		{
			iTourism = pCity->GetSeaTourismBonus();
		}
		break;
	case HISTORIC_EVENT_TRADE_SEA:
		if (GC.getLogging() && GC.getAILogging())
		{
			strLogString.Format("Sea Trade Specific Event triggered.");
		}
		if (pCity != NULL)
		{
			iTourism = pCity->GetLandTourismBonus();
		}
		break;
	}

	if (iTourism <= 0)
		return 0;

	int iPreviousTurnsToCount = iTourism;

	// Calculate boost
	int iTotalBonus = GetCultureYieldFromPreviousTurns(GC.getGame().getGameTurn(), iPreviousTurnsToCount);
	iTotalBonus += GetTourismYieldFromPreviousTurns(GC.getGame().getGameTurn(), iPreviousTurnsToCount);

	// Mod for City Count
	int iMod = (GC.getMap().getWorldInfo().GetNumCitiesPolicyCostMod() / 2);	// Default is 5, gets smaller on larger maps

	int iNumCities = GetMaxEffectiveCities();

	iMod *= (iNumCities - 1);

	if (iMod <= 0)
		iMod = 1;
	else if (iMod >= 75)
		iMod = 75;

	int iSubtraction = (iTotalBonus * iMod);
	iSubtraction /= 100;

	iTotalBonus -= iSubtraction;

	iTotalBonus /= 10;

	if (GC.getLogging() && GC.getAILogging())
	{
		CvString strTemp;

		CvString strFileName = "HistoricEventLog.csv";
		FILogFile* pLog;
		pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

		CvString strPlayerName;
		strPlayerName = getCivilizationShortDescription();
		strTemp += strPlayerName;
		strTemp += ", ";

		CvString strTurn;
 
		strTurn.Format("%d, ", GC.getGame().getGameTurn()); // turn
		strTemp += strTurn;

		strTemp += strLogString;

		CvString strData;
		strData.Format(" --- Total Events: %d. Tourism bonus with all civs (before modifiers): %d", GetNumHistoricEvents(), iTotalBonus);
		strTemp += strData;
		
		pLog->Msg(strTemp);
	}

	return iTotalBonus;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeSingleVotes(int iChange)
{
	m_iSingleVotes += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetSingleVotes(int iChange)
{
	m_iSingleVotes = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetSingleVotes() const
{
	return m_iSingleVotes;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMonopolyModFlat(int iChange)
{
	m_iMonopolyModFlat += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetMonopolyModFlat(int iChange)
{
	m_iMonopolyModFlat = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetMonopolyModFlat() const
{
	return m_iMonopolyModFlat;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMonopolyModPercent(int iChange)
{
	m_iMonopolyModPercent += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetMonopolyModPercent(int iChange)
{
	m_iMonopolyModPercent = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetMonopolyModPercent() const
{
	return m_iMonopolyModPercent;
}

/// What are we willing to give/receive for peace with the active human player?
int CvPlayer::GetCachedValueOfPeaceWithHuman() const
{
	return m_iCachedValueOfPeaceWithHuman;
}

/// Sets what are we willing to give/receive for peace with the active human player
void CvPlayer::SetCachedValueOfPeaceWithHuman(int iValue)
{
	m_iCachedValueOfPeaceWithHuman = iValue;
}

/// What are we willing to give/receive for peace with the active human player?
int CvPlayer::GetFaithPurchaseCooldown() const
{
	return m_iFaithPurchaseCooldown;
}

/// Sets what are we willing to give/receive for peace with the active human player
void CvPlayer::ChangeFaithPurchaseCooldown(int iValue)
{
	m_iFaithPurchaseCooldown += iValue;
}

int CvPlayer::GetNumCSAllies() const
{
	return m_iCSAllies;
}
void CvPlayer::SetNumCSAllies(int iChange)
{
	if (m_iCSAllies != iChange)
	{
		m_iCSAllies = iChange;
	}
}

int CvPlayer::GetNumCSFriends() const
{
	return m_iCSFriends;
}
void CvPlayer::SetNumCSFriends(int iChange)
{
	if (m_iCSFriends != iChange)
	{
		m_iCSFriends = iChange;
	}
}

void CvPlayer::RefreshCSAlliesFriends()
{
	int iFriends = 0;
	int iAllies = 0;
	// Loop through all minors and get the total number we've met.
	for (int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		PlayerTypes eMinor = (PlayerTypes)iMinorLoop;

		if (GET_PLAYER(eMinor).isAlive() && GET_PLAYER(eMinor).isMinorCiv())
		{
			if (GET_PLAYER(eMinor).GetMinorCivAI()->IsAllies(GetID()))
			{
				iAllies++;
			}
			else if (GET_PLAYER(eMinor).GetMinorCivAI()->IsFriends(GetID()))
			{
				iFriends++;
			}
		}
	}
	SetNumCSAllies(iAllies);
	SetNumCSFriends(iFriends);
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::GetAbleToAnnexCityStatesCount() const
{
	return m_iAbleToAnnexCityStatesCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeAbleToAnnexCityStatesCount(int iChange)
{
	m_iAbleToAnnexCityStatesCount += iChange;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsOnlyTradeSameIdeology() const
{
	return m_iOnlyTradeSameIdeology > 0;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeOnlyTradeSameIdeology(int iChange)
{
	m_iOnlyTradeSameIdeology += iChange;
}

#if defined(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS)
//	--------------------------------------------------------------------------------
int CvPlayer::GetPovertyUnhappinessMod() const
{
	return m_iPovertyUnhappinessMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangePovertyUnhappinessMod(int iChange)
{
	m_iPovertyUnhappinessMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetDefenseUnhappinessMod() const
{
	return m_iDefenseUnhappinessMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeDefenseUnhappinessMod(int iChange)
{
	m_iDefenseUnhappinessMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetUnculturedUnhappinessMod() const
{
	return m_iUnculturedUnhappinessMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeUnculturedUnhappinessMod(int iChange)
{
	m_iUnculturedUnhappinessMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetIlliteracyUnhappinessMod() const
{
	return m_iIlliteracyUnhappinessMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeIlliteracyUnhappinessMod(int iChange)
{
	m_iIlliteracyUnhappinessMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetMinorityUnhappinessMod() const
{
	return m_iMinorityUnhappinessMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMinorityUnhappinessMod(int iChange)
{
	m_iMinorityUnhappinessMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetPovertyUnhappinessModCapital() const
{
	return m_iPovertyUnhappinessModCapital;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangePovertyUnhappinessModCapital(int iChange)
{
	m_iPovertyUnhappinessModCapital += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetDefenseUnhappinessModCapital() const
{
	return m_iDefenseUnhappinessModCapital;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeDefenseUnhappinessModCapital(int iChange)
{
	m_iDefenseUnhappinessModCapital += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetUnculturedUnhappinessModCapital() const
{
	return m_iUnculturedUnhappinessModCapital;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeUnculturedUnhappinessModCapital(int iChange)
{
	m_iUnculturedUnhappinessModCapital += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetIlliteracyUnhappinessModCapital() const
{
	return m_iIlliteracyUnhappinessModCapital;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeIlliteracyUnhappinessModCapital(int iChange)
{
	m_iIlliteracyUnhappinessModCapital += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetMinorityUnhappinessModCapital() const
{
	return m_iMinorityUnhappinessModCapital;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMinorityUnhappinessModCapital(int iChange)
{
	m_iMinorityUnhappinessModCapital += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetCapitalUnhappinessModCBP() const
{
	return m_iCapitalUnhappinessModCBP;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangeCapitalUnhappinessModCBP(int iChange)
{
	m_iCapitalUnhappinessModCBP += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetPuppetUnhappinessMod() const
{
	return m_iPuppetUnhappinessMod;
}
//	--------------------------------------------------------------------------------
void CvPlayer::ChangePuppetUnhappinessMod(int iChange)
{
	m_iPuppetUnhappinessMod += iChange;
}
// Specialists
//	--------------------------------------------------------------------------------
int CvPlayer::GetNoUnhappfromXSpecialists() const
{
	return m_iNoUnhappfromXSpecialists;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNoUnhappfromXSpecialists(int iChange)
{
	m_iNoUnhappfromXSpecialists += iChange;
}

int CvPlayer::GetTechDeviation() const
{
	//Let's modify this based on the number of player techs - more techs means the threshold goes higher.
	int iOurTech = GET_TEAM(getTeam()).GetTeamTechs()->GetNumTechsKnown();
	int iAvgTech = GC.getGame().GetGlobalTechAvg();

	int iTechDeviation = iOurTech - iAvgTech;

	//Using the num of techs to get a % - num of techs artificially increased to slow rate of runaways
	int iTech = (int)((iTechDeviation * iTechDeviation * iTechDeviation) * /*.1*/ GC.getBALANCE_HAPPINESS_TECH_BASE_MODIFIER());

	if (iTech > 0 && iTech > (GC.getBALANCE_HAPPINESS_TECH_BASE_MODIFIER() * 100))
		iTech = ((int)GC.getBALANCE_HAPPINESS_TECH_BASE_MODIFIER() * 100);
	else if (iTech < 0 && iTech <= (GC.getBALANCE_HAPPINESS_TECH_BASE_MODIFIER() * -100))
		iTech = ((int)GC.getBALANCE_HAPPINESS_TECH_BASE_MODIFIER() * -100);

	return iTech;
}


//	--------------------------------------------------------------------------------
int CvPlayer::GetHappfromXSpecialists() const
{
	return m_iHappfromXSpecialists;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeHappfromXSpecialists(int iChange)
{
	m_iHappfromXSpecialists += iChange;
}



//	--------------------------------------------------------------------------------
int CvPlayer::GetNoUnhappfromXSpecialistsCapital() const
{
	return m_iNoUnhappfromXSpecialistsCapital;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNoUnhappfromXSpecialistsCapital(int iChange)
{
	m_iNoUnhappfromXSpecialistsCapital += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetSpecialistFoodChange() const
{
	return m_iSpecialistFoodChange;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeSpecialistFoodChange(int iChange)
{
	m_iSpecialistFoodChange += iChange;
}



//	--------------------------------------------------------------------------------
int CvPlayer::GetWarWearinessModifier() const
{
	return m_iWarWearinessModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeWarWearinessModifier(int iChange)
{
	m_iWarWearinessModifier += iChange;
}

int CvPlayer::GetWarScoreModifier() const
{
	return m_iWarScoreModifier;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeWarScoreModifier(int iChange)
{
	m_iWarScoreModifier += iChange;
}

void CvPlayer::SetProductionRoutesAllCities(bool bValue)
{
	if (m_bAllowsProductionTradeRoutesGlobal != bValue)
	{
		m_bAllowsProductionTradeRoutesGlobal = bValue;
	}
}
bool CvPlayer::IsProductionRoutesAllCities() const
{
	return m_bAllowsProductionTradeRoutesGlobal;
}

void CvPlayer::SetFoodRoutesAllCities(bool bValue)
{
	if (m_bAllowsFoodTradeRoutesGlobal != bValue)
	{
		m_bAllowsFoodTradeRoutesGlobal = bValue;
	}
}
bool CvPlayer::IsFoodRoutesAllCities() const
{
	return m_bAllowsFoodTradeRoutesGlobal;
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getCultureBombTimer() const
{
	return m_iCultureBombTimer;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setCultureBombTimer(int iNewValue)
{
	if(getCultureBombTimer() != iNewValue)
	{
		m_iCultureBombTimer = iNewValue;
		CvAssert(getCultureBombTimer() >= 0);
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeCultureBombTimer(int iChange)
{
	setCultureBombTimer(getCultureBombTimer() + iChange);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getConversionTimer() const
{
	return m_iConversionTimer;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setConversionTimer(int iNewValue)
{
	if(getConversionTimer() != iNewValue)
	{
		m_iConversionTimer = iNewValue;
		CvAssert(getConversionTimer() >= 0);

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(MiscButtons_DIRTY_BIT, true);
		}
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeConversionTimer(int iChange)
{
	setConversionTimer(getConversionTimer() + iChange);
}

//	--------------------------------------------------------------------------------
CvCity* CvPlayer::getCapitalCity()
{
	return getCity(m_iCapitalCityID);
}

//	--------------------------------------------------------------------------------
const CvCity* CvPlayer::getCapitalCity() const
{
	return getCity(m_iCapitalCityID);
}

//	--------------------------------------------------------------------------------
void CvPlayer::setCapitalCity(CvCity* pNewCapitalCity)
{
	CvCity* pOldCapitalCity;

	pOldCapitalCity = getCapitalCity();

	if(pOldCapitalCity != pNewCapitalCity)
	{
		if(pNewCapitalCity != NULL)
		{
			// Need to set our original capital x,y?
			if(GetOriginalCapitalX() == -1 || GetOriginalCapitalY() == -1)
			{
				m_iOriginalCapitalX = pNewCapitalCity->getX();
				m_iOriginalCapitalY = pNewCapitalCity->getY();
			}

			m_iCapitalCityID = pNewCapitalCity->GetID();
		}
		else
		{
			m_iCapitalCityID = -1;
		}
	}
}

//	--------------------------------------------------------------------------------
/// Where was our original capital located?
int CvPlayer::GetOriginalCapitalX() const
{
	return m_iOriginalCapitalX;
}

//	--------------------------------------------------------------------------------
/// Where was our original capital located?
int CvPlayer::GetOriginalCapitalY() const
{
	return m_iOriginalCapitalY;
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
void CvPlayer::setOriginalCapitalXY(CvCity* pCapitalCity)
{
	if(pCapitalCity != NULL)
	{
		m_iOriginalCapitalX = pCapitalCity->getX();
		m_iOriginalCapitalY = pCapitalCity->getY();
	}
}
#endif

//	--------------------------------------------------------------------------------
/// Have we lost our holy city in war?
bool CvPlayer::IsHasLostHolyCity() const
{
	return m_bLostHolyCity;
}

//	--------------------------------------------------------------------------------
/// Sets us to having lost our capital in war
void CvPlayer::SetHasLostHolyCity(bool bValue, PlayerTypes eConqueror)
{
	if (bValue != m_bLostCapital)
	{
		m_bLostHolyCity = bValue;
		m_eHolyCityConqueror = eConqueror;
	}
}

//	--------------------------------------------------------------------------------
/// Sets us to having lost our capital in war
void CvPlayer::SetLostHolyCityXY(int iX, int iY)
{
	m_iHolyCityX = iX;
	m_iHolyCityY = iY;
}

int CvPlayer::GetLostHolyCityX()
{
	return m_iHolyCityX;
}
int CvPlayer::GetLostHolyCityY()
{
	return m_iHolyCityY;
}

PlayerTypes CvPlayer::GetHolyCityConqueror()
{
	return m_eHolyCityConqueror;
}


//	--------------------------------------------------------------------------------
/// Have we lost our capital in war?
bool CvPlayer::IsHasLostCapital() const
{
	return m_bLostCapital;
}

//	--------------------------------------------------------------------------------
/// Sets us to having lost our capital in war
void CvPlayer::SetHasLostCapital(bool bValue, PlayerTypes eConqueror)
{
	if(bValue != m_bLostCapital)
	{
		m_bLostCapital = bValue;
		m_eConqueror = eConqueror;

		// Don't really care if a City State lost its capital
		if(!isMinorCiv())
		{
			int iMostOriginalCapitals = 0;
			TeamTypes eWinningTeam = NO_TEAM;
			PlayerTypes eWinningPlayer = NO_PLAYER;

			{
				// Calculate who owns the most original capitals by iterating through all civs 
				// and finding out who owns their original capital.
				typedef std::tr1::array<int, MAX_CIV_TEAMS> CivTeamArray;
				CivTeamArray aTeamCityCount;
				aTeamCityCount.assign(0);

				CvMap& kMap = GC.getMap();
				for (int iLoopPlayer = 0; iLoopPlayer < MAX_MAJOR_CIVS; ++iLoopPlayer)
				{
					const PlayerTypes ePlayer = static_cast<PlayerTypes>(iLoopPlayer);
					CvPlayer& kLoopPlayer = GET_PLAYER(ePlayer);
					if(kLoopPlayer.isEverAlive())
					{
						const int iOriginalCapitalX = kLoopPlayer.GetOriginalCapitalX();
						const int iOriginalCapitalY = kLoopPlayer.GetOriginalCapitalY();
						if(iOriginalCapitalX != -1 && iOriginalCapitalY != -1)
						{
							CvPlot* pkPlot = kMap.plot(iOriginalCapitalX, iOriginalCapitalY);
							if(pkPlot != NULL)
							{
								CvCity* pkCapitalCity = pkPlot->getPlotCity();
								if(pkCapitalCity != NULL)
								{
									const PlayerTypes eCapitalOwner = pkCapitalCity->getOwner();
									if(eCapitalOwner != NO_PLAYER)
									{
										CvPlayer& kCapitalOwnerPlayer = GET_PLAYER(eCapitalOwner);
										aTeamCityCount[kCapitalOwnerPlayer.getTeam()]++;
									}
								}
							}	
						}
					}
				}

				// What's the max count and are they the only team to have the max?
				CivTeamArray::iterator itMax = max_element(aTeamCityCount.begin(), aTeamCityCount.end());
				if(count(aTeamCityCount.begin(), aTeamCityCount.end(), *itMax) == 1)
				{
					eWinningTeam = static_cast<TeamTypes>(itMax - aTeamCityCount.begin());
					iMostOriginalCapitals = *itMax;

					CvTeam& kTeam = GET_TEAM(eWinningTeam);
					eWinningPlayer = kTeam.getLeaderID();
				}			
			}

			// Someone just lost their capital, test to see if someone wins
			if(bValue)
			{
				// slewis - Moved Conquest victory elsewhere so that victory is more accurately awarded
				//GC.getGame().DoTestConquestVictory();

				Localization::String localizedBuffer;
				Localization::String localizedSummary;
				NotificationTypes eNotificationType = NOTIFICATION_CAPITAL_LOST;

				for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
				{
					PlayerTypes ePlayer = (PlayerTypes)ui;
					CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();
					if(!pNotifications)
					{
						continue;
					}

					// Notify Player lost their capital
					if(ePlayer == GetID())
					{
						eNotificationType = NOTIFICATION_CAPITAL_LOST_ACTIVE_PLAYER;
						localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_YOU_LOST_CAPITAL");
						if (eWinningPlayer == ePlayer)
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_LOST_CAPITAL_YOU_WINNING");
							localizedBuffer << iMostOriginalCapitals;
						}
						else if (eWinningTeam != NO_TEAM)
						{
							if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(eWinningTeam))
							{
								if (eWinningPlayer != NO_PLAYER) // there is a winning player
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_LOST_CAPITAL_OTHER_PLAYER_WINNING");
									if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
									}
									else
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
									}
									localizedBuffer << iMostOriginalCapitals;
								}
								else
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_LOST_CAPITAL_TEAM_WINNING");
									localizedBuffer << (int)eWinningTeam;
									localizedBuffer << iMostOriginalCapitals;
								}
							}
							else // if someone is winning
							{
								localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_LOST_CAPITAL_UNMET_WINNING");
								localizedBuffer << iMostOriginalCapitals;
							}
						}
						else // if no one is winning
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_LOST_CAPITAL");
						}
					}
					// Known player
					else if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(getTeam()))
					{
						eNotificationType = NOTIFICATION_CAPITAL_LOST;
						localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_PLAYER_LOST_CAPITAL");
						localizedSummary << getCivilizationShortDescriptionKey();

						if (eWinningTeam != NO_TEAM)
						{
							if (GET_TEAM(eWinningTeam).isHasMet(getTeam()))
							{
								if (eWinningPlayer == GetID())
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL_YOU_WINNING");

									if (GC.getGame().isGameMultiPlayer() && isHuman())
									{
										localizedBuffer << getNickName();
									}
									else
									{
										localizedBuffer << getNameKey();
									}
									localizedBuffer << iMostOriginalCapitals;
								}
								else if (eWinningPlayer != NO_PLAYER)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL_OTHER_WINNING");
									if (GC.getGame().isGameMultiPlayer() && isHuman())
									{
										localizedBuffer << getNickName();
									}
									else
									{
										localizedBuffer << getNameKey();
									}

									if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
									}
									else
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
									}
									localizedBuffer << iMostOriginalCapitals;
								}
								else // if (eWinningTeam != NO_TEAM)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL_TEAM_WINNING");
									if (GC.getGame().isGameMultiPlayer() && isHuman())
									{
										localizedBuffer << getNickName();
									}
									else
									{
										localizedBuffer << getNameKey();
									}

									localizedBuffer << (int)eWinningTeam;
									localizedBuffer << iMostOriginalCapitals;
								}
							}
							else
							{
								localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL_UNMET_WINNING");
								if (GC.getGame().isGameMultiPlayer() && isHuman())
								{
									localizedBuffer << getNickName();
								}
								else
								{
									localizedBuffer << getNameKey();
								}
								localizedBuffer << iMostOriginalCapitals;
							}
						}
						else
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL");
							if (GC.getGame().isGameMultiPlayer() && isHuman())
							{
								localizedBuffer << getNickName();
							}
							else
							{
								localizedBuffer << getNameKey();
							}
						}
					}
					else // unmet player
					{
						eNotificationType = NOTIFICATION_CAPITAL_LOST;
						localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_SOMEONE_LOST_CAPITAL");

						if (eWinningTeam != NO_TEAM)
						{
							if (GET_TEAM(eWinningTeam).isHasMet(getTeam()))
							{
								if (eWinningPlayer == GetID())
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_LOST_CAPITAL_YOU_WINNING");
									localizedBuffer << iMostOriginalCapitals;
								}
								else if (eWinningPlayer != NO_PLAYER)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_LOST_CAPITAL_OTHER_WINNING");
									if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
									}
									else
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
									}
									localizedBuffer << iMostOriginalCapitals;
								}
								else // if (eWinningTeam != NO_TEAM)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_LOST_CAPITAL_TEAM_WINNING");
									localizedBuffer << (int)eWinningTeam;
									localizedBuffer << iMostOriginalCapitals;
								}
							}
							else
							{
								localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_LOST_CAPITAL_UNMET_WINNING");
								localizedBuffer << iMostOriginalCapitals;
							}
						}
						else
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_LOST_CAPITAL");
						}
					}

					pNotifications->Add(eNotificationType, localizedBuffer.toUTF8(), localizedSummary.toUTF8(), -1, -1, -1);
				}

				//replay message
				{
					Localization::String message;
					if (eWinningPlayer != NO_PLAYER)
					{
						message = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL_OTHER_WINNING");
						if (GC.getGame().isGameMultiPlayer() && isHuman())
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNickName();
#else
							localizedBuffer << getNickName();
#endif
						}
						else
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNameKey();
#else
							localizedBuffer << getNameKey();
#endif
						}

						if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
						{
#if defined(MOD_BUGFIX_MINOR)
							message << GET_PLAYER(eWinningPlayer).getNickName();
#else
							localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
#endif
						}
						else
						{
#if defined(MOD_BUGFIX_MINOR)
							message << GET_PLAYER(eWinningPlayer).getNameKey();
#else
							localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
#endif
						}

#if defined(MOD_BUGFIX_MINOR)
						message << iMostOriginalCapitals;
#else
						localizedBuffer << iMostOriginalCapitals;
#endif
					}
					else if (eWinningTeam != NO_TEAM)
					{
						message = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL_TEAM_WINNING");
						if (GC.getGame().isGameMultiPlayer() && isHuman())
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNickName();
#else
							localizedBuffer << getNickName();
#endif
						}
						else
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNameKey();
#else
							localizedBuffer << getNameKey();
#endif
						}

#if defined(MOD_BUGFIX_MINOR)
						message << (int)eWinningTeam;
						message << iMostOriginalCapitals;
#else
						localizedBuffer << (int)eWinningTeam;
						localizedBuffer << iMostOriginalCapitals;
#endif
					}
					else
					{
						message = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_LOST_CAPITAL");
						if (GC.getGame().isGameMultiPlayer() && isHuman())
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNickName();
#else
							localizedBuffer << getNickName();
#endif
						}
						else
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNameKey();
#else
							localizedBuffer << getNameKey();
#endif
						}
					}

					CvString translatedMessage = message.toUTF8();
					GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, GetID(), translatedMessage, GetOriginalCapitalX(), GetOriginalCapitalY());
				}					
			}
			// Player recovered capital!
			else
			{
				Localization::String localizedBuffer;
				Localization::String localizedSummary;

				for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
				{
					PlayerTypes ePlayer = (PlayerTypes)ui;
					CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();
					if(!pNotifications)
					{
						continue;
					}

					// Notify Player lost their capital
					if(ePlayer == GetID())
					{
						localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_RECOVERED_CAPITAL");
						if (eWinningPlayer == ePlayer)
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_REGAINED_CAPITAL_YOU_WINNING");
							localizedBuffer << iMostOriginalCapitals;
						}
						else if (GET_TEAM(getTeam()).isHasMet(eWinningTeam))
						{
							if (eWinningPlayer != NO_PLAYER) // there is a winning player
							{
								localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_REGAINED_CAPITAL_OTHER_PLAYER_WINNING");
								if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
								{
									localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
								}
								else
								{
									localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
								}
								localizedBuffer << iMostOriginalCapitals;
							}
							else
							{
								localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_REGAINED_CAPITAL_TEAM_WINNING");
								localizedBuffer << (int)eWinningTeam;
								localizedBuffer << iMostOriginalCapitals;
							}
						}
						else if (eWinningTeam != NO_TEAM) // if someone is winning
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_REGAINED_CAPITAL_UNMET_WINNING");
							localizedBuffer << iMostOriginalCapitals;
						}
						else // if no one is winning
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_YOU_RECOVERED_CAPITAL");
						}
					}
					// Known player
					else if (GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(getTeam()))
					{
						localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_PLAYER_RECOVERED_CAPITAL");
						localizedSummary << getCivilizationShortDescriptionKey();

						if (eWinningTeam != NO_TEAM)
						{
							if (GET_TEAM(eWinningTeam).isHasMet(getTeam()))
							{
								if (eWinningPlayer == ePlayer)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL_YOU_WINNING");
									localizedBuffer << iMostOriginalCapitals;
								}
								else if (eWinningPlayer != NO_PLAYER)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL_OTHER_WINNING");
									if (GC.getGame().isGameMultiPlayer() && isHuman())
									{
										localizedBuffer << getNickName();
									}
									else
									{
										localizedBuffer << getNameKey();
									}

									if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
									}
									else
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
									}
									localizedBuffer << iMostOriginalCapitals;
								}
								else // if (eWinningTeam != NO_TEAM)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL_TEAM_WINNING");
									if (GC.getGame().isGameMultiPlayer() && isHuman())
									{
										localizedBuffer << getNickName();
									}
									else
									{
										localizedBuffer << getNameKey();
									}

									localizedBuffer << (int)eWinningTeam;
									localizedBuffer << iMostOriginalCapitals;
								}
							}
							else
							{
								localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL_UNMET_WINNING");
								if (GC.getGame().isGameMultiPlayer() && isHuman())
								{
									localizedBuffer << getNickName();
								}
								else
								{
									localizedBuffer << getNameKey();
								}
								localizedBuffer << iMostOriginalCapitals;
							}
						}
						else
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL");
							if (GC.getGame().isGameMultiPlayer() && isHuman())
							{
								localizedBuffer << getNickName();
							}
							else
							{
								localizedBuffer << getNameKey();
							}
						}
					}
					else // unmet player
					{
						localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_SOMEONE_RECOVERED_CAPITAL");

						if (eWinningTeam != NO_TEAM)
						{
							if (GET_TEAM(eWinningTeam).isHasMet(getTeam()))
							{
								if (eWinningPlayer == ePlayer)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_REGAINED_CAPITAL_YOU_WINNING");
									localizedBuffer << iMostOriginalCapitals;
								}
								else if (eWinningPlayer != NO_PLAYER)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_REGAINED_CAPITAL_OTHER_WINNING");
									if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
									}
									else
									{
										localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
									}
									localizedBuffer << iMostOriginalCapitals;
								}
								else // if (eWinningTeam != NO_TEAM)
								{
									localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_REGAINED_CAPITAL_TEAM_WINNING");
									localizedBuffer << (int)eWinningTeam;
									localizedBuffer << iMostOriginalCapitals;
								}
							}
							else
							{
								localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_REGAINED_CAPITAL_UNMET_WINNING");
								localizedBuffer << iMostOriginalCapitals;
							}
						}
						else
						{
							localizedBuffer = Localization::Lookup("TXT_KEY_NOTIFICATION_UNMET_REGAINED_CAPITAL");
						}
					}

					pNotifications->Add(NOTIFICATION_CAPITAL_RECOVERED, localizedBuffer.toUTF8(), localizedSummary.toUTF8(), -1, -1, -1);
				}

				//replay message
				{
					Localization::String message;
					if (eWinningPlayer != NO_PLAYER)
					{
						message = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL_OTHER_WINNING");
						if (GC.getGame().isGameMultiPlayer() && isHuman())
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNickName();
#else
							localizedBuffer << getNickName();
#endif
						}
						else
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNameKey();
#else
							localizedBuffer << getNameKey();
#endif
						}

						if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eWinningPlayer).isHuman())
						{
#if defined(MOD_BUGFIX_MINOR)
							message << GET_PLAYER(eWinningPlayer).getNickName();
#else
							localizedBuffer << GET_PLAYER(eWinningPlayer).getNickName();
#endif
						}
						else
						{
#if defined(MOD_BUGFIX_MINOR)
							message << GET_PLAYER(eWinningPlayer).getNameKey();
#else
							localizedBuffer << GET_PLAYER(eWinningPlayer).getNameKey();
#endif
						}

#if defined(MOD_BUGFIX_MINOR)
						message << iMostOriginalCapitals;
#else
						localizedBuffer << iMostOriginalCapitals;
#endif
					}
					else if (eWinningTeam != NO_TEAM)
					{
						message = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL_TEAM_WINNING");
						if (GC.getGame().isGameMultiPlayer() && isHuman())
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNickName();
#else
							localizedBuffer << getNickName();
#endif
						}
						else
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNameKey();
#else
							localizedBuffer << getNameKey();
#endif
						}

#if defined(MOD_BUGFIX_MINOR)
						message << (int)eWinningTeam;
						message << iMostOriginalCapitals;
#else
						localizedBuffer << (int)eWinningTeam;
						localizedBuffer << iMostOriginalCapitals;
#endif
					}
					else
					{
						message = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_REGAINED_CAPITAL");
						if (GC.getGame().isGameMultiPlayer() && isHuman())
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNickName();
#else
							localizedBuffer << getNickName();
#endif
						}
						else
						{
#if defined(MOD_BUGFIX_MINOR)
							message << getNameKey();
#else
							localizedBuffer << getNameKey();
#endif
						}
					}

					CvString translatedMessage = message.toUTF8();
					GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, GetID(), translatedMessage, GetOriginalCapitalX(), GetOriginalCapitalY());
				}					
			}
		}
	}
}


//	--------------------------------------------------------------------------------
/// Player who first captured our capital
PlayerTypes CvPlayer::GetCapitalConqueror() const
{
	return m_eConqueror;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getCitiesLost() const
{
	return m_iCitiesLost;
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeCitiesLost(int iChange)
{
	m_iCitiesLost = (m_iCitiesLost + iChange);
}

void CvPlayer::updateMightStatistics()
{
	m_iTurnMightRecomputed = GC.getGame().getElapsedGameTurns();
	m_iMilitaryMight = calculateMilitaryMight();
	m_iEconomicMight = calculateEconomicMight();
	m_iProductionMight = calculateProductionMight();
}

//	--------------------------------------------------------------------------------
int CvPlayer::getPower() const
{
	// more lazy evaluation
	if (m_iTurnMightRecomputed < GC.getGame().getElapsedGameTurns())
	{
		const_cast<CvPlayer*>(this)->updateMightStatistics();
#if defined(MOD_BATTLE_ROYALE)
		const_cast<CvPlayer*>(this)->m_iMilitaryMight = calculateMilitaryMight(NO_DOMAIN);
		const_cast<CvPlayer*>(this)->m_iMilitarySeaMight = calculateMilitaryMight(DOMAIN_SEA);
		const_cast<CvPlayer*>(this)->m_iMilitaryAirMight = calculateMilitaryMight(DOMAIN_AIR);
		const_cast<CvPlayer*>(this)->m_iMilitaryLandMight = calculateMilitaryMight(DOMAIN_LAND);
#endif
	}

	return m_iMilitaryMight + m_iEconomicMight;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetMilitaryMight(bool bForMinor) const
{
	// more lazy evaluation
	if (m_iTurnMightRecomputed < GC.getGame().getElapsedGameTurns())
	{
		const_cast<CvPlayer*>(this)->updateMightStatistics();
#if defined(MOD_BATTLE_ROYALE)
		const_cast<CvPlayer*>(this)->m_iMilitaryMight = calculateMilitaryMight(NO_DOMAIN);
		const_cast<CvPlayer*>(this)->m_iMilitarySeaMight = calculateMilitaryMight(DOMAIN_SEA);
		const_cast<CvPlayer*>(this)->m_iMilitaryAirMight = calculateMilitaryMight(DOMAIN_AIR);
		const_cast<CvPlayer*>(this)->m_iMilitaryLandMight = calculateMilitaryMight(DOMAIN_LAND);
#endif
	}
	if (bForMinor && GetPlayerTraits()->GetBullyMilitaryStrengthModifier() != 0)
	{
		int iBonus = m_iMilitaryMight;
		iBonus *= (100 + GetPlayerTraits()->GetBullyMilitaryStrengthModifier());
		iBonus /= 100;
		return iBonus;
	}

	return m_iMilitaryMight;
}
#if defined(MOD_BATTLE_ROYALE)
//	--------------------------------------------------------------------------------
int CvPlayer::GetMilitarySeaMight() const
{
	if (m_iTurnMightRecomputed < GC.getGame().getElapsedGameTurns())
	{
		// more lazy evaluation
		const_cast<CvPlayer*>(this)->m_iTurnMightRecomputed = GC.getGame().getElapsedGameTurns();
		const_cast<CvPlayer*>(this)->m_iMilitaryMight = calculateMilitaryMight(NO_DOMAIN);
		const_cast<CvPlayer*>(this)->m_iMilitarySeaMight = calculateMilitaryMight(DOMAIN_SEA);
		const_cast<CvPlayer*>(this)->m_iMilitaryAirMight = calculateMilitaryMight(DOMAIN_AIR);
		const_cast<CvPlayer*>(this)->m_iMilitaryLandMight = calculateMilitaryMight(DOMAIN_LAND);
		const_cast<CvPlayer*>(this)->m_iEconomicMight = calculateEconomicMight();
	}
	return m_iMilitarySeaMight;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetMilitaryAirMight() const
{
	if (m_iTurnMightRecomputed < GC.getGame().getElapsedGameTurns())
	{
		// more lazy evaluation
		const_cast<CvPlayer*>(this)->m_iTurnMightRecomputed = GC.getGame().getElapsedGameTurns();
		const_cast<CvPlayer*>(this)->m_iMilitaryMight = calculateMilitaryMight(NO_DOMAIN);
		const_cast<CvPlayer*>(this)->m_iMilitarySeaMight = calculateMilitaryMight(DOMAIN_SEA);
		const_cast<CvPlayer*>(this)->m_iMilitaryAirMight = calculateMilitaryMight(DOMAIN_AIR);
		const_cast<CvPlayer*>(this)->m_iMilitaryLandMight = calculateMilitaryMight(DOMAIN_LAND);
		const_cast<CvPlayer*>(this)->m_iEconomicMight = calculateEconomicMight();
	}
	return m_iMilitaryAirMight;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetMilitaryLandMight() const
{
	if (m_iTurnMightRecomputed < GC.getGame().getElapsedGameTurns())
	{
		// more lazy evaluation
		const_cast<CvPlayer*>(this)->m_iTurnMightRecomputed = GC.getGame().getElapsedGameTurns();
		const_cast<CvPlayer*>(this)->m_iMilitaryMight = calculateMilitaryMight(NO_DOMAIN);
		const_cast<CvPlayer*>(this)->m_iMilitarySeaMight = calculateMilitaryMight(DOMAIN_SEA);
		const_cast<CvPlayer*>(this)->m_iMilitaryAirMight = calculateMilitaryMight(DOMAIN_AIR);
		const_cast<CvPlayer*>(this)->m_iMilitaryLandMight = calculateMilitaryMight(DOMAIN_LAND);
		const_cast<CvPlayer*>(this)->m_iEconomicMight = calculateEconomicMight();
	}
	return m_iMilitaryLandMight;
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::GetEconomicMight() const
{
	// more lazy evaluation
	if (m_iTurnMightRecomputed < GC.getGame().getElapsedGameTurns())
	{
		const_cast<CvPlayer*>(this)->updateMightStatistics();
#if defined(MOD_BATTLE_ROYALE)
		const_cast<CvPlayer*>(this)->m_iMilitaryMight = calculateMilitaryMight(NO_DOMAIN);
		const_cast<CvPlayer*>(this)->m_iMilitarySeaMight = calculateMilitaryMight(DOMAIN_SEA);
		const_cast<CvPlayer*>(this)->m_iMilitaryAirMight = calculateMilitaryMight(DOMAIN_AIR);
		const_cast<CvPlayer*>(this)->m_iMilitaryLandMight = calculateMilitaryMight(DOMAIN_LAND);
#endif
	}
	return m_iEconomicMight;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetProductionMight() const
{
	// more lazy evaluation
	if(m_iTurnMightRecomputed < GC.getGame().getElapsedGameTurns())
		const_cast<CvPlayer*>(this)->updateMightStatistics();

	return m_iProductionMight;
}

//	--------------------------------------------------------------------------------
#if defined(MOD_BATTLE_ROYALE)
int CvPlayer::calculateMilitaryMight(DomainTypes eDomain) const
#else
int CvPlayer::calculateMilitaryMight() const
#endif
{
	int rtnValue = 0;
	const CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(!pLoopUnit->IsCombatUnit())
			continue;
		// Current combat strength or bombard strength, whichever is higher
		int iPower =  pLoopUnit->GetPower();
#if defined(MOD_BATTLE_ROYALE)
		if (eDomain == NO_DOMAIN)
		{
			rtnValue += iPower;
		}
		else if (pLoopUnit->getDomainType() == eDomain)
		{
			rtnValue += iPower;
		}
#else
		rtnValue += iPower;
#endif
	}

#if defined(MOD_BALANCE_CORE_MILITARY)
	//Finally, divide our power by the number of cities we own - the more we have, the less we can defend.
	return int( rtnValue / max(1.f, sqrt((float)getNumCities())));
#else

	//Simplistic increase based on player's gold
	//500 gold will increase might by 22%, 2000 by 45%, 8000 gold by 90%
	float fGoldMultiplier = 1.0f + (sqrt((float)GetTreasury()->GetGold()) / 100.0f);
	if(fGoldMultiplier > 2.0f) fGoldMultiplier = 2.0f;
	rtnValue = (int)(rtnValue * fGoldMultiplier);
	return rtnValue;
#endif
}


//	--------------------------------------------------------------------------------
int CvPlayer::calculateEconomicMight() const
{
	int iEconomicMight = 5;
	iEconomicMight += getTotalPopulation();

	iEconomicMight += calculateTotalYield(YIELD_FOOD);
	iEconomicMight += calculateTotalYield(YIELD_PRODUCTION);
	iEconomicMight += calculateTotalYield(YIELD_SCIENCE);
	iEconomicMight += calculateTotalYield(YIELD_GOLD);
	iEconomicMight += calculateTotalYield(YIELD_CULTURE);

	if(IsEmpireUnhappy())
	{
		iEconomicMight += GetExcessHappiness() * 25;
	}

	//Finally, divide our power by the number of cities we own - the more we have, the more our upkeep.
	return int( iEconomicMight / max(1.f, sqrt((float)(getNumCities() / 2))));
}

//	--------------------------------------------------------------------------------
int CvPlayer::calculateProductionMight() const
{
	int iMight = 0;

	const CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iMight += pLoopCity->getRawProductionDifference(/*bIgnoreFood*/ true, /*bOverflow*/ false);
	}

	return iMight;
}

#if defined(MOD_UNITS_XP_TIMES_100)
int CvPlayer::getCombatExperienceTimes100() const
#else
int CvPlayer::getCombatExperience() const
#endif
{
#if defined(MOD_UNITS_XP_TIMES_100)
	return m_iCombatExperienceTimes100;
#else
	return m_iCombatExperience;
#endif
}

//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
#if defined(MOD_UNITS_XP_TIMES_100)
void CvPlayer::setCombatExperienceTimes100(int iExperienceTimes100, CvUnit* pFromUnit)
#else
void CvPlayer::setCombatExperience(int iExperience, CvUnit* pFromUnit)
#endif
#else
#if defined(MOD_UNITS_XP_TIMES_100)
void CvPlayer::setCombatExperienceTimes100(int iExperienceTimes100)
#else
void CvPlayer::setCombatExperience(int iExperience)
#endif
#endif
{

#if defined(MOD_UNITS_XP_TIMES_100)
	CvAssert(iExperienceTimes100 >= 0);
	
	if (iExperienceTimes100 != getCombatExperienceTimes100())
#else
	CvAssert(iExperience >= 0);
	
	if (iExperience != getCombatExperience())
#endif
	{
#if defined(MOD_UNITS_XP_TIMES_100)
		m_iCombatExperienceTimes100 = iExperienceTimes100;
#else
		m_iCombatExperience = iExperience;
#endif

		// Enough XP for a Great General to appear?
		if(!isBarbarian())
		{
#if defined(MOD_UNITS_XP_TIMES_100)
			int iExperienceThresholdTimes100 = greatGeneralThreshold() * 100;
			if (m_iCombatExperienceTimes100 >= iExperienceThresholdTimes100 && iExperienceThresholdTimes100 > 0)
#else
			int iExperienceThreshold = greatGeneralThreshold();
			if (m_iCombatExperience >= iExperienceThreshold && iExperienceThreshold > 0)
#endif
			{
				// create great person
				CvCity* pBestCity = NULL;
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
				if(pFromUnit == NULL)
				{
#endif
					int iBestValue = INT_MAX;
					int iLoop;
					for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						int iValue = 4 * GC.getGame().getSmallFakeRandNum(getNumCities(), getGlobalAverage(YIELD_CULTURE) + iLoop);

						for(int i = 0; i < NUM_YIELD_TYPES; i++)
						{
							iValue += pLoopCity->findYieldRateRank((YieldTypes)i);
						}
						iValue += pLoopCity->findPopulationRank();

						if(iValue < iBestValue)
						{
							pBestCity = pLoopCity;
							iBestValue = iValue;
						}
					}
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
				}
#endif

#if defined(MOD_GLOBAL_LOCAL_GENERALS)
				if(pBestCity || pFromUnit)
#else
				if(pBestCity)
#endif
				{
					// Figure out which Promotion is the one which makes a unit a Great General
					for(int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
					{
						const PromotionTypes eLoopPromotion = static_cast<PromotionTypes>(iI);
						CvPromotionEntry* pkPromotionInfo = GC.getPromotionInfo(eLoopPromotion);
						if(pkPromotionInfo)
						{
							if(pkPromotionInfo->IsGreatGeneral())
							{
								for(int iI = 0; iI < GC.getNumUnitInfos(); iI++)
								{
									const UnitTypes eLoopUnit = static_cast<UnitTypes>(iI);
									CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eLoopUnit);
									if(pkUnitInfo)
									{
										if(pkUnitInfo->GetFreePromotions(eLoopPromotion))
										{
											// Is this the right unit of this class for this civ?
											const UnitTypes eUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits((UnitClassTypes)pkUnitInfo->GetUnitClassType());

											if(eUnit == eLoopUnit)
											{
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
												if(pFromUnit)
												{
													CUSTOMLOG("Create Great General at (%d, %d) from unit %s", pFromUnit->plot()->getX(), pFromUnit->plot()->getY(), pFromUnit->getName().GetCString());
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
													createGreatGeneral(eUnit, pFromUnit->plot()->getX(), pFromUnit->plot()->getY(), false);
#else
													createGreatGeneral(eUnit, pFromUnit->plot()->getX(), pFromUnit->plot()->getY());
#endif
												}
												else
												{
#endif
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
													pBestCity->createGreatGeneral(eUnit, false);
#else
													pBestCity->createGreatGeneral(eUnit);
#endif
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
												}
#endif
#if defined(MOD_UNITS_XP_TIMES_100)
												setCombatExperienceTimes100(getCombatExperienceTimes100() - iExperienceThresholdTimes100);
#else
												setCombatExperience(getCombatExperience() - iExperienceThreshold);
#endif
												break;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
#if defined(MOD_UNITS_XP_TIMES_100)
void CvPlayer::changeCombatExperienceTimes100(int iChangeTimes100, CvUnit* pFromUnit)
#else
void CvPlayer::changeCombatExperience(int iChange, CvUnit* pFromUnit)
#endif
#else
#if defined(MOD_UNITS_XP_TIMES_100)
void CvPlayer::changeCombatExperienceTimes100(int iChangeTimes100)
#else
void CvPlayer::changeCombatExperience(int iChange)
#endif
#endif
{
#if defined(MOD_UNITS_XP_TIMES_100)
	if (!MOD_UNITS_XP_TIMES_100) {
		// If NOT using XP times 100, remove any fractional part
		iChangeTimes100 -= (iChangeTimes100 % 100);
	}
	if (getCombatExperienceTimes100() + iChangeTimes100 < 0)
#else
	if (getCombatExperience() + iChange < 0)
#endif
	{
#if defined(MOD_UNITS_XP_TIMES_100)
		setCombatExperienceTimes100(0);
#else
		setCombatExperience(0);
#endif
	}
	else
	{
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
#if defined(MOD_UNITS_XP_TIMES_100)
		setCombatExperienceTimes100(getCombatExperienceTimes100() + iChangeTimes100, pFromUnit);
#else
		setCombatExperience(getCombatExperience() + iChange, pFromUnit);
#endif
#else
#if defined(MOD_UNITS_XP_TIMES_100)
		setCombatExperienceTimes100(getCombatExperienceTimes100() + iChangeTimes100);
#else
		setCombatExperience(getCombatExperience() + iChange);
#endif
#endif
	}

#if defined(MOD_UNITS_XP_TIMES_100)
	m_iLifetimeCombatExperienceTimes100 += iChangeTimes100;
#else
	m_iLifetimeCombatExperience += iChange;
#endif
}

//	--------------------------------------------------------------------------------
#if defined(MOD_UNITS_XP_TIMES_100)
int CvPlayer::getNavalCombatExperienceTimes100() const
#else
int CvPlayer::getNavalCombatExperience() const
#endif
{
#if defined(MOD_UNITS_XP_TIMES_100)
	return m_iNavalCombatExperienceTimes100;
#else
	return m_iNavalCombatExperience;
#endif
}

//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
#if defined(MOD_UNITS_XP_TIMES_100)
void CvPlayer::setNavalCombatExperienceTimes100(int iExperienceTimes100, CvUnit* pFromUnit)
#else
void CvPlayer::setNavalCombatExperience(int iExperience, CvUnit* pFromUnit)
#endif
#else
#if defined(MOD_UNITS_XP_TIMES_100)
void CvPlayer::setNavalCombatExperienceTimes100(int iExperienceTimes100)
#else
void CvPlayer::setNavalCombatExperience(int iExperience)
#endif
#endif
{
#if defined(MOD_UNITS_XP_TIMES_100)
	CvAssert(iExperienceTimes100 >= 0);

	if (iExperienceTimes100 != getNavalCombatExperienceTimes100())
#else
	CvAssert(iExperience >= 0);

	if (iExperience != getNavalCombatExperience())
#endif
	{
#if defined(MOD_UNITS_XP_TIMES_100)
		m_iNavalCombatExperienceTimes100 = iExperienceTimes100;
#else
		m_iNavalCombatExperience = iExperience;
#endif

		// Enough XP for a Great Admiral to appear?
		if(!isBarbarian())
		{
#if defined(MOD_UNITS_XP_TIMES_100)
			int iExperienceThresholdTimes100 = greatAdmiralThreshold() * 100;
			if (m_iNavalCombatExperienceTimes100 >= iExperienceThresholdTimes100 && iExperienceThresholdTimes100 > 0)
#else
			int iExperienceThreshold = greatAdmiralThreshold();
			if (m_iNavalCombatExperience >= iExperienceThreshold && iExperienceThreshold > 0)
#endif
			{
				// create great person
				CvCity* pBestCity = NULL;
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
				if(pFromUnit == NULL)
				{
#endif
					int iBestValue = INT_MAX;
					int iLoop;
					for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
					{
						if(!pLoopCity->isCoastal())
						{
							continue;
						}

						int iValue = 4 * GC.getGame().getSmallFakeRandNum(getNumCities(), getGlobalAverage(YIELD_CULTURE) + iLoop);

						for(int i = 0; i < NUM_YIELD_TYPES; i++)
						{
							iValue += pLoopCity->findYieldRateRank((YieldTypes)i);
						}
						iValue += pLoopCity->findPopulationRank();

						if(iValue < iBestValue)
						{
							pBestCity = pLoopCity;
							iBestValue = iValue;
						}
					}
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
				}
#endif

#if defined(MOD_GLOBAL_LOCAL_GENERALS)
				if(pBestCity || pFromUnit)
#else
				if(pBestCity)
#endif
				{
					for(int iI = 0; iI < GC.getNumPromotionInfos(); iI++)
					{
						const PromotionTypes eLoopPromotion = static_cast<PromotionTypes>(iI);
						CvPromotionEntry* pkPromotionInfo = GC.getPromotionInfo(eLoopPromotion);
						if(pkPromotionInfo)
						{
							if(pkPromotionInfo->IsGreatAdmiral())
							{
								for(int iI = 0; iI < GC.getNumUnitInfos(); iI++)
								{
									const UnitTypes eLoopUnit = static_cast<UnitTypes>(iI);
									CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eLoopUnit);
									if(pkUnitInfo)
									{
										if(pkUnitInfo->GetFreePromotions(eLoopPromotion))
										{
											// Is this the right unit of this class for this civ?
											const UnitTypes eUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits((UnitClassTypes)pkUnitInfo->GetUnitClassType());

											if(eUnit == eLoopUnit)
											{
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
												if(pFromUnit)
												{
													CUSTOMLOG("Create Great Admiral at (%d, %d) from unit %s", pFromUnit->plot()->getX(), pFromUnit->plot()->getY(), pFromUnit->getName().GetCString());
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
													createGreatAdmiral(eUnit, pFromUnit->plot()->getX(), pFromUnit->plot()->getY(), false);
#else
													createGreatAdmiral(eUnit, pFromUnit->plot()->getX(), pFromUnit->plot()->getY());
#endif

#if defined(MOD_PROMOTIONS_FLAGSHIP)
													if (MOD_PROMOTIONS_FLAGSHIP)
													{
														pFromUnit->setHasPromotion((PromotionTypes)GC.getPROMOTION_FLAGSHIP(), true);
													}
#endif
												}
												else
												{
#endif
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
													pBestCity->createGreatAdmiral(eUnit, false);
#else
													pBestCity->createGreatAdmiral(eUnit);
#endif
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
												}
#endif
#if defined(MOD_UNITS_XP_TIMES_100)
												setNavalCombatExperienceTimes100(getNavalCombatExperienceTimes100() - iExperienceThresholdTimes100);
#else
												setNavalCombatExperience(getNavalCombatExperience() - iExperienceThreshold);
#endif
												break;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
#if defined(MOD_UNITS_XP_TIMES_100)
void CvPlayer::changeNavalCombatExperienceTimes100(int iChangeTimes100, CvUnit* pFromUnit)
#else
void CvPlayer::changeNavalCombatExperience(int iChange, CvUnit* pFromUnit)
#endif
#else
#if defined(MOD_UNITS_XP_TIMES_100)
void CvPlayer::changeNavalCombatExperienceTimes100(int iChangeTimes100)
#else
void CvPlayer::changeNavalCombatExperience(int iChange)
#endif
#endif
{
#if defined(MOD_UNITS_XP_TIMES_100)
	if (!MOD_UNITS_XP_TIMES_100)
	{
		// If NOT using XP times 100, remove any fractional part
		iChangeTimes100 -= (iChangeTimes100 % 100);
	}
	if (getNavalCombatExperienceTimes100() + iChangeTimes100 < 0)
#else
	if (getNavalCombatExperience() + iChange < 0)
#endif
	{
#if defined(MOD_UNITS_XP_TIMES_100)
		setNavalCombatExperienceTimes100(0);
#else
		setNavalCombatExperience(0);
#endif
	}
	else
	{
#if defined(MOD_GLOBAL_LOCAL_GENERALS)
#if defined(MOD_UNITS_XP_TIMES_100)
		setNavalCombatExperienceTimes100(getNavalCombatExperienceTimes100() + iChangeTimes100, pFromUnit);
#else
		setNavalCombatExperience(getNavalCombatExperience() + iChange, pFromUnit);
#endif
#else
#if defined(MOD_UNITS_XP_TIMES_100)
		setNavalCombatExperienceTimes100(getNavalCombatExperienceTimes100() + iChangeTimes100);
#else
		setNavalCombatExperience(getNavalCombatExperience() + iChange);
#endif
#endif
	}

#if defined(MOD_UNITS_XP_TIMES_100)
	m_iLifetimeCombatExperienceTimes100 += iChangeTimes100;
#else
	m_iLifetimeCombatExperience += iChange;
#endif
}

//	--------------------------------------------------------------------------------
#if defined(MOD_UNITS_XP_TIMES_100)
int CvPlayer::getLifetimeCombatExperienceTimes100() const
#else
int CvPlayer::getLifetimeCombatExperience() const
#endif
{
#if defined(MOD_UNITS_XP_TIMES_100)
	return m_iLifetimeCombatExperienceTimes100;
#else
	return m_iLifetimeCombatExperience;
#endif
}

#if defined(MOD_GLOBAL_NO_CONQUERED_SPACESHIPS)
//	--------------------------------------------------------------------------------
// Remove all the parts of the spaceship that this player has assembled
void CvPlayer::disassembleSpaceship(CvPlot* pPlot) {
	if (MOD_GLOBAL_NO_CONQUERED_SPACESHIPS && !isMinorCiv() && !isBarbarian()) {
		CUSTOMLOG("Disassemble spaceship for player %i", GetID());
		CvTeam& thisTeam = GET_TEAM(getTeam());

		if (thisTeam.getProjectCount((ProjectTypes) GC.getSPACE_RACE_TRIGGER_PROJECT()) == 1) {
			thisTeam.changeProjectCount((ProjectTypes) GC.getSPACESHIP_CAPSULE(), -1 * thisTeam.getProjectCount((ProjectTypes) GC.getSPACESHIP_CAPSULE()));
			thisTeam.changeProjectCount((ProjectTypes) GC.getSPACESHIP_BOOSTER(), -1 * thisTeam.getProjectCount((ProjectTypes) GC.getSPACESHIP_BOOSTER()));
			thisTeam.changeProjectCount((ProjectTypes) GC.getSPACESHIP_STASIS(), -1 * thisTeam.getProjectCount((ProjectTypes) GC.getSPACESHIP_STASIS()));
			thisTeam.changeProjectCount((ProjectTypes) GC.getSPACESHIP_ENGINE(), -1 * thisTeam.getProjectCount((ProjectTypes) GC.getSPACESHIP_ENGINE()));

			if (pPlot) {
				CUSTOMLOG("Removing launch pad at (%i, %i)", pPlot->getX(), pPlot->getY());
				auto_ptr<ICvPlot1> pDllPlot(new CvDllPlot(pPlot));
				gDLL->GameplaySpaceshipEdited(pDllPlot.get(), 0x0000); // Remove the launch pad
			}
		}
	}
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::getBorderObstacleCount() const
{
	return m_iBorderObstacleCount;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isBorderObstacle() const
{
	return (getBorderObstacleCount() > 0);
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeBorderObstacleCount(int iChange)
{
	if(iChange != 0)
	{
		m_iBorderObstacleCount = (m_iBorderObstacleCount + iChange);
		CvAssert(getBorderObstacleCount() >= 0);
	}
}

#if defined(HH_MOD_BUILDINGS_FRUITLESS_PILLAGE)
//	--------------------------------------------------------------------------------
bool CvPlayer::isBorderGainlessPillage() const
{
	return (m_iBorderGainlessPillageCount > 0);
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeBorderGainlessPillageCount(int iChange)
{
	if(iChange != 0)
	{
		m_iBorderGainlessPillageCount = m_iBorderGainlessPillageCount + iChange;
	}
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::getNetID() const
{
	return CvPreGame::netID(GetID());
}

//	--------------------------------------------------------------------------------
void CvPlayer::setNetID(int iNetID)
{
	CvPreGame::setNetID(GetID(), iNetID);
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isConnected() const
{
	return gDLL->IsPlayerConnected(GetID());
}

//	--------------------------------------------------------------------------------
void CvPlayer::sendTurnReminder()
{
	//Send a game invite to the player if they aren't currently connected to the game.
	gDLL->sendTurnReminder(GetID());

	/* email notifications not implimented.
	if(!getPbemEmailAddress().empty() &&
	        !gDLL->GetPitbossSmtpHost().empty())
	{

	}
	*/
}

//	--------------------------------------------------------------------------------
uint CvPlayer::getStartTime() const
{
	return m_uiStartTime;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setStartTime(uint uiStartTime)
{
	m_uiStartTime = uiStartTime;
}


//	--------------------------------------------------------------------------------
uint CvPlayer::getTotalTimePlayed() const
{
	return ((timeGetTime() - m_uiStartTime)/1000);
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isMinorCiv() const
{
	return CvPreGame::isMinorCiv(m_eID);
}


#if defined(MOD_API_EXTENSIONS)
//	--------------------------------------------------------------------------------
bool CvPlayer::isMajorCiv() const
{
	return GET_TEAM(getTeam()).isMajorCiv();
}
#endif


//	--------------------------------------------------------------------------------
/// Has this player betrayed a Minor Civ he was bullying by declaring war on him?
bool CvPlayer::IsHasBetrayedMinorCiv() const
{
	return m_bHasBetrayedMinorCiv;
}

//	--------------------------------------------------------------------------------
/// Sets this player to have betrayed a Minor Civ he was bullying by declaring war on him
void CvPlayer::SetHasBetrayedMinorCiv(bool bValue)
{
	if(IsHasBetrayedMinorCiv() != bValue)
	{
		m_bHasBetrayedMinorCiv = bValue;
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::setAlive(bool bNewValue, bool bNotify)
{
	CvString strBuffer;
	int iI;

	if(isAlive() != bNewValue)
	{
		m_bAlive = bNewValue;

		GET_TEAM(getTeam()).changeAliveCount((isAlive()) ? 1 : -1);

		GC.getGame().GetGameLeagues()->DoPlayerAliveStatusChanged(GetID());

		// Tell Minor Civ AI what's up so that it knows when to add/remove bonuses for players it's friends with
		if(isMinorCiv())
		{
			GetMinorCivAI()->DoChangeAliveStatus(bNewValue);
		}

		if(isAlive())
		{
			if(!isEverAlive() && !isObserver())
			{
				m_bEverAlive = true;

				GET_TEAM(getTeam()).changeEverAliveCount(1);
			}

			if(getNumCities() == 0)
			{
				setFoundedFirstCity(false);
			}

			GET_TEAM(getTeam()).SetKilledByTeam(NO_TEAM);

			if(isSimultaneousTurns() || (GC.getGame().getNumGameTurnActive() == 0) || (GC.getGame().isSimultaneousTeamTurns() && GET_TEAM(getTeam()).isTurnActive()))
			{
				setTurnActive(true);
			}

			gDLL->openSlot(GetID());
		}
		else
		{
			clearResearchQueue();
			killUnits();
			killCities();
			if(CvPreGame::isNetworkMultiplayerGame() && m_eID == GC.getGame().getActivePlayer())
				gDLL->netDisconnect();

			if (!GET_TEAM(getTeam()).isAlive())
			{
				for (int i = 0; i < MAX_TEAMS; i++)
				{
					TeamTypes eTheirTeam = (TeamTypes)i;
					if (getTeam() != eTheirTeam)
					{
						// close both embassies
						GET_TEAM(getTeam()).CloseEmbassyAtTeam(eTheirTeam);
						GET_TEAM(eTheirTeam).CloseEmbassyAtTeam(getTeam());

						// cancel any research agreements
						GET_TEAM(getTeam()).CancelResearchAgreement(eTheirTeam);
						GET_TEAM(eTheirTeam).CancelResearchAgreement(getTeam());

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
						if (MOD_DIPLOMACY_CIV4_FEATURES) {
							GET_TEAM(getTeam()).DoEndVassal(eTheirTeam, true, true);
							GET_TEAM(eTheirTeam).DoEndVassal(getTeam(), true, true);
						}
#endif
#if defined(MOD_BALANCE_CORE)
						GET_TEAM(getTeam()).setAtWar(eTheirTeam, false, false);
						GET_TEAM(eTheirTeam).setAtWar(getTeam(), false, false);
#endif
					}
				}
			}

			// Reset incoming units
			for(int iLoop = 0; iLoop < MAX_PLAYERS; iLoop++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes) iLoop;
				SetIncomingUnitCountdown(eLoopPlayer, -1);
				SetIncomingUnitType(eLoopPlayer, NO_UNIT);
#if defined(MOD_BALANCE_CORE)
				// forget any denouncing
				GetDiplomacyAI()->SetDenouncedPlayer(eLoopPlayer, false);
				GET_PLAYER(eLoopPlayer).GetDiplomacyAI()->SetDenouncedPlayer(GetID(), false);
				GET_PLAYER(eLoopPlayer).recomputeGreatPeopleModifiers(); //if we are getting any modifiers from denouncement
#endif
			}

			GC.getGame().GetGameDeals().DoCancelAllDealsWithPlayer(GetID());

			// Reset relationships with minor civs
			for(int iPlayerLoop = MAX_MAJOR_CIVS; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
			{
				PlayerTypes eOtherPlayer = (PlayerTypes) iPlayerLoop;
				GET_PLAYER(eOtherPlayer).GetMinorCivAI()->ResetFriendshipWithMajor(GetID());
			}

			setTurnActive(false);

			gDLL->closeSlot(GetID());

			if(bNotify && !isBarbarian())
			{
				Localization::String strMessage = Localization::Lookup("TXT_KEY_MISC_CIV_DESTROYED");
				strMessage << getCivilizationAdjectiveKey();
				Localization::String strSummary = Localization::Lookup("TXT_KEY_MISC_CIV_DESTROYED_SHORT");
				strSummary << getCivilizationShortDescriptionKey();

				for(iI = 0; iI < MAX_PLAYERS; iI++)
				{
					const PlayerTypes eOtherPlayer = static_cast<PlayerTypes>(iI);
					CvPlayerAI& kOtherPlayer = GET_PLAYER(eOtherPlayer);

					if(kOtherPlayer.isAlive() && kOtherPlayer.GetNotifications())
					{
						kOtherPlayer.GetNotifications()->Add(NOTIFICATION_PLAYER_KILLED, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, -1);
					}
				}

				GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, GetID(), strMessage.toUTF8(), -1, -1);
			}

			GC.getGame().testVictory();
		}

		GC.getGame().setScoreDirty(true);
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::setBeingResurrected(bool bValue)
{
	if (m_bBeingResurrected != bValue)
	{
		m_bBeingResurrected = bValue;
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::verifyAlive()
{
	bool bKill;

	if(isAlive())
	{
		bKill = false;

		if(!bKill)
		{
			if(!isBarbarian())
			{
				if(getNumCities() == 0 && getAdvancedStartPoints() < 0)
				{
					if((getNumUnits() == 0) || (!(GC.getGame().isOption(GAMEOPTION_COMPLETE_KILLS)) && isFoundedFirstCity()))
					{
						if(!GetPlayerTraits()->IsStaysAliveZeroCities())
						{
							bKill = true;
						}
					}
				}
			}
		}

		if(!bKill)
		{
			if(!isBarbarian())
			{
				if(GC.getGame().getMaxCityElimination() > 0)
				{
					if(getCitiesLost() >= GC.getGame().getMaxCityElimination())
					{
						bKill = true;
					}
				}
			}
		}

		if(bKill)
		{
			setAlive(false, false);
		}
	}
	else
	{
		if((getNumCities() > 0) || (getNumUnits() > 0))
		{
			setAlive(true);
		}
	}
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isTurnActive() const
{
	return m_bTurnActive;
}

//	--------------------------------------------------------------------------------
void CvPlayer::setTurnActiveForPbem(bool bActive)
{
	CvAssertMsg(GC.getGame().isPbem(), "You are using setTurnActiveForPbem. Are you sure you know what you're doing?");

	// does nothing more than to set the member variable before saving the game
	// the rest of the turn will be performed upon loading the game
	// This allows the player to browse the game in paused mode after he has generated the save
	if(isTurnActive() != bActive)
	{
		m_bTurnActive = bActive;
		GC.getGame().changeNumGameTurnActive(isTurnActive() ? 1 : -1, "setTurnActiveForPlayByEmail");
	}
}


//	--------------------------------------------------------------------------------
void CvPlayer::setTurnActive(bool bNewValue, bool bDoTurn) // R: bDoTurn default is true (CvPlayer.h)
{
	if(isTurnActive() != bNewValue)
	{
		CvGame& kGame = GC.getGame();
		CvMap& theMap = GC.getMap();
		m_bTurnActive = bNewValue; // R: this is causing the AI playing twice in one turn bug
#if defined(MOD_BUGFIX_AI_DOUBLE_TURN_MP_LOAD)
		// DN: There is a strange issue with players missing their turns after loading a game, with the AI getting two turns in a row.
		// It seems *to me* that Civ is incorrectly thinking telling us that the players have already indicated they have finished their turns
		// A hacky solution to this is to tell Civ to cancel the player turn complete state.
		// Otherwise they get their turn ended in the next call to updateMoves after the condition (!player.isEndTurn() && gDLL->HasReceivedTurnComplete(player.GetID()) && player.isHuman())
		// R: the function CancelActivePlayerEndTurn() does not help with this issue, because player.isEndTurn() == False, only gDLL->HasReceivedTurnComplete(player.GetID()) seems to catch this issue, was there a wrong gDLL->sendTurnComplete() somewhere?
		// in addition, this bug does not advance the turn count
		// also, the players do not really miss their turns, what actually happens is that the AI plays twice in one turn
		if(bNewValue)
			if(kGame.isFirstActivationOfPlayersAfterLoad())
				if(isHuman() && isAlive() && isSimultaneousTurns() && isLocalPlayer())
					if(gDLL->HasReceivedTurnComplete(GetID()))
						gDLL->sendTurnUnready();
#endif
		DLLUI->PublishEndTurnDirty();

		/////////////////////////////////////////////
		// TURN IS BEGINNING
		/////////////////////////////////////////////

		if(isTurnActive())
		{
			CvAssertMsg(isAlive(), "isAlive is expected to be true");

			setEndTurn(false);

			DoUnitAttrition();

#if defined(MOD_CORE_DELAYED_VISIBILITY)
			//force update in case one of our units was killed or moved
			for (int iI = 0; iI < theMap.numPlots(); iI++)
				theMap.plotByIndexUnchecked(iI)->flipVisibility(getTeam());
#endif

			if(kGame.getActivePlayer() == m_eID)
				theMap.updateDeferredFog();

			if((kGame.isHotSeat() || kGame.isPbem()) && isHuman() && bDoTurn)
			{
				DLLUI->clearEventMessages();

				kGame.setActivePlayer(GetID());
			}

			if(CvPreGame::isPitBoss() && kGame.getActivePlayer() != m_eID && isHuman() && gDLL->IsHost() && !isConnected())
			{//send turn reminder if the player isn't actively connected to the game.
				sendTurnReminder();
			}

			std::ostringstream infoStream;
			infoStream << "setTurnActive(true) for player ";
			infoStream << (int)GetID();	infoStream << " ";
			infoStream << getName();
			kGame.changeNumGameTurnActive(1, infoStream.str());
			infoStream << std::endl;
			//if (isMajorCiv() || isBarbarian()) OutputDebugString(infoStream.str().c_str());

			DLLUI->PublishPlayerTurnStatus(DLLUIClass::TURN_START, GetID());

			if(bDoTurn)
			{
				SetAllUnitsUnprocessed();

#if defined(MOD_CORE_CACHE_REACHABLE_PLOTS)
				ResetReachablePlotsForAllUnits();
#endif

				{
					AI_PERF_FORMAT("AI-perf.csv", ("Connections/Gold, Turn %03d, %s", kGame.getElapsedGameTurns(), getCivilizationShortDescription()) );

					// This block all has things which might change based on city connections changing
					m_pCityConnections->Update();
					GetTreasury()->DoUpdateCityConnectionGold();
				}

				if(kGame.isFinalInitialized())
				{
					if(isAlive())
					{
						if(GetDiplomacyRequests())
						{
							GetDiplomacyRequests()->BeginTurn();
						}

						//this is misleading - actual turn processing now happens in CvGame::updateMoves()
						doTurn();
						doTurnUnits();
					}
				}

				if((GetID() == kGame.getActivePlayer()) && (kGame.getElapsedGameTurns() > 0))
				{
					if(kGame.isNetworkMultiPlayer())
					{
						DLLUI->AddMessage(0, GetID(), true, GC.getEVENT_MESSAGE_TIME(), GetLocalizedText("TXT_KEY_MISC_TURN_BEGINS").GetCString(), "AS2D_NEWTURN", MESSAGE_TYPE_DISPLAY_ONLY);
					}
				}

				doWarnings();
			}

#if defined(MOD_ACTIVE_DIPLOMACY)
			if(GC.getGame().isReallyNetworkMultiPlayer() && MOD_ACTIVE_DIPLOMACY)
			{
				if (isHuman())
				{
					// JdH: we just activated a human
					// later the AI players need to try to contact the player
					CvDiplomacyRequests::s_aDiploHumans.push_back(GetID());
				}
			}
#endif

			if(GetID() == kGame.getActivePlayer())
			{
				if(DLLUI->GetLengthSelectionList() == 0)
				{
					DLLUI->setCycleSelectionCounter(1);
				}

				DLLUI->setDirty(SelectionCamera_DIRTY_BIT, true);

				// slewis - added this so the tutorial knows when a turn begins
				DLLUI->PublishActivePlayerTurnStart();
			}
			else if(isHuman() && kGame.isGameMultiPlayer())
			{
				DLLUI->PublishRemotePlayerTurnStart();
			}
		}

		/////////////////////////////////////////////
		// TURN IS ENDING
		/////////////////////////////////////////////

		else
		{
#if defined(MOD_CORE_DELAYED_VISIBILITY)
			//visibility expires now!
			for (int iI = 0; iI < theMap.numPlots(); iI++)
				theMap.plotByIndexUnchecked(iI)->flipVisibility(getTeam());
#endif

#if defined(MOD_EVENTS_RED_TURN)
			if (MOD_EVENTS_RED_TURN)
			// RED <<<<<
			{
				ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
				if(pkScriptSystem)
				{	
					CvLuaArgsHandle args;

					args->Push(GetID());

					bool bResult;
					LuaSupport::CallHook(pkScriptSystem, "PlayerEndTurnInitiated", args.get(), bResult);
				}
			}
			// RED >>>>>
#endif

			CvAssertFmt(GetEndTurnBlockingType() == NO_ENDTURN_BLOCKING_TYPE, "Expecting the end-turn blocking to be NO_ENDTURN_BLOCKING_TYPE, got %d", GetEndTurnBlockingType());
			SetEndTurnBlocking(NO_ENDTURN_BLOCKING_TYPE, -1);	// Make sure this is clear so the UI doesn't block when it is not our turn.

			//important: healing and restoration of movement points
			DoUnitReset();

			if(!isHuman())
			{
				RespositionInvalidUnits();
			}

			if(GetNotifications())
			{
				GetNotifications()->EndOfTurnCleanup();
			}

			if(GetDiplomacyRequests())
			{
				GetDiplomacyRequests()->EndTurn();
			}

			if(GetID() == kGame.getActivePlayer())
			{
				DLLUI->PublishActivePlayerTurnEnd();
			}

			if (!isHuman() || (isHuman() && !isAlive()) || (isHuman() && gDLL->HasReceivedTurnAllComplete(GetID())) || kGame.getAIAutoPlay())
			{
				std::ostringstream infoStream;
				infoStream << "setTurnActive(false) for player ";
				infoStream << (int)GetID(); infoStream << " ";
				infoStream << getName();
				kGame.changeNumGameTurnActive(-1, infoStream.str());
				infoStream << std::endl;
				//if (isMajorCiv() || isBarbarian()) OutputDebugString(infoStream.str().c_str());
			}

#if defined(MOD_EVENTS_RED_TURN)
			if (MOD_EVENTS_RED_TURN)
			// RED <<<<<
			{
				ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
				if(pkScriptSystem)
				{	
					CvLuaArgsHandle args;

					args->Push(GetID());

					bool bResult;
					LuaSupport::CallHook(pkScriptSystem, "PlayerEndTurnCompleted", args.get(), bResult);
				}
			}
			// RED >>>>>
#endif

			DLLUI->PublishPlayerTurnStatus(DLLUIClass::TURN_END, GetID());
		}
	}
	else
	{
		CvString logOutput;
		logOutput.Format("SetTurnActive() called without changing the end turn status. Player(%i) OldTurnActive(%i) NewTurnActive(%i)", GetID(), isTurnActive(), bNewValue);
		gDLL->netMessageDebugLog(logOutput);
	}
}

//	----------------------------------------------------------------------------
bool CvPlayer::isSimultaneousTurns() const
{
	if(GC.getGame().isOption(GAMEOPTION_DYNAMIC_TURNS))
	{//in dynamic turns mode, our turn mode varies
		return m_bDynamicTurnsSimultMode;
	}
	else if(GC.getGame().isOption(GAMEOPTION_SIMULTANEOUS_TURNS))
	{
		return true;
	}

	return false;
}


//	----------------------------------------------------------------------------
void CvPlayer::setDynamicTurnsSimultMode(bool simultaneousTurns)
{
	if(simultaneousTurns != m_bDynamicTurnsSimultMode)
	{
		CvNotifications* pNotifications = GetNotifications();
		if (pNotifications)
		{
			NotificationTypes notifyType = NOTIFICATION_TURN_MODE_SEQUENTIAL;
			Localization::String localizedText = Localization::Lookup("TXT_KEY_NOTIFICATION_TURN_MODE_SEQUENTIAL");
			Localization::String localizedTextSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_TURN_MODE_SEQUENTIAL_SUMMARY");
			if(simultaneousTurns)
			{
				notifyType = NOTIFICATION_TURN_MODE_SIMULTANEOUS;
				localizedText = Localization::Lookup("TXT_KEY_NOTIFICATION_TURN_MODE_SIMULTANEOUS");
				localizedTextSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_TURN_MODE_SIMULTANEOUS_SUMMARY");
			}

			pNotifications->Add(notifyType, localizedText.toUTF8(), localizedTextSummary.toUTF8(), -1, -1, -1);
		}

		m_bDynamicTurnsSimultMode = simultaneousTurns;
	}
	
}

//	----------------------------------------------------------------------------
bool CvPlayer::isAutoMoves() const
{
	return m_bAutoMoves;
}

//	----------------------------------------------------------------------------
void CvPlayer::setAutoMoves(bool bNewValue)
{
	if(isAutoMoves() != bNewValue)
	{
		m_bAutoMoves = bNewValue;
		m_bProcessedAutoMoves = false;
	}
}

//	----------------------------------------------------------------------------
bool CvPlayer::hasProcessedAutoMoves() const
{
	return m_bProcessedAutoMoves;
}

//	----------------------------------------------------------------------------
void CvPlayer::setProcessedAutoMoves(bool bNewValue)
{
	if(hasProcessedAutoMoves() != bNewValue)
	{
		m_bProcessedAutoMoves = bNewValue;
	}
}

//	----------------------------------------------------------------------------
bool CvPlayer::isEndTurn() const
{
	return m_bEndTurn;
}

//	------------------------------------------------------------------------------------------------
void CvPlayer::setEndTurn(bool bNewValue)
{
	CvGame& game = GC.getGame();

	if(isSimultaneousTurns()
		&& bNewValue 
		&& game.isNetworkMultiPlayer() 
		&& !gDLL->HasReceivedTurnAllCompleteFromAllPlayers())
	{//When doing simultaneous turns in multiplayer, we don't want anyone to end their turn until everyone has signalled TurnAllComplete.
		// No setting end turn to true until all the players have sent the TurnComplete network message
		return;
	}

	// If this is a remote player in an MP match, don't
	// honor the end of turn request if the player still
	// has units to run the simulation for the turn
	if(!isEndTurn() && isHuman() && GetID() != game.getActivePlayer())
	{
		if(hasBusyUnitOrCity() || (!gDLL->HasReceivedTurnComplete(GetID()) && hasReadyUnit()))
		{
			return;
		}
	}
	else if(!isHuman())
	{
		if(hasBusyUnitOrCity())
		{
			return;
		}
	}

	if(isEndTurn() != bNewValue)
	{
		//  If the game isn't MP and the player has queued popups force him to deal with them first
		if(!GC.getGame().isGameMultiPlayer())
		{
			//if (GC.GetEngineUserInterface()->isPopupQueued())
			//{
			//	GC.GetEngineUserInterface()->setForcePopup(true);
			//	return;
			//}
			//if (GC.GetEngineUserInterface()->isDiploOrPopupWaiting())
			//{
			//	return;
			//}
		}

		CvAssertMsg(isTurnActive(), "isTurnActive is expected to be true");

		m_bEndTurn = bNewValue;

		if(isEndTurn())
		{
			if(!GC.getGame().isOption(GAMEOPTION_DYNAMIC_TURNS) && GC.getGame().isOption(GAMEOPTION_SIMULTANEOUS_TURNS))
			{//fully simultaneous turns only run automoves after every human has moved.
				checkRunAutoMovesForEveryone();
			}
			else
			{
				setAutoMoves(true);
			}
		}
		else
			setAutoMoves(false);
	}
	else
	{
		// This check is here for the AI.  Currently, the setEndTurn(true) never seems to get called for AI players, the automoves are just set directly
		// Why is this?  It would be great if all players were processed the same.
		if(!bNewValue && isAutoMoves())
			setAutoMoves(false);
	}
}

//	---------------------------------------------------------------------------
void CvPlayer::checkRunAutoMovesForEveryone()
{
	bool runAutoMovesForEveryone = true;
	int i = 0;
	for(i = 0; i < MAX_PLAYERS; ++i)
	{
		CvPlayer& p = CvPlayerAI::getPlayer((PlayerTypes)i);
		if(p.isHuman() && !p.isObserver() 
			// Check to see if this human player hasn't gotten to the end turn phase of their turn.  
			// This gets tricky because hot joiners can hop into an ai civ that already finished their turn.
			// When this occurs, the hot joiner will not be turn active, will have already run their automoves,
			// and not have end turn set. (AIs do not set end turn) *sigh*
			// To handle that case, we assume that human players who are not endturn and turn inactive after TurnAllComplete
			// are ready for the human automoves phase.
			&& (!p.isEndTurn()
			&& (!gDLL->HasReceivedTurnAllCompleteFromAllPlayers() || p.isTurnActive()))) 
		{
			runAutoMovesForEveryone = false;
			break;
		}
	}

	if(runAutoMovesForEveryone)
	{
		for(i = 0; i < MAX_PLAYERS; ++i)
		{
			CvPlayer& p = CvPlayerAI::getPlayer((PlayerTypes)i);
			if(p.isHuman())
			{
				p.setAutoMoves(true);
			}
		}
	}
}

//	---------------------------------------------------------------------------
EndTurnBlockingTypes CvPlayer::GetEndTurnBlockingType(void) const
{
	return m_eEndTurnBlockingType;
}

//	---------------------------------------------------------------------------
int CvPlayer::GetEndTurnBlockingNotificationIndex(void) const
{
	return m_iEndTurnBlockingNotificationIndex;
}

//	---------------------------------------------------------------------------
void CvPlayer::SetEndTurnBlocking(EndTurnBlockingTypes eBlockingType, int iNotificationIndex)
{
	bool bFireEvent = false;
	if(m_eEndTurnBlockingType != eBlockingType || m_iEndTurnBlockingNotificationIndex != iNotificationIndex)
	{
		bFireEvent = true;
	}

	EndTurnBlockingTypes ePrevBlockingType = m_eEndTurnBlockingType;
	m_eEndTurnBlockingType = eBlockingType;
	m_iEndTurnBlockingNotificationIndex = iNotificationIndex;

	if(bFireEvent)
	{
		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->SetEndTurnBlockingChanged( ePrevBlockingType, m_eEndTurnBlockingType );
			GC.GetEngineUserInterface()->UpdateEndTurn();
		}
	}
}

//	---------------------------------------------------------------------------
bool CvPlayer::isTurnDone() const
{
	// if this returns true, popups and diplomacy will wait to appear until next turn
	if(!GC.getGame().isPbem() && !GC.getGame().isHotSeat())
	{
		return false;
	}
	if(!isHuman())
	{
		return true;
	}
	if(!isEndTurn())
	{
		return false;
	}
	return (!isAutoMoves());
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isExtendedGame() const
{
	return m_bExtendedGame;
}


//	--------------------------------------------------------------------------------
void CvPlayer::makeExtendedGame()
{
	m_bExtendedGame = true;
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isFoundedFirstCity() const
{
	return m_bFoundedFirstCity;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setFoundedFirstCity(bool bNewValue)
{
	if(isFoundedFirstCity() != bNewValue)
	{
		m_bFoundedFirstCity = bNewValue;

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(PercentButtons_DIRTY_BIT, true);
			GC.GetEngineUserInterface()->setDirty(ResearchButtons_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumCitiesFounded() const
{
	return m_iNumCitiesFounded;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumCitiesFounded(int iValue)
{
	m_iNumCitiesFounded += iValue;
}

//	--------------------------------------------------------------------------------
// check to see if we defeated this other player
void CvPlayer::CheckForMurder(PlayerTypes ePossibleVictimPlayer)
{
	// Cache whether the player is human or not.  If the player is killed, the CvPreGame::slotStatus is changed to SS_CLOSED
	// but the slot status is used to determine if the player is human or not, so it looks like it is an AI!
	// This should be fixed, but might have unforeseen ramifications so...
	CvPlayer& kPossibleVictimPlayer = GET_PLAYER(ePossibleVictimPlayer);
	bool bPossibileVictimIsHuman = kPossibleVictimPlayer.isHuman();

	// This may 'kill' the player if it is deemed that he does not have the proper units to stay alive
	kPossibleVictimPlayer.verifyAlive();

	// You... you killed him!
	if(!kPossibleVictimPlayer.isAlive())
	{
		GET_TEAM(kPossibleVictimPlayer.getTeam()).SetKilledByTeam(getTeam());
		kPossibleVictimPlayer.SetEverConqueredBy(m_eID, true);

		// Leader pops up and whines
		if(!CvPreGame::isNetworkMultiplayerGame())		// Not in MP
		{
			if(!bPossibileVictimIsHuman && !kPossibleVictimPlayer.isMinorCiv() && !kPossibleVictimPlayer.isBarbarian())
				kPossibleVictimPlayer.GetDiplomacyAI()->DoKilledByPlayer(GetID());
		}

		// do post-dying clean up
		if (!kPossibleVictimPlayer.isMinorCiv())
		{
			for (uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
			{
				PlayerTypes eCleanupPlayer = (PlayerTypes)ui;
				GET_PLAYER(eCleanupPlayer).GetDiplomacyAI()->KilledPlayerCleanup(kPossibleVictimPlayer.GetID());
			}
		}
#if defined(MOD_BALANCE_CORE)
		DoWarVictoryBonuses();
#endif
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isStrike() const
{
	return m_bStrike;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setStrike(bool bNewValue)
{
	if(m_bStrike != bNewValue)
	{
		m_bStrike = bNewValue;

		if(m_bStrike)
		{
			if(GetID() == GC.getGame().getActivePlayer())
			{
				GC.GetEngineUserInterface()->AddMessage(0, GetID(), false, GC.getEVENT_MESSAGE_TIME(), GetLocalizedText("TXT_KEY_MISC_UNITS_ON_STRIKE").GetCString(), "AS2D_STRIKE", MESSAGE_TYPE_MINOR_EVENT, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_WARNING_TEXT"));

				GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
			}
		}
	}
}


//	--------------------------------------------------------------------------------
/// Is the player is cramped in his current area?
bool CvPlayer::IsCramped() const
{
	return m_bCramped;
}

//	--------------------------------------------------------------------------------
/// Determines if the player is cramped in his current area.  Not a perfect algorithm, as it will double-count Plots shared by different Cities, but it should be good enough
void CvPlayer::DoUpdateCramped()
{
	CvCity* pLoopCity;
	CvPlot* pPlot;

	int iTotalPlotsNearby = 0;
	int iUsablePlotsNearby = 0;

	int iRange = GC.getCRAMPED_RANGE_FROM_CITY();

	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		for(int iX = -iRange; iX <= iRange; iX++)
		{
			for(int iY = -iRange; iY <= iRange; iY++)
			{
				pPlot = plotXYWithRangeCheck(pLoopCity->getX(), pLoopCity->getY(), iX, iY, iRange);

				if(pPlot != NULL)
				{
					// Plot not owned by me
					if(!pPlot->isOwned() || pPlot->getOwner() != GetID())
					{
						iTotalPlotsNearby++;

						// A "good" unowned Plot
						if(!pPlot->isOwned() && pPlot->isValidMovePlot(GetID()) && !pPlot->isWater())
						{
							iUsablePlotsNearby++;
						}
					}
				}
			}
		}
	}

	if(iTotalPlotsNearby > 0)
	{
		if(100 * iUsablePlotsNearby / iTotalPlotsNearby <= GC.getCRAMPED_USABLE_PLOT_PERCENT())	// 20
		{
			m_bCramped = true;
		}
		else
		{
			m_bCramped = false;
		}
	}
}

//	--------------------------------------------------------------------------------
const CvHandicapInfo& CvPlayer::getHandicapInfo() const
{
	CvHandicapInfo* pkHandicapInfo = GC.getHandicapInfo(getHandicapType());
	if(pkHandicapInfo == NULL)
	{
		const char* szError = "ERROR: Player does not contain valid handicap!!";
		GC.LogMessage(szError);
		CvAssertMsg(false, szError);

		// it hurts but we have to - whoever designed this should be whipped
#pragma warning ( push )
#pragma warning(disable:4172) //returning address of temporary
		return CvHandicapInfo();
#pragma warning ( pop )
	}

#pragma warning ( push )
#pragma warning ( disable : 6011 ) // Dereferencing NULL pointer
	return *pkHandicapInfo;
#pragma warning ( pop )
}

//	--------------------------------------------------------------------------------
HandicapTypes CvPlayer::getHandicapType() const
{
	return CvPreGame::handicap(GetID());
}

//	--------------------------------------------------------------------------------
const CvCivilizationInfo& CvPlayer::getCivilizationInfo() const
{
	CvCivilizationInfo* pkCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
	if(pkCivilizationInfo == NULL)
	{
		const char* szError = "ERROR: Player does not contain valid civilization type!!";
		GC.LogMessage(szError);
		CvAssertMsg(false, szError);

		// it hurts but we have to - whoever designed this should be whipped
#pragma warning ( push )
#pragma warning(disable:4172) //returning address of temporary
		return CvCivilizationInfo();
#pragma warning ( pop )
	}

#pragma warning ( push )
#pragma warning ( disable : 6011 ) // Dereferencing NULL pointer
	return *pkCivilizationInfo;
#pragma warning ( pop )
}

//	--------------------------------------------------------------------------------
CivilizationTypes CvPlayer::getCivilizationType() const
{
	return CvPreGame::civilization(GetID());
}


//	--------------------------------------------------------------------------------
const CvLeaderHeadInfo& CvPlayer::getLeaderInfo() const
{
	CvLeaderHeadInfo* pkLeaderInfo = GC.getLeaderHeadInfo(getLeaderType());
	if(pkLeaderInfo == NULL)
	{
		const char* szError = "ERROR: Player does not contain valid leader type!!";
		GC.LogMessage(szError);
		CvAssertMsg(false, szError);

		// it hurts but we have to - whoever designed this should be whipped
#pragma warning ( push )
#pragma warning(disable:4172) //returning address of temporary
		return CvLeaderHeadInfo();
#pragma warning ( pop )
	}

#pragma warning ( push )
#pragma warning ( disable : 6011 ) // Dereferencing NULL pointer
	return *pkLeaderInfo;
#pragma warning ( pop )
}

//	--------------------------------------------------------------------------------
LeaderHeadTypes CvPlayer::getLeaderType() const
{
	return CvPreGame::leaderHead(GetID());
}
#if defined(MOD_API_EXTENSIONS)
//	--------------------------------------------------------------------------------
void CvPlayer::setLeaderType(LeaderHeadTypes eNewLeader)
{
    if (isMajorCiv())
	{
		LeaderHeadTypes eOldLeader = getLeaderType();
		
		// Set the new leader type
		CvPreGame::setLeaderHead(GetID(), eNewLeader);
	
		// Update the player's personality
		setPersonalityType(eNewLeader);
	
		// Update the player's traits (Leader_Traits)
		GetPlayerTraits()->Reset();
		GetPlayerTraits()->InitPlayerTraits();
		recomputePolicyCostModifier();
		
		if (!isHuman()) {
			// Update the player's biases (Leader_MajorCivApproachBiases)
			// Nothing to do as they are not cached in CvPlayer
	
			// Update the player's flavours (Leader_Flavors)
			GetFlavorManager()->ChangeLeader(eOldLeader, eNewLeader);
			
			// Update the player's strategies
			// Nothing to do as these will auto-update based on the new flavours at the end of the player's turn
		}
	}
}
#endif

//	--------------------------------------------------------------------------------
LeaderHeadTypes CvPlayer::getPersonalityType() const
{
	return m_ePersonalityType;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setPersonalityType(LeaderHeadTypes eNewValue)
{
	m_ePersonalityType = eNewValue;
}


//	--------------------------------------------------------------------------------
EraTypes CvPlayer::GetCurrentEra() const
{
	return GET_TEAM(getTeam()).GetCurrentEra();
}

//	--------------------------------------------------------------------------------
void CvPlayer::setTeam(TeamTypes eTeam)
{
	CvAssert(eTeam != NO_TEAM);
	CvAssert(getTeam() != NO_TEAM);

	GET_TEAM(getTeam()).changeNumMembers(-1);
	if(isAlive())
	{
		GET_TEAM(getTeam()).changeAliveCount(-1);
	}
	if(isEverAlive())
	{
		GET_TEAM(getTeam()).changeEverAliveCount(-1);
	}
	GET_TEAM(getTeam()).changeNumCities(-(getNumCities()));
	GET_TEAM(getTeam()).changeTotalPopulation(-(getTotalPopulation()));
	GET_TEAM(getTeam()).changeTotalLand(-(getTotalLand()));

#if defined(MOD_BALANCE_CORE)
	GET_TEAM(getTeam()).removePlayer(GetID());
#endif

	CvPreGame::setTeamType(GetID(), eTeam);

#if defined(MOD_BALANCE_CORE)
	if (GET_TEAM(getTeam()).addPlayer(GetID()))
		GET_TEAM(getTeam()).changeNumMembers(1);
#else
	GET_TEAM(getTeam()).changeNumMembers(1);
#endif

	if(isAlive())
	{
		GET_TEAM(getTeam()).changeAliveCount(1);
	}
	if(isEverAlive())
	{
		GET_TEAM(getTeam()).changeEverAliveCount(1);
	}
	GET_TEAM(getTeam()).changeNumCities(getNumCities());
	GET_TEAM(getTeam()).changeTotalPopulation(getTotalPopulation());
	GET_TEAM(getTeam()).changeTotalLand(getTotalLand());
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsAITeammateOfHuman() const
{
	bool bRtnValue = false;

#if defined(MOD_BALANCE_CORE)
	const std::vector<PlayerTypes>& teammates = GET_TEAM(getTeam()).getPlayers();
	for (size_t i = 0; i < teammates.size(); ++i)
	{
		CvPlayer& player = GET_PLAYER(teammates[i]);
#else
	for(int i = 0; i < MAX_PLAYERS; ++i)
	{
		CvPlayer& player = GET_PLAYER(static_cast<PlayerTypes>(i));
#endif
		if (player.isHuman() && player.isAlive())
		{
			if(player.getTeam() == getTeam())
			{
				bRtnValue = true;
				break;
			}
		}
	}

	return bRtnValue;
}

//	--------------------------------------------------------------------------------
PlayerColorTypes CvPlayer::getPlayerColor() const
{
	return CvPreGame::playerColor(GetID());
}

//	--------------------------------------------------------------------------------
const CvColorA& CvPlayer::getPlayerTextColor() const
{
	CvAssertMsg(getPlayerColor() != NO_PLAYERCOLOR, "getPlayerColor() is not expected to be equal with NO_PLAYERCOLOR");
	CvPlayerColorInfo* pkPlayerColorInfo = GC.GetPlayerColorInfo(getPlayerColor());
	CvColorInfo* pkColorInfo = NULL;
	if(pkPlayerColorInfo)
	{
		ColorTypes eTextColor = static_cast<ColorTypes>(pkPlayerColorInfo->GetColorTypeText());
		pkColorInfo = GC.GetColorInfo(eTextColor);
		if(pkColorInfo)
			return pkColorInfo->GetColor();
	}

	//Default to black text if no color exists.
	static CvColorA black(0,0,0,1.0f);
	return black;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getSeaPlotYield(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiSeaPlotYield[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeSeaPlotYield(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiSeaPlotYield.setAt(eIndex, m_aiSeaPlotYield[eIndex] + iChange);

		updateYield();
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getYieldRateModifier(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldRateModifier[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldRateModifier(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldRateModifier.setAt(eIndex, m_aiYieldRateModifier[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
#if defined(MOD_BALANCE_CORE_POLICIES)
int CvPlayer::GetApproachScratchValue(PlayerTypes ePlayer, MajorCivApproachTypes eMajorCivApproach) const
{
	CvAssertMsg(ePlayer >= 0, "ePlayer expected to be >= 0");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer expected to be < MAX_MAJOR_CIVS");
	CvAssertMsg(eMajorCivApproach >= 0, "eMajorCivApproach expected to be >= 0");
	CvAssertMsg(eMajorCivApproach < NUM_MAJOR_CIV_APPROACHES, "eMajorCivApproach expected to be < NUM_MAJOR_CIV_APPROACHES");
	return  m_ppiApproachScratchValue[ePlayer][eMajorCivApproach];
}
void CvPlayer::SetApproachScratchValue(PlayerTypes ePlayer, MajorCivApproachTypes eMajorCivApproach, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "ePlayer expected to be >= 0");
	CvAssertMsg(ePlayer < MAX_MAJOR_CIVS, "ePlayer expected to be < MAX_MAJOR_CIVS");
	CvAssertMsg(eMajorCivApproach >= 0, "eMajorCivApproach expected to be >= 0");
	CvAssertMsg(eMajorCivApproach < NUM_MAJOR_CIV_APPROACHES, "eMajorCivApproach expected to be < NUM_MAJOR_CIV_APPROACHES");

	if(iValue != 0)
	{
		m_ppiApproachScratchValue[ePlayer][eMajorCivApproach] = iValue;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetTradeReligionModifier() const
{
	return m_iTradeReligionModifier;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeTradeReligionModifier(int iChange)
{
	m_iTradeReligionModifier += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromBirth(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldFromBirth[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromBirth(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldFromBirth.setAt(eIndex, m_aiYieldFromBirth[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromBirthCapital(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldFromBirthCapital[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromBirthCapital(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldFromBirthCapital.setAt(eIndex, m_aiYieldFromBirthCapital[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}


int CvPlayer::getYieldFromBirthRetroactive(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldFromBirthRetroactive[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromBirthRetroactive(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiYieldFromBirthRetroactive.setAt(eIndex, m_aiYieldFromBirthRetroactive[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromBirthCapitalRetroactive(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldFromBirthCapitalRetroactive[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromBirthCapitalRetroactive(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiYieldFromBirthCapitalRetroactive.setAt(eIndex, m_aiYieldFromBirthCapitalRetroactive[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromDeath(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldFromDeath[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromDeath(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldFromDeath.setAt(eIndex, m_aiYieldFromDeath[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromConstruction(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldFromConstruction[eIndex];
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromConstruction(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldFromConstruction.setAt(eIndex, m_aiYieldFromConstruction[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromwonderConstruction(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldFromwonderConstruction[eIndex];
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromwonderConstruction(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiYieldFromwonderConstruction.setAt(eIndex, m_aiYieldFromwonderConstruction[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromTech(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldFromTech[eIndex];
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromTech(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldFromTech.setAt(eIndex, m_aiYieldFromTech[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromBorderGrowth(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldFromBorderGrowth[eIndex];
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromBorderGrowth(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldFromBorderGrowth.setAt(eIndex, m_aiYieldFromBorderGrowth[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::getYieldGPExpend(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiYieldGPExpend[eIndex];
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldGPExpend(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiYieldGPExpend.setAt(eIndex, m_aiYieldGPExpend[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::getConquerorYield(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiConquerorYield[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeConquerorYield(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiConquerorYield.setAt(eIndex, m_aiConquerorYield[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::getFounderYield(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiFounderYield[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeFounderYield(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiFounderYield.setAt(eIndex, m_aiFounderYield[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getArtifactYieldBonus(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiArtifactYieldBonus[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeArtifactYieldBonus(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiArtifactYieldBonus.setAt(eIndex, m_aiArtifactYieldBonus[eIndex] + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getArtYieldBonus(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiArtYieldBonus[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeArtYieldBonus(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiArtYieldBonus.setAt(eIndex, m_aiArtYieldBonus[eIndex] + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getMusicYieldBonus(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiMusicYieldBonus[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeMusicYieldBonus(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiMusicYieldBonus.setAt(eIndex, m_aiMusicYieldBonus[eIndex] + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getLitYieldBonus(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiLitYieldBonus[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeLitYieldBonus(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiLitYieldBonus.setAt(eIndex, m_aiLitYieldBonus[eIndex] + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getFilmYieldBonus(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiFilmYieldBonus[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeFilmYieldBonus(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiFilmYieldBonus.setAt(eIndex, m_aiFilmYieldBonus[eIndex] + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getRelicYieldBonus(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiRelicYieldBonus[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeRelicYieldBonus(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiRelicYieldBonus.setAt(eIndex, m_aiRelicYieldBonus[eIndex] + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGoldenAgeYieldMod(YieldTypes eIndex)	const
{
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiGoldenAgeYieldMod[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeGoldenAgeYieldMod(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiGoldenAgeYieldMod.setAt(eIndex, m_aiGoldenAgeYieldMod[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromNonSpecialistCitizens(YieldTypes eIndex)	const
{
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromNonSpecialistCitizens[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromNonSpecialistCitizens(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiYieldFromNonSpecialistCitizens.setAt(eIndex, m_aiYieldFromNonSpecialistCitizens[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getYieldModifierFromGreatWorks(YieldTypes eIndex)	const
{
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldModifierFromGreatWorks[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldModifierFromGreatWorks(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiYieldModifierFromGreatWorks.setAt(eIndex, m_aiYieldModifierFromGreatWorks[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getYieldModifierFromActiveSpies(YieldTypes eIndex)	const
{
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldModifierFromActiveSpies[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldModifierFromActiveSpies(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiYieldModifierFromActiveSpies.setAt(eIndex, m_aiYieldModifierFromActiveSpies[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getYieldFromDelegateCount(YieldTypes eIndex)	const
{
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromDelegateCount[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromDelegateCount(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiYieldFromDelegateCount.setAt(eIndex, m_aiYieldFromDelegateCount[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getReligionYieldRateModifier(YieldTypes eIndex)	const
{
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiReligionYieldRateModifier[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeReligionYieldRateModifier(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiReligionYieldRateModifier.setAt(eIndex, m_aiReligionYieldRateModifier[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		if(getTeam() == GC.getGame().getActiveTeam())
		{
			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetGarrisonsOccupiedUnhapppinessMod() const
{
	return m_iGarrisonsOccupiedUnhapppinessMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGarrisonsOccupiedUnhapppinessMod(int iChange)
{
	m_iGarrisonsOccupiedUnhapppinessMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetXPopulationConscription() const
{
	return m_iXPopulationConscription;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeXPopulationConscription(int iChange)
{
	m_iXPopulationConscription += iChange;
}
void CvPlayer::DoXPopulationConscription(CvCity* pCity)
{
	UnitTypes eBestUnit = NO_UNIT;
	int iStrengthBest = 0;
	// Loop through adding the available units
	for (int iUnitLoop = 0; iUnitLoop < GC.getNumUnitInfos(); iUnitLoop++)
	{
		UnitTypes eLoopUnit = (UnitTypes)iUnitLoop;
		if (eLoopUnit != NO_UNIT)
		{
			CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eLoopUnit);
			if (pkUnitEntry)
			{
				if (!pCity->canTrain(eLoopUnit))
				{
					continue;
				}

				if (pkUnitEntry->GetCombat() <= 0 && pkUnitEntry->GetRangedCombat() <= 0)
					continue;

				if (pkUnitEntry->GetDefaultUnitAIType() == UNITAI_EXPLORE)
					continue;

				if (pkUnitEntry->GetDomainType() == DOMAIN_SEA)
				{
					int iChance = GC.getGame().getSmallFakeRandNum(100, pCity->plot()->GetPlotIndex() + GC.getGame().GetCultureAverage() + iUnitLoop);
					if (iChance < 50)
					{
						continue;
					}
				}
				bool bBad = false;
				ResourceTypes eResource;
				for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
				{
					eResource = (ResourceTypes)iResourceLoop;
					int iNumResource = pkUnitEntry->GetResourceQuantityRequirement(eResource);
					if (iNumResource > 0)
					{
						bBad = true;
						break;
					}
					if (pkUnitEntry->GetResourceType() == eResource)
					{
						bBad = true;
						break;
					}
				}

				if (bBad)
				{
					continue;
				}
				int iCombatStrength = (pkUnitEntry->GetPower() + GC.getGame().getSmallFakeRandNum(pkUnitEntry->GetPower(), pCity->plot()->GetPlotIndex() + GC.getGame().GetCultureAverage()));

				iCombatStrength *= pkUnitEntry->GetProductionCost();
				iCombatStrength /= max(1, (pkUnitEntry->GetProductionCost() + GC.getGame().getSmallFakeRandNum(pkUnitEntry->GetProductionCost(), pCity->plot()->GetPlotIndex() + GC.getGame().GetCultureAverage())));

				if (pkUnitEntry->GetRange() > 0)
				{
					iCombatStrength *= 50;
					iCombatStrength /= 100;
				}

				if (iCombatStrength <= 0)
					iCombatStrength = 1;
				
				if (iCombatStrength > iStrengthBest)
				{
					iStrengthBest = iCombatStrength;
					eBestUnit = eLoopUnit;
				}
			}
		}
	}
	if (eBestUnit != NO_UNIT)
	{
		CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eBestUnit);
		if (pkUnitEntry)
		{
			UnitAITypes eUnitAI = pkUnitEntry->GetDefaultUnitAIType();
			int iResult = pCity->CreateUnit(eBestUnit, eUnitAI);

			CvAssertMsg(iResult != -1, "Unable to create unit");

			if (iResult != -1)
			{
				CvUnit* pUnit = getUnit(iResult);
				changeNumUnitsSupplyFree(1);
				pUnit->changeNoSupply(1);
				PromotionTypes ePromotionConscript = (PromotionTypes)GC.getInfoTypeForString("PROMOTION_CONSCRIPT");
				if (ePromotionConscript != NO_PROMOTION)
					pUnit->setHasPromotion(ePromotionConscript, true);

				if (!pUnit->jumpToNearestValidPlot())
				{
					pUnit->kill(false);	// Could not find a valid spot!
				}
				pUnit->finishMoves();
				CvNotifications* pNotifications = GetNotifications();
				if (pUnit && pNotifications)
				{
					Localization::String localizedText = Localization::Lookup("TXT_KEY_NOTIFICATION_CONSCRIPTION_SPAWN");
					localizedText << pCity->getNameKey() << pCity->getPopulation() << pUnit->getNameKey();
					Localization::String localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CONSCRIPTION_SPAWN_SUMMARY");
					localizedSummary << getNameKey() << pUnit->getNameKey();
					pNotifications->Add(NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER, localizedText.toUTF8(), localizedSummary.toUTF8(), pUnit->getX(), pUnit->getY(), eBestUnit);
				}
				if (GC.getLogging() && GC.getAILogging())
				{
					CvString strLogString;
					strLogString.Format("Conscripted %s spawned at %s. Population: %d", pUnit->getName().GetCString(), pCity->getName().GetCString(), pCity->getPopulation());
					GetHomelandAI()->LogHomelandMessage(strLogString);
				}
			}
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetExtraMoves() const
{
	return m_iExtraMoves;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeExtraMoves(int iChange)
{
	m_iExtraMoves += iChange;
}
//	--------------------------------------------------------------------------------
bool CvPlayer::IsNoUnhappinessExpansion() const
{
	return GetNoUnhappinessExpansion() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNoUnhappinessExpansion() const
{
	return m_iNoUnhappinessExpansion;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNoUnhappinessExpansion(int iChange)
{
	if(iChange != 0)
	{
		m_iNoUnhappinessExpansion += iChange;
	}
}
//	--------------------------------------------------------------------------------
bool CvPlayer::IsNoUnhappyIsolation() const
{
	return GetNoUnhappyIsolation() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNoUnhappyIsolation() const
{
	return m_iNoUnhappyIsolation;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNoUnhappyIsolation(int iChange)
{
	if(iChange != 0)
	{
		m_iNoUnhappyIsolation += iChange;
	}
}
//	--------------------------------------------------------------------------------
bool CvPlayer::IsDoubleBorderGA() const
{
	return GetDoubleBorderGA() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetDoubleBorderGA() const
{
	return m_iDoubleBorderGA;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeDoubleBorderGA(int iChange)
{
	if(iChange != 0)
	{
		m_iDoubleBorderGA += iChange;
	}
}
//Increased influence from CS quests
//	--------------------------------------------------------------------------------
bool CvPlayer::IsIncreasedQuestInfluence() const
{
	return GetIncreasedQuestInfluence() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetIncreasedQuestInfluence() const
{
	return m_iIncreasedQuestInfluence;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeIncreasedQuestInfluence(int iChange)
{
	if(iChange != 0)
	{
		m_iIncreasedQuestInfluence += iChange;
	}
}
//Citadel Boost
//	--------------------------------------------------------------------------------
bool CvPlayer::IsCultureBombBoost() const
{
	return GetCultureBombBoost() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetCultureBombBoost() const
{
	return m_iCultureBombBoost;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeCultureBombBoost(int iChange)
{
	if(iChange != 0)
	{
		m_iCultureBombBoost += iChange;
	}
}

//Puppet Prod Boost
//	--------------------------------------------------------------------------------
bool CvPlayer::IsPuppetProdMod() const
{
	return GetPuppetProdMod() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetPuppetProdMod() const
{
	return m_iPuppetProdMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changePuppetProdMod(int iChange)
{
	if(iChange != 0)
	{
		m_iPuppetProdMod += iChange;
	}
}

//Occupied Prod Boost
//	--------------------------------------------------------------------------------
bool CvPlayer::IsOccupiedProdMod() const
{
	return GetOccupiedProdMod() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetOccupiedProdMod() const
{
	return m_iOccupiedProdMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeOccupiedProdMod(int iChange)
{
	if(iChange != 0)
	{
		m_iOccupiedProdMod += iChange;
	}
}

//Free Gold from Internal Trade Routes
//	--------------------------------------------------------------------------------
bool CvPlayer::IsGoldInternalTrade() const
{
	return GetGoldInternalTrade() > 0;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetGoldInternalTrade() const
{
	return m_iGoldInternalTrade;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGoldInternalTrade(int iChange)
{
	if(iChange != 0)
	{
		m_iGoldInternalTrade += iChange;
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetFreeWCVotes() const
{
	return m_iFreeWCVotes;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeFreeWCVotes(int iChange)
{
	m_iFreeWCVotes += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetInfluenceGPExpend() const
{
	return m_iInfluenceGPExpend;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeInfluenceGPExpend(int iChange)
{
	m_iInfluenceGPExpend += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetFreeTradeRoute() const
{
	return m_iFreeTradeRoute;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeFreeTradeRoute(int iChange)
{
	m_iFreeTradeRoute += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetFreeSpy() const
{
	return m_iFreeSpy;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeFreeSpy(int iChange)
{
	m_iFreeSpy += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetReligionDistance() const
{
	return m_iReligionDistance;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeReligionDistance(int iChange)
{
	m_iReligionDistance += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetPressureMod() const
{
	return m_iPressureMod;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changePressureMod(int iChange)
{
	m_iPressureMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetCityStateCombatModifier() const
{
	return m_iCityStateCombatModifier;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeCityStateCombatModifier(int iChange)
{
	m_iCityStateCombatModifier += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getBuildingClassCultureChange(BuildingClassTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiBuildingClassCulture[eIndex];
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeBuildingClassCultureChange(BuildingClassTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	m_paiBuildingClassCulture.setAt(eIndex, m_paiBuildingClassCulture[eIndex] + iChange);
	CvAssert(getBuildingClassCultureChange(eIndex) >= 0);
}
#endif
#if defined(MOD_BALANCE_CORE_SPIES)
//	--------------------------------------------------------------------------------
int CvPlayer::GetAdvancedActionGold() const
{
	return m_iAdvancedActionGold;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeAdvancedActionGold(int iChange)
{
	m_iAdvancedActionGold += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::setAdvancedActionGold(int iChange)
{
	m_iAdvancedActionGold = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetAdvancedActionScience() const
{
	return m_iAdvancedActionScience;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeAdvancedActionScience(int iChange)
{
	m_iAdvancedActionScience += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::setAdvancedActionScience(int iChange)
{
	m_iAdvancedActionScience = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetAdvancedActionUnrest() const
{
	return m_iAdvancedActionUnrest;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeAdvancedActionUnrest(int iChange)
{
	m_iAdvancedActionUnrest += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::setAdvancedActionUnrest(int iChange)
{
	m_iAdvancedActionUnrest = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetAdvancedActionRebellion() const
{
	return m_iAdvancedActionRebellion;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeAdvancedActionRebellion(int iChange)
{
	m_iAdvancedActionRebellion += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::setAdvancedActionRebellion(int iChange)
{
	m_iAdvancedActionRebellion = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetAdvancedActionGP() const
{
	return m_iAdvancedActionGP;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeAdvancedActionGP(int iChange)
{
	m_iAdvancedActionGP += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::setAdvancedActionGP(int iChange)
{
	m_iAdvancedActionGP = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetAdvancedActionUnit() const
{
	return m_iAdvancedActionUnit;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeAdvancedActionUnit(int iChange)
{
	m_iAdvancedActionUnit += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::setAdvancedActionUnit(int iChange)
{
	m_iAdvancedActionUnit = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetAdvancedActionWonder() const
{
	return m_iAdvancedActionWonder;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeAdvancedActionWonder(int iChange)
{
	m_iAdvancedActionWonder += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::setAdvancedActionWonder(int iChange)
{
	m_iAdvancedActionWonder = iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetAdvancedActionBuilding() const
{
	return m_iAdvancedActionBuilding;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeAdvancedActionBuilding(int iChange)
{
	m_iAdvancedActionBuilding += iChange;
}
//	--------------------------------------------------------------------------------
void CvPlayer::setAdvancedActionBuilding(int iChange)
{
	m_iAdvancedActionBuilding = iChange;
}
//	--------------------------------------------------------------------------------
bool CvPlayer::IsCannotFailSpies() const
{
	return GetCannotFailSpies() > 0;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetCannotFailSpies() const
{
	return m_iCannotFailSpies;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeCannotFailSpies(int iChange)
{
	m_iCannotFailSpies += iChange;
}
//	--------------------------------------------------------------------------------
/// Extra yield for a improvement this city is working?
int CvPlayer::GetImprovementExtraYield(ImprovementTypes eImprovement, YieldTypes eYield) const
{
	CvAssertMsg(eImprovement >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eImprovement < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eYield >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiImprovementYieldChange[eImprovement][eYield];
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeImprovementExtraYield(ImprovementTypes eImprovement, YieldTypes eYield, int iChange)
{
	CvAssertMsg(eImprovement >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eImprovement < GC.getNumImprovementInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eYield >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiImprovementYieldChange[eImprovement];
		yields[eYield] = (m_ppiImprovementYieldChange[eImprovement][eYield] + iChange);
		m_ppiImprovementYieldChange[eImprovement] = yields;
		CvAssert(GetImprovementExtraYield(eImprovement, eYield) >= 0);

		updateYield();
	}
}
#endif
#if defined(MOD_BALANCE_CORE_BUILDING_INVESTMENTS)
//	--------------------------------------------------------------------------------
int CvPlayer::GetInvestmentModifier() const
{
	return m_iInvestmentModifier;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeInvestmentModifier(int iChange)
{
	m_iInvestmentModifier += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetMissionInfluenceModifier() const
{
	return m_iMissionInfluenceModifier;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeMissionInfluenceModifier(int iChange)
{
	m_iMissionInfluenceModifier += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetHappinessPerActiveTradeRoute() const
{
	return m_iHappinessPerActiveTradeRoute;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeHappinessPerActiveTradeRoute(int iChange)
{
	m_iHappinessPerActiveTradeRoute += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNeedsModifierFromAirUnits() const
{
	return m_iNeedsModifierFromAirUnits;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeNeedsModifierFromAirUnits(int iChange)
{
	m_iNeedsModifierFromAirUnits += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetFlatDefenseFromAirUnits() const
{
	return m_iFlatDefenseFromAirUnits;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeFlatDefenseFromAirUnits(int iChange)
{
	if (iChange != 0)
	{
		m_iFlatDefenseFromAirUnits += iChange;

		CvCity* pLoopCity;

		int iLoop;
		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			pLoopCity->updateStrengthValue();
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetPuppetYieldPenaltyMod() const
{
	return m_iPuppetYieldPenaltyMod;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changePuppetYieldPenaltyMod(int iChange)
{
	m_iPuppetYieldPenaltyMod += iChange;
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetConquestPerEraBuildingProductionMod() const
{
	return m_iConquestPerEraBuildingProductionMod;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeConquestPerEraBuildingProductionMod(int iChange)
{
	m_iConquestPerEraBuildingProductionMod += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetAdmiralLuxuryBonus() const
{
	return m_iAdmiralLuxuryBonus;
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeAdmiralLuxuryBonus(int iChange)
{
	m_iAdmiralLuxuryBonus += iChange;
}



//	--------------------------------------------------------------------------------
bool CvPlayer::IsCSResourcesCountMonopolies() const
{
	return (m_iCSResourcesCountMonopolies > 0);
}
//	--------------------------------------------------------------------------------
void CvPlayer::changeCSResourcesCountMonopolies(int iChange)
{
	m_iCSResourcesCountMonopolies += iChange;
}


int CvPlayer::GetScalingNationalPopulationRequrired(BuildingTypes eBuilding) const
{
	if(eBuilding != NO_BUILDING)
	{
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
		if(pkBuildingInfo)
		{
			int iNationalPop = pkBuildingInfo->GetNationalPopulationRequired();
			if(iNationalPop > 0)
			{
				int iScaler = (getNumCities() * pkBuildingInfo->GetNumCityCostMod());
				iNationalPop *= (100 + iScaler);
				iNationalPop /= 100;
				//If OCC... 1/3 the value, as three cities is 'roughly' average for a game.
				if(GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE))
				{
					iNationalPop /= 3;
				}
				return iNationalPop;
			}
		}
	}
	return 0;
}
void CvPlayer::ChangeNumCivsConstructingWonder(BuildingTypes eBuilding, int iValue)
{
	CvAssertMsg(eBuilding >= 0, "eBuilding is expected to be non-negative (invalid eBuilding)");
	CvAssertMsg(eBuilding < GC.getNumBuildingInfos(), "eBuilding is expected to be within maximum bounds (invalid Index)");

	if (iValue != 0)
	{
		m_paiNumCivsConstructingWonder.setAt(eBuilding, m_paiNumCivsConstructingWonder[eBuilding] + iValue);
	}
}
int CvPlayer::GetNumCivsConstructingWonder(BuildingTypes eBuilding) const
{
	CvAssertMsg(eBuilding >= 0, "eBuilding is expected to be non-negative (invalid eBuilding)");
	CvAssertMsg(eBuilding < GC.getNumBuildingInfos(), "eBuilding is expected to be within maximum bounds (invalid Index)");

	return m_paiNumCivsConstructingWonder[eBuilding];
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::getCapitalYieldRateModifier(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiCapitalYieldRateModifier[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeCapitalYieldRateModifier(YieldTypes eIndex, int iChange)
{
	CvCity* pCapitalCity;

	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_aiCapitalYieldRateModifier.setAt(eIndex, m_aiCapitalYieldRateModifier[eIndex] + iChange);

		invalidateYieldRankCache(eIndex);

		pCapitalCity = getCapitalCity();
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getExtraYieldThreshold(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiExtraYieldThreshold[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::updateExtraYieldThreshold(YieldTypes eIndex)
{
	int iBestValue;

	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	iBestValue = GetPlayerTraits()->GetExtraYieldThreshold(eIndex);

	if(getExtraYieldThreshold(eIndex) != iBestValue)
	{
		m_aiExtraYieldThreshold.setAt(eIndex, iBestValue);
		CvAssert(getExtraYieldThreshold(eIndex) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetScience() const
{
	return GetScienceTimes100() / 100;
}

//	--------------------------------------------------------------------------------
#if defined(MOD_BALANCE_CORE)
int CvPlayer::GetScienceTimes100(bool bIgnoreHappiness) const
#else
int CvPlayer::GetScienceTimes100() const
#endif
{
	// If we're in anarchy, then no Research is done!
	if(IsAnarchy())
		return 0;

	int iValue = 0;

	// Science from our Cities
	iValue += GetScienceFromCitiesTimes100(false);

#if defined(MOD_API_UNIFIED_YIELDS)
	// Science from religion
	iValue += GetYieldPerTurnFromReligion(YIELD_SCIENCE) * 100;
#endif

#if defined(MOD_API_UNIFIED_YIELDS)
	// Trait bonus which adds Science for trade partners? 
	iValue += GetYieldPerTurnFromTraits(YIELD_SCIENCE) * 100;
#endif

	// Science from other players!
#if defined(MOD_BALANCE_CORE)
	if (!isMinorCiv())
		//avoid pointless recursion
		iValue += GetScienceFromOtherPlayersTimes100();
#else
	iValue += GetScienceFromOtherPlayersTimes100();
#endif

	// Happiness converted to Science? (Policies, etc.)
	iValue += GetScienceFromHappinessTimes100();

	// Research Agreement bonuses
	iValue += GetScienceFromResearchAgreementsTimes100();

	// If we have a negative Treasury + GPT then it gets removed from Science
	iValue += GetScienceFromBudgetDeficitTimes100();

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	if (MOD_DIPLOMACY_CIV4_FEATURES) {
		// We're a vassal of someone, we get x% of his science
		iValue += (GetYieldPerTurnFromVassals(YIELD_SCIENCE) * 100);
	}

	if (MOD_BALANCE_CORE_JFD)
	{
		iValue += GetYieldPerTurnFromMinors(YIELD_FAITH) * 100;
	}
#endif
#if defined(MOD_BALANCE_CORE)
	if(MOD_BALANCE_CORE_MINOR_CIV_GIFT)
	{
		iValue += GetSciencePerTurnFromMinorCivs() * 100;
	}
#endif
#if defined(MOD_DIPLOMACY_CITYSTATES)
	if (MOD_DIPLOMACY_CITYSTATES) {
		//Science Funding Rate Boost
		if(IsLeagueAid())
		{
			int iFreeScience = GetScienceFromCitiesTimes100(false) * GetScienceRateFromLeagueAid();
			iFreeScience /= 100;

			iValue += iFreeScience;
		}
	}
#endif

#if defined(MOD_BALANCE_CORE_HAPPINESS_NATIONAL)
	//Mod for national unhappiness
	if(MOD_BALANCE_CORE_HAPPINESS_NATIONAL && !bIgnoreHappiness)
	{
		iValue += GetYieldPerTurnFromHappiness(YIELD_SCIENCE, iValue);
	}
#endif
#if defined(MOD_BALANCE_CORE)
	if(!isHuman())
	{
		return max(iValue, 300);
	}
#endif
	return max(iValue, 0);
}

//	--------------------------------------------------------------------------------
/// Where is our Science coming from?
int CvPlayer::GetScienceFromCitiesTimes100(bool bIgnoreTrade) const
{
	int iScience = 0;

	const CvCity* pLoopCity;

	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		iScience += pLoopCity->getYieldRateTimes100(YIELD_SCIENCE, bIgnoreTrade);
	}

	return iScience;
}

//	--------------------------------------------------------------------------------
/// Where is our Science coming from?
int CvPlayer::GetScienceFromOtherPlayersTimes100() const
{
	int iScience = 0;

	PlayerTypes ePlayer;
	int iScienceFromPlayer;
	for(int iPlayerLoop = MAX_MAJOR_CIVS; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		ePlayer = (PlayerTypes) iPlayerLoop;

		iScienceFromPlayer = 0;

		if(IsGetsScienceFromPlayer(ePlayer))
		{
			iScienceFromPlayer = GET_PLAYER(ePlayer).GetMinorCivAI()->GetScienceFriendshipBonusTimes100();

			iScience += iScienceFromPlayer;
		}
	}
	return iScience;
}

//	--------------------------------------------------------------------------------
/// Where is our Science coming from?
int CvPlayer::GetScienceFromHappinessTimes100() const
{
	if(GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS))
	{
		return 0;
	}

	int iScience = 0;

	if(getHappinessToScience() != 0)
	{
		if(GetExcessHappiness() >= 0)
		{
			int iFreeScience = GetScienceFromCitiesTimes100(false) * getHappinessToScience();
			iFreeScience /= 100;

			iScience += iFreeScience;
		}
	}

	return iScience;
}

//	--------------------------------------------------------------------------------
/// Where is our Science coming from?
int CvPlayer::GetScienceFromResearchAgreementsTimes100() const
{
	int iScience = GetScienceFromCitiesTimes100(false);

	int iResearchAgreementBonus = /*0*/ GC.getRESEARCH_AGREEMENT_MOD() * GET_TEAM(getTeam()).GetTotalNumResearchAgreements(); // RAs currently do not have this effect
	iScience *= iResearchAgreementBonus;	// Apply to the % to the current value
	iScience /= 100;

	return iScience;
}

//	--------------------------------------------------------------------------------
/// Where is our Science coming from?
int CvPlayer::GetScienceFromBudgetDeficitTimes100() const
{
	int iScience = 0;
	int iGoldPerTurn = calculateGoldRateTimes100();
	if(GetTreasury()->GetGoldTimes100() + iGoldPerTurn < 0)
	{
		iScience += (GetTreasury()->GetGoldTimes100() + iGoldPerTurn);
	}

	return iScience;
}

//	--------------------------------------------------------------------------------
/// What is the sum of science yield (not counting Research Agreements or Great Scientist bonuses) from the previous N turns?
/// NOTE: This uses the data tracked in recording a replay, so if replays are disabled in the future then this must change!
int CvPlayer::GetScienceYieldFromPreviousTurns(int iGameTurn, int iNumPreviousTurnsToCount)
{
	// Beakers per turn yield is tracked in replay data, so use that
	int iSum = 0;
	for (int iI = 1; iI < iNumPreviousTurnsToCount; iI++)
	{
		int iTurn = iGameTurn - iI;
		if (iTurn < 0)
		{
			break;
		}

		int iTurnScience = getReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_SCIENCEPERTURN"), iTurn);
		if (iTurnScience >= 0)
		{
			iSum += iTurnScience;
		}
		else if (iTurnScience == -1) // No data for this turn (ex. late era start)
		{
			iSum += (3 * GetScience());
		}
	}

	return iSum;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsGetsScienceFromPlayer(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= MAX_MAJOR_CIVS, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");

	// Might have global modifier
	if(IsMinorScienceAllies() && GET_PLAYER(ePlayer).GetMinorCivAI()->IsAllies(GetID()))
	{
		return true;
	}

	return m_pabGetsScienceFromPlayer[ePlayer];
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetGetsScienceFromPlayer(PlayerTypes ePlayer, bool bNewValue)
{
	CvAssertMsg(ePlayer >= MAX_MAJOR_CIVS, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(bNewValue != m_pabGetsScienceFromPlayer[ePlayer])
	{
		m_pabGetsScienceFromPlayer.setAt(ePlayer, bNewValue);
	}
}

//	--------------------------------------------------------------------------------
/// Player spending too much cash?
void CvPlayer::DoDeficit()
{
	int iNumMilitaryUnits = 0;

	CvUnit* pLoopUnit;
	int iLoop;
	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if(pLoopUnit->IsCombatUnit())
			iNumMilitaryUnits++;
	}

	// If the player has more units than cities, start disbanding things
#if defined(MOD_BALANCE_CORE)
	if(isBarbarian())
	{
		return;
	}
	int iMax = isMinorCiv() ? ((GetCurrentEra() + 4) * getNumCities()) : max(10, getNumCities());
	if(iNumMilitaryUnits >= iMax)
#else
	if(iNumMilitaryUnits > getNumCities())
#endif
	{
		int iRand = GC.getGame().getSmallFakeRandNum(100, getGlobalAverage(YIELD_CULTURE));
		if (iRand < 50)
		{
			CvUnit* pLandUnit = NULL;
			CvUnit* pNavalUnit = NULL;
			int iLandScore = MAX_INT;
			int iNavalScore = MAX_INT;

			// Look for obsolete land units if in deficit or have sufficient units
			//if(GetMilitaryAI()->GetLandDefenseState() <= DEFENSE_STATE_NEUTRAL)
			if (iRand <= 25)
			{
				pLandUnit = GetMilitaryAI()->FindBestUnitToScrap(true /*bLand*/, true /*bDeficitForcedDisband*/, iLandScore);
			}

			// Look for obsolete naval units if in deficit or have sufficient units
			//if(GetMilitaryAI()->GetNavalDefenseState() <= DEFENSE_STATE_NEUTRAL)
			else
			{
				pNavalUnit = GetMilitaryAI()->FindBestUnitToScrap(false/*bNaval*/, true /*bDeficitForcedDisband*/, iNavalScore);
			}

			if(iLandScore < MAX_INT && (GetMilitaryAI()->GetLandDefenseState() <= GetMilitaryAI()->GetNavalDefenseState() || iLandScore <= iNavalScore))
			{
				if(pLandUnit)
				{
					CvNotifications* pNotifications = GetNotifications();
					if(pNotifications)
					{
						Localization::String locString = Localization::Lookup("TXT_KEY_NTFN_UNIT_DISBANDED");
						Localization::String locSummary = Localization::Lookup("TXT_KEY_NTFN_UNIT_DISBANDED_S");
						pNotifications->Add(NOTIFICATION_UNIT_DIED, locString.toUTF8(), locSummary.toUTF8(), pLandUnit->getX(), pLandUnit->getY(), pLandUnit->getUnitType(), GetID());
					}

					pLandUnit->scrap();
					GetMilitaryAI()->LogDeficitScrapUnit(pLandUnit);
				}
			}
			else if(iNavalScore < MAX_INT)
			{
				if(pNavalUnit)
				{
					CvNotifications* pNotifications = GetNotifications();
					if(pNotifications)
					{
						Localization::String locString = Localization::Lookup("TXT_KEY_NTFN_UNIT_DISBANDED");
						Localization::String locSummary = Localization::Lookup("TXT_KEY_NTFN_UNIT_DISBANDED_S");
						pNotifications->Add(NOTIFICATION_UNIT_DIED, locString.toUTF8(), locSummary.toUTF8(), pNavalUnit->getX(), pNavalUnit->getY(), pNavalUnit->getUnitType(), GetID());
					}

					pNavalUnit->scrap();
					GetMilitaryAI()->LogDeficitScrapUnit(pNavalUnit);
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getSpecialistExtraYield(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiSpecialistExtraYield[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeSpecialistExtraYield(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		// Have to handle Specialists yield update manually here because the "updateYield()" below only accounts for land Yield!

		CvCity* pLoopCity;
		int iLoop;
		int iNumTotalSpecialists = 0;

		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			for(int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
			{
				iNumTotalSpecialists = pLoopCity->GetCityCitizens()->GetSpecialistCount((SpecialistTypes) iSpecialistLoop);
//				iNumTotalSpecialists = pLoopCity->getSpecialistCount((SpecialistTypes) iSpecialistLoop) + pLoopCity->getFreeSpecialistCount((SpecialistTypes) iSpecialistLoop);

				for(int iTempLoop = 0; iTempLoop < iNumTotalSpecialists; iTempLoop++)
				{
					pLoopCity->processSpecialist((SpecialistTypes) iSpecialistLoop, -1);
				}
			}
		}

		m_aiSpecialistExtraYield.setAt(eIndex ,m_aiSpecialistExtraYield[eIndex] + iChange);
		CvAssert(getSpecialistExtraYield(eIndex) >= 0);

		updateYield();

		// Reprocess Specialist AFTER yield change
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			for(int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
			{
				iNumTotalSpecialists = pLoopCity->GetCityCitizens()->GetSpecialistCount((SpecialistTypes) iSpecialistLoop);
//				iNumTotalSpecialists = pLoopCity->getSpecialistCount((SpecialistTypes) iSpecialistLoop) + pLoopCity->getFreeSpecialistCount((SpecialistTypes) iSpecialistLoop);

				for(int iTempLoop = 0; iTempLoop < iNumTotalSpecialists; iTempLoop++)
				{
					pLoopCity->processSpecialist((SpecialistTypes) iSpecialistLoop, 1);
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Returns how "close" we are to another player (useful for diplomacy, war planning, etc.)
PlayerProximityTypes CvPlayer::GetProximityToPlayer(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePlayer < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
	return (PlayerProximityTypes) m_aiProximityToPlayer[ePlayer];
}

//	--------------------------------------------------------------------------------
/// Sets how "close" we are to another player (useful for diplomacy, war planning, etc.)
void CvPlayer::SetProximityToPlayer(PlayerTypes ePlayer, PlayerProximityTypes eProximity)
{
	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePlayer < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");

	CvAssertMsg(GetID() != ePlayer, "Trying to calculate proximity to oneself. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	CvAssertMsg(eProximity >= NO_PLAYER_PROXIMITY, "eIndex is expected to be non-negative (invalid Index)");	// NO_PLAYER_PROXIMITY is valid because some players may have no Cities (e.g. on the first turn)
	CvAssertMsg(eProximity < NUM_PLAYER_PROXIMITIES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if((GC.getLogging() && GC.getAILogging()))
	{
		if(eProximity != m_aiProximityToPlayer[ePlayer])
		{
			// Open the log file
			CvString strFileName = "PlayerProximityLog.csv";
			FILogFile* pLog;
			pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
			CvString strLog, strTemp;

			CvString strPlayerName;
			strPlayerName = getCivilizationShortDescription();
			strLog += strPlayerName;
			strLog += ",";

			strTemp.Format("%d,", GC.getGame().getGameTurn()); // turn
			strLog += strTemp;
			CvString strOtherPlayerName;
			strOtherPlayerName = GET_PLAYER(ePlayer).getCivilizationShortDescription();
			strLog += strOtherPlayerName;
			strLog += ",";

			switch(m_aiProximityToPlayer[ePlayer])
			{
			case NO_PLAYER_PROXIMITY:
				strLog += "No player proximity,";
				break;
			case PLAYER_PROXIMITY_NEIGHBORS:
				strLog += "Neighbors,";
				break;
			case PLAYER_PROXIMITY_CLOSE:
				strLog += "Close,";
				break;
			case PLAYER_PROXIMITY_FAR:
				strLog += "Far,";
				break;
			case PLAYER_PROXIMITY_DISTANT:
				strLog += "Distant,";
				break;
			}

			strLog += "-->,";

			switch(eProximity)
			{
			case NO_PLAYER_PROXIMITY:
				strLog += "No player proximity,";
				break;
			case PLAYER_PROXIMITY_NEIGHBORS:
				strLog += "Neighbors,";
				break;
			case PLAYER_PROXIMITY_CLOSE:
				strLog += "Close,";
				break;
			case PLAYER_PROXIMITY_FAR:
				strLog += "Far,";
				break;
			case PLAYER_PROXIMITY_DISTANT:
				strLog += "Distant,";
				break;
			}

			pLog->Msg(strLog);
		}
	}

	m_aiProximityToPlayer.setAt(ePlayer, eProximity);
}

//	--------------------------------------------------------------------------------
/// Figure out how "close" we are to another player (useful for diplomacy, war planning, etc.)
void CvPlayer::DoUpdateProximityToPlayer(PlayerTypes ePlayer, bool bTileCheck)
{
	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePlayer < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");

#if !defined(MOD_BALANCE_CORE)
	int iSmallestDistanceBetweenCities = GC.getMap().numPlots();
#endif
	int iAverageDistanceBetweenCities = 0;
#if !defined(MOD_BALANCE_CORE)
	int iNumCityConnections = 0;
#endif

	CvCity* pLoopMyCity;
	int iMyCityLoop;
#if !defined(MOD_BALANCE_CORE)
	
	CvCity* pLoopTheirCity;

	
	int iTheirCityLoop;

	int iTempDistance;
#endif
	// Loop through all of MY Cities, but only if we're close (or we just bought a tile).
	if (GetProximityToPlayer(ePlayer) >= PLAYER_PROXIMITY_CLOSE || bTileCheck)
	{
		for (pLoopMyCity = firstCity(&iMyCityLoop); pLoopMyCity != NULL; pLoopMyCity = nextCity(&iMyCityLoop))
		{
			if (pLoopMyCity->AreOurBordersTouching(ePlayer))
			{
				SetProximityToPlayer(ePlayer, PLAYER_PROXIMITY_NEIGHBORS);
				return;
			}
		}
	}
	//only checking for connecting tiles.
	if (bTileCheck)
		return;

#if defined(MOD_BALANCE_CORE)
	if(GetCenterOfMassEmpire() != NULL && GET_PLAYER(ePlayer).GetCenterOfMassEmpire() != NULL)
	{
		iAverageDistanceBetweenCities = plotDistance(GetCenterOfMassEmpire()->getX(), GetCenterOfMassEmpire()->getY(), GET_PLAYER(ePlayer).GetCenterOfMassEmpire()->getX(), GET_PLAYER(ePlayer).GetCenterOfMassEmpire()->getY());
	}
	else
	{
		SetProximityToPlayer(ePlayer, NO_PLAYER_PROXIMITY);
		return;
	}

	// Seed this value with something reasonable to start.  This will be the value assigned if one player has 0 Cities.
	PlayerProximityTypes eProximity = NO_PLAYER_PROXIMITY;

	if(iAverageDistanceBetweenCities != 0)
	{
#if defined(MOD_BALANCE_CORE_DIPLOMACY)
		if(GC.getMap().GetAIMapHint() & ciMapHint_Naval)
		{
			iAverageDistanceBetweenCities *= 2;
			iAverageDistanceBetweenCities /= 3;
		}
		//If small empire (CS, OCC, etc.), increase the value.
		if(GET_PLAYER(ePlayer).getNumCities() <= 2)
		{
			iAverageDistanceBetweenCities *= 3;
			iAverageDistanceBetweenCities /= 2;
		}
#endif

		// Closest Cities must be within a certain range
		if(iAverageDistanceBetweenCities < /*6*/ GC.getPROXIMITY_NEIGHBORS_CLOSEST_CITY_REQUIREMENT())
		{
			eProximity = PLAYER_PROXIMITY_NEIGHBORS;
		}
		// If our closest Cities are pretty near one another and our average is less than the max then we can be considered CLOSE
		else if(iAverageDistanceBetweenCities < /*12*/ GC.getPROXIMITY_CLOSE_CLOSEST_CITY_POSSIBILITY())
		{
			eProximity = PLAYER_PROXIMITY_CLOSE;
		}
		// If our closest Cities are far away from one another and our average is less than the max then we can be considered FAR
		else if(iAverageDistanceBetweenCities < /*18*/ GC.getPROXIMITY_FAR_DISTANCE_MAX())
		{
			eProximity = PLAYER_PROXIMITY_FAR;
		}
		else
		{
			eProximity = PLAYER_PROXIMITY_DISTANT;
		}
	}

	int iNumMajorsLeft = GC.getGame().countMajorCivsAlive();

	// Only two players left, the farthest we can be considered is "Close"
	if(iNumMajorsLeft == 2)
		eProximity = max(eProximity, PLAYER_PROXIMITY_CLOSE);

	// Four or fewer players left, the farthest we can be considered is "Far"
	else if(iNumMajorsLeft <= 4)
		eProximity = max(eProximity, PLAYER_PROXIMITY_FAR);

	SetProximityToPlayer(ePlayer, eProximity);
#else
	// Loop through all of MY Cities
	for(pLoopMyCity = firstCity(&iMyCityLoop); pLoopMyCity != NULL; pLoopMyCity = nextCity(&iMyCityLoop))
	{
		// Loop through all of THEIR Cities
		for(pLoopTheirCity = GET_PLAYER(ePlayer).firstCity(&iTheirCityLoop); pLoopTheirCity != NULL; pLoopTheirCity = GET_PLAYER(ePlayer).nextCity(&iTheirCityLoop))
		{
			iNumCityConnections++;

			// Different area or couldn't find path - get distance the hard way
			//if (!bPathFinderSuccess)
			{
				iTempDistance = plotDistance(pLoopMyCity->getX(), pLoopMyCity->getY(), pLoopTheirCity->getX(), pLoopTheirCity->getY());
			}

			// Smallest distance between any two Cities
			if(iTempDistance < iSmallestDistanceBetweenCities)
			{
				iSmallestDistanceBetweenCities = iTempDistance;
			}

			iAverageDistanceBetweenCities += iTempDistance;
		}
	}

	// Seed this value with something reasonable to start.  This will be the value assigned if one player has 0 Cities.
	PlayerProximityTypes eProximity = NO_PLAYER_PROXIMITY;

	if(iNumCityConnections > 0)
	{
		iAverageDistanceBetweenCities /= iNumCityConnections;

#if defined(MOD_BALANCE_CORE_DIPLOMACY)
		if(GC.getMap().GetAIMapHint() & ciMapHint_Naval)
		{
			iSmallestDistanceBetweenCities /= 2;
		}
#endif

		// Closest Cities must be within a certain range
		if(iSmallestDistanceBetweenCities <= /*7*/ GC.getPROXIMITY_NEIGHBORS_CLOSEST_CITY_REQUIREMENT())
		{
			eProximity = PLAYER_PROXIMITY_NEIGHBORS;
		}
		// If our closest Cities are pretty near one another  and our average is less than the max then we can be considered CLOSE (will also look at City average below)
		else if(iSmallestDistanceBetweenCities <= /*11*/ GC.getPROXIMITY_CLOSE_CLOSEST_CITY_POSSIBILITY())
		{
			eProximity = PLAYER_PROXIMITY_CLOSE;
		}

		// If we've already set ourselves as Neighbors, no need to undo what we just did
		if(eProximity != PLAYER_PROXIMITY_NEIGHBORS)
		{
			int iMapFactor = (GC.getMap().getGridWidth() + GC.getMap().getGridHeight()) / 2;

			// Normally base distance on map size, but cap it at a certain point
			// Close can't be so big that it sits on Far's turf
			int iCloseDistance = iMapFactor* /*25*/ GC.getPROXIMITY_CLOSE_DISTANCE_MAP_MULTIPLIER() / 100;
			if(iCloseDistance > /*20*/ GC.getPROXIMITY_CLOSE_DISTANCE_MAX())
			{
				iCloseDistance = /*20*/ GC.getPROXIMITY_CLOSE_DISTANCE_MAX();
			}
			// Close also can't be so small that it sits on Neighbor's turf
			else if(iCloseDistance < /*10*/ GC.getPROXIMITY_CLOSE_DISTANCE_MIN())
			{
				iCloseDistance = /*10*/ GC.getPROXIMITY_CLOSE_DISTANCE_MIN();
			}

			// Far can't be so big that it sits on Distant's turf
			int iFarDistance = iMapFactor* /*45*/ GC.getPROXIMITY_FAR_DISTANCE_MAP_MULTIPLIER() / 100;
			if(iFarDistance > /*50*/ GC.getPROXIMITY_FAR_DISTANCE_MAX())
			{
				iFarDistance = /*50*/ GC.getPROXIMITY_FAR_DISTANCE_MAX();
			}
			// Far also can't be so small that it sits on Close's turf
			else if(iFarDistance < /*20*/ GC.getPROXIMITY_FAR_DISTANCE_MIN())
			{
				iFarDistance = /*20*/ GC.getPROXIMITY_FAR_DISTANCE_MIN();
			}

			// Close
			if(eProximity == PLAYER_PROXIMITY_CLOSE && iAverageDistanceBetweenCities <= iCloseDistance)
			{
				eProximity = PLAYER_PROXIMITY_CLOSE;
			}
			// Far
			else if(iAverageDistanceBetweenCities <= iFarDistance)
			{
				eProximity = PLAYER_PROXIMITY_FAR;
			}
			// Distant
			else
			{
				eProximity = PLAYER_PROXIMITY_DISTANT;
			}
		}

		// Players NOT on the same landmass - bump up PROXIMITY by one level (unless we're already distant or on a water map)
		if(eProximity != PLAYER_PROXIMITY_DISTANT && !(GC.getMap().GetAIMapHint() & ciMapHint_Naval))
		{
			// Both players have capitals, so we can check their areas to see if they're separated by water
			if(getCapitalCity() != NULL && GET_PLAYER(ePlayer).getCapitalCity() != NULL)
			{
				if(getCapitalCity()->getArea() != GET_PLAYER(ePlayer).getCapitalCity()->getArea())
				{
					eProximity = PlayerProximityTypes(eProximity - 1);
				}
			}
		}
	}

	int iNumMajorsLeft = GC.getGame().countMajorCivsAlive();

	// Only two players left, the farthest we can be considered is "Close"
	if(iNumMajorsLeft == 2)
		eProximity = max(eProximity, PLAYER_PROXIMITY_CLOSE);

	// Four or fewer players left, the farthest we can be considered is "Far"
	else if(iNumMajorsLeft <= 4)
		eProximity = max(eProximity, PLAYER_PROXIMITY_FAR);

	SetProximityToPlayer(ePlayer, eProximity);
#endif
}

//	--------------------------------------------------------------------------------
/// Update the beakers accumulated during the term of RAs
void CvPlayer::UpdateResearchAgreements(int iValue)
{
	PlayerTypes ePlayerLoop;
	TeamTypes eTeamLoop;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		ePlayerLoop = (PlayerTypes) iPlayerLoop;
		eTeamLoop = GET_PLAYER(ePlayerLoop).getTeam();
		if(ePlayerLoop == GetID())
			continue;
		if(eTeamLoop == getTeam())
			continue;

		if(GET_TEAM(getTeam()).IsHasResearchAgreement(eTeamLoop))
		{
			// Note that this increases the counter for all players on the other team,
			// even though the RA was only made with one of them.  This is because
			// RAs, though made with players, are restricted and tracked by 1 per team.
			// This must change if future implementations allow for multiple RAs to be
			// made with a particular team.
			ChangeResearchAgreementCounter(ePlayerLoop, iValue);
		}
		else if(GetResearchAgreementCounter(ePlayerLoop) != 0)
		{
			SetResearchAgreementCounter(ePlayerLoop, 0);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Get the beakers accumulated during the RA with a player
int CvPlayer::GetResearchAgreementCounter(PlayerTypes ePlayer) const
{
	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePlayer < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_aiResearchAgreementCounter[ePlayer];
}

//	--------------------------------------------------------------------------------
/// Set the beakers accumulated during the RA with a player
void CvPlayer::SetResearchAgreementCounter(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePlayer < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");

	CvAssertMsg(GetID() != ePlayer, "Trying to make a RA Agreement with oneself. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

	m_aiResearchAgreementCounter.setAt(ePlayer, iValue);
}

//	--------------------------------------------------------------------------------
/// Change the beakers accumulated during the RA with a player
void CvPlayer::ChangeResearchAgreementCounter(PlayerTypes ePlayer, int iChange)
{
	SetResearchAgreementCounter(ePlayer, GetResearchAgreementCounter(ePlayer) + iChange);
}

//	--------------------------------------------------------------------------------
/// Someone sent us a present!
void CvPlayer::DoCivilianReturnLogic(bool bReturn, PlayerTypes eToPlayer, int iUnitID)
{
	CvUnit* pUnit = getUnit(iUnitID);
	if(!pUnit)
	{
		return;
	}

	CvPlot* pPlot = pUnit->plot();
	if(!pPlot)
	{
		return;
	}

	// Kill any units this guy is transporting
	IDInfo* pUnitNode = pPlot->headUnitNode();
	while(pUnitNode != NULL)
	{
		CvUnit* pLoopUnit = ::getUnit(*pUnitNode);
		pUnitNode = pPlot->nextUnitNode(pUnitNode);

		if(NULL != pLoopUnit && pLoopUnit->getTransportUnit() == pUnit)
			pLoopUnit->kill(true);
	}

	// What are the details for the new unit?
	UnitTypes eNewUnitType = pUnit->getUnitType();

	if(!bReturn)
		eNewUnitType = pUnit->getCaptureUnitType(getCivilizationType());

	int iX = pUnit->getX();
	int iY = pUnit->getY();

	// Returns to the previous owner
	if(bReturn)
	{
		pUnit->kill(true);
		CvUnit* pNewUnit = GET_PLAYER(eToPlayer).initUnit(eNewUnitType, iX, iY);
		CvAssert(pNewUnit != NULL);
		if (pNewUnit)
		{
			if (!pNewUnit->jumpToNearestValidPlot())
				pNewUnit->kill(false);	// Could not find a spot!
		}

		// Returned to a city-state
		if(GET_PLAYER(eToPlayer).isMinorCiv())
		{
			int iInfluence = /*45*/ GC.getRETURN_CIVILIAN_FRIENDSHIP();
			GET_PLAYER(eToPlayer).GetMinorCivAI()->ChangeFriendshipWithMajor(GetID(), iInfluence);
		}
		// Returned to major power
		else if(!GET_PLAYER(eToPlayer).isHuman())
		{
			GET_PLAYER(eToPlayer).GetDiplomacyAI()->ChangeNumCiviliansReturnedToMe(GetID(), 1);
		}
#if defined(MOD_BALANCE_CORE)
		else if(GET_PLAYER(eToPlayer).isHuman() && pNewUnit)
		{
			CvNotifications* pNotification = GET_PLAYER(eToPlayer).GetNotifications();
			if(pNotification)
			{
				Localization::String localizedText = Localization::Lookup("TXT_KEY_NOTIFICATION_UNIT_RETURNED_AI");
				localizedText << getNameKey() << pNewUnit->getUnitInfo().GetTextKey();
				Localization::String localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_UNIT_RETURNED_AI_SUMMARY");
				localizedSummary << getNameKey() << pNewUnit->getUnitInfo().GetTextKey();
				pNotification->Add(NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER, localizedText.toUTF8(), localizedSummary.toUTF8(), pNewUnit->getX(), pNewUnit->getY(), pNewUnit->getUnitType());
			}
		}
#endif
	}
	// Kept for oneself
	else
	{
		// Make a new unit because the kind we should capture doesn't match (e.g. Settler to Worker)
		if(eNewUnitType != pUnit->getUnitType())
		{
#if defined(MOD_GLOBAL_GRATEFUL_SETTLERS)
			// In OCC games, all captured settlers are converted
			if ((pUnit->isFound() || pUnit->IsFoundAbroad()) && MOD_GLOBAL_GRATEFUL_SETTLERS && !(GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && isHuman())) {
				int iDefectProb = gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_PERCENT", 20);
				int iPercent = 0;

				// Approach is very important
				switch (GetDiplomacyAI()->GetMajorCivApproach(eToPlayer, false)) {
					case MAJOR_CIV_APPROACH_WAR:
						iPercent = iDefectProb * gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_WAR_MULTIPLIER", 0) / gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DIVISOR", 8);
						break;
					case MAJOR_CIV_APPROACH_HOSTILE:
						iPercent = iDefectProb * gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_HOSTILE_MULTIPLIER", 2) / gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DIVISOR", 8);
						break;
					case MAJOR_CIV_APPROACH_GUARDED:
						iPercent = iDefectProb * gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_GUARDED_MULTIPLIER", 4) / gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DIVISOR", 8);
						break;
					case MAJOR_CIV_APPROACH_DECEPTIVE:
						iPercent = iDefectProb * gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DECEPTIVE_MULTIPLIER", 4) / gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DIVISOR", 8);
						break;
					case MAJOR_CIV_APPROACH_AFRAID:
						iPercent = iDefectProb * gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_AFRAID_MULTIPLIER", 4) / gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DIVISOR", 8);
						break;
					case MAJOR_CIV_APPROACH_NEUTRAL:
						iPercent = iDefectProb * gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_NEUTRAL_MULTIPLIER", 6) / gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DIVISOR", 8);
						break;
					case MAJOR_CIV_APPROACH_FRIENDLY:
						iPercent = iDefectProb * gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_FRIENDLY_MULTIPLIER", 10) / gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_DIVISOR", 8);
						break;
					default:
						break;
				}

				// Opinion also matters
				switch (GetDiplomacyAI()->GetMajorCivOpinion(eToPlayer)) {
					case MAJOR_CIV_OPINION_ALLY:
						iPercent += iDefectProb * 5 / 4;
						break;
					case MAJOR_CIV_OPINION_FRIEND:
						iPercent += iDefectProb * 1;
						break;
					case MAJOR_CIV_OPINION_FAVORABLE:
						iPercent += iDefectProb * 3 / 4;
						break;
					case MAJOR_CIV_OPINION_NEUTRAL:
						iPercent += iDefectProb * 1 / 2;
						break;
					case MAJOR_CIV_OPINION_COMPETITOR:
						iPercent += iDefectProb * 0;
						break;
					case MAJOR_CIV_OPINION_ENEMY:
						iPercent += iDefectProb * -1;
						break;
					case MAJOR_CIV_OPINION_UNFORGIVABLE:
						iPercent += iDefectProb * -1;
						break;
					default:
						break;
				}

				// Limit the outcome
				iPercent = std::min(50, std::max(5, iPercent));

				// Our masters sent us into a war-zone, we'll stick where we are!
				if (GetDiplomacyAI()->GetNumOurEnemiesPlayerAtWarWith(eToPlayer) > 0) {
					iPercent *= 2;
				}

				// If they will found the second city (ie kudos) multiply by 1.5
				if (getNumCities() == 1) {
					iPercent *= 3;
					iPercent /= 2;
				}

#if defined(MOD_GLOBAL_RELIGIOUS_SETTLERS)
				if (MOD_GLOBAL_RELIGIOUS_SETTLERS) {
					ReligionTypes eReligion = pUnit->GetReligionData()->GetReligion();

					if (eReligion > RELIGION_PANTHEON) {
						const CvReligion* pkReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, NO_PLAYER);

						if (pkReligion) {
							CvPlot* pPlot = GC.getMap().plot(pkReligion->m_iHolyCityX, pkReligion->m_iHolyCityY);

							if (pPlot) {
								CvCity* pHolyCity = pPlot->getPlotCity();

								if (pHolyCity->getOriginalOwner() == GetID()) {
									// Bonus if the liberator founded their holy city
									iPercent += gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_HOLYCITY_FOUNDER", 20);
								} else if (pHolyCity->getOwner() == GetID()) {
									// Serious bad karma if the liberator has captured their holy city
									iPercent += gCustomMods.getOption("GLOBAL_GRATEFUL_SETTLERS_HOLYCITY_OCCUPIER", -20);
								}
							}
						}
					}
				}
#endif

				// Limit the outcome
				iPercent = std::min(80, iPercent);
				
				// Use the popularity difference between the players to skew the probability
				int iSmileRatio = (GetExcessHappiness() * 100) / (std::max(0, GET_PLAYER(eToPlayer).GetExcessHappiness()) + 10);
				iPercent = iPercent * std::min(150, std::max(75, iSmileRatio)) / 100;
				CUSTOMLOG("Settler defect percent: %i (Approach=%i, Opinion=%i)", iPercent, GetDiplomacyAI()->GetMajorCivApproach(eToPlayer, false), GetDiplomacyAI()->GetMajorCivOpinion(eToPlayer));

				if (GC.getGame().getSmallFakeRandNum(100, getGlobalAverage(YIELD_CULTURE)) < iPercent) {
					if (GC.getGame().getActivePlayer() == GetID()) {
						CvPopupInfo kPopupInfo(BUTTONPOPUP_TEXT);
						strcpy_s(kPopupInfo.szText, "TXT_KEY_GRATEFUL_SETTLERS");
						GC.GetEngineUserInterface()->AddPopup(kPopupInfo);
					}
				} else {
					pUnit->kill(true);
					CvUnit* pNewUnit = initUnit(eNewUnitType, iX, iY);
					CvAssert(pNewUnit != NULL);
					if (pNewUnit)
						pNewUnit->finishMoves();
				}
			} else {
#endif
				pUnit->kill(true);
				CvUnit* pNewUnit = initUnit(eNewUnitType, iX, iY);
				CvAssert(pNewUnit != NULL);
				if (pNewUnit)
					pNewUnit->finishMoves();
#if defined(MOD_GLOBAL_GRATEFUL_SETTLERS)
			}
#endif
		}
	}
}
#if defined(MOD_BALANCE_CORE)
void CvPlayer::DoTradeInfluenceAP()
{
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();
	int iOwner = GetID();
	if(GetPlayerTraits()->IsTradeRouteMinorInfluenceAdmiralPoints())
	{
		for (uint ui = 0; ui < pTrade->GetNumTradeConnections(); ui++)
		{
			if (pTrade->IsTradeRouteIndexEmpty(ui))
			{
				continue;
			}

			const TradeConnection* pConnection = &(pTrade->GetTradeConnection(ui));

			if (pConnection->m_eOriginOwner == iOwner && pConnection->m_eDestOwner != iOwner)
			{
				bool bMinorCiv = GET_PLAYER(pConnection->m_eDestOwner).isMinorCiv();
				if(bMinorCiv)
				{
					int iInfluence = GC.getGame().getGameSpeedInfo().getGoldGiftMod() / 100;
					if (pConnection->m_eDomain == DOMAIN_LAND)
					{
						GET_PLAYER(pConnection->m_eDestOwner).GetMinorCivAI()->ChangeFriendshipWithMajor((PlayerTypes)iOwner, iInfluence);
						changeNavalCombatExperienceTimes100(iInfluence * 100);
					}
					else if (pConnection->m_eDomain == DOMAIN_SEA)
					{
						iInfluence *= 2;
						GET_PLAYER(pConnection->m_eDestOwner).GetMinorCivAI()->ChangeFriendshipWithMajor((PlayerTypes)iOwner, iInfluence);
						changeNavalCombatExperienceTimes100(iInfluence * 100);
					}
				}
			}
		}
	}
}
#endif
//	--------------------------------------------------------------------------------
/// Units in the ether coming towards us?
void CvPlayer::DoIncomingUnits()
{
	AI_PERF_FORMAT("AI-perf.csv", ("CvPlayer::DoIncomingUnits, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), getCivilizationShortDescription()) );
	for(int iLoop = 0; iLoop < MAX_PLAYERS; iLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iLoop;
		CvAssertMsg(GetIncomingUnitCountdown(eLoopPlayer) >= -1, "Incoming Unit countdown is an invalid value. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
		if(GetIncomingUnitCountdown(eLoopPlayer) > 0)
		{
			ChangeIncomingUnitCountdown(eLoopPlayer, -1);

			// Time to spawn a new unit
			if(GetIncomingUnitCountdown(eLoopPlayer) == 0)
			{
				// Must have capital to actually spawn unit
				CvCity* pCapital = getCapitalCity();
				if(pCapital)
				{
					CvUnit* pNewUnit = initUnit(GetIncomingUnitType(eLoopPlayer), pCapital->getX(), pCapital->getY());
					CvAssert(pNewUnit);
					if (pNewUnit)
					{
						if(pNewUnit->getDomainType() != DOMAIN_AIR)
						{
							if (!pNewUnit->jumpToNearestValidPlot())
								pNewUnit->kill(false);
						}

						// Gift from a major to a city-state
						if (isMinorCiv() && !GET_PLAYER(eLoopPlayer).isMinorCiv())
						{
							GetMinorCivAI()->DoUnitGiftFromMajor(eLoopPlayer, pNewUnit, /*bDistanceGift*/ true);
						}
					}
				}

				// Reset stuff
				SetIncomingUnitCountdown(eLoopPlayer, -1);
				SetIncomingUnitType(eLoopPlayer, NO_UNIT);
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Someone sent us a present!
void CvPlayer::DoDistanceGift(PlayerTypes eFromPlayer, CvUnit* pUnit)
{
	if(!pUnit)
	{
		return;
	}

	CvPlot* pPlot = pUnit->plot();
	if(!pPlot)
	{
		return;
	}

	// Also add any units this guy is transporting
	IDInfo* pUnitNode = pPlot->headUnitNode();
	while(pUnitNode != NULL)
	{
		CvUnit* pLoopUnit = ::getUnit(*pUnitNode);
		pUnitNode = pPlot->nextUnitNode(pUnitNode);

		if(NULL != pLoopUnit && pLoopUnit->getTransportUnit() == pUnit)
			AddIncomingUnit(eFromPlayer, pLoopUnit);
	}

	AddIncomingUnit(eFromPlayer, pUnit);
}
bool CvPlayer::CanGiftUnit(PlayerTypes eToPlayer)
{
	if (GET_PLAYER(eToPlayer).isMinorCiv())
	{
		if (GET_PLAYER(eToPlayer).GetIncomingUnitCountdown(GetID()) != -1)
		{
			return false;
		}

		int iNum = GET_PLAYER(eToPlayer).GetNumUnitsToSupply();
		int iMax = max(3, ((GET_PLAYER(eToPlayer).GetCurrentEra() + 2) * GET_PLAYER(eToPlayer).getNumCities()));

		if (iNum >= iMax)
			return false;

		return true;
	}
	return false;
}
//	--------------------------------------------------------------------------------
/// Someone sent us a present!
void CvPlayer::AddIncomingUnit(PlayerTypes eFromPlayer, CvUnit* pUnit)
{
	UnitTypes eUnitType = pUnit->getUnitType();

	// Gift to a minor civ for friendship
	if(isMinorCiv() && eFromPlayer < MAX_MAJOR_CIVS)
	{
		CvAssertMsg(GetIncomingUnitType(eFromPlayer) == NO_UNIT, "Adding incoming unit when one is already on its way. Please send Anton your save file and version.");
		CvAssertMsg(GetIncomingUnitCountdown(eFromPlayer) == -1, "Adding incoming unit when one is already on its way. Please send Anton your save file and version.");
		if(GetIncomingUnitCountdown(eFromPlayer) == -1)
		{
			SetIncomingUnitCountdown(eFromPlayer, GC.getMINOR_UNIT_GIFT_TRAVEL_TURNS());
			SetIncomingUnitType(eFromPlayer, eUnitType);
		}

		// Get rid of the old unit
		pUnit->kill(true);
	}
	// Gift from minor civ to this major civ (ex. Austria UA, but NOT Militaristic unit spawning, that is handled elsewhere)
	else if(!isMinorCiv() && GET_PLAYER(eFromPlayer).isMinorCiv())
	{
		int iX = pUnit->getX();
		int iY = pUnit->getY();
		UnitTypes eType = pUnit->getUnitType();

		// Get rid of the old unit
		pUnit->kill(true);

		// Add the new unit in its place
		if(eType != NO_UNIT)
		{
			CvUnit* pNewUnit = initUnit(eType, iX, iY);
			CvAssert(pNewUnit);
			if (pNewUnit)
#if defined(MOD_BUGFIX_MOVE_AFTER_PURCHASE)
			{
				if (!pUnit->getUnitInfo().CanMoveAfterPurchase())
				{
#endif
					pNewUnit->finishMoves();
#if defined(MOD_BUGFIX_MOVE_AFTER_PURCHASE)
				}
				if (getCapitalCity() != NULL)
				{
					pNewUnit->setOriginCity(getCapitalCity()->GetID());
				}
			}
#endif
		}
	}
	else
	{
		CvAssertMsg(false, "Unexpected case for adding an incoming unit for this player. Please send Anton your save file and version.");
	}
}
//AI Routine for Gifting
PlayerTypes CvPlayer::GetBestGiftTarget()
{
	int iBestValue = 0;
	PlayerTypes eBestMinor = NO_PLAYER;
	for (int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		PlayerTypes eLoopMinor = (PlayerTypes)iMinorLoop;
		if (eLoopMinor != NO_PLAYER)
		{
			CvPlayer* eMinor = &GET_PLAYER(eLoopMinor);
			if (eMinor && eMinor->isAlive())
			{
				CvCity* pCity = eMinor->getCapitalCity();
				if (pCity == NULL)
					continue;

				//First, the exclusions!
				if (!CanGiftUnit(eLoopMinor))
					continue;

				//Initializations...
				int iScore = 0;

				CvMinorCivAI* pMinorCivAI = eMinor->GetMinorCivAI();
				int iFriendship = pMinorCivAI->GetFriendshipFromUnitGift(GetID(), false, true);

				// Skip if not revealed.
				if (!pCity->plot()->isRevealed(getTeam()))
				{
					continue;
				}

				if (!GET_TEAM(eMinor->getTeam()).isHasMet(getTeam()))
					continue;

				if (pMinorCivAI->IsNoAlly() && pMinorCivAI->IsFriends(GetID()))
				{
					continue;
				}
				if (pMinorCivAI->GetPermanentAlly() == GetID())
				{
					continue;
				}
				if (pMinorCivAI->GetPermanentAlly() != GetID() && pMinorCivAI->GetPermanentAlly() != NO_PLAYER)
				{
					continue;
				}
				//If we are at war with target minor, let's not send diplomatic lambs to slaughter.
				if (eMinor->GetMinorCivAI()->IsAtWarWithPlayersTeam(GetID()))
				{
					continue;
				}

				if (eMinor->GetMinorCivAI()->IsActiveQuestForPlayer(GetID(), MINOR_CIV_QUEST_HORDE) || eMinor->GetMinorCivAI()->IsActiveQuestForPlayer(GetID(), MINOR_CIV_QUEST_REBELLION))
				{
					continue;
				}

				// Did we bully you recently?  If so, being friendly now would be very odd.
				if (pMinorCivAI->IsRecentlyBulliedByMajor(GetID()))
				{
					continue;
				}

				int iOtherMajorLoop;
				PlayerTypes eOtherMajor;
				int iFriendshipWithMinor;
				int iOtherPlayerFriendshipWithMinor;

				EconomicAIStrategyTypes eNeedHappiness = (EconomicAIStrategyTypes)GC.getInfoTypeForString("ECONOMICAISTRATEGY_NEED_HAPPINESS");
				EconomicAIStrategyTypes eNeedHappinessCritical = (EconomicAIStrategyTypes)GC.getInfoTypeForString("ECONOMICAISTRATEGY_NEED_HAPPINESS_CRITICAL");
				bool bNeedHappiness = (eNeedHappiness != NO_ECONOMICAISTRATEGY) ? GetEconomicAI()->IsUsingStrategy(eNeedHappiness) : false;
				bool bNeedHappinessCritical = (eNeedHappinessCritical != NO_ECONOMICAISTRATEGY) ? GetEconomicAI()->IsUsingStrategy(eNeedHappinessCritical) : false;

				MinorCivApproachTypes eApproach;

				// **************************
				// Approaches
				// **************************

				iScore = 100;
				eApproach = GetDiplomacyAI()->GetMinorCivApproach(eLoopMinor);

				if (eApproach == MINOR_CIV_APPROACH_IGNORE)
				{
					iScore /= 2;
				}

				// **************************
				// Benefits to Us!
				// **************************

				//DIPLOMACY - We want all of them the same!
				if (GetDiplomacyAI()->IsGoingForDiploVictory())
				{
					iScore *= 2;
				}

				//MILITARY - We want units and happiness!!
				else if (GetDiplomacyAI()->IsGoingForWorldConquest())
				{
					if (pMinorCivAI->GetTrait() == MINOR_CIV_TRAIT_MILITARISTIC)
					{
						iScore *= 2;
					}
				}

				//SCIENCE - We want happiness and growth!!
				else if (GetDiplomacyAI()->IsGoingForSpaceshipVictory())
				{
					if (pMinorCivAI->GetTrait() == MINOR_CIV_TRAIT_MARITIME)
					{
						iScore *= 2;
					}
					if (pMinorCivAI->GetTrait() == MINOR_CIV_TRAIT_MERCANTILE)
					{
						iScore *= 2;
					}
				}

				//CULTURE - We want culture and religion!!
				else if (GetDiplomacyAI()->IsGoingForCultureVictory())
				{
					if (pMinorCivAI->GetTrait() == MINOR_CIV_TRAIT_CULTURED)
					{
						iScore *= 2;
					}
					if (pMinorCivAI->GetTrait() == MINOR_CIV_TRAIT_RELIGIOUS)
					{
						iScore *= 2;
					}
				}

				// Is Our Influence worth more here? Definitely take advantage of this.
				if (pMinorCivAI->IsActiveQuestForPlayer(GetID(), MINOR_CIV_QUEST_INFLUENCE))
				{
					iScore *= 5;
				}

				// Do they have a resource we lack?
				int iResourcesWeLack = pMinorCivAI->GetNumResourcesMajorLacks(GetID());
				if (iResourcesWeLack > 0)
				{
					if (bNeedHappiness)
					{
						iScore *= 3;
					}
					else if (bNeedHappinessCritical)
					{
						iScore *= 4;
					}
					else
					{
						iScore *= 2;
					}
				}

				//Will they give us a WLTKD for their resource?
				CvCity* pLoopCity;
				int iCityLoop;
				for (pLoopCity = GET_PLAYER(GetID()).firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(GetID()).nextCity(&iCityLoop))
				{
					if (pLoopCity != NULL)
					{
						ResourceTypes eResourceDemanded = pLoopCity->GetResourceDemanded();
						if (eResourceDemanded != NO_RESOURCE)
						{
							//Will we get a WLTKD from this? We want it a bit more, please.
							if (eMinor->getResourceInOwnedPlots(eResourceDemanded) > 0)
							{
								iScore *= 3;
								iScore /= 2;
							}
						}
					}
				}

				//Nobody likes hostile city-states.
				if (pMinorCivAI->GetPersonality() == MINOR_CIV_PERSONALITY_HOSTILE)
				{
					iScore /= 2;
				}
				//If our friendship is under 0, we've probably done something bad to this City-State. Let's not look at them!
				if (eMinor->GetMinorCivAI()->GetEffectiveFriendshipWithMajor(GetID()) < 0)
				{
					iScore /= 2;
				}

				// **************************
				// Other Relationships!
				// **************************

				PlayerTypes eAlliedPlayer = NO_PLAYER;
				iFriendshipWithMinor = pMinorCivAI->GetEffectiveFriendshipWithMajor(GetID());
				eAlliedPlayer = pMinorCivAI->GetAlly();

				if (eAlliedPlayer != NO_PLAYER)
				{
					int iHighestInfluence = 0;
					// Loop through other players to see if we can pass them in influence
					for (iOtherMajorLoop = 0; iOtherMajorLoop < MAX_MAJOR_CIVS; iOtherMajorLoop++)
					{
						eOtherMajor = (PlayerTypes)iOtherMajorLoop;

						iOtherPlayerFriendshipWithMinor = pMinorCivAI->GetEffectiveFriendshipWithMajor(eOtherMajor);
						if (iOtherPlayerFriendshipWithMinor > iHighestInfluence)
						{
							iHighestInfluence = iOtherPlayerFriendshipWithMinor;
						}
						if (eOtherMajor != NO_PLAYER && eOtherMajor != GetID() && GET_TEAM(GET_PLAYER(GetID()).getTeam()).isHasMet(GET_PLAYER(eOtherMajor).getTeam()))
						{
							MajorCivApproachTypes eApproachType = GetDiplomacyAI()->GetMajorCivApproach(eOtherMajor, false);
							MajorCivOpinionTypes eOpinion = GetDiplomacyAI()->GetMajorCivOpinion(eOtherMajor);
							// If another player is allied, let's evaluate that.
							// Only care if they are allies
							if (pMinorCivAI->IsAllies(eOtherMajor))
							{
								//Are they not on our team?
								if (GET_PLAYER(eOtherMajor).getTeam() != getTeam())
								{
									//If their influence is way higher than ours, let's tune this down...
									if (iOtherPlayerFriendshipWithMinor >= (60 + iFriendship + iFriendshipWithMinor))
									{
										iScore /= 4;
									}
									//If we can pass them, ramp it up!
									else if (iOtherPlayerFriendshipWithMinor < (iFriendship + iFriendshipWithMinor))
									{
										iScore *= 4;
									}
								}
								// If a teammate is allied, let's discourage going there.
								else
								{
									iScore /= 5;
								}
								// If a friendly player is allied, let's discourage going there.
								if (eApproachType == MAJOR_CIV_APPROACH_FRIENDLY)
								{
									iScore /= 2;
								}
								// If an enemy is allied, let's take their stuff!
								else if (eApproachType == MAJOR_CIV_APPROACH_HOSTILE)
								{
									iScore *= 2;
								}
								// If an ally is allied, let's leave it alone!
								if (eOpinion == MAJOR_CIV_OPINION_ALLY)
								{
									iScore /= 2;
								}
								// If an competitor is allied, let's fight for it!
								else if (eOpinion == MAJOR_CIV_OPINION_COMPETITOR)
								{
									iScore *= 2;
								}
							}
							// Is another player really close to us? If so, let's keep an eye on things.
							else if (iOtherPlayerFriendshipWithMinor >= (iFriendshipWithMinor - 30))
							{
								iScore *= 2;
							}
						}
					}
					int iDifference = (iFriendshipWithMinor - iHighestInfluence);
					// Are we allied? Yay! But let's be careful.
					if (pMinorCivAI->IsAllies(GetID()))
					{
						// Are WE allies by a wide margin (over 100)? If so, let's find someone new to love.
						if (iDifference >= 60)
						{
							iScore /= 5;
						}
						// Are we close to losing our status? If so, obsess away!
						else if (iDifference <= 30 || pMinorCivAI->IsCloseToNotBeingAllies(GetID()))
						{
							iScore *= 5;
						}
					}
				}
				else
				{
					// Are we close to becoming an normal (60) ally and no one else ? If so, obsess away!
#if defined(MOD_CITY_STATE_SCALE)
					if ((iFriendshipWithMinor + iFriendship) >= pMinorCivAI->GetAlliesThreshold(GetID()))
#else
					if ((iFriendshipWithMinor + iFriendship) >= pMinorCivAI->GetAlliesThreshold())
#endif
					{
						iScore *= 4;
					}

					// Are we already Friends? If so, let's stay the course.
					if (pMinorCivAI->IsFriends(GetID()))
					{
						iScore *= 4;
					}
				}

				//All CSs should theoretically be valuable if we've gotten this far.
				if (iScore <= 0)
				{
					iScore = 1;
				}
				if (iScore > iBestValue)
				{
					iBestValue = iScore;
					eBestMinor = eLoopMinor;
				}
			}
		}
	}
	return eBestMinor;
}
//	--------------------------------------------------------------------------------
/// Units in the ether coming towards us?
UnitTypes CvPlayer::GetIncomingUnitType(PlayerTypes eFromPlayer) const
{
	CvAssertMsg(eFromPlayer >= 0, "eFromPlayer is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFromPlayer < MAX_PLAYERS, "eFromPlayer is expected to be within maximum bounds (invalid Index)");
	return (UnitTypes) m_aiIncomingUnitTypes[eFromPlayer];
}

//	--------------------------------------------------------------------------------
/// Units in the ether coming towards us?
void CvPlayer::SetIncomingUnitType(PlayerTypes eFromPlayer, UnitTypes eUnitType)
{
	CvAssertMsg(eFromPlayer >= 0, "eFromPlayer is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFromPlayer < MAX_PLAYERS, "eFromPlayer is expected to be within maximum bounds (invalid Index)");

	CvAssertMsg(eUnitType >= NO_UNIT, "eUnitType is expected to be non-negative (invalid Index)");
	CvAssertMsg(eUnitType < GC.getNumUnitInfos(), "eUnitType is expected to be within maximum bounds (invalid Index)");

	if(eUnitType != m_aiIncomingUnitTypes[eFromPlayer])
	{
		m_aiIncomingUnitTypes.setAt(eFromPlayer, eUnitType);
	}
}

//	--------------------------------------------------------------------------------
/// Units in the ether coming towards us?
int CvPlayer::GetIncomingUnitCountdown(PlayerTypes eFromPlayer) const
{
	CvAssertMsg(eFromPlayer >= 0, "eFromPlayer is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFromPlayer < MAX_PLAYERS, "eFromPlayer is expected to be within maximum bounds (invalid Index)");
	return m_aiIncomingUnitCountdowns[eFromPlayer];
}

//	--------------------------------------------------------------------------------
/// Units in the ether coming towards us?
void CvPlayer::SetIncomingUnitCountdown(PlayerTypes eFromPlayer, int iNumTurns)
{
	CvAssertMsg(eFromPlayer >= 0, "eFromPlayer is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFromPlayer < MAX_PLAYERS, "eFromPlayer is expected to be within maximum bounds (invalid Index)");

	if(iNumTurns != m_aiIncomingUnitCountdowns[eFromPlayer])
		m_aiIncomingUnitCountdowns.setAt(eFromPlayer, iNumTurns);
}

//	--------------------------------------------------------------------------------
/// Units in the ether coming towards us?
void CvPlayer::ChangeIncomingUnitCountdown(PlayerTypes eFromPlayer, int iChange)
{
	if(iChange != 0)
		SetIncomingUnitCountdown(eFromPlayer, GetIncomingUnitCountdown(eFromPlayer) + iChange);
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isOption(PlayerOptionTypes eID) const
{
	for (PlayerOptionsVector::const_iterator itr = m_aOptions.begin(); itr != m_aOptions.end(); ++itr )
	{
		if ((*itr).first == eID)
			return (*itr).second != 0;
	}
	return false;
}


//	--------------------------------------------------------------------------------
void CvPlayer::setOption(PlayerOptionTypes eID, bool bNewValue)
{
	int iIndex = 0;
	for (PlayerOptionsVector::const_iterator itr = m_aOptions.begin(); itr != m_aOptions.end(); ++itr )
	{
		if ((*itr).first == eID)
		{
			m_aOptions.setAt(iIndex, PlayerOptionEntry((uint)eID, bNewValue?1:0));
			return;
		}
		++iIndex;
	}

	m_aOptions.push_back(PlayerOptionEntry((uint)eID, bNewValue?1:0));
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isPlayable() const
{
	return CvPreGame::isPlayable(GetID());
}

//	--------------------------------------------------------------------------------
void CvPlayer::setPlayable(bool bNewValue)
{
	CvPreGame::setPlayable(GetID(), bNewValue);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNumResourceUsed(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiNumResourceUsed[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeNumResourceUsed(ResourceTypes eIndex, int iChange)
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumResourceInfos());

	if(iChange != 0)
	{
		m_paiNumResourceUsed.setAt(eIndex, m_paiNumResourceUsed[eIndex] + iChange);
	}
#if !defined(MOD_BALANCE_CORE)
	if(iChange > 0)
		DoTestOverResourceNotification(eIndex);
#endif

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	CvAssert(m_paiNumResourceUsed[eIndex] >= 0);
}
//	--------------------------------------------------------------------------------
int CvPlayer::getNumResourcesFromOther(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	// Mod applied to how much we have?
	CvResourceInfo *pkResource = GC.getResourceInfo(eIndex);
	if (pkResource == NULL)
	{
		return 0;
	}

	int iTotalNumResource = m_paiNumResourceTotal[eIndex];

#if defined(MOD_BALANCE_CORE)
	// Additional resources from Corporation
	CorporationTypes eCorporation = GetCorporations()->GetFoundedCorporation();
	if (eCorporation != NO_CORPORATION)
	{
		CvCorporationEntry* pkCorporationInfo = GC.getCorporationInfo(eCorporation);
		if (pkCorporationInfo)
		{
			int iFreeResource = pkCorporationInfo->GetNumFreeResource(eIndex);
			if (iFreeResource > 0)
			{
				iTotalNumResource += iFreeResource;
			}
		}
	}

	int iCSResource = getResourceFromCSAlliances(eIndex);
	if (iCSResource != 0)
	{
		TechTypes eRevealTech = (TechTypes)pkResource->getTechReveal();

		if (eRevealTech == NO_TECH || GET_TEAM(getTeam()).GetTeamTechs()->HasTech(eRevealTech))
		{
			iCSResource *= GetNumCSAllies();
			iCSResource /= 100;
			iTotalNumResource += iCSResource;
		}
		else
		{
			PolicyTypes eRevealPolicy = (PolicyTypes)pkResource->getPolicyReveal();

			// Is there no Reveal Tech or do we have it?
			if (eRevealPolicy != NO_POLICY && GetPlayerPolicies()->HasPolicy(eRevealPolicy))
			{
				iCSResource *= GetNumCSAllies();
				iCSResource /= 100;
				iTotalNumResource += iCSResource;
			}
		}
	}
#endif

	if (pkResource->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)
	{
#if defined(MOD_BALANCE_CORE)
		const CvCity* pLoopCity;
		int iLoop;
		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if (pLoopCity != NULL)
			{
				if (pLoopCity->GetResourceQuantityPerXFranchises(eIndex) > 0)
				{
					int iFranchises = GetCorporations()->GetNumFranchises();
					if (iFranchises > 0)
					{
						iTotalNumResource += (iFranchises / pLoopCity->GetResourceQuantityPerXFranchises(eIndex));
					}
				}
			}
		}
#endif
		if (GetStrategicResourceMod() != 0)
		{
			iTotalNumResource *= GetStrategicResourceMod();
			iTotalNumResource /= 100;
		}
	}

#if defined(MOD_BALANCE_CORE)
	ReligionTypes eFounder = GC.getGame().GetGameReligions()->GetReligionCreatedByPlayer(GetID());
	if (eFounder == NO_RELIGION)
	{
		eFounder = GetReligions()->GetReligionInMostCities();
	}
	const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eFounder, GetID());
	if (pReligion)
	{
		CvCity* pHolyCity = NULL;
		CvPlot* pHolyCityPlot = GC.getMap().plot(pReligion->m_iHolyCityX, pReligion->m_iHolyCityY);
		if (pHolyCityPlot)
		{
			pHolyCity = pHolyCityPlot->getPlotCity();
		}
		if (pHolyCity == NULL)
		{
			pHolyCity = GET_PLAYER(GetID()).getCapitalCity();
		}
		int iQuantityMod = pReligion->m_Beliefs.GetResourceQuantityModifier(eIndex, GetID(), pHolyCity, true);
		if (iQuantityMod != 0)
		{
			iQuantityMod *= GC.getGame().GetGameReligions()->GetNumCitiesFollowing(eFounder);

			iTotalNumResource *= 100 + std::min(25, iQuantityMod);
			iTotalNumResource /= 100;
		}
	}
#endif

	//And remove the starter.
	iTotalNumResource -= m_paiNumResourceTotal[eIndex];

	return iTotalNumResource;
}
//	--------------------------------------------------------------------------------
int CvPlayer::getNumResourceTotal(ResourceTypes eIndex, bool bIncludeImport, bool bIncludeMinors) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	// Mod applied to how much we have?
	CvResourceInfo *pkResource = GC.getResourceInfo(eIndex);
	if (pkResource == NULL)
	{
		return 0;
	}

	int iTotalNumResource = m_paiNumResourceTotal[eIndex];

#if defined(MOD_BALANCE_CORE)
	// Additional resources from Corporation
	CorporationTypes eCorporation = GetCorporations()->GetFoundedCorporation();
	if (eCorporation != NO_CORPORATION)
	{
		CvCorporationEntry* pkCorporationInfo = GC.getCorporationInfo(eCorporation);
		if (pkCorporationInfo)
		{
			int iFreeResource = pkCorporationInfo->GetNumFreeResource(eIndex);
			if (iFreeResource > 0)
			{
				iTotalNumResource += iFreeResource;
			}
		}
	}

	int iCSResource = getResourceFromCSAlliances(eIndex);
	if (iCSResource != 0)
	{
		TechTypes eRevealTech = (TechTypes)pkResource->getTechReveal();

		if (eRevealTech == NO_TECH || GET_TEAM(getTeam()).GetTeamTechs()->HasTech(eRevealTech))
		{
			iCSResource *= GetNumCSAllies();
			iCSResource /= 100;
			iTotalNumResource += iCSResource;
		}
		else
		{
			PolicyTypes eRevealPolicy = (PolicyTypes)pkResource->getPolicyReveal();

			// Is there no Reveal Tech or do we have it?
			if (eRevealPolicy != NO_POLICY && GetPlayerPolicies()->HasPolicy(eRevealPolicy))
			{
				iCSResource *= GetNumCSAllies();
				iCSResource /= 100;
				iTotalNumResource += iCSResource;
			}
		}
	}
#endif

	if(pkResource->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)
	{
#if defined(MOD_BALANCE_CORE)
		const CvCity* pLoopCity;
		int iLoop;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity != NULL)
			{
				if(pLoopCity->GetResourceQuantityPerXFranchises(eIndex) > 0)
				{
					int iFranchises = GetCorporations()->GetNumFranchises();
					if(iFranchises > 0)
					{
						iTotalNumResource += (iFranchises / pLoopCity->GetResourceQuantityPerXFranchises(eIndex));
					}
				}
			}
		}
#endif
		if(GetStrategicResourceMod() != 0)
		{
			iTotalNumResource *= GetStrategicResourceMod();
			iTotalNumResource /= 100;
		}
	}

#if defined(MOD_BALANCE_CORE)
	ReligionTypes eFounder = GC.getGame().GetGameReligions()->GetReligionCreatedByPlayer(GetID());
	if (eFounder == NO_RELIGION)
	{
		eFounder = GetReligions()->GetReligionInMostCities();
	}
	const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eFounder, GetID());
	if (pReligion)
	{
		CvCity* pHolyCity = NULL;
		CvPlot* pHolyCityPlot = GC.getMap().plot(pReligion->m_iHolyCityX, pReligion->m_iHolyCityY);
		if (pHolyCityPlot)
		{
			pHolyCity = pHolyCityPlot->getPlotCity();
		}
		if (pHolyCity == NULL)
		{
			pHolyCity = GET_PLAYER(GetID()).getCapitalCity();
		}
		int iQuantityMod = pReligion->m_Beliefs.GetResourceQuantityModifier(eIndex, GetID(), pHolyCity, true);
		if (iQuantityMod != 0)
		{
			iQuantityMod *= GC.getGame().GetGameReligions()->GetNumCitiesFollowing(eFounder);

			iTotalNumResource *= 100 + std::min(50, iQuantityMod);
			iTotalNumResource /= 100;
		}
	}
#endif
	if (bIncludeMinors && !IsCSResourcesCountMonopolies())
		bIncludeMinors = false;

	if (bIncludeImport || bIncludeMinors)
		iTotalNumResource += getResourceFromMinors(eIndex);

	if(bIncludeImport)
	{
		iTotalNumResource += getResourceImport(eIndex);
		iTotalNumResource += getResourceSiphoned(eIndex);
	}

	iTotalNumResource -= getResourceExport(eIndex);

	return iTotalNumResource;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeNumResourceTotal(ResourceTypes eIndex, int iChange, bool bIgnoreResourceWarning)
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumResourceInfos());

	if(iChange != 0)
	{
		m_paiNumResourceTotal.setAt(eIndex, m_paiNumResourceTotal[eIndex] + iChange);

#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
		if(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
		{
			CheckForMonopoly(eIndex);
		}
#endif

		// Minors with an Ally give their Resources to their friend (awww)
		if(isMinorCiv())
		{
			PlayerTypes eBestRelationsPlayer = GetMinorCivAI()->GetAlly();

			if(eBestRelationsPlayer != NO_PLAYER)
			{
				ResourceUsageTypes eUsage = GC.getResourceInfo(eIndex)->getResourceUsage();

				if(eUsage == RESOURCEUSAGE_STRATEGIC || eUsage == RESOURCEUSAGE_LUXURY)
				{
					GET_PLAYER(eBestRelationsPlayer).changeResourceFromMinors(eIndex, iChange);
					changeResourceExport(eIndex, iChange);

					// Someone new is getting the bonus - but do they have the tech to see it?
					if (GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)GC.getResourceInfo(eIndex)->getTechReveal()))
					{
						CvNotifications* pNotifications = GET_PLAYER(eBestRelationsPlayer).GetNotifications();
						if(pNotifications && !GetMinorCivAI()->IsDisableNotifications())
						{
							Localization::String strMessage;
							Localization::String strSummary;

							// Adding Resources
							if(iChange > 0)
							{
								strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_BFF_NEW_RESOURCE");
								strMessage << getNameKey() << GC.getResourceInfo(eIndex)->GetDescriptionKey();
								strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MINOR_BFF_NEW_RESOURCE");
								strSummary << getNameKey() << GC.getResourceInfo(eIndex)->GetDescriptionKey();
							}
							// Lost Resources
							else
							{
								strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_BFF_LOST_RESOURCE");
								strMessage << getNameKey() << GC.getResourceInfo(eIndex)->GetDescriptionKey();
								strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MINOR_BFF_LOST_RESOURCE");
								strSummary << getNameKey() << GC.getResourceInfo(eIndex)->GetDescriptionKey();
							}

							int iX = -1;
							int iY = -1;

							CvCity* capCity = getCapitalCity();

							if(capCity != NULL)
							{
								iX = capCity->getX();
								iY = capCity->getY();
							}

							pNotifications->Add(NOTIFICATION_MINOR, strMessage.toUTF8(), strSummary.toUTF8(), iX, iY, -1);
						}
					}
				}
			}
		}

		// Any players siphoning resources from us need to be updated as well
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_PLAYERS; iPlayerLoop++)
		{
			GET_PLAYER((PlayerTypes)iPlayerLoop).UpdateResourcesSiphoned();
		}
	}
	if(iChange < 0 && !bIgnoreResourceWarning)
#if !defined(MOD_BALANCE_CORE)
	{
		DoTestOverResourceNotification(eIndex);
	}
#endif

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	CvAssert(m_paiNumResourceTotal[eIndex] >= 0);
}
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
//	--------------------------------------------------------------------------------
int CvPlayer::getResourceOverValue(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiResourceOverValue[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceOverValue(ResourceTypes eIndex, int iChange)
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumResourceInfos());

	if(iChange != 0)
	{
		m_paiResourceOverValue.setAt(eIndex, m_paiResourceOverValue[eIndex] + iChange);
	}

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	CvAssert(m_paiResourceOverValue[eIndex] >= 0);
}
//	--------------------------------------------------------------------------------
void CvPlayer::setResourceOverValue(ResourceTypes eIndex, int iChange)
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumResourceInfos());

	m_paiResourceOverValue.setAt(eIndex, iChange);

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	CvAssert(m_paiResourceOverValue[eIndex] >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getResourceFromCSAlliances(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiResourceFromCSAlliances[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceFromCSAlliances(ResourceTypes eIndex, int iChange)
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumResourceInfos());

	if (iChange != 0)
	{
		m_paiResourceFromCSAlliances.setAt(eIndex, m_paiResourceFromCSAlliances[eIndex] + iChange);
	}

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	CvAssert(m_paiResourceFromCSAlliances[eIndex] >= 0);
}
//	--------------------------------------------------------------------------------
void CvPlayer::setResourceFromCSAlliances(ResourceTypes eIndex, int iChange)
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumResourceInfos());

	m_paiResourceFromCSAlliances.setAt(eIndex, iChange);

	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	CvAssert(m_paiResourceFromCSAlliances[eIndex] >= 0);
}

//	--------------------------------------------------------------------------------
bool CvPlayer::HasGlobalMonopoly(ResourceTypes eResource) const
{
	return m_pabHasGlobalMonopoly[eResource];
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetHasGlobalMonopoly(ResourceTypes eResource, bool bNewValue)
{
	if(!MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
		return;

	if (bNewValue != m_pabHasGlobalMonopoly[eResource])
	{
		m_pabHasGlobalMonopoly.setAt(eResource, bNewValue);

		YieldTypes eYield;
		CvResourceInfo* pResource = GC.getResourceInfo(eResource);
		if (pResource)
		{
			for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				eYield = (YieldTypes)iI;

				if (eYield == NO_YIELD)
					continue;

				int iModValue = pResource->getCityYieldModFromMonopoly(eYield);
				if (iModValue != 0)
				{
					if (bNewValue)
					{
						changeCityYieldModFromMonopoly(eYield, iModValue);
					}
					else
					{
						changeCityYieldModFromMonopoly(eYield, (iModValue * -1));
					}
				}
			}
		}
	}

	std::vector<ResourceTypes>::iterator it = std::find(m_vResourcesWGlobalMonopoly.begin(),m_vResourcesWGlobalMonopoly.end(),eResource);
	if (bNewValue && it==m_vResourcesWGlobalMonopoly.end())
		m_vResourcesWGlobalMonopoly.push_back(eResource);
	else if (!bNewValue && it!=m_vResourcesWGlobalMonopoly.end())
		m_vResourcesWGlobalMonopoly.erase(it);
}
//	--------------------------------------------------------------------------------
bool CvPlayer::HasStrategicMonopoly(ResourceTypes eResource) const
{
	return m_pabHasStrategicMonopoly[eResource];
}
//	--------------------------------------------------------------------------------
void CvPlayer::SetHasStrategicMonopoly(ResourceTypes eResource, bool bNewValue)
{
	if(!MOD_BALANCE_CORE_RESOURCE_MONOPOLIES_STRATEGIC)
		return;

	if(bNewValue != m_pabHasStrategicMonopoly[eResource])
	{
		m_pabHasStrategicMonopoly.setAt(eResource, bNewValue);
	}

	std::vector<ResourceTypes>::iterator it = std::find(m_vResourcesWStrategicMonopoly.begin(),m_vResourcesWStrategicMonopoly.end(),eResource);
	if (bNewValue && it==m_vResourcesWStrategicMonopoly.end())
		m_vResourcesWStrategicMonopoly.push_back(eResource);
	else if (!bNewValue && it!=m_vResourcesWStrategicMonopoly.end())
		m_vResourcesWStrategicMonopoly.erase(it);
}

//	--------------------------------------------------------------------------------
void CvPlayer::CheckForMonopoly(ResourceTypes eResource)
{
	const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);
	if(pkResourceInfo != NULL)
	{
		if(pkResourceInfo->isMonopoly())
		{
			bool bGainingBonus = false;
			bool bGainingStrategicBonus = false;
			bool bLosingBonus = false;
			bool bLosingStrategicBonus = false;
			int iTotalNumResource = GC.getMap().getNumResources(eResource);
			if (iTotalNumResource > 0)
			{
				int iOwnedNumResource = getNumResourceTotal(eResource, false, IsCSResourcesCountMonopolies()) + getResourceExport(eResource);
				if (GetPlayerTraits()->IsImportsCountTowardsMonopolies())
				{
					iOwnedNumResource += getResourceImport(eResource);
				}
				
				if (pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_LUXURY && !GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(GetID(), eResource))
				{
					int iThreshold = max(GC.getGame().GetGreatestPlayerResourceMonopolyValue(eResource), GC.getGLOBAL_RESOURCE_MONOPOLY_THRESHOLD());
					//Do we have +50% of this resource under our control?
					bool bValid = false;
					if (GC.getGame().GetGreatestPlayerResourceMonopoly(eResource) == GetID())
					{
						if (((iOwnedNumResource * 100) / iTotalNumResource) >= iThreshold)
							bValid = true;
					}
					else
					{
						if (((iOwnedNumResource * 100) / iTotalNumResource) > iThreshold)
							bValid = true;
					}
					if (bValid)
					{
						if(m_pabHasGlobalMonopoly[eResource] == false)
						{
							bGainingBonus = true;
							GC.getGame().UpdateGreatestPlayerResourceMonopoly(eResource);
						}
						SetHasGlobalMonopoly(eResource, true);						
					}
					else
					{
						if(m_pabHasGlobalMonopoly[eResource] == true)
						{
							bLosingBonus = true;
							GC.getGame().UpdateGreatestPlayerResourceMonopoly(eResource);
						}
						SetHasGlobalMonopoly(eResource, false);
					}
				}
				else if(pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)
				{
					//Do we have +25% of this resource under our control?
					if(((iOwnedNumResource * 100) / iTotalNumResource) > GC.getSTRATEGIC_RESOURCE_MONOPOLY_THRESHOLD())
					{
						if(m_pabHasStrategicMonopoly[eResource] == false)
						{
							bGainingStrategicBonus = true;
							GC.getGame().UpdateGreatestPlayerResourceMonopoly(eResource);
						}
						SetHasStrategicMonopoly(eResource, true);
					}
					else
					{
						if(m_pabHasStrategicMonopoly[eResource] == true)
						{
							bLosingStrategicBonus = true;
							GC.getGame().UpdateGreatestPlayerResourceMonopoly(eResource);
						}
						SetHasStrategicMonopoly(eResource, false);
					}
					//Do we also have 50% of this resource under our control?
					int iThreshold = max(GC.getGame().GetGreatestPlayerResourceMonopolyValue(eResource), GC.getGLOBAL_RESOURCE_MONOPOLY_THRESHOLD());

					bool bValid = false;
					if (GC.getGame().GetGreatestPlayerResourceMonopoly(eResource) == GetID())
					{
						if (((iOwnedNumResource * 100) / iTotalNumResource) >= iThreshold)
							bValid = true;
					}
					else
					{
						if (((iOwnedNumResource * 100) / iTotalNumResource) > iThreshold)
							bValid = true;
					}

					if (bValid)
					{
						if(m_pabHasGlobalMonopoly[eResource] == false)
						{
							bGainingBonus = true;
							GC.getGame().UpdateGreatestPlayerResourceMonopoly(eResource);
						}
						SetHasGlobalMonopoly(eResource, true);
						
					}
					else
					{
						if(m_pabHasGlobalMonopoly[eResource] == true)
						{
							bLosingBonus = true;
							GC.getGame().UpdateGreatestPlayerResourceMonopoly(eResource);
						}
						SetHasGlobalMonopoly(eResource, false);
					}
				}
				CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
				if(pLeague != NULL)
				{
					if (GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(GetID(), eResource))
					{
						if(m_pabHasGlobalMonopoly[eResource] == true)
						{
							bLosingBonus = true;
							GC.getGame().UpdateGreatestPlayerResourceMonopoly(eResource);
						}
						SetHasGlobalMonopoly(eResource, false);
					}
				}
			}
			else
			{
				SetHasGlobalMonopoly(eResource, false);

			}
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications && MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
			{
				const char* strResourceHelp = pkResourceInfo->GetHelp();

				// Adding Resources
				if(bGainingBonus)
				{
					Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MONOPOLY_GAINED");
					strMessage << pkResourceInfo->GetTextKey();
					strMessage << strResourceHelp;
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MONOPOLY_GAINED");
					strSummary << pkResourceInfo->GetTextKey();

					pNotifications->Add(NOTIFICATION_DISCOVERED_BONUS_RESOURCE, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, eResource);
					updateYield();
					for(int iPlayer = 0; iPlayer < MAX_PLAYERS; ++iPlayer)
					{
						//Notify human players of this, as they'll care.
						CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iPlayer);
						if(GET_TEAM(kLoopPlayer.getTeam()).isHasMet(getTeam()) && kLoopPlayer.isHuman() && (kLoopPlayer.GetID() != GetID()))
						{
							Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_PLAYER_MONOPOLY_GAINED");
							strMessage << pkResourceInfo->GetTextKey();
							strMessage << strResourceHelp;
							strMessage << getCivilizationInfo().getShortDescriptionKey();
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_OTHER_PLAYER_MONOPOLY_GAINED");
							strSummary << pkResourceInfo->GetTextKey();
							strSummary << getCivilizationInfo().getShortDescriptionKey();

							kLoopPlayer.GetNotifications()->Add(NOTIFICATION_DISCOVERED_BONUS_RESOURCE, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, eResource);
						}
					}
				}
				// Lost Resources
				else if(bLosingBonus && MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
				{
					Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_MONOPOLY_LOST");
					strMessage << pkResourceInfo->GetTextKey();
					strMessage << strResourceHelp;
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MONOPOLY_LOST");
					strSummary << pkResourceInfo->GetTextKey();

					pNotifications->Add(NOTIFICATION_DISCOVERED_BONUS_RESOURCE, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, eResource);
					updateYield();
				}
				// Adding Resources
				if(bGainingStrategicBonus && MOD_BALANCE_CORE_RESOURCE_MONOPOLIES_STRATEGIC)
				{
					Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_STRATEGIC_MONOPOLY_GAINED");
					strMessage << pkResourceInfo->GetTextKey();
					strMessage << strResourceHelp;
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_STRATEGIC_MONOPOLY_GAINED");
					strSummary << pkResourceInfo->GetTextKey();

					pNotifications->Add(NOTIFICATION_DISCOVERED_BONUS_RESOURCE, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, eResource);
					updateYield();
					for(int iPlayer = 0; iPlayer < MAX_PLAYERS; ++iPlayer)
					{
						//Notify human players of this, as they'll care.
						CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iPlayer);
						if(GET_TEAM(kLoopPlayer.getTeam()).isHasMet(getTeam()) && kLoopPlayer.isHuman() && (kLoopPlayer.GetID() != GetID()))
						{
							Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_OTHER_PLAYER_STRATEGIC_MONOPOLY_GAINED");
							strMessage << pkResourceInfo->GetTextKey();
							strMessage << strResourceHelp;
							strMessage << getCivilizationInfo().getShortDescriptionKey();
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_OTHER_PLAYER_STRATEGIC_MONOPOLY_GAINED");
							strSummary << pkResourceInfo->GetTextKey();
							strSummary << getCivilizationInfo().getShortDescriptionKey();

							kLoopPlayer.GetNotifications()->Add(NOTIFICATION_DISCOVERED_BONUS_RESOURCE, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, eResource);
						}
					}
				}
				// Lost Resources
				else if(bLosingStrategicBonus && MOD_BALANCE_CORE_RESOURCE_MONOPOLIES_STRATEGIC)
				{
					Localization::String strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_STRATEGIC_MONOPOLY_LOST");
					strMessage << pkResourceInfo->GetTextKey();
					strMessage << strResourceHelp;
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_STRATEGIC_MONOPOLY_LOST");
					strSummary << pkResourceInfo->GetTextKey();

					pNotifications->Add(NOTIFICATION_DISCOVERED_BONUS_RESOURCE, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, eResource);
					updateYield();
				}
			}
		}
	}
}
#endif
//	--------------------------------------------------------------------------------
/// Get the monopoly percentage owned for eResource.
int CvPlayer::GetMonopolyPercent(ResourceTypes eResource) const
{
	int iOwnedNumResource = getNumResourceTotal(eResource, false, IsCSResourcesCountMonopolies()) + getResourceExport(eResource);
	if (GetPlayerTraits()->IsImportsCountTowardsMonopolies())
	{
		iOwnedNumResource += getResourceImport(eResource);
	}
	int iTotalNumResource = GC.getMap().getNumResources(eResource);

	if (iTotalNumResource <= 0)
	{
		// if we own a resource, but it's not on the map at all, it is 100%
		return iOwnedNumResource > 0 ? 100 : 0;
	}

	return (iOwnedNumResource * 100) / iTotalNumResource;
}
int CvPlayer::getCityYieldModFromMonopoly(YieldTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	return m_aiCityYieldModFromMonopoly[eIndex];
}
void CvPlayer::changeCityYieldModFromMonopoly(YieldTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiCityYieldModFromMonopoly.setAt(eIndex, m_aiCityYieldModFromMonopoly[eIndex] + iChange);
	}
}

//	--------------------------------------------------------------------------------
//	--------------------------------------------------------------------------------
/// Do we get copies of each type of luxury connected by eFromPlayer?
int CvPlayer::getSiphonLuxuryCount(PlayerTypes eFromPlayer) const
{
	CvAssertMsg(eFromPlayer >= 0, "eFromPlayer is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFromPlayer < MAX_PLAYERS, "eFromPlayer is expected to be within maximum bounds (invalid Index)");

	return m_aiSiphonLuxuryCount[eFromPlayer];
}

//	--------------------------------------------------------------------------------
/// Change number of copies we get of luxury types connected by eFromPlayer
void CvPlayer::changeSiphonLuxuryCount(PlayerTypes eFromPlayer, int iChange)
{
	CvAssertMsg(eFromPlayer >= 0, "eFromPlayer is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFromPlayer < MAX_PLAYERS, "eFromPlayer is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_aiSiphonLuxuryCount.setAt(eFromPlayer, m_aiSiphonLuxuryCount[eFromPlayer] + iChange);
		CvAssert(getSiphonLuxuryCount(eFromPlayer) >= 0);

		UpdateResourcesSiphoned();
	}
}

//	--------------------------------------------------------------------------------
/// Count up the number of resources we have been siphoning from others and compare it to how many 
/// we are now allowed to siphon.  Change our resource count if there is a discrepancy.
void CvPlayer::UpdateResourcesSiphoned()
{
	FStaticVector<int, 64, true, c_eCiv5GameplayDLL> vDeltas;
	
	// Subtract all currently siphoned resources
	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
		vDeltas.push_back(-1 * getResourceSiphoned(eResourceLoop));
	}

	// Add back in valid siphoned resources
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes ePlayerLoop = (PlayerTypes) iPlayerLoop;
		int iSiphonLuxuryCount = getSiphonLuxuryCount(ePlayerLoop);
		if (iSiphonLuxuryCount > 0)
		{
			for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
			{
				ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
				CvResourceInfo* pInfo = GC.getResourceInfo(eResourceLoop);
				// Is it a luxury?
				if (pInfo && pInfo->getResourceUsage() == RESOURCEUSAGE_LUXURY)
				{
					// Do they have at least one of this type, even if it was exported?
					if (GET_PLAYER(ePlayerLoop).getNumResourceTotal(eResourceLoop, /*bIncludeImport*/ false) > 0 || GET_PLAYER(ePlayerLoop).getResourceExport(eResourceLoop) > 0)
					{
						vDeltas[eResourceLoop] += iSiphonLuxuryCount;
					}
				}
			}
		}
	}

	// Propagate any actual changes
	for (uint i = 0; i < vDeltas.size(); i++)
	{
		if (vDeltas[i] != 0)
		{
			ResourceTypes eResource = (ResourceTypes) i;
			changeResourceSiphoned(eResource, vDeltas[i]);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Are we over our resource limit? If so, give out a notification
void CvPlayer::DoTestOverResourceNotification(ResourceTypes eIndex)
{
#if defined(MOD_BALANCE_CORE)
	if((getNumResourceAvailable(eIndex, true) < 0) && (getNumResourceUsed(eIndex) > 0))
#else
	if(getNumResourceAvailable(eIndex, true) < 0)
#endif
	{
#if defined(MOD_BALANCE_CORE)
		//Flip the amount available as our drain pool - helper for cities to prevent empire wide drop.
		setResourceOverValue(eIndex, (getNumResourceAvailable(eIndex, true) * -1));
		int iUnitLoop;
		CvUnit* pLoopUnit = NULL;

		// Test
		bool bTest = false;
		for(pLoopUnit = firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iUnitLoop))
		{
			if(!pLoopUnit)
			{
				continue;
			}
			CvUnitEntry* pkUnitInfo = GC.getUnitInfo(pLoopUnit->getUnitType());
			if(pkUnitInfo)
			{
				if(pkUnitInfo->GetResourceQuantityRequirement(eIndex) > 0)
				{
					bTest = true;
					break;
				}
			}
		}
		if(!bTest)
			return;
#endif
		const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eIndex);
		if(pkResourceInfo != NULL && pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)
		{
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_OVER_RESOURCE_LIMIT");
				strText << pkResourceInfo->GetTextKey();
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_OVER_RESOURCE_LIMIT");
				strSummary << pkResourceInfo->GetTextKey();
#if defined(MOD_BALANCE_CORE)
				pNotifications->Add(NOTIFICATION_DISCOVERED_STRATEGIC_RESOURCE, strText.toUTF8(), strSummary.toUTF8(), -1, -1, eIndex);
#else
				pNotifications->Add(NOTIFICATION_DEMAND_RESOURCE, strText.toUTF8(), strSummary.toUTF8(), -1, -1, eIndex);
#endif
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Is our collection of Strategic Resources modified?
int CvPlayer::GetStrategicResourceMod() const
{
	return m_iStrategicResourceMod;
}

//	--------------------------------------------------------------------------------
/// Is our collection of Strategic Resources modified?
void CvPlayer::ChangeStrategicResourceMod(int iChange)
{
	m_iStrategicResourceMod += iChange;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNumResourceAvailable(ResourceTypes eIndex, bool bIncludeImport) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return getNumResourceTotal(eIndex, bIncludeImport) - getNumResourceUsed(eIndex);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getResourceGiftedToMinors(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiResourceGiftedToMinors[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceGiftedToMinors(ResourceTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiResourceGiftedToMinors.setAt(eIndex, m_paiResourceGiftedToMinors[eIndex] + iChange);
		CvAssert(getResourceGiftedToMinors(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getResourceExport(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiResourceExport[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceExport(ResourceTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiResourceExport.setAt(eIndex, m_paiResourceExport[eIndex] + iChange);
		CvAssert(getResourceExport(eIndex) >= 0);

		CalculateNetHappiness();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getResourceImport(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiResourceImport[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceImport(ResourceTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiResourceImport.setAt(eIndex, m_paiResourceImport[eIndex] + iChange);
		CvAssert(getResourceImport(eIndex) >= 0);

		CalculateNetHappiness();

		if (GetPlayerTraits()->IsImportsCountTowardsMonopolies())
		{
			CheckForMonopoly(eIndex);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getResourceFromMinors(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	int iNumResourceFromMinors = m_paiResourceFromMinors[eIndex];

	// Resource bonus doubles quantity of Resources from Minors (Policies, etc.)
	if(IsMinorResourceBonus())
	{
		iNumResourceFromMinors *= /*200*/ GC.getMINOR_POLICY_RESOURCE_MULTIPLIER();
		iNumResourceFromMinors /= 100;
	}

	return iNumResourceFromMinors;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceFromMinors(ResourceTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiResourceFromMinors.setAt(eIndex, m_paiResourceFromMinors[eIndex] + iChange);
		CvAssert(getResourceFromMinors(eIndex) >= 0);

		CalculateNetHappiness();

		if (IsCSResourcesCountMonopolies())
			CheckForMonopoly(eIndex);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getResourceSiphoned(ResourceTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	int iNumResourceSiphoned = m_paiResourcesSiphoned[eIndex];

	return iNumResourceSiphoned;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceSiphoned(ResourceTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_paiResourcesSiphoned.setAt(eIndex, m_paiResourcesSiphoned[eIndex] + iChange);
		CvAssert(getResourceSiphoned(eIndex) >= 0);

		CalculateNetHappiness();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getResourceInOwnedPlots(ResourceTypes eIndex)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	int iCount = 0;

	// go through all the plots the player has under their control
	for (PlotIndexContainer::const_iterator it = m_aiPlots.begin(); it != m_aiPlots.end(); ++it)
	{
		CvPlot* pPlot = GC.getMap().plotByIndex(*it);
		if (pPlot && pPlot->getResourceType(getTeam()) == eIndex)
		{
			iCount++;
		}
	}

	return iCount;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getTotalImprovementsBuilt() const
{
	return m_iTotalImprovementsBuilt;
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeTotalImprovementsBuilt(int iChange)
{
	m_iTotalImprovementsBuilt = (m_iTotalImprovementsBuilt + iChange);
	CvAssert(getTotalImprovementsBuilt() >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getImprovementCount(ImprovementTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumImprovementInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiImprovementCount[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeImprovementCount(ImprovementTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumImprovementInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	m_paiImprovementCount.setAt(eIndex, m_paiImprovementCount[eIndex] + iChange);
	CvAssert(getImprovementCount(eIndex) >= 0);
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvPlayer::getTotalImprovementsBuilt(ImprovementTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumImprovementInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiTotalImprovementsBuilt[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeTotalImprovementsBuilt(ImprovementTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumImprovementInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	m_paiTotalImprovementsBuilt.setAt(eIndex, m_paiTotalImprovementsBuilt[eIndex] + iChange);
	CvAssert(getTotalImprovementsBuilt(eIndex) >= 0);
}
#endif


//	--------------------------------------------------------------------------------
int CvPlayer::getGreatPersonImprovementCount()
{
	int iCount = 0;
	for (int i = 0; i < GC.getNumImprovementInfos(); i++)
	{
		ImprovementTypes e = (ImprovementTypes)i;
		CvImprovementEntry* pInfo = GC.getImprovementInfo(e);
		if (pInfo && pInfo->IsCreatedByGreatPerson())
		{
			iCount += getImprovementCount(e);
		}
	}
	return iCount;
}


//	--------------------------------------------------------------------------------
int CvPlayer::getFreeBuildingCount(BuildingTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiFreeBuildingCount[eIndex];
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isBuildingFree(BuildingTypes eIndex)	const
{
	return (getFreeBuildingCount(eIndex) > 0);
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeFreeBuildingCount(BuildingTypes eIndex, int iChange)
{
	CvCity* pLoopCity;
	int iOldFreeBuildingCount;
	int iLoop;

	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		iOldFreeBuildingCount = getFreeBuildingCount(eIndex);

		m_paiFreeBuildingCount.setAt(eIndex, m_paiFreeBuildingCount[eIndex] + iChange);
		CvAssert(getFreeBuildingCount(eIndex) >= 0);

		if(iOldFreeBuildingCount == 0)
		{
			CvAssertMsg(getFreeBuildingCount(eIndex) > 0, "getFreeBuildingCount(eIndex) is expected to be greater than 0");

			for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				pLoopCity->GetCityBuildings()->SetNumFreeBuilding(eIndex, 1);
			}
		}
		else if(getFreeBuildingCount(eIndex) == 0)
		{
			CvAssertMsg(iOldFreeBuildingCount > 0, "iOldFreeBuildingCount is expected to be greater than 0");

			for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				pLoopCity->GetCityBuildings()->SetNumFreeBuilding(eIndex, 0);
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Is ePromotion a free promotion?
int CvPlayer::GetFreePromotionCount(PromotionTypes ePromotion) const
{
	CvAssertMsg(ePromotion >= 0, "ePromotion is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePromotion < GC.getNumPromotionInfos(), "ePromotion is expected to be within maximum bounds (invalid Index)");
	return m_paiFreePromotionCount[ePromotion];
}

//	--------------------------------------------------------------------------------
/// Is ePromotion a free promotion?
bool CvPlayer::IsFreePromotion(PromotionTypes ePromotion)	const
{
	return (GetFreePromotionCount(ePromotion) > 0);
}

//	--------------------------------------------------------------------------------
/// Is ePromotion a free promotion?
void CvPlayer::ChangeFreePromotionCount(PromotionTypes ePromotion, int iChange)
{
	CvAssertMsg(ePromotion >= 0, "ePromotion is expected to be non-negative (invalid Index)");
	CvAssertMsg(ePromotion < GC.getNumPromotionInfos(), "ePromotion is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		bool bWasFree = IsFreePromotion(ePromotion);

		m_paiFreePromotionCount.setAt(ePromotion, m_paiFreePromotionCount[ePromotion] + iChange);

		CvAssert(GetFreePromotionCount(ePromotion) >= 0);

		// This promotion is now set to be free, but wasn't before we called this function
		if(IsFreePromotion(ePromotion) && !bWasFree)
		{
			// Loop through Units
			CvUnit* pLoopUnit;

			int iLoop;
			for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
			{
				// Valid Promotion for this Unit?
				if(::IsPromotionValidForUnitCombatType(ePromotion, pLoopUnit->getUnitType()))
				{
					pLoopUnit->setHasPromotion(ePromotion, true);
				}

				else if(::IsPromotionValidForCivilianUnitType(ePromotion, pLoopUnit->getUnitType()))
				{
					pLoopUnit->setHasPromotion(ePromotion, true);
				}
			}
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getUnitCombatProductionModifiers(UnitCombatTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitCombatClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiUnitCombatProductionModifiers[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeUnitCombatProductionModifiers(UnitCombatTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitCombatClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiUnitCombatProductionModifiers.setAt(eIndex, m_paiUnitCombatProductionModifiers[eIndex] + iChange);
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getUnitCombatFreeExperiences(UnitCombatTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitCombatClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiUnitCombatFreeExperiences[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeUnitCombatFreeExperiences(UnitCombatTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitCombatClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiUnitCombatFreeExperiences.setAt(eIndex, m_paiUnitCombatFreeExperiences[eIndex] + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getUnitClassCount(UnitClassTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiUnitClassCount[eIndex];
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isUnitClassMaxedOut(UnitClassTypes eIndex, int iExtra) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eIndex);
	if(pkUnitClassInfo == NULL)
	{
		return false;
	}

#if defined(MOD_BALANCE_CORE)
	if(isUnitLimitPerCity(eIndex))
	{
		CvAssertMsg(getUnitClassCount(eIndex) <= (getNumCities() * pkUnitClassInfo->getUnitInstancePerCity()), "getUnitInstancePerCity is expected to be less than maximum bound of UnitInstancePerCity (invalid index)");
		return ((getUnitClassCount(eIndex) + iExtra) >= (getNumCities() * pkUnitClassInfo->getUnitInstancePerCity()));
	}
	else if(isNationalUnitClass(eIndex))
	{
		CvAssertMsg(getUnitClassCount(eIndex) <= pkUnitClassInfo->getMaxPlayerInstances(), "getUnitClassCount is expected to be less than maximum bound of MaxPlayerInstances (invalid index)");
		return ((getUnitClassCount(eIndex) + iExtra) >= pkUnitClassInfo->getMaxPlayerInstances());
	}
	else
	{
		return false;
	}
#else
	if(!isNationalUnitClass(eIndex))
	{
		return false;
	}

	CvAssertMsg(getUnitClassCount(eIndex) <= pkUnitClassInfo->getMaxPlayerInstances(), "getUnitClassCount is expected to be less than maximum bound of MaxPlayerInstances (invalid index)");

	return ((getUnitClassCount(eIndex) + iExtra) >= pkUnitClassInfo->getMaxPlayerInstances());
#endif
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeUnitClassCount(UnitClassTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	m_paiUnitClassCount.setAt(eIndex, m_paiUnitClassCount[eIndex] + iChange);
	CvAssert(getUnitClassCount(eIndex) >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getUnitClassMaking(UnitClassTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiUnitClassMaking[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeUnitClassMaking(UnitClassTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumUnitClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiUnitClassMaking.setAt(eIndex, m_paiUnitClassMaking[eIndex] + iChange);
		CvAssert(getUnitClassMaking(eIndex) >= 0);

		const CvCivilizationInfo& playerCivilizationInfo = getCivilizationInfo();
		UnitTypes eUnit = static_cast<UnitTypes>(playerCivilizationInfo.getCivilizationUnits(eIndex));
		CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
		if(pkUnitInfo)
		{
			// Builder Limit
			if(pkUnitInfo->GetWorkRate() > 0 && pkUnitInfo->GetDomainType() == DOMAIN_LAND)
			{
				ChangeNumBuilders(iChange);
			}

			// Update the amount of a Resource used up by Units in Production
			for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
			{
				ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);
				CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
				if(pkResource)
				{
					if(pkUnitInfo->GetResourceQuantityRequirement(iResourceLoop) > 0)
					{
						changeNumResourceUsed(eResource, iChange * pkUnitInfo->GetResourceQuantityRequirement(iResourceLoop));
					}
				}
			}

			if(GetID() == GC.getGame().getActivePlayer())
			{
				GC.GetEngineUserInterface()->setDirty(Help_DIRTY_BIT, true);
			}
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getUnitClassCountPlusMaking(UnitClassTypes eIndex) const
{
	return (getUnitClassCount(eIndex) + getUnitClassMaking(eIndex));
}


//	--------------------------------------------------------------------------------
int CvPlayer::getBuildingClassCount(BuildingClassTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiBuildingClassCount[eIndex];
}


//	--------------------------------------------------------------------------------
bool CvPlayer::isBuildingClassMaxedOut(BuildingClassTypes eIndex, int iExtra) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eIndex);
	if(pkBuildingClassInfo == NULL)
	{
		CvAssertMsg(false, "This should never happen...");
		return false;
	}

	if(!isNationalWonderClass(*pkBuildingClassInfo))
	{
		return false;
	}

	CvAssertMsg(getBuildingClassCount(eIndex) <= (pkBuildingClassInfo->getMaxPlayerInstances() + pkBuildingClassInfo->getExtraPlayerInstances()), "BuildingClassCount is expected to be less than or match the number of max player instances plus extra player instances");

	return ((getBuildingClassCount(eIndex) + iExtra) >= (pkBuildingClassInfo->getMaxPlayerInstances() + pkBuildingClassInfo->getExtraPlayerInstances()));
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeBuildingClassCount(BuildingClassTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	m_paiBuildingClassCount.setAt(eIndex, m_paiBuildingClassCount[eIndex] + iChange);
	CvAssert(getBuildingClassCount(eIndex) >= 0);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getBuildingClassMaking(BuildingClassTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiBuildingClassMaking[eIndex];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeBuildingClassMaking(BuildingClassTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiBuildingClassMaking.setAt(eIndex, m_paiBuildingClassMaking[eIndex] + iChange);
		CvAssert(getBuildingClassMaking(eIndex) >= 0);

		const BuildingTypes eBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eIndex);
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
		if(pkBuildingInfo)
		{
			// Update the amount of a Resource used up by Buildings in Production
			for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
			{
				const ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);
				CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);
				if(pkResourceInfo)
				{
					if(pkBuildingInfo->GetResourceQuantityRequirement(iResourceLoop) > 0)
					{
						changeNumResourceUsed(eResource, iChange * pkBuildingInfo->GetResourceQuantityRequirement(iResourceLoop));
					}
				}

			}
		}


		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Help_DIRTY_BIT, true);
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getBuildingClassCountPlusMaking(BuildingClassTypes eIndex) const
{
	return (getBuildingClassCount(eIndex) + getBuildingClassMaking(eIndex));
}


//	--------------------------------------------------------------------------------
// The following two functions are only used to keep track of how many Projects are in progress so we know what each player's Resource situation is
// Check out CvTeam::getProjectMaking() for something used more
int CvPlayer::getProjectMaking(ProjectTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiProjectMaking[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeProjectMaking(ProjectTypes eIndex, int iChange, CvCity* pCity)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_paiProjectMaking.setAt(eIndex, m_paiProjectMaking[eIndex] + iChange);
		CvAssert(getProjectMaking(eIndex) >= 0);

		// Update the amount of a Resource used up by Projects in Production
		for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
		{
			if(GC.getProjectInfo(eIndex)->GetResourceQuantityRequirement(iResourceLoop) > 0)
			{
				changeNumResourceUsed((ResourceTypes) iResourceLoop, iChange * GC.getProjectInfo(eIndex)->GetResourceQuantityRequirement(iResourceLoop));
			}
		}

		if (iChange > 0)
		{
			ProjectTypes eUtopia = (ProjectTypes)GC.getInfoTypeForString("PROJECT_UTOPIA_PROJECT", true);
			if (eUtopia == eIndex)
			{
				int iNumTurns = pCity != NULL ? pCity->getProductionTurnsLeft() : -1;
				PlayerTypes ePlayer;
				for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
				{
					ePlayer = (PlayerTypes)iPlayerLoop;

					if (GC.getGame().getActivePlayer() != ePlayer)
					{
						CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();
						if (pNotifications)
						{
							Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_PROJECT_STARTED");
							strText << getNameKey();
							strText << GC.getProjectInfo(eIndex)->GetDescription();
							strText << iNumTurns;
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_PROJECT_STARTED_S");
							strSummary << GC.getProjectInfo(eIndex)->GetDescription();
							pNotifications->Add(NOTIFICATION_CULTURE_VICTORY_WITHIN_ONE, strText.toUTF8(), strSummary.toUTF8(), -1, -1, ePlayer);
						}
					}
				}
			}
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getHurryCount(HurryTypes eIndex) const
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumHurryInfos());
	return m_paiHurryCount[eIndex];
}


//	--------------------------------------------------------------------------------
// Do we have access to this Hurry type?
bool CvPlayer::IsHasAccessToHurry(HurryTypes eIndex) const
{
	return (getHurryCount(eIndex) > 0);
}

//	--------------------------------------------------------------------------------
/// Can we use this Hurry RIGHT NOW?
bool CvPlayer::IsCanHurry(HurryTypes eIndex) const
{
	CvHurryInfo* pkHurryInfo = GC.getHurryInfo(eIndex);
	if(pkHurryInfo == NULL)
		return false;

	int iCost = GetHurryGoldCost(eIndex);

	// Can we pay for this Hurry?
	if(iCost < 0 || GetTreasury()->GetGold() < iCost)
	{
		return false;
	}

	// Science Rushing
	if(pkHurryInfo->getGoldPerBeaker() > 0)
	{
		return true;
	}

	// Culture Rushing
	if(pkHurryInfo->getGoldPerCulture() > 0)
	{
		// If we already have enough Culture for the next Policy, there's nothing to rush!
		if(getNextPolicyCost() > getJONSCulture())
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
/// How much Gold does it cost us to Hurry? (whatever the applicable item is)
int CvPlayer::GetHurryGoldCost(HurryTypes eHurry) const
{
	int iGold = -1;

	CvHurryInfo* pkHurryInfo = GC.getHurryInfo(eHurry);
	if(pkHurryInfo == NULL)
	{
		//This should never happen.
		return -1;
	}

	// Science Rushing
	if(pkHurryInfo->getGoldPerBeaker() > 0)
	{
		TechTypes eTech = GetPlayerTechs()->GetCurrentResearch();

		if(eTech != NO_TECH)
		{
			int iTotalCost = GET_TEAM(getTeam()).GetTeamTechs()->GetResearchCost(eTech);
			int iResearchLeft = GET_TEAM(getTeam()).GetTeamTechs()->GetResearchLeft(eTech);

			// Cost of Gold rushing based on the ORIGINAL Research price
			int iGoldForFullPrice = iTotalCost * pkHurryInfo->getGoldPerBeaker();
			iGoldForFullPrice = (int) pow((double) iGoldForFullPrice, (double) /*1.10f*/ GC.getHURRY_GOLD_TECH_EXPONENT());

			// Figure out the actual cost by comparing what's left to the original Research cost, and multiplying that by the amount to Gold rush the original cost
			iGold = (iGoldForFullPrice * iResearchLeft / iTotalCost);
		}
	}

	// Culture Rushing
	if(pkHurryInfo->getGoldPerCulture() > 0)
	{
		int iCurrentPolicyCost = getNextPolicyCost();

		if(iCurrentPolicyCost > 0)
		{
			int iCultureLeft = iCurrentPolicyCost - getJONSCulture();

			// Cost of Gold rushing based on the ORIGINAL Culture price
			int iGoldForFullPrice = iCurrentPolicyCost * pkHurryInfo->getGoldPerCulture();
			iGoldForFullPrice = (int) pow((double) iGoldForFullPrice, (double) /*1.10f*/ GC.getHURRY_GOLD_CULTURE_EXPONENT());

			// Figure out the actual cost by comparing what's left to the original Culture cost, and multiplying that by the amount to Gold rush the original cost
			iGold = (iGoldForFullPrice * iCultureLeft / iCurrentPolicyCost);
		}
	}

	return iGold;
}

//	--------------------------------------------------------------------------------
/// Hurry something!
void CvPlayer::DoHurry(HurryTypes eIndex)
{
	CvHurryInfo* pkHurryInfo = GC.getHurryInfo(eIndex);
	if(pkHurryInfo)
	{
		if(IsCanHurry(eIndex))
		{
			int iGoldCost = GetHurryGoldCost(eIndex);
			GetTreasury()->ChangeGold(-iGoldCost);

			// Science Rushing
			if(pkHurryInfo->getGoldPerBeaker() > 0)
			{
				TechTypes eTech = GetPlayerTechs()->GetCurrentResearch();

				GET_TEAM(getTeam()).setHasTech(eTech, true, GetID(), false, false);
			}

			// Culture Rushing
			if(pkHurryInfo->getGoldPerCulture() > 0)
			{
				setJONSCulture(getNextPolicyCost());
			}
		}
	}
}


//	--------------------------------------------------------------------------------
bool CvPlayer::canPopRush()
{
	return (m_iPopRushHurryCount > 0);
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeHurryCount(HurryTypes eIndex, int iChange)
{
	CvAssert(eIndex >= 0);
	CvAssert(eIndex < GC.getNumHurryInfos());

	int oldHurryCount = m_paiHurryCount[eIndex];
	m_paiHurryCount.setAt(eIndex, m_paiHurryCount[eIndex] + iChange);
	CvAssert(getHurryCount(eIndex) >= 0);

	CvHurryInfo* pkHurryInfo = GC.getHurryInfo(eIndex);
	if(pkHurryInfo == NULL)
		return;

	// if we just went from 0 to 1 (or the reverse)
	if((oldHurryCount > 0) != (m_paiHurryCount[eIndex] > 0))
	{
		// does this hurry reduce population?
		if(pkHurryInfo->getProductionPerPopulation() > 0)
		{
			m_iPopRushHurryCount += iChange;
			CvAssert(m_iPopRushHurryCount >= 0);
		}
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getHurryModifier(HurryTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumHurryInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiHurryModifier[eIndex];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeHurryModifier(HurryTypes eIndex, int iChange)
{
	if(iChange != 0)
	{
		CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
		CvAssertMsg(eIndex < GC.getNumHurryInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
		m_paiHurryModifier.setAt(eIndex, m_paiHurryModifier[eIndex] + iChange);
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::setResearchingTech(TechTypes eIndex, bool bNewValue)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(m_pPlayerTechs->IsResearchingTech(eIndex) != bNewValue)
	{
		GetPlayerTechs()->SetResearchingTech(eIndex, bNewValue);

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Popup_DIRTY_BIT, true); // to check whether we still need the tech chooser popup
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getSpecialistExtraYield(SpecialistTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 expected to be >= 0");
	CvAssertMsg(eIndex1 < GC.getNumSpecialistInfos(), "eIndex1 expected to be < GC.getNumSpecialistInfos()");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 expected to be >= 0");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 expected to be < NUM_YIELD_TYPES");
	return m_ppaaiSpecialistExtraYield[eIndex1][eIndex2];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeSpecialistExtraYield(SpecialistTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 expected to be >= 0");
	CvAssertMsg(eIndex1 < GC.getNumSpecialistInfos(), "eIndex1 expected to be < GC.getNumSpecialistInfos()");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 expected to be >= 0");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 expected to be < NUM_YIELD_TYPES");

	if(iChange != 0)
	{
		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppaaiSpecialistExtraYield[eIndex1];
		yields[eIndex2] = (m_ppaaiSpecialistExtraYield[eIndex1][eIndex2] + iChange);
		m_ppaaiSpecialistExtraYield.setAt(eIndex1, yields);
		CvAssert(getSpecialistExtraYield(eIndex1, eIndex2) >= 0);

		updateExtraSpecialistYield();
	}
}


#if defined(MOD_API_UNIFIED_YIELDS) && defined(MOD_API_PLOT_YIELDS)
//	--------------------------------------------------------------------------------
int CvPlayer::getPlotYieldChange(PlotTypes eIndex1, YieldTypes eIndex2) const
{
	if (MOD_API_PLOT_YIELDS) {
		CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
		CvAssertMsg(eIndex1 < GC.getNumPlotInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
		CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
		CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
		return m_ppiPlotYieldChange[eIndex1][eIndex2];
	} else {
		return 0;
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::changePlotYieldChange(PlotTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	if (MOD_API_PLOT_YIELDS) {
		CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
		CvAssertMsg(eIndex1 < GC.getNumPlotInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
		CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
		CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

		if(iChange != 0)
		{
			CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

			Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiPlotYieldChange[eIndex1];
			yields[eIndex2] = (m_ppiPlotYieldChange[eIndex1][eIndex2] + iChange);
			m_ppiPlotYieldChange[eIndex1] = yields;
			CvAssert(getPlotYieldChange(eIndex1, eIndex2) >= 0);

			updateYield();
		}
	}
}
#endif

#if defined(MOD_API_UNIFIED_YIELDS)
//	--------------------------------------------------------------------------------
int CvPlayer::getFeatureYieldChange(FeatureTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiFeatureYieldChange[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeFeatureYieldChange(FeatureTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiFeatureYieldChange[eIndex1];
		yields[eIndex2] = (m_ppiFeatureYieldChange[eIndex1][eIndex2] + iChange);
		m_ppiFeatureYieldChange[eIndex1] = yields;
		CvAssert(getFeatureYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getCityYieldFromUnimprovedFeature(FeatureTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiCityYieldFromUnimprovedFeature[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeCityYieldFromUnimprovedFeature(FeatureTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number.");

		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiCityYieldFromUnimprovedFeature[eIndex1];
		yields[eIndex2] = (m_ppiCityYieldFromUnimprovedFeature[eIndex1][eIndex2] + iChange);
		m_ppiCityYieldFromUnimprovedFeature[eIndex1] = yields;
		CvAssert(getCityYieldFromUnimprovedFeature(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getUnimprovedFeatureYieldChange(FeatureTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiUnimprovedFeatureYieldChange[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeUnimprovedFeatureYieldChange(FeatureTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumFeatureInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number.");

		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiUnimprovedFeatureYieldChange[eIndex1];
		yields[eIndex2] = (m_ppiUnimprovedFeatureYieldChange[eIndex1][eIndex2] + iChange);
		m_ppiUnimprovedFeatureYieldChange[eIndex1] = yields;
		CvAssert(getUnimprovedFeatureYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getResourceYieldChange(ResourceTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumResourceInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiResourceYieldChange[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeResourceYieldChange(ResourceTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumResourceInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiResourceYieldChange[eIndex1];
		yields[eIndex2] = (m_ppiResourceYieldChange[eIndex1][eIndex2] + iChange);
		m_ppiResourceYieldChange[eIndex1] = yields;
		CvAssert(getResourceYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getTerrainYieldChange(TerrainTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumTerrainInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiTerrainYieldChange[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeTerrainYieldChange(TerrainTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumTerrainInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiTerrainYieldChange[eIndex1];
		yields[eIndex2] = (m_ppiTerrainYieldChange[eIndex1][eIndex2] + iChange);
		m_ppiTerrainYieldChange[eIndex1] = yields;
		CvAssert(getTerrainYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getTradeRouteYieldChange(DomainTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < NUM_DOMAIN_TYPES, "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiTradeRouteYieldChange[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeTradeRouteYieldChange(DomainTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < NUM_DOMAIN_TYPES, "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiTradeRouteYieldChange[eIndex1];
		yields[eIndex2] = (m_ppiTradeRouteYieldChange[eIndex1][eIndex2] + iChange);
		m_ppiTradeRouteYieldChange[eIndex1] = yields;
		CvAssert(getTradeRouteYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getSpecialistYieldChange(SpecialistTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumSpecialistInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiSpecialistYieldChange[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeSpecialistYieldChange(SpecialistTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumSpecialistInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiSpecialistYieldChange[eIndex1];
		yields[eIndex2] = (m_ppiSpecialistYieldChange[eIndex1][eIndex2] + iChange);
		m_ppiSpecialistYieldChange[eIndex1] = yields;
		CvAssert(getSpecialistYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGreatPersonExpendedYield(GreatPersonTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumGreatPersonInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiGreatPersonExpendedYield[eIndex1][eIndex2];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGreatPersonExpendedYield(GreatPersonTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumGreatPersonInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiGreatPersonExpendedYield[eIndex1];
		yields[eIndex2] = (m_ppiGreatPersonExpendedYield[eIndex1][eIndex2] + iChange);
		m_ppiGreatPersonExpendedYield[eIndex1] = yields;
		CvAssert(getGreatPersonExpendedYield(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGoldenAgeGreatPersonRateModifier(GreatPersonTypes eGreatPerson) const
{
	CvAssertMsg(eGreatPerson >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eGreatPerson < GC.getNumGreatPersonInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piGoldenAgeGreatPersonRateModifier[eGreatPerson];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeGoldenAgeGreatPersonRateModifier(GreatPersonTypes eGreatPerson, int iChange)
{
	CvAssertMsg(eGreatPerson >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eGreatPerson < GC.getNumGreatPersonInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_piGoldenAgeGreatPersonRateModifier[eGreatPerson] += iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetYieldFromKills(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piYieldFromKills[eYield];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromKills(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_piYieldFromKills[eYield] += iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetYieldFromBarbarianKills(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piYieldFromBarbarianKills[eYield];
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeYieldFromBarbarianKills(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_piYieldFromBarbarianKills[eYield] += iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetYieldChangeTradeRoute(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piYieldChangeTradeRoute[eYield];
}

void CvPlayer::ChangeYieldChangeTradeRoute(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_piYieldChangeTradeRoute[eYield] += iChange;

		updateYield();
	}
}

int CvPlayer::GetYieldChangesNaturalWonder(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piYieldChangesNaturalWonder[eYield];
}

void CvPlayer::ChangeYieldChangesNaturalWonder(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_piYieldChangesNaturalWonder[eYield] += iChange;

		updateYield();
	}
}

int CvPlayer::GetYieldChangeWorldWonder(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piYieldChangeWorldWonder[eYield];
}

void CvPlayer::ChangeYieldChangeWorldWonder(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_piYieldChangeWorldWonder[eYield] += iChange;

		updateYield();
	}
}

int CvPlayer::GetYieldFromMinorDemand(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piYieldFromMinorDemand[eYield];
}

void CvPlayer::ChangeYieldFromMinorDemand(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		m_piYieldFromMinorDemand[eYield] += iChange;
	}
}

int CvPlayer::GetYieldFromWLTKD(YieldTypes eYield) const
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_piYieldFromWLTKD[eYield];
}

void CvPlayer::ChangeYieldFromWLTKD(YieldTypes eYield, int iChange)
{
	CvAssertMsg(eYield >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");

	if (iChange != 0)
	{
		m_piYieldFromWLTKD[eYield] += iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getBuildingClassYieldChange(BuildingClassTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumBuildingClassInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppiBuildingClassYieldChange[eIndex1][eIndex2];
}

#if defined(MOD_BALANCE_CORE)
// (Corp) Note to future modders: if you think this works as you expect, you're wrong. just ignore it. Use ::GetBuildingClassYieldChange() instead (note the capital), or fix this so it's functional.
// grrrr....
#endif
//	--------------------------------------------------------------------------------
void CvPlayer::changeBuildingClassYieldChange(BuildingClassTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumBuildingClassInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiBuildingClassYieldChange[eIndex1];
		yields[eIndex2] = (m_ppiBuildingClassYieldChange[eIndex1][eIndex2] + iChange);
		m_ppiBuildingClassYieldChange.setAt(eIndex1, yields);
		CvAssert(getBuildingClassYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getImprovementYieldChange(ImprovementTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumImprovementInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return m_ppaaiImprovementYieldChange[eIndex1][eIndex2];
}


//	--------------------------------------------------------------------------------
void CvPlayer::changeImprovementYieldChange(ImprovementTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumImprovementInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	if(iChange != 0)
	{
		CvAssertMsg(iChange > -50 && iChange < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");

		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppaaiImprovementYieldChange[eIndex1];
		yields[eIndex2] = (m_ppaaiImprovementYieldChange[eIndex1][eIndex2] + iChange);
		m_ppaaiImprovementYieldChange.setAt(eIndex1, yields);
		CvAssert(getImprovementYieldChange(eIndex1, eIndex2) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::removeFromArmy(int iArmyID, int iID)
{
	bool bRemoved = false;
	CvArmyAI* pThisArmyAI = getArmyAI(iArmyID);
	if(pThisArmyAI)
	{
		bRemoved = pThisArmyAI->RemoveUnit(iID);
	}

	return bRemoved;
}


//	---------------------------------------------------------------------------
bool CvPlayer::removeFromArmy(int iID)
{
	CvArmyAI* pLoopArmyAI;
	int iLoop;
	bool bRemoved = false;

	// for all the army AIs
	for(pLoopArmyAI = firstArmyAI(&iLoop); pLoopArmyAI != NULL && !bRemoved; pLoopArmyAI = nextArmyAI(&iLoop))
	{
		// attempt to remove from this army
		bRemoved = removeFromArmy(pLoopArmyAI->GetID(), iID);
	}
	return bRemoved;
}

//	---------------------------------------------------------------------------
//	Finds the path length from this tech type to one you already know (FIXED)
//	This one doesn't count technologies multiple times during recursive calls!
//	A temporary buffer is used to mark techs already visited, so they can be 
//	counted only once when the recursive calls end.
int CvPlayer::findPathLengthNew(TechTypes eTech, int pTechs[]) const
{
	CvAssertMsg(eTech != NO_TECH, "Tech is not assigned a valid value");
	int i;

	// if buffer is empty then initialize, start recursive calls and count techs at the end
	if (pTechs == NULL)
	{
		int pTechBuffer[200]; // ideally need to count all techs and allocate a dynamic array
		std::fill(pTechBuffer, pTechBuffer+200, 0);
		(void) findPathLengthNew(eTech, pTechBuffer);
		int iNumTechs = 0;
		for (i=0; i<200; i++) iNumTechs += pTechBuffer[i]; // count all techs that we visited during recursive calls
		return iNumTechs;
	}

	// if buffer is not empty then mark the tech as required and analyze prerequisite techs
	CvTechEntry* pkTechInfo = GC.getTechInfo(eTech);
	if(pkTechInfo == NULL)
		return 0;
	if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech(eTech)) // We have this tech
		return 0;
	
	// this tech is not yet FULLY researched, so mark it; always 1, so they won't be counted multiple times!
	pTechs[(int) eTech] = 1;
	//	Cycle through the AND paths and mark their techs
	for(i = 0; i < GC.getNUM_AND_TECH_PREREQS(); i++)
	{
		TechTypes ePreReq = (TechTypes)pkTechInfo->GetPrereqAndTechs(i);
		if(ePreReq != NO_TECH)
			(void) findPathLengthNew(ePreReq, pTechs);
	}

	// OR paths omitted as of now, not used

	return 0;
}

//	---------------------------------------------------------------------------
//	Finds the path length from this tech type to one you already know
//	If bCost is false, then it returns number of techs that need to be researched to acquire eTech
//	If bCost is true, then it returns the cost of a currently researched tech
int CvPlayer::findPathLength(TechTypes eTech, bool bCost) const
{
	int i;
	int iNumSteps = 0;
	int iShortestPath = 0;
	int iPathLength = 0;
	TechTypes ePreReq;
	TechTypes eShortestOr;

	CvTechEntry* pkTechInfo = GC.getTechInfo(eTech);
	if(pkTechInfo == NULL)
		return 0;

	if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech(eTech)) // We have this tech
		return 0;

	/* WRONG - MULTIPLE COUNTS
	//	Cycle through the and paths and add up their tech lengths
	for(i = 0; i < GC.getNUM_AND_TECH_PREREQS(); i++)
	{
		ePreReq = (TechTypes)pkTechInfo->GetPrereqAndTechs(i);

		if(ePreReq != NO_TECH)
		{
			iPathLength += findPathLength(ePreReq, bCost);
		}
	}
	*/
	iPathLength = findPathLengthNew(eTech, NULL);

	eShortestOr = NO_TECH;
	iShortestPath = INT_MAX;
	//	Find the shortest OR tech
	for(i = 0; i < GC.getNUM_OR_TECH_PREREQS(); i++)
	{
		//	Grab the tech
		ePreReq = (TechTypes)pkTechInfo->GetPrereqOrTechs(i);

		//	If this is a valid tech
		if(ePreReq != NO_TECH)
		{
			//	Recursively find the path length (takes into account all ANDs)
			//iNumSteps = findPathLength(ePreReq, bCost);
			iNumSteps = findPathLengthNew(ePreReq, NULL);

			//	If the prereq is a valid tech and its the current shortest, mark it as such
			if(iNumSteps < iShortestPath)
			{
				eShortestOr = ePreReq;
				iShortestPath = iNumSteps;
			}
		}
	}

	//	If the shortest OR is a valid tech, add the steps to it...
	if(eShortestOr != NO_TECH)
	{
		iPathLength += iShortestPath;
	}

	//return (iPathLength + ((bCost) ? GET_TEAM(getTeam()).GetTeamTechs()->GetResearchCost(eTech) : 1));
	return bCost ? (GET_TEAM(getTeam()).GetTeamTechs()->GetResearchCost(eTech)) : iPathLength;
}


//	--------------------------------------------------------------------------------
//	Function specifically for python/tech chooser screen
int CvPlayer::getQueuePosition(TechTypes eTech) const
{
	int i = 1;
	const CLLNode<TechTypes>* pResearchNode;

	for(pResearchNode = headResearchQueueNode(); pResearchNode; pResearchNode = nextResearchQueueNode(pResearchNode))
	{
		if(pResearchNode->m_data == eTech)
		{
			return i;
		}
		i++;
	}

	return -1;
}


//	--------------------------------------------------------------------------------
void CvPlayer::clearResearchQueue()
{
	int iI;

	m_researchQueue.clear();

	for(iI = 0; iI < GC.getNumTechInfos(); iI++)
	{
		setResearchingTech(((TechTypes)iI), false);
	}

	if(getTeam() == GC.getGame().getActiveTeam())
	{
		GC.GetEngineUserInterface()->setDirty(ResearchButtons_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(Score_DIRTY_BIT, true);
	}
}


//	--------------------------------------------------------------------------------
//	Pushes research onto the queue.  If it is an append if will put it
//	and its pre-reqs into the queue.  If it is not an append it will change
//	research immediately and should be used with clear.  Clear will clear the entire queue.
bool CvPlayer::pushResearch(TechTypes eTech, bool bClear)
{
	int i;
	int iNumSteps;
	int iShortestPath;
	bool bOrPrereqFound;
	TechTypes ePreReq;
	TechTypes eShortestOr;

	CvAssertMsg(eTech != NO_TECH, "Tech is not assigned a valid value");

	CvTechEntry* pkTechInfo = GC.getTechInfo(eTech);
	if(pkTechInfo == NULL)
		return false;


	if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech(eTech) || m_pPlayerTechs->IsResearchingTech(eTech))
	{
		//	We have this tech, no reason to add this to the pre-reqs
		return true;
	}

	if(!GetPlayerTechs()->CanEverResearch(eTech))
	{
		return false;
	}

	//	Pop the entire queue...
	if(bClear)
	{
		clearResearchQueue();
	}

	//	Add in all the pre-reqs for the and techs...
	for(i = 0; i < GC.getNUM_AND_TECH_PREREQS(); i++)
	{
		ePreReq = (TechTypes)pkTechInfo->GetPrereqAndTechs(i);

		if(ePreReq != NO_TECH)
		{
			if(!pushResearch(ePreReq))
			{
				return false;
			}
		}
	}

	// Will return the shortest path of all the or techs.  Tie breaker goes to the first one...
	eShortestOr = NO_TECH;
	iShortestPath = INT_MAX;
	bOrPrereqFound = false;
	//	Cycle through all the OR techs
	for(i = 0; i < GC.getNUM_OR_TECH_PREREQS(); i++)
	{
		ePreReq = (TechTypes)pkTechInfo->GetPrereqOrTechs(i);

		if(ePreReq != NO_TECH)
		{
			bOrPrereqFound = true;

			//	If the pre-req exists, and we have it, it is the shortest path, get out, we're done
			if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech(ePreReq))
			{
				eShortestOr = ePreReq;
				break;
			}

			if(GetPlayerTechs()->CanEverResearch(ePreReq))
			{
				//	Find the length of the path to this pre-req
				iNumSteps = findPathLength(ePreReq);

				//	If this pre-req is a valid tech, and its the shortest current path, set it as such
				if(iNumSteps < iShortestPath)
				{
					eShortestOr = ePreReq;
					iShortestPath = iNumSteps;
				}
			}
		}
	}

	//	If the shortest path tech is valid, push it (and its children) on to the research queue recursively
	if(eShortestOr != NO_TECH)
	{
		if(!pushResearch(eShortestOr))
		{
			return false;
		}
	}
	else if(bOrPrereqFound)
	{
		return false;
	}

	//	Insert this tech at the end of the queue
	m_researchQueue.insertAtEnd(eTech);

	setResearchingTech(eTech, true);

	//	Set the dirty bits
	if(getTeam() == GC.getGame().getActiveTeam())
	{
		GC.GetEngineUserInterface()->setDirty(ResearchButtons_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(Score_DIRTY_BIT, true);
	}
	return true;
}


//	--------------------------------------------------------------------------------
//	If bHead is true we delete the entire queue...
void CvPlayer::popResearch(TechTypes eTech)
{
	CLLNode<TechTypes>* pResearchNode;

	for(pResearchNode = headResearchQueueNode(); pResearchNode; pResearchNode = nextResearchQueueNode(pResearchNode))
	{
		if(pResearchNode->m_data == eTech)
		{
			m_researchQueue.deleteNode(pResearchNode);
			break;
		}
	}

	setResearchingTech(eTech, false);

	if(getTeam() == GC.getGame().getActiveTeam())
	{
		GC.GetEngineUserInterface()->setDirty(ResearchButtons_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
		GC.GetEngineUserInterface()->setDirty(Score_DIRTY_BIT, true);
	}
}


//	--------------------------------------------------------------------------------
int CvPlayer::getLengthResearchQueue() const
{
	return m_researchQueue.getLength();
}


//	--------------------------------------------------------------------------------
CLLNode<TechTypes>* CvPlayer::nextResearchQueueNode(CLLNode<TechTypes>* pNode)
{
	return m_researchQueue.next(pNode);
}

//	--------------------------------------------------------------------------------
const CLLNode<TechTypes>* CvPlayer::nextResearchQueueNode(const CLLNode<TechTypes>* pNode) const
{
	return m_researchQueue.next(pNode);
}

//	--------------------------------------------------------------------------------
CLLNode<TechTypes>* CvPlayer::headResearchQueueNode()
{
	return m_researchQueue.head();
}

//	--------------------------------------------------------------------------------
const CLLNode<TechTypes>* CvPlayer::headResearchQueueNode() const
{
	return m_researchQueue.head();
}

//	--------------------------------------------------------------------------------
CLLNode<TechTypes>* CvPlayer::tailResearchQueueNode()
{
	return m_researchQueue.tail();
}


//	--------------------------------------------------------------------------------
void CvPlayer::addCityName(const CvString& szName)
{
	m_cityNames.insertAtEnd(szName);
}


//	--------------------------------------------------------------------------------
int CvPlayer::getNumCityNames() const
{
	return m_cityNames.getLength();
}


//	--------------------------------------------------------------------------------
CvString CvPlayer::getCityName(int iIndex) const
{
	CLLNode<CvString>* pCityNameNode;

	pCityNameNode = m_cityNames.nodeNum(iIndex);

	if(pCityNameNode != NULL)
	{
		return pCityNameNode->m_data;
	}
	else
	{
		return "";
	}
}

//	--------------------------------------------------------------------------------
CLLNode<CvString>* CvPlayer::nextCityNameNode(CLLNode<CvString>* pNode)
{
	return m_cityNames.next(pNode);
}

//	--------------------------------------------------------------------------------
const CLLNode<CvString>* CvPlayer::nextCityNameNode(const CLLNode<CvString>* pNode) const
{
	return m_cityNames.next(pNode);
}

//	--------------------------------------------------------------------------------
CLLNode<CvString>* CvPlayer::headCityNameNode()
{
	return m_cityNames.head();
}

//	--------------------------------------------------------------------------------
const CLLNode<CvString>* CvPlayer::headCityNameNode() const
{
	return m_cityNames.head();
}

//	--------------------------------------------------------------------------------
CvCity* CvPlayer::firstCity(int* pIterIdx, bool bRev)
{
	if (bRev)
		*pIterIdx = m_cities.GetCount()-1;
	else
		*pIterIdx = 0;
	return m_cities.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
const CvCity* CvPlayer::firstCity(int* pIterIdx, bool bRev) const
{
	if (bRev)
		*pIterIdx = m_cities.GetCount()-1;
	else
		*pIterIdx = 0;
	return m_cities.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
CvCity* CvPlayer::nextCity(int* pIterIdx, bool bRev)
{
	if (bRev)
		(*pIterIdx)--;
	else
		(*pIterIdx)++;

	return m_cities.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
const CvCity* CvPlayer::nextCity(int* pIterIdx, bool bRev) const
{
	if (bRev)
		(*pIterIdx)--;
	else
		(*pIterIdx)++;

	return m_cities.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
#if defined(MOD_BALANCE_CORE)
CvCity* CvPlayer::nextCity(const CvCity* pCurrent, bool bRev)
{
	int iIdx = m_cities.GetIndexForID(pCurrent->GetID());

	if (iIdx<0)
		return NULL;

	if (bRev)
		iIdx--;
	else
		iIdx++;

	return m_cities.GetAt(iIdx);
}

//	--------------------------------------------------------------------------------
const CvCity* CvPlayer::nextCity(const CvCity* pCurrent, bool bRev) const
{
	int iIdx = m_cities.GetIndexForID(pCurrent->GetID());

	if (iIdx<0)
		return NULL;

	if (bRev)
		iIdx--;
	else
		iIdx++;

	return m_cities.GetAt(iIdx);
}
#endif

//	--------------------------------------------------------------------------------
int CvPlayer::getNumCities() const
{
	return m_cities.GetCount();
}

//	--------------------------------------------------------------------------------
CvCity* CvPlayer::getCity(int iID) const
{
	return(m_cities.Get(iID));
}

//	--------------------------------------------------------------------------------
CvCity* CvPlayer::addCity()
{
	m_iNumUnitsSuppliedCached = -1;
	return(m_cities.Add());
}

//	--------------------------------------------------------------------------------
void CvPlayer::deleteCity(int iID)
{
	m_cities.Remove(iID);
	m_iNumUnitsSuppliedCached = -1;

#if defined(MOD_BALANCE_CORE_SETTLER)
	SetClosestCityMapDirty();
#endif

#if defined(MOD_BALANCE_CORE)
	int iLoop=0;
	for (CvCity* pCity=firstCity(&iLoop); pCity!=NULL; pCity=nextCity(&iLoop))
		pCity->UpdateClosestFriendlyNeighbors();
#endif
}

#if defined(MOD_BALANCE_CORE)
void CvPlayer::SetClosestCityMapDirty()
{
	if (m_pCityDistanceTurns)
		m_pCityDistanceTurns->SetDirty();
	if (m_pCityDistancePlots)
		m_pCityDistancePlots->SetDirty();

	GC.getGame().SetClosestCityMapDirty();
}

int CvPlayer::GetCityDistanceInEstimatedTurns( const CvPlot* pPlot ) const
{
	if (pPlot && m_pCityDistanceTurns)
		return m_pCityDistanceTurns->GetClosestFeatureDistance( *pPlot );
	else
		return INT_MAX;
}

CvCity* CvPlayer::GetClosestCityByEstimatedTurns( const CvPlot* pPlot ) const
{
	if (pPlot && m_pCityDistanceTurns)
		return getCity(m_pCityDistanceTurns->GetClosestFeatureID( *pPlot ));
	else
		return NULL;
}

int CvPlayer::GetCityDistanceInPlots(const CvPlot* pPlot) const
{
	if (pPlot && m_pCityDistancePlots)
		return m_pCityDistancePlots->GetClosestFeatureDistance(*pPlot);
	else
		return INT_MAX;
}

CvCity* CvPlayer::GetClosestCityByPlots(const CvPlot* pPlot) const
{
	if (pPlot && m_pCityDistancePlots)
		return getCity(m_pCityDistancePlots->GetClosestFeatureID(*pPlot));
	else
		return NULL;
}
#endif

//	--------------------------------------------------------------------------------
CvCity* CvPlayer::GetFirstCityWithBuildingClass(BuildingClassTypes eBuildingClass)
{
	CvCity *pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		const CvCivilizationInfo& playerCivilizationInfo = getCivilizationInfo();
		BuildingTypes eBuilding = (BuildingTypes)playerCivilizationInfo.getCivilizationBuildings((BuildingClassTypes)eBuildingClass);
		if (eBuilding != NO_BUILDING)
		{
			if (pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
			{
				return pLoopCity;
			}
		}
	}
	return false;
}

//	--------------------------------------------------------------------------------
const CvUnit* CvPlayer::firstUnit(int* pIterIdx, bool bRev) const
{
	if (bRev)
		*pIterIdx = m_units.GetCount()-1;
	else
		*pIterIdx = 0;
	return m_units.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
CvUnit* CvPlayer::firstUnit(int* pIterIdx, bool bRev)
{
	if (bRev)
		*pIterIdx = m_units.GetCount()-1;
	else
		*pIterIdx = 0;
	return m_units.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
const CvUnit* CvPlayer::nextUnit(int* pIterIdx, bool bRev) const
{
	if (bRev)
		(*pIterIdx)--;
	else
		(*pIterIdx)++;
	return m_units.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
CvUnit* CvPlayer::nextUnit(int* pIterIdx, bool bRev)
{
	if (bRev)
		(*pIterIdx)--;
	else
		(*pIterIdx)++;
	return m_units.GetAt(*pIterIdx);
}

#if defined(MOD_BALANCE_CORE)
CvUnit* CvPlayer::nextUnit(const CvUnit* pCurrent, bool bRev)
{
	int iIdx = m_units.GetIndexForID(pCurrent->GetID());

	if (iIdx<0)
		return NULL;

	if (bRev)
		iIdx--;
	else
		iIdx++;

	return m_units.GetAt(iIdx);
}

//	--------------------------------------------------------------------------------
const CvUnit* CvPlayer::nextUnit(const CvCity* pCurrent, bool bRev) const
{
	int iIdx = m_units.GetIndexForID(pCurrent->GetID());

	if (iIdx<0)
		return NULL;

	if (bRev)
		iIdx--;
	else
		iIdx++;

	return m_units.GetAt(iIdx);
}
#endif
//	--------------------------------------------------------------------------------
int CvPlayer::getNumUnits() const
{
	return m_units.GetCount();
}


//	--------------------------------------------------------------------------------
CvUnit* CvPlayer::getUnit(int iID) const
{
#if defined(MOD_BALANCE_CORE)
	//spread it out a little for an easy breakpoint
	CvUnit* pUnit = m_units.Get(iID);
	return pUnit;
#else
	return (m_units.GetAt(iID));
#endif
}

//	--------------------------------------------------------------------------------
CvUnit* CvPlayer::addUnit()
{
	CvUnit* pResult = m_units.Add();

	//debugging ...
	for (int iIdx = 0; iIdx < m_units.GetCount()-1; iIdx++)
	{
		if (m_units.GetAt(iIdx)==pResult)
			OutputDebugString("inconsistent state: double unit pointer!\n");
	}

	return pResult;
}


//	--------------------------------------------------------------------------------
void CvPlayer::deleteUnit(int iID)
{
	m_units.Remove(iID);
}


//	--------------------------------------------------------------------------------
const CvArmyAI* CvPlayer::firstArmyAI(int* pIterIdx, bool bRev) const
{
	if (bRev)
		*pIterIdx = m_armyAIs.GetCount()-1;
	else
		*pIterIdx = 0;
	return m_armyAIs.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
CvArmyAI* CvPlayer::firstArmyAI(int* pIterIdx, bool bRev)
{
	if (bRev)
		*pIterIdx = m_armyAIs.GetCount()-1;
	else
		*pIterIdx = 0;	
	return m_armyAIs.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
const CvArmyAI* CvPlayer::nextArmyAI(int* pIterIdx, bool bRev) const
{
	if (bRev)
		(*pIterIdx)--;
	else
		(*pIterIdx)++;
	return m_armyAIs.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
CvArmyAI* CvPlayer::nextArmyAI(int* pIterIdx, bool bRev)
{
	if (bRev)
		(*pIterIdx)--;
	else
		(*pIterIdx)++;
	return m_armyAIs.GetAt(*pIterIdx);
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNumArmyAIs() const
{
	return m_armyAIs.GetCount();
}


//	--------------------------------------------------------------------------------
const CvArmyAI* CvPlayer::getArmyAI(int iID) const
{
	return ((CvArmyAI*)(m_armyAIs.Get(iID)));
}

//	--------------------------------------------------------------------------------
CvArmyAI* CvPlayer::getArmyAI(int iID)
{
	return ((CvArmyAI*)(m_armyAIs.Get(iID)));
}


//	--------------------------------------------------------------------------------
CvArmyAI* CvPlayer::addArmyAI()
{
	CvArmyAI* pArmy = m_armyAIs.Add();
	if (pArmy)
		pArmy->SetOwner(m_eID);
	return pArmy;
}


//	--------------------------------------------------------------------------------
void CvPlayer::deleteArmyAI(int iID)
{
	bool bRemoved = m_armyAIs.Remove(iID);
	DEBUG_VARIABLE(bRemoved);
	CvAssertMsg(bRemoved, "could not find army, delete failed");
}


//	--------------------------------------------------------------------------------
const CvAIOperation* CvPlayer::getAIOperation(int iID) const
{
	std::map<int, CvAIOperation*>::const_iterator it = m_AIOperations.find(iID);
	if(it != m_AIOperations.end())
	{
		return it->second;
	}
	return 0;
}

//	--------------------------------------------------------------------------------
CvAIOperation* CvPlayer::getFirstAIOperation()
{
	CvAIOperation* rtnValue = NULL;

	m_CurrentOperation = m_AIOperations.begin();
	if(m_CurrentOperation != m_AIOperations.end())
	{
		rtnValue = m_CurrentOperation->second;
	}
	return rtnValue;
}

//	--------------------------------------------------------------------------------
CvAIOperation* CvPlayer::getNextAIOperation()
{
	CvAIOperation* rtnValue = NULL;

	if(m_CurrentOperation != m_AIOperations.end())
	{
		++m_CurrentOperation;
		if(m_CurrentOperation != m_AIOperations.end())
		{
			rtnValue = m_CurrentOperation->second;
		}
	}
	return rtnValue;
}

//	--------------------------------------------------------------------------------
CvAIOperation* CvPlayer::getAIOperation(int iID)
{
	std::map<int, CvAIOperation*>::iterator it = m_AIOperations.find(iID);
	if(it != m_AIOperations.end())
	{
		return it->second;
	}
	return 0;
}


//	--------------------------------------------------------------------------------
CvAIOperation* CvPlayer::addAIOperation(int OperationType, PlayerTypes eEnemy, int iArea, CvCity* pTarget, CvCity* pMuster, bool bOceanMoves)
{
	CvAIOperation* pNewOperation = CvAIOperation::CreateOperation((AIOperationTypes) OperationType);
	if(pNewOperation)
	{
		m_AIOperations.insert(std::make_pair(m_iNextOperationID.get(), pNewOperation));
		pNewOperation->Init(m_iNextOperationID, m_eID, eEnemy, iArea, pTarget, pMuster, bOceanMoves);
		m_iNextOperationID++;
	}
	return pNewOperation;
}

//	--------------------------------------------------------------------------------
void CvPlayer::deleteAIOperation(int iID)
{
	std::map<int, CvAIOperation*>::iterator it = m_AIOperations.find(iID);
	if(it != m_AIOperations.end())
	{
		delete(it->second);
		m_AIOperations.erase(it);
	}
	else
	{
		CvAssertMsg(false, "could not find operation, delete failed");
	}
}

bool CvPlayer::StopAllLandOffensiveOperationsAgainstPlayer(PlayerTypes ePlayer, bool bIncludeSneakOps, AIOperationAbortReason eReason)
{
	bool bFoundOne = false;

	// loop through all entries looking for match
	std::map<int , CvAIOperation*>::iterator iter;
	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
	{
		CvAIOperation* pThisOperation = iter->second;

		if (pThisOperation->GetOperationState() == AI_OPERATION_STATE_SUCCESSFUL_FINISH)
			continue;

		if(pThisOperation->IsOffensive() && !pThisOperation->IsNavalOperation() && pThisOperation->GetOperationState() != AI_OPERATION_STATE_ABORTED)
		{
			if( (ePlayer == NO_PLAYER && pThisOperation->GetEnemy() != BARBARIAN_PLAYER) || ePlayer == pThisOperation->GetEnemy())
			{
				if (bIncludeSneakOps || !pThisOperation->IsAllowedDuringPeace())
				{
					bFoundOne = true;
					pThisOperation->SetToAbort(eReason);
				}
			}
		}
	}

	return bFoundOne;
}

int CvPlayer::GetNumOffensiveOperations(DomainTypes eDomain)
{
	int iNum = 0;
	// loop through all entries looking for match
	std::map<int , CvAIOperation*>::iterator iter;
	for (iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
	{
		CvAIOperation* pThisOperation = iter->second;
		if (!pThisOperation->IsDefensive() && pThisOperation->GetOperationState() != AI_OPERATION_STATE_ABORTED)
		{
			if (eDomain == DOMAIN_SEA && pThisOperation->IsNavalOperation())
				iNum++;
			else if (eDomain == DOMAIN_LAND && !pThisOperation->IsNavalOperation())
				iNum++;
		}
	}

	return iNum;
}

bool CvPlayer::StopAllLandDefensiveOperationsAgainstPlayer(PlayerTypes ePlayer, AIOperationAbortReason eReason)
{
	bool bFoundOne = false;

	// loop through all entries looking for match
	std::map<int , CvAIOperation*>::iterator iter;
	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
	{
		CvAIOperation* pThisOperation = iter->second;

		if (pThisOperation->GetOperationState() == AI_OPERATION_STATE_SUCCESSFUL_FINISH)
			continue;

		if(pThisOperation->IsDefensive() && !pThisOperation->IsNavalOperation() && pThisOperation->GetOperationState() != AI_OPERATION_STATE_ABORTED)
		{
			if(ePlayer == NO_PLAYER || ePlayer == pThisOperation->GetEnemy())
			{
				bFoundOne = true;
				pThisOperation->SetToAbort(eReason);
			}
		}
	}

	return bFoundOne;
}

bool CvPlayer::StopAllSeaOffensiveOperationsAgainstPlayer(PlayerTypes ePlayer, bool bIncludeSneakOps, AIOperationAbortReason eReason)
{
	bool bFoundOne = false;

	// loop through all entries looking for match
	std::map<int , CvAIOperation*>::iterator iter;
	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
	{
		CvAIOperation* pThisOperation = iter->second;

		if (pThisOperation->GetOperationState() == AI_OPERATION_STATE_SUCCESSFUL_FINISH)
			continue;

		if(pThisOperation->IsOffensive() && pThisOperation->IsNavalOperation() && pThisOperation->GetOperationState() != AI_OPERATION_STATE_ABORTED)
		{
			if( (ePlayer == NO_PLAYER && pThisOperation->GetEnemy() != BARBARIAN_PLAYER) || ePlayer == pThisOperation->GetEnemy())
			{
				if (bIncludeSneakOps || !pThisOperation->IsAllowedDuringPeace())
				{
					bFoundOne = true;
					pThisOperation->SetToAbort(eReason);
				}
			}
		}
	}

	return bFoundOne;
}

bool CvPlayer::StopAllSeaDefensiveOperationsAgainstPlayer(PlayerTypes ePlayer, AIOperationAbortReason eReason)
{
	bool bFoundOne = false;

	// loop through all entries looking for match
	std::map<int , CvAIOperation*>::iterator iter;
	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
	{
		CvAIOperation* pThisOperation = iter->second;

		if (pThisOperation->GetOperationState() == AI_OPERATION_STATE_SUCCESSFUL_FINISH)
			continue;

		if(pThisOperation->IsDefensive() && pThisOperation->IsNavalOperation() && pThisOperation->GetOperationState() != AI_OPERATION_STATE_ABORTED)
		{
			if(ePlayer == NO_PLAYER || ePlayer == pThisOperation->GetEnemy())
			{
				bFoundOne = true;
				pThisOperation->SetToAbort(eReason);
			}
		}
	}

	return bFoundOne;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::haveAIOperationOfType(int iOperationType, int* piID /* optional return argument */, PlayerTypes eTargetPlayer /* optional additional match criteria */, CvPlot* pTarget /* optional additional match criteria */)
{
	// loop through all entries looking for match
	std::map<int , CvAIOperation*>::iterator iter;
	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
	{
		CvAIOperation* pThisOperation = iter->second;
		if(pThisOperation->GetOperationType() == iOperationType && pThisOperation->GetOperationState() != AI_OPERATION_STATE_ABORTED)
		{
			if(eTargetPlayer == NO_PLAYER || eTargetPlayer == pThisOperation->GetEnemy())
			{
				if(pTarget == NULL || pTarget == pThisOperation->GetTargetPlot() || pTarget == pThisOperation->GetMusterPlot())
				{
					// Fill in optional parameter (ID) if passed in
					if(piID != NULL)
					{
						*piID = pThisOperation->GetID();
					}
					return true;
				}
			}
		}
	}
	// Fill in optional parameter (ID) if passed in
	if(piID != NULL)
	{
		*piID = -1;
	}
	return false;
}

//	--------------------------------------------------------------------------------
int CvPlayer::numOperationsOfType(int iOperationType)
{
	int iRtnValue = 0;

	std::map<int , CvAIOperation*>::iterator iter;
	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
	{
		CvAIOperation* pThisOperation = iter->second;
		if(pThisOperation->GetOperationType() == iOperationType && pThisOperation->GetOperationState() != AI_OPERATION_STATE_ABORTED)
		{
			iRtnValue++;
		}
	}

	return iRtnValue;
}

//	--------------------------------------------------------------------------------
/// Is an existing operation already going after this city?
bool CvPlayer::IsCityAlreadyTargeted(CvCity* pCity, DomainTypes eDomain, int iPercentToTarget, int iIgnoreOperationID, AIOperationTypes eAlreadyActiveOperation) const
{
	CvAIOperation* pOperation;
	std::map<int , CvAIOperation*>::const_iterator iter;
	AIOperationState eOperationState = INVALID_AI_OPERATION_STATE;
	if (iPercentToTarget <= 50)
	{
		eOperationState = AI_OPERATION_STATE_GATHERING_FORCES;
	}
	else
	{
		eOperationState = AI_OPERATION_STATE_MOVING_TO_TARGET;
	}
	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
	{
		pOperation = iter->second;

		if(pOperation)
		{
			if(iIgnoreOperationID == -1 || iIgnoreOperationID != pOperation->GetID())
			{
				if (pOperation->GetOperationState() <= eOperationState)
				{
					if(pOperation->GetTargetPlot() != NULL)
					{
						if(pOperation->GetTargetPlot() == pCity->plot())
						{
							// Naval attacks are mixed land/naval operations
							if((eDomain == NO_DOMAIN || eDomain == DOMAIN_SEA) && pOperation->IsNavalOperation())
							{
								return true;
							}

							if((eDomain == NO_DOMAIN || eDomain == DOMAIN_LAND) && !pOperation->IsNavalOperation())
							{
								return true;
							}
						}
						else if(pOperation->GetTargetPlot()->getOwningCity() != NULL)
						{
							if(pOperation->GetTargetPlot()->getOwningCity() == pCity)
							{
								// Naval attacks are mixed land/naval operations
								if((eDomain == NO_DOMAIN || eDomain == DOMAIN_SEA) && pOperation->IsNavalOperation())
								{
									return true;
								}

								if((eDomain == NO_DOMAIN || eDomain == DOMAIN_LAND) && !pOperation->IsNavalOperation())
								{
									return true;
								}
							}
						}
					}
				}
			}
			if (eAlreadyActiveOperation == INVALID_AI_OPERATION || eAlreadyActiveOperation == pOperation->GetOperationType())
			{
				if (pOperation->GetOperationState() <= eOperationState)
				{
					if (pOperation->GetTargetPlot() != NULL)
					{
						if (pOperation->GetTargetPlot() == pCity->plot())
						{
							// Naval attacks are mixed land/naval operations
							if ((eDomain == NO_DOMAIN || eDomain == DOMAIN_SEA) && pOperation->IsNavalOperation())
							{
								return true;
							}

							if ((eDomain == NO_DOMAIN || eDomain == DOMAIN_LAND) && !pOperation->IsNavalOperation())
							{
								return true;
							}
						}
						else if (pOperation->GetTargetPlot()->getOwningCity() != NULL)
						{
							if (pOperation->GetTargetPlot()->getOwningCity() == pCity)
							{
								// Naval attacks are mixed land/naval operations
								if ((eDomain == NO_DOMAIN || eDomain == DOMAIN_SEA) && pOperation->IsNavalOperation())
								{
									return true;
								}

								if ((eDomain == NO_DOMAIN || eDomain == DOMAIN_LAND) && !pOperation->IsNavalOperation())
								{
									return true;
								}
							}
						}
					}
				}
			}
		}
	}

	return false;
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Is an existing operation already starting from this city?
bool CvPlayer::IsMusterCityAlreadyTargeted(CvCity* pCity, DomainTypes eDomain, int iPercentToTarget, int iIgnoreOperationID, AIOperationTypes eAlreadyActiveOperation) const
{
	CvAIOperation* pOperation;
	std::map<int, CvAIOperation*>::const_iterator iter;
	AIOperationState eOperationState = INVALID_AI_OPERATION_STATE;
	if (iPercentToTarget <= 50)
	{
		eOperationState = AI_OPERATION_STATE_GATHERING_FORCES;
	}
	else
	{
		eOperationState = AI_OPERATION_STATE_MOVING_TO_TARGET;
	}
	for (iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
	{
		pOperation = iter->second;

		if (pOperation)
		{
			if (iIgnoreOperationID == -1 || iIgnoreOperationID != pOperation->GetID())
			{
				if (pOperation->GetOperationState() <= eOperationState)
				{
					if(pOperation->GetMusterPlot() != NULL)
					{
						if(pOperation->GetMusterPlot() == pCity->plot())
						{
							// Naval attacks are mixed land/naval operations
							if((eDomain == NO_DOMAIN || eDomain == DOMAIN_SEA) && pOperation->IsNavalOperation())
							{
								return true;
							}

							if((eDomain == NO_DOMAIN || eDomain == DOMAIN_LAND) && !pOperation->IsNavalOperation())
							{
								return true;
							}
						}
						else if(pOperation->GetMusterPlot()->getOwningCity() != NULL)
						{
							if(pOperation->GetMusterPlot()->getOwningCity() == pCity)
							{
								// Naval attacks are mixed land/naval operations
								if((eDomain == NO_DOMAIN || eDomain == DOMAIN_SEA) && pOperation->IsNavalOperation())
								{
									return true;
								}

								if((eDomain == NO_DOMAIN || eDomain == DOMAIN_LAND) && !pOperation->IsNavalOperation())
								{
									return true;
								}
							}
						}
					}
				}
			}
			if (eAlreadyActiveOperation == INVALID_AI_OPERATION || eAlreadyActiveOperation == pOperation->GetOperationType())
			{
				if (pOperation->GetOperationState() <= eOperationState)
				{
					if (pOperation->GetMusterPlot() != NULL)
					{
						if (pOperation->GetMusterPlot() == pCity->plot())
						{
							// Naval attacks are mixed land/naval operations
							if ((eDomain == NO_DOMAIN || eDomain == DOMAIN_SEA) && pOperation->IsNavalOperation())
							{
								return true;
							}

							if ((eDomain == NO_DOMAIN || eDomain == DOMAIN_LAND) && !pOperation->IsNavalOperation())
							{
								return true;
							}
						}
						else if (pOperation->GetMusterPlot()->getOwningCity() != NULL)
						{
							if (pOperation->GetMusterPlot()->getOwningCity() == pCity)
							{
								// Naval attacks are mixed land/naval operations
								if ((eDomain == NO_DOMAIN || eDomain == DOMAIN_SEA) && pOperation->IsNavalOperation())
								{
									return true;
								}

								if ((eDomain == NO_DOMAIN || eDomain == DOMAIN_LAND) && !pOperation->IsNavalOperation())
								{
									return true;
								}
							}
						}
					}
				}
			}
		}
	}

	return false;
}
#endif

#if defined(MOD_BALANCE_CORE)
bool CvPlayer::IsPlotTargetedForExplorer(const CvPlot* pPlot, const CvUnit* pIgnoreUnit) const
{
	if (!pPlot)
		return false;

	// Loop through our units
	int iLoop = 0;
	for(const CvUnit* pUnit = firstUnit(&iLoop); pUnit; pUnit = nextUnit(&iLoop))
	{
		if (pUnit==pIgnoreUnit)
			continue;

		if(pUnit->AI_getUnitAIType() == UNITAI_EXPLORE || (pUnit->IsAutomated() && pUnit->GetAutomateType() == AUTOMATE_EXPLORE) )
		{
			CvPlot* pMissionPlot = pUnit->GetMissionAIPlot();
			if (pMissionPlot && ::plotDistance(*pMissionPlot,*pPlot)<3)
				return true;
		}
	}
	return false;
}
#endif

//	--------------------------------------------------------------------------------
/// Are we already sending a settler to this plot (or any plot within 3)
bool CvPlayer::IsPlotTargetedForCity(CvPlot *pPlot, CvAIOperation* pOpToIgnore) const
{
	std::map<int , CvAIOperation*>::const_iterator iter;
	for(iter = m_AIOperations.begin(); iter != m_AIOperations.end(); ++iter)
	{
		CvAIOperation* pOperation = iter->second;
		if(pOperation && pOperation != pOpToIgnore && pOperation->HasTargetPlot())
		{
			switch (pOperation->GetOperationType())
			{
			case AI_OPERATION_FOUND_CITY:
			case AI_OPERATION_FOUND_CITY_OVERSEAS:
			case AI_OPERATION_FOUND_CITY_QUICK:
				{
					if (plotDistance(*pPlot,*pOperation->GetTargetPlot()) <= 3)
					{
						return true;
					}
				}
			}
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
unsigned int CvPlayer::getNumReplayDataSets() const
{
	return m_ReplayDataSets.size();
}

//	--------------------------------------------------------------------------------
const char* CvPlayer::getReplayDataSetName(unsigned int idx) const
{
	if(idx < m_ReplayDataSets.size())
		return m_ReplayDataSets[idx];

	return NULL;
}

//	--------------------------------------------------------------------------------
unsigned int CvPlayer::getReplayDataSetIndex(const char* szDataSetName)
{
	CvString dataSetName = szDataSetName;

	unsigned int idx = 0;
	for(std::vector<CvString>::iterator it = m_ReplayDataSets.begin(); it != m_ReplayDataSets.end(); ++it)
	{
		if((*it) == dataSetName)
			return idx;

		idx++;
	}

	m_ReplayDataSets.push_back(dataSetName);
	m_ReplayDataSetValues.push_back(TurnData());
	return m_ReplayDataSets.size() - 1;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getReplayDataValue(unsigned int uiDataSet, unsigned int uiTurn) const
{
	if(uiDataSet < m_ReplayDataSetValues.size())
	{
		const TurnData& dataSet = m_ReplayDataSetValues[uiDataSet];
		TurnData::const_iterator it = dataSet.find(uiTurn);
		if(it != dataSet.end())
		{
			return (*it).second;
		}
	}

	return -1;
}

//	--------------------------------------------------------------------------------
void CvPlayer::setReplayDataValue(unsigned int uiDataSet, unsigned int uiTurn, int iValue)
{
	if(uiDataSet < m_ReplayDataSetValues.size())
	{
		TurnData& dataSet = m_ReplayDataSetValues[uiDataSet];
		dataSet[uiTurn] = iValue;
	}
}

//	--------------------------------------------------------------------------------
CvPlayer::TurnData CvPlayer::getReplayDataHistory(unsigned int uiDataSet) const
{
	if(uiDataSet < m_ReplayDataSetValues.size())
	{
		return m_ReplayDataSetValues[uiDataSet];
	}

	return CvPlayer::TurnData();
}

//	--------------------------------------------------------------------------------
void CvPlayer::changeInstantYieldValue(YieldTypes eYield, int iValue)
{
	if (iValue != 0)
	{
		int iTurn = GC.getGame().getGameTurn();
		Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppiInstantYieldHistoryValues[iTurn];
		yields[eYield] = (m_ppiInstantYieldHistoryValues[iTurn][eYield] + iValue);
		m_ppiInstantYieldHistoryValues[iTurn] = yields;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getInstantYieldValue(YieldTypes eYield, int iTurn) const
{
	//catch for CTD
	if (iTurn <= 0 || iTurn >= GC.getGame().getEstimateEndTurn())
		return 0;

	return m_ppiInstantYieldHistoryValues[iTurn][eYield];
}

CvString CvPlayer::getInstantYieldHistoryTooltip(int iGameTurn, int iNumPreviousTurnsToCount)
{
	CvString yieldtooltip = "";
	int MaxTurnsBack = 0;
	for (int i = 0; i < NUM_YIELD_TYPES; i++)
	{
		int TurnsBack = 0;
		YieldTypes eYield = (YieldTypes)i;
		if (eYield == NO_YIELD)
			continue;

		if (eYield > YIELD_CULTURE_LOCAL)
			continue;

		if (GC.getYieldInfo(eYield) == NULL)
			continue;

		//current turn
		int iSum = 0;

		//turn zero is strange
		if (iGameTurn == 0)
		{
			iSum = getInstantYieldValue(eYield, GC.getGame().getGameTurn());
			TurnsBack++;
		}
		else
		{
			//and x turns back
			for (int iI = iNumPreviousTurnsToCount; iI >= 0; iI--)
			{
				int iTurn = iGameTurn - iI;
				if (iTurn < 0)
				{
					continue;
				}

				iSum += getInstantYieldValue(eYield, iTurn);
				TurnsBack++;
			}
		}
		if (TurnsBack > MaxTurnsBack)
			MaxTurnsBack = TurnsBack;

		if (iSum != 0)
		{
			if (yieldtooltip != "")
			{
				yieldtooltip += "[NEWLINE]";
			}

			Localization::String localizedIYText;

			localizedIYText = Localization::Lookup("TXT_KEY_INSTANT_YIELD_TOTAL");

			localizedIYText << GC.getYieldInfo(eYield)->GetDescription();
			localizedIYText << GC.getYieldInfo(eYield)->getIconString();
			localizedIYText << GC.getYieldInfo(eYield)->getColorString();
			localizedIYText << iSum;

			yieldtooltip += localizedIYText.toUTF8();

			int iAverage = iSum / max(1, MaxTurnsBack);

			yieldtooltip += " " + GetLocalizedText("TXT_KEY_INSTANT_YIELD_AVERAGE", iAverage);

			if (eYield == YIELD_FOOD || eYield == YIELD_PRODUCTION)
			{
				iAverage /= max(1, getNumCities());
				yieldtooltip += " " + GetLocalizedText("TXT_KEY_INSTANT_YIELD_AVERAGE_CITIES", iAverage);
			}
		}
	}
	CvString tooltip = GetLocalizedText("TXT_KEY_YIELD_PER_TURN_HEADER", min(iNumPreviousTurnsToCount, MaxTurnsBack)) + "[NEWLINE]";

	if (yieldtooltip != "")
	{
		tooltip += yieldtooltip;
	}
	else
	{
		tooltip = GetLocalizedText("TXT_KEY_YIELD_PER_TURN_HEADER_EMPTY");
	}

	return tooltip;
}

//	--------------------------------------------------------------------------------
std::string CvPlayer::getScriptData() const
{
	return m_strScriptData;
}

//	--------------------------------------------------------------------------------
void CvPlayer::setScriptData(std::string strNewValue)
{
	m_strScriptData = strNewValue;
}

//	--------------------------------------------------------------------------------
const CvString& CvPlayer::getPbemEmailAddress() const
{
	return CvPreGame::emailAddress(GetID());
}

//	--------------------------------------------------------------------------------
void CvPlayer::setPbemEmailAddress(const char* szAddress)
{
	CvPreGame::setEmailAddress(GetID(), szAddress);
}

// Protected Functions...

//	--------------------------------------------------------------------------------
void CvPlayer::doResearch()
{
	if(GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))
	{
		return;
	}

	AI_PERF_FORMAT("AI-perf.csv", ("CvPlayer::doResearch, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), getCivilizationShortDescription()) );
	bool bForceResearchChoice;
	int iOverflowResearch;

	if(GetPlayerTechs()->IsResearch())
	{
		bForceResearchChoice = false;

		// Force player to pick Research if he doesn't have anything assigned
		if(GetPlayerTechs()->GetCurrentResearch() == NO_TECH)
		{
			if(GetID() == GC.getGame().getActivePlayer() && GetScienceTimes100() > 0)
			{
				chooseTech();
			}

			if(GC.getGame().getElapsedGameTurns() > 4)
			{
				AI_chooseResearch();

				bForceResearchChoice = true;
			}
		}

		TechTypes eCurrentTech = GetPlayerTechs()->GetCurrentResearch();
		if(eCurrentTech == NO_TECH)
		{
			int iOverflow = (GetScienceTimes100()) / std::max(1, calculateResearchModifier(eCurrentTech));
			changeOverflowResearchTimes100(iOverflow);
		}
		else
		{
			iOverflowResearch = (getOverflowResearchTimes100() * calculateResearchModifier(eCurrentTech)) / 100;
			setOverflowResearch(0);
			if(GET_TEAM(getTeam()).GetTeamTechs())
			{
				int iBeakersTowardsTechTimes100 = GetScienceTimes100() + iOverflowResearch;
#if defined(MOD_BUGFIX_RESEARCH_OVERFLOW)
				GET_TEAM(getTeam()).GetTeamTechs()->ChangeResearchProgressTimes100(eCurrentTech, iBeakersTowardsTechTimes100, GetID(), iOverflowResearch, calculateResearchModifier(eCurrentTech));
#else
				GET_TEAM(getTeam()).GetTeamTechs()->ChangeResearchProgressTimes100(eCurrentTech, iBeakersTowardsTechTimes100, GetID());
#endif
				UpdateResearchAgreements(GetScienceTimes100() / 100);
			}
		}

		if(bForceResearchChoice)
		{
			clearResearchQueue();
		}
	}
	GetPlayerTechs()->CheckForTechAchievement();

}

//	--------------------------------------------------------------------------------
void CvPlayer::doAdvancedStartAction(AdvancedStartActionTypes eAction, int iX, int iY, int iData, bool bAdd)
{
	CvPlot* pPlot = GC.getMap().plot(iX, iY);

	if(0 == getNumCities())
	{
		switch(eAction)
		{
		case ADVANCEDSTARTACTION_EXIT:
			//Try to build this player's empire
			if(GetID() == GC.getGame().getActivePlayer())
			{
				GC.GetEngineUserInterface()->setBusy(true);
			}
			if(GetID() == GC.getGame().getActivePlayer())
			{
				GC.GetEngineUserInterface()->setBusy(false);
			}
			break;
		case ADVANCEDSTARTACTION_AUTOMATE:
		case ADVANCEDSTARTACTION_CITY:
			break;
		default:
			// The first action must be to place a city
			// so players can lose by spending everything
			return;
		}
	}

	switch(eAction)
	{
	case ADVANCEDSTARTACTION_EXIT:
		GetTreasury()->ChangeGold(getAdvancedStartPoints());
		setAdvancedStartPoints(-1);
		if(GC.getGame().getActivePlayer() == GetID())
		{
			GC.GetEngineUserInterface()->setInAdvancedStart(false);
		}

		if(isHuman())
		{
			int iLoop;
			for(CvCity* pCity = firstCity(&iLoop); NULL != pCity; pCity = nextCity(&iLoop))
			{
				pCity->chooseProduction();
			}

			chooseTech();
		}
		break;
	case ADVANCEDSTARTACTION_AUTOMATE:
		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setBusy(true);
		}
		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setBusy(false);
		}
		break;
	case ADVANCEDSTARTACTION_UNIT:
	{
		if(pPlot == NULL)
			return;

		UnitTypes eUnit = (UnitTypes) iData;
		int iCost = getAdvancedStartUnitCost(eUnit, bAdd, pPlot);

		if(bAdd && iCost < 0)
		{
			return;
		}

		// Add unit to the map
		if(bAdd)
		{
			if(getAdvancedStartPoints() >= iCost)
			{
				CvUnit* pUnit = initUnit(eUnit, iX, iY);
				if(NULL != pUnit)
				{
					pUnit->finishMoves();
					changeAdvancedStartPoints(-iCost);
				}
			}
		}

		// Remove unit from the map
		else
		{
			// If cost is -1 we already know this unit isn't present
			if(iCost != -1)
			{
				IDInfo* pUnitNode = pPlot->headUnitNode();
				while(pUnitNode != NULL)
				{
					CvUnit* pLoopUnit = ::getUnit(*pUnitNode);
					pUnitNode = pPlot->nextUnitNode(pUnitNode);

					if(NULL != pLoopUnit && pLoopUnit->getUnitType() == eUnit)
					{
						pLoopUnit->kill(false);
						changeAdvancedStartPoints(iCost);
						return;
					}
				}
			}

			// Proper unit not found above, delete first found
			IDInfo* pUnitNode = pPlot->headUnitNode();
			if(pUnitNode != NULL)
			{
				CvUnit* pUnit = ::getUnit(*pUnitNode);

				iCost = getAdvancedStartUnitCost(pUnit->getUnitType(), false);
				CvAssertMsg(iCost != -1, "If this is -1 then that means it's going to try to delete a unit which shouldn't exist");
				pUnit->kill(false);
				changeAdvancedStartPoints(iCost);
			}
		}

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Advanced_Start_DIRTY_BIT, true);
		}
	}
	break;
	case ADVANCEDSTARTACTION_CITY:
	{
		if(pPlot == NULL)
			return;

		int iCost = getAdvancedStartCityCost(bAdd, pPlot);

		if(iCost < 0)
		{
			return;
		}

		// Add City to the map
		if(bAdd)
		{
			if(0 == getNumCities())
			{
				PlayerTypes eClosestPlayer = NO_PLAYER;
				int iMinDistance = INT_MAX;
				for(int iPlayer = 0; iPlayer < MAX_CIV_PLAYERS; iPlayer++)
				{
					CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iPlayer);
					if(kPlayer.isAlive())
					{
						if(kPlayer.getTeam() == getTeam())
						{
							if(0 == kPlayer.getNumCities())
							{
								CvAssert(kPlayer.getStartingPlot() != NULL);
								int iDistance = plotDistance(iX, iY, kPlayer.getStartingPlot()->getX(), kPlayer.getStartingPlot()->getY());
								if(iDistance < iMinDistance)
								{
									eClosestPlayer = kPlayer.GetID();
									iMinDistance = iDistance;
								}
							}
						}
					}
				}
				CvAssertMsg(eClosestPlayer != NO_PLAYER, "Self at a minimum should always be valid");
				if(eClosestPlayer != GetID())
				{
					CvPlot* pTempPlot = GET_PLAYER(eClosestPlayer).getStartingPlot();
					GET_PLAYER(eClosestPlayer).setStartingPlot(getStartingPlot());
					setStartingPlot(pTempPlot);
				}
			}
			if(getAdvancedStartPoints() >= iCost || 0 == getNumCities())
			{
				found(iX, iY);
				changeAdvancedStartPoints(-iCost);
				CvCity* pCity = pPlot->getPlotCity();
				if(pCity != NULL)
				{
					if(pCity->getPopulation() > 1)
					{
						pCity->setFood(pCity->growthThreshold() / 2);
					}
				}
			}
		}

		// Remove City from the map
		else
		{
			pPlot->setRouteType(NO_ROUTE);
			pPlot->getPlotCity()->kill();
			pPlot->setImprovementType(NO_IMPROVEMENT);
			changeAdvancedStartPoints(iCost);
		}

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Advanced_Start_DIRTY_BIT, true);
		}
	}
	break;
	case ADVANCEDSTARTACTION_POP:
	{
		if(pPlot == NULL)
			return;

		CvCity* pCity = pPlot->getPlotCity();

		if(pCity != NULL)
		{
			int iCost = getAdvancedStartPopCost(bAdd, pCity);

			if(iCost < 0)
			{
				return;
			}

			// Add Pop to the City
			if(bAdd)
			{
				if(getAdvancedStartPoints() >= iCost)
				{
					pCity->changePopulation(1);
					changeAdvancedStartPoints(-iCost);
					if(pCity->getPopulation() > 1)
					{
						pCity->setFood(pCity->growthThreshold() / 2);
						pCity->setFoodKept((pCity->getFood() * pCity->getMaxFoodKeptPercent()) / 100);
					}
				}
			}

			// Remove Pop from the city
			else
			{
				pCity->changePopulation(-1);
				changeAdvancedStartPoints(iCost);
				if(pCity->getPopulation() == 1)
				{
					pCity->setFood(0);
					pCity->setFoodKept(0);
				}
			}
		}
	}
	break;
	case ADVANCEDSTARTACTION_BUILDING:
	{
		if(pPlot == NULL)
			return;

		CvCity* pCity = pPlot->getPlotCity();

		if(pCity != NULL)
		{
			BuildingTypes eBuilding = (BuildingTypes) iData;

			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
			if(pkBuildingInfo == NULL)
			{
				return;
			}

			int iCost = getAdvancedStartBuildingCost(eBuilding, bAdd, pCity);
			if(iCost < 0)
			{
				return;
			}

			// Add Building to the City
			if(bAdd)
			{
				if(getAdvancedStartPoints() >= iCost)
				{
					pCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, pCity->GetCityBuildings()->GetNumRealBuilding(eBuilding)+1);
					changeAdvancedStartPoints(-iCost);
					if(pkBuildingInfo->GetFoodKept() != 0)
					{
						pCity->setFoodKept((pCity->getFood() * pCity->getMaxFoodKeptPercent()) / 100);
					}
				}
			}

			// Remove Building from the map
			else
			{
				pCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, pCity->GetCityBuildings()->GetNumRealBuilding(eBuilding)-1);
				changeAdvancedStartPoints(iCost);
				if(pkBuildingInfo->GetFoodKept() != 0)
				{
					pCity->setFoodKept((pCity->getFood() * pCity->getMaxFoodKeptPercent()) / 100);
				}
			}
		}

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Advanced_Start_DIRTY_BIT, true);
		}
	}
	break;
	case ADVANCEDSTARTACTION_ROUTE:
	{
		if(pPlot == NULL)
			return;

		RouteTypes eRoute = (RouteTypes) iData;
		int iCost = getAdvancedStartRouteCost(eRoute, bAdd, pPlot);

		if(bAdd && iCost < 0)
		{
			return;
		}

		// Add Route to the plot
		if(bAdd)
		{
			if(getAdvancedStartPoints() >= iCost)
			{
				pPlot->setRouteType(eRoute);
				changeAdvancedStartPoints(-iCost);
			}
		}

		// Remove Route from the Plot
		else
		{
			if(pPlot->getRouteType() != eRoute)
			{
				eRoute = pPlot->getRouteType();
				iCost = getAdvancedStartRouteCost(eRoute, bAdd);
			}

			if(iCost < 0)
			{
				return;
			}

			pPlot->setRouteType(NO_ROUTE);
			changeAdvancedStartPoints(iCost);
		}

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Advanced_Start_DIRTY_BIT, true);
		}
	}
	break;
	case ADVANCEDSTARTACTION_IMPROVEMENT:
	{
		if(pPlot == NULL)
			return;

		ImprovementTypes eImprovement = (ImprovementTypes) iData;
		int iCost = getAdvancedStartImprovementCost(eImprovement, bAdd, pPlot);

		if(bAdd && iCost < 0)
		{
			return;
		}

		// Add Improvement to the plot
		if(bAdd)
		{
			if(getAdvancedStartPoints() >= iCost)
			{
				if(pPlot->getFeatureType() != NO_FEATURE)
				{
					for(int iI = 0; iI < GC.getNumBuildInfos(); ++iI)
					{
						CvBuildInfo* pkBuildInfo = GC.getBuildInfo((BuildTypes) iI);
						if(!pkBuildInfo)
						{
							continue;
						}

						ImprovementTypes eLoopImprovement = ((ImprovementTypes)(pkBuildInfo->getImprovement()));

						if(eImprovement == eLoopImprovement)
						{
							if(pkBuildInfo->isFeatureRemove(pPlot->getFeatureType()) && canBuild(pPlot, (BuildTypes)iI))
							{
								pPlot->setFeatureType(NO_FEATURE);
								break;
							}
						}
					}
				}

				pPlot->setImprovementType(eImprovement, GetID());

				changeAdvancedStartPoints(-iCost);
			}
		}

		// Remove Improvement from the Plot
		else
		{
			if(pPlot->getImprovementType() != eImprovement)
			{
				eImprovement = pPlot->getImprovementType();
				iCost = getAdvancedStartImprovementCost(eImprovement, bAdd, pPlot);
			}

			if(iCost < 0)
			{
				return;
			}

			pPlot->setImprovementType(NO_IMPROVEMENT);
			changeAdvancedStartPoints(iCost);
		}

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Advanced_Start_DIRTY_BIT, true);
		}
	}
	break;
	case ADVANCEDSTARTACTION_TECH:
	{
		TechTypes eTech = (TechTypes) iData;
		int iCost = getAdvancedStartTechCost(eTech, bAdd);

		if(iCost < 0)
		{
			return;
		}

		// Add Tech to team
		if(bAdd)
		{
			if(getAdvancedStartPoints() >= iCost)
			{
				GET_TEAM(getTeam()).setHasTech(eTech, true, GetID(), false, false);
				changeAdvancedStartPoints(-iCost);
			}
		}

		// Remove Tech from the Team
		else
		{
			GET_TEAM(getTeam()).setHasTech(eTech, false, GetID(), false, false);
			changeAdvancedStartPoints(iCost);
		}

		if(GetID() == GC.getGame().getActivePlayer())
		{
			GC.GetEngineUserInterface()->setDirty(Advanced_Start_DIRTY_BIT, true);
		}
	}
	break;
	case ADVANCEDSTARTACTION_VISIBILITY:
	{
		if(pPlot == NULL)
			return;

		int iCost = getAdvancedStartVisibilityCost(bAdd, pPlot);

		if(iCost < 0)
		{
			return;
		}

		// Add Visibility to the plot
		if(bAdd)
		{
			if(getAdvancedStartPoints() >= iCost)
			{
#if defined(MOD_API_EXTENSIONS)
				pPlot->setRevealed(getTeam(), true, NULL, true);
#else
				pPlot->setRevealed(getTeam(), true, true);
#endif
				changeAdvancedStartPoints(-iCost);
			}
		}

		// Remove Visibility from the Plot
		else
		{
#if defined(MOD_API_EXTENSIONS)
			pPlot->setRevealed(getTeam(), false, NULL, true);
#else
			pPlot->setRevealed(getTeam(), false, true);
#endif
			changeAdvancedStartPoints(iCost);
		}
	}
	break;
	default:
		CvAssert(false);
		break;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing a unit
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartUnitCost(UnitTypes eUnit, bool bAdd, CvPlot* pPlot)
{
	if(0 == getNumCities())
	{
		return -1;
	}

	CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
	if(pkUnitInfo == NULL)
	{
		return -1;
	}

	int iCost = (getProductionNeeded(eUnit) * pkUnitInfo->GetAdvancedStartCost()) / 100;
	if(iCost < 0)
	{
		return -1;
	}

	if(NULL == pPlot)
	{
		if(bAdd)
		{
			bool bValid = false;
			int iLoop;
			for(CvCity* pLoopCity = firstCity(&iLoop); NULL != pLoopCity; pLoopCity = nextCity(&iLoop))
			{
				if(pLoopCity->canTrain(eUnit))
				{
					bValid = true;
					break;
				}
			}

			if(!bValid)
			{
				return -1;
			}
		}
	}
	else
	{
		CvCity* pCity = NULL;

		if(0 == GC.getADVANCED_START_ALLOW_UNITS_OUTSIDE_CITIES())
		{
			pCity = pPlot->getPlotCity();

			if(NULL == pCity || pCity->getOwner() != GetID())
			{
				return -1;
			}

			iCost *= 100;
			iCost /= std::max(1, 100 + pCity->getProductionModifier(eUnit));
		}
		else
		{
			if(pPlot->getOwner() != GetID())
			{
				return -1;
			}

			iCost *= 100;
			iCost /= std::max(1, 100 + getProductionModifier(eUnit));
		}


		if(bAdd)
		{
			int iMaxUnitsPerCity = GC.getADVANCED_START_MAX_UNITS_PER_CITY();
			if(iMaxUnitsPerCity >= 0)
			{
				if(pkUnitInfo->IsMilitarySupport() && getNumMilitaryUnits() >= iMaxUnitsPerCity * getNumCities())
				{
					return -1;
				}
			}

			if(NULL != pCity)
			{
				if(!pCity->canTrain(eUnit))
				{
					return -1;
				}
			}
			else
			{
				if(!pPlot->canTrain(eUnit, false, false))
				{
					return -1;
				}
				if(!pPlot->isValidMovePlot(GetID()))
				{
					return -1;
				}
			}
		}
		// Must be this unit at plot in order to remove
		else
		{
			bool bUnitFound = false;

			IDInfo* pUnitNode = pPlot->headUnitNode();
			while(pUnitNode != NULL)
			{
				CvUnit* pLoopUnit = ::getUnit(*pUnitNode);
				pUnitNode = pPlot->nextUnitNode(pUnitNode);

				if(NULL != pLoopUnit && pLoopUnit->getUnitType() == eUnit)
				{
					bUnitFound = true;
				}
			}

			if(!bUnitFound)
			{
				return -1;
			}
		}
	}

	return iCost;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing a City
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartCityCost(bool bAdd, CvPlot* pPlot)
{
	int iNumCities = getNumCities();

	int iCost = getNewCityProductionValue();

	if(iCost < 0)
	{
		return -1;
	}

	// Valid plot?
	if(pPlot != NULL)
	{
		// Need valid plot to found on if adding
		if(bAdd)
		{
			if(!canFound(pPlot->getX(), pPlot->getY()))
			{
				return -1;
			}
		}
		// Need your own city present to remove
		else
		{
			if(pPlot->isCity())
			{
				if(pPlot->getPlotCity()->getOwner() != GetID())
				{
					return -1;
				}
			}
			else
			{
				return -1;
			}
		}

		// Is there a distance limit on how far a city can be placed from a player's start/another city?
		if(GC.getADVANCED_START_CITY_PLACEMENT_MAX_RANGE() > 0)
		{
			PlayerTypes eClosestPlayer = NO_PLAYER;
			int iClosestDistance = INT_MAX;

			for(int iPlayer = 0; iPlayer < MAX_CIV_PLAYERS; ++iPlayer)
			{
				CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iPlayer);

				if(kPlayer.isAlive())
				{
					CvPlot* pStartingPlot = kPlayer.getStartingPlot();

					if(NULL != pStartingPlot)
					{
						int iDistance = ::plotDistance(pPlot->getX(), pPlot->getY(), pStartingPlot->getX(), pStartingPlot->getY());
						if(iDistance <= GC.getADVANCED_START_CITY_PLACEMENT_MAX_RANGE())
						{
							if(iDistance < iClosestDistance || (iDistance == iClosestDistance && getTeam() != kPlayer.getTeam()))
							{
								iClosestDistance = iDistance;
								eClosestPlayer = kPlayer.GetID();
							}
						}
					}
				}
			}

			if(NO_PLAYER == eClosestPlayer || GET_PLAYER(eClosestPlayer).getTeam() != getTeam())
			{
				return -1;
			}
			//Only allow founding a city at someone elses start point if
			//We have no cities and they have no cities.
			if((GetID() != eClosestPlayer) && ((getNumCities() > 0) || (GET_PLAYER(eClosestPlayer).getNumCities() > 0)))
			{
				return -1;
			}
		}
	}

	// Increase cost if the XML defines that additional units will cost more
	if(0 != GC.getADVANCED_START_CITY_COST_INCREASE())
	{
		if(!bAdd)
		{
			--iNumCities;
		}

		if(iNumCities > 0)
		{
			iCost *= 100 + GC.getADVANCED_START_CITY_COST_INCREASE() * iNumCities;
			iCost /= 100;
		}
	}

	return iCost;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing Population
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartPopCost(bool bAdd, CvCity* pCity)
{
	if(0 == getNumCities())
	{
		return -1;
	}

	int iCost = (getGrowthThreshold(1) * GC.getADVANCED_START_POPULATION_COST()) / 100;

	if(NULL != pCity)
	{
		if(pCity->getOwner() != GetID())
		{
			return -1;
		}

		int iPopulation = pCity->getPopulation();

		// Need to have Population to remove it
		if(!bAdd)
		{
			--iPopulation;

			if(iPopulation < GC.getINITIAL_CITY_POPULATION() + GC.getGame().getStartEraInfo().getFreePopulation())
			{
				return -1;
			}
		}

		iCost = (getGrowthThreshold(iPopulation) * GC.getADVANCED_START_POPULATION_COST()) / 100;

		// Increase cost if the XML defines that additional Pop will cost more
		if(0 != GC.getADVANCED_START_POPULATION_COST_INCREASE())
		{
			--iPopulation;

			if(iPopulation > 0)
			{
				iCost *= 100 + GC.getADVANCED_START_POPULATION_COST_INCREASE() * iPopulation;
				iCost /= 100;
			}
		}
	}

	return iCost;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing a Building from a city
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartBuildingCost(BuildingTypes eBuilding, bool bAdd, CvCity* pCity)
{
	if(0 == getNumCities())
	{
		return -1;
	}

	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if(pkBuildingInfo == NULL)
	{
		return -1;
	}

	int iCost = getProductionNeeded(eBuilding);

	if(iCost < 0)
	{
		return -1;
	}

	if(pkBuildingInfo->GetFreeStartEra() != NO_ERA && GC.getGame().getStartEra() >=  pkBuildingInfo->GetFreeStartEra())
	{
		// you get this building for free
		return -1;
	}

	if(NULL == pCity)
	{
		if(bAdd)
		{
			bool bValid = false;
			int iLoop;
			for(CvCity* pLoopCity = firstCity(&iLoop); NULL != pLoopCity; pLoopCity = nextCity(&iLoop))
			{
				if(pLoopCity->canConstruct(eBuilding))
				{
					bValid = true;
					break;
				}
			}

			if(!bValid)
			{
				return -1;
			}
		}
	}
	if(NULL != pCity)
	{
		if(pCity->getOwner() != GetID())
		{
			return -1;
		}

		iCost *= 100;
		iCost /= std::max(1, 100 + pCity->getProductionModifier(eBuilding));

		if(bAdd)
		{
			if(!pCity->canConstruct(eBuilding, true, false, false))
			{
				return -1;
			}
		}
		else
		{
			if(pCity->GetCityBuildings()->GetNumRealBuilding(eBuilding) <= 0)
			{
				return -1;
			}

			// Check other buildings in this city and make sure none of them require this one

			// Loop through Buildings to see which are present
			for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
			{
				const BuildingTypes eBuildingLoop = static_cast<BuildingTypes>(iBuildingLoop);
				CvBuildingEntry* pkBuildingLoopInfo = GC.getBuildingInfo(eBuildingLoop);
				if(pkBuildingLoopInfo)
				{
					if(pCity->GetCityBuildings()->GetNumBuilding(eBuildingLoop) > 0)
					{
						// Loop through present Building's requirements
						for(int iBuildingClassPrereqLoop = 0; iBuildingClassPrereqLoop < GC.getNumBuildingClassInfos(); iBuildingClassPrereqLoop++)
						{
							const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iBuildingClassPrereqLoop);
							CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
							if(pkBuildingClassInfo)
							{
								if(pkBuildingLoopInfo->IsBuildingClassNeededInCity(iBuildingClassPrereqLoop))
								{
									if((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(iBuildingClassPrereqLoop)) == eBuilding)
									{
										return -1;
									}
								}
#if defined(MOD_BALANCE_CORE)
								// Does this city have prereq buildings?
								if(MOD_BALANCE_CORE && pkBuildingLoopInfo->IsBuildingClassNeededAnywhere(iBuildingClassPrereqLoop))
								{
									int iNumBuildings = 0;
									BuildingTypes ePrereqBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(iBuildingClassPrereqLoop)));

									if(ePrereqBuilding != NO_BUILDING)
									{
										CvCity* pLoopCity;
										int iLoop;
										for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
										{
											if(pLoopCity->GetCityBuildings()->GetNumBuilding(ePrereqBuilding) > 0)
											{
												iNumBuildings++;
											}
										}
										if(iNumBuildings == 0)
										{
											return -1;
										}
									}
								}
								// Does this city have prereq buildings?
								if(MOD_BALANCE_CORE && pkBuildingLoopInfo->IsBuildingClassNeededNowhere(iBuildingClassPrereqLoop))
								{
									BuildingTypes ePrereqBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(iBuildingClassPrereqLoop)));

									if(ePrereqBuilding != NO_BUILDING)
									{
										CvCity* pLoopCity;
										int iLoop;
										for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
										{
											if(pLoopCity->GetCityBuildings()->GetNumBuilding(ePrereqBuilding) > 0)
											{
												return -1;
											}
										}
									}
								}
#endif
							}
						}
					}
				}
			}
		}
	}

	return iCost;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing Route
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartRouteCost(RouteTypes eRoute, bool bAdd, CvPlot* pPlot)
{
	if(0 == getNumCities())
	{
		return -1;
	}

	if(eRoute == NO_ROUTE)
	{
		return -1;
	}

	CvRouteInfo* pkRouteInfo = GC.getRouteInfo(eRoute);
	if(pkRouteInfo == NULL)
	{
		return -1;
	}

	int iCost = pkRouteInfo->getAdvancedStartCost();

	// This denotes cities may not be purchased through Advanced Start
	if(iCost < 0)
	{
		return -1;
	}

	iCost *= GC.getGame().getGameSpeedInfo().getBuildPercent();
	iCost /= 100;

	// No invalid plots!
	if(pPlot != NULL)
	{
		if(pPlot->isCity())
		{
			return -1;
		}

		if(bAdd)
		{
			if(!pPlot->isValidMovePlot(GetID()) || pPlot->isWater())
			{
				return -1;
			}
			// Can't place twice
			if(pPlot->getRouteType() == eRoute)
			{
				return -1;
			}
		}
		else
		{
			// Need Route to remove it
			if(pPlot->getRouteType() != eRoute)
			{
				return -1;
			}
		}

		// Must be owned by me
		if(pPlot->getOwner() != GetID())
		{
			return -1;
		}
	}

	// Tech requirement
	for(int iBuildLoop = 0; iBuildLoop < GC.getNumBuildInfos(); iBuildLoop++)
	{
		const BuildTypes eBuild = static_cast<BuildTypes>(iBuildLoop);
		CvBuildInfo* pkBuildInfo = GC.getBuildInfo(eBuild);
		if(pkBuildInfo)
		{
			if(pkBuildInfo->getRoute() == eRoute)
			{
				if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkBuildInfo->getTechPrereq())))
				{
					return -1;
				}
#if defined(MOD_BALANCE_CORE)
				else if(MOD_BALANCE_CORE && pkBuildInfo->getTechObsolete() != NO_TECH && (GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkBuildInfo->getTechObsolete())))
				{
					return -1;
				}
#endif
			}
		}
	}

	return iCost;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing Improvement
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartImprovementCost(ImprovementTypes eImprovement, bool bAdd, CvPlot* pPlot)
{
	if(eImprovement == NO_IMPROVEMENT)
	{
		return -1;
	}

	if(0 == getNumCities())
	{
		return -1;
	}

	int iCost = 0; //GC.getImprovementInfo(eImprovement)->GetAdvancedStartCost();

	// This denotes cities may not be purchased through Advanced Start
	if(iCost < 0)
	{
		return -1;
	}

	iCost *= GC.getGame().getGameSpeedInfo().getBuildPercent();
	iCost /= 100;

	// Can this Improvement be on our plot?
	if(pPlot != NULL)
	{
		if(bAdd)
		{
			// Valid Plot
			if(!pPlot->canHaveImprovement(eImprovement, GetID(), false))
			{
				return -1;
			}

			bool bValid = false;

			for(int iI = 0; iI < GC.getNumBuildInfos(); ++iI)
			{
				CvBuildInfo* pkBuildInfo = GC.getBuildInfo((BuildTypes) iI);
				if(!pkBuildInfo)
				{
					continue;
				}
				ImprovementTypes eLoopImprovement = ((ImprovementTypes)(pkBuildInfo->getImprovement()));

				if(eImprovement == eLoopImprovement && canBuild(pPlot, (BuildTypes)iI))
				{
					bValid = true;

					FeatureTypes eFeature = pPlot->getFeatureType();
					if(NO_FEATURE != eFeature && pkBuildInfo->isFeatureRemove(eFeature))
					{
						iCost += GC.getFeatureInfo(eFeature)->getAdvancedStartRemoveCost();
					}

					break;
				}
			}

			if(!bValid)
			{
				return -1;
			}

			// Can't place twice
			if(pPlot->getImprovementType() == eImprovement)
			{
				return -1;
			}
		}
		else
		{
			// Need this improvement in order to remove it
			if(pPlot->getImprovementType() != eImprovement)
			{
				return -1;
			}
		}

		// Must be owned by me
		if(pPlot->getOwner() != GetID())
		{
			return -1;
		}
	}

	// Tech requirement
	for(int iBuildLoop = 0; iBuildLoop < GC.getNumBuildInfos(); iBuildLoop++)
	{
		CvBuildInfo* pkBuildInfo = GC.getBuildInfo((BuildTypes) iBuildLoop);
		if(!pkBuildInfo)
		{
			continue;
		}

		if(pkBuildInfo->getImprovement() == eImprovement)
		{
			if(!(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkBuildInfo->getTechPrereq())))
			{
				return -1;
			}
#if defined(MOD_BALANCE_CORE)
			else if(MOD_BALANCE_CORE && pkBuildInfo->getTechObsolete() != NO_TECH && (GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkBuildInfo->getTechObsolete())))
			{
				return -1;
			}
#endif
		}
	}

	return iCost;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing Tech
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartTechCost(TechTypes eTech, bool bAdd)
{
	if(eTech == NO_TECH)
	{
		return -1;
	}

	if(0 == getNumCities())
	{
		return -1;
	}

	int iCost = (GET_TEAM(getTeam()).GetTeamTechs()->GetResearchCost(eTech) * GC.getTechInfo(eTech)->GetAdvancedStartCost()) / 100;
	if(iCost < 0)
	{
		return -1;
	}

	if(bAdd)
	{
		if(!GetPlayerTechs()->CanResearch(eTech, false))
		{
			return -1;
		}
	}
	else if(!bAdd)
	{
		if(!GET_TEAM(getTeam()).GetTeamTechs()->HasTech(eTech))
		{
			return -1;
		}

		// Search through all techs to see if any of the currently owned ones requires this tech
		for(int iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)
		{
			TechTypes eTechLoop = (TechTypes) iTechLoop;

			if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech(eTechLoop))
			{
				int iPrereqLoop;

				// Or Prereqs
				for(iPrereqLoop = 0; iPrereqLoop < GC.getNUM_OR_TECH_PREREQS(); iPrereqLoop++)
				{
					if(GC.getTechInfo(eTechLoop)->GetPrereqOrTechs(iPrereqLoop) == eTech)
					{
						return -1;
					}
				}

				// And Prereqs
				for(iPrereqLoop = 0; iPrereqLoop < GC.getNUM_AND_TECH_PREREQS(); iPrereqLoop++)
				{
					if(GC.getTechInfo(eTechLoop)->GetPrereqAndTechs(iPrereqLoop) == eTech)
					{
						return -1;
					}
				}
			}
		}

		// If player has placed anything on the map which uses this tech then you cannot remove it
		int iLoop;

		// Units
		CvUnit* pLoopUnit;
		for(pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		{
			if(pLoopUnit->getUnitInfo().GetPrereqAndTech() == eTech)
			{
				return -1;
			}

			for(int iI = 0; iI < GC.getNUM_UNIT_AND_TECH_PREREQS(); iI++)
			{
				if(pLoopUnit->getUnitInfo().GetPrereqAndTechs(iI) == eTech)
				{
					return -1;
				}
			}
		}

		// Cities
		CvCity* pLoopCity;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			// All Buildings
			for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
			{
				const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
				CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
				if(pkBuildingInfo)
				{
					if(pLoopCity->GetCityBuildings()->GetNumRealBuilding(eBuilding) > 0)
					{
						if(pkBuildingInfo->GetPrereqAndTech() == eTech)
						{
							return -1;
						}

						for(int iI = 0; iI < GC.getNUM_BUILDING_AND_TECH_PREREQS(); iI++)
						{
							if(pkBuildingInfo->GetPrereqAndTechs(iI) == eTech)
							{
								return -1;
							}
						}
					}
				}
			}
		}

	}

	return iCost;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Adding or removing Visibility
/////////////////////////////////////////////////////////////////////////////////////////////

int CvPlayer::getAdvancedStartVisibilityCost(bool bAdd, CvPlot* pPlot)
{
	if(0 == getNumCities())
	{
		return -1;
	}

	int iNumVisiblePlots = 0;
	int iCost = GC.getADVANCED_START_VISIBILITY_COST();

	// This denotes Visibility may not be purchased through Advanced Start
	if(iCost == -1)
	{
		return -1;
	}

	// Valid Plot?
	if(pPlot != NULL)
	{
		if(bAdd)
		{
			if(pPlot->isRevealed(getTeam()))
			{
				return -1;
			}
			if(!pPlot->isAdjacentRevealed(getTeam()))
			{
				return -1;
			}
		}
		else
		{
			if(!pPlot->isRevealed(getTeam()))
			{
				return -1;
			}
		}
	}

	// Increase cost if the XML defines that additional units will cost more
	if(0 != GC.getADVANCED_START_VISIBILITY_COST_INCREASE())
	{
		const int nPlots = GC.getMap().numPlots();
		for(int iPlotLoop = 0; iPlotLoop < nPlots; iPlotLoop++)
		{
			CvPlot* pMapPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);

			if(pMapPlot->isRevealed(getTeam()))
			{
				++iNumVisiblePlots;
			}
		}

		if(!bAdd)
		{
			--iNumVisiblePlots;
		}

		if(iNumVisiblePlots > 0)
		{
			iCost *= 100 + GC.getADVANCED_START_VISIBILITY_COST_INCREASE() * iNumVisiblePlots;
			iCost /= 100;
		}
	}

	return iCost;
}

//	--------------------------------------------------------------------------------
void CvPlayer::doWarnings()
{
	if(m_eID == GC.getGame().getActivePlayer())
	{
		//update enemy units close to your territory
		int iMaxCount = range(((getNumCities() + 4) / 7), 2, 5);
		for(int iI = 0; iI < GC.getMap().numPlots(); iI++)
		{
			if(iMaxCount == 0)
			{
				break;
			}

			CvPlot* pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

			if(pLoopPlot->isAdjacentPlayer(GetID()))
			{
				if(!(pLoopPlot->isCity()))
				{
					if(pLoopPlot->isVisible(getTeam()))
					{
						CvUnit* pUnit = pLoopPlot->getVisibleEnemyDefender(GetID());
						if(pUnit != NULL)
						{
							CvCity* pNearestCity = GC.getMap().findCity(pLoopPlot->getX(), pLoopPlot->getY(), GetID(), NO_TEAM, !(pLoopPlot->isWater()));

							if(pNearestCity != NULL)
							{
								CvString message = GetLocalizedText("TXT_KEY_MISC_ENEMY_TROOPS_SPOTTED", pNearestCity->getNameKey());
								GC.GetEngineUserInterface()->AddPlotMessage(0, pLoopPlot->GetPlotIndex(), GetID(), true, GC.getEVENT_MESSAGE_TIME(), message);

								iMaxCount--;
							}
						}
					}
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::processPolicies(PolicyTypes ePolicy, int iChange)
{
	int iI, iJ;

	CvPolicyEntry* pPolicy = GC.getPolicyInfo(ePolicy);
	if(pPolicy == NULL)
		return;

#if defined(MOD_TRAITS_OTHER_PREREQS)
	if (MOD_TRAITS_OTHER_PREREQS) {
		GetPlayerTraits()->InitPlayerTraits();
	}
#endif

	const CvPolicyEntry& kPolicy = (*pPolicy);

	ChangeCulturePerWonder(pPolicy->GetCulturePerWonder() * iChange);
	ChangeCultureWonderMultiplier(pPolicy->GetCultureWonderMultiplier() * iChange);
	ChangeCulturePerTechResearched(pPolicy->GetCulturePerTechResearched() * iChange);
	ChangeGoldenAgeMeterMod(pPolicy->GetGoldenAgeMeterMod() * iChange);
	changeGoldenAgeModifier(pPolicy->GetGoldenAgeDurationMod() * iChange);
	changeWorkerSpeedModifier(pPolicy->GetWorkerSpeedModifier() * iChange);
	changeImprovementCostModifier(pPolicy->GetImprovementCostModifier() * iChange);
	changeImprovementUpgradeRateModifier(pPolicy->GetImprovementUpgradeRateModifier() * iChange);
	changeSpecialistProductionModifier(pPolicy->GetSpecialistProductionModifier() * iChange);
	changeMilitaryProductionModifier(pPolicy->GetMilitaryProductionModifier() * iChange);
	changeBaseFreeUnits(pPolicy->GetBaseFreeUnits() * iChange);
	ChangeHappinessPerGarrisonedUnit(pPolicy->GetHappinessPerGarrisonedUnit() * iChange);
	ChangeHappinessPerTradeRoute(pPolicy->GetHappinessPerTradeRoute() * iChange);
	ChangeHappinessPerXPopulation(pPolicy->GetHappinessPerXPopulation() * iChange);
#if defined(MOD_BALANCE_CORE_POLICIES)
	ChangeGreatGeneralCombatBonus(pPolicy->GetGreatGeneralExtraBonus() * iChange);
	ChangeExtraSupplyPerPopulation(pPolicy->GetExtraSupplyPerPopulation() * iChange);
	ChangeCSAlliesLowersPolicyNeedWonders(pPolicy->GetXCSAlliesLowersPolicyNeedWonders() * iChange);
	ChangeHappinessPerXPopulationGlobal(pPolicy->GetHappinessPerXPopulationGlobal() * iChange);
	ChangeIdeologyPoint(pPolicy->GetIdeologyPoint() * iChange);
	ChangeNoXPLossUnitPurchase(pPolicy->IsNoXPLossUnitPurchase() * iChange);
	ChangeEventTourism(pPolicy->GetEventTourism() * iChange);
	ChangeEventTourismCS(pPolicy->GetEventTourismCS() * iChange);
	ChangeMonopolyModFlat(pPolicy->GetMonopolyModFlat() * iChange);
	ChangeMonopolyModPercent(pPolicy->GetMonopolyModPercent() * iChange);
	ChangeTRVisionBoost(pPolicy->GetTRVisionBoost() * iChange);
	ChangeTRSpeedBoost(pPolicy->GetTRSpeedBoost() * iChange);
	ChangeExtraHappinessPerXPoliciesFromPolicies(pPolicy->GetHappinessPerXPolicies() * iChange);
	ChangeHappinessPerXGreatWorks(pPolicy->GetHappinessPerXGreatWorks() * iChange);
	ChangePositiveWarScoreTourismMod(pPolicy->GetPositiveWarScoreTourismMod() * iChange);

	ChangeIsNoCSDecayAtWar(pPolicy->IsNoCSDecayAtWar() * iChange);
	ChangeCanBullyFriendlyCS(pPolicy->CanBullyFriendlyCS() * iChange);
	ChangeBullyGlobalCSReduction(pPolicy->GetBullyGlobalCSReduction() * iChange);
#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
	ChangeIsVassalsNoRebel(pPolicy->IsVassalsNoRebel() * iChange);
	ChangeVassalCSBonusModifier(pPolicy->GetVassalCSBonusModifier() * iChange);
#endif


	if (GetExtraHappinessPerXPolicies() != 0)
	{
		DoUpdateHappinessFromBuildings();
	}

	if(pPolicy->IsCorporationOfficesAsFranchises())
	{
		GetCorporations()->SetCorporationOfficesAsFranchises(true);
		GetCorporations()->RecalculateNumFranchises();
	}
	if(pPolicy->IsCorporationRandomForeignFranchise())
	{
		GetCorporations()->SetCorporationRandomForeignFranchise(true);
		GetCorporations()->RecalculateNumFranchises();
	}
	if(pPolicy->IsCorporationFreeFranchiseAbovePopular())
	{
		GetCorporations()->SetCorporationFreeFranchiseAbovePopular(true);
		GetCorporations()->RecalculateNumFranchises();
	}
	if (pPolicy->GetAdditionalNumFranchisesMod() > 0)
	{
		GetCorporations()->ChangeAdditionalNumFranchisesMod(pPolicy->GetAdditionalNumFranchisesMod() * iChange);
	}
	if(pPolicy->IsUpgradeCSVassalTerritory())
	{
		ChangeUpgradeCSVassalTerritory(pPolicy->IsUpgradeCSVassalTerritory() * iChange);
	}
	if(pPolicy->GetArchaeologicalDigTourism() != 0)
	{
		ChangeArchaeologicalDigTourism(pPolicy->GetArchaeologicalDigTourism() * iChange);
	}
	if(pPolicy->GetGoldenAgeTourism() != 0)
	{
		ChangeGoldenAgeTourism(pPolicy->GetGoldenAgeTourism() * iChange);
	}
	if (pPolicy->GetExtraCultureandScienceTradeRoutes() != 0)
	{
		ChangeExtraCultureandScienceTradeRoutes(pPolicy->GetExtraCultureandScienceTradeRoutes() * iChange);
	}
	ChangeRazingSpeedBonus(pPolicy->GetRazingSpeedBonus() * iChange);
	ChangeNoPartisans(pPolicy->IsNoPartisans() * iChange);

	if(pPolicy->GetTradeRouteLandDistanceModifier() != 0)
	{
		changeTradeRouteLandDistanceModifier(pPolicy->GetTradeRouteLandDistanceModifier() * iChange);
	}
	if(pPolicy->GetTradeRouteSeaDistanceModifier() != 0)
	{
		changeTradeRouteSeaDistanceModifier(pPolicy->GetTradeRouteSeaDistanceModifier() * iChange);
	}
	if(pPolicy->GetEspionageModifier() != 0)
	{
		ChangeEspionageModifier(pPolicy->GetEspionageModifier() * iChange);
	}
	ChangeGreatScientistBeakerMod(pPolicy->GetGreatScientistBeakerModifier() * iChange);
	ChangeGreatEngineerHurryMod(pPolicy->GetGreatEngineerHurryModifier() * iChange);
	ChangeTechCostXCitiesModifier(pPolicy->GetTechCostXCitiesMod() * iChange);
	ChangeTourismCostXCitiesMod(pPolicy->GetTourismCostXCitiesMod() * iChange);
#endif
	ChangeExtraHappinessPerLuxury(pPolicy->GetExtraHappinessPerLuxury() * iChange);
	ChangeUnhappinessFromUnitsMod(pPolicy->GetUnhappinessFromUnitsMod() * iChange);
	ChangeUnhappinessMod(pPolicy->GetUnhappinessMod() * iChange);
	ChangeCityCountUnhappinessMod(pPolicy->GetCityCountUnhappinessMod() * iChange);
	ChangeOccupiedPopulationUnhappinessMod(pPolicy->GetOccupiedPopulationUnhappinessMod() * iChange);
	ChangeCapitalUnhappinessMod(pPolicy->GetCapitalUnhappinessMod() * iChange);
	ChangeWoundedUnitDamageMod(pPolicy->GetWoundedUnitDamageMod() * iChange);
	ChangeUnitUpgradeCostMod(pPolicy->GetUnitUpgradeCostMod() * iChange);
	ChangeBarbarianCombatBonus(pPolicy->GetBarbarianCombatBonus() * iChange);
	ChangeAlwaysSeeBarbCampsCount(pPolicy->IsAlwaysSeeBarbCamps() * iChange);
	ChangeMaxNumBuilders(pPolicy->GetNumExtraBuilders() * iChange);
	ChangePlotGoldCostMod(pPolicy->GetPlotGoldCostMod() * iChange);
#if defined(MOD_TRAITS_CITY_WORKING) || defined(MOD_BUILDINGS_CITY_WORKING) || defined(MOD_POLICIES_CITY_WORKING) || defined(MOD_TECHS_CITY_WORKING)
	ChangeCityWorkingChange(pPolicy->GetCityWorkingChange() * iChange);
#endif
	ChangePlotCultureCostModifier(pPolicy->GetPlotCultureCostModifier() * iChange);
	ChangePlotCultureExponentModifier(pPolicy->GetPlotCultureExponentModifier() * iChange);
	ChangeNumCitiesPolicyCostDiscount(pPolicy->GetNumCitiesPolicyCostDiscount() * iChange);
	ChangeGarrisonFreeMaintenanceCount(pPolicy->IsGarrisonFreeMaintenance() * iChange);
	ChangeGarrisonedCityRangeStrikeModifier(pPolicy->GetGarrisonedCityRangeStrikeModifier() * iChange);
	ChangeUnitPurchaseCostModifier(pPolicy->GetUnitPurchaseCostModifier() * iChange);
	GetTreasury()->ChangeCityConnectionTradeRouteGoldModifier(pPolicy->GetCityConnectionTradeRouteGoldModifier() * iChange);
	changeGoldPerUnit(pPolicy->GetGoldPerUnit() * iChange);
	changeGoldPerMilitaryUnit(pPolicy->GetGoldPerMilitaryUnit() * iChange);
	ChangeCityStrengthMod(pPolicy->GetCityStrengthMod() * iChange);
	ChangeCityGrowthMod(pPolicy->GetCityGrowthMod() * iChange);
	ChangeCapitalGrowthMod(pPolicy->GetCapitalGrowthMod() * iChange);
	changeSettlerProductionModifier(pPolicy->GetSettlerProductionModifier() * iChange);
	changeCapitalSettlerProductionModifier(pPolicy->GetCapitalSettlerProductionModifier() * iChange);
	ChangeImprovementGoldMaintenanceMod(pPolicy->GetImprovementGoldMaintenanceMod() * iChange);
#if defined(MOD_CIV6_WORKER)
	ChangeRouteBuilderCostMod(pPolicy->GetRouteBuilderCostMod() * iChange);
#endif
	ChangeBuildingGoldMaintenanceMod(pPolicy->GetBuildingGoldMaintenanceMod() * iChange);
	ChangeUnitGoldMaintenanceMod(pPolicy->GetUnitGoldMaintenanceMod() * iChange);
	ChangeUnitSupplyMod(pPolicy->GetUnitSupplyMod() * iChange);
	changeHappyPerMilitaryUnit(pPolicy->GetHappyPerMilitaryUnit() * iChange);
	changeHappinessToCulture(pPolicy->GetHappinessToCulture() * iChange);
	changeHappinessToScience(pPolicy->GetHappinessToScience() * iChange);
	changeHalfSpecialistUnhappinessCount((pPolicy->IsHalfSpecialistUnhappiness()) ? iChange : 0);
	changeHalfSpecialistFoodCount((pPolicy->IsHalfSpecialistFood()) ? iChange : 0);
#if defined(MOD_BALANCE_CORE)
	changeHalfSpecialistFoodCapitalCount((pPolicy->IsHalfSpecialistFoodCapital()) ? iChange : 0);
#endif
	changeMilitaryFoodProductionCount((pPolicy->IsMilitaryFoodProduction()) ? iChange : 0);
	ChangeGoldenAgeCultureBonusDisabledCount((pPolicy->IsGoldenAgeCultureBonusDisabled()) ? iChange : 0);
	ChangeSecondReligionPantheonCount((pPolicy->IsSecondReligionPantheon()) ? iChange : 0);
	ChangeEnablesSSPartHurryCount((pPolicy->IsEnablesSSPartHurry()) ? iChange : 0);
	ChangeEnablesSSPartPurchaseCount((pPolicy->IsEnablesSSPartPurchase()) ? iChange : 0);
	changeMaxConscript(getWorldSizeMaxConscript(kPolicy) * iChange);
	changeExpModifier(pPolicy->GetExpModifier() * iChange);
	changeExpInBorderModifier(pPolicy->GetExpInBorderModifier() * iChange);
	changeMinorQuestFriendshipMod(pPolicy->GetMinorQuestFriendshipMod() * iChange);
	changeMinorGoldFriendshipMod(pPolicy->GetMinorGoldFriendshipMod() * iChange);
	ChangeMinorFriendshipAnchorMod(pPolicy->GetMinorFriendshipMinimum() * iChange);
	changeGetMinorFriendshipDecayMod(pPolicy->GetMinorFriendshipDecayMod() * iChange);
	ChangeMinorScienceAlliesCount(pPolicy->IsMinorScienceAllies() * iChange);
	ChangeMinorResourceBonusCount(pPolicy->IsMinorResourceBonus() * iChange);
	ChangeNewCityExtraPopulation(pPolicy->GetNewCityExtraPopulation() * iChange);
	ChangeFreeFoodBox(pPolicy->GetFreeFoodBox() * iChange);
	ChangeStrategicResourceMod(pPolicy->GetStrategicResourceMod() * iChange);
#if defined(MOD_BALANCE_CORE)
	if(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES_STRATEGIC && pPolicy->GetStrategicResourceMod() > 0)
	{
		for(int iLoop = 0; iLoop < GC.getNumResourceInfos(); iLoop++)
		{
			const ResourceTypes eResource = static_cast<ResourceTypes>(iLoop);
			CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
			if(pkResource && pkResource->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)
			{
				CheckForMonopoly(eResource);
			}
		}
	}
	for (iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
	{
		const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
		CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
		if (pkUnitClassInfo && pPolicy->GetUnitClassProductionModifiers(iI) != 0)
		{
			ChangeUnitClassProductionModifier(eUnitClass, (pPolicy->GetUnitClassProductionModifiers(iI) * iChange));
		}
	}
	
#endif
	ChangeAbleToAnnexCityStatesCount((pPolicy->IsAbleToAnnexCityStates()) ? iChange : 0);
	ChangeOnlyTradeSameIdeology((pPolicy->IsOnlyTradeSameIdeology()) ? iChange : 0);
	if (pPolicy->IsOnlyTradeSameIdeology())
	{
		for (int i = 0; i < MAX_CIV_PLAYERS; i++)
		{
			PlayerTypes eOtherPlayer = (PlayerTypes)i;
			if (eOtherPlayer != GetID() && GET_PLAYER(eOtherPlayer).isAlive() && !GET_PLAYER(eOtherPlayer).isMinorCiv())
			{
				if(GET_PLAYER(eOtherPlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE)
				{
					if (GET_PLAYER(eOtherPlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != GetPlayerPolicies()->GetLateGamePolicyTree())
					{
						GC.getGame().GetGameTrade()->CancelTradeBetweenTeams(GET_PLAYER(eOtherPlayer).getTeam(), getTeam());
					}
				}
			}
		}
	}
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	if(MOD_BALANCE_CORE_HAPPINESS)
	{
		ChangePovertyUnhappinessMod(pPolicy->GetPovertyHappinessChangePolicy() * iChange);
		ChangeDefenseUnhappinessMod(pPolicy->GetDefenseHappinessChangePolicy() * iChange);
		ChangeUnculturedUnhappinessMod(pPolicy->GetUnculturedHappinessChangePolicy() * iChange);
		ChangeIlliteracyUnhappinessMod(pPolicy->GetIlliteracyHappinessChangePolicy() * iChange);
		ChangeMinorityUnhappinessMod(pPolicy->GetMinorityHappinessChangePolicy() * iChange);
		ChangePovertyUnhappinessModCapital(pPolicy->GetPovertyHappinessChangePolicyCapital() * iChange);
		ChangeDefenseUnhappinessModCapital(pPolicy->GetDefenseHappinessChangePolicyCapital() * iChange);
		ChangeUnculturedUnhappinessModCapital(pPolicy->GetUnculturedHappinessChangePolicyCapital() * iChange);
		ChangeIlliteracyUnhappinessModCapital(pPolicy->GetIlliteracyHappinessChangePolicyCapital() * iChange);
		ChangeMinorityUnhappinessModCapital(pPolicy->GetMinorityHappinessChangePolicyCapital() * iChange);
		ChangePuppetUnhappinessMod(pPolicy->GetPuppetUnhappinessMod() * iChange);
		ChangeNoUnhappfromXSpecialists(pPolicy->GetNoUnhappfromXSpecialists() * iChange);
		ChangeHappfromXSpecialists(pPolicy->GetHappfromXSpecialists() * iChange);
		ChangeNoUnhappfromXSpecialistsCapital(pPolicy->GetNoUnhappfromXSpecialistsCapital() * iChange);
		ChangeSpecialistFoodChange(pPolicy->GetSpecialistFoodChange() * iChange);
		ChangeWarWearinessModifier(pPolicy->GetWarWearinessModifier() * iChange);
		ChangeWarScoreModifier(pPolicy->GetWarScoreModifier() * iChange);

	}
#endif
#if defined(MOD_BALANCE_CORE_POLICIES)
	if(MOD_BALANCE_CORE_POLICIES)
	{
		if (pPolicy->GetDefenseBoost() != 0)
		{
			int iLoop;
			CvCity* pLoopCity;
			for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				pLoopCity->updateStrengthValue();
			}
		}
		for (iI = 0; iI < GC.getNumResourceInfos(); iI++)
		{
			changeResourceFromCSAlliances((ResourceTypes)iI, (pPolicy->GetResourceFromCSAlly(iI) * iChange));
		}
		ChangeNoUnhappinessExpansion(pPolicy->GetNoUnhappinessExpansion() * iChange);
		ChangeNoUnhappyIsolation(pPolicy->GetNoUnhappyIsolation() * iChange);
		ChangeDoubleBorderGA(pPolicy->GetDoubleBorderGA() * iChange);
		changeGarrisonsOccupiedUnhapppinessMod(pPolicy->GetGarrisonsOccupiedUnhapppinessMod() * iChange);
		changeTradeReligionModifier(pPolicy->GetTradeReligionModifier() * iChange);
		changeFreeWCVotes(pPolicy->GetFreeWCVotes() * iChange);
		if (pPolicy->GetIncreasedQuestInfluence() != 0)
		{
			ChangeIncreasedQuestInfluence(pPolicy->GetIncreasedQuestInfluence() * iChange);
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
			{
				PlayerTypes ePlayer = (PlayerTypes)iPlayerLoop;
				CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);
				if (ePlayer != NO_PLAYER && kPlayer.isMinorCiv() && kPlayer.isAlive())
				{
					kPlayer.GetMinorCivAI()->RecalculateRewards(GetID());				
				}
			}
		}
		changeCultureBombBoost(pPolicy->GetCultureBombBoost() * iChange);
		changePuppetProdMod(pPolicy->GetPuppetProdMod() * iChange);
		changeOccupiedProdMod(pPolicy->GetOccupiedProdMod() * iChange);
		changeGoldInternalTrade(pPolicy->GetInternalTradeGold() * iChange);
		changeInfluenceGPExpend(pPolicy->GetInfluenceGPExpend() * iChange);
		changeFreeTradeRoute(pPolicy->GetFreeTradeRoute() * iChange);
		changeFreeSpy(pPolicy->GetFreeSpy() * iChange);

		changeReligionDistance(pPolicy->GetReligionDistance() * iChange);
		changePressureMod(pPolicy->GetPressureMod() * iChange);

		changeCityStateCombatModifier(pPolicy->GetCityStateCombatModifier() * iChange);

		if(GetFreeSpy() > 0)
		{
			CvPlayerEspionage* pEspionage = GetEspionage();
			CvAssertMsg(pEspionage, "pEspionage is null! What's up with that?!");
			if(pEspionage)
			{
				int iNumSpies = GetFreeSpy();
#if defined(MOD_BALANCE_CORE_SPIES)
				if (MOD_BALANCE_CORE_SPIES) {
					//Optional: Spies scaled for the number of City-States in the game.
					int iNumMinor = ((GC.getGame().GetNumMinorCivsEver() * /*15*/ GC.getBALANCE_SPY_TO_MINOR_RATIO()) / 100);
					if(iNumMinor > 1)
					{
						iNumSpies += iNumMinor;
					}
				}
#endif
				for(int i = 0; i < iNumSpies; i++)
				{
					pEspionage->CreateSpy();
				}
				changeFreeSpy(GetFreeSpy() * -1);
			}
		}
		
		int iLoop;
		CvCity* pLoopCity;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pPolicy->GetFreePopulation() > 0)
			{
				pLoopCity->changePopulation(pPolicy->GetFreePopulation());
			}
			if (pPolicy->GetFreePopulationCapital() > 0 && pLoopCity->isCapital())
			{
				pLoopCity->changePopulation(pPolicy->GetFreePopulationCapital());
			}
		}
		changeExtraMoves(pPolicy->GetExtraMoves() * iChange);

		if(pPolicy->GetXPopulationConscription() > 0)
		{
			changeXPopulationConscription(pPolicy->GetXPopulationConscription() * iChange);
			int iLoop;
			for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				if(pLoopCity == NULL)
				{
					continue;
				}
				if(pLoopCity->getPopulation() < GetXPopulationConscription())
				{
					continue;
				}
				if(pLoopCity->IsRazing())
				{
					continue;
				}
				if (GetNumUnitsOutOfSupply() > 0)
				{
					continue;
				}
				DoXPopulationConscription(pLoopCity);
			}
		}
	}
#endif
#if defined(MOD_BALANCE_CORE_BUILDING_INVESTMENTS)
	changeInvestmentModifier(pPolicy->GetInvestmentModifier() * iChange);

	changeMissionInfluenceModifier(pPolicy->GetMissionInfluenceModifier() * iChange);
	changeHappinessPerActiveTradeRoute(pPolicy->GetHappinessPerActiveTradeRoute() * iChange);
	changeCSResourcesCountMonopolies(pPolicy->IsCSResourcesForMonopolies() ? iChange : 0);

	changeNeedsModifierFromAirUnits(pPolicy->GetNeedsModifierFromAirUnits() * iChange);
	changeFlatDefenseFromAirUnits(pPolicy->GetFlatDefenseFromAirUnits() * iChange);
	changePuppetYieldPenaltyMod(pPolicy->GetPuppetYieldPenaltyMod() * iChange);
	changeConquestPerEraBuildingProductionMod(pPolicy->GetConquestPerEraBuildingProductionMod() * iChange);
	changeAdmiralLuxuryBonus(pPolicy->GetAdmiralLuxuryBonus() * iChange);

#endif
	if(pPolicy->IsOneShot())
	{
		if(m_pPlayerPolicies->HasOneShotPolicyFired(ePolicy))
		{
			return;
		}
		else
		{
			m_pPlayerPolicies->SetOneShotPolicyFired(ePolicy,true);
		}
	}

	GetPlayerPolicies()->ChangeNumExtraBranches(pPolicy->GetNumExtraBranches() * iChange);

	ChangeAllFeatureProduction(pPolicy->GetAllFeatureProduction());

	int iMod;
	YieldTypes eYield;

	for(iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		eYield = (YieldTypes) iI;

#if defined(MOD_BALANCE_CORE_POLICIES)
		changeYieldFromBirth(eYield, (pPolicy->GetYieldFromBirth(iI) * iChange));
		changeYieldFromBirthCapital(eYield, (pPolicy->GetYieldFromBirthCapital(iI) * iChange));

		changeYieldFromConstruction(eYield, (pPolicy->GetYieldFromConstruction(iI) * iChange));
		changeYieldFromwonderConstruction(eYield, (pPolicy->GetYieldFromWonderConstruction(iI) * iChange));

		changeYieldFromTech(eYield, (pPolicy->GetYieldFromTech(iI) * iChange));
		changeYieldFromBorderGrowth(eYield, (pPolicy->GetYieldFromBorderGrowth(iI) * iChange));
		changeYieldGPExpend(eYield, (pPolicy->GetYieldGPExpend(iI) * iChange));
		changeConquerorYield(eYield, (pPolicy->GetConquerorYield(iI) * iChange));
		changeReligionYieldRateModifier(eYield, (pPolicy->GetReligionYieldMod(iI) * iChange));
		changeGoldenAgeYieldMod(eYield, (pPolicy->GetGoldenAgeYieldMod(iI) * iChange));
		changeFounderYield(eYield, (pPolicy->GetFounderYield(iI) * iChange));

		changeArtifactYieldBonus(eYield, (pPolicy->GetArtifactYieldChanges(iI) * iChange));
		changeArtYieldBonus(eYield, (pPolicy->GetArtYieldChanges(iI) * iChange));
		changeMusicYieldBonus(eYield, (pPolicy->GetMusicYieldChanges(iI) * iChange));
		changeLitYieldBonus(eYield, (pPolicy->GetLitYieldChanges(iI) * iChange));
		changeFilmYieldBonus(eYield, (pPolicy->GetFilmYieldChanges(iI) * iChange));
		changeRelicYieldBonus(eYield, (pPolicy->GetRelicYieldChanges(iI) * iChange));

		changeYieldFromBirthRetroactive(eYield, (pPolicy->GetYieldFromBirthRetroactive(iI) * iChange));
		changeYieldFromBirthCapitalRetroactive(eYield, (pPolicy->GetYieldFromBirthCapitalRetroactive(iI) * iChange));

		changeYieldFromNonSpecialistCitizens(eYield, (pPolicy->GetYieldFromNonSpecialistCitizens(iI) * iChange));
		changeYieldModifierFromGreatWorks(eYield, (pPolicy->GetYieldModifierFromGreatWorks(iI) * iChange));
		changeYieldModifierFromActiveSpies(eYield, (pPolicy->GetYieldModifierFromActiveSpies(iI) * iChange));
		changeYieldFromDelegateCount(eYield, (pPolicy->GetYieldFromDelegateCount(iI) * iChange));

		if (pPolicy->GetYieldFromBirthRetroactive(eYield) != 0)
		{
			int iLoop;
			for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
			{
				int iPop = pLoopCity->getPopulation();
				doInstantYield(INSTANT_YIELD_TYPE_BIRTH_RETROACTIVE, false, NO_GREATPERSON, NO_BUILDING, iPop, true, NO_PLAYER, NULL, false, pLoopCity);
			}
		}

		if (pPolicy->GetYieldFromBirthCapitalRetroactive(eYield) != 0)
		{
			if (getCapitalCity() != NULL)
			{
				int iPop = getCapitalCity()->getPopulation();
				doInstantYield(INSTANT_YIELD_TYPE_BIRTH_RETROACTIVE, false, NO_GREATPERSON, NO_BUILDING, iPop, true, NO_PLAYER, NULL, false, getCapitalCity());
			}
		}
#endif

		iMod = pPolicy->GetYieldModifier(iI) * iChange;
		if(iMod != 0)
			changeYieldRateModifier(eYield, iMod);

		iMod = pPolicy->GetCityYieldChange(iI) * iChange;
		if(iMod != 0)
#if defined(MOD_BUGFIX_MINOR)
			ChangeCityYieldChangeTimes100(eYield, iMod * 100);
#else
			ChangeCityYieldChange(eYield, iMod * 100);
#endif

		iMod = pPolicy->GetCoastalCityYieldChange(iI) * iChange;
		if(iMod != 0)
			ChangeCoastalCityYieldChange(eYield, iMod);

		iMod = pPolicy->GetCapitalYieldChange(iI) * iChange;
		if(iMod != 0)
#if defined(MOD_BUGFIX_MINOR)
			ChangeCapitalYieldChangeTimes100(eYield, iMod * 100);
#else
			ChangeCapitalYieldChange(eYield, iMod * 100);
#endif

		iMod = pPolicy->GetCapitalYieldPerPopChange(iI) * iChange;
		if(iMod != 0)
			ChangeCapitalYieldPerPopChange(eYield, iMod);

		iMod = pPolicy->GetCapitalYieldPerPopChangeEmpire(iI) * iChange;
		if (iMod != 0)
			ChangeCapitalYieldPerPopChangeEmpire(eYield, iMod);

		iMod = pPolicy->GetCapitalYieldModifier(iI) * iChange;
		if(iMod != 0)
			changeCapitalYieldRateModifier(eYield, iMod);

		iMod = pPolicy->GetGreatWorkYieldChange(iI) * iChange;
		if(iMod != 0)
			ChangeGreatWorkYieldChange(eYield, iMod);

		iMod = pPolicy->GetSpecialistExtraYield(iI) * iChange;
		if(iMod != 0)
			changeSpecialistExtraYield(eYield, iMod);

#if defined(MOD_API_UNIFIED_YIELDS)
		iMod = pPolicy->GetYieldFromKills(iI) * iChange;
		if(iMod != 0)
			changeYieldFromKills(eYield, iMod);

		iMod = pPolicy->GetYieldFromBarbarianKills(iI) * iChange;
		if(iMod != 0)
			changeYieldFromBarbarianKills(eYield, iMod);

		iMod = pPolicy->GetYieldChangeTradeRoute(iI) * iChange;
		if(iMod != 0)
			ChangeYieldChangeTradeRoute(eYield, iMod);

		iMod = pPolicy->GetYieldChangesNaturalWonder(iI) * iChange;
		if(iMod != 0)
			ChangeYieldChangesNaturalWonder(eYield, iMod);

		iMod = pPolicy->GetYieldChangeWorldWonder(iI) * iChange;
		if(iMod != 0)
			ChangeYieldChangeWorldWonder(eYield, iMod);

		iMod = pPolicy->GetYieldFromMinorDemand(iI) * iChange;
		if(iMod != 0)
			ChangeYieldFromMinorDemand(eYield, iMod);

		iMod = pPolicy->GetYieldFromWLTKD(iI) * iChange;
		if (iMod != 0)
			ChangeYieldFromWLTKD(eYield, iMod);
#endif
	}

	for(iI = 0; iI < GC.getNumUnitCombatClassInfos(); iI++)
	{
		changeUnitCombatProductionModifiers((UnitCombatTypes)iI, (pPolicy->GetUnitCombatProductionModifiers(iI) * iChange));
		changeUnitCombatFreeExperiences((UnitCombatTypes)iI, (pPolicy->GetUnitCombatFreeExperiences(iI) * iChange));
	}

	for(iI = 0; iI < GC.getNumHurryInfos(); iI++)
	{
		if(GC.getHurryInfo((HurryTypes) iI)->getPolicyPrereq() == ePolicy)
		{
			changeHurryCount(((HurryTypes)iI), iChange);
		}
		{
			changeHurryModifier((HurryTypes) iI, (pPolicy->GetHurryModifier(iI) * iChange));
		}
	}

#if defined(MOD_API_UNIFIED_YIELDS) && defined(MOD_API_PLOT_YIELDS)
	for(iI = 0; iI < GC.getNumPlotInfos(); iI++)
	{
		for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
		{
			changePlotYieldChange(((PlotTypes)iI), ((YieldTypes)iJ), (pPolicy->GetPlotYieldChanges(iI, iJ) * iChange));
		}
	}
#endif

#if defined(MOD_API_UNIFIED_YIELDS)
	for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
	{
		for(iI = 0; iI < GC.getNumFeatureInfos(); iI++)
		{
			changeFeatureYieldChange(((FeatureTypes)iI), ((YieldTypes)iJ), (pPolicy->GetFeatureYieldChanges(iI, iJ) * iChange));
		}

		for(iI = 0; iI < GC.getNumFeatureInfos(); iI++)
		{
			changeCityYieldFromUnimprovedFeature(((FeatureTypes)iI), ((YieldTypes)iJ), (pPolicy->GetCityYieldFromUnimprovedFeature(iI, iJ) * iChange));
			changeUnimprovedFeatureYieldChange(((FeatureTypes)iI), ((YieldTypes)iJ), (pPolicy->GetUnimprovedFeatureYieldChanges(iI, iJ) * iChange));
		}

		for(iI = 0; iI < GC.getNumResourceInfos(); iI++)
		{
			changeResourceYieldChange(((ResourceTypes)iI), ((YieldTypes)iJ), (pPolicy->GetResourceYieldChanges(iI, iJ) * iChange));
		}

		for(iI = 0; iI < GC.getNumTerrainInfos(); iI++)
		{
			changeTerrainYieldChange(((TerrainTypes)iI), ((YieldTypes)iJ), (pPolicy->GetTerrainYieldChanges(iI, iJ) * iChange));
		}

		for(iI = 0; iI < NUM_DOMAIN_TYPES; iI++)
		{
			changeTradeRouteYieldChange(((DomainTypes)iI), ((YieldTypes)iJ), (pPolicy->GetTradeRouteYieldChange(iI, iJ) * iChange));
		}

		for(iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
		{
			changeSpecialistYieldChange(((SpecialistTypes)iI), ((YieldTypes)iJ), (pPolicy->GetSpecialistYieldChanges(iI, iJ) * iChange));
		}

		for(iI = 0; iI < GC.getNumGreatPersonInfos(); iI++)
		{
			changeGreatPersonExpendedYield(((GreatPersonTypes)iI), ((YieldTypes)iJ), (pPolicy->GetGreatPersonExpendedYield(iI, iJ) * iChange));
		}
	}

	for(iI = 0; iI < GC.getNumGreatPersonInfos(); iI++)
	{
		iMod = pPolicy->GetGoldenAgeGreatPersonRateModifier(iI) * iChange;
		if(iMod != 0)
			changeGoldenAgeGreatPersonRateModifier((GreatPersonTypes)iI, iMod);
	}
#endif

	for(iI = 0; iI < GC.getNumImprovementInfos(); iI++)
	{
		for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
		{
			changeImprovementYieldChange(((ImprovementTypes)iI), ((YieldTypes)iJ), (pPolicy->GetImprovementYieldChanges(iI, iJ) * iChange));
		}
	}

	// Free Promotions
	PromotionTypes ePromotion;
	for(iI = 0; iI < GC.getNumPromotionInfos(); iI++)
	{
		ePromotion = (PromotionTypes) iI;

		if(pPolicy->IsFreePromotion(ePromotion))
			ChangeFreePromotionCount(ePromotion, iChange);
	}

	CvCity* pLoopCity;
	PlayerTypes ePlayer;

	// All player Capital Locations Revealed
	if(pPolicy->IsRevealAllCapitals())
	{
		for(iI = 0; iI < MAX_CIV_PLAYERS; iI++)
		{
			ePlayer = (PlayerTypes) iI;

			if(GET_PLAYER(ePlayer).isAlive())
			{
				pLoopCity = GET_PLAYER(ePlayer).getCapitalCity();

				if(pLoopCity != NULL)
				{
					pLoopCity->plot()->setRevealed(getTeam(), true);
				}
			}
		}
	}

	// Friendship Decay for OTHER PLAYERS
	CvNotifications* pNotifications;
	Localization::String locString;
	Localization::String locSummary;

	int iOtherPlayersDecay = pPolicy->GetOtherPlayersMinorFriendshipDecayMod();
	if(iOtherPlayersDecay != 0)
	{
		for(iI = 0; iI < MAX_MAJOR_CIVS; iI++)
		{
			ePlayer = (PlayerTypes) iI;

			if(GET_PLAYER(ePlayer).isEverAlive())
			{
				// Don't hurt us or teammates
				if(GET_PLAYER(ePlayer).getTeam() != getTeam())
				{
#if defined(MOD_BALANCE_CORE)
					if(GET_PLAYER(ePlayer).GetMinorFriendshipDecayMod() <= 0)
					{
						// Send notification to affected players
						locString = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_FRIENDSHIP_DECAY");
						locString << getNameKey();
						locSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MINOR_FRIENDSHIP_DECAY");

						pNotifications = GET_PLAYER(ePlayer).GetNotifications();
						if(pNotifications)
						{
							pNotifications->Add(NOTIFICATION_DIPLOMACY_DECLARATION, locString.toUTF8(), locSummary.toUTF8(), -1, -1, -1);
						}
					}
#endif
					GET_PLAYER(ePlayer).changeGetMinorFriendshipDecayMod(iOtherPlayersDecay * iChange);
#if !defined(MOD_BALANCE_CORE)
					// Send notification to affected players
					locString = Localization::Lookup("TXT_KEY_NOTIFICATION_MINOR_FRIENDSHIP_DECAY");
					locString << getNameKey();
					locSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_MINOR_FRIENDSHIP_DECAY");

					pNotifications = GET_PLAYER(ePlayer).GetNotifications();
					if(pNotifications)
					{
						pNotifications->Add(NOTIFICATION_DIPLOMACY_DECLARATION, locString.toUTF8(), locSummary.toUTF8(), -1, -1, -1);
					}
#endif
				}
			}
		}
	}

	BuildingClassTypes eBuildingClass;
	BuildingTypes eBuilding;
	int iBuildingCount;
	int iYieldMod;
	int iYieldChange;

	// How many cities get free culture buildings?
	int iNumCitiesFreeCultureBuilding = pPolicy->GetNumCitiesFreeCultureBuilding();
	int iNumCitiesFreeFoodBuilding = pPolicy->GetNumCitiesFreeFoodBuilding();

	// Loop through Cities
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(iNumCitiesFreeCultureBuilding > 0)
		{
			BuildingTypes eCultureBuilding = pLoopCity->ChooseFreeCultureBuilding();
			if(eCultureBuilding != NO_BUILDING)
			{
				pLoopCity->GetCityBuildings()->SetNumFreeBuilding(eCultureBuilding, 1);

				if(pLoopCity->getFirstBuildingOrder(eCultureBuilding) == 0)
				{
					pLoopCity->clearOrderQueue();
					pLoopCity->chooseProduction();		// Send a notification to the user that what they were building was given to them, and they need to produce something else.
				}
			}
			else
			{
				pLoopCity->SetOwedCultureBuilding(true);
			}

			// Decrement cities left to get free culture building (at end of loop we'll set the remainder)
			iNumCitiesFreeCultureBuilding--;
		}

		if(iNumCitiesFreeFoodBuilding > 0)
		{
			BuildingTypes eFoodBuilding = pLoopCity->ChooseFreeFoodBuilding();
			if(eFoodBuilding != NO_BUILDING)
			{
				pLoopCity->GetCityBuildings()->SetNumFreeBuilding(eFoodBuilding, 1);

				if(pLoopCity->getFirstBuildingOrder(eFoodBuilding) == 0)
				{
					pLoopCity->clearOrderQueue();
					pLoopCity->chooseProduction();		// Send a notification to the user that what they were building was given to them, and they need to produce something else.
				}
			}
#if defined(MOD_BUGFIX_FREE_FOOD_BUILDING)
			else
			{
				pLoopCity->SetOwedFoodBuilding(true);
			}
#endif

			// Decrement cities left to get free food building (at end of loop we'll set the remainder)
			iNumCitiesFreeFoodBuilding--;
		}

		// Free Culture-per-turn in every City
		int iCityCultureChange = pPolicy->GetCulturePerCity() * iChange;
		if(pLoopCity->HasGarrison())
		{
			iCityCultureChange += (pPolicy->GetCulturePerGarrisonedUnit() * iChange);
		}

		pLoopCity->ChangeJONSCulturePerTurnFromPolicies(iCityCultureChange);
		
#if defined(MOD_API_UNIFIED_YIELDS)
		int iTotalWonders = 0;
#endif

		// Building modifiers
		for(iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
		{
			eBuildingClass = (BuildingClassTypes) iI;

			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
			if(!pkBuildingClassInfo)
			{
				continue;
			}

			eBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

			if(eBuilding != NO_BUILDING)
			{
				CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
				if(pkBuilding)
				{
					iBuildingCount = pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding);

					if(iBuildingCount > 0)
					{
#if defined(MOD_API_UNIFIED_YIELDS)
						if (::isWorldWonderClass(pkBuilding->GetBuildingClassInfo())) 
						{
							iTotalWonders += iBuildingCount;
						}
#endif
						
#if defined(MOD_API_UNIFIED_YIELDS)
						iYieldMod = pPolicy->GetBuildingClassYieldModifiers(eBuildingClass, YIELD_CULTURE);
						if (iYieldMod != 0)
						{
							pLoopCity->changeYieldRateModifier(YIELD_CULTURE, iYieldMod * iBuildingCount * iChange);
						}
						iYieldChange = pPolicy->GetBuildingClassCultureChange(eBuildingClass);
						iYieldChange += pPolicy->GetBuildingClassYieldChanges(eBuildingClass, YIELD_CULTURE);
						if (iYieldChange != 0)
						{
							pLoopCity->ChangeJONSCulturePerTurnFromPolicies(iYieldChange * iBuildingCount * iChange);
#if defined(MOD_BALANCE_CORE_POLICIES)
							pLoopCity->changeBuildingClassCultureChange(eBuildingClass, (iYieldChange * iBuildingCount * iChange));
						}
						//Policy-Religion Fusion Yield Changes
						iYieldChange = pPolicy->GetReligionBuildingYieldMod(eBuildingClass, YIELD_CULTURE);
						if (MOD_BALANCE_CORE_POLICIES && iYieldChange != 0)
						{
							pLoopCity->changeReligionBuildingYieldRateModifier(eBuildingClass, YIELD_CULTURE, (iYieldChange * iBuildingCount * iChange));
#endif
						}
#else
						pLoopCity->ChangeJONSCulturePerTurnFromPolicies(pPolicy->GetBuildingClassCultureChange(eBuildingClass) * iBuildingCount * iChange);
#endif

						// Building Class Yield Stuff
						for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
						{
							switch(iJ)
							{
							case YIELD_CULTURE:
								// Skip, handled above
								break;
							case YIELD_FAITH:
#if defined(MOD_API_UNIFIED_YIELDS)
								{
									eYield = (YieldTypes) iJ;
									iYieldMod = pPolicy->GetBuildingClassYieldModifiers(eBuildingClass, eYield);
									if (iYieldMod != 0)
									{
										pLoopCity->changeYieldRateModifier(eYield, iYieldMod * iBuildingCount * iChange);
									}
									iYieldChange = pPolicy->GetBuildingClassYieldChanges(eBuildingClass, eYield);
									if (iYieldChange != 0)
									{
										pLoopCity->ChangeFaithPerTurnFromPolicies(iYieldChange * iBuildingCount * iChange);
									}
#if defined(MOD_BALANCE_CORE_POLICIES)
									//Policy-Religion Fusion Yield Changes
									iYieldChange = pPolicy->GetReligionBuildingYieldMod(eBuildingClass, eYield);
									if (MOD_BALANCE_CORE_POLICIES && iYieldChange != 0)
									{
										pLoopCity->changeReligionBuildingYieldRateModifier(eBuildingClass, eYield, (iYieldChange * iBuildingCount * iChange));
									}
#endif
								}
#else
								pLoopCity->ChangeFaithPerTurnFromPolicies(pPolicy->GetBuildingClassYieldChanges(eBuildingClass, iJ) * iBuildingCount * iChange);
#endif
								break;
							default:
								{
									eYield = (YieldTypes) iJ;
									iYieldMod = pPolicy->GetBuildingClassYieldModifiers(eBuildingClass, eYield);
#if defined(MOD_BALANCE_CORE)
									if (iYieldMod != 0)
#else
									if (iYieldMod > 0)
#endif
									{
										pLoopCity->changeYieldRateModifier(eYield, iYieldMod * iBuildingCount * iChange);
									}
									iYieldChange = pPolicy->GetBuildingClassYieldChanges(eBuildingClass, eYield);
									if (iYieldChange != 0)
									{
										pLoopCity->ChangeBaseYieldRateFromBuildings(eYield, iYieldChange * iBuildingCount * iChange);
									}
#if defined(MOD_BALANCE_CORE_POLICIES)
									//Policy-Religion Fusion Yield Changes
									iYieldChange = pPolicy->GetReligionBuildingYieldMod(eBuildingClass, eYield);
									if (MOD_BALANCE_CORE_POLICIES && iYieldChange != 0)
									{
										pLoopCity->changeReligionBuildingYieldRateModifier(eBuildingClass, eYield, (iYieldChange * iBuildingCount * iChange));
									}
#endif
								}
							}
						}
					}
				}
			}
		}

#if defined(MOD_API_UNIFIED_YIELDS)
		if (iTotalWonders > 0) {
			for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				YieldTypes eYield = (YieldTypes) iI;
				int iYield = pPolicy->GetYieldChangeWorldWonder(iI);

#if !defined(MOD_API_UNIFIED_YIELDS_CONSOLIDATION)
				if (eYield == YIELD_CULTURE)
				{
					pLoopCity->ChangeJONSCulturePerTurnFromBuildings(iYield * iTotalWonders * iChange);
				}
				else if (eYield == YIELD_FAITH)
				{
					pLoopCity->ChangeFaithPerTurnFromBuildings(iYield * iTotalWonders * iChange);
				}
				else
#endif
				{
					pLoopCity->ChangeBaseYieldRateFromBuildings(eYield, iYield * iTotalWonders * iChange);
				}
			}
		}
#endif
	}
#if defined(MOD_BALANCE_CORE)
	// Free Buildings from Policies
	if(MOD_BALANCE_CORE)
	{
		for(iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
		{
			const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iI);
			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
			if(pkBuildingClassInfo)
			{
				int iNumFreeBuildings = pPolicy->GetFreeChosenBuilding(eBuildingClass);
				if(iNumFreeBuildings > 0 || (pPolicy->GetAllCityFreeBuilding() == eBuildingClass))
				{
					const BuildingTypes eBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(pkBuildingClassInfo->GetID())));
					if(NO_BUILDING != eBuilding)
					{
						CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
						if(pkBuildingInfo)
						{
							ChangeNumCitiesFreeChosenBuilding(eBuildingClass, iNumFreeBuildings);
							ChangeAllCityFreeBuilding(eBuildingClass, (pPolicy->GetAllCityFreeBuilding() == eBuildingClass) * iChange);
							int iLoopTwo;
							for(pLoopCity = firstCity(&iLoopTwo); pLoopCity != NULL; pLoopCity = nextCity(&iLoopTwo))
							{
								if(pLoopCity->isValidBuildingLocation(eBuilding))
								{
									if (GetNumCitiesFreeChosenBuilding(eBuildingClass) > 0 || IsFreeBuildingAllCity(eBuildingClass))
									{
										if(pLoopCity->GetCityBuildings()->GetNumRealBuilding(eBuilding) > 0)
										{
											pLoopCity->GetCityBuildings()->SetNumRealBuilding(eBuilding, 0);
										}

										pLoopCity->GetCityBuildings()->SetNumFreeBuilding(eBuilding, 1);

										if(pLoopCity->GetCityBuildings()->GetNumFreeBuilding(eBuilding) > 0)
										{
											ChangeNumCitiesFreeChosenBuilding(eBuildingClass, -1);
										}
										if(pLoopCity->getFirstBuildingOrder(eBuilding) == 0)
										{
											pLoopCity->clearOrderQueue();
											pLoopCity->chooseProduction();
											// Send a notification to the user that what they were building was given to them, and they need to produce something else.
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if (pPolicy->GetNewCityFreeBuilding() != NO_BUILDINGCLASS)
	{
		ChangeFreeChosenBuildingNewCity(pPolicy->GetNewCityFreeBuilding(), iChange);
	}
	if (pPolicy->GetNewFoundCityFreeBuilding() != NO_BUILDINGCLASS)
	{
		ChangeNewFoundCityFreeBuilding(pPolicy->GetNewFoundCityFreeBuilding(), iChange);
	}
	if (pPolicy->GetNewFoundCityFreeUnit() != NO_UNITCLASS)
	{
		ChangeNewFoundCityFreeUnit(pPolicy->GetNewFoundCityFreeUnit(), iChange);
	}
#endif

	// Store off number of newly built cities that will get a free building
	ChangeNumCitiesFreeCultureBuilding(iNumCitiesFreeCultureBuilding);
	ChangeNumCitiesFreeFoodBuilding(iNumCitiesFreeFoodBuilding);

	// Not really techs but this is what we use (for now)
	for(iI = 0; iI < GC.getNUM_AND_TECH_PREREQS(); iI++)
	{
		if(pPolicy->GetPolicyDisables(iI) != NO_POLICY)
		{
			if(m_pPlayerPolicies->HasPolicy((PolicyTypes) pPolicy->GetPolicyDisables(iI)))
			{
				setHasPolicy((PolicyTypes) pPolicy->GetPolicyDisables(iI), false);
			}
		}
	}

	// Attack bonus for a period of time
	int iTurns = pPolicy->GetAttackBonusTurns() * iChange;
	if(iTurns > 0)
	{
		ChangeAttackBonusTurns(iTurns);
	}

	// Golden Age!
	int iGoldenAgeTurns = pPolicy->GetGoldenAgeTurns() * iChange;
	if(iGoldenAgeTurns > 0)
	{
		// Player modifier
		int iLengthModifier = getGoldenAgeModifier();
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
		// Do we get increased Golden Ages from a resource monopoly?
		if(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
		{
			for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
			{
				ResourceTypes eResourceLoop = (ResourceTypes) iResourceLoop;
				if(eResourceLoop != NO_RESOURCE)
				{
					CvResourceInfo* pInfo = GC.getResourceInfo(eResourceLoop);
					if (pInfo && pInfo->isMonopoly())
					{
						if(HasGlobalMonopoly(eResourceLoop) && pInfo->getMonopolyGALength() > 0)
						{
							int iTemp = pInfo->getMonopolyGALength();
							iTemp += GetMonopolyModPercent();
							iLengthModifier += iTemp;
						}
					}
				}
			}
		}
#endif
		// Trait modifier
		iLengthModifier += GetPlayerTraits()->GetGoldenAgeDurationModifier();

		if(iLengthModifier > 0)
		{
			iGoldenAgeTurns = iGoldenAgeTurns * (100 + iLengthModifier) / 100;
		}

		// Game Speed mod
		iGoldenAgeTurns *= GC.getGame().getGameSpeedInfo().getGoldenAgePercent();
		iGoldenAgeTurns /= 100;
#if defined(MOD_BALANCE_CORE)
		int iValue = GetGoldenAgeProgressMeter();
		changeGoldenAgeTurns(iGoldenAgeTurns, iValue);
#else
		changeGoldenAgeTurns(iGoldenAgeTurns);
#endif
	}

	// Free Techs
	int iNumFreeTechs = pPolicy->GetNumFreeTechs() * iChange;
	if(iNumFreeTechs > 0)
	{
		if(!isHuman())
		{
			for(iI = 0; iI < iNumFreeTechs; iI++)
			{
				AI_chooseFreeTech();
			}
		}
		else
		{
			CvString strBuffer = GetLocalizedText("TXT_KEY_MISC_COMPLETED_WONDER_CHOOSE_TECH", pPolicy->GetTextKey());
			chooseTech(iNumFreeTechs, strBuffer.GetCString());
		}
	}

	ChangeMedianTechPercentage(pPolicy->GetMedianTechPercentChange());

	// Free Policies
	int iNumFreePolicies = pPolicy->GetNumFreePolicies() * iChange;
	if(iNumFreePolicies > 0)
	{
		ChangeNumFreePolicies(iNumFreePolicies);
	}

	if(pPolicy->IncludesOneShotFreeUnits())
	{
		if(!m_pPlayerPolicies->HaveOneShotFreeUnitsFired(ePolicy))
		{
			m_pPlayerPolicies->SetOneShotFreeUnitsFired(ePolicy,true);

			int iNumFreeGreatPeople = pPolicy->GetNumFreeGreatPeople() * iChange;
			if(iNumFreeGreatPeople > 0)
			{
				ChangeNumFreeGreatPeople(iNumFreeGreatPeople);
			}

			if(getCapitalCity() != NULL)
			{
				int iX = getCapitalCity()->getX();
				int iY = getCapitalCity()->getY();

				for(iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
				{
					const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
					CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
					if(pkUnitClassInfo)
					{
						int iNumFreeUnits = pPolicy->GetNumFreeUnitsByClass(eUnitClass);
						if(iNumFreeUnits > 0)
						{
							const UnitTypes eUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eUnitClass);
							CvUnitEntry* pUnitEntry = GC.getUnitInfo(eUnit);
							if (isHuman() && pUnitEntry != NULL && pUnitEntry->IsFound() && GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE))
							{
								continue;
							}

							for(int iUnitLoop = 0; iUnitLoop < iNumFreeUnits; iUnitLoop++)
							{
								CvUnit* pNewUnit = NULL;

								// slewis
								// for venice
								if (pUnitEntry->IsFound() && GetPlayerTraits()->IsNoAnnexing())
								{
									// drop a merchant of venice instead
									// find the eUnit replacement that's the merchant of venice
									for(int iVeniceSearch = 0; iVeniceSearch < GC.getNumUnitClassInfos(); iVeniceSearch++)
									{
										const UnitClassTypes eVeniceUnitClass = static_cast<UnitClassTypes>(iVeniceSearch);
										CvUnitClassInfo* pkVeniceUnitClassInfo = GC.getUnitClassInfo(eVeniceUnitClass);
										if(pkVeniceUnitClassInfo)
										{
											const UnitTypes eMerchantOfVeniceUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eVeniceUnitClass);
											if (eMerchantOfVeniceUnit != NO_UNIT)
											{
												CvUnitEntry* pVeniceUnitEntry = GC.getUnitInfo(eMerchantOfVeniceUnit);
												if (pVeniceUnitEntry->IsCanBuyCityState())
												{
													pNewUnit = initUnit(eMerchantOfVeniceUnit, iX, iY);				
													break;
												}
											}
										}
									}
								}
								else
								{
									pNewUnit = initUnit(eUnit, iX, iY);
								}

								CvAssert(pNewUnit);

								if (pNewUnit)
								{
#if defined(MOD_BALANCE_CORE)
									if(pNewUnit->isWLKTKDOnBirth())
									{
										CvCity* pLoopCity;
										int iLoop;
										for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
										{
											if(pLoopCity != NULL && pLoopCity->getOwner() == GetID())
											{
												int iWLTKD = (GC.getCITY_RESOURCE_WLTKD_TURNS() / 3);

												iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
												iWLTKD /= 100;

												if (iWLTKD > 0)
												{
													pLoopCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
													CvNotifications* pNotifications = GetNotifications();
													if (pNotifications)
													{
														Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UNIT");
														strText << pNewUnit->getNameKey() << pLoopCity->getNameKey();
														Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UNIT");
														strSummary << pLoopCity->getNameKey();
														pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pLoopCity->getX(), pLoopCity->getY(), -1);
													}
												}
											}
										}
									}
									if(pNewUnit->isGoldenAgeOnBirth())
									{
										int iGoldenAgeTurns = getGoldenAgeLength();
										int iValue = GetGoldenAgeProgressMeter();
										changeGoldenAgeTurns(iGoldenAgeTurns, iValue);
									}
									if(pNewUnit->isCultureBoost())
									{
										int iValue = GetTotalJONSCulturePerTurn() * 4;
										changeJONSCulture(iValue);
										if(getCapitalCity() != NULL)
										{
											getCapitalCity()->ChangeJONSCultureStored(iValue);
										}
										CvNotifications* pNotifications = GetNotifications();
										if (pNotifications)
										{
											Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CULTURE_UNIT");
											strText << pNewUnit->getNameKey();
											Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CULTURE_UNIT");
											strSummary << pNewUnit->getNameKey();
											pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pNewUnit->getX(), pNewUnit->getY(), -1);
										}
									}
#endif
									if(pNewUnit->IsGreatGeneral())
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGreatGeneralsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGreatGeneralsCreated();
#endif
										bool bJumpSuccess = pNewUnit->jumpToNearestValidPlot();
										if (bJumpSuccess)
										{
											getCapitalCity()->addProductionExperience(pNewUnit);
										}
										else
										{
											pNewUnit->kill(false);
										}
									}
									else if(pNewUnit->IsGreatAdmiral())
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGreatAdmiralsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGreatAdmiralsCreated();
#endif
										CvPlot *pSpawnPlot = GetGreatAdmiralSpawnPlot(pNewUnit);
										if (pNewUnit->plot() != pSpawnPlot)
										{
											pNewUnit->setXY(pSpawnPlot->getX(), pSpawnPlot->getY());
											getCapitalCity()->addProductionExperience(pNewUnit);
										}
									}
									else if(pNewUnit->getUnitInfo().IsFoundReligion())
									{
										ReligionTypes eReligion = GetReligions()->GetReligionCreatedByPlayer();
										if (eReligion == NO_RELIGION)
										{
											eReligion = GetReligions()->GetReligionInMostCities();
										}
										int iReligionSpreads = pNewUnit->getUnitInfo().GetReligionSpreads();
										int iReligiousStrength = pNewUnit->getUnitInfo().GetReligiousStrength();
#if defined(MOD_BALANCE_CORE)
										iReligiousStrength *= (100 + GetPlayerTraits()->GetExtraMissionaryStrength());
										iReligiousStrength /= 100;
#endif
										if(iReligionSpreads > 0 && eReligion > RELIGION_PANTHEON)
										{
#if defined(MOD_BUGFIX_EXTRA_MISSIONARY_SPREADS)
											if (MOD_BUGFIX_EXTRA_MISSIONARY_SPREADS)
											{
												if (GetHolyCity() && GetHolyCity()->getOwner() == GetID())
												{
													pNewUnit->GetReligionData()->SetSpreadsLeft(iReligionSpreads + GetHolyCity()->GetCityBuildings()->GetMissionaryExtraSpreads() + GetNumMissionarySpreads());
												}
												else if (getCapitalCity())
												{
													pNewUnit->GetReligionData()->SetSpreadsLeft(iReligionSpreads + getCapitalCity()->GetCityBuildings()->GetMissionaryExtraSpreads() + GetNumMissionarySpreads());
												}
												else
												{
													pNewUnit->GetReligionData()->SetSpreadsLeft(iReligionSpreads);
												}
											}
											else
											{
												pNewUnit->GetReligionData()->SetSpreadsLeft(iReligionSpreads);
											}
#else
											pNewUnit->GetReligionData()->SetSpreadsLeft(iReligionSpreads);
#endif
											pNewUnit->GetReligionData()->SetReligiousStrength(iReligiousStrength);
											pNewUnit->GetReligionData()->SetReligion(eReligion);
										}
									}
									else if (pNewUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_WRITER"))
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGreatWritersCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGreatWritersCreated();
#endif
#if !defined(MOD_BALANCE_CORE)
										if (pNewUnit->getUnitInfo().GetOneShotTourism() > 0)
										{
											pNewUnit->SetTourismBlastStrength(GetCulture()->GetTourismBlastStrength(pNewUnit->getUnitInfo().GetOneShotTourism()));
										}
#endif

										pNewUnit->jumpToNearestValidPlot();
									}							
									else if (pNewUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_ARTIST"))
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGreatArtistsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGreatArtistsCreated();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}							
									else if (pNewUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_MUSICIAN"))
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGreatMusiciansCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGreatMusiciansCreated();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
#if defined(MOD_DIPLOMACY_CITYSTATES)
									else if (MOD_DIPLOMACY_CITYSTATES && pNewUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_GREAT_DIPLOMAT"))
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGreatDiplomatsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGreatDiplomatsCreated();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
#endif
#if defined(MOD_BALANCE_CORE)
									else if (pNewUnit->getUnitInfo().IsGPExtra() == 1)
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGPExtra1Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGPExtra1Created();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
									else if (pNewUnit->getUnitInfo().IsGPExtra() == 2)
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGPExtra2Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGPExtra2Created();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
									else if (pNewUnit->getUnitInfo().IsGPExtra() == 3)
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGPExtra3Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGPExtra3Created();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
									else if (pNewUnit->getUnitInfo().IsGPExtra() == 4)
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGPExtra4Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGPExtra4Created();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
									else if (pNewUnit->getUnitInfo().IsGPExtra() == 5)
									{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										incrementGPExtra5Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
										incrementGPExtra5Created();
#endif
										pNewUnit->jumpToNearestValidPlot();
									}
#endif
									else if(pNewUnit->IsGreatPerson())
									{
#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
										if (MOD_GLOBAL_SEPARATE_GP_COUNTERS) 
										{
											if (pNewUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_MERCHANT"))
											{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
												incrementGreatMerchantsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
												incrementGreatMerchantsCreated();
#endif
											}
											else if (pNewUnit->getUnitInfo().GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_SCIENTIST"))
											{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
												incrementGreatScientistsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
												incrementGreatScientistsCreated();
#endif
											}
											else
											{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
												incrementGreatEngineersCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
												incrementGreatEngineersCreated();
#endif
											}
										}
										else
#endif
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
											incrementGreatPeopleCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
											incrementGreatPeopleCreated();
#endif
											pNewUnit->jumpToNearestValidPlot();
									}
									else
									{
										pNewUnit->jumpToNearestValidPlot();
										if (pNewUnit && getCapitalCity() != NULL)
										{
											getCapitalCity()->addProductionExperience(pNewUnit);
										}
									}
								}
							}
						}
					}
				}
				int iNumFreeCombatLandUnits = pPolicy->GetBestNumberLandCombatUnitClass();
				CvCity* pCapital = getCapitalCity();
				if(iNumFreeCombatLandUnits > 0)
				{
					UnitTypes eBestLandUnit = NO_UNIT;
					int iStrengthBestLandCombat = 0;
					for(iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
					{
						const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
						CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
						if(pkUnitClassInfo)
						{
							const UnitTypes eUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eUnitClass);
							CvUnitEntry* pUnitEntry = GC.getUnitInfo(eUnit);
							if(pUnitEntry)
							{
								if(!pCapital->canTrain(eUnit))
								{
									continue;
								}
								if(pUnitEntry->GetRangedCombat() > 0)
								{
									continue;
								}
								if(pUnitEntry->GetDomainType() == DOMAIN_LAND)
								{
									bool bBad = false;
									ResourceTypes eResource;
									for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
									{
										eResource = (ResourceTypes) iResourceLoop;
										int iNumResource = pUnitEntry->GetResourceQuantityRequirement(eResource);
										if (iNumResource > 0)
										{
											if(getNumResourceAvailable(eResource, true) < iNumResource)
											{
												bBad = true;
												break;
											}
										}
									}
									if(bBad)
									{
										continue;
									}
									int iCombatLandStrength = (std::max(1, pUnitEntry->GetCombat()));
									if(iCombatLandStrength > iStrengthBestLandCombat)
									{
										iStrengthBestLandCombat = iCombatLandStrength;
										eBestLandUnit = eUnit;
									}
								}
							}
						}
					}
					if(eBestLandUnit != NO_UNIT)
					{
						for(int iUnitLoop = 0; iUnitLoop < iNumFreeCombatLandUnits; iUnitLoop++)
						{
							CvUnitEntry* pkbUnitEntry = GC.getUnitInfo(eBestLandUnit);
							if(pkbUnitEntry)
							{
								UnitAITypes eUnitAI = pkbUnitEntry->GetDefaultUnitAIType();
								int iResult = pCapital->CreateUnit(eBestLandUnit, eUnitAI);
								CvAssertMsg(iResult != -1, "Unable to create unit");
								if (iResult != -1)
								{
									CvUnit* pUnit = getUnit(iResult);
									if (!pUnit->jumpToNearestValidPlot())
									{
										pUnit->kill(false);	// Could not find a valid spot!
									}
								}
							}
						}
					}
					else
					{
						for(int iUnitLoop = 0; iUnitLoop < iNumFreeCombatLandUnits; iUnitLoop++)
						{
							UnitTypes eWarrior = (UnitTypes)GC.getInfoTypeForString("UNIT_WARRIOR");
							CvUnitEntry* pkbUnitEntry = GC.getUnitInfo(eWarrior);
							if(pkbUnitEntry)
							{
								UnitAITypes eUnitAI = pkbUnitEntry->GetDefaultUnitAIType();
								int iResult = pCapital->CreateUnit(eWarrior, eUnitAI);
								CvAssertMsg(iResult != -1, "Unable to create unit");
								if (iResult != -1)
								{
									CvUnit* pUnit = getUnit(iResult);
									if (!pUnit->jumpToNearestValidPlot())
									{
										pUnit->kill(false);	// Could not find a valid spot!
									}
								}
							}
						}
					}
				}
				int iNumFreeRangedLandUnits = pPolicy->GetBestNumberLandRangedUnitClass();
				if(iNumFreeRangedLandUnits > 0)
				{
					UnitTypes eBestLandRangedUnit = NO_UNIT;
					int iStrengthBestLandRanged = 0;
					for(iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
					{
						const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
						CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
						if(pkUnitClassInfo)
						{
							const UnitTypes eUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eUnitClass);
							CvUnitEntry* pUnitEntry = GC.getUnitInfo(eUnit);
							if(pUnitEntry)
							{
								if(!pCapital->canTrain(eUnit))
								{
									continue;
								}
								if(pUnitEntry->GetDomainType() == DOMAIN_LAND && pUnitEntry->GetRangedCombat() > 0)
								{
									bool bBad = false;
									ResourceTypes eResource;
									for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
									{
										eResource = (ResourceTypes) iResourceLoop;
										int iNumResource = pUnitEntry->GetResourceQuantityRequirement(eResource);
										if (iNumResource > 0)
										{
											if(getNumResourceAvailable(eResource, true) < iNumResource)
											{
												bBad = true;
												break;
											}
										}
									}
									if(bBad)
									{
										continue;
									}
									int iCombatLandRangedStrength = (std::max(1, pUnitEntry->GetRangedCombat()));
									if(iCombatLandRangedStrength > iStrengthBestLandRanged)
									{
										iStrengthBestLandRanged = iCombatLandRangedStrength;
										eBestLandRangedUnit = eUnit;
									}
								}
							}
						}
					}
					if(eBestLandRangedUnit != NO_UNIT)
					{
						for(int iUnitLoop = 0; iUnitLoop < iNumFreeRangedLandUnits; iUnitLoop++)
						{
							CvUnitEntry* pkbUnitEntry = GC.getUnitInfo(eBestLandRangedUnit);
							if(pkbUnitEntry)
							{
								UnitAITypes eUnitAI = pkbUnitEntry->GetDefaultUnitAIType();
								int iResult = pCapital->CreateUnit(eBestLandRangedUnit, eUnitAI);
								CvAssertMsg(iResult != -1, "Unable to create unit");
								if (iResult != -1)
								{
									CvUnit* pUnit = getUnit(iResult);
									if (!pUnit->jumpToNearestValidPlot())
									{
										pUnit->kill(false);	// Could not find a valid spot!
									}
								}
							}
						}
					}
					else
					{
						for(int iUnitLoop = 0; iUnitLoop < iNumFreeRangedLandUnits; iUnitLoop++)
						{
							UnitTypes eArcher = (UnitTypes)GC.getInfoTypeForString("UNIT_ARCHER");
							CvUnitEntry* pkbUnitEntry = GC.getUnitInfo(eArcher);
							if(pkbUnitEntry)
							{
								UnitAITypes eUnitAI = pkbUnitEntry->GetDefaultUnitAIType();
								int iResult = pCapital->CreateUnit(eArcher, eUnitAI);
								CvAssertMsg(iResult != -1, "Unable to create unit");
								if (iResult != -1)
								{
									CvUnit* pUnit = getUnit(iResult);
									if (!pUnit->jumpToNearestValidPlot())
									{
										pUnit->kill(false);	// Could not find a valid spot!
									}
								}
							}
						}
					}
				}
				int iNumFreeCombatSeaUnits = pPolicy->GetBestNumberSeaCombatUnitClass();
				if(iNumFreeCombatSeaUnits > 0 && pCapital->isCoastal())
				{
					UnitTypes eBestSeaUnit = NO_UNIT;
					int iStrengthBestSeaCombat = 0;
					for(iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
					{
						const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
						CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
						if(pkUnitClassInfo)
						{
							const UnitTypes eUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eUnitClass);
							CvUnitEntry* pUnitEntry = GC.getUnitInfo(eUnit);
							if(pUnitEntry)
							{
								if(!pCapital->canTrain(eUnit))
								{
									continue;
								}
								if(pUnitEntry->GetRangedCombat() > 0)
								{
									continue;
								}
								if(pUnitEntry->GetDomainType() == DOMAIN_SEA)
								{
									bool bBad = false;
									ResourceTypes eResource;
									for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
									{
										eResource = (ResourceTypes) iResourceLoop;
										int iNumResource = pUnitEntry->GetResourceQuantityRequirement(eResource);
										if (iNumResource > 0)
										{
											if(getNumResourceAvailable(eResource, true) < iNumResource)
											{
												bBad = true;
												break;
											}
										}
									}
									if(bBad)
									{
										continue;
									}
									int iCombatSeaStrength = (std::max(1, pUnitEntry->GetCombat()));
									if(iCombatSeaStrength > iStrengthBestSeaCombat)
									{
										iStrengthBestSeaCombat = iCombatSeaStrength;
										eBestSeaUnit = eUnit;
									}
								}
							}
						}
					}
					if(eBestSeaUnit != NO_UNIT)
					{
						for(int iUnitLoop = 0; iUnitLoop < iNumFreeCombatSeaUnits; iUnitLoop++)
						{
							CvUnitEntry* pkbUnitEntry = GC.getUnitInfo(eBestSeaUnit);
							if(pkbUnitEntry)
							{
								UnitAITypes eUnitAI = pkbUnitEntry->GetDefaultUnitAIType();
								int iResult = pCapital->CreateUnit(eBestSeaUnit, eUnitAI);
								CvAssertMsg(iResult != -1, "Unable to create unit");
								if (iResult != -1)
								{
									CvUnit* pUnit = getUnit(iResult);
									if (!pUnit->jumpToNearestValidPlot())
									{
										pUnit->kill(false);	// Could not find a valid spot!
									}
								}
							}
						}
					}
					else
					{
						for(int iUnitLoop = 0; iUnitLoop < iNumFreeCombatSeaUnits; iUnitLoop++)
						{
							UnitTypes eCaravel = (UnitTypes)GC.getInfoTypeForString("UNIT_CARAVEL");
							CvUnitEntry* pkbUnitEntry = GC.getUnitInfo(eCaravel);
							if(pkbUnitEntry)
							{
								UnitAITypes eUnitAI = pkbUnitEntry->GetDefaultUnitAIType();
								int iResult = pCapital->CreateUnit(eCaravel, eUnitAI);
								CvAssertMsg(iResult != -1, "Unable to create unit");
								if (iResult != -1)
								{
									CvUnit* pUnit = getUnit(iResult);
									if (!pUnit->jumpToNearestValidPlot())
									{
										pUnit->kill(false);	// Could not find a valid spot!
									}
								}
							}
						}
					}
				}
				int iNumFreeRangedSeaUnits = pPolicy->GetBestNumberSeaRangedUnitClass();
				if(iNumFreeRangedSeaUnits > 0 && pCapital->isCoastal())
				{
					UnitTypes eBestSeaRangedUnit = NO_UNIT;
					int iStrengthBestSeaRanged = 0;
					for(iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
					{
						const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
						CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
						if(pkUnitClassInfo)
						{
							const UnitTypes eUnit = (UnitTypes) getCivilizationInfo().getCivilizationUnits(eUnitClass);
							CvUnitEntry* pUnitEntry = GC.getUnitInfo(eUnit);
							if(pUnitEntry)
							{
								if(!pCapital->canTrain(eUnit))
								{
									continue;
								}
								if(pUnitEntry->GetDomainType() == DOMAIN_SEA && pUnitEntry->GetRangedCombat() > 0)
								{
									bool bBad = false;
									ResourceTypes eResource;
									for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
									{
										eResource = (ResourceTypes) iResourceLoop;
										int iNumResource = pUnitEntry->GetResourceQuantityRequirement(eResource);
										if (iNumResource > 0)
										{
											if(getNumResourceAvailable(eResource, true) < iNumResource)
											{
												bBad = true;
												break;
											}
										}
									}
									if(bBad)
									{
										continue;
									}
									int iCombatSeaRangedStrength = (std::max(1, pUnitEntry->GetRangedCombat()));
									if(iCombatSeaRangedStrength > iStrengthBestSeaRanged)
									{
										iStrengthBestSeaRanged = iCombatSeaRangedStrength;
										eBestSeaRangedUnit = eUnit;
									}
								}
							}
						}
					}
					if(eBestSeaRangedUnit != NO_UNIT)
					{
						for(int iUnitLoop = 0; iUnitLoop < iNumFreeRangedSeaUnits; iUnitLoop++)
						{
							CvUnitEntry* pkbUnitEntry = GC.getUnitInfo(eBestSeaRangedUnit);
							if(pkbUnitEntry)
							{
								UnitAITypes eUnitAI = pkbUnitEntry->GetDefaultUnitAIType();
								int iResult = pCapital->CreateUnit(eBestSeaRangedUnit, eUnitAI);
								CvAssertMsg(iResult != -1, "Unable to create unit");
								if (iResult != -1)
								{
									CvUnit* pUnit = getUnit(iResult);
									if (!pUnit->jumpToNearestValidPlot())
									{
										pUnit->kill(false);	// Could not find a valid spot!
									}
								}
							}
						}
					}
					else
					{
						for(int iUnitLoop = 0; iUnitLoop < iNumFreeRangedSeaUnits; iUnitLoop++)
						{
							UnitTypes eGalleass = (UnitTypes)GC.getInfoTypeForString("UNIT_GALLEASS");
							CvUnitEntry* pkbUnitEntry = GC.getUnitInfo(eGalleass);
							if(pkbUnitEntry)
							{
								UnitAITypes eUnitAI = pkbUnitEntry->GetDefaultUnitAIType();
								int iResult = pCapital->CreateUnit(eGalleass, eUnitAI);
								CvAssertMsg(iResult != -1, "Unable to create unit");
								if (iResult != -1)
								{
									CvUnit* pUnit = getUnit(iResult);
									if (!pUnit->jumpToNearestValidPlot())
									{
										pUnit->kill(false);	// Could not find a valid spot!
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// Great People bonus from Allied city-states
	if(pPolicy->IsMinorGreatPeopleAllies())
	{
		DoAdoptedGreatPersonCityStatePolicy();
	}

	// Add a Reformation belief if eligible
#if defined(MOD_RELIGION_LOCAL_RELIGIONS)
	if (isHuman() && pPolicy->IsAddReformationBelief() && GetReligions()->HasCreatedReligion(true) && !GetReligions()->HasAddedReformationBelief())
#else
	if (isHuman() && pPolicy->IsAddReformationBelief() && GetReligions()->HasCreatedReligion() && !GetReligions()->HasAddedReformationBelief())
#endif
	{
		pNotifications = GetNotifications();
		if(pNotifications)
		{
			CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_ADD_REFORMATION_BELIEF");
			CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_ADD_REFORMATION_BELIEF");
			pNotifications->Add(NOTIFICATION_ADD_REFORMATION_BELIEF, strBuffer, strSummary, -1, -1, -1);
		}
	}

	// if the steal tech faster amount is modified, then update the progress of all spies
	if (pPolicy->GetStealTechFasterModifier() != 0)
	{
		GetEspionage()->UpdateSpies();
	}
#if defined(MOD_BALANCE_CORE)
	if (pPolicy->GetStealGWFasterModifier() != 0)
	{
		GetEspionage()->UpdateSpies();
	}
#endif

	CvPlot *pLoopPlot;
	ResourceTypes eResource;
	for(iI = 0; iI < GC.getMap().numPlots(); iI++)
	{
		pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);
		eResource = pLoopPlot->getResourceType();
		if(eResource != NO_RESOURCE)
		{
			if(GC.getResourceInfo(eResource)->getPolicyReveal() == (int)ePolicy)
			{
				pLoopPlot->updateYield();
				if (pLoopPlot->isRevealed(getTeam()))
				{
					pLoopPlot->setLayoutDirty(true);
				}
			}
		}
	}

	GetTrade()->UpdateTradeConnectionValues();
	recomputeGreatPeopleModifiers();
	recomputePolicyCostModifier();
	recomputeFreeExperience();
#if defined(MOD_BALANCE_CORE)
	CvCity* pLoopCity2;
	int iLoop2;
	for(pLoopCity2 = firstCity(&iLoop2); pLoopCity2 != NULL; pLoopCity2 = nextCity(&iLoop2))
	{
		if(pLoopCity2 != NULL)
		{
			pLoopCity2->UpdateReligion(pLoopCity2->GetCityReligions()->GetReligiousMajority());		
		}
	}
#endif
	CalculateNetHappiness();
#if defined(MOD_BALANCE_CORE)
	for(pLoopCity2 = firstCity(&iLoop2); pLoopCity2 != NULL; pLoopCity2 = nextCity(&iLoop2))
	{
		if(pLoopCity2 != NULL)
		{
			pLoopCity2->UpdateComboHappiness();
		}
	}
#endif

	doUpdateBarbarianCampVisibility();

	GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);
	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);
}

#if defined(MOD_BALANCE_CORE)
void CvPlayer::processCorporations(CorporationTypes eCorporation, int iChange)
{
	CvCorporationEntry* pkCorporationEntry = GC.getCorporationInfo(eCorporation);
	if(pkCorporationEntry == NULL)
		return;

	int iI, jJ;

	for (iI = 0; iI < GC.getNUM_YIELD_TYPES(); iI++)
	{
		for (jJ = 0; jJ < GC.getNumSpecialistInfos(); jJ++)
		{
			changeSpecialistYieldChange((SpecialistTypes)jJ, (YieldTypes)iI, pkCorporationEntry->GetSpecialistYieldChange(jJ, iI) * iChange);
		}
	}
	// Loop through Cities
	int iLoop;
	CvCity* pLoopCity;
	int iBuildingCount;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		// Building modifiers
		BuildingClassTypes eBuildingClass;
		for(iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
		{
			eBuildingClass = (BuildingClassTypes) iI;

			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
			if(!pkBuildingClassInfo)
			{
				continue;
			}

			BuildingTypes eTestBuilding = (BuildingTypes) getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

			if(eTestBuilding != NO_BUILDING)
			{
				CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eTestBuilding);
				if(pkBuilding)
				{
					iBuildingCount = pLoopCity->GetCityBuildings()->GetNumBuilding(eTestBuilding);
					if(iBuildingCount > 0)
					{
						// Building Class Yield Stuff
						for(int iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
						{
							YieldTypes eYield = (YieldTypes)iJ;
								
							int iYieldChange = pkCorporationEntry->GetBuildingClassYieldChange(eBuildingClass, eYield);
							if(iYieldChange <= 0)
								continue;

							pLoopCity->ChangeBaseYieldRateFromBuildings(eYield, iYieldChange * iBuildingCount * iChange);
						}
					}
				}
			}
		}
	}
}
#endif

//	--------------------------------------------------------------------------------
/// If we should see where the locations of all current Barb Camps are, do it
void CvPlayer::doUpdateBarbarianCampVisibility()
{
	if(IsAlwaysSeeBarbCamps())
	{
		CvPlot* pPlot;

		ImprovementTypes eImprovement;

		for(int iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); ++iPlotLoop)
		{
			pPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);

			if(pPlot->isRevealed(getTeam()))
			{
				eImprovement = pPlot->getImprovementType();

				// Camp here
				if(eImprovement == GC.getBARBARIAN_CAMP_IMPROVEMENT())
				{
					// We don't see Camp
					if(pPlot->getRevealedImprovementType(getTeam()) != eImprovement)
					{
						pPlot->setRevealedImprovementType(getTeam(), eImprovement);
					}
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isPbemNewTurn() const
{
	return m_bPbemNewTurn;
}

//	--------------------------------------------------------------------------------
void CvPlayer::setPbemNewTurn(bool bNew)
{
	m_bPbemNewTurn = bNew;
}

//	--------------------------------------------------------------------------------
CvEconomicAI* CvPlayer::GetEconomicAI() const
{
	return m_pEconomicAI;
}

//	--------------------------------------------------------------------------------
CvMilitaryAI* CvPlayer::GetMilitaryAI() const
{
	return m_pMilitaryAI;
}

//	--------------------------------------------------------------------------------
CvCitySpecializationAI* CvPlayer::GetCitySpecializationAI() const
{
	return m_pCitySpecializationAI;
}

//	--------------------------------------------------------------------------------
CvWonderProductionAI* CvPlayer::GetWonderProductionAI() const
{
	return m_pWonderProductionAI;
}

//	--------------------------------------------------------------------------------
CvGrandStrategyAI* CvPlayer::GetGrandStrategyAI() const
{
	return m_pGrandStrategyAI;
}

//	--------------------------------------------------------------------------------
CvDiplomacyAI* CvPlayer::GetDiplomacyAI() const
{
	return m_pDiplomacyAI;
}

//	--------------------------------------------------------------------------------
CvPlayerReligions* CvPlayer::GetReligions() const
{
	return m_pReligions;
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
CvPlayerCorporations* CvPlayer::GetCorporations() const
{
	return m_pCorporations;
}
//	--------------------------------------------------------------------------------
CvPlayerContracts* CvPlayer::GetContracts() const
{
	return m_pContracts;
}
#endif

//	--------------------------------------------------------------------------------
CvReligionAI* CvPlayer::GetReligionAI() const
{
	return m_pReligionAI;
}

//	--------------------------------------------------------------------------------
CvMinorCivAI* CvPlayer::GetMinorCivAI() const
{
	return m_pMinorCivAI;
}

//	--------------------------------------------------------------------------------
CvDealAI* CvPlayer::GetDealAI() const
{
	return m_pDealAI;
}

//	--------------------------------------------------------------------------------
/// Get the object that decides what task the builders should perform
CvBuilderTaskingAI* CvPlayer::GetBuilderTaskingAI() const
{
	return m_pBuilderTaskingAI;
}

//	--------------------------------------------------------------------------------
/// Get the city connection that gives you information about the route connections between cities
CvCityConnections* CvPlayer::GetCityConnections() const
{
	return m_pCityConnections;
}

//	--------------------------------------------------------------------------------
/// Get the player's information about their espionage
CvPlayerEspionage* CvPlayer::GetEspionage() const
{
	return m_pEspionage;
}

//	--------------------------------------------------------------------------------
/// Get the player's espionage AI version
CvEspionageAI* CvPlayer::GetEspionageAI() const
{
	return m_pEspionageAI;
}

//	--------------------------------------------------------------------------------
/// Get the player's information about their trade
CvPlayerTrade* CvPlayer::GetTrade() const
{
	return m_pTrade;
}

//	--------------------------------------------------------------------------------
/// Get the player's trade AI version
CvTradeAI* CvPlayer::GetTradeAI() const
{
	return m_pTradeAI;
}

//	--------------------------------------------------------------------------------
/// Get the player's League AI
CvLeagueAI* CvPlayer::GetLeagueAI() const
{
	return m_pLeagueAI;
}

//	--------------------------------------------------------------------------------
CvPlayerCulture* CvPlayer::GetCulture() const
{
	return m_pCulture;
}

//	--------------------------------------------------------------------------------
CvNotifications* CvPlayer::GetNotifications() const
{
	return m_pNotifications;
}

#if defined(MOD_API_EXTENSIONS)
//	--------------------------------------------------------------------------------
int CvPlayer::AddNotification(NotificationTypes eNotificationType, const char* sMessage, const char* sSummary, int iGameDataIndex, int iExtraGameData)
{
  return AddNotification(eNotificationType, sMessage, sSummary, NULL, iGameDataIndex, iExtraGameData);
}

int CvPlayer::AddNotification(NotificationTypes eNotificationType, const char* sMessage, const char* sSummary, CvPlot* pPlot, int iGameDataIndex, int iExtraGameData)
{
  int iNotification = -1;
  
  CvNotifications* pNotifications = GetNotifications();

  if (pNotifications) {
    const int iPlotX = pPlot ? pPlot->getX() : -1;
    const int iPlotY = pPlot ? pPlot->getY() : -1;
	
    iNotification = pNotifications->Add(eNotificationType, sMessage, sSummary, iPlotX, iPlotY, iGameDataIndex, iExtraGameData);
  }
  
  return iNotification;
}
#endif

//	--------------------------------------------------------------------------------
CvTreasury* CvPlayer::GetTreasury() const
{
	return m_pTreasury;
}

//	--------------------------------------------------------------------------------
CvDiplomacyRequests* CvPlayer::GetDiplomacyRequests() const
{
	return m_pDiplomacyRequests;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::HasActiveDiplomacyRequests() const
{
	PlayerTypes ePlayer = GetID();

	// Do I have any?
	CvDiplomacyRequests* pkDiploRequests = GetDiplomacyRequests();
	if(pkDiploRequests && pkDiploRequests->HasActiveRequest())
		return true;
#if defined(MOD_ACTIVE_DIPLOMACY)
	if (!MOD_ACTIVE_DIPLOMACY || !GC.getGame().isReallyNetworkMultiPlayer())
	{
#endif
		// Do I have any for others?
		for (int i = 0; i < MAX_PLAYERS; ++i)
		{
			const CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)i);
			if (kPlayer.isAlive())
			{
				pkDiploRequests = kPlayer.GetDiplomacyRequests();
				if (pkDiploRequests)
				{
					if (pkDiploRequests->HasActiveRequestFrom(ePlayer))
						return true;
				}
			}
		}
#if defined(MOD_ACTIVE_DIPLOMACY)
	}
#endif
	return false;
}

//	--------------------------------------------------------------------------------
//
// read object from a stream
// used during load
//
void CvPlayer::Read(FDataStream& kStream)
{
	// Init data before load
	reset();

	// Version number to maintain backwards compatibility
	uint uiVersion;
	kStream >> uiVersion;
	MOD_SERIALIZE_INIT_READ(kStream);

#if defined(MOD_BALANCE_CORE)
	kStream >> m_syncArchive;
	//Values below deleted, as they're already in the sync archive! Use the sync archive from now on!
#endif

	m_pPlayerPolicies->Read(kStream);
	m_pEconomicAI->Read(kStream);
	m_pCitySpecializationAI->Read(kStream);
	m_pWonderProductionAI->Read(kStream);
	m_pMilitaryAI->Read(kStream);
	m_pGrandStrategyAI->Read(kStream);
	m_pDiplomacyAI->Read(kStream);
	m_pReligions->Read(kStream);
	m_pReligionAI->Read(kStream);
#if defined(MOD_BALANCE_CORE)
	m_pCorporations->Read(kStream);
#endif
	m_pPlayerTechs->Read(kStream);
	m_pFlavorManager->Read(kStream);
	m_pTacticalAI->Read(kStream);
	m_pHomelandAI->Read(kStream);
	m_pMinorCivAI->Read(kStream);
	m_pDealAI->Read(kStream);
	m_pBuilderTaskingAI->Read(kStream);
	m_pCityConnections->Read(kStream);
	m_pDangerPlots->Read(kStream);
	m_pTraits->Read(kStream);
	kStream >> *m_pEspionage;
	kStream >> *m_pEspionageAI;
	kStream >> *m_pTrade;
	kStream >> *m_pTradeAI;
	m_pLeagueAI->Read(kStream);
	kStream >> *m_pCulture;

	bool bReadNotifications;
	kStream >> bReadNotifications;
	if(bReadNotifications)
	{
		if (!m_pNotifications)
			m_pNotifications = FNEW(CvNotifications, c_eCiv5GameplayDLL, 0);
		m_pNotifications->Init(GetID());
		m_pNotifications->Read(kStream);
	}
	m_pTreasury->Read(kStream);

	// If this is a real player, hook up the player-level flavor recipients
	if(GetID() != NO_PLAYER)
	{
		SlotStatus s = CvPreGame::slotStatus(GetID());
		if((s == SS_TAKEN || s == SS_COMPUTER) && !isBarbarian())
		{
			m_pFlavorManager->AddFlavorRecipient(m_pPlayerTechs,        false /*bPropogateFlavors*/);
			m_pFlavorManager->AddFlavorRecipient(m_pPlayerPolicies,     false /*bPropogateFlavors*/);
			m_pFlavorManager->AddFlavorRecipient(m_pWonderProductionAI, false /*bPropogateFlavors*/);
		}
	}

	kStream >> m_researchQueue;
	kStream >> m_eEndTurnBlockingType;
	kStream >> m_iEndTurnBlockingNotificationIndex;

	kStream >> m_cityNames;

	kStream >> m_cities;
#if defined(MOD_BALANCE_CORE_SETTLER)
	SetClosestCityMapDirty();
#endif

	kStream >> m_units;
	kStream >> m_armyAIs;

	{
		m_AIOperations.clear();
		uint iSize;
		int iID;
		int iOperationType;
		kStream >> iSize;
		for(uint i = 0; i < iSize; i++)
		{
			kStream >> iID;
			kStream >> iOperationType;
			CvAIOperation* pThisOperation = CvAIOperation::CreateOperation((AIOperationTypes)iOperationType);
			pThisOperation->Read(kStream);
			m_AIOperations.insert(std::make_pair(pThisOperation->GetID(), pThisOperation));
		}
	}

	if (uiVersion <= 10)
	{
		// Unused popup queue
		int iSize;
		kStream >> iSize;
		CvAssert(iSize == 0);
	}

	kStream >> m_ReplayDataSets;
	kStream >> m_ReplayDataSetValues;

	kStream >> m_ppiInstantYieldHistoryValues;

	kStream >> m_aVote;
	kStream >> m_aUnitExtraCosts;

	// reading plot values
	kStream >> m_aiPlots;

	if(!isBarbarian())
	{
		// Get the NetID from the initialization structure
		setNetID(gDLL->getAssignedNetworkID(GetID()));
	}

	m_bfEverConqueredBy.ClearAll();
	int iSize;
	kStream >> iSize;
	for(int i = 0; i < iSize; i++)
	{
		bool bValue;
		kStream >> bValue;
		if(bValue)
		{
			m_bfEverConqueredBy.SetBit(i);
		}
	}

	kStream >> m_strEmbarkedGraphicOverride;
	m_kPlayerAchievements.Read(kStream);

	if(GetID() < MAX_MAJOR_CIVS)
	{
		if(!m_pDiplomacyRequests)
			m_pDiplomacyRequests = FNEW(CvDiplomacyRequests, c_eCiv5GameplayDLL, 0);
		else
			m_pDiplomacyRequests->Uninit();

		m_pDiplomacyRequests->Init(GetID());
		m_pDiplomacyRequests->Read(kStream);
	}

	if(m_bTurnActive)
		GC.getGame().changeNumGameTurnActive(1, std::string("setTurnActive() [loading save game] for player ") + getName());

#if defined(MOD_API_UNIFIED_YIELDS) && defined(MOD_API_PLOT_YIELDS)
	// MOD_SERIALIZE_READ - v57/v58/v59 broke the save format  couldn't be helped, but don't make a habit of it!!!
	kStream >> m_ppiPlotYieldChange;
#endif
#if defined(MOD_API_UNIFIED_YIELDS)
	// MOD_SERIALIZE_READ - v57/v58/v59 and v61 broke the save format  couldn't be helped, but don't make a habit of it!!!
	kStream >> m_ppiImprovementYieldChange;
	kStream >> m_ppiFeatureYieldChange;
	kStream >> m_ppiResourceYieldChange;
	kStream >> m_ppiTerrainYieldChange;
	kStream >> m_ppiTradeRouteYieldChange;
	kStream >> m_ppiSpecialistYieldChange;
	kStream >> m_ppiGreatPersonExpendedYield;
	kStream >> m_piGoldenAgeGreatPersonRateModifier;
	kStream >> m_ppiUnimprovedFeatureYieldChange;
	kStream >> m_ppiCityYieldFromUnimprovedFeature;
	kStream >> m_piYieldFromKills;
	kStream >> m_piYieldFromBarbarianKills;
	kStream >> m_piYieldChangeTradeRoute;
	kStream >> m_piYieldChangesNaturalWonder;
	kStream >> m_piYieldChangeWorldWonder;
	kStream >> m_piYieldFromMinorDemand;
	kStream >> m_piYieldFromWLTKD;
	kStream >> m_ppiBuildingClassYieldChange;
	kStream >> m_piCityFeatures;
	kStream >> m_piNumBuildings;
	kStream >> m_piNumBuildingsInPuppets;
	kStream >> m_ppiApproachScratchValue;
#endif
#if defined(MOD_BALANCE_CORE)
/// MODDED ELEMENTS BELOW
	UpdateAreaEffectUnits();
	UpdateAreaEffectPlots();
	GET_TEAM(getTeam()).updateTeamStatus();
	UpdateCurrentAndFutureWars();

	int iLoop=0;
	for (CvCity* pCity=firstCity(&iLoop); pCity!=NULL; pCity=nextCity(&iLoop))
	{
		pCity->GetClosestFriendlyNeighboringCities();
	}
#endif
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	kStream >> m_pabHasGlobalMonopoly;
	kStream >> m_pabHasStrategicMonopoly;

	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		if (MOD_BALANCE_CORE_RESOURCE_MONOPOLIES && m_pabHasGlobalMonopoly[iResourceLoop])
		{
			SetHasGlobalMonopoly((ResourceTypes)iResourceLoop, true);
		}
		if (MOD_BALANCE_CORE_RESOURCE_MONOPOLIES_STRATEGIC && m_pabHasStrategicMonopoly[iResourceLoop])
		{
			SetHasStrategicMonopoly((ResourceTypes)iResourceLoop, true);
		}
	}
	kStream >> m_noSettlingPlots;
#endif
}

//	--------------------------------------------------------------------------------
//
// save object to a stream
// used during save
//
void CvPlayer::Write(FDataStream& kStream) const
{
	//Save version number.  THIS MUST BE FIRST!!
	kStream << g_CurrentCvPlayerVersion;
	MOD_SERIALIZE_INIT_WRITE(kStream);

#if defined(MOD_BALANCE_CORE)
	kStream << m_syncArchive;
	//Values below deleted, as they're already in the sync archive! Use the sync archive from now on!
#endif
	m_pPlayerPolicies->Write(kStream);
	m_pEconomicAI->Write(kStream);
	m_pCitySpecializationAI->Write(kStream);
	m_pWonderProductionAI->Write(kStream);
	m_pMilitaryAI->Write(kStream);
	m_pGrandStrategyAI->Write(kStream);
	m_pDiplomacyAI->Write(kStream);
	m_pReligions->Write(kStream);
	m_pReligionAI->Write(kStream);
#if defined(MOD_BALANCE_CORE)
	m_pCorporations->Write(kStream);
#endif
	m_pPlayerTechs->Write(kStream);
	m_pFlavorManager->Write(kStream);
	m_pTacticalAI->Write(kStream);
	m_pHomelandAI->Write(kStream);
	m_pMinorCivAI->Write(kStream);
	m_pDealAI->Write(kStream);
	m_pBuilderTaskingAI->Write(kStream);
	m_pCityConnections->Write(kStream);
	m_pDangerPlots->Write(kStream);
	m_pTraits->Write(kStream);
	kStream << *m_pEspionage;
	kStream << *m_pEspionageAI;
	kStream << *m_pTrade;
	kStream << *m_pTradeAI;
	m_pLeagueAI->Write(kStream);
	kStream << *m_pCulture;

	if(m_pNotifications)
	{
		kStream << true;
		m_pNotifications->Write(kStream);
	}
	else
	{
		kStream << false;
	}
	m_pTreasury->Write(kStream);

	kStream << m_researchQueue;
	kStream << m_eEndTurnBlockingType;
	kStream << m_iEndTurnBlockingNotificationIndex;

	kStream << m_cityNames;
	kStream << m_cities;
	kStream << m_units;
	kStream << m_armyAIs;

	{
		uint iSize = m_AIOperations.size();
		kStream << iSize;
		std::map<int, CvAIOperation*>::const_iterator it;
		for(it = m_AIOperations.begin(); it != m_AIOperations.end(); ++it)
		{
			kStream << it->first;
			CvAIOperation* pThisOperation = it->second;
			kStream << pThisOperation->GetOperationType();
			pThisOperation->Write(kStream);
		}
	}

	kStream << m_ReplayDataSets;
	kStream << m_ReplayDataSetValues;
	
	kStream << m_ppiInstantYieldHistoryValues;

	kStream << m_aVote;
	kStream << m_aUnitExtraCosts;

	kStream << m_aiPlots;

	// writing out
	{
		int iSize = MAX_PLAYERS;
		kStream << iSize;
		for(int i = 0; i < iSize; i++)
		{
			bool bValue = m_bfEverConqueredBy.GetBit(i);
			kStream << bValue;
		}
	}

	kStream << m_strEmbarkedGraphicOverride;

	m_kPlayerAchievements.Write(kStream);
	
	if (GetID() < MAX_MAJOR_CIVS)
		m_pDiplomacyRequests->Write(kStream);	
	
#if defined(MOD_API_UNIFIED_YIELDS) && defined(MOD_API_PLOT_YIELDS)
	// MOD_SERIALIZE_READ - v57/v58/v59 broke the save format  couldn't be helped, but don't make a habit of it!!!
	kStream << m_ppiPlotYieldChange;
#endif
#if defined(MOD_API_UNIFIED_YIELDS)
	// MOD_SERIALIZE_READ - v57/v58/v59 and v61 broke the save format  couldn't be helped, but don't make a habit of it!!!
	kStream << m_ppiImprovementYieldChange;
	kStream << m_ppiFeatureYieldChange;
	kStream << m_ppiResourceYieldChange;
	kStream << m_ppiTerrainYieldChange;
	kStream << m_ppiTradeRouteYieldChange;
	kStream << m_ppiSpecialistYieldChange;
	kStream << m_ppiGreatPersonExpendedYield;
	kStream << m_piGoldenAgeGreatPersonRateModifier;
	kStream << m_ppiUnimprovedFeatureYieldChange;
	kStream << m_ppiCityYieldFromUnimprovedFeature;
	kStream << m_piYieldFromKills;
	kStream << m_piYieldFromBarbarianKills;
	kStream << m_piYieldChangeTradeRoute;
	kStream << m_piYieldChangesNaturalWonder;
	kStream << m_piYieldChangeWorldWonder;
	kStream << m_piYieldFromMinorDemand;
	kStream << m_piYieldFromWLTKD;
	kStream << m_ppiBuildingClassYieldChange;
	kStream << m_piCityFeatures;
	kStream << m_piNumBuildings;
	kStream << m_piNumBuildingsInPuppets;
	kStream << m_ppiApproachScratchValue;
#endif
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	kStream << m_pabHasGlobalMonopoly;
	kStream << m_pabHasStrategicMonopoly;
	kStream << m_noSettlingPlots;
#endif
}

//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
void CvPlayer::createGreatGeneral(UnitTypes eGreatPersonUnit, int iX, int iY, bool bIsFree)
#else
void CvPlayer::createGreatGeneral(UnitTypes eGreatPersonUnit, int iX, int iY)
#endif
{
	CvUnit* pGreatPeopleUnit = initUnit(eGreatPersonUnit, iX, iY);
	if(NULL == pGreatPeopleUnit)
	{
		CvAssert(false);
		return;
	}
#if defined(MOD_BALANCE_CORE)
	if(GetPlayerTraits()->IsGPWLTKD() && pGreatPeopleUnit != NULL)
	{
		CvCity* pCity = pGreatPeopleUnit->plot()->getOwningCity();
		if (pCity != NULL && pCity->getOwner() == GetID())
		{
			int iWLTKD = (GC.getCITY_RESOURCE_WLTKD_TURNS() / 3);

			iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iWLTKD /= 100;

			if (iWLTKD > 0)
			{
				pCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
				CvNotifications* pNotifications = GetNotifications();
				if (pNotifications)
				{
					Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UA");
					strText << pGreatPeopleUnit->getNameKey() << pCity->getNameKey();
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UA");
					strSummary << pCity->getNameKey();
					pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), -1);
				}
			}
		}
	}
	if(pGreatPeopleUnit->isWLKTKDOnBirth())
	{
		CvCity* pLoopCity;
		int iLoop;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity != NULL && pLoopCity->getOwner() == GetID())
			{
				int iWLTKD = (GC.getCITY_RESOURCE_WLTKD_TURNS() / 3);

				iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iWLTKD /= 100;

				if (iWLTKD > 0)
				{
					pLoopCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
					CvNotifications* pNotifications = GetNotifications();
					if (pNotifications)
					{
						Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UNIT");
						strText << pGreatPeopleUnit->getNameKey() << pLoopCity->getNameKey();
						Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UNIT");
						strSummary << pLoopCity->getNameKey();
						pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pLoopCity->getX(), pLoopCity->getY(), -1);
					}
				}
			}
		}
	}
	if(pGreatPeopleUnit->getUnitInfo().IsFoundReligion())
	{
		ReligionTypes eReligion = GetReligions()->GetReligionCreatedByPlayer();
		int iReligionSpreads = pGreatPeopleUnit->getUnitInfo().GetReligionSpreads();
		int iReligiousStrength = pGreatPeopleUnit->getUnitInfo().GetReligiousStrength();
		iReligiousStrength *= (100 + GetPlayerTraits()->GetExtraMissionaryStrength());
		iReligiousStrength /= 100;
		if(iReligionSpreads > 0 && eReligion > RELIGION_PANTHEON)
		{
			pGreatPeopleUnit->GetReligionData()->SetSpreadsLeft(iReligionSpreads);
			pGreatPeopleUnit->GetReligionData()->SetReligiousStrength(iReligiousStrength);
			pGreatPeopleUnit->GetReligionData()->SetReligion(eReligion);
		}
	}
	if(pGreatPeopleUnit->isGoldenAgeOnBirth())
	{
		int iGoldenAgeTurns = getGoldenAgeLength();
		int iValue = GetGoldenAgeProgressMeter();
		changeGoldenAgeTurns(iGoldenAgeTurns, iValue);
	}
	if(pGreatPeopleUnit->isCultureBoost())
	{
		int iValue = GetTotalJONSCulturePerTurn() * 4;
		changeJONSCulture(iValue);
		if(getCapitalCity() != NULL)
		{
			getCapitalCity()->ChangeJONSCultureStored(iValue);
		}
		CvNotifications* pNotifications = GetNotifications();
		if (pNotifications)
		{
			Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CULTURE_UNIT");
			strText << pGreatPeopleUnit->getNameKey();
			Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CULTURE_UNIT");
			strSummary << pGreatPeopleUnit->getNameKey();
			pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pGreatPeopleUnit->getX(), pGreatPeopleUnit->getY(), -1);
		}
	}
	if(pGreatPeopleUnit->IsCombatUnit() && getCapitalCity() != NULL)
	{
		getCapitalCity()->addProductionExperience(pGreatPeopleUnit);
		pGreatPeopleUnit->setOriginCity(getCapitalCity()->GetID());
	}
#endif
	ChangeNumGreatPeople(1);

#if defined(MOD_GLOBAL_TRULY_FREE_GP)
	incrementGreatGeneralsCreated(bIsFree);
#else
	incrementGreatGeneralsCreated();
#endif

#if defined(MOD_GLOBAL_TRULY_FREE_GP)
	changeGreatGeneralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE() * ((getGreatGeneralsCreated(bIsFree) / 10) + 1));
#else
	changeGreatGeneralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE() * ((getGreatGeneralsCreated() / 10) + 1));
#endif

	for(int iI = 0; iI < MAX_PLAYERS; iI++)
	{
		if(GET_PLAYER((PlayerTypes)iI).getTeam() == getTeam())
		{
#if defined(MOD_BUGFIX_MINOR)
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
			GET_PLAYER((PlayerTypes)iI).changeGreatGeneralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE_TEAM() * ((getGreatGeneralsCreated(bIsFree) / 10) + 1));
#else
			GET_PLAYER((PlayerTypes)iI).changeGreatGeneralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE_TEAM() * ((getGreatGeneralsCreated() / 10) + 1));
#endif
#else
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
			GET_PLAYER((PlayerTypes)iI).changeGreatGeneralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE_TEAM() * ((getGreatPeopleCreated(bIsFree) / 10) + 1));
#else
			GET_PLAYER((PlayerTypes)iI).changeGreatGeneralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE_TEAM() * ((getGreatPeopleCreated() / 10) + 1));
#endif
#endif
		}
	}

#if defined(MOD_GLOBAL_LOCAL_GENERALS)
	CvPlot* pPlot = pGreatPeopleUnit->plot();

	// In rare cases we can gain the general from an embarked unit being attacked, or from a hovering unit over coast
	// so if this plot is water, relocate the Great General
	if (pPlot->isWater() || pGreatPeopleUnit->IsCombatUnit()) {
		pGreatPeopleUnit->jumpToNearestValidPlot();
	}
#else
	CvPlot* pPlot = GC.getMap().plot(iX, iY);
#endif

#if !defined(NO_ACHIEVEMENTS)
	//Achievements and Stats
	if(pGreatPeopleUnit->isHuman() && !GC.getGame().isGameMultiPlayer())
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_GREATGENERALS);
		const char* strLeader = GET_PLAYER(pGreatPeopleUnit->getOwner()).getLeaderTypeKey();
		if(strLeader && strcmp(strLeader, "LEADER_WU_ZETIAN") == 0)
		{
			gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_SUNTZU);
		}

		CvAchievementUnlocker::Check_PSG();
	}
#endif
	// Notification
	if(GetNotifications())
	{
		Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER");
		Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_GREAT_PERSON");
		GetNotifications()->Add(NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER, strText.toUTF8(), strSummary.toUTF8(), pPlot->getX(), pPlot->getY(), eGreatPersonUnit);
	}
}

//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
void CvPlayer::createGreatAdmiral(UnitTypes eGreatPersonUnit, int iX, int iY, bool bIsFree)
#else
void CvPlayer::createGreatAdmiral(UnitTypes eGreatPersonUnit, int iX, int iY)
#endif
{
	CvUnit* pGreatPeopleUnit = initUnit(eGreatPersonUnit, iX, iY);
	if(NULL == pGreatPeopleUnit)
	{
		CvAssert(false);
		return;
	}
#if defined(MOD_BALANCE_CORE)
	if(GetPlayerTraits()->IsGPWLTKD() && pGreatPeopleUnit != NULL)
	{
		CvCity* pCity = pGreatPeopleUnit->plot()->getOwningCity();
		if (pCity != NULL && pCity->getOwner() == GetID())
		{
			int iWLTKD = (GC.getCITY_RESOURCE_WLTKD_TURNS() / 3);

			iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iWLTKD /= 100;

			if (iWLTKD > 0)
			{
				pCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
				CvNotifications* pNotifications = GetNotifications();
				if (pNotifications)
				{
					Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UA");
					strText << pGreatPeopleUnit->getNameKey() << pCity->getNameKey();
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UA");
					strSummary << pCity->getNameKey();
					pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pCity->getX(), pCity->getY(), -1);
				}
			}
		}
	}
	if(pGreatPeopleUnit->isWLKTKDOnBirth())
	{
		CvCity* pLoopCity;
		int iLoop;
		for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		{
			if(pLoopCity != NULL && pLoopCity->getOwner() == GetID())
			{
				int iWLTKD = (GC.getCITY_RESOURCE_WLTKD_TURNS() / 3);

				iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iWLTKD /= 100;

				if (iWLTKD > 0)
				{
					pLoopCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
					CvNotifications* pNotifications = GetNotifications();
					if (pNotifications)
					{
						Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UNIT");
						strText << pGreatPeopleUnit->getNameKey() << pLoopCity->getNameKey();
						Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UNIT");
						strSummary << pLoopCity->getNameKey();
						pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pLoopCity->getX(), pLoopCity->getY(), -1);
					}
				}
			}
		}
	}
	if(pGreatPeopleUnit->isGoldenAgeOnBirth())
	{
		int iGoldenAgeTurns = getGoldenAgeLength();
		int iValue = GetGoldenAgeProgressMeter();
		changeGoldenAgeTurns(iGoldenAgeTurns, iValue);
	}
	if(pGreatPeopleUnit->isCultureBoost())
	{
		int iValue = GetTotalJONSCulturePerTurn() * 4;
		changeJONSCulture(iValue);
		if(getCapitalCity() != NULL)
		{
			getCapitalCity()->ChangeJONSCultureStored(iValue);
		}
		CvNotifications* pNotifications = GetNotifications();
		if (pNotifications)
		{
			Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CULTURE_UNIT");
			strText << pGreatPeopleUnit->getNameKey();
			Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CULTURE_UNIT");
			strSummary << pGreatPeopleUnit->getNameKey();
			pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pGreatPeopleUnit->getX(), pGreatPeopleUnit->getY(), -1);
		}
	}
	if(pGreatPeopleUnit->IsCombatUnit())
	{
		getCapitalCity()->addProductionExperience(pGreatPeopleUnit);
	}
#endif
	ChangeNumGreatPeople(1);
#if !defined(MOD_GLOBAL_LOCAL_GENERALS)
	CvPlot *pSpawnPlot = GetGreatAdmiralSpawnPlot(pGreatPeopleUnit);
	if (pGreatPeopleUnit->plot() != pSpawnPlot)
	{
		pGreatPeopleUnit->setXY(pSpawnPlot->getX(), pSpawnPlot->getY());
	}
#endif

#if defined(MOD_GLOBAL_TRULY_FREE_GP)
	incrementGreatAdmiralsCreated(bIsFree);
#else
	incrementGreatAdmiralsCreated();
#endif
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
	changeGreatAdmiralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE() * ((getGreatAdmiralsCreated(bIsFree) / 10) + 1));
#else
	changeGreatAdmiralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE() * ((getGreatAdmiralsCreated() / 10) + 1));
#endif

	for(int iI = 0; iI < MAX_PLAYERS; iI++)
	{
		if(GET_PLAYER((PlayerTypes)iI).getTeam() == getTeam())
		{
#if defined(MOD_BUGFIX_MINOR)
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
			GET_PLAYER((PlayerTypes)iI).changeGreatAdmiralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE_TEAM() * ((getGreatAdmiralsCreated(bIsFree) / 10) + 1));
#else
			GET_PLAYER((PlayerTypes)iI).changeGreatAdmiralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE_TEAM() * ((getGreatAdmiralsCreated() / 10) + 1));
#endif
#else
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
			GET_PLAYER((PlayerTypes)iI).changeGreatAdmiralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE_TEAM() * ((getGreatPeopleCreated(bIsFree) / 10) + 1));
#else
			GET_PLAYER((PlayerTypes)iI).changeGreatAdmiralsThresholdModifier(/*50*/ GC.getGREAT_GENERALS_THRESHOLD_INCREASE_TEAM() * ((getGreatPeopleCreated() / 10) + 1));
#endif
#endif
		}
	}

	CvPlot* pPlot = GC.getMap().plot(iX, iY);

	// Notification
	if(GetNotifications())
	{
		Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER");
		Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_GREAT_PERSON");
		GetNotifications()->Add(NOTIFICATION_GREAT_PERSON_ACTIVE_PLAYER, strText.toUTF8(), strSummary.toUTF8(), pPlot->getX(), pPlot->getY(), eGreatPersonUnit);
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::launch(VictoryTypes eVictory)
{
	CvTeam& kTeam = GET_TEAM(getTeam());

	if(!kTeam.canLaunch(eVictory))
	{
		return;
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::getUnitExtraCost(UnitClassTypes eUnitClass) const
{
	for(std::vector< std::pair<UnitClassTypes, int> >::const_iterator it = m_aUnitExtraCosts.begin(); it != m_aUnitExtraCosts.end(); ++it)
	{
		if((*it).first == eUnitClass)
		{
			return ((*it).second);
		}
	}

	return 0;
}

//	--------------------------------------------------------------------------------
void CvPlayer::setUnitExtraCost(UnitClassTypes eUnitClass, int iCost)
{
	for(std::vector< std::pair<UnitClassTypes, int> >::iterator it = m_aUnitExtraCosts.begin(); it != m_aUnitExtraCosts.end(); ++it)
	{
		if((*it).first == eUnitClass)
		{
			if(0 == iCost)
			{
				m_aUnitExtraCosts.erase(it);
			}
			else
			{
				(*it).second = iCost;
			}
			return;
		}
	}

	if(0 != iCost)
	{
		m_aUnitExtraCosts.push_back(std::make_pair(eUnitClass, iCost));
	}
}

// CACHE: cache frequently used values
///////////////////////////////////////

//	--------------------------------------------------------------------------------
void CvPlayer::invalidatePopulationRankCache()
{
	int iLoop;
	CvCity* pLoopCity;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->invalidatePopulationRankCache();
	}
}

//	--------------------------------------------------------------------------------
void CvPlayer::invalidateYieldRankCache(YieldTypes)
{
	int iLoop;
	CvCity* pLoopCity;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->invalidateYieldRankCache();
	}
}

//	--------------------------------------------------------------------------------
PlayerTypes CvPlayer::pickConqueredCityOwner(const CvCity& kCity) const
{
	PlayerTypes eBestPlayer = kCity.getOriginalOwner();

	if(NO_PLAYER != eBestPlayer)
	{
		CvPlayer& kBestPlayer = GET_PLAYER(eBestPlayer);

		if(kBestPlayer.getTeam() == getTeam())
		{
			return eBestPlayer;
		}
	}

	return GetID();
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canStealTech(PlayerTypes eTarget, TechTypes eTech) const
{
	if(GET_TEAM(GET_PLAYER(eTarget).getTeam()).GetTeamTechs()->HasTech(eTech))
	{
		if(GetPlayerTechs()->CanResearch(eTech))
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canSpyDestroyUnit(PlayerTypes, CvUnit& kUnit) const
{
	if(kUnit.getTeam() == getTeam())
	{
		return false;
	}

	if(kUnit.getUnitInfo().GetProductionCost() <= 0)
	{
		return false;
	}

	if(!kUnit.plot()->isVisible(getTeam()))
	{
		return false;
	}

	return true;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canSpyBribeUnit(PlayerTypes eTarget, CvUnit& kUnit) const
{
	if(!canSpyDestroyUnit(eTarget, kUnit))
	{
		return false;
	}

	// Can't buy units when at war
	if(kUnit.isEnemy(getTeam()))
	{
		return false;
	}

	IDInfo* pUnitNode = kUnit.plot()->headUnitNode();

	while(pUnitNode != NULL)
	{
		CvUnit* pLoopUnit = ::getUnit(*pUnitNode);
		pUnitNode = kUnit.plot()->nextUnitNode(pUnitNode);

		if(NULL != pLoopUnit && pLoopUnit != &kUnit)
		{
			if(pLoopUnit->isEnemy(getTeam()))
			{
				// If we buy the unit, we will be on the same plot as an enemy unit! Not good.
				return false;
			}
		}
	}

	return true;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canSpyDestroyBuilding(PlayerTypes, BuildingTypes eBuilding) const
{
	CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
	if(pkBuilding)
	{
		if(pkBuilding->GetProductionCost() <= 0)
		{
			return false;
		}

		if(::isLimitedWonderClass(pkBuilding->GetBuildingClassInfo()))
		{
			return false;
		}
	}

	return true;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::canSpyDestroyProject(PlayerTypes eTarget, ProjectTypes eProject) const
{
	CvProjectEntry& kProject = *GC.getProjectInfo(eProject);
	if(kProject.GetProductionCost() <= 0)
	{
		return false;
	}

	if(GET_TEAM(GET_PLAYER(eTarget).getTeam()).getProjectCount(eProject) <= 0)
	{
		return false;
	}

	if(::isWorldProject(eProject))
	{
		return false;
	}

	if(!kProject.IsSpaceship())
	{
		return false;
	}
	else
	{
		VictoryTypes eVictory = (VictoryTypes)kProject.GetVictoryPrereq();
		if(NO_VICTORY != eVictory)
		{
			// Can't destroy spaceship components if we have already launched
			if(GET_TEAM(GET_PLAYER(eTarget).getTeam()).getVictoryCountdown(eVictory) >= 0)
			{
				return false;
			}
		}
	}

	return true;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getNewCityProductionValue() const
{
	if(GC.getSETTLER_PRODUCTION_SPEED() != 0)
	{
		return GC.getSETTLER_PRODUCTION_SPEED();
	}

	int iValue = 0;
	for(int iJ = 0; iJ < GC.getNumBuildingClassInfos(); iJ++)
	{
		const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iJ);
		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
		if(pkBuildingClassInfo)
		{
			const BuildingTypes eBuilding = ((BuildingTypes)(getCivilizationInfo().getCivilizationBuildings(iJ)));
			if(NO_BUILDING != eBuilding)
			{
				CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
				if(pkBuildingInfo)
				{
					if(pkBuildingInfo->GetFreeStartEra() != NO_ERA)
					{
						if(GC.getGame().getStartEra() >= pkBuildingInfo->GetFreeStartEra())
						{
							iValue += (100 * getProductionNeeded(eBuilding)) / std::max(1, 100 + getProductionModifier(eBuilding));
						}
					}
				}
			}
		}
	}

	iValue *= 100 + GC.getNEW_CITY_BUILDING_VALUE_MODIFIER();
	iValue /= 100;

	CvGame& kGame = GC.getGame();

	iValue += (GC.getADVANCED_START_CITY_COST() * kGame.getGameSpeedInfo().getGrowthPercent()) / 100;

	int iPopulation = GC.getINITIAL_CITY_POPULATION() + kGame.getStartEraInfo().getFreePopulation();
	for(int i = 1; i <= iPopulation; ++i)
	{
		iValue += (getGrowthThreshold(i) * GC.getADVANCED_START_POPULATION_COST()) / 100;
	}

	return iValue;
}

//	--------------------------------------------------------------------------------
int CvPlayer::getGrowthThreshold(int iPopulation) const
{
	CvAssertMsg(iPopulation > 0, "Population of city should be at least 1. Please show Jon this and send your last 5 autosaves.");

	int iThreshold;

	int iBaseThreshold = /*15*/ GC.getBASE_CITY_GROWTH_THRESHOLD();

	int iExtraPopThreshold = int((iPopulation-1) * /*6*/ GC.getCITY_GROWTH_MULTIPLIER());

	iBaseThreshold += iExtraPopThreshold;
	iExtraPopThreshold = (int) pow(double(iPopulation-1), (double) /*1.8*/ GC.getCITY_GROWTH_EXPONENT());

	iThreshold = iBaseThreshold + iExtraPopThreshold;

	if(isMinorCiv())
	{
		iThreshold *= GC.getMINOR_CIV_GROWTH_PERCENT();
		iThreshold /= 100;
	}

	iThreshold *= GC.getGame().getGameSpeedInfo().getGrowthPercent();
	iThreshold /= 100;

	iThreshold *= GC.getGame().getStartEraInfo().getGrowthPercent();
	iThreshold /= 100;

	if(!isHuman() && !IsAITeammateOfHuman() && !isBarbarian())
	{
		iThreshold *= GC.getGame().getHandicapInfo().getAIGrowthPercent();
		iThreshold /= 100;

		iThreshold *= std::max(0, ((GC.getGame().getHandicapInfo().getAIPerEraModifier() * GetCurrentEra()) + 100));
		iThreshold /= 100;
	}

	return std::max(1, iThreshold);
}

//	--------------------------------------------------------------------------------
/// This determines what plots the player has under control
void CvPlayer::UpdatePlots(void)
{
	m_aiPlots.clear();

	int iNumPlotsInEntireWorld = GC.getMap().numPlots();
	for(int iI = 0; iI < iNumPlotsInEntireWorld; iI++)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);
		if(pLoopPlot->getOwner() != m_eID)
			continue;

		//somebody might have plundered an improvement
		pLoopPlot->updateWaterFlags();

		m_aiPlots.push_back(iI);
	}
}

//	--------------------------------------------------------------------------------
/// Adds a plot at the end of the list
void CvPlayer::AddAPlot(CvPlot* pPlot)
{
	if(!pPlot)
		return;

	m_aiPlots.push_back(pPlot->GetPlotIndex());
}

//	--------------------------------------------------------------------------------
/// Returns the list of the plots the player owns
const PlotIndexContainer& CvPlayer::GetPlots(void) const
{
	return m_aiPlots;
}

//	--------------------------------------------------------------------------------
/// How many plots does this player own?
int CvPlayer::GetNumPlots() const
{
	return m_aiPlots.size();
}


//	--------------------------------------------------------------------------------
/// City strength mod (i.e. 100 = strength doubled)
int CvPlayer::GetCityStrengthMod() const
{
	return m_iCityStrengthMod;
}

//	--------------------------------------------------------------------------------
/// Sets City strength mod (i.e. 100 = strength doubled)
void CvPlayer::SetCityStrengthMod(int iValue)
{
	CvAssert(iValue >= 0);
	m_iCityStrengthMod = iValue;

	// Loop through all Cities and update their strength
	CvCity* pLoopCity;
	int iLoop;

	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		pLoopCity->updateStrengthValue();
	}
}

//	--------------------------------------------------------------------------------
/// Changes City strength mod (i.e. 100 = strength doubled)
void CvPlayer::ChangeCityStrengthMod(int iChange)
{
	if(iChange != 0)
	{
		SetCityStrengthMod(GetCityStrengthMod() + iChange);
	}
}

//	--------------------------------------------------------------------------------
/// City growth percent mod (i.e. 100 = foodDifference doubled)
int CvPlayer::GetCityGrowthMod() const
{
	return m_iCityGrowthMod;
}

//	--------------------------------------------------------------------------------
/// Sets City growth percent mod (i.e. 100 = foodDifference doubled)
void CvPlayer::SetCityGrowthMod(int iValue)
{
	CvAssert(iValue >= 0);
	m_iCityGrowthMod = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes City growth percent mod (i.e. 100 = foodDifference doubled)
void CvPlayer::ChangeCityGrowthMod(int iChange)
{
	if(iChange != 0)
	{
		SetCityGrowthMod(GetCityGrowthMod() + iChange);
	}
}


//	--------------------------------------------------------------------------------
/// Capital growth percent mod (i.e. 100 = foodDifference doubled)
int CvPlayer::GetCapitalGrowthMod() const
{
	return m_iCapitalGrowthMod;
}

//	--------------------------------------------------------------------------------
/// Sets Capital growth percent mod (i.e. 100 = foodDifference doubled)
void CvPlayer::SetCapitalGrowthMod(int iValue)
{
	CvAssert(iValue >= 0);
	m_iCapitalGrowthMod = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes Capital growth percent mod (i.e. 100 = foodDifference doubled)
void CvPlayer::ChangeCapitalGrowthMod(int iChange)
{
	if(iChange != 0)
	{
		SetCapitalGrowthMod(GetCapitalGrowthMod() + iChange);
	}
}

//	--------------------------------------------------------------------------------
/// How many Plot has this player bought (costs should ramp up as more are purchased)
int CvPlayer::GetNumPlotsBought() const
{
	return m_iNumPlotsBought;
}

//	--------------------------------------------------------------------------------
/// Sets how many Plot has this player bought (costs should ramp up as more are purchased)
void CvPlayer::SetNumPlotsBought(int iValue)
{
	CvAssert(iValue >= 0);
	m_iNumPlotsBought = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes how many Plot has this player bought (costs should ramp up as more are purchased)
void CvPlayer::ChangeNumPlotsBought(int iChange)
{
	if(iChange != 0)
	{
		SetNumPlotsBought(GetNumPlotsBought() + iChange);
	}
}

//	--------------------------------------------------------------------------------
/// Gold cost of buying a new Plot
int CvPlayer::GetBuyPlotCost() const
{
	int iCost = /*50*/ GC.getPLOT_BASE_COST();
	iCost += (/*5*/ GC.getPLOT_ADDITIONAL_COST_PER_PLOT() * GetNumPlotsBought());

	// Cost Mod (Policies, etc.)
	if(GetPlotGoldCostMod() != 0)
	{
		iCost *= (100 + GetPlotGoldCostMod());
		iCost /= 100;
	}

	if(isMinorCiv())
	{
		iCost *= /*200*/ GC.getMINOR_CIV_GOLD_PERCENT();
		iCost /= 100;
	}

	return iCost;
}

//	--------------------------------------------------------------------------------
/// How much of a discount do we have for Plot buying
int CvPlayer::GetPlotGoldCostMod() const
{
	return m_iPlotGoldCostMod;
}

//	--------------------------------------------------------------------------------
/// Changes how much of a discount we have for Plot buying
void CvPlayer::ChangePlotGoldCostMod(int iChange)
{
	if(iChange != 0)
	{
		m_iPlotGoldCostMod += iChange;
	}
}

#if defined(MOD_TRAITS_CITY_WORKING) || defined(MOD_BUILDINGS_CITY_WORKING) || defined(MOD_POLICIES_CITY_WORKING) || defined(MOD_TECHS_CITY_WORKING)
//	--------------------------------------------------------------------------------
/// How many more city rings can we work
int CvPlayer::GetCityWorkingChange() const
{
	return m_iCityWorkingChange;
}

//	--------------------------------------------------------------------------------
/// Changes how many more city rings we can work
void CvPlayer::ChangeCityWorkingChange(int iChange)
{
	if(iChange != 0)
	{
		CvCity* pLoopCity;
		int iLoop;
		
		for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
			int iOldPlots = pLoopCity->GetNumWorkablePlots();
			int iNewPlots = pLoopCity->GetNumWorkablePlots(iChange);
			
			for (int iI = std::min(iOldPlots, iNewPlots); iI < std::max(iOldPlots, iNewPlots); ++iI) {
				CvPlot* pLoopPlot = iterateRingPlots(pLoopCity->getX(), pLoopCity->getY(), iI);

				if (pLoopPlot) {
					pLoopPlot->changeCityRadiusCount(iChange);
					pLoopPlot->changePlayerCityRadiusCount(GetID(), iChange);
				}
			}
		}

		m_iCityWorkingChange += iChange;
	}
}
#endif

//	--------------------------------------------------------------------------------
/// How much Culture is required for this City to acquire a new Plot
int CvPlayer::GetPlotCultureCostModifier() const
{
	return m_iPlotCultureCostModifier;
}

//	--------------------------------------------------------------------------------
/// Changes how much Culture is required for this City to acquire a new Plot
void CvPlayer::ChangePlotCultureCostModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iPlotCultureCostModifier += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// How much do we dampen the exponent used to determine Culture needed for a City to acquire a new Plot?
int CvPlayer::GetPlotCultureExponentModifier() const
{
	return m_iPlotCultureExponentModifier;
}

//	--------------------------------------------------------------------------------
/// Changes how much we dampen the exponent used to determine Culture needed for a City to acquire a new Plot?
void CvPlayer::ChangePlotCultureExponentModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iPlotCultureExponentModifier += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// How much do we dampen the growth of policy costs based on number of cities?
int CvPlayer::GetNumCitiesPolicyCostDiscount() const
{
	return m_iNumCitiesPolicyCostDiscount;
}

//	--------------------------------------------------------------------------------
/// Changes how much we dampen the growth of policy costs based on number of cities
void CvPlayer::ChangeNumCitiesPolicyCostDiscount(int iChange)
{
	if(iChange != 0)
	{
		m_iNumCitiesPolicyCostDiscount += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Do we save on unit maintenance for garrisons?
bool CvPlayer::IsGarrisonFreeMaintenance() const
{
	return m_iGarrisonFreeMaintenanceCount > 0;
}

//	--------------------------------------------------------------------------------
/// Changes setting on unit maintenance for garrisons
void CvPlayer::ChangeGarrisonFreeMaintenanceCount(int iChange)
{
	if(iChange != 0)
	{
		m_iGarrisonFreeMaintenanceCount += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Increase in city range strike due to garrison
int CvPlayer::GetGarrisonedCityRangeStrikeModifier() const
{
	return m_iGarrisonedCityRangeStrikeModifier;
}

//	--------------------------------------------------------------------------------
/// Changes increase in city range strike due to garrison
void CvPlayer::ChangeGarrisonedCityRangeStrikeModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iGarrisonedCityRangeStrikeModifier += iChange;
	}
}

//	--------------------------------------------------------------------------------
/// Cost of purchasing units modified?
int CvPlayer::GetUnitPurchaseCostModifier() const
{
	return m_iUnitPurchaseCostModifier;
}

//	--------------------------------------------------------------------------------
/// Cost of purchasing units modified?
void CvPlayer::ChangeUnitPurchaseCostModifier(int iChange)
{
	if(iChange != 0)
	{
		m_iUnitPurchaseCostModifier += iChange;
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::isEnemyCombatUnitAdjacent(const CvPlot* pPlot, bool bSameDomain) const
{
	if (!pPlot)
		return false;

	if (m_pDangerPlots->IsDirty())
		m_pDangerPlots->UpdateDanger();

	return m_pDangerPlots->isEnemyCombatUnitAdjacent(*pPlot, bSameDomain);
}


int CvPlayer::GetPlotDanger(const CvPlot& pPlot, const CvUnit* pUnit, const UnitIdContainer& unitsToIgnore, AirActionType iAirAction)
{
	if (m_pDangerPlots->IsDirty())
		m_pDangerPlots->UpdateDanger();

	return m_pDangerPlots->GetDanger(pPlot, pUnit, unitsToIgnore, iAirAction);
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetPlotDanger(const CvPlot& pPlot, CvCity* pCity, const CvUnit* pPretendGarrison)
{
	if (m_pDangerPlots->IsDirty())
		m_pDangerPlots->UpdateDanger();

	return m_pDangerPlots->GetDanger(pPlot, pCity, pPretendGarrison);
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetPlotDanger(const CvPlot& pPlot, PlayerTypes ePlayer)
{
	if (m_pDangerPlots->IsDirty())
		m_pDangerPlots->UpdateDanger();

	return m_pDangerPlots->GetDanger(pPlot, ePlayer == NO_PLAYER ? GetID() : ePlayer );
}

void CvPlayer::ResetDangerCache(const CvPlot & Plot, int iRange)
{
	m_pDangerPlots->ResetDangerCache(&Plot, iRange);
}

std::vector<CvUnit*> CvPlayer::GetPossibleAttackers(const CvPlot& Plot)
{
	if (m_pDangerPlots->IsDirty())
		m_pDangerPlots->UpdateDanger();

	return m_pDangerPlots->GetPossibleAttackers(Plot);
}

bool CvPlayer::IsKnownAttacker(const CvUnit* pAttacker)
{
	if (m_pDangerPlots->IsDirty())
		m_pDangerPlots->UpdateDanger();

	return m_pDangerPlots->IsKnownAttacker(pAttacker);
}

void CvPlayer::AddKnownAttacker(const CvUnit* pAttacker)
{
	if (m_pDangerPlots->IsDirty())
		m_pDangerPlots->UpdateDanger();

	m_pDangerPlots->AddKnownAttacker(pAttacker);
}

//	--------------------------------------------------------------------------------
/// Find closest city to a plot (within specified search radius)
CvCity* CvPlayer::GetClosestCity(const CvPlot* pPlot, int iSearchRadius, bool bSameArea )
{
	if (!pPlot)
		return NULL;

	CvCity* pClosestCity = NULL;
	int iBestDistance = INT_MAX;

	int iLoop;
	for(CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		//need to check area
		if (bSameArea && !pLoopCity->isMatchingArea(pPlot))
			continue;

		int iDistance = plotDistance(pPlot->getX(), pPlot->getY(), pLoopCity->getX(), pLoopCity->getY());
		if(iDistance < iBestDistance && iDistance <= iSearchRadius)
		{
			pClosestCity = pLoopCity;
			iBestDistance = iDistance;
		}
	}

	return pClosestCity;
}

//	--------------------------------------------------------------------------------
// How many Puppet Cities does this player own
int CvPlayer::GetNumPuppetCities() const
{
	int iNum = 0;

	const CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity->IsPuppet())
		{
			iNum++;
		}
	}

	return iNum;
}
#if defined(MOD_DIPLOMACY_CITYSTATES_RESOLUTIONS) || defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
// How many other Capital Cities does this player own
int CvPlayer::GetNumCapitalCities() const
{
	int iNum = 0;

	const CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity->IsOriginalMajorCapital() && !pLoopCity->isCapital())
		{
			iNum++;
		}
	}

	return iNum;
}
#endif

#if defined(MOD_BALANCE_CORE_MILITARY)
int CvPlayer::GetFractionOriginalCapitalsUnderControl() const
{
	return m_iFractionOriginalCapitalsUnderControl;
}

void CvPlayer::UpdateMilitaryStats()
{
	m_iFractionOriginalCapitalsUnderControl = 0;
	m_iAvgUnitExp100 = 0;

	int iLoop;
	int iOCCount = 0;
	for(const CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
		//don't count our own capital!
		if(pLoopCity->IsOriginalMajorCapital() && !pLoopCity->isCapital())
			iOCCount++;

	if(iOCCount > 0)
	{
		int iCivCount = 0;
		for (int iLoopPlayer = 0; iLoopPlayer < MAX_PLAYERS; iLoopPlayer++)
		{
			CvPlayer &kPlayer = GET_PLAYER((PlayerTypes)iLoopPlayer);
			if (kPlayer.isEverAlive() && kPlayer.isMajorCiv() && !kPlayer.isObserver())
				iCivCount++;
		}

		m_iFractionOriginalCapitalsUnderControl = iOCCount * 100 / max(1, (iCivCount-1));
	}

	int iExpCount = 0, iExpSum = 0;
	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
	{
		if (pLoopUnit->IsCombatUnit() && pLoopUnit->AI_getUnitAIType() != UNITAI_EXPLORE)
		{
			iExpCount++;
			iExpSum += pLoopUnit->getExperienceTimes100();
		}
	}

	m_iAvgUnitExp100 = iExpSum / max(1,iExpCount);
}

void CvPlayer::UpdateAreaEffectUnit(CvUnit* pUnit)
{
	if (!pUnit || pUnit->isDelayedDeath())
		return;

	if ((pUnit->IsGreatGeneral() || pUnit->GetGreatGeneralCount() > 0) || (pUnit->IsGreatAdmiral() || pUnit->GetGreatAdmiralCount() > 0) || pUnit->IsCityAttackSupport() || pUnit->IsSapper())
	{
		bool bFound = false;
		for ( size_t i=0; i<m_unitsAreaEffectPositive.size(); i++ )
		{
			if ( m_unitsAreaEffectPositive[i].first == pUnit->GetID() )
			{
				m_unitsAreaEffectPositive[i].second = pUnit->plot()->GetPlotIndex();
				bFound = true;
				break;
			}
		}

		if (!bFound)
			m_unitsAreaEffectPositive.push_back(std::make_pair(pUnit->GetID(), pUnit->plot()->GetPlotIndex()));
	}

	if (pUnit->getNearbyEnemyCombatMod() < 0)
	{
		bool bFound = false;
		for ( size_t i=0; i<m_unitsAreaEffectNegative.size(); i++ )
		{
			if ( m_unitsAreaEffectNegative[i].first == pUnit->GetID() )
			{
				m_unitsAreaEffectNegative[i].second = pUnit->plot()->GetPlotIndex();
				bFound = true;
				break;
			}
		}

		if (!bFound)
			m_unitsAreaEffectNegative.push_back(std::make_pair(pUnit->GetID(), pUnit->plot()->GetPlotIndex()));
	}

	if (pUnit->isNearbyPromotion())
	{
		bool bFound = false;
		for (size_t i = 0; i<m_unitsAreaEffectPromotion.size(); i++)
		{
			if (m_unitsAreaEffectPromotion[i].first == pUnit->GetID())
			{
				m_unitsAreaEffectPromotion[i].second = pUnit->plot()->GetPlotIndex();
				bFound = true;
				break;
			}
		}

		if (!bFound)
			m_unitsAreaEffectPromotion.push_back(std::make_pair(pUnit->GetID(), pUnit->plot()->GetPlotIndex()));
	}

	// Must be able to intercept
	if (pUnit->canIntercept())
	{
		bool bFound = false;
		for (size_t i = 0; i < m_unitsWhichCanIntercept.size(); i++)
		{
			if (m_unitsWhichCanIntercept[i].first == pUnit->GetID())
			{
				m_unitsWhichCanIntercept[i].second = pUnit->plot()->GetPlotIndex();
				bFound = true;
				break;
			}
		}

		if (!bFound)
			m_unitsWhichCanIntercept.push_back(std::make_pair(pUnit->GetID(), pUnit->plot()->GetPlotIndex()));
	}
}

void CvPlayer::UpdateAreaEffectUnits()
{
	//great generals/admirals
	m_unitsAreaEffectPositive.clear();
	//maori warrior et al
	m_unitsAreaEffectNegative.clear();
	//interceptors
	m_unitsWhichCanIntercept.clear();
	//special promotions
	m_unitsAreaEffectPromotion.clear();

	// Loop through our units
	int iLoop;
	for (CvUnit* pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if ((pLoopUnit->IsGreatGeneral() || pLoopUnit->GetGreatGeneralCount() > 0) || (pLoopUnit->IsGreatAdmiral() || pLoopUnit->GetGreatAdmiralCount() > 0) || pLoopUnit->IsCityAttackSupport() || pLoopUnit->IsSapper())
			m_unitsAreaEffectPositive.push_back(std::make_pair(pLoopUnit->GetID(), pLoopUnit->plot()->GetPlotIndex()));

		if (pLoopUnit->getNearbyEnemyCombatMod() < 0)
			m_unitsAreaEffectNegative.push_back(std::make_pair(pLoopUnit->GetID(), pLoopUnit->plot()->GetPlotIndex()));

		if (pLoopUnit->isNearbyPromotion())
			m_unitsAreaEffectPromotion.push_back(std::make_pair(pLoopUnit->GetID(), pLoopUnit->plot()->GetPlotIndex()));

		if (pLoopUnit->canIntercept())
			m_unitsWhichCanIntercept.push_back(std::make_pair(pLoopUnit->GetID(), pLoopUnit->plot()->GetPlotIndex()));
	}
}

void CvPlayer::UpdateAreaEffectPlots()
{
	//moai et al
	m_plotsAreaEffectPositiveFromTraits.clear();

	// Loop through our plots
	ImprovementTypes iTraitImprovement = GetPlayerTraits()->GetCombatBonusImprovementType();
	if (iTraitImprovement!=NO_IMPROVEMENT)
	{
		for(int iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)
		{
			CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);
			if (pPlot && pPlot->getOwner()==GetID() && pPlot->getImprovementType()==iTraitImprovement )
				m_plotsAreaEffectPositiveFromTraits.push_back( iPlotLoop );
		}
	}

	//Looks for Natural Wonders
	if(GetPlayerTraits()->IsCombatBoostNearNaturalWonder())
	{
		for(int iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)
		{
			CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);
			if (pPlot && pPlot->IsNaturalWonder())
				m_plotsAreaEffectPositiveFromTraits.push_back( iPlotLoop );
		}
	}
}
const std::vector<std::pair<int, int>>& CvPlayer::GetAreaEffectPromotionUnits() const
{
	return m_unitsAreaEffectPromotion;
}
const std::vector<std::pair<int,int>>& CvPlayer::GetAreaEffectPositiveUnits() const
{
	return m_unitsAreaEffectPositive;
}

const std::vector<std::pair<int,int>>& CvPlayer::GetAreaEffectNegativeUnits() const
{
	return m_unitsAreaEffectNegative;
}

const std::vector<std::pair<int, int>>& CvPlayer::GetPossibleInterceptors() const
{
	return m_unitsWhichCanIntercept;
}

const std::vector<int>& CvPlayer::GetAreaEffectPositiveFromTraitsPlots() const
{
	return m_plotsAreaEffectPositiveFromTraits;
}

void CvPlayer::UpdateCurrentAndFutureWars()
{
	//cache the wars we have going - ignore barbarians
	m_playersWeAreAtWarWith.clear();
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_PLAYERS-1; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		if(GET_PLAYER(eLoopPlayer).isAlive() && GET_TEAM(getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
			m_playersWeAreAtWarWith.push_back( eLoopPlayer );
	}

	//see if we're not at war yet but war is coming
	m_playersAtWarWithInFuture.clear();
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;
		if(GET_PLAYER(eLoopPlayer).isAlive() && !GET_PLAYER(eLoopPlayer).isBarbarian() && !IsAtWarWith(eLoopPlayer) )
		{
			bool bWarMayBeComing = false;

			//do we want to start a war?
			if(GetDiplomacyAI()->IsMusteringForAttack(eLoopPlayer) || GetMilitaryAI()->GetSneakAttackOperation(eLoopPlayer) != NULL)
				bWarMayBeComing = true;

			//do they want to start a war?
			AggressivePostureTypes eMilitaryPosture = GetDiplomacyAI()->GetMilitaryAggressivePosture(eLoopPlayer);
			ThreatTypes eWarmongerThreat = GetDiplomacyAI()->GetWarmongerThreat(eLoopPlayer);
			if (eMilitaryPosture == AGGRESSIVE_POSTURE_INCREDIBLE || eWarmongerThreat == THREAT_SEVERE || eWarmongerThreat == THREAT_CRITICAL)
				bWarMayBeComing = true;

			//how is the general diplomatic climate?
			MajorCivApproachTypes eApproach = GetDiplomacyAI()->GetMajorCivApproach(eLoopPlayer, /*bHideTrueFeelings*/ false);
			MajorCivOpinionTypes eOpinion = GetDiplomacyAI()->GetMajorCivOpinion(eLoopPlayer);
			if(eApproach == MAJOR_CIV_APPROACH_HOSTILE || eApproach == MAJOR_CIV_APPROACH_WAR || 
				eApproach == MAJOR_CIV_APPROACH_AFRAID || eOpinion == MAJOR_CIV_OPINION_ENEMY)
				bWarMayBeComing = true;

			if (bWarMayBeComing)
				m_playersAtWarWithInFuture.push_back(eLoopPlayer);
		}
	}

}

bool CvPlayer::HasCityInDanger(bool bAboutToFall, int iMinDanger) const
{
	const CvCity *pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if (bAboutToFall && pLoopCity->isInDangerOfFalling())
			return true;

		//trick for non const call
		if (!bAboutToFall && GET_PLAYER(m_eID).GetPlotDanger(*pLoopCity->plot(), GET_PLAYER(m_eID).getCity(pLoopCity->GetID())) >= iMinDanger)
			return true;
	}

	return false;
}
#endif

//	--------------------------------------------------------------------------------
// How many Cities does this player have for policy/tech cost purposes?
int CvPlayer::GetMaxEffectiveCities(bool bIncludePuppets)
{
	int iNumCities = getNumCities();

	// Don't count puppet Cities
	int iNumPuppetCities = GetNumPuppetCities();
	iNumCities -= iNumPuppetCities;

	// Don't count cities where the player hasn't decided yet what to do with them or ones that are currently being razed
	int iNumLimboCities = 0;
	const CvCity* pLoopCity;
	int iLoop;
	for(pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		if(pLoopCity->IsIgnoreCityForHappiness() || pLoopCity->IsRazing())
		{
			iNumLimboCities++;
		}
	}
	iNumCities -= iNumLimboCities;

	if(iNumCities == 0)	// If we don't pretend the player has at least one city it screws up the math
		iNumCities = 1;

	// Update member variable
	m_iMaxEffectiveCities = (m_iMaxEffectiveCities > iNumCities) ? m_iMaxEffectiveCities : iNumCities;

	if (bIncludePuppets)
	{
		return m_iMaxEffectiveCities + iNumPuppetCities;
	}

	return m_iMaxEffectiveCities;
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// How many Natural Wonders has this player found in its area?
int CvPlayer::GetExtraSupplyPerPopulation() const
{
	return m_iExtraSupplyPerPopulation;
}

//	--------------------------------------------------------------------------------
/// Changes many Natural Wonders has this player found in its area
void CvPlayer::ChangeExtraSupplyPerPopulation(int iChange)
{
	m_iExtraSupplyPerPopulation += iChange;
}

int CvPlayer::getCitySupplyFlatGlobal() const
{
	return m_iCitySupplyFlatGlobal;
}
void CvPlayer::changeCitySupplyFlatGlobal(int iChange)
{
	if (iChange != 0)
		m_iCitySupplyFlatGlobal += iChange;
}
#endif
//	--------------------------------------------------------------------------------
/// How many Natural Wonders has this player found in its area?
int CvPlayer::GetNumNaturalWondersDiscoveredInArea() const
{
	return m_iNumNaturalWondersDiscoveredInArea;
}

//	--------------------------------------------------------------------------------
/// Sets how many Natural Wonders has this player found in its area
void CvPlayer::SetNumNaturalWondersDiscoveredInArea(int iValue)
{
	m_iNumNaturalWondersDiscoveredInArea = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes many Natural Wonders has this player found in its area
void CvPlayer::ChangeNumNaturalWondersDiscoveredInArea(int iChange)
{
	SetNumNaturalWondersDiscoveredInArea(GetNumNaturalWondersDiscoveredInArea() + iChange);
}

//	--------------------------------------------------------------------------------
/// Calculates how many Natural Wonders are in plots this player owns
int CvPlayer::GetNumNaturalWondersInOwnedPlots()
{
	int iValue = 0;
	// go through all the plots the player has under their control
	for (PlotIndexContainer::const_iterator it = m_aiPlots.begin(); it != m_aiPlots.end(); ++it)
	{
		CvPlot* pPlot = GC.getMap().plotByIndex(*it);

		if (pPlot && pPlot->IsNaturalWonder())
			iValue++;
	}
	return iValue;
}

//	--------------------------------------------------------------------------------
#if defined(MOD_BALANCE_CORE)

bool CvPlayer::HaveGoodSettlePlot(int iAreaID)
{
	// Check if there are good plots to settle somewhere
	int iFirstArea, iSecondArea;
	if (iAreaID==-1)
		return GetBestSettleAreas(iFirstArea, iSecondArea) > 0; 
	else
	{
		GetBestSettleAreas(iFirstArea, iSecondArea);
		return (iFirstArea == iAreaID || iSecondArea == iAreaID);
	}
}

#endif
//	--------------------------------------------------------------------------------
/// How long ago did this guy last settle a city?
int CvPlayer::GetTurnsSinceSettledLastCity() const
{
	return m_iTurnsSinceSettledLastCity;
}

//	--------------------------------------------------------------------------------
/// How long ago did this guy last settle a city?
void CvPlayer::SetTurnsSinceSettledLastCity(int iValue)
{
	if(m_iTurnsSinceSettledLastCity != iValue)
		m_iTurnsSinceSettledLastCity = iValue;
}

//	--------------------------------------------------------------------------------
/// How long ago did this guy last settle a city?
void CvPlayer::ChangeTurnsSinceSettledLastCity(int iChange)
{
	if(iChange != 0)
		SetTurnsSinceSettledLastCity(GetTurnsSinceSettledLastCity() + iChange);
}

//	--------------------------------------------------------------------------------
/// Find best continents to settle next two cities; returns number found over minimum
int CvPlayer::GetBestSettleAreas(int& iFirstArea, int& iSecondArea)
{
	//lazy update
	updatePlotFoundValues();

	CvArea* pLoopArea;
	int iLoop;
	float fBestScore = 0;	//default score of each area is zero, so we have to be better
	float fSecondBestScore = 0;
	int iBestArea = -1;
	int iSecondBestArea = -1;
	int iNumFound = 0;

	CvMap& theMap = GC.getMap();

	// Find best two scores above minimum
	for(pLoopArea = theMap.firstArea(&iLoop); pLoopArea != NULL; pLoopArea = theMap.nextArea(&iLoop))
	{
		if(pLoopArea->isWater())
			continue;

		float fScore = (float)pLoopArea->getTotalFoundValue();
		if (fScore <= 0)
			continue;

		EconomicAIStrategyTypes eStrategyExpandToOtherContinents = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_EXPAND_TO_OTHER_CONTINENTS");
		if(eStrategyExpandToOtherContinents != NO_ECONOMICAISTRATEGY)
		{
			if (GetEconomicAI()->IsUsingStrategy(eStrategyExpandToOtherContinents))
			{
				if (getCapitalCity() && pLoopArea->GetID() != getCapitalCity()->getArea())
				{
					fScore *= 2;
				}
			}
		}
		EconomicAIStrategyTypes eStrategyReallyExpandToOtherContinents = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_REALLY_EXPAND_TO_OTHER_CONTINENTS");
		if(eStrategyExpandToOtherContinents != NO_ECONOMICAISTRATEGY)
		{
			if (GetEconomicAI()->IsUsingStrategy(eStrategyReallyExpandToOtherContinents))
			{
				if (getCapitalCity() && pLoopArea->GetID() != getCapitalCity()->getArea())
				{
					fScore *= 2;
				}
			}
		}

		int nEnemyCities = 0, nMyCities = 0;
		for(int iPlayer = 0; iPlayer < MAX_MAJOR_CIVS; ++iPlayer)
		{
			if(iPlayer!=GetID())
				nEnemyCities += pLoopArea->getCitiesPerPlayer((PlayerTypes)iPlayer);
			else
				nMyCities += pLoopArea->getCitiesPerPlayer((PlayerTypes)iPlayer);
		}

		//if we don't have any cities there but our potential enemies do, be careful
		if (nEnemyCities>0 && nMyCities==0)
			fScore *= 0.50f;

		iNumFound++;
		if(fScore > fBestScore)
		{
			// Already have a best area?  If so demote to 2nd
			if(fBestScore > 0)
			{
				fSecondBestScore = fBestScore;
				iSecondBestArea = iBestArea;
			}
			iBestArea = pLoopArea->GetID();
			fBestScore = fScore;
		}

		else if(fScore > fSecondBestScore)
		{
			iSecondBestArea = pLoopArea->GetID();
			fSecondBestScore = fScore;
		}
	}

	// Return data
	iFirstArea = iBestArea;
	iSecondArea = iSecondBestArea;

	return iNumFound;
}

//	--------------------------------------------------------------------------------
/// Find the best spot in the entire world for this unit to settle
ostream& operator<<(ostream& os, const CvPlot* pPlot)
{
	if (pPlot)
	    os << pPlot->getX() << "," << pPlot->getY() << "," << pPlot->getTerrainType() << "," << pPlot->getPlotType() << "," \
			<< pPlot->getFeatureType() << "," << pPlot->getOwner() << "," << pPlot->getArea();
    return os;
}

CvPlot* CvPlayer::GetBestSettlePlot(const CvUnit* pUnit, int iTargetArea, bool bNeedSafePlot, bool& bIsSafe, CvAIOperation* pOpToIgnore, bool bForceLogging) const
{
	std::vector<SPlotWithScore> vSettlePlots;

	//--------
	bool bLogging = (GC.getLogging() && GC.getAILogging()) || bForceLogging; 
	std::stringstream dump;
	int iDanger=0, iFertility=0;

#if defined(MOD_BALANCE_CORE_MILITARY_LOGGING)
	bLogging &= MOD_BALANCE_CORE_MILITARY_LOGGING;
#endif
	//--------

	PlayerTypes eOwner = pUnit ? pUnit->getOwner() : GetID();
	TeamTypes eTeam = pUnit ? pUnit->getTeam() : getTeam();

	int iBestArea, iSecondBestArea;
	//call this the sneaky way cause it's not const
	int iNumSettleAreas = GET_PLAYER(GetID()).GetBestSettleAreas(iBestArea, iSecondBestArea);
	if(iNumSettleAreas == 0)
	{
		return NULL;
	}

	//in case we're not getting the cached data, we need to prepare some things
	vector<int> ignorePlots(GC.getMap().numPlots(), 0);
	if (bLogging)
	{
		GC.getGame().GetSettlerSiteEvaluator()->ComputeFlavorMultipliers(this);
		for (int iI = 0; iI < GC.getMap().numPlots(); iI++)
		{
			CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iI);
			if (pPlot->isOwned() && pPlot->getOwner() != m_eID)
				ignorePlots[iI] = 1;
			else if (pPlot->IsAdjacentOwnedByOtherTeam(getTeam()) && GC.getGame().GetClosestCityDistanceInPlots(pPlot)<4)
				ignorePlots[iI] = 1;
		}
	}

	//prefer settling close in the beginning
	int iTimeOffset = (24 * GC.getGame().getElapsedGameTurns()) / max(512, GC.getGame().getMaxTurns());

	//basic search area around existing cities. value at eval distance is scaled to zero.
	int iEvalDistance = 5 + iTimeOffset;
	if(IsCramped())
		iEvalDistance += iTimeOffset;

	//if we want to go to other continents, we need a very large search radius
	EconomicAIStrategyTypes eStrategyExpandToOtherContinents = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_EXPAND_TO_OTHER_CONTINENTS");
	EconomicAIStrategyTypes eStrategyReallyExpandToOtherContinents = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_REALLY_EXPAND_TO_OTHER_CONTINENTS");
	bool bWantOffshore = GetEconomicAI()->IsUsingStrategy(eStrategyReallyExpandToOtherContinents) || GetEconomicAI()->IsUsingStrategy(eStrategyExpandToOtherContinents);
	bool bCanEmbark = GET_TEAM(getTeam()).canEmbark() || GetPlayerTraits()->IsEmbarkedAllWater();

	CvMap& kMap = GC.getMap();
	int iNumPlots = kMap.numPlots();
	for(int iPlotLoop = 0; iPlotLoop < iNumPlots; iPlotLoop++)
	{
		CvPlot* pPlot = kMap.plotByIndexUnchecked(iPlotLoop);

		if(!pPlot)
		{
			continue;
		}

		if (bLogging)
		{
			iDanger = pUnit->GetDanger(pPlot);
			iFertility = GC.getGame().GetSettlerSiteEvaluator()->PlotFertilityValue(pPlot,true);
		}

		if(!pPlot->isRevealed(getTeam()))
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",0," << iDanger << "," << iFertility << ",-1" << ",0" << std::endl;
			//--------------
			continue;
		}

		if(iTargetArea != -1 && pPlot->getArea() != iTargetArea)
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",1," << iDanger << "," << iFertility << ",-1" << ",-6" << std::endl;
			//--------------
			continue;
		}

		if ((pPlot->getOwner() != NO_PLAYER && pPlot->getOwner() != eOwner) || (pPlot->getImprovementType() == (ImprovementTypes)GC.getBARBARIAN_CAMP_IMPROVEMENT()))
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",1," << iDanger << "," << iFertility << ",-1" << ",-2" << std::endl;
			//--------------
			continue;
		}

		if(pPlot->IsAdjacentOwnedByOtherTeam(eTeam))
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",1," << iDanger << "," << iFertility << ",-1" << ",-2" << std::endl;
			//--------------
			continue;
		}

		for (std::vector<PlayerTypes>::const_iterator it = m_playersWeAreAtWarWith.begin(); it != m_playersWeAreAtWarWith.end(); ++it)
		{
			if(!GET_PLAYER(*it).isBarbarian())
			{
				if(pPlot->IsHomeFrontForPlayer(*it))
				{
					//--------------
					if (bLogging) 
					dump << pPlot << ",1," << iDanger << "," << iFertility << ",-1" << ",-2" << std::endl;
					//--------------
					continue;
				}
			}
		}

		if(pUnit && (!pUnit->canFound(pPlot) || !pUnit->canMoveInto(*pPlot)))
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",1," << iDanger << "," << iFertility << ",-1" << ",-1" << std::endl;
			//--------------
			continue;
		}

		if (IsPlotTargetedForCity(pPlot,pOpToIgnore))
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",1," << iDanger << "," << iFertility << ",-1" << ",-3" << std::endl;
			//--------------
			continue;
		}

		if(pUnit && pPlot->getArea() != pUnit->getArea() && !bCanEmbark)
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",1," << iDanger << "," << iFertility << ",-1" << ",-4" << std::endl;
			//--------------
			continue;
		}

		//check for new continent
		const CvArea* pArea = GC.getMap().getArea(pPlot->getArea());
		const CvCity* pCapital = getCapitalCity();

		//ignore if not interesting
		bool bOffshore = (pArea && pCapital && pArea->GetID() != pCapital->plot()->getArea());
		if (bWantOffshore && !bOffshore)
			continue;

		//take into account distance from existing cities
		int iUnitDistance = pUnit ? plotDistance(pUnit->getX(),pUnit->getY(),pPlot->getX(),pPlot->getY()) : INT_MAX;
		int iRelevantDistance = min(iUnitDistance,GetCityDistanceInEstimatedTurns(pPlot)*2); //times 2 to get the approximate plot distance
		int iScale = MapToPercent( iRelevantDistance, iEvalDistance, GC.getSETTLER_DISTANCE_DROPOFF_MODIFIER() );

		//on a new continent we want to settle along the coast
		bool bNewContinent = (pArea && pArea->getCitiesPerPlayer(GetID()) == 0);
		if (bNewContinent && !pPlot->isCoastalLand())
			iScale = 1;

		//if we want offshore expansion, distance is less important
		if (bWantOffshore && bOffshore)
			iScale = max(50,min(100,iScale*2));

		//bonus if the plot is in a desirable (large) area
		if (pPlot->getArea() == iBestArea)
			iScale *= 4;
		if (pPlot->getArea() == iSecondBestArea)
			iScale *= 2;

		if (iScale==0)
		{
			//--------------
			if (bLogging) 
			dump << pPlot << ",1," << iDanger << "," << iFertility << ",0" << ",-5" << std::endl;
			//--------------
			continue;
		}

		//finally no more obstacles
		int iValue = 0;
		if (bLogging) 
		{
			CvString strDebug;
			iValue = GC.getGame().GetSettlerSiteEvaluator()->PlotFoundValue(pPlot, this, ignorePlots, bNewContinent, &strDebug);
			//--------------
			dump << pPlot << ",1," << iDanger << "," << iFertility << "," << iScale << "," << iValue << "," << strDebug.c_str() << std::endl;
			//--------------
		}
		else
		{
			//with caching - is set to -1 if not possible / not good enough
			iValue = pPlot->getFoundValue(eOwner);
		}

		if (iValue==0)
			continue;

		//factor in the distance
		iValue = (iValue*iScale)/100;

		vSettlePlots.push_back( SPlotWithScore(pPlot,iValue) );
	}

#if defined(MOD_BALANCE_CORE_MILITARY_LOGGING)
	if (bLogging) 
	{
		std::stringstream ss;
		ss << "CitySites_" << getCivilizationAdjective() << "_" << std::setfill('0') << std::setw(3) << GC.getGame().getGameTurn() << ".txt";
		FILogFile* pLog=LOGFILEMGR.GetLog( ss.str().c_str(), FILogFile::kDontTimeStamp );
		pLog->Msg( "#x,y,terrain,plotype,feature,owner,area,revealed,danger,fertility,distancescale,value,comments\n" );
		pLog->Msg( dump.str().c_str() );
		pLog->Close();
	}
#endif

	if (vSettlePlots.empty())
		return 0;

	//order by increasing score
	std::stable_sort( vSettlePlots.begin(), vSettlePlots.end() );
	//delete the worst half
	SPlotWithScore ref = vSettlePlots.back();
	ref.score = int(ref.score * 0.5f);
	std::vector<SPlotWithScore>::iterator cutoff = std::upper_bound( vSettlePlots.begin(), vSettlePlots.end(), ref );
	//reverse so best comes first
	vSettlePlots.erase( vSettlePlots.begin(), cutoff );
	std::reverse( vSettlePlots.begin(), vSettlePlots.end() );

	//AI cheating here ... check if a settler would likely be captured
	std::vector<CvPlot*> vBadPlots;
	for(int iI = 0; iI < iNumPlots; iI++)
	{
		CvPlot *pPlot = kMap.plotByIndexUnchecked(iI);

		if(iTargetArea!=-1 && pPlot->getArea()!=iTargetArea)
			continue;

		if (pPlot->getRevealedImprovementType(getTeam()) == GC.getBARBARIAN_CAMP_IMPROVEMENT())
		{
			vBadPlots.push_back(pPlot);
			continue;
		}

		IDInfo* pUnitNode = pPlot->headUnitNode();
		while(pUnitNode != NULL)
		{
			CvUnit* pLoopUnit = ::getUnit(*pUnitNode);
			pUnitNode = pPlot->nextUnitNode(pUnitNode);

			if (pLoopUnit && pLoopUnit->IsCombatUnit() && pLoopUnit->getDomainType() == DOMAIN_LAND)
			{
				if (pLoopUnit->isEnemy(getTeam()) || pLoopUnit->isHuman()) //extra careful with those sneaky humans
				{
					vBadPlots.push_back(pPlot);
					break;
				}
			}
		}
	}

	//see where our settler can go
	ReachablePlots reachablePlots;
	int iMaxSafeTurns = 4;
	if (pUnit)
	{
		SPathFinderUserData data(pUnit,0,iMaxSafeTurns);
		data.ePathType = PT_UNIT_REACHABLE_PLOTS;
		data.iMinMovesLeft = 1; //we want to be able to found on the final turn
		reachablePlots = GC.GetPathFinder().GetPlotsInReach(pUnit->plot(), data);
	}

	for (size_t i=0; i<vSettlePlots.size(); i++)
	{
		CvPlot* pTestPlot = vSettlePlots[i].pPlot;
		ReachablePlots::iterator it = reachablePlots.find(pTestPlot->GetPlotIndex());

		bool isDangerous = (it==reachablePlots.end());
		bool bCanReachThisTurn = (it != reachablePlots.end() && it->iTurns==0);

		//check if it's too close to an enemy
		for (size_t j=0; j<vBadPlots.size(); j++)
		{
			if (vSettlePlots[i].pPlot->getArea() != vBadPlots[j]->getArea())
				continue;

			int iDistanceToDanger = plotDistance(*pTestPlot,*(vBadPlots[j]));
			if (iDistanceToDanger<4 && !bCanReachThisTurn)
			{
				isDangerous = true;
				break;
			}
		}

		//if it's too far from our existing cities, it's dangerous
		if (!isDangerous)
		{
			int iDistanceToCity = GetCityDistanceInEstimatedTurns(pTestPlot);
			//also consider distance to settler here in case of re-targeting an operation
			if (iDistanceToCity>4 && !bCanReachThisTurn && pTestPlot->getOwner()!=m_eID)
				isDangerous = true;

			//closer to enemy than to us?
			if (GetClosestCityByEstimatedTurns(pTestPlot) != GC.getGame().GetClosestCityByEstimatedTurns(pTestPlot))
				isDangerous = true;

		}

		if (bNeedSafePlot)
		{
			if (!isDangerous)
			{
				bIsSafe = true;
				return pTestPlot;
			}
		}
		else //don't care about safety but return the status nevertheless
		{
			bIsSafe = !isDangerous;
			return pTestPlot;
		}
	}

	bIsSafe = false;
	return NULL;
}

//	--------------------------------------------------------------------------------
/// How many Wonders has this Player constructed?
int CvPlayer::GetNumWonders() const
{
	return m_iNumWonders;
}

//	--------------------------------------------------------------------------------
/// Changes how many Wonders this Player has constructed
void CvPlayer::ChangeNumWonders(int iValue)
{
	if(iValue != 0)
	{
		m_iNumWonders += iValue;
	}
}

//	--------------------------------------------------------------------------------
/// How many Policies has this Player constructed?
int CvPlayer::GetNumPolicies() const
{
	return m_iNumPolicies;
}

//	--------------------------------------------------------------------------------
/// Changes how many Policies this Player has constructed
void CvPlayer::ChangeNumPolicies(int iValue)
{
	if(iValue != 0)
	{
		m_iNumPolicies += iValue;
	}
}

//	--------------------------------------------------------------------------------
/// How many GreatPeople has this Player constructed?
int CvPlayer::GetNumGreatPeople() const
{
	return m_iNumGreatPeople;
}

//	--------------------------------------------------------------------------------
/// Changes how many GreatPeople this Player has constructed
void CvPlayer::ChangeNumGreatPeople(int iValue)
{
	if(iValue != 0)
	{
		m_iNumGreatPeople += iValue;
	}
}
#if defined(MOD_BALANCE_CORE)
void CvPlayer::SetBestWonderCities()
{
	int iGPT = GetTreasury()->CalculateBaseNetGold();
	bool bIsCapitalCompetitive = isCapitalCompetitive();
	
	for (int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
	{
		int iBestValue = 0;
		CvCity* pBestCity = NULL;
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
		CvBuildingEntry* pkeBuildingInfo = GC.getBuildingInfo(eBuilding);

		//Not wonder? Skip
		if (!pkeBuildingInfo)
			continue;

		if (!::isWorldWonderClass(pkeBuildingInfo->GetBuildingClassInfo()) && !::isNationalWonderClass(pkeBuildingInfo->GetBuildingClassInfo()))
			continue;

		const CvBuildingClassInfo& kBuildingClassInfo = pkeBuildingInfo->GetBuildingClassInfo();

		bool bCivUnique = kBuildingClassInfo.getDefaultBuildingIndex() != eBuilding;

		bool bCapitalCanConstruct = false;
		int iLoopCity;
		CvCity* pLoopCity = NULL;
		// Look at all of our Cities to see which is the best.
		for (pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity))
		{
			bool bAlreadyStarted = pLoopCity->GetCityBuildings()->GetBuildingProduction(eBuilding) > 0;

			//We've already started? We can bail out here, then.
			if (pLoopCity->getProductionBuilding() == eBuilding || bAlreadyStarted)
			{
				pBestCity = pLoopCity;
				break;
			}

			//is this a unique wonder that we can't build? Ignore it.
			if (bCivUnique && !getCivilizationInfo().isCivilizationBuildingOverridden((BuildingClassTypes)pkeBuildingInfo->GetBuildingClassType()))
				continue;

			if (!pLoopCity->canConstruct(eBuilding))
			{
				pLoopCity->SetBestForWonder((BuildingClassTypes)pkeBuildingInfo->GetBuildingClassType(), false);
				continue;
			}
			else if (pLoopCity->isCapital())
				bCapitalCanConstruct = true;

			//stats to decide whether to disband a unit
			int iWaterPriority = pLoopCity->GetTradePrioritySea();
			int iLandPriority = pLoopCity->GetTradePriorityLand();

			int iWaterRoutes = -1;
			int iLandRoutes = -1;

			if (iWaterPriority >= 0)
			{
				//0 is best, and 1+ = 100% less valuable than top. More routes from better cities, please!
				iWaterRoutes = 1000 - min(1000, (iWaterPriority * 50));
			}
			if (iLandPriority >= 0)
			{
				iLandRoutes = 1000 - min(1000, (iLandPriority * 50));
			}

			//Best? Do it!
			int iValue = pLoopCity->GetCityStrategyAI()->GetBuildingProductionAI()->CheckBuildingBuildSanity(eBuilding, 1000, iLandRoutes, iWaterRoutes, iGPT, false, true);

			iValue += (-50 * pLoopCity->getProductionTurnsLeft(eBuilding, 0));

			if (iValue > iBestValue)
			{
				iBestValue = iValue;
				pBestCity = pLoopCity;
			}
		}

		//default to capital if no other option (for world wonders only if we have a chance)
		if (!pBestCity && bCapitalCanConstruct && (bIsCapitalCompetitive || ::isNationalWonderClass(pkeBuildingInfo->GetBuildingClassInfo())))
			pBestCity = getCapitalCity();

		if (pBestCity)
		{
			pBestCity->SetBestForWonder((BuildingClassTypes)pkeBuildingInfo->GetBuildingClassType(), true);

			int iLoopCity;
			CvCity* pLoopCity = NULL;

			// Remove from all other cities.
			for (pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity))
			{
				if (pLoopCity != pBestCity)
					pLoopCity->SetBestForWonder((BuildingClassTypes)pkeBuildingInfo->GetBuildingClassType(), false);
			}

			if ((GC.getLogging() && GC.getAILogging()))
			{
				CvString playerName;
				FILogFile* pLog;
				CvString strBaseString;
				CvString strOutBuf;
				CvString strFileName = "CustomMods.csv";
				playerName = getCivilizationShortDescription();
				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				strBaseString += playerName + ", ";
				strOutBuf.Format("%s is the best city to construct %s", pBestCity->getName().GetCString(), pkeBuildingInfo->GetDescription());
				strBaseString += strOutBuf;
				pLog->Msg(strBaseString);
			}
		}
	}
}

//to avoid hardcoding any hammers per pop values, we look at hammers per pop for all other capitals
//however, we don't look at the total hammers, because that would be cheating :)
bool CvPlayer::isCapitalCompetitive()
{
	if (!getCapitalCity())
		return false;

	int iSum = 0;
	int iCount = 0;
	for (int iPlayer = 0; iPlayer < MAX_MAJOR_CIVS; iPlayer++)
	{
		CvPlayer& kPlayer = GET_PLAYER( (PlayerTypes)iPlayer );
		if (!kPlayer.isAlive() || !kPlayer.getCapitalCity())
			continue;

		if (iPlayer == GetID())
			continue;

		iSum += kPlayer.getCapitalCity()->getYieldRateTimes100(YIELD_PRODUCTION,false) / kPlayer.getCapitalCity()->getPopulation();
		iCount++;
	}

	int iThreshold = iSum / max(1, iCount);
	//venice exception
	if (GetPlayerTraits()->IsNoAnnexing())
		iThreshold -= iThreshold / 3;

	return (getCapitalCity()->getYieldRateTimes100(YIELD_PRODUCTION,false) / getCapitalCity()->getPopulation()) >= iThreshold;
}

#endif
//	--------------------------------------------------------------------------------
/// Special ability where city-states gift great people
void CvPlayer::DoAdoptedGreatPersonCityStatePolicy()
{
	// Loop through all minors and if they're allies, seed the GP counter
	PlayerTypes eMinor;
	for(int iPlayerLoop = MAX_MAJOR_CIVS; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		eMinor = (PlayerTypes) iPlayerLoop;

		if(GET_PLAYER(eMinor).isEverAlive())
		{
			if(GET_PLAYER(eMinor).GetMinorCivAI()->GetAlly() == GetID())
			{
				DoSeedGreatPeopleSpawnCounter();

				break;
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Special ability where city-states gift great people
bool CvPlayer::IsAlliesGreatPersonBiasApplied() const
{
	return m_bAlliesGreatPersonBiasApplied;
}

//	--------------------------------------------------------------------------------
/// Special ability where city-states gift great people
void CvPlayer::SetAlliesGreatPersonBiasApplied(bool bValue)
{
	if(m_bAlliesGreatPersonBiasApplied != bValue)
	{
		m_bAlliesGreatPersonBiasApplied = bValue;
	}
}

//	--------------------------------------------------------------------------------
/// Has this player picked up a Religion yet
bool CvPlayer::IsHasAdoptedStateReligion() const
{
	return m_bHasAdoptedStateReligion;
}

//	--------------------------------------------------------------------------------
/// Sets this player picked up a Religion yet
void CvPlayer::SetHasAdoptedStateReligion(bool bValue)
{
	if(m_bHasAdoptedStateReligion != bValue)
	{
		m_bHasAdoptedStateReligion = bValue;
	}
}

//	--------------------------------------------------------------------------------
/// Number of Cities in the empire with our State Religion
int CvPlayer::GetNumCitiesWithStateReligion()
{
	int iNumCitiesWithStateReligion = 0;

	int iLoopCity;
	CvCity* pLoopCity = NULL;
	// Look at all of our Cities to see if they have our Religion
	for(pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity))
	{
		if(pLoopCity->GetPlayersReligion() == GetID())
		{
			iNumCitiesWithStateReligion++;
		}
	}

	return iNumCitiesWithStateReligion;
}

//	--------------------------------------------------------------------------------
/// Where was this player's Religion adopted
CvCity* CvPlayer::GetHolyCity()
{
	return getCity(m_iHolyCityID);
}

//	--------------------------------------------------------------------------------
/// Sets where this player's Religion adopted
void CvPlayer::SetHolyCity(int iCityID)
{
	// This should only be set once under normal circumstances
	CvAssert(m_iHolyCityID == -1);

	m_iHolyCityID = iCityID;
}

//	--------------------------------------------------------------------------------
PromotionTypes CvPlayer::GetEmbarkationPromotion() const
{
	if(GET_TEAM(getTeam()).canDefensiveEmbark())
	{
		return (PromotionTypes)GC.getPROMOTION_DEFENSIVE_EMBARKATION();
	}

	if(m_pTraits)
	{
		if(m_pTraits->IsEmbarkedAllWater())
		{
			return (PromotionTypes)GC.getPROMOTION_ALLWATER_EMBARKATION();
		}
	}

	return (PromotionTypes)GC.getPROMOTION_EMBARKATION();
}

#if defined(MOD_PROMOTIONS_DEEP_WATER_EMBARKATION)
//	--------------------------------------------------------------------------------
PromotionTypes CvPlayer::GetDeepWaterEmbarkationPromotion() const
{
	if (MOD_PROMOTIONS_DEEP_WATER_EMBARKATION) {
		if(GET_TEAM(getTeam()).canDefensiveEmbark())
		{
			return (PromotionTypes)GC.getPROMOTION_DEFENSIVE_DEEPWATER_EMBARKATION();
		}

		return (PromotionTypes)GC.getPROMOTION_DEEPWATER_EMBARKATION();
	} else {
		return GetEmbarkationPromotion();
	}
}
#endif

//	--------------------------------------------------------------------------------
/// Provide Notification about someone adopting a new Religon
void CvPlayer::DoAnnounceReligionAdoption()
{
	CvCity* pHolyCity = GetHolyCity();

	for(int iI = 0; iI < MAX_PLAYERS; iI++)
	{
		CvPlayerAI& thisPlayer = GET_PLAYER((PlayerTypes)iI);
		if(thisPlayer.isHuman() && thisPlayer.isAlive() && thisPlayer.GetNotifications())
		{
			int iX = -1;
			int iY = -1;

			Localization::String localizedText;

			// Active Player
			if(GC.getGame().getActivePlayer() == GetID())
			{
				iX = pHolyCity->getX();
				iY = pHolyCity->getY();
				localizedText = Localization::Lookup("TXT_KEY_MISC_RELIGION_ADOPTED_YOU");
				localizedText << pHolyCity->getNameKey() << GetStateReligionKey();
			}
			// Met Player
			else if(GET_TEAM(GC.getGame().getActiveTeam()).isHasMet(thisPlayer.getTeam()))
			{
				localizedText = Localization::Lookup("TXT_KEY_MISC_RELIGION_ADOPTED_ANOTHER_PLAYER");
				localizedText << GET_PLAYER(pHolyCity->getOwner()).getNameKey() << GetStateReligionKey();

				// We've seen this player's City
				if(pHolyCity->isRevealed(thisPlayer.getTeam(), false))
				{
					iX = pHolyCity->getX();
					iY = pHolyCity->getY();
				}
			}
			// Unmet Player
			else
			{
				localizedText = Localization::Lookup("TXT_KEY_MISC_RELIGION_ADOPTED_UNKNOWN");
			}

#if defined(MOD_API_EXTENSIONS)
			thisPlayer.GetNotifications()->Add(NOTIFICATION_RELIGION_RACE, localizedText.toUTF8(), localizedText.toUTF8(), iX, iY, GetReligions()->GetReligionCreatedByPlayer(), -1);
#else
			thisPlayer.GetNotifications()->Add(NOTIFICATION_RELIGION_RACE, localizedText.toUTF8(), localizedText.toUTF8(), iX, iY, -1);
#endif
		}
	}
}

bool CvPlayer::IsAllowedToTradeWith(PlayerTypes eOtherPlayer)
{
	if (GC.getGame().GetGameLeagues()->IsTradeEmbargoed(GetID(), eOtherPlayer) && eOtherPlayer != m_eID)
	{
		return false;
	}

#if defined(MOD_DIPLOMACY_CITYSTATES_RESOLUTIONS)
	if (MOD_DIPLOMACY_CITYSTATES_RESOLUTIONS && GC.getGame().GetGameLeagues()->IsIdeologyEmbargoed(GetID(), eOtherPlayer) && eOtherPlayer != m_eID)
	{
		return false;
	}
#endif

#if defined(MOD_BALANCE_CORE)
	if (eOtherPlayer != m_eID && GET_PLAYER(eOtherPlayer).isMajorCiv() && GET_PLAYER(eOtherPlayer).GetPlayerTraits()->IsNoOpenTrade())
	{
		if (!GC.getGame().GetGameTrade()->IsPlayerConnectedToPlayer(eOtherPlayer, GetID(), true))
			return false;
	}
	if (IsOnlyTradeSameIdeology() && GET_PLAYER(eOtherPlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != NO_POLICY_BRANCH_TYPE)
	{
		if (GET_PLAYER(eOtherPlayer).GetPlayerPolicies()->GetLateGamePolicyTree() != GetPlayerPolicies()->GetLateGamePolicyTree())
		{
			return false;
		}
	}
#endif
	return true;
}

bool CvPlayer::CanCrossOcean() const
{
	return GET_TEAM(getTeam()).canEmbarkAllWaterPassage() || GetPlayerTraits()->IsEmbarkedAllWater();
}
bool CvPlayer::CanCrossMountain() const
{
	return GetPlayerTraits()->IsAbleToCrossMountainsWithGreatGeneral() || GetPlayerTraits()->IsMountainPass();
}
bool CvPlayer::CanCrossIce() const
{
	return GetPlayerTraits()->IsAbleToCrossIce();
}

//////////////////////////////////////////////////////////////////////////
// Tutorial Stuff...
//////////////////////////////////////////////////////////////////////////

//	--------------------------------------------------------------------------------
bool CvPlayer::GetEverPoppedGoody()
{
	return m_bEverPoppedGoody;
}

//	--------------------------------------------------------------------------------
CvPlot* CvPlayer::GetClosestGoodyPlot(bool bStopAfterFindingFirst)
{
#if defined(MOD_CORE_ALTERNATIVE_EXPLORE_SCORE)
	CvPlot* pResultPlot = NULL;
	int iShortestPath = INT_MAX;

	// cycle through goodies
	for(int i = 0; i < GC.getMap().numPlots(); i++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(i);
#else
	FFastVector<int> aiGoodyPlots = GetEconomicAI()->GetGoodyHutPlots();

	CvPlot* pResultPlot = NULL;
	int iShortestPath = INT_MAX;

	// cycle through goodies
	for(uint uiGoodyIndex = 0; uiGoodyIndex < aiGoodyPlots.size(); uiGoodyIndex++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndex(aiGoodyPlots[uiGoodyIndex]);
#endif
		if(!pPlot || !pPlot->isGoody(getTeam()))
		{
			continue;
		}

		// cycle through units
		int iUnitLoop;
		CvUnit* pLoopUnit = NULL;

		// Setup m_units
		for(pLoopUnit = firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iUnitLoop))
		{
			if(!pLoopUnit)
			{
				continue;
			}

			if(pPlot->getArea() != pLoopUnit->getArea() && !pLoopUnit->CanEverEmbark())
			{
				continue;
			}

			int iReturnValue = INT_MAX;
			bool bResult = pLoopUnit->GeneratePath(pPlot, CvUnit::MOVEFLAG_IGNORE_DANGER, iShortestPath, &iReturnValue);

			if(bResult)
			{
				if(iReturnValue < iShortestPath)
				{
					pResultPlot = pPlot;
					iShortestPath = iReturnValue;
				}

				if(bStopAfterFindingFirst)
				{
					return pPlot;
				}
			}
		}
	}

	return pResultPlot;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::GetPlotHasOrder(CvPlot* pPlot)
{
	if(!pPlot)
	{
		return false;
	}

	int iLoopUnit;
	for(CvUnit* pLoopUnit = firstUnit(&iLoopUnit); pLoopUnit; pLoopUnit = nextUnit(&iLoopUnit))
	{
		CvPlot* pMissionPlot = pLoopUnit->GetMissionAIPlot();
		if(NULL != pMissionPlot && pMissionPlot->getX() == pPlot->getX() && pMissionPlot->getY() == pPlot->getY())
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::GetAnyUnitHasOrderToGoody()
{
#if defined(MOD_CORE_ALTERNATIVE_EXPLORE_SCORE)
	// cycle through goodies
	for(int i = 0; i < GC.getMap().numPlots(); i++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(i);
#else

	FFastVector<int> aiGoodyPlots = GetEconomicAI()->GetGoodyHutPlots();

	// cycle through goodies
	for(uint uiGoodyIndex = 0; uiGoodyIndex < aiGoodyPlots.size(); uiGoodyIndex++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndex(aiGoodyPlots[uiGoodyIndex]);
#endif
		if(!pPlot)
		{
			continue;
		}

		if(!pPlot->isGoody(getTeam()))
		{
			continue;
		}

		if(GetPlotHasOrder(pPlot))
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::GetEverTrainedBuilder()
{
	return m_bEverTrainedBuilder;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumFreeTechs() const
{
	return m_iFreeTechCount;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumFreeTechs(int iValue)
{
	m_iFreeTechCount = iValue;
	if(GetID() == GC.getGame().getActivePlayer())
	{
		GC.GetEngineUserInterface()->setDirty(ResearchButtons_DIRTY_BIT, true);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetMedianTechPercentage() const
{
	return m_iMedianTechPercentage;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeMedianTechPercentage(int iValue)
{
	m_iMedianTechPercentage += iValue;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumFreePolicies() const
{
	return m_iNumFreePolicies;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumFreePolicies(int iValue)
{
	// Increase count of free Policies we've ever had
	int iDifference = iValue - m_iNumFreePolicies;
	if(iDifference > 0)
	{
		ChangeNumFreePoliciesEver(iDifference);
	}

	m_iNumFreePolicies = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumFreePolicies(int iChange)
{
	SetNumFreePolicies(GetNumFreePolicies() + iChange);

	if(iChange > 0 && getNumCities() > 0)
	{
		CvNotifications* pNotifications = GetNotifications();
		if(pNotifications)
		{
			CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_FREE_POLICY");
			CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_FREE_POLICY_SUMMARY");
			pNotifications->Add(NOTIFICATION_FREE_POLICY, strBuffer, strSummary, -1, -1, -1);
		}

	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumFreeTenets() const
{
	return m_iNumFreeTenets;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumFreeTenets(int iValue, bool bCountAsFreePolicies)
{
	// Increase count of free Policies we've ever had
	int iDifference = iValue - m_iNumFreeTenets;
	if (bCountAsFreePolicies && iDifference > 0)
	{
		ChangeNumFreePoliciesEver(iDifference);
	}

	m_iNumFreeTenets = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumFreeTenets(int iChange, bool bCountAsFreePolicies)
{
	SetNumFreeTenets(GetNumFreeTenets() + iChange, bCountAsFreePolicies);

	if(iChange > 0 && getNumCities() > 0)
	{
		CvNotifications* pNotifications = GetNotifications();
		if(pNotifications)
		{
			CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_FREE_POLICY");
			CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_FREE_POLICY_SUMMARY");
			pNotifications->Add(NOTIFICATION_FREE_POLICY, strBuffer, strSummary, -1, -1, -1);
		}

	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumFreeGreatPeople() const
{
	return m_iNumFreeGreatPeople;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumFreeGreatPeople(int iValue)
{
	m_iNumFreeGreatPeople = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumFreeGreatPeople(int iChange)
{
	m_iNumFreeGreatPeople = GetNumFreeGreatPeople() + iChange;
	if(iChange > 0)
	{
		if(isHuman())
		{
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				CvString strBuffer = GetLocalizedText("TXT_KEY_CHOOSE_FREE_GREAT_PERSON");
				CvString strSummary = GetLocalizedText("TXT_KEY_CHOOSE_FREE_GREAT_PERSON_TT");
				pNotifications->Add(NOTIFICATION_FREE_GREAT_PERSON, strSummary.c_str(), strBuffer.c_str(), -1, -1, -1);
			}
		}
		else
		{
			for(int iI = 0; iI < iChange; iI++)
			{
				AI_chooseFreeGreatPerson();
			}
		}
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumMayaBoosts() const
{
	return m_iNumMayaBoosts;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumMayaBoosts(int iValue)
{
	m_iNumMayaBoosts = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumMayaBoosts(int iChange)
{
	m_iNumMayaBoosts = GetNumMayaBoosts() + iChange;
	if(iChange > 0)
	{
		if(isHuman())
		{
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_MAYA_LONG_COUNT");
				CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_MAYA_LONG_COUNT_TT");
				pNotifications->Add(NOTIFICATION_MAYA_LONG_COUNT, strSummary.c_str(), strBuffer.c_str(), -1, -1, -1);
			}
		}
		else
		{
			for(int iI = 0; iI < iChange; iI++)
			{
				GetPlayerTraits()->ChooseMayaBoost();
			}
		}
	}
}


/// Accessor: Get extra times to spread religion for missionaries from this city
int CvPlayer::GetMissionaryExtraStrength() const
{
	return m_iMissionaryExtraStrength;
}

/// Accessor: Change extra times to spread religion for missionaries from this city
void CvPlayer::ChangeMissionaryExtraStrength(int iChange)
{
	if (iChange != 0)
	{
		m_iMissionaryExtraStrength = (m_iMissionaryExtraStrength + iChange);
		CvAssert(m_iMissionaryExtraStrength >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumFaithGreatPeople() const
{
	return m_iNumFaithGreatPeople;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumFaithGreatPeople(int iValue)
{
	m_iNumFaithGreatPeople = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumFaithGreatPeople(int iChange)
{
	m_iNumFaithGreatPeople = GetNumFaithGreatPeople() + iChange;
	if(iChange > 0)
	{
		if(isHuman())
		{
			CvNotifications* pNotifications = GetNotifications();
			if(pNotifications)
			{
				CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_FAITH_GREAT_PERSON");
				CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_FAITH_GREAT_PERSON_TT");
				pNotifications->Add(NOTIFICATION_FAITH_GREAT_PERSON, strSummary.c_str(), strBuffer.c_str(), -1, -1, -1);
			}
		}
		else
		{
			for(int iI = 0; iI < iChange; iI++)
			{
				AI_chooseFreeGreatPerson();
			}
		}
	}
}
//	--------------------------------------------------------------------------------
int CvPlayer::GetNumArchaeologyChoices() const
{
	return m_iNumArchaeologyChoices;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumArchaeologyChoices(int iValue)
{
	m_iNumArchaeologyChoices = iValue;
}

//	--------------------------------------------------------------------------------
FaithPurchaseTypes CvPlayer::GetFaithPurchaseType() const
{
	return m_eFaithPurchaseType;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetFaithPurchaseType(FaithPurchaseTypes eType)
{
	m_eFaithPurchaseType = eType;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetFaithPurchaseIndex() const
{
	return m_iFaithPurchaseIndex;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetFaithPurchaseIndex(int iIndex)
{
	m_iFaithPurchaseIndex = iIndex;
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetNumFreePoliciesEver() const
{
	return m_iNumFreePoliciesEver;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetNumFreePoliciesEver(int iValue)
{
	m_iNumFreePoliciesEver = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeNumFreePoliciesEver(int iChange)
{
	SetNumFreePoliciesEver(GetNumFreePoliciesEver() + iChange);
}

//	--------------------------------------------------------------------------------
int CvPlayer::GetLastSliceMoved() const
{
	return m_iLastSliceMoved;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetLastSliceMoved(int iValue)
{
	m_iLastSliceMoved = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetEverConqueredBy(PlayerTypes ePlayer, bool bValue)
{
	if(bValue)
	{
		m_bfEverConqueredBy.SetBit(ePlayer);
	}
	else
	{
		m_bfEverConqueredBy.ClearBit(ePlayer);
	}
}

//	--------------------------------------------------------------------------------
bool CvPlayer::IsEverConqueredBy(PlayerTypes ePlayer)
{
	return m_bfEverConqueredBy.GetBit(ePlayer);
}

//	------------------------------------------------------------------------------------------------
const FAutoArchive& CvPlayer::getSyncArchive() const
{
	return m_syncArchive;
}

//	--------------------------------------------------------------------------------
FAutoArchive& CvPlayer::getSyncArchive()
{
	return m_syncArchive;
}

//	-----------------------------------------------------------------------------------------------
bool CvPlayer::isLocalPlayer() const
{
	return (GC.getGame().getActivePlayer() == GetID());
}

//	-----------------------------------------------------------------------------------------------
void CvPlayer::disconnected()
{
	bool isMultiplayer = GC.getGame().isGameMultiPlayer();
	if(isMultiplayer && isHuman() && !isLocalPlayer())
	{
			//log message for debugging the occasional lack of disconnect notification when Steam p2p connections timeout. - bolson 1/10/13
			FILogFile* logFile = LOGFILEMGR.GetLog("net_message_debug.log", 0);
			if(logFile)
			{
				logFile->DebugMsg("Attempted to post notification for player disconnect event.  Player(%i)", GetID());
			}

			CvNotifications* pNotifications = GET_PLAYER(GC.getGame().getActivePlayer()).GetNotifications();
			if(pNotifications){
				if(gDLL->IsPlayerKicked(GetID())){
					Localization::String kickedMsg = Localization::Lookup("TXT_KEY_PLAYER_KICKED");
					kickedMsg << getNameKey();
					pNotifications->Add(NOTIFICATION_PLAYER_KICKED, kickedMsg.toUTF8(), kickedMsg.toUTF8(), -1, -1, GetID());
				}
				else{
					Localization::String disconnectString = Localization::Lookup("TXT_KEY_PLAYER_DISCONNECTED");
					disconnectString << getNameKey();

					if(CvPreGame::isPitBoss()){
						disconnectString = Localization::Lookup("TXT_KEY_PLAYER_DISCONNECTED_PITBOSS");
						disconnectString << getNameKey();	
					}

					pNotifications->Add(NOTIFICATION_PLAYER_DISCONNECTED, disconnectString.toUTF8(), disconnectString.toUTF8(), -1, -1, GetID());
				}
			}

		if(!isObserver() && (!CvPreGame::isPitBoss() || gDLL->IsPlayerKicked(GetID())))
		{
			// JAR : First pass, automatically fall back to CPU so the
			// game can continue. Todo : add popup on host asking whether
			// the AI should take over or everyone should wait for the
			// player to reconnect
			CvPreGame::setSlotStatus(GetID(), SS_COMPUTER);
			CvPreGame::VerifyHandicap(GetID());	//Changing the handicap because we're switching to AI

			// Load leaderhead for this new AI player
			gDLL->NotifySpecificAILeaderInGame(GetID());
			
			if(!GC.getGame().isOption(GAMEOPTION_DYNAMIC_TURNS) && GC.getGame().isOption(GAMEOPTION_SIMULTANEOUS_TURNS))
			{//When in fully simultaneous turn mode, having a player disconnect might trigger the automove phase for all human players.
				checkRunAutoMovesForEveryone();
			}
		}
	}
}
//	-----------------------------------------------------------------------------------------------
void CvPlayer::reconnected()
{
	//Preserve observer status for the connecting human player's slot.
	if(CvPreGame::slotStatus(GetID()) != SS_OBSERVER){
		CvPreGame::setSlotStatus(GetID(), SS_TAKEN);
	}

	CvPreGame::VerifyHandicap(GetID()); //verify the handicap because we might have replaced an ai.

	CvGame& kGame = GC.getGame();
	bool isMultiplayer = kGame.isGameMultiPlayer();

	if(isMultiplayer && !isLocalPlayer())
	{
		FAutoArchive& archive = getSyncArchive();
		archive.clearDelta();

		Localization::String connectString = Localization::Lookup("TXT_KEY_PLAYER_CONNECTING");
		connectString << getNameKey();

		CvNotifications* pNotifications = GET_PLAYER(kGame.getActivePlayer()).GetNotifications();
		if(pNotifications)
		{
			pNotifications->Add(NOTIFICATION_PLAYER_CONNECTING, connectString.toUTF8(), connectString.toUTF8(), -1, -1, GetID());
		}
	}
}
//	-----------------------------------------------------------------------------------------------
bool CvPlayer::hasBusyUnitUpdatesRemaining() const
{
	return m_endTurnBusyUnitUpdatesLeft > 0;
}

//	-----------------------------------------------------------------------------------------------
void CvPlayer::setBusyUnitUpdatesRemaining(int iUpdateCount)
{
	m_endTurnBusyUnitUpdatesLeft = iUpdateCount;
}

//	-----------------------------------------------------------------------------------------------
const char* const CvPlayer::getNickName() const
{
	return CvPreGame::nicknameDisplayed(GetID()).c_str();
}

//	-----------------------------------------------------------------------------------------------
bool CvPlayer::hasUnitsThatNeedAIUpdate() const
{
	const CvUnit* pLoopUnit;
	int iLoop;

	for(pLoopUnit = firstUnit(&iLoop); pLoopUnit; pLoopUnit = nextUnit(&iLoop))
	{
		if(!pLoopUnit->TurnProcessed() &&
		        (pLoopUnit->IsAutomated() &&
		         pLoopUnit->AI_getUnitAIType() != UNITAI_UNKNOWN &&
		         pLoopUnit->canMove()))
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
std::string CvPlayer::debugDump(const FAutoVariableBase&) const
{
	std::string result = "Game Turn : ";
	char gameTurnBuffer[8] = {0};
	int gameTurn = GC.getGame().getGameTurn();
	sprintf_s(gameTurnBuffer, "%d\0", gameTurn);
	result += gameTurnBuffer;
	return result;
}

//	--------------------------------------------------------------------------------
std::string CvPlayer::stackTraceRemark(const FAutoVariableBase& var) const
{
	std::string result = debugDump(var);
	if(&var == &m_aOptions)
	{//detail output for player options array.
		result += "\nPlayer Options:";
		for (PlayerOptionsVector::const_iterator itr = m_aOptions.begin(); itr != m_aOptions.end(); ++itr )
		{
			CvString curOptionsStr;
			curOptionsStr.Format("\n%u, %d", itr->first, itr->second);
			result += curOptionsStr;
		}
		result += "\n";
	}
	return result;
}

//	--------------------------------------------------------------------------------
bool CvPlayer::hasTurnTimerExpired()
{//Indicates if this player's turn time has elapsed.
	return GC.getGame().hasTurnTimerExpired(GetID());
}

//	--------------------------------------------------------------------------------
void CvPlayer::checkArmySizeAchievement()
{
#if !defined(NO_ACHIEVEMENTS)
	int numUnits = 0;
	int32 nLargestArmy = 0;
	int iI;

	for(iI = 0; iI < NUM_UNITAI_TYPES; iI++)
	{
		if((UnitAITypes)iI == UNITAI_ARTIST ||(UnitAITypes)iI == UNITAI_ENGINEER || (UnitAITypes)iI == UNITAI_UNKNOWN ||
		        (UnitAITypes)iI == UNITAI_GENERAL || (UnitAITypes)iI == UNITAI_SETTLE || (UnitAITypes)iI == UNITAI_WORKER ||
		        (UnitAITypes)iI == UNITAI_SCIENTIST || (UnitAITypes)iI == UNITAI_MERCHANT || (UnitAITypes)iI == UNITAI_WORKER_SEA ||
		        (UnitAITypes)iI == UNITAI_SPACESHIP_PART || (UnitAITypes)iI == UNITAI_TREASURE || (UnitAITypes)iI == UNITAI_PROPHET ||
		        (UnitAITypes)iI == UNITAI_MISSIONARY || (UnitAITypes)iI == UNITAI_INQUISITOR || (UnitAITypes)iI == UNITAI_ADMIRAL ||
#if defined(MOD_DIPLOMACY_CITYSTATES) 
				(MOD_DIPLOMACY_CITYSTATES && ((UnitAITypes)iI == UNITAI_DIPLOMAT || (UnitAITypes)iI == UNITAI_MESSENGER)) ||
#endif
				(UnitAITypes)iI == UNITAI_WRITER || (UnitAITypes)iI == UNITAI_MUSICIAN)
		{
			continue;
		}
		else
		{
			numUnits += GetNumUnitsWithUnitAI((UnitAITypes)iI, false, true);
		}
	}
	gDLL->GetSteamStat(ESTEAMSTAT_STANDINGARMY, &nLargestArmy);

	if(nLargestArmy < numUnits)
	{
		gDLL->SetSteamStat(ESTEAMSTAT_STANDINGARMY, numUnits);

		CvAchievementUnlocker::Check_PSG();
	}
#endif
}

//	--------------------------------------------------------------------------------
void CvPlayer::checkInitialTurnAIProcessed()
{
	int turn = GC.getGame().getGameTurn();
	if(m_lastGameTurnInitialAIProcessed != turn)
	{
		//Note: Players that are not turn active at the beginning of the game turn will 
		//process their AI when they are turn active.  However, they should still 
		//act like their initial AI has been processed.
		if(!isTurnActive() || !hasUnitsThatNeedAIUpdate())
		{
			m_lastGameTurnInitialAIProcessed = turn;
			if(GC.getGame().getActivePlayer() == GetID())
				gDLL->sendPlayerInitialAIProcessed();
		}
	}
}

//------------------------------------------------------------------------------
void CvPlayer::GatherPerTurnReplayStats(int iGameTurn)
{
	AI_PERF_FORMAT("AI-perf.csv", ("CvPlayer::GatherPerTurnReplayStats, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), getCivilizationShortDescription()) );
#if !defined(FINAL_RELEASE)
	cvStopWatch watch("Replay Stat Recording");
#endif
	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if(pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(GetID());

		bool bResult;
		LuaSupport::CallHook(pkScriptSystem, "GatherPerTurnReplayStats", args.get(), bResult);
	}

	//Only record the following statistics if the player is alive.
	if(isAlive())
	{
		//	Production Per Turn
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_PRODUCTIONPERTURN"), iGameTurn, calculateTotalYield(YIELD_PRODUCTION));
		// 	Gold
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_TOTALGOLD"), iGameTurn, GetTreasury()->GetGold());
		// 	Gold per Turn
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_GOLDPERTURN"), iGameTurn, calculateTotalYield(YIELD_GOLD));
		// 	Num Cities
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_CITYCOUNT"), iGameTurn, getNumCities());

		//	Number of Techs known
		CvTeam& team = GET_TEAM(getTeam());
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_TECHSKNOWN"), iGameTurn, team.GetTeamTechs()->GetNumTechsKnown());

		// 	Science per Turn
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_SCIENCEPERTURN"), iGameTurn, calculateTotalYield(YIELD_SCIENCE));
		// antonjs: This data is also used to calculate Great Scientist and Research Agreement beaker bonuses. If replay data changes
		// or is disabled, CvPlayer::GetScienceYieldFromPreviousTurns must also change.

		// 	Total Culture
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_TOTALCULTURE"), iGameTurn, getJONSCulture());

		// 	Culture per turn
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_CULTUREPERTURN"), iGameTurn, GetTotalJONSCulturePerTurn());
		
#if defined(MOD_BALANCE_CORE)
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_TOURISMPERTURN"), iGameTurn, GetCulture()->GetTourism() / 100);
#endif

		// 	Happiness
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_EXCESSHAPINESS"), iGameTurn, GetExcessHappiness());
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_HAPPINESS"), iGameTurn, GetHappiness());
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_UNHAPPINESS"), iGameTurn, GetUnhappiness());

		// 	Golden Age turns
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_GOLDENAGETURNS"), iGameTurn, getGoldenAgeTurns());

		// 	Population
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_POPULATION"), iGameTurn, getTotalPopulation());

		// 	Food Per Turn
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_FOODPERTURN"), iGameTurn, calculateTotalYield(YIELD_FOOD));

		//	Total Land
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_TOTALLAND"), iGameTurn, getTotalLand());

		CvTreasury* pkTreasury = GetTreasury();
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_GPTCITYCONNECTIONS"), iGameTurn, pkTreasury->GetCityConnectionGold());
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_GPTINTERNATIONALTRADE"), iGameTurn, pkTreasury->GetGoldPerTurnFromTradeRoutes());
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_GPTDEALS"), iGameTurn, pkTreasury->GetGoldPerTurnFromDiplomacy());
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_UNITMAINTENANCE"), iGameTurn, pkTreasury->GetExpensePerTurnUnitMaintenance());
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_BUILDINGMAINTENANCE"), iGameTurn, pkTreasury->GetBuildingGoldMaintenance());
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_IMPROVEMENTMAINTENANCE"), iGameTurn, pkTreasury->GetImprovementGoldMaintenance());
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_NUMBEROFPOLICIES"), iGameTurn, GetPlayerPolicies()->GetNumPoliciesOwned());

		// workers
		int iWorkerCount = 0;
		CvUnit* pLoopUnit;
		int iLoopUnit;
		for(pLoopUnit = firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoopUnit))
		{
			if(pLoopUnit->AI_getUnitAIType() == UNITAI_WORKER)
			{
				iWorkerCount++;
			}
		}
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_NUMBEROFWORKERS"), iGameTurn, iWorkerCount);

		// worked tiles
		int iWorkedTiles = 0;
		int iImprovedTiles = 0;
		// go through all the plots the player has under their control
		for (PlotIndexContainer::const_iterator it = m_aiPlots.begin(); it != m_aiPlots.end(); ++it)
		{
			CvPlot* pPlot = GC.getMap().plotByIndex(*it);
			if (!pPlot)
			{
				continue;
			}

			// plot has city in it, don't count
			if(pPlot->getPlotCity())
			{
				continue;
			}

			if(pPlot->isBeingWorked())
			{
				iWorkedTiles++;
			}

			if(pPlot->getImprovementType() != NO_IMPROVEMENT)
			{
				iImprovedTiles++;
			}
		}

		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_IMPROVEDTILES"), iGameTurn, iImprovedTiles);
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_WORKEDTILES"), iGameTurn, iWorkedTiles);
		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_NUMBEROFWORKERS"), iGameTurn, iWorkerCount);


		setReplayDataValue(getReplayDataSetIndex("REPLAYDATASET_MILITARYMIGHT"), iGameTurn, GetMilitaryMight());
	}
}

//	---------------------------------------------------------------------------
//	If the active player is in the end-turn processing phase, attempt to cancel that.
//	This should be called when something occurs that could happen during the end-turn
//	that may need the players attention this turn.
//	Ex.  A player's unit auto-moves into a goody hut plot.
bool CancelActivePlayerEndTurn()
{
	CvPlayer& kActivePlayer = GET_PLAYER(GC.getGame().getActivePlayer());

	if(kActivePlayer.isLocalPlayer() && kActivePlayer.isEndTurn())
	{
		if (gDLL->sendTurnUnready())	// This will see if we can actually do the unready, sometimes you can't in MP games.
		{
			kActivePlayer.setEndTurn(false);
			return true;
		}
		return false;
	}
	return true;
}

#if defined(MOD_DIPLOMACY_CIV4_FEATURES)
//	--------------------------------------------------------------------------------
///	Get the amount of Happiness we're getting from our vassals
int CvPlayer::GetHappinessFromVassals() const
{
	int iHappiness = 0;

	PlayerTypes ePlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		ePlayer = (PlayerTypes) iPlayerLoop;
		if(GetID() != ePlayer && GET_PLAYER(ePlayer).isAlive())
		{
			iHappiness += GetHappinessFromVassal(ePlayer);
		}
	}

	return max(0, iHappiness);
}
//	--------------------------------------------------------------------------------
/// Happiness from a Vassal
int CvPlayer::GetHappinessFromVassal(PlayerTypes ePlayer) const
{
	// Do not evaluate dead players (prevents crash)
	if (!GET_PLAYER(ePlayer).isAlive()) return 0;
	
	int iAmount = 0;
	if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassal(getTeam()))
	{
		iAmount += GET_PLAYER(ePlayer).GetExcessHappiness() * (GC.getVASSAL_HAPPINESS_PERCENT() + GetVassalCSBonusModifier());
		iAmount /= 100;
	}
	return iAmount;
}
//	--------------------------------------------------------------------------------
/// Special bonus for having a vassal
int CvPlayer::GetYieldPerTurnFromVassals(YieldTypes eYield) const
{
	int iFreeYield = 0;
	int iYield = 0;
	PlayerTypes ePlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		ePlayer = (PlayerTypes) iPlayerLoop;
		
		// ePlayer vassal of ours?
		if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassal(getTeam()))
		{
			iFreeYield = 0;
			switch(eYield)
			{
				// We now collect gold from taxes
				case YIELD_GOLD:
					//iFreeYield = GET_PLAYER(ePlayer).calculateGoldRate();
					//iFreeYield *= /*33*/GC.getVASSALAGE_FREE_YIELD_FROM_VASSAL_PERCENT();
					//iFreeYield /= 100;
					break;

				case YIELD_CULTURE:
					if (eYield == YIELD_CULTURE && (GC.getGame().isOption(GAMEOPTION_NO_POLICIES)))
					{
						return 0;
					}
					iFreeYield = GET_PLAYER(ePlayer).GetTotalJONSCulturePerTurn();
					iFreeYield *= (/*33*/GC.getVASSALAGE_FREE_YIELD_FROM_VASSAL_PERCENT() + GetVassalCSBonusModifier());
					iFreeYield /= 100;

					break;

				case YIELD_FAITH:
					if (eYield == YIELD_FAITH && (GC.getGame().isOption(GAMEOPTION_NO_RELIGION)))
					{
						return 0;
					}
					iFreeYield = GET_PLAYER(ePlayer).GetTotalFaithPerTurn();
					iFreeYield *= (/*33*/GC.getVASSALAGE_FREE_YIELD_FROM_VASSAL_PERCENT() + GetVassalCSBonusModifier());
					iFreeYield /= 100;
					break;
				case YIELD_SCIENCE:
					if (eYield == YIELD_SCIENCE && (GC.getGame().isOption(GAMEOPTION_NO_SCIENCE)))
					{
						return 0;
					}
					iFreeYield = GET_PLAYER(ePlayer).GetScience();
					iFreeYield *= (/*33*/GC.getVASSALAGE_FREE_YIELD_FROM_VASSAL_PERCENT() + GetVassalCSBonusModifier());
					iFreeYield /= 100;
					break;
			}

			iYield += iFreeYield;
		}
	}
	return iYield;
}
//	--------------------------------------------------------------------------------
// Score from Vassals: 50% percent
int CvPlayer::GetScoreFromVassals() const
{
	int iScore = 0;
	PlayerTypes ePlayer;
	for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		ePlayer = (PlayerTypes) iPlayerLoop;
		iScore += GetScoreFromVassal(ePlayer);
	}

	return iScore;
}
//	--------------------------------------------------------------------------------
// Score from vassal
int CvPlayer::GetScoreFromVassal(PlayerTypes ePlayer) const
{
	int iScore = 0;

	if(GET_TEAM(GET_PLAYER(ePlayer).getTeam()).IsVassal(getTeam()))
	{
		iScore = GET_PLAYER(ePlayer).GetScoreFromLand() + GET_PLAYER(ePlayer).GetScoreFromPopulation();
		iScore *= /*20*/ GC.getVASSAL_SCORE_PERCENT();
		iScore /= 100;
	}

	return iScore;
}
// ------------------------

//	--------------------------------------------------------------------------------
int CvPlayer::GetVassalGoldMaintenanceMod() const
{
	return m_iVassalGoldMaintenanceMod;
}

//	--------------------------------------------------------------------------------
void CvPlayer::SetVassalGoldMaintenanceMod(int iValue)
{
	m_iVassalGoldMaintenanceMod = iValue;
}

//	--------------------------------------------------------------------------------
void CvPlayer::ChangeVassalGoldMaintenanceMod(int iChange)
{
	if(iChange != 0)
	{
		m_iVassalGoldMaintenanceMod = (m_iVassalGoldMaintenanceMod + iChange);
	}
}

void CvPlayer::DoVassalLevy()
{
	if (!m_bVassalLevy)
		return;

	// Look at all Cities
	bool bMaster = false;
	CvCity* pMasterCity = NULL;
	int iSum = 0;
	CvCity* pLoopCity;
	int iLoop;
	for (pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop))
	{
		for (int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
		{
			const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

			if (pkBuildingInfo)
			{
				// Has this Building
				if (pLoopCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
				{
					if (pkBuildingInfo->IsVassalLevyEra())
					{
						bMaster = true;
						pMasterCity = pLoopCity;
						break;
					}
				}
			}
		}
	}
	if (bMaster && pMasterCity != NULL)
	{
		std::vector<UnitTypes> aExtraUnits;
		std::vector<UnitAITypes> aExtraUnitAITypes;
		CvUnit* pLoopUnit = NULL;
		int iLoop = 0;
		for (pLoopUnit = firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoop))
		{
			if (pLoopUnit->getDomainType() == DOMAIN_LAND && pLoopUnit->IsCombatUnit())
			{
				UnitTypes eCurrentUnitType = pLoopUnit->getUnitType();
				UnitAITypes eCurrentUnitAIType = pLoopUnit->AI_getUnitAIType();

				// check for duplicate unit
				bool bAddUnit = true;
				for (uint ui = 0; ui < aExtraUnits.size(); ui++)
				{
					if (aExtraUnits[ui] == eCurrentUnitType)
					{
						bAddUnit = false;
					}
				}

				if (bAddUnit)
				{
					aExtraUnits.push_back(eCurrentUnitType);
					aExtraUnitAITypes.push_back(eCurrentUnitAIType);
				}
			}
		}
		if (aExtraUnits.size() > 0)
		{
			int iTotal = GET_TEAM(getTeam()).GetNumVassals() * 2;
			for (int iK = 0; iK < iTotal; iK++)
			{
				int iUnit = GC.getGame().getSmallFakeRandNum(aExtraUnits.size(), GC.getGame().GetCultureAverage() + iK);
				CvUnit* pNewUnit = initUnit(aExtraUnits[iUnit], pMasterCity->getX(), pMasterCity->getY(), aExtraUnitAITypes[iUnit]);
				bool bJumpSuccess = pNewUnit->jumpToNearestValidPlot();
				if (bJumpSuccess)
				{
					pMasterCity->addProductionExperience(pNewUnit);
					iSum++;
				}
				if (!bJumpSuccess)
				{
					pNewUnit->kill(false);
					break;
				}
			}
			if (iSum > 0)
			{
				CvNotifications* pNotifications = GetNotifications();
				if (pNotifications && GetID() == GC.getGame().getActivePlayer())
				{
					Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_VASSAL_LEVY");
					strText << iSum;
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_VASSAL_LEVY_SUMMARY");
					strSummary << iSum;
					pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pMasterCity->getX(), pMasterCity->getY(), -1);
				}
			}
		}
	}

	m_bVassalLevy = false;
}

void CvPlayer::SetVassalLevy(bool bValue)
{
	if (m_bVassalLevy != bValue)
		m_bVassalLevy = bValue;
}

//	--------------------------------------------------------------------------------
// Generate tooltip displayed for whether or not our vassal can declare independence from us
CvString CvPlayer::GetVassalIndependenceTooltipAsMaster(PlayerTypes ePlayer) const
{
	CvTeam& kVassalTeam = GET_TEAM(GET_PLAYER(ePlayer).getTeam());

	TeamTypes eMaster = kVassalTeam.GetMaster();
	if(eMaster != getTeam())
		return "";

	CvTeam& kMasterTeam = GET_TEAM(eMaster);
	
	CvString szTooltip = "";
	
	szTooltip += GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_TT") + "[NEWLINE][NEWLINE]";

	bool bVoluntary = kVassalTeam.IsVoluntaryVassal(getTeam());
	bool bSatisfied = false;

	int iMinimumVassalTurns = bVoluntary ? GC.getGame().getGameSpeedInfo().getMinimumVoluntaryVassalTurns() : GC.getGame().getGameSpeedInfo().getMinimumVassalTurns();

	int iNumTurnsIsVassal = kVassalTeam.GetNumTurnsIsVassal();

	bSatisfied = (iNumTurnsIsVassal >= iMinimumVassalTurns);
	szTooltip += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_TURNS_TT", iMinimumVassalTurns) + "[ENDCOLOR][NEWLINE]";
	
	// Rules only for capitulated vassals
	if(!bVoluntary)
	{
		CvString szTemp = "";
		bool bAnySatisfied = false;

		int iNumCitiesWhenVassalMade = kVassalTeam.getNumCitiesWhenVassalMade();
		int iPopulationWhenVassalMade = kVassalTeam.getTotalPopulationWhenVassalMade();

		int iCityPercent = 0;
		int iPopPercent = 0;

		iCityPercent = kVassalTeam.getNumCities() * 100 / std::max(1, iNumCitiesWhenVassalMade);
		iPopPercent = kVassalTeam.getTotalPopulation() * 100 / std::max(1, iPopulationWhenVassalMade);

		bSatisfied = iCityPercent <= GC.getVASSALAGE_VASSAL_LOST_CITIES_THRESHOLD();
		bAnySatisfied = bAnySatisfied || bSatisfied;
		szTemp += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_CITY_PERCENT_TT", GC.getVASSALAGE_VASSAL_LOST_CITIES_THRESHOLD(),iCityPercent) + "[ENDCOLOR][NEWLINE]";

		bSatisfied = iPopPercent >= GC.getVASSALAGE_VASSAL_POPULATION_THRESHOLD();
		bAnySatisfied = bAnySatisfied || bSatisfied;
		szTemp += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_POP_PERCENT_TT", GC.getVASSALAGE_VASSAL_POPULATION_THRESHOLD(), iPopPercent) + "[ENDCOLOR][NEWLINE]";
		
		int iMasterCityPercent = 0;
		int iMasterPopPercent = 0;

		iMasterCityPercent = kVassalTeam.getNumCities() * 100 / std::max(1, kMasterTeam.getNumCities());
		iMasterPopPercent = kVassalTeam.getTotalPopulation() * 100 / std::max(1, kMasterTeam.getTotalPopulation());

		bSatisfied = iMasterCityPercent >= GC.getVASSALAGE_VASSAL_MASTER_CITY_PERCENT_THRESHOLD() && iMasterPopPercent >= GC.getVASSALAGE_VASSAL_MASTER_POP_PERCENT_THRESHOLD();
		bAnySatisfied = bAnySatisfied || bSatisfied;
		szTemp += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_MASTER_PERCENT_TT", GC.getVASSALAGE_VASSAL_MASTER_CITY_PERCENT_THRESHOLD(), GC.getVASSALAGE_VASSAL_MASTER_POP_PERCENT_THRESHOLD(), iMasterCityPercent, iMasterPopPercent) + "[ENDCOLOR][NEWLINE]";

		szTooltip += (bAnySatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_OR_HEADER_TT") + "[NEWLINE]";
		szTooltip += szTemp;
	}

	return szTooltip;
}

// Generate tooltip displayed for whether or not we can declare independence from master
CvString CvPlayer::GetVassalIndependenceTooltipAsVassal() const
{
	CvTeam& kVassalTeam = GET_TEAM(getTeam());

	TeamTypes eMaster = kVassalTeam.GetMaster();
	if(eMaster == NO_TEAM)
		return "";

	CvTeam& kMasterTeam = GET_TEAM(eMaster);
	
	CvString szTooltip = "";
	
	szTooltip += GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_MASTER_TT") + "[NEWLINE][NEWLINE]";

	bool bVoluntary = kVassalTeam.IsVoluntaryVassal(getTeam());
	bool bSatisfied = false;

	int iMinimumVassalTurns = bVoluntary ? GC.getGame().getGameSpeedInfo().getMinimumVoluntaryVassalTurns() : GC.getGame().getGameSpeedInfo().getMinimumVassalTurns();

	int iNumTurnsIsVassal = kVassalTeam.GetNumTurnsIsVassal();

	bSatisfied = (iNumTurnsIsVassal >= iMinimumVassalTurns);
	szTooltip += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_TURNS_TT", iMinimumVassalTurns) + "[ENDCOLOR][NEWLINE]";
	
	// Rules only for capitulated vassals
	if(!bVoluntary)
	{
		CvString szTemp = "";
		bool bAnySatisfied = false;

		int iNumCitiesWhenVassalMade = kVassalTeam.getNumCitiesWhenVassalMade();
		int iPopulationWhenVassalMade = kVassalTeam.getTotalPopulationWhenVassalMade();

		int iCityPercent = 0;
		int iPopPercent = 0;

		iCityPercent = kVassalTeam.getNumCities() * 100 / std::max(1, iNumCitiesWhenVassalMade);
		iPopPercent = kVassalTeam.getTotalPopulation() * 100 / std::max(1, iPopulationWhenVassalMade);

		bSatisfied = iCityPercent <= GC.getVASSALAGE_VASSAL_LOST_CITIES_THRESHOLD();
		bAnySatisfied = bAnySatisfied || bSatisfied;
		szTemp += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_CITY_PERCENT_TT", GC.getVASSALAGE_VASSAL_LOST_CITIES_THRESHOLD(),iCityPercent) + "[ENDCOLOR][NEWLINE]";

		bSatisfied = iPopPercent >= GC.getVASSALAGE_VASSAL_POPULATION_THRESHOLD();
		bAnySatisfied = bAnySatisfied || bSatisfied;
		szTemp += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_CITY_PERCENT_TT", GC.getVASSALAGE_VASSAL_POPULATION_THRESHOLD(), iPopPercent) + "[ENDCOLOR][NEWLINE]";
		
		int iMasterCityPercent = 0;
		int iMasterPopPercent = 0;

		iMasterCityPercent = kVassalTeam.getNumCities() * 100 / std::max(1, kMasterTeam.getNumCities());
		iMasterPopPercent = kVassalTeam.getTotalPopulation() * 100 / std::max(1, kMasterTeam.getTotalPopulation());

		bSatisfied = iMasterCityPercent >= GC.getVASSALAGE_VASSAL_MASTER_CITY_PERCENT_THRESHOLD() && iMasterPopPercent >= GC.getVASSALAGE_VASSAL_MASTER_POP_PERCENT_THRESHOLD();
		bAnySatisfied = bAnySatisfied || bSatisfied;
		szTemp += (bSatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_MASTER_PERCENT_TT", GC.getVASSALAGE_VASSAL_MASTER_CITY_PERCENT_THRESHOLD(), GC.getVASSALAGE_VASSAL_MASTER_POP_PERCENT_THRESHOLD(), iMasterCityPercent, iMasterPopPercent) + "[ENDCOLOR][NEWLINE]";

		szTooltip += (bAnySatisfied ? "[COLOR_POSITIVE_TEXT]" : "[COLOR_GREY]") + GetLocalizedText("TXT_KEY_VO_INDEPENDENCE_POSSIBLE_OR_HEADER_TT") + "[NEWLINE]";
		szTooltip += szTemp;
	}

	return szTooltip;
}

#endif

#if defined(MOD_BALANCE_CORE)
int CvPlayer::GetScoreFromMinorAllies() const
{
	int iScore = (GC.getGame().GetNumMinorCivsEver() * 25);
	int iMaxMinorCivs = 0;
	int iMinorAllies = 0;
	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
	{
		PlayerTypes eMinor = (PlayerTypes) iMinorLoop;
		if(GET_PLAYER(eMinor).isAlive())
		{
			iMaxMinorCivs++;
		}
		if(GET_PLAYER(eMinor).GetMinorCivAI()->IsAllies(GetID()))
		{
			iMinorAllies++;
		}
	}
	if(iMaxMinorCivs > 0)
	{
		int iPercentage = ((iMinorAllies * 100) / iMaxMinorCivs);
		iScore = ((iPercentage * iScore) / 100);
		return iScore;
	}
	return 0;
}
int CvPlayer::GetScoreFromMilitarySize() const
{
	return (GetMilitaryMight() / (20 + getNumCities()));
}
#endif

#if defined(MOD_API_EXTENSIONS)
//	----------------------------------------------------------------------------
bool CvPlayer::HasBelief(BeliefTypes iBeliefType) const
{
	const ReligionTypes iReligion = GetReligions()->GetReligionCreatedByPlayer(true);
	const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(iReligion, GetID());

	return (pReligion && pReligion->m_Beliefs.HasBelief(iBeliefType));
}

bool CvPlayer::HasBuilding(BuildingTypes iBuildingType)
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasBuilding(iBuildingType)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasBuildingClass(BuildingClassTypes iBuildingClassType)
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasBuildingClass(iBuildingClassType)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasAnyWonder()
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasAnyWonder()) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasWonder(BuildingTypes iBuildingType)
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasWonder(iBuildingType)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::IsCivilization(CivilizationTypes iCivilizationType) const
{
	return (getCivilizationType() == iCivilizationType);
}

bool CvPlayer::IsInEra(EraTypes iEraType) const
{
	return (GET_TEAM(getTeam()).GetCurrentEra() == iEraType);
}

bool CvPlayer::HasReachedEra(EraTypes iEraType) const
{
	return (GET_TEAM(getTeam()).GetCurrentEra() >= iEraType);
}

bool CvPlayer::HasAnyNaturalWonder()
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasAnyNaturalWonder()) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasNaturalWonder(FeatureTypes iFeatureType)
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasNaturalWonder(iFeatureType)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasPolicy(PolicyTypes iPolicyType) const
{
	return GetPlayerPolicies()->HasPolicy(iPolicyType);
}

bool CvPlayer::HasTenet(PolicyTypes iPolicyType) const
{
	return HasPolicy(iPolicyType);
}

bool CvPlayer::HasPolicyBranch(PolicyBranchTypes iPolicyBranchType) const
{
	return GetPlayerPolicies()->IsPolicyBranchUnlocked(iPolicyBranchType);
}

bool CvPlayer::HasIdeology(PolicyBranchTypes iPolicyBranchType) const
{
	return HasPolicyBranch(iPolicyBranchType);
}
bool CvPlayer::HasSameIdeology(PlayerTypes ePlayer) const
{
	CvPlayer &kPlayer = GET_PLAYER(ePlayer);
	PolicyBranchTypes eMyIdeology = GetPlayerPolicies()->GetLateGamePolicyTree();
	PolicyBranchTypes eTheirIdeology = kPlayer.GetPlayerPolicies()->GetLateGamePolicyTree();
	if (eMyIdeology != NO_POLICY_BRANCH_TYPE && eTheirIdeology != NO_POLICY_BRANCH_TYPE && eMyIdeology == eTheirIdeology)
	{
		return true;
	}
	return false;
}
bool CvPlayer::HasProject(ProjectTypes iProjectType) const
{
	return (GET_TEAM(getTeam()).getProjectCount(iProjectType) > 0);
}

bool CvPlayer::IsAtPeace() const
{
	return !IsAtWar();
}

bool CvPlayer::IsAtPeaceAllMajors() const
{
	return !IsAtWarAnyMajor();
}

bool CvPlayer::IsAtPeaceAllMinors() const
{
	return !IsAtWarAnyMinor();
}

bool CvPlayer::IsAtPeaceWith(PlayerTypes iPlayer) const
{
	return !IsAtWarWith(iPlayer);
}

bool CvPlayer::IsAtWar() const
{
	//reference is important! otherwise the destructor will be called
	CvTeam& kTeam = GET_TEAM(getTeam());

	//ignore the barbarian team here!
	for (int iTeam = 0; iTeam < (MAX_TEAMS-1); iTeam++) {
		if (GET_TEAM((TeamTypes)iTeam).isAlive() && kTeam.isAtWar((TeamTypes)iTeam)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::IsAtWarAnyMajor() const
{
	//reference is important! otherwise the destructor will be called
	CvTeam& kTeam = GET_TEAM(getTeam());

	for (int iTeam = 0; iTeam < (MAX_TEAMS-1); iTeam++) {
		if (GET_TEAM((TeamTypes)iTeam).isAlive() && GET_TEAM((TeamTypes)iTeam).isMajorCiv() && kTeam.isAtWar((TeamTypes)iTeam)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::IsAtWarAnyMinor() const
{
	//reference is important! otherwise the destructor will be called
	CvTeam& kTeam = GET_TEAM(getTeam());

	for (int iTeam = 0; iTeam < (MAX_TEAMS-1); iTeam++) {
		if (GET_TEAM((TeamTypes)iTeam).isAlive() && GET_TEAM((TeamTypes)iTeam).isMinorCiv() && kTeam.isAtWar((TeamTypes)iTeam)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::IsAtWarWith(PlayerTypes iPlayer) const
{
	if (iPlayer==NO_PLAYER)
		return false;

	return GET_TEAM(getTeam()).isAtWar(GET_PLAYER(iPlayer).getTeam());
}

bool CvPlayer::HasPantheon() const
{
	return GetReligions()->HasCreatedPantheon();
}

bool CvPlayer::HasAnyReligion() const
{
	return GetReligions()->HasCreatedReligion();
}

bool CvPlayer::HasReligion(ReligionTypes iReligionType) const
{
	return (GetReligions()->GetReligionCreatedByPlayer() == iReligionType);
}

bool CvPlayer::HasEnhancedReligion() const
{
	const ReligionTypes eReligion = GetReligions()->GetReligionCreatedByPlayer();
	const CvReligion* pMyReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, GetID());

	return (pMyReligion && pMyReligion->m_bEnhanced);
}

bool CvPlayer::IsConnectedTo(PlayerTypes iPlayer)
{
	return IsCapitalConnectedToPlayer(iPlayer);
}

bool CvPlayer::HasSpecialistSlot(SpecialistTypes iSpecialistType)
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasSpecialistSlot(iSpecialistType)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasSpecialist(SpecialistTypes iSpecialistType)
{
	int iLoopCity;
	for (CvCity* pLoopCity = firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = nextCity(&iLoopCity)) {
		if (pLoopCity->HasSpecialist(iSpecialistType)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasTech(TechTypes iTechType) const
{
	return GET_TEAM(getTeam()).GetTeamTechs()->HasTech(iTechType);
}

bool CvPlayer::HasAnyDomesticTradeRoute() const
{
	int iOwner = GetID();
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute)) {
			continue;
		}

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));

		if (pConnection->m_eOriginOwner == iOwner && pConnection->m_eDestOwner == iOwner) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasAnyInternationalTradeRoute() const
{
	int iOwner = GetID();
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute)) {
			continue;
		}

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));

		if ((pConnection->m_eOriginOwner == iOwner && pConnection->m_eDestOwner   != iOwner) ||
		    (pConnection->m_eDestOwner   == iOwner && pConnection->m_eOriginOwner != iOwner)) {
			return true;
		}
	}

	return false;
}
int CvPlayer::GetNumInternalRoutes() const
{
	int iOwner = GetID();
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();
	int iNum = 0;
	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute)) {
			continue;
		}

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));

		if (pConnection->m_eOriginOwner == iOwner && pConnection->m_eDestOwner == iOwner) {
			iNum++;
		}
	}

	return iNum;
}

int CvPlayer::GetNumInternationalRoutes() const
{
	int iOwner = GetID();
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();
	int iNum = 0;
	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute)) {
			continue;
		}

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));

		if (pConnection->m_eOriginOwner == iOwner && pConnection->m_eDestOwner != iOwner)
		{
			iNum++;
		}
	}

	return iNum;
}
bool CvPlayer::HasAnyTradeRoute() const
{
	int iOwner = GetID();
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute)) {
			continue;
		}

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));

		if (pConnection->m_eOriginOwner == iOwner || pConnection->m_eDestOwner == iOwner) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasAnyTradeRouteWith(PlayerTypes iPlayer) const
{
	int iOwner = GetID();
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute)) {
			continue;
		}

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));

		if ((pConnection->m_eOriginOwner == iOwner && pConnection->m_eDestOwner   == iPlayer) ||
		    (pConnection->m_eDestOwner   == iOwner && pConnection->m_eOriginOwner == iPlayer)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasUnit(UnitTypes iUnitType)
{
	int iLoopUnit;

	for (CvUnit* pLoopUnit = firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoopUnit)) {
		if (!pLoopUnit->isDelayedDeath()) {
			if (pLoopUnit->IsUnit(iUnitType)) {
				return true;
			}
		}
	}

	return false;
}

bool CvPlayer::HasUnitClass(UnitClassTypes iUnitClassType)
{
	int iLoopUnit;

	for (CvUnit* pLoopUnit = firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoopUnit)) {
		if (!pLoopUnit->isDelayedDeath()) {
			if (pLoopUnit->IsUnitClass(iUnitClassType)) {
				return true;
			}
		}
	}

	return false;
}

bool CvPlayer::HasUUActive()
{
	int iLoopUnit;

	CvCivilizationInfo* pkInfo = GC.getCivilizationInfo(getCivilizationType());
	if (pkInfo)
	{
		for (CvUnit* pLoopUnit = firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = nextUnit(&iLoopUnit)) 
		{
			if (!pLoopUnit->isDelayedDeath()) 
			{
				if (pkInfo->isCivilizationUnitOverridden(pLoopUnit->getUnitClassType()))
				{
					return true;
				}
			}
		}
	}

	return false;
}

bool CvPlayer::HasUUPeriod() const
{
	return m_bHasUUPeriod;
}

void CvPlayer::SetHasUUPeriod()
{
	CvCivilizationInfo* pkInfo = GC.getCivilizationInfo(getCivilizationType());
	if (pkInfo)
	{
		// Loop through all units
		for (int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
		{
			// Is this one overridden for our civ?
			if (pkInfo->isCivilizationUnitOverridden(iI))
			{
				UnitTypes eCivilizationUnit = static_cast<UnitTypes>(pkInfo->getCivilizationUnits(iI));
				if (eCivilizationUnit != NO_UNIT)
				{
					CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eCivilizationUnit);
					if (pkUnitEntry && pkUnitEntry->GetCombat() > 0 || pkUnitEntry->GetRangedCombat() > 0 || pkUnitEntry->GetCultureBombRadius() > 0 || pkUnitEntry->IsCanRepairFleet() || pkUnitEntry->IsCityAttackSupport())
					{
						//obsolete? This no longer applies.
						if (pkUnitEntry->GetObsoleteTech() != NO_TECH && HasTech((TechTypes)pkUnitEntry->GetObsoleteTech()))
						{
							m_bHasUUPeriod = false;
						}
						else if (!m_bHasUUPeriod)
						{
							m_bHasUUPeriod = true;
							return;
						}
					}
				}
			}
		}
	}
	if (m_bHasUUPeriod)
		m_bHasUUPeriod = false;
}

bool CvPlayer::HasTrait(TraitTypes eTrait) const
{
	return GetPlayerTraits()->HasTrait(eTrait);
}

bool CvPlayer::HasAnyHolyCity()
{
	int iLoop;

	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		if (pLoopCity->GetCityReligions()->IsHolyCityAnyReligion()) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasHolyCity(ReligionTypes eReligion)
{
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		if (pLoopCity->GetCityReligions()->IsHolyCityForReligion(eReligion)) {
			return true;
		}
	}

	return false;
}

bool CvPlayer::HasCapturedHolyCity(ReligionTypes eReligion)
{
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		if (pLoopCity->GetCityReligions()->IsHolyCityForReligion(eReligion)) {
			return (pLoopCity->getOriginalOwner() != GetID());
		}
	}

	return false;
}

bool CvPlayer::HasEmbassyWith(PlayerTypes eOtherPlayer) const
{
	if (eOtherPlayer >= 0 && eOtherPlayer < MAX_MAJOR_CIVS) {
		CvPlayer& kOtherPlayer = GET_PLAYER(eOtherPlayer);

		return (kOtherPlayer.isAlive() && GET_TEAM(getTeam()).HasEmbassyAtTeam(kOtherPlayer.getTeam()));
	}

	return false;
}

void CvPlayer::DoForceDefPact(PlayerTypes eOtherPlayer)
{
	CvTeam& pOtherTeam = GET_TEAM(GET_PLAYER(eOtherPlayer).getTeam());

	GET_TEAM(getTeam()).SetHasDefensivePact(pOtherTeam.GetID(), true);
	pOtherTeam.SetHasDefensivePact(getTeam(), true);
}
int CvPlayer::CountAllFeature(FeatureTypes iFeatureType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountFeature(iFeatureType);
	}
	
	return iCount;
}

int CvPlayer::CountAllWorkedFeature(FeatureTypes iFeatureType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountWorkedFeature(iFeatureType);
	}
	
	return iCount;
}

int CvPlayer::CountAllImprovement(ImprovementTypes iImprovementType, bool bOnlyCreated)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountImprovement(iImprovementType, bOnlyCreated);
	}
	
	return iCount;
}

int CvPlayer::CountAllWorkedImprovement(ImprovementTypes iImprovementType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountWorkedImprovement(iImprovementType);
	}
	
	return iCount;
}

int CvPlayer::CountAllPlotType(PlotTypes iPlotType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountPlotType(iPlotType);
	}
	
	return iCount;
}

int CvPlayer::CountAllWorkedPlotType(PlotTypes iPlotType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountWorkedPlotType(iPlotType);
	}
	
	return iCount;
}

int CvPlayer::CountAllResource(ResourceTypes iResourceType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountResource(iResourceType);
	}
	
	return iCount;
}

int CvPlayer::CountAllWorkedResource(ResourceTypes iResourceType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountWorkedResource(iResourceType);
	}
	
	return iCount;
}

int CvPlayer::CountAllTerrain(TerrainTypes iTerrainType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountTerrain(iTerrainType);
	}
	
	return iCount;
}

int CvPlayer::CountAllWorkedTerrain(TerrainTypes iTerrainType)
{
	int iCount = 0;
	
	int iLoop;
	for (CvCity* pLoopCity = firstCity(&iLoop); pLoopCity != NULL; pLoopCity = nextCity(&iLoop)) {
		iCount += pLoopCity->CountWorkedTerrain(iTerrainType);
	}
	
	return iCount;
}
#endif

void CvPlayer::invalidatePlotFoundValues()
{
	m_iPlotFoundValuesUpdateTurn = -1;
}

void CvPlayer::computeAveragePlotFoundValue()
{
	// important preparation
	GC.getGame().GetSettlerSiteEvaluator()->ComputeFlavorMultipliers(this);

	unsigned int iSum = 0, iValidPlots = 0;

	CvSiteEvaluatorForSettler* pCalc = GC.getGame().GetSettlerSiteEvaluator();
	for (int iI = 0; iI < GC.getMap().numPlots(); iI++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iI);
		int iValue = pCalc->PlotFoundValue(pPlot, this, vector<int>());

		if (iValue > 0)
		{
			iSum += iValue / 1000;
			iValidPlots++;
		}
	}

	int iAvg = (iSum / max(1u,iValidPlots)) * 1000;
	OutputDebugString(CvString::format("Average city site value for player %d is %d\n", m_eID.get(), iAvg).c_str());

	//assuming a normal distribution, this should allow all but the worst plots
	m_iReferenceFoundValue = iAvg - iAvg / 3;
}

void CvPlayer::updatePlotFoundValues()
{
	if (m_iPlotFoundValuesUpdateTurn==GC.getGame().getGameTurn())
		return;

	//OutputDebugString(CvString::format("updating plot found values for player %d in turn %d\n",GetID(),GC.getGame().getGameTurn()).c_str());
	m_viPlotFoundValues = std::vector<int>(GC.getMap().numPlots(), -1);

	// Set all area fertilities to 0
	int iLoop = 0;
	for (CvArea* pLoopArea = GC.getMap().firstArea(&iLoop); pLoopArea != NULL; pLoopArea = GC.getMap().nextArea(&iLoop))
		pLoopArea->setTotalFoundValue(0);

	//don't need to update if never going to settle
	if (isBarbarian())
		return;

	//don't need to update if never going to settle again
	bool bVenice = GetPlayerTraits()->IsNoAnnexing();
#if defined(MOD_BUGFIX_MINOR_CIV_STRATEGIES)
	EconomicAIStrategyTypes eCanSettle = (EconomicAIStrategyTypes)GC.getInfoTypeForString("ECONOMICAISTRATEGY_FOUND_CITY");
	if (EconomicAIHelpers::CannotMinorCiv(this, eCanSettle) || bVenice)
#else
	if (isMinorCiv() || bVenice)
#endif
	{
		if (GetNumCitiesFounded()>0)
			return;
	}

	// important preparation
	GC.getGame().GetSettlerSiteEvaluator()->ComputeFlavorMultipliers(this);
	vector<int> ignorePlots(GC.getMap().numPlots(), 0);
	for (int iI = 0; iI < GC.getMap().numPlots(); iI++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iI);
		if (pPlot->isOwned())
		{
			if (pPlot->getOwner() != m_eID) //if we own it, it's fine
				ignorePlots[iI] = 1;
		}
		else if (pPlot->IsAdjacentOwnedByOtherTeam(getTeam()) && GC.getGame().GetClosestCityDistanceInPlots(pPlot)<4)
			ignorePlots[iI] = 1;
	}

	//what is the worst plot we would settle?
	int iFlavorExpansion = GetFlavorManager()->GetPersonalityIndividualFlavor((FlavorTypes)GC.getInfoTypeForString("FLAVOR_EXPANSION"));
	//clamp it to a sensible range - alternatively use GetIndividualFlavor() but that has an even more undefined range
	iFlavorExpansion = min(max(0, iFlavorExpansion), 12);
	//todo: take into account previously settled cities?
	int iGoodEnoughToBeWorthOurTime = (m_iReferenceFoundValue * (100 - 2 * iFlavorExpansion)) / 100;

	// first pass: precalculate found values
	CvSiteEvaluatorForSettler* pCalc = GC.getGame().GetSettlerSiteEvaluator();
	for (int iI = 0; iI < GC.getMap().numPlots(); iI++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iI);
		if (!pPlot->isRevealed(getTeam()))
			continue;

		int iValue = pCalc->PlotFoundValue(pPlot, this, ignorePlots);
		if (iValue > iGoodEnoughToBeWorthOurTime)
			m_viPlotFoundValues[iI] = iValue;
	}

	std::map<int,int> minDistancePerArea;
	std::map<int,int> countPerArea;

	// second pass: non-maxima suppression and aggregation
	for (int iI = 0; iI < GC.getMap().numPlots(); iI++)
	{
		CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iI);
		int iRefValue = m_viPlotFoundValues[iI];

		if (iRefValue < iGoodEnoughToBeWorthOurTime)
			continue;

		for (int iCount = RING0_PLOTS; iCount<RING3_PLOTS; iCount++)
		{
			CvPlot* pLoopPlot = iterateRingPlots(pPlot,iCount);
			if (pLoopPlot == NULL)
				continue;

			if (m_viPlotFoundValues[pLoopPlot->GetPlotIndex()] > iRefValue)
			{
				//this is not a local maximum
				pPlot = NULL;
				break;
			}
		}

		if (pPlot)
		{
			CvArea* pLoopArea = GC.getMap().getArea(pPlot->getArea());
			if (pLoopArea && !pLoopArea->isWater() && (pLoopArea->getNumTiles() > 0))
			{
				//one supercity counts more than two mediocre ones
				int iAddValue = (int)pow((float)iRefValue-iGoodEnoughToBeWorthOurTime,1.5f);
				int newValue = pLoopArea->getTotalFoundValue() + iAddValue;
				pLoopArea->setTotalFoundValue(newValue);
				
				//track the distance from our existing cities
				int iCityDistance = GetCityDistanceInEstimatedTurns(pPlot);
				if (minDistancePerArea.find(pLoopArea->GetID())==minDistancePerArea.end())
					minDistancePerArea[pLoopArea->GetID()] = iCityDistance;
				else if (iCityDistance < minDistancePerArea[pLoopArea->GetID()])
					minDistancePerArea[pLoopArea->GetID()] = iCityDistance;

				//track the number of cities we could found there
				if (countPerArea.find(pLoopArea->GetID())==countPerArea.end())
					countPerArea[pLoopArea->GetID()] = 1;
				else
					countPerArea[pLoopArea->GetID()]++;
			}
		}
	}

	//try to make it so that we settle close areas first and try to correct the bias towards large areas
	for (CvArea* pLoopArea = GC.getMap().firstArea(&iLoop); pLoopArea != NULL; pLoopArea = GC.getMap().nextArea(&iLoop))
	{
		if (pLoopArea->getTotalFoundValue()>0)
		{
			//take care with overflow here
			float fDistScale = 0.5f + MapToPercent( minDistancePerArea[pLoopArea->GetID()],30,10 )/200.f;
			float fCountScale = 1/sqrt( (float)countPerArea[pLoopArea->GetID()] );

			pLoopArea->setTotalFoundValue( int(pLoopArea->getTotalFoundValue() * fDistScale) );
			pLoopArea->setTotalFoundValue( int(pLoopArea->getTotalFoundValue() * fCountScale) );
		}
	}

	m_iPlotFoundValuesUpdateTurn = GC.getGame().getGameTurn();
}

int CvPlayer::getPlotFoundValue(int iX, int iY)
{
	//lazy update
	updatePlotFoundValues();

	size_t iIndex = (size_t)GC.getMap().plotNum(iX,iY);

	if (iIndex<m_viPlotFoundValues.size())
		return m_viPlotFoundValues[iIndex];
	else
		return 0;
}

void CvPlayer::setPlotFoundValue(int iX, int iY, int iValue)
{
	//if setting the values manually, make sure the size is right
	if (m_viPlotFoundValues.size() != GC.getMap().numPlots())
		m_viPlotFoundValues.resize(GC.getMap().numPlots(), -1);

	size_t iIndex = (size_t)GC.getMap().plotNum(iX, iY);
	if (iIndex<m_viPlotFoundValues.size())
		m_viPlotFoundValues[iIndex] = iValue;

	//prevent lazy update from overwriting this
	m_iPlotFoundValuesUpdateTurn = GC.getGame().getGameTurn();
}

int CvPlayer::GetAvgUnitExp100() const
{
	return m_iAvgUnitExp100;
}
