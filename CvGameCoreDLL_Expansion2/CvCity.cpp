/*	-------------------------------------------------------------------------------------------------------
	Â© 1991-2012 Take-Two Interactive Software and its subsidiaries.  Developed by Firaxis Games.
	Sid Meier's Civilization V, Civ, Civilization, 2K Games, Firaxis Games, Take-Two Interactive Software
	and their respective logos are all trademarks of Take-Two interactive Software, Inc.
	All other marks and trademarks are the property of their respective owners.
	All rights reserved.
	------------------------------------------------------------------------------------------------------- */

#include "CvGameCoreDLLPCH.h"
#include "CvGlobals.h"
#include "CvCity.h"
#include "CvArea.h"
#include "CvMap.h"
#include "CvPlot.h"
#include "CvTeam.h"
#include "CvGameCoreUtils.h"
#include "CvInternalGameCoreUtils.h"
#include "CvPlayerAI.h"
#include "CvUnit.h"
#include "CvInfos.h"
#include "CvRandom.h"
#include "CvImprovementClasses.h"
#include "CvCitySpecializationAI.h"
#include "CvEconomicAI.h"
#include "CvMilitaryAI.h"
#include "CvNotifications.h"
#include "CvUnitCombat.h"
#include "CvTypes.h"

// interfaces used
#include "CvEnumSerialization.h"
#include "CvDiplomacyAI.h"
#include "CvWonderProductionAI.h"

#include "CvDllCity.h"
#include "CvDllCombatInfo.h"
#include "CvDllPlot.h"
#include "CvDllUnit.h"
#include "CvGameQueries.h"

#include "CvInfosSerializationHelper.h"
#include "cvStopWatch.h"
#include "CvCityManager.h"
#if defined(MOD_BALANCE_CORE)
#include "CvBarbarians.h"
#endif

#include "CvDllNetMessageExt.h"
// include after all other headers
#include "LintFree.h"

OBJECT_VALIDATE_DEFINITION(CvCity)

int g_iCityToTrace = 0;

//	--------------------------------------------------------------------------------
namespace FSerialization
{

	//is it wise to store pointers here?
	//anyway vector seems better than set because of the defined ordering
	std::vector<CvCity*> citiesToCheck;

	void SyncCities()
	{
		if (GC.getGame().isNetworkMultiPlayer())
		{
			PlayerTypes authoritativePlayer = GC.getGame().getActivePlayer();

			std::vector<CvCity*>::const_iterator i;
			for (i = citiesToCheck.begin(); i != citiesToCheck.end(); ++i)
			{
				CvCity* city = *i;

				if (city)
				{
					const CvPlayer& player = GET_PLAYER(city->getOwner());
					if (city->getOwner() == authoritativePlayer || (gDLL->IsHost() && !player.isHuman() && player.isAlive()))
					{
						CvSyncArchive<CvCity>& archive = city->getSyncArchive();
						archive.collectDeltas();
						if (archive.hasDeltas())
						{
							FMemoryStream memoryStream;
							std::vector<std::pair<std::string, std::string> > callStacks;
							archive.saveDelta(memoryStream, callStacks);
							gDLL->sendCitySyncCheck(city->getOwner(), city->GetID(), memoryStream, callStacks);
						}
					}
				}
			}
		}
	}

	//	--------------------------------------------------------------------------------
	// clears ALL deltas for ALL units
	void ClearCityDeltas()
	{
		std::vector<CvCity*>::iterator i;
		for (i = citiesToCheck.begin(); i != citiesToCheck.end(); ++i)
		{
			CvCity* city = *i;

			if (city)
			{
				FAutoArchive& archive = city->getSyncArchive();
				archive.clearDelta();
			}
		}
	}
}

//helper function for managing extra yields
template <typename T>
bool ModifierUpdateInsertRemove(vector<pair<T, int>>& container, T key, int value, bool modifyExisting)
{
	for (typename vector<pair<T, int>>::iterator it = container.begin(); it != container.end(); ++it)
	{
		if (it->first == key)
		{
			if (modifyExisting && value != 0)
			{
				it->second += value;
				if (it->second == 0)
					container.erase(it);
				return true; //update was made
			}

			if (!modifyExisting && value != it->second)
			{
				it->second = value;
				if (it->second == 0)
					container.erase(it);
				return true; //update was made
			}

			return false; //no change
		}
	}

	//if we're here we don't have an entry yet
	if (value != 0)
	{
		container.push_back(make_pair(key, value));
		return true; //update was made
	}

	return false;
}

template <typename T>
int ModifierLookup(const vector<pair<T, int>>& container, T key)
{
	for (typename vector<pair<T, int>>::const_iterator it = container.begin(); it != container.end(); ++it)
		if (it->first == key)
			return it->second;

	return 0;
}

//	--------------------------------------------------------------------------------
// Public Functions...
CvCity::CvCity() :
	m_syncArchive()
	, m_eOwner(NO_PLAYER)
	, m_iX()
	, m_iY()
	, m_iID()
	, m_iRallyX()
	, m_iRallyY()
	, m_iGameTurnFounded()
	, m_iGameTurnAcquired()
	, m_iGameTurnLastExpanded()
#if defined(MOD_BALANCE_CORE)
	, m_iAdditionalFood()
	, m_iCityBuildingBombardRange()
	, m_iCityIndirectFire()
	, m_iCityBuildingRangeStrikeModifier()
	, m_iGarrisonRangedAttackModifier()
#endif
	, m_iPopulation()
#if defined(MOD_GLOBAL_CITY_AUTOMATON_WORKERS)
	, m_iAutomatons(0)
#endif
	, m_iHighestPopulation()
	, m_iExtraHitPoints()
	, m_iBaseGreatPeopleRate()
	, m_iGreatPeopleRateModifier()
	, m_iGPRateModifierPerMarriage()
	, m_iGPRateModifierPerLocalTheme()
	, m_iGPPOnCitizenBirth()
	, m_iJONSCultureStored()
	, m_iJONSCultureLevel()
	, m_iJONSCulturePerTurnFromPolicies()
	, m_iJONSCulturePerTurnFromSpecialists()
	, m_iaAddedYieldPerTurnFromTraits()
	, m_iFaithPerTurnFromPolicies()
	, m_iCultureRateModifier()
	, m_iNumWorldWonders()
	, m_iNumTeamWonders()
	, m_iNumNationalWonders()
	, m_iWonderProductionModifier()
	, m_iCapturePlunderModifier()
	, m_iDiplomatInfluenceBoost()
	, m_iBorderGrowthRateIncrease()
	, m_iPlotCultureCostModifier()
	, m_iPlotBuyCostModifier()
	, m_iMaintenance()
	, m_iHealRate()
	, m_iNoOccupiedUnhappinessCount()
	, m_iFoodBonusPerCityMajorityFollower()
#if defined(HH_MOD_BUILDINGS_FRUITLESS_PILLAGE)
	, m_iLocalGainlessPillageCount()
#endif
	, m_iFood()
	, m_iMaxFoodKeptPercent()
	, m_iOverflowProduction()
	, m_iFeatureProduction()
	, m_iMilitaryProductionModifier()
	, m_iSpaceProductionModifier()
	, m_iFreeExperience()
	, m_iMaxAirUnits()
	, m_iNukeModifier()
	, m_iCitySizeBoost()
	, m_iSpecialistFreeExperience()
	, m_iStrengthValue()
	, m_iStrengthValueRanged()
	, m_iDamage()
	, m_iThreatValue()
	, m_hGarrison()
	, m_iResourceDemanded()
	, m_iResourceDemandedCounter()
	, m_iWeLoveTheKingDayCounter()
	, m_iLastTurnGarrisonAssigned()
	, m_iThingsProduced()
	, m_iDemandResourceCounter()
	, m_iResistanceTurns()
	, m_iRazingTurns()
	, m_iLowestRazingPop()
	, m_iCountExtraLuxuries()
	, m_iCheapestPlotInfluenceDistance()
	, m_iEspionageModifier()
	, m_iSpySecurityModifier()
	, m_iSpySecurityModifierPerXPop()
	, m_iTradeRouteRecipientBonus()
	, m_iTradeRouteSeaGoldBonus()
	, m_iTradeRouteLandGoldBonus()
	, m_iTradeRouteTargetBonus()
	, m_iNumTradeRouteBonus()
	, m_iCityConnectionTradeRouteGoldModifier()
	, m_unitBeingBuiltForOperation()
	, m_bNeverLost()
	, m_bDrafted()
	, m_bProductionAutomated()
	, m_bLayoutDirty()
	, m_bMadeAttack()
	, m_bOccupied()
	, m_bPuppet()
	, m_bIgnoreCityForHappiness()
	, m_bIndustrialRouteToCapital()
	, m_iTerrainImprovementNeed()
	, m_ePreviousOwner()
	, m_eOriginalOwner()
	, m_ePlayersReligion()
	, m_aiSeaPlotYield()
	, m_aiRiverPlotYield()
	, m_aiLakePlotYield()
	, m_aiSeaResourceYield()
	, m_aiBaseYieldRateFromTerrain()
	, m_aiBaseYieldRateFromBuildings()
	, m_aiBaseYieldRateFromSpecialists()
	, m_aiBaseYieldRateFromMisc()
	, m_aiBaseYieldRateFromReligion()
	, m_aiYieldRateModifier()
	, m_aiYieldPerPop()
#if defined(MOD_BALANCE_CORE)
	, m_aiYieldPerPopInEmpire()
	, m_miTechEnhancedYields()
	, m_miGreatPersonPointFromConstruction()
	, m_aiDamagePermyriad()
#endif
	, m_aiYieldPerReligion()
	, m_aiPowerYieldRateModifier()
	, m_aiResourceYieldRateModifier()
	, m_aiExtraSpecialistYield()
	, m_aiProductionToYieldModifier()
	, m_aiDomainFreeExperience()
	, m_aiDomainProductionModifier()
#if defined(MOD_BALANCE_CORE_EVENTS)
	, m_aiGreatWorkYieldChange()
	, m_aiEconomicValue()
	, m_miUnitClassTrainingAllowed()
	, m_miInstantYieldsTotal()
	, m_aiEventChoiceDuration()
	, m_aiEventIncrement()
	, m_abEventActive()
	, m_abEventChoiceActive()
	, m_abEventChoiceFired()
	, m_abEventFired()
	, m_aiEventCooldown()
	, m_aiEventCityYield()
	, m_aiEventCityYieldModifier()
	, m_iEventHappiness()
	, m_iCityEventCooldown()
	, m_iHappinessDelta()
	, m_iPillagedPlots()
	, m_iGrowthFromTourism()
	, m_iGrowthEvent()
	, m_iEventGPPFromSpecialists()
	, m_vEventGPPFromSpecialistsExpiryTurns()
	, m_iBuildingClassHappiness()
	, m_iReligionHappiness()
#endif
	, m_abEverLiberated()
	, m_strScriptData()
	, m_paiNoResource()
	, m_paiFreeResource()
	, m_paiNumResourcesLocal()
	, m_paiNumUnimprovedResourcesLocal()
	, m_paiProjectProduction()
	, m_paiUnitProduction()
	, m_paiUnitProductionTime()
	, m_paiUnitCombatFreeExperience()
	, m_paiUnitCombatProductionModifier()
	, m_paiFreePromotionCount()
	, m_iBaseHappinessFromBuildings()
	, m_iUnmoddedHappinessFromBuildings()
	, m_bRouteToCapitalConnectedLastTurn()
	, m_bRouteToCapitalConnectedThisTurn()
	, m_strName()
	, m_orderQueue()
	, m_pCityBuildings(FNEW(CvCityBuildings, c_eCiv5GameplayDLL, 0))
	, m_pCityStrategyAI(FNEW(CvCityStrategyAI, c_eCiv5GameplayDLL, 0))
	, m_pCityCitizens(FNEW(CvCityCitizens, c_eCiv5GameplayDLL, 0))
	, m_pCityReligions(FNEW(CvCityReligions, c_eCiv5GameplayDLL, 0))
	, m_pEmphases(FNEW(CvCityEmphases, c_eCiv5GameplayDLL, 0))
	, m_pCityEspionage(FNEW(CvCityEspionage, c_eCiv5GameplayDLL, 0))
	, m_pCityCulture(FNEW(CvCityCulture, c_eCiv5GameplayDLL, 0))
	, m_iPopulationRank()
	, m_bPopulationRankValid()
	, m_aiBaseYieldRank()
	, m_abBaseYieldRankValid()
	, m_aiYieldRank()
	, m_abYieldRankValid()
	, m_bOwedCultureBuilding()
#if defined(MOD_BUILDINGS_CITY_WORKING)
	, m_iCityWorkingChange()
	, m_iCitySupplyModifier()
	, m_iCitySupplyFlat()
	, m_iDamageReductionFlat()
	, m_bAllowsProductionTradeRoutes()
	, m_bAllowsFoodTradeRoutes()
	, m_bAllowPuppetPurchase()
	, m_iHappinessFromEmpire()
	, m_iUnhappinessFromEmpire()
	, m_iCachedBasicNeedsMedian()
	, m_iCachedGoldMedian()
	, m_iCachedScienceMedian()
	, m_iCachedCultureMedian()
	, m_iCachedTechNeedModifier()
	, m_iCachedEmpireSizeModifier()
	, m_iYieldMediansCachedTurn()
#endif
#if defined(MOD_BUILDINGS_CITY_AUTOMATON_WORKERS)
	, m_iCityAutomatonWorkersChange()
#endif
	, m_iNumPreviousSpyMissions()
	, m_fDefensePerWonder()
#if defined(MOD_RELIGION_CONVERSION_MODIFIERS)
	, m_iConversionModifier()
#endif
	, m_aiBaseYieldRateFromLeague()
	, m_siPlots()
	, m_iTotalScienceyAid()
	, m_iTotalArtsyAid()
	, m_iEmpireSizeModifierReduction()
	, m_iDistressFlatReduction()
	, m_iPovertyFlatReduction()
	, m_iIlliteracyFlatReduction()
	, m_iBoredomFlatReduction()
	, m_iReligiousUnrestFlatReduction()
	, m_iBasicNeedsMedianModifier()
	, m_iGoldMedianModifier()
	, m_iScienceMedianModifier()
	, m_iCultureMedianModifier()
	, m_iReligiousUnrestModifier()
	, m_aiChangeGrowthExtraYield()
#if defined(MOD_BALANCE_CORE)
	, m_iNukeInterceptionChance()
	, m_iTradeRouteSeaDistanceModifier()
	, m_iTradeRouteLandDistanceModifier()
	, m_iTradePriorityLand()
	, m_iTradePrioritySea()
	, m_iUnitPurchaseCooldown()
	, m_iUnitPurchaseCooldownCivilian()
	, m_iUnitPurchaseCooldownMod()
	, m_iUnitPurchaseCooldownCivilianMod()
	, m_iUnitFaithPurchaseCooldown()
	, m_iUnitFaithPurchaseCooldownCivilian()
	, m_iBuildingPurchaseCooldown()
	, m_iReligiousTradeModifier()
	, m_iCityAirStrikeDefense()
	, m_iFreeBuildingTradeTargetCity()
	, m_iBaseTourism()
	, m_iBaseTourismBeforeModifiers()
	, m_aiYieldFromVictory()
	, m_aiYieldFromVictoryGlobal()
	, m_aiYieldFromVictoryGlobalEraScaling()
	, m_aiYieldFromVictoryGlobalInGoldenAge()
	, m_aiYieldFromVictoryGlobalInGoldenAgeEraScaling()
	, m_aiYieldFromPillage()
	, m_aiYieldFromPillageGlobal()
	, m_aiNumTimesAttackedThisTurn()
	, m_aiNumProjects()
	, m_aiYieldFromKnownPantheons()
	, m_aiYieldFromGoldenAgeStart()
	, m_aiYieldChangePerGoldenAge()
	, m_aiYieldChangePerGoldenAgeCap()
	, m_aiYieldFromPreviousGoldenAges()
	, m_aiGoldenAgeYieldMod()
	, m_aiYieldChangesPerLocalTheme()
	, m_aiYieldFromUnitGiftGlobal()
	, m_aiYieldFromWLTKD()
	, m_aiYieldFromConstruction()
	, m_aiYieldFromTech()
	, m_aiYieldFromUnitProduction()
	, m_aiYieldFromBirth()
	, m_aiYieldFromBirthEraScaling()
	, m_aiYieldFromBorderGrowth()
	, m_aiYieldFromPolicyUnlock()
	, m_aiYieldFromPurchase()
	, m_aiYieldFromPurchaseGlobal()
	, m_aiYieldFromFaithPurchase()
	, m_aiYieldFromUnitLevelUp()
	, m_aiYieldFromCombatExperienceTimes100()
	, m_aiYieldPerAlly()
	, m_aiYieldPerFriend()
	, m_aiYieldFromInternalTREnd()
	, m_aiYieldFromInternationalTREnd()
	, m_aiYieldFromInternalTR()
	, m_aiYieldFromProcessModifier()
	, m_aiYieldFromLongCount()
	, m_aiYieldFromGPBirthScaledWithWriterBulb()
	, m_aiYieldFromGPBirthScaledWithArtistBulb()
	, m_miYieldFromGPBirthScaledWithPerTurnYield()
	, m_aiSpecialistRateModifierFromBuildings()
	, m_aiNumTimesOwned()
	, m_aiStaticCityYield()
	, m_aiThemingYieldBonus()
	, m_aiYieldFromSpyAttack()
	, m_aiYieldFromSpyDefense()
	, m_aiYieldFromSpyIdentify()
	, m_aiYieldFromSpyDefenseOrID()
	, m_aiYieldFromSpyRigElection()
	, m_aiYieldChangesPerCityStrengthTimes100()
	, m_aiBaseYieldRateFromCSAlliance()
	, m_aiBaseYieldRateFromCSFriendship()
	, m_aiYieldFromMinors()
	, m_aiResourceQuantityPerXFranchises()
	, m_aiYieldChangeFromCorporationFranchises()
	, m_aiResourceQuantityFromPOP()
	, m_iLandTourismBonus()
	, m_iSeaTourismBonus()
	, m_iAlwaysHeal()
	, m_iResourceDiversityModifier()
	, m_iNoUnhappfromXSpecialists()
	, m_bNoWarmonger()
	, m_iNoStarvationNonSpecialist()
#endif
#if defined(MOD_BALANCE_CORE)
	, m_abIsBestForWonder()
	, m_abIsPurchased()
	, m_abTraded()
	, m_abIgnoredForExpansionBickering()
	, m_abPaidAdoptionBonus()
	, m_aiReligiousPressureModifier()
	, m_iExtraBuildingMaintenance()
	, m_paiNumTerrainWorked()
	, m_paiNumFeaturelessTerrainWorked()
	, m_paiNumFeatureWorked()
	, m_paiNumImprovementWorked()
#endif
#if defined(MOD_BALANCE_CORE_POLICIES)
	, m_paiBuildingClassCulture()
	, m_paiHurryModifier()
#endif
#if defined(MOD_BALANCE_CORE)
	, m_vClosestNeighbors()
#endif
	, m_yieldChanges(NUM_YIELD_TYPES)
	, m_eventYields(NUM_YIELD_TYPES)
	, m_ppiGreatPersonProgressFromConstruction()
#if defined(MOD_BALANCE_CORE)
	, m_abOwedChosenBuilding()
	, m_abBuildingInvestment()
	, m_aiBuildingCostInvestmentReduction()
	, m_abUnitInvestment()
	, m_aiUnitCostInvestmentReduction()
	, m_abBuildingConstructed()
	, m_iBorderObstacleCity()
	, m_iBorderObstacleWater()
	, m_iDeepWaterTileDamage()
	, m_iNumNearbyMountains()
	, m_iLocalUnhappinessMod()
#endif
	, m_iExperiencePerGoldenAge()
	, m_iExperiencePerGoldenAgeCap()
	, m_iExperienceFromPreviousGoldenAges()
	, m_bOwedFoodBuilding()
#if defined(MOD_CORE_PER_TURN_DAMAGE)
	, m_iDamageTakenThisTurn()
	, m_iDamageTakenLastTurn()
#endif
#if defined(MOD_BALANCE_CORE)
	, m_bIsColony()
	, m_iProvinceLevel()
	, m_iOrganizedCrime()
	, m_iResistanceCounter()
	, m_iPlagueCounter()
	, m_iPlagueTurns()
	, m_iSappedTurns()
	, m_iBuildingProductionBlockedTurns()
	, m_iNoTourismTurns()
	, m_iPlagueType()
	, m_iLoyaltyCounter()
	, m_iDisloyaltyCounter()
	, m_iLoyaltyStateType()
	, m_aiYieldModifierFromHappiness()
	, m_aiYieldModifierFromHealth()
	, m_aiYieldModifierFromCrime()
	, m_aiYieldModifierFromDevelopment()
	, m_aiYieldFromHappiness()
	, m_aiYieldFromHealth()
	, m_aiYieldFromCrime()
	, m_aiYieldFromDevelopment()
	, m_aiTempCaptureData()
	, m_abTempCaptureData()
	, m_bIsPendingCapture()
#endif
	, m_iVassalLevyEra()
{
	OBJECT_ALLOCATED
		FSerialization::citiesToCheck.push_back(this);

	reset(0, NO_PLAYER, 0, 0, true);

	if (GC.getGame().isNetworkMultiPlayer())
	{
		m_syncArchive.initSyncVars(*FNEW(CvSyncArchive<CvCity>::SyncVars(*this), c_eCiv5GameplayDLL, 0));
	}
}

//	--------------------------------------------------------------------------------
CvCity::~CvCity()
{
	CvCityManager::OnCityDestroyed(this);

	//really shouldn't happen that it's not present, but there was a crash here
	std::vector<CvCity*>::iterator it = std::find(FSerialization::citiesToCheck.begin(), FSerialization::citiesToCheck.end(), this);
	if (it != FSerialization::citiesToCheck.end())
		FSerialization::citiesToCheck.erase(it);

	uninit();

	delete m_pCityBuildings;
	delete m_pCityStrategyAI;
	delete m_pCityCitizens;
	delete m_pCityReligions;
	delete m_pEmphases;
	delete m_pCityEspionage;
	delete m_pCityCulture;

	OBJECT_DESTROYED
}


//	--------------------------------------------------------------------------------
void CvCity::init(int iID, PlayerTypes eOwner, int iX, int iY, bool bBumpUnits, bool bInitialFounding, ReligionTypes eInitialReligion, const char* szName, CvUnitEntry* pkSettlerUnitEntry)
{
	VALIDATE_OBJECT();
	//CvPlot* pAdjacentPlot;
	CvPlot* pPlot = GC.getMap().plot(iX, iY);
	int iI = 0;
	bool bFoundingCapital = bInitialFounding && GET_PLAYER(eOwner).GetOriginalCapitalX() == -1;

	//--------------------------------
	// Init saved data
	reset(iID, eOwner, pPlot->getX(), pPlot->getY());

	CvPlayerAI& owningPlayer = GET_PLAYER(getOwner());

	//--------------------------------
	// Init non-saved data

	//--------------------------------
	// Init other game data
	CvString strNewCityName = owningPlayer.getNewCityName();
	setName(strNewCityName.c_str());

	if (MOD_API_ACHIEVEMENTS && strcmp(strNewCityName.c_str(), "TXT_KEY_CITY_NAME_LLANFAIRPWLLGWYNGYLL") == 0)
	{
		gDLL->UnlockAchievement(ACHIEVEMENT_XP1_34);
	}

	if (bInitialFounding)
	{
		SetNumTimesOwned(eOwner, 1);
	}

	pPlot->SetPlayerThatDestroyedCityHere(NO_PLAYER);

	// Plot Ownership
	pPlot->setOwner(getOwner(), m_iID, bBumpUnits, true, true);

	// Clear the improvement before the city attaches itself to the plot, else the improvement does not
	// remove the resource allocation from the current owner.  This would result in double resource points because
	// the plot has already had setOwner called on it (above), giving the player the resource points.
	pPlot->setImprovementType(NO_IMPROVEMENT);

	//only after the owner is set!
	pPlot->setIsCity(true, m_iID, getWorkPlotDistance());

	pPlot->SetImprovementPillaged(false, false);
	pPlot->SetRoutePillaged(false, false);

	//clear the first ring
	int iRange = min(1, /*1*/ GD_INT_GET(CITY_STARTING_RINGS));
	for (int iDX = -iRange; iDX <= iRange; iDX++)
	{
		for (int iDY = -iRange; iDY <= iRange; iDY++)
		{
			CvPlot* pLoopPlot = plotXYWithRangeCheck(getX(), getY(), iDX, iDY, iRange);
			if (pLoopPlot != NULL)
				pLoopPlot->setOwner(getOwner(), m_iID, bBumpUnits);
		}
	}

	// this is a list of plot that are owned by the player
	owningPlayer.UpdatePlots();

	static BuildTypes eBuildRemoveForest = (BuildTypes)GC.getInfoTypeForString("BUILD_REMOVE_FOREST");
	static BuildTypes eBuildRemoveJungle = (BuildTypes)GC.getInfoTypeForString("BUILD_REMOVE_JUNGLE");
	bool bClearedForest = false;
	bool bClearedJungle = false;
	FeatureTypes eFeature = pPlot->getFeatureType();

	//SCRIPT call ' bool citiesDestroyFeatures(iX, iY);'
	if (pPlot->getFeatureType() != NO_FEATURE)
	{
		// Only for major civs building on a forest
		if (MOD_GLOBAL_CITY_FOREST_BONUS && eBuildRemoveForest != -1 && !owningPlayer.isMinorCiv() && (eFeature == FEATURE_FOREST))
		{
			// Don't do this for the AI capitals - it's just too much of an initial boost!
			TechTypes iRequiredTech = (TechTypes)gCustomMods.getOption("GLOBAL_CITY_FOREST_BONUS_TECH", -1);
			bClearedForest = (iRequiredTech == -1 || GET_TEAM(owningPlayer.getTeam()).GetTeamTechs()->HasTech(iRequiredTech));
		}
		// OR only for major civs building on a jungle
		else if (MOD_GLOBAL_CITY_FOREST_BONUS && (eBuildRemoveJungle != -1) && (!owningPlayer.isMinorCiv()) && (eFeature == FEATURE_JUNGLE))
		{
			TechTypes iRequiredTech = (TechTypes)gCustomMods.getOption("GLOBAL_CITY_FOREST_BONUS_TECH", -1);
			bClearedJungle = (iRequiredTech == -1 || GET_TEAM(owningPlayer.getTeam()).GetTeamTechs()->HasTech(iRequiredTech));
		}

		pPlot->setFeatureType(NO_FEATURE);
	}

	// wipe out dig sites
	pPlot->ClearArchaeologicalRecord();

	setupGraphical();

	pPlot->updateCityRoute();

	//force recalculation of trade routes
	GC.getGame().GetGameTrade()->InvalidateTradePathCache();

	for (iI = 0; iI < MAX_TEAMS; iI++)
	{
		if (GET_TEAM((TeamTypes)iI).isAlive())
		{
			if (pPlot->isVisible(((TeamTypes)iI)))
			{
				setRevealed(((TeamTypes)iI), true);
			}
		}
	}

	for (iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);
		if (owningPlayer.isBuildingFree(eBuilding))
		{
			SetNumFreeBuilding(eBuilding, 1);
		}
	}

	// Free Buildings
	const CvCivilizationInfo& thisCiv = getCivilizationInfo();
	for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
	{
		const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iI);
		BuildingTypes eBuilding = static_cast<BuildingTypes>(thisCiv.getCivilizationBuildings(iI));

		if (eBuilding == NO_BUILDING)
			continue;

		if (owningPlayer.GetNumCitiesFreeChosenBuilding(eBuildingClass) > 0
			|| owningPlayer.IsFreeChosenBuildingNewCity(eBuildingClass)
			|| owningPlayer.IsFreeBuildingAllCity(eBuildingClass)
			|| (owningPlayer.IsFreeBuildingNewFoundCity(eBuildingClass) && bInitialFounding))
		{
			if (SetNumFreeBuilding(eBuilding, 1) && owningPlayer.GetNumCitiesFreeChosenBuilding(eBuildingClass) > 0)
			{
				owningPlayer.ChangeNumCitiesFreeChosenBuilding(eBuildingClass, -1);
			}
		}
	}

	if (bInitialFounding)
	{
		for (int iUnitClassLoop = 0; iUnitClassLoop < GC.getNumUnitClassInfos(); iUnitClassLoop++)
		{
			const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iUnitClassLoop);
			if (GET_PLAYER(getOwner()).IsFreeUnitNewFoundCity(eUnitClass))
			{
				UnitTypes eUnit = GET_PLAYER(getOwner()).GetSpecificUnitType(eUnitClass);
				if (eUnit != NO_UNIT)
				{
					CvUnit* pFreeUnit = owningPlayer.initUnit(eUnit, getX(), getY());
					bool bJumpSuccess = pFreeUnit->jumpToNearestValidPlot();
					if (bJumpSuccess)
					{
						addProductionExperience(pFreeUnit);
						if (getFirstUnitOrder(eUnit) == 0)
						{
							clearOrderQueue();
							chooseProduction();
						}
					}
					else
					{
						pFreeUnit->kill(false);
					}
				}
			}
		}
	}

	//don't need to update landmass stats, that is implied by area changes
	GC.getMap().getAreaById(pPlot->getArea())->changeCitiesPerPlayer(getOwner(), 1);
	std::vector<int> areas = pPlot->getAllAdjacentAreas();
	for (std::vector<int>::iterator it = areas.begin(); it != areas.end(); ++it)
	{
		CvArea* pkArea = GC.getMap().getAreaById(*it);
		if (pkArea->isWater())
			pkArea->changeCitiesPerPlayer(getOwner(), 1);
	}

	GET_TEAM(getTeam()).changeNumCities(1);

	GC.getGame().changeNumCities(1);
	// Tell the city manager now as well.
	CvCityManager::OnCityCreated(this);

	int iGameTurn = GC.getGame().getGameTurn();
	setGameTurnFounded(iGameTurn);
	setGameTurnAcquired(iGameTurn);
	setGameTurnLastExpanded(iGameTurn);

	GetCityCitizens()->DoFoundCity();

	// Default starting population
	changePopulation(/*1*/ GD_INT_GET(INITIAL_CITY_POPULATION) + GC.getGame().getStartEraInfo().getFreePopulation(), true, true);
	// Free population from things (e.g. Policies)
	changePopulation(GET_PLAYER(getOwner()).GetNewCityExtraPopulation(), true, true);

	// We do this here as changePopulation() sends a game event we may have caught to do funky renaming things
	if (szName) 
	{
		setName(szName);
	}

	// Free food from things (e.g. Policies)
	int iFreeFood = growthThreshold() * GET_PLAYER(getOwner()).GetFreeFoodBox();
	changeFoodTimes100(iFreeFood);

	if (bInitialFounding)
	{
		owningPlayer.ChangeNumCitiesFounded(1);

		// Free resources under city?
		for (int i = 0; i < GC.getNumResourceInfos(); i++)
		{
			ResourceTypes eResource = (ResourceTypes)i;
			FreeResourceXCities freeResource = owningPlayer.GetPlayerTraits()->GetFreeResourceXCities(eResource);

			if (freeResource.m_iResourceQuantity > 0)
			{
				if (owningPlayer.GetNumCitiesFounded() <= freeResource.m_iNumCities)
				{
					plot()->setResourceType(NO_RESOURCE, 0);
					plot()->setResourceType(eResource, freeResource.m_iResourceQuantity);
				}
			}
		}

		if (MOD_BALANCE_CORE_LUXURIES_TRAIT && !owningPlayer.isMinorCiv() && (owningPlayer.GetPlayerTraits()->GetUniqueLuxuryQuantity() > 0))
		{
			owningPlayer.GetPlayerTraits()->AddUniqueLuxuriesAround(this, owningPlayer.GetPlayerTraits()->GetUniqueLuxuryQuantity());
		}
		else
		{
			owningPlayer.GetPlayerTraits()->AddUniqueLuxuries(this);
		}

		if (owningPlayer.isMinorCiv())
		{
			owningPlayer.GetMinorCivAI()->DoAddStartingResources(plot());
		}
	}

	// make sure that all the team members get the city connection update
	for (int i = 0; i < MAX_PLAYERS; i++)
	{
		PlayerTypes ePlayer = (PlayerTypes)i;
		if (GET_PLAYER(ePlayer).getTeam() == owningPlayer.getTeam())
		{
			GET_PLAYER(ePlayer).GetCityConnections()->SetDirty();
		}
	}
	for (int iFeatureLoop = 0; iFeatureLoop < GC.getNumFeatureInfos(); iFeatureLoop++)
	{
		FeatureTypes eFeature2 = (FeatureTypes)iFeatureLoop;
		if (eFeature2 != NO_FEATURE)
		{
			GET_PLAYER(getOwner()).UpdateCityFeatureCount(eFeature2);
		}
	}

	// Policy changes
	for (int iPoliciesLoop = 0; iPoliciesLoop < GC.getNumPolicyInfos(); iPoliciesLoop++)
	{
		PolicyTypes ePolicy = (PolicyTypes)iPoliciesLoop;

		if (owningPlayer.GetPlayerPolicies()->HasPolicy(ePolicy) && !owningPlayer.GetPlayerPolicies()->IsPolicyBlocked(ePolicy))
		{
			// Free Culture-per-turn in every City from Policies
			ChangeJONSCulturePerTurnFromPolicies(GC.getPolicyInfo(ePolicy)->GetCulturePerCity());
		}
	}

	if (MOD_BALANCE_CORE_EVENTS && bInitialFounding)
		CheckActivePlayerEvents();

	// Update Proximity between this Player and all others
	owningPlayer.DoUpdateProximityToPlayers();

	// Free Buildings in the first City
	if (GC.getGame().isFinalInitialized())
	{
		if (owningPlayer.getNumCities() == 1)
		{
			int iCapitalBuilding = thisCiv.getCivilizationBuildings(GD_INT_GET(CAPITAL_BUILDINGCLASS));

			for (iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
			{
				if (thisCiv.isCivilizationFreeBuildingClass(iI))
				{
					BuildingTypes eBuilding = static_cast<BuildingTypes>(thisCiv.getCivilizationBuildings(iI));
					if (eBuilding == NO_BUILDING)
						continue;

					GetCityBuildings()->SetNumRealBuilding(eBuilding, 1, true);

					if (iI == iCapitalBuilding && MOD_EVENTS_CITY_CAPITAL)
					{
						GAMEEVENTINVOKE_HOOK(GAMEEVENT_CapitalChanged, getOwner(), GetID(), -1);
					}
				}
			}

			// Free building in Capital from Trait?
			BuildingTypes eBuilding = owningPlayer.GetPlayerTraits()->GetFreeCapitalBuilding();
			if (eBuilding != NO_BUILDING)
			{
				if (owningPlayer.GetPlayerTraits()->GetCapitalFreeBuildingPrereqTech() == NO_TECH)
				{
					SetNumFreeBuilding(eBuilding, 1);
				}
			}

			if (!isHuman())
			{
				changeOverflowProduction(/*0*/ GD_INT_GET(INITIAL_AI_CITY_PRODUCTION));
			}
			else if (MOD_API_ACHIEVEMENTS)
			{
				CvAchievementUnlocker::UnlockFromDatabase();
			}
		}
	}

	// How long before this City picks a Resource to demand?
	DoSeedResourceDemandedCountdown();

	// Garrisoned?
	SetGarrison(plot()->getBestGarrison(getOwner()));

	// Update Unit Maintenance for the player
	CvPlayer& kPlayer = GET_PLAYER(getOwner());
	kPlayer.UpdateUnitProductionMaintenanceMod();

	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		UpdateYieldPerXUnimprovedFeature(((YieldTypes)iI));
	}
	int iRange3 = 3;
	int iMountain = 0;
	for (int iDX = -iRange3; iDX <= iRange3; iDX++)
	{
		for (int iDY = -iRange3; iDY <= iRange3; iDY++)
		{
			CvPlot* pLoopPlot = plotXYWithRangeCheck(getX(), getY(), iDX, iDY, iRange3);
			if (pLoopPlot != NULL)
			{
				if (pLoopPlot->isMountain() && !pLoopPlot->IsNaturalWonder())
				{
					iMountain++;
				}
			}
		}
	}
	SetNearbyMountains(iMountain);

	// Spread a pantheon here if one is active
	CvPlayerReligions* pReligions = kPlayer.GetReligions();
	CvCity* pCapital = GET_PLAYER(getOwner()).getCapitalCity();
	if (GET_PLAYER(getOwner()).GetPlayerTraits()->IsNewCitiesStartWithCapitalReligion() && pCapital && pCapital->GetCityReligions()->GetMajorityReligion())
	{
		const CvReligion* pCapitalReligion = pCapital->GetCityReligions()->GetMajorityReligion();
		int iInitialPressure = /*1000*/ GD_INT_GET(RELIGION_ATHEISM_PRESSURE_PER_POP) * getPopulation() * 2;
		GetCityReligions()->AddReligiousPressure(FOLLOWER_CHANGE_POP_CHANGE, pCapitalReligion->m_eReligion, iInitialPressure);
		GetCityReligions()->RecomputeFollowers(FOLLOWER_CHANGE_POP_CHANGE);
	}
	else if (pReligions->HasCreatedPantheon() && !pReligions->OwnsReligion())
	{
		int iInitialPressure = /*1000*/ GD_INT_GET(RELIGION_ATHEISM_PRESSURE_PER_POP) * getPopulation() * 2;
		GetCityReligions()->AddReligiousPressure(FOLLOWER_CHANGE_POP_CHANGE, RELIGION_PANTHEON, iInitialPressure);
		GetCityReligions()->RecomputeFollowers(FOLLOWER_CHANGE_POP_CHANGE);
	}

	if (bInitialFounding) 
	{
		if (eInitialReligion != NO_RELIGION) 
		{
			// Spread an initial religion here if one was given
			GetCityReligions()->AdoptReligionFully(eInitialReligion);
		}

		else if (MOD_RELIGION_LOCAL_RELIGIONS) 
		{
			// Spread a local religion here if one is active
			if (pReligions->OwnsReligion() && GC.getReligionInfo(pReligions->GetOwnedReligion())->IsLocalReligion()) 
			{
				GetCityReligions()->AdoptReligionFully(pReligions->GetOwnedReligion());
			}
		}
	}

	// A new City might change our victory progress
	GET_TEAM(getTeam()).DoTestSmallAwards();

	DLLUI->setDirty(NationalBorders_DIRTY_BIT, true);

	if (bClearedForest || bClearedJungle)
	{
		int iProduction = 0;

		// Base value
		if (GET_PLAYER(getOwner()).GetAllFeatureProduction() > 0)
		{
			iProduction = GET_PLAYER(getOwner()).GetAllFeatureProduction();
		}
		else if (bClearedForest)
		{
			iProduction = GC.getBuildInfo(eBuildRemoveForest)->getFeatureProduction(FEATURE_FOREST);
		}
		else if (bClearedJungle)
		{
			iProduction = GC.getBuildInfo(eBuildRemoveJungle)->getFeatureProduction(FEATURE_JUNGLE);
		}

		if (MOD_BALANCE_CORE_SETTLER_ADVANCED)
		{
			iProduction *= std::max(0, (GET_PLAYER(getOwner()).getFeatureProductionModifier()));
			iProduction /= 100;
		}
		else
		{
			iProduction *= std::max(0, (GET_PLAYER(getOwner()).getFeatureProductionModifier() + 100));
			iProduction /= 100;
		}

		iProduction *= GC.getGame().getGameSpeedInfo().getFeatureProductionPercent();
		iProduction /= 100;

		if (iProduction > 0)
		{
			// Make the production higher than a "ring-1 chop"
			iProduction *= gCustomMods.getOption("GLOBAL_CITY_FOREST_BONUS_PERCENT", 125);
			iProduction /= 100;

			changeFeatureProduction(iProduction);
			if (bClearedForest)
			{
				//CUSTOMLOG("Founding of %s on a forest created %d initial production", getName().GetCString(), iProduction);
			}
			else if (bClearedJungle)
			{
				//CUSTOMLOG("Founding of %s on a jungle created %d initial production", getName().GetCString(), iProduction);
			}

			if (getOwner() == GC.getGame().getActivePlayer())
			{
				CvString strBuffer = GetLocalizedText("TXT_KEY_MISC_CLEARING_FEATURE_RESOURCE", GC.getFeatureInfo(eFeature)->GetTextKey(), iProduction, getNameKey());
				GC.GetEngineUserInterface()->AddCityMessage(0, GetIDInfo(), getOwner(), false, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), strBuffer);
			}
		}
	}

	// Stuff for Pioneers and Colonists
	if (MOD_BALANCE_CORE_SETTLER_ADVANCED && bInitialFounding && pkSettlerUnitEntry != NULL)
	{
		if (pkSettlerUnitEntry->GetNumColonyFound() > 0)
		{
			kPlayer.cityBoost(getX(), getY(), pkSettlerUnitEntry, /*3*/ GD_INT_GET(PIONEER_EXTRA_PLOTS), /*3*/ GD_INT_GET(PIONEER_POPULATION_CHANGE), 1);
			DoCreatePuppet();
		}

		if (pkSettlerUnitEntry->IsFoundMid())
		{
			kPlayer.cityBoost(getX(), getY(), pkSettlerUnitEntry, /*3*/ GD_INT_GET(PIONEER_EXTRA_PLOTS), /*3*/ GD_INT_GET(PIONEER_POPULATION_CHANGE), /*25*/ GD_INT_GET(PIONEER_FOOD_PERCENT));
		}
		if (pkSettlerUnitEntry->IsFoundLate())
		{
			kPlayer.cityBoost(getX(), getY(), pkSettlerUnitEntry, /*5*/ GD_INT_GET(COLONIST_EXTRA_PLOTS), /*5*/ GD_INT_GET(COLONIST_POPULATION_CHANGE), /*50*/ GD_INT_GET(COLONIST_FOOD_PERCENT));
		}
	}

	if (bInitialFounding)
	{
		owningPlayer.doInstantYield(INSTANT_YIELD_TYPE_FOUND, false, NO_GREATPERSON, NO_BUILDING, 0, true, NO_PLAYER, NULL, false, this);

		if (owningPlayer.GetPlayerTraits()->IsExpansionWLTKD())
		{
			int iWLTKD = /*6*/ GD_INT_GET(CITY_RESOURCE_WLTKD_TURNS) / 3;
			iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iWLTKD /= 100;

			if (iWLTKD > 0)
			{
				CvCity* pLoopCity = NULL;
				int iCityLoop = 0;

				// Loop through owner's cities.
				for (pLoopCity = owningPlayer.firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = owningPlayer.nextCity(&iCityLoop))
				{
					if (pLoopCity != NULL)
					{
						pLoopCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
					}
				}
				CvNotifications* pNotifications = owningPlayer.GetNotifications();
				if (pNotifications)
				{
					Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UA_CITY_SETTLING");
					strText << iWLTKD << /*25*/ GD_INT_GET(WLTKD_GROWTH_MULTIPLIER);
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UA_CITY_SETTLING");
					pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), -1);
				}
			}
		}
	}
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes)iI;
		if (eYield == NO_YIELD)
			continue;

		UpdateSpecialReligionYields(eYield);
		UpdateCityYields(eYield);

		for (int iK = 0; iK < NUM_YIELD_TYPES; iK++)
		{
			YieldTypes eYield2 = (YieldTypes)iK;

			if (eYield == eYield2)
				continue;

			int iGlobalConversionYield = owningPlayer.getYieldFromYieldGlobal(eYield, eYield2);
			if (iGlobalConversionYield > 0)
			{
				ChangeBuildingYieldFromYield(eYield, eYield2, iGlobalConversionYield);
			}
		}
	}
	if (bInitialFounding && owningPlayer.GetPlayerTraits()->GetStartingSpies() > 0 && owningPlayer.getNumCities() == 1)
	{
		owningPlayer.CreateSpies(owningPlayer.GetPlayerTraits()->GetStartingSpies(), false);
	}

	owningPlayer.CalculateNetHappiness();

	// Initialize all buildings to not be hidden
	ClearHiddenBuildings();

	//If this is a conquered city, the city value is not updated - it is copied over from the previous city (see in CvPlayer::acquireCity())
	//This is so that the AI sees the actual value of the city, not the value of the city in resistance, which will be much lower
	//However updateEconomicValue() is also called in doTurn() so it will only have the old value for 1 turn
	if (bInitialFounding)
	{
		updateEconomicValue();
	}

	UpdateCachedYieldMedians();

	// Possible difficulty bonus!
	if (bInitialFounding)
		owningPlayer.DoDifficultyBonus(bFoundingCapital ? DIFFICULTY_BONUS_CITY_FOUND_CAPITAL : DIFFICULTY_BONUS_CITY_FOUND);

	AI_init();

	if (GC.getGame().getGameTurn() == 0)
	{
		chooseProduction();
	}
	if (!GET_PLAYER(getOwner()).isHuman())
	{
		AI_chooseProduction(false, false);
	}
}

//	--------------------------------------------------------------------------------
void CvCity::uninit()
{
	VALIDATE_OBJECT();
	m_aiYieldPerPopInEmpire.clear();
	m_miTechEnhancedYields.clear();
	m_miGreatPersonPointFromConstruction.clear();

#if defined(MOD_BALANCE_CORE)
	m_ppiGreatPersonProgressFromConstruction.clear();
#endif

	m_pCityBuildings->Uninit();
	m_pCityStrategyAI->Uninit();
	m_pCityCitizens->Uninit();
	m_pCityReligions->Uninit();
	m_pEmphases->Uninit();
	m_pCityEspionage->Uninit();

	m_orderQueue.clear();

	m_yieldChanges.clear();
	m_eventYields.clear();
}

//	--------------------------------------------------------------------------------
// FUNCTION: reset()
// Initializes data members that are serialized.
void CvCity::reset(int iID, PlayerTypes eOwner, int iX, int iY, bool bConstructorCall)
{
	VALIDATE_OBJECT();
	m_syncArchive.reset();

	int iI = 0;

	//--------------------------------
	// Uninit class
	uninit();

	m_iID = iID;
	m_iX = iX;
	m_iY = iY;
	m_iRallyX = INVALID_PLOT_COORD;
	m_iRallyY = INVALID_PLOT_COORD;
	m_iGameTurnFounded = 0;
	m_iGameTurnAcquired = 0;
	m_iPopulation = 0;
#if defined(MOD_GLOBAL_CITY_AUTOMATON_WORKERS)
	m_iAutomatons = 0;
#endif
#if defined(MOD_BALANCE_CORE)
	m_iAdditionalFood = 0;
	m_iCityBuildingBombardRange = 0;
	m_iCityIndirectFire = 0;
	m_iCityBuildingRangeStrikeModifier = 0;
	m_iGarrisonRangedAttackModifier = 0;
#endif
	m_iHighestPopulation = 0;
	m_iExtraHitPoints = 0;
	m_iBaseGreatPeopleRate = 0;
	m_iGreatPeopleRateModifier = 0;
	m_iGPRateModifierPerMarriage = 0;
	m_iGPRateModifierPerLocalTheme = 0;
	m_iGPPOnCitizenBirth = 0;
	m_iJONSCultureStored = 0;
	m_iJONSCultureLevel = 0;
	m_iJONSCulturePerTurnFromPolicies = 0;
	m_iJONSCulturePerTurnFromSpecialists = 0;
	m_iaAddedYieldPerTurnFromTraits.resize(NUM_YIELD_TYPES);
	m_iFaithPerTurnFromPolicies = 0;
	m_iCultureRateModifier = 0;
	m_iNumWorldWonders = 0;
	m_iNumTeamWonders = 0;
	m_iNumNationalWonders = 0;
	m_iWonderProductionModifier = 0;
	m_iCapturePlunderModifier = 0;
	m_iDiplomatInfluenceBoost = 0;
	m_iBorderGrowthRateIncrease = 0;
	m_iPlotCultureCostModifier = 0;
	m_iPlotBuyCostModifier = 0;
#if defined(MOD_BUILDINGS_CITY_WORKING)
	m_iCityWorkingChange = 0;
	m_iCitySupplyModifier = 0;
	m_iCitySupplyFlat = 0;
	m_iDamageReductionFlat = 0;
	m_bAllowsProductionTradeRoutes = false;
	m_bAllowsFoodTradeRoutes = false;
	m_bAllowPuppetPurchase = false;
#endif
#if defined(MOD_BUILDINGS_CITY_AUTOMATON_WORKERS)
	m_iCityAutomatonWorkersChange = 0;
#endif
	m_iMaintenance = 0;
	m_iHealRate = 0;
	m_iEspionageModifier = 0;
	m_iSpySecurityModifier = 0;
	m_iSpySecurityModifierPerXPop = 0;
	m_iNumPreviousSpyMissions = 0;
	m_fDefensePerWonder = 0;
#if defined(MOD_RELIGION_CONVERSION_MODIFIERS)
	m_iConversionModifier = 0;
#endif
	m_iNoOccupiedUnhappinessCount = 0;
	m_iFoodBonusPerCityMajorityFollower = 0;
#if defined(HH_MOD_BUILDINGS_FRUITLESS_PILLAGE)
	m_iLocalGainlessPillageCount = 0;
#endif
	m_iFood = 0;
	m_iMaxFoodKeptPercent = 0;
	m_iOverflowProduction = 0;
	m_iFeatureProduction = 0;
	m_iMilitaryProductionModifier = 0;
	m_iSpaceProductionModifier = 0;
	m_iFreeExperience = 0;
	m_iMaxAirUnits = /*6 in CP, 2 in VP*/ GD_INT_GET(BASE_CITY_AIR_STACKING);
	m_iNukeModifier = 0;
	m_iTradeRouteRecipientBonus = 0;
	m_iTradeRouteSeaGoldBonus = 0;
	m_iTradeRouteLandGoldBonus = 0;
	m_iNumTradeRouteBonus = 0;
	m_iCityConnectionTradeRouteGoldModifier = 0;
	m_iTradeRouteTargetBonus = 0;
	m_iCitySizeBoost = 0;
	m_iSpecialistFreeExperience = 0;
	m_iStrengthValue = 0;
	m_iDamage = 0;
	m_iThreatValue = 0;
	m_hGarrison = -1;
	m_iResourceDemanded = -1;
	m_iResourceDemandedCounter = 0;
	m_iWeLoveTheKingDayCounter = 0;
	m_iLastTurnGarrisonAssigned = -1;
	m_iThingsProduced = 0;
	m_iDemandResourceCounter = 0;
	m_iResistanceTurns = 0;
	m_iRazingTurns = 0;
	m_iLowestRazingPop = 0;
	m_iCountExtraLuxuries = 0;
	m_iCheapestPlotInfluenceDistance = 0;
	m_unitBeingBuiltForOperation.Invalidate();
	m_hGarrisonOverride = -1;

	m_bNeverLost = true;
	m_bDrafted = false;
	m_bProductionAutomated = false;
	m_bLayoutDirty = false;
	m_bMadeAttack = false;
	m_bOccupied = false;
	m_bPuppet = false;
	m_bIgnoreCityForHappiness = false;
	m_bIndustrialRouteToCapital = false;
	m_iTerrainImprovementNeed = 0;
	m_bOwedCultureBuilding = false;
	m_bOwedFoodBuilding = false;

	m_eOwner = eOwner;
	m_ePreviousOwner = NO_PLAYER;
	m_eOriginalOwner = eOwner;
	m_ePlayersReligion = NO_PLAYER;


	m_aiSeaPlotYield.resize(NUM_YIELD_TYPES);
	m_aiRiverPlotYield.resize(NUM_YIELD_TYPES);
	m_aiSeaResourceYield.resize(NUM_YIELD_TYPES);
	m_aiLakePlotYield.resize(NUM_YIELD_TYPES);
	m_aiBaseYieldRateFromTerrain.resize(NUM_YIELD_TYPES);
	m_aiBaseYieldRateFromBuildings.resize(NUM_YIELD_TYPES);
	m_aiBaseYieldRateFromSpecialists.resize(NUM_YIELD_TYPES);
	m_aiBaseYieldRateFromMisc.resize(NUM_YIELD_TYPES);
	m_aiBaseYieldRateFromLeague.resize(NUM_YIELD_TYPES);
	m_siPlots.clear();
	m_iTotalScienceyAid = 0;
	m_iTotalArtsyAid = 0;
	m_iCachedTechNeedModifier = 0;
	m_iHappinessFromEmpire = 0;
	m_iUnhappinessFromEmpire = 0;
	m_iCachedBasicNeedsMedian = 0;
	m_iCachedGoldMedian = 0;
	m_iCachedScienceMedian = 0;
	m_iCachedCultureMedian = 0;
	m_iCachedTechNeedModifier = 0;
	m_iCachedEmpireSizeModifier = 0;
	m_iYieldMediansCachedTurn = GC.getGame().getGameTurn();
	m_iEmpireSizeModifierReduction = 0;
	m_iDistressFlatReduction = 0;
	m_iPovertyFlatReduction = 0;
	m_iIlliteracyFlatReduction = 0;
	m_iBoredomFlatReduction = 0;
	m_iReligiousUnrestFlatReduction = 0;
	m_iBasicNeedsMedianModifier = 0;
	m_iGoldMedianModifier = 0;
	m_iScienceMedianModifier = 0;
	m_iCultureMedianModifier = 0;
	m_iReligiousUnrestModifier = 0;
	m_iEventHappiness = 0;
	m_iCityEventCooldown = 0;
	m_aiChangeGrowthExtraYield.resize(NUM_YIELD_TYPES);
#if defined(MOD_BALANCE_CORE)
	m_iBorderObstacleWater = 0;
	m_iBorderObstacleCity = 0;
	m_iDeepWaterTileDamage = 0;
	m_iNumNearbyMountains = 0;
	m_iLocalUnhappinessMod = 0;
	m_iExperiencePerGoldenAge = 0;
	m_iExperiencePerGoldenAgeCap = 0;
	m_iExperienceFromPreviousGoldenAges = 0;
	m_iTradePriorityLand = 0;
	m_iNukeInterceptionChance = 0;
	m_iTradeRouteSeaDistanceModifier = 0;
	m_iTradeRouteLandDistanceModifier = 0;
	m_iTradePrioritySea = 0;
	m_iUnitPurchaseCooldown = 0;
	m_iUnitPurchaseCooldownCivilian = 0;
	m_iUnitPurchaseCooldownMod = 0;
	m_iUnitPurchaseCooldownCivilianMod = 0;
	m_iUnitFaithPurchaseCooldown = 0;
	m_iUnitFaithPurchaseCooldownCivilian = 0;
	m_iBuildingPurchaseCooldown = 0;
	m_iReligiousTradeModifier = 0;
	m_iCityAirStrikeDefense = 5;
	m_iFreeBuildingTradeTargetCity = -1;
	m_iBaseTourism = 0;
	m_iBaseTourismBeforeModifiers = 0;
	m_aiNumTimesAttackedThisTurn.resize(REALLY_MAX_PLAYERS);
	m_aiNumProjects.resize(GC.getNumProjectInfos());
	m_aiSpecialistRateModifierFromBuildings.resize(GC.getNumSpecialistInfos());
	m_aiYieldFromVictory.resize(NUM_YIELD_TYPES);
	m_aiYieldFromVictoryGlobal.resize(NUM_YIELD_TYPES);
	m_aiYieldFromVictoryGlobalEraScaling.resize(NUM_YIELD_TYPES);
	m_aiYieldFromVictoryGlobalInGoldenAge.resize(NUM_YIELD_TYPES);
	m_aiYieldFromVictoryGlobalInGoldenAgeEraScaling.resize(NUM_YIELD_TYPES);
	m_aiYieldFromPillage.resize(NUM_YIELD_TYPES);
	m_aiYieldFromPillageGlobal.resize(NUM_YIELD_TYPES);
	m_aiYieldFromKnownPantheons.resize(NUM_YIELD_TYPES);
	m_aiYieldFromGoldenAgeStart.resize(NUM_YIELD_TYPES);
	m_aiYieldChangePerGoldenAge.resize(NUM_YIELD_TYPES);
	m_aiYieldChangePerGoldenAgeCap.resize(NUM_YIELD_TYPES);
	m_aiYieldFromPreviousGoldenAges.resize(NUM_YIELD_TYPES);
	m_aiGoldenAgeYieldMod.resize(NUM_YIELD_TYPES);
	m_aiYieldChangesPerLocalTheme.resize(NUM_YIELD_TYPES);
	m_aiYieldFromUnitGiftGlobal.resize(NUM_YIELD_TYPES);
	m_aiYieldFromWLTKD.resize(NUM_YIELD_TYPES);
	m_aiYieldFromConstruction.resize(NUM_YIELD_TYPES);
	m_aiYieldFromTech.resize(NUM_YIELD_TYPES);
	m_aiYieldFromBirth.resize(NUM_YIELD_TYPES);
	m_aiYieldFromBirthEraScaling.resize(NUM_YIELD_TYPES);
	m_aiYieldFromUnitProduction.resize(NUM_YIELD_TYPES);
	m_aiYieldFromBorderGrowth.resize(NUM_YIELD_TYPES);
	m_aiYieldFromPolicyUnlock.resize(NUM_YIELD_TYPES);
	m_aiYieldFromPurchase.resize(NUM_YIELD_TYPES);
	m_aiYieldFromPurchaseGlobal.resize(NUM_YIELD_TYPES);
	m_aiYieldFromFaithPurchase.resize(NUM_YIELD_TYPES);
	m_aiYieldFromUnitLevelUp.resize(NUM_YIELD_TYPES);
	m_aiYieldFromCombatExperienceTimes100.resize(NUM_YIELD_TYPES);
	m_aiYieldPerAlly.resize(NUM_YIELD_TYPES);
	m_aiYieldPerFriend.resize(NUM_YIELD_TYPES);
	m_aiYieldFromInternalTREnd.resize(NUM_YIELD_TYPES);
	m_aiYieldFromInternationalTREnd.resize(NUM_YIELD_TYPES);
	m_aiYieldFromInternalTR.resize(NUM_YIELD_TYPES);
	m_aiYieldFromProcessModifier.resize(NUM_YIELD_TYPES);
	m_aiYieldFromLongCount.resize(NUM_YIELD_TYPES);
	m_aiYieldFromGPBirthScaledWithWriterBulb.resize(NUM_YIELD_TYPES);
	m_aiYieldFromGPBirthScaledWithArtistBulb.resize(NUM_YIELD_TYPES);
	m_miYieldFromGPBirthScaledWithPerTurnYield.clear();
	m_aiThemingYieldBonus.resize(NUM_YIELD_TYPES);
	m_aiYieldFromSpyAttack.resize(NUM_YIELD_TYPES);
	m_aiYieldFromSpyDefense.resize(NUM_YIELD_TYPES);
	m_aiYieldFromSpyIdentify.resize(NUM_YIELD_TYPES);
	m_aiYieldFromSpyDefenseOrID.resize(NUM_YIELD_TYPES);
	m_aiYieldFromSpyRigElection.resize(NUM_YIELD_TYPES);
	m_aiYieldChangesPerCityStrengthTimes100.resize(NUM_YIELD_TYPES);
	m_aiNumTimesOwned.resize(REALLY_MAX_PLAYERS);
	m_aiStaticCityYield.resize(NUM_YIELD_TYPES);
#endif
#if defined(MOD_BALANCE_CORE)
	m_iExtraBuildingMaintenance = 0;
	m_iLandTourismBonus = 0;
	m_iSeaTourismBonus = 0;
	m_iAlwaysHeal = 0;
	m_iResourceDiversityModifier = 0;
	m_iNoUnhappfromXSpecialists = 0;
	m_bNoWarmonger = false;
	m_iNoStarvationNonSpecialist = 0;
#endif
	m_aiEconomicValue.resize(MAX_CIV_PLAYERS);
	for (iI = 0; iI < MAX_CIV_PLAYERS; iI++)
	{
		m_aiEconomicValue[iI] = 0;
	}
	for (iI = 0; iI < REALLY_MAX_PLAYERS; iI++)
	{
		m_aiNumTimesAttackedThisTurn[iI] = 0;
	}
	m_miUnitClassTrainingAllowed.clear();
	m_miInstantYieldsTotal.clear();
	m_aiBaseYieldRateFromReligion.resize(NUM_YIELD_TYPES);
#if defined(MOD_BALANCE_CORE)	
	m_aiYieldFromMinors.resize(NUM_YIELD_TYPES);
	m_aiBaseYieldRateFromCSFriendship.resize(NUM_YIELD_TYPES);
	m_aiBaseYieldRateFromCSAlliance.resize(NUM_YIELD_TYPES);
	m_aiGreatWorkYieldChange.resize(NUM_YIELD_TYPES);
	m_aiDamagePermyriad.resize(MAX_CIV_PLAYERS);
	for (iI = 0; iI < MAX_CIV_PLAYERS; iI++)
	{
		m_aiDamagePermyriad[iI] = 0;
	}
#endif
	m_aiYieldPerPop.resize(NUM_YIELD_TYPES);
#if defined(MOD_BALANCE_CORE)
	m_aiYieldPerPopInEmpire.clear();
#endif
	m_miTechEnhancedYields.clear();
	m_miGreatPersonPointFromConstruction.clear();
	m_aiYieldPerReligion.resize(NUM_YIELD_TYPES);
	m_aiYieldRateModifier.resize(NUM_YIELD_TYPES);
	m_aiPowerYieldRateModifier.resize(NUM_YIELD_TYPES);
	m_aiResourceYieldRateModifier.resize(NUM_YIELD_TYPES);
	m_aiExtraSpecialistYield.resize(NUM_YIELD_TYPES);
	m_aiProductionToYieldModifier.resize(NUM_YIELD_TYPES);
	m_aiEventCityYield.resize(NUM_YIELD_TYPES);
	m_aiEventCityYieldModifier.resize(NUM_YIELD_TYPES);
	for (iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		m_aiSeaPlotYield[iI] = 0;
		m_aiRiverPlotYield[iI] = 0;
		m_aiLakePlotYield[iI] = 0;
		m_aiSeaResourceYield[iI] = 0;
		m_aiBaseYieldRateFromTerrain[iI] = 0;
		m_aiBaseYieldRateFromBuildings[iI] = 0;
		m_aiBaseYieldRateFromSpecialists[iI] = 0;
		m_aiBaseYieldRateFromMisc[iI] = 0;
		m_aiBaseYieldRateFromLeague[iI] = 0;
		m_aiChangeGrowthExtraYield[iI] = 0;
#if defined(MOD_BALANCE_CORE)
		m_aiGreatWorkYieldChange[iI] = 0;
		m_aiYieldFromKnownPantheons[iI] = 0;
		m_aiYieldFromVictory[iI] = 0;
		m_aiYieldFromVictoryGlobal[iI] = 0;
		m_aiYieldFromVictoryGlobalEraScaling[iI] = 0;
		m_aiYieldFromVictoryGlobalInGoldenAge[iI] = 0;
		m_aiYieldFromVictoryGlobalInGoldenAgeEraScaling[iI] = 0;
		m_aiYieldFromPillage[iI] = 0;
		m_aiYieldFromPillageGlobal[iI] = 0;
		m_aiYieldFromGoldenAgeStart[iI] = 0;
		m_aiYieldChangePerGoldenAge[iI] = 0;
		m_aiYieldChangePerGoldenAgeCap[iI] = 0;
		m_aiYieldFromPreviousGoldenAges[iI] = 0;
		m_aiGoldenAgeYieldMod[iI] = 0;
		m_aiYieldChangesPerLocalTheme[iI] = 0;
		m_aiYieldFromUnitGiftGlobal[iI] = 0;
		m_aiYieldFromWLTKD[iI] = 0;
		m_aiYieldFromConstruction[iI] = 0;
		m_aiYieldFromTech[iI] = 0;
		m_aiYieldFromBirth[iI] = 0;
		m_aiYieldFromBirthEraScaling[iI] = 0;
		m_aiYieldFromUnitProduction[iI] = 0;
		m_aiYieldFromBorderGrowth[iI] = 0;
		m_aiYieldFromPolicyUnlock[iI] = 0;
		m_aiYieldFromPurchase[iI] = 0;
		m_aiYieldFromPurchaseGlobal[iI] = 0;
		m_aiYieldFromFaithPurchase[iI] = 0;
		m_aiYieldFromUnitLevelUp[iI] = 0;
		m_aiYieldFromCombatExperienceTimes100[iI] = 0;
		m_aiYieldPerAlly[iI] = 0;
		m_aiYieldPerFriend[iI] = 0;
		m_aiYieldFromInternalTREnd[iI] = 0;
		m_aiYieldFromInternationalTREnd[iI] = 0;
		m_aiYieldFromInternalTR[iI] = 0;
		m_aiYieldFromProcessModifier[iI] = 0;
		m_aiYieldFromLongCount[iI] = 0;
		m_aiYieldFromGPBirthScaledWithWriterBulb[iI] = 0;
		m_aiYieldFromGPBirthScaledWithArtistBulb[iI] = 0;
		m_aiThemingYieldBonus[iI] = 0;
		m_aiYieldFromSpyAttack[iI] = 0;
		m_aiYieldFromSpyDefense[iI] = 0;
		m_aiYieldFromSpyIdentify[iI] = 0;
		m_aiYieldFromSpyDefenseOrID[iI] = 0;
		m_aiYieldFromSpyRigElection[iI] = 0;
		m_aiYieldChangesPerCityStrengthTimes100[iI] = 0;
		m_aiEventCityYield[iI] = 0;
		m_aiEventCityYieldModifier[iI] = 0;
#endif
		m_aiBaseYieldRateFromReligion[iI] = 0;
#if defined(MOD_BALANCE_CORE)
		m_aiYieldFromMinors[iI] = 0;
		m_aiBaseYieldRateFromCSFriendship[iI] = 0;
		m_aiBaseYieldRateFromCSAlliance[iI] = 0;
		m_aiStaticCityYield[iI] = 0;
#endif
		m_aiYieldPerPop[iI] = 0;
		m_aiYieldPerReligion[iI] = 0;
		m_aiYieldRateModifier[iI] = 0;
		m_aiPowerYieldRateModifier[iI] = 0;
		m_aiResourceYieldRateModifier[iI] = 0;
		m_aiExtraSpecialistYield[iI] = 0;
		m_aiProductionToYieldModifier[iI] = 0;
	}
	m_miYieldFromGPBirthScaledWithPerTurnYield.clear();
#if defined(MOD_BALANCE_CORE_EVENTS)
	m_abEventChoiceFired.resize(GC.getNumCityEventChoiceInfos());
	m_aiEventChoiceDuration.resize(GC.getNumCityEventChoiceInfos());
	m_abEventChoiceActive.resize(GC.getNumCityEventChoiceInfos());
	for (iI = 0; iI < GC.getNumCityEventChoiceInfos(); iI++)
	{
		m_aiEventChoiceDuration[iI] = 0;
		m_abEventChoiceFired[iI] = false;
		m_abEventChoiceActive[iI] = false;
	}
	m_abEventFired.resize(GC.getNumCityEventInfos());
	m_abEventActive.resize(GC.getNumCityEventInfos());
	m_aiEventIncrement.resize(GC.getNumCityEventInfos());
	m_aiEventCooldown.resize(GC.getNumCityEventInfos());
	for (iI = 0; iI < GC.getNumCityEventInfos(); iI++)
	{
		m_abEventFired[iI] = false;
		m_abEventActive[iI] = false;
		m_aiEventIncrement[iI] = 0;
		m_aiEventCooldown[iI] = 0;
	}
#endif
	m_aiDomainFreeExperience.resize(NUM_DOMAIN_TYPES);
	m_aiDomainProductionModifier.resize(NUM_DOMAIN_TYPES);
	for (iI = 0; iI < NUM_DOMAIN_TYPES; iI++)
	{
		m_aiDomainFreeExperience[iI] = 0;
		m_aiDomainProductionModifier[iI] = 0;
	}

	m_abEverLiberated.resize(REALLY_MAX_PLAYERS);
#if defined(MOD_BALANCE_CORE)
	m_abIsBestForWonder.resize(GC.getNumBuildingClassInfos());
	m_abIsPurchased.resize(GC.getNumBuildingClassInfos());
	for (iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
	{
		m_abIsPurchased[iI] = false;
		m_abIsBestForWonder[iI] = false;
	}

	for (iI = 0; iI < GC.getNumProjectInfos(); iI++)
	{
		m_aiNumProjects[iI] = 0;
	}

	m_abTraded.resize(REALLY_MAX_PLAYERS);
	m_abIgnoredForExpansionBickering.resize(MAX_MAJOR_CIVS);
#endif
	for (iI = 0; iI < REALLY_MAX_PLAYERS; iI++)
	{
		m_abEverLiberated[iI] = false;
		m_abTraded[iI] = false;
		m_aiNumTimesOwned[iI] = 0;

		if (iI < MAX_MAJOR_CIVS)
		{
			m_abIgnoredForExpansionBickering[iI] = false;
		}
	}
#if defined(MOD_BALANCE_CORE)
	m_abPaidAdoptionBonus.resize(GC.getNumReligionInfos());
	for (iI = 0; iI < GC.getNumReligionInfos(); iI++)
	{
		m_abPaidAdoptionBonus[iI] = false;
	}
	m_aiReligiousPressureModifier.resize(GC.getNumReligionInfos());
	for (iI = 0; iI < GC.getNumReligionInfos(); iI++)
	{
		m_aiReligiousPressureModifier[iI] = 0;
	}
#endif

	m_strName = "unknown";
	m_strScriptData = "";

	m_bPopulationRankValid = false;
	m_iPopulationRank = -1;
	m_iBaseHappinessFromBuildings = 0;
	m_iUnmoddedHappinessFromBuildings = 0;
	m_bRouteToCapitalConnectedLastTurn = false;
	m_bRouteToCapitalConnectedThisTurn = false;

	m_abBaseYieldRankValid.resize(NUM_YIELD_TYPES);
	m_abYieldRankValid.resize(NUM_YIELD_TYPES);
	m_aiBaseYieldRank.resize(NUM_YIELD_TYPES);
	m_aiYieldRank.resize(NUM_YIELD_TYPES);
#if defined(MOD_BALANCE_CORE)
	m_iHappinessDelta = 0;
	m_iPillagedPlots = 0;
	m_iGrowthFromTourism = 0;
	m_iGrowthEvent = 0;
	m_iEventGPPFromSpecialists = 0;
	m_vEventGPPFromSpecialistsExpiryTurns.clear();
	m_iBuildingClassHappiness = 0;
	m_iReligionHappiness = 0;
	m_aiYieldChangeFromCorporationFranchises.resize(NUM_YIELD_TYPES);
	m_aiYieldModifierFromHappiness.resize(NUM_YIELD_TYPES);
	m_aiYieldModifierFromHealth.resize(NUM_YIELD_TYPES);
	m_aiYieldModifierFromCrime.resize(NUM_YIELD_TYPES);
	m_aiYieldModifierFromDevelopment.resize(NUM_YIELD_TYPES);
	m_aiYieldFromHappiness.resize(NUM_YIELD_TYPES);
	m_aiYieldFromHealth.resize(NUM_YIELD_TYPES);
	m_aiYieldFromCrime.resize(NUM_YIELD_TYPES);
	m_aiYieldFromDevelopment.resize(NUM_YIELD_TYPES);
	m_aiTempCaptureData.resize(5);
	m_abTempCaptureData.resize(2);
#endif
	for (iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		m_abBaseYieldRankValid[iI] = false;
		m_abYieldRankValid[iI] = false;
		m_aiBaseYieldRank[iI] = -1;
		m_aiYieldRank[iI] = -1;
#if defined(MOD_BALANCE_CORE)
		m_aiYieldChangeFromCorporationFranchises[iI] = 0;
		m_aiYieldModifierFromHappiness[iI] = 0;
		m_aiYieldModifierFromHealth[iI] = 0;
		m_aiYieldModifierFromCrime[iI] = 0;
		m_aiYieldModifierFromDevelopment[iI] = 0;
		m_aiYieldFromHappiness[iI] = 0;
		m_aiYieldFromHealth[iI] = 0;
		m_aiYieldFromCrime[iI] = 0;
		m_aiYieldFromDevelopment[iI] = 0;
#endif
	}
	for (int iI = 0; iI < 5; iI++)
	{
		m_aiTempCaptureData[iI] = 0;
	}
	for (int iI = 0; iI < 2; iI++)
	{
		m_abTempCaptureData[iI] = false;
	}
#if defined(MOD_BALANCE_CORE)
	m_abOwedChosenBuilding.resize(GC.getNumBuildingClassInfos());
	m_abBuildingInvestment.resize(GC.getNumBuildingClassInfos());
	m_aiBuildingCostInvestmentReduction.resize(GC.getNumBuildingClassInfos());
	m_abUnitInvestment.resize(GC.getNumUnitClassInfos());
	m_aiUnitCostInvestmentReduction.resize(GC.getNumUnitClassInfos());
	m_abBuildingConstructed.resize(GC.getNumBuildingClassInfos());
	for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
	{
		m_abOwedChosenBuilding[iI] = false;
		m_abBuildingInvestment[iI] = false;
		m_aiBuildingCostInvestmentReduction[iI] = 0;
		m_abBuildingConstructed[iI] = false;
	}
	for (int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
	{
		m_abUnitInvestment[iI] = false;
		m_aiUnitCostInvestmentReduction[iI] = 0;
	}
#endif
#if defined(MOD_BALANCE_CORE_JFD)
	m_bIsColony = false;
	m_iProvinceLevel = 0;
	m_iOrganizedCrime = -1;
	m_iResistanceCounter = 0;
	m_iPlagueCounter = 0;
	m_iPlagueTurns = -1;
	m_iSappedTurns = 0;
	m_iBuildingProductionBlockedTurns = 0;
	m_iNoTourismTurns = 0;
	m_iPlagueType = -1;
	m_iLoyaltyCounter = 0;
	m_iDisloyaltyCounter = 0;
	m_iLoyaltyStateType = 0;
	m_bIsPendingCapture = false;
#endif
	if (!bConstructorCall)
	{
		int iNumResources = GC.getNumResourceInfos();
		ASSERT_DEBUG((0 < iNumResources), "GC.getNumResourceInfos() is not greater than zero but an array is being allocated in CvCity::reset");
		m_paiNoResource.clear();
		m_paiNoResource.resize(iNumResources);
		m_paiFreeResource.clear();
		m_paiFreeResource.resize(iNumResources);
		m_paiNumResourcesLocal.clear();
		m_paiNumResourcesLocal.resize(iNumResources);

		m_paiNumUnimprovedResourcesLocal.clear();
		m_paiNumUnimprovedResourcesLocal.resize(iNumResources);
#if defined(MOD_BALANCE_CORE)
		m_aiResourceQuantityPerXFranchises.clear();
		m_aiResourceQuantityPerXFranchises.resize(iNumResources);
#endif
		m_aiResourceQuantityFromPOP.clear();
		m_aiResourceQuantityFromPOP.resize(iNumResources);
		for (iI = 0; iI < iNumResources; iI++)
		{
			m_paiNoResource[iI] = 0;
			m_paiFreeResource[iI] = 0;
			m_paiNumResourcesLocal[iI] = 0;
			m_paiNumUnimprovedResourcesLocal[iI] = 0;
#if defined(MOD_BALANCE_CORE)
			m_aiResourceQuantityPerXFranchises[iI] = 0;
#endif
			m_aiResourceQuantityFromPOP[iI] = 0;
		}
		int iNumProjectInfos = GC.getNumProjectInfos();
		m_paiProjectProduction.clear();
		m_paiProjectProduction.resize(iNumProjectInfos);
		for (iI = 0; iI < iNumProjectInfos; iI++)
		{
			m_paiProjectProduction[iI] = 0;
		}

		int iNumSpecialistInfos = GC.getNumSpecialistInfos();
		for (iI = 0; iI < iNumSpecialistInfos; iI++)
		{
			m_aiSpecialistRateModifierFromBuildings[iI] = 0;
		}

		m_pCityBuildings->Init(GC.GetGameBuildings(), this);

		int iNumUnitInfos = GC.getNumUnitInfos();
		ASSERT_DEBUG((0 < iNumUnitInfos), "GC.getNumUnitInfos() is not greater than zero but an array is being allocated in CvCity::reset");
		m_paiUnitProduction.clear();
		m_paiUnitProduction.resize(iNumUnitInfos);
		m_paiUnitProductionTime.clear();
		m_paiUnitProductionTime.resize(iNumUnitInfos);
		for (iI = 0; iI < iNumUnitInfos; iI++)
		{
			m_paiUnitProduction[iI] = 0;
			m_paiUnitProductionTime[iI] = 0;
		}

		int iNumUnitCombatClassInfos = GC.getNumUnitCombatClassInfos();
		ASSERT_DEBUG((0 < iNumUnitCombatClassInfos), "GC.getNumUnitCombatClassInfos() is not greater than zero but an array is being allocated in CvCity::reset");
		m_paiUnitCombatFreeExperience.clear();
		m_paiUnitCombatFreeExperience.resize(iNumUnitCombatClassInfos);
		m_paiUnitCombatProductionModifier.clear();
		m_paiUnitCombatProductionModifier.resize(iNumUnitCombatClassInfos);
		for (iI = 0; iI < iNumUnitCombatClassInfos; iI++)
		{
			m_paiUnitCombatFreeExperience[iI] = 0;
			m_paiUnitCombatProductionModifier[iI] = 0;
		}

		m_paiFreePromotionCount.clear();

#if defined(MOD_BALANCE_CORE_POLICIES)
		int iNumBuildingClassInfos = GC.getNumBuildingClassInfos();
		ASSERT_DEBUG((0 < iNumBuildingClassInfos), "GC.getNumBuildingClassInfos() is not greater than zero but an array is being allocated in CvCity::reset");
		m_paiBuildingClassCulture.clear();
		m_paiBuildingClassCulture.resize(iNumBuildingClassInfos);
		for (iI = 0; iI < iNumBuildingClassInfos; iI++)
		{
			m_paiBuildingClassCulture[iI] = 0;
		}

		int iNumHurryInfos = GC.getNumHurryInfos();
		ASSERT_DEBUG((0 < iNumHurryInfos), "GC.getNumHurryInfos() is not greater than zero but an array is being allocated in CvCity::reset");
		m_paiHurryModifier.clear();
		m_paiHurryModifier.resize(iNumHurryInfos);
		for (iI = 0; iI < iNumHurryInfos; iI++)
		{
			m_paiHurryModifier[iI] = 0;
		}
#endif

		int iNumTerrainInfos = GC.getNumTerrainInfos();
		int iNumFeatureInfos = GC.getNumFeatureInfos();
		int iNumImprovementInfos = GC.getNumImprovementInfos();

#if defined(MOD_BALANCE_CORE)
		m_paiNumTerrainWorked.clear();
		m_paiNumFeaturelessTerrainWorked.clear();
		m_paiNumFeaturelessTerrainWorked.resize(iNumTerrainInfos);
		m_paiNumTerrainWorked.resize(iNumTerrainInfos);
		for (iI = 0; iI < iNumTerrainInfos; iI++)
		{
			m_paiNumTerrainWorked[iI] = 0;
			m_paiNumFeaturelessTerrainWorked[iI] = 0;
		}

		m_paiNumFeatureWorked.clear();
		m_paiNumFeatureWorked.resize(iNumFeatureInfos);
		for (iI = 0; iI < iNumFeatureInfos; iI++)
		{
			m_paiNumFeatureWorked[iI] = 0;
		}

		m_paiNumImprovementWorked.clear();
		m_paiNumImprovementWorked.resize(iNumImprovementInfos);
		for (iI = 0; iI < iNumImprovementInfos; iI++)
		{
			m_paiNumImprovementWorked[iI] = 0;
		}
#endif
	}

#if defined(MOD_BALANCE_CORE)
	m_ppiGreatPersonProgressFromConstruction.clear();
#endif

	m_yieldChanges = vector<SCityExtraYields>(NUM_YIELD_TYPES);
	m_eventYields = vector<SCityEventYields>(NUM_YIELD_TYPES);
	m_GwYieldCache = vector<int>(NUM_YIELD_TYPES, -1);

	if (!bConstructorCall)
	{
		// Set up AI and hook it up to the flavor manager
		m_pCityStrategyAI->Init(GC.GetGameAICityStrategies(), this, true);
		if (m_eOwner != NO_PLAYER)
			GET_PLAYER(getOwner()).GetFlavorManager()->AddFlavorRecipient(m_pCityStrategyAI);

		m_pCityCitizens->Init(this);
		m_pCityReligions->Init(this);
		m_pEmphases->Init(this);
		m_pCityEspionage->Init(this);
		m_pCityCulture->Init(this);

		AI_reset();

		if (m_eOwner != NO_PLAYER)
		{
			int iAutomaton = GET_TEAM(GET_PLAYER(getOwner()).getTeam()).GetCityAutomatonWorkersChange() + GET_PLAYER(getOwner()).GetCityAutomatonWorkersChange();
			setAutomatons(iAutomaton);
		}
	}

	m_iVassalLevyEra = 0;
}


//////////////////////////////////////
// graphical only setup
//////////////////////////////////////
void CvCity::setupGraphical()
{
	VALIDATE_OBJECT();
	if (!GC.IsGraphicsInitialized())
	{
		return;
	}

	CvPlayer& player = GET_PLAYER(getOwner());
	EraTypes eCurrentEra = player.GetCurrentEra();

	CvInterfacePtr<ICvCity1> pkDllCity(new CvDllCity(this));
	gDLL->GameplayCityCreated(pkDllCity.get(), eCurrentEra);
	gDLL->GameplayCitySetDamage(pkDllCity.get(), getDamage(), 0);

	// setup the wonders
	setupWonderGraphics();

	// setup any special buildings
	setupBuildingGraphics();

	// setup the spaceship
	setupSpaceshipGraphics();

	setLayoutDirty(true);
}

//	--------------------------------------------------------------------------------
void CvCity::setupWonderGraphics()
{
	VALIDATE_OBJECT();
	PlayerTypes ePlayerID = getOwner();
	for (int eBuildingType = 0; eBuildingType < GC.getNumBuildingInfos(); eBuildingType++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(eBuildingType);
		CvBuildingEntry* buildingInfo = GC.getBuildingInfo(eBuilding);

		//Only work with valid buildings.
		if (buildingInfo == NULL)
			continue;

		// if this building exists
		int iExists = m_pCityBuildings->GetNumRealBuilding(eBuilding);
		int iPreferredPosition = buildingInfo->GetPreferredDisplayPosition();
		if (iPreferredPosition > 0)
		{
			if (iExists > 0)
			{
				// display the wonder
				CvInterfacePtr<ICvPlot1> pDllPlot(new CvDllPlot(plot()));
				gDLL->GameplayWonderCreated(ePlayerID, pDllPlot.get(), eBuilding, 1);
			}
			else
			{
				if (isWorldWonderClass(buildingInfo->GetBuildingClassInfo()))
				{
					bool bShowHalfBuilt = false;
					// Are we are constructing it?
					if (eBuilding == getProductionBuilding())
					{
						bShowHalfBuilt = true;
					}
					else
					{
						// Is it part of an international project?
						LeagueProjectTypes eThisBuildingProject = NO_LEAGUE_PROJECT;
						for (int i = 0; i < GC.getNumLeagueProjectInfos(); i++)
						{
							LeagueProjectTypes eProject = (LeagueProjectTypes)i;
							CvLeagueProjectEntry* pProjectInfo = GC.getLeagueProjectInfo(eProject);
							if (pProjectInfo != NULL && pProjectInfo->GetRewardTier3() != NO_LEAGUE_PROJECT_REWARD) // Only check top reward tier
							{
								CvLeagueProjectRewardEntry* pRewardInfo = GC.getLeagueProjectRewardInfo(pProjectInfo->GetRewardTier3());
								if (pRewardInfo != NULL && pRewardInfo->GetBuilding() == eBuilding)
								{
									eThisBuildingProject = eProject;
									break;
								}
							}
						}
						if (eThisBuildingProject != NO_LEAGUE_PROJECT)
						{
							// Have we contributed anything to it?
							if (GC.getGame().GetGameLeagues()->GetNumActiveLeagues() > 0)
							{
								CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
								if (pLeague != NULL)
								{
									if (pLeague->IsProjectActive(eThisBuildingProject) && pLeague->GetMemberContribution(ePlayerID, eThisBuildingProject, true) > 0)
									{
										// Only show the graphic in the capital, since that is where the wonder would go
										if (isCapital())
										{
											bShowHalfBuilt = true;
										}
									}
								}
							}
						}


					}

					if (bShowHalfBuilt)
					{
						CvInterfacePtr<ICvPlot1> pDllPlot(new CvDllPlot(plot()));
						gDLL->GameplayWonderCreated(ePlayerID, pDllPlot.get(), eBuilding, 0);
					}
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
void CvCity::setupBuildingGraphics()
{
	VALIDATE_OBJECT();
	for (int eBuildingType = 0; eBuildingType < GC.getNumBuildingInfos(); eBuildingType++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(eBuildingType);
		CvBuildingEntry* buildingInfo = GC.getBuildingInfo(eBuilding);

		if (buildingInfo)
		{
			int iExists = m_pCityBuildings->GetNumBuilding(eBuilding);
			if (iExists > 0 && buildingInfo->IsCityWall())
			{
				CvInterfacePtr<ICvPlot1> pDllPlot(new CvDllPlot(plot()));
				gDLL->GameplayWallCreated(pDllPlot.get());
			}
		}
	}
}

//	--------------------------------------------------------------------------------
void CvCity::setupSpaceshipGraphics()
{
	VALIDATE_OBJECT();

	CvTeam& thisTeam = GET_TEAM(getTeam());
	ProjectTypes ApolloProgram = (ProjectTypes)GD_INT_GET(SPACE_RACE_TRIGGER_PROJECT);
	int spaceshipState = 0;

	if (isCapital() && thisTeam.getProjectCount(ApolloProgram) == 1)
	{
		ProjectTypes capsuleID = (ProjectTypes)GD_INT_GET(SPACESHIP_CAPSULE);
		ProjectTypes boosterID = (ProjectTypes)GD_INT_GET(SPACESHIP_BOOSTER);
		ProjectTypes stasisID = (ProjectTypes)GD_INT_GET(SPACESHIP_STASIS);
		ProjectTypes engineID = (ProjectTypes)GD_INT_GET(SPACESHIP_ENGINE);

		enum eSpaceshipState
		{
			eUnderConstruction = 0x0000,
			eFrame = 0x0001,
			eCapsule = 0x0002,
			eStasis_Chamber = 0x0004,
			eEngine = 0x0008,
			eBooster1 = 0x0010,
			eBooster2 = 0x0020,
			eBooster3 = 0x0040,
			eConstructed = 0x0080,
		};

		CvInterfacePtr<ICvPlot1> pDllPlot(new CvDllPlot(plot()));
		gDLL->GameplaySpaceshipRemoved(pDllPlot.get());
		gDLL->GameplaySpaceshipCreated(pDllPlot.get(), eUnderConstruction + eFrame);

		spaceshipState = eFrame;

		if ((thisTeam.getProjectCount(capsuleID)) == 1)
		{
			spaceshipState += eCapsule;
		}

		if ((thisTeam.getProjectCount(stasisID)) == 1)
		{
			spaceshipState += eStasis_Chamber;
		}

		if ((thisTeam.getProjectCount(engineID)) == 1)
		{
			spaceshipState += eEngine;
		}

		if ((thisTeam.getProjectCount(boosterID)) >= 1)
		{
			spaceshipState += eBooster1;
		}

		if ((thisTeam.getProjectCount(boosterID)) >= 2)
		{
			spaceshipState += eBooster2;
		}

		if ((thisTeam.getProjectCount(boosterID)) == 3)
		{
			spaceshipState += eBooster3;
		}

		gDLL->GameplaySpaceshipEdited(pDllPlot.get(), spaceshipState);
	}
}

//	--------------------------------------------------------------------------------
void CvCity::PreKill()
{
	VALIDATE_OBJECT();

	PlayerTypes eOwner;
	if (isCitySelected())
	{
		DLLUI->clearSelectedCities();
	}

	setAutomatons(0);
	setPopulation(0);

	CvPlot* pPlot = plot();

	GC.getGame().GetGameTrade()->ClearAllCityTradeRoutes(pPlot, true);

	pPlot->removeMinorResources();

	for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);
		GetCityBuildings()->SetNumRealBuilding(eBuilding, 0);
		GetCityBuildings()->SetNumFreeBuilding(eBuilding, 0);
	}

	clearOrderQueue();

	// Killing a city while in combat is not something we really expect to happen.
	// It is *mostly* safe for it to happen, but combat systems must be able to gracefully handle the disapperance of a city.
	ASSERT_DEBUG(!isFighting(), "isFighting did not return false as expected");

	clearCombat();

	// Could also be non-garrisoned units here that we need to show
	for (int iUnitLoop = 0; iUnitLoop < pPlot->getNumUnits(); iUnitLoop++)
	{
		CvUnit* pLoopUnit = pPlot->getUnitByIndex(iUnitLoop);

		if (pLoopUnit->IsGarrisoned())
			pLoopUnit->SetGarrisonedCity(-1);

		// Only show units that belong to this city's owner - that way we don't show units on EVERY city capture (since the old city is deleted in this case)
		if (getOwner() == pLoopUnit->getOwner())
		{
			CvInterfacePtr<ICvUnit1> pDllUnit(new CvDllUnit(pLoopUnit));
			gDLL->GameplayUnitVisibility(pDllUnit.get(), !pLoopUnit->isInvisible(GC.getGame().getActiveTeam(), true) /*bVisible*/);
		}
	}

	for (int iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);
		if (!pLoopPlot)
			continue;
		
		//give up all plots owned by this city
		if (pLoopPlot->getOwningCityID() == GetID())
			pLoopPlot->setOwner(NO_PLAYER, NO_PLAYER, /*bCheckUnits*/ false, /*bUpdateResources*/ true);

		//but also give back any loaned plots to their original city
		if (pLoopPlot->isEffectiveOwner(this))
			pLoopPlot->setOwningCityOverride(NULL);
	}

	pPlot->setIsCity(false, m_iID, getWorkPlotDistance());

	//don't need to update landmass stats, that is implied by area changes
	GC.getMap().getAreaById(pPlot->getArea())->changeCitiesPerPlayer(getOwner(), -1);
	std::vector<int> areas = pPlot->getAllAdjacentAreas();
	for (std::vector<int>::iterator it = areas.begin(); it != areas.end(); ++it)
	{
		CvArea* pkArea = GC.getMap().getAreaById(*it);
		if (pkArea->isWater())
			pkArea->changeCitiesPerPlayer(getOwner(), -1);
	}

	GET_TEAM(getTeam()).changeNumCities(-1);

	GC.getGame().changeNumCities(-1);

	ASSERT_DEBUG(!isProduction(), "isProduction is expected to be false");

	eOwner = getOwner();

	GET_PLAYER(getOwner()).GetFlavorManager()->RemoveFlavorRecipient(m_pCityStrategyAI);

	if (m_unitBeingBuiltForOperation.IsValid())
	{
		GET_PLAYER(getOwner()).CityUncommitToBuildUnitForOperationSlot(m_unitBeingBuiltForOperation);
		m_unitBeingBuiltForOperation.Invalidate();
	}
}

//	--------------------------------------------------------------------------------
void CvCity::PostKill(bool bCapital, CvPlot* pPlot, int iWorkPlotDistance, PlayerTypes eOwner)
{
	VALIDATE_OBJECT();

	CvPlayer& owningPlayer = GET_PLAYER(eOwner);
	owningPlayer.CalculateNetHappiness();

	// Update Unit Maintenance for the player
	owningPlayer.UpdateUnitProductionMaintenanceMod();

	GC.getMap().updateOwningCityForPlots(pPlot, iWorkPlotDistance * 2);
	if (bCapital)
	{
#if defined(MOD_GLOBAL_NO_CONQUERED_SPACESHIPS)
		owningPlayer.disassembleSpaceship(pPlot);
#endif
		owningPlayer.findNewCapital();
		owningPlayer.SetHasLostCapital(true, getOwner());
		GET_TEAM(owningPlayer.getTeam()).resetVictoryProgress();
	}

	pPlot->setImprovementType((ImprovementTypes)(GD_INT_GET(RUINS_IMPROVEMENT)));

	if (eOwner == GC.getGame().getActivePlayer())
	{
		DLLUI->setDirty(SelectionButtons_DIRTY_BIT, true);
	}

	DLLUI->setDirty(NationalBorders_DIRTY_BIT, true);

	if (GC.getGame().getActivePlayer() == eOwner)
	{
		CvMap& theMap = GC.getMap();
		theMap.updateDeferredFog();
	}

}

//	--------------------------------------------------------------------------------
void CvCity::kill()
{
	VALIDATE_OBJECT();
	CvPlot* pPlot = plot();
	PlayerTypes eOwner = getOwner();
	bool bCapital = isCapital();

	IDInfo* pUnitNode = NULL;
	CvUnit* pLoopUnit = NULL;
	pUnitNode = pPlot->headUnitNode();

	FFastSmallFixedList<IDInfo, 25, true, c_eCiv5GameplayDLL > oldUnits;

	while (pUnitNode != NULL)
	{
		oldUnits.insertAtEnd(pUnitNode);
		pUnitNode = pPlot->nextUnitNode(pUnitNode);
	}

	pUnitNode = oldUnits.head();

	while (pUnitNode != NULL)
	{
		pLoopUnit = ::GetPlayerUnit(*pUnitNode);
		pUnitNode = oldUnits.next(pUnitNode);

		if (pLoopUnit)
		{
			if (pLoopUnit->IsImmobile() && !pLoopUnit->isCargo())
			{
				pLoopUnit->kill(false);
			}
		}
	}

	// Original capital destroyed somehow? Treat it as if it was never founded.
	if (IsOriginalCapital())
		GET_PLAYER(m_eOriginalOwner).resetOriginalCapitalXY();

	// Remove Holy City status!
	if (GetCityReligions()->IsHolyCityAnyReligion())
		GC.getGame().GetGameReligions()->SetHolyCity(GetCityReligions()->GetReligionForHolyCity(), NULL);

	// get spies out of city
	CvCityEspionage* pCityEspionage = GetCityEspionage();
	if (pCityEspionage)
	{
		for (int i = 0; i < MAX_MAJOR_CIVS; i++)
		{
			int iAssignedSpy = pCityEspionage->m_aiSpyAssignment[i];
			// if there is a spy in the city
			if (iAssignedSpy != -1)
			{
				GET_PLAYER((PlayerTypes)i).GetEspionage()->ExtractSpyFromCity(iAssignedSpy);
			}
		}
	}

	PreKill();

	// Delete the city's information here!!!
	CvGameTrade* pkGameTrade = GC.getGame().GetGameTrade();
	if (pkGameTrade)
	{
		pkGameTrade->ClearAllCityTradeRoutes(plot(), true);
	}

	//save this before deleting the city
	int iWorkPlotDistance = getWorkPlotDistance();

	GET_PLAYER(getOwner()).deleteCity(m_iID);
	GET_PLAYER(eOwner).GetCityConnections()->SetDirty();

	// clean up
	PostKill(bCapital, pPlot, iWorkPlotDistance, eOwner);
}

//	--------------------------------------------------------------------------------
CvPlayer* CvCity::GetPlayer() const
{
	VALIDATE_OBJECT();
	return &GET_PLAYER(getOwner());
}

void CvCity::ResetGreatWorkYieldCache()
{
	//reset the cache
	m_GwYieldCache = vector<int>(NUM_YIELD_TYPES, -1);
}

//	--------------------------------------------------------------------------------
void CvCity::doTurn()
{
	VALIDATE_OBJECT();

	ResetGreatWorkYieldCache();

	if (getDamage() > 0 && !IsBlockadedWaterAndLand())
	{
		int iHitsHealed = /*20 in CP, 8 in VP*/ GD_INT_GET(CITY_HIT_POINTS_HEALED_PER_TURN);

		int iBuildingDefense = m_pCityBuildings->GetBuildingDefense();
		iBuildingDefense *= (100 + m_pCityBuildings->GetBuildingDefenseMod());
		iBuildingDefense /= 100;

		iHitsHealed += iBuildingDefense / 1000;

		//cities heal much faster if there are no enemies around
		if (MOD_BALANCE_VP)
		{
			iHitsHealed += getPopulation();
			if (getDamageTakenLastTurn()==0 && !GetCityCitizens()->AnyPlotBlockaded())
				iHitsHealed *= 3;
		}

		if (getProductionProcess() != NO_PROCESS)
		{
			CvProcessInfo* pkProcessInfo = GC.getProcessInfo(getProductionProcess());
			if (pkProcessInfo && pkProcessInfo->getDefenseValue() != 0)
			{
				int iPile = getYieldRate(YIELD_PRODUCTION, false) * pkProcessInfo->getDefenseValue();
				iHitsHealed += iPile / 100;
			}
		}

		changeDamage(-iHitsHealed);
	}

	if (getDamage() < 0)
		setDamage(0);

	if (MOD_BALANCE_CORE_JFD)
	{
		if (GetPlagueTurns() > 0)
		{
			ChangePlagueTurns(-1);
		}
	}

	if (GetSappedTurns() > 0)
		ChangeSappedTurns(-1);

	if (GetBuildingProductionBlockedTurns() > 0)
		ChangeBuildingProductionBlockedTurns(-1);

	UpdateEventGPPFromSpecialistsCounters();

	if (GetNoTourismTurns() > 0)
	{
		ChangeNoTourismTurns(-1);
		if (GetNoTourismTurns() == 0)
		{
			CvNotifications* pNotifications = GET_PLAYER(m_eOwner).GetNotifications();
			if (pNotifications)
			{
				Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_NO_TOURISM_EVENT_ENDED");
				strText << getNameKey();
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_NO_TOURISM_EVENT_ENDED_S");
				strSummary << getNameKey();
				pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), -1);
			}
		}
	}

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		ChangeNumTimesAttackedThisTurn((PlayerTypes)iPlayerLoop, (-1 * GetNumTimesAttackedThisTurn((PlayerTypes)iPlayerLoop)));
	}

	updateEconomicValue();
	UpdateGrowthFromTourism();

	if (plot() != NULL)
	{
		for (int iUnitLoop = 0; iUnitLoop < plot()->getNumUnits(); iUnitLoop++)
		{
			CvUnit* pLoopUnit = plot()->getUnitByIndex(iUnitLoop);

			//Only get land combat units
			if (pLoopUnit != NULL && getOwner() == pLoopUnit->getOwner() && pLoopUnit->IsCombatUnit() && pLoopUnit->getDomainType() == DOMAIN_LAND)
			{
				if (pLoopUnit->getDamage() > 0)
				{
					if ((pLoopUnit->getDamage() - GetAlwaysHeal()) <= 0)
					{
						pLoopUnit->setDamage(0);
					}
					else
					{
						pLoopUnit->changeDamage(-GetAlwaysHeal());
					}
				}
			}
		}
	}

	if (MOD_BALANCE_CORE_EVENTS)
	{
		if (GC.getGame().isOption(GAMEOPTION_GOOD_EVENTS) || GC.getGame().isOption(GAMEOPTION_NEUTRAL_EVENTS) || GC.getGame().isOption(GAMEOPTION_BAD_EVENTS)
			|| GC.getGame().isOption(GAMEOPTION_TRADE_EVENTS) || GC.getGame().isOption(GAMEOPTION_CIV_SPECIFIC_EVENTS))
		{
			DoEvents();
		}
		else
		{
			DoEvents(true);
		}
	}

	setDrafted(false);
	setMadeAttack(false);
	GetCityBuildings()->SetSoldBuildingThisTurn(false);

	
	if (foodDifferenceTimes100(true) < 0)
	{
		// avoid starvation if possible
		GetCityCitizens()->DoReallocateCitizens(true);
	}
	else
	{
		//not a full re-allocation but see if we can shift some citizens around
		//DoReallocateCitizens() will be called less frequently when a building is added, a plot is claimed, population changes etc
		GetCityCitizens()->DoVerifyWorkingPlots();
		GetCityCitizens()->OptimizeWorkedPlots(false);
		updateNetHappiness();
	}
	UpdateTerrainImprovementNeed();

	GetCityStrategyAI()->DoTurn();
	AI_doTurn();

	if (GetUnitPurchaseCooldown() > 0)
	{
		ChangeUnitPurchaseCooldown(false, -1);
	}
	if (GetUnitPurchaseCooldown(true) > 0)
	{
		ChangeUnitPurchaseCooldown(true, -1);
	}
	if (GetUnitFaithPurchaseCooldown() > 0)
	{
		ChangeUnitFaithPurchaseCooldown(false, -1);
	}
	if (GetUnitFaithPurchaseCooldown(true) > 0)
	{
		ChangeUnitFaithPurchaseCooldown(true, -1);
	}
	if (GetBuildingPurchaseCooldown() > 0)
	{
		ChangeBuildingPurchaseCooldown(-1);
	}
	if (!GET_PLAYER(getOwner()).isHuman())
	{
		CheckForOperationUnits();
	}
	if (isCapital() && IsPuppet())
	{
		SetPuppet(false);
	}
	if (isCapital() && IsOccupied() && !IsNoOccupiedUnhappiness())
	{
		ChangeNoOccupiedUnhappinessCount(1);
	}
	if (IsRazing())
	{
		DoSellBuilding();
	}

	if (!GET_PLAYER(getOwner()).isMinorCiv() && !GET_PLAYER(getOwner()).isBarbarian())
	{
		//normally we only do delta update. this is for debugging
		CrosscheckYieldsFromMinors();

		if (MOD_BALANCE_CORE_BUILDING_RESOURCE_MAINTENANCE)
		{
			int iBad = 0;
			for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
			{
				ResourceTypes eResourceLoop = (ResourceTypes)iResourceLoop;
				if (eResourceLoop != NO_RESOURCE)
				{
					const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResourceLoop);
					if (pkResourceInfo && pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)
					{
						// See if there are any BuildingClass requirements
						if (GET_PLAYER(getOwner()).getResourceShortageValue(eResourceLoop) > 0)
						{
							for (int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
							{
								const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iBuildingClassLoop);
								BuildingTypes eResourceBuilding = GetBuildingTypeFromClass(eBuildingClass);
								if (eResourceBuilding == NO_BUILDING)
									continue;

								if (!HasBuilding(eResourceBuilding))
									continue;

								CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eResourceBuilding);
								if (!pkBuildingInfo)
									continue;

								int iResourceDelta = 0;

								// If amount we're under is less than resource quantity, take the lesser value.
								if (GET_PLAYER(getOwner()).getResourceShortageValue(eResourceLoop) < pkBuildingInfo->GetResourceQuantityRequirement(eResourceLoop))
								{
									iResourceDelta = GET_PLAYER(getOwner()).getResourceShortageValue(eResourceLoop);
								}
								// Otherwise, take the building's full value.
								else
								{
									iResourceDelta = pkBuildingInfo->GetResourceQuantityRequirement(eResourceLoop);
								}
								if (iResourceDelta > 0)
								{
									iBad += (iResourceDelta * 2);
									GET_PLAYER(getOwner()).changeResourceShortageValue(eResourceLoop, -iResourceDelta);
									if (GET_PLAYER(getOwner()).getResourceShortageValue(eResourceLoop) < 0)
									{
										GET_PLAYER(getOwner()).setResourceShortageValue(eResourceLoop, 0);
									}
									CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
									if (pNotifications)
									{
										Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_OVER_RESOURCE_LIMIT_CITY");
										strText << pkResourceInfo->GetTextKey();
										strText << getNameKey();
										strText << (iResourceDelta * 2);
										Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_OVER_RESOURCE_LIMIT_CITY");
										strSummary << pkResourceInfo->GetTextKey();
										strSummary << getNameKey();
										pNotifications->Add(NOTIFICATION_DISCOVERED_STRATEGIC_RESOURCE, strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), eResourceLoop);
									}
								}
							}
						}
					}
				}
			}
			if (iBad > 0)
			{
				SetExtraBuildingMaintenance(iBad);
			}
			else
			{
				SetExtraBuildingMaintenance(0);
			}
		}
	}

	bool bRazed = DoRazingTurn();

	if (!bRazed)
	{
		DoResistanceTurn();

		bool bWeGrew = false;
		int iDifference = (getYieldRateTimes100(YIELD_FOOD, false) - foodConsumptionTimes100());
		if (isFoodProduction() || getFood() <= 5 || iDifference <= 0)
		{
			doGrowth();
			bWeGrew = true;
		}

		doProduction(!doCheckProduction());
		doDecay();
		doMeltdown();

		for (int iI = 0; iI < GetNumWorkablePlots(); iI++)
		{
			CvPlot* pLoopPlot = GetCityCitizens()->GetCityPlotFromIndex(iI);
			if (pLoopPlot != NULL)
			{
				if (GetCityCitizens()->IsWorkingPlot(iI))
				{
					pLoopPlot->doImprovement();
				}
			}
		}

		// Following function also looks at WLTKD stuff
		DoTestResourceDemanded();

		int iBorderGrowth = 0;
		iBorderGrowth += getJONSCulturePerTurn();
		iBorderGrowth += getYieldRate(YIELD_CULTURE_LOCAL, false);
		// Culture accumulation
		if (iBorderGrowth > 0)
			ChangeJONSCultureStored(iBorderGrowth);

		// Enough Culture to acquire a new Plot?
		if (GetJONSCultureStored() >= GetJONSCultureThreshold())
		{
			DoJONSCultureLevelIncrease();
		}

		// Resource Demanded Counter
		if (GetResourceDemandedCountdown() > 0)
		{
			ChangeResourceDemandedCountdown(-1);

			if (GetResourceDemandedCountdown() <= 0)
			{
				// Pick a Resource to demand
				DoPickResourceDemanded();
			}
		}

		updateStrengthValue();

		DoNearbyEnemy();

		//Check for Achievements
		if (MOD_API_ACHIEVEMENTS && isHuman() && !GC.getGame().isGameMultiPlayer() && GET_PLAYER(GC.getGame().getActivePlayer()).isLocalPlayer())
		{
			if (getJONSCulturePerTurn() >= 100)
			{
				gDLL->UnlockAchievement(ACHIEVEMENT_CITY_100CULTURE);
			}
			if (getYieldRate(YIELD_GOLD, false) >= 100)
			{
				gDLL->UnlockAchievement(ACHIEVEMENT_CITY_100GOLD);
			}
			if (getYieldRate(YIELD_SCIENCE, false) >= 100)
			{
				gDLL->UnlockAchievement(ACHIEVEMENT_CITY_100SCIENCE);
			}
		}

		if (!bWeGrew)
		{
			doGrowth();
		}
		GetCityCitizens()->DoTurn();

		// sending notifications on when routes are connected to the capital
		if (!isCapital())
		{
			CvNotifications* pNotifications = GET_PLAYER(m_eOwner).GetNotifications();
			if (pNotifications)
			{
				CvCity* pPlayerCapital = GET_PLAYER(m_eOwner).getCapitalCity();
				ASSERT_DEBUG(pPlayerCapital, "No capital city?");

				if (m_bRouteToCapitalConnectedLastTurn != m_bRouteToCapitalConnectedThisTurn && pPlayerCapital)
				{
					Localization::String strMessage;
					Localization::String strSummary;

					if (m_bRouteToCapitalConnectedThisTurn)  // connected this turn
					{
						strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_TRADE_ROUTE_ESTABLISHED");
						strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_TRADE_ROUTE_ESTABLISHED");
						strMessage << getNameKey();
						strMessage << pPlayerCapital->getNameKey();
						pNotifications->Add(NOTIFICATION_TRADE_ROUTE, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, -1);
					}
					else // lost connection this turn
					{
						strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_TRADE_ROUTE_BROKEN");
						strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_TRADE_ROUTE_BROKEN");
						strMessage << getNameKey();
						strMessage << pPlayerCapital->getNameKey();
						pNotifications->Add(NOTIFICATION_TRADE_ROUTE_BROKEN, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, -1);
					}
				}
			}

			updateYield();
			m_bRouteToCapitalConnectedLastTurn = m_bRouteToCapitalConnectedThisTurn;
		}

		for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
		{
			YieldTypes eYield = (YieldTypes)iI;
			if (eYield == NO_YIELD)
				continue;

			UpdateSpecialReligionYields(eYield);
			UpdateCityYields(eYield);
		}

#ifdef _DEBUG
		//checking if yields are correct ... there have been issues
		{
			for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				ASSERT_DEBUG(getBaseYieldRate((YieldTypes)iI) >= 0);
				ASSERT_DEBUG(getYieldRate((YieldTypes)iI, false) >= 0);

				int iCount = 0;
				for (int iJ = 0; iJ < GetNumWorkablePlots(); iJ++)
				{
					CvPlot* pPlot = GetCityCitizens()->GetCityPlotFromIndex(iJ);
					if (pPlot != NULL)
					{
						if (GetCityCitizens()->IsWorkingPlot(pPlot))
						{
							iCount += pPlot->getYield((YieldTypes)iI);
						}
					}
				}

				for (int iJ = 0; iJ < GC.getNumSpecialistInfos(); iJ++)
				{
					iCount += (GET_PLAYER(getOwner()).specialistYield(((SpecialistTypes)iJ), ((YieldTypes)iI)) * (GetCityCitizens()->GetSpecialistCount((SpecialistTypes)iJ)));
				}

				for (int iJ = 0; iJ < GC.getNumBuildingInfos(); iJ++)
				{
					const BuildingTypes eBuilding = static_cast<BuildingTypes>(iJ);
					CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
					if (pkBuildingInfo)
					{
						iCount += m_pCityBuildings->GetNumActiveBuilding(eBuilding) * (pkBuildingInfo->GetYieldChange(iI) + m_pCityBuildings->GetBuildingYieldChange(pkBuildingInfo->GetBuildingClassType(), (YieldTypes)iI));
					}
				}

				// Science from Population
				if ((YieldTypes)iI == YIELD_SCIENCE)
				{
					iCount += getPopulation() * /*1 in CP, 0 in VP*/ GD_INT_GET(SCIENCE_PER_POPULATION);
				}

				ASSERT_DEBUG(iCount == getBaseYieldRate((YieldTypes)iI));
			}
		}
#endif
	}
}


//	--------------------------------------------------------------------------------
bool CvCity::isCitySelected()
{
	VALIDATE_OBJECT();
	CvInterfacePtr<ICvCity1> pCity = GC.WrapCityPointer(this);

	return DLLUI->isCitySelected(pCity.get());
}


//	--------------------------------------------------------------------------------
void CvCity::updateYield(bool bRecalcPlotYields)
{
	VALIDATE_OBJECT();
	if (bRecalcPlotYields)
	{
		ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
		BeliefTypes eSecondaryPantheon = GetCityReligions()->GetSecondaryReligionPantheonBelief();
		const CvReligion* pReligion = (eMajority != NO_RELIGION) ? GC.getGame().GetGameReligions()->GetReligion(eMajority, getOwner()) : 0;
		const CvBeliefEntry* pPantheon = (eSecondaryPantheon != NO_BELIEF) ? GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon) : 0;

		//we look at all the plots we *could* work
		for (int iI = 0; iI < GetNumWorkablePlots(); iI++)
		{
			CvPlot* pLoopPlot = GetCityCitizens()->GetCityPlotFromIndex(iI);
			if (!pLoopPlot || !pLoopPlot->isEffectiveOwner(this))
				continue;

			pLoopPlot->updateYieldFast(this, pReligion, pPantheon);
		}
	}

	UpdateAllNonPlotYields(false);
}

#if defined(MOD_BALANCE_CORE)
void CvCity::UpdateAllNonPlotYields(bool bIncludePlayerHappiness)
{
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes)iI;
		if (eYield == NO_YIELD)
			continue;

		//Simplification - errata yields not worth considering.
		if ((YieldTypes)iI > YIELD_CULTURE_LOCAL && !MOD_BALANCE_CORE_JFD)
			break;

		UpdateCityYields(eYield);
		UpdateSpecialReligionYields(eYield);
	}

	//do not always update player happiness here, it's too expensive to update
	if (bIncludePlayerHappiness)
		GET_PLAYER(getOwner()).CalculateNetHappiness();

	updateNetHappiness();
}

void CvCity::UpdateCityYields(YieldTypes eYield)
{
	if (eYield == YIELD_CULTURE)
	{
		SetStaticYield(eYield, getJONSCulturePerTurn(false) * 100);
	}
	else if (eYield == YIELD_FAITH)
	{
		SetStaticYield(eYield, GetFaithPerTurn(false) * 100);
	}
	else
	{
		SetStaticYield(eYield, getYieldRateTimes100(eYield, false, false));
	}

	//don't forget tourism
	if (eYield == YIELD_CULTURE || eYield == YIELD_TOURISM)
	{
		GetCityCulture()->CalculateBaseTourismBeforeModifiers();
		GetCityCulture()->CalculateBaseTourism();
	}
}


void CvCity::SetStaticYield(YieldTypes eYield, int iValue)
{
	ASSERT_DEBUG(eYield >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eYield < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	m_aiStaticCityYield[eYield] = iValue;
}

int CvCity::GetStaticYield(YieldTypes eYield) const
{
	VALIDATE_OBJECT();
	return m_aiStaticCityYield[eYield];
}

void CvCity::SetTradePriorityLand(int iValue)
{
	m_iTradePriorityLand = iValue;
}
int CvCity::GetTradePriorityLand() const
{
	VALIDATE_OBJECT();
	return m_iTradePriorityLand;
}

void CvCity::SetTradePrioritySea(int iValue)
{
	m_iTradePrioritySea = iValue;
}
int CvCity::GetTradePrioritySea() const
{
	VALIDATE_OBJECT();
	return m_iTradePrioritySea;
}

void CvCity::ChangeTradeRouteSeaDistanceModifier(int iValue)
{
	if (iValue != 0)
	{
		m_iTradeRouteSeaDistanceModifier += iValue;
	}
}
int CvCity::GetTradeRouteSeaDistanceModifier() const
{
	VALIDATE_OBJECT();
	return m_iTradeRouteSeaDistanceModifier;
}

void CvCity::ChangeTradeRouteLandDistanceModifier(int iValue)
{
	if (iValue != 0)
	{
		m_iTradeRouteLandDistanceModifier += iValue;
	}
}
int CvCity::GetTradeRouteLandDistanceModifier() const
{
	VALIDATE_OBJECT();
	return m_iTradeRouteLandDistanceModifier;
}


//	--------------------------------------------------------------------------------
int CvCity::GetLongestPotentialTradeRoute(DomainTypes eDomain) const
{
	return GC.getGame().GetGameTrade()->GetLongestPotentialTradeRoute(GetID(), eDomain);
}
//	--------------------------------------------------------------------------------
void CvCity::SetLongestPotentialTradeRoute(int iValue, DomainTypes eDomain)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eDomain >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eDomain < NUM_DOMAIN_TYPES, "eIndex1 is expected to be within maximum bounds (invalid Index)");
	GC.getGame().GetGameTrade()->SetLongestPotentialTradeRoute(iValue, GetID(), eDomain);
}

bool CvCity::AreOurBordersTouching(PlayerTypes ePlayer)
{
	for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

		for (int jJ = 0; jJ < NUM_DIRECTION_TYPES; jJ++)
		{
			CvPlot* pAdjacentPlot = plotDirection(pLoopPlot->getX(), pLoopPlot->getY(), ((DirectionTypes)jJ));
			if (pAdjacentPlot != NULL && pAdjacentPlot->getOwner() == ePlayer)
				return true;
		}
	}
	return false;
}

//	--------------------------------------------------------------------------------
void CvCity::UpdateCachedYieldMedians()
{
	SetCachedBasicNeedsMedian(GC.getGame().GetBasicNeedsMedian());
	SetCachedGoldMedian(GC.getGame().GetGoldMedian());
	SetCachedScienceMedian(GC.getGame().GetScienceMedian());
	SetCachedCultureMedian(GC.getGame().GetCultureMedian());

	SetCachedTechNeedModifier(GET_PLAYER(getOwner()).GetTechNeedModifier());
	SetCachedEmpireSizeModifier(GetEmpireSizeModifier());

	SetYieldMediansCachedTurn(GC.getGame().getGameTurn());
}
//	--------------------------------------------------------------------------------
void CvCity::SetCachedBasicNeedsMedian(int iValue)
{
	m_iCachedBasicNeedsMedian = iValue;
}
void CvCity::SetCachedGoldMedian(int iValue)
{
	m_iCachedGoldMedian = iValue;
}
void CvCity::SetCachedScienceMedian(int iValue)
{
	m_iCachedScienceMedian = iValue;
}
void CvCity::SetCachedCultureMedian(int iValue)
{
	m_iCachedCultureMedian = iValue;
}
void CvCity::SetCachedTechNeedModifier(int iValue)
{
	m_iCachedTechNeedModifier = iValue;
}
void CvCity::SetCachedEmpireSizeModifier(int iValue)
{
	m_iCachedEmpireSizeModifier = iValue;
}
void CvCity::SetYieldMediansCachedTurn(int iTurn)
{
	m_iYieldMediansCachedTurn = iTurn;
}
//	--------------------------------------------------------------------------------
int CvCity::GetCachedBasicNeedsMedian() const
{
	return m_iCachedBasicNeedsMedian;
}
int CvCity::GetCachedGoldMedian() const
{
	return m_iCachedGoldMedian;
}
int CvCity::GetCachedScienceMedian() const
{
	return m_iCachedScienceMedian;
}
int CvCity::GetCachedCultureMedian() const
{
	return m_iCachedCultureMedian;
}
int CvCity::GetCachedTechNeedModifier() const
{
	return m_iCachedTechNeedModifier;
}
int CvCity::GetCachedEmpireSizeModifier() const
{
	return m_iCachedEmpireSizeModifier;
}
int CvCity::GetYieldMediansCachedTurn() const
{
	return m_iYieldMediansCachedTurn;
}
//	--------------------------------------------------------------------------------

int CvCity::GetHappinessFromEmpire() const
{
	VALIDATE_OBJECT();
	return m_iHappinessFromEmpire;
}
void CvCity::ChangeHappinessFromEmpire(int iValue)
{
	m_iHappinessFromEmpire += iValue;
}
void CvCity::ResetHappinessFromEmpire()
{
	m_iHappinessFromEmpire = 0;
}

void CvCity::UpdateUnhappinessFromEmpire()
{
	CvPlayer& kPlayer = GET_PLAYER(getOwner());
	if (CityStrategyAIHelpers::IsTestCityStrategy_IsPuppetAndAnnexable(this))
	{
		m_iUnhappinessFromEmpire = 0;
		return;
	}

	if (kPlayer.GetUnhappiness() == 0)
	{
		m_iUnhappinessFromEmpire = 0;
		return;
	}

	int iCities = max(1, kPlayer.GetNumRealCities());
	int iRemainder = kPlayer.GetUnhappiness() % iCities;
	int iUnhappiness = kPlayer.GetUnhappiness() / iCities;

	int iThisCityUnhappiness = 0;
	const CvCity* pLoopCity = NULL;
	int iLoop = 0;
	while (iRemainder > 0)
	{
		for (pLoopCity = kPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kPlayer.nextCity(&iLoop))
		{
			if (CityStrategyAIHelpers::IsTestCityStrategy_IsPuppetAndAnnexable(pLoopCity))
				continue;

			if (pLoopCity->GetID() == GetID())
				iThisCityUnhappiness++;

			iRemainder--;
			if (iRemainder <= 0)
				break;
		}
	}

	m_iUnhappinessFromEmpire = iUnhappiness + iThisCityUnhappiness;
}
int CvCity::GetUnhappinessFromEmpire() const
{
	VALIDATE_OBJECT();
	return m_iUnhappinessFromEmpire;
}

#endif
#if defined(MOD_BALANCE_CORE_EVENTS)
int CvCity::GetEventChoiceDuration(CityEventChoiceTypes eEventChoice) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eEventChoice >= 0, "eEvent is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eEventChoice < GC.getNumCityEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	return m_aiEventChoiceDuration[eEventChoice];
}
void CvCity::ChangeEventChoiceDuration(CityEventChoiceTypes eEventChoice, int iValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eEventChoice >= 0, "eEvent is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eEventChoice < GC.getNumCityEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	if (iValue != 0)
	{
		m_aiEventChoiceDuration[eEventChoice] = m_aiEventChoiceDuration[eEventChoice] + iValue;
	}
}
void CvCity::SetEventChoiceDuration(CityEventChoiceTypes eEventChoice, int iValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eEventChoice >= 0, "eEvent is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eEventChoice < GC.getNumCityEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	m_aiEventChoiceDuration[eEventChoice] = iValue;
}
int CvCity::GetEventIncrement(CityEventTypes eEvent) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eEvent < GC.getNumCityEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	return m_aiEventIncrement[eEvent];
}
void CvCity::IncrementEvent(CityEventTypes eEvent, int iValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eEvent < GC.getNumCityEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	if (iValue != 0)
	{
		m_aiEventIncrement[eEvent] = m_aiEventIncrement[eEvent] + iValue;
	}
}
int CvCity::GetCityEventCooldown() const
{
	VALIDATE_OBJECT();
	return m_iCityEventCooldown;
}
void CvCity::ChangeCityEventCooldown(int iValue)
{
	VALIDATE_OBJECT();
	if (iValue != 0)
	{
		m_iCityEventCooldown += iValue;
	}
}
void CvCity::ChangeEventCityYield(YieldTypes eYield, int iValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eYield >= 0, "eYield is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eYield < NUM_YIELD_TYPES, "eYield is expected to be within maximum bounds (invalid Index)");
	if (iValue != 0)
	{
		m_aiEventCityYield[eYield] = m_aiEventCityYield[eYield] + iValue;
		updateYield(false);
	}
}
int CvCity::GetEventCityYield(YieldTypes eYield) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eYield >= 0, "eYield is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eYield < NUM_YIELD_TYPES, "eYield is expected to be within maximum bounds (invalid Index)");
	return m_aiEventCityYield[eYield];
}

void CvCity::ChangeEventCityYieldModifier(YieldTypes eYield, int iValue)
{
	VALIDATE_OBJECT();
		ASSERT_DEBUG(eYield >= 0, "eYield is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eYield < NUM_YIELD_TYPES, "eYield is expected to be within maximum bounds (invalid Index)");
	if (iValue != 0)
	{
		m_aiEventCityYieldModifier[eYield] = m_aiEventCityYieldModifier[eYield] + iValue;
		updateYield(false);
	}
}
int CvCity::GetEventCityYieldModifier(YieldTypes eYield) const
{
	VALIDATE_OBJECT();
		ASSERT_DEBUG(eYield >= 0, "eYield is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eYield < NUM_YIELD_TYPES, "eYield is expected to be within maximum bounds (invalid Index)");
	return m_aiEventCityYieldModifier[eYield];
}


//	--------------------------------------------------------------------------------
int CvCity::GetEventBuildingClassCityYield(BuildingClassTypes eIndex1, YieldTypes eIndex2)	const
{
	ASSERT_DEBUG(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eIndex1 < GC.getNumBuildingClassInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	ASSERT_DEBUG(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return ModifierLookup(m_eventYields[eIndex2].forBuilding, eIndex1);
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeEventBuildingClassYield(BuildingClassTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	ASSERT_DEBUG(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eIndex1 < GC.getNumBuildingClassInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	ASSERT_DEBUG(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	SCityEventYields& y = m_eventYields[eIndex2];
	if (ModifierUpdateInsertRemove(y.forBuilding, eIndex1, iChange, true))
		updateYield(false);
}
//	--------------------------------------------------------------------------------
int CvCity::GetEventBuildingClassCityYieldModifier(BuildingClassTypes eIndex1, YieldTypes eIndex2)	const
{
	ASSERT_DEBUG(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eIndex1 < GC.getNumBuildingClassInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	ASSERT_DEBUG(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return ModifierLookup(m_eventYields[eIndex2].forBuildingModifier, eIndex1);
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeEventBuildingClassYieldModifier(BuildingClassTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	ASSERT_DEBUG(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eIndex1 < GC.getNumBuildingClassInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	ASSERT_DEBUG(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	SCityEventYields& y = m_eventYields[eIndex2];
	if (ModifierUpdateInsertRemove(y.forBuildingModifier, eIndex1, iChange, true))
		updateYield(false);
}

//	--------------------------------------------------------------------------------
int CvCity::GetEventImprovementYield(ImprovementTypes eImprovement, YieldTypes eIndex2)	const
{
	ASSERT_DEBUG(eImprovement >= 0, "eImprovement is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eImprovement < GC.getNumImprovementInfos(), "eImprovement is expected to be within maximum bounds (invalid Index)");
	ASSERT_DEBUG(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return ModifierLookup(m_eventYields[eIndex2].forImprovement, eImprovement);
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeEventImprovementYield(ImprovementTypes eImprovement, YieldTypes eIndex2, int iChange)
{
	ASSERT_DEBUG(eImprovement >= 0, "eImprovement is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eImprovement < GC.getNumImprovementInfos(), "eImprovement is expected to be within maximum bounds (invalid Index)");
	ASSERT_DEBUG(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	SCityEventYields& y = m_eventYields[eIndex2];
	if (ModifierUpdateInsertRemove(y.forImprovement, eImprovement, iChange, true))
		updateYield();
}
//	--------------------------------------------------------------------------------
int CvCity::GetEventResourceYield(ResourceTypes eResource, YieldTypes eIndex2)	const
{
	ASSERT_DEBUG(eResource >= 0, "eResource is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eResource < GC.getNumResourceInfos(), "eResource is expected to be within maximum bounds (invalid Index)");
	ASSERT_DEBUG(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return ModifierLookup(m_eventYields[eIndex2].forResource, eResource);
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeEventResourceYield(ResourceTypes eResource, YieldTypes eIndex2, int iChange)
{
	ASSERT_DEBUG(eResource >= 0, "eResource is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eResource < GC.getNumResourceInfos(), "eResource is expected to be within maximum bounds (invalid Index)");
	ASSERT_DEBUG(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	SCityEventYields& y = m_eventYields[eIndex2];
	if (ModifierUpdateInsertRemove(y.forResource, eResource, iChange, true))
		updateYield();
}

//	--------------------------------------------------------------------------------
int CvCity::GetEventSpecialistYield(SpecialistTypes eSpecialist, YieldTypes eIndex2)	const
{
	ASSERT_DEBUG(eSpecialist >= 0, "eSpecialist is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eSpecialist < GC.getNumSpecialistInfos(), "eSpecialist is expected to be within maximum bounds (invalid Index)");
	ASSERT_DEBUG(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return ModifierLookup(m_eventYields[eIndex2].forSpecialist, eSpecialist);
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeEventSpecialistYield(SpecialistTypes eSpecialist, YieldTypes eIndex2, int iChange)
{
	ASSERT_DEBUG(eSpecialist >= 0, "eSpecialist is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eSpecialist < GC.getNumSpecialistInfos(), "eSpecialist is expected to be within maximum bounds (invalid Index)");
	ASSERT_DEBUG(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	SCityEventYields& y = m_eventYields[eIndex2];
	if (ModifierUpdateInsertRemove(y.forSpecialist, eSpecialist, iChange, true))
		updateYield(false);
}

//	--------------------------------------------------------------------------------
int CvCity::GetEventTerrainYield(TerrainTypes eTerrain, YieldTypes eIndex2)	const
{
	ASSERT_DEBUG(eTerrain >= 0, "eImprovement is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eTerrain < GC.getNumTerrainInfos(), "eImprovement is expected to be within maximum bounds (invalid Index)");
	ASSERT_DEBUG(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return ModifierLookup(m_eventYields[eIndex2].forTerrain, eTerrain);
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeEventTerrainYield(TerrainTypes eTerrain, YieldTypes eIndex2, int iChange)
{
	ASSERT_DEBUG(eTerrain >= 0, "eTerrain is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eTerrain < GC.getNumTerrainInfos(), "eTerrain is expected to be within maximum bounds (invalid Index)");
	ASSERT_DEBUG(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	SCityEventYields& y = m_eventYields[eIndex2];
	if (ModifierUpdateInsertRemove(y.forTerrain, eTerrain, iChange, true))
		updateYield();
}
//	--------------------------------------------------------------------------------
int CvCity::GetEventFeatureYield(FeatureTypes eFeature, YieldTypes eIndex2)	const
{
	ASSERT_DEBUG(eFeature >= 0, "eFeature is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eFeature < GC.getNumFeatureInfos(), "eFeature is expected to be within maximum bounds (invalid Index)");
	ASSERT_DEBUG(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return ModifierLookup(m_eventYields[eIndex2].forFeature, eFeature);
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeEventFeatureYield(FeatureTypes eFeature, YieldTypes eIndex2, int iChange)
{
	ASSERT_DEBUG(eFeature >= 0, "eFeature is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eFeature < GC.getNumFeatureInfos(), "eFeature is expected to be within maximum bounds (invalid Index)");
	ASSERT_DEBUG(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	SCityEventYields& y = m_eventYields[eIndex2];
	if (ModifierUpdateInsertRemove(y.forFeature, eFeature, iChange, true))
		updateYield();
}
void CvCity::DoEvents(bool bEspionageOnly)
{
	//Minors? Barbs? Get out!
	if (!GET_PLAYER(getOwner()).isMajorCiv())
		return;

	//Event Choice Duration First - if we're in one, let's do the countdown now.
	//We need to do this first so we can cancel the event(s).
	for (int iLoop = 0; iLoop < GC.getNumCityEventChoiceInfos(); iLoop++)
	{
		CityEventChoiceTypes eEventChoice = (CityEventChoiceTypes)iLoop;
		if (eEventChoice != NO_EVENT_CHOICE_CITY)
		{
			if (GetEventChoiceDuration(eEventChoice) > 0)
			{
				ChangeEventChoiceDuration(eEventChoice, -1);
				CvModEventCityChoiceInfo* pkEventInfo = GC.getCityEventChoiceInfo(eEventChoice);
				if (pkEventInfo != NULL)
				{
					//we expire these in a special way.
					if (pkEventInfo->isCounterspyMission())
						continue;

					if (GC.getLogging())
					{

						CvString playerName;
						FILogFile* pLog = NULL;
						CvString strBaseString;
						CvString strOutBuf;
						CvString strFileName = "EventCityLogging.csv";
						playerName = getName();
						pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
						strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
						strBaseString += playerName + ", ";
						strOutBuf.Format("Event choice: %s. Cooldown Active. Changing Value by -1. Cooldown Remaining: %d", pkEventInfo->GetDescription(), GetEventChoiceDuration(eEventChoice));
						strBaseString += strOutBuf;
						pLog->Msg(strBaseString);
					}
				}
				if (GetEventChoiceDuration(eEventChoice) == 0)
				{
					DoCancelEventChoice(eEventChoice);
				}
			}
		}
	}

	if (bEspionageOnly)
		return;

	if (GetCityEventCooldown() > 0)
	{
		if (GC.getLogging())
		{
			CvString cityName = getName();
			FILogFile* pLog = NULL;
			CvString strBaseString;
			CvString strOutBuf;
			CvString strFileName = "EventCityLogging.csv";
			pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			strBaseString += cityName + ", ";
			strOutBuf.Format("City Event: Global Cooldown Active. Cooldown: %d", GetCityEventCooldown());
			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}
		ChangeCityEventCooldown(-1);
	}

	// Random Roll: Can we have a city event at all this turn?
	int iAnyEventChance = /*100*/ range(GD_INT_GET(CITY_EVENT_PROBABILITY_EACH_TURN), 0, 100);
	bool bAnyEventAllowed = iAnyEventChance == 100 || GC.getGame().randRangeInclusive(1, 100, CvSeeder::fromRaw(0xba5d02ff).mix(GetID())) <= iAnyEventChance;

	//Let's loop through all events.
	CvWeightedVector<CityEventTypes> veValidEventsThisTurn;
	vector<CityEventTypes> vValidEvents;

	for (int iLoop = 0; iLoop < GC.getNumCityEventInfos(); iLoop++)
	{
		CityEventTypes eEvent = (CityEventTypes)iLoop;
		if (eEvent == NO_EVENT_CITY)
			continue;

		CvModCityEventInfo* pkEventInfo = GC.getCityEventInfo(eEvent);
		if (pkEventInfo == NULL)
			continue;

		if (pkEventInfo->getRandomChance() == -1)
			continue;

		if (pkEventInfo->isOneShot() && IsEventFired(eEvent))
			continue;

		// Is this event on cooldown?
		if (GetEventCooldown(eEvent) > 0)
		{
			if (GetEventCooldown(eEvent) > 1)
			{
				if (GC.getLogging())
				{
					CvString cityName = getName();
					FILogFile* pLog = NULL;
					CvString strBaseString;
					CvString strOutBuf;
					CvString strFileName = "EventCityLogging.csv";
					pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
					strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
					strBaseString += cityName + ", ";
					strOutBuf.Format("City Event: %s. Cooldown Active. Cooldown: %d.", pkEventInfo->GetDescription(), GetEventCooldown(eEvent));
					strBaseString += strOutBuf;
					pLog->Msg(strBaseString);
				}
				ChangeEventCooldown(eEvent, -1);
				continue;
			}
			ChangeEventCooldown(eEvent, -1);
		}

		//Lua Hook
		if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_CityEventCanTake, getOwner(), GetID(), eEvent) == GAMEEVENTRETURN_FALSE)
			continue;

		//most expensive check last
		if (!IsCityEventValid(eEvent))
			continue;

		// Global cooldown in effect?
		if (GetCityEventCooldown() > 0 && !pkEventInfo->IgnoresGlobalCooldown())
		{
			if (pkEventInfo->getRandomChanceDelta() > 0)
			{
				IncrementEvent(eEvent, pkEventInfo->getRandomChanceDelta());

				if (GC.getLogging())
				{
					CvString cityName = getName();
					FILogFile* pLog = NULL;
					CvString strBaseString;
					CvString strOutBuf;
					CvString strFileName = "EventCityLogging.csv";
					pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
					strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
					strBaseString += cityName + ", ";
					strOutBuf.Format("Incrementing event chance for: %s, Increment: %d", pkEventInfo->GetDescription(), GetEventIncrement(eEvent));
					strBaseString += strOutBuf;
					pLog->Msg(strBaseString);
				}
			}
			continue;
		}

		vValidEvents.push_back(eEvent);
	}

	if (vValidEvents.size() > 0)
	{
		CityEventTypes eChosenEvent = NO_EVENT_CITY;

		if (bAnyEventAllowed)
		{
			// Random Roll #2: Randomly roll each event to see if it can occur
			// Probability = chance / 100
			int iHighestChance = 0;
			for (uint uLoop = 0; uLoop < vValidEvents.size(); uLoop++)
			{
				CityEventTypes eEvent = (CityEventTypes)vValidEvents[uLoop];
				CvModCityEventInfo* pkEventInfo = GC.getCityEventInfo(eEvent);
				int iChance = pkEventInfo->getRandomChance() + GetEventIncrement(eEvent);
				if (iChance > iHighestChance)
					iHighestChance = iChance;

				int iRoll = GC.getGame().randRangeInclusive(1, 100, CvSeeder::fromRaw(0x133e2161).mix(GetID()).mix(uLoop));
				if (iRoll <= iChance)
					veValidEventsThisTurn.push_back(eEvent, iChance);
			}

			if (GC.getLogging())
			{
				CvString strBaseString;
				CvString strOutBuf;
				CvString strFileName = "EventCityLogging.csv";
				CvString cityName = getName();
				FILogFile* pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				strBaseString += cityName + ", ";
				strOutBuf.Format("Found %d Events for seeding. %d of them passed the random roll. Highest Chance = %d.", vValidEvents.size(), veValidEventsThisTurn.size(), iHighestChance);
				strBaseString += strOutBuf;
				pLog->Msg(strBaseString);
			}

			if (veValidEventsThisTurn.size() > 0)
			{
				// Random Roll #3: Do a weighted choice of the event
				veValidEventsThisTurn.StableSortItems();
				eChosenEvent = veValidEventsThisTurn.ChooseByWeight(CvSeeder::fromRaw(0xf875c3cb).mix(GetID()));
				CvModCityEventInfo* pkEventInfo = GC.getCityEventInfo(eChosenEvent);
				DoStartEvent(eChosenEvent, false);
				ChangeCityEventCooldown(/*25*/ GD_INT_GET(CITY_EVENT_MIN_DURATION_BETWEEN));

				// We did it! Reset added per turn chance.
				IncrementEvent(eChosenEvent, -GetEventIncrement(eChosenEvent));
				if (GC.getLogging())
				{
					CvString strBaseString;
					CvString strOutBuf;
					CvString strFileName = "EventCityLogging.csv";
					CvString cityName = getName();
					FILogFile* pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
					strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
					strBaseString += cityName + ", ";
					strOutBuf.Format("EVENT CHOSEN: %s. Resetting event chance.", pkEventInfo->GetDescription());
					strBaseString += strOutBuf;
					pLog->Msg(strBaseString);
				}
			}
		}
		else if (GC.getLogging())
		{
			CvString strBaseString;
			CvString strOutBuf;
			CvString strFileName = "EventCityLogging.csv";
			CvString cityName = getName();
			FILogFile* pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			strBaseString += cityName + ", ";
			strOutBuf.Format("Found %d Valid Events. Failed random roll to run any events this turn.", vValidEvents.size());
			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}

		// We didn't do it? Bummer. BUT if there's a delta, the chance gets higher next turn...
		for (uint uLoop = 0; uLoop < vValidEvents.size(); uLoop++)
		{
			CityEventTypes eEvent = (CityEventTypes)vValidEvents[uLoop];
			CvModCityEventInfo* pkEventInfo = GC.getCityEventInfo(eEvent);

			if (eEvent == eChosenEvent)
				continue;

			if (pkEventInfo->getRandomChanceDelta() > 0)
			{
				IncrementEvent(eEvent, pkEventInfo->getRandomChanceDelta());
				if (GC.getLogging())
				{
					CvString strBaseString;
					CvString strOutBuf;
					CvString strFileName = "EventCityLogging.csv";
					CvString cityName = getName();
					FILogFile* pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
					strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
					strBaseString += cityName + ", ";
					strOutBuf.Format("Incrementing event chance: %s, Increment: %d", pkEventInfo->GetDescription(), GetEventIncrement(eEvent));
					strBaseString += strOutBuf;
					pLog->Msg(strBaseString);
				}
			}
		}
	}
}

void CvCity::DoStartEvent(CityEventTypes eChosenEvent, bool bSendMsg)
{
	if (eChosenEvent != NO_EVENT_CITY)
	{
		CvModCityEventInfo* pkEventInfo = GC.getCityEventInfo(eChosenEvent);
		if (pkEventInfo != NULL)
		{
			//Set true so we know we're doing an event right now.
			if (!pkEventInfo->isEspionageSetup())
			{
				SetEventActive(eChosenEvent, true);
			}

			//Set oneshot stuff so this event can't fire ever again.
			if (pkEventInfo->isOneShot())
			{
				SetEventFired(eChosenEvent, true);
			}
			//Lua Hook
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityEventActivated, getOwner(), GetID(), eChosenEvent);

			//Gamespeed.
			int iEventDuration = pkEventInfo->getCooldown();
			iEventDuration *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iEventDuration /= 100;
			ChangeEventCooldown(eChosenEvent, iEventDuration);
			if (GC.getLogging())
			{
				CvString playerName;
				FILogFile* pLog = NULL;
				CvString strBaseString;
				CvString strOutBuf;
				CvString strFileName = "EventCityLogging.csv";
				playerName = getName();
				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				strBaseString += playerName + ", ";
				strOutBuf.Format("Event started for city: %s. Cooldown: %d", pkEventInfo->GetDescription(), iEventDuration);
				strBaseString += strOutBuf;
				pLog->Msg(strBaseString);
			}
			int iNumEvent = 0;
			CityEventChoiceTypes eEventChoice = NO_EVENT_CHOICE_CITY;
			for (int iLoop = 0; iLoop < GC.getNumCityEventChoiceInfos(); iLoop++)
			{
				eEventChoice = (CityEventChoiceTypes)iLoop;
				if (eEventChoice != NO_EVENT_CHOICE_CITY)
				{
					CvModEventCityChoiceInfo* pkEventChoiceInfo = GC.getCityEventChoiceInfo(eEventChoice);
					if (pkEventChoiceInfo != NULL)
					{
						if (IsCityEventChoiceValid(eEventChoice, eChosenEvent))
						{
							iNumEvent++;
							if (pkEventInfo->getNumChoices() == 1)
							{
								DoEventChoice(eEventChoice, eChosenEvent, bSendMsg);
								if (isHuman())
								{
									CvPopupInfo kPopupInfo(BUTTONPOPUP_MODDER_7, eEventChoice, GetID(), getOwner());
									GC.GetEngineUserInterface()->AddPopup(kPopupInfo);
								}
								return;
							}
						}
					}
				}
			}
			if (iNumEvent > 0 && pkEventInfo->getNumChoices() > 1)
			{
				if (GET_PLAYER(getOwner()).isHuman())
				{
					CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
					if (pNotifications)
					{
						CvString strBuffer = GetLocalizedText("TXT_KEY_CHOOSE_EVENT_CHOICE_CITY");
						CvString strSummary = GetLocalizedText("TXT_KEY_CHOOSE_EVENT_CHOICE_CITY_TT");
						pNotifications->Add((NotificationTypes)FStringHash("NOTIFICATION_EVENT_CHOICE_CITY"), strSummary.c_str(), strBuffer.c_str(), -1, -1, eChosenEvent, GetID());
					}
				}
				else
				{
					//Lua Hook
					if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_OverrideAICityEvent, getOwner(), GetID(), eChosenEvent) == GAMEEVENTRETURN_TRUE)
					{
						return;
					}
					AI_DoEventChoice(eChosenEvent);
				}
			}
		}
	}
}
bool CvCity::IsCityEventValid(CityEventTypes eEvent)
{
	CvModCityEventInfo* pkEventInfo = GC.getCityEventInfo(eEvent);
	if (pkEventInfo == NULL)
	{
		return false;
	}

	//Lua Hook
	if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_CityEventCanActivate, getOwner(), GetID(), eEvent) == GAMEEVENTRETURN_FALSE)
	{
		return false;
	}

	EventClassTypes eEventClass = (EventClassTypes)pkEventInfo->getEventClass();
	if (eEventClass != NO_EVENT_CLASS)
	{
		if (eEventClass == EVENT_CLASS_GOOD)
		{
			if (!GC.getGame().isOption(GAMEOPTION_GOOD_EVENTS))
				return false;
		}
		else if (eEventClass == EVENT_CLASS_BAD)
		{
			if (!GC.getGame().isOption(GAMEOPTION_BAD_EVENTS))
				return false;
		}
		else if (eEventClass == EVENT_CLASS_NEUTRAL)
		{
			if (!GC.getGame().isOption(GAMEOPTION_NEUTRAL_EVENTS))
				return false;
		}
		else if (eEventClass == EVENT_CLASS_TRADE)
		{
			if (!GC.getGame().isOption(GAMEOPTION_TRADE_EVENTS))
				return false;
		}
		else if (eEventClass == EVENT_CLASS_CIV_SPECIFIC)
		{
			if (!GC.getGame().isOption(GAMEOPTION_CIV_SPECIFIC_EVENTS))
				return false;
		}
	}

	CvPlayer& kPlayer = GET_PLAYER(m_eOwner);

	//Let's do our linker checks here.
	for (int iI = 0; iI < pkEventInfo->GetNumLinkers(); iI++)
	{
		CvCityEventLinkingInfo* pLinkerInfo = pkEventInfo->GetLinkerInfo(iI);
		if (pLinkerInfo)
		{
			EventTypes eLinkerEvent = (EventTypes)pLinkerInfo->GetLinkingEvent();
			EventChoiceTypes eLinkerEventChoice = (EventChoiceTypes)pLinkerInfo->GetLinkingEventChoice();
			CityEventTypes eLinkerCityEvent = (CityEventTypes)pLinkerInfo->GetCityLinkingEvent();
			CityEventChoiceTypes eLinkerCityEventChoice = (CityEventChoiceTypes)pLinkerInfo->GetCityLinkingEventChoice();

			PlayerTypes ePlayer;
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				ePlayer = (PlayerTypes)iPlayerLoop;
				if (ePlayer == NO_PLAYER)
					continue;

				CvPlayer& kPlayer2 = GET_PLAYER(ePlayer);

				if (!pLinkerInfo->CheckOtherPlayers() && ePlayer != getOwner())
					continue;

				if (eLinkerEvent != NO_EVENT)
				{
					bool bActive = (kPlayer2.GetEventCooldown(eLinkerEvent) > 0 || kPlayer2.IsEventFired(eLinkerEvent));
					if (bActive != pLinkerInfo->CheckForActive())
						return false;
				}

				if (eLinkerEventChoice != NO_EVENT_CHOICE)
				{
					bool bActive = (kPlayer2.GetEventChoiceDuration(eLinkerEventChoice) > 0 || kPlayer2.IsEventChoiceFired(eLinkerEventChoice));
					if (bActive != pLinkerInfo->CheckForActive())
						return false;
				}

				if (eLinkerCityEvent != NO_EVENT_CITY || eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
				{
					int iLoop = 0;
					CvCity* pLoopCity = NULL;
					for (pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))
					{
						if (pLoopCity != this && pLinkerInfo->CheckOnlyActiveCity())
							continue;

						if (eLinkerCityEvent != NO_EVENT_CITY)
						{
							bool bActive = (pLoopCity->GetEventCooldown(eLinkerCityEvent) > 0 || pLoopCity->IsEventFired(eLinkerCityEvent));
							if (bActive != pLinkerInfo->CheckForActive())
								return false;
						}

						if (eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
						{
							bool bActive = (pLoopCity->GetEventChoiceDuration(eLinkerCityEventChoice) > 0 || pLoopCity->IsEventChoiceFired(eLinkerCityEventChoice));
							if (bActive != pLinkerInfo->CheckForActive())
								return false;
						}
					}
				}
			}
		}
	}

	//Let's narrow down all events here!
	if (pkEventInfo->isCapital() && !isCapital())
		return false;

	if (pkEventInfo->isCoastal() && !isCoastal())
		return false;

	if (pkEventInfo->isRiver() && !plot()->isRiver())
		return false;

	if (pkEventInfo->isRequiresGarrison() && !HasGarrison())
		return false;

	if (pkEventInfo->hasStateReligion() && kPlayer.GetReligions()->GetStateReligion(false) == NO_RELIGION)
		return false;

	if (pkEventInfo->getPrereqTech() != -1 && !GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
		return false;

	if (pkEventInfo->getObsoleteTech() != -1 && GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getObsoleteTech()))
		return false;

	if (pkEventInfo->getRequiredEra() != -1 && kPlayer.GetCurrentEra() < (EraTypes)pkEventInfo->getRequiredEra())
		return false;

	if (pkEventInfo->getObsoleteEra() != -1 && kPlayer.GetCurrentEra() >= (EraTypes)pkEventInfo->getObsoleteEra())
		return false;

	if (pkEventInfo->getMinimumPopulation() > 0 && getPopulation() < pkEventInfo->getMinimumPopulation())
		return false;

	if (pkEventInfo->isResistance() && GetResistanceTurns() <= 0)
		return false;

	if (pkEventInfo->isWLTKD() && GetWeLoveTheKingDayCounter() <= 0)
		return false;

	if (pkEventInfo->isPuppet() && !IsPuppet())
		return false;

	if (pkEventInfo->isRazing() && !IsRazing())
		return false;

	if (pkEventInfo->isOccupied() && (!IsOccupied() || IsNoOccupiedUnhappiness()))
		return false;

	if (pkEventInfo->hasAnyReligion() && GetCityReligions()->GetReligiousMajority() <= RELIGION_PANTHEON)
		return false;

	if (pkEventInfo->getRequiredCiv() != -1 && getCivilizationType() != (CivilizationTypes)pkEventInfo->getRequiredCiv())
		return false;

	if (pkEventInfo->getRequiredPolicy() != -1 && !kPlayer.GetPlayerPolicies()->HasPolicy((PolicyTypes)pkEventInfo->getRequiredPolicy()))
		return false;

	if (pkEventInfo->getRequiredIdeology() != -1 && kPlayer.GetPlayerPolicies()->GetLateGamePolicyTree() != (PolicyBranchTypes)pkEventInfo->getRequiredIdeology())
		return false;

	if (pkEventInfo->hasPlayerReligion() && kPlayer.GetReligions()->GetOwnedReligion() != GetCityReligions()->GetReligiousMajority())
		return false;

	if (pkEventInfo->lacksPlayerReligion() && kPlayer.GetReligions()->GetOwnedReligion() == GetCityReligions()->GetReligiousMajority())
		return false;

	if (pkEventInfo->hasPlayerMajority() && kPlayer.GetReligions()->GetReligionInMostCities() != GetCityReligions()->GetReligiousMajority())
		return false;

	if (pkEventInfo->lacksPlayerMajority() && kPlayer.GetReligions()->GetReligionInMostCities() == GetCityReligions()->GetReligiousMajority())
		return false;

	if (pkEventInfo->getRequiredStateReligion() != -1)
	{
		if (kPlayer.GetReligions()->GetOwnedReligion() != pkEventInfo->getRequiredStateReligion())
			return false;
	}

	if (!pkEventInfo->isRequiresHolyCity() && pkEventInfo->getRequiredReligion() != -1)
	{
		if (GetCityReligions()->GetReligiousMajority() != (ReligionTypes)pkEventInfo->getRequiredReligion())
			return false;
	}

	if (pkEventInfo->isRequiresHolyCity())
	{
		if (pkEventInfo->getRequiredReligion() != -1)
		{
			if (!GetCityReligions()->IsHolyCityForReligion((ReligionTypes)pkEventInfo->getRequiredReligion()))
				return false;
		}
		else
		{
			if (!GetCityReligions()->IsHolyCityAnyReligion())
				return false;
		}
	}
	if (pkEventInfo->isRequiresIdeology() && kPlayer.GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
		return false;

	if (pkEventInfo->isRequiresWar() && kPlayer.GetMilitaryAI()->GetNumberCivsAtWarWith(false) <= 0)
		return false;

	if (pkEventInfo->hasCityConnection() && !IsRouteToCapitalConnected())
		return false;

	if (pkEventInfo->hasTradeConnection() && !HasTradeRouteFromAnyCity() && !HasTradeRouteToAnyCity())
		return false;

	if (pkEventInfo->isNearMountain() && GetNearbyMountains() <= 0)
		return false;

	if (pkEventInfo->isNearNaturalWonder() && !HasAnyNaturalWonder())
		return false;

	if (pkEventInfo->getMaximumPopulation() != 0 && getPopulation() > pkEventInfo->getMaximumPopulation())
		return false;

	if (pkEventInfo->hasPantheon() && GetCityReligions()->GetReligiousMajority() != RELIGION_PANTHEON)
		return false;

	if (pkEventInfo->isUnhappy() && !kPlayer.IsEmpireUnhappy())
		return false;

	if (pkEventInfo->isSuperUnhappy() && !kPlayer.IsEmpireSuperUnhappy())
		return false;

	if (pkEventInfo->hasMetAnotherCiv())
	{
		if (GET_TEAM(getTeam()).getHasMetCivCount(true) <= 0)
			return false;
	}

	if (pkEventInfo->isMaster() && GET_TEAM(getTeam()).GetNumVassals() <= 0)
		return false;

	if (pkEventInfo->isVassal() && !GET_TEAM(getTeam()).IsVassalOfSomeone())
		return false;

	if (pkEventInfo->isRequiresWarMinor())
	{
		bool bHas = false;
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes)iPlayerLoop;

			// Is this a player we have relations with?
			if (GET_PLAYER(eLoopPlayer).isBarbarian())
			{
				continue;
			}
			if (!GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				continue;
			}
			if (eLoopPlayer != getOwner())
			{
				if (GET_TEAM(getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
				{
					bHas = true;
					break;
				}
			}
		}
		if (!bHas)
		{
			return false;
		}
	}

	if (pkEventInfo->getBuildingRequired() != -1)
	{
		BuildingClassTypes eBuilding = (BuildingClassTypes)pkEventInfo->getBuildingRequired();
		if (eBuilding != NO_BUILDINGCLASS)
		{
			if (GetCityBuildings()->GetNumBuildingClass(eBuilding) <= 0)
				return false;
		}
	}
	if (pkEventInfo->getBuildingLimiter() != -1)
	{
		BuildingClassTypes eBuilding = (BuildingClassTypes)pkEventInfo->getBuildingLimiter();
		if (eBuilding != NO_BUILDINGCLASS)
		{
			if (GetCityBuildings()->GetNumBuildingClass(eBuilding) > 0)
				return false;
		}
	}
	if (pkEventInfo->getRequiredImprovement() != -1)
	{
		ImprovementTypes eImprovement = (ImprovementTypes)pkEventInfo->getRequiredImprovement();
		if (eImprovement != NO_IMPROVEMENT)
		{
			if (!HasImprovement(eImprovement))
				return false;
		}
	}
	if (pkEventInfo->getLocalResourceRequired() != -1)
	{
		ResourceTypes eResource = (ResourceTypes)pkEventInfo->getLocalResourceRequired();
		if (eResource != NO_RESOURCE)
		{
			if (!HasResource(eResource))
				return false;
		}
	}
	if (pkEventInfo->hasNearbyFeature() != -1)
	{
		FeatureTypes eFeature = (FeatureTypes)pkEventInfo->hasNearbyFeature();
		if (eFeature != NO_FEATURE)
		{
			if (!IsHasFeatureLocal(eFeature))
				return false;
		}
	}
	if (pkEventInfo->hasNearbyTerrain() != -1)
	{
		TerrainTypes eTerrain = (TerrainTypes)pkEventInfo->hasNearbyTerrain();
		if (eTerrain != NO_TERRAIN)
		{
			if (!HasTerrain(eTerrain))
				return false;
		}
	}
	//Check our minimum yields - this looks at stored values, not yields per turn.
	bool bHas = true;
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes)iI;
		if (eYield == NO_YIELD)
			return false;

		int iNeededYield = pkEventInfo->getYieldMinimum(eYield);
		iNeededYield *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
		iNeededYield /= 100;
		if (pkEventInfo->isEraScaling())
		{
			int iEra = kPlayer.GetCurrentEra();
			if (iEra <= 0)
			{
				iEra = 1;
			}
			iNeededYield *= iEra;
		}

		if (iNeededYield != 0)
		{
			if (eYield == YIELD_FOOD)
			{
				if (iNeededYield > getFood())
				{
					bHas = false;
					break;
				}
			}
			if (eYield == YIELD_PRODUCTION)
			{
				if (iNeededYield > getProduction())
				{
					bHas = false;
					break;
				}
			}
			if (eYield == YIELD_GOLD)
			{
				if (iNeededYield > kPlayer.GetTreasury()->GetGold())
				{
					bHas = false;
					break;
				}
			}
			else if (eYield == YIELD_SCIENCE)
			{
				TechTypes eCurrentTech = kPlayer.GetPlayerTechs()->GetCurrentResearch();
				int iTech = 0;
				if (eCurrentTech != NO_TECH)
				{
					iTech = kPlayer.GetPlayerTechs()->GetResearchProgress(eCurrentTech);
				}
				if (iNeededYield > iTech)
				{
					bHas = false;
					break;
				}
			}
			else if (eYield == YIELD_FAITH)
			{
				if (iNeededYield > kPlayer.GetFaith())
				{
					bHas = false;
					break;
				}
			}
			else if (eYield == YIELD_GOLDEN_AGE_POINTS)
			{
				if (iNeededYield > kPlayer.GetGoldenAgeProgressMeter())
				{
					bHas = false;
					break;
				}
			}
			else if (eYield == YIELD_CULTURE)
			{
				if (iNeededYield > kPlayer.getJONSCulture())
				{
					bHas = false;
					break;
				}
			}
		}
	}
	if (!bHas)
	{
		return false;
	}

	if (pkEventInfo->isInDebt() && kPlayer.GetTreasury()->GetGold() > 0)
		return false;

	if (pkEventInfo->isLosingMoney() && kPlayer.GetTreasury()->CalculateBaseNetGold() > 0)
		return false;

	return true;
}
bool CvCity::IsCityEventChoiceValid(CityEventChoiceTypes eChosenEventChoice, CityEventTypes eParentEvent, bool bIgnoreActive, bool bIgnorePlayer)
{
	if (eChosenEventChoice == NO_EVENT_CHOICE_CITY)
		return false;

	CvModEventCityChoiceInfo* pkEventInfo = GC.getCityEventChoiceInfo(eChosenEventChoice);
	if (pkEventInfo == NULL)
	{
		return false;
	}

	if (!pkEventInfo->isParentEvent(eParentEvent))
		return false;

	CvPlayer& kPlayer = GET_PLAYER(m_eOwner);

	if (GC.getGame().isOption(GAMEOPTION_PASSIVE_ESPIONAGE) && pkEventInfo->isEspionageMission())
		return false;

	if (pkEventInfo->isCounterspyMission())
	{
		// check if a spy is already doing this
		CvPlayerEspionage* pEspionage = kPlayer.GetEspionage();
		if (pEspionage)
		{
			int iSpyID = pEspionage->GetSpyIndexInCity(this);
			if (iSpyID >= 0)
			{
				CvEspionageSpy* pSpy = pEspionage->GetSpyByID(iSpyID);
				if (pSpy && pSpy->GetSpyFocus() == eChosenEventChoice)
				{
					return false;
				}
			}
		}
	}
	else
	{
		if (!bIgnoreActive && !pkEventInfo->isEspionageMission() && !IsEventActive(eParentEvent))
			return false;
	}

	//Lua Hook
	if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_CityEventChoiceCanTake, getOwner(), GetID(), eChosenEventChoice) == GAMEEVENTRETURN_FALSE) {
		return false;
	}

	if (pkEventInfo->isOneShot() && IsEventChoiceFired(eChosenEventChoice))
		return false;

	//Event Choice already active for this event? Abort!
	if (GetEventChoiceDuration(eChosenEventChoice) > 0)
	{
		if (GC.getLogging())
		{
			CvString playerName;
			FILogFile* pLog = NULL;
			CvString strBaseString;
			CvString strOutBuf;
			CvString strFileName = "EventCityLogging.csv";
			playerName = getName();
			pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			strBaseString += playerName + ", ";
			strOutBuf.Format("Event choice already active for city, skipping: %s, Event: %s. Cooldown: %d", pkEventInfo->GetDescription(), pkEventInfo->GetDescription(), GetEventChoiceDuration(eChosenEventChoice));
			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}
		return false;
	}

	if (pkEventInfo->getMutuallyExclusiveGroup() != 0 && !bIgnoreActive)
	{
		// check for all other event choices of the same group if they are active
		for (int iLoopEventChoice = 0; iLoopEventChoice < GC.getNumCityEventChoiceInfos(); iLoopEventChoice++)
		{
			CityEventChoiceTypes eLoopEventChoice = (CityEventChoiceTypes)iLoopEventChoice;
			if (eLoopEventChoice == eChosenEventChoice)
				continue;

			CvModEventCityChoiceInfo* pkLoopEventInfo = GC.getCityEventChoiceInfo(eLoopEventChoice);
			if (pkLoopEventInfo == NULL)
				continue;

			if (pkLoopEventInfo->getMutuallyExclusiveGroup() == pkEventInfo->getMutuallyExclusiveGroup())
			{
				if (GetEventChoiceDuration(eLoopEventChoice) > 0)
				{
					return false;
				}
			}
		}
	}

	if (pkEventInfo->getSapCityTurns() > 0)
	{
		CvCityEspionage* pCityEspionage = GetCityEspionage();
		if (pCityEspionage && pCityEspionage->HasCounterSpy())
		{
			CityEventChoiceTypes eCounterSpyFocus = pCityEspionage->GetCounterSpyFocus();
			CvModEventCityChoiceInfo* pkEventChoiceInfo = GC.getCityEventChoiceInfo(eCounterSpyFocus);
			if (pkEventChoiceInfo && pkEventChoiceInfo->isCounterspyBlockSapCity())
			{
				return false;
			}
		}
	}

	//Let's do our linker checks here.
	for (int iI = 0; iI < pkEventInfo->GetNumLinkers(); iI++)
	{
		CvCityEventChoiceLinkingInfo* pLinkerInfo = pkEventInfo->GetLinkerInfo(iI);
		if (pLinkerInfo)
		{
			EventTypes eLinkerEvent = (EventTypes)pLinkerInfo->GetLinkingEvent();
			EventChoiceTypes eLinkerEventChoice = (EventChoiceTypes)pLinkerInfo->GetLinkingEventChoice();
			CityEventTypes eLinkerCityEvent = (CityEventTypes)pLinkerInfo->GetCityLinkingEvent();
			CityEventChoiceTypes eLinkerCityEventChoice = (CityEventChoiceTypes)pLinkerInfo->GetCityLinkingEventChoice();

			PlayerTypes ePlayer;
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				ePlayer = (PlayerTypes)iPlayerLoop;
				if (ePlayer == NO_PLAYER)
					continue;

				CvPlayer& kPlayer2 = GET_PLAYER(ePlayer);

				if (!pLinkerInfo->CheckOtherPlayers() && ePlayer != getOwner())
					continue;

				if (eLinkerEvent != NO_EVENT)
				{
					bool bActive = (kPlayer2.GetEventCooldown(eLinkerEvent) > 0 || kPlayer2.IsEventFired(eLinkerEvent));
					if (bActive != pLinkerInfo->CheckForActive())
						return false;
				}

				if (eLinkerEventChoice != NO_EVENT_CHOICE)
				{
					bool bActive = (kPlayer2.GetEventChoiceDuration(eLinkerEventChoice) > 0 || kPlayer2.IsEventChoiceFired(eLinkerEventChoice));
					if (bActive != pLinkerInfo->CheckForActive())
						return false;
				}

				if (eLinkerCityEvent != NO_EVENT_CITY || eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
				{
					int iLoop = 0;
					CvCity* pLoopCity = NULL;
					for (pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))
					{
						if (pLoopCity != this && pLinkerInfo->CheckOnlyActiveCity())
							continue;

						if (eLinkerCityEvent != NO_EVENT_CITY)
						{
							bool bActive = (pLoopCity->GetEventCooldown(eLinkerCityEvent) > 0 || pLoopCity->IsEventFired(eLinkerCityEvent));
							if (bActive != pLinkerInfo->CheckForActive())
								return false;
						}

						if (eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
						{
							bool bActive = (pLoopCity->GetEventChoiceDuration(eLinkerCityEventChoice) > 0 || pLoopCity->IsEventChoiceFired(eLinkerCityEventChoice));
							if (bActive != pLinkerInfo->CheckForActive())
								return false;
						}
					}
				}
			}
		}
	}

	//Let's narrow down all events here!
	if (pkEventInfo->isCapital() && !isCapital())
		return false;

	if (pkEventInfo->isCoastal() && !isCoastal())
		return false;

	if (pkEventInfo->isRiver() && !plot()->isRiver())
		return false;

	if (pkEventInfo->isResistance() && GetResistanceTurns() <= 0)
		return false;

	if (pkEventInfo->getRandomBarbs() > 0 || pkEventInfo->getRandomBarbsPerEra() > 0)
	{
		if (GC.getGame().isOption(GAMEOPTION_NO_BARBARIANS))
			return false;

		if (GC.getGame().getGameTurn() < GC.getGame().GetBarbarianReleaseTurn())
			return false;
	}

	if (pkEventInfo->isWLTKD() && GetWeLoveTheKingDayCounter() <= 0)
		return false;

	if (pkEventInfo->isPuppet() && !IsPuppet())
		return false;

	if (pkEventInfo->isNotPuppet() && IsPuppet())
		return false;

	if (pkEventInfo->isRazing() && !IsRazing())
		return false;

	if (pkEventInfo->isOccupied() && (!IsOccupied() || IsNoOccupiedUnhappiness()))
		return false;

	if (pkEventInfo->hasAnyReligion() && GetCityReligions()->GetReligiousMajority() <= RELIGION_PANTHEON)
		return false;

	if (pkEventInfo->isRequiresGarrison() && !HasGarrison())
		return false;

	if (pkEventInfo->getMinimumPopulation() > 0 && getPopulation() < pkEventInfo->getMinimumPopulation())
		return false;

	if (!pkEventInfo->isRequiresHolyCity() && pkEventInfo->getRequiredReligion() != -1)
	{
		if (GetCityReligions()->GetReligiousMajority() != (ReligionTypes)pkEventInfo->getRequiredReligion())
			return false;
	}

	if (pkEventInfo->getPillageResourceTilesChance() > 0)
	{
		bool bImprovementFound = false;
		for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
		{
			CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

			// no resource on plot
			if (pLoopPlot->getResourceType(getTeam()) == NO_RESOURCE)
				continue;

			ImprovementTypes eImprovement = pLoopPlot->getImprovementType();
			if (eImprovement == NO_IMPROVEMENT)
				continue;
			
			//connected?
			CvImprovementEntry* pImprovement = GC.getImprovementInfo(eImprovement);
			if (pImprovement && pImprovement->IsConnectsResource(pLoopPlot->getResourceType(getTeam())) && !pLoopPlot->IsImprovementPillaged())
			{
				bImprovementFound = true;
				break;
			}
		}
		if (!bImprovementFound)
			return false;
	}


	if (!bIgnorePlayer)
	{
		if (pkEventInfo->hasStateReligion() && kPlayer.GetReligions()->GetStateReligion(false) == NO_RELIGION)
			return false;

		if (pkEventInfo->getPrereqTech() != -1 && !GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
			return false;

		if (pkEventInfo->getObsoleteTech() != -1 && GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
			return false;

		if (pkEventInfo->getRequiredEra() != -1 && kPlayer.GetCurrentEra() < (EraTypes)pkEventInfo->getRequiredEra())
			return false;

		if (pkEventInfo->getObsoleteEra() != -1 && kPlayer.GetCurrentEra() >= (EraTypes)pkEventInfo->getObsoleteEra())
			return false;

		if (pkEventInfo->getRequiredCiv() != -1 && getCivilizationType() != (CivilizationTypes)pkEventInfo->getRequiredCiv())
			return false;

		if (pkEventInfo->getRequiredPolicy() != -1 && !kPlayer.GetPlayerPolicies()->HasPolicy((PolicyTypes)pkEventInfo->getRequiredPolicy()))
			return false;

		if (pkEventInfo->getRequiredIdeology() != -1 && kPlayer.GetPlayerPolicies()->GetLateGamePolicyTree() != (PolicyBranchTypes)pkEventInfo->getRequiredIdeology())
			return false;

		if (pkEventInfo->hasPlayerReligion() && kPlayer.GetReligions()->GetOwnedReligion() != GetCityReligions()->GetReligiousMajority())
			return false;

		if (pkEventInfo->lacksPlayerReligion() && kPlayer.GetReligions()->GetOwnedReligion() == GetCityReligions()->GetReligiousMajority())
			return false;

		if (pkEventInfo->hasPlayerMajority() && kPlayer.GetReligions()->GetReligionInMostCities() != GetCityReligions()->GetReligiousMajority())
			return false;

		if (pkEventInfo->lacksPlayerMajority() && kPlayer.GetReligions()->GetReligionInMostCities() == GetCityReligions()->GetReligiousMajority())
			return false;

		if (pkEventInfo->getRequiredStateReligion() != -1)
		{
			if (kPlayer.GetReligions()->GetOwnedReligion() != pkEventInfo->getRequiredStateReligion())
				return false;
		}

		if (pkEventInfo->isRequiresIdeology() && kPlayer.GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
			return false;

		if (pkEventInfo->getStealFromTreasuryPercent() > 0)
		{
			int iStealPercent = pkEventInfo->getStealFromTreasuryPercent();
			// inverse scaling with game speed
			iStealPercent *= 100;
			iStealPercent /= GC.getGame().getGameSpeedInfo().getTrainPercent();
			int iAmount = kPlayer.GetTreasury()->GetGold() * iStealPercent / 100;
			if (iAmount <= 0)
				return false;
		}

		if (pkEventInfo->isRequiresWar() && kPlayer.GetMilitaryAI()->GetNumberCivsAtWarWith(false) <= 0)
			return false;


		if (pkEventInfo->isUnhappy() && !kPlayer.IsEmpireUnhappy())
			return false;

		if (pkEventInfo->isSuperUnhappy() && !kPlayer.IsEmpireSuperUnhappy())
			return false;

		if (pkEventInfo->hasMetAnotherCiv())
		{
			if (GET_TEAM(getTeam()).getHasMetCivCount(true) <= 0)
				return false;
		}

		if (pkEventInfo->isMaster() && GET_TEAM(getTeam()).GetNumVassals() <= 0)
			return false;

		if (pkEventInfo->isVassal() && !GET_TEAM(getTeam()).IsVassalOfSomeone())
			return false;

		if (pkEventInfo->isRequiresWarMinor())
		{
			bool bHas = false;
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes)iPlayerLoop;

				// Is this a player we have relations with?
				if (GET_PLAYER(eLoopPlayer).isBarbarian())
				{
					continue;
				}
				if (!GET_PLAYER(eLoopPlayer).isMinorCiv())
				{
					continue;
				}
				if (eLoopPlayer != getOwner())
				{
					if (GET_TEAM(getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
					{
						bHas = true;
						break;
					}
				}
			}
			if (!bHas)
			{
				return false;
			}
		}
	}

	if (pkEventInfo->isRequiresHolyCity())
	{
		if (pkEventInfo->getRequiredReligion() != -1)
		{
			if (!GetCityReligions()->IsHolyCityForReligion((ReligionTypes)pkEventInfo->getRequiredReligion()))
				return false;
		}
		else
		{
			if (!GetCityReligions()->IsHolyCityAnyReligion())
				return false;
		}
	}

	if (pkEventInfo->hasCityConnection() && !IsRouteToCapitalConnected())
		return false;

	if (pkEventInfo->hasTradeConnection() && !HasTradeRouteFromAnyCity() && !HasTradeRouteToAnyCity())
		return false;

	if (pkEventInfo->isNearMountain() && GetNearbyMountains() <= 0)
		return false;

	if (pkEventInfo->isNearNaturalWonder() && !HasAnyNaturalWonder())
		return false;

	if (pkEventInfo->getMaximumPopulation() != 0 && getPopulation() > pkEventInfo->getMaximumPopulation())
		return false;

	if (pkEventInfo->hasPantheon() && GetCityReligions()->GetReligiousMajority() != RELIGION_PANTHEON)
		return false;

	if (pkEventInfo->hasNearbyFeature() != -1)
	{
		FeatureTypes eFeature = (FeatureTypes)pkEventInfo->hasNearbyFeature();
		if (eFeature != NO_FEATURE)
		{
			if (!IsHasFeatureLocal(eFeature))
				return false;
		}
	}
	if (pkEventInfo->hasNearbyTerrain() != -1)
	{
		TerrainTypes eTerrain = (TerrainTypes)pkEventInfo->hasNearbyTerrain();
		if (eTerrain != NO_TERRAIN)
		{
			if (!HasTerrain(eTerrain))
				return false;
		}
	}

	if (pkEventInfo->getBuildingRequired() != -1)
	{
		BuildingClassTypes eBuilding = (BuildingClassTypes)pkEventInfo->getBuildingRequired();
		if (eBuilding != NO_BUILDINGCLASS)
		{
			if (GetCityBuildings()->GetNumBuildingClass(eBuilding) <= 0)
				return false;
		}
	}
	if (pkEventInfo->getBuildingLimiter() != -1)
	{
		BuildingClassTypes eBuilding = (BuildingClassTypes)pkEventInfo->getBuildingLimiter();
		if (eBuilding != NO_BUILDINGCLASS)
		{
			if (GetCityBuildings()->GetNumBuildingClass(eBuilding) > 0)
				return false;
		}
	}
	if (pkEventInfo->getRequiredImprovement() != -1)
	{
		ImprovementTypes eImprovement = (ImprovementTypes)pkEventInfo->getRequiredImprovement();
		if (eImprovement != NO_IMPROVEMENT)
		{
			if (!HasImprovement(eImprovement))
				return false;
		}
	}
	if (pkEventInfo->getLocalResourceRequired() != -1)
	{
		ResourceTypes eResource = (ResourceTypes)pkEventInfo->getLocalResourceRequired();
		if (eResource != NO_RESOURCE)
		{
			if (!HasResource(eResource))
				return false;
		}
	}
	//Check our minimum yields - this looks at stored values, not yields per turn.
	bool bHas = true;
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes)iI;
		if (eYield == NO_YIELD)
			continue;

		int iNeededYield = pkEventInfo->getYieldMinimum(eYield);
		if (pkEventInfo->getPreCheckEventYield(eYield) != 0)
		{
			if (iNeededYield < pkEventInfo->getPreCheckEventYield(eYield))
			{
				iNeededYield = pkEventInfo->getPreCheckEventYield(eYield);
			}
		}
		iNeededYield *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
		iNeededYield /= 100;
		if (pkEventInfo->IsEraScaling())
		{
			int iEra = kPlayer.GetCurrentEra();
			if (iEra <= 0)
			{
				iEra = 1;
			}
			iNeededYield *= iEra;
		}
		if (iNeededYield != 0)
		{
			if (eYield == YIELD_FOOD)
			{
				if (iNeededYield > getFood())
				{
					bHas = false;
					break;
				}
			}
			if (eYield == YIELD_PRODUCTION)
			{
				if (iNeededYield > getProduction())
				{
					bHas = false;
					break;
				}
			}
			if (eYield == YIELD_GOLD)
			{
				if (iNeededYield > kPlayer.GetTreasury()->GetGold())
				{
					bHas = false;
					break;
				}
			}
			else if (eYield == YIELD_SCIENCE)
			{
				TechTypes eCurrentTech = kPlayer.GetPlayerTechs()->GetCurrentResearch();
				int iTech = 0;
				if (eCurrentTech != NO_TECH)
				{
					iTech = kPlayer.GetPlayerTechs()->GetResearchProgress(eCurrentTech);
				}
				if (iNeededYield > iTech)
				{
					bHas = false;
					break;
				}
			}
			else if (eYield == YIELD_FAITH)
			{
				if (iNeededYield > kPlayer.GetFaith())
				{
					bHas = false;
					break;
				}
			}
			else if (eYield == YIELD_GOLDEN_AGE_POINTS)
			{
				if (iNeededYield > kPlayer.GetGoldenAgeProgressMeter())
				{
					bHas = false;
					break;
				}
			}
			else if (eYield == YIELD_CULTURE)
			{
				if (iNeededYield > kPlayer.getJONSCulture())
				{
					bHas = false;
					break;
				}
			}
		}
	}
	if (!bHas)
	{
		return false;
	}

	if (pkEventInfo->isInDebt() && kPlayer.GetTreasury()->GetGold() > 0)
		return false;

	if (pkEventInfo->isLosingMoney() && kPlayer.GetTreasury()->CalculateBaseNetGold() > 0)
		return false;

	return true;
}

bool CvCity::IsCityEventChoiceValidEspionage(CityEventChoiceTypes eEventChoice, CityEventTypes eEvent, int uiSpyIndex, PlayerTypes eSpyOwner, bool bIgnoreActive, bool bIgnoreNetworkPoints)
{
	if (eSpyOwner == NO_PLAYER)
		return false;

	CvEspionageSpy* pSpy = uiSpyIndex >= 0 ? GET_PLAYER(eSpyOwner).GetEspionage()->GetSpyByID(uiSpyIndex) : NULL;

	CvModEventCityChoiceInfo* pkEventInfo = GC.getCityEventChoiceInfo(eEventChoice);
	if (pkEventInfo == NULL)
		return false;

	if (eEvent == NO_EVENT_CITY)
	{
		for (int iLoop = 0; iLoop < GC.getNumCityEventInfos(); iLoop++)
		{
			CityEventTypes eParentEvent = (CityEventTypes)iLoop;
			if (eParentEvent != NO_EVENT_CITY)
			{
				if (pkEventInfo->isParentEvent(eParentEvent))
				{
					eEvent = eParentEvent;
					break;
				}
			}
		}
	}

	if (eEvent == NO_EVENT_CITY)
		return false;

	if (pSpy && pkEventInfo->GetSpyLevelRequired() > pSpy->GetSpyRank(eSpyOwner))
		return false;

	if (!bIgnoreActive && GET_PLAYER(eSpyOwner).GetEspionage()->GetNumTurnsSpyActiveMissionsBlocked(uiSpyIndex) > 0)
		return false;

	if (!bIgnoreNetworkPoints && pkEventInfo->GetNetworkPointsNeededScaled() > 0 && GET_PLAYER(eSpyOwner).GetEspionage()->GetNetworkPointsStored(uiSpyIndex) < pkEventInfo->GetNetworkPointsNeededScaled())
		return false;

	if (pkEventInfo->getStealTech() > 0)
	{
		GET_PLAYER(eSpyOwner).GetEspionage()->BuildStealableTechList(getOwner());
		int iNumTechsWeDontHave = GET_PLAYER(eSpyOwner).GetEspionage()->GetNumTechsToSteal(getOwner());
		if (iNumTechsWeDontHave < pkEventInfo->getStealTech())
			return false;
	}

	if (pkEventInfo->getStealGW() > 0)
	{
		int iNumGWInCity = GetCityCulture()->GetNumGreatWorks();
		if (iNumGWInCity < pkEventInfo->getStealGW())
			return false;
	}

	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes)iI;
		if (eYield == NO_YIELD)
			continue;

		int iSiphonYield = pkEventInfo->getYieldSiphon(eYield);
		if (iSiphonYield <= 0)
			continue;

		int iCityYield = getYieldRate(eYield, false);
		iCityYield *= iSiphonYield;
		iCityYield /= 100;

		if (iCityYield <= 0)
		{
			return false;
		}
	}

	if (pkEventInfo->getSpecialistsGreatPersonPointsPerTurn() != 0)
	{
		if (GET_PLAYER(eSpyOwner).getCapitalCity() == NULL)
			return false;
	}

	if (!IsCityEventChoiceValid(eEventChoice, eEvent, bIgnoreActive, true))
		return false;

	if (pkEventInfo->hasStateReligion() && GET_PLAYER(eSpyOwner).GetReligions()->GetStateReligion(false) == NO_RELIGION)
		return false;

	if (pkEventInfo->getPrereqTech() != -1 && !GET_TEAM(GET_PLAYER(eSpyOwner).getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
		return false;

	if (pkEventInfo->getObsoleteTech() != -1 && GET_TEAM(GET_PLAYER(eSpyOwner).getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
		return false;

	if (pkEventInfo->getRequiredEra() != -1 && GET_PLAYER(eSpyOwner).GetCurrentEra() < (EraTypes)pkEventInfo->getRequiredEra())
		return false;

	if (pkEventInfo->getObsoleteEra() != -1 && GET_PLAYER(eSpyOwner).GetCurrentEra() >= (EraTypes)pkEventInfo->getObsoleteEra())
		return false;

	if (pkEventInfo->getRequiredCiv() != -1 && GET_PLAYER(eSpyOwner).getCivilizationType() != (CivilizationTypes)pkEventInfo->getRequiredCiv())
		return false;

	if (pkEventInfo->getRequiredPolicy() != -1 && !GET_PLAYER(eSpyOwner).GetPlayerPolicies()->HasPolicy((PolicyTypes)pkEventInfo->getRequiredPolicy()))
		return false;

	if (pkEventInfo->getRequiredIdeology() != -1 && GET_PLAYER(eSpyOwner).GetPlayerPolicies()->GetLateGamePolicyTree() != (PolicyBranchTypes)pkEventInfo->getRequiredIdeology())
		return false;

	if (pkEventInfo->hasPlayerReligion() && GET_PLAYER(eSpyOwner).GetReligions()->GetOwnedReligion() != GetCityReligions()->GetReligiousMajority())
		return false;

	if (pkEventInfo->lacksPlayerReligion() && GET_PLAYER(eSpyOwner).GetReligions()->GetOwnedReligion() == GetCityReligions()->GetReligiousMajority())
		return false;

	if (pkEventInfo->hasPlayerMajority() && GET_PLAYER(eSpyOwner).GetReligions()->GetReligionInMostCities() != GetCityReligions()->GetReligiousMajority())
		return false;

	if (pkEventInfo->lacksPlayerMajority() && GET_PLAYER(eSpyOwner).GetReligions()->GetReligionInMostCities() == GetCityReligions()->GetReligiousMajority())
		return false;

	if (pkEventInfo->getRequiredStateReligion() != -1)
	{
		if (GET_PLAYER(eSpyOwner).GetReligions()->GetOwnedReligion() != pkEventInfo->getRequiredStateReligion())
			return false;
	}

	if (pkEventInfo->isRequiresIdeology() && GET_PLAYER(eSpyOwner).GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
		return false;

	if (pkEventInfo->isRequiresWar() && GET_PLAYER(eSpyOwner).GetMilitaryAI()->GetNumberCivsAtWarWith(false) <= 0)
		return false;


	if (pkEventInfo->isUnhappy() && !GET_PLAYER(eSpyOwner).IsEmpireUnhappy())
		return false;

	if (pkEventInfo->isSuperUnhappy() && !GET_PLAYER(eSpyOwner).IsEmpireSuperUnhappy())
		return false;

	if (pkEventInfo->isEnemyUnhappy() && !GET_PLAYER(getOwner()).IsEmpireUnhappy())
		return false;

	if (pkEventInfo->isEnemySuperUnhappy() && !GET_PLAYER(getOwner()).IsEmpireSuperUnhappy())
		return false;

	if (pkEventInfo->hasMetAnotherCiv())
	{
		if (GET_TEAM(GET_PLAYER(eSpyOwner).getTeam()).getHasMetCivCount(true) <= 0)
			return false;
	}

	if (pkEventInfo->isMaster() && GET_TEAM(GET_PLAYER(eSpyOwner).getTeam()).GetNumVassals() <= 0)
		return false;

	if (pkEventInfo->isVassal() && !GET_TEAM(GET_PLAYER(eSpyOwner).getTeam()).IsVassalOfSomeone())
		return false;

	if (pkEventInfo->isRequiresWarMinor())
	{
		bool bHas = false;
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes)iPlayerLoop;

			// Is this a player we have relations with?
			if (GET_PLAYER(eLoopPlayer).isBarbarian())
			{
				continue;
			}
			if (!GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				continue;
			}
			if (eLoopPlayer != getOwner())
			{
				if (GET_TEAM(GET_PLAYER(eSpyOwner).getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
				{
					bHas = true;
					break;
				}
			}
		}
		if (!bHas)
		{
			return false;
		}
	}

	return true;
}

void CvCity::DoCancelEventChoice(CityEventChoiceTypes eChosenEventChoice)
{
	if (eChosenEventChoice == NO_EVENT_CHOICE_CITY)
		return;

	CvModEventCityChoiceInfo* pkEventChoiceInfo = GC.getCityEventChoiceInfo(eChosenEventChoice);
	if (pkEventChoiceInfo != NULL)
	{
		//Lua Hook
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityEventChoiceEnded, getOwner(), GetID(), eChosenEventChoice);
		bool bChanged = false;
		if (GC.getLogging())
		{
			CvString playerName;
			FILogFile* pLog = NULL;
			CvString strBaseString;
			CvString strOutBuf;
			CvString strFileName = "EventCityLogging.csv";
			playerName = getName();
			pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			strBaseString += playerName + ", ";
			strOutBuf.Format("Event choice ended for city: %s", pkEventChoiceInfo->GetDescription());
			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}
		//Let's make sure this is at zero.
		ChangeEventChoiceDuration(eChosenEventChoice, -GetEventChoiceDuration(eChosenEventChoice));

		//Let's only reverse if it expires, and it was active.
		if (pkEventChoiceInfo->isCounterspyMission() || (IsEventChoiceActive(eChosenEventChoice) && pkEventChoiceInfo->Expires()))
		{
			if (pkEventChoiceInfo->getEventBuilding() != -1)
			{
				BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(pkEventChoiceInfo->getEventBuilding());
				if (eBuildingClass != NO_BUILDINGCLASS)
				{
					BuildingTypes eBuildingType = GetBuildingTypeFromClass(eBuildingClass);
					if (eBuildingType != NO_BUILDING)
					{
						GetCityBuildings()->SetNumRealBuilding(eBuildingType, 0);
						bChanged = true;
					}
				}
			}

			if (pkEventChoiceInfo->getGrowthMod() != 0)
			{
				ChangeGrowthFromEvent(pkEventChoiceInfo->getGrowthMod() * -1);
			}

			if (pkEventChoiceInfo->getEventPromotion() != -1)
			{
				PromotionTypes ePromotion = (PromotionTypes)pkEventChoiceInfo->getEventPromotion();
				if (ePromotion != -1)
				{
					changeFreePromotionCount(ePromotion, -1);
				}
			}

			if (pkEventChoiceInfo->getSpecialistsGreatPersonPointsPerTurn() != 0)
			{
				ChangeEventGPPFromSpecialists(-pkEventChoiceInfo->getSpecialistsGreatPersonPointsPerTurn());
			}

			for (int iI = 0; iI < GC.getNumResourceInfos(); iI++)
			{
				ResourceTypes eResource = (ResourceTypes)iI;
				if (eResource != NO_RESOURCE)
				{
					int iBonus = pkEventChoiceInfo->getEventResourceChange(eResource);
					iBonus *= -1;
					if (iBonus != 0)
					{
						GET_PLAYER(getOwner()).changeNumResourceTotal(eResource, iBonus * -1);
					}
				}
			}
			for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				YieldTypes eYield = (YieldTypes)iI;
				if (eYield == NO_YIELD)
					continue;

				int iYieldChange = pkEventChoiceInfo->getCityYield(eYield);
				if (iYieldChange != 0)
				{
					ChangeEventCityYield(eYield, iYieldChange * -1);
				}

				int iYieldMod = pkEventChoiceInfo->getCityYieldModifier(eYield);
				if (iYieldMod != 0)
				{
					ChangeEventCityYieldModifier(eYield, iYieldMod * -1);
				}

				// Building modifiers
				for (int iJ = 0; iJ < GC.getNumBuildingClassInfos(); iJ++)
				{
					BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iJ);
					if (pkEventChoiceInfo->getBuildingClassYield(iJ, iI) != 0 || pkEventChoiceInfo->getBuildingClassYieldModifier(iJ, iI) != 0)
					{
						bChanged = true;

						ChangeEventBuildingClassYield(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYield(iJ, iI) * -1);
						ChangeEventBuildingClassYieldModifier(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(iJ, iI) * -1);

						int iNumBuildingClass = GetCityBuildings()->GetNumBuildingClass(eBuildingClass);
						ChangeBaseYieldRateFromBuildings(eYield, pkEventChoiceInfo->getBuildingClassYield(iJ, iI) * iNumBuildingClass * -1);
						changeYieldRateModifier(eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(iJ, iI) * iNumBuildingClass * -1);
					}
				}
				for (int iJ = 0; iJ < GC.getNumImprovementInfos(); iJ++)
				{
					ImprovementTypes eImprovement = (ImprovementTypes)iJ;
					if (eImprovement != NO_IMPROVEMENT && pkEventChoiceInfo->getImprovementYield(eImprovement, eYield) != 0)
					{
						ChangeEventImprovementYield(eImprovement, eYield, pkEventChoiceInfo->getImprovementYield(eImprovement, eYield) * -1);
						bChanged = true;
					}
				}
				for (int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
				{
					FeatureTypes eFeature = (FeatureTypes)iJ;
					if (eFeature != NO_FEATURE && pkEventChoiceInfo->getFeatureYield(eFeature, eYield) != 0)
					{
						ChangeEventFeatureYield(eFeature, eYield, pkEventChoiceInfo->getFeatureYield(eFeature, eYield) * -1);
						bChanged = true;
					}
				}
				for (int iJ = 0; iJ < GC.getNumTerrainInfos(); iJ++)
				{
					TerrainTypes eTerrain = (TerrainTypes)iJ;
					if (eTerrain != NO_TERRAIN && pkEventChoiceInfo->getTerrainYield(eTerrain, eYield) != 0)
					{
						ChangeEventTerrainYield(eTerrain, eYield, pkEventChoiceInfo->getTerrainYield(eTerrain, eYield) * -1);
						bChanged = true;
					}
				}
				for (int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
				{
					ResourceTypes eResource = (ResourceTypes)iJ;
					if (eResource != NO_RESOURCE && pkEventChoiceInfo->getResourceYield(eResource, eYield) != 0)
					{
						ChangeEventResourceYield(eResource, eYield, pkEventChoiceInfo->getResourceYield(eResource, eYield) * -1);
						bChanged = true;
					}
				}
				for (int iJ = 0; iJ < GC.getNumSpecialistInfos(); iJ++)
				{
					const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iJ);
					CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
					if (pkSpecialistInfo)
					{
						ChangeEventSpecialistYield(eSpecialist, eYield, pkEventChoiceInfo->getCitySpecialistYieldChange(eSpecialist, eYield) * -1);
						bChanged = true;
					}
				}
			}
			if (pkEventChoiceInfo->getCityHappiness() != 0)
			{
				ChangeEventHappiness(pkEventChoiceInfo->getCityHappiness() * -1);
				bChanged = true;
			}
			if (pkEventChoiceInfo->getReligiousPressureModifier() != 0)
			{
				for (int iI = RELIGION_PANTHEON + 1; iI < GC.GetGameReligions()->GetNumReligions(); iI++)
				{
					ReligionTypes eReligion = (ReligionTypes)iI;
					ChangeReligiousPressureModifier(eReligion, pkEventChoiceInfo->getReligiousPressureModifier() * -1);
				}
				bChanged = true;
			}
			if (pkEventChoiceInfo->getBasicNeedsMedianModifier() != 0)
			{
				ChangeBasicNeedsMedianModifier(pkEventChoiceInfo->getBasicNeedsMedianModifier() * -1);
				bChanged = true;
			}
			if (pkEventChoiceInfo->getGoldMedianModifier() != 0)
			{
				ChangeGoldMedianModifier(pkEventChoiceInfo->getGoldMedianModifier() * -1);
				bChanged = true;
			}
			if (pkEventChoiceInfo->getScienceMedianModifier() != 0)
			{
				ChangeScienceMedianModifier(pkEventChoiceInfo->getScienceMedianModifier() * -1);
				bChanged = true;
			}
			if (pkEventChoiceInfo->getCultureMedianModifier() != 0)
			{
				ChangeCultureMedianModifier(pkEventChoiceInfo->getCultureMedianModifier() * -1);
				bChanged = true;
			}
			if (pkEventChoiceInfo->getReligiousUnrestModifier() != 0)
			{
				ChangeReligiousUnrestModifier(pkEventChoiceInfo->getReligiousUnrestModifier() * -1);
				bChanged = true;
			}
			if (pkEventChoiceInfo->isCounterspyMission())
			{
				// notify other players if they have a spy in the city
				const char* szMissionText = pkEventChoiceInfo->GetHelp();
				for (int i = 0; i < MAX_CIV_PLAYERS; ++i)
				{
					const PlayerTypes eOtherPlayer = static_cast<PlayerTypes>(i);
					CvNotifications* pOtherNotifications = GET_PLAYER(eOtherPlayer).GetNotifications();
					if (pOtherNotifications)
					{
						// does the player have a spy in this city?
						CvPlayerEspionage* pOtherPlayerEspionage = GET_PLAYER(eOtherPlayer).GetEspionage();
						if (pOtherPlayerEspionage && pOtherPlayerEspionage->GetSpyIndexInCity(this) != -1)
						{
							CvEspionageSpy* pOtherSpy = pOtherPlayerEspionage->GetSpyByID(pOtherPlayerEspionage->GetSpyIndexInCity(this));
							if (pOtherSpy->GetSpyState() == SPY_STATE_GATHERING_INTEL)
							{
								CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_COUNTERSPY_ENDED", getNameKey(), szMissionText);
								CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_COUNTERSPY_ENDED_S", getNameKey());
								pOtherNotifications->Add(NOTIFICATION_SPY_YOU_STAGE_COUP_SUCCESS, strBuffer, strSummary, getX(), getY(), -1);
							}
						}
					}
				}
			}
			
			if (bChanged)
			{
				CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
				if (pNotifications && GC.getGame().getActivePlayer() == getOwner())
				{
					if (pkEventChoiceInfo->isEspionageMission())
					{
						Localization::String strMessage;
						Localization::String strSummary;
						strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_ESPIONAGE_EVENT_HAS_ENDED_CITY");
						strMessage << GetScaledSpyEffectText(eChosenEventChoice, true);
						strMessage << getNameKey();
						strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_ESPIONAGE_EVENT_HAS_ENDED_CITY_T");
						strSummary << getNameKey();

						pNotifications->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), getX(), getY(), GetID(), getOwner());
					}
					else if (!pkEventChoiceInfo->isCounterspyMission())
					{
						Localization::String strMessage;
						Localization::String strSummary;
						strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_EVENT_HAS_ENDED_CITY");
						strMessage << GetScaledHelpText(eChosenEventChoice, false, -1, NO_PLAYER, true);
						strMessage << getNameKey();
						strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_EVENT_HAS_ENDED_CITY_T");
						strSummary << getNameKey();

						pNotifications->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), getX(), getY(), GetID(), getOwner());
					}
				}
				for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
				{
					YieldTypes eYield = (YieldTypes)iI;
					if (eYield == NO_YIELD)
						continue;

					UpdateSpecialReligionYields(eYield);
					UpdateCityYields(eYield);
				}
				UpdateReligion(GetCityReligions()->GetReligiousMajority());

				GET_PLAYER(getOwner()).CalculateNetHappiness();
				updateNetHappiness();
			}
		}
		if (!pkEventChoiceInfo->isOneShot())
		{
			//Set it false here so we know the event choice is over now.
			SetEventChoiceActive(eChosenEventChoice, false);
		}
	}
}

CvString CvCity::GetScaledSpyEffectText(CityEventChoiceTypes eEventChoice, bool bSpyMissionEnd, TechTypes eTech, int iGWID, int iAmountStolen)
{
	CvString CoreYieldTip = "";
	CvModEventCityChoiceInfo* pkEventChoiceInfo = GC.getCityEventChoiceInfo(eEventChoice);
	if (pkEventChoiceInfo == NULL)
	{
		return "";
	}

	CvTechEntry* pTechEntry = NULL;
	if (eTech != NO_TECH)
	{
		pTechEntry = GC.getTechInfo(eTech);
	}

	int iNumberTip = 0;
	if (pkEventChoiceInfo->getBlockBuildingTurns() > 0)
	{
		iNumberTip = pkEventChoiceInfo->getBlockBuildingTurns();
	}
	else if (pkEventChoiceInfo->getNoTourismTurns() > 0)
	{
		iNumberTip = pkEventChoiceInfo->getNoTourismTurns();
	}
	else if (pkEventChoiceInfo->getSapCityTurns() > 0)
	{
		iNumberTip = pkEventChoiceInfo->getSapCityTurns();
	}
	else if (pkEventChoiceInfo->getStealFromTreasuryPercent() > 0)
	{
		iNumberTip = pkEventChoiceInfo->getStealFromTreasuryPercent();
		// inverse scaling with game speed
		iNumberTip *= 100;
		iNumberTip /= GC.getGame().getGameSpeedInfo().getTrainPercent();

	}

	Localization::String localizedCoreText;
	localizedCoreText = Localization::Lookup(pkEventChoiceInfo->getSpyMissionEffect());
	localizedCoreText << (pTechEntry ? pTechEntry->GetDescriptionKey() : "");
	localizedCoreText << (iGWID != -1 ? GC.getGame().GetGameCulture()->GetGreatWorkName(iGWID) : "");
	localizedCoreText << iAmountStolen;
	localizedCoreText << "";
	if (pkEventChoiceInfo->Expires() && !bSpyMissionEnd)
	{
		int iDuration = pkEventChoiceInfo->getEventDuration();
		if (pkEventChoiceInfo->isEventDurationScaling())
		{
			iDuration *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iDuration /= 100;
		}
		localizedCoreText << GetLocalizedText("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_TURNS", iDuration);
	}
	else
	{
		localizedCoreText << "";
	}
	localizedCoreText << "";
	localizedCoreText << "";
	localizedCoreText << iNumberTip;

	CoreYieldTip = localizedCoreText.toUTF8();
	return CoreYieldTip;
}


CvString CvCity::GetScaledHelpText(CityEventChoiceTypes eEventChoice, bool bYieldsOnly, int iSpyIndex, PlayerTypes eSpyOwner, bool bSpyMissionEnd)
{
	CvString CoreYieldTip = "";
	CvModEventCityChoiceInfo* pkEventChoiceInfo = GC.getCityEventChoiceInfo(eEventChoice);
	if (pkEventChoiceInfo == NULL)
	{
		return "";
	}
	Localization::String localizedCoreText;
	if (bYieldsOnly)
	{
		localizedCoreText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_CITY_HEADER");
	}
	else
	{
		localizedCoreText = Localization::Lookup(pkEventChoiceInfo->GetHelp());
	}

	int iEra = GET_PLAYER(getOwner()).GetCurrentEra();
	if (iEra <= 0)
	{
		iEra = 1;
	}

	CvString playerEventTip = "";
	CvString yieldCostTip = "";
	CvString yieldInstantTip = "";
	CvString yieldCityTip = "";
	CvString yieldSpecialistTip = "";
	CvString turnsTip = "";
	CvString spyInstantYieldTip = "";
	int iNumberTip = 0; // for spy-related turn numbers

	if (pkEventChoiceInfo->GetTriggerPlayerEventChoice() != NO_EVENT_CHOICE)
	{
		CvModEventChoiceInfo* pPlayerEvent = GC.getEventChoiceInfo(pkEventChoiceInfo->GetTriggerPlayerEventChoice());
		if (pPlayerEvent)
		{
			if (eSpyOwner != NO_PLAYER && iSpyIndex != -1)
			{
				playerEventTip += GET_PLAYER(eSpyOwner).GetScaledHelpText(pkEventChoiceInfo->GetTriggerPlayerEventChoice(), false);
			}
			else
			{
				playerEventTip += GET_PLAYER(getOwner()).GetScaledHelpText(pkEventChoiceInfo->GetTriggerPlayerEventChoice(), false);
			}
		}
	}

	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eIndex = (YieldTypes)iI;
		if (eIndex == NO_YIELD)
		{
			continue;
		}
		CvYieldInfo* pYield = GC.getYieldInfo(eIndex);
		if (pYield)
		{
			int iPreValue = pkEventChoiceInfo->getPreCheckEventYield(eIndex);
			if (pkEventChoiceInfo->IsEraScaling())
			{
				iPreValue *= iEra;
			}
			iPreValue *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
			iPreValue /= 100;
			if (iPreValue != 0)
			{
				iPreValue *= -1;
				if (!yieldCostTip.empty())
				{
					yieldCostTip += ", ";
				}
				Localization::String localizedCostText;
				if (bYieldsOnly)
				{
					localizedCostText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_SPENT");
				}
				else
				{
					localizedCostText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED");
				}
				localizedCostText << pYield->GetDescription();
				localizedCostText << pYield->getIconString();
				localizedCostText << iPreValue;

				const char* const localized = localizedCostText.toUTF8();
				if (localized)
				{
					yieldCostTip += localized;
				}
			}
			int iYieldValue = pkEventChoiceInfo->getEventYield(eIndex);
			if (iYieldValue != 0)
			{

				if (pkEventChoiceInfo->IsEraScaling())
				{
					iYieldValue *= iEra;
				}
				iYieldValue *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
				iYieldValue /= 100;
				if (iYieldValue != 0)
				{
					if (!yieldInstantTip.empty())
					{
						yieldInstantTip += ", ";
					}
					Localization::String localizedEventText;
					if (bYieldsOnly)
					{
						localizedEventText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_INSTANT");
					}
					else
					{
						localizedEventText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED");
					}
					localizedEventText << pYield->GetDescription();
					localizedEventText << pYield->getIconString();
					localizedEventText << iYieldValue;

					const char* const localized = localizedEventText.toUTF8();
					if (localized)
					{
						yieldInstantTip += localized;
					}
				}
			}

			int iCityValue = pkEventChoiceInfo->getCityYield(eIndex);
			if (iCityValue != 0)
			{
				if (!yieldCityTip.empty())
				{
					yieldCityTip += ", ";
				}

				Localization::String localizedCityText;
				if (bYieldsOnly)
				{
					localizedCityText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_CITY");
				}
				else
				{
					localizedCityText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED");
				}
				localizedCityText << pYield->GetDescription();
				localizedCityText << pYield->getIconString();
				localizedCityText << iCityValue;

				const char* const localized = localizedCityText.toUTF8();
				if (localized)
				{
					yieldCityTip += localized;
				}
			}
		}
	}
	for (int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
	{
		const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iSpecialistLoop);
		CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
		if (pkSpecialistInfo)
		{
			int iValue = pkEventChoiceInfo->getEventGPChange(eSpecialist);
			if (pkEventChoiceInfo->IsEraScaling())
			{
				iValue *= iEra;
				iValue *= GC.getGame().getGameSpeedInfo().getGreatPeoplePercent();
				iValue /= 100;
			}
			if (iValue != 0)
			{
				if (!yieldSpecialistTip.empty())
				{
					yieldSpecialistTip += ", ";
				}
				Localization::String localizedSpecialistText;
				if (bYieldsOnly)
				{
					localizedSpecialistText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_GPP");
				}
				else
				{
					localizedSpecialistText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_SPECIALIST");
				}

				CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass());
				if (pkUnitClassInfo)
				{
					localizedSpecialistText << pkUnitClassInfo->GetDescription();
					localizedSpecialistText << iValue;
				}

				const char* const localized = localizedSpecialistText.toUTF8();
				if (localized)
				{
					yieldSpecialistTip += localized;
				}
			}
		}
	}

	//Duration. Don't show event duration is this is a notification that an event has ended
	if (!bSpyMissionEnd)
	{
		int iDuration = pkEventChoiceInfo->getEventDuration();
		if (pkEventChoiceInfo->isEventDurationScaling())
		{
			iDuration *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iDuration /= 100;
		}

		if (iDuration > 0)
		{
			Localization::String localizedDurationText;
			if (bYieldsOnly)
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_TURNS");
			}
			else
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_YIELD_DURATION");
			}
			localizedDurationText << iDuration;
			const char* const localized = localizedDurationText.toUTF8();
			if (localized)
			{
				turnsTip += localized;
			}
		}
	}

	if (eSpyOwner != NO_PLAYER)
	{
		if (pkEventChoiceInfo->getStealFromTreasuryPercent() > 0)
		{
			int iStealPercent = pkEventChoiceInfo->getStealFromTreasuryPercent();
			// inverse scaling with game speed
			iStealPercent *= 100;
			iStealPercent /= GC.getGame().getGameSpeedInfo().getTrainPercent();
			int iAmount = GET_PLAYER(getOwner()).GetTreasury()->GetGold() * iStealPercent / 100;
			if (iAmount > 0)
			{
				Localization::String localizedStealTreasuryText = Localization::Lookup("TXT_KEY_ESPIONAGE_EVENT_STEAL_TREASURY_AMOUNT");
				localizedStealTreasuryText << iAmount;
				const char* const localized = localizedStealTreasuryText.toUTF8();
				if (localized)
				{
					spyInstantYieldTip += localized;
				}
			}
		}
		if (pkEventChoiceInfo->getBlockBuildingTurns() > 0)
		{
			iNumberTip = pkEventChoiceInfo->getBlockBuildingTurns();
		}
		else if (pkEventChoiceInfo->getNoTourismTurns() > 0)
		{
			iNumberTip = pkEventChoiceInfo->getNoTourismTurns();
		}
		else if (pkEventChoiceInfo->getSapCityTurns() > 0)
		{
			iNumberTip = pkEventChoiceInfo->getSapCityTurns();
		}
		else if (pkEventChoiceInfo->getStealFromTreasuryPercent() > 0)
		{
			iNumberTip = pkEventChoiceInfo->getStealFromTreasuryPercent();
			// inverse scaling with game speed
			iNumberTip *= 100;
			iNumberTip /= GC.getGame().getGameSpeedInfo().getTrainPercent();
			
		}
	}

	localizedCoreText << yieldCostTip;	
	localizedCoreText << yieldInstantTip;	
	localizedCoreText << yieldCityTip;	
	localizedCoreText << yieldSpecialistTip;
	localizedCoreText << turnsTip;
	localizedCoreText << playerEventTip;
	localizedCoreText << spyInstantYieldTip;
	localizedCoreText << iNumberTip;

	const char* const finallocalized = localizedCoreText.toUTF8();
	if (finallocalized)
	{
		CoreYieldTip = finallocalized;
	}
	return CoreYieldTip.c_str();
}
CvString CvCity::GetDisabledTooltip(CityEventChoiceTypes eChosenEventChoice, int iSpyIndex, PlayerTypes eSpyOwner)
{
	CvString DisabledTT = (iSpyIndex == -1) ? Localization::Lookup("TXT_KEY_EVENT_DISABLED_REASONS_HEADER").toUTF8() : Localization::Lookup("TXT_KEY_EO_MISSIONS_DISABLED_REASONS_HEADER").toUTF8();
	Localization::String localizedDurationText;

	if (eChosenEventChoice == NO_EVENT_CHOICE_CITY)
		return "";

	CvModEventCityChoiceInfo* pkEventInfo = GC.getCityEventChoiceInfo(eChosenEventChoice);
	if (pkEventInfo == NULL)
	{
		return "";
	}

	CvPlayer& kPlayer = GET_PLAYER(m_eOwner);

	//Lua Hook
	if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_CityEventChoiceCanTake, getOwner(), GetID(), eChosenEventChoice) == GAMEEVENTRETURN_FALSE)
	{
		CvString strOverrideText = GetLocalizedText(pkEventInfo->getDisabledTooltip());
		if (!strOverrideText.empty())
		{
			DisabledTT += strOverrideText;
		}
		else
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_DISABLED_LUA");
			DisabledTT += localizedDurationText.toUTF8();
		}
	}

	if (iSpyIndex != -1 && eSpyOwner != NO_PLAYER)
	{
		if (GC.getGame().isOption(GAMEOPTION_PASSIVE_ESPIONAGE))
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_SPY_MISSIONS_DISABLED");
			DisabledTT += localizedDurationText.toUTF8();
			return DisabledTT.c_str(); // don't show any other reasons
		}

		if (pkEventInfo->GetSpyLevelRequired() > 0)
		{
			CvEspionageSpy* pSpy = (GET_PLAYER(eSpyOwner).GetEspionage()->GetSpyByID(iSpyIndex));
			if (pSpy && pSpy->GetSpyRank(eSpyOwner) < pkEventInfo->GetSpyLevelRequired())
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_SPY_RANK");
				DisabledTT += localizedDurationText.toUTF8();
			}
		}

		if (pkEventInfo->GetNetworkPointsNeededScaled() > 0)
		{
			if (GET_PLAYER(eSpyOwner).GetEspionage()->GetNetworkPointsStored(iSpyIndex) < pkEventInfo->GetNetworkPointsNeededScaled())
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_NOT_ENOUGH_NP");
				DisabledTT += localizedDurationText.toUTF8();
			}
		}

		if (GET_PLAYER(eSpyOwner).GetEspionage()->GetNumTurnsSpyActiveMissionsBlocked(iSpyIndex) > 0)
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_RECENT_SPY_MISSION");
			DisabledTT += localizedDurationText.toUTF8();
		}

		if (pkEventInfo->getStealTech() > 0)
		{
			GET_PLAYER(eSpyOwner).GetEspionage()->BuildStealableTechList(getOwner());
			int iNumTechsWeDontHave = GET_PLAYER(eSpyOwner).GetEspionage()->GetNumTechsToSteal(getOwner());
			if (iNumTechsWeDontHave < pkEventInfo->getStealTech())
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_NO_TECH_STEAL");
				DisabledTT += localizedDurationText.toUTF8();
			}
		}

		if (pkEventInfo->getStealGW() > 0)
		{
			int iNumGWInCity = GetCityCulture()->GetNumGreatWorks();
			if (iNumGWInCity < pkEventInfo->getStealGW())
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_NO_GW_FORGE");
				DisabledTT += localizedDurationText.toUTF8();
			}
		}


		CvCity* pCity = GET_PLAYER(eSpyOwner).GetEspionage()->GetCityWithSpy(iSpyIndex);
		if (pCity)
		{
			if (pkEventInfo->isEnemyUnhappy() && !GET_PLAYER(pCity->getOwner()).IsEmpireUnhappy())
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ENEMY_UNHAPPY");
				DisabledTT += localizedDurationText.toUTF8();
			}

			if (pkEventInfo->isEnemySuperUnhappy() && !GET_PLAYER(pCity->getOwner()).IsEmpireSuperUnhappy())
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ENEMY_SUPER_UNHAPPY");
				DisabledTT += localizedDurationText.toUTF8();
			}

			for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				YieldTypes eYield = (YieldTypes)iI;
				if (eYield == NO_YIELD)
					continue;

				int iSiphonYield = pkEventInfo->getYieldSiphon(eYield);
				if (iSiphonYield <= 0)
					continue;

				int iCityYield = pCity->getYieldRate(eYield, false);
				iCityYield *= iSiphonYield;
				iCityYield /= 100;

				if (iCityYield <= 0)
				{
					if (eYield == YIELD_FAITH)
					{
						localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_MIN_SIPHON_FAITH_NOT_MET");
						DisabledTT += localizedDurationText.toUTF8();
					}
					else
					{
						localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_MIN_SIPHON_OTHER_NOT_MET");
						DisabledTT += localizedDurationText.toUTF8();
					}
					break;
				}
			}
		}
	}

	if (pkEventInfo->isOneShot() && IsEventChoiceFired(eChosenEventChoice))
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_ONESHOT");
		DisabledTT += localizedDurationText.toUTF8();
	}

	//Let's do our linker checks here.
	for (int iI = 0; iI < pkEventInfo->GetNumLinkers(); iI++)
	{
		CvCityEventChoiceLinkingInfo* pLinkerInfo = pkEventInfo->GetLinkerInfo(iI);
		if (pLinkerInfo)
		{
			EventTypes eLinkerEvent = (EventTypes)pLinkerInfo->GetLinkingEvent();
			EventChoiceTypes eLinkerEventChoice = (EventChoiceTypes)pLinkerInfo->GetLinkingEventChoice();
			CityEventTypes eLinkerCityEvent = (CityEventTypes)pLinkerInfo->GetCityLinkingEvent();
			CityEventChoiceTypes eLinkerCityEventChoice = (CityEventChoiceTypes)pLinkerInfo->GetCityLinkingEventChoice();

			PlayerTypes ePlayer;

			bool bEventFound = false;
			bool bEventChoiceFound = false;
			bool bCityEventFound = false;
			bool bCityEventChoiceFound = false;
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				ePlayer = (PlayerTypes)iPlayerLoop;
				if (ePlayer == NO_PLAYER)
					continue;

				CvPlayer& kPlayer2 = GET_PLAYER(ePlayer);

				if (!pLinkerInfo->CheckOtherPlayers() && ePlayer != getOwner())
					continue;

				if (eLinkerEvent != NO_EVENT && !bEventFound)
				{
					bool bActive = (kPlayer2.GetEventCooldown(eLinkerEvent) > 0 || kPlayer2.IsEventFired(eLinkerEvent));
					if (bActive != pLinkerInfo->CheckForActive())
					{
						if (bActive)
						{
							if (pLinkerInfo->CheckOtherPlayers())
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_EVENT_ACTIVE");
							}
							else
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ACTIVE_EVENT");
							}
						}
						else
						{
							if (pLinkerInfo->CheckOtherPlayers())
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_EVENT_NO_ACTIVE");
							}
							else
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NO_ACTIVE_PLAYER_EVENT");

							}
						}
						localizedDurationText << GC.getEventInfo(eLinkerEvent)->GetDescription();
						DisabledTT += localizedDurationText.toUTF8();
						bEventFound = true;
					}
				}

				if (eLinkerEventChoice != NO_EVENT_CHOICE && !bEventChoiceFound)
				{
					bool bActive = (kPlayer2.GetEventChoiceDuration(eLinkerEventChoice) > 0 || kPlayer2.IsEventChoiceFired(eLinkerEventChoice));
					if (bActive != pLinkerInfo->CheckForActive())
					{
						if (bActive)
						{
							if (pLinkerInfo->CheckOtherPlayers())
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_EVENT_CHOICE_ACTIVE");

							}
							else
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ACTIVE_EVENT_CHOICE");
							}
						}
						else
						{
							if (pLinkerInfo->CheckOtherPlayers())
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_NO_EVENT_CHOICE_ACTIVE");
							}
							else
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NO_ACTIVE_PLAYER_EVENT_CHOICE");
							}
						}
						localizedDurationText << GC.getEventChoiceInfo(eLinkerEventChoice)->GetDescription();
						DisabledTT += localizedDurationText.toUTF8();
						bEventChoiceFound = true;
						break;
					}
				}

				if (eLinkerCityEvent != NO_EVENT_CITY || eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
				{
					int iLoop = 0;
					CvCity* pLoopCity = NULL;
					for (pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))
					{
						if (pLoopCity != this && pLinkerInfo->CheckOnlyActiveCity())
							continue;

						if (eLinkerCityEvent != NO_EVENT_CITY && !bCityEventFound)
						{
							bool bActive = (pLoopCity->GetEventCooldown(eLinkerCityEvent) > 0 || pLoopCity->IsEventFired(eLinkerCityEvent));
							if (bActive != pLinkerInfo->CheckForActive())
							{
								if (bActive)
								{
									if (pLinkerInfo->CheckOtherPlayers())
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_CITY_EVENT_ACTIVE");
									}
									else
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ACTIVE_CITY_EVENT");
									}
								}
								else
								{
									if (pLinkerInfo->CheckOtherPlayers())
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_NO_CITY_EVENT_ACTIVE");
									}
									else
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NO_ACTIVE_CITY_EVENT");
									}
								}
								localizedDurationText << GC.getCityEventInfo(eLinkerCityEvent)->GetDescription();
								DisabledTT += localizedDurationText.toUTF8();
								bCityEventFound = true;
								break;
							}
						}

						if (!bCityEventChoiceFound && eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
						{
							bool bActive = (pLoopCity->GetEventChoiceDuration(eLinkerCityEventChoice) > 0 || pLoopCity->IsEventChoiceFired(eLinkerCityEventChoice));
							if (bActive != pLinkerInfo->CheckForActive())
							{
								if (bActive)
								{
									if (pLinkerInfo->CheckOtherPlayers())
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_CITY_EVENT_CHOICE_ACTIVE");
									}
									else
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ACTIVE_CITY_EVENT_CHOICE");
									}
								}
								else
								{
									if (pLinkerInfo->CheckOtherPlayers())
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_CITY_EVENT_CHOICE_NO_ACTIVE");
									}
									else
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NO_ACTIVE_CITY_EVENT_CHOICE");
									}
								}
								localizedDurationText << GC.getCityEventChoiceInfo(eLinkerCityEventChoice)->GetDescription();
								DisabledTT += localizedDurationText.toUTF8();
								bCityEventChoiceFound = true;
								break;
							}
						}
					}
				}
			}
		}
	}

	//Let's narrow down all events here!
	if (GetEventChoiceDuration(eChosenEventChoice) > 0)
	{
		if(pkEventInfo->isEspionageMission())
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_ESPIONAGE_EVENT_ACTIVE");
			localizedDurationText << GetEventChoiceDuration(eChosenEventChoice);
		}
		else
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_ACTIVE");
		}
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->getMutuallyExclusiveGroup() != 0)
	{
		bool bFoundEvent = false;
		int iBlockedDuration = 0;
		// check for all other event choices of the same group if they are active
		for (int iLoopEventChoice = 0; iLoopEventChoice < GC.getNumCityEventChoiceInfos(); iLoopEventChoice++)
		{
			CityEventChoiceTypes eLoopEventChoice = (CityEventChoiceTypes)iLoopEventChoice;
			if (eLoopEventChoice == eChosenEventChoice)
				continue;

			CvModEventCityChoiceInfo* pkLoopEventInfo = GC.getCityEventChoiceInfo(eLoopEventChoice);
			if (pkLoopEventInfo == NULL)
				continue;

			if (pkLoopEventInfo->getMutuallyExclusiveGroup() == pkEventInfo->getMutuallyExclusiveGroup())
			{
				if (GetEventChoiceDuration(eLoopEventChoice) > 0)
				{
					bFoundEvent = true;
					iBlockedDuration = GetEventChoiceDuration(eLoopEventChoice);
					break;
				}
			}
		}
		if (bFoundEvent)
		{
			if (pkEventInfo->isEspionageMission())
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_ESPIONAGE_EVENT_ACTIVE_RELATED");
				localizedDurationText << iBlockedDuration;
			}
			else
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_ACTIVE_RELATED");
			}
			DisabledTT += localizedDurationText.toUTF8();
		}
	}

	if (pkEventInfo->getSapCityTurns() > 0)
	{
		CvCityEspionage* pCityEspionage = GetCityEspionage();
		if (pCityEspionage && pCityEspionage->HasCounterSpy())
		{
			CityEventChoiceTypes eCounterSpyFocus = pCityEspionage->GetCounterSpyFocus();
			CvModEventCityChoiceInfo* pkEventChoiceInfo = GC.getCityEventChoiceInfo(eCounterSpyFocus);
			if (pkEventChoiceInfo && pkEventChoiceInfo->isCounterspyBlockSapCity())
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_ESPIONAGE_BLOCKED_BY_COUNTERSPY");
				DisabledTT += localizedDurationText.toUTF8();
			}
		}
	}

	if (pkEventInfo->isCapital() && !isCapital())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_BE_CAPITAL");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isCoastal() && !isCoastal())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_BE_COASTAL");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isRiver() && !plot()->isRiver())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_BE_RIVER");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isResistance() && GetResistanceTurns() <= 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_BE_RESISTANCE");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->getRandomBarbs() > 0 || pkEventInfo->getRandomBarbsPerEra() > 0)
	{
		if (GC.getGame().isOption(GAMEOPTION_NO_BARBARIANS))
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_BARBARIANS_ENABLED");
			DisabledTT += localizedDurationText.toUTF8();
		}
		else if (GC.getGame().getGameTurn() < GC.getGame().GetBarbarianReleaseTurn())
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_TOO_EARLY_FOR_BARBARIANS");
			DisabledTT += localizedDurationText.toUTF8();
		}
	}

	if (pkEventInfo->isWLTKD() && GetWeLoveTheKingDayCounter() <= 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_BE_WLTKD");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isPuppet() && !IsPuppet())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_BE_PUPPET");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isNotPuppet() && IsPuppet())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_MUST_NOT_BE_PUPPET");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isRazing() && !IsRazing())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_BE_RAZING");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isOccupied() && (!IsOccupied() || IsNoOccupiedUnhappiness()))
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_BE_OCCUPIED");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->hasAnyReligion() && GetCityReligions()->GetReligiousMajority() <= RELIGION_PANTHEON)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ANY_RELIGION");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isRequiresGarrison() && !HasGarrison())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_GARRISON");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->hasStateReligion() && kPlayer.GetReligions()->GetStateReligion(false) == NO_RELIGION)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ANY_STATE_RELIGION");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->getPrereqTech() != -1 && !GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_TECH");
		localizedDurationText << GC.getTechInfo((TechTypes)pkEventInfo->getPrereqTech())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->getObsoleteTech() != -1 && GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getObsoleteTech()))
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_OBSOLETE_TECH");
		localizedDurationText << GC.getTechInfo((TechTypes)pkEventInfo->getObsoleteTech())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->getRequiredEra() != -1 && kPlayer.GetCurrentEra() < (EraTypes)pkEventInfo->getRequiredEra())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ERA");
		localizedDurationText << GC.getEraInfo((EraTypes)pkEventInfo->getRequiredEra())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->getObsoleteEra() != -1 && kPlayer.GetCurrentEra() >= (EraTypes)pkEventInfo->getObsoleteEra())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_OBSOLETE_ERA");
		localizedDurationText << GC.getEraInfo((EraTypes)pkEventInfo->getObsoleteEra())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->getMinimumPopulation() > 0 && getPopulation() < pkEventInfo->getMinimumPopulation())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_POP_LOCAL");
		localizedDurationText << pkEventInfo->getMinimumPopulation();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->getRequiredCiv() != -1 && getCivilizationType() != (CivilizationTypes)pkEventInfo->getRequiredCiv())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_CIV");
		localizedDurationText << GC.getCivilizationInfo((CivilizationTypes)pkEventInfo->getRequiredCiv())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->getRequiredPolicy() != -1 && !kPlayer.GetPlayerPolicies()->HasPolicy((PolicyTypes)pkEventInfo->getRequiredPolicy()))
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_POLICY");
		localizedDurationText << GC.getPolicyInfo((PolicyTypes)pkEventInfo->getRequiredPolicy())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->getRequiredIdeology() != -1 && kPlayer.GetPlayerPolicies()->GetLateGamePolicyTree() != (PolicyBranchTypes)pkEventInfo->getRequiredIdeology())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_IDEOLOGY");
		localizedDurationText << GC.getPolicyBranchInfo((PolicyBranchTypes)pkEventInfo->getRequiredIdeology())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->hasPlayerReligion() && kPlayer.GetReligions()->GetOwnedReligion() != GetCityReligions()->GetReligiousMajority())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_PLAYER_RELIGION");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->lacksPlayerReligion() && kPlayer.GetReligions()->GetOwnedReligion() == GetCityReligions()->GetReligiousMajority())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NO_PLAYER_RELIGION");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->hasPlayerMajority() && kPlayer.GetReligions()->GetReligionInMostCities() != GetCityReligions()->GetReligiousMajority())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_PLAYER_MAJORITY_RELIGION");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->lacksPlayerMajority() && kPlayer.GetReligions()->GetReligionInMostCities() == GetCityReligions()->GetReligiousMajority())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NO_PLAYER_MAJORITY_RELIGION");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->getRequiredStateReligion() != -1)
	{
		if (kPlayer.GetReligions()->GetOwnedReligion() != pkEventInfo->getRequiredStateReligion())
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_SPECIFIC_STATE_RELIGION");
			localizedDurationText << GC.getReligionInfo((ReligionTypes)pkEventInfo->getRequiredStateReligion())->GetDescription();
			DisabledTT += localizedDurationText.toUTF8();
		}
	}

	if (!pkEventInfo->isRequiresHolyCity() && pkEventInfo->getRequiredReligion() != -1)
	{
		if (GetCityReligions()->GetReligiousMajority() != (ReligionTypes)pkEventInfo->getRequiredReligion())
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_SPECIFIC_RELIGION");
			localizedDurationText << GC.getReligionInfo((ReligionTypes)pkEventInfo->getRequiredReligion())->GetDescription();
			DisabledTT += localizedDurationText.toUTF8();
		}
	}

	if (pkEventInfo->isRequiresHolyCity())
	{
		if (pkEventInfo->getRequiredReligion() != -1)
		{
			if (!GetCityReligions()->IsHolyCityForReligion((ReligionTypes)pkEventInfo->getRequiredReligion()))
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_NEED_HOLY_CITY_SPECIFIC_LOCAL");
				localizedDurationText << GC.getReligionInfo((ReligionTypes)pkEventInfo->getRequiredReligion())->GetDescription();
				DisabledTT += localizedDurationText.toUTF8();
			}
		}
		else
		{
			if (!GetCityReligions()->IsHolyCityAnyReligion())
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_NEED_HOLY_CITY_LOCAL");
				DisabledTT += localizedDurationText.toUTF8();
			}
		}
	}

	if (pkEventInfo->getPillageResourceTilesChance() > 0)
	{
		int iCityID = GetID();
		bool bImprovementFound = false;
		for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
		{
			CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

			// Invalid plot or not owned by this city
			if (!pLoopPlot || pLoopPlot->getOwningCityID() != iCityID)
				continue;

			// no resource on plot
			if (pLoopPlot->getResourceType(getTeam()) == NO_RESOURCE)
				continue;

			ImprovementTypes eImprovement = pLoopPlot->getImprovementType();
			if (eImprovement == NO_IMPROVEMENT)
				continue;

			//connected?
			CvImprovementEntry* pImprovement = GC.getImprovementInfo(eImprovement);
			if (pImprovement && pImprovement->IsConnectsResource(pLoopPlot->getResourceType(getTeam())) && !pLoopPlot->IsImprovementPillaged())
			{
				bImprovementFound = true;
				break;
			}
		}
		if (!bImprovementFound)
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_RESOURCE_IMPROVEMENT");
			DisabledTT += localizedDurationText.toUTF8();
		}
	}

	if (pkEventInfo->isRequiresIdeology() && kPlayer.GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ANY_IDEOLOGY");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->getStealFromTreasuryPercent() > 0)
	{
		int iStealPercent = pkEventInfo->getStealFromTreasuryPercent();
		// inverse scaling with game speed
		iStealPercent *= 100;
		iStealPercent /= GC.getGame().getGameSpeedInfo().getTrainPercent();
		int iAmount = kPlayer.GetTreasury()->GetGold() * iStealPercent / 100;
		if (iAmount <= 0)
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NOT_ENOUGH_GOLD");
			DisabledTT += localizedDurationText.toUTF8();
		}
	}

	if (pkEventInfo->isRequiresWar() && kPlayer.GetMilitaryAI()->GetNumberCivsAtWarWith(false) <= 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_WAR_MAJOR");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->hasCityConnection() && !IsRouteToCapitalConnected())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_CITY_CONNECTION");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->hasTradeConnection() && !HasTradeRouteFromAnyCity() && !HasTradeRouteToAnyCity())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_TRADE_CONNECTION");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isNearMountain() && GetNearbyMountains() <= 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_MOUNTAIN");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isNearNaturalWonder() && !HasAnyNaturalWonder())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NATURAL_WONDER");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->getMaximumPopulation() != 0 && getPopulation() > pkEventInfo->getMaximumPopulation())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_OVER_MAX_POPULATION");
		localizedDurationText << pkEventInfo->getMaximumPopulation();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->hasPantheon() && GetCityReligions()->GetReligiousMajority() != RELIGION_PANTHEON)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ANY_PANTHEON");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isUnhappy() && !kPlayer.IsEmpireUnhappy())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_UNHAPPY");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isSuperUnhappy() && !kPlayer.IsEmpireSuperUnhappy())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_SUPER_UNHAPPY");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->hasMetAnotherCiv())
	{
		if (GET_TEAM(getTeam()).getHasMetCivCount(true) <= 0)
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_MET_OTHER_CIV");
			DisabledTT += localizedDurationText.toUTF8();
		}
	}

	if (pkEventInfo->isMaster() && GET_TEAM(getTeam()).GetNumVassals() <= 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_VASSAL");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isVassal() && !GET_TEAM(getTeam()).IsVassalOfSomeone())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_BE_VASSAL");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->hasNearbyFeature() != -1)
	{
		FeatureTypes eFeature = (FeatureTypes)pkEventInfo->hasNearbyFeature();
		if (eFeature != NO_FEATURE)
		{
			if (!IsHasFeatureLocal(eFeature))
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_NEED_FEATURE_NEARBY");
				localizedDurationText << GC.getFeatureInfo((FeatureTypes)pkEventInfo->hasNearbyFeature())->GetDescription();
				DisabledTT += localizedDurationText.toUTF8();
			}
		}
	}
	if (pkEventInfo->hasNearbyTerrain() != -1)
	{
		TerrainTypes eTerrain = (TerrainTypes)pkEventInfo->hasNearbyTerrain();
		if (eTerrain != NO_TERRAIN)
		{
			if (!HasTerrain(eTerrain))
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_NEED_TERRAIN_NEARBY");
				localizedDurationText << GC.getTerrainInfo((TerrainTypes)pkEventInfo->hasNearbyTerrain())->GetDescription();
				DisabledTT += localizedDurationText.toUTF8();
			}
		}
	}

	if (pkEventInfo->isRequiresWarMinor())
	{
		bool bHas = false;
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes)iPlayerLoop;

			// Is this a player we have relations with?
			if (GET_PLAYER(eLoopPlayer).isBarbarian())
			{
				continue;
			}
			if (!GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				continue;
			}
			if (eLoopPlayer != getOwner())
			{
				if (GET_TEAM(getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
				{
					bHas = true;
					break;
				}
			}
		}
		if (!bHas)
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_WAR_MINOR");
			DisabledTT += localizedDurationText.toUTF8();
		}
	}

	if (pkEventInfo->getBuildingRequired() != -1)
	{
		BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(pkEventInfo->getBuildingRequired());
		if (!HasBuildingClass(eBuildingClass))
		{
			CvCivilizationInfo* pkCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());
			if (pkCivilizationInfo)
			{
				BuildingTypes eBuilding = static_cast<BuildingTypes>(pkCivilizationInfo->getCivilizationBuildings(eBuildingClass));
				if (eBuilding != NO_BUILDING)
				{
					CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
					if (pkBuildingInfo)
					{
						localizedDurationText = Localization::Lookup("TXT_KEY_NEED_BUILDING_CLASS_LOCAL");
						localizedDurationText << pkBuildingInfo->GetDescription();
						DisabledTT += localizedDurationText.toUTF8();
					}
				}
			}
		}
	}
	if (pkEventInfo->getBuildingLimiter() != -1)
	{
		BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(pkEventInfo->getBuildingLimiter());
		if (HasBuildingClass(eBuildingClass))
		{
			BuildingTypes eBuilding = GetBuildingTypeFromClass(eBuildingClass);
			if (eBuilding != NO_BUILDING)
			{
				CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
				if (pkBuildingInfo)
				{
					localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NO_BUILDING_CLASS_LOCAL");
					localizedDurationText << GC.getBuildingInfo(eBuilding)->GetDescription();
					DisabledTT += localizedDurationText.toUTF8();
				}
			}
		}
	}
	if (pkEventInfo->getRequiredImprovement() != -1)
	{
		ImprovementTypes eImprovement = static_cast<ImprovementTypes>(pkEventInfo->getRequiredImprovement());
		if (!HasImprovement(eImprovement))
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_IMPROVEMENT_LOCAL");
			localizedDurationText << GC.getImprovementInfo((ImprovementTypes)pkEventInfo->getRequiredImprovement())->GetDescription();
			DisabledTT += localizedDurationText.toUTF8();
		}
	}
	if (pkEventInfo->getLocalResourceRequired() != -1)
	{
		ResourceTypes eResource = static_cast<ResourceTypes>(pkEventInfo->getLocalResourceRequired());
		if (!HasResource(eResource))
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_RESOURCE_LOCAL");
			localizedDurationText << GC.getResourceInfo((ResourceTypes)pkEventInfo->getLocalResourceRequired())->GetDescription();
			DisabledTT += localizedDurationText.toUTF8();
		}
	}

	//Check our minimum yields - this looks at stored values, not yields per turn.
	bool bHas = true;
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes)iI;
		if (eYield == NO_YIELD)
			continue;

		int iNeededYield = pkEventInfo->getYieldMinimum(eYield);
		if (pkEventInfo->getPreCheckEventYield(eYield) != 0)
		{
			if (iNeededYield < pkEventInfo->getPreCheckEventYield(eYield))
			{
				iNeededYield = pkEventInfo->getPreCheckEventYield(eYield);
			}
		}
		iNeededYield *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
		iNeededYield /= 100;
		if (pkEventInfo->IsEraScaling())
		{
			int iEra = kPlayer.GetCurrentEra();
			if (iEra <= 0)
			{
				iEra = 1;
			}
			iNeededYield *= iEra;
		}
		if (iNeededYield != 0)
		{
			if (eYield == YIELD_FOOD)
			{
				if (iNeededYield > getFood())
				{
					bHas = false;
					break;
				}
			}
			if (eYield == YIELD_PRODUCTION)
			{
				if (iNeededYield > getProduction())
				{
					bHas = false;
					break;
				}
			}
			if (eYield == YIELD_GOLD)
			{
				if (iNeededYield > kPlayer.GetTreasury()->GetGold())
				{
					bHas = false;
					break;
				}
			}
			else if (eYield == YIELD_SCIENCE)
			{
				TechTypes eCurrentTech = kPlayer.GetPlayerTechs()->GetCurrentResearch();
				int iTech = 0;
				if (eCurrentTech != NO_TECH)
				{
					iTech = kPlayer.GetPlayerTechs()->GetResearchProgress(eCurrentTech);
				}
				if (iNeededYield > iTech)
				{
					bHas = false;
					break;
				}
			}
			else if (eYield == YIELD_FAITH)
			{
				if (iNeededYield > kPlayer.GetFaith())
				{
					bHas = false;
					break;
				}
			}
			else if (eYield == YIELD_GOLDEN_AGE_POINTS)
			{
				if (iNeededYield > kPlayer.GetGoldenAgeProgressMeter())
				{
					bHas = false;
					break;
				}
			}
			else if (eYield == YIELD_CULTURE)
			{
				if (iNeededYield > kPlayer.getJONSCulture())
				{
					bHas = false;
					break;
				}
			}
		}
	}
	if (!bHas)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_YIELDS");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isInDebt() && kPlayer.GetTreasury()->GetGold() > 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_DEBT");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isLosingMoney() && kPlayer.GetTreasury()->CalculateBaseNetGold() > 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NEGATIVE_GPT");
		DisabledTT += localizedDurationText.toUTF8();
	}

	return DisabledTT.c_str();

}
void CvCity::DoEventChoice(CityEventChoiceTypes eEventChoice, CityEventTypes eCityEvent, bool bSendMsg, int iSpyID, PlayerTypes eSpyOwner)
{
	if (GC.getGame().isNetworkMultiPlayer() && bSendMsg && (GET_PLAYER(getOwner()).isHuman() || (eSpyOwner != NO_PLAYER && GET_PLAYER(eSpyOwner).isHuman()))) {
		NetMessageExt::Send::DoCityEventChoice(getOwner(), GetID(), eEventChoice, eCityEvent, iSpyID, eSpyOwner);
		return;
	}
	if (eEventChoice != NO_EVENT_CHOICE_CITY)
	{
		CvModEventCityChoiceInfo* pkEventChoiceInfo = GC.getCityEventChoiceInfo(eEventChoice);
		if (pkEventChoiceInfo != NULL)
		{
			//Set oneshot stuff so this event can't fire ever again.
			if (pkEventChoiceInfo->isOneShot())
			{
				SetEventChoiceFired(eEventChoice, true);
			}
			//Set false so we know we've completed the city event.
			//Loop through all city events and set any related to this to false, just to be sure.
			if (eCityEvent == NO_EVENT_CITY)
			{
				for (int iLoop = 0; iLoop < GC.getNumCityEventInfos(); iLoop++)
				{
					CityEventTypes eEvent = (CityEventTypes)iLoop;
					if (eEvent != NO_EVENT_CITY)
					{
						if (pkEventChoiceInfo->isParentEvent(eEvent))
						{
							SetEventActive(eEvent, false);
						}
					}
				}
			}
			else
			{
				SetEventActive(eCityEvent, false);
			}

			if (GC.getLogging())
			{
				CvString playerName;
				FILogFile* pLog = NULL;
				CvString strBaseString;
				CvString strOutBuf;
				CvString strFileName = "EventCityLogging.csv";
				playerName = getName();
				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				strBaseString += playerName + ", ";
				strOutBuf.Format("Event choice chosen by City: %s", pkEventChoiceInfo->GetDescription());
				strBaseString += strOutBuf;
				pLog->Msg(strBaseString);
			}
			//Set the cooldown for the event choice.
			if (pkEventChoiceInfo->getEventDuration() > 0)
			{
				//Gamespeed.
				int iEventDuration = pkEventChoiceInfo->getEventDuration();
				if (pkEventChoiceInfo->isEventDurationScaling())
				{
					iEventDuration *= GC.getGame().getGameSpeedInfo().getTrainPercent();
					iEventDuration /= 100;
				}
				ChangeEventChoiceDuration(eEventChoice, max(1, iEventDuration));
			}

			//Lua Hook
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityEventChoiceActivated, getOwner(), GetID(), eEventChoice);

			// apply an event to the spy owner
			EventChoiceTypes eEventChoicePlayer = pkEventChoiceInfo->GetTriggerPlayerEventChoice();
			if (eEventChoicePlayer != NO_EVENT_CHOICE)
			{
				if (eSpyOwner != NO_PLAYER && iSpyID != -1)
				{
					CvEspionageSpy* pSpy = GET_PLAYER(eSpyOwner).GetEspionage()->GetSpyByID(iSpyID);
					if (pSpy)
					{
						GET_PLAYER(eSpyOwner).DoEventChoice(eEventChoicePlayer, NO_EVENT, false, true);
					}
				}
			}

			if (eSpyOwner != NO_PLAYER && iSpyID != -1)
			{
				CvEspionageSpy* pSpy = GET_PLAYER(eSpyOwner).GetEspionage()->GetSpyByID(iSpyID);
				if (pSpy)
				{
					if (pkEventChoiceInfo->isEspionageMission())
					{
						// apply network point cost
						GetCityEspionage()->DoMission(eSpyOwner, eEventChoice);
						// this is an advanced mission. determine what happens to the spy
						GET_PLAYER(eSpyOwner).GetEspionage()->ProcessSpyMissionResult(eSpyOwner, this, iSpyID, eEventChoice);
					}
					else if (pkEventChoiceInfo->isCounterspyMission())
					{
						CityEventChoiceTypes ePreviousMission = pSpy->GetSpyFocus();
						if (ePreviousMission == eEventChoice)
						{
							return;
						}
						if (ePreviousMission != NO_EVENT_CHOICE_CITY)
						{
							DoCancelEventChoice(ePreviousMission);
						}

						pSpy->SetSpyFocus(eEventChoice);
						pSpy->SetTurnCounterspyMissionChanged(GC.getGame().getGameTurn());
						GetCityEspionage()->SetPendingEvents(eSpyOwner, 0);

						// notify other players
						const char* szMissionText = pkEventChoiceInfo->GetHelp();
						for (int i = 0; i < MAX_CIV_PLAYERS; ++i)
						{
							const PlayerTypes eOtherPlayer = static_cast<PlayerTypes>(i);
							CvNotifications* pOtherNotifications = GET_PLAYER(eOtherPlayer).GetNotifications();
							if (pOtherNotifications)
							{
								// does the player have a spy in this city?
								CvPlayerEspionage* pOtherPlayerEspionage = GET_PLAYER(eOtherPlayer).GetEspionage();
								if (pOtherPlayerEspionage && pOtherPlayerEspionage->GetSpyIndexInCity(this) != -1)
								{
									CvEspionageSpy* pOtherSpy = pOtherPlayerEspionage->GetSpyByID(pOtherPlayerEspionage->GetSpyIndexInCity(this));
									if (pOtherSpy->GetSpyState() == SPY_STATE_GATHERING_INTEL)
									{
										CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_COUNTERSPY_STARTED", getNameKey(), szMissionText);
										CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_COUNTERSPY_STARTED_S", getNameKey());
										pOtherNotifications->Add(NOTIFICATION_SPY_YOU_STAGE_COUP_SUCCESS, strBuffer, strSummary, getX(), getY(), -1);
									}
								}
							}
						}
					}
				}
			}

			//Do the cost first, as that goes through whether or not the event succeeds!
			for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				YieldTypes eYield = (YieldTypes)iI;
				if (eYield == NO_YIELD)
					continue;

				int iPassYield = pkEventChoiceInfo->getPreCheckEventYield(eYield);
				iPassYield *= -1;

				if (iPassYield != 0)
				{
					GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_INSTANT, false, NO_GREATPERSON, NO_BUILDING, iPassYield, pkEventChoiceInfo->IsEraScaling(), NO_PLAYER, NULL, true, this, false, true, true, eYield);
				}
			}

			if (eSpyOwner == NO_PLAYER || iSpyID == -1)
			{
				uint uRandom = GC.getGame().urandLimitExclusive(100, CvSeeder(getFood()));
				int iLimit = pkEventChoiceInfo->getEventChance();
				if (iLimit > 0 && static_cast<int>(uRandom) > iLimit)
				{
					//Notify if it did not work.
					CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
					if (pNotifications && GC.getGame().getActivePlayer() == getOwner())
					{
						for (int iLoop = 0; iLoop < GC.getNumCityEventInfos(); iLoop++)
						{
							CityEventTypes eEvent = (CityEventTypes)iLoop;
							if (eEvent != NO_EVENT_CITY)
							{
								if (pkEventChoiceInfo->isParentEvent(eEvent))
								{
									CvModCityEventInfo* pkEventInfo = GC.getCityEventInfo(eEvent);
									if (pkEventInfo != NULL)
									{
										Localization::String strMessage;
										Localization::String strSummary;
										strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_EVENT_FAILED_CITY");
										strMessage << pkEventChoiceInfo->GetDescription();
										strMessage << GetScaledHelpText(eEventChoice, false, -1, NO_PLAYER);
										strMessage << pkEventInfo->GetDescription();
										strMessage << getNameKey();
										strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_EVENT_FAILED_CITY_T");
										strSummary << pkEventInfo->GetDescription();
										strSummary << getNameKey();

										pNotifications->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), getX(), getY(), GetID(), getOwner());
										break;
									}
								}
							}
						}
					}
					return;
				}
			}
			//Set the event choice active if it succeeded, so we know to cancel it later.
			SetEventChoiceActive(eEventChoice, true);

			//Now do the bonuses.

			if (pkEventChoiceInfo->getStealTech() > 0 && eSpyOwner != NO_PLAYER)
			{
				GET_PLAYER(eSpyOwner).GetEspionage()->BuildStealableTechList(getOwner());
				int iNumTechsWeDontHave = GET_PLAYER(eSpyOwner).GetEspionage()->GetNumTechsToSteal(getOwner());
				if (iNumTechsWeDontHave > 0)
				{
					for (int i = 0; i < min(pkEventChoiceInfo->getStealTech(), iNumTechsWeDontHave); i++)
					{
						GET_PLAYER(eSpyOwner).GetEspionage()->DoStealTechnology(this, getOwner());
					}
				}
			}

			if (pkEventChoiceInfo->getStealGW() > 0 && eSpyOwner != NO_PLAYER)
			{
				std::vector<int> GWIDs = GET_PLAYER(eSpyOwner).GetEspionage()->BuildGWList(this);
				if (GWIDs.size() > 0)
				{
					int iNumStolen = 0;
					int iNumToSteal = pkEventChoiceInfo->getStealGW();
					while (iNumStolen < iNumToSteal && GWIDs.size() > 0)
					{
						int iGrab = GC.getGame().randRangeInclusive(0, GWIDs.size() - 1, CvSeeder::fromRaw(0xd3270c47).mix(GET_PLAYER(eSpyOwner).GetID()).mix(GetID()).mix(GET_PLAYER(eSpyOwner).GetEspionage()->m_aiNumSpyActionsDone[getOwner()]));
						GET_PLAYER(eSpyOwner).GetEspionage()->DoStealGW(this, GWIDs[iGrab]);
						GWIDs.erase(GWIDs.begin() + iGrab);
						iNumStolen++;
					}
				}
			}

			if (pkEventChoiceInfo->getStealFromTreasuryPercent() != 0 && eSpyOwner != NO_PLAYER)
			{
				int iStealPercent = pkEventChoiceInfo->getStealFromTreasuryPercent();
				// inverse scaling with game speed
				iStealPercent *= 100;
				iStealPercent /= GC.getGame().getGameSpeedInfo().getTrainPercent();
				int iAmountStolen = GET_PLAYER(m_eOwner).GetTreasury()->GetGold() * iStealPercent / 100;
				GET_PLAYER(m_eOwner).GetTreasury()->ChangeGold(-iAmountStolen);
				GET_PLAYER(eSpyOwner).GetTreasury()->ChangeGold(iAmountStolen);
				GET_PLAYER(m_eOwner).GetEspionage()->UpdateSpyMessage(getX(), getY(), eSpyOwner, NO_TECH, iAmountStolen);
			}

			if (pkEventChoiceInfo->getSapCityTurns() != 0)
			{
				int iTurns = pkEventChoiceInfo->getSapCityTurns();
				ChangeSappedTurns(iTurns);
			}
			if (pkEventChoiceInfo->getNoTourismTurns() != 0)
			{
				int iTurns = pkEventChoiceInfo->getNoTourismTurns();
				ChangeNoTourismTurns(iTurns);
			}
			if (pkEventChoiceInfo->getGrowthMod() != 0)
			{
				ChangeGrowthFromEvent(pkEventChoiceInfo->getGrowthMod());
			}

			if (pkEventChoiceInfo->getEventPromotion() != -1)
			{
				PromotionTypes ePromotion = (PromotionTypes)pkEventChoiceInfo->getEventPromotion();
				if (ePromotion != -1)
				{
					changeFreePromotionCount(ePromotion, 1);
				}
			}
			for (int iI = 0; iI < GC.getNumResourceInfos(); iI++)
			{
				ResourceTypes eResource = (ResourceTypes)iI;
				if (eResource != NO_RESOURCE)
				{
					int iBonus = pkEventChoiceInfo->getEventResourceChange(eResource);
					if (iBonus != 0)
					{
						GET_PLAYER(getOwner()).changeNumResourceTotal(eResource, iBonus);
					}
				}
			}
			if (pkEventChoiceInfo->getEventBuilding() != -1)
			{
				BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventChoiceInfo->getEventBuilding();
				if (eBuildingClass != NO_BUILDINGCLASS)
				{
					const CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);

					if (pkBuildingClassInfo)
					{
						CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());

						if (pCivilizationInfo != NULL)
						{
							if (!HasBuildingClass(eBuildingClass))
							{
								BuildingTypes eBuildingType = (BuildingTypes)pCivilizationInfo->getCivilizationBuildings(eBuildingClass);
								if (eBuildingType != NO_BUILDING)
								{
									GetCityBuildings()->SetNumRealBuilding(eBuildingType, 1, true);
								}
							}
						}
					}
				}
			}
			if (pkEventChoiceInfo->getEventBuildingDestruction() != -1)
			{
				BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(pkEventChoiceInfo->getEventBuildingDestruction());
				if (eBuildingClass != NO_BUILDINGCLASS)
				{
					BuildingTypes eBuilding = GetBuildingTypeFromClass(eBuildingClass);
					if (eBuilding != NO_BUILDING)
					{
						GetCityBuildings()->SetNumRealBuilding(eBuilding, 0, true);
					}
				}
			}

			for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
			{
				BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iI);
				if (eBuildingClass == NO_BUILDINGCLASS)
					continue;

				if (GetCityBuildings()->GetNumBuildingClass(eBuildingClass) <= 0)
					continue;

				const CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
				if (!pkBuildingClassInfo)
					continue;

				int iChance = pkEventChoiceInfo->getBuildingDestructionChance(iI);
				if (pkEventChoiceInfo->getCityWideDestructionChance() > iChance)
				{
					if (pkBuildingClassInfo->getMaxGlobalInstances() != -1)
						continue;

					if (pkBuildingClassInfo->getMaxPlayerInstances() != -1)
						continue;

					iChance = pkEventChoiceInfo->getCityWideDestructionChance();
				}

				if (iChance <= 0)
					continue;

				BuildingTypes eBuilding = GetBuildingTypeFromClass(eBuildingClass);
				if (eBuilding != NO_BUILDING)
				{
					CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
					if (!pkBuildingInfo)
						continue;

					if (pkBuildingInfo->IsNukeImmune() || pkBuildingInfo->IsDummy())
						continue;

					int iRandom = GC.getGame().getJonRandNum(100, "Random Event Chance");
					if (iRandom < iChance)
					{
						GetCityBuildings()->SetNumRealBuilding(eBuilding, 0, true);
						if (getOwner() == GC.getGame().getActivePlayer())
						{
							CvString strBuffer = GetLocalizedText("TXT_KEY_MISC_BUILDING_DESTROYED_EVENT", pkBuildingInfo->GetTextKey(), getNameKey());
							GC.GetEngineUserInterface()->AddCityMessage(0, GetIDInfo(), getOwner(), false, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), strBuffer);
						}
					}
				}
			}
			for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				YieldTypes eYield = (YieldTypes)iI;
				if (eYield == NO_YIELD)
					continue;

				int iYieldChange = pkEventChoiceInfo->getCityYield(eYield);
				if (iYieldChange != 0)
				{
					ChangeEventCityYield(eYield, iYieldChange);
				}

				int iYieldMod = pkEventChoiceInfo->getCityYieldModifier(eYield);
				if (iYieldMod != 0)
				{
					ChangeEventCityYieldModifier(eYield, iYieldMod);
				}

				// Building modifiers
				for (int iJ = 0; iJ < GC.getNumBuildingClassInfos(); iJ++)
				{
					BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iJ);
					if (pkEventChoiceInfo->getBuildingClassYield(iJ, iI) != 0 || pkEventChoiceInfo->getBuildingClassYieldModifier(iJ, iI) != 0)
					{
						ChangeEventBuildingClassYield(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYield(iJ, iI));
						ChangeEventBuildingClassYieldModifier(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(iJ, iI));

						int iNumBuildingClass = GetCityBuildings()->GetNumBuildingClass(eBuildingClass);
						ChangeBaseYieldRateFromBuildings(eYield, pkEventChoiceInfo->getBuildingClassYield(iJ, iI) * iNumBuildingClass);
						changeYieldRateModifier(eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(iJ, iI) * iNumBuildingClass);
					}
				}

				int iPassYield = pkEventChoiceInfo->getEventYield(eYield);
				if (iPassYield != 0)
				{
					GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_INSTANT, false, NO_GREATPERSON, NO_BUILDING, iPassYield, pkEventChoiceInfo->IsEraScaling(), NO_PLAYER, NULL, true, this, false, true, true, eYield);
				}
				int iSiphonYield = pkEventChoiceInfo->getYieldSiphon(eYield);
				if (iSiphonYield > 0)
				{
					CvEspionageSpy* pSpy = GET_PLAYER(eSpyOwner).GetEspionage()->GetSpyByID(iSpyID);
					if (pSpy)
					{
						int iAmount = getYieldRate(eYield, false) * iSiphonYield / 100;
						int iEffectDuration = pkEventChoiceInfo->getEventDuration();
						if (pkEventChoiceInfo->isEventDurationScaling())
						{
							iEffectDuration *= GC.getGame().getGameSpeedInfo().getTrainPercent();
							iEffectDuration /= 100;
						}

						GET_PLAYER(eSpyOwner).AddEspionageEvent(getOwner(), true, GC.getGame().getGameTurn(), GC.getGame().getGameTurn() + iEffectDuration, eYield, iAmount);

						//int iTurnIncrease = (getOwner() < eSpyOwner) ? 1 : 0; // if the targeted player plays his turns before the spy owner, start and end turn numbers needs to be increased by 1 because in the current turn the effect isn't yet active for the targeted player
						int iTurnIncrease = 0;
						GET_PLAYER(getOwner()).AddEspionageEvent(eSpyOwner, false, GC.getGame().getGameTurn() + iTurnIncrease, GC.getGame().getGameTurn() + iEffectDuration + iTurnIncrease, eYield, iAmount);

						if (GC.getLogging())
						{
							CvString strMsg;
							strMsg.Format("Siphoning %d Yield per Turn for Spy Event! %d, ", (int)eYield, iAmount);
							strMsg += GetLocalizedText(pSpy->GetSpyName(&GET_PLAYER(eSpyOwner)));
							GET_PLAYER(eSpyOwner).GetEspionage()->LogEspionageMsg(strMsg);
						}
					}
				}

				for (int iJ = 0; iJ < GC.getNumImprovementInfos(); iJ++)
				{
					ImprovementTypes eImprovement = (ImprovementTypes)iJ;
					if (eImprovement != NO_IMPROVEMENT && pkEventChoiceInfo->getImprovementYield(eImprovement, eYield) != 0)
					{
						ChangeEventImprovementYield(eImprovement, eYield, pkEventChoiceInfo->getImprovementYield(eImprovement, eYield));
					}
				}
				for (int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
				{
					FeatureTypes eFeature = (FeatureTypes)iJ;
					if (eFeature != NO_FEATURE && pkEventChoiceInfo->getFeatureYield(eFeature, eYield) != 0)
					{
						ChangeEventFeatureYield(eFeature, eYield, pkEventChoiceInfo->getFeatureYield(eFeature, eYield));
					}
				}
				for (int iJ = 0; iJ < GC.getNumTerrainInfos(); iJ++)
				{
					TerrainTypes eTerrain = (TerrainTypes)iJ;
					if (eTerrain != NO_TERRAIN && pkEventChoiceInfo->getTerrainYield(eTerrain, eYield) != 0)
					{
						ChangeEventTerrainYield(eTerrain, eYield, pkEventChoiceInfo->getTerrainYield(eTerrain, eYield));
					}
				}
				for (int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
				{
					ResourceTypes eResource = (ResourceTypes)iJ;
					if (eResource != NO_RESOURCE && pkEventChoiceInfo->getResourceYield(eResource, eYield) != 0)
					{
						ChangeEventResourceYield(eResource, eYield, pkEventChoiceInfo->getResourceYield(eResource, eYield));
					}
				}
				for (int iJ = 0; iJ < GC.getNumSpecialistInfos(); iJ++)
				{
					const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iJ);
					CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
					if (pkSpecialistInfo)
					{
						ChangeEventSpecialistYield(eSpecialist, eYield, pkEventChoiceInfo->getCitySpecialistYieldChange(eSpecialist, eYield));
					}
				}
			}
			for (int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
			{
				const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iSpecialistLoop);
				CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
				if (pkSpecialistInfo)
				{
					int iBonus = pkEventChoiceInfo->getEventGPChange(eSpecialist);
					if (pkEventChoiceInfo->IsEraScaling())
					{
						int iEra = GET_PLAYER(getOwner()).GetCurrentEra();
						if (iEra <= 0)
						{
							iEra = 1;
						}
						iBonus *= iEra;
						iBonus *= GC.getGame().getGameSpeedInfo().getGreatPeoplePercent();
						iBonus /= 100;
					}
					if (iBonus != 0)
					{
						if (iBonus < 0)
						{
							int iMinimum = GetCityCitizens()->GetSpecialistGreatPersonProgressTimes100(eSpecialist) / 100;
							if ((iBonus * -1) > iMinimum)
								iBonus = (iMinimum * -1);
						}
						GetCityCitizens()->ChangeSpecialistGreatPersonProgressTimes100(eSpecialist, iBonus * 100, true);
					}
				}
			}

			typedef CvWeightedVector<CvPlot*> WeightedPlotVector;
			WeightedPlotVector aBestPlots;
			for (int iI = 0; iI < GC.getNumImprovementInfos(); iI++)
			{
				ImprovementTypes eImprovement = (ImprovementTypes)iI;
				if (eImprovement != NO_IMPROVEMENT && pkEventChoiceInfo->getImprovementDestruction(eImprovement) > 0)
				{
					aBestPlots.clear();

					for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
					{
						CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

						if (pLoopPlot->HasImprovement(eImprovement))
						{
							int iValue = GC.getGame().getJonRandNum(100, "Improvement Destruction");
							if (pkEventChoiceInfo->isCoastal() && pLoopPlot->isCoastalLand())
							{
								iValue += 100;
							}
							if (pkEventChoiceInfo->isRiver() && pLoopPlot->isRiver())
							{
								iValue += 100;
							}
							if (pkEventChoiceInfo->isNearMountain() && pLoopPlot->GetNumAdjacentMountains() > 0)
							{
								iValue += 100;
							}
							aBestPlots.push_back(pLoopPlot, iValue);
						}
					}
					if (aBestPlots.size() > 0)
					{
						aBestPlots.StableSortItems();
						//Delete improvents up to the total on the event.
						int iNumber = 0;
						int iRuns = pkEventChoiceInfo->getImprovementDestruction(eImprovement);
						if (aBestPlots.size() < iRuns)
						{
							iRuns = aBestPlots.size();
						}
						for (int iI = 0; iI < iRuns; iI++)
						{
							CvPlot* pPlot = aBestPlots.GetElement(iI);
							if (pPlot != NULL && pPlot->getOwner() == getOwner() && pPlot->getImprovementType() == eImprovement)
							{
								pPlot->SetImprovementPillaged(true);
								iNumber++;
							}
						}
						if (getOwner() == GC.getGame().getActivePlayer())
						{
							CvString strBuffer = GetLocalizedText("TXT_KEY_MISC_IMPROVEMENT_DESTROYED_EVENT", GC.getImprovementInfo(eImprovement)->GetTextKey(), iNumber, getNameKey());
							GC.GetEngineUserInterface()->AddCityMessage(0, GetIDInfo(), getOwner(), false, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), strBuffer);
						}
					}
				}
			}
			int iNumStrategicsToDestroy = pkEventChoiceInfo->getCityStrategicResourcePillage();
			if (iNumStrategicsToDestroy > 0)
			{
				for (int iI = 0; iI < GC.getNumResourceInfos(); iI++)
				{
					ResourceTypes eResource = (ResourceTypes)iI;
					if (eResource != NO_RESOURCE)
					{
						CvResourceInfo* pResource = GC.getResourceInfo(eResource);
						if (pResource && pResource->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)
						{
							aBestPlots.clear();

							for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
							{
								CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

								if (pLoopPlot->HasResource(eResource) && (pLoopPlot->getImprovementTypeNeededToImproveResource(getOwner()) == pLoopPlot->getImprovementType()))
								{
									int iValue = GC.getGame().getJonRandNum(100, "Improvement Destruction");
									if (pkEventChoiceInfo->isCoastal() && pLoopPlot->isCoastalLand())
									{
										iValue += 100;
									}
									if (pkEventChoiceInfo->isRiver() && pLoopPlot->isRiver())
									{
										iValue += 100;
									}
									if (pkEventChoiceInfo->isNearMountain() && pLoopPlot->GetNumAdjacentMountains() > 0)
									{
										iValue += 100;
									}
									aBestPlots.push_back(pLoopPlot, iValue);
								}
							}
							if (aBestPlots.size() > 0)
							{
								aBestPlots.StableSortItems();
								//Delete improvents up to the total on the event.
								int iNumber = 0;
								int iRuns = iNumStrategicsToDestroy;
								if (aBestPlots.size() < iRuns)
								{
									iRuns = aBestPlots.size();
								}
								for (int iI = 0; iI < iRuns; iI++)
								{
									CvPlot* pPlot = aBestPlots.GetElement(iI);
									if (pPlot != NULL && pPlot->getOwner() == getOwner() && pPlot->getResourceType(getTeam()) == eResource && pPlot->getImprovementType() != NO_IMPROVEMENT)
									{
										pPlot->SetImprovementPillaged(true);
										iNumber++;
									}
								}
								if (getOwner() == GC.getGame().getActivePlayer())
								{
									CvString strBuffer = GetLocalizedText("TXT_KEY_MISC_STRATEGIC_RESOURCE_PILLAGED_EVENT", pResource->GetTextKey(), iNumber, getNameKey());
									GC.GetEngineUserInterface()->AddCityMessage(0, GetIDInfo(), getOwner(), false, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), strBuffer);
								}
							}
						}
					}
				}
			}
			int iPillageResourceTilesChance = pkEventChoiceInfo->getPillageResourceTilesChance();
			if (iPillageResourceTilesChance > 0)
			{
				int iCityID = GetID();
				for (std::set<int>::iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
				{
					CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

					// no resource on plot
					if (pLoopPlot->getResourceType(getTeam()) == NO_RESOURCE)
						continue;

					ImprovementTypes eImprovement = pLoopPlot->getImprovementType();
					if (eImprovement == NO_IMPROVEMENT)
						continue;

					//connected?
					CvImprovementEntry* pImprovement = GC.getImprovementInfo(eImprovement);
					if (pImprovement && pImprovement->IsConnectsResource(pLoopPlot->getResourceType(getTeam())) && !pLoopPlot->IsImprovementPillaged())
					{
						// this is a plot with an improved resource. check if it should be pillaged
						if (iPillageResourceTilesChance == 100 || GC.getGame().randRangeInclusive(1, 100, CvSeeder::fromRaw(0xbe510f48).mix(iCityID).mix(*it).mix(GC.getGame().getGameTurn())) <= iPillageResourceTilesChance)
						{
							pLoopPlot->SetImprovementPillaged(true);
						}
					}
				}
			}
			int iPillageRoadsChance = pkEventChoiceInfo->getPillageRoadsChance();
			if (iPillageRoadsChance > 0)
			{
				int iCityID = GetID();
				for (std::set<int>::iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
				{
					CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

					// exclude center tile
					if (pLoopPlot == plot())
						continue;
					
					if (pLoopPlot->getRouteType() != NO_ROUTE && !pLoopPlot->IsRoutePillaged())
					{
						// check if the road should be pillaged
						if (iPillageRoadsChance == 100 || GC.getGame().randRangeInclusive(1, 100, CvSeeder::fromRaw(0x78e2d0c2).mix(iCityID).mix(*it).mix(GC.getGame().getGameTurn())) <= iPillageRoadsChance)
						{
							pLoopPlot->SetRoutePillaged(true);
						}
					}
				}
			}
			int iPillageFortificationsChance = pkEventChoiceInfo->getPillageFortificationsChance();
			if (iPillageFortificationsChance > 0)
			{
				int iCityID = GetID();
				for (std::set<int>::iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
				{
					CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

					// exclude center tile
					if (pLoopPlot == plot())
						continue;

					if (pLoopPlot->getImprovementType() != NO_IMPROVEMENT)
					{
						CvImprovementEntry* pImprovementInfo = GC.getImprovementInfo(pLoopPlot->getImprovementType());
						if (pImprovementInfo->IsNoFollowUp() && !pLoopPlot->IsImprovementPillaged())
						{
							// check if the fortification should be pillaged
							if (iPillageFortificationsChance == 100 || GC.getGame().randRangeInclusive(1, 100, CvSeeder::fromRaw(0xae41e82).mix(iCityID).mix(*it).mix(GC.getGame().getGameTurn())) <= iPillageFortificationsChance)
							{
								pLoopPlot->SetImprovementPillaged(true);
							}
						}
					}
				}
			}
			int iBlockBuildingTurns = pkEventChoiceInfo->getBlockBuildingTurns();
			if (iBlockBuildingTurns > 0)
			{
				ChangeBuildingProductionBlockedTurns(iBlockBuildingTurns);
			}
			for (int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
			{
				const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
				if (pkEventChoiceInfo->getNumFreeUnits((UnitClassTypes)iI) <= 0)
					continue;

				const UnitTypes eLoopUnit = GET_PLAYER(getOwner()).GetSpecificUnitType(eUnitClass);
				if (eLoopUnit != NO_UNIT)
				{
					CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eLoopUnit);
					if (pkUnitEntry)
					{
						for (int iJ = 0; iJ < pkEventChoiceInfo->getNumFreeUnits((UnitClassTypes)iI); iJ++)
						{
							UnitAITypes eUnitAI = pkUnitEntry->GetDefaultUnitAIType();
							CvUnit* pUnit = CreateUnit(eLoopUnit, eUnitAI, REASON_GIFT);
							if (pUnit)
							{
								if (!pUnit->IsCivilianUnit() && !pUnit->jumpToNearestValidPlot())
								{
									pUnit->kill(false);	// Could not find a valid spot!
								}
								else
								{
									pUnit->finishMoves();
									//Lua Hook
									GAMEEVENTINVOKE_HOOK(GAMEEVENT_EventUnitCreated, getOwner(), eEventChoice, pUnit);
								}
							}
						}
					}
				}
			}
			for (int iI = 0; iI < GC.getNumUnitInfos(); iI++)
			{
				const UnitTypes eUnit = static_cast<UnitTypes>(iI);
				CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eUnit);
				if (pkUnitEntry)
				{
					if (pkEventChoiceInfo->getNumFreeSpecificUnits((UnitTypes)iI) <= 0)
						continue;

					for (int iJ = 0; iJ < pkEventChoiceInfo->getNumFreeSpecificUnits((UnitTypes)iI); iJ++)
					{
						UnitAITypes eUnitAI = pkUnitEntry->GetDefaultUnitAIType();
						CvUnit* pUnit = CreateUnit(eUnit, eUnitAI, REASON_GIFT);
						if (pUnit)
						{
							if (!pUnit->IsCivilianUnit() && !pUnit->jumpToNearestValidPlot())
							{
								pUnit->kill(false);	// Could not find a valid spot!
							}
							else
							{
								pUnit->finishMoves();
								//Lua Hook
								GAMEEVENTINVOKE_HOOK(GAMEEVENT_EventUnitCreated, getOwner(), eEventChoice, pUnit);
							}
						}
					}
				}
			}
			if (pkEventChoiceInfo->ConvertsCityToPlayerReligion() != 0)
			{
				ReligionTypes eReligion = GET_PLAYER(getOwner()).GetReligions()->GetOwnedReligion();
				if (eReligion != NO_RELIGION)
				{
					GetCityReligions()->ConvertPercentAllOtherFollowers(eReligion, pkEventChoiceInfo->ConvertsCityToPlayerReligion());
				}
			}
			if (pkEventChoiceInfo->ConvertsCityToPlayerMajorityReligion() != 0)
			{
				ReligionTypes eReligion = GET_PLAYER(getOwner()).GetReligions()->GetStateReligion();
				if (eReligion != NO_RELIGION)
				{
					GetCityReligions()->ConvertPercentAllOtherFollowers(eReligion, pkEventChoiceInfo->ConvertsCityToPlayerMajorityReligion());
				}
			}
			if (pkEventChoiceInfo->getResistanceTurns() != 0)
			{
				int iTurns = pkEventChoiceInfo->getResistanceTurns();
				iTurns *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iTurns /= 100;
				ChangeResistanceTurns(max(1, iTurns));
			}
			if (pkEventChoiceInfo->getWLTKD() != 0)
			{
				int iTurns = pkEventChoiceInfo->getWLTKD();
				iTurns *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iTurns /= 100;
				ChangeWeLoveTheKingDayCounter(max(1, iTurns));
			}
			if (pkEventChoiceInfo->getCityHappiness() != 0)
			{
				ChangeEventHappiness(pkEventChoiceInfo->getCityHappiness());
			}
			if (pkEventChoiceInfo->getReligiousPressureModifier() != 0)
			{
				for (int iI = RELIGION_PANTHEON + 1; iI < GC.GetGameReligions()->GetNumReligions(); iI++)
				{
					ReligionTypes eReligion = (ReligionTypes)iI;
					ChangeReligiousPressureModifier(eReligion, pkEventChoiceInfo->getReligiousPressureModifier());
				}
			}
			if (pkEventChoiceInfo->getBasicNeedsMedianModifier() != 0)
			{
				ChangeBasicNeedsMedianModifier(pkEventChoiceInfo->getBasicNeedsMedianModifier());
			}
			if (pkEventChoiceInfo->getGoldMedianModifier() != 0)
			{
				ChangeGoldMedianModifier(pkEventChoiceInfo->getGoldMedianModifier());
			}
			if (pkEventChoiceInfo->getScienceMedianModifier() != 0)
			{
				ChangeScienceMedianModifier(pkEventChoiceInfo->getScienceMedianModifier());
			}
			if (pkEventChoiceInfo->getCultureMedianModifier() != 0)
			{
				ChangeCultureMedianModifier(pkEventChoiceInfo->getCultureMedianModifier());
			}
			if (pkEventChoiceInfo->getReligiousUnrestModifier() != 0)
			{
				ChangeReligiousUnrestModifier(pkEventChoiceInfo->getReligiousUnrestModifier());
			}
			for (int iI = 0; iI < GC.getNumReligionInfos(); iI++)
			{
				ReligionTypes eReligion = (ReligionTypes)iI;
				if (eReligion == NO_RELIGION)
					continue;

				int iPercent = (ReligionTypes)pkEventChoiceInfo->getEventConvertReligionPercent(iI);
				if (iPercent > 0)
				{
					GetCityReligions()->ConvertPercentAllOtherFollowers(eReligion, iPercent);
				}
				int iPop = (ReligionTypes)pkEventChoiceInfo->getEventConvertReligion(iI);
				if (iPop > 0)
				{
					GetCityReligions()->ConvertNumberAllOtherFollowers(eReligion, iPop);
				}
			}
			if (pkEventChoiceInfo->getRandomBarbs() > 0 || pkEventChoiceInfo->getRandomBarbsPerEra() > 0)
			{
				int iNumRebels = pkEventChoiceInfo->getRandomBarbs() + pkEventChoiceInfo->getRandomBarbsPerEra() * max(1, (int)GET_PLAYER(getOwner()).GetCurrentEra());
				CvBarbarians::SpawnBarbarianUnits(plot(), iNumRebels, BARB_SPAWN_EVENT);
			}
			if (pkEventChoiceInfo->getFreeScaledUnits() > 0)
			{
				// In hundreds
				int iNumRecruits = pkEventChoiceInfo->getFreeScaledUnits();

				SpawnPlayerUnitsNearby(getOwner(), iNumRecruits, true, isCoastal());
			}
			if (pkEventChoiceInfo->getSpecialistsGreatPersonPointsPerTurn() != 0)
			{
				ChangeEventGPPFromSpecialists(pkEventChoiceInfo->getSpecialistsGreatPersonPointsPerTurn());
			}
			//Let's do our notification stuff here.
			for (int iI = 0; iI < pkEventChoiceInfo->GetNumNotifications(); iI++)
			{
				if (pkEventChoiceInfo->GetNotificationInfo(iI)->IsEspionageEvent())
					continue;

				CvString strNotificationString = pkEventChoiceInfo->GetNotificationInfo(iI)->GetNotificationString();
				if (strNotificationString != NULL && !strNotificationString.empty())
				{
					NotificationTypes eNotificationType = (NotificationTypes)FStringHash(strNotificationString);

					if (eNotificationType != NO_NOTIFICATION_TYPE)
					{
						Localization::String strMessage;
						Localization::String strSummary;
						strSummary = Localization::Lookup(pkEventChoiceInfo->GetNotificationInfo(iI)->GetShortDescription());
						strSummary << GET_PLAYER(getOwner()).getCivilizationShortDescriptionKey();
						strSummary << getNameKey();
						strSummary << GET_PLAYER(getOwner()).getCivilizationDescription();
						strSummary << GET_PLAYER(getOwner()).getName();
						strMessage = Localization::Lookup(pkEventChoiceInfo->GetNotificationInfo(iI)->GetDescription());
						strMessage << GET_PLAYER(getOwner()).getCivilizationShortDescriptionKey();
						strMessage << getNameKey();
						strMessage << GET_PLAYER(getOwner()).getCivilizationDescription();
						strMessage << GET_PLAYER(getOwner()).getName();
						strMessage << GetScaledHelpText(eEventChoice, true, -1, NO_PLAYER);
						bool bGlobal = pkEventChoiceInfo->GetNotificationInfo(iI)->IsWorldEvent();
						int iX = -1;
						int iY = -1;
						int iVariable = pkEventChoiceInfo->GetNotificationInfo(iI)->GetVariable();
						if (pkEventChoiceInfo->GetNotificationInfo(iI)->IsNeedCityCoordinates())
						{
							iX = getX();
							iY = getY();
						}

						for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
						{
							PlayerTypes ePlayer = (PlayerTypes)iPlayerLoop;
							if (ePlayer != NO_PLAYER && GET_PLAYER(ePlayer).isMajorCiv())
							{
								//Not global? Skip all but me.
								if (!bGlobal && ePlayer != getOwner())
									continue;

								//Global? Seed only to known players.
								if (bGlobal && ePlayer != getOwner() && !GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(getTeam()))
									continue;

								//Send out notifications!
								CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();
								if (pNotifications && GC.getGame().getActivePlayer() == ePlayer)
								{
									if (pkEventChoiceInfo->GetNotificationInfo(iI)->IsNeedPlayerID())
									{
										pNotifications->Add(eNotificationType, strMessage.toUTF8(), strSummary.toUTF8(), iX, iY, getOwner(), GetID());
									}
									else
									{
										pNotifications->Add(eNotificationType, strMessage.toUTF8(), strSummary.toUTF8(), iX, iY, iVariable, GetID());
									}
								}
							}
						}
					}
				}
			}

			UpdateReligion(GetCityReligions()->GetReligiousMajority());

			//Some yield cleanup and refresh here - note that not all of this has to do with religion, however any time religion is updated, that's a good time to update the city's yields.
			for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				YieldTypes eYield = (YieldTypes)iI;
				if (eYield == NO_YIELD)
					continue;

				UpdateSpecialReligionYields(eYield);
				UpdateCityYields(eYield);
			}

			GET_PLAYER(getOwner()).CalculateNetHappiness();
			updateNetHappiness();
		}
	}
}
void CvCity::SetEventActive(CityEventTypes eEvent, bool bValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eEvent < GC.getNumCityEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	m_abEventActive[eEvent] = bValue;
}
bool CvCity::IsEventActive(CityEventTypes eEvent) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eEvent < GC.getNumCityEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	return m_abEventActive[eEvent];
}
void CvCity::SetEventChoiceActive(CityEventChoiceTypes eEventChoice, bool bValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eEventChoice >= 0, "eEventChoice is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eEventChoice < GC.getNumCityEventChoiceInfos(), "eEventChoice is expected to be within maximum bounds (invalid Index)");

	m_abEventChoiceActive[eEventChoice] = bValue;
}
bool CvCity::IsEventChoiceActive(CityEventChoiceTypes eEventChoice) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eEventChoice >= 0, "eEventChoice is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eEventChoice < GC.getNumCityEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	return m_abEventChoiceActive[eEventChoice];
}

void CvCity::SetEventChoiceFired(CityEventChoiceTypes eEvent, bool bValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eEvent < GC.getNumCityEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	m_abEventChoiceFired[eEvent] = bValue;
}
bool CvCity::IsEventChoiceFired(CityEventChoiceTypes eEvent) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eEvent < GC.getNumCityEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	return m_abEventChoiceFired[eEvent];
}
void CvCity::SetEventFired(CityEventTypes eEvent, bool bValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eEvent < GC.getNumCityEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	m_abEventFired[eEvent] = bValue;
}
bool CvCity::IsEventFired(CityEventTypes eEvent) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eEvent < GC.getNumCityEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	return m_abEventFired[eEvent];
}
int CvCity::GetEventCooldown(CityEventTypes eEvent) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eEvent < GC.getNumCityEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	return m_aiEventCooldown[eEvent];
}
void CvCity::ChangeEventCooldown(CityEventTypes eEvent, int iValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eEvent < GC.getNumCityEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	if (iValue != 0)
	{
		m_aiEventCooldown[eEvent] = m_aiEventCooldown[eEvent] + iValue;
	}
}
void CvCity::SetEventCooldown(CityEventTypes eEvent, int iValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eEvent < GC.getNumCityEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	m_aiEventCooldown[eEvent] = iValue;
}
int CvCity::GetEventHappiness() const
{
	VALIDATE_OBJECT();
	return m_iEventHappiness;
}
void CvCity::ChangeEventHappiness(int iValue)
{
	VALIDATE_OBJECT();
	m_iEventHappiness += iValue;
}

// Check for currently active player events, and apply them to this city
// Call when this city is newly founded or captured
void CvCity::CheckActivePlayerEvents()
{
	CvPlayer& kOwner = GET_PLAYER(getOwner());
	for (int iI = 0; iI < GC.getNumEventChoiceInfos(); iI++)
	{
		EventChoiceTypes eEventChoice = static_cast<EventChoiceTypes>(iI);
		if (kOwner.GetEventChoiceDuration(eEventChoice) > 0 || kOwner.IsEventChoiceFired(eEventChoice))
		{
			ApplyPlayerEventChoice(eEventChoice);
		}
	}
}

// Apply the non-instant effects of ongoing eEventChoice to this city
void CvCity::ApplyPlayerEventChoice(const EventChoiceTypes eEventChoice)
{
	ASSERT_DEBUG(eEventChoice != NO_EVENT_CHOICE, "eEventChoice not expected to be NO_EVENT_CHOICE");

	CvModEventChoiceInfo* pkEventChoiceInfo = GC.getEventChoiceInfo(eEventChoice);
	if (!pkEventChoiceInfo)
		return;

	if (pkEventChoiceInfo->isCoastalOnly() && !isCoastal())
		return;

	if (pkEventChoiceInfo->isCapitalEffectOnly() && !isCapital())
		return;

	CvPlayer& kOwner = GET_PLAYER(getOwner());

	if (pkEventChoiceInfo->getEventBuilding() != -1)
	{
		BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(pkEventChoiceInfo->getEventBuilding());
		BuildingTypes eBuilding = GetBuildingTypeFromClass(eBuildingClass, true);
		if (eBuilding != NO_BUILDING && !HasBuilding(eBuilding))
		{
			GetCityBuildings()->SetNumRealBuilding(eBuilding, 1);
		}
	}

	ChangeEventHappiness(pkEventChoiceInfo->getCityHappinessGlobal());
	UpdateReligion(GetCityReligions()->GetReligiousMajority());

	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = static_cast<YieldTypes>(iI);

		// Skip errata yields
		if (!MOD_BALANCE_CORE_JFD && eYield >= YIELD_JFD_HEALTH)
			break;

		int iCityYieldChange = pkEventChoiceInfo->getCityYield(iI);
		if (pkEventChoiceInfo->IsEraScaling())
		{
			int iEra = kOwner.GetCurrentEra();
			if(iEra <= 0)
				iEra = 1;

			iCityYieldChange *= iEra;
		}
		ChangeEventCityYield(eYield, iCityYieldChange);

		// Building modifiers
		for (int iJ = 0; iJ < GC.getNumBuildingClassInfos(); iJ++)
		{
			BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iJ);
			int iYieldChange = pkEventChoiceInfo->getBuildingClassYield(iJ, iI);
			int iYieldModifier = pkEventChoiceInfo->getBuildingClassYieldModifier(iJ, iI);
			int iNumBuilding = GetCityBuildings()->GetNumBuildingClass(eBuildingClass);
			ChangeEventBuildingClassYield(eBuildingClass, eYield, iYieldChange);
			ChangeEventBuildingClassYieldModifier(eBuildingClass, eYield, iYieldModifier);
			ChangeBaseYieldRateFromBuildings(eYield, iYieldChange * iNumBuilding);
			changeYieldRateModifier(eYield, iYieldModifier * iNumBuilding);
		}

		// Improvement modifiers
		for(int iJ = 0; iJ < GC.getNumImprovementInfos(); iJ++)
		{
			ImprovementTypes eImprovement = static_cast<ImprovementTypes>(iJ);
			ChangeEventImprovementYield(eImprovement, eYield, pkEventChoiceInfo->getImprovementYield(iJ, iI));
		}

		// Feature modifiers
		for (int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
		{
			FeatureTypes eFeature = static_cast<FeatureTypes>(iJ);
			ChangeEventFeatureYield(eFeature, eYield, pkEventChoiceInfo->getFeatureYield(iJ, iI));
		}

		// Terrain modifiers
		for (int iJ = 0; iJ < GC.getNumTerrainInfos(); iJ++)
		{
			TerrainTypes eTerrain = static_cast<TerrainTypes>(iJ);
			ChangeEventTerrainYield(eTerrain, eYield, pkEventChoiceInfo->getTerrainYield(iJ, iI));
		}

		// Resource modifiers
		for (int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
		{
			ResourceTypes eResource = static_cast<ResourceTypes>(iJ);
			ChangeEventResourceYield(eResource, eYield, pkEventChoiceInfo->getResourceYield(iJ, iI));
		}

		// Specialist modifiers
		for (int iJ = 0; iJ < GC.getNumSpecialistInfos(); iJ++)
		{
			SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iJ);
			ChangeEventSpecialistYield(eSpecialist, eYield, pkEventChoiceInfo->getGlobalSpecialistYieldChange(iJ, iI));
		}

		UpdateSpecialReligionYields(eYield);
		UpdateCityYields(eYield);
	}

	updateNetHappiness();
}

int CvCity::maxXPValue() const
{
	VALIDATE_OBJECT();
	int iMaxValue = MAX_INT; // negative values mean no XP limit, and MAX_INT is the same in effect

	if (isBarbarian())
	{
		iMaxValue = std::min(iMaxValue, /*30 in CP, 45 in VP*/ GD_INT_GET(BARBARIAN_MAX_XP_VALUE));
	}
	if (GET_PLAYER(getOwner()).isMinorCiv())
	{
		iMaxValue = std::min(iMaxValue, /*-1 in CP, 70 in VP*/ GD_INT_GET(MINOR_MAX_XP_VALUE));
	}

	if (MOD_BALANCE_CORE_SCALING_XP && iMaxValue > 0)
	{
		iMaxValue *= GC.getGame().getGameSpeedInfo().getTrainPercent();
		iMaxValue /= 100;
	}

	return iMaxValue;
}
#endif
//	--------------------------------------------------------------------------------
/// Connected to capital with industrial route? (Railroads)
bool CvCity::IsIndustrialRouteToCapitalConnected() const
{
	return m_bIndustrialRouteToCapital;
}

//	--------------------------------------------------------------------------------
/// Connected to capital with industrial route? (Railroads)
void CvCity::SetIndustrialRouteToCapitalConnected(bool bValue)
{
	m_bIndustrialRouteToCapital = bValue;
}

//	--------------------------------------------------------------------------------
void CvCity::SetRouteToCapitalConnected(bool bValue, bool bSuppressReligionUpdate)
{
	bool bUpdateReligion = !bSuppressReligionUpdate && (bValue != m_bRouteToCapitalConnectedThisTurn);

	//do this before the religion recalculation ...
	m_bRouteToCapitalConnectedThisTurn = bValue;

	if (bUpdateReligion)
	{
		UpdateReligion(GetCityReligions()->GetReligiousMajority());
	}
}

//	--------------------------------------------------------------------------------
bool CvCity::IsRouteToCapitalConnected(void) const
{
	return m_bRouteToCapitalConnectedThisTurn;
}


//	--------------------------------------------------------------------------------
void CvCity::createGreatGeneral(UnitTypes eGreatPersonUnit, bool bIsFree)
{
	VALIDATE_OBJECT();
	GET_PLAYER(getOwner()).createGreatGeneral(eGreatPersonUnit, getX(), getY(), bIsFree);
}

//	--------------------------------------------------------------------------------
void CvCity::createGreatAdmiral(UnitTypes eGreatPersonUnit, bool bIsFree)
{
	VALIDATE_OBJECT();
	GET_PLAYER(getOwner()).createGreatAdmiral(eGreatPersonUnit, getX(), getY(), bIsFree);
}

//	--------------------------------------------------------------------------------
CityTaskResult CvCity::doTask(TaskTypes eTask, int iData1, int iData2, bool bOption, bool bAlt, bool bShift, bool bCtrl)
{
	VALIDATE_OBJECT();
	CityTaskResult eResult = TASK_COMPLETED;
	switch (eTask)
	{
	case TASK_RAZE:
		GET_PLAYER(getOwner()).raze(this);
		resetCaptureData();
		break;

	case TASK_UNRAZE:
		GET_PLAYER(getOwner()).unraze(this);
		break;

	case TASK_DISBAND:
		GET_PLAYER(getOwner()).disband(this);
		break;

	case TASK_GIFT:
		GET_PLAYER((PlayerTypes)iData1).acquireCity(this, false, true, false);
		break;

	case TASK_SET_AUTOMATED_CITIZENS:
		break;

	case TASK_SET_AUTOMATED_PRODUCTION:
		setProductionAutomated(bOption, bAlt && bShift && bCtrl);
		break;

	case TASK_SET_EMPHASIZE:
		m_pEmphases->SetEmphasize(((EmphasizeTypes)iData1), bOption);
		break;

	case TASK_NO_AUTO_ASSIGN_SPECIALISTS:
		GetCityCitizens()->SetNoAutoAssignSpecialists(bOption, true);
		break;

	case TASK_ADD_SPECIALIST:
		GetCityCitizens()->DoAddSpecialistToBuilding(/*eBuilding*/ (BuildingTypes)iData2, true, CvCity::YIELD_UPDATE_GLOBAL);
		break;

	case TASK_REMOVE_SPECIALIST:
	{
		GetCityCitizens()->DoRemoveSpecialistFromBuilding(/*eBuilding*/ (BuildingTypes)iData2, true, CvCity::YIELD_UPDATE_LOCAL);
		GetCityCitizens()->DoAddBestCitizenFromUnassigned(CvCity::YIELD_UPDATE_GLOBAL);
		break;
	}

	case TASK_UNSLOT_SPECIALIST:
	{
		GetCityCitizens()->DoRemoveSpecialistFromBuilding(/*eBuilding*/ (BuildingTypes)iData2, bOption, CvCity::YIELD_UPDATE_LOCAL);
		GetCityCitizens()->DoAddBestCitizenFromUnassigned(CvCity::YIELD_UPDATE_GLOBAL, false, true);
		break;
	}
	case TASK_RESET_SPECIALISTS:
	{
		GetCityCitizens()->SetNoAutoAssignSpecialists(false, true);
		break;
	}

	case TASK_CHANGE_WORKING_PLOT:
		GetCityCitizens()->DoAlterWorkingPlot(/*CityPlotIndex*/ iData1);
		break;

	case TASK_REMOVE_SLACKER:
		if (GetCityCitizens()->GetNumDefaultSpecialists() > 0)
		{
			// remove forced laborer if possible
			if (GetCityCitizens()->GetNumForcedDefaultSpecialists() > 0)
			{
				GetCityCitizens()->ChangeNumForcedDefaultSpecialists(-1);
			}
			GetCityCitizens()->ChangeNumDefaultSpecialists(-1, CvCity::YIELD_UPDATE_LOCAL);
			GetCityCitizens()->DoReallocateCitizens(true);
		}
		break;

	case TASK_CLEAR_WORKING_OVERRIDE:
		clearWorkingOverride(iData1);
		break;

	case TASK_HURRY:
		// Civ 4 feature, non-functional
		UNREACHABLE();
		break;

	case TASK_CONSCRIPT:
		// Civ 4 feature, non-functional
		UNREACHABLE();
		break;

	case TASK_CLEAR_ORDERS:
		clearOrderQueue();
		break;

	case TASK_RALLY_PLOT:
		setRallyPlot(GC.getMap().plot(iData1, iData2));
		break;

	case TASK_CLEAR_RALLY_PLOT:
		setRallyPlot(NULL);
		break;

	case TASK_RANGED_ATTACK:
		eResult = rangeStrike(iData1, iData2);
		break;

	case TASK_CREATE_PUPPET:
		DoCreatePuppet();
		resetCaptureData();
		break;

	case TASK_ANNEX_PUPPET:
		DoAnnex();
		resetCaptureData();
		break;

	default:
		ASSERT_DEBUG(false, "eTask failed to match a valid option");
		break;
	}

	return eResult;
}


//	--------------------------------------------------------------------------------
void CvCity::chooseProduction(UnitTypes eTrainUnit, BuildingTypes eConstructBuilding, ProjectTypes eCreateProject, bool /*bFinish*/, bool /*bFront*/)
{
	VALIDATE_OBJECT();
	CvString strTooltip = GetLocalizedText("TXT_KEY_NOTIFICATION_NEW_CONSTRUCTION", getNameKey());
#if defined(MOD_BALANCE_CORE)
	if (IsRazing())
	{
		//No popup if razing.
		return;
	}
#endif
	CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
	if (pNotifications)
	{
		// Figure out what we just finished so we can package it into something the lua will understand
		OrderTypes eOrder = NO_ORDER;
		int iItemID = -1;

		if (eTrainUnit != NO_UNIT)
		{
			eOrder = ORDER_TRAIN;
			iItemID = eTrainUnit;
		}
		else if (eConstructBuilding != NO_BUILDING)
		{
			eOrder = ORDER_CONSTRUCT;
			iItemID = eConstructBuilding;
		}
		else if (eCreateProject != NO_PROJECT)
		{
			eOrder = ORDER_CREATE;
			iItemID = eCreateProject;
		}

		pNotifications->Add(NOTIFICATION_PRODUCTION, strTooltip, strTooltip, getX(), getY(), eOrder, iItemID);
	}
}

void CvCity::updateEconomicValue()
{
	//todo: take into account player personality
	int iYieldValue = 0;

	CvWeightedVector<int> validResources;

	//notes:
	//- economic value is in gold, so use a rough conversion factor for the others
	//- for food and gold only surplus is interesting, rest is converted to other yields already
	//- ignore trade, as the city might the change owner
	iYieldValue += (getYieldRateTimes100(YIELD_FOOD, true) - foodConsumptionTimes100()) * 3;
	iYieldValue += getYieldRateTimes100(YIELD_PRODUCTION, true) * 4;
	iYieldValue += getYieldRateTimes100(YIELD_SCIENCE, true) * 3;
	iYieldValue += (getYieldRateTimes100(YIELD_GOLD, true) - GetCityBuildings()->GetTotalBaseBuildingMaintenance() * 100) * 1;
	iYieldValue += getJONSCulturePerTurn() * 3;
	iYieldValue += GetFaithPerTurn() * 3;
	iYieldValue += getYieldRateTimes100(YIELD_TOURISM, true) * 3;
	iYieldValue += getYieldRateTimes100(YIELD_GOLDEN_AGE_POINTS, true) * 3;

	//divide by avg conversion factor
	iYieldValue /= 3;

	//arbitrary conversion factor ... yields are already covered?
	iYieldValue += getNumWorldWonders() * 23;

	//now check access to resources
	//todo: call CvDealAI::GetResourceValue() for each resource

	for (int iI = 0; iI < GetNumWorkablePlots(); iI++)
	{
		CvPlot* pLoopPlot = GetCityCitizens()->GetCityPlotFromIndex(iI);
		if (!pLoopPlot)
			continue;

		ResourceTypes eResource = pLoopPlot->getResourceType(getTeam());
		if (eResource == NO_RESOURCE)
			continue;

		//for plots owned by this city or reasonably likely to be claimed
		bool bGood = false;
		if (pLoopPlot->isOwned())
			bGood = (GetID() == pLoopPlot->getOwningCityID());
		else
			bGood = pLoopPlot->isAdjacentPlayer(getOwner()) && !pLoopPlot->IsAdjacentOwnedByTeamOtherThan(getTeam());

		if (bGood)
		{
			const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);
			if (!pkResourceInfo)
				continue;

			validResources.push_back(eResource, pLoopPlot->getNumResource());
		}
	}

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes ePossibleOwner = (PlayerTypes)iPlayerLoop;
		m_aiEconomicValue[iPlayerLoop] = 0; //everybody gets a new value

		if (ePossibleOwner != NO_PLAYER && GET_PLAYER(ePossibleOwner).isAlive())
		{
			int iResourceValue = 0;
			if (validResources.size() > 0)
			{
				for (int iResourceLoop = 0; iResourceLoop < validResources.size(); iResourceLoop++)
				{
					//todo: add something for currently unworked plots (future potential)
					ResourceTypes eResource = (ResourceTypes)validResources.GetElement(iResourceLoop);
					if (eResource == NO_RESOURCE)
						continue;

					if (GET_TEAM(GET_PLAYER(ePossibleOwner).getTeam()).IsResourceObsolete(eResource))
						continue;

					const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);
					if (!pkResourceInfo)
						continue;

					int iResourceQuantity = validResources.GetWeight(iResourceLoop);
					if (iResourceQuantity > 0)
					{
						ResourceUsageTypes eUsage = pkResourceInfo->getResourceUsage();
						if (eUsage == RESOURCEUSAGE_LUXURY)
						{
							int iValue = 200;

							if (GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(getOwner(), eResource))
								iValue = 100;

							// If the new owner doesn't have it or the old owner would lose it completely, it's worth more
							if ((GET_PLAYER(ePossibleOwner).getNumResourceAvailable(eResource) == 0) ||
								(GET_PLAYER(getOwner()).getNumResourceAvailable(eResource) == iResourceQuantity) ||
								(GET_PLAYER(ePossibleOwner).WouldGainMonopoly(eResource, iResourceQuantity)))
								iValue = 600;

							int iHappinessFromResource = pkResourceInfo->getHappiness() + GET_PLAYER(ePossibleOwner).GetExtraHappinessPerLuxury();
							iResourceValue += iResourceQuantity * iHappinessFromResource * iValue;
						}
						else if (eUsage == RESOURCEUSAGE_STRATEGIC)
						{
							int iValue = 400;

							// If the new owner doesn't have it or the old owner would lose it completely, it's worth more
							if ((GET_PLAYER(ePossibleOwner).getNumResourceAvailable(eResource) == 0) ||
								(GET_PLAYER(getOwner()).getNumResourceAvailable(eResource) == iResourceQuantity) ||
								(GET_PLAYER(ePossibleOwner).WouldGainMonopoly(eResource, iResourceQuantity)))
								iValue = 800;

							iResourceValue += iResourceQuantity * iValue;
						}
					}
				}
			}

			m_aiEconomicValue[ePossibleOwner] = iYieldValue + iResourceValue;
		}
	}
}

int CvCity::getEconomicValue(PlayerTypes ePossibleOwner)
{
	if (ePossibleOwner == NO_PLAYER || ePossibleOwner >= MAX_CIV_PLAYERS)
		return 0;

	if ((int)m_aiEconomicValue.size() <= ePossibleOwner)
		updateEconomicValue();

	return m_aiEconomicValue[ePossibleOwner];
}

void CvCity::setEconomicValue(PlayerTypes ePossibleOwner, int iValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(ePossibleOwner >= 0, "ePossibleOwner expected to be >= 0");
	ASSERT_DEBUG(ePossibleOwner < MAX_CIV_PLAYERS, "ePossibleOwner expected to be < MAX_CIV_PLAYERS");
	m_aiEconomicValue[ePossibleOwner] = iValue;
}

/// Keeps track of local instant yield. use this in conjunction with getGameTurnFounded() to get an average
void CvCity::ChangeInstantYieldTotal(YieldTypes eYield, int iValue)
{
	VALIDATE_OBJECT();
	m_miInstantYieldsTotal[eYield] += iValue;
}
 
int CvCity::GetInstantYieldTotal(YieldTypes eYield)
{
	return m_miInstantYieldsTotal[eYield];
}

void CvCity::ChangeUnitClassTrainingAllowed(UnitClassTypes eUnitClass, int iValue)
{
	VALIDATE_OBJECT();
	m_miUnitClassTrainingAllowed[eUnitClass] += iValue;

	if (m_miUnitClassTrainingAllowed[eUnitClass] == 0)
	{
		m_miUnitClassTrainingAllowed.erase(eUnitClass);
	}

	GET_PLAYER(getOwner()).UpdateUnitClassTrainingAllowedAnywhere(eUnitClass);
}
 
int CvCity::GetUnitClassTrainingAllowed(UnitClassTypes eUnitClass) const
{
	if (m_miUnitClassTrainingAllowed.count(eUnitClass) > 0)
	{
		return m_miUnitClassTrainingAllowed.find(eUnitClass)->second;
	}
	return 0;
}

map<UnitClassTypes, int> CvCity::GetUnitClassTrainingAllowed() const
{
	return m_miUnitClassTrainingAllowed;
}


std::vector<CvPlot*> CvCity::GetPlotsClaimedByBuilding(BuildingTypes eBuilding) const
{
	std::vector<CvPlot*> vPlotsClaimed;

	CvBuildingEntry* pBuildingInfo = GC.getBuildingInfo(eBuilding);
	if (pBuildingInfo == NULL)
		return vPlotsClaimed;

	set<std::pair<int, bool>> sBuildingResourceClaim = pBuildingInfo->GetResourceClaim();
	if (sBuildingResourceClaim.empty())
		return vPlotsClaimed;

	// loop through all unowned plots within working range and check if they have one of the required resources
	for (int i = RING0_PLOTS; i < GetNumWorkablePlots(); i++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(plot(), i);
		if (!pLoopPlot)
			continue;
		 
		// already our plot?
		if (pLoopPlot->getOwner() == getOwner())
			continue;

		if (!pLoopPlot->isRevealed(getTeam()))
			continue;

		ResourceTypes eResource = pLoopPlot->getResourceType(getTeam());
		if (eResource == NO_RESOURCE)
			continue;

		if (pLoopPlot->IsStealBlockedByImprovement())
			continue;

		// resource claimed, including tiles owned by other players?
		if (sBuildingResourceClaim.count(make_pair((int)eResource, true)) > 0)
		{
			vPlotsClaimed.push_back(pLoopPlot);
		}
		// resource claimed, not including tiles owned by other players?
		else if (sBuildingResourceClaim.count(make_pair((int)eResource, false)) > 0)
		{
			if (!pLoopPlot->isOwned())
			{
				vPlotsClaimed.push_back(pLoopPlot);
			}
		}
	}
	return vPlotsClaimed;
}

int CvCity::GetContestedPlotScore(PlayerTypes eOtherPlayer) const
{
	TeamTypes eOtherTeam = (eOtherPlayer == NO_PLAYER) ? NO_TEAM : GET_PLAYER(eOtherPlayer).getTeam();

	int iCounter = 0;
	int iRange = range(getWorkPlotDistance(), 1, 5);

	for (int i = RING0_PLOTS; i < RING_PLOTS[iRange]; i++)
	{
		CvPlot* pPlot = iterateRingPlots(plot(), i);
		if (!pPlot || !pPlot->isOwned() || pPlot->getOwningCity() == NULL)
			continue;

		int iWeight = 1;
		if (i < RING1_PLOTS)
			iWeight = 3;
		else if (i < RING2_PLOTS)
			iWeight = 2;

		bool bRelevant = false;
		if (eOtherTeam == NO_TEAM && pPlot->getTeam() != getTeam())
			bRelevant = true;
		if (eOtherTeam != NO_TEAM && pPlot->getTeam() == eOtherTeam)
			bRelevant = true;

		if (bRelevant && pPlot->hasYield())
			iCounter += iWeight;
	}

	return iCounter;
}

//	--------------------------------------------------------------------------------
/// How far out this city may buy plots
int CvCity::getBuyPlotDistance() const
{
	int iDistance = GET_PLAYER(getOwner()).getBuyPlotDistance();

	iDistance = std::min(MAX_CITY_RADIUS, std::max(getWorkPlotDistance(), iDistance));
	return iDistance;
}

//	--------------------------------------------------------------------------------
/// How far out this city may buy/work plots
int CvCity::getWorkPlotDistance(int iChange) const
{
	int iDistance = GET_PLAYER(getOwner()).getWorkPlotDistance();

	// Change distance based on buildings/wonders in this city
	iDistance += GetCityWorkingChange();

	iDistance = std::min(MAX_CITY_RADIUS, std::max(MIN_CITY_RADIUS, iDistance + iChange));
	return iDistance;
}

//	--------------------------------------------------------------------------------
/// How many plots this city may work
int CvCity::GetNumWorkablePlots(int iChange) const
{
	int iWorkablePlots = ((6 * (1 + getWorkPlotDistance(iChange)) * getWorkPlotDistance(iChange) / 2) + 1);
	return iWorkablePlots;
}

bool CvCity::IsWithinWorkRange(const CvPlot * pPlot) const
{
	if (pPlot)
	{
		int iDistance = plotDistance(pPlot->getX(), pPlot->getY(), getX(), getY());
		return iDistance <= getWorkPlotDistance();
	}

	return false;
}

//	--------------------------------------------------------------------------------
void CvCity::clearWorkingOverride(int iIndex)
{
	VALIDATE_OBJECT();
	CvPlot* pPlot = GetCityCitizens()->GetCityPlotFromIndex(iIndex);

	if (pPlot != NULL)
	{
		pPlot->setOwningCityOverride(NULL);
	}
}


//	--------------------------------------------------------------------------------
int CvCity::countNumImprovedPlots(ImprovementTypes eImprovement) const
{
	VALIDATE_OBJECT();
	int iCount = 0;

	CvCityCitizens* pCityCitizens = GetCityCitizens();
	for (int iI = 0; iI < GetNumWorkablePlots(); iI++)
	{
		CvPlot* pLoopPlot = pCityCitizens->GetCityPlotFromIndex(iI);
		if (pLoopPlot != NULL)
		{
			if (!GetCityCitizens()->IsCanWork(pLoopPlot))
			{
				if (eImprovement != NO_IMPROVEMENT)
				{
					if (pLoopPlot->getImprovementType() == eImprovement && !pLoopPlot->IsImprovementPillaged())
					{
						++iCount;
					}
				}
				else if (pLoopPlot->getImprovementType() != NO_IMPROVEMENT && !pLoopPlot->IsImprovementPillaged())
				{
					iCount++;
				}
			}
		}
	}

	return iCount;
}

//	--------------------------------------------------------------------------------
int CvCity::countNumImprovablePlots(ImprovementTypes eImprovement, DomainTypes eDomain) const
{
	VALIDATE_OBJECT();
	int iCount = 0;

	CvCityCitizens* pCityCitizens = GetCityCitizens();
	for (int iI = 0; iI < GetNumWorkablePlots(); iI++)
	{
		CvPlot* pLoopPlot = pCityCitizens->GetCityPlotFromIndex(iI);
		if (pLoopPlot != NULL && !pLoopPlot->isCity() && (eDomain == NO_DOMAIN || pLoopPlot->getDomain() == eDomain))
		{
			if (GetCityCitizens()->IsCanWork(pLoopPlot))
			{
				if (pLoopPlot->getImprovementType() == NO_IMPROVEMENT || pLoopPlot->IsImprovementPillaged())
				{
					if (eImprovement != NO_IMPROVEMENT)
					{
						if (pLoopPlot->canHaveImprovement(eImprovement, getOwner()))
						{
							++iCount;
						}
					}
					else if (pLoopPlot->getDomain() == DOMAIN_LAND || (pLoopPlot->getDomain() == DOMAIN_SEA && pLoopPlot->getResourceType(getTeam()) != NO_RESOURCE))
					{
						++iCount;
					}
				}
			}
		}
	}

	return iCount;
}

//	--------------------------------------------------------------------------------
int CvCity::countNumWaterPlots() const
{
	VALIDATE_OBJECT();
	int iCount = 0;

	CvCityCitizens* pCityCitizens = GetCityCitizens();
	for (int iI = 0; iI < GetNumWorkablePlots(); iI++)
	{
		CvPlot* pLoopPlot = pCityCitizens->GetCityPlotFromIndex(iI);
		if (pLoopPlot != NULL)
		{
			if (pLoopPlot->isWater())
			{
				if (GetCityCitizens()->IsCanWork(pLoopPlot))
				{
					iCount++;
				}
			}
		}
	}

	return iCount;
}

//	--------------------------------------------------------------------------------
int CvCity::countNumLakePlots() const
{
	VALIDATE_OBJECT();
		int iCount = 0;

	CvCityCitizens* pCityCitizens = GetCityCitizens();
	for (int iI = 0; iI < GetNumWorkablePlots(); iI++)
	{
		CvPlot* pLoopPlot = pCityCitizens->GetCityPlotFromIndex(iI);
		if (pLoopPlot != NULL)
		{
			if (pLoopPlot->isLake())
			{
				if (GetCityCitizens()->IsCanWork(pLoopPlot))
				{
					iCount++;
				}
			}
		}
	}

	return iCount;
}

//	--------------------------------------------------------------------------------
int CvCity::countNumRiverPlots() const
{
	VALIDATE_OBJECT();
	int iCount = 0;

	CvCityCitizens* pCityCitizens = GetCityCitizens();
	for (int iI = 0; iI < GetNumWorkablePlots(); iI++)
	{
		CvPlot* pLoopPlot = pCityCitizens->GetCityPlotFromIndex(iI);

		if (pLoopPlot != NULL)
		{
			if (pLoopPlot->isRiver())
			{
				if (GetCityCitizens()->IsCanWork(pLoopPlot))
				{
					++iCount;
				}
			}
		}
	}

	return iCount;
}

//	--------------------------------------------------------------------------------
int CvCity::countNumForestPlots() const
{
	VALIDATE_OBJECT();
	int iCount = 0;
	for (int iI = 0; iI < GetNumWorkablePlots(); iI++)
	{
		CvPlot* pLoopPlot = GetCityCitizens()->GetCityPlotFromIndex(iI);

		if (pLoopPlot != NULL)
		{
			if (pLoopPlot->getFeatureType() == FEATURE_FOREST)
			{
				if (GetCityCitizens()->IsCanWork(pLoopPlot))
				{
					++iCount;
				}
			}
		}
	}

	return iCount;
}

//	--------------------------------------------------------------------------------
int CvCity::findPopulationRank()
{
	VALIDATE_OBJECT();
	if (!m_bPopulationRankValid)
	{
		int iRank = 1;
		int iLoop = 0;
		for (CvCity* pLoopCity = GET_PLAYER(getOwner()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(getOwner()).nextCity(&iLoop))
		{
			if ((pLoopCity->getPopulation() > getPopulation()) ||
				((pLoopCity->getPopulation() == getPopulation()) && (pLoopCity->GetID() < GetID())))
			{
				iRank++;
			}
		}

		// shenanigans are to get around the const check
		m_bPopulationRankValid = true;
		m_iPopulationRank = iRank;
	}

	return m_iPopulationRank;
}


//	--------------------------------------------------------------------------------
int CvCity::findBaseYieldRateRank(YieldTypes eYield)
{
	VALIDATE_OBJECT();
	if (!m_abBaseYieldRankValid[eYield])
	{
		int iRate = getBaseYieldRate(eYield);
		int iRank = 1;
		int iLoop = 0;
		for (CvCity* pLoopCity = GET_PLAYER(getOwner()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(getOwner()).nextCity(&iLoop))
		{
			if ((pLoopCity->getBaseYieldRate(eYield) > iRate) ||
				((pLoopCity->getBaseYieldRate(eYield) == iRate) && (pLoopCity->GetID() < GetID())))
			{
				iRank++;
			}
		}

		m_abBaseYieldRankValid[eYield] = true;
		m_aiBaseYieldRank[eYield] = iRank;
	}

	return m_aiBaseYieldRank[eYield];
}


//	--------------------------------------------------------------------------------
int CvCity::findYieldRateRank(YieldTypes eYield)
{
	if (!m_abYieldRankValid[eYield])
	{
		int iRate = getYieldRateTimes100(eYield, false);
		int iRank = 1;
		int iLoop = 0;
		for (CvCity* pLoopCity = GET_PLAYER(getOwner()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(getOwner()).nextCity(&iLoop))
		{
			if ((pLoopCity->getYieldRateTimes100(eYield, false) > iRate) ||
				((pLoopCity->getYieldRateTimes100(eYield, false) == iRate) && (pLoopCity->GetID() < GetID())))
			{
				iRank++;
			}
		}

		m_abYieldRankValid[eYield] = true;
		m_aiYieldRank[eYield] = iRank;
	}

	return m_aiYieldRank[eYield];
}


//	--------------------------------------------------------------------------------
// Returns one of the upgrades...
UnitTypes CvCity::allUpgradesAvailable(UnitTypes eUnit, int iUpgradeCount) const
{
	VALIDATE_OBJECT();
	UnitTypes eUpgradeUnit;
	bool bUpgradeFound = false;
	bool bUpgradeAvailable = false;
	bool bUpgradeUnavailable = false;

	ASSERT_DEBUG(eUnit != NO_UNIT, "eUnit is expected to be assigned (not NO_UNIT)");

	CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
	if (pkUnitInfo == NULL)
		return NO_UNIT;

	if (iUpgradeCount > GC.getNumUnitClassInfos())
	{
		return NO_UNIT;
	}

	eUpgradeUnit = NO_UNIT;

	bUpgradeFound = false;
	bUpgradeAvailable = false;
	bUpgradeUnavailable = false;

	for (int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
	{
		const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
		if (pkUnitInfo->GetUpgradeUnitClass(iI))
		{
			const UnitTypes eLoopUnit = GET_PLAYER(getOwner()).GetSpecificUnitType(eUnitClass);

			if (eLoopUnit != NO_UNIT)
			{
				bUpgradeFound = true;

				const UnitTypes eTempUnit = allUpgradesAvailable(eLoopUnit, (iUpgradeCount + 1));

				if (eTempUnit != NO_UNIT)
				{
					eUpgradeUnit = eTempUnit;
					bUpgradeAvailable = true;
				}
				else
				{
					bUpgradeUnavailable = true;
				}
			}
		}

		if (GET_PLAYER(getOwner()).GetPlayerTraits()->HasSpecialUnitUpgrade(eUnitClass, eUnit))
		{
			const UnitTypes eLoopUnit = GET_PLAYER(getOwner()).GetSpecificUnitType(eUnitClass);

			if (eLoopUnit != NO_UNIT)
			{
				bUpgradeFound = true;

				const UnitTypes eTempUnit = allUpgradesAvailable(eLoopUnit, (iUpgradeCount + 1));

				if (eTempUnit != NO_UNIT)
				{
					eUpgradeUnit = eTempUnit;
					bUpgradeAvailable = true;
				}
				else
				{
					bUpgradeUnavailable = true;
				}
			}
		}
	}

	if (iUpgradeCount > 0)
	{
		if (bUpgradeFound && bUpgradeAvailable)
		{
			ASSERT_DEBUG(eUpgradeUnit != NO_UNIT, "eUpgradeUnit is expected to be assigned (not NO_UNIT)");
			return eUpgradeUnit;
		}

		if (canTrain(eUnit, false, false, false, true))
		{
			return eUnit;
		}
	}
	else
	{
		if (bUpgradeFound && !bUpgradeUnavailable)
		{
			return eUpgradeUnit;
		}
	}

	return NO_UNIT;
}


//	--------------------------------------------------------------------------------
bool CvCity::isWorldWondersMaxed() const
{
	VALIDATE_OBJECT();
	if (GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && isHuman())
	{
		return false;
	}

	if (/*-1*/ GD_INT_GET(MAX_WORLD_WONDERS_PER_CITY) == -1)
	{
		return false;
	}

	if (getNumWorldWonders() >= GD_INT_GET(MAX_WORLD_WONDERS_PER_CITY))
	{
		return true;
	}

	return false;
}


//	--------------------------------------------------------------------------------
bool CvCity::isTeamWondersMaxed() const
{
	VALIDATE_OBJECT();
	if (GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && isHuman())
	{
		return false;
	}

	if (/*-1*/ GD_INT_GET(MAX_TEAM_WONDERS_PER_CITY) == -1)
	{
		return false;
	}

	if (getNumTeamWonders() >= GD_INT_GET(MAX_TEAM_WONDERS_PER_CITY))
	{
		return true;
	}

	return false;
}


//	--------------------------------------------------------------------------------
bool CvCity::isNationalWondersMaxed() const
{
	VALIDATE_OBJECT();
	int iMaxNumWonders = (GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && isHuman()) ? /*-1*/ GD_INT_GET(MAX_NATIONAL_WONDERS_PER_CITY_FOR_OCC) : /*-1*/ GD_INT_GET(MAX_NATIONAL_WONDERS_PER_CITY);

	if (iMaxNumWonders == -1)
	{
		return false;
	}

	if (getNumNationalWonders() >= iMaxNumWonders)
	{
		return true;
	}

	return false;
}


//	--------------------------------------------------------------------------------
bool CvCity::isBuildingsMaxed() const
{
	VALIDATE_OBJECT();
	if (/*-1*/ GD_INT_GET(MAX_BUILDINGS_PER_CITY) == -1)
	{
		return false;
	}

	if (GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && isHuman())
	{
		return false;
	}

	if (m_pCityBuildings->GetNumBuildings() >= GD_INT_GET(MAX_BUILDINGS_PER_CITY))
	{
		return true;
	}

	return false;
}


//	--------------------------------------------------------------------------------
bool CvCity::hasBuildingPrerequisites(BuildingTypes eBuilding) const
{
	VALIDATE_OBJECT();
	if (eBuilding == NO_BUILDING)
		return false;

	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if (!pkBuildingInfo)
		return false;

	// Does this city have prereq buildings?
	for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
	{
		BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iI);

		if (pkBuildingInfo->IsBuildingClassNeededInCity(iI))
		{
			if (!HasBuildingClass(eBuildingClass))
			{
				return false;
			}
		}

		if (pkBuildingInfo->IsBuildingClassNeededAnywhere(iI) || pkBuildingInfo->IsBuildingClassNeededNowhere(iI))
		{
			bool bHasBuildingClass = false;
			CvPlayer& kOwner = GET_PLAYER(getOwner());
			int iLoop = 0;
			for (CvCity* pLoopCity = kOwner.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kOwner.nextCity(&iLoop))
			{
				if (pLoopCity->HasBuildingClass(eBuildingClass))
				{
					bHasBuildingClass = true;
					break;
				}
			}

			if (pkBuildingInfo->IsBuildingClassNeededAnywhere(iI) && !bHasBuildingClass)
				return false;

			if (pkBuildingInfo->IsBuildingClassNeededNowhere(iI) && bHasBuildingClass)
				return false;
		}
	}

	// Check if a specific prerequisite building is needed in this city
	BuildingTypes ePrereqBuilding = static_cast<BuildingTypes>(pkBuildingInfo->GetNeedBuildingThisCity());

	// Return true if no specific prerequisite building is needed or it is present in the city
	return (ePrereqBuilding == NO_BUILDING) || HasBuilding(ePrereqBuilding);
}

//	--------------------------------------------------------------------------------
bool CvCity::canTrain(UnitTypes eUnit, bool bContinue, bool bTestVisible, bool bIgnoreCost, bool bWillPurchase, CvString* toolTipSink) const
{
	VALIDATE_OBJECT();
	if (eUnit == NO_UNIT)
	{
		return false;
	}

	CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eUnit);
	if (pkUnitEntry == NULL)
	{
		return false;
	}

	// UnitClassTrainAllowed overrides tech requirements
	const CvUnitEntry& pUnitInfo = *pkUnitEntry;
	const UnitClassTypes eUnitClass = (UnitClassTypes)pUnitInfo.GetUnitClassType();
	bool bIgnoreTechRequirements = GetUnitClassTrainingAllowed(eUnitClass) > 0;
	
	if (!(GET_PLAYER(getOwner()).canTrainUnit(eUnit, bContinue, bTestVisible, bIgnoreCost, false, bIgnoreTechRequirements, toolTipSink)))
	{
		return false;
	}
	
	// can we build an upgraded version of this unit locally?
	if (!GetUnitClassTrainingAllowed().empty())
	{
		const map<UnitClassTypes, int>& sUnitClassTrainingAllowed = GetUnitClassTrainingAllowed();
		for (map<UnitClassTypes, int>::const_iterator it = sUnitClassTrainingAllowed.begin(); it != sUnitClassTrainingAllowed.end(); ++it)
		{
			if (it->second > 0)
			{
				if (pkUnitEntry->GetUpgradeUnitClass((int)it->first))
				{
					return false;
				}
			}
		}
	}

	// Puppets cannot build units (except workers and work boats, or any other civilian with a work rate)
	// Automated cities handled in CvCityStrategyAI to avoid messing with the UI
	if (CityStrategyAIHelpers::IsTestCityStrategy_IsPuppetAndAnnexable(this))
	{
		if ( !MOD_BALANCE_VP || pkUnitEntry->GetWorkRate()==0 || pkUnitEntry->GetCombat()>0 || pkUnitEntry->GetRangedCombat() > 0 )
			return false;
	}

	if (!bWillPurchase && pkUnitEntry->IsPurchaseOnly())
	{
		return false;
	}

	// check whether we can supply the units. do not check this on player level, all the dynamic checks should happen here
	if (MOD_BALANCE_CORE_MILITARY && !isHuman() && !isBarbarian() && !pkUnitEntry->IsNoSupply() && (pkUnitEntry->GetCombat() > 0 || pkUnitEntry->GetRangedCombat() > 0))
	{
		bool bCanSupply = GET_PLAYER(getOwner()).GetNumUnitsToSupply() < GET_PLAYER(getOwner()).GetNumUnitsSupplied(); // this works when we're at the limit
		if (!bCanSupply)
		{
			return false;
		}
	}

	// If Zulu Player has this trait and Pikeman are an immediate upgrade to Impi, let's not let player exploit lower production cost of pikeman->impi. So, let's make it immediately obsolete.
	static UnitClassTypes ePikemanClass = (UnitClassTypes)GC.getInfoTypeForString("UNITCLASS_PIKEMAN");
	static UnitTypes eZuluImpi = (UnitTypes)GC.getInfoTypeForString("UNIT_ZULU_IMPI");
	if (GET_PLAYER(getOwner()).GetPlayerTraits()->IsFreeZuluPikemanToImpi())
	{
		if (eUnitClass != NO_UNITCLASS && (eUnitClass == ePikemanClass) && GET_PLAYER(getOwner()).canTrainUnit(eZuluImpi, false, false, true))
		{
			return false;
		}
	}

	//this flag seems to be needed to check whether we should show the unit in the build list at all, and if it's greyed out generate a tooltip why
	if (!bTestVisible)
	{
		CvUnitEntry& thisUnitInfo = *pkUnitEntry;
		// Settlers may not be trained in Cities that are too small
		if (thisUnitInfo.IsFound() || thisUnitInfo.IsFoundAbroad())
		{
			int iSizeRequirement = /*2 in CP, 4 in VP*/ GD_INT_GET(CITY_MIN_SIZE_FOR_SETTLERS);
			if (getPopulation() < iSizeRequirement)
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_SETTLER_SIZE_LIMIT", "", "", iSizeRequirement);
				if (toolTipSink == NULL)
					return false;
			}
		}

		if (MOD_BALANCE_VP && !isBarbarian() && !pUnitInfo.IsNoSupply() && (pUnitInfo.GetCombat() > 0 || pUnitInfo.GetRangedCombat() > 0))
		{
			int iMaxSupplyPenalty = /*70*/ GD_INT_GET(MAX_UNIT_SUPPLY_PRODMOD);
			int iSupplyPenaltyPerUnit = /*10 in CP, 5 in VP*/ GD_INT_GET(PRODUCTION_PENALTY_PER_UNIT_OVER_SUPPLY);
			int iMaxUnitsOverSupply = (iMaxSupplyPenalty > 0 && iSupplyPenaltyPerUnit > 0) ? iMaxSupplyPenalty / iSupplyPenaltyPerUnit : INT_MAX;

			if (GET_PLAYER(getOwner()).GetNumUnitsOutOfSupply() >= iMaxUnitsOverSupply)
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_NO_SUPPLY");
				if (toolTipSink == NULL)
					return false;
			}
		}

		// See if there are any BuildingClass requirements
		for (int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
		{
			if (thisUnitInfo.GetBuildingClassRequireds(iBuildingClassLoop))
			{
				const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iBuildingClassLoop);
				if (!HasBuildingClass(eBuildingClass))
				{
					if (!toolTipSink)
						return false;

					const BuildingTypes ePrereqBuilding = static_cast<BuildingTypes>(getCivilizationInfo().getCivilizationBuildings(iBuildingClassLoop));
					if (ePrereqBuilding != NO_BUILDING)
					{
						CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(ePrereqBuilding);
						GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_UNIT_REQUIRES_BUILDING", pkBuildingInfo->GetDescriptionKey());
					}
				}
			}
		}

		// Air units can't be built above capacity
		if (pkUnitEntry->GetDomainType() == DOMAIN_AIR)
		{
			int iNumAirUnits = plot()->countNumAirUnits(getTeam());
			if (iNumAirUnits >= GetMaxAirUnits())
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_CITY_AT_AIR_CAPACITY");
				if (toolTipSink == NULL)
					return false;
			}
		}
	}

	if (!plot()->canTrain(eUnit))
	{
		return false;
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if (pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(getOwner());
		args->Push(GetID());
		args->Push(eUnit);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if (LuaSupport::CallTestAll(pkScriptSystem, "CityCanTrain", args.get(), bResult))
		{
			// Check the result.
			if (!bResult)
			{
				return false;
			}
		}
	}

	return true;
}

//	--------------------------------------------------------------------------------
bool CvCity::canTrain(UnitCombatTypes eUnitCombat) const
{
	VALIDATE_OBJECT();
	for (int i = 0; i < GC.getNumUnitInfos(); i++)
	{
		const UnitTypes eUnit = static_cast<UnitTypes>(i);
		CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
		if (pkUnitInfo)
		{
			if (pkUnitInfo->GetUnitCombatType() == eUnitCombat)
			{
				if (canTrain(eUnit))
				{
					return true;
				}
			}
		}
	}

	return false;
}


//	--------------------------------------------------------------------------------
// slow version to call for a single building in a single city
bool CvCity::canConstruct(BuildingTypes eBuilding, bool bContinue, bool bTestVisible, bool bIgnoreCost, bool bWillPurchase, CvString* toolTipSink) const
{
	return canConstruct(eBuilding, GET_PLAYER(m_eOwner).GetTotalBuildingCount(), bContinue, bTestVisible, bIgnoreCost, bWillPurchase, toolTipSink);
}

//fast version to call in loops over building types / cities
bool CvCity::canConstruct(BuildingTypes eBuilding, const std::vector<int>& vPreExistingBuildings, bool bContinue, bool bTestVisible, bool bIgnoreCost, bool bWillPurchase, CvString* toolTipSink) const
{
	if (eBuilding == NO_BUILDING)
	{
		return false;
	}

	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

	//no wonders in puppets (also affects venice unless invest or already invested)
	if (IsPuppet() && !(GET_PLAYER(m_eOwner).GetPlayerTraits()->IsNoAnnexing() && (bContinue || bWillPurchase)))
	{
		if (isWorldWonderClass(pkBuildingInfo->GetBuildingClassInfo()) || isNationalWonderClass(pkBuildingInfo->GetBuildingClassInfo()))
		{
			return false;
		}
	}

	if (!(GET_PLAYER(getOwner()).canConstruct(eBuilding, vPreExistingBuildings, bContinue, bTestVisible, bIgnoreCost, toolTipSink)))
	{
		return false;
	}

	if (!bWillPurchase && pkBuildingInfo->IsPurchaseOnly())
	{
		return false;
	}
	if (pkBuildingInfo->IsRequiresIndustrialCityConnection() && !IsIndustrialRouteToCapitalConnected())
	{
		return false;
	}

	if ((pkBuildingInfo->GetCivType() != NO_CIVILIZATION) && (getCivilizationType() != pkBuildingInfo->GetCivType()))
	{
		return false;
	}

	if (pkBuildingInfo->GetEventRequiredActive() != NO_EVENT_CHOICE)
	{
		if (!GET_PLAYER(getOwner()).IsEventChoiceActive((EventChoiceTypes)pkBuildingInfo->GetEventRequiredActive()))
			return false;
	}
	if (pkBuildingInfo->GetCityEventRequiredActive() != NO_EVENT_CHOICE_CITY)
	{
		if (!IsEventChoiceActive((CityEventChoiceTypes)pkBuildingInfo->GetEventRequiredActive()))
			return false;
	}

	if (m_pCityBuildings->GetNumBuilding(eBuilding) >= /*1*/ GD_INT_GET(CITY_MAX_NUM_BUILDINGS))
	{
		return false;
	}

	if (!isValidBuildingLocation(eBuilding))
	{
		return false;
	}

	// Religion-enabled national wonder
	if (pkBuildingInfo && pkBuildingInfo->IsUnlockedByBelief() && pkBuildingInfo->IsReformation())
	{
		CvGameReligions* pReligions = GC.getGame().GetGameReligions();
		ReligionTypes eReligion = GET_PLAYER(getOwner()).GetReligions()->GetOwnedReligion();
		if (eReligion != NO_RELIGION)
		{
			const CvReligion* pReligion = pReligions->GetReligion(eReligion, getOwner());
			if (pReligion == NULL || !pReligion->m_Beliefs.IsBuildingClassEnabled(pkBuildingInfo->GetBuildingClassType(), getOwner(), GET_PLAYER(getOwner()).getCity(GetID()), true))
			{
				return false;
			}
		}
		else
		{
			return false;
		}
	}

	// Local Resource requirements met?
	if (!IsBuildingLocalResourceValid(eBuilding, bTestVisible, toolTipSink))
	{
		return false;
	}
	// Resource Monopoly requirements met?
	if (!IsBuildingResourceMonopolyValid(eBuilding, toolTipSink))
	{
		return false;
	}
#if defined(MOD_BALANCE_CORE)
	if (!IsBuildingFeatureValid(eBuilding, toolTipSink))
	{
		return false;
	}
#endif
#if defined(MOD_BALANCE_CORE)
	// Corporation building?
	if (pkBuildingInfo->GetBuildingClassInfo().getCorporationType() != NO_CORPORATION)
	{
		// Must have Corporations tech
		if (!GET_TEAM(GET_PLAYER(getOwner()).getTeam()).IsCorporationsEnabled())
		{
			return false;
		}

		// This building is a franchise - cannot construct EVER
		if (pkBuildingInfo->GetBuildingClassInfo().IsFranchise())
		{
			return false;
		}
		// Corporation HQ
		if (pkBuildingInfo->GetBuildingClassInfo().IsHeadquarters())
		{
			CvPlayerCorporations* pPlayerCorporation = GET_PLAYER(getOwner()).GetCorporations();
			// Cannot construct if corporation exists or we've founded a corporation already
			if (pPlayerCorporation->HasFoundedCorporation() ||
				GC.getGame().GetGameCorporations()->IsCorporationFounded(pkBuildingInfo->GetBuildingClassInfo().getCorporationType()))
			{
				return false;
			}
		}
		// Corporation Office
		if (pkBuildingInfo->GetBuildingClassInfo().IsOffice())
		{
			CvPlayerCorporations* pPlayerCorporation = GET_PLAYER(getOwner()).GetCorporations();
			// Cannot construct if we do not have this corporation
			if (pPlayerCorporation->GetFoundedCorporation() != pkBuildingInfo->GetBuildingClassInfo().getCorporationType())
			{
				return false;
			}
		}
	}
#endif
	// Holy city requirement
	if (pkBuildingInfo->IsRequiresHolyCity() && !GetCityReligions()->IsHolyCityAnyReligion())
	{
		return false;
	}

	const CvCivilizationInfo& thisCivInfo = *GC.getCivilizationInfo(getCivilizationType());
	int iNumBuildingClassInfos = GC.getNumBuildingClassInfos();

	// Can't construct a building to reduce occupied unhappiness if the city isn't occupied
	if (pkBuildingInfo->IsNoOccupiedUnhappiness() && !IsOccupied() && !pkBuildingInfo->IsBuildAnywhere())
		return false;

	// Does this city have prereq buildings?
	if (!hasBuildingPrerequisites(eBuilding))
	{
		return false;
	}

#if defined(MOD_BALANCE_CORE)
	//Check for uniques of the same type.
	const std::vector<BuildingTypes>& allBuildings = GetCityBuildings()->GetAllBuildingsHere();
	for (size_t iI = 0; iI < allBuildings.size(); iI++)
	{
		CvBuildingEntry* pkBuildingInfo2 = GC.getBuildingInfo(allBuildings[iI]);
		if (pkBuildingInfo2 && pkBuildingInfo2->GetBuildingClassType() == pkBuildingInfo->GetBuildingClassType())
		{
			return false;
		}
	}
#endif

	///////////////////////////////////////////////////////////////////////////////////
	// Everything above this is what is checked to see if Building shows up in the list of construction items
	///////////////////////////////////////////////////////////////////////////////////

	const CvBuildingClassInfo& kBuildingClassInfo = pkBuildingInfo->GetBuildingClassInfo();
	if (!bTestVisible)
	{
		if (!bContinue)
		{
			if (!MOD_BALANCE_CORE_BUILDING_INVESTMENTS && getFirstBuildingOrder(eBuilding) != -1)
			{
				return false;
			}
		}

		if (!(kBuildingClassInfo.isNoLimit()))
		{
			if (isWorldWonderClass(kBuildingClassInfo))
			{
				if (isWorldWondersMaxed())
				{
					return false;
				}
			}
			else if (isTeamWonderClass(kBuildingClassInfo))
			{
				if (isTeamWondersMaxed())
				{
					return false;
				}
			}
			else if (isNationalWonderClass(kBuildingClassInfo))
			{
				if (isNationalWondersMaxed())
				{
					return false;
				}
			}
			else
			{
				if (isBuildingsMaxed())
				{
					return false;
				}
			}
		}
	}

	// Locked Buildings (Mutually Exclusive Buildings?) - not quite sure how this works
	for (int iI = 0; iI < iNumBuildingClassInfos; iI++)
	{
		BuildingClassTypes eLockedBuildingClass = (BuildingClassTypes)pkBuildingInfo->GetLockedBuildingClasses(iI);

		if (eLockedBuildingClass != NO_BUILDINGCLASS)
		{
			BuildingTypes eLockedBuilding = (BuildingTypes)(thisCivInfo.getCivilizationBuildings(eLockedBuildingClass));

			if (eLockedBuilding != NO_BUILDING)
			{
				if (m_pCityBuildings->GetNumBuilding(eLockedBuilding) > 0)
				{
					return false;
				}
			}
		}
	}

	// Mutually Exclusive Buildings 2
	if (pkBuildingInfo->GetMutuallyExclusiveGroup() != -1)
	{
		int iNumBuildingInfos = GC.getNumBuildingInfos();
		for (int iI = 0; iI < iNumBuildingInfos; iI++)
		{
			const BuildingTypes eBuildingLoop = static_cast<BuildingTypes>(iI);
			if (eBuildingLoop == eBuilding)
				continue;

			CvBuildingEntry* pkLoopBuilding = GC.getBuildingInfo(eBuildingLoop);
			if (pkLoopBuilding)
			{
				// Buildings are in a Mutually Exclusive Group, so only one is allowed
				if (pkLoopBuilding->GetMutuallyExclusiveGroup() == pkBuildingInfo->GetMutuallyExclusiveGroup())
				{
					if (m_pCityBuildings->GetNumBuilding(eBuildingLoop) > 0 || isBuildingInQueue(eBuildingLoop))
					{
						return false;
					}
				}
			}
		}
	}

#if defined(MOD_BALANCE_CORE)
	if (!bTestVisible) // Test visible check here is so that the buildings will show up in the build list, but can't be selected (for every other city!)
	{
		if (GetBuildingProductionBlockedTurns() > 0)
		{
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_PRODUCTION_SPY_BLOCKED", pkBuildingInfo->GetTextKey(), "", GetBuildingProductionBlockedTurns());
			if (toolTipSink == NULL)
				return false;
		}

		// Check if it's a Corporation headquarters
		if (pkBuildingInfo->GetBuildingClassInfo().IsHeadquarters())
		{
			CvCity* pLoopCity = NULL;
			int iLoop = 0;
			for (pLoopCity = GET_PLAYER(getOwner()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(getOwner()).nextCity(&iLoop))
			{
				if (pLoopCity == NULL)
					continue;

				if (pLoopCity->GetID() == GetID())
					continue;

				BuildingTypes eTestBuilding = pLoopCity->getProductionBuilding();
				if (eTestBuilding != NO_BUILDING)
				{
					CvBuildingEntry* pkLoopBuildingInfo = GC.getBuildingInfo(eTestBuilding);
					if (pkLoopBuildingInfo && pkLoopBuildingInfo->GetBuildingClassInfo().IsHeadquarters())
					{
						GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_ONE_CORP_ONLY", pkBuildingInfo->GetTextKey(), pkLoopBuildingInfo->GetDescription());
						if (toolTipSink == NULL)
							return false;
					}
				}
			}
		}
	}
#endif

#if defined(MOD_BALANCE_CORE_POP_REQ_BUILDINGS)
	//Requires a certain population size, either nationally or locally.
	if (MOD_BALANCE_CORE_POP_REQ_BUILDINGS)
	{
		if (pkBuildingInfo->GetLocalPopulationRequired() > 0)
		{
			int iPopRequired = pkBuildingInfo->GetLocalPopulationRequired();
			if (getPopulation() < iPopRequired)
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_NEED_LOCAL_POP", pkBuildingInfo->GetTextKey(), "", iPopRequired - getPopulation());
				if (toolTipSink == NULL)
					return false;
			}
		}
	}
#endif

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if (pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(getOwner());
		args->Push(GetID());
		args->Push(eBuilding);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if (LuaSupport::CallTestAll(pkScriptSystem, "CityCanConstruct", args.get(), bResult))
		{
			// Check the result.
			if (!bResult)
			{
				return false;
			}
		}
	}

	return true;
}


//	--------------------------------------------------------------------------------
bool CvCity::canCreate(ProjectTypes eProject, bool bContinue, bool bTestVisible, CvString* toolTipSink) const
{
	VALIDATE_OBJECT();

	//no projects in puppets except venice
	if (eProject == NO_PROJECT || CityStrategyAIHelpers::IsTestCityStrategy_IsPuppetAndAnnexable(this))
	{
		return false;
	}

	if (!bTestVisible) // Test visible check here is so that the buildings will show up in the build list, but can't be selected (for every other city!)
	{
		if (GetBuildingProductionBlockedTurns() > 0)
		{
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_PRODUCTION_SPY_BLOCKED", "", "", GetBuildingProductionBlockedTurns());
			if (toolTipSink == NULL)
				return false;
		}
	}

	if (!(GET_PLAYER(getOwner()).canCreate(eProject, bContinue, bTestVisible)))
	{
		return false;
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if (pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(getOwner());
		args->Push(GetID());
		args->Push(eProject);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if (LuaSupport::CallTestAll(pkScriptSystem, "CityCanCreate", args.get(), bResult))
		{
			// Check the result.
			if (!bResult)
			{
				return false;
			}
		}
	}

	return true;
}

//	--------------------------------------------------------------------------------
bool CvCity::canMaintain(ProcessTypes eProcess, bool bContinue) const
{
	VALIDATE_OBJECT();

	if (!(GET_PLAYER(getOwner()).canMaintain(eProcess, bContinue)))
	{
		return false;
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if (pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(getOwner());
		args->Push(GetID());
		args->Push(eProcess);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if (LuaSupport::CallTestAll(pkScriptSystem, "CityCanMaintain", args.get(), bResult))
		{
			// Check the result.
			if (!bResult)
			{
				return false;
			}
		}
	}

	return true;
}


//	--------------------------------------------------------------------------------
bool CvCity::canJoinCity() const
{
	VALIDATE_OBJECT();
	return true;
}

//	--------------------------------------------------------------------------------
int CvCity::GetTerrainImprovementNeed() const
{
	return m_iTerrainImprovementNeed;
}

//	--------------------------------------------------------------------------------
void CvCity::UpdateTerrainImprovementNeed()
{
	int iImprovablePlots = 0;

	//start at one, ignore the city plot itself
	for (int iI = 1; iI < GetNumWorkablePlots(); iI++)
	{
		CvPlot* pLoopPlot = GetCityCitizens()->GetCityPlotFromIndex(iI);

		if (!pLoopPlot)
			continue;

		if (pLoopPlot->getDomain() != DOMAIN_LAND)
			continue;

		if (pLoopPlot->getOwner() != getOwner())
			continue;

		if (pLoopPlot->IsTeamImpassable(getTeam()))
			continue;

		if (pLoopPlot->isCity())
			continue;

		//the most interesting case, empty plots
		if (pLoopPlot->getImprovementType() == NO_IMPROVEMENT)
		{
			//can't assume that there is an improvement for every type of unimproved plot (especially in the beginning). need to check individually
			for (int iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
			{
				BuildTypes eBuild = (BuildTypes)iBuildIndex;
				if (!pLoopPlot->canBuild(eBuild, getOwner(), false, true))
					continue;

				if (GET_PLAYER(getOwner()).GetPlayerTraits()->IsNoBuild(eBuild))
					continue;

				if (GC.getBuildInfo(eBuild)->getTechPrereq() != NO_TECH && !GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)GC.getBuildInfo(eBuild)->getTechPrereq()))
					continue;

				if (GC.getBuildInfo(eBuild)->getTechObsolete() != NO_TECH && GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)GC.getBuildInfo(eBuild)->getTechObsolete()))
					continue;

				// Is this an improvement that is only useable by a specific civ?
				ImprovementTypes eImprovement = (ImprovementTypes)GC.getBuildInfo(eBuild)->getImprovement();
				if (eImprovement != NO_IMPROVEMENT)
				{
					CvImprovementEntry* pkEntry = GC.getImprovementInfo(eImprovement);
					if (pkEntry->IsSpecificCivRequired())
					{
						CivilizationTypes eCiv = pkEntry->GetRequiredCivilization();
						if (eCiv != getCivilizationType())
							continue;
					}
				}

				//if we get here it seems to be applicable
				iImprovablePlots++;

				//todo: should we add more of the improvement is very valuable?
				//for now give extra weight to resource plots
				if (pLoopPlot->getResourceType(getTeam()) != NO_RESOURCE)
					iImprovablePlots++;

				break;
			}
		}
		//ignore plots which have a working improvement ...
		else if (pLoopPlot->IsImprovementPillaged())
			iImprovablePlots++;
		//if there is a route, see if we have better ones
		else if (pLoopPlot->getRouteType() != NO_ROUTE && (GET_TEAM(getTeam()).GetBestPossibleRoute() != pLoopPlot->getRouteType() || pLoopPlot->IsRoutePillaged()))
			iImprovablePlots++;
	}

	//should we take into account the population of the city or whether any of these plots are worked or will be worked?
	m_iTerrainImprovementNeed = iImprovablePlots;
}

//	--------------------------------------------------------------------------------
/// Extra yield for a resource this city is working?
int CvCity::GetResourceExtraYield(ResourceTypes eResource, YieldTypes eYield) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eResource > -1 && eResource < GC.getNumResourceInfos(), "Invalid resource index.");
	ASSERT_DEBUG(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	return ModifierLookup(m_yieldChanges[eYield].forResource, eResource);
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeResourceExtraYield(ResourceTypes eResource, YieldTypes eYield, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eResource > -1 && eResource < GC.getNumResourceInfos(), "Invalid resource index.");
	ASSERT_DEBUG(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	SCityExtraYields& y = m_yieldChanges[eYield];
	if (ModifierUpdateInsertRemove(y.forResource, eResource, iChange, true))
		updateYield();
}

//	--------------------------------------------------------------------------------
/// Extra yield for a Feature this city is working?
int CvCity::GetFeatureExtraYield(FeatureTypes eFeature, YieldTypes eYield) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eFeature > -1 && eFeature < GC.getNumFeatureInfos(), "Invalid Feature index.");
	ASSERT_DEBUG(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	return ModifierLookup(m_yieldChanges[eYield].forFeature, eFeature);
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeFeatureExtraYield(FeatureTypes eFeature, YieldTypes eYield, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eFeature > -1 && eFeature < GC.getNumFeatureInfos(), "Invalid Feature index.");
	ASSERT_DEBUG(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	SCityExtraYields& y = m_yieldChanges[eYield];
	if (ModifierUpdateInsertRemove(y.forFeature, eFeature, iChange, true))
		updateYield();
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Extra yield for a improvement this city is working?
int CvCity::GetImprovementExtraYield(ImprovementTypes eImprovement, YieldTypes eYield) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eImprovement > -1 && eImprovement < GC.getNumImprovementInfos(), "Invalid Improvement index.");
	ASSERT_DEBUG(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");
	return ModifierLookup(m_yieldChanges[eYield].forImprovement, eImprovement);
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeImprovementExtraYield(ImprovementTypes eImprovement, YieldTypes eYield, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eImprovement > -1 && eImprovement < GC.getNumImprovementInfos(), "Invalid Improvement index.");
	ASSERT_DEBUG(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	SCityExtraYields& y = m_yieldChanges[eYield];
	if (ModifierUpdateInsertRemove(y.forImprovement, eImprovement, iChange, true))
		updateYield();
}

/// Extra maintenance for a building this city is lacking resources for?
int CvCity::GetExtraBuildingMaintenance() const
{
	VALIDATE_OBJECT();
	return m_iExtraBuildingMaintenance;
}

//	--------------------------------------------------------------------------------
void CvCity::SetExtraBuildingMaintenance(int iChange)
{
	VALIDATE_OBJECT();
	m_iExtraBuildingMaintenance = iChange;
}
#endif
//	--------------------------------------------------------------------------------
/// Extra yield for a Terrain this city is working?
int CvCity::GetTerrainExtraYield(TerrainTypes eTerrain, YieldTypes eYield) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eTerrain > -1 && eTerrain < GC.getNumTerrainInfos(), "Invalid Terrain index.");
	ASSERT_DEBUG(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	return ModifierLookup(m_yieldChanges[eYield].forTerrain, eTerrain);
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeTerrainExtraYield(TerrainTypes eTerrain, YieldTypes eYield, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eTerrain > -1 && eTerrain < GC.getNumTerrainInfos(), "Invalid Terrain index.");
	ASSERT_DEBUG(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	SCityExtraYields& y = m_yieldChanges[eYield];
	if (ModifierUpdateInsertRemove(y.forTerrain, eTerrain, iChange, true))
		updateYield();
}

//	--------------------------------------------------------------------------------
/// Extra yield for a Plot this city is working?
int CvCity::GetPlotExtraYield(PlotTypes ePlot, YieldTypes eYield) const
{
	VALIDATE_OBJECT();
	return ModifierLookup(m_yieldChanges[eYield].forPlot, ePlot);
}

//	--------------------------------------------------------------------------------
void CvCity::ChangePlotExtraYield(PlotTypes ePlot, YieldTypes eYield, int iChange)
{
	VALIDATE_OBJECT();
	SCityExtraYields& y = m_yieldChanges[eYield];
	if (ModifierUpdateInsertRemove(y.forPlot, ePlot, iChange, true))
		updateYield();
}

std::set<int> CvCity::GetPlotList() const
{
	VALIDATE_OBJECT();
	return m_siPlots;
}
void CvCity::AddToPlotList(CvPlot* pPlot)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(pPlot);
	int iPlotIndex = pPlot->GetPlotIndex();

	ASSERT_DEBUG(m_siPlots.find(iPlotIndex) == m_siPlots.end());
	m_siPlots.insert(iPlotIndex);
}
void CvCity::RemoveFromPlotList(CvPlot* pPlot)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(pPlot);
	int iPlotIndex = pPlot->GetPlotIndex();

	ASSERT_DEBUG(m_siPlots.find(iPlotIndex) != m_siPlots.end());
	m_siPlots.erase(iPlotIndex);
}

#if defined(MOD_BALANCE_CORE)
bool CvCity::IsHasFeatureLocal(FeatureTypes eFeature) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eFeature > -1 && eFeature < GC.getNumFeatureInfos(), "Invalid resource index.");

	// See if we have the resource linked to this city, but not connected yet
	bool bFoundFeature = false;

	// Loop through all plots near this City to see if we can find eResource

	for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

		// Invalid plot
		if (pLoopPlot == NULL)
			continue;

		// Doesn't have the resource (ignore team first to save time)
		if (pLoopPlot->getFeatureType() != eFeature)
			continue;

		// Not owned by this player
		if (pLoopPlot->getOwner() != getOwner())
			continue;

		if (pLoopPlot->getOwningCityID() != GetID())
			continue;

		bFoundFeature = true;
		break;
	}

	return bFoundFeature;
}
#endif
//	--------------------------------------------------------------------------------
/// Does this City have eResource nearby?
bool CvCity::IsHasResourceLocal(ResourceTypes eResource, bool bTestVisible) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eResource > -1 && eResource < GC.getNumResourceInfos(), "Invalid resource index.");

	// Actually check to see if we have this Resource to use right now
	if (!bTestVisible)
	{
		return m_paiNumResourcesLocal[eResource] > 0;
	}
	else
	{
		return (m_paiNumUnimprovedResourcesLocal[eResource] + m_paiNumResourcesLocal[eResource]) > 0;
	}
}

#if defined(MOD_TRADE_WONDER_RESOURCE_ROUTES)
int CvCity::GetNumResourceLocal(ResourceTypes eResource, bool bImproved)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eResource > -1 && eResource < GC.getNumResourceInfos(), "Invalid resource index.");
	return bImproved ? m_paiNumResourcesLocal[eResource] : m_paiNumUnimprovedResourcesLocal[eResource];
}
#endif

int CvCity::GetNumTotalResource(ResourceTypes eResource) const
{
	return m_paiNumUnimprovedResourcesLocal[eResource] + m_paiNumResourcesLocal[eResource];
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeNumResourceLocal(ResourceTypes eResource, int iChange, bool bUnimproved)
{
	VALIDATE_OBJECT();

	ASSERT_DEBUG(eResource >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eResource < GC.getNumResourceInfos(), "eIndex expected to be < GC.getNumResourceInfos()");

	if (iChange != 0)
	{
		bool bOldHasResource = IsHasResourceLocal(eResource, /*bTestVisible*/ false);

		if (bUnimproved)
		{
			m_paiNumUnimprovedResourcesLocal[eResource] = m_paiNumUnimprovedResourcesLocal[eResource] + iChange;
			return;
		}
		else
		{
			m_paiNumResourcesLocal[eResource] = m_paiNumResourcesLocal[eResource] + iChange;
		}

		if (bOldHasResource != IsHasResourceLocal(eResource, /*bTestVisible*/ false))
		{
			if (IsHasResourceLocal(eResource, /*bTestVisible*/ false))
			{
				processResource(eResource, 1);

				CvResourceInfo* pkResource = GC.getResourceInfo(eResource);

				// Notification letting player know his city gets a bonus for wonders
				int iWonderMod = pkResource->getWonderProductionMod();
				if (iWonderMod != 0)
				{
					if (MOD_BALANCE_CORE_RESOURCE_FLAVORS && pkResource->getWonderProductionModObsoleteEra() == GC.getInfoTypeForString("ERA_INDUSTRIAL", true /*bHideAssert*/))
					{
						static EraTypes industrialEra = (EraTypes)GC.getInfoTypeForString("ERA_INDUSTRIAL", true /*bHideAssert*/);
						if (GET_PLAYER(getOwner()).GetCurrentEra() < industrialEra)
						{
							CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
							if (pNotifications)
							{
								Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_RESOURCE_WONDER_MOD_LATE");
								strText << getNameKey() << pkResource->GetTextKey() << iWonderMod;
								Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_RESOURCE_WONDER_MOD_SUMMARY");
								strSummary << getNameKey() << pkResource->GetTextKey();
								pNotifications->Add(NOTIFICATION_DISCOVERED_BONUS_RESOURCE, strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), eResource);
							}
						}
					}
					else
					{
						CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
						if (pNotifications)
						{
							Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_RESOURCE_WONDER_MOD");
							strText << getNameKey() << pkResource->GetTextKey() << iWonderMod;
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_RESOURCE_WONDER_MOD_SUMMARY");
							strSummary << getNameKey() << pkResource->GetTextKey();
							pNotifications->Add(NOTIFICATION_DISCOVERED_BONUS_RESOURCE, strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), eResource);
						}
					}
				}

				// Notification letting player know his city gets a production cost modifier
				if (MOD_RESOURCES_PRODUCTION_COST_MODIFIERS)
				{

					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_RESOURCE_WONDER_MOD_SUMMARY");
					strSummary << getNameKey() << pkResource->GetTextKey();

					CvString strList = "";

					// Unit combat cost modifier
					if (pkResource->isHasUnitCombatProductionCostModifiersLocal())
					{
						for (int iUnitCombat = 0; iUnitCombat < GC.getNumUnitCombatClassInfos(); iUnitCombat++)
						{
							UnitCombatTypes eUnitCombat = (UnitCombatTypes)iUnitCombat;
							CvBaseInfo* pkUnitCombat = GC.getUnitCombatClassInfo(eUnitCombat);

							if (eUnitCombat == NO_UNITCOMBAT)
							{
								continue;
							}
							std::vector<ProductionCostModifiers> aiiiUnitCostMod = pkResource->getUnitCombatProductionCostModifiersLocal(eUnitCombat);
							for (std::vector<ProductionCostModifiers>::const_iterator it = aiiiUnitCostMod.begin(); it != aiiiUnitCostMod.end(); ++it)
							{
								EraTypes eRequiredEra = (EraTypes)it->m_iRequiredEra;
								EraTypes eObsoleteEra = (EraTypes)it->m_iObsoleteEra;
								int iCostModifier = it->m_iCostModifier;

								CvString strEraText = "";

								if (iCostModifier != 0)
								{
									if (eRequiredEra != NO_ERA)
									{
										strEraText += " ";
										strEraText += GetLocalizedText("TXT_KEY_NOTIFICATION_CITY_RESOURCE_PROD_COST_MOD_ERA_PREREQUISITE", GC.getEraInfo(eRequiredEra)->getShortDesc());
									}

									if (eObsoleteEra != NO_ERA)
									{
										strEraText += " ";
										strEraText += GetLocalizedText("TXT_KEY_NOTIFICATION_CITY_RESOURCE_PROD_COST_MOD_ERA_OBSOLETE", GC.getEraInfo(eObsoleteEra)->getShortDesc());
									}

									strList += "[NEWLINE]" + GetLocalizedText("TXT_KEY_NOTIFICATION_CITY_RESOURCE_PROD_COST_MOD_LIST", pkUnitCombat->GetDescriptionKey(), iCostModifier, strEraText);
								}
							}
						}
					}

					// Building cost modifier
					if (pkResource->isHasBuildingProductionCostModifiersLocal())
					{
						std::vector<ProductionCostModifiers> aiiiBuildingCostMod = pkResource->getBuildingProductionCostModifiersLocal();
						for (std::vector<ProductionCostModifiers>::const_iterator it = aiiiBuildingCostMod.begin(); it != aiiiBuildingCostMod.end(); ++it)
						{
							EraTypes eRequiredEra = (EraTypes)it->m_iRequiredEra;
							EraTypes eObsoleteEra = (EraTypes)it->m_iObsoleteEra;
							int iCostModifier = it->m_iCostModifier;

							CvString strEraText = "";

							if (iCostModifier != 0)
							{
								if (eRequiredEra != NO_ERA)
								{
									strEraText += " ";
									strEraText += GetLocalizedText("TXT_KEY_NOTIFICATION_CITY_RESOURCE_PROD_COST_MOD_ERA_PREREQUISITE", GC.getEraInfo(eRequiredEra)->getShortDesc());
								}

								if (eObsoleteEra != NO_ERA)
								{
									strEraText += " ";
									strEraText += GetLocalizedText("TXT_KEY_NOTIFICATION_CITY_RESOURCE_PROD_COST_MOD_ERA_OBSOLETE", GC.getEraInfo(eObsoleteEra)->getShortDesc());
								}

								strList += "[NEWLINE]" + GetLocalizedText("TXT_KEY_NOTIFICATION_CITY_RESOURCE_PROD_COST_MOD_LIST", "TXT_KEY_NOTIFICATION_CITY_RESOURCE_PROD_COST_MOD_BUILDING", iCostModifier, strEraText);
							}
						}
					}

					// Combine the list we just made with the header text
					if (!strList.empty())
					{
						Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_RESOURCE_PROD_COST_MOD");
						strText << getNameKey() << pkResource->GetTextKey() << strList;

						CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
						if (pNotifications)
						{
							pNotifications->Add((NotificationTypes)FStringHash("NOTIFICATION_PRODUCTION_COST_MODIFIERS_FROM_RESOURCES"), strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), eResource);
						}
					}
				}
			}
			else
			{
				processResource(eResource, -1);
			}
		}

		// Building Culture change for a local resource
		for (int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
		{
			const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
			if (pkBuildingInfo)
			{
				// Do we have this building?
				if (GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
				{
					// Does eBuilding give culture with eResource?
					int iCulture = pkBuildingInfo->GetResourceCultureChange(eResource);

					if (iCulture != 0)
						iCulture *= GetCityBuildings()->GetNumBuilding(eBuilding);

					ChangeBaseYieldRateFromBuildings(YIELD_CULTURE, iCulture * iChange);

					// Does eBuilding give faith with eResource?
					int iFaith = pkBuildingInfo->GetResourceFaithChange(eResource);

					if (iFaith != 0)
						iFaith *= GetCityBuildings()->GetNumBuilding(eBuilding);

					ChangeBaseYieldRateFromBuildings(YIELD_FAITH, iFaith * iChange);

					int iHappiness = pkBuildingInfo->GetResourceHappiness(eResource);
					if (iHappiness != 0)
						iHappiness *= GetCityBuildings()->GetNumBuilding(eBuilding);
					ChangeBaseHappinessFromBuildings(iHappiness * iChange);
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Does eBuilding pass the local resource requirement test?
bool CvCity::IsBuildingLocalResourceValid(BuildingTypes eBuilding, bool bTestVisible, CvString* toolTipSink) const
{
	VALIDATE_OBJECT();
	CvBuildingEntry* pBuildingInfo = GC.getBuildingInfo(eBuilding);
	if (!pBuildingInfo)
		return false;

	bool bHasAllAnd = true;
	bool bHasAnyOr = false;
	bool bNeedAnyOr = false;
	CvString tempTooltip;
	for (uint uiPrereq = 0; uiPrereq < pBuildingInfo->GetLocalResourceAndSize(); uiPrereq++)
	{
		ResourceTypes eAndResource = static_cast<ResourceTypes>(pBuildingInfo->GetLocalResourceAnd(uiPrereq));
		
		if (!IsHasResourceLocal(eAndResource, bTestVisible))
		{
			CvResourceInfo* pAndResource = GC.getResourceInfo(eAndResource);
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_LOCAL_RESOURCE", pAndResource->GetTextKey(), pAndResource->GetIconString());
			bHasAllAnd = false;
		}
	}

	for (uint uiPrereq = 0; uiPrereq < pBuildingInfo->GetLocalResourceOrSize(); uiPrereq++)
	{
		ResourceTypes eOrResource = static_cast<ResourceTypes>(pBuildingInfo->GetLocalResourceOr(uiPrereq));
		bNeedAnyOr = true;

		// City has resource locally
		if (IsHasResourceLocal(eOrResource, bTestVisible))
		{
			bHasAnyOr = true;
			continue;
		}

		// Otherwise, prepare the temp tooltip
		CvResourceInfo* pOrResource = GC.getResourceInfo(eOrResource);
		GC.getGame().BuildCannotPerformActionHelpText(&tempTooltip, "TXT_KEY_NO_ACTION_BUILDING_LOCAL_RESOURCE", pOrResource->GetTextKey(), pOrResource->GetIconString());
	}

	if (!bHasAllAnd || (bNeedAnyOr && !bHasAnyOr))
	{
		// Hope nobody puts both AND and OR requirements onto the same building...
		if (toolTipSink)
			*toolTipSink += tempTooltip;

		return false;
	}

	return true;
}

//	--------------------------------------------------------------------------------
/// Does eBuilding pass the resource monopoly requirement test?
bool CvCity::IsBuildingResourceMonopolyValid(BuildingTypes eBuilding, CvString* toolTipSink) const
{
	VALIDATE_OBJECT();
	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if (pkBuildingInfo == NULL)
		return false;

	// ANDs: City must have ALL of these nearby
	// If this is a corporation HQ, consider it's corporation resource ANDs instead!
	const CvBuildingClassInfo& kBuildingClass = pkBuildingInfo->GetBuildingClassInfo();
	CorporationTypes eCorporation = kBuildingClass.getCorporationType();
	CvCorporationEntry* pkCorporationInfo = (kBuildingClass.IsHeadquarters() && eCorporation != NO_CORPORATION) ? GC.getCorporationInfo(eCorporation) : NULL;

	uint uiNumAndPrereq = pkCorporationInfo ? pkCorporationInfo->GetResourceMonopolyAndSize() : pkBuildingInfo->GetResourceMonopolyAndSize();
	for (uint uiPrereq = 0; uiPrereq < uiNumAndPrereq; uiPrereq++)
	{
		ResourceTypes eResource = pkCorporationInfo ? (ResourceTypes)pkCorporationInfo->GetResourceMonopolyAnd(uiPrereq) : (ResourceTypes)pkBuildingInfo->GetResourceMonopolyAnd(uiPrereq);
		CvResourceInfo* pkResource = GC.getResourceInfo(eResource);

		if (!GET_PLAYER(getOwner()).HasGlobalMonopoly(eResource))
		{
			int iOwnedNumResource = GET_PLAYER(getOwner()).getNumResourceTotal(eResource, false) + GET_PLAYER(getOwner()).getResourceExport(eResource);
			if (iOwnedNumResource > 0)
			{
				int iTotalNumResource = GC.getMap().getNumResources(eResource);
				if (iTotalNumResource > 0)
				{
					int iValue = ((iOwnedNumResource * 100) / iTotalNumResource);
					GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_NEED_MONOPOLY", pkResource->GetTextKey(), pkResource->GetIconString(), iValue);
				}
			}
			return false;
		}
		else if (GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(getOwner(), eResource))
		{
			return false;
		}
	}

	int iOrResources = 0;

	// ORs: City must have ONE of these nearby
	uint uiNumOrPrereq = pkCorporationInfo ? pkCorporationInfo->GetResourceMonopolyOrSize() : pkBuildingInfo->GetResourceMonopolyOrSize();
	for (uint uiPrereq = 0; uiPrereq < uiNumOrPrereq; uiPrereq++)
	{
		ResourceTypes eResource = pkCorporationInfo ? (ResourceTypes)pkCorporationInfo->GetResourceMonopolyOr(uiPrereq) : (ResourceTypes)pkBuildingInfo->GetResourceMonopolyOr(uiPrereq);
		CvResourceInfo* pkResource = GC.getResourceInfo(eResource);

		if (GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(getOwner(), eResource))
			continue;

		if (GET_PLAYER(getOwner()).HasGlobalMonopoly(eResource))
			return true;

		// If we get here it means we passed the AND tests but not one of the OR tests
		int iOwnedNumResource = GET_PLAYER(getOwner()).getNumResourceTotal(eResource, false) + GET_PLAYER(getOwner()).getResourceExport(eResource);
		if (iOwnedNumResource > 0)
		{
			int iTotalNumResource = GC.getMap().getNumResources(eResource);
			if (iTotalNumResource > 0)
			{
				int iValue = ((iOwnedNumResource * 100) / iTotalNumResource);
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_NEED_MONOPOLY", pkResource->GetTextKey(), pkResource->GetIconString(), iValue);
			}
		}

		// Increment counter for OR we don't have
		iOrResources++;
	}

	// No OR resource requirements (and passed the AND test above)
	return iOrResources == 0;
}

void CvCity::GetPlotsBoostedByBuilding(std::vector<int>& aiPlotList, BuildingTypes eBuilding)
{
	VALIDATE_OBJECT();
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if (pkBuildingInfo == NULL)
	{
		return;
	}
	aiPlotList.clear();

	// Loop through resources, find ones that would be increased by this building
	std::set<int> iResourceTypesBoosted;
	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		int* yieldsArr = pkBuildingInfo->GetResourceYieldChangeArray(iResourceLoop);
		for (int iYieldLoop = 0; iYieldLoop < NUM_YIELD_TYPES; iYieldLoop++)
		{
			// We only care about it being boosted so one yield type is sufficient, 
			// add it to the list of resources we care about and move on
			if (yieldsArr[iYieldLoop] > 0)
			{
				iResourceTypesBoosted.insert(iResourceLoop);
				break;
			}
		}
	}

	// Loop through terrain, find terrain types that would be increased by this building
	std::set<int> iTerrainTypesBoosted;
	for (int iTerrainLoop = 0; iTerrainLoop < GC.getNumTerrainInfos(); iTerrainLoop++)
	{
		int* yieldsArr = pkBuildingInfo->GetTerrainYieldChangeArray(iTerrainLoop);
		int* xYieldsArr = pkBuildingInfo->GetYieldPerXTerrainArray(iTerrainLoop);
		for (int iYieldLoop = 0; iYieldLoop < NUM_YIELD_TYPES; iYieldLoop++)
		{
			// We only care about it being boosted so one yield type is sufficient, 
			// add it to the list of terrain types we care about and move on
			if (yieldsArr[iYieldLoop] > 0 || xYieldsArr[iYieldLoop] > 0)
			{
				iTerrainTypesBoosted.insert(iTerrainLoop);
				break;
			}
		}
	}

	// Check if water tiles or resources are boosted
	bool bSeaPlotsBoosted = false;
	bool bSeaResourcesBoosted = false;
	bool bLakePlotsBoosted = false;
	bool bRiverPlotsBoosted = false;

	int* yieldsArr = pkBuildingInfo->GetSeaPlotYieldChangeArray();
	for (int iYieldLoop = 0; iYieldLoop < NUM_YIELD_TYPES; iYieldLoop++)
	{
		if (yieldsArr[iYieldLoop] > 0)
		{
			bSeaPlotsBoosted = true;
			break;
		}
	}
	yieldsArr = pkBuildingInfo->GetSeaResourceYieldChangeArray();
	for (int iYieldLoop = 0; iYieldLoop < NUM_YIELD_TYPES; iYieldLoop++)
	{
		if (yieldsArr[iYieldLoop] > 0)
		{
			bSeaResourcesBoosted = true;
			break;
		}
	}
	yieldsArr = pkBuildingInfo->GetLakePlotYieldChangeArray();
	for (int iYieldLoop = 0; iYieldLoop < NUM_YIELD_TYPES; iYieldLoop++)
	{
		if (yieldsArr[iYieldLoop] > 0)
		{
			bLakePlotsBoosted = true;
			break;
		}
	}
	yieldsArr = pkBuildingInfo->GetLakePlotYieldChangeGlobalArray();
	for (int iYieldLoop = 0; iYieldLoop < NUM_YIELD_TYPES; iYieldLoop++)
	{
		if (yieldsArr[iYieldLoop] > 0)
		{
			bLakePlotsBoosted = true;
			break;
		}
	}
	yieldsArr = pkBuildingInfo->GetRiverPlotYieldChangeArray();
	for (int iYieldLoop = 0; iYieldLoop < NUM_YIELD_TYPES; iYieldLoop++)
	{
		if (yieldsArr[iYieldLoop] > 0)
		{
			bRiverPlotsBoosted = true;
			break;
		}
	}

	// Loop through improvements, find improvements that would be increased by this building
	std::set<int> iImprovementTypesBoosted;
	for (int iImprovementLoop = 0; iImprovementLoop < GC.getNumImprovementInfos(); iImprovementLoop++)
	{
		int* yieldsArr = pkBuildingInfo->GetImprovementYieldChangeArray(iImprovementLoop);
		for (int iYieldLoop = 0; iYieldLoop < NUM_YIELD_TYPES; iYieldLoop++)
		{
			if (yieldsArr[iYieldLoop] > 0)
			{
				iImprovementTypesBoosted.insert(iImprovementLoop);
				break;
			}
		}
	}

	// Loop through features, find features that would be increased by this building
	std::set<int> iFeatureTypesBoosted;
	for (int iFeatureLoop = 0; iFeatureLoop < GC.getNumFeatureInfos(); iFeatureLoop++)
	{
		int* yieldsArr = pkBuildingInfo->GetFeatureYieldChangeArray(iFeatureLoop);
		int* xYieldsArr = pkBuildingInfo->GetYieldPerXFeatureArray(iFeatureLoop);
		for (int iYieldLoop = 0; iYieldLoop < NUM_YIELD_TYPES; iYieldLoop++)
		{
			if (yieldsArr[iYieldLoop] > 0 || xYieldsArr[iYieldLoop] > 0)
			{
				iFeatureTypesBoosted.insert(iFeatureLoop);
				break;
			}
		}
	}

	// Loop through tiles that can potentially be worked this city. If the tile contains 
	// a tile that's boosted, append it to the passed in vector reference
	for (int targetPlotIdx = 0; targetPlotIdx < RING_PLOTS[getWorkPlotDistance()]; targetPlotIdx++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(plot(), targetPlotIdx);
		// If it's owned and not by this city continue
		if (!pLoopPlot || (pLoopPlot->isOwned() && (pLoopPlot->getOwner() != getOwner())))
			continue;

		
		if (iResourceTypesBoosted.count(pLoopPlot->getResourceType(getTeam())))
		{
			aiPlotList.push_back(pLoopPlot->GetPlotIndex());
		}
		else if (iTerrainTypesBoosted.count(pLoopPlot->getTerrainType()))
		{
			aiPlotList.push_back(pLoopPlot->GetPlotIndex());
		}
		else if (bSeaPlotsBoosted && pLoopPlot->isWater() && !pLoopPlot->isLake())
		{
			aiPlotList.push_back(pLoopPlot->GetPlotIndex());
		}
		else if (bSeaResourcesBoosted && pLoopPlot->isWater() && pLoopPlot->getResourceType(getTeam()) != NO_RESOURCE)
		{
			aiPlotList.push_back(pLoopPlot->GetPlotIndex());
		}
		else if (bRiverPlotsBoosted && pLoopPlot->IsFeatureRiver())
		{
			aiPlotList.push_back(pLoopPlot->GetPlotIndex());
		}
		else if (iImprovementTypesBoosted.count(pLoopPlot->getImprovementType()))
		{
			aiPlotList.push_back(pLoopPlot->GetPlotIndex());
		}
		else if (iFeatureTypesBoosted.count(pLoopPlot->getFeatureType()))
		{
			aiPlotList.push_back(pLoopPlot->GetPlotIndex());
		}
	}
}

int CvCity::GetNumHiddenBuildings() const
{
	return m_inumHiddenBuildings;
}

void CvCity::SetBuildingHidden(BuildingTypes eBuilding)
{
	if (!IsBuildingHidden(eBuilding))
	{
		m_inumHiddenBuildings++;
	}
	m_abIsBuildingHidden[eBuilding] = true;
}

void CvCity::ClearHiddenBuildings()
{
	m_abIsBuildingHidden.clear();
	m_abIsBuildingHidden.resize(GC.getNumBuildingInfos(), false);
	std::fill(m_abIsBuildingHidden.begin(), m_abIsBuildingHidden.end(), false);
	m_inumHiddenBuildings = 0;
}

bool CvCity::IsBuildingHidden(BuildingTypes eBuilding) const
{
	return m_abIsBuildingHidden[eBuilding];
}

#if defined(MOD_BALANCE_CORE)
bool CvCity::IsBuildingFeatureValid(BuildingTypes eBuilding, CvString* toolTipSink) const
{
	VALIDATE_OBJECT();
	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if (pkBuildingInfo == NULL)
		return false;

	// ANDs: City must have ALL of these nearby
	for (int iFeatureLoop = 0; iFeatureLoop < GC.getNumFeatureInfos(); iFeatureLoop++)
	{
		FeatureTypes eFeature = (FeatureTypes)pkBuildingInfo->GetFeatureAnd(iFeatureLoop);

		// Doesn't require a feature in this AND slot
		if (eFeature == NO_FEATURE)
			continue;

		CvFeatureInfo* pkFeature = GC.getFeatureInfo(eFeature);
		if (pkFeature == NULL)
			continue;

		// City doesn't have feature locally - return false immediately
		if (!IsHasFeatureLocal(eFeature))
		{
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_LOCAL_FEATURE", pkFeature->GetTextKey());
			return false;
		}
	}

	int iOrFeatures = 0;

	// ORs: City must have ONE of these nearby
	for (int iFeatureLoop = 0; iFeatureLoop < GC.getNumFeatureInfos(); iFeatureLoop++)
	{
		FeatureTypes eFeature = (FeatureTypes)pkBuildingInfo->GetFeatureOr(iFeatureLoop);

		// Doesn't require a feature in this AND slot
		if (eFeature == NO_FEATURE)
			continue;

		CvFeatureInfo* pkFeature = GC.getFeatureInfo(eFeature);
		if (pkFeature == NULL)
			continue;

		// City has feature locally - return true immediately
		if (IsHasFeatureLocal(eFeature))
			return true;

		// If we get here it means we passed the AND tests but not one of the OR tests
		GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_LOCAL_FEATURE", pkFeature->GetTextKey());

		// Increment counter for OR we don't have
		iOrFeatures++;
	}

	// No OR resource requirements (and passed the AND test above)
	return iOrFeatures == 0;
}
#endif
//	--------------------------------------------------------------------------------
/// What Resource does this City want so that it goes into WLTKD?
ResourceTypes CvCity::GetResourceDemanded(bool bHideUnknown) const
{
	VALIDATE_OBJECT();
	ResourceTypes eResourceDemanded = static_cast<ResourceTypes>(m_iResourceDemanded);

	// If we're not hiding the result then don't bother with looking at tech
	if (!bHideUnknown)
	{
		return eResourceDemanded;
	}

	if (eResourceDemanded != NO_RESOURCE)
	{
		CvResourceInfo* pInfo = GC.getResourceInfo(eResourceDemanded);
		if (pInfo)
		{
			// Is there no Reveal Tech or do we have it?
			if (GET_TEAM(getTeam()).IsResourceRevealed(eResourceDemanded))
			{
				return eResourceDemanded;
			}
		}
	}

	// We don't have the Tech to reveal the currently demanded Resource
	return NO_RESOURCE;
}

//	--------------------------------------------------------------------------------
/// Sets what Resource this City wants so that it goes into WLTKD
void CvCity::SetResourceDemanded(ResourceTypes eResource)
{
	VALIDATE_OBJECT();
	m_iResourceDemanded = eResource;
}

//	--------------------------------------------------------------------------------
/// Picks a Resource for this City to want
void CvCity::DoPickResourceDemanded()
{
	if (!GET_PLAYER(getOwner()).isMajorCiv())
		return;

	ResourceTypes ePreviousResource = GetResourceDemanded(false);
	SetResourceDemanded(NO_RESOURCE);
	SetResourceDemandedCounter(0);

	if (MOD_BALANCE_VP && GetWeLoveTheKingDayCounter() > 0)
		return;

	// Create the list of invalid Luxury Resources
	set<ResourceTypes> localLuxuryResources;

	// Loop through all Plots near this City to see if there's Luxuries we should invalidate
	for (int iPlotLoop = 0; iPlotLoop < GetNumWorkablePlots(); iPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(getX(), getY(), iPlotLoop);
		if (pLoopPlot != NULL)
		{
			ResourceTypes eResource = pLoopPlot->getResourceType(getTeam());
			if (eResource != NO_RESOURCE)
			{
				if (GC.getResourceInfo(eResource)->getResourceUsage() == RESOURCEUSAGE_LUXURY)
				{
					localLuxuryResources.insert(eResource);
				}
			}
		}
	}

	// VP: Only resources on plots revealed by this player are valid
	set<ResourceTypes> DiscoveredLuxuryResources;
	if (MOD_BALANCE_VP)
	{
		// Go through the map and see which resources have been discovered by this player
		CvMap& theMap = GC.getMap();
		int iNumPlots = theMap.numPlots();
		TeamTypes eTeam = getTeam();
		for (int iI = 0; iI < iNumPlots; iI++)
		{
			CvPlot* pLoopPlot = theMap.plotByIndexUnchecked(iI);
			ResourceTypes eResource = pLoopPlot->getResourceType(eTeam); // This check will ignore resources that haven't been discovered by this player (tech)
			if (eResource != NO_RESOURCE)
			{
				CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
				if (pkResource && pkResource->getResourceUsage() == RESOURCEUSAGE_LUXURY && localLuxuryResources.find(eResource) == localLuxuryResources.end()
					&& DiscoveredLuxuryResources.find(eResource) == DiscoveredLuxuryResources.end())
				{
					if (pLoopPlot->isRevealed(eTeam, false))
						DiscoveredLuxuryResources.insert(eResource);
				}
			}
		}
	}

	// Create list of valid Luxuries
	vector<ResourceTypes> veValidLuxuryResources;
	CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResource = (ResourceTypes)iResourceLoop;

		// Is this a Luxury Resource?
		CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
		if (pkResource && pkResource->getResourceUsage() == RESOURCEUSAGE_LUXURY)
		{
			// VP: Can't reroll the same resource as before!
			if (MOD_BALANCE_VP && ePreviousResource == eResource)
				continue;

			// VP: No unknown tech resources
			if (MOD_BALANCE_VP && !GET_TEAM(getTeam()).IsResourceRevealed(eResource))
				continue;

			// Is the Resource actually on the map?
			if (GC.getMap().getNumResources(eResource) <= 0)
				continue;

			if (pkResource->isOnlyMinorCivs())
				continue;

			if (pLeague && pLeague->IsLuxuryHappinessBanned(eResource))
				continue;

			if (localLuxuryResources.find(eResource) != localLuxuryResources.end())
				continue;

			if (MOD_BALANCE_VP && DiscoveredLuxuryResources.find(eResource) == DiscoveredLuxuryResources.end())
				continue;

			if (!MOD_BALANCE_VP && GET_PLAYER(getOwner()).getNumResourceAvailable(eResource) > 0)
				continue;

			veValidLuxuryResources.push_back(eResource);
		}
	}

	// Is there actually anything in our vector? - 0 can be valid if we already have everything, for example
	if (veValidLuxuryResources.size() == 0)
	{
		return;
	}

	// Now pick a Luxury we can use
	uint uVectorIndex = GC.getGame().urandLimitExclusive(veValidLuxuryResources.size(), plot()->GetPseudoRandomSeed().mix(GET_PLAYER(getOwner()).GetPseudoRandomSeed()));
	ResourceTypes eResource = static_cast<ResourceTypes>(veValidLuxuryResources[uVectorIndex]);

	//hurk! STOP.
	if (eResource == NO_RESOURCE)
		return;

	SetResourceDemanded(eResource);

	// if we already have the resource, immediately enter WLTKD
	if (GET_PLAYER(getOwner()).getNumResourceAvailable(eResource) > 0)
	{
		int iWLTKD = MOD_BALANCE_VP ? /*20 in CP, 10 in VP*/ (GD_INT_GET(CITY_RESOURCE_WLTKD_TURNS) / 2) : GD_INT_GET(CITY_RESOURCE_WLTKD_TURNS);
		iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
		iWLTKD /= 100;

		ChangeWeLoveTheKingDayCounter(iWLTKD);

		CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
		if (pNotifications && !MOD_CORE_REDUCE_NOTIFICATIONS)
		{
			if (GET_PLAYER(getOwner()).GetPlayerTraits()->IsExpansionWLTKD())
			{
				Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UA_RESOURCE");
				strText << GC.getResourceInfo(eResource)->GetTextKey() << getNameKey() << iWLTKD << /*25*/ GD_INT_GET(WLTKD_GROWTH_MULTIPLIER);
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UA_RESOURCE");
				strSummary << getNameKey();
				pNotifications->Add(NOTIFICATION_REQUEST_RESOURCE, strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), eResource);
			}
			else
			{
				Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD");
				strText << GC.getResourceInfo(eResource)->GetTextKey() << getNameKey();
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD");
				strSummary << getNameKey();
				pNotifications->Add(NOTIFICATION_REQUEST_RESOURCE, strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), eResource);
			}
		}
	}
	else
	{
		// Notification
		CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
		if (pNotifications)
		{
			if (GET_PLAYER(getOwner()).GetPlayerTraits()->IsExpansionWLTKD())
			{
				Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_RESOURCE_DEMAND_UA");
				strText << getNameKey() << GC.getResourceInfo(eResource)->GetTextKey();
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_RESOURCE_DEMAND");
				strSummary << getNameKey() << GC.getResourceInfo(eResource)->GetTextKey();
				pNotifications->Add(NOTIFICATION_REQUEST_RESOURCE, strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), eResource);
			}
			else
			{
				Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_RESOURCE_DEMAND");
				strText << getNameKey() << GC.getResourceInfo(eResource)->GetTextKey();
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_RESOURCE_DEMAND");
				strSummary << getNameKey() << GC.getResourceInfo(eResource)->GetTextKey();
				pNotifications->Add(NOTIFICATION_REQUEST_RESOURCE, strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), eResource);
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Checks to see if we have the Resource demanded and if so starts WLTKD in this City
void CvCity::DoTestResourceDemanded()
{
	VALIDATE_OBJECT();
	ResourceTypes eResource = GetResourceDemanded();

	if (eResource == NO_RESOURCE && GetResourceDemandedCountdown() <= 0)
	{
		DoPickResourceDemanded();
		eResource = GetResourceDemanded();
	}

	if (GetWeLoveTheKingDayCounter() > 0)
	{
		ChangeWeLoveTheKingDayCounter(-1);

		// WLTKD over!
		if (GetWeLoveTheKingDayCounter() == 0)
		{
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityEndsWLTKD, getOwner(), getX(), getY(), 0);
			DoPickResourceDemanded(); // this can immediately start another WLTKD
			eResource = GetResourceDemanded();
		}
	}

	if (GetWeLoveTheKingDayCounter() == 0)
	{
		if (eResource != NO_RESOURCE)
		{
			// Do we have the right Resource?
			if (GET_PLAYER(getOwner()).getNumResourceAvailable(eResource) > 0)
			{
				int iWLTKD = MOD_BALANCE_VP ? /*20 in CP, 10 in VP*/ (GD_INT_GET(CITY_RESOURCE_WLTKD_TURNS) / 2) : GD_INT_GET(CITY_RESOURCE_WLTKD_TURNS);
				iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iWLTKD /= 100;

				ChangeWeLoveTheKingDayCounter(iWLTKD);

				CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
				if (pNotifications && !MOD_CORE_REDUCE_NOTIFICATIONS)
				{
					if (GET_PLAYER(getOwner()).GetPlayerTraits()->IsExpansionWLTKD())
					{
						Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UA_RESOURCE");
						strText << GC.getResourceInfo(eResource)->GetTextKey() << getNameKey() << iWLTKD << /*25*/ GD_INT_GET(WLTKD_GROWTH_MULTIPLIER);
						Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UA_RESOURCE");
						strSummary << getNameKey();
						pNotifications->Add(NOTIFICATION_REQUEST_RESOURCE, strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), eResource);
					}
					else
					{
						Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD");
						strText << GC.getResourceInfo(eResource)->GetTextKey() << getNameKey();
						Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD");
						strSummary << getNameKey();
						pNotifications->Add(NOTIFICATION_REQUEST_RESOURCE, strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), eResource);
					}
				}
			}
			else
			{
				ChangeResourceDemandedCounter(1);

				// Is it time to pick something new?
				if (GD_INT_GET(WLTKD_RESOURCE_RESET_TURNS) > 0)
				{
					int iResetTurns = /*0 in CP, 30 in VP*/ GD_INT_GET(WLTKD_RESOURCE_RESET_TURNS);
					iResetTurns *= GC.getGame().getGameSpeedInfo().getTrainPercent();
					iResetTurns /= 100;

					if (GetResourceDemandedCounter() >= iResetTurns)
						DoPickResourceDemanded();
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Figure out how long it should be before this City demands a Resource
void CvCity::DoSeedResourceDemandedCountdown()
{
	VALIDATE_OBJECT();

	int iNumTurns = /*15*/ GD_INT_GET(RESOURCE_DEMAND_COUNTDOWN_BASE);

	if (isCapital())
	{
		iNumTurns += /*25*/ GD_INT_GET(RESOURCE_DEMAND_COUNTDOWN_CAPITAL_ADD);
	}

	uint uRand = static_cast<uint>(/*10*/ GD_INT_GET(RESOURCE_DEMAND_COUNTDOWN_RAND));
	iNumTurns = static_cast<int>(static_cast<uint>(iNumTurns) + GC.getGame().urandLimitExclusive(uRand, plot()->GetPseudoRandomSeed().mix(GET_PLAYER(getOwner()).GetPseudoRandomSeed())));
	SetResourceDemandedCountdown(iNumTurns);
}

//	--------------------------------------------------------------------------------
/// How long before we pick a Resource to demand
int CvCity::GetResourceDemandedCountdown() const
{
	VALIDATE_OBJECT();
	return m_iDemandResourceCounter;
}

//	--------------------------------------------------------------------------------
/// How long before we pick a Resource to demand
void CvCity::SetResourceDemandedCountdown(int iValue)
{
	VALIDATE_OBJECT();
	m_iDemandResourceCounter = iValue;
}

//	--------------------------------------------------------------------------------
/// How long before we pick a Resource to demand
void CvCity::ChangeResourceDemandedCountdown(int iChange)
{
	VALIDATE_OBJECT();
	if (iChange != 0)
		m_iDemandResourceCounter += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::getFoodTurnsLeft() const
{
	VALIDATE_OBJECT();
	int iDeltaPerTurn = foodDifferenceTimes100(false);
	int iFoodStored = getFoodTimes100();
	int iFoodNeededToGrow = (growthThreshold() * 100 - iFoodStored);

	//growing
	if (iDeltaPerTurn > 0)
	{
		if (iFoodNeededToGrow > 0)
		{
			int iTurnsLeft = iFoodNeededToGrow / iDeltaPerTurn;
			//correct for truncation
			if (iTurnsLeft * iDeltaPerTurn < iFoodNeededToGrow)
				iTurnsLeft++;

			return iTurnsLeft;
		}
		else //already over the threshold
			return 0;
	}
	//starving
	else if (iDeltaPerTurn < 0)
	{
		int iTurnsLeft = iFoodStored / iDeltaPerTurn;
		//correct for truncation
		if (iTurnsLeft * iDeltaPerTurn < iFoodStored)
			iTurnsLeft++;

		return -iTurnsLeft;
	}

	//stagnation, let's assume this is a large number
	return iFoodNeededToGrow;
}

//	--------------------------------------------------------------------------------
bool CvCity::isProduction() const
{
	VALIDATE_OBJECT();
	return (headOrderQueueNode() != NULL);
}


//	--------------------------------------------------------------------------------
bool CvCity::isProductionLimited() const
{
	VALIDATE_OBJECT();
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_TRAIN:
		{
			CvUnitEntry* pkUnitInfo = GC.getUnitInfo((UnitTypes)(pOrderNode->iData1));
			if (pkUnitInfo)
			{
				return isLimitedUnitClass((UnitClassTypes)(pkUnitInfo->GetUnitClassType()));
			}
		}
		break;

		case ORDER_CONSTRUCT:
		{
			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo((BuildingTypes)pOrderNode->iData1);
			if (pkBuildingInfo)
			{
				return isLimitedWonderClass(pkBuildingInfo->GetBuildingClassInfo());
			}
		}
		break;

		case ORDER_CREATE:
			return isLimitedProject((ProjectTypes)(pOrderNode->iData1));
			break;

		case ORDER_MAINTAIN:
			break;

		default:
			ASSERT_DEBUG(false, "pOrderNode->eOrderType failed to match a valid option");
			break;
		}
	}

	return false;
}


//	--------------------------------------------------------------------------------
bool CvCity::isProductionUnit() const
{
	VALIDATE_OBJECT();
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		return (pOrderNode->eOrderType == ORDER_TRAIN);
	}

	return false;
}

//	--------------------------------------------------------------------------------
bool CvCity::isProductionBuilding() const
{
	VALIDATE_OBJECT();
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		return (pOrderNode->eOrderType == ORDER_CONSTRUCT);
	}

	return false;
}


//	--------------------------------------------------------------------------------
bool CvCity::isProductionProject() const
{
	VALIDATE_OBJECT();
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		return (pOrderNode->eOrderType == ORDER_CREATE);
	}

	return false;
}

//	--------------------------------------------------------------------------------
bool CvCity::isProductionProcess() const
{
	VALIDATE_OBJECT();
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		return (pOrderNode->eOrderType == ORDER_MAINTAIN);
	}

	return false;
}


//	--------------------------------------------------------------------------------
bool CvCity::canContinueProduction(OrderData order)
{
	VALIDATE_OBJECT();
	switch (order.eOrderType)
	{
	case ORDER_TRAIN:
		return canTrain((UnitTypes)(order.iData1), true);
		break;

	case ORDER_CONSTRUCT:
		return canConstruct((BuildingTypes)(order.iData1), true);
		break;

	case ORDER_CREATE:
		return canCreate((ProjectTypes)(order.iData1), true);
		break;

	case ORDER_MAINTAIN:
		return canMaintain((ProcessTypes)(order.iData1), true);
		break;

	default:
		ASSERT_DEBUG(false, "order.eOrderType failed to match a valid option");
		break;
	}

	return false;
}


//	--------------------------------------------------------------------------------
int CvCity::getProductionExperience(UnitTypes eUnit) const
{
	VALIDATE_OBJECT();
	CvPlayerAI& kOwner = GET_PLAYER(getOwner());
	int iExperience = getFreeExperience() + kOwner.getFreeExperience();
	int iExperienceModifier = 0;

	if (eUnit != NO_UNIT)
	{
		CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
		if (pkUnitInfo)
		{
			DomainTypes eDomain = pkUnitInfo->GetDomainType();
			UnitCombatTypes eUnitCombat = (UnitCombatTypes)(pkUnitInfo->GetUnitCombatType());

			if (eUnitCombat != NO_UNITCOMBAT)
			{
				iExperience += getUnitCombatFreeExperience(eUnitCombat);
				iExperience += kOwner.getUnitCombatFreeExperiences(eUnitCombat);
			}
			if (eDomain != NO_DOMAIN)
			{
				iExperience += getDomainFreeExperience(eDomain);
				iExperience += getDomainFreeExperienceFromGreatWorks(eDomain);
				iExperience += getDomainFreeExperienceFromGreatWorksGlobal(eDomain);
				iExperience += kOwner.GetDomainFreeExperience(eDomain);
				iExperienceModifier += kOwner.GetPlayerTraits()->GetDomainFreeExperienceModifier(pkUnitInfo->GetDomainType());
			}

			iExperience += GetExperienceFromPreviousGoldenAges();
			iExperience += getSpecialistFreeExperience();
		}
	}

	if (iExperienceModifier != 0)
	{
		iExperience *= (100 + iExperienceModifier);
		iExperience /= 100;
	}

	return std::max(0, iExperience);
}


//	--------------------------------------------------------------------------------
void CvCity::addProductionExperience(CvUnit* pUnit, bool bHalveXP, bool bGoldPurchase) const
{
	VALIDATE_OBJECT();
	bHalveXP = (bHalveXP || (bGoldPurchase && MOD_BALANCE_CORE_HALF_XP_PURCHASE && GET_PLAYER(getOwner()).GetNoXPLossUnitPurchase() <= 0 && !pUnit->getUnitInfo().CanMoveAfterPurchase()));

	if (pUnit->canAcquirePromotionAny())
	{
		pUnit->changeExperienceTimes100(getProductionExperience(pUnit->getUnitType()) * 100 / ((bHalveXP) ? 2 : 1));

		// Carthage UA: Bonus XP to Gold purchased units
		int iBonusXP = bGoldPurchase ? GET_PLAYER(getOwner()).GetPlayerTraits()->GetPurchasedUnitsBonusXP() : 0;
		if (iBonusXP > 0)
		{
			int iEra = GET_PLAYER(getOwner()).GetCurrentEra();
			if (iEra <= 0)
				iEra = 1;

			pUnit->changeExperienceTimes100(iBonusXP * iEra * 100);
		}

		// XP2 Achievement
		if (MOD_API_ACHIEVEMENTS && getOwner() != NO_PLAYER)
		{
			CvPlayer& kOwner = GET_PLAYER(getOwner());
			if (!GC.getGame().isGameMultiPlayer() && kOwner.isHuman() && kOwner.isLocalPlayer())
			{
				// This unit begins with a promotion from XP, and part of that XP came from filled Great Work slots
				if ((pUnit->getExperienceTimes100() / 100) >= pUnit->experienceNeeded() && getDomainFreeExperienceFromGreatWorks(pUnit->getUnitInfo().GetDomainType()) > 0)
				{
					// We have a Royal Library
					static BuildingTypes eRoyalLibrary = (BuildingTypes)GC.getInfoTypeForString("BUILDING_ROYAL_LIBRARY", true);
					if (eRoyalLibrary != NO_BUILDING && GetCityBuildings()->GetNumBuilding(eRoyalLibrary) > 0)
					{
						gDLL->UnlockAchievement(ACHIEVEMENT_XP2_19);
					}
				}
			}
		}
	}

	vector<PromotionTypes> freePromotions = getFreePromotions();
	for (size_t iI = 0; iI < freePromotions.size(); iI++)
	{
		CvPromotionEntry* pkPromotionInfo = GC.getPromotionInfo(freePromotions[iI]);
		if (pkPromotionInfo)
		{
			if ((pUnit->getUnitCombatType() != NO_UNITCOMBAT && pkPromotionInfo->GetUnitCombatClass(pUnit->getUnitCombatType()))
				|| (::IsPromotionValidForCivilianUnitType(freePromotions[iI], pUnit->getUnitType())))
			{
				pUnit->setHasPromotion(freePromotions[iI], true);
			}
		}
	}

	pUnit->testPromotionReady();
}


//	--------------------------------------------------------------------------------
UnitTypes CvCity::getProductionUnit() const
{
	VALIDATE_OBJECT();
	const OrderData* pOrderNode = headOrderQueueNode();
	if (pOrderNode)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_TRAIN:
			return static_cast<UnitTypes>(pOrderNode->iData1);

		case ORDER_CONSTRUCT:
		case ORDER_CREATE:
		case ORDER_MAINTAIN:
			return NO_UNIT;

		default:
			UNREACHABLE();
		}
	}

	return NO_UNIT;
}

//	--------------------------------------------------------------------------------
UnitAITypes CvCity::getProductionUnitAI() const
{
	VALIDATE_OBJECT();
	const OrderData* pOrderNode = headOrderQueueNode();
	if (pOrderNode)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_TRAIN:
			return static_cast<UnitAITypes>(pOrderNode->iData2);

		case ORDER_CONSTRUCT:
		case ORDER_CREATE:
		case ORDER_MAINTAIN:
			return NO_UNITAI;

		default:
			UNREACHABLE();
		}
	}

	return NO_UNITAI;
}

//	--------------------------------------------------------------------------------
BuildingTypes CvCity::getProductionBuilding() const
{
	VALIDATE_OBJECT();
	const OrderData* pOrderNode = headOrderQueueNode();
	if (pOrderNode)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_CONSTRUCT:
			return static_cast<BuildingTypes>(pOrderNode->iData1);

		case ORDER_TRAIN:
		case ORDER_CREATE:
		case ORDER_MAINTAIN:
			return NO_BUILDING;

		default:
			UNREACHABLE();
		}
	}

	return NO_BUILDING;
}

//	--------------------------------------------------------------------------------
ProjectTypes CvCity::getProductionProject() const
{
	VALIDATE_OBJECT();
	const OrderData* pOrderNode = headOrderQueueNode();
	if (pOrderNode)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_CREATE:
			return static_cast<ProjectTypes>(pOrderNode->iData1);

		case ORDER_TRAIN:
		case ORDER_CONSTRUCT:
		case ORDER_MAINTAIN:
			return NO_PROJECT;

		default:
			UNREACHABLE();
		}
	}

	return NO_PROJECT;
}

//	--------------------------------------------------------------------------------
ProcessTypes CvCity::getProductionProcess() const
{
	VALIDATE_OBJECT();
	const OrderData* pOrderNode = headOrderQueueNode();
	if (pOrderNode)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_MAINTAIN:
			return static_cast<ProcessTypes>(pOrderNode->iData1);

		case ORDER_TRAIN:
		case ORDER_CONSTRUCT:
		case ORDER_CREATE:
			return NO_PROCESS;

		default:
			UNREACHABLE();
		}
	}

	return NO_PROCESS;
}

//	--------------------------------------------------------------------------------
const char* CvCity::getProductionName() const
{
	VALIDATE_OBJECT();
	const OrderData* pOrderNode = headOrderQueueNode();
	if (pOrderNode)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_TRAIN:
		{
			CvUnitEntry* pkUnitInfo = GC.getUnitInfo(static_cast<UnitTypes>(pOrderNode->iData1));
			return pkUnitInfo->GetDescription();
		}

		case ORDER_CONSTRUCT:
		{
			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(static_cast<BuildingTypes>(pOrderNode->iData1));
			return pkBuildingInfo->GetDescription();
		}

		case ORDER_CREATE:
		{
			CvProjectEntry* pkProjectInfo = GC.getProjectInfo(static_cast<ProjectTypes>(pOrderNode->iData1));
			return pkProjectInfo->GetDescription();
		}

		case ORDER_MAINTAIN:
		{
			CvProcessInfo* pkProcessInfo = GC.getProcessInfo(static_cast<ProcessTypes>(pOrderNode->iData1));
			return pkProcessInfo->GetDescription();
		}

		default:
			UNREACHABLE();
		}
	}

	return "";
}


//	--------------------------------------------------------------------------------
int CvCity::getGeneralProductionTurnsLeft() const
{
	VALIDATE_OBJECT();
	const OrderData* pOrderNode = headOrderQueueNode();
	if (pOrderNode)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_TRAIN:
			return getProductionTurnsLeft(static_cast<UnitTypes>(pOrderNode->iData1), 0);

		case ORDER_CONSTRUCT:
			return getProductionTurnsLeft(static_cast<BuildingTypes>(pOrderNode->iData1), 0);

		case ORDER_CREATE:
			return getProductionTurnsLeft(static_cast<ProjectTypes>(pOrderNode->iData1), 0);

		case ORDER_MAINTAIN:
			return getProductionTurnsLeft(static_cast<ProcessTypes>(pOrderNode->iData1), 0);

		default:
			UNREACHABLE();
		}
	}

	return 0;
}


//	--------------------------------------------------------------------------------
const char* CvCity::getProductionNameKey() const
{
	VALIDATE_OBJECT();
	const OrderData* pOrderNode = headOrderQueueNode();
	if (pOrderNode)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_TRAIN:
		{
			CvUnitEntry* pkUnitInfo = GC.getUnitInfo(static_cast<UnitTypes>(pOrderNode->iData1));
			return pkUnitInfo->GetTextKey();
		}

		case ORDER_CONSTRUCT:
		{
			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(static_cast<BuildingTypes>(pOrderNode->iData1));
			return pkBuildingInfo->GetTextKey();
		}

		case ORDER_CREATE:
		{
			CvProjectEntry* pkProjectInfo = GC.getProjectInfo(static_cast<ProjectTypes>(pOrderNode->iData1));
			return pkProjectInfo->GetTextKey();
		}

		case ORDER_MAINTAIN:
		{
			CvProcessInfo* pkProcessInfo = GC.getProcessInfo(static_cast<ProcessTypes>(pOrderNode->iData1));
			return pkProcessInfo->GetTextKey();
		}

		default:
			UNREACHABLE();
		}
	}

	return "";
}

//	--------------------------------------------------------------------------------
bool CvCity::isProductionSpaceshipPart() const
{
	VALIDATE_OBJECT();
	UnitTypes eCurrentUnit = getProductionUnit();
	if (eCurrentUnit != NO_UNIT)
	{
		CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eCurrentUnit);
		if (pkUnitInfo && pkUnitInfo->GetSpaceshipProject() != NO_PROJECT)
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
bool isUnitTypeFoodProduction(PlayerTypes ePlayer, UnitTypes eUnit)
{
	CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
	if (pkUnitInfo == NULL)
		return false;

	if (pkUnitInfo->IsFoodProduction())
	{
		return true;
	}

	if (GET_PLAYER(ePlayer).isMilitaryFoodProduction())
	{
		if (pkUnitInfo->IsMilitaryProduction())
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
bool CvCity::isFoodProduction() const
{
	VALIDATE_OBJECT();
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_TRAIN:
			return isUnitTypeFoodProduction(getOwner(), (UnitTypes)(pOrderNode->iData1));
			break;

		case ORDER_CONSTRUCT:
		case ORDER_CREATE:
		case ORDER_MAINTAIN:
			break;

		default:
			ASSERT_DEBUG(false, "pOrderNode->eOrderType failed to match a valid option");
			break;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
int CvCity::getFirstUnitOrder(UnitTypes eUnit) const
{
	VALIDATE_OBJECT();
	int iCount = 0;
	const OrderData* pOrderNode = headOrderQueueNode();

	while (pOrderNode != NULL)
	{
		if (pOrderNode->eOrderType == ORDER_TRAIN)
		{
			if (pOrderNode->iData1 == eUnit)
			{
				return iCount;
			}
		}

		iCount++;

		pOrderNode = nextOrderQueueNode(pOrderNode);
	}

	return -1;
}


//	--------------------------------------------------------------------------------
int CvCity::getFirstBuildingOrder(BuildingTypes eBuilding) const
{
	VALIDATE_OBJECT();
	int iCount = 0;
	const OrderData* pOrderNode = headOrderQueueNode();

	while (pOrderNode != NULL)
	{
		if (pOrderNode->eOrderType == ORDER_CONSTRUCT)
		{
			if (pOrderNode->iData1 == eBuilding)
			{
				return iCount;
			}
		}

		iCount++;

		pOrderNode = nextOrderQueueNode(pOrderNode);
	}

	return -1;
}
bool CvCity::isBuildingInQueue(BuildingTypes eBuilding) const
{
	VALIDATE_OBJECT();
	const OrderData* pOrderNode = headOrderQueueNode();

	while (pOrderNode != NULL)
	{
		if (pOrderNode->eOrderType == ORDER_CONSTRUCT)
		{
			if (pOrderNode->iData1 == eBuilding)
			{
				return true;
			}
		}

		pOrderNode = nextOrderQueueNode(pOrderNode);
	}

	return false;
}


//	--------------------------------------------------------------------------------
int CvCity::getFirstProjectOrder(ProjectTypes eProject) const
{
	VALIDATE_OBJECT();
	int iCount = 0;
	const OrderData* pOrderNode = headOrderQueueNode();

	while (pOrderNode != NULL)
	{
		if (pOrderNode->eOrderType == ORDER_CREATE)
		{
			if (pOrderNode->iData1 == eProject)
			{
				return iCount;
			}
		}

		iCount++;

		pOrderNode = nextOrderQueueNode(pOrderNode);
	}

	return -1;
}

//	--------------------------------------------------------------------------------
int CvCity::getNumTrainUnitAI(UnitAITypes eUnitAI) const
{
	VALIDATE_OBJECT();
	int iCount = 0;
	const OrderData* pOrderNode = headOrderQueueNode();

	while (pOrderNode != NULL)
	{
		if (pOrderNode->eOrderType == ORDER_TRAIN)
		{
			if (pOrderNode->iData2 == eUnitAI)
			{
				iCount++;
			}
		}

		pOrderNode = nextOrderQueueNode(pOrderNode);
	}

	return iCount;
}


//	--------------------------------------------------------------------------------
int CvCity::getProduction() const
{
	VALIDATE_OBJECT();
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_TRAIN:
			return getUnitProduction((UnitTypes)(pOrderNode->iData1));
			break;

		case ORDER_CONSTRUCT:
			return m_pCityBuildings->GetBuildingProduction((BuildingTypes)(pOrderNode->iData1));
			break;

		case ORDER_CREATE:
			return getProjectProduction((ProjectTypes)(pOrderNode->iData1));
			break;

		case ORDER_MAINTAIN:
#if defined(MOD_PROCESS_STOCKPILE)
			return getProcessProduction((ProcessTypes)(pOrderNode->iData1));
#endif
			break;

		default:
			ASSERT_DEBUG(false, "pOrderNode->eOrderType failed to match a valid option");
			break;
		}
	}

	return 0;
}


//	--------------------------------------------------------------------------------
int CvCity::getProductionTimes100() const
{
	VALIDATE_OBJECT();
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_TRAIN:
			return getUnitProductionTimes100((UnitTypes)(pOrderNode->iData1));
			break;

		case ORDER_CONSTRUCT:
			return m_pCityBuildings->GetBuildingProductionTimes100((BuildingTypes)(pOrderNode->iData1));
			break;

		case ORDER_CREATE:
			return getProjectProductionTimes100((ProjectTypes)(pOrderNode->iData1));
			break;

		case ORDER_MAINTAIN:
#if defined(MOD_PROCESS_STOCKPILE)
			return getProcessProductionTimes100((ProcessTypes)(pOrderNode->iData1));
#endif
			break;

		default:
			ASSERT_DEBUG(false, "pOrderNode->eOrderType failed to match a valid option");
			break;
		}
	}

	return 0;
}


//	--------------------------------------------------------------------------------
int CvCity::getProductionNeeded() const
{
	VALIDATE_OBJECT();
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_TRAIN:
			return getProductionNeeded((UnitTypes)(pOrderNode->iData1));
			break;

		case ORDER_CONSTRUCT:
			return getProductionNeeded((BuildingTypes)(pOrderNode->iData1));
			break;

		case ORDER_CREATE:
			return getProductionNeeded((ProjectTypes)(pOrderNode->iData1));
			break;

		case ORDER_MAINTAIN:
#if defined(MOD_PROCESS_STOCKPILE)
			return getProductionNeeded((ProcessTypes)(pOrderNode->iData1));
#endif
			break;

		default:
			ASSERT_DEBUG(false, "pOrderNode->eOrderType failed to match a valid option");
			break;
		}
	}

	return INT_MAX;
}

//	--------------------------------------------------------------------------------
int CvCity::getProductionNeeded(UnitTypes eUnit, bool bIgnoreInvestment) const
{
	VALIDATE_OBJECT();
	int iNumProductionNeeded = GET_PLAYER(getOwner()).getProductionNeeded(eUnit, false);

	if (eUnit != NO_UNIT)
	{
		CvUnitEntry* pGameUnit = GC.getUnitInfo(eUnit);
		UnitClassTypes eUnitClass = (UnitClassTypes)pGameUnit->GetUnitClassType();

		if (MOD_RESOURCES_PRODUCTION_COST_MODIFIERS)
		{
			int iCostMod = 0;

			UnitCombatTypes eUnitCombat = (UnitCombatTypes)pGameUnit->GetUnitCombatType();
			EraTypes eUnitEra = (EraTypes)pGameUnit->GetEra();

			if (eUnitEra == NO_ERA)
			{
				eUnitEra = GET_PLAYER(getOwner()).GetCurrentEra();
			}

			if (eUnitCombat != NO_UNITCOMBAT && eUnitEra != NO_ERA)
			{
				for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
				{
					const ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);
					CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
					if (pkResource && pkResource->isHasUnitCombatProductionCostModifiersLocal() && IsHasResourceLocal(eResource, false))
					{
						iCostMod += pkResource->getUnitCombatProductionCostModifiersLocal(eUnitCombat, eUnitEra);
					}
				}
			}

			// Cost modifiers must be applied before the investment code
			iNumProductionNeeded *= (iCostMod + 100);
			iNumProductionNeeded /= 100;
		}

		if (MOD_BALANCE_CORE_UNIT_INVESTMENTS || (MOD_BALANCE_CORE && pGameUnit->GetSpaceshipProject() != NO_PROJECT))
		{
			if (IsUnitInvestment(eUnitClass) && !bIgnoreInvestment)
			{
				iNumProductionNeeded -= GetUnitCostInvestmentReduction(eUnitClass);
			}
		}
	}

	return max(1, iNumProductionNeeded);
}

//	--------------------------------------------------------------------------------
int CvCity::getProductionNeeded(BuildingTypes eBuilding, bool bIgnoreInvestment) const
{
	ASSERT_DEBUG(eBuilding != NO_BUILDING);
	VALIDATE_OBJECT();

	CvPlayer& kOwner = GET_PLAYER(getOwner());
	int iNumProductionNeeded = kOwner.getProductionNeeded(eBuilding);
	const CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	const BuildingClassTypes eBuildingClass = pkBuildingInfo->GetBuildingClassType();

	if (MOD_RESOURCES_PRODUCTION_COST_MODIFIERS)
	{
		int iCostMod = 0;
		EraTypes eBuildingEra = static_cast<EraTypes>(pkBuildingInfo->GetEra());
		if (eBuildingEra == NO_ERA)
			eBuildingEra = kOwner.GetCurrentEra();

		bool bWonder = false;
		if (eBuildingClass != NO_BUILDINGCLASS)
		{
			const CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
			bWonder = isWorldWonderClass(*pkBuildingClassInfo) || isTeamWonderClass(*pkBuildingClassInfo) || isNationalWonderClass(*pkBuildingClassInfo);
		}

		if (!bWonder)
		{
			for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
			{
				const ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);
				const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);
				if (pkResourceInfo->isHasBuildingProductionCostModifiersLocal() && IsHasResourceLocal(eResource, false))
				{
					iCostMod += pkResourceInfo->getBuildingProductionCostModifiersLocal(eBuildingEra);
				}
			}
		}

		// Cost modifiers must be applied before the investment code
		iNumProductionNeeded *= iCostMod + 100;
		iNumProductionNeeded /= 100;
	}

	if (MOD_BALANCE_CORE_BUILDING_INVESTMENTS && !bIgnoreInvestment && eBuildingClass != NO_BUILDINGCLASS && IsBuildingInvestment(eBuildingClass))
	{
		iNumProductionNeeded -= GetBuildingCostInvestmentReduction(eBuildingClass);
	}

	return max(1, iNumProductionNeeded);
}

//	--------------------------------------------------------------------------------
int CvCity::getProductionNeeded(ProjectTypes eProject) const
{
	VALIDATE_OBJECT();
	int iNumProductionNeeded = GET_PLAYER(getOwner()).getProductionNeeded(eProject);

	CvProjectEntry* pProject = GC.getProjectInfo(eProject);
	if (pProject != NULL)
	{
		iNumProductionNeeded += pProject->CostScalerNumberOfRepeats() * getProjectCount(eProject);
		iNumProductionNeeded += pProject->CostScalerEra() * GET_PLAYER(getOwner()).GetCurrentEra();
	}

	return max(1, iNumProductionNeeded);
}

//	--------------------------------------------------------------------------------
int CvCity::getProductionTurnsLeft() const
{
	VALIDATE_OBJECT();
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_TRAIN:
			return getProductionTurnsLeft(((UnitTypes)(pOrderNode->iData1)), 0);
			break;

		case ORDER_CONSTRUCT:
			return getProductionTurnsLeft(((BuildingTypes)(pOrderNode->iData1)), 0);
			break;

		case ORDER_CREATE:
			return getProductionTurnsLeft(((ProjectTypes)(pOrderNode->iData1)), 0);
			break;

		case ORDER_MAINTAIN:
#if defined(MOD_PROCESS_STOCKPILE)
			return getProductionTurnsLeft(((ProcessTypes)(pOrderNode->iData1)), 0);
#endif
			break;

		default:
			ASSERT_DEBUG(false, "pOrderNode->eOrderType failed to match a valid option");
			break;
		}
	}

	return INT_MAX;
}

//	--------------------------------------------------------------------------------
int CvCity::getUnitTotalProductionTurns(UnitTypes eUnit) const
{
	VALIDATE_OBJECT();
	int iProductionNeeded = getProductionNeeded(eUnit) * 100;
	int iProductionModifier = getProductionModifier(eUnit);
	return getProductionTurnsLeft(iProductionNeeded, 0,
		getProductionDifferenceTimes100(iProductionNeeded, 0, iProductionModifier, isUnitTypeFoodProduction(getOwner(), eUnit), true),
		getProductionDifferenceTimes100(iProductionNeeded, 0, iProductionModifier, isUnitTypeFoodProduction(getOwner(), eUnit), false));
}

//	--------------------------------------------------------------------------------
int CvCity::getProductionTurnsLeft(UnitTypes eUnit, int iNum) const
{
	VALIDATE_OBJECT();
	int iProduction = 0;
	int iFirstUnitOrder = getFirstUnitOrder(eUnit);

	if ((iFirstUnitOrder == -1) || (iFirstUnitOrder == iNum))
	{
		iProduction += getUnitProductionTimes100(eUnit);
	}

	int iProductionNeeded = getProductionNeeded(eUnit) * 100;
	int iProductionModifier = getProductionModifier(eUnit);

	return getProductionTurnsLeft(iProductionNeeded, iProduction,
		getProductionDifferenceTimes100(iProductionNeeded, iProduction, iProductionModifier, isUnitTypeFoodProduction(getOwner(), eUnit), (iNum == 0)),
		getProductionDifferenceTimes100(iProductionNeeded, iProduction, iProductionModifier, isUnitTypeFoodProduction(getOwner(), eUnit), false));
}


//	--------------------------------------------------------------------------------
int CvCity::getProductionTurnsLeft(BuildingTypes eBuilding, int iNum) const
{
	ASSERT_DEBUG(eBuilding != NO_BUILDING);
	VALIDATE_OBJECT();
	int iProduction = 0;
	int iFirstBuildingOrder = getFirstBuildingOrder(eBuilding);

	if ((iFirstBuildingOrder == -1) || (iFirstBuildingOrder == iNum))
	{
		iProduction += m_pCityBuildings->GetBuildingProductionTimes100(eBuilding);
	}

	int iProductionNeeded = getProductionNeeded(eBuilding) * 100;
	int iProductionModifier = getProductionModifier(eBuilding);

	return getProductionTurnsLeft(iProductionNeeded, iProduction,
		getProductionDifferenceTimes100(iProductionNeeded, iProduction, iProductionModifier, false, (iNum == 0)),
		getProductionDifferenceTimes100(iProductionNeeded, iProduction, iProductionModifier, false, false));
}


//	--------------------------------------------------------------------------------
int CvCity::getProductionTurnsLeft(ProjectTypes eProject, int iNum) const
{
	VALIDATE_OBJECT();
	int iProduction = 0;
	int iFirstProjectOrder = getFirstProjectOrder(eProject);

	if ((iFirstProjectOrder == -1) || (iFirstProjectOrder == iNum))
	{
		iProduction += getProjectProductionTimes100(eProject);
	}

	int iProductionNeeded = getProductionNeeded(eProject) * 100;
	int iProductionModifier = getProductionModifier(eProject);

	return getProductionTurnsLeft(iProductionNeeded, iProduction, getProductionDifferenceTimes100(iProductionNeeded, iProduction, iProductionModifier, false, (iNum == 0)), getProductionDifferenceTimes100(iProductionNeeded, iProduction, iProductionModifier, false, false));
}

#if defined(MOD_PROCESS_STOCKPILE)
//	--------------------------------------------------------------------------------
int CvCity::getProductionNeeded(ProcessTypes eProcess) const
{
	VALIDATE_OBJECT();
	static ProcessTypes stockpile = (ProcessTypes)GC.getInfoTypeForString("PROCESS_STOCKPILE");
	if (eProcess == stockpile)
	{
		return GET_PLAYER(getOwner()).getMaxStockpile();
	}

	return INT_MAX;
}

//	--------------------------------------------------------------------------------
int CvCity::getProductionTurnsLeft(ProcessTypes eProcess, int) const
{
	VALIDATE_OBJECT();
	static ProcessTypes stockpile = (ProcessTypes)GC.getInfoTypeForString("PROCESS_STOCKPILE");
	if (eProcess == stockpile)
	{
		int iProduction = getOverflowProduction();
		int iProductionNeeded = GET_PLAYER(getOwner()).getMaxStockpile();
		int iProductionModifier = getProductionModifier(eProcess);
		int iProductionDifference = getProductionDifference(iProductionNeeded, iProduction, iProductionModifier, false, false);

		return getProductionTurnsLeft(iProductionNeeded, iProduction, iProductionDifference, iProductionDifference);
	}

	return INT_MAX;
}
#endif
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
bool CvCity::IsBuildingInvestment(BuildingClassTypes eBuildingClass) const
{
	ASSERT_DEBUG(eBuildingClass >= 0);
	ASSERT_DEBUG(eBuildingClass < GC.getNumBuildingClassInfos());

	return m_abBuildingInvestment[eBuildingClass];
}
//	--------------------------------------------------------------------------------
void CvCity::SetBuildingInvestment(BuildingClassTypes eBuildingClass, bool bNewValue)
{
	ASSERT_DEBUG(eBuildingClass > NO_BUILDINGCLASS);
	ASSERT_DEBUG(eBuildingClass < GC.getNumBuildingClassInfos());

	// Is there actually a building to invest in?
	BuildingTypes eBuilding = static_cast<BuildingTypes>(GC.getCivilizationInfo(getCivilizationType())->getCivilizationBuildings(eBuildingClass));
	if (eBuilding == NO_BUILDING)
		bNewValue = false;

	m_abBuildingInvestment[eBuildingClass] = bNewValue;
	if (!bNewValue)
	{
		m_aiBuildingCostInvestmentReduction[eBuildingClass] = 0;
		return;
	}

	GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityInvestedBuilding, getOwner(), GetID(), eBuildingClass, bNewValue);

	// Calculate reduction of building production cost
	int iProductionNeeded = getProductionNeeded(eBuilding, true);
	int iProductionNeededAfterInvestment = iProductionNeeded;

	CvPlayer& kOwner = GET_PLAYER(getOwner());
	int iDiscountPercent = /*-50*/ GD_INT_GET(BALANCE_BUILDING_INVESTMENT_BASELINE) + kOwner.GetPlayerTraits()->GetInvestmentModifier() + kOwner.GetInvestmentModifier();
	if (isWorldWonderClass(*GC.getBuildingClassInfo(eBuildingClass)))
	{
		iDiscountPercent /= 2;
	}

	iProductionNeededAfterInvestment *= 100 + iDiscountPercent;
	iProductionNeededAfterInvestment /= 100;

	// Leave the building at least one turn (production) from completion after investment
	int iProductionCompleted = GetCityBuildings()->GetBuildingProduction(eBuilding);
	iProductionNeededAfterInvestment = max(iProductionNeededAfterInvestment, iProductionCompleted + 1);

	// Sanity check: the building shouldn't be more expensive after investment
	m_aiBuildingCostInvestmentReduction[eBuildingClass] = max(0, iProductionNeeded - iProductionNeededAfterInvestment);
}
// ---------------------------------------------------------------------------------
int CvCity::GetBuildingCostInvestmentReduction(BuildingClassTypes eBuildingClass) const
{
	ASSERT_DEBUG(eBuildingClass > NO_BUILDINGCLASS);
	ASSERT_DEBUG(eBuildingClass < GC.getNumBuildingClassInfos());

	return m_aiBuildingCostInvestmentReduction[eBuildingClass];
}
//	--------------------------------------------------------------------------------
bool CvCity::IsProcessInternationalProject(ProcessTypes eProcess) const
{
	for (int iI = 0; iI < GC.getNumLeagueProjectInfos(); iI++)
	{
		LeagueProjectTypes eLeagueProject = (LeagueProjectTypes)iI;
		CvLeagueProjectEntry* pInfo = GC.getLeagueProjectInfo(eLeagueProject);
		if (pInfo && pInfo->GetProcess() == eProcess) {
			return true;
		}
	}
	return false;
}
//	--------------------------------------------------------------------------------
bool CvCity::IsUnitInvestment(UnitClassTypes eUnitClass) const
{
	ASSERT_DEBUG(eUnitClass >= 0);
	ASSERT_DEBUG(eUnitClass < GC.getNumUnitClassInfos());

	return m_abUnitInvestment[eUnitClass];
}
//	--------------------------------------------------------------------------------
void CvCity::SetUnitInvestment(UnitClassTypes eUnitClass, bool bNewValue)
{
	ASSERT_DEBUG(eUnitClass >= 0);
	ASSERT_DEBUG(eUnitClass < GC.getNumUnitClassInfos());

	if (bNewValue)
	{
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityInvestedUnit, getOwner(), GetID(), eUnitClass, bNewValue);
	}

	m_abUnitInvestment[eUnitClass] = bNewValue;
	if (bNewValue)
	{
		// calculate reduction of unit production cost
		UnitTypes eUnit = GET_PLAYER(getOwner()).GetSpecificUnitType(eUnitClass);

		int iNumProductionNeeded = getProductionNeeded(eUnit);
		int AmountNeededAfterInvestment = max(1, iNumProductionNeeded);

		int iTotalDiscount = (/*-50*/ GD_INT_GET(BALANCE_UNIT_INVESTMENT_BASELINE) + GET_PLAYER(getOwner()).GetPlayerTraits()->GetInvestmentModifier() + GET_PLAYER(getOwner()).GetInvestmentModifier());

		AmountNeededAfterInvestment *= (iTotalDiscount + 100);
		AmountNeededAfterInvestment /= 100;

		// Investment checks when AmountComplete >= 50 moved here
		int AmountComplete = getUnitProduction(eUnit);
		if (AmountComplete >= AmountNeededAfterInvestment)
		{
			int iProductionDifference = getProductionDifference(AmountNeededAfterInvestment, AmountComplete, getProductionModifier(), false, false);
			AmountNeededAfterInvestment = max(AmountNeededAfterInvestment, AmountComplete - iProductionDifference); //allow one turn of overflow
		}
		m_aiUnitCostInvestmentReduction[eUnitClass] = iNumProductionNeeded - AmountNeededAfterInvestment;
	}
	else
	{
		m_aiUnitCostInvestmentReduction[eUnitClass] = 0;
	}
}
// ---------------------------------------------------------------------------------
int CvCity::GetUnitCostInvestmentReduction(UnitClassTypes eUnitClass) const
{
	ASSERT_DEBUG(eUnitClass >= 0);
	ASSERT_DEBUG(eUnitClass < GC.getNumUnitClassInfos());

	return m_aiUnitCostInvestmentReduction[eUnitClass];
}
//	--------------------------------------------------------------------------------
bool CvCity::IsBuildingConstructed(BuildingClassTypes eBuildingClass) const
{
	ASSERT_DEBUG(eBuildingClass >= 0);
	ASSERT_DEBUG(eBuildingClass < GC.getNumBuildingClassInfos());

	return m_abBuildingConstructed[eBuildingClass];
}
//	--------------------------------------------------------------------------------
void CvCity::SetBuildingConstructed(BuildingClassTypes eBuildingClass, bool bNewValue)
{
	ASSERT_DEBUG(eBuildingClass >= 0);
	ASSERT_DEBUG(eBuildingClass < GC.getNumBuildingClassInfos());

	m_abBuildingConstructed[eBuildingClass] = bNewValue;
}
#endif
//	--------------------------------------------------------------------------------
int CvCity::getProductionTurnsLeft(int iProductionNeeded, int iProduction, int iFirstProductionDifference, int iProductionDifference) const
{
	VALIDATE_OBJECT();
	int iProductionLeft = std::max(0, (iProductionNeeded - iProduction - iFirstProductionDifference));

	if (iProductionDifference == 0)
	{
		return iProductionLeft + 1;
	}

	int iTurnsLeft = (iProductionLeft / iProductionDifference);

	if ((iTurnsLeft * iProductionDifference) < iProductionLeft)
	{
		iTurnsLeft++;
	}

	iTurnsLeft++;

	return std::max(1, iTurnsLeft);
}

//	--------------------------------------------------------------------------------
int CvCity::GetPurchaseCost(UnitTypes eUnit)
{
	VALIDATE_OBJECT();
	CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
	if (pkUnitInfo == NULL)
	{
		//Should never happen
		return 0;
	}

	bool bIsSpaceshipPart = pkUnitInfo->GetSpaceshipProject() != NO_PROJECT;

	if (bIsSpaceshipPart && !GET_PLAYER(getOwner()).IsEnablesSSPartPurchase())
		return -1;

	int iModifier = pkUnitInfo->GetHurryCostModifier();
	if (!bIsSpaceshipPart && iModifier == -1)
	{
		return -1;
	}

	int iCost = GetPurchaseCostFromProduction(getProductionNeeded(eUnit));
	iCost *= (100 + iModifier);
	iCost /= 100;

	// Cost of purchasing units modified?
	iCost *= (100 + GET_PLAYER(getOwner()).GetUnitPurchaseCostModifier());
	iCost /= 100;

	int iLimitSpaceshipPurchase = GC.getGame().GetGameLeagues()->GetSpaceShipPurchaseMod(getOwner());
	if (bIsSpaceshipPart && iLimitSpaceshipPurchase != 0)
	{
		iCost *= (100 + GC.getGame().GetGameLeagues()->GetSpaceShipPurchaseMod(getOwner()));
		iCost /= 100;
	}

	if (MOD_BALANCE_CORE_PURCHASE_COST_INCREASE)
	{
		//Increase cost based on # of techs researched.
		int iTechProgress = (GET_TEAM(getTeam()).GetTeamTechs()->GetNumTechsKnown() * 100) / GC.getNumTechInfos();

		iTechProgress /= 2;
		if (iTechProgress > 0)
		{
			iCost *= (100 + iTechProgress);
			iCost /= 100;
		}
	}

	if (MOD_BALANCE_VP)
	{
		bool bCombat = pkUnitInfo->GetCombat() > 0 || pkUnitInfo->GetRangedCombat() > 0 || pkUnitInfo->GetNukeDamageLevel() > 0;
		bool bSettler = pkUnitInfo->IsFound() || pkUnitInfo->IsFoundMid() || pkUnitInfo->IsFoundLate() || pkUnitInfo->IsFoundAbroad();

		if (bCombat)
		{
			int iWarWeariness = GET_PLAYER(getOwner()).GetUnitCostIncreaseFromWarWeariness();
			if (iWarWeariness > 0)
			{
				//Let's do the yield mods.			
				iCost *= 100 + iWarWeariness;
				iCost /= 100;
			}
		}
		else if (bSettler)
		{
			int iTempMod = min(0, getHappinessDelta() * /*10*/ GD_INT_GET(LOCAL_UNHAPPY_SETTLER_PRODUCTION_PENALTY) * -1);
			iTempMod += GET_PLAYER(getOwner()).GetUnhappinessSettlerCostPenalty();

			// Can't be lower than -75% from Unhappiness.
			if (iTempMod < /*-75*/ GD_INT_GET(UNHAPPY_MAX_UNIT_PRODUCTION_PENALTY))
			{
				iTempMod = GD_INT_GET(UNHAPPY_MAX_UNIT_PRODUCTION_PENALTY);
			}

			iTempMod *= -1;

			//Let's do the yield mods.
			iCost *= 100 + iTempMod;
			iCost /= 100;
		}
	}

	if (MOD_BALANCE_CORE_PURCHASE_COST_INCREASE)
	{
		//Decrease base cost, then increase based on # of cities in empire.
		iCost *= 8;
		iCost /= 10;
	}

	// Make the number not be funky
	int iDivisor = /*10*/ GD_INT_GET(GOLD_PURCHASE_VISIBLE_DIVISOR);
	iCost /= iDivisor;
	iCost *= iDivisor;

	return max(/*10*/ GD_INT_GET(GOLD_PURCHASE_VISIBLE_DIVISOR), iCost);
}

//	--------------------------------------------------------------------------------
int CvCity::GetFaithPurchaseCost(UnitTypes eUnit, bool bIncludeBeliefDiscounts)
{
	VALIDATE_OBJECT();
	int iCost = 0;
	CvPlayer& kPlayer = GET_PLAYER(m_eOwner);

	CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
	if (pkUnitInfo == NULL)
	{
		//Should never happen
		return iCost;
	}

	ReligionTypes eFoundedReligion = kPlayer.GetReligions()->GetOwnedReligion();
	ReligionTypes eFollowingReligion = kPlayer.GetReligions()->GetStateReligion();
	ReligionTypes eCityReligion = GetCityReligions()->GetReligiousMajority();

	// LATE-GAME GREAT PERSON
	static SpecialUnitTypes eSpecialUnitGreatPerson = (SpecialUnitTypes)GC.getInfoTypeForString("SPECIALUNIT_PEOPLE");
	if (pkUnitInfo->GetSpecialUnitType() == eSpecialUnitGreatPerson)
	{
		// We must be into the industrial era
		if (kPlayer.GetCurrentEra() >= GC.getGame().GetGameReligions()->GetFaithPurchaseGreatPeopleEra(&kPlayer))
		{
			// Must be proper great person for our civ
			const UnitClassTypes eUnitClass = (UnitClassTypes)pkUnitInfo->GetUnitClassType();
			if (eUnitClass != NO_UNITCLASS)
			{
				const UnitTypes eThisPlayersUnitType = kPlayer.GetSpecificUnitType(eUnitClass);

				if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_PROPHET", true /*bHideAssert*/)) //here
				{
					// Can't be bought if didn't start religion
					if (eFoundedReligion == NO_RELIGION)
					{
						iCost = -1;
					}
					else
					{
						iCost = kPlayer.GetReligions()->GetCostNextProphet(true /*bIncludeBeliefDiscounts*/, false /*bAdjustForSpeedDifficulty*/, MOD_GLOBAL_TRULY_FREE_GP);
					}
				}
				else if (eThisPlayersUnitType == eUnit)
				{
					PolicyBranchTypes eBranch = NO_POLICY_BRANCH_TYPE;
					int iNum = 0;

					// Check social policy tree
					if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_WRITER", true /*bHideAssert*/))
					{
						eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_AESTHETICS", true /*bHideAssert*/);
						iNum = kPlayer.getWritersFromFaith();
					}
					else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_ARTIST", true /*bHideAssert*/))
					{
						eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_AESTHETICS", true /*bHideAssert*/);
						iNum = kPlayer.getArtistsFromFaith();
					}
					else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_MUSICIAN", true /*bHideAssert*/))
					{
						eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_AESTHETICS", true /*bHideAssert*/);
						iNum = kPlayer.getMusiciansFromFaith();
					}
					else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_SCIENTIST", true /*bHideAssert*/))
					{
						eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_RATIONALISM", true /*bHideAssert*/);
						iNum = kPlayer.getScientistsFromFaith();
					}
					else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_MERCHANT", true /*bHideAssert*/))
					{
						eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_COMMERCE", true /*bHideAssert*/);
						iNum = kPlayer.getMerchantsFromFaith();
					}
					else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_ENGINEER", true /*bHideAssert*/))
					{
						eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_TRADITION", true /*bHideAssert*/);
						iNum = kPlayer.getEngineersFromFaith();
					}
					else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_GREAT_GENERAL", true /*bHideAssert*/))
					{
						eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_HONOR", true /*bHideAssert*/);
						iNum = kPlayer.getGeneralsFromFaith();
					}
					else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_GREAT_ADMIRAL", true /*bHideAssert*/))
					{
						eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_EXPLORATION", true /*bHideAssert*/);
						iNum = kPlayer.getAdmiralsFromFaith();
					}
					else if (MOD_BALANCE_VP && eUnitClass == GC.getInfoTypeForString("UNITCLASS_GREAT_DIPLOMAT", true /*bHideAssert*/))
					{
						eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_PATRONAGE", true /*bHideAssert*/);
						iNum = kPlayer.getDiplomatsFromFaith();
					}
#if defined(MOD_BALANCE_CORE)
					if (pkUnitInfo->IsGPExtra() == 1)
					{
						eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_PATRONAGE", true /*bHideAssert*/);
						iNum = kPlayer.getGPExtra1FromFaith();
					}
					else if (pkUnitInfo->IsGPExtra() == 2)
					{
						eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_PATRONAGE", true /*bHideAssert*/);
						iNum = kPlayer.getGPExtra2FromFaith();
					}

					else if (pkUnitInfo->IsGPExtra() == 3)
					{
						eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_PATRONAGE", true /*bHideAssert*/);
						iNum = kPlayer.getGPExtra3FromFaith();
					}

					else if (pkUnitInfo->IsGPExtra() == 4)
					{
						eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_PATRONAGE", true /*bHideAssert*/);
						iNum = kPlayer.getGPExtra4FromFaith();
					}

					else if (pkUnitInfo->IsGPExtra() == 5)
					{
						eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_PATRONAGE", true /*bHideAssert*/);
						iNum = kPlayer.getGPExtra5FromFaith();
					}
#endif

					bool bAllUnlockedByBelief = false;
					const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eFoundedReligion, getOwner());

					if (pReligion == NULL)
						pReligion = GC.getGame().GetGameReligions()->GetReligion(eFollowingReligion, getOwner());

					if (pReligion)
					{
						if (pReligion->m_Beliefs.IsFaithPurchaseAllGreatPeople(getOwner(), this) && kPlayer.GetCurrentEra() >= GC.getGame().GetGameReligions()->GetFaithPurchaseGreatPeopleEra(NULL))
						{
							bAllUnlockedByBelief = true;
						}
					}

#if defined(MOD_RELIGION_POLICY_BRANCH_FAITH_GP)
					if (MOD_RELIGION_POLICY_BRANCH_FAITH_GP)
					{
						bool bIsUnlocked = bAllUnlockedByBelief;

						if (!bIsUnlocked)
						{
							EraTypes eCurrentEra = kPlayer.GetCurrentEra();

							for (int iPolicyLoop = 0; iPolicyLoop < kPlayer.GetPlayerPolicies()->GetPolicies()->GetNumPolicies(); iPolicyLoop++)
							{
								const PolicyTypes eLoopPolicy = static_cast<PolicyTypes>(iPolicyLoop);
								CvPolicyEntry* pkLoopPolicyInfo = GC.getPolicyInfo(eLoopPolicy);
								if (pkLoopPolicyInfo)
								{
									// We have this policy
									if (kPlayer.HasPolicy(eLoopPolicy))
									{
										if (pkLoopPolicyInfo->IsFaithPurchaseUnitClass(eUnitClass, eCurrentEra))
										{
											bIsUnlocked = true;
											break;
										}
									}
								}
							}
						}

						if (bIsUnlocked)
						{
							iCost = GC.getGame().GetGameReligions()->GetFaithGreatPersonNumber(iNum + 1);
						}
					}
					else
					{
#endif

						if (bAllUnlockedByBelief || (eBranch != NO_POLICY_BRANCH_TYPE && kPlayer.GetPlayerPolicies()->IsPolicyBranchFinished(eBranch) && !kPlayer.GetPlayerPolicies()->IsPolicyBranchBlocked(eBranch)))
						{
							iCost = GC.getGame().GetGameReligions()->GetFaithGreatPersonNumber(iNum + 1);
						}
#if defined(MOD_RELIGION_POLICY_BRANCH_FAITH_GP)
					}
#endif
				}
			}
		}
	}

	// ALL OTHERS
	else
	{
		iCost = pkUnitInfo->GetFaithCost();
		int iMultiplier = 0;

		// Cost goes up in later eras
		// Only Missionaries and Inquisitors for VP
		if (!MOD_BALANCE_VP || pkUnitInfo->IsSpreadReligion() || pkUnitInfo->IsRemoveHeresy())
		{
			EraTypes eEra = GET_TEAM(GET_PLAYER(getOwner()).getTeam()).GetCurrentEra();
			iMultiplier = GC.getEraInfo(eEra)->getFaithCostMultiplier();
			iCost = iCost * iMultiplier / 100;
		}

		if (pkUnitInfo->IsSpreadReligion() || pkUnitInfo->IsRemoveHeresy())
		{
			if (eCityReligion == NO_RELIGION || eCityReligion == RELIGION_PANTHEON)
				return 0;

			iMultiplier = (100 + GET_PLAYER(getOwner()).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_FAITH_COST_MODIFIER));
			iCost = iCost * iMultiplier / 100;
		}
	}

	// Adjust for game speed
	iCost *= GC.getGame().getGameSpeedInfo().getTrainPercent();
	iCost /= 100;

	// Adjust for difficulty
	if (pkUnitInfo->IsFoundReligion())
	{
		iCost *= GET_PLAYER(getOwner()).getHandicapInfo().getProphetPercent();
		iCost /= 100;

		if (!GET_PLAYER(getOwner()).isHuman())
		{
			iCost *= GC.getGame().getHandicapInfo().getAIProphetPercent();
			iCost /= 100;
		}
	}
	else
	{
		bool bCombat = pkUnitInfo->GetCombat() > 0 || pkUnitInfo->GetRangedCombat() > 0 || pkUnitInfo->GetNukeDamageLevel() > 0;
		if (bCombat)
		{
			iCost *= GET_PLAYER(getOwner()).getHandicapInfo().getTrainPercent();
			iCost /= 100;

			iCost *= std::max(0, GET_PLAYER(getOwner()).getHandicapInfo().getTrainPerEraModifier() * GC.getGame().getCurrentEra() + 100);
			iCost /= 100;

			if (!isHuman())
			{
				iCost *= GC.getGame().getHandicapInfo().getAITrainPercent();
				iCost /= 100;

				iCost *= std::max(0, GC.getGame().getHandicapInfo().getAITrainPerEraModifier() * GC.getGame().getCurrentEra() + 100);
				iCost /= 100;
			}
		}
		else
		{
			iCost *= GET_PLAYER(getOwner()).getHandicapInfo().getCivilianPercent();
			iCost /= 100;

			iCost *= std::max(0, GET_PLAYER(getOwner()).getHandicapInfo().getCivilianPerEraModifier() * GC.getGame().getCurrentEra() + 100);
			iCost /= 100;

			if (!isHuman())
			{
				iCost *= GC.getGame().getHandicapInfo().getAICivilianPercent();
				iCost /= 100;

				iCost *= std::max(0, GC.getGame().getHandicapInfo().getAICivilianPerEraModifier() * GC.getGame().getCurrentEra() + 100);
				iCost /= 100;
			}
		}
	}

	// Modify by any beliefs
	if (bIncludeBeliefDiscounts && !pkUnitInfo->IsFoundReligion() && eCityReligion > RELIGION_PANTHEON)
	{
		const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
		if (pReligion)
		{
			int iReligionCostMod = 0;

			if (pkUnitInfo->IsSpreadReligion())
				iReligionCostMod = pReligion->m_Beliefs.GetMissionaryCostModifier(getOwner(), this);
			else if (pkUnitInfo->IsRemoveHeresy())
				iReligionCostMod = pReligion->m_Beliefs.GetInquisitorCostModifier(getOwner(), this);

			if (iReligionCostMod != 0)
			{
				iCost *= (100 + iReligionCostMod);
				iCost /= 100;
			}
		}
	}

	//Modify for Resolution
	int iGetSpaceShipPurchaseMod = GC.getGame().GetGameLeagues()->GetSpaceShipPurchaseMod(getOwner());
	if ((pkUnitInfo->GetBaseHurry() > 0) && (iGetSpaceShipPurchaseMod != 0))
	{
		iCost *= (100 + iGetSpaceShipPurchaseMod);
		iCost /= 100;
	}

#if defined(MOD_BALANCE_CORE_PURCHASE_COST_INCREASE)

	/*
	if(MOD_BALANCE_CORE_PURCHASE_COST_INCREASE)
	{
		//Increase cost based on # of techs researched.
		int iTechProgress = (GET_TEAM(getTeam()).GetTeamTechs()->GetNumTechsKnown() * 100) / GC.getNumTechInfos();
		iTechProgress /= 2;
		if(iTechProgress > 0)
		{
			iCost *= (100 + iTechProgress);
			iCost /= 100;
		}
	}
	*/

	if (!pkUnitInfo->IsFoundReligion())
	{
		int iTraitValue = kPlayer.GetPlayerTraits()->GetFaithCostModifier();
		iCost *= (100 + iTraitValue);
		iCost /= 100;
	}
#endif

	if (MOD_BALANCE_VP)
	{
		bool bCombat = pkUnitInfo->GetCombat() > 0 || pkUnitInfo->GetRangedCombat() > 0 || pkUnitInfo->GetNukeDamageLevel() > 0;
		bool bSettler = pkUnitInfo->IsFound() || pkUnitInfo->IsFoundMid() || pkUnitInfo->IsFoundLate() || pkUnitInfo->IsFoundAbroad();

		if (bCombat)
		{
			int iWarWeariness = GET_PLAYER(getOwner()).GetUnitCostIncreaseFromWarWeariness();
			if (iWarWeariness > 0)
			{
				//Let's do the yield mods.			
				iCost *= 100 + iWarWeariness;
				iCost /= 100;
			}
		}
		else if (bSettler)
		{
			int iTempMod = min(0, getHappinessDelta() * /*10*/ GD_INT_GET(LOCAL_UNHAPPY_SETTLER_PRODUCTION_PENALTY) * -1);
			iTempMod += GET_PLAYER(getOwner()).GetUnhappinessSettlerCostPenalty();

			// Can't be lower than -75% from Unhappiness.
			if (iTempMod < /*-75*/ GD_INT_GET(UNHAPPY_MAX_UNIT_PRODUCTION_PENALTY))
			{
				iTempMod = GD_INT_GET(UNHAPPY_MAX_UNIT_PRODUCTION_PENALTY);
			}

			iTempMod *= -1;

			//Let's do the yield mods.
			iCost *= 100 + iTempMod;
			iCost /= 100;
		}
	}

	// Make the number not be funky
	int iDivisor = /*10*/ GD_INT_GET(GOLD_PURCHASE_VISIBLE_DIVISOR);
	iCost /= iDivisor;
	iCost *= iDivisor;

	return iCost;
}

//	--------------------------------------------------------------------------------
int CvCity::GetPurchaseCost(BuildingTypes eBuilding)
{
	VALIDATE_OBJECT();
	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if (pkBuildingInfo == NULL)
		return -1;

	int iModifier = pkBuildingInfo->GetHurryCostModifier();

	if (iModifier == -1)
		return -1;

	if (MOD_BALANCE_CORE_BUILDING_INVESTMENTS && (NO_BUILDING != eBuilding))
	{
		//Have we already invested here?
		const BuildingClassTypes eBuildingClass = pkBuildingInfo->GetBuildingClassType();
		if (IsBuildingInvestment(eBuildingClass))
		{
			return -1;
		}
	}

	int iProductionNeeded = getProductionNeeded(eBuilding);

	if (MOD_BUILDINGS_PRO_RATA_PURCHASE)
	{
		// Deduct any current production towards this building
		int iProductionToDate = m_pCityBuildings->GetBuildingProduction(eBuilding);
		iProductionNeeded -= (iProductionToDate * gCustomMods.getOption("BUILDINGS_PRO_RATA_PURCHASE_DEPRECIATION", 80)) / 100;
	}

	int iCost = GetPurchaseCostFromProduction(iProductionNeeded);
	iCost *= (100 + iModifier);
	iCost /= 100;

	// Cost of purchasing buildings modified?
	iCost *= (100 + GET_PLAYER(getOwner()).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_BUILDING_PURCHASE_COST_MODIFIER));
	iCost /= 100;

#if defined(MOD_BALANCE_CORE)
	if (MOD_BALANCE_CORE_PURCHASE_COST_INCREASE)
	{
		//Increase cost based on # of techs researched.
		int iTechProgress = (GET_TEAM(getTeam()).GetTeamTechs()->GetNumTechsKnown() * 100) / GC.getNumTechInfos();
		iTechProgress /= 3;
		if (iTechProgress > 0)
		{
			iCost *= (100 + iTechProgress);
			iCost /= 100;
		}
	}
	if (MOD_BALANCE_CORE_BUILDING_INVESTMENTS)
	{
		//Decrease base cost, then increase based on # of cities in empire.
		iCost *= 6;
		iCost /= 10;
	}
#endif

	// Make the number not be funky
	int iDivisor = /*10*/ GD_INT_GET(GOLD_PURCHASE_VISIBLE_DIVISOR);
	iCost /= iDivisor;
	iCost *= iDivisor;

	return max(/*10*/ GD_INT_GET(GOLD_PURCHASE_VISIBLE_DIVISOR), iCost);
}

//	--------------------------------------------------------------------------------
int CvCity::GetFaithPurchaseCost(BuildingTypes eBuilding)
{
	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if (pkBuildingInfo == NULL)
	{
		//Should never happen
		return 0;
	}

	int iCost = pkBuildingInfo->GetFaithCost();
	int iMultiplier = 0;

	// Cost goes up in later eras (CP only)
	if (!MOD_BALANCE_VP)
	{
		EraTypes eEra = GET_TEAM(GET_PLAYER(getOwner()).getTeam()).GetCurrentEra();
		iMultiplier = GC.getEraInfo(eEra)->getFaithCostMultiplier();
		iCost = iCost * iMultiplier / 100;
	}

	iMultiplier = (100 + GET_PLAYER(getOwner()).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_FAITH_COST_MODIFIER));
	iCost = iCost * iMultiplier / 100;

	// Adjust for game speed
	iCost *= GC.getGame().getGameSpeedInfo().getConstructPercent();
	iCost /= 100;

	// Adjust for difficulty
	if (!isBarbarian())
	{
		iCost *= getHandicapInfo().getConstructPercent();
		iCost /= 100;

		if (!isHuman())
		{
			iCost *= GC.getGame().getHandicapInfo().getAIConstructPercent();
			iCost /= 100;
		}
	}
#if defined(MOD_BALANCE_CORE_PURCHASE_COST_INCREASE)
	/*
	if(MOD_BALANCE_CORE_PURCHASE_COST_INCREASE)
	{
		//Increase cost based on # of techs researched.
		int iTechProgress = (GET_TEAM(getTeam()).GetTeamTechs()->GetNumTechsKnown() * 100) / GC.getNumTechInfos();
		iTechProgress /= 2;
		if(iTechProgress > 0)
		{
			iCost *= (100 + iTechProgress);
			iCost /= 100;
		}
	}
	*/

	int iTraitValue = GET_PLAYER(getOwner()).GetPlayerTraits()->GetFaithCostModifier();
	iCost *= (100 + iTraitValue);
	iCost /= 100;

#endif

	// Make the number not be funky
	int iDivisor = /*10*/ GD_INT_GET(GOLD_PURCHASE_VISIBLE_DIVISOR);
	iCost /= iDivisor;
	iCost *= iDivisor;

	return iCost;
}

//	--------------------------------------------------------------------------------
int CvCity::GetPurchaseCost(ProjectTypes eProject)
{
	VALIDATE_OBJECT();
	int iCost = GetPurchaseCostFromProduction(getProductionNeeded(eProject));

	// Make the number not be funky
	int iDivisor = /*10*/ GD_INT_GET(GOLD_PURCHASE_VISIBLE_DIVISOR);
	iCost /= iDivisor;
	iCost *= iDivisor;

	return max(/*10*/ GD_INT_GET(GOLD_PURCHASE_VISIBLE_DIVISOR), iCost);
}

//	--------------------------------------------------------------------------------
/// Cost of Purchasing something based on the amount of Production it requires to construct
int CvCity::GetPurchaseCostFromProduction(int iProduction)
{
	VALIDATE_OBJECT();
	// Gold per Production
	int iPurchaseCostBase = iProduction * /*30*/ GD_INT_GET(GOLD_PURCHASE_GOLD_PER_PRODUCTION);
	// Cost ramps up
	int iPurchaseCost = (int)pow((double)iPurchaseCostBase, (double) /*0.75f in CP, 0.68f in VP*/ GD_FLOAT_GET(HURRY_GOLD_PRODUCTION_EXPONENT));

	// Hurry Mod (Policies, etc.)
	HurryTypes eHurry = static_cast<HurryTypes>(GC.getInfoTypeForString("HURRY_GOLD"));
	if (eHurry != NO_HURRY)
	{
		int iHurryMod = GET_PLAYER(getOwner()).getHurryModifier(eHurry);
		iHurryMod += getHurryModifier(eHurry);

		if (iHurryMod != 0)
		{
			iPurchaseCost *= (100 + iHurryMod);
			iPurchaseCost /= 100;
		}
	}

	// Game Speed modifier
	iPurchaseCost *= GC.getGame().getGameSpeedInfo().getHurryPercent();
	iPurchaseCost /= 100;

	return max(0, iPurchaseCost);
}

//	--------------------------------------------------------------------------------
void CvCity::setProduction(int iNewValue)
{
	VALIDATE_OBJECT();
	if (isProductionUnit())
	{
		setUnitProduction(getProductionUnit(), iNewValue);
	}
	else if (isProductionBuilding())
	{
		m_pCityBuildings->SetBuildingProduction(getProductionBuilding(), iNewValue);
	}
	else if (isProductionProject())
	{
		setProjectProduction(getProductionProject(), iNewValue);
	}
}


//	--------------------------------------------------------------------------------
void CvCity::changeProduction(int iChange)
{
	VALIDATE_OBJECT();
	if (isProductionUnit())
	{
		changeUnitProduction(getProductionUnit(), iChange);
	}
	else if (isProductionBuilding())
	{
		m_pCityBuildings->ChangeBuildingProduction(getProductionBuilding(), iChange);
	}
	else if (isProductionProject())
	{
		changeProjectProduction(getProductionProject(), iChange);
	}
#if defined(MOD_BALANCE_CORE)
	else
	{
		changeOverflowProduction(iChange);
		if (GC.getLogging() && GC.getAILogging())
		{
			CvString strLogString;
			strLogString.Format("MOD - overflow production from policy/belief/trait/ruin/etc added: %d in %s.",
				iChange, getName().GetCString());
			GET_PLAYER(getOwner()).GetHomelandAI()->LogHomelandMessage(strLogString);
		}
	}
#endif
}

//	--------------------------------------------------------------------------------
void CvCity::setProductionTimes100(int iNewValue)
{
	VALIDATE_OBJECT();
	if (isProductionUnit())
	{
		setUnitProductionTimes100(getProductionUnit(), iNewValue);
	}
	else if (isProductionBuilding())
	{
		m_pCityBuildings->SetBuildingProductionTimes100(getProductionBuilding(), iNewValue);
	}
	else if (isProductionProject())
	{
		setProjectProductionTimes100(getProductionProject(), iNewValue);
	}
}

//	--------------------------------------------------------------------------------
void CvCity::changeProductionTimes100(int iChange)
{
	VALIDATE_OBJECT();
	if (isProductionUnit())
	{
		changeUnitProductionTimes100(getProductionUnit(), iChange);
	}
	else if (isProductionBuilding())
	{
		m_pCityBuildings->ChangeBuildingProductionTimes100(getProductionBuilding(), iChange);
	}
	else if (isProductionProject())
	{
		changeProjectProductionTimes100(getProductionProject(), iChange);
	}
	else if (isProductionProcess())
	{
		doProcess();
	}

	if (MOD_TRAITS_TRADE_ROUTE_PRODUCTION_SIPHON)
	{
		PlayerTypes iPlayer = getOwner();
		if (iPlayer != NO_PLAYER)
		{
			CvPlayer* pPlayer = &GET_PLAYER(iPlayer);
			CvGameTrade* pTrade = GC.getGame().GetGameTrade();

			for (uint ui = 0; ui < pTrade->GetNumTradeConnections(); ui++)
			{
				if (pTrade->IsTradeRouteIndexEmpty(ui))
				{
					continue;
				}

				const TradeConnection* pConnection = &(pTrade->GetTradeConnection(ui));

				CvCity* pOriginCity = GC.getMap().plot(pConnection->m_iOriginX, pConnection->m_iOriginY)->getPlotCity();
				CvCity* pDestCity = GC.getMap().plot(pConnection->m_iDestX, pConnection->m_iDestY)->getPlotCity();

				if (pDestCity == this && pOriginCity != NULL)
				{
					if (pConnection->m_eOriginOwner != NO_PLAYER)
					{
						CvPlayer* pOtherPlayer = &GET_PLAYER(pConnection->m_eOriginOwner);
						if (pOtherPlayer->GetPlayerTraits()->IsTradeRouteProductionSiphon())
						{
							Localization::String localizedText;
							int iSiphonPercent = pOtherPlayer->GetTradeRouteProductionSiphonPercent(false, pPlayer);
							if (pPlayer->GetID() != pOtherPlayer->GetID())
							{
								iSiphonPercent += pOtherPlayer->GetTradeRouteProductionSiphonPercent(true, pPlayer);
							}

							int iSiphonAmount = iChange * iSiphonPercent / 100;

							if (iSiphonAmount > 0)
							{
								int iOverflow = 0;
								int iProductionNeeded = 0;

								if (isProductionUnit())
								{
									UnitTypes eUnit = getProductionUnit();
									CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
									UnitClassTypes eUnitClass = (UnitClassTypes)pkUnitInfo->GetUnitClassType();

									// check if this unit is valid in the origin city
									// we are going very light on restrictions, so we are not using CanTrain()
									bool bValid = true;

									// no ships in land-locked cities
									if (!pOriginCity->isCoastal() && pkUnitInfo->GetDomainType() == DOMAIN_SEA)
									{
										bValid = false;
									}
									// no trade units if our trade route slots are maxed
									else if (pkUnitInfo->IsTrade() && pOtherPlayer->GetTrade()->GetNumTradeUnitsRemaining(false) <= 0)
									{
										bValid = false;
									}
									// settler related
									else if (pkUnitInfo->IsFound() || pkUnitInfo->IsFoundAbroad())
									{
										// require certain city population
										int iSizeRequirement = /*2 in CP, 4 in VP*/ GD_INT_GET(CITY_MIN_SIZE_FOR_SETTLERS);
										if (pOriginCity->getPopulation() < iSizeRequirement)
										{
											bValid = false;
										}
										// one city challenge
										else if (GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && pOtherPlayer->isHuman())
										{
											bValid = false;
										}
									}
									// air units can't be built above capacity
									else if (pkUnitInfo->GetDomainType() == DOMAIN_AIR)
									{
										int iNumAirUnits = pOriginCity->plot()->countNumAirUnits(pOriginCity->getTeam());
										if (iNumAirUnits >= pOriginCity->GetMaxAirUnits())
										{
											bValid = false;
										}
									}
									// cannot exceed max instance
									else if (GC.getGame().isUnitClassMaxedOut(eUnitClass) || GET_TEAM(pOtherPlayer->getTeam()).isUnitClassMaxedOut(eUnitClass) || pOtherPlayer->isUnitClassMaxedOut(eUnitClass))
									{
										bValid = false;
									}

									//proceed only if valid
									if (bValid)
									{
										// siphon production to the required unit in the origin
										pOriginCity->changeUnitProductionTimes100(eUnit, iSiphonAmount);

										// check if the origin have completed production
										iProductionNeeded = pOriginCity->getProductionNeeded(eUnit) * 100;
										iOverflow = pOriginCity->getUnitProductionTimes100(eUnit) - iProductionNeeded;

										// if origin has completed production
										if (iOverflow >= 0)
										{
											pOriginCity->produce(eUnit, NO_UNITAI, false);

											if (pkUnitInfo)
											{
												localizedText = Localization::Lookup(((isLimitedUnitClass(eUnitClass)) ? "TXT_KEY_MISC_TRAINED_UNIT_IN_LIMITED" : "TXT_KEY_MISC_TRAINED_UNIT_IN"));
												localizedText << pkUnitInfo->GetTextKey() << getNameKey();
											}
										}
									}
								}
								else if (isProductionBuilding())
								{
									// what building is the destination city making?
									BuildingTypes eBuilding = getProductionBuilding();
									CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
									BuildingClassTypes eBuildingClass = pkBuildingInfo->GetBuildingClassType();
									BuildingTypes eDefaultBuilding = static_cast<BuildingTypes>(GC.getBuildingClassInfo(eBuildingClass)->getDefaultBuildingIndex());

									// check if this building is valid in the origin city
									// we are going very light on restrictions, so we are not using CanConstruct()
									bool bValid = true;

									// cannot build if city already has the exact building
									if (pOriginCity->m_pCityBuildings->GetNumBuilding(eBuilding) >= /*1*/ GD_INT_GET(CITY_MAX_NUM_BUILDINGS))
									{
										bValid = false;
									}
									// cannot exceed max instance
									else if (GC.getGame().isBuildingClassMaxedOut(eBuildingClass) || GET_TEAM(pOtherPlayer->getTeam()).isBuildingClassMaxedOut(eBuildingClass) || pOtherPlayer->isBuildingClassMaxedOut(eBuildingClass))
									{
										bValid = false;
									}
									// If the building class exists in the city, but the default building in the city doesn't, that means we already managed to siphon a unique building. Do not replace in this case.
									else if (pOriginCity->HasBuildingClass(eBuildingClass) && (eDefaultBuilding == NO_BUILDING || pOriginCity->m_pCityBuildings->GetNumBuilding(eDefaultBuilding) == 0))
									{
										bValid = false;
									}
									// Mutually Exclusive Buildings
									else if (pkBuildingInfo->GetMutuallyExclusiveGroup() != -1)
									{
										int iNumBuildingInfos = GC.getNumBuildingInfos();
										for (int iI = 0; iI < iNumBuildingInfos; iI++)
										{
											const BuildingTypes eBuildingLoop = static_cast<BuildingTypes>(iI);

											CvBuildingEntry* pkLoopBuilding = GC.getBuildingInfo(eBuildingLoop);
											if (pkLoopBuilding)
											{
												if (eBuildingLoop == eBuilding)
													continue;

												// Buildings are in a Mutually Exclusive Group, so only one is allowed
												if (pkLoopBuilding->GetMutuallyExclusiveGroup() == pkBuildingInfo->GetMutuallyExclusiveGroup())
												{
													if (m_pCityBuildings->GetNumBuilding(eBuildingLoop) > 0 || isBuildingInQueue(eBuildingLoop))
													{
														bValid = false;
														break;
													}
												}
											}
										}
									}

									// proceed only if valid
									if (bValid)
									{
										// siphon production to the required building
										pOriginCity->m_pCityBuildings->ChangeBuildingProductionTimes100(eBuilding, iSiphonAmount);

										// check if the origin have completed production
										iProductionNeeded = pOriginCity->getProductionNeeded(eBuilding) * 100;
										iOverflow = pOriginCity->m_pCityBuildings->GetBuildingProductionTimes100(eBuilding) - iProductionNeeded;

										// if origin has completed production
										if (iOverflow >= 0)
										{
											// due to above check, if building class already exists, it means we are replacing the default building with a unique building
											if (eDefaultBuilding != NO_BUILDING && pOriginCity->HasBuildingClass(eBuildingClass))
											{
												pOriginCity->m_pCityBuildings->SetNumRealBuilding(eDefaultBuilding, 0);
												pOriginCity->m_pCityBuildings->SetNumFreeBuilding(eDefaultBuilding, 0);
											}

											pOriginCity->produce(eBuilding, false);

											CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
											if (pkBuildingInfo)
											{
												localizedText = Localization::Lookup(((isLimitedWonderClass(pkBuildingInfo->GetBuildingClassInfo())) ? "TXT_KEY_MISC_CONSTRUCTED_BUILD_IN_LIMITED" : "TXT_KEY_MISC_CONSTRUCTED_BUILD_IN"));
												localizedText << pkBuildingInfo->GetTextKey() << getNameKey();
											}
										}
									}
								}
								else if (isProductionProject())
								{
									// siphon production to the required project in the origin
									ProjectTypes eProject = getProductionProject();
									pOriginCity->changeProjectProductionTimes100(eProject, iSiphonAmount);

									// check if the origin have completed production
									iProductionNeeded = pOriginCity->getProductionNeeded(eProject) * 100;
									iOverflow = pOriginCity->getProjectProductionTimes100(eProject) - iProductionNeeded;

									// if origin has completed production (code below is a brief version of popOrder())
									if (iOverflow >= 0)
									{
										pOriginCity->produce(eProject, false);

										localizedText = Localization::Lookup(((isLimitedProject(eProject)) ? "TXT_KEY_MISC_CREATED_PROJECT_IN_LIMITED" : "TXT_KEY_MISC_CREATED_PROJECT_IN"));
										localizedText << GC.getProjectInfo(eProject)->GetTextKey() << getNameKey();
									}
								}

								else if (isProductionProcess())
								{
									if (getProductionProcess() != NO_PROCESS)
									{
										for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
										{
											//Simplification - errata yields not worth considering.
											if ((YieldTypes)iI > YIELD_CULTURE_LOCAL && !MOD_BALANCE_CORE_JFD)
												break;

											int iYield = ((getBasicYieldRateTimes100(YIELD_PRODUCTION) + GET_PLAYER(m_eOwner).GetTrade()->GetTradeValuesAtCityTimes100(this, YIELD_PRODUCTION)) / 100) * getProductionToYieldModifier((YieldTypes)iI) / 100;

											pOtherPlayer->doInstantYield(INSTANT_YIELD_TYPE_TR_PRODUCTION_SIPHON, false, NO_GREATPERSON, NO_BUILDING, iYield, false, NO_PLAYER, NULL, false, pOriginCity, false, true, false, (YieldTypes)iI);
										}
									}
								}

								if (!localizedText.IsEmpty())
								{
									DLLUI->AddCityMessage(0, pOriginCity->GetIDInfo(), pOriginCity->getOwner(), false, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), localizedText.toUTF8()/*, szSound, MESSAGE_TYPE_MINOR_EVENT, szIcon, (ColorTypes)GC.getInfoTypeForString("COLOR_WHITE"), getX(), getY(), true, true*/);
								}
							}
						}
					}
				}
			}
		}
	}
}


//	--------------------------------------------------------------------------------
int CvCity::getProductionModifier(CvString* toolTipSink) const
{
	VALIDATE_OBJECT();
	const OrderData* pOrderNode = headOrderQueueNode();

	int iMultiplier = 0;

	if (pOrderNode != NULL)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_TRAIN:
			iMultiplier += getProductionModifier((UnitTypes)(pOrderNode->iData1), toolTipSink);
			break;

		case ORDER_CONSTRUCT:
			iMultiplier += getProductionModifier((BuildingTypes)(pOrderNode->iData1), toolTipSink);
			break;

		case ORDER_CREATE:
			iMultiplier += getProductionModifier((ProjectTypes)(pOrderNode->iData1), toolTipSink);
			break;

		case ORDER_MAINTAIN:
			iMultiplier += getProductionModifier((ProcessTypes)(pOrderNode->iData1), toolTipSink);
			break;

		default:
			ASSERT_DEBUG(false, "pOrderNode->eOrderType failed to match a valid option");
			break;
		}
	}

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvCity::getGeneralProductionModifiers(CvString* toolTipSink) const
{
	int iMultiplier = 0;

	// Railroad to capital?
	if (IsIndustrialRouteToCapitalConnected())
	{
		const int iTempMod = /*25 in CP, 0 in VP*/ GD_INT_GET(INDUSTRIAL_ROUTE_PRODUCTION_MOD);
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod != 0)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_RAILROAD_CONNECTION", iTempMod);
		}
	}

	if (MOD_BALANCE_VP && GetBaseYieldRateFromLeague(YIELD_PRODUCTION) > 0)
	{
		int iTempLeagueMod = GetBaseYieldRateFromLeague(YIELD_PRODUCTION);
		iMultiplier += iTempLeagueMod;
		if (toolTipSink && iTempLeagueMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_LEAGUE", iTempLeagueMod);
		}
	}

#if defined(MOD_BALANCE_CORE_POLICIES)
	if (MOD_BALANCE_CORE_POLICIES && GET_PLAYER(getOwner()).IsPuppetProdMod() && IsPuppet())
	{
		int iTempMod = GET_PLAYER(getOwner()).GetPuppetProdMod();
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_PUPPET_POLICY", iTempMod);
		}
	}
	if (MOD_BALANCE_CORE_POLICIES && GET_PLAYER(getOwner()).IsOccupiedProdMod() && IsOccupied() && !IsNoOccupiedUnhappiness())
	{
		int iTempMod = GET_PLAYER(getOwner()).GetOccupiedProdMod();
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_OCCUPIED_POLICY", iTempMod);
		}
	}
#endif
#if defined(MOD_BALANCE_CORE)
	if (GET_PLAYER(getOwner()).GetPlayerTraits()->IsProductionModFromNumSpecialists())
	{
		if (GetCityCitizens()->GetTotalSpecialistCount() > 0)
		{
			int iTempMod = GetCityCitizens()->GetTotalSpecialistCount();
			iMultiplier += iTempMod;
			if (toolTipSink && iTempMod)
			{
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_NUM_SPECIALISTS", iTempMod);
			}
		}
	}
#endif
	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvCity::getProductionModifier(UnitTypes eUnit, CvString* toolTipSink, bool bIgnoreHappiness) const
{
	VALIDATE_OBJECT();
	CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
	if (pkUnitInfo == NULL)
	{
		//Unit type doesn't exist!
		return 0;
	}

	CvPlayerAI& thisPlayer = GET_PLAYER(getOwner());
	int iMultiplier = getGeneralProductionModifiers(toolTipSink) + thisPlayer.getProductionModifier(eUnit, toolTipSink);
	int iTempMod = 0;

	// Capital Settler bonus
	if (isCapital() && pkUnitInfo->IsFound())
	{
		iTempMod = GET_PLAYER(getOwner()).getCapitalSettlerProductionModifier();
		iMultiplier += iTempMod;
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_CAPITAL_SETTLER_PLAYER", iTempMod);
	}

#if defined(MOD_BALANCE_CORE)
	// Class Production Bonus
	if (thisPlayer.GetUnitClassProductionModifier((UnitClassTypes)pkUnitInfo->GetUnitClassType()) != 0)
	{
		iTempMod = GET_PLAYER(getOwner()).GetUnitClassProductionModifier((UnitClassTypes)pkUnitInfo->GetUnitClassType());
		iMultiplier += iTempMod;
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_UNIT_CLASS", iTempMod);
	}

	// Trait Bonus from Conquest
	if (thisPlayer.GetProductionBonusTurnsConquest() > 0)
	{
		iTempMod = thisPlayer.GetPlayerTraits()->GetProductionBonusModifierConquest();
		iMultiplier += iTempMod;
		int iTurns = thisPlayer.GetProductionBonusTurnsConquest();
		CvString strMessage = GetLocalizedText("TXT_KEY_PRODMOD_TRAIT_BONUS_CONQUEST_TURNS", iTurns);
		const char* szTurnsRemaining = strMessage.GetCString();
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_TRAIT_BONUS_CONQUEST", iTempMod, szTurnsRemaining);
	}
#endif

	// Domain bonus
	iTempMod = getDomainProductionModifier(pkUnitInfo->GetDomainType());
	iMultiplier += iTempMod;
	if (toolTipSink && iTempMod)
	{
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_UNIT_DOMAIN", iTempMod);
	}

	if (thisPlayer.GetPlayerTraits()->GetNumPledgeDomainProductionModifier(pkUnitInfo->GetDomainType()) != 0)
	{
		int iProtections = 0;
		for (int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
		{
			PlayerTypes eMinorLoop = static_cast<PlayerTypes>(iMinorLoop);
			if (GET_PLAYER(eMinorLoop).GetMinorCivAI()->IsProtectedByMajor(getOwner()))
				iProtections++;
		}
		iTempMod = thisPlayer.GetPlayerTraits()->GetNumPledgeDomainProductionModifier(pkUnitInfo->GetDomainType()) * iProtections;
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_PLEDGES_UNIT_DOMAIN", iTempMod);
		}
	}

	// UnitCombat class bonus
	UnitCombatTypes eUnitCombatType = (UnitCombatTypes)(pkUnitInfo->GetUnitCombatType());
	if (eUnitCombatType != NO_UNITCOMBAT)
	{
		iTempMod = getUnitCombatProductionModifier(eUnitCombatType);
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_UNIT_COMBAT_TYPE", iTempMod);
		}
	}

	// Production bonus from Corporation
	CorporationTypes eCorporation = GET_PLAYER(getOwner()).GetCorporations()->GetFoundedCorporation();
	if (eCorporation != NO_CORPORATION)
	{
		CvCorporationEntry* pkCorporationInfo = GC.getCorporationInfo(eCorporation);
		if (pkCorporationInfo)
		{
			for (int iResource = 0; iResource < GC.getNumResourceInfos(); iResource++)
			{
				if (pkUnitInfo->GetResourceQuantityRequirement(iResource) > 0 || (MOD_UNITS_RESOURCE_QUANTITY_TOTALS && pkUnitInfo->GetResourceQuantityTotal(iResource) > 0))
				{
					iTempMod = pkCorporationInfo->GetUnitResourceProductionModifier(iResource);
					iMultiplier += iTempMod;
					if (toolTipSink && iTempMod)
					{
						GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_UNIT_CORPORATION", iTempMod);
					}
				}
			}
		}
	}

	UnitTypes prodUnit = getProductionUnit();
	if (MOD_BALANCE_VP && !bIgnoreHappiness && prodUnit != NO_UNIT)
	{
		CvUnitEntry* pUnitEntry = GC.getUnitInfo(prodUnit);
		int iTempMod = 0;
		bool bCombat = pUnitEntry->GetCombat() > 0 || pUnitEntry->GetRangedCombat() > 0 || pUnitEntry->GetNukeDamageLevel() > 0;
		bool bSettler = pUnitEntry->IsFound() || pUnitEntry->IsFoundMid() || pUnitEntry->IsFoundLate() || pUnitEntry->IsFoundAbroad();

		if (bCombat)
		{
			iTempMod = min(0, getHappinessDelta() * /*10*/ GD_INT_GET(LOCAL_UNHAPPY_COMBAT_UNIT_PRODUCTION_PENALTY) * -1);
		}
		else if (bSettler)
		{
			iTempMod = min(0, getHappinessDelta() * /*10*/ GD_INT_GET(LOCAL_UNHAPPY_SETTLER_PRODUCTION_PENALTY) * -1);
			iTempMod += GET_PLAYER(getOwner()).GetUnhappinessSettlerCostPenalty();
		}

		// Can't be lower than -75% from Unhappiness.
		if (iTempMod < /*-75*/ GD_INT_GET(UNHAPPY_MAX_UNIT_PRODUCTION_PENALTY))
			iTempMod = GD_INT_GET(UNHAPPY_MAX_UNIT_PRODUCTION_PENALTY);

		iMultiplier += iTempMod;
		if (iTempMod != 0 && toolTipSink)
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_BALANCE_HAPPINESS_MOD", iTempMod);
	}

	// Military production bonus
	if (pkUnitInfo->IsMilitaryProduction())
	{
		iTempMod = getMilitaryProductionModifier();
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_MILITARY", iTempMod);
		}
		CvPlot* pCityPlot = plot();
		for (int iUnitLoop = 0; iUnitLoop < pCityPlot->getNumUnits(); iUnitLoop++)
		{
			iTempMod = pCityPlot->getUnitByIndex(iUnitLoop)->getMilitaryProductionModifier();
			if (iTempMod != 0)
			{
				iMultiplier += iTempMod;
				if (toolTipSink && iTempMod)
				{
					GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_MILITARY_UNITPROMOTION", iTempMod);
				}
			}
		}
	}

	// City Space mod
	if (pkUnitInfo->GetSpaceshipProject() != NO_PROJECT)
	{
		iTempMod = getSpaceProductionModifier();
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_SPACE", iTempMod);
		}

		iTempMod = thisPlayer.getSpaceProductionModifier();

		int iLimitSpaceshipProduction = GC.getGame().GetGameLeagues()->GetSpaceShipProductionMod(getOwner());
		if (iLimitSpaceshipProduction != 0)
		{
			iTempMod += iLimitSpaceshipProduction;
		}

		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_SPACE_PLAYER", iTempMod);
		}
	}
	else
	{
		ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
		if (eMajority != NO_RELIGION && (pkUnitInfo->GetCombat() > 0 || pkUnitInfo->GetRangedCombat() > 0))
		{
			const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
			if (pReligion)
			{
				iTempMod = pReligion->m_Beliefs.GetUnitProductionModifier();
				iMultiplier += iTempMod;
				if (toolTipSink && iTempMod)
				{
					GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_RELIGION_UNIT", iTempMod);
				}
			}
		}
	}

	// Production bonus for having a particular building
	iTempMod = 0;
	int iBuildingMod = 0;
	BuildingTypes eBuilding;
	for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		eBuilding = (BuildingTypes)iI;
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
		if (pkBuildingInfo)
		{
			if (GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
			{
				iTempMod = pkUnitInfo->GetBuildingProductionModifier(eBuilding);

				if (iTempMod != 0)
				{
					iTempMod *= GetCityBuildings()->GetNumBuilding(eBuilding);

					iBuildingMod += iTempMod;
					if (toolTipSink && iTempMod)
					{
						GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_UNIT_WITH_BUILDING", iTempMod, pkBuildingInfo->GetDescription());
					}
				}
			}
		}
	}
	if (iBuildingMod != 0)
	{
		iMultiplier += iBuildingMod;
	}

	return iMultiplier;
}


//	--------------------------------------------------------------------------------
int CvCity::getProductionModifier(BuildingTypes eBuilding, CvString* toolTipSink) const
{
	VALIDATE_OBJECT();
	CvBuildingEntry* thisBuildingEntry = GC.getBuildingInfo(eBuilding);
	if (thisBuildingEntry == NULL)	//should never happen
		return -1;

	int iMultiplier = getGeneralProductionModifiers(toolTipSink) + GET_PLAYER(getOwner()).getProductionModifier(eBuilding, toolTipSink);
	const CvBuildingClassInfo& kBuildingClassInfo = thisBuildingEntry->GetBuildingClassInfo();
	int iTempMod = 0;

	EraTypes eEra = NO_ERA;
	TechTypes eTech = (TechTypes)thisBuildingEntry->GetPrereqAndTech();
	CvTechEntry* pEntry = GC.GetGameTechs()->GetEntry(eTech);
	if (pEntry)
	{
		eEra = (EraTypes)pEntry->GetEra();
	}

	// Wonder bonus
	if (::isWorldWonderClass(kBuildingClassInfo) ||
		::isTeamWonderClass(kBuildingClassInfo) ||
		::isNationalWonderClass(kBuildingClassInfo))
	{
		iTempMod = GetWonderProductionModifier();
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_CITY", iTempMod);
		}

		iTempMod = GET_PLAYER(getOwner()).getWonderProductionModifier();
#if defined(MOD_BALANCE_CORE)
		if (GET_PLAYER(getOwner()).isGoldenAge() && GET_PLAYER(getOwner()).GetPlayerTraits()->GetWonderProductionModGA() > 0)
		{
			iTempMod += GET_PLAYER(getOwner()).GetPlayerTraits()->GetWonderProductionModGA();
		}
#endif
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_PLAYER", iTempMod);
		}

		iTempMod = GetLocalResourceWonderProductionMod(eBuilding, toolTipSink);
		iMultiplier += iTempMod;

		ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
		BeliefTypes eSecondaryPantheon = NO_BELIEF;
		iTempMod = 0;
		if (eMajority != NO_RELIGION)
		{
			const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
			if (pReligion)
			{
				// Depends on era of wonder
				if (eTech != NO_TECH)
				{
					if (pEntry)
					{
						if (eEra != NO_ERA)
						{
							iTempMod = pReligion->m_Beliefs.GetWonderProductionModifier(eEra, getOwner(), GET_PLAYER(getOwner()).getCity(GetID()));
							eSecondaryPantheon = GetCityReligions()->GetSecondaryReligionPantheonBelief();
							if (eSecondaryPantheon != NO_BELIEF)
							{
								if ((int)eEra < GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetObsoleteEra())
								{
									iTempMod += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetWonderProductionModifier();
								}
							}
						}
					}
				}
			}
		}

#if defined(MOD_RELIGION_PERMANENT_PANTHEON)
		// Mod for civs keeping their pantheon belief forever
		if (MOD_RELIGION_PERMANENT_PANTHEON)
		{
			if (GC.getGame().GetGameReligions()->HasCreatedPantheon(getOwner()))
			{
				const CvReligion* pPantheon = GC.getGame().GetGameReligions()->GetReligion(RELIGION_PANTHEON, getOwner());
				BeliefTypes ePantheonBelief = GC.getGame().GetGameReligions()->GetBeliefInPantheon(getOwner());
				if (pPantheon != NULL && ePantheonBelief != NO_BELIEF && ePantheonBelief != eSecondaryPantheon)
				{
					const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
					if (pReligion == NULL || (pReligion != NULL && !pReligion->m_Beliefs.IsPantheonBeliefInReligion(ePantheonBelief, eMajority, getOwner()))) // check that the our religion does not have our belief, to prevent double counting
					{
						if (eEra != NO_ERA)
						{
							if ((int)eEra < GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetObsoleteEra())
							{
								iTempMod += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetWonderProductionModifier();
							}
						}
					}
				}
			}
		}
#endif

		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_RELIGION", iTempMod);
		}

		CvPlot* pCityPlot = plot();
		for (int iUnitLoop = 0; iUnitLoop < pCityPlot->getNumUnits(); iUnitLoop++)
		{
			iTempMod = pCityPlot->getUnitByIndex(iUnitLoop)->getWonderProductionModifier();
			if (iTempMod != 0)
			{
				iMultiplier += iTempMod;
				if (toolTipSink && iTempMod)
				{
					GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_UNITPROMOTION", iTempMod);
				}
			}
		}

		iTempMod = 0;
		for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
		{
			CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);
			ImprovementTypes eImprovement = pLoopPlot->getImprovementType();
			if (eImprovement != NO_IMPROVEMENT && !pLoopPlot->IsImprovementPillaged())
			{
				CvImprovementEntry* pImprovementInfo = GC.getImprovementInfo(eImprovement);
				iTempMod += pImprovementInfo->GetWonderProductionModifier();
			}
		}
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_IMPROVEMENT", iTempMod);
		}
	}
	// Not-wonder bonus
	else
	{
		iTempMod = m_pCityBuildings->GetBuildingProductionModifier();
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_BUILDING_CITY", iTempMod);
		}
	}

	// From policies
	iTempMod = GET_PLAYER(getOwner()).GetPlayerPolicies()->GetBuildingClassProductionModifier((BuildingClassTypes)kBuildingClassInfo.GetID());
	if (iTempMod != 0)
	{
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_BUILDING_POLICY", iTempMod);
		}
	}

	// From traits
	iTempMod = GET_PLAYER(getOwner()).GetPlayerTraits()->GetCapitalBuildingDiscount(eBuilding);
	if (iTempMod != 0)
	{
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_CAPITAL_BUILDING_TRAIT", iTempMod);
		}
	}

	if (GET_PLAYER(getOwner()).GetPlayerTraits()->GetWonderProductionModifierToBuilding() > 0)
	{
		int iMod = GET_PLAYER(getOwner()).GetPlayerTraits()->GetWonderProductionToBuildingDiscount(eBuilding);
		iTempMod = (GetWonderProductionModifier() * iMod) / 100;
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_TO_BUILDING_FROM_CITY_TRAIT", iTempMod);
		}

		iTempMod = (GET_PLAYER(getOwner()).getWonderProductionModifier() * iMod) / 100;
		if (GET_PLAYER(getOwner()).isGoldenAge() && GET_PLAYER(getOwner()).GetPlayerTraits()->GetWonderProductionModGA() > 0)
		{
			iTempMod += (GET_PLAYER(getOwner()).GetPlayerTraits()->GetWonderProductionModGA() * iMod) / 100;
		}
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_TO_BUILDING_FROM_PLAYER_TRAIT", iTempMod);
		}

		BuildingTypes ePyramidWonder = (BuildingTypes)GC.getInfoTypeForString("BUILDING_PYRAMID");
		iTempMod = (GetLocalResourceWonderProductionMod(ePyramidWonder) * iMod) / 100;
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_TO_BUILDING_FROM_RESOURCE_TRAIT", iTempMod);
		}

		ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
		BeliefTypes eSecondaryPantheon = NO_BELIEF;
		if (eMajority != NO_RELIGION)
		{
			const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
			if (pReligion)
			{
				// Depends on era of wonder
				if (eTech != NO_TECH)
				{
					if (pEntry)
					{
						eEra = (EraTypes)pEntry->GetEra();
						if (eEra != NO_ERA)
						{
							iTempMod = (pReligion->m_Beliefs.GetWonderProductionModifier(eEra, getOwner(), GET_PLAYER(getOwner()).getCity(GetID())) * iMod) / 100;
							eSecondaryPantheon = GetCityReligions()->GetSecondaryReligionPantheonBelief();
							if (eSecondaryPantheon != NO_BELIEF)
							{
								if ((int)eEra < GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetObsoleteEra())
								{
									iTempMod += (GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetWonderProductionModifier() * iMod) / 100;
								}
							}
						}
					}
				}
			}
		}
#if defined(MOD_RELIGION_PERMANENT_PANTHEON)
		// Mod for civs keeping their pantheon belief forever
		if (MOD_RELIGION_PERMANENT_PANTHEON)
		{
			if (GC.getGame().GetGameReligions()->HasCreatedPantheon(getOwner()))
			{
				const CvReligion* pPantheon = GC.getGame().GetGameReligions()->GetReligion(RELIGION_PANTHEON, getOwner());
				BeliefTypes ePantheonBelief = GC.getGame().GetGameReligions()->GetBeliefInPantheon(getOwner());
				if (pPantheon != NULL && ePantheonBelief != NO_BELIEF && ePantheonBelief != eSecondaryPantheon)
				{
					const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
					if (pReligion == NULL || (pReligion != NULL && !pReligion->m_Beliefs.IsPantheonBeliefInReligion(ePantheonBelief, eMajority, getOwner()))) // check that the our religion does not have our belief, to prevent double counting
					{
						if (eEra != NO_ERA)
						{
							if ((int)eEra < GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetObsoleteEra())
							{
								iTempMod += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetWonderProductionModifier();
							}
						}
					}
				}
			}
		}
#endif
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_RELIGION", iTempMod);
		}
		iTempMod = (GET_PLAYER(getOwner()).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_WONDER_PRODUCTION_MODIFIER) * iMod) / 100;
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_TO_BUILDING_FROM_POLICY_TRAIT", iTempMod);
		}

		CvPlot* pCityPlot = plot();
		for (int iUnitLoop = 0; iUnitLoop < pCityPlot->getNumUnits(); iUnitLoop++)
		{
			iTempMod = (pCityPlot->getUnitByIndex(iUnitLoop)->getWonderProductionModifier() * iMod) / 100;
			if (iTempMod != 0)
			{
				iMultiplier += iTempMod;
				if (toolTipSink && iTempMod)
				{
					GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_TO_BUILDING_FROM_UNIT_TRAIT", iTempMod);
				}
			}
		}
		int iNumberOfImprovements = 0;
		CvPlot* pLoopPlot = NULL;
		for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
		{
			pLoopPlot = GC.getMap().plotByIndex(*it);
			if (pLoopPlot->getImprovementType() != NO_IMPROVEMENT && !pLoopPlot->IsImprovementPillaged())
			{
				CvImprovementEntry* pImprovementInfo = GC.getImprovementInfo(pLoopPlot->getImprovementType());
				if (pImprovementInfo->GetWonderProductionModifier() > 0)
				{
					iTempMod = (pImprovementInfo->GetWonderProductionModifier() * iMod) / 100;
					iMultiplier += iTempMod;
					iNumberOfImprovements++;
				}
			}
		}
		if (toolTipSink && iTempMod && iNumberOfImprovements)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_TO_BUILDING_FROM_IMPROVEMENT_TRAIT", iTempMod * iNumberOfImprovements);
		}
	}

	if (GET_PLAYER(getOwner()).GetConquestPerEraBuildingProductionMod() != 0)
	{
		if (IsPuppet() || IsNoOccupiedUnhappiness())
		{
			iTempMod = GET_PLAYER(getOwner()).GetConquestPerEraBuildingProductionMod();
			EraTypes eBuildingEra = (EraTypes)0;

			if (thisBuildingEntry->IsCorp())
				eBuildingEra = NO_ERA;

			if (eTech != NO_TECH)
			{
				if (pEntry)
				{
					eBuildingEra = (EraTypes)pEntry->GetEra();
				}
			}

			if (eBuildingEra != NO_ERA)
			{
				int iEraDelta = GET_PLAYER(getOwner()).GetCurrentEra() - eBuildingEra;
				if (iEraDelta > 0)
				{
					iTempMod += GET_PLAYER(getOwner()).GetConquestPerEraBuildingProductionMod() * iEraDelta;
				}
			}
			iMultiplier += iTempMod;
			if (toolTipSink && iTempMod)
			{
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_CONQUEST_BUILDINGS_PRIOR_ERAS", iTempMod);
			}
		}
	}

	// Trait Bonus from Conquest
	if (GET_PLAYER(getOwner()).GetProductionBonusTurnsConquest() > 0)
	{
		iTempMod = GET_PLAYER(getOwner()).GetPlayerTraits()->GetProductionBonusModifierConquest();
		iMultiplier += iTempMod;
		int iTurns = GET_PLAYER(getOwner()).GetProductionBonusTurnsConquest();
		CvString strMessage = GetLocalizedText("TXT_KEY_PRODMOD_TRAIT_BONUS_CONQUEST_TURNS", iTurns);
		const char* szTurnsRemaining = strMessage.GetCString();
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_TRAIT_BONUS_CONQUEST", iTempMod, szTurnsRemaining);
	}

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvCity::getProductionModifier(ProjectTypes eProject, CvString* toolTipSink) const
{
	VALIDATE_OBJECT();
	int iMultiplier = getGeneralProductionModifiers(toolTipSink) + GET_PLAYER(getOwner()).getProductionModifier(eProject, toolTipSink);
	int iTempMod = 0;

	// City Space mod
	if (GC.getProjectInfo(eProject)->IsSpaceship())
	{
		iTempMod = getSpaceProductionModifier();
		iMultiplier += iTempMod;
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_SPACE", iTempMod);
	}

	// Trait Bonus from Conquest
	if (GET_PLAYER(getOwner()).GetProductionBonusTurnsConquest() > 0)
	{
		iTempMod = GET_PLAYER(getOwner()).GetPlayerTraits()->GetProductionBonusModifierConquest();
		iMultiplier += iTempMod;
		int iTurns = GET_PLAYER(getOwner()).GetProductionBonusTurnsConquest();
		CvString strMessage = GetLocalizedText("TXT_KEY_PRODMOD_TRAIT_BONUS_CONQUEST_TURNS", iTurns);
		const char* szTurnsRemaining = strMessage.GetCString();
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_TRAIT_BONUS_CONQUEST", iTempMod, szTurnsRemaining);
	}

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvCity::getProductionModifier(ProcessTypes eProcess, CvString* toolTipSink) const
{
	VALIDATE_OBJECT();
	int iMultiplier = getGeneralProductionModifiers(toolTipSink) + GET_PLAYER(getOwner()).getProductionModifier(eProcess, toolTipSink);

	// Trait Bonus from Conquest
	if (GET_PLAYER(getOwner()).GetProductionBonusTurnsConquest() > 0)
	{
		int iTempMod = GET_PLAYER(getOwner()).GetPlayerTraits()->GetProductionBonusModifierConquest();
		iMultiplier += iTempMod;
	}

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvCity::getProductionDifference(int /*iProductionNeeded*/, int /*iProduction*/, int iProductionModifier, bool bFoodProduction, bool bOverflow) const
{
	VALIDATE_OBJECT();
	// Anarchy, Resistance or Razing? Then no Production is done!
	if (GET_PLAYER(getOwner()).IsAnarchy() || IsResistance() || IsRazing())
		return 0;

	int iFoodProduction = ((bFoodProduction) ? (GetFoodProductionTimes100(getYieldRateTimes100(YIELD_FOOD, false) - foodConsumptionTimes100(true))) / 100 : 0);
	int iOverflow = ((bOverflow) ? (getOverflowProduction() + getFeatureProduction()) : 0);

	// Sum up difference
	int iBaseProduction = getBaseYieldRate(YIELD_PRODUCTION) * 100;
	iBaseProduction += (GetYieldPerPopTimes100(YIELD_PRODUCTION) * getPopulation());
	iBaseProduction += (GetYieldPerPopInEmpireTimes100(YIELD_PRODUCTION) * GET_PLAYER(getOwner()).getTotalPopulation());

	if (MOD_BALANCE_VP && IsIndustrialRouteToCapitalConnected())
	{
		iBaseProduction += GetConnectionGoldTimes100();
	}

	int iModifiedProduction = iBaseProduction * getBaseYieldRateModifier(YIELD_PRODUCTION, iProductionModifier);
	iModifiedProduction /= 10000;

	iModifiedProduction += iOverflow;
	iModifiedProduction += iFoodProduction;

	return iModifiedProduction;
}


//	--------------------------------------------------------------------------------
int CvCity::getCurrentProductionDifference(bool bIgnoreFood, bool bOverflow) const
{
	VALIDATE_OBJECT();
	return getProductionDifference(getProductionNeeded(), getProduction(), getProductionModifier(), (!bIgnoreFood && isFoodProduction()), bOverflow);
}

//	--------------------------------------------------------------------------------
// What is the production of this city, not counting modifiers specific to what we happen to be building?
int CvCity::getRawProductionDifference(bool bIgnoreFood, bool bOverflow) const
{
	VALIDATE_OBJECT();
	return getProductionDifference(getProductionNeeded(), getProduction(), getGeneralProductionModifiers(), (!bIgnoreFood && isFoodProduction()), bOverflow);
}


//	--------------------------------------------------------------------------------
int CvCity::getProductionDifferenceTimes100(int /*iProductionNeeded*/, int /*iProduction*/, int iProductionModifier, bool bFoodProduction, bool bOverflow) const
{
	VALIDATE_OBJECT();
	// Anarchy, Resistance or Razing? Then no Production is done!
	if (GET_PLAYER(getOwner()).IsAnarchy() || IsResistance() || IsRazing())
		return 0;

	int iFoodProduction = ((bFoodProduction) ? (GetFoodProductionTimes100(getYieldRateTimes100(YIELD_FOOD, false) - foodConsumptionTimes100(true))) / 100 : 0);
	iFoodProduction *= 100;

	int iOverflow = ((bOverflow) ? (getOverflowProductionTimes100() + getFeatureProduction() * 100) : 0);

	// Sum up difference
	int iBaseProduction = getBaseYieldRate(YIELD_PRODUCTION) * 100;
	iBaseProduction += (GetYieldPerPopTimes100(YIELD_PRODUCTION) * getPopulation());
	iBaseProduction += (GetYieldPerPopInEmpireTimes100(YIELD_PRODUCTION) * GET_PLAYER(getOwner()).getTotalPopulation());

	if (MOD_BALANCE_VP && IsIndustrialRouteToCapitalConnected())
	{
		iBaseProduction += GetConnectionGoldTimes100();
	}

	int iModifiedProduction = iBaseProduction * getBaseYieldRateModifier(YIELD_PRODUCTION, iProductionModifier);
	iModifiedProduction /= 100;

	iModifiedProduction += iOverflow;
	iModifiedProduction += iFoodProduction;

	int iTradeYield = GET_PLAYER(m_eOwner).GetTrade()->GetTradeValuesAtCityTimes100(this, YIELD_PRODUCTION);
	iModifiedProduction += iTradeYield;

	return iModifiedProduction;
}


//	--------------------------------------------------------------------------------
int CvCity::getCurrentProductionDifferenceTimes100(bool bIgnoreFood, bool bOverflow) const
{
	VALIDATE_OBJECT();
	return getProductionDifferenceTimes100(getProductionNeeded(), getProductionTimes100(), getProductionModifier(), (!bIgnoreFood && isFoodProduction()), bOverflow);
}

//	--------------------------------------------------------------------------------
// What is the production of this city, not counting modifiers specific to what we happen to be building?
int CvCity::getRawProductionDifferenceTimes100(bool bIgnoreFood, bool bOverflow) const
{
	VALIDATE_OBJECT();
	return getProductionDifferenceTimes100(getProductionNeeded(), getProductionTimes100(), getGeneralProductionModifiers(), (!bIgnoreFood && isFoodProduction()), bOverflow);
}


//	--------------------------------------------------------------------------------
int CvCity::getExtraProductionDifference(int iExtra) const
{
	VALIDATE_OBJECT();
	return getExtraProductionDifference(iExtra, getProductionModifier());
}

//	--------------------------------------------------------------------------------
int CvCity::getExtraProductionDifference(int iExtra, UnitTypes eUnit) const
{
	VALIDATE_OBJECT();
	return getExtraProductionDifference(iExtra, getProductionModifier(eUnit));
}

//	--------------------------------------------------------------------------------
int CvCity::getExtraProductionDifference(int iExtra, BuildingTypes eBuilding) const
{
	VALIDATE_OBJECT();
	return getExtraProductionDifference(iExtra, getProductionModifier(eBuilding));
}

//	--------------------------------------------------------------------------------
int CvCity::getExtraProductionDifference(int iExtra, ProjectTypes eProject) const
{
	VALIDATE_OBJECT();
	return getExtraProductionDifference(iExtra, getProductionModifier(eProject));
}

//	--------------------------------------------------------------------------------
int CvCity::getExtraProductionDifference(int iExtra, int iModifier) const
{
	VALIDATE_OBJECT();
	return ((iExtra * getBaseYieldRateModifier(YIELD_PRODUCTION, iModifier)) / 100);
}

//	--------------------------------------------------------------------------------
/// Convert extra food to production if building a unit built partially from food
int CvCity::GetFoodProduction(int iExcessFood) const
{
	return GetFoodProductionTimes100(iExcessFood * 100);
}

//	--------------------------------------------------------------------------------
/// Convert extra food to production if building a unit built partially from food
int CvCity::GetFoodProductionTimes100(int iExcessFoodTimes100) const
{
	int iRtnValue = 0;

	if (iExcessFoodTimes100 <= 0)
	{
		iRtnValue = 0;
	}
	else if (iExcessFoodTimes100 <= 200)
	{
		iRtnValue = iExcessFoodTimes100;
	}
	else if (iExcessFoodTimes100 > 200 && iExcessFoodTimes100 <= 400)
	{
		iRtnValue = 200 + (iExcessFoodTimes100 - 200) * 50 / 100;
	}
	else
	{
		iRtnValue = 300 + (iExcessFoodTimes100 - 400) * 25 / 100;
	}

	return (iRtnValue);
}

//	--------------------------------------------------------------------------------
SPlotStats::SPlotStats():
	vTerrainCount( GC.getNumTerrainInfos(), 0 ),
	vFeatureCount( GC.getNumFeatureInfos(), 0 ),
	vResourceCount( GC.getNumResourceInfos(), 0 ),
	vImprovementCount( GC.getNumImprovementInfos(), 0 )
{
}

SPlotStats CvCity::getPlotStats() const
{
	SPlotStats result;

	for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

		if (pLoopPlot->getImprovementType() != NO_IMPROVEMENT)
			result.vImprovementCount[pLoopPlot->getImprovementType()]++;

		if (pLoopPlot->getTerrainType() != NO_TERRAIN)
			result.vTerrainCount[pLoopPlot->getTerrainType()]++;

		if (pLoopPlot->getFeatureType() != NO_FEATURE)
			result.vFeatureCount[pLoopPlot->getFeatureType()]++;

		if (pLoopPlot->getResourceType(getTeam()) != NO_RESOURCE)
			result.vResourceCount[pLoopPlot->getResourceType(getTeam())]++;
	}

	return result;
}

//	--------------------------------------------------------------------------------
int CvCity::getResourceYieldRateModifier(YieldTypes eIndex, ResourceTypes eResource) const
{
	VALIDATE_OBJECT();
	int iModifier = 0;

	for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
		if (pkBuildingInfo)
		{
			iModifier += m_pCityBuildings->GetNumActiveBuilding(eBuilding) * pkBuildingInfo->GetResourceYieldModifier(eResource, eIndex);
		}
	}

	return iModifier;
}


//	--------------------------------------------------------------------------------
void CvCity::processResource(ResourceTypes eResource, int iChange)
{
	VALIDATE_OBJECT();

	// Yield modifier for having a local resource
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		const YieldTypes eYield = static_cast<YieldTypes>(iI);
		changeResourceYieldRateModifier(eYield, (getResourceYieldRateModifier(eYield, eResource) * iChange));
#if defined(MOD_BALANCE_CORE)
		UpdateCityYields(eYield);
#endif
	}
}


//	--------------------------------------------------------------------------------
void CvCity::processBuilding(BuildingTypes eBuilding, int iChange, bool bFirst, bool bObsolete, bool /*bApplyingAllCitiesBonus*/, bool bNoBonus)
{
	VALIDATE_OBJECT();

	CvBuildingEntry* pBuildingInfo = GC.getBuildingInfo(eBuilding);
	if (pBuildingInfo == NULL)
		return;

	BuildingClassTypes eBuildingClass = pBuildingInfo->GetBuildingClassType();

	CvPlayer& owningPlayer = GET_PLAYER(getOwner());
	CvTeam& owningTeam = GET_TEAM(getTeam());
	if (!(owningTeam.isObsoleteBuilding(eBuilding)) || bObsolete)
	{
		changeFreeExperience(pBuildingInfo->GetFreeExperience() * iChange);
		for (int iI = 0; iI < GC.getNumUnitCombatClassInfos(); iI++)
		{
			const UnitCombatTypes eUnitCombatClass = static_cast<UnitCombatTypes>(iI);
			CvBaseInfo* pkUnitCombatClassInfo = GC.getUnitCombatClassInfo(eUnitCombatClass);
			if (pkUnitCombatClassInfo)
			{
				changeUnitCombatFreeExperience(eUnitCombatClass, pBuildingInfo->GetUnitCombatFreeExperience(iI) * iChange);
				changeUnitCombatProductionModifier(eUnitCombatClass, pBuildingInfo->GetUnitCombatProductionModifier(iI) * iChange);
			}
		}
		for (int iI = 0; iI < NUM_DOMAIN_TYPES; iI++)
		{
			changeDomainFreeExperience(((DomainTypes)iI), pBuildingInfo->GetDomainFreeExperience(iI) * iChange);
			changeDomainProductionModifier(((DomainTypes)iI), pBuildingInfo->GetDomainProductionModifier(iI) * iChange);
		}
		// One-shot items
		if (bFirst && iChange > 0)
		{
			// Global Pop change
			if (pBuildingInfo->GetPopulationChange() != 0)
			{
				setPopulation(std::max(1, (getPopulation() + iChange * pBuildingInfo->GetPopulationChange())));
			}

			// Capital
			if (pBuildingInfo->IsCapital())
				owningPlayer.setCapitalCity(this);

			bool bIsWonder = ::isWorldWonderClass(pBuildingInfo->GetBuildingClassInfo());
			if (bIsWonder)
			{
				owningPlayer.GetCitySpecializationAI()->SetSpecializationsDirty(SPECIALIZATION_UPDATE_WONDER_BUILT_BY_US);
				if (!pBuildingInfo->IsUnlockedByLeague() && !pBuildingInfo->IsCorp())
					owningPlayer.ChangeWondersConstructed(1);
			}
			if (!bNoBonus && bIsWonder)
			{
				int iTourism = owningPlayer.GetHistoricEventTourism(HISTORIC_EVENT_WORLD_WONDER);
				owningPlayer.ChangeNumHistoricEvents(HISTORIC_EVENT_WORLD_WONDER, 1);

				if (iTourism > 0)
				{
					owningPlayer.GetCulture()->AddTourismAllKnownCivsWithModifiers(iTourism);
					if (owningPlayer.GetID() == GC.getGame().getActivePlayer())
					{
						char text[256] = { 0 };

						sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_TOURISM]", iTourism);
						SHOW_PLOT_POPUP(plot(), m_eOwner, text);

						CvNotifications* pNotification = owningPlayer.GetNotifications();
						if (pNotification)
						{
							CvString strMessage;
							CvString strSummary;
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_WW", iTourism);
							strSummary = GetLocalizedText("TXT_KEY_TOURISM_EVENT_SUMMARY");
							pNotification->Add(NOTIFICATION_CULTURE_VICTORY_SOMEONE_INFLUENTIAL, strMessage, strSummary, getX(), getY(), owningPlayer.GetID());
						}
					}
				}
			}

			// Free Units
			int iFreeUnitLoop = 0;
			int iFreeSpecUnitLoop = 0;
			for (int iUnitLoop = 0; iUnitLoop < GC.getNumUnitInfos(); iUnitLoop++)
			{
				const UnitTypes eUnit = static_cast<UnitTypes>(iUnitLoop);
				const CvUnitEntry* pUnitInfo = GC.getUnitInfo(eUnit);
				if (pUnitInfo)
				{
					// No settling units for One City Challenge
					if (isHuman() && pUnitInfo->IsFound() && GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE))
						continue;

					int iNumFreeUnits = pBuildingInfo->GetNumFreeUnits(iUnitLoop);
					int iNumFreeSpecUnits = pBuildingInfo->GetNumFreeSpecialUnits(iUnitLoop);

					if (iNumFreeUnits > 0 || iNumFreeSpecUnits > 0)
					{
						for (iFreeSpecUnitLoop = 0; iFreeSpecUnitLoop < iNumFreeSpecUnits; iFreeSpecUnitLoop++)
						{
							SpawnFreeUnit(eUnit);
						}

						// Get the right unit of this class for this civ
						const UnitClassTypes eFreeUnitClass = static_cast<UnitClassTypes>(pUnitInfo->GetUnitClassType());
						UnitTypes eFreeUnit = owningPlayer.GetSpecificUnitType(eFreeUnitClass);

						// For Venice, replace any spawned settling unit with Merchant of Venice
						if (pUnitInfo->IsFound() && owningPlayer.GetPlayerTraits()->IsNoAnnexing())
						{
							bool bFound = false;
							for (int iVeniceSearch = 0; iVeniceSearch < GC.getNumUnitClassInfos(); iVeniceSearch++)
							{
								const UnitClassTypes eVeniceUnitClass = static_cast<UnitClassTypes>(iVeniceSearch);
								const UnitTypes eMerchantOfVeniceUnit = owningPlayer.GetSpecificUnitType(eVeniceUnitClass);
								if (eMerchantOfVeniceUnit != NO_UNIT)
								{
									CvUnitEntry* pVeniceUnitEntry = GC.getUnitInfo(eMerchantOfVeniceUnit);
									if (pVeniceUnitEntry->IsCanBuyCityState())
									{
										eFreeUnit = eMerchantOfVeniceUnit;
										bFound = true;
										break;
									}
								}
							}

							// Failed to find a replacement
							if (!bFound)
								continue;
						}

						for (iFreeUnitLoop = 0; iFreeUnitLoop < iNumFreeUnits; iFreeUnitLoop++)
						{
							SpawnFreeUnit(eFreeUnit);
						}
					}
				}
			}

			// Is this a Corporation building?
			CvBuildingClassInfo* pkBuildingClass = GC.getBuildingClassInfo(eBuildingClass);
			if (pkBuildingClass)
			{
				CorporationTypes eCorporation = pkBuildingClass->getCorporationType();
				if (eCorporation != NO_CORPORATION)
				{
					// Valid corporation
					CvCorporationEntry* pkCorporationInfo = GC.getCorporationInfo(eCorporation);
					if (pkCorporationInfo != NULL)
					{
						// Should we found this Corporation?
						if (pkCorporationInfo->GetHeadquartersBuildingClass() == eBuildingClass)
						{
							if (iChange > 0)
							{
								GC.getGame().GetGameCorporations()->FoundCorporation(getOwner(), eCorporation, this);
							}
						}
					}
				}
			}

			// Free building
			BuildingClassTypes eFreeBuildingClassThisCity = static_cast<BuildingClassTypes>(pBuildingInfo->GetFreeBuildingThisCity());
			if (eFreeBuildingClassThisCity != NO_BUILDINGCLASS)
			{
				BuildingTypes eFreeBuildingThisCity = GetBuildingTypeFromClass(eFreeBuildingClassThisCity, true);
				if (eFreeBuildingThisCity != NO_BUILDING)
				{
					SetNumFreeBuilding(eFreeBuildingThisCity, 1);
				}
			}

			// Free Great Work
			GreatWorkType eGWType = pBuildingInfo->GetFreeGreatWork();
			if (eGWType != NO_GREAT_WORK)
			{
				GreatWorkClass eClass = CultureHelpers::GetGreatWorkClass(eGWType);
				int iGWindex = GC.getGame().GetGameCulture()->CreateGreatWork(eGWType, eClass, m_eOwner, owningPlayer.GetCurrentEra(), pBuildingInfo->GetDescription());
				m_pCityBuildings->SetBuildingGreatWork(eBuildingClass, 0, iGWindex);

				GetCityCulture()->CalculateBaseTourismBeforeModifiers();
				GetCityCulture()->CalculateBaseTourism();

				if (owningPlayer.GetPlayerTraits()->IsGreatWorkWLTKD())
				{
					int iWLTKD = /*6*/ GD_INT_GET(CITY_RESOURCE_WLTKD_TURNS) / 3;
					iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
					iWLTKD /= 100;

					if (iWLTKD > 0)
					{
						CvCity* pLoopCity = NULL;
						int iCityLoop = 0;

						// Loop through owner's cities.
						for (pLoopCity = owningPlayer.firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = owningPlayer.nextCity(&iCityLoop))
						{
							if (pLoopCity != NULL)
							{
								pLoopCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
							}
						}
						CvNotifications* pNotifications = owningPlayer.GetNotifications();
						if (pNotifications)
						{
							Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UA_GREAT_WORK");
							strText << iWLTKD << /*25*/ GD_INT_GET(WLTKD_GROWTH_MULTIPLIER);
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UA_GREAT_WORK");
							pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), -1);
						}
					}
				}
			}

			// Tech boost for science buildings in capital
			if (owningPlayer.GetPlayerTraits()->IsTechBoostFromCapitalScienceBuildings())
			{
				if (isCapital())
				{
					if (pBuildingInfo->IsScienceBuilding())
					{
						int iMedianTechResearch = owningPlayer.GetPlayerTechs()->GetMedianTechResearch();
						iMedianTechResearch = (iMedianTechResearch * owningPlayer.GetMedianTechPercentage()) / 100;
						owningPlayer.doInstantYield(INSTANT_YIELD_TYPE_INSTANT, false, NO_GREATPERSON, eBuilding, iMedianTechResearch, false, NO_PLAYER, NULL, false, this);
					}
				}
			}

			// TERRA COTTA AWESOME
			if (pBuildingInfo->GetInstantMilitaryIncrease())
			{
				std::vector<UnitTypes> aExtraUnits;
				std::vector<UnitAITypes> aExtraUnitAITypes;
				CvUnit* pLoopUnit = NULL;
				int iLoop = 0;
				for (pLoopUnit = GET_PLAYER(m_eOwner).firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = GET_PLAYER(m_eOwner).nextUnit(&iLoop))
				{
					if (pLoopUnit->getDomainType() == DOMAIN_LAND && pLoopUnit->IsCombatUnit())
					{
						UnitTypes eCurrentUnitType = pLoopUnit->getUnitType();
						UnitAITypes eCurrentUnitAIType = pLoopUnit->AI_getUnitAIType();

						// check for duplicate unit
						bool bAddUnit = true;
						for (uint ui = 0; ui < aExtraUnits.size(); ui++)
						{
							if (aExtraUnits[ui] == eCurrentUnitType)
							{
								bAddUnit = false;
							}
						}

						if (bAddUnit)
						{
							aExtraUnits.push_back(eCurrentUnitType);
							aExtraUnitAITypes.push_back(eCurrentUnitAIType);
						}
					}
				}

				for (uint ui = 0; ui < aExtraUnits.size(); ui++)
				{
					CvUnit* pNewUnit = GET_PLAYER(m_eOwner).initUnit(aExtraUnits[ui], m_iX, m_iY, aExtraUnitAITypes[ui]);
					bool bJumpSuccess = pNewUnit->jumpToNearestValidPlot();

					if (bJumpSuccess)
					{
						addProductionExperience(pNewUnit);
					}
					else
					{
						pNewUnit->kill(false);
						break;
					}
				}
			}
			// END TERRA COTTA AWESOME

			if (pBuildingInfo->IsReformation())
			{
				GET_PLAYER(getOwner()).SetReformation(true);
			}
			if (pBuildingInfo->GrantsRandomResourceTerritory() > 0 && iChange > 0)
			{
				CvPlayer& kPlayer = GET_PLAYER(getOwner());
				if (!kPlayer.GetPlayerTraits()->GetUniqueLuxuryCities())
				{
					// Does this building add resources?
					int iNumResourceTotal = pBuildingInfo->GrantsRandomResourceTerritory();
					if (iNumResourceTotal != 0)
					{
						// Find our unique resources
						vector<ResourceTypes> vPossibleResources;
						for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
						{
							ResourceTypes eResource = (ResourceTypes)iResourceLoop;
							CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
							if (pkResource != NULL && pkResource->GetRequiredCivilization() == kPlayer.getCivilizationType())
							{
								vPossibleResources.push_back(eResource);

								//if this is one we haven't got so far, boost the chance
								if (kPlayer.getNumResourceTotal(eResource, false) == 0)
									vPossibleResources.push_back(eResource);
							}
						}

						if (vPossibleResources.size() > 0)
						{
							//choose one
							uint uChoice = GC.getGame().urandLimitExclusive(vPossibleResources.size(), plot()->GetPseudoRandomSeed().mix(GET_PLAYER(getOwner()).GetPseudoRandomSeed()));
							ResourceTypes eResourceToGive = vPossibleResources[uChoice];

							int iNumResourceGiven = 0;
							CvPlot* pLoopPlot = NULL;

							for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
							{
								pLoopPlot = iterateRingPlots(getX(), getY(), iCityPlotLoop);
								if (pLoopPlot != NULL && pLoopPlot->getOwner() == owningPlayer.GetID() && !pLoopPlot->isCity() &&
									pLoopPlot->isValidMovePlot(getOwner()) && !pLoopPlot->isWater() && !pLoopPlot->IsNaturalWonder() && !pLoopPlot->isMountain() && (pLoopPlot->getFeatureType() == NO_FEATURE))
								{
									if (pLoopPlot->getResourceType() == NO_RESOURCE && pLoopPlot->getImprovementType() == NO_IMPROVEMENT)
									{
										pLoopPlot->setResourceType(NO_RESOURCE, 0, false);
										pLoopPlot->setResourceType(eResourceToGive, 1, false);
										iNumResourceGiven++;
										if (iNumResourceGiven >= iNumResourceTotal)
										{
											break;
										}
									}
								}
							}
							if (iNumResourceGiven < iNumResourceTotal)
							{
								for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
								{
									pLoopPlot = iterateRingPlots(getX(), getY(), iCityPlotLoop);
									if (pLoopPlot != NULL && (pLoopPlot->getOwner() == NO_PLAYER) && pLoopPlot->isValidMovePlot(getOwner()) &&
										!pLoopPlot->isWater() && !pLoopPlot->IsNaturalWonder() && (pLoopPlot->getFeatureType() != FEATURE_OASIS))
									{
										if (pLoopPlot->getResourceType() == NO_RESOURCE && pLoopPlot->getImprovementType() == NO_IMPROVEMENT)
										{
											pLoopPlot->setResourceType(NO_RESOURCE, 0, false);
											pLoopPlot->setResourceType(eResourceToGive, 1, false);
											iNumResourceGiven++;
											if (iNumResourceGiven >= iNumResourceTotal)
											{
												break;
											}
										}
									}
								}
							}
							if (iNumResourceGiven < iNumResourceTotal)
							{
								ResourceTypes eCurrentResource = plot()->getResourceType(getTeam());
								if (eCurrentResource == NO_RESOURCE)
									plot()->setResourceType(eResourceToGive, 1, false);
							}
						}
					}
				}
				else
				{
					GET_PLAYER(getOwner()).GetPlayerTraits()->AddUniqueLuxuriesAround(this, pBuildingInfo->GrantsRandomResourceTerritory() * iChange);
				}
			}

			if (MOD_BALANCE_CORE_BUILDING_INSTANT_YIELD && (iChange > 0))
			{
				if (!IsBuildingConstructed(eBuildingClass))
				{
					SetBuildingConstructed(eBuildingClass, true);
					GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_INSTANT, false, NO_GREATPERSON, eBuilding, 0, false, NO_PLAYER, NULL, false, this);
					
					if (pBuildingInfo->GetInstantReligionPressure() > 0) 
					{
						ReligionTypes eReligion = GET_PLAYER(getOwner()).getCapitalCity()->GetCityReligions()->GetReligiousMajority();
						if (eReligion > RELIGION_PANTHEON)
						{
							GetCityReligions()->AddReligiousPressure(FOLLOWER_CHANGE_INSTANT_YIELD, eReligion, pBuildingInfo->GetInstantReligionPressure());
							GetCityReligions()->RecomputeFollowers(FOLLOWER_CHANGE_INSTANT_YIELD);
						}
					}
				}
			}
		}

		if (pBuildingInfo->GetTrainedFreePromotion() != NO_PROMOTION)
		{
			changeFreePromotionCount(((PromotionTypes)(pBuildingInfo->GetTrainedFreePromotion())), iChange);

			//Let's give this to all units from this city.
			if (MOD_BALANCE_RETROACTIVE_PROMOS)
			{
				SetRetroactivePromotion((PromotionTypes)(pBuildingInfo->GetTrainedFreePromotion()));
			}
		}

		GetCityBuildings()->ChangeBuildingDefenseMod(pBuildingInfo->GetBuildingDefenseModifier() * iChange);
		changeCitySupplyModifier(pBuildingInfo->GetCitySupplyModifier() * iChange);
		changeCitySupplyFlat(pBuildingInfo->GetCitySupplyFlat() * iChange);
		changeCityBuildingBombardRange(pBuildingInfo->CityRangedStrikeRange() * iChange);
		changeCityIndirectFire(pBuildingInfo->CityIndirectFire() * iChange);
		changeCityBuildingRangeStrikeModifier(pBuildingInfo->CityRangedStrikeModifier() * iChange);
		changeGarrisonRangedAttackModifier(pBuildingInfo->GetGarrisonRangedAttackModifier() * iChange);
		if (pBuildingInfo->GetDefensePerXWonder() > 0)
		{
			ChangeDefensePerWonder(fraction(1, pBuildingInfo->GetDefensePerXWonder()) * iChange);
		}

		if (pBuildingInfo->AllowsProductionTradeRoutes())
		{
			SetProductionRoutes(pBuildingInfo->AllowsProductionTradeRoutes() * iChange > 0);
		}
		if (pBuildingInfo->AllowsFoodTradeRoutes())
		{
			SetFoodRoutes(pBuildingInfo->AllowsFoodTradeRoutes() * iChange > 0);
		}
		if (pBuildingInfo->IsAllowsPuppetPurchase())
		{
			SetAllowPuppetPurchase(pBuildingInfo->IsAllowsPuppetPurchase() * iChange > 0);
		}
		if (pBuildingInfo->IsNoStarvationNonSpecialist())
		{
			ChangeNoStarvationNonSpecialist(iChange);
		}

		changeGreatPeopleRateModifier(pBuildingInfo->GetGreatPeopleRateModifier() * iChange);
		changeGPRateModifierPerMarriage(pBuildingInfo->GetGPRateModifierPerMarriage() * iChange);
		changeGPRateModifierPerLocalTheme(pBuildingInfo->GetGPRateModifierPerLocalTheme() * iChange);
		ChangeGPPOnCitizenBirth(pBuildingInfo->GetGPPOnCitizenBirth() * iChange);

		ChangeMaxAirUnits(pBuildingInfo->GetAirModifier() * iChange);
		changeNukeModifier(pBuildingInfo->GetNukeModifier() * iChange);
		changeHealRate(pBuildingInfo->GetHealRateChange() * iChange);
		ChangeExtraHitPoints(pBuildingInfo->GetExtraCityHitPoints() * iChange);
		changeDamageReductionFlat(pBuildingInfo->GetDamageReductionFlat() * iChange);

		ChangeNoOccupiedUnhappinessCount(pBuildingInfo->IsNoOccupiedUnhappiness() * iChange);

		ChangeFoodBonusPerCityMajorityFollower(pBuildingInfo->GetFoodBonusPerCityMajorityFollower() * iChange);

		ChangeLocalGainlessPillageCount(pBuildingInfo->IsCityGainlessPillage() * iChange); //bool promotion

		ChangeBaseHappinessFromBuildings(pBuildingInfo->GetHappiness() * iChange);
		
		ChangeExperiencePerGoldenAge(pBuildingInfo->GetExperiencePerGoldenAge() * iChange);
		ChangeExperiencePerGoldenAgeCap(pBuildingInfo->GetExperiencePerGoldenAgeCap() * iChange);

		if (pBuildingInfo->GetUnmoddedHappiness() != 0)
		{
			ChangeUnmoddedHappinessFromBuildings(pBuildingInfo->GetUnmoddedHappiness() * iChange);
		}

		if (pBuildingInfo->GetUnhappinessModifier() != 0)
		{
			owningPlayer.ChangeUnhappinessMod(pBuildingInfo->GetUnhappinessModifier() * iChange);
		}

		if (pBuildingInfo->GetLocalUnhappinessModifier() != 0)
		{
			ChangeLocalUnhappinessMod(pBuildingInfo->GetLocalUnhappinessModifier() * iChange);
		}

		int iBuildingCulture = pBuildingInfo->GetYieldChange(YIELD_CULTURE);
		if (iBuildingCulture != 0)
		{
			iBuildingCulture = owningPlayer.GetPlayerTraits()->GetCultureBuildingYieldChange();
		}

		ChangeBaseYieldRateFromBuildings(YIELD_CULTURE, iBuildingCulture * iChange);
		changeCultureRateModifier(pBuildingInfo->GetCultureRateModifier() * iChange);
		ChangeDiplomatInfluenceBoost(pBuildingInfo->GetDiplomatInfluenceBoost() * iChange);
		ChangeBorderGrowthRateIncrease(pBuildingInfo->GetBorderGrowthRateIncrease() * iChange);
		changePlotCultureCostModifier(pBuildingInfo->GetPlotCultureCostModifier() * iChange);
		changePlotBuyCostModifier(pBuildingInfo->GetPlotBuyCostModifier() * iChange);

		changeCityWorkingChange(pBuildingInfo->GetCityWorkingChange() * iChange);
		changeCityAutomatonWorkersChange(pBuildingInfo->GetCityAutomatonWorkersChange() * iChange);

		if (pBuildingInfo->GetReligiousPressureModifier() != 0)
		{
			bool bSpecificFaithOnly = false;
			if (pBuildingInfo->IsUnlockedByBelief())
			{
				ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
				if (eMajority > RELIGION_PANTHEON)
				{
					const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
					if (pReligion != NULL)
					{
						if (pReligion->m_Beliefs.IsBuildingClassEnabled(pBuildingInfo->GetBuildingClassType(), getOwner(), this))
						{
							ChangeReligiousPressureModifier(eMajority, pBuildingInfo->GetReligiousPressureModifier() * iChange);
							bSpecificFaithOnly = true;
						}
					}
				}
			}
			if (!bSpecificFaithOnly)
			{
				for (int iI = RELIGION_PANTHEON + 1; iI < GC.GetGameReligions()->GetNumReligions(); iI++)
				{
					ReligionTypes eReligion = (ReligionTypes)iI;
					ChangeReligiousPressureModifier(eReligion, pBuildingInfo->GetReligiousPressureModifier() * iChange);
				}
			}
		}

		PolicyTypes ePolicy;
		for (int iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)
		{
			ePolicy = (PolicyTypes)iPolicyLoop;

			if (owningPlayer.GetPlayerPolicies()->HasPolicy(ePolicy) && !owningPlayer.GetPlayerPolicies()->IsPolicyBlocked(ePolicy))
			{
				ChangeJONSCulturePerTurnFromPolicies(GC.getPolicyInfo(ePolicy)->GetBuildingClassCultureChange(eBuildingClass) * iChange);
				ChangeSpySecurityModifier(GC.getPolicyInfo(ePolicy)->GetBuildingClassSecurityChange(eBuildingClass) * iChange);
				changeBuildingClassCultureChange(eBuildingClass, GC.getPolicyInfo(ePolicy)->GetBuildingClassCultureChange(eBuildingClass) * iChange);
			}
		}

		ChangeEmpireSizeModifierReduction(pBuildingInfo->GetEmpireSizeModifierReduction() * iChange);
		ChangeDistressFlatReduction(pBuildingInfo->GetDistressFlatReduction() * iChange);
		ChangePovertyFlatReduction(pBuildingInfo->GetPovertyFlatReduction() * iChange);
		ChangeIlliteracyFlatReduction(pBuildingInfo->GetIlliteracyFlatReduction() * iChange);
		ChangeBoredomFlatReduction(pBuildingInfo->GetBoredomFlatReduction() * iChange);
		ChangeReligiousUnrestFlatReduction(pBuildingInfo->GetReligiousUnrestFlatReduction() * iChange);

		ChangeBasicNeedsMedianModifier(pBuildingInfo->GetBasicNeedsMedianModifier() * iChange);
		ChangeGoldMedianModifier(pBuildingInfo->GetGoldMedianModifier() * iChange);
		ChangeScienceMedianModifier(pBuildingInfo->GetScienceMedianModifier() * iChange);
		ChangeCultureMedianModifier(pBuildingInfo->GetCultureMedianModifier() * iChange);
		ChangeReligiousUnrestModifier(pBuildingInfo->GetReligiousUnrestModifier() * iChange);

		if ((pBuildingInfo->GetTradeReligionModifier() != 0))
		{
			ChangeReligiousTradeModifier(pBuildingInfo->GetTradeReligionModifier() * iChange);
		}
		if ((pBuildingInfo->GetCityAirStrikeDefense() > 0))
		{
			ChangeCityAirStrikeDefense(pBuildingInfo->GetCityAirStrikeDefense() * iChange);
		}
		if ((pBuildingInfo->GetBorderObstacleLand() > 0))
		{
			ChangeBorderObstacleCity(pBuildingInfo->GetBorderObstacleLand() * iChange);
		}
		if ((pBuildingInfo->GetBorderObstacleWater() > 0))
		{
			ChangeBorderObstacleWater(pBuildingInfo->GetBorderObstacleWater() * iChange);
		}
		if ((pBuildingInfo->GetDeepWaterTileDamage() > 0))
		{
			ChangeDeepWaterTileDamage(pBuildingInfo->GetDeepWaterTileDamage() * iChange);
		}
		if (bFirst && (iChange > 0) && (pBuildingInfo->GetWLTKDTurns() > 0))
		{
			int iWLTKD = pBuildingInfo->GetWLTKDTurns();
			iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iWLTKD /= 100;
			if (iWLTKD > 0)
			{
				ChangeWeLoveTheKingDayCounter(iWLTKD);
			}
		}
		if (pBuildingInfo->GetLandTourismEnd() > 0)
		{
			ChangeLandTourismBonus(pBuildingInfo->GetLandTourismEnd() * iChange);
		}
		if (pBuildingInfo->GetSeaTourismEnd() > 0)
		{
			ChangeSeaTourismBonus(pBuildingInfo->GetSeaTourismEnd() * iChange);
		}
		if (pBuildingInfo->GetAlwaysHeal() > 0)
		{
			ChangeAlwaysHeal(pBuildingInfo->GetAlwaysHeal() * iChange);
		}
		if (pBuildingInfo->GetResourceDiversityModifier() != 0)
		{
			ChangeResourceDiversityModifier(pBuildingInfo->GetResourceDiversityModifier() * iChange);
		}

		if (pBuildingInfo->GetNoUnhappfromXSpecialists() != 0)
		{
			ChangeNoUnhappfromXSpecialists(pBuildingInfo->GetNoUnhappfromXSpecialists() * iChange);
		}

		if (bFirst && iChange > 0 && pBuildingInfo->GetNumFreeArtifacts() > 0)
		{
			for (int iI = 0; iI < pBuildingInfo->GetNumFreeArtifacts(); iI++)
			{
				if (iI <= pBuildingInfo->GetGreatWorkCount())
				{
					if (GET_PLAYER(getOwner()).GetPlayerTraits()->GetWonderProductionModifier() > 0)
					{
						plot()->AddArchaeologicalRecord(CvTypes::getARTIFACT_SARCOPHAGUS(), GET_PLAYER(getOwner()).GetCurrentEra(), getOwner(), NO_PLAYER);
					}
					else
					{
						plot()->AddArchaeologicalRecord(CvTypes::getARTIFACT_ANCIENT_RUIN(), GET_PLAYER(getOwner()).GetCurrentEra(), getOwner(), NO_PLAYER);
					}
					GreatWorkType eGreatArtifact = CultureHelpers::GetArtifact(plot());
					if (eGreatArtifact != NO_GREAT_WORK)
					{
						GreatWorkClass eClass = CultureHelpers::GetGreatWorkClass(eGreatArtifact);
						if (eClass != NO_GREAT_WORK_CLASS)
						{
							int iGWindex = GC.getGame().GetGameCulture()->CreateGreatWork(eGreatArtifact, eClass, plot()->GetArchaeologicalRecord().m_ePlayer1, plot()->GetArchaeologicalRecord().m_eEra, "");
							if (iGWindex != -1)
							{
								GetCityBuildings()->SetBuildingGreatWork(eBuildingClass, iI, iGWindex);
							}
						}
					}
				}
			}
		}
		// Hurries
		for (int iI = 0; iI < GC.getNumHurryInfos(); iI++)
		{
			changeHurryModifier((HurryTypes)iI, (pBuildingInfo->GetHurryModifierLocal(iI) * iChange));
		}
		for (int iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
		{
			for (int iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
			{
				changeSpecialistExtraYield(((SpecialistTypes)iI), ((YieldTypes)iJ), (pBuildingInfo->GetSpecialistYieldChangeLocal(iI, iJ) * iChange));
			}
		}

		//Trade Routes
		if (pBuildingInfo->GetTradeRouteLandDistanceModifier() != 0)
		{
			ChangeTradeRouteLandDistanceModifier(pBuildingInfo->GetTradeRouteLandDistanceModifier() * iChange);
		}
		if (pBuildingInfo->GetTradeRouteSeaDistanceModifier() != 0)
		{
			ChangeTradeRouteSeaDistanceModifier(pBuildingInfo->GetTradeRouteSeaDistanceModifier() * iChange);
		}

		ChangeUnitPurchaseCooldownMod(true, pBuildingInfo->GetPurchaseCooldownReduction(true) * iChange);
		ChangeUnitPurchaseCooldownMod(false, pBuildingInfo->GetPurchaseCooldownReduction(false) * iChange);

		if (pBuildingInfo->GetBuildingClassInfo().IsOffice() || pBuildingInfo->GetBuildingClassInfo().IsHeadquarters() || pBuildingInfo->GetBuildingClassInfo().IsFranchise())
		{
			for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				UpdateYieldFromCorporationFranchises((YieldTypes)iI);
			}
		}
		if (pBuildingInfo->GetSpecialistType() != NO_SPECIALIST && pBuildingInfo->GetSpecialistCount() > 0)
		{
			GetCityCitizens()->ChangeNumSpecialistSlots((SpecialistTypes)pBuildingInfo->GetSpecialistType(), (pBuildingInfo->GetSpecialistCount() * iChange));
		}

		changeMaxFoodKeptPercent(pBuildingInfo->GetFoodKept() * iChange);
		changeMilitaryProductionModifier(pBuildingInfo->GetMilitaryProductionModifier() * iChange);
		changeSpaceProductionModifier(pBuildingInfo->GetSpaceProductionModifier() * iChange);
		m_pCityBuildings->ChangeBuildingProductionModifier(pBuildingInfo->GetBuildingProductionModifier() * iChange);
		m_pCityBuildings->ChangeBuildingProductionModifierPotentialFromMinorTrade(pBuildingInfo->GetCityStateTradeRouteProductionModifier() * iChange);
		m_pCityBuildings->ChangeMissionaryExtraSpreads(pBuildingInfo->GetExtraMissionarySpreads() * iChange);
		m_pCityBuildings->ChangeLandmarksTourismPercent(pBuildingInfo->GetLandmarksTourismPercent() * iChange);
		m_pCityBuildings->ChangeGreatWorksTourismModifier(pBuildingInfo->GetGreatWorksTourismModifier() * iChange);
		ChangeWonderProductionModifier(pBuildingInfo->GetWonderProductionModifier() * iChange);
		changeCapturePlunderModifier(pBuildingInfo->GetCapturePlunderModifier() * iChange);
		ChangeEspionageModifier(pBuildingInfo->GetEspionageModifier() * iChange);
		ChangeSpySecurityModifier(pBuildingInfo->GetSpySecurityModifier() * iChange);
		ChangeSpySecurityModifierPerXPop(pBuildingInfo->GetSpySecurityModifierPerXPop() * iChange);

		ChangeConversionModifier(pBuildingInfo->GetConversionModifier() * iChange);
		owningPlayer.ChangeConversionModifier(pBuildingInfo->GetGlobalConversionModifier() * iChange);

		changeNukeInterceptionChance(pBuildingInfo->GetNukeInterceptionChance() * iChange);

		ChangeTradeRouteTargetBonus(pBuildingInfo->GetTradeRouteTargetBonus() * iChange);
		ChangeTradeRouteSeaGoldBonus(pBuildingInfo->GetTradeRouteSeaGoldBonus() * iChange);
		ChangeTradeRouteLandGoldBonus(pBuildingInfo->GetTradeRouteLandGoldBonus() * iChange);
		ChangeTradeRouteRecipientBonus(pBuildingInfo->GetTradeRouteRecipientBonus() * iChange);
		ChangeNumTradeRouteBonus(pBuildingInfo->GetTradeRouteLandGoldBonus() * iChange);
		ChangeCityConnectionTradeRouteGoldModifier(pBuildingInfo->GetCityConnectionTradeRouteGoldModifier() * iChange);
		ChangeVassalLevyEra(pBuildingInfo->GetVassalLevyEra() * iChange);

		if (pBuildingInfo->AffectSpiesNow() && iChange > 0)
		{
			for (uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
			{
				PlayerTypes ePlayer = (PlayerTypes)ui;
				GET_PLAYER(ePlayer).GetEspionage()->UpdateCity(this);
			}
		}

		std::multimap<int, std::pair<int, int>> piiGreatPersonProgressFromConstruction = pBuildingInfo->GetGreatPersonProgressFromConstructionArray();
		if (piiGreatPersonProgressFromConstruction.empty() == false)
		{
			for (std::multimap<int, std::pair<int, int>>::const_iterator it = piiGreatPersonProgressFromConstruction.begin(); it != piiGreatPersonProgressFromConstruction.end(); ++it)
			{
				if (it->first >= 0 && it->first < GC.getNumGreatPersonInfos() && it->second.first >= 0 && it->second.first < GC.getNumEraInfos())
				{
					ChangeGreatPersonProgressFromConstruction((GreatPersonTypes)it->first, (EraTypes)it->second.first, it->second.second);
				}
			}
		}

		const set<int>& sUnitClassTrainingAllowed = pBuildingInfo->GetUnitClassTrainingAllowed();
		for (set<int>::const_iterator it = sUnitClassTrainingAllowed.begin(); it != sUnitClassTrainingAllowed.end(); ++it)
		{
			ChangeUnitClassTrainingAllowed((UnitClassTypes)*it, iChange);
		}

		// instant tile claim
		if (iChange > 0)
		{
			if (GetPlotsClaimedByBuilding(eBuilding).size() > 0)
			{
				const std::vector<CvPlot*>& vTilesClaimed = GetPlotsClaimedByBuilding(eBuilding);
				for (std::vector<CvPlot*>::const_iterator it = vTilesClaimed.begin(); it != vTilesClaimed.end(); ++it)
				{
					int iX = (*it)->getX();
					int iY = (*it)->getY();

					if (getOwner() == GC.getGame().getActivePlayer())
					{
						CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
						if (pNotifications)
						{
							CvPlot* pPlotClaimed = GC.getMap().plot(iX, iY);
							ResourceTypes eResource = pPlotClaimed->getResourceType(getTeam());
							CvResourceInfo* pResourceInfo = GC.getResourceInfo(eResource);
							ASSERT_DEBUG(pResourceInfo);
							NotificationTypes eNotificationType = NO_NOTIFICATION_TYPE;

							CvString strBuffer;
							if (pPlotClaimed->getOwner() == NO_PLAYER)
							{
								strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_BUILDING_CLAIMED_RESOURCE", pBuildingInfo->GetTextKey(), getNameKey(), pResourceInfo->GetTextKey());
							}
							else
							{
								strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_BUILDING_CLAIMED_RESOURCE_FROM_OTHER_PLAYER", pBuildingInfo->GetTextKey(), getNameKey(), pResourceInfo->GetTextKey(), GET_PLAYER(pPlotClaimed->getOwner()).getNameKey());
							}
							CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_BUILDING_CLAIMED_RESOURCE_S");

							switch (pResourceInfo->getResourceUsage())
							{
							case RESOURCEUSAGE_LUXURY:
								eNotificationType = NOTIFICATION_DISCOVERED_LUXURY_RESOURCE;
								break;
							case RESOURCEUSAGE_STRATEGIC:
								eNotificationType = NOTIFICATION_DISCOVERED_STRATEGIC_RESOURCE;
								break;
							case RESOURCEUSAGE_BONUS:
								eNotificationType = NOTIFICATION_DISCOVERED_BONUS_RESOURCE;
								break;
							}
							pNotifications->Add(eNotificationType, strBuffer, strSummary, iX, iY, eResource);
						}
					}

					BuyPlot(iX, iY, true);
				}
			}
		}

		// Resource loop
		int iCulture = 0;
		int iFaith = 0;
		ResourceTypes eResource;
		for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
		{
			eResource = (ResourceTypes)iResourceLoop;

			// Does this building add resources?
			int iNumResource = pBuildingInfo->GetResourceQuantity(iResourceLoop) * iChange;
			if (iNumResource != 0)
			{
				owningPlayer.changeNumResourceTotal(eResource, iNumResource, true);
			}

			if (pBuildingInfo->IsResourcePlotsToPlace())
			{
				std::map<int, int> piResourcePlotsToPlace = pBuildingInfo->GetResourcePlotsToPlace(iResourceLoop);

				for (std::map<int, int>::const_iterator it = piResourcePlotsToPlace.begin(); it != piResourcePlotsToPlace.end(); ++it)
				{
					int iNumResourcePlotsGiven = 0;
					int iNumResourceTotalPlots = it->second;
					if (iNumResourceTotalPlots > 0 && (iChange > 0) && bFirst)
					{
						//const ResourceTypes eResourceToPlace = static_cast<ResourceTypes>(iResourceLoop);
						CvPlot* pLoopPlot = NULL;
						for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
						{
							pLoopPlot = iterateRingPlots(getX(), getY(), iCityPlotLoop);
							if (pLoopPlot != NULL && ((pLoopPlot->getOwner() == owningPlayer.GetID()) || (pLoopPlot->getOwner() == NO_PLAYER && pLoopPlot->isValidMovePlot(getOwner()))) && !pLoopPlot->isCity())
							{
								if (pLoopPlot->canHaveResource(eResource, false, true) && pLoopPlot->getResourceType(getTeam()) == NO_RESOURCE)
								{
									ImprovementTypes eImprovement = pLoopPlot->getImprovementType();
									if (eImprovement != NO_IMPROVEMENT)
									{
										CvImprovementEntry* ImprovementEntry = GC.getImprovementInfo(eImprovement);
										if (ImprovementEntry && ImprovementEntry->IsCreatedByGreatPerson() && !ImprovementEntry->IsImprovementResourceMakesValid(eResource))
										{
											continue;
										}
									}

									int iResourceQuantityPerPlot = MAX(it->first, 1);
									pLoopPlot->setResourceType(NO_RESOURCE, 0, false);
									pLoopPlot->setResourceType(eResource, iResourceQuantityPerPlot, false);
									iNumResourcePlotsGiven++;

									if (pLoopPlot->getOwner() == GC.getGame().getActivePlayer())
									{
										if (!CvPreGame::loadWBScenario() || GC.getGame().getGameTurn() > 0)
										{
											CvString strBuffer;
											CvResourceInfo* pResourceInfo = GC.getResourceInfo(eResource);
											ASSERT_DEBUG(pResourceInfo);
											NotificationTypes eNotificationType = NO_NOTIFICATION_TYPE;
											strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_FOUND_RESOURCE", pResourceInfo->GetTextKey());

											CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_FOUND_RESOURCE", pResourceInfo->GetTextKey());

											switch (pResourceInfo->getResourceUsage())
											{
											case RESOURCEUSAGE_LUXURY:
												eNotificationType = NOTIFICATION_DISCOVERED_LUXURY_RESOURCE;
												break;
											case RESOURCEUSAGE_STRATEGIC:
												eNotificationType = NOTIFICATION_DISCOVERED_STRATEGIC_RESOURCE;
												break;
											case RESOURCEUSAGE_BONUS:
												eNotificationType = NOTIFICATION_DISCOVERED_BONUS_RESOURCE;
												break;
											}

											CvNotifications* pNotifications = GET_PLAYER(pLoopPlot->getOwner()).GetNotifications();
											if (pNotifications)
											{
												pNotifications->Add(eNotificationType, strBuffer, strSummary, pLoopPlot->getX(), pLoopPlot->getY(), eResource);
											}
										}
									}
									if (iNumResourcePlotsGiven >= iNumResourceTotalPlots)
									{
										break;
									}
								}
							}
						}
					}
				}
			}
			if (MOD_BALANCE_CORE && (pBuildingInfo->GetResourceQuantityPerXFranchises(iResourceLoop) > 0))
			{
				ChangeResourceQuantityPerXFranchises(eResource, pBuildingInfo->GetResourceQuantityPerXFranchises(iResourceLoop) * iChange);
			}
			if (MOD_BALANCE_CORE && (pBuildingInfo->GetResourceQuantityFromPOP(iResourceLoop) > 0))
			{
				ChangeResourceQuantityFromPOP(eResource, pBuildingInfo->GetResourceQuantityFromPOP(iResourceLoop) * iChange);
			}

			// Do we have this resource local?
			if (IsHasResourceLocal(eResource, /*bTestVisible*/ false))
			{
				// Our Building does give culture with eResource
				iCulture = pBuildingInfo->GetResourceCultureChange(eResource);

				if (iCulture != 0)
				{
					ChangeBaseYieldRateFromBuildings(YIELD_CULTURE, iCulture * m_paiNumResourcesLocal[eResource] * iChange);
				}

				// What about faith?
				iFaith = pBuildingInfo->GetResourceFaithChange(eResource);

				if (iFaith != 0)
				{
					ChangeBaseYieldRateFromBuildings(YIELD_FAITH, iFaith * m_paiNumResourcesLocal[eResource] * iChange);
				}
			}
		}

		if (pBuildingInfo->IsExtraLuxuries())
		{
			CvPlot* pLoopPlot = NULL;

			ChangeExtraLuxuryResources(iChange);

			// Add extra luxury counts

			std::set<int>::iterator it;
			for (it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
			{
				pLoopPlot = GC.getMap().plotByIndex(*it);
				ASSERT_DEBUG(pLoopPlot);

				ResourceTypes eLoopResource = pLoopPlot->getResourceType(getTeam());
				if (eLoopResource != NO_RESOURCE && GC.getResourceInfo(eLoopResource)->getResourceUsage() == RESOURCEUSAGE_LUXURY)
				{
					if (pLoopPlot->IsResourceImprovedForOwner())
					{
						if (iChange > 0)
						{
							owningPlayer.addResourcesOnPlotToTotal(pLoopPlot, true);
						}
						else
						{
							owningPlayer.removeResourcesOnPlotFromTotal(pLoopPlot, true);
						}
					}
					else
					{
						if (iChange > 0)
						{
							owningPlayer.addResourcesOnPlotToUnimproved(pLoopPlot, true);
						}
						else
						{
							owningPlayer.removeResourcesOnPlotFromUnimproved(pLoopPlot, true);
						}
					}
				}
			}
		}

		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);

		for (int iL = 0; iL < GC.getNumSpecialistInfos(); iL++)
		{
			SpecialistTypes eSpecialist = (SpecialistTypes)iL;
			CvSpecialistInfo* pSpecialistInfo = GC.getSpecialistInfo((SpecialistTypes)iL);
			if (pSpecialistInfo)
			{
				int iValue = pBuildingInfo->GetSpecificGreatPersonRateModifier((SpecialistTypes)iL);
				if (iValue > 0)
				{
					ChangeSpecialistRateModifierFromBuildings(eSpecialist, (pBuildingInfo->GetSpecificGreatPersonRateModifier((SpecialistTypes)iL) * iChange));
				}
			}
		}

		if (!pBuildingInfo->GetGreatPersonPointFromConstruction().empty())
		{
			std::map<pair<GreatPersonTypes, EraTypes>, int> mGreatPersonPointFromConstruction = pBuildingInfo->GetGreatPersonPointFromConstruction();
			std::map<pair<GreatPersonTypes, EraTypes>, int>::iterator it;
			for (it = mGreatPersonPointFromConstruction.begin(); it != mGreatPersonPointFromConstruction.end(); ++it)
			{
				ChangeGreatPersonPointFromConstruction(it->first, it->second * iChange);
			}
		}

		YieldTypes eYield;

		for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
		{
			eYield = (YieldTypes)iI;

			//Yield from growth
			if (pBuildingInfo->GetGrowthExtraYield(eYield) != 0)
			{
				ChangeGrowthExtraYield(eYield, pBuildingInfo->GetGrowthExtraYield(eYield) * iChange);
			}

			int iMod = pBuildingInfo->GetGreatWorkYieldChangeLocal(iI) * iChange;
			if (iMod != 0)
			{
				ChangeGreatWorkYieldChange((YieldTypes)iI, iMod);
				ResetGreatWorkYieldCache();
				
			}

			if ((pBuildingInfo->GetYieldFromVictory(eYield) > 0))
			{
				ChangeYieldFromVictory(eYield, pBuildingInfo->GetYieldFromVictory(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldFromVictoryGlobal(eYield) > 0))
			{
				ChangeYieldFromVictoryGlobal(eYield, pBuildingInfo->GetYieldFromVictoryGlobal(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldFromVictoryGlobalEraScaling(eYield) > 0))
			{
				ChangeYieldFromVictoryGlobalEraScaling(eYield, pBuildingInfo->GetYieldFromVictoryGlobalEraScaling(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldFromVictoryGlobalInGoldenAge(eYield) > 0))
			{
				ChangeYieldFromVictoryGlobalInGoldenAge(eYield, pBuildingInfo->GetYieldFromVictoryGlobalInGoldenAge(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldFromVictoryGlobalInGoldenAgeEraScaling(eYield) > 0))
			{
				ChangeYieldFromVictoryGlobalInGoldenAgeEraScaling(eYield, pBuildingInfo->GetYieldFromVictoryGlobalInGoldenAgeEraScaling(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldFromPillage(eYield) > 0))
			{
				ChangeYieldFromPillage(eYield, pBuildingInfo->GetYieldFromPillage(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldFromPillageGlobal(eYield) > 0))
			{
				ChangeYieldFromPillageGlobal(eYield, pBuildingInfo->GetYieldFromPillageGlobal(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldChangePerGoldenAge(eYield) > 0))
			{
				ChangeYieldChangePerGoldenAge(eYield, pBuildingInfo->GetYieldChangePerGoldenAge(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldChangePerGoldenAgeCap(eYield) > 0))
			{
				ChangeYieldChangePerGoldenAgeCap(eYield, pBuildingInfo->GetYieldChangePerGoldenAgeCap(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldFromGoldenAgeStart(eYield) > 0))
			{
				ChangeYieldFromGoldenAgeStart(eYield, pBuildingInfo->GetYieldFromGoldenAgeStart(eYield) * iChange);
			}

			if ((pBuildingInfo->GetGoldenAgeYieldMod(eYield) > 0))
			{
				ChangeGoldenAgeYieldMod(eYield, pBuildingInfo->GetGoldenAgeYieldMod(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldChangesPerLocalTheme(eYield) > 0))
			{
				ChangeYieldChangesPerLocalTheme(eYield, pBuildingInfo->GetYieldChangesPerLocalTheme(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldFromUnitGiftGlobal(eYield) > 0))
			{
				ChangeYieldFromUnitGiftGlobal(eYield, pBuildingInfo->GetYieldFromUnitGiftGlobal(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldFromWLTKD(eYield) > 0))
			{
				ChangeYieldFromWLTKD(eYield, pBuildingInfo->GetYieldFromWLTKD(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldFromConstruction(eYield) > 0))
			{
				ChangeYieldFromConstruction(eYield, pBuildingInfo->GetYieldFromConstruction(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldFromTech(eYield) > 0))
			{
				ChangeYieldFromTech(eYield, pBuildingInfo->GetYieldFromTech(eYield) * iChange);
			}

			for (int iK = 0; iK < NUM_YIELD_TYPES; iK++)
			{
				YieldTypes eYield2 = (YieldTypes)iK;

				//protect against modder stupidity!
				if (eYield == eYield2)
					continue;

				int iBuildingVal = pBuildingInfo->GetYieldFromYield(eYield, eYield2);
				if (iBuildingVal > 0)
				{
					ChangeBuildingYieldFromYield(eYield, eYield2, (iBuildingVal * iChange));
				}

				int iGlobalConversionYield = pBuildingInfo->GetYieldFromYieldGlobal(eYield, eYield2);
				if (iGlobalConversionYield > 0)
				{
					GET_PLAYER(getOwner()).changeYieldFromYieldGlobal(eYield, eYield2, iGlobalConversionYield);
					int iLoop = 0;
					for (CvCity* pLoopCity = GET_PLAYER(getOwner()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(getOwner()).nextCity(&iLoop))
					{
						pLoopCity->ChangeBuildingYieldFromYield(eYield, eYield2, (iGlobalConversionYield * iChange));
					}
				}
			}

			if ((pBuildingInfo->GetYieldFromInternalTREnd(eYield) > 0))
			{
				ChangeYieldFromInternalTREnd(eYield, (pBuildingInfo->GetYieldFromInternalTREnd(eYield) * iChange));
			}
			if ((pBuildingInfo->GetYieldFromInternationalTREnd(eYield) > 0))
			{
				ChangeYieldFromInternationalTREnd(eYield, (pBuildingInfo->GetYieldFromInternationalTREnd(eYield) * iChange));
			}

			if ((pBuildingInfo->GetYieldFromInternal(eYield) > 0))
			{
				ChangeYieldFromInternalTR(eYield, (pBuildingInfo->GetYieldFromInternal(eYield) * iChange));
			}

			if ((pBuildingInfo->GetYieldFromProcessModifier(eYield) > 0))
			{
				ChangeYieldFromProcessModifier(eYield, (pBuildingInfo->GetYieldFromProcessModifier(eYield) * iChange));
			}

			if ((pBuildingInfo->GetYieldFromLongCount(eYield) > 0))
			{
				ChangeYieldFromLongCount(eYield, (pBuildingInfo->GetYieldFromLongCount(eYield) * iChange));
			}

			if ((pBuildingInfo->GetYieldFromGPBirthScaledWithWriterBulb(eYield) > 0))
			{
				ChangeYieldFromGPBirthScaledWithWriterBulb(eYield, (pBuildingInfo->GetYieldFromGPBirthScaledWithWriterBulb(eYield) * iChange));
			}

			if ((pBuildingInfo->GetYieldFromGPBirthScaledWithArtistBulb(eYield) > 0))
			{
				ChangeYieldFromGPBirthScaledWithArtistBulb(eYield, (pBuildingInfo->GetYieldFromGPBirthScaledWithArtistBulb(eYield) * iChange));
			}

			if ((pBuildingInfo->GetThemingYieldBonus(eYield) > 0))
			{
				ChangeThemingYieldBonus(eYield, pBuildingInfo->GetThemingYieldBonus(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldFromSpyAttack(eYield) > 0))
			{
				ChangeYieldFromSpyAttack(eYield, pBuildingInfo->GetYieldFromSpyAttack(eYield) * iChange);
			}
			if ((pBuildingInfo->GetYieldFromSpyDefense(eYield) > 0))
			{
				ChangeYieldFromSpyDefense(eYield, pBuildingInfo->GetYieldFromSpyDefense(eYield) * iChange);
			}
			if ((pBuildingInfo->GetYieldFromSpyIdentify(eYield) > 0))
			{
				ChangeYieldFromSpyIdentify(eYield, pBuildingInfo->GetYieldFromSpyIdentify(eYield) * iChange);
			}
			if ((pBuildingInfo->GetYieldFromSpyDefenseOrID(eYield) > 0))
			{
				ChangeYieldFromSpyDefenseOrID(eYield, pBuildingInfo->GetYieldFromSpyDefenseOrID(eYield) * iChange);
			}
			if ((pBuildingInfo->GetYieldFromSpyRigElection(eYield) > 0))
			{
				ChangeYieldFromSpyRigElection(eYield, pBuildingInfo->GetYieldFromSpyRigElection(eYield) * iChange);
			}
			if ((pBuildingInfo->GetYieldChangesPerCityStrengthTimes100(eYield) > 0))
			{
				ChangeYieldChangesPerCityStrengthTimes100(eYield, pBuildingInfo->GetYieldChangesPerCityStrengthTimes100(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldFromBirth(eYield) > 0))
			{
				ChangeYieldFromBirth(eYield, pBuildingInfo->GetYieldFromBirth(eYield) * iChange);
			}
			if ((pBuildingInfo->GetYieldFromBirthEraScaling(eYield) > 0))
			{
				ChangeYieldFromBirthEraScaling(eYield, pBuildingInfo->GetYieldFromBirthEraScaling(eYield) * iChange);
			}
			if ((pBuildingInfo->GetYieldFromBirthRetroactive(eYield) > 0))
			{
				int iVal = getPopulation() * pBuildingInfo->GetYieldFromBirthRetroactive(eYield);
				GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_BIRTH_RETROACTIVE, false, NO_GREATPERSON, eBuilding, iVal, false, NO_PLAYER, NULL, false, this, false, false, false, eYield);
			}
			if ((pBuildingInfo->GetYieldFromUnitProduction(eYield) > 0))
			{
				ChangeYieldFromUnitProduction(eYield, pBuildingInfo->GetYieldFromUnitProduction(eYield) * iChange);
			}
			if ((pBuildingInfo->GetYieldFromBorderGrowth(eYield) > 0))
			{
				ChangeYieldFromBorderGrowth(eYield, pBuildingInfo->GetYieldFromBorderGrowth(eYield) * iChange);
			}
			if ((pBuildingInfo->GetYieldFromPolicyUnlock(eYield) > 0))
			{
				ChangeYieldFromPolicyUnlock(eYield, pBuildingInfo->GetYieldFromPolicyUnlock(eYield) * iChange);
			}
			if ((pBuildingInfo->GetYieldFromPurchase(eYield) > 0))
			{
				ChangeYieldFromPurchase(eYield, pBuildingInfo->GetYieldFromPurchase(eYield) * iChange);
			}
			if ((pBuildingInfo->GetYieldFromPurchaseGlobal(eYield) > 0))
			{
				ChangeYieldFromPurchaseGlobal(eYield, pBuildingInfo->GetYieldFromPurchaseGlobal(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldFromFaithPurchase(eYield) > 0))
			{
				ChangeYieldFromFaithPurchase(eYield, pBuildingInfo->GetYieldFromFaithPurchase(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldFromUnitLevelUp(eYield) > 0))
			{
				ChangeYieldFromUnitLevelUp(eYield, pBuildingInfo->GetYieldFromUnitLevelUp(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldFromCombatExperienceTimes100(eYield) > 0))
			{
				ChangeYieldFromCombatExperienceTimes100(eYield, pBuildingInfo->GetYieldFromCombatExperienceTimes100(eYield) * iChange);
			}

			ChangeYieldPerAlly(eYield, pBuildingInfo->GetYieldPerAlly(eYield) * iChange);
			ChangeYieldPerFriend(eYield, pBuildingInfo->GetYieldPerFriend(eYield) * iChange);

			if (GetEventBuildingClassCityYield(eBuildingClass, eYield) != 0)
			{
				ChangeBaseYieldRateFromBuildings(eYield, GetEventBuildingClassCityYield(eBuildingClass, eYield) * iChange);
			}
			if (GetEventBuildingClassCityYieldModifier(eBuildingClass, eYield) != 0)
			{
				changeYieldRateModifier(eYield, GetEventBuildingClassCityYieldModifier(eBuildingClass, eYield) * iChange);
			}

			changeSeaPlotYield(eYield, (pBuildingInfo->GetSeaPlotYieldChange(eYield) * iChange));
			changeRiverPlotYield(eYield, (pBuildingInfo->GetRiverPlotYieldChange(eYield) * iChange));
			changeLakePlotYield(eYield, (pBuildingInfo->GetLakePlotYieldChange(eYield) * iChange));
			changeSeaResourceYield(eYield, (pBuildingInfo->GetSeaResourceYieldChange(eYield) * iChange));
			ChangeBaseYieldRateFromBuildings(eYield, ((pBuildingInfo->GetYieldChange(eYield) + m_pCityBuildings->GetBuildingYieldChange(eBuildingClass, eYield)) * iChange));
			ChangeYieldPerPopTimes100(eYield, pBuildingInfo->GetYieldChangePerPop(eYield) * iChange);
			ChangeYieldPerPopInEmpireTimes100(eYield, pBuildingInfo->GetYieldChangePerPopInEmpire(eYield) * iChange);
			ChangeYieldPerReligionTimes100(eYield, pBuildingInfo->GetYieldChangePerReligion(eYield) * iChange);
			changeYieldRateModifier(eYield, (pBuildingInfo->GetYieldModifier(eYield) * iChange));

			CvPlayerPolicies* pPolicies = GET_PLAYER(getOwner()).GetPlayerPolicies();
			changeYieldRateModifier(eYield, pPolicies->GetBuildingClassYieldModifier(eBuildingClass, eYield) * iChange);
			ChangeBaseYieldRateFromBuildings(eYield, pPolicies->GetBuildingClassYieldChange(eBuildingClass, eYield) * iChange);

			int iYieldMod = pBuildingInfo->GetBuildingClassYieldModifier(eBuildingClass, eYield);
			if (iYieldMod != 0)
			{
				changeYieldRateModifier(eYield, iYieldMod * iChange);
			}

			ChangeBaseYieldRateFromBuildings(eYield, GET_PLAYER(getOwner()).GetPlayerTraits()->GetBuildingClassYieldChange(eBuildingClass, eYield) * iChange);

			// Building modifiers
			for (int iJ = 0; iJ < GC.getNumBuildingClassInfos(); iJ++)
			{
				BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iJ);
				CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
				if (!pkBuildingClassInfo)
					continue;

				int iYieldChange = pBuildingInfo->GetBuildingClassLocalYieldChange(iJ, iI);

				if (isWorldWonderClass(*pkBuildingClassInfo))
				{
					iYieldChange += pBuildingInfo->GetYieldChangeWorldWonder(iI);
				}

				if (iYieldChange != 0)
				{
					m_pCityBuildings->ChangeBuildingYieldChange(eBuildingClass, eYield, iYieldChange * iChange);
					changeLocalBuildingClassYield(eBuildingClass, eYield, iYieldChange * iChange);
				}
			}

			CorporationTypes eCorporation = GET_PLAYER(getOwner()).GetCorporations()->GetFoundedCorporation();
			if (eCorporation != NO_CORPORATION)
			{
				CvCorporationEntry* pkCorporationInfo = GC.getCorporationInfo(eCorporation);
				if (pkCorporationInfo)
				{
					ChangeBaseYieldRateFromBuildings(eYield, pkCorporationInfo->GetBuildingClassYieldChange(eBuildingClass, eYield) * iChange);
				}
			}

			//Policy-Religion Fusion Yield Changes
			changeReligionBuildingYieldRateModifier(eBuildingClass, eYield, (pPolicies->GetReligionBuildingClassYieldModifier(eBuildingClass, eYield) * iChange));

			if (pkBuildingClassInfo && isWorldWonderClass(*pkBuildingClassInfo))
			{
				ChangeBaseYieldRateFromBuildings(eYield, GetPlayer()->GetYieldChangeWorldWonder(eYield) * iChange);
				ChangeBaseYieldRateFromBuildings(eYield, GetPlayer()->GetPlayerTraits()->GetYieldChangeWorldWonder(eYield) * iChange);
				int iGlobalWonderBonus = owningPlayer.GetWorldWonderYieldChange(iI);
				if (iGlobalWonderBonus != 0)
				{
					m_pCityBuildings->ChangeBuildingYieldChange(eBuildingClass, eYield, (iGlobalWonderBonus * iChange));
					changeLocalBuildingClassYield(eBuildingClass, eYield, (iGlobalWonderBonus * iChange));
				}
			}

			for (int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
			{
				ChangeResourceExtraYield(((ResourceTypes)iJ), eYield, (pBuildingInfo->GetResourceYieldChange(iJ, eYield) * iChange));
			}

			for (int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
			{
				ChangeFeatureExtraYield(((FeatureTypes)iJ), eYield, (pBuildingInfo->GetFeatureYieldChange(iJ, eYield) * iChange));
			}

			// Is this building part of a Corporation?
			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
			if (pkBuildingClassInfo)
			{
				CorporationTypes eCorporation = pkBuildingClassInfo->getCorporationType();
				if (eCorporation != NO_CORPORATION)
				{
					CvCorporationEntry* pkCorporationInfo = GC.getCorporationInfo(eCorporation);
					if (pkCorporationInfo)
					{
						// Only if this is the Franchise
						if (pkCorporationInfo->GetFranchiseBuildingClass() == eBuildingClass)
						{
							for (int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
							{
								ChangeResourceExtraYield(((ResourceTypes)iJ), eYield, (pkCorporationInfo->GetResourceYieldChange(iJ, eYield) * iChange));
							}
						}
					}
				}
			}

			for (int iJ = 0; iJ < GC.getNumImprovementInfos(); iJ++)
			{
				ImprovementTypes eImprovement = (ImprovementTypes)iJ;
				if (eImprovement != NO_IMPROVEMENT)
				{
					int iYieldChange = pBuildingInfo->GetImprovementYieldChange(eImprovement, eYield);
					if (iYieldChange > 0)
					{
						ChangeImprovementExtraYield(eImprovement, eYield, (iYieldChange * iChange));
					}
				}
			}

			for (int iJ = 0; iJ < GC.getNumTerrainInfos(); iJ++)
			{
				ChangeTerrainExtraYield(((TerrainTypes)iJ), eYield, (pBuildingInfo->GetTerrainYieldChange(iJ, eYield) * iChange));
				ChangeYieldPerXTerrainFromBuildingsTimes100(((TerrainTypes)iJ), eYield, (pBuildingInfo->GetYieldPerXTerrain(iJ, eYield) * iChange));
			}

			for (int iJ = 0; iJ < GC.getNumPlotInfos(); iJ++)
			{
				ChangePlotExtraYield(((PlotTypes)iJ), eYield, (pBuildingInfo->GetPlotYieldChange(iJ, eYield) * iChange));
			}

			for (int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
			{
				ChangeYieldPerXFeatureFromBuildingsTimes100(((FeatureTypes)iJ), eYield, (pBuildingInfo->GetYieldPerXFeature(iJ, eYield) * iChange));
			}

			if (!pBuildingInfo->GetTechEnhancedYields().empty())
			{
				map<int, std::map<int, int>> mTechEnhancedYields = pBuildingInfo->GetTechEnhancedYields();
				map<int, std::map<int, int>>::iterator it;
				for (it = mTechEnhancedYields.begin(); it != mTechEnhancedYields.end(); ++it)
				{
					std::map<int, int>::const_iterator it2 = (it->second).find(eYield);
					if (it2 != (it->second).end())
					{
						ChangeTechEnhancedYields((TechTypes)it->first, eYield, it2->second * iChange);
					}
				}
			}

			int iBuildingClassBonus = owningPlayer.GetBuildingClassYieldChange(eBuildingClass, eYield);
			if (iBuildingClassBonus > 0)
			{
				ChangeBaseYieldRateFromBuildings(eYield, iBuildingClassBonus * iChange);
			}
		}

		if (!pBuildingInfo->GetYieldFromGPBirthScaledWithPerTurnYieldMap().empty())
		{
			map<GreatPersonTypes, map<std::pair<YieldTypes, YieldTypes>, int>> mYieldFromGPBirthScaledWithPerTurnYield = pBuildingInfo->GetYieldFromGPBirthScaledWithPerTurnYieldMap();
			map<GreatPersonTypes, map<std::pair<YieldTypes, YieldTypes>, int>>::iterator it;
			for (it = mYieldFromGPBirthScaledWithPerTurnYield.begin(); it != mYieldFromGPBirthScaledWithPerTurnYield.end(); ++it)
			{
				map<std::pair<YieldTypes, YieldTypes>, int> mInnerYieldMap = it->second;
				map<std::pair<YieldTypes, YieldTypes>, int>::iterator it2;
				for (it2 = mInnerYieldMap.begin(); it2 != mInnerYieldMap.end(); ++it2)
				{
					ChangeYieldFromGPBirthScaledWithPerTurnYield(it->first, it2->first, it2->second);
				}
			}
		}

		if (pBuildingInfo->GetSpecialistType() != NO_SPECIALIST)
		{
			GetCityCitizens()->ChangeBuildingGreatPeopleRateChanges((SpecialistTypes)pBuildingInfo->GetSpecialistType(), pBuildingInfo->GetGreatPeopleRateChange() * iChange);
		}

		// Process for our player
		for (int iI = 0; iI < MAX_PLAYERS; iI++)
		{
			if (GET_PLAYER((PlayerTypes)iI).getTeam() == getTeam())
			{
				if (pBuildingInfo->IsTeamShare() || (iI == getOwner()))
				{
					GET_PLAYER((PlayerTypes)iI).processBuilding(eBuilding, iChange, bFirst, this);
				}
			}
		}

		// Process for our team
		owningTeam.processBuilding(eBuilding, iChange);
	}

	if (!bObsolete)
	{
		m_pCityBuildings->ChangeBuildingDefense(pBuildingInfo->GetDefenseModifier() * iChange);

		owningTeam.changeBuildingClassCount(eBuildingClass, iChange);
		owningPlayer.changeBuildingClassCount(eBuildingClass, iChange);
	}

	UpdateReligion(GetCityReligions()->GetReligiousMajority());
	GET_PLAYER(getOwner()).CalculateNetHappiness();
	updateNetHappiness();

	GetCityCitizens()->SetDirty(true);

	if (IsPurchased(eBuildingClass) || pBuildingInfo->IsDummy())
	{
		bNoBonus = true;
	}
	//If a building is being processed, it has been here before. No more bonuses!
	if (!IsResistance() && !IsRazing() && !bNoBonus && bFirst && iChange > 0)
	{
		if (GetCityBuildings()->IsFirstTimeBuilding(eBuilding) <= 0)
		{
			GetCityBuildings()->SetFirstTimeBuilding(eBuilding, 1);

			if (::isWorldWonderClass(*GC.getBuildingClassInfo(eBuildingClass)))
			{
				GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_CONSTRUCTION_WONDER, false, NO_GREATPERSON, eBuilding, 0, true, NO_PLAYER, NULL, false, this);
			}
			else
			{
				GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_CONSTRUCTION, true, NO_GREATPERSON, eBuilding, 0, true, NO_PLAYER, NULL, false, this);
				GET_PLAYER(getOwner()).doInstantGreatPersonProgress(INSTANT_YIELD_TYPE_CONSTRUCTION, false, this, eBuilding);
			}
		}
	}

	setLayoutDirty(true);
}


//	--------------------------------------------------------------------------------
void CvCity::processProcess(ProcessTypes eProcess, int iChange)
{
	VALIDATE_OBJECT();
	const CvProcessInfo* pkProcessInfo = GC.getProcessInfo(eProcess);
	ASSERT_DEBUG(pkProcessInfo != NULL, "Process type %d is invalid", eProcess);
	if (pkProcessInfo != NULL)
	{
		// Convert to another yield
		for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
		{
			if (pkProcessInfo->getProductionToYieldModifier((YieldTypes)iI) <= 0)
				continue;

			int iDifficultyMod = GET_PLAYER(getOwner()).getHandicapInfo().getProcessBonus();
			iDifficultyMod += GET_PLAYER(getOwner()).getHandicapInfo().getProcessPerEraModifier() * GC.getGame().getCurrentEra();
			iDifficultyMod += GET_PLAYER(getOwner()).isHuman() ? 0 : GC.getGame().getHandicapInfo().getAIProcessBonus();
			iDifficultyMod += GET_PLAYER(getOwner()).isHuman() ? 0 : GC.getGame().getHandicapInfo().getAIProcessPerEraModifier() * GC.getGame().getCurrentEra();

			changeProductionToYieldModifier((YieldTypes)iI, (pkProcessInfo->getProductionToYieldModifier(iI) + GetYieldFromProcessModifier((YieldTypes)iI) + iDifficultyMod) * iChange);

			UpdateCityYields((YieldTypes)iI);
		}
	}
}


//	--------------------------------------------------------------------------------
void CvCity::processSpecialist(SpecialistTypes eSpecialist, int iChange, CvCity::eUpdateMode updateMode)
{
	VALIDATE_OBJECT();
	CvSpecialistInfo* pkSpecialist = GC.getSpecialistInfo(eSpecialist);
	if (pkSpecialist == NULL)
	{
		//This function requires a valid specialist type.
		return;
	}

	changeBaseGreatPeopleRate(pkSpecialist->getGreatPeopleRateChange() * iChange);

	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		ChangeBaseYieldRateFromSpecialists(((YieldTypes)iI), (pkSpecialist->getYieldChange(iI) * iChange));
	}
	updateExtraSpecialistYield();
	changeSpecialistFreeExperience(pkSpecialist->getExperience() * iChange);

	// Culture
	int iCulturePerSpecialist = GetCultureFromSpecialist(eSpecialist);
	ChangeJONSCulturePerTurnFromSpecialists(iCulturePerSpecialist * iChange);

	for (int iI = 0; iI < NUM_DOMAIN_TYPES; iI++)
	{
		DomainTypes eDomain = (DomainTypes)iI;
		if (eDomain == NO_DOMAIN)
			continue;

		int iModifierPerSpecialist = GET_PLAYER(getOwner()).GetPlayerTraits()->GetDomainProductionModifiersPerSpecialist(eDomain);

		if (iModifierPerSpecialist != 0)
		{
			changeDomainProductionModifier(eDomain, iModifierPerSpecialist * iChange);
		}
	}

	if (updateMode == CvCity::YIELD_UPDATE_GLOBAL)
		UpdateAllNonPlotYields(true);
	else if (updateMode == CvCity::YIELD_UPDATE_LOCAL)
		UpdateAllNonPlotYields(false);
}

//very reduced version of UpdateReligion() which assumes only the number of specialists changed
void CvCity::UpdateReligiousYieldFromSpecialist(bool bFirstOneAdded)
{
	const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion( GetCityReligions()->GetReligiousMajority(), getOwner() );
	if (pReligion)
	{
		for (int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)
		{
			int iChange = pReligion->m_Beliefs.GetYieldChangeAnySpecialist((YieldTypes)iYield, getOwner(), this);

			//surgically add or remove some yields but don't recalculate from scratch
			if (bFirstOneAdded)
				ChangeBaseYieldRateFromReligion((YieldTypes)iYield, +iChange);
			else
				ChangeBaseYieldRateFromReligion((YieldTypes)iYield, -iChange);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Process the majority religion changing for a city
void CvCity::UpdateReligion(ReligionTypes eNewMajority, bool bRecalcPlotYields)
{
	updateYield(bRecalcPlotYields);

	// Reset city level yields
	for (int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)
	{
		m_aiBaseYieldRateFromReligion[iYield] = 0;
	}

	for (int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)
	{
		int iYieldPerReligion = GetYieldPerReligionTimes100((YieldTypes)iYield);

		// Player-level yield per religion
		iYieldPerReligion += GET_PLAYER(getOwner()).GetYieldChangesPerReligionTimes100((YieldTypes)iYield);

		if (iYieldPerReligion > 0)
		{
			ChangeBaseYieldRateFromReligion((YieldTypes)iYield, (GetCityReligions()->GetNumReligionsWithFollowers() * iYieldPerReligion) / 100);
		}

		if (eNewMajority != NO_RELIGION)
		{
			const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eNewMajority, getOwner());
			if (pReligion)
			{
				int iFollowers = GetCityReligions()->GetNumFollowers(eNewMajority);

				int iReligionYieldChange = pReligion->m_Beliefs.GetCityYieldChange(getPopulation(), (YieldTypes)iYield, getOwner(), this);
				int iReligionPop = pReligion->m_Beliefs.GetYieldPerPop((YieldTypes)iYield, getOwner(), this);
				if ((getPopulation() > 0) && (iReligionPop > 0))
				{
					int iFaithPerPop = (getPopulation() / iReligionPop);
					if (iFaithPerPop != 0)
					{
						iReligionYieldChange += iFaithPerPop;
					}
				}

				int iReligionYieldMaxFollowers = pReligion->m_Beliefs.GetMaxYieldPerFollower((YieldTypes)iYield, getOwner(), this);
				int iReligionYieldMaxFollowersPercent = pReligion->m_Beliefs.GetMaxYieldPerFollowerPercent((YieldTypes)iYield, getOwner(), this);
				if (iReligionYieldMaxFollowersPercent > 0)
				{
					int iVal = iFollowers * iReligionYieldMaxFollowersPercent;
					if (iVal > 0)
					{
						iVal /= 100;

						if (iVal <= 0)
							iVal = 1;

						int iTempMod = min(iVal, iReligionYieldMaxFollowers);
						iReligionYieldChange += iTempMod;
					}
				}
				else
				{
					if (iReligionYieldMaxFollowers > 0)
					{
						int iTempMod = min(iFollowers, iReligionYieldMaxFollowers);
						iReligionYieldChange += iTempMod;
					}
				}

				if (isCapital()) 
				{
					iReligionYieldChange += pReligion->m_Beliefs.GetCapitalYieldChange(getPopulation(), (YieldTypes)iYield, getOwner(), this);
				}
				if (isCoastal()) 
				{
					iReligionYieldChange += pReligion->m_Beliefs.GetCoastalCityYieldChange(getPopulation(), (YieldTypes)iYield, getOwner(), this);
				}

				BeliefTypes eSecondaryPantheon = GetCityReligions()->GetSecondaryReligionPantheonBelief();
				if (eSecondaryPantheon != NO_BELIEF && getPopulation() >= GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetMinPopulation())
				{
					iReligionYieldChange += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetCityYieldChange((YieldTypes)iYield);

					if ((getPopulation() > 0) && (GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetYieldPerPop((YieldTypes)iYield) > 0))
					{
						int iFaithPerPop = (getPopulation() / GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetYieldPerPop((YieldTypes)iYield));
						if (iFaithPerPop != 0)
						{
							iReligionYieldChange += iFaithPerPop;
						}
					}

					if (isCapital()) 
					{
						iReligionYieldChange += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetCapitalYieldChange((YieldTypes)iYield);
					}
					if (isCoastal()) 
					{
						iReligionYieldChange += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetCoastalCityYieldChange((YieldTypes)iYield);
					}
				}

				ChangeBaseYieldRateFromReligion((YieldTypes)iYield, iReligionYieldChange);

				if (IsRouteToCapitalConnected())
				{
					int iReligionChange = pReligion->m_Beliefs.GetYieldChangeTradeRoute((YieldTypes)iYield, getOwner(), this);
					//BeliefTypes eSecondaryPantheon = GetCityReligions()->GetSecondaryReligionPantheonBelief();
					if (eSecondaryPantheon != NO_BELIEF)
					{
						iReligionChange += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetYieldChangeTradeRoute((YieldTypes)iYield);
					}

					ChangeBaseYieldRateFromReligion((YieldTypes)iYield, iReligionChange);
				}

				if (GetCityCitizens()->GetTotalSpecialistCount() > 0)
				{
					ChangeBaseYieldRateFromReligion((YieldTypes)iYield, pReligion->m_Beliefs.GetYieldChangeAnySpecialist((YieldTypes)iYield, getOwner(), this));
				}

				const std::vector<BuildingTypes>& allBuildings = GetCityBuildings()->GetAllBuildingsHere();
				for (size_t iI = 0; iI < allBuildings.size(); iI++)
				{
					CvBuildingEntry* pkBuilding = GC.getBuildingInfo(allBuildings[iI]);
					if (pkBuilding)
					{
						BuildingClassTypes eBuildingClass = pkBuilding->GetBuildingClassType();
						int iYieldFromBuilding = pReligion->m_Beliefs.GetBuildingClassYieldChange(eBuildingClass, (YieldTypes)iYield, iFollowers, getOwner(), this);

						iYieldFromBuilding *= GetCityBuildings()->GetNumBuilding(allBuildings[iI]);

						if (isWorldWonderClass(*GC.getBuildingClassInfo(eBuildingClass)))
						{
							iYieldFromBuilding += pReligion->m_Beliefs.GetYieldChangeWorldWonder((YieldTypes)iYield, getOwner(), this);
						}

						//New majority, not a pantheon
						if (eNewMajority > RELIGION_PANTHEON)
						{
							//Our new majority matches our state religion, so let's add in our new yields.
							if (GET_PLAYER(getOwner()).GetReligions()->GetStateReligion() == eNewMajority)
							{
								iYieldFromBuilding += getReligionBuildingYieldRateModifier(eBuildingClass, (YieldTypes)iYield);
							}
						}

						ChangeBaseYieldRateFromReligion((YieldTypes)iYield, iYieldFromBuilding);
					}
				}
			}
		}

		// Mod for civs keeping their pantheon belief forever
		if (MOD_RELIGION_PERMANENT_PANTHEON)
		{
			if (GC.getGame().GetGameReligions()->HasCreatedPantheon(getOwner()))
			{
				const CvReligion* pPantheon = GC.getGame().GetGameReligions()->GetReligion(RELIGION_PANTHEON, getOwner());
				BeliefTypes ePantheonBelief = GC.getGame().GetGameReligions()->GetBeliefInPantheon(getOwner());
				BeliefTypes eSecondaryPantheon = GetCityReligions()->GetSecondaryReligionPantheonBelief();
				if (pPantheon != NULL && ePantheonBelief != NO_BELIEF && ePantheonBelief != eSecondaryPantheon)
				{
					const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eNewMajority, getOwner());
					if (pReligion == NULL || (pReligion != NULL && !pReligion->m_Beliefs.IsPantheonBeliefInReligion(ePantheonBelief, eNewMajority, getOwner()))) // check that the our religion does not have our belief, to prevent double counting
					{
						int iReligionYieldChange = GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetCityYieldChange((YieldTypes)iYield);

						if ((getPopulation() > 0) && (GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetYieldPerPop((YieldTypes)iYield) > 0))
						{
							int iFaithPerPop = (getPopulation() / GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetYieldPerPop((YieldTypes)iYield));
							if (iFaithPerPop != 0)
							{
								iReligionYieldChange += iFaithPerPop;
							}
						}

						if (isCapital()) 
						{
							iReligionYieldChange += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetCapitalYieldChange((YieldTypes)iYield);
						}
						if (isCoastal()) 
						{
							iReligionYieldChange += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetCoastalCityYieldChange((YieldTypes)iYield);
						}

						iReligionYieldChange += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetYieldChangeTradeRoute((YieldTypes)iYield);
						ChangeBaseYieldRateFromReligion((YieldTypes)iYield, iReligionYieldChange);

						const std::vector<BuildingTypes>& allBuildings = GetCityBuildings()->GetAllBuildingsHere();
						for (size_t iI = 0; iI < allBuildings.size(); iI++)
						{
							CvBuildingEntry* pkBuilding = GC.getBuildingInfo(allBuildings[iI]);
							if (pkBuilding)
							{
								BuildingClassTypes eBuildingClass = pkBuilding->GetBuildingClassType();
								int iYieldFromBuilding = GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetBuildingClassYieldChange((int)eBuildingClass, iYield);

								iYieldFromBuilding *= GetCityBuildings()->GetNumBuilding(allBuildings[iI]);

								if (isWorldWonderClass(*GC.getBuildingClassInfo(eBuildingClass)))
								{
									iYieldFromBuilding += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetYieldChangeWorldWonder(iYield);
								}

								ChangeBaseYieldRateFromReligion((YieldTypes)iYield, iYieldFromBuilding);
							}
						}
					}
				}
			}
		}
	}

	//Some yield cleanup and refresh here - note that not all of this has to do with religion, however any time religion is updated, that's a good time to update the city's yields.
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes)iI;
		if (eYield == NO_YIELD)
			continue;

		UpdateSpecialReligionYields(eYield);
		UpdateCityYields(eYield);

		//Also mountains, because they aren't called anywhere else!
		UpdateYieldPerXTerrainFromReligion(eYield);
		UpdateYieldPerXFeature(eYield);
		UpdateYieldPerXTerrain(eYield, TERRAIN_MOUNTAIN);
		UpdateYieldPerXFeature(eYield);
		updateExtraSpecialistYield(eYield);
	}

	if (MOD_RELIGION_EXTENSIONS && MOD_BALANCE_RETROACTIVE_PROMOS)
	{
		PlayerTypes eCityOwner = getOwner();
		if (eNewMajority != NO_RELIGION)
		{
			const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eNewMajority, eCityOwner);
			if (pReligion)
			{
				std::vector<int> aFreePromotions = pReligion->m_Beliefs.GetFreePromotions(eCityOwner, this, false);
				if (aFreePromotions.size() > 0)
				{
					for (std::vector<int>::iterator it = aFreePromotions.begin(); it != aFreePromotions.end(); ++it)
					{
						PromotionTypes ePromotion = (PromotionTypes)*it;
						SetRetroactivePromotion(ePromotion);
					}
				}
			}
		}
	}

	GET_PLAYER(getOwner()).UpdateReligion();
	UpdateHappinessFromReligion();
}
#if defined(MOD_BALANCE_CORE)
bool CvCity::HasPaidAdoptionBonus(ReligionTypes eReligion) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eReligion >= 0, "eReligion expected to be >= 0");
	ASSERT_DEBUG(eReligion < GC.getNumReligionInfos(), "eReligion expected to be < getNumReligionInfos");
	return m_abPaidAdoptionBonus[eReligion];
}
void CvCity::SetPaidAdoptionBonus(ReligionTypes eReligion, bool bNewValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eReligion >= 0, "eReligion expected to be >= 0");
	ASSERT_DEBUG(eReligion < GC.getNumReligionInfos(), "eReligion expected to be < getNumReligionInfos");
	m_abPaidAdoptionBonus[eReligion] = bNewValue;
}

int CvCity::GetReligiousPressureModifier(ReligionTypes eReligion) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eReligion >= 0, "eReligion expected to be >= 0");
	ASSERT_DEBUG(eReligion < GC.getNumReligionInfos(), "eReligion expected to be < getNumReligionInfos");
	return m_aiReligiousPressureModifier[eReligion];
}
void CvCity::SetReligiousPressureModifier(ReligionTypes eReligion, int iNewValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eReligion >= 0, "eReligion expected to be >= 0");
	ASSERT_DEBUG(eReligion < GC.getNumReligionInfos(), "eReligion expected to be < getNumReligionInfos");
	m_aiReligiousPressureModifier[eReligion] = iNewValue;
}
void CvCity::ChangeReligiousPressureModifier(ReligionTypes eReligion, int iNewValue)
{
	SetReligiousPressureModifier(eReligion, (GetReligiousPressureModifier(eReligion) + iNewValue));
}
#endif
//	--------------------------------------------------------------------------------
/// Culture from eSpecialist
int CvCity::GetCultureFromSpecialist(SpecialistTypes eSpecialist) const
{
	CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
	if (pkSpecialistInfo == NULL)
	{
		//This function REQUIRES a valid specialist type.
		return 0;
	}

	int iCulture = pkSpecialistInfo->getCulturePerTurn() + GET_PLAYER(getOwner()).GetSpecialistCultureChange();
	return iCulture;
}

//	--------------------------------------------------------------------------------
const CvHandicapInfo& CvCity::getHandicapInfo() const
{
	return GET_PLAYER(getOwner()).getHandicapInfo();
}

//	--------------------------------------------------------------------------------
HandicapTypes CvCity::getHandicapType() const
{
	VALIDATE_OBJECT();
	return GET_PLAYER(getOwner()).getHandicapType();
}

//	--------------------------------------------------------------------------------
const CvCivilizationInfo& CvCity::getCivilizationInfo() const
{
	return GET_PLAYER(getOwner()).getCivilizationInfo();
}

//	--------------------------------------------------------------------------------
CivilizationTypes CvCity::getCivilizationType() const
{
	VALIDATE_OBJECT();
	return GET_PLAYER(getOwner()).getCivilizationType();
}


//	--------------------------------------------------------------------------------
LeaderHeadTypes CvCity::getPersonalityType() const
{
	VALIDATE_OBJECT();
	return GET_PLAYER(getOwner()).getPersonalityType();
}


//	--------------------------------------------------------------------------------
ArtStyleTypes CvCity::getArtStyleType() const
{
	VALIDATE_OBJECT();
	return GET_PLAYER(getOwner()).getArtStyleType();
}


//	--------------------------------------------------------------------------------
CitySizeTypes CvCity::getCitySizeType() const
{
	VALIDATE_OBJECT();
	return ((CitySizeTypes)(range((getPopulation() / 7), 0, (NUM_CITYSIZE_TYPES - 1))));
}


//	--------------------------------------------------------------------------------
bool CvCity::isBarbarian() const
{
	VALIDATE_OBJECT();
	return GET_PLAYER(getOwner()).isBarbarian();
}


//	--------------------------------------------------------------------------------
bool CvCity::isHuman() const
{
	VALIDATE_OBJECT();
	return GET_PLAYER(getOwner()).isHuman();
}

//	Automated City Production
bool CvCity::isHumanAutomated() const
{
	VALIDATE_OBJECT();
	return GET_PLAYER(getOwner()).isHuman() && isProductionAutomated() && !IsPuppet();
}

//	--------------------------------------------------------------------------------
bool CvCity::isVisible(TeamTypes eTeam, bool bDebug) const
{
	VALIDATE_OBJECT();
	return plot()->isVisible(eTeam, bDebug);
}


//	--------------------------------------------------------------------------------
bool CvCity::isCapital() const
{
	VALIDATE_OBJECT();
	return (GET_PLAYER(getOwner()).getCapitalCityID() == GetID());
}

//	--------------------------------------------------------------------------------
/// Was this city originally any player's capital?
bool CvCity::IsOriginalCapital() const
{
	VALIDATE_OBJECT();
	if (m_eOriginalOwner == NO_PLAYER || m_eOriginalOwner == BARBARIAN_PLAYER)
		return false;

	CvPlayerAI& kPlayer = GET_PLAYER(m_eOriginalOwner);
	return getX() == kPlayer.GetOriginalCapitalX() && getY() == kPlayer.GetOriginalCapitalY();
}

//	--------------------------------------------------------------------------------
/// Was this city originally a major civ's capital?
bool CvCity::IsOriginalMajorCapital() const
{
	VALIDATE_OBJECT();
	return IsOriginalCapital() && GET_PLAYER(m_eOriginalOwner).isMajorCiv();
}

//	--------------------------------------------------------------------------------
/// Was this city originally a major civ's capital?
bool CvCity::IsOriginalMinorCapital() const
{
	VALIDATE_OBJECT();
	return IsOriginalCapital() && GET_PLAYER(m_eOriginalOwner).isMinorCiv();
}

//	--------------------------------------------------------------------------------
/// Was this city a player's original capital?
bool CvCity::IsOriginalCapitalForPlayer(PlayerTypes ePlayer) const
{
	VALIDATE_OBJECT();
	return IsOriginalCapital() && ePlayer == m_eOriginalOwner;
}

//	--------------------------------------------------------------------------------
/// Who owns this city for the purposes of a Domination Victory?
/// Note: This function assumes the city is an original major capital.
PlayerTypes CvCity::GetOwnerForDominationVictory() const
{
	PlayerTypes eCapitalOwner = getOwner();
	TeamTypes eOwnerTeam = getTeam();

	// A City-State's ally controls their capital.
	if (GET_PLAYER(eCapitalOwner).isMinorCiv())
	{
		PlayerTypes eAlly = GET_PLAYER(eCapitalOwner).GetMinorCivAI()->GetAlly();
		if (eAlly != NO_PLAYER)
		{
			// However, if the ally is a vassal, then their master controls the City-State's capital.
			if (GET_TEAM(GET_PLAYER(eAlly).getTeam()).IsVassalOfSomeone())
			{
				TeamTypes eMasterTeam = GET_TEAM(GET_PLAYER(eAlly).getTeam()).GetMaster();
				if (GET_TEAM(eMasterTeam).getLeaderID() != NO_PLAYER)
					return GET_TEAM(eMasterTeam).getLeaderID();
			}
			else
				return eAlly;
		}
	}
	// If a vassal owns a capital, their master controls it.
	else if (GET_TEAM(eOwnerTeam).IsVassalOfSomeone())
	{
		TeamTypes eMasterTeam = GET_TEAM(eOwnerTeam).GetMaster();
		if (GET_TEAM(eMasterTeam).getLeaderID() != NO_PLAYER)
			return GET_TEAM(eMasterTeam).getLeaderID();
	}

	// Otherwise, the owner controls the capital.
	return eCapitalOwner;
}

//	--------------------------------------------------------------------------------
bool CvCity::isCoastal(int iMinWaterSize) const
{
	VALIDATE_OBJECT();
	return plot()->isCoastalLand(iMinWaterSize);
}

//	--------------------------------------------------------------------------------
bool CvCity::isAddsFreshWater() const 
{
	VALIDATE_OBJECT();

	//ideally this should be cached and changed when a building is added/removed ...
	const std::vector<BuildingTypes>& vBuildings = GetCityBuildings()->GetAllBuildingsHere();
	for (size_t iBuilding = 0; iBuilding < vBuildings.size(); iBuilding++)
	{
		CvBuildingEntry* pInfo = GC.getBuildingInfo(vBuildings[iBuilding]);
		if (pInfo && pInfo->IsAddsFreshWater())
			return true;
	}

	return false;
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvCity::GetUnitPurchaseCooldown(bool bCivilian) const
{
	VALIDATE_OBJECT();
	if (bCivilian)
		return m_iUnitPurchaseCooldownCivilian;

	return m_iUnitPurchaseCooldown;
}
//	--------------------------------------------------------------------------------
void CvCity::SetUnitPurchaseCooldown(bool bCivilian, int iValue)
{
	VALIDATE_OBJECT();
	if (bCivilian)
		m_iUnitPurchaseCooldownCivilian = iValue;
	else
		m_iUnitPurchaseCooldown = iValue;
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeUnitPurchaseCooldown(bool bCivilian, int iValue)
{
	VALIDATE_OBJECT();
	if (iValue != 0)
	{
		if (bCivilian)
			m_iUnitPurchaseCooldownCivilian += iValue;
		else
			m_iUnitPurchaseCooldown += iValue;
	}
}
//	--------------------------------------------------------------------------------
int CvCity::GetUnitPurchaseCooldownMod(bool bCivilian) const
{
	VALIDATE_OBJECT();
		if (bCivilian)
			return m_iUnitPurchaseCooldownCivilianMod;

	return m_iUnitPurchaseCooldownMod;
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeUnitPurchaseCooldownMod(bool bCivilian, int iValue)
{
	VALIDATE_OBJECT();
	if (bCivilian)
		m_iUnitPurchaseCooldownCivilianMod += iValue;
	else
		m_iUnitPurchaseCooldownMod += iValue;
}
//	--------------------------------------------------------------------------------
int CvCity::GetUnitFaithPurchaseCooldown(bool bCivilian) const
{
	VALIDATE_OBJECT();
	if (bCivilian)
		return m_iUnitFaithPurchaseCooldownCivilian;

	return m_iUnitFaithPurchaseCooldown;
}
//	--------------------------------------------------------------------------------
void CvCity::SetUnitFaithPurchaseCooldown(bool bCivilian, int iValue)
{
	VALIDATE_OBJECT();
	if (bCivilian)
		m_iUnitFaithPurchaseCooldownCivilian = iValue;
	else
		m_iUnitFaithPurchaseCooldown = iValue;
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeUnitFaithPurchaseCooldown(bool bCivilian, int iValue)
{
	VALIDATE_OBJECT();
	if (iValue != 0)
	{
		if (bCivilian)
			m_iUnitFaithPurchaseCooldownCivilian += iValue;
		else
			m_iUnitFaithPurchaseCooldown += iValue;
	}
}
//	--------------------------------------------------------------------------------
int CvCity::GetBuildingPurchaseCooldown() const
{
	VALIDATE_OBJECT();
	return m_iBuildingPurchaseCooldown;
}
//	--------------------------------------------------------------------------------
void CvCity::SetBuildingPurchaseCooldown(int iValue)
{
	VALIDATE_OBJECT();
	m_iBuildingPurchaseCooldown = iValue;
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeBuildingPurchaseCooldown(int iValue)
{
	VALIDATE_OBJECT();
	if (iValue != 0)
	{
		m_iBuildingPurchaseCooldown += iValue;
	}
}
void CvCity::DoSellBuilding()
{
	// Only sell buildings if we're razing
	if (!IsRazing())
		return;

	// Can't sell anything?
	if (IsResistance() || GetCityBuildings()->IsSoldBuildingThisTurn() || GET_PLAYER(getOwner()).GetPlayerTraits()->IsNoAnnexing())
		return;

	int iBestRefund = 0;
	BuildingTypes eBestBuilding = NO_BUILDING;
	for (int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

		if (pkBuildingInfo)
		{
			// Has this Building
			if (GetCityBuildings()->GetNumBuilding(eBuilding) > 0 && GetCityBuildings()->IsBuildingSellable(*pkBuildingInfo))
			{
				int iRefund = GetCityBuildings()->GetSellBuildingRefund(eBuilding);
				if (iRefund > iBestRefund)
				{
					iBestRefund = iRefund;
					eBestBuilding = eBuilding;
				}
			}
		}
	}
	if (eBestBuilding != NO_BUILDING)
	{
		GetCityBuildings()->DoSellBuilding(eBestBuilding);
		if (GC.getLogging() && GC.getAILogging())
		{
			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBestBuilding);
			if (pkBuildingInfo)
			{
				CvString strLogString;
				strLogString.Format("MOD - Selling building in a razed city: %s in %s. Gold Recovered: %d",
					pkBuildingInfo->GetDescription(), getName().c_str(), iBestRefund);

				GET_PLAYER(getOwner()).GetHomelandAI()->LogHomelandMessage(strLogString);
			}
		}
	}
}
void CvCity::SetTraded(PlayerTypes ePlayer, bool bValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(ePlayer >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(ePlayer < MAX_PLAYERS, "eIndex expected to be < MAX_PLAYERS");
	m_abTraded[ePlayer] = bValue;
}
bool CvCity::IsTraded(PlayerTypes ePlayer)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(ePlayer >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(ePlayer < MAX_PLAYERS, "eIndex expected to be < MAX_PLAYERS");
	return m_abTraded[ePlayer];
}

void CvCity::SetIgnoredForExpansionBickering(PlayerTypes ePlayer, bool bValue)
{
	VALIDATE_OBJECT();
	m_abIgnoredForExpansionBickering[ePlayer] = bValue;
}
bool CvCity::IsIgnoredForExpansionBickering(PlayerTypes ePlayer) const
{
	return m_abIgnoredForExpansionBickering[ePlayer];
}

void CvCity::CheckForOperationUnits()
{
	VALIDATE_OBJECT();
	UnitTypes eBestUnit;
	UnitAITypes eUnitAI;
	if (CityStrategyAIHelpers::IsTestCityStrategy_IsPuppetAndAnnexable(this) || IsRazing())
		return;

	if (GET_PLAYER(getOwner()).isMinorCiv() || isBarbarian())
		return;

	if (isHumanAutomated()) // absolutely no units in automated cities
		return;

	CvPlayerAI& kPlayer = GET_PLAYER(getOwner());

	//Don't if we're in debt.
	if (kPlayer.GetTreasury()->AverageIncome100(10) < 0)
	{
		return;
	}

	//Do we already have a military unit in the queue? If so, let's not flood the queue.
	bool bAlreadyUnderConstruction = false;
	const OrderData* pOrderNode = headOrderQueueNode();

	while (pOrderNode != NULL)
	{
		if (pOrderNode->eOrderType == ORDER_TRAIN)
		{
			bAlreadyUnderConstruction = true;
			break;
		}
		pOrderNode = nextOrderQueueNode(pOrderNode);
	}
	if (bAlreadyUnderConstruction)
	{
		return;
	}
	bool bAppend = true;
	if (kPlayer.GetMilitaryAI()->GetNumberCivsAtWarWith(false) > 0)
	{
		bAppend = false;
	}

	bool bCitySameAsMuster = false;
	OperationSlot thisOperationSlot = kPlayer.PeekAtNextUnitToBuildForOperationSlot(this, bCitySameAsMuster);
	if (thisOperationSlot.IsValid() && bCitySameAsMuster)
	{
		CvArmyAI* pThisArmy = kPlayer.getArmyAI(thisOperationSlot.m_iArmyID);

		if (pThisArmy)
		{
			CvFormationSlotEntry slotEntry = pThisArmy->GetSlotInfo(thisOperationSlot.m_iSlotID);
			int iTempWeight = 100;
			eUnitAI = slotEntry.m_primaryUnitType;
			eBestUnit = m_pCityStrategyAI->GetUnitProductionAI()->RecommendUnit(eUnitAI, true);
			if (eBestUnit == NO_UNIT)
			{
				eUnitAI = slotEntry.m_secondaryUnitType;
				eBestUnit = m_pCityStrategyAI->GetUnitProductionAI()->RecommendUnit(eUnitAI, true);
			}
			if (eBestUnit != NO_UNIT)
			{
				iTempWeight = GetCityStrategyAI()->GetUnitProductionAI()->CheckUnitBuildSanity(eBestUnit, true, iTempWeight, true);
				if (iTempWeight > 0)
				{
					int iGoldCost = GetPurchaseCost(eBestUnit);
					CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eBestUnit);
					if (pkUnitEntry && kPlayer.GetEconomicAI()->CanWithdrawMoneyForPurchase(PURCHASE_TYPE_UNIT, iGoldCost) && IsCanPurchase(/*bTestPurchaseCost*/ true, /*bTestTrainable*/ true, eBestUnit, NO_BUILDING, NO_PROJECT, YIELD_GOLD))
					{
						//Log it
						CvString strLogString;
						strLogString.Format("MOD - Buying unit for active operation from City root function: %s in %s. Cost: %d, Balance (before buy): %d",
							pkUnitEntry->GetDescription(), getName().c_str(), iGoldCost, GET_PLAYER(getOwner()).GetTreasury()->GetGold());
						GetCityStrategyAI()->LogHurryMessage(strLogString);

						bool bInvest = MOD_BALANCE_CORE_UNIT_INVESTMENTS || (MOD_BALANCE_VP && pkUnitEntry->GetSpaceshipProject() != NO_PROJECT);
						if (bInvest)
						{
							//take the money...
							kPlayer.GetTreasury()->ChangeGold(-iGoldCost);

							const UnitClassTypes eUnitClass = (UnitClassTypes)(pkUnitEntry->GetUnitClassType());
							if (eUnitClass != NO_UNITCLASS)
							{
								SetUnitInvestment(eUnitClass, true);
								if (CityStrategyAIHelpers::IsTestCityStrategy_IsPuppetAndAnnexable(this))
								{
									if (getProductionProcess() != NO_PROCESS)
									{
										clearOrderQueue();
									}
									pushOrder(ORDER_TRAIN, eBestUnit, -1, false, false, true, false);
								}
								else if (!GET_PLAYER(getOwner()).isHuman() && !IsPuppet())
								{
									if (getProductionProcess() != NO_PROCESS)
									{
										clearOrderQueue();
									}
									pushOrder(ORDER_TRAIN, eBestUnit, -1, false, false, true, false);
								}
							}
						}
						else
						{
							//and train it!
							CvUnit* pUnit = PurchaseUnit(eBestUnit, YIELD_GOLD);
							if (pUnit)
							{
								CleanUpQueue();

								kPlayer.GetMilitaryAI()->ResetNumberOfTimesOpsBuildSkippedOver();

								//bookkeeping
								if (m_unitBeingBuiltForOperation.IsValid())
								{
									kPlayer.CityFinishedBuildingUnitForOperationSlot(m_unitBeingBuiltForOperation, pUnit);
									m_unitBeingBuiltForOperation.Invalidate();
								}
								else
								{
									vector<pair<size_t, size_t>> freeSlotsPerOp;
									// Check existing armies this unit could fit into if it wasn't automatically added to one.
									for (size_t i = 0; i < GET_PLAYER(m_eOwner).getNumAIOperations(); i++)
									{
										CvAIOperation* pOp = GET_PLAYER(m_eOwner).getAIOperationByIndex(i);
										if (pOp->GetOperationState() == AI_OPERATION_STATE_RECRUITING_UNITS)
										{
											//only look at the first army ...
											CvArmyAI* pFirstArmy = pOp->GetArmy(0);
											if (pFirstArmy)
												freeSlotsPerOp.push_back(make_pair(pFirstArmy->GetOpenSlots(true).size(), i));
										}
									}
									//try the army which is closest to completion first!
									if (!freeSlotsPerOp.empty())
									{
										//default sort order is ascending by first pair member 
										std::stable_sort(freeSlotsPerOp.begin(), freeSlotsPerOp.end());
										for (size_t i = 0; i < freeSlotsPerOp.size(); i++)
											if (GET_PLAYER(m_eOwner).getAIOperationByIndex(freeSlotsPerOp[i].second)->RecruitUnit(pUnit))
												break;
									}
								}

								return;
							}
						}
					}
				}
				else
				{
					if (getProductionTurnsLeft(eBestUnit, 0) >= 7)
					{
						return;
					}

					iTempWeight = GetCityStrategyAI()->GetUnitProductionAI()->CheckUnitBuildSanity(eBestUnit, true, iTempWeight);
					if (iTempWeight > 0)
					{
						pushOrder(ORDER_TRAIN, eBestUnit, eUnitAI, false, false, bAppend, false /*bRush*/);
						if (!bAppend)
						{
							kPlayer.CityCommitToBuildUnitForOperationSlot(thisOperationSlot);
							m_unitBeingBuiltForOperation = thisOperationSlot;
							kPlayer.GetMilitaryAI()->ResetNumberOfTimesOpsBuildSkippedOver();
						}
						//Log it
						CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eBestUnit);
						if (pkUnitEntry)
						{
							if (GC.getLogging() && GC.getAILogging())
							{
								CvString strLogString;
								strLogString.Format("MOD - Building unit for active operation from City root function: %s in %s. Turns: %d",
									pkUnitEntry->GetDescription(), getName().c_str(), getProductionTurnsLeft(eBestUnit, 0));
								GetCityStrategyAI()->LogHurryMessage(strLogString);
							}
						}
						return;
					}
				}
			}
		}
	}
	eBestUnit = kPlayer.GetMilitaryAI()->GetUnitTypeForArmy(this);
	if (eBestUnit != NO_UNIT)
	{
		if (getProductionTurnsLeft(eBestUnit, 0) >= 10)
		{
			return;
		}
	}
	bool bTarget = false;
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (eLoopPlayer != NO_PLAYER && GET_PLAYER(eLoopPlayer).isAlive() && eLoopPlayer != getOwner())
		{
			if (kPlayer.GetDiplomacyAI()->IsWantsSneakAttack(eLoopPlayer))
			{
				bTarget = true;
				break;
			}
		}
	}
	if (bTarget)
	{
		if (eBestUnit != NO_UNIT)
		{
			int iGoldCost = GetPurchaseCost(eBestUnit);
			CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eBestUnit);
			if (pkUnitEntry && kPlayer.GetEconomicAI()->CanWithdrawMoneyForPurchase(PURCHASE_TYPE_UNIT, iGoldCost) && IsCanPurchase(/*bTestPurchaseCost*/ true, /*bTestTrainable*/ true, eBestUnit, NO_BUILDING, NO_PROJECT, YIELD_GOLD))
			{
				//Log it
				CvString strLogString;
				strLogString.Format("MOD - Buying unit for sneak attack from City root function: %s in %s. Cost: %d, Balance (before buy): %d",
					pkUnitEntry->GetDescription(), getName().c_str(), iGoldCost, GET_PLAYER(getOwner()).GetTreasury()->GetGold());
				kPlayer.GetHomelandAI()->LogHomelandMessage(strLogString);

				bool bInvest = MOD_BALANCE_CORE_UNIT_INVESTMENTS || (MOD_BALANCE_VP && pkUnitEntry->GetSpaceshipProject() != NO_PROJECT);
				if (bInvest)
				{
					//take the money...
					kPlayer.GetTreasury()->ChangeGold(-iGoldCost);

					const UnitClassTypes eUnitClass = (UnitClassTypes)(pkUnitEntry->GetUnitClassType());
					if (eUnitClass != NO_UNITCLASS)
					{
						SetUnitInvestment(eUnitClass, true);
						if (CityStrategyAIHelpers::IsTestCityStrategy_IsPuppetAndAnnexable(this))
						{
							if (getProductionProcess() != NO_PROCESS)
							{
								clearOrderQueue();
							}
							pushOrder(ORDER_TRAIN, eBestUnit, -1, false, false, true, false);
						}
						else if (!GET_PLAYER(getOwner()).isHuman() && !IsPuppet())
						{
							if (getProductionProcess() != NO_PROCESS)
							{
								clearOrderQueue();
							}
							pushOrder(ORDER_TRAIN, eBestUnit, -1, false, false, true, false);
						}
					}
				}
				else
				{
					//and train it!
					CvUnit* pUnit = PurchaseUnit(eBestUnit, YIELD_GOLD);
					if (pUnit)
					{
						CleanUpQueue();

						kPlayer.GetMilitaryAI()->ResetNumberOfTimesOpsBuildSkippedOver();
					}
				}
				return;
			}
			else
			{
				CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eBestUnit);
				if (pkUnitEntry)
				{
					UnitAITypes eUnitAI = pkUnitEntry->GetDefaultUnitAIType();
					pushOrder(ORDER_TRAIN, eBestUnit, eUnitAI, false, false, bAppend, false /*bRush*/);
					if (GC.getLogging() && GC.getAILogging())
					{
						CvString strLogString;
						strLogString.Format("MOD - Building unit for sneak attack (or at war) from City root function: %s in %s. Turns: %d",
							pkUnitEntry->GetDescription(), getName().c_str(), getProductionTurnsLeft(eBestUnit, 0));
						kPlayer.GetHomelandAI()->LogHomelandMessage(strLogString);
					}

					kPlayer.GetMilitaryAI()->ResetNumberOfTimesOpsBuildSkippedOver();
				}
				return;
			}
		}
	}
}
#endif

//	--------------------------------------------------------------------------------
//	Returns food consumed by a non-specialist citizen
int CvCity::foodConsumptionNonSpecialistTimes100() const
{
	VALIDATE_OBJECT();

	int iFoodPerPop = /*2*/ GD_INT_GET(FOOD_CONSUMPTION_PER_POPULATION) * 100;
	iFoodPerPop += GetAdditionalFood() * 100;
	iFoodPerPop += GET_PLAYER(getOwner()).GetPlayerTraits()->GetNonSpecialistFoodChange();
	iFoodPerPop = max(0, iFoodPerPop); //cannot reduce food per citizen to less than 0
	return iFoodPerPop;
}

//	--------------------------------------------------------------------------------
//	Returns food consumed by a specialist depending on Era and applicable modifiers
int CvCity::foodConsumptionSpecialistTimes100() const
{
	VALIDATE_OBJECT();
	int iFoodPerSpec = 0;
	if (MOD_BALANCE_YIELD_SCALE_ERA)
	{
		iFoodPerSpec = max((int)GET_PLAYER(getOwner()).GetCurrentEra(), /*2*/ GD_INT_GET(FOOD_CONSUMPTION_PER_POPULATION)) + 1;
		iFoodPerSpec = min(iFoodPerSpec, 10) * 100;
	}
	else
	{
		iFoodPerSpec = /*2*/ GD_INT_GET(FOOD_CONSUMPTION_PER_POPULATION) * 100;
	}

	iFoodPerSpec += GET_PLAYER(getOwner()).GetSpecialistFoodChange() * 100;

	// Specialists eat less food? (Policies, etc.)
	if (GET_PLAYER(getOwner()).isHalfSpecialistFood())
	{
		iFoodPerSpec /= 2;
	}
#if defined(MOD_BALANCE_CORE)
	if (GET_PLAYER(getOwner()).isHalfSpecialistFoodCapital() && isCapital())
	{
		iFoodPerSpec /= 2;
	}
#endif

	return max(100, iFoodPerSpec);
}

// --------------------------------------------------------------------------------
int CvCity::foodConsumption(bool bNoAngry, int iExtra) const
{
	return foodConsumptionTimes100(bNoAngry, iExtra * 100) / 100;
}
//	--------------------------------------------------------------------------------
int CvCity::foodConsumptionTimes100(bool /*bNoAngry*/, int iExtra, bool bAssumeNoReductionForNonSpecialists) const
{
	VALIDATE_OBJECT();

	int iSpecialists = GetCityCitizens()->GetTotalSpecialistCount();
	int iNonSpecialists = max(0, (getPopulation() - iSpecialists)) + iExtra;

	int iConsumptionNonSpecialists = foodConsumptionNonSpecialistTimes100() * iNonSpecialists;
	if (IsNoStarvationNonSpecialist() && !bAssumeNoReductionForNonSpecialists)
	{
		iConsumptionNonSpecialists = min(getYieldRateTimes100(YIELD_FOOD, false), iConsumptionNonSpecialists);
	}
	return max(100, iConsumptionNonSpecialists + foodConsumptionSpecialistTimes100() * iSpecialists);
}


//	--------------------------------------------------------------------------------
int CvCity::foodDifference(bool bJustCheckingStarve) const
{
	VALIDATE_OBJECT();
	return foodDifferenceTimes100(bJustCheckingStarve) / 100;
}


//	--------------------------------------------------------------------------------
int CvCity::foodDifferenceTimes100(bool bJustCheckingStarve, CvString* toolTipSink) const
{
	VALIDATE_OBJECT();
	int iDifference = getYieldRateTimes100(YIELD_FOOD, false) - foodConsumptionTimes100();

	//cannot grow during settler production, but can starve!
	//excess food will be converted to production via GetFoodProductionTimes100()
	if (isFoodProduction())
		iDifference = std::min(0, iDifference);

	//cannot starve if at size 1 and nothing stored
	if (getPopulation() == 1 && getFoodTimes100() == 0)
	{
		iDifference = std::max(0, iDifference);
	}

	if (bJustCheckingStarve) //important, otherwise we can get into endless recursion (happiness depends on food which depends on happiness!)
		return iDifference;

	// Growth Mods - Only apply if the City is growing (and not starving, otherwise it would actually have the OPPOSITE of the intended effect!)
	if (iDifference > 0)
	{
		iDifference *= (100 + getGrowthMods(toolTipSink));
		iDifference /= 100;
	}

	return iDifference;
}

int CvCity::getGrowthMods(CvString* toolTipSink, int iAssumedLocalHappinessChange) const
{
	int iTotalMod = 0;

	// Capital Mod for player. Used for Policies and such
	if (isCapital())
	{
		int iCapitalGrowthMod = GET_PLAYER(getOwner()).GetCapitalGrowthMod();
		if (iCapitalGrowthMod != 0)
		{
			iTotalMod += iCapitalGrowthMod;
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_CAPITAL", iCapitalGrowthMod);
		}
	}

	// City Mod for player. Used for Policies and such
	int iCityGrowthMod = GET_PLAYER(getOwner()).GetCityGrowthMod();
	if (iCityGrowthMod != 0)
	{
		iTotalMod += iCityGrowthMod;
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_PLAYER", iCityGrowthMod);
	}

	if (GET_PLAYER(getOwner()).isGoldenAge() && (GetGoldenAgeYieldMod(YIELD_FOOD) != 0))
	{
		int iBuildingMod = GetGoldenAgeYieldMod(YIELD_FOOD);
		iTotalMod += iBuildingMod;
		if (toolTipSink)
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_YIELD_GOLDEN_AGE_BUILDINGS", iBuildingMod);
	}
	if (GET_PLAYER(getOwner()).isGoldenAge() && GET_PLAYER(getOwner()).getGoldenAgeYieldMod(YIELD_FOOD) != 0)
	{
		int iPolicyMod = GET_PLAYER(getOwner()).getGoldenAgeYieldMod(YIELD_FOOD);
		iTotalMod += iPolicyMod;
		if (toolTipSink)
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_YIELD_GOLDEN_AGE_POLICIES", iPolicyMod);
	}
	if (GET_PLAYER(getOwner()).GetPlayerTraits()->GetGoldenAgeYieldModifier(YIELD_FOOD) != 0)
	{
		int iTraitMod = GET_PLAYER(getOwner()).GetPlayerTraits()->GetGoldenAgeYieldModifier(YIELD_FOOD);
		iTotalMod += iTraitMod;
		if (toolTipSink)
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_YIELD_GOLDEN_AGE_TRAITS", iTraitMod);
	}

	int iSupply = GET_PLAYER(getOwner()).GetNumUnitsOutOfSupply();
	if (MOD_BALANCE_VP && iSupply > 0)
	{
		int iSupplyMod = GET_PLAYER(getOwner()).GetUnitGrowthMaintenanceMod();
		iTotalMod += iSupplyMod;
		if (toolTipSink)
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_YIELD_OVER_SUPPLY", iSupplyMod);
	}

	int iGrowthEvent = GetGrowthFromEvent();
	iTotalMod += iGrowthEvent;
	if (iGrowthEvent != 0)
	{
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_EVENT", iGrowthEvent);
	}

	int iGrowthTourism = GetGrowthFromTourism();
	iTotalMod += iGrowthTourism;
	if (iGrowthTourism != 0)
	{
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_TOURISM", iGrowthTourism);
	}

	if (IsPuppet())
	{
		int iTempMod = GET_PLAYER(getOwner()).GetPuppetYieldPenaltyMod() + GET_PLAYER(getOwner()).GetPlayerTraits()->GetPuppetPenaltyReduction() + /*0*/ GD_INT_GET(PUPPET_GROWTH_MODIFIER);
		if (iTempMod > 0)
			iTempMod = 0;
		iTotalMod += iTempMod;
		if (iTempMod != 0)
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_PUPPET", iTempMod);
	}
	// Religion growth mod
	int iReligionGrowthMod = 0;
	ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
	if (eMajority != NO_RELIGION)
	{
		const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
		if (pReligion)
		{
			bool bAtPeace = GET_TEAM(getTeam()).getAtWarCount(false) == 0;
			iReligionGrowthMod = pReligion->m_Beliefs.GetCityGrowthModifier(bAtPeace, getOwner(), GET_PLAYER(getOwner()).getCity(GetID()));
			BeliefTypes eSecondaryPantheon = GetCityReligions()->GetSecondaryReligionPantheonBelief();

			if (GET_PLAYER(getOwner()).GetPlayerTraits()->IsPopulationBoostReligion() && eMajority == GET_PLAYER(getOwner()).GetReligions()->GetStateReligion(true))
			{
				int iFollowers = GetCityReligions()->GetNumFollowers(eMajority);
				iReligionGrowthMod += (iFollowers * /*0*/ GD_INT_GET(BALANCE_FOLLOWER_GROWTH_BONUS));
			}

			if (eSecondaryPantheon != NO_BELIEF)
			{
				iReligionGrowthMod += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetCityGrowthModifier();
			}
		}
	}

	// Mod for civs keeping their pantheon belief forever
	if (MOD_RELIGION_PERMANENT_PANTHEON)
	{
		if (GC.getGame().GetGameReligions()->HasCreatedPantheon(getOwner()))
		{
			const CvReligion* pPantheon = GC.getGame().GetGameReligions()->GetReligion(RELIGION_PANTHEON, getOwner());
			BeliefTypes ePantheonBelief = GC.getGame().GetGameReligions()->GetBeliefInPantheon(getOwner());
			if (pPantheon != NULL && ePantheonBelief != NO_BELIEF && ePantheonBelief != GetCityReligions()->GetSecondaryReligionPantheonBelief())
			{
				const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
				if (pReligion == NULL || (pReligion != NULL && !pReligion->m_Beliefs.IsPantheonBeliefInReligion(ePantheonBelief, pReligion->m_eReligion, getOwner()))) // check that the our religion does not have our belief, to prevent double counting
				{
					iReligionGrowthMod += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetCityGrowthModifier();
				}
			}
		}
	}

	iTotalMod += iReligionGrowthMod;
	GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_RELIGION", iReligionGrowthMod);

	if (MOD_BALANCE_VP)
	{
		int iHappiness = getHappinessDelta() + iAssumedLocalHappinessChange;

		if (iHappiness > 0)
			iHappiness *= /*2*/ GD_INT_GET(LOCAL_HAPPINESS_FOOD_MODIFIER);
		else
			iHappiness *= /*10*/ GD_INT_GET(LOCAL_UNHAPPINESS_FOOD_MODIFIER);

		if (GET_PLAYER(getOwner()).IsEmpireUnhappy())
		{
			if (iHappiness > 0)
				iHappiness = 0;

			iHappiness += GET_PLAYER(getOwner()).GetUnhappinessGrowthPenalty();
		}

		iHappiness = range(iHappiness, -100, 100);

		iTotalMod += iHappiness;

		if (iHappiness > 0)
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_HAPPY", iHappiness);
		else if (iHappiness < 0)
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_UNHAPPY", iHappiness);
	}
	else
	{
		// Cities stop growing when empire is very unhappy
		if (GET_PLAYER(getOwner()).IsEmpireVeryUnhappy())
		{
			int iMod = /*-100*/ GD_INT_GET(VERY_UNHAPPY_GROWTH_PENALTY);
			iTotalMod += iMod;
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_UNHAPPY", iMod);
		}
		// Cities grow slower if the player is over his Happiness Limit
		else if (GET_PLAYER(getOwner()).IsEmpireUnhappy())
		{
			int iMod = /*-75*/ GD_INT_GET(UNHAPPY_GROWTH_PENALTY);
			iTotalMod += iMod;
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_UNHAPPY", iMod);
		}
	}

	// WLTKD Growth Bonus
	if (GetWeLoveTheKingDayCounter() > 0)
	{
		int iMod = /*25*/ GD_INT_GET(WLTKD_GROWTH_MULTIPLIER) + GET_PLAYER(getOwner()).GetPlayerTraits()->GetGrowthBoon();
		iTotalMod += iMod;
		if (GET_PLAYER(getOwner()).GetPlayerTraits()->IsExpansionWLTKD())
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_WLTKD_UA", iMod);
		else
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_WLTKD", iMod);
	}

	//Resolution League Bonus	
	if (MOD_BALANCE_VP && GetBaseYieldRateFromLeague(YIELD_FOOD) > 0)
	{
		int iMod = GetBaseYieldRateFromLeague(YIELD_FOOD);
		iTotalMod += iMod;
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_LEAGUE", iMod);
	}

	return max(-100, iTotalMod);
}

//	--------------------------------------------------------------------------------
int CvCity::growthThreshold() const
{
	VALIDATE_OBJECT();
	return GET_PLAYER(getOwner()).getGrowthThreshold(getPopulation());
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvCity::GetNumFreeSpecialists()
{
	int iFreeSpecialists = 0;
	if (isCapital())
	{
		iFreeSpecialists += GET_PLAYER(getOwner()).GetNoUnhappfromXSpecialistsCapital();
	}
	//...elsewhere?	
	iFreeSpecialists += GET_PLAYER(getOwner()).GetNoUnhappfromXSpecialists() + GetNoUnhappfromXSpecialists();
	return iFreeSpecialists;
}
//	--------------------------------------------------------------------------------
int CvCity::GetUnhappinessFromCitySpecialists()
{
	float iUnhappiness = 0;
	float iUnhappinessFromThisCity;
	float iUnhappinessPerPop = /*1*/ (/*1*/ GD_INT_GET(UNHAPPINESS_PER_POPULATION) + GD_FLOAT_GET(UNHAPPINESS_PER_POPULATION_FLOAT)) * 100;
	int iPopulation = 0;

	bool bCityValid = false;

	bCityValid = false;

	// Assume city doesn't exist, and does NOT count
	if (IsIgnoreCityForHappiness())
		bCityValid = false;
	// Occupied Cities don't get counted here (see the next function)
	else if (!IsOccupied() || IsNoOccupiedUnhappiness())
		bCityValid = true;

	if (bCityValid)
	{
		iPopulation = GetCityCitizens()->GetTotalSpecialistCount();

		// No Unhappiness from Specialist Pop? (Policies, etc.)
		if (GET_PLAYER(getOwner()).isHalfSpecialistUnhappiness())
		{
			iPopulation++; // Round up
			iPopulation /= 2;
		}

		//Less unhappiness from specialists....
		if (MOD_BALANCE_VP)
		{
			iUnhappinessPerPop = (float)/*100*/ GD_INT_GET(UNHAPPINESS_PER_SPECIALIST);
			int iNoHappinessSpecialists = GetNumFreeSpecialists();
			//Can't give more free happiness than specialists.
			if (iNoHappinessSpecialists > iPopulation)
			{
				iNoHappinessSpecialists = iPopulation;
			}
			if (iNoHappinessSpecialists > 0)
			{
				iPopulation -= iNoHappinessSpecialists;
			}
		}

		iUnhappinessFromThisCity = iPopulation * iUnhappinessPerPop;

		if (MOD_BALANCE_VP)
		{
			iUnhappiness += iUnhappinessFromThisCity;
		}
		else
		{
			//Took these away as they were making specialists do weird things.
			if (isCapital() && GET_PLAYER(getOwner()).GetCapitalUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + GET_PLAYER(getOwner()).GetCapitalUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}

			if (GetLocalUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + GetLocalUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}

			iUnhappiness += iUnhappinessFromThisCity;
		}
	}

	if (!MOD_BALANCE_VP)
	{
		iUnhappiness *= (100 + GET_PLAYER(getOwner()).GetUnhappinessMod());
		iUnhappiness /= 100;

		iUnhappiness *= 100 + GET_PLAYER(getOwner()).GetPlayerTraits()->GetPopulationUnhappinessModifier();
		iUnhappiness /= 100;

		// Handicap mod
		iUnhappiness *= GET_PLAYER(getOwner()).isHuman() ? 100 + GET_PLAYER(getOwner()).getHandicapInfo().getPopulationUnhappinessMod() : 100 + GET_PLAYER(getOwner()).getHandicapInfo().getPopulationUnhappinessMod() + GC.getGame().getHandicapInfo().getAIPopulationUnhappinessMod();
		iUnhappiness /= 100;
	}

	return (int)iUnhappiness;
}
#endif

//	--------------------------------------------------------------------------------
int CvCity::productionLeft() const
{
	VALIDATE_OBJECT();
	return (getProductionNeeded() - getProduction());
}

//	--------------------------------------------------------------------------------
bool CvCity::hasActiveWorldWonder() const
{
	VALIDATE_OBJECT();
	CvTeam& kTeam = GET_TEAM(getTeam());

	for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);

		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
		if (pkBuildingInfo)
		{
			if (isWorldWonderClass(pkBuildingInfo->GetBuildingClassInfo()))
			{
				if (m_pCityBuildings->GetNumRealBuilding(eBuilding) > 0 && !(kTeam.isObsoleteBuilding(eBuilding)))
				{
					return true;
				}
			}
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
IDInfo CvCity::GetIDInfo() const
{
	VALIDATE_OBJECT();
	return IDInfo(getOwner(), GetID());
}


//	--------------------------------------------------------------------------------
void CvCity::SetID(int iID)
{
	VALIDATE_OBJECT();
	m_iID = iID;
}

//	--------------------------------------------------------------------------------
CvPlot* CvCity::plot() const
{
	if ((m_iX != INVALID_PLOT_COORD) && (m_iY != INVALID_PLOT_COORD))
		return GC.getMap().plotUnchecked(m_iX, m_iY);
	return NULL;
}

//	--------------------------------------------------------------------------------
bool CvCity::at(int iX, int iY) const
{
	VALIDATE_OBJECT();
	return ((getX() == iX) && (getY() == iY));
}


//	--------------------------------------------------------------------------------
bool CvCity::at(CvPlot* pPlot) const
{
	VALIDATE_OBJECT();
	return (plot() == pPlot);
}

//	--------------------------------------------------------------------------------
bool CvCity::HasAccessToArea(int iAreaID) const
{
	CvPlot* pPlot = plot();
	if (pPlot)
	{
		if (pPlot->getArea() == iAreaID)
			return true;
		else
		{
			std::vector<int> allAreas = pPlot->getAllAdjacentAreas();
			return std::find(allAreas.begin(), allAreas.end(), iAreaID) != allAreas.end();
		}
	}

	return false;
}

bool CvCity::HasSharedAreaWith(const CvCity * pOther, bool bAllowLand, bool bAllowWater) const
{
	if (!pOther)
		return false;

	//shortcut ...
	if (plot()->getArea() == pOther->plot()->getArea())
		return true;

	return plot()->hasSharedAdjacentArea(pOther->plot(),bAllowLand,bAllowWater);
}

//	--------------------------------------------------------------------------------
bool CvCity::HasAccessToLandmassOrOcean(int iLandmassID) const
{
	//"landmass id" doubles as "ocean id"!
	CvPlot* pPlot = plot();
	if (pPlot)
	{
		if (pPlot->getLandmass() == iLandmassID)
			return true;
		else
		{
			std::vector<int> allLandmasses = pPlot->getAllAdjacentLandmasses();
			return std::find(allLandmasses.begin(), allLandmasses.end(), iLandmassID) != allLandmasses.end();
		}
	}

	return false;
}

bool CvCity::HasSharedLandmassWith(const CvCity * pOther, bool bAllowLand, bool bAllowWater) const
{
	if (!pOther)
		return false;

	//shortcut ...
	if (plot()->getLandmass() == pOther->plot()->getLandmass())
		return true;

	return plot()->hasSharedAdjacentLandmass(pOther->plot(),bAllowLand,bAllowWater);
}

//	--------------------------------------------------------------------------------
// if called with an invalid unit as argument, the current garrison is removed but no new garrison created!
void CvCity::SetGarrison(CvUnit* pUnit)
{
	bool bPreviousGarrison = (m_hGarrison != -1);
	CvUnit* pOldGarrison = bPreviousGarrison ? GET_PLAYER(getOwner()).getUnit(m_hGarrison) : NULL;
	if (pOldGarrison)
	{
		if (pOldGarrison == pUnit)
			//nothing to do
			return;
		else
			//will be replaced
			pOldGarrison->SetGarrisonedCity(-1);
	}

	if (pUnit && pUnit->CanGarrison() && pUnit->getOwner() == getOwner())
	{
		m_hGarrison = pUnit->GetID();
		m_iLastTurnGarrisonAssigned = GC.getGame().getGameTurn();

		pUnit->SetGarrisonedCity(GetID());

		//no previous garrison. we might earn culture / happiness from this
		if (!bPreviousGarrison)
		{
			ChangeJONSCulturePerTurnFromPolicies(GET_PLAYER(getOwner()).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_CULTURE_FROM_GARRISON));

			if (pUnit != NULL && pUnit->GetReligiousPressureModifier() != 0)
			{
				ReligionTypes eReligion = GET_PLAYER(getOwner()).GetReligions()->GetOwnedReligion();
				if (eReligion != NO_RELIGION)
				{
					if (m_pCityReligions->IsReligionInCity())
					{
						ReligionTypes eMajority = m_pCityReligions->GetReligiousMajority();
						ReligionTypes eSecondary = m_pCityReligions->GetReligionByAccumulatedPressure(1);
						if (eMajority != NO_RELIGION && eMajority == eReligion)
						{
							ChangeReligiousPressureModifier(eReligion, pUnit->GetReligiousPressureModifier());
						}
						else if (eSecondary != NO_RELIGION && eSecondary == eReligion)
						{
							ChangeReligiousPressureModifier(eReligion, pUnit->GetReligiousPressureModifier());
						}
					}
				}
			}
		}
	}
	else
	{
		m_hGarrison = -1;

		//had a previous garrison. bonuses be gone
		if (bPreviousGarrison)
		{
			ChangeJONSCulturePerTurnFromPolicies(-(GET_PLAYER(getOwner()).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_CULTURE_FROM_GARRISON)));

			if (pOldGarrison != NULL && pOldGarrison->GetReligiousPressureModifier() != 0)
			{
				ReligionTypes eReligion = GET_PLAYER(getOwner()).GetReligions()->GetOwnedReligion();
				if (eReligion != NO_RELIGION)
				{
					if (m_pCityReligions->IsReligionInCity())
					{
						ReligionTypes eMajority = m_pCityReligions->GetReligiousMajority();
						ReligionTypes eSecondary = m_pCityReligions->GetReligionByAccumulatedPressure(1);
						if (eMajority != NO_RELIGION && eMajority == eReligion)
						{
							ChangeReligiousPressureModifier(eReligion, -pOldGarrison->GetReligiousPressureModifier());
						}
						else if (eSecondary != NO_RELIGION && eSecondary == eReligion)
						{
							ChangeReligiousPressureModifier(eReligion, -pOldGarrison->GetReligiousPressureModifier());
						}
					}
				}
			}
		}
	}

	// Update City Strength
	updateStrengthValue();

	GET_PLAYER(getOwner()).CalculateNetHappiness();
	updateNetHappiness();
}

bool CvCity::NeedsGarrison() const
{
	if (isUnderSiege())
		return true;

	CvPlayer& kPlayer = GET_PLAYER(getOwner());

	//this allows the player to use the garrison for settler escorts
	if (kPlayer.IsEarlyExpansionPhase())
		return false;

	return kPlayer.GetMilitaryAI()->IsExposedToEnemy(this, NO_PLAYER);
}

bool CvCity::HasGarrison() const
{
	if (m_hGarrison > -1 && GetGarrisonedUnit() == NULL)
	{
		CUSTOMLOG("Invalid garrison %d is set in %s!\n", m_hGarrison, getName().c_str());
		(const_cast<CvCity*>(this))->m_hGarrison = -1;
		return false;
	}

	return m_hGarrison > -1;
}

CvUnit* CvCity::GetGarrisonedUnit() const
{
	if (m_hGarrisonOverride != -1)
	{
		CvUnit* pGarrison = GET_PLAYER(getOwner()).getUnit(m_hGarrisonOverride);
		if (pGarrison)
			return pGarrison;
		else
			CUSTOMLOG("warning: invalid garrison override!\n");
	}

	if (m_hGarrison > -1)
		return GET_PLAYER(getOwner()).getUnit(m_hGarrison);

	return NULL;
}

void CvCity::OverrideGarrison(const CvUnit* pUnit) const
{
	if (pUnit && pUnit->getDomainType() == DOMAIN_LAND)
		m_hGarrisonOverride = pUnit->GetID();
	else
		m_hGarrisonOverride = -1;
}

//	--------------------------------------------------------------------------------
CvPlot* CvCity::getRallyPlot() const
{
	VALIDATE_OBJECT();
	if ((m_iRallyX != INVALID_PLOT_COORD) && (m_iRallyY != INVALID_PLOT_COORD))
	{
		return GC.getMap().plotUnchecked(m_iRallyX, m_iRallyY);
	}
	else
		return NULL;
}


//	--------------------------------------------------------------------------------
void CvCity::setRallyPlot(CvPlot* pPlot)
{
	VALIDATE_OBJECT();
	if (getRallyPlot() != pPlot)
	{
		if (pPlot != NULL)
		{
			m_iRallyX = pPlot->getX();
			m_iRallyY = pPlot->getY();
		}
		else
		{
			m_iRallyX = INVALID_PLOT_COORD;
			m_iRallyY = INVALID_PLOT_COORD;
		}

		if (isCitySelected())
		{
			DLLUI->setDirty(ColoredPlots_DIRTY_BIT, true);
		}
	}
}


//	--------------------------------------------------------------------------------
int CvCity::getGameTurnFounded() const
{
	VALIDATE_OBJECT();
	return m_iGameTurnFounded;
}


//	--------------------------------------------------------------------------------
void CvCity::setGameTurnFounded(int iNewValue)
{
	VALIDATE_OBJECT();
	if (m_iGameTurnFounded != iNewValue)
	{
		m_iGameTurnFounded = iNewValue;
		ASSERT_DEBUG(getGameTurnFounded() >= 0);
	}
}


//	--------------------------------------------------------------------------------
int CvCity::getGameTurnAcquired() const
{
	VALIDATE_OBJECT();
	return m_iGameTurnAcquired;
}


//	--------------------------------------------------------------------------------
void CvCity::setGameTurnAcquired(int iNewValue)
{
	VALIDATE_OBJECT();
	m_iGameTurnAcquired = iNewValue;
	ASSERT_DEBUG(getGameTurnAcquired() >= 0);
}


//	--------------------------------------------------------------------------------
int CvCity::getGameTurnLastExpanded() const
{
	VALIDATE_OBJECT();
	return m_iGameTurnLastExpanded;
}


//	--------------------------------------------------------------------------------
void CvCity::setGameTurnLastExpanded(int iNewValue)
{
	VALIDATE_OBJECT();
	if (m_iGameTurnLastExpanded != iNewValue)
	{
		m_iGameTurnLastExpanded = iNewValue;
		ASSERT_DEBUG(m_iGameTurnLastExpanded >= 0);
	}
}

#if defined(MOD_BALANCE_CORE)
int CvCity::GetAdditionalFood() const
{
	VALIDATE_OBJECT();
	return m_iAdditionalFood;
}
void CvCity::SetAdditionalFood(int iValue)
{
	VALIDATE_OBJECT();
	m_iAdditionalFood = iValue;
}
#endif
//	--------------------------------------------------------------------------------
int CvCity::getPopulation(bool bIncludeAutomatons /* = false */) const
{
	VALIDATE_OBJECT();
	return m_iPopulation + (bIncludeAutomatons ? getAutomatons() : 0);
}

//	---------------------------------------------------------------------------------
//	Be very careful with setting bReassignPop to false.  This assumes that the caller
//  is manually adjusting the worker assignments *and* handling the setting of
//  the CityCitizens unassigned worker value.
void CvCity::setPopulation(int iNewValue, bool bReassignPop /* = true */, bool bNoBonus)
{
	VALIDATE_OBJECT();
	//make sure this is valid
	iNewValue = max(0, iNewValue);

	int iOldPopulation = getPopulation();
	int iOldHighestPopulation = getHighestPopulation();
	int iPopChange = iNewValue - iOldPopulation;

	if (iOldPopulation != iNewValue)
	{
		// If we are reducing population, remove the workers first
		if (bReassignPop)
		{
			if (iPopChange < 0)
			{
				// Need to Remove Citizens
				for (int iNewPopLoop = -iPopChange; iNewPopLoop--;)
				{
					//first try and remove an non-forced plot, if that fails, we need to pick a forced plot
					if (!GetCityCitizens()->DoRemoveWorstCitizen(CvCity::YIELD_UPDATE_GLOBAL, false, NO_SPECIALIST))
						GetCityCitizens()->DoRemoveWorstCitizen(CvCity::YIELD_UPDATE_GLOBAL, true, NO_SPECIALIST);
				}

				// Fixup the unassigned workers
				int iUnassignedWorkers = GetCityCitizens()->GetNumUnassignedCitizens();
				ASSERT_DEBUG(iUnassignedWorkers >= -iPopChange);
				GetCityCitizens()->ChangeNumUnassignedCitizens(std::max(iPopChange, -iUnassignedWorkers));
			}
		}

		m_iPopulation = iNewValue;

		GET_PLAYER(getOwner()).invalidatePopulationRankCache();

		if (getPopulation() > getHighestPopulation())
		{
			setHighestPopulation(getPopulation());

			int iGameTurn = GC.getGame().getGameTurn() - getGameTurnFounded();
			if (!IsResistance() && iGameTurn > 0 && !bNoBonus)
			{
				// Two triggers: one era scaling and one not
				GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_BIRTH, true, NO_GREATPERSON, NO_BUILDING, iPopChange, false, NO_PLAYER, NULL, false, this);
				GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_BIRTH, true, NO_GREATPERSON, NO_BUILDING, iPopChange, true, NO_PLAYER, NULL, false, this);
				
				// GPPOnCitizenBirth: instant GPP for the great person with the most points
				if (GetGPPOnCitizenBirth() > 0)
				{
					GreatPersonTypes eBestGreatPerson = NO_GREATPERSON;
					int iCurrentPointsOfBestGreatPerson = -1;
					for (int iGreatPersonTypes = 0; iGreatPersonTypes < GC.getNumGreatPersonInfos(); iGreatPersonTypes++)
					{
						GreatPersonTypes eGreatPerson = (GreatPersonTypes)iGreatPersonTypes;
						if (eGreatPerson == NO_GREATPERSON)
							continue;

						SpecialistTypes eSpecialist = (SpecialistTypes)GC.getGreatPersonInfo(eGreatPerson)->GetSpecialistType();
						if (eSpecialist == NO_SPECIALIST)
							continue;

						if (GetCityCitizens()->GetSpecialistGreatPersonProgressTimes100(eSpecialist) > iCurrentPointsOfBestGreatPerson)
						{
							iCurrentPointsOfBestGreatPerson = GetCityCitizens()->GetSpecialistGreatPersonProgressTimes100(eSpecialist);
							eBestGreatPerson = eGreatPerson;
						}
					}
					if (eBestGreatPerson != NO_GREATPERSON)
					{
						GET_PLAYER(getOwner()).doInstantGreatPersonProgress(INSTANT_YIELD_TYPE_BIRTH, false, this, NO_BUILDING, iPopChange, eBestGreatPerson);
					}
				}

				ReligionTypes eOwnerReligion = GET_PLAYER(getOwner()).GetReligions()->GetOwnedReligion();
				if (eOwnerReligion != NO_RELIGION && GetCityReligions()->IsHolyCityForReligion(eOwnerReligion))
				{
					GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_BIRTH_HOLY_CITY, false, NO_GREATPERSON, NO_BUILDING, iPopChange, false, NO_PLAYER, NULL, false, this);
				}
			}

			if (MOD_BALANCE_CORE_POLICIES && GET_PLAYER(getOwner()).GetXPopulationConscription() > 0 && !IsRazing())
			{
				int iRemainder = (getPopulation() % GET_PLAYER(getOwner()).GetXPopulationConscription());
				int iPopThreshold = getPopulation() - iRemainder;

				// Account for population jumps
				if (iRemainder < iPopChange && iPopThreshold > iOldHighestPopulation)
				{
					GET_PLAYER(getOwner()).DoXPopulationConscription(this);
				}
			}
		}

		plot()->area()->changePopulationPerPlayer(getOwner(), (getPopulation() - iOldPopulation));

#if defined(MOD_BALANCE_CORE)
		//we track population on the coast of water areas as well
		std::vector<int> areas = plot()->getAllAdjacentAreas();
		for (std::vector<int>::iterator it = areas.begin(); it != areas.end(); ++it)
		{
			CvArea* pkArea = GC.getMap().getAreaById(*it);
			if (pkArea->isWater())
				pkArea->changePopulationPerPlayer(getOwner(), (getPopulation() - iOldPopulation));
		}
#endif

		int iGlobalPopChange = getPopulation() - iOldPopulation;
		GET_PLAYER(getOwner()).changeTotalPopulation(iGlobalPopChange);
		GET_TEAM(getTeam()).changeTotalPopulation(iGlobalPopChange);
		GC.getGame().changeTotalPopulation(iGlobalPopChange);

		int iNewTotal = GET_PLAYER(getOwner()).getTotalPopulation();
		if (iNewTotal > GET_PLAYER(getOwner()).getHighestPopulation())
			GET_PLAYER(getOwner()).setHighestPopulation(iNewTotal);

		plot()->updateYield();

		UpdateReligion(GetCityReligions()->GetReligiousMajority());

		ChangeBaseYieldRateFromMisc(YIELD_SCIENCE, (iNewValue - iOldPopulation) * /*1 in CP, 0 in VP*/ GD_INT_GET(SCIENCE_PER_POPULATION));

		if (iPopChange > 0)
		{
			// Give new Population something to do in the City
			if (bReassignPop)
			{
				GetCityCitizens()->ChangeNumUnassignedCitizens(iPopChange);

				// Need to Add Citizens
				for (int iNewPopLoop = 0; iNewPopLoop < iPopChange; iNewPopLoop++)
				{
					GetCityCitizens()->DoAddBestCitizenFromUnassigned(CvCity::YIELD_UPDATE_GLOBAL);
				}
			}
		}

		setLayoutDirty(true);
		{
			CvInterfacePtr<ICvCity1> pkDllCity(new CvDllCity(this));
			gDLL->GameplayCityPopulationChanged(pkDllCity.get(), iNewValue);
		}

		plot()->plotAction(PUF_makeInfoBarDirty);

		if ((getOwner() == GC.getGame().getActivePlayer()) && isCitySelected())
		{
			DLLUI->setDirty(SelectionButtons_DIRTY_BIT, true);
			DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
		}

		// Update Unit Maintenance for the player
		GET_PLAYER(getOwner()).UpdateUnitProductionMaintenanceMod();
		GET_PLAYER(getOwner()).CalculateNetHappiness();
		updateNetHappiness();

		//updateGenericBuildings();
		updateStrengthValue();

		DLLUI->setDirty(CityInfo_DIRTY_BIT, true);
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if (pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(getX());
		args->Push(getY());
		args->Push(iOldPopulation);
		args->Push(iNewValue);

		bool bResult = false;
		LuaSupport::CallHook(pkScriptSystem, "SetPopulation", args.get(), bResult);
	}
}

//	---------------------------------------------------------------------------------
//	Be very careful with setting bReassignPop to false.  This assumes that the caller
//  is manually adjusting the worker assignments *and* handling the setting of
//  the CityCitizens unassigned worker value.
void CvCity::changePopulation(int iChange, bool bReassignPop, bool bIgnoreStaticUpdate)
{
	VALIDATE_OBJECT();
	setPopulation(getPopulation() + iChange, bReassignPop);

	// When the population changes (for most reasons), fetch the current global yield medians (for Needs Unhappiness) and cache them
	if (iChange != 0 && !bIgnoreStaticUpdate)
		UpdateCachedYieldMedians();

	// Update the religious system
	GetCityReligions()->DoPopulationChange(iChange);
}

void CvCity::setLowestRazingPop(int iValue)
{
	m_iLowestRazingPop = iValue;
}
#if defined(MOD_GLOBAL_CITY_AUTOMATON_WORKERS)
//	--------------------------------------------------------------------------------
int CvCity::getAutomatons() const
{
	VALIDATE_OBJECT();
	return m_iAutomatons;
}
//	---------------------------------------------------------------------------------
//	Be very careful with setting bReassignPop to false.  This assumes that the caller
//  is manually adjusting the worker assignments *and* handling the setting of
//  the CityCitizens unassigned worker value.
void CvCity::setAutomatons(int iNewValue, bool bReassignPop /* = true */)
{
	VALIDATE_OBJECT();
	int iChange = iNewValue - getAutomatons();
	if (iChange != 0) {
		if (bReassignPop && iChange < 0)
		{
			// If we are reducing automatons, remove the workers first
			for (int iNewPopLoop = -iChange; iNewPopLoop--;)
			{
				GetCityCitizens()->DoRemoveWorstCitizen(CvCity::YIELD_UPDATE_GLOBAL, false, NO_SPECIALIST);
			}
			// Fixup the unassigned workers
			int iUnassignedWorkers = GetCityCitizens()->GetNumUnassignedCitizens();
			ASSERT_DEBUG(iUnassignedWorkers >= -iChange);
			GetCityCitizens()->ChangeNumUnassignedCitizens(std::max(iChange, -iUnassignedWorkers));
		}
		m_iAutomatons = iNewValue;
		ASSERT_DEBUG(getAutomatons() >= 0);
		if (bReassignPop && iChange > 0) {
			// Give new automatons something to do in the City
			GetCityCitizens()->ChangeNumUnassignedCitizens(iChange);
			// Need to Add Citizens
			for (int iNewPopLoop = 0; iNewPopLoop < iChange; iNewPopLoop++)
			{
				GetCityCitizens()->DoAddBestCitizenFromUnassigned(CvCity::YIELD_UPDATE_GLOBAL);
			}
		}
		setLayoutDirty(true);
		plot()->plotAction(PUF_makeInfoBarDirty);
		if ((getOwner() == GC.getGame().getActivePlayer()) && isCitySelected())
		{
			DLLUI->setDirty(SelectionButtons_DIRTY_BIT, true);
			DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
		}
		DLLUI->setDirty(CityInfo_DIRTY_BIT, true);
	}
}
//	---------------------------------------------------------------------------------
void CvCity::changeAutomatons(int iChange, bool bReassignPop)
{
	VALIDATE_OBJECT();
	setAutomatons(getAutomatons() + iChange, bReassignPop);
}
#endif

//	--------------------------------------------------------------------------------
long CvCity::getRealPopulation() const
{
	VALIDATE_OBJECT();
	return (((long)(pow((double)getPopulation(), 2.8))) * 1000);
}

//	--------------------------------------------------------------------------------
int CvCity::getHighestPopulation() const
{
	VALIDATE_OBJECT();
	return m_iHighestPopulation;
}


//	--------------------------------------------------------------------------------
void CvCity::setHighestPopulation(int iNewValue)
{
	VALIDATE_OBJECT();
	m_iHighestPopulation = iNewValue;
	ASSERT_DEBUG(getHighestPopulation() >= 0);
}

//	--------------------------------------------------------------------------------
int CvCity::getBaseGreatPeopleRate() const
{
	VALIDATE_OBJECT();
	return m_iBaseGreatPeopleRate;
}


//	--------------------------------------------------------------------------------
int CvCity::getGreatPeopleRate() const
{
	VALIDATE_OBJECT();
	return ((getBaseGreatPeopleRate() * getTotalGreatPeopleRateModifier()) / 100);
}


//	--------------------------------------------------------------------------------
int CvCity::getTotalGreatPeopleRateModifier() const
{
	VALIDATE_OBJECT();
	int iModifier = getGreatPeopleRateModifier() + GET_PLAYER(getOwner()).getGreatPeopleRateModifier();

	if (GET_PLAYER(getOwner()).isGoldenAge())
	{
		iModifier += /*100*/ GD_INT_GET(GOLDEN_AGE_GREAT_PEOPLE_MODIFIER);
	}

	return std::max(0, (iModifier + 100));
}


//	--------------------------------------------------------------------------------
void CvCity::changeBaseGreatPeopleRate(int iChange)
{
	VALIDATE_OBJECT();
	m_iBaseGreatPeopleRate = (m_iBaseGreatPeopleRate + iChange);
	ASSERT_DEBUG(getBaseGreatPeopleRate() >= 0);
}


//	--------------------------------------------------------------------------------
int CvCity::getGreatPeopleRateModifier() const
{
	VALIDATE_OBJECT();
	int iValue = m_iGreatPeopleRateModifier;
	// todo: getGreatPropleRateModifier shouldn't do anything else but get the value of m_iGreatPeopleRateModifier, all the other calculations should be put into a different function

	int iNumMarried = GET_PLAYER(getOwner()).GetNumMarriedCityStatesNotAtWar();
	if (iNumMarried > 0)
	{
		iValue += (iNumMarried * getGPRateModifierPerMarriage());
		if (isCapital())
		{
			iValue += (iNumMarried * /*15*/ GD_INT_GET(BALANCE_GPP_RATE_IN_CAPITAL_PER_MARRIAGE));
		}
	}

	int iGPRateModifierPerLocalTheme = getGPRateModifierPerLocalTheme();
	if (iGPRateModifierPerLocalTheme > 0)
	{
		iValue += iGPRateModifierPerLocalTheme * GetCityBuildings()->GetTotalNumThemedBuildings();
	}

	// Corporations: Great people rate modifier by number of franchises
	int iGPRateCorp = GetGPRateModifierPerXFranchises();
	if (iGPRateCorp > 0)
	{
		iValue += iGPRateCorp;
	}

	// Improvements: Great people rate modifier by number of worked improvements
	int iGPRateImprovements = GetImprovementGreatPersonRateModifier();
	if (iGPRateImprovements > 0)
	{
		iValue += iGPRateImprovements;
	}

	return iValue;
}

//	--------------------------------------------------------------------------------
void CvCity::changeGreatPeopleRateModifier(int iChange)
{
	VALIDATE_OBJECT();
	m_iGreatPeopleRateModifier = (m_iGreatPeopleRateModifier + iChange);
}

int CvCity::GetImprovementGreatPersonRateModifier() const
{
	int iGPPRateFromImprovements = 0;

	const std::vector<int> aWorkedPlots = GetCityCitizens()->GetWorkedPlots();
	for (std::vector<int>::const_iterator it = aWorkedPlots.begin(); it != aWorkedPlots.end(); ++it)
	{
		CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(*it);
		if (!pPlot)
			continue;

		if (pPlot->IsImprovementPillaged())
			continue;

		ImprovementTypes eImprovement = pPlot->getImprovementType();
		if (eImprovement == NO_IMPROVEMENT)
			continue;

		CvImprovementEntry* pkImprovementInfo = GC.getImprovementInfo(eImprovement);
		int iGPPRateFromImprovement = pkImprovementInfo->GetGreatPersonRateModifier();
		if (iGPPRateFromImprovement != 0)
		{
			iGPPRateFromImprovements += iGPPRateFromImprovement;
		}
	}

	return iGPPRateFromImprovements;
}

int CvCity::GetReligionGreatPersonRateModifier(GreatPersonTypes eGreatPerson) const
{
	int iResult = 0;

	if (GET_PLAYER(getOwner()).getGoldenAgeTurns() > 0)
	{
		ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
		BeliefTypes eSecondaryPantheon = NO_BELIEF;
		if (eMajority != NO_RELIGION)
		{
			const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eMajority, getOwner());
			if (pReligion)
			{
				iResult += pReligion->m_Beliefs.GetGoldenAgeGreatPersonRateModifier(eGreatPerson, getOwner(), this);
				eSecondaryPantheon = GetCityReligions()->GetSecondaryReligionPantheonBelief();
				if (eSecondaryPantheon != NO_BELIEF)
				{
					iResult += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetGoldenAgeGreatPersonRateModifier(eGreatPerson);
				}
			}
		}

		// Mod for civs keeping their pantheon belief forever
		if (MOD_RELIGION_PERMANENT_PANTHEON)
		{
			if (GC.getGame().GetGameReligions()->HasCreatedPantheon(getOwner()))
			{
				const CvReligion* pPantheon = GC.getGame().GetGameReligions()->GetReligion(RELIGION_PANTHEON, getOwner());
				BeliefTypes ePantheonBelief = GC.getGame().GetGameReligions()->GetBeliefInPantheon(getOwner());
				if (pPantheon != NULL && ePantheonBelief != NO_BELIEF && ePantheonBelief != eSecondaryPantheon)
				{
					const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eMajority, getOwner());
					if (pReligion == NULL || (pReligion != NULL && !pReligion->m_Beliefs.IsPantheonBeliefInReligion(ePantheonBelief, eMajority, getOwner()))) // check that the our religion does not have our belief, to prevent double counting
					{
						iResult += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetGoldenAgeGreatPersonRateModifier(eGreatPerson);
					}
				}
			}
		}
	}

	return iResult;
}

//	--------------------------------------------------------------------------------
int CvCity::getGPRateModifierPerMarriage() const
{
	VALIDATE_OBJECT();
	return m_iGPRateModifierPerMarriage;
}

//	--------------------------------------------------------------------------------
void CvCity::changeGPRateModifierPerMarriage(int iChange)
{
	VALIDATE_OBJECT();
	m_iGPRateModifierPerMarriage = (m_iGPRateModifierPerMarriage + iChange);
}

//	--------------------------------------------------------------------------------
int CvCity::getGPRateModifierPerLocalTheme() const
{
	VALIDATE_OBJECT();
	return m_iGPRateModifierPerLocalTheme;
}

//	--------------------------------------------------------------------------------
void CvCity::changeGPRateModifierPerLocalTheme(int iChange)
{
	VALIDATE_OBJECT();
		m_iGPRateModifierPerLocalTheme = (m_iGPRateModifierPerLocalTheme + iChange);
}

//	--------------------------------------------------------------------------------
int CvCity::GetGPPOnCitizenBirth() const
{
	VALIDATE_OBJECT();
	return m_iGPPOnCitizenBirth;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeGPPOnCitizenBirth(int iChange)
{
	VALIDATE_OBJECT();
	m_iGPPOnCitizenBirth = (m_iGPPOnCitizenBirth + iChange);
}

//	--------------------------------------------------------------------------------
/// Amount of Culture in this City
int CvCity::GetJONSCultureStored() const
{
	VALIDATE_OBJECT();
	return m_iJONSCultureStored;
}

//	--------------------------------------------------------------------------------
/// Sets the amount of Culture in this City
void CvCity::SetJONSCultureStored(int iValue)
{
	VALIDATE_OBJECT();

	if (GetID() == g_iCityToTrace)
	{
		OutputDebugString(CvString::format("Turn %d, culture %d, delta %d\n", GC.getGame().getGameTurn(), m_iJONSCultureStored, iValue - m_iJONSCultureStored).c_str());
	}

	m_iJONSCultureStored = max(iValue, 0);
}

//	--------------------------------------------------------------------------------
/// Changes the amount of Culture in this City
void CvCity::ChangeJONSCultureStored(int iChange)
{
	VALIDATE_OBJECT();

	// Positive modifier to border growth rate?
	int iModifier = GetBorderGrowthRateIncreaseTotal();
	if (iChange > 0 && iModifier > 0)
	{
		iChange *= 100 + iModifier;
		iChange /= 100;
	}

	SetJONSCultureStored(GetJONSCultureStored() + iChange);
}


//	--------------------------------------------------------------------------------
/// Culture level of this City
int CvCity::GetJONSCultureLevel() const
{
	VALIDATE_OBJECT();
	return m_iJONSCultureLevel;
}

//	--------------------------------------------------------------------------------
/// Sets the Culture level of this City
void CvCity::SetJONSCultureLevel(int iValue)
{
	VALIDATE_OBJECT();
	m_iJONSCultureLevel = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes the Culture level of this City
void CvCity::ChangeJONSCultureLevel(int iChange)
{
	VALIDATE_OBJECT();
	SetJONSCultureLevel(GetJONSCultureLevel() + iChange);
}

//	--------------------------------------------------------------------------------
/// What happens when you have enough Culture to acquire a new Plot?
void CvCity::DoJONSCultureLevelIncrease()
{
	VALIDATE_OBJECT();
	int iOverflow = GetJONSCultureStored() - GetJONSCultureThreshold();
	bool bIsHumanControlled = (GET_PLAYER(getOwner()).isHuman() && !IsPuppet());
	bool bSendEvent = true;
	if (!(MOD_UI_CITY_EXPANSION && bIsHumanControlled)) {
		// We need to defer this for humans picking their own tiles
		SetJONSCultureStored(iOverflow);
		ChangeJONSCultureLevel(1);
	}

	CvPlot* pPlotToAcquire = GetNextBuyablePlot(false);

	// maybe the player owns ALL of the plots or there are none avaialable?
	if (pPlotToAcquire)
	{
		// For human players, let them decide which plot to acquire
		if (MOD_UI_CITY_EXPANSION && bIsHumanControlled)
		{
			// Yep CITY_PLOTS_RADIUS is a #define and not taken from the database - well done Firaxis!

			bool bCanAcquirePlot = plotDistance(getX(), getY(), pPlotToAcquire->getX(), pPlotToAcquire->getY()) <= getWorkPlotDistance();
			if (bCanAcquirePlot && GetBuyPlotCost(pPlotToAcquire->getX(), pPlotToAcquire->getY()) < 1) {
				// Within working/buying distance
				bSendEvent = false;

				CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
				if (pNotifications) {
					Localization::String localizedText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_CULTURE_ACQUIRED_NEW_PLOT");
					localizedText << getNameKey();
					Localization::String localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_CULTURE_ACQUIRED_NEW_PLOT");
					localizedSummary << getNameKey();
					pNotifications->Add(NOTIFICATION_CITY_TILE, localizedText.toUTF8(), localizedSummary.toUTF8(), getX(), getY(), GetID());
				}
			}
			else
			{
				// The cheapest plot we can have is outside our working/buying distance, so just acquire it
				DoAcquirePlot(pPlotToAcquire->getX(), pPlotToAcquire->getY());

				ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
				if (pkScriptSystem)
				{
					CvLuaArgsHandle args;
					args->Push(getOwner());
					args->Push(GetID());
					args->Push(pPlotToAcquire->getX());
					args->Push(pPlotToAcquire->getY());
					args->Push(false); // bGold
					args->Push(true); // bFaith/bCulture

					bool bResult = false;
					LuaSupport::CallHook(pkScriptSystem, "CityBoughtPlot", args.get(), bResult);
				}
				// and also the deferred stuff
				SetJONSCultureStored(iOverflow);
				ChangeJONSCultureLevel(1);
			}
		}
		else
		{
			// AI or dis-interested human, just acquire the plot normally
			if (GC.getLogging() && GC.getAILogging())
			{
				CvPlayerAI& kOwner = GET_PLAYER(getOwner());
				CvString strBaseString;
				CvString strOutBuf;
				CvString playerName = kOwner.getCivilizationShortDescription();
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				strBaseString += playerName + ", ";
				strOutBuf.Format("%s, City Culture Leveled Up. Level: %d Border Expanded, X: %d, Y: %d", getName().GetCString(),
					GetJONSCultureLevel(), pPlotToAcquire->getX(), pPlotToAcquire->getY());
				strBaseString += strOutBuf;
				kOwner.GetCitySpecializationAI()->LogMsg(strBaseString);
			}
			DoAcquirePlot(pPlotToAcquire->getX(), pPlotToAcquire->getY());
		}

		// If the human is picking their own tile, the event will be sent when the tile is "bought"
		if (bSendEvent)
		{
			if (MOD_EVENTS_CITY)
			{
				GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityBoughtPlot, getOwner(), GetID(), pPlotToAcquire->getX(), pPlotToAcquire->getY(), false, true);
			}
			else
			{
				ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
				if (pkScriptSystem)
				{
					CvLuaArgsHandle args;
					args->Push(getOwner());
					args->Push(GetID());
					args->Push(pPlotToAcquire->getX());
					args->Push(pPlotToAcquire->getY());
					args->Push(false); // bGold
					args->Push(true); // bFaith/bCulture

					bool bResult = false;
					LuaSupport::CallHook(pkScriptSystem, "CityBoughtPlot", args.get(), bResult);
				}
			}
		}

		GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_BORDERS, true, NO_GREATPERSON, NO_BUILDING, 0, true, NO_PLAYER, NULL, false, this, false, true, false, NO_YIELD, NULL, pPlotToAcquire->getTerrainType());

		if (GET_PLAYER(getOwner()).GetPlayerTraits()->TerrainClaimBoost(pPlotToAcquire->getTerrainType()))
		{
			for (int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; ++iDirectionLoop)
			{
				CvPlot* pAdjacentPlot = plotDirection(pPlotToAcquire->getX(), pPlotToAcquire->getY(), ((DirectionTypes)iDirectionLoop));
				if (pAdjacentPlot && pAdjacentPlot->getTerrainType() == pPlotToAcquire->getTerrainType())
				{
					if (pAdjacentPlot->getOwner() == NO_PLAYER)
					{
						DoAcquirePlot(pAdjacentPlot->getX(), pAdjacentPlot->getY());
					}
				}
			}
		}
	}
	else
	{
		if (MOD_UI_CITY_EXPANSION && bIsHumanControlled)
		{
			// Do the stuff we deferred as we though we'd do it when the human bought a tile but can't as there are no tiles to buy!
			SetJONSCultureStored(iOverflow);
			ChangeJONSCultureLevel(1);
		}

		// Still give instant yields even if no tile is acquired
		GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_BORDERS, true, NO_GREATPERSON, NO_BUILDING, 0, true, NO_PLAYER, NULL, false, this);
	}
}

//	--------------------------------------------------------------------------------
/// Amount of Culture needed in this City to acquire a new Plot
int CvCity::GetJONSCultureThreshold() const
{
	VALIDATE_OBJECT();
	int iCultureThreshold = /*15 in CP, 20 in VP*/ GD_INT_GET(CULTURE_COST_FIRST_PLOT);

	float fExponent = /*1.1f in CP, 1.35f in VP*/ GD_FLOAT_GET(CULTURE_COST_LATER_PLOT_EXPONENT);

	int iPolicyExponentMod = GET_PLAYER(m_eOwner).GetPlotCultureExponentModifier();
	if (iPolicyExponentMod != 0)
	{
		fExponent = fExponent * (float)((100 + iPolicyExponentMod));
		fExponent /= 100.0f;
	}

	int iAdditionalCost = GetJONSCultureLevel() * /*10 in CP, 15 in VP*/ GD_INT_GET(CULTURE_COST_LATER_PLOT_MULTIPLIER);
	double dAdditionalCost = pow((double)iAdditionalCost, (double)fExponent);

	//watch out for overflow ...
	iCultureThreshold += (dAdditionalCost < INT_MAX / 256 ? int(dAdditionalCost) : INT_MAX / 256);

	// More expensive for Minors to claim territory
	if (GET_PLAYER(getOwner()).isMinorCiv())
	{
		iCultureThreshold *= /*150 in CP, 115 in VP*/ GD_INT_GET(MINOR_CIV_PLOT_CULTURE_COST_MULTIPLIER);
		iCultureThreshold /= 100;
	}

	// Religion modifier
	int iReligionMod = 0;
	ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
	BeliefTypes eSecondaryPantheon = NO_BELIEF;
	if (eMajority != NO_RELIGION)
	{
		const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
		if (pReligion)
		{
			iReligionMod = pReligion->m_Beliefs.GetPlotCultureCostModifier(getOwner(), GET_PLAYER(getOwner()).getCity(GetID()));
			eSecondaryPantheon = GetCityReligions()->GetSecondaryReligionPantheonBelief();
			if (eSecondaryPantheon != NO_BELIEF)
			{
				iReligionMod += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetPlotCultureCostModifier();
			}
		}
	}

#if defined(MOD_RELIGION_PERMANENT_PANTHEON)
	// Mod for civs keeping their pantheon belief forever
	if (MOD_RELIGION_PERMANENT_PANTHEON)
	{
		if (GC.getGame().GetGameReligions()->HasCreatedPantheon(getOwner()))
		{
			const CvReligion* pPantheon = GC.getGame().GetGameReligions()->GetReligion(RELIGION_PANTHEON, getOwner());
			BeliefTypes ePantheonBelief = GC.getGame().GetGameReligions()->GetBeliefInPantheon(getOwner());
			if (pPantheon != NULL && ePantheonBelief != NO_BELIEF && ePantheonBelief != eSecondaryPantheon)
			{
				const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eMajority, getOwner());
				if (pReligion == NULL || (pReligion != NULL && !pReligion->m_Beliefs.IsPantheonBeliefInReligion(ePantheonBelief, eMajority, getOwner()))) // check that the our religion does not have our belief, to prevent double counting
				{
					iReligionMod += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetPlotCultureCostModifier();
				}
			}
		}
	}
#endif

	// -50 = 50% cost
	int iModifier = GET_PLAYER(getOwner()).GetPlotCultureCostModifier() + m_iPlotCultureCostModifier + iReligionMod;
	if (iModifier != 0)
	{
		iModifier = max(iModifier, /*-85*/ GD_INT_GET(CULTURE_PLOT_COST_MOD_MINIMUM));	// value cannot reduced by more than 85%
		iCultureThreshold *= (100 + iModifier);
		iCultureThreshold /= 100;
	}

	// Game Speed Mod
	iCultureThreshold *= GC.getGame().getGameSpeedInfo().getCulturePercent();
	iCultureThreshold /= 100;

	// Make the number not be funky
	int iDivisor = /*5*/ GD_INT_GET(CULTURE_COST_VISIBLE_DIVISOR);
	if (iCultureThreshold > iDivisor * 2)
	{
		iCultureThreshold /= iDivisor;
		iCultureThreshold *= iDivisor;
	}

	return iCultureThreshold;
}


//	--------------------------------------------------------------------------------
int CvCity::getJONSCulturePerTurn(bool bStatic) const
{
	VALIDATE_OBJECT();
	// Anarchy, Resistance or Razing? Then no Culture is given!
	if (GET_PLAYER(getOwner()).IsAnarchy() || IsResistance() || IsRazing())
		return 0;

	if (bStatic)
	{
		return (GetStaticYield(YIELD_CULTURE) / 100);
	}

	int iCulture = GetBaseJONSCulturePerTurn();

	// City modifier
	iCulture *= getBaseYieldRateModifier(YIELD_CULTURE, 0, NULL);
	iCulture /= 100;

	// Culture from having trade routes
	iCulture += GET_PLAYER(m_eOwner).GetTrade()->GetTradeValuesAtCityTimes100(this, YIELD_CULTURE) / 100;

	// Process production into culture
	if (getProductionToYieldModifier(YIELD_CULTURE) > 0)
	{
		int iTradeRouteBonus = GET_PLAYER(m_eOwner).GetTrade()->GetTradeValuesAtCityTimes100(this, YIELD_PRODUCTION);
		iCulture += ((getBasicYieldRateTimes100(YIELD_PRODUCTION) + iTradeRouteBonus) * getProductionToYieldModifier(YIELD_CULTURE)) / 10000;
	}

	return iCulture;
}

//	--------------------------------------------------------------------------------
int CvCity::GetBaseJONSCulturePerTurn() const
{
	VALIDATE_OBJECT();

	int iCulturePerTurn = 0;
	iCulturePerTurn += GetJONSCulturePerTurnFromBuildings();
	iCulturePerTurn += GetJONSCulturePerTurnFromPolicies();
	iCulturePerTurn += GetJONSCulturePerTurnFromSpecialists();

	// GetJONSCulturePerTurnFromSpecialists() uses the Specialists.CulturePerTurn column,
	// GetBaseYieldRateFromSpecialists(YIELD_CULTURE) gets everything else!
	iCulturePerTurn += GetBaseYieldRateFromSpecialists(YIELD_CULTURE);
	iCulturePerTurn += (GetYieldPerPopTimes100(YIELD_CULTURE) * getPopulation()) / 100;
	iCulturePerTurn += (GetYieldPerPopInEmpireTimes100(YIELD_CULTURE) * GET_PLAYER(getOwner()).getTotalPopulation()) / 100;

	if (IsRouteToCapitalConnected())
	{
		int iEra = GET_PLAYER(getOwner()).GetCurrentEra();
		if (iEra <= 0)
			iEra = 1;
		iCulturePerTurn += GET_PLAYER(getOwner()).GetYieldChangeTradeRoute(YIELD_CULTURE);
		iCulturePerTurn += GET_PLAYER(getOwner()).GetPlayerTraits()->GetYieldChangeTradeRoute(YIELD_CULTURE) * iEra;
	}

	iCulturePerTurn += GetBaseYieldRateFromGreatWorks(YIELD_CULTURE);
	iCulturePerTurn += GetBaseYieldRateFromTerrain(YIELD_CULTURE);

	for (int iI = 0; iI < GC.getNumFeatureInfos(); iI++)
	{
		FeatureTypes eFeature = (FeatureTypes)iI;
		if (eFeature != NO_FEATURE)
		{
			iCulturePerTurn += GetYieldPerTurnFromUnimprovedFeatures(eFeature, YIELD_CULTURE);
		}
	}

	iCulturePerTurn += GetJONSCulturePerTurnFromTraits();
	iCulturePerTurn += GetJONSCulturePerTurnFromReligion();
	iCulturePerTurn += GetJONSCulturePerTurnFromLeagues();

	CvPlot* pCityPlot = plot();
	for (int iUnitLoop = 0; iUnitLoop < pCityPlot->getNumUnits(); iUnitLoop++)
	{
		int iTempVal = pCityPlot->getUnitByIndex(iUnitLoop)->GetYieldChange(YIELD_CULTURE);
		if (iTempVal != 0)
		{
			iCulturePerTurn += iTempVal;
		}
	}

	ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
	if (MOD_BALANCE_CORE_POLICIES && eMajority != NO_RELIGION && eMajority > RELIGION_PANTHEON)
	{
		if (GET_PLAYER(getOwner()).GetReligions()->GetStateReligion() == eMajority)
		{
			iCulturePerTurn += GET_PLAYER(getOwner()).getReligionYieldRateModifier(YIELD_CULTURE);
		}
	}

	iCulturePerTurn += GetBaseYieldRateFromCSAlliance(YIELD_CULTURE);
	iCulturePerTurn += GetBaseYieldRateFromCSFriendship(YIELD_CULTURE);
	iCulturePerTurn += GetYieldFromMinors(YIELD_CULTURE);
	iCulturePerTurn += GetYieldPerTurnFromTraits(YIELD_CULTURE);
	iCulturePerTurn += GetYieldChangeFromCorporationFranchises(YIELD_CULTURE);
	iCulturePerTurn += GetEventCityYield(YIELD_CULTURE);
	iCulturePerTurn += GetBaseYieldRateFromMisc(YIELD_CULTURE);

	//Update Yields from yields ... need to sidestep constness
	CvCity* pThisCity = const_cast<CvCity*>(this);
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eIndex2 = (YieldTypes)iI;
		if (eIndex2 == NO_YIELD)
			continue;
		if (YIELD_CULTURE == eIndex2)
			continue;

		pThisCity->UpdateCityYieldFromYield(YIELD_CULTURE, eIndex2, iCulturePerTurn);

		//NOTE! We flip it here, because we want the OUT yield
		iCulturePerTurn += GetRealYieldFromYield(eIndex2, YIELD_CULTURE);
	}

	if (MOD_BALANCE_CORE_JFD)
	{
		iCulturePerTurn += GetYieldFromHappiness(YIELD_CULTURE);
		iCulturePerTurn += GetYieldFromHealth(YIELD_CULTURE);

		iCulturePerTurn += GetYieldFromCrime(YIELD_CULTURE);
		iCulturePerTurn += GetYieldFromDevelopment(YIELD_CULTURE);
	}

	return iCulturePerTurn;
}

//	--------------------------------------------------------------------------------
int CvCity::GetJONSCulturePerTurnFromBuildings() const
{
	VALIDATE_OBJECT();
	return GetBaseYieldRateFromBuildings(YIELD_CULTURE);
}

//	--------------------------------------------------------------------------------
int CvCity::GetJONSCulturePerTurnFromPolicies() const
{
	VALIDATE_OBJECT();

	int iNonSpecialist = GET_PLAYER(m_eOwner).getYieldFromNonSpecialistCitizens(YIELD_CULTURE);
	int iValue = 0;
	if (iNonSpecialist != 0)
	{
		int iBonusTimes100 = (iNonSpecialist * (getPopulation() - GetCityCitizens()->GetTotalSpecialistCount()));
		iBonusTimes100 /= 100;
		iValue += iBonusTimes100;
	}
	if (MOD_BALANCE_VP && GET_PLAYER(m_eOwner).getHappinessToCulture() != 0)
	{
		int iFreeCulture = GetLocalHappiness() * GET_PLAYER(m_eOwner).getHappinessToCulture();
		iFreeCulture /= 100;
		if (iFreeCulture > 0)
			iValue += iFreeCulture;
	}

	return (m_iJONSCulturePerTurnFromPolicies + iValue);
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeJONSCulturePerTurnFromPolicies(int iChange)
{
	VALIDATE_OBJECT();
	if (iChange != 0)
	{
		m_iJONSCulturePerTurnFromPolicies += iChange;
		UpdateCityYields(YIELD_CULTURE);
	}
}

//	--------------------------------------------------------------------------------
int CvCity::GetJONSCulturePerTurnFromSpecialists() const
{
	VALIDATE_OBJECT();
	return m_iJONSCulturePerTurnFromSpecialists;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeJONSCulturePerTurnFromSpecialists(int iChange)
{
	VALIDATE_OBJECT();
	if (iChange != 0)
	{
		m_iJONSCulturePerTurnFromSpecialists = (m_iJONSCulturePerTurnFromSpecialists + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvCity::GetJONSCulturePerTurnFromGreatWorks() const
{
	return GetCityBuildings()->GetYieldFromGreatWorks(YIELD_CULTURE);
}

//	--------------------------------------------------------------------------------
int CvCity::GetJONSCulturePerTurnFromTraits() const
{
	VALIDATE_OBJECT();
	return GET_PLAYER(m_eOwner).GetPlayerTraits()->GetCityCultureBonus();
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeYieldFromTraits(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_iaAddedYieldPerTurnFromTraits[eIndex] = m_iaAddedYieldPerTurnFromTraits[eIndex] + iChange;

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			if (isCitySelected())
			{
				DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
				//DLLUI->setDirty(InfoPane_DIRTY_BIT, true );
			}
		}
	}
}

//	--------------------------------------------------------------------------------
int CvCity::GetYieldPerTurnFromTraits(YieldTypes eYield) const
{
	int iYield = 0;

	if (isCapital() || !GET_PLAYER(m_eOwner).GetPlayerTraits()->IsCapitalOnly())
	{
		vector<ImprovementTypes> relevantTypes = GET_PLAYER(m_eOwner).GetPlayerTraits()->GetImprovementTypesWithYieldChange();
		for (size_t i = 0; i < relevantTypes.size(); i++)
		{
			ImprovementTypes eImprovement = relevantTypes[i];
			int iYieldChangePerImprovementBuilt = GET_PLAYER(m_eOwner).GetPlayerTraits()->GetYieldChangePerImprovementBuilt(eImprovement, eYield);
			if (iYieldChangePerImprovementBuilt == 0)
				continue;

			iYield += iYieldChangePerImprovementBuilt * GET_PLAYER(m_eOwner).getTotalImprovementsBuilt(eImprovement);
			if (GET_PLAYER(m_eOwner).GetPlayerTraits()->IsOddEraScaler())
			{
				if ((EraTypes)GET_PLAYER(m_eOwner).GetCurrentEra() >= (EraTypes)GC.getInfoTypeForString("ERA_MEDIEVAL", true))
				{
					iYield += iYieldChangePerImprovementBuilt * GET_PLAYER(m_eOwner).getTotalImprovementsBuilt(eImprovement);
				}
				if ((EraTypes)GET_PLAYER(m_eOwner).GetCurrentEra() >= (EraTypes)GC.getInfoTypeForString("ERA_INDUSTRIAL", true))
				{
					iYield += iYieldChangePerImprovementBuilt * GET_PLAYER(m_eOwner).getTotalImprovementsBuilt(eImprovement);
				}
				if ((EraTypes)GET_PLAYER(m_eOwner).GetCurrentEra() >= (EraTypes)GC.getInfoTypeForString("ERA_POSTMODERN", true))
				{
					iYield += iYieldChangePerImprovementBuilt * GET_PLAYER(m_eOwner).getTotalImprovementsBuilt(eImprovement);
				}
			}
		}
	}

	//Currently only used by Arabian CBP UA.
	if (isCapital())
	{
		iYield += (GET_PLAYER(m_eOwner).GetPlayerTraits()->GetYieldFromHistoricEvent(eYield) * GET_PLAYER(m_eOwner).GetNumHistoricEvents());
#if defined(MOD_BALANCE_YIELD_SCALE_ERA)
		if (MOD_BALANCE_YIELD_SCALE_ERA)
		{
			int iEra = GET_PLAYER(m_eOwner).GetCurrentEra();
			int iChange = GET_PLAYER(m_eOwner).GetPlayerTraits()->GetYieldChangePerTradePartner(eYield);
			if (iChange > 0)
				iYield += (max(1, iEra) * GET_PLAYER(m_eOwner).GetPlayerTraits()->GetYieldChangePerTradePartner(eYield) * GET_PLAYER(m_eOwner).GetTrade()->GetNumDifferentTradingPartners());
		}
	}
#endif

	return (iYield + m_iaAddedYieldPerTurnFromTraits[eYield]);
}
//	--------------------------------------------------------------------------------
int CvCity::GetJONSCulturePerTurnFromReligion() const
{
	VALIDATE_OBJECT();
	return GetBaseYieldRateFromReligion(YIELD_CULTURE);
}

//	--------------------------------------------------------------------------------
int CvCity::GetJONSCulturePerTurnFromLeagues() const
{
	VALIDATE_OBJECT();
	return (getNumWorldWonders() * GC.getGame().GetGameLeagues()->GetWorldWonderYieldChange(getOwner(), YIELD_CULTURE));
}

//	--------------------------------------------------------------------------------
int CvCity::GetFaithPerTurn(bool bStatic) const
{
	VALIDATE_OBJECT();
	// Anarchy, Resistance or Razing? Then no Faith is given!
	if (GET_PLAYER(getOwner()).IsAnarchy() || IsResistance() || IsRazing())
		return 0;

	if (bStatic)
	{
		return (GetStaticYield(YIELD_FAITH) / 100);
	}

	int iFaith = GetFaithPerTurnFromBuildings();
	iFaith += GetBaseYieldRateFromSpecialists(YIELD_FAITH);
	iFaith += (GetYieldPerPopTimes100(YIELD_FAITH) * getPopulation()) / 100;
	iFaith += (GetYieldPerPopInEmpireTimes100(YIELD_FAITH) * GET_PLAYER(getOwner()).getTotalPopulation()) / 100;

	if (IsRouteToCapitalConnected())
	{
		int iEra = GET_PLAYER(getOwner()).GetCurrentEra();
		if (iEra <= 0)
			iEra = 1;
		iFaith += GET_PLAYER(getOwner()).GetYieldChangeTradeRoute(YIELD_FAITH);
		iFaith += GET_PLAYER(getOwner()).GetPlayerTraits()->GetYieldChangeTradeRoute(YIELD_FAITH) * iEra;
	}

	iFaith += GetBaseYieldRateFromGreatWorks(YIELD_FAITH);
	iFaith += GetBaseYieldRateFromTerrain(YIELD_FAITH);
	iFaith += GetFaithPerTurnFromPolicies();

	for (int iI = 0; iI < GC.getNumFeatureInfos(); iI++)
	{
		FeatureTypes eFeature = (FeatureTypes)iI;
		if (eFeature != NO_FEATURE)
		{
			iFaith += GetYieldPerTurnFromUnimprovedFeatures(eFeature, YIELD_FAITH);
		}
	}

	iFaith += GetFaithPerTurnFromReligion();

	ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
	if (MOD_BALANCE_CORE_POLICIES && eMajority != NO_RELIGION && eMajority > RELIGION_PANTHEON)
	{
		if (GET_PLAYER(getOwner()).GetReligions()->GetStateReligion() == eMajority)
		{
			iFaith += GET_PLAYER(getOwner()).getReligionYieldRateModifier(YIELD_FAITH);
		}
	}

	iFaith += GetBaseYieldRateFromCSAlliance(YIELD_FAITH);
	iFaith += GetBaseYieldRateFromCSFriendship(YIELD_FAITH);
	iFaith += GetYieldFromMinors(YIELD_FAITH);
	iFaith += GetYieldPerTurnFromTraits(YIELD_FAITH);
	iFaith += GetYieldChangeFromCorporationFranchises(YIELD_FAITH);
	iFaith += GetEventCityYield(YIELD_FAITH);

	//Update Yields from yields ... need to sidestep constness
	CvCity* pThisCity = const_cast<CvCity*>(this);
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eIndex2 = (YieldTypes)iI;
		if (eIndex2 == NO_YIELD)
			continue;
		if (YIELD_FAITH == eIndex2)
			continue;

		pThisCity->UpdateCityYieldFromYield(YIELD_FAITH, eIndex2, iFaith);

		//NOTE! We flip it here, because we want the OUT yield
		iFaith += GetRealYieldFromYield(eIndex2, YIELD_FAITH);
	}

	if (MOD_BALANCE_CORE_JFD)
	{
		iFaith += GetYieldFromHappiness(YIELD_FAITH);
		iFaith += GetYieldFromHealth(YIELD_FAITH);
		iFaith += GetYieldFromCrime(YIELD_FAITH);
		iFaith += GetYieldFromDevelopment(YIELD_FAITH);
	}

	CvPlot* pCityPlot = plot();
	for (int iUnitLoop = 0; iUnitLoop < pCityPlot->getNumUnits(); iUnitLoop++)
	{
		int iTempVal = pCityPlot->getUnitByIndex(iUnitLoop)->GetYieldChange(YIELD_FAITH);
		if (iTempVal != 0)
		{
			iFaith += iTempVal;
		}
	}

	int iModifier = 100;

	// City modifier
	iModifier = getBaseYieldRateModifier(YIELD_FAITH);

	// FIXME: EUI doesn't expect `CvCity::getBaseYieldRateModifier` to populate the puppet modifier for faith.
	// EUI should be fixed and this behavior moved to `CvCity::getBaseYieldRateModifier`.
	if (IsPuppet())
	{
		int iTempMod = GET_PLAYER(getOwner()).GetPuppetYieldPenaltyMod() + GET_PLAYER(getOwner()).GetPlayerTraits()->GetPuppetPenaltyReduction() + /*0 in CP, -80 in VP*/ GD_INT_GET(PUPPET_FAITH_MODIFIER);
		if (iTempMod > 0)
			iTempMod = 0;
		iModifier += iTempMod;
	}

	iFaith *= iModifier;
	iFaith /= 100;

	// Process production into faith
	if (getProductionToYieldModifier(YIELD_FAITH) > 0)
	{
		int iTradeRouteBonus = GET_PLAYER(m_eOwner).GetTrade()->GetTradeValuesAtCityTimes100(this, YIELD_PRODUCTION);
		iFaith += ((getBasicYieldRateTimes100(YIELD_PRODUCTION) + iTradeRouteBonus) * getProductionToYieldModifier(YIELD_FAITH)) / 10000;
	}

	// Faith from having trade routes
	iFaith += GET_PLAYER(m_eOwner).GetTrade()->GetTradeValuesAtCityTimes100(this, YIELD_FAITH) / 100;

	return iFaith;
}

//	--------------------------------------------------------------------------------
int CvCity::GetFaithPerTurnFromBuildings() const
{
	VALIDATE_OBJECT();
	return GetBaseYieldRateFromBuildings(YIELD_FAITH);
}

//	--------------------------------------------------------------------------------
int CvCity::GetFaithPerTurnFromPolicies() const
{
	VALIDATE_OBJECT();
	int iNonSpecialist = GET_PLAYER(m_eOwner).getYieldFromNonSpecialistCitizens(YIELD_FAITH);
	int iValue = 0;
	if (iNonSpecialist != 0)
	{
		int iBonusTimes100 = (iNonSpecialist * (getPopulation() - GetCityCitizens()->GetTotalSpecialistCount()));
		iBonusTimes100 /= 100;
		iValue += iBonusTimes100;
	}

	return (m_iFaithPerTurnFromPolicies + iValue);
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeFaithPerTurnFromPolicies(int iChange)
{
	VALIDATE_OBJECT();
	m_iFaithPerTurnFromPolicies += iChange;
}

//	--------------------------------------------------------------------------------
void CvCity::UpdateYieldPerXTerrain(YieldTypes eYield, TerrainTypes eTerrain)
{
	VALIDATE_OBJECT();
	int iYield = 0;

	int iValidTilesTerrain = 0;
	int iBaseYieldBuildings = 0;

	//Passed in a terrain? Let's only update that.
	if (eTerrain != NO_TERRAIN)
	{
		iBaseYieldBuildings = GetYieldPerXTerrainFromBuildingsTimes100(eTerrain, eYield);

		if (iBaseYieldBuildings > 0)
		{
			if (eTerrain == TERRAIN_MOUNTAIN)
			{
				iValidTilesTerrain = GetNearbyMountains();
			}
			else if (eTerrain == TERRAIN_SNOW)
			{
				iValidTilesTerrain = CountTerrain(TERRAIN_SNOW);
			}
			else
			{
				iValidTilesTerrain = GetNumTerrainWorked(eTerrain);
			}

			iYield = (iValidTilesTerrain * iBaseYieldBuildings) / 100;

			//iDifference determines +/- of difference of old value
			int iDifference = iYield - GetYieldPerXTerrain(eTerrain, eYield);

			//Change base rate first
			ChangeBaseYieldRateFromBuildings(eYield, iDifference);

			//then set base rate for retrieval next time.
			SetYieldPerXTerrain(eTerrain, eYield, iYield);
		}
		else if (GetYieldPerXTerrain(eTerrain, eYield) > 0)
		{
			//No bonuses? Clear it out.
			ChangeBaseYieldRateFromBuildings(eYield, -GetYieldPerXTerrain(eTerrain, eYield));
			SetYieldPerXTerrain(eTerrain, eYield, 0);
		}
	}
	else
	{
		for (int iI = 0; iI < GC.getNumTerrainInfos(); iI++)
		{
			eTerrain = (TerrainTypes)iI;
			if (eTerrain == NO_TERRAIN)
			{
				continue;
			}

			iBaseYieldBuildings = GetYieldPerXTerrainFromBuildingsTimes100(eTerrain, eYield);

			if (iBaseYieldBuildings > 0)
			{
				if (eTerrain == TERRAIN_MOUNTAIN)
				{
					iValidTilesTerrain = GetNearbyMountains();
				}
				else if (eTerrain == TERRAIN_SNOW)
				{
					iValidTilesTerrain = CountTerrain(TERRAIN_SNOW);
				}
				else
				{
					iValidTilesTerrain = GetNumTerrainWorked(eTerrain);
				}

				iYield = (iValidTilesTerrain * iBaseYieldBuildings) / 100;

				//iDifference determines +/- of difference of old value
				int iDifference = iYield - GetYieldPerXTerrain(eTerrain, eYield);

				//Change base rate first
				ChangeBaseYieldRateFromBuildings(eYield, iDifference);

				//then set base rate for retrieval next time.
				SetYieldPerXTerrain(eTerrain, eYield, iYield);
			}
			else if (GetYieldPerXTerrain(eTerrain, eYield) > 0)
			{
				//No bonuses? Clear it out.
				ChangeBaseYieldRateFromBuildings(eYield, -GetYieldPerXTerrain(eTerrain, eYield));
				SetYieldPerXTerrain(eTerrain, eYield, 0);
			}
		}
	}
}
void CvCity::UpdateYieldPerXTerrainFromReligion(YieldTypes eYield, TerrainTypes eTerrain)
{
	VALIDATE_OBJECT();
	int iYield = 0;

	int iValidTilesTerrain = 0;
	int iBaseYieldReligion = 0;
	ReligionTypes eReligionFounded = GetCityReligions()->GetReligiousMajority();
	if (eReligionFounded != NO_RELIGION)
	{
		const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eReligionFounded, getOwner());
		if (pReligion)
		{
			//Passed in a Terrain? Use that.
			if (eTerrain != NO_TERRAIN)
			{
				iYield = 0;
				iBaseYieldReligion = pReligion->m_Beliefs.GetYieldPerXTerrainTimes100(eTerrain, eYield, getOwner(), this);
				if (iBaseYieldReligion > 0)
				{
					if (eTerrain == TERRAIN_MOUNTAIN)
					{
						iValidTilesTerrain = GetNearbyMountains();
					}
					else if (eTerrain == TERRAIN_SNOW)
					{
						iValidTilesTerrain = CountTerrain(TERRAIN_SNOW);
					}
					else if (pReligion->m_Beliefs.RequiresNoFeature(getOwner()))
					{
						iValidTilesTerrain = GetNumFeaturelessTerrainWorked(eTerrain);
					}
					else
					{
						iValidTilesTerrain = GetNumTerrainWorked(eTerrain);
					}

					iYield += ((iValidTilesTerrain * iBaseYieldReligion) / 100);

					if (eTerrain == TERRAIN_MOUNTAIN && iYield > getPopulation())
					{
						iYield = getPopulation();
					}
					if (eTerrain == TERRAIN_SNOW && iYield > getPopulation())
					{
						iYield = getPopulation();
					}

					SetYieldPerXTerrainFromReligion(eTerrain, eYield, iYield);
				}
				else if (GetYieldPerXTerrainFromReligion(eTerrain, eYield) > 0)
				{
					SetYieldPerXTerrainFromReligion(eTerrain, eYield, 0);
				}
			}
			else
			{
				for (int iI = 0; iI < GC.getNumTerrainInfos(); iI++)
				{
					eTerrain = (TerrainTypes)iI;
					iYield = 0;
					if (eTerrain == NO_TERRAIN)
					{
						continue;
					}
					iBaseYieldReligion = pReligion->m_Beliefs.GetYieldPerXTerrainTimes100(eTerrain, eYield, getOwner(), this);
					if (iBaseYieldReligion > 0)
					{
						if (eTerrain == TERRAIN_MOUNTAIN)
						{
							iValidTilesTerrain = GetNearbyMountains();
						}
						else if (eTerrain == TERRAIN_SNOW)
						{
							iValidTilesTerrain = CountTerrain(TERRAIN_SNOW);
						}
						else if (pReligion->m_Beliefs.RequiresNoFeature(getOwner()))
						{
							iValidTilesTerrain = GetNumFeaturelessTerrainWorked(eTerrain);
						}
						else
						{
							iValidTilesTerrain = GetNumTerrainWorked(eTerrain);
						}

						iYield += ((iValidTilesTerrain * iBaseYieldReligion) / 100);

						if (eTerrain == TERRAIN_MOUNTAIN && iYield > getPopulation())
						{
							iYield = getPopulation();
						}
						if (eTerrain == TERRAIN_SNOW && iYield > getPopulation())
						{
							iYield = getPopulation();
						}

						SetYieldPerXTerrainFromReligion(eTerrain, eYield, iYield);
					}
					else if (GetYieldPerXTerrainFromReligion(eTerrain, eYield) > 0)
					{
						SetYieldPerXTerrainFromReligion(eTerrain, eYield, 0);
					}
				}
			}
		}
	}
}
//	--------------------------------------------------------------------------------
int CvCity::GetNumTerrainWorked(TerrainTypes eTerrain)
{
	ASSERT_DEBUG(eTerrain >= 0, "eTerrain is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eTerrain < GC.getNumTerrainInfos(), "eTerrain is expected to be within maximum bounds (invalid Index)");
	return m_paiNumTerrainWorked[eTerrain];
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeNumTerrainWorked(TerrainTypes eTerrain, int iChange)
{
	ASSERT_DEBUG(eTerrain >= 0, "eTerrain is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eTerrain < GC.getNumTerrainInfos(), "eTerrain is expected to be within maximum bounds (invalid Index)");
	m_paiNumTerrainWorked[eTerrain] = m_paiNumTerrainWorked[eTerrain] + iChange;
	ASSERT_DEBUG(GetNumTerrainWorked(eTerrain) >= 0);

	//Update yields
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		//Simplification - errata yields not worth considering.
		if ((YieldTypes)iI > YIELD_CULTURE_LOCAL && !MOD_BALANCE_CORE_JFD)
			break;

		UpdateYieldPerXTerrain(((YieldTypes)iI), eTerrain);
		UpdateYieldPerXTerrainFromReligion(((YieldTypes)iI), eTerrain);
	}
}

int CvCity::GetNumFeaturelessTerrainWorked(TerrainTypes eTerrain)
{
	ASSERT_DEBUG(eTerrain >= 0, "eTerrain is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eTerrain < GC.getNumTerrainInfos(), "eTerrain is expected to be within maximum bounds (invalid Index)");
	return m_paiNumFeaturelessTerrainWorked[eTerrain];
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeNumFeaturelessTerrainWorked(TerrainTypes eTerrain, int iChange)
{
	ASSERT_DEBUG(eTerrain >= 0, "eTerrain is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eTerrain < GC.getNumTerrainInfos(), "eTerrain is expected to be within maximum bounds (invalid Index)");
	m_paiNumFeaturelessTerrainWorked[eTerrain] = m_paiNumFeaturelessTerrainWorked[eTerrain] + iChange;
	ASSERT_DEBUG(GetNumFeaturelessTerrainWorked(eTerrain) >= 0);

	//Update yields
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		//Simplification - errata yields not worth considering.
		if ((YieldTypes)iI > YIELD_CULTURE_LOCAL && !MOD_BALANCE_CORE_JFD)
			break;

		UpdateYieldPerXTerrain(((YieldTypes)iI), eTerrain);
		UpdateYieldPerXTerrainFromReligion(((YieldTypes)iI), eTerrain);
	}
}
//	--------------------------------------------------------------------------------
int CvCity::GetNumFeatureWorked(FeatureTypes eFeature)
{
	ASSERT_DEBUG(eFeature >= 0, "eFeature is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eFeature < GC.getNumFeatureInfos(), "eFeature is expected to be within maximum bounds (invalid Index)");
	return m_paiNumFeatureWorked[eFeature];
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeNumFeatureWorked(FeatureTypes eFeature, int iChange)
{
	ASSERT_DEBUG(eFeature >= 0, "eFeature is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eFeature < GC.getNumFeatureInfos(), "eFeature is expected to be within maximum bounds (invalid Index)");
	m_paiNumFeatureWorked[eFeature] = m_paiNumFeatureWorked[eFeature] + iChange;
	ASSERT_DEBUG(GetNumFeatureWorked(eFeature) >= 0);

	//Update yields
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		//Simplification - errata yields not worth considering.
		if ((YieldTypes)iI > YIELD_CULTURE_LOCAL && !MOD_BALANCE_CORE_JFD)
			break;

		UpdateYieldPerXFeature(((YieldTypes)iI), eFeature);
	}
}
//	--------------------------------------------------------------------------------
int CvCity::GetNumImprovementWorked(ImprovementTypes eImprovement)
{
	ASSERT_DEBUG(eImprovement >= 0, "eImprovement is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eImprovement < GC.getNumImprovementInfos(), "eImprovement is expected to be within maximum bounds (invalid Index)");
	return m_paiNumImprovementWorked[eImprovement];
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeNumImprovementWorked(ImprovementTypes eImprovement, int iChange)
{
	ASSERT_DEBUG(eImprovement >= 0, "eImprovement is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eImprovement < GC.getNumImprovementInfos(), "eImprovement is expected to be within maximum bounds (invalid Index)");
	m_paiNumImprovementWorked[eImprovement] = m_paiNumImprovementWorked[eImprovement] + iChange;
	ASSERT_DEBUG(GetNumImprovementWorked(eImprovement) >= 0);
}

//	--------------------------------------------------------------------------------
void CvCity::SetYieldPerXTerrain(TerrainTypes eTerrain, YieldTypes eYield, int iValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eTerrain > -1 && eTerrain < GC.getNumTerrainInfos(), "Invalid Terrain index.");
	ASSERT_DEBUG(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	SCityExtraYields& y = m_yieldChanges[eYield];
	if (ModifierUpdateInsertRemove(y.forXTerrain, eTerrain, iValue, false))
		updateYield(false);
}
//	--------------------------------------------------------------------------------
void CvCity::SetYieldPerXTerrainFromReligion(TerrainTypes eTerrain, YieldTypes eYield, int iValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eTerrain > -1 && eTerrain < GC.getNumTerrainInfos(), "Invalid Terrain index.");
	ASSERT_DEBUG(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	SCityExtraYields& y = m_yieldChanges[eYield];
	if (ModifierUpdateInsertRemove(y.forTerrainFromReligion, eTerrain, iValue, false))
		updateYield(false);
}
//	--------------------------------------------------------------------------------
/// Extra yield for a Terrain this city is working?
int CvCity::GetYieldPerXTerrain(TerrainTypes eTerrain, YieldTypes eYield) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eTerrain > -1 && eTerrain < GC.getNumTerrainInfos(), "Invalid Terrain index.");
	ASSERT_DEBUG(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	return ModifierLookup(m_yieldChanges[eYield].forXTerrain, eTerrain);
}
//	--------------------------------------------------------------------------------
/// Extra yield for a Terrain this city is working?
int CvCity::GetYieldPerXTerrainFromReligion(TerrainTypes eTerrain, YieldTypes eYield) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eTerrain > -1 && eTerrain < GC.getNumTerrainInfos(), "Invalid Terrain index.");
	ASSERT_DEBUG(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	return ModifierLookup(m_yieldChanges[eYield].forTerrainFromReligion, eTerrain);
}
//	--------------------------------------------------------------------------------
/// Extra yield for a Terrain this city is working?
int CvCity::GetYieldPerXTerrainFromBuildingsTimes100(TerrainTypes eTerrain, YieldTypes eYield) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eTerrain > -1 && eTerrain < GC.getNumTerrainInfos(), "Invalid Terrain index.");
	ASSERT_DEBUG(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	return ModifierLookup(m_yieldChanges[eYield].forTerrainFromBuildings, eTerrain);
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeYieldPerXTerrainFromBuildingsTimes100(TerrainTypes eTerrain, YieldTypes eYield, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eTerrain > -1 && eTerrain < GC.getNumTerrainInfos(), "Invalid Terrain index.");
	ASSERT_DEBUG(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	SCityExtraYields& y = m_yieldChanges[eYield];
	if (ModifierUpdateInsertRemove(y.forTerrainFromBuildings, eTerrain, iChange, true))
		updateYield(false);
}

//	--------------------------------------------------------------------------------
/// Extra yield for a Feature this city is working?
int CvCity::GetYieldPerXFeatureFromBuildingsTimes100(FeatureTypes eFeature, YieldTypes eYield) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eFeature > -1 && eFeature < GC.getNumFeatureInfos(), "Invalid Feature index.");
	ASSERT_DEBUG(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	return ModifierLookup(m_yieldChanges[eYield].forFeatureFromBuildings, eFeature);
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeYieldPerXFeatureFromBuildingsTimes100(FeatureTypes eFeature, YieldTypes eYield, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eFeature > -1 && eFeature < GC.getNumFeatureInfos(), "Invalid Feature index.");
	ASSERT_DEBUG(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	SCityExtraYields& y = m_yieldChanges[eYield];
	if (ModifierUpdateInsertRemove(y.forFeatureFromBuildings, eFeature, iChange, true))
	{
		updateYield(false);
		UpdateYieldPerXFeature(eYield, eFeature);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield for a Feature this city is working?
int CvCity::GetYieldPerXFeature(FeatureTypes eFeature, YieldTypes eYield) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eFeature > -1 && eFeature < GC.getNumFeatureInfos(), "Invalid Terrain index.");
	ASSERT_DEBUG(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	return ModifierLookup(m_yieldChanges[eYield].forXFeature, eFeature);
}

int CvCity::GetYieldPerXFeatureFromReligion(FeatureTypes eFeature, YieldTypes eYield) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eFeature > -1 && eFeature < GC.getNumFeatureInfos(), "Invalid Terrain index.");
	ASSERT_DEBUG(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	return ModifierLookup(m_yieldChanges[eYield].forFeatureFromReligion, eFeature);
}

//	--------------------------------------------------------------------------------
/// Extra yield for an unimproved Feature this city is working?
int CvCity::GetYieldPerTurnFromUnimprovedFeatures(FeatureTypes eFeature, YieldTypes eYield) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eFeature > -1 && eFeature < GC.getNumFeatureInfos(), "Invalid Terrain index.");
	ASSERT_DEBUG(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	return ModifierLookup(m_yieldChanges[eYield].forFeatureUnimproved, eFeature);
}
//	--------------------------------------------------------------------------------
void CvCity::SetYieldPerXFeature(FeatureTypes eFeature, YieldTypes eYield, int iValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eFeature > -1 && eFeature < GC.getNumFeatureInfos(), "Invalid Feature index.");
	ASSERT_DEBUG(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	SCityExtraYields& y = m_yieldChanges[eYield];
	if (ModifierUpdateInsertRemove(y.forXFeature, eFeature, iValue, false))
		updateYield(false);
}

//	--------------------------------------------------------------------------------
void CvCity::SetYieldPerXFeatureFromReligion(FeatureTypes eFeature, YieldTypes eYield, int iValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eFeature > -1 && eFeature < GC.getNumFeatureInfos(), "Invalid Feature index.");
	ASSERT_DEBUG(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	SCityExtraYields& y = m_yieldChanges[eYield];
	if (ModifierUpdateInsertRemove(y.forFeatureFromReligion, eFeature, iValue, false))
		updateYield(false);
}
//	--------------------------------------------------------------------------------
void CvCity::SetYieldPerXUnimprovedFeature(FeatureTypes eFeature, YieldTypes eYield, int iValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eFeature > -1 && eFeature < GC.getNumFeatureInfos(), "Invalid Feature index.");
	ASSERT_DEBUG(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	SCityExtraYields& y = m_yieldChanges[eYield];
	if (ModifierUpdateInsertRemove(y.forFeatureUnimproved, eFeature, iValue, false))
		updateYield(false);
}

void CvCity::UpdateYieldPerXUnimprovedFeature(YieldTypes eYield, FeatureTypes eFeature)
{
	VALIDATE_OBJECT();
	int iYield = 0;

	CvPlayer& kPlayer = GET_PLAYER(getOwner());
	const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
	BeliefTypes eSecondaryPantheon = GetCityReligions()->GetSecondaryReligionPantheonBelief();

	const CvReligion* pPantheon = NULL;
	BeliefTypes ePantheonBelief = NO_BELIEF;

	// Mod for civs keeping their pantheon belief forever
	if (MOD_RELIGION_PERMANENT_PANTHEON)
	{
		if (GC.getGame().GetGameReligions()->HasCreatedPantheon(getOwner()))
		{
			pPantheon = GC.getGame().GetGameReligions()->GetReligion(RELIGION_PANTHEON, getOwner());
			ePantheonBelief = GC.getGame().GetGameReligions()->GetBeliefInPantheon(getOwner());
		}
	}

	for (int iI = 0; iI < GC.getNumFeatureInfos(); iI++)
	{
		FeatureTypes eUseFeature = static_cast<FeatureTypes>(iI);

		// Passed in a feature? Use only that
		if (eFeature != NO_FEATURE && eFeature != eUseFeature)
			continue;

		if (!GC.getFeatureInfo(eUseFeature)->IsNaturalWonder(true))
		{
			int iBaseYield = kPlayer.getCityYieldFromUnimprovedFeature(eUseFeature, eYield);
			iBaseYield += kPlayer.GetPlayerTraits()->GetCityYieldFromUnimprovedFeature(eUseFeature, eYield);

			if (pReligion)
			{
				iBaseYield += pReligion->m_Beliefs.GetCityYieldFromUnimprovedFeature(eUseFeature, eYield, getOwner(), this);
				if (eSecondaryPantheon != NO_BELIEF)
				{
					iBaseYield += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetCityYieldFromUnimprovedFeature(eUseFeature, eYield);
				}
			}

			if (MOD_RELIGION_PERMANENT_PANTHEON)
			{
				if (pPantheon != NULL && ePantheonBelief != NO_BELIEF && ePantheonBelief != eSecondaryPantheon)
				{
					if (pReligion == NULL || (pReligion != NULL && !pReligion->m_Beliefs.IsPantheonBeliefInReligion(ePantheonBelief, pReligion->m_eReligion, getOwner()))) // check that the our religion does not have our belief, to prevent double counting
					{
						iBaseYield += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetCityYieldFromUnimprovedFeature(eUseFeature, eYield);
					}
				}
			}

			if (eYield == YIELD_FAITH && eUseFeature == FEATURE_FOREST && kPlayer.GetPlayerTraits()->IsFaithFromUnimprovedForest())
			{
				++iBaseYield;
			}

			if (iBaseYield > 0)
			{
				int iAdjacentFeatures = 0;

				for (int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; ++iDirectionLoop)
				{
					CvPlot* pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iDirectionLoop));
					if (pAdjacentPlot && pAdjacentPlot->getFeatureType() == eUseFeature && pAdjacentPlot->getImprovementType() == NO_IMPROVEMENT)
					{
						iAdjacentFeatures++;
					}
				}

				if (iAdjacentFeatures > 2)
				{
					iYield += MOD_ALTERNATE_CELTS ? iBaseYield * 3 : iBaseYield * 2;
				}
				else if (iAdjacentFeatures > 1 && MOD_ALTERNATE_CELTS)
				{
					iYield += iBaseYield * 2;
				}
				else if (iAdjacentFeatures > 0)
				{
					iYield += iBaseYield;
				}
				SetYieldPerXUnimprovedFeature(eUseFeature, eYield, iYield);
			}
		}
	}
}

void CvCity::UpdateYieldPerXFeature(YieldTypes eYield, FeatureTypes eFeature)
{
	VALIDATE_OBJECT();
	int iYieldBase = 0;
	int iYieldReligion = 0;

	int iValidTiles = 0;
	int iBaseYield = 0;
	int iBaseYieldReligion = 0;

	const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();

	for (int iI = 0; iI < GC.getNumFeatureInfos(); iI++)
	{
		FeatureTypes eUseFeature = (FeatureTypes)iI;

		// Passed in a feature? Update only that
		if (eFeature != NO_FEATURE && eFeature != eUseFeature)
			continue;

		iYieldBase = 0;
		iYieldReligion = 0;
		if (pReligion)
		{
			iBaseYieldReligion = pReligion->m_Beliefs.GetYieldPerXFeatureTimes100(eUseFeature, eYield, getOwner(), this);
		}

		iBaseYield = GetYieldPerXFeatureFromBuildingsTimes100(eUseFeature, eYield);

		bool bTest = false;
		if (iBaseYield <= 0)
		{
			ChangeBaseYieldRateFromBuildings(eYield, -GetYieldPerXFeature(eUseFeature, eYield));
			SetYieldPerXFeature(eUseFeature, eYield, 0);
		}
		else
		{
			bTest = true;
		}

		if (iBaseYieldReligion <= 0)
		{
			SetYieldPerXFeatureFromReligion(eUseFeature, eYield, iYieldReligion);
		}
		else
		{
			bTest = true;
		}

		if (bTest)
		{
			iValidTiles = GetNumFeatureWorked(eUseFeature);
			if (iValidTiles > 0)
			{
				// Gain 1 yield per x valid tiles - so if 'x' is 3, and you have 3 tiles that match, you get 1 yield
				iYieldBase = (iValidTiles * iBaseYield) / 100;
				iYieldReligion = (iValidTiles * iBaseYieldReligion) / 100;

				// iDifference determines +/- of difference of old value
				int iDifference = iYieldBase - GetYieldPerXFeature(eUseFeature, eYield);

				// Change base rate first
				ChangeBaseYieldRateFromBuildings(eYield, iDifference);
				SetYieldPerXFeature(eUseFeature, eYield, iYieldBase);

				SetYieldPerXFeatureFromReligion(eUseFeature, eYield, iYieldReligion);
			}
			else
			{
				ChangeBaseYieldRateFromBuildings(eYield, -GetYieldPerXFeature(eUseFeature, eYield));
				SetYieldPerXFeature(eUseFeature, eYield, 0);

				SetYieldPerXFeatureFromReligion(eUseFeature, eYield, 0);
			}
		}
	}
}

//	--------------------------------------------------------------------------------
int CvCity::getHurryModifier(HurryTypes eIndex) const
{
	ASSERT_DEBUG(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eIndex < GC.getNumHurryInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiHurryModifier[eIndex];
}

//	--------------------------------------------------------------------------------
void CvCity::changeHurryModifier(HurryTypes eIndex, int iChange)
{
	if (iChange != 0)
	{
		ASSERT_DEBUG(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
		ASSERT_DEBUG(eIndex < GC.getNumHurryInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
		m_paiHurryModifier[eIndex] = m_paiHurryModifier[eIndex] + iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvCity::getSpecialistExtraYield(SpecialistTypes eIndex1, YieldTypes eIndex2) const
{
	ASSERT_DEBUG(eIndex1 >= 0, "eIndex1 expected to be >= 0");
	ASSERT_DEBUG(eIndex1 < GC.getNumSpecialistInfos(), "eIndex1 expected to be < GC.getNumSpecialistInfos()");
	ASSERT_DEBUG(eIndex2 >= 0, "eIndex2 expected to be >= 0");
	ASSERT_DEBUG(eIndex2 < NUM_YIELD_TYPES, "eIndex2 expected to be < NUM_YIELD_TYPES");
	return ModifierLookup(m_yieldChanges[eIndex2].forSpecialist, eIndex1);
}


//	--------------------------------------------------------------------------------
void CvCity::changeSpecialistExtraYield(SpecialistTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	ASSERT_DEBUG(eIndex1 >= 0, "eIndex1 expected to be >= 0");
	ASSERT_DEBUG(eIndex1 < GC.getNumSpecialistInfos(), "eIndex1 expected to be < GC.getNumSpecialistInfos()");
	ASSERT_DEBUG(eIndex2 >= 0, "eIndex2 expected to be >= 0");
	ASSERT_DEBUG(eIndex2 < NUM_YIELD_TYPES, "eIndex2 expected to be < NUM_YIELD_TYPES");

	SCityExtraYields& y = m_yieldChanges[eIndex2];
	if (ModifierUpdateInsertRemove(y.forSpecialist, eIndex1, iChange, true))
		updateExtraSpecialistYield();
}

//	--------------------------------------------------------------------------------
int CvCity::GetFaithPerTurnFromReligion() const
{
	VALIDATE_OBJECT();
	return GetBaseYieldRateFromReligion(YIELD_FAITH);
}

//	--------------------------------------------------------------------------------
int CvCity::getCultureRateModifier() const
{
	VALIDATE_OBJECT();
	return m_iCultureRateModifier;
}

//	--------------------------------------------------------------------------------
void CvCity::changeCultureRateModifier(int iChange)
{
	VALIDATE_OBJECT();
	if (iChange != 0)
	{
		m_iCultureRateModifier = (m_iCultureRateModifier + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvCity::getBuildingClassCultureChange(BuildingClassTypes eIndex) const
{
	ASSERT_DEBUG(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiBuildingClassCulture[eIndex];
}
//	--------------------------------------------------------------------------------
void CvCity::changeBuildingClassCultureChange(BuildingClassTypes eIndex, int iChange)
{
	ASSERT_DEBUG(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	m_paiBuildingClassCulture[eIndex] += iChange;
	ASSERT_DEBUG(m_paiBuildingClassCulture[eIndex] >= 0);
}

//	--------------------------------------------------------------------------------
int CvCity::GetBaseTourism() const
{
	VALIDATE_OBJECT();
	return m_iBaseTourism;
}

//	--------------------------------------------------------------------------------
void CvCity::SetBaseTourism(int iValue)
{
	VALIDATE_OBJECT();
	m_iBaseTourism = iValue;
}
//	--------------------------------------------------------------------------------
int CvCity::GetBaseTourismBeforeModifiers() const
{
	VALIDATE_OBJECT();
	return m_iBaseTourismBeforeModifiers;
}

//	--------------------------------------------------------------------------------
void CvCity::SetBaseTourismBeforeModifiers(int iValue)
{
	VALIDATE_OBJECT();
	m_iBaseTourismBeforeModifiers = iValue;
}

//	--------------------------------------------------------------------------------
int CvCity::getTourismRateModifier() const
{
	VALIDATE_OBJECT();
	return (GetCityBuildings()->GetGreatWorksTourismModifier() + GET_PLAYER(getOwner()).GetGreatWorksTourismModifierGlobal());
}

//	--------------------------------------------------------------------------------
void CvCity::changeTourismRateModifier(int iChange)
{
	VALIDATE_OBJECT();
	if (iChange != 0)
	{
		GetCityBuildings()->ChangeGreatWorksTourismModifier(iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvCity::getNumWorldWonders() const
{
	VALIDATE_OBJECT();
	return m_iNumWorldWonders;
}


//	--------------------------------------------------------------------------------
void CvCity::changeNumWorldWonders(int iChange)
{
	VALIDATE_OBJECT();
	if (iChange != 0)
	{
		m_iNumWorldWonders = (m_iNumWorldWonders + iChange);
		ASSERT_DEBUG(getNumWorldWonders() >= 0);

		// Extra culture for Wonders (Policies, etc.)
		ChangeJONSCulturePerTurnFromPolicies(GET_PLAYER(getOwner()).GetCulturePerWonder() * iChange);
		if (GetDefensePerWonder() > 0)
		{
			updateStrengthValue();
		}
	}
}


//	--------------------------------------------------------------------------------
int CvCity::getNumTeamWonders() const
{
	VALIDATE_OBJECT();
	return m_iNumTeamWonders;
}


//	--------------------------------------------------------------------------------
void CvCity::changeNumTeamWonders(int iChange)
{
	VALIDATE_OBJECT();
	m_iNumTeamWonders = (m_iNumTeamWonders + iChange);
	ASSERT_DEBUG(getNumTeamWonders() >= 0);
}


//	--------------------------------------------------------------------------------
int CvCity::getNumNationalWonders() const
{
	VALIDATE_OBJECT();
	return m_iNumNationalWonders;
}


//	--------------------------------------------------------------------------------
void CvCity::changeNumNationalWonders(int iChange)
{
	VALIDATE_OBJECT();
	m_iNumNationalWonders = (m_iNumNationalWonders + iChange);
	ASSERT_DEBUG(getNumNationalWonders() >= 0);
}


//	--------------------------------------------------------------------------------
int CvCity::GetWonderProductionModifier() const
{
	VALIDATE_OBJECT();
	return m_iWonderProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvCity::ChangeWonderProductionModifier(int iChange)
{
	VALIDATE_OBJECT();
	m_iWonderProductionModifier = (m_iWonderProductionModifier + iChange);
	ASSERT_DEBUG(GetWonderProductionModifier() >= 0);
}

//	--------------------------------------------------------------------------------
int CvCity::GetLocalResourceWonderProductionMod(BuildingTypes eBuilding, CvString* toolTipSink) const
{
	VALIDATE_OBJECT();
	int iMultiplier = 0;

	ASSERT_DEBUG(eBuilding > -1 && eBuilding < GC.getNumBuildingInfos(), "Invalid building index.");
	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if (pkBuildingInfo)
	{
		// Is this even a wonder?
		const CvBuildingClassInfo& kBuildingClassInfo = pkBuildingInfo->GetBuildingClassInfo();
		if (!::isWorldWonderClass(kBuildingClassInfo) &&
			!::isTeamWonderClass(kBuildingClassInfo) &&
			!::isNationalWonderClass(kBuildingClassInfo))
		{
			return 0;
		}

#if defined(MOD_TRADE_WONDER_RESOURCE_ROUTES)
		// Are we using a trade route to ship the wonder resource from/to this city?
		bool bWonderResourceIn = false;
		bool bWonderResourceOut = false;
		if (MOD_TRADE_WONDER_RESOURCE_ROUTES) {
			CvGameTrade* pGameTrade = GC.getGame().GetGameTrade();
			for (uint ui = 0; ui < pGameTrade->GetNumTradeConnections(); ui++)
			{
				if (pGameTrade->IsTradeRouteIndexEmpty(ui))
				{
					continue;
				}

				if (pGameTrade->GetTradeConnection(ui).m_eConnectionType == TRADE_CONNECTION_WONDER_RESOURCE)
				{
					CvCity* pOriginCity = CvGameTrade::GetOriginCity(pGameTrade->GetTradeConnection(ui));
					CvCity* pDestCity = CvGameTrade::GetDestCity(pGameTrade->GetTradeConnection(ui));

					if (pDestCity->getX() == getX() && pDestCity->getY() == getY())
					{
						ResourceTypes eWonderResource = ::getWonderResource();
						bWonderResourceIn = (eWonderResource != NO_RESOURCE && pOriginCity->GetNumResourceLocal(eWonderResource) > 0);
					}
					else
					{
						if (pOriginCity->getX() == getX() && pOriginCity->getY() == getY())
						{
							bWonderResourceOut = true;
						}
					}

					break;
				}
			}
			// if (bWonderResourceIn) CUSTOMLOG("Shipping a wonder resource into %s", getName().c_str());
			// if (bWonderResourceOut) CUSTOMLOG("Shipping a wonder resource out of %s", getName().c_str());
		}
#endif

		// Resource wonder bonus
		int iTotalBonus = 0;
		for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
		{
			const ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);
			CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
			if (pkResource)
			{
				int iBonus = pkResource->getWonderProductionMod();
				if (iBonus != 0)
				{
					bool bHasLocalResource = IsHasResourceLocal(eResource, /*bTestVisible*/ false);
					if (MOD_TRADE_WONDER_RESOURCE_ROUTES)
					{
						// We're shipping one in, or we're not shipping our only one out, or we have more than one
						bHasLocalResource = bWonderResourceIn || (m_paiNumResourcesLocal[eResource] == 1 && !bWonderResourceOut) || (m_paiNumResourcesLocal[eResource] > 1);
					}

					if (bHasLocalResource)
					{
						// Depends on era of wonder?
						EraTypes eResourceObsoleteEra = pkResource->getWonderProductionModObsoleteEra();
						if (eResourceObsoleteEra != NO_ERA)
						{
							EraTypes eWonderEra;
							TechTypes eTech = (TechTypes)pkBuildingInfo->GetPrereqAndTech();
							if (eTech != NO_TECH)
							{
								CvTechEntry* pEntry = GC.GetGameTechs()->GetEntry(eTech);
								if (pEntry)
								{
									eWonderEra = (EraTypes)pEntry->GetEra();
									if (eWonderEra != NO_ERA)
									{
										if (eWonderEra >= eResourceObsoleteEra)
										{
											continue;
										}
									}
								}
							}
						}

						iTotalBonus += iBonus;
					}
				}
			}
		}
		if (iTotalBonus != 0)
		{
			iMultiplier += iTotalBonus;
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_LOCAL_RES", iTotalBonus, pkBuildingInfo->GetDescription());
		}
	}

	return iMultiplier;
}


//	--------------------------------------------------------------------------------
int CvCity::getCapturePlunderModifier() const
{
	VALIDATE_OBJECT();
	return m_iCapturePlunderModifier;
}


//	--------------------------------------------------------------------------------
void CvCity::changeCapturePlunderModifier(int iChange)
{
	VALIDATE_OBJECT();
	m_iCapturePlunderModifier = (m_iCapturePlunderModifier + iChange);
	ASSERT_DEBUG(m_iCapturePlunderModifier >= 0);
}

//	--------------------------------------------------------------------------------
int CvCity::GetDiplomatInfluenceBoost() const
{
	VALIDATE_OBJECT();
	return m_iDiplomatInfluenceBoost;
}

void CvCity::ChangeDiplomatInfluenceBoost(int iChange)
{
	VALIDATE_OBJECT();
	m_iDiplomatInfluenceBoost += iChange;
}

//	--------------------------------------------------------------------------------
/// Total % rate increase to border growth in this city
int CvCity::GetBorderGrowthRateIncreaseTotal()
{
	int iModifier = GetBorderGrowthRateIncrease() + GET_PLAYER(getOwner()).GetBorderGrowthRateIncreaseGlobal();

	// Religion modifier
	ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
	BeliefTypes eSecondaryPantheon = NO_BELIEF;
	if (eMajority != NO_RELIGION)
	{
		const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
		if (pReligion)
		{
			iModifier += pReligion->m_Beliefs.GetBorderGrowthRateIncreaseGlobal(getOwner(), GET_PLAYER(getOwner()).getCity(GetID()));
			eSecondaryPantheon = GetCityReligions()->GetSecondaryReligionPantheonBelief();
			if (eSecondaryPantheon != NO_BELIEF)
			{
				iModifier += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetBorderGrowthRateIncreaseGlobal();
			}
		}
	}

	// Mod for civs keeping their pantheon belief forever
	if (MOD_RELIGION_PERMANENT_PANTHEON)
	{
		if (GC.getGame().GetGameReligions()->HasCreatedPantheon(getOwner()))
		{
			const CvReligion* pPantheon = GC.getGame().GetGameReligions()->GetReligion(RELIGION_PANTHEON, getOwner());
			BeliefTypes ePantheonBelief = GC.getGame().GetGameReligions()->GetBeliefInPantheon(getOwner());
			if (pPantheon != NULL && ePantheonBelief != NO_BELIEF && ePantheonBelief != eSecondaryPantheon)
			{
				const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eMajority, getOwner());
				if (pReligion == NULL || (pReligion != NULL && !pReligion->m_Beliefs.IsPantheonBeliefInReligion(ePantheonBelief, eMajority, getOwner()))) // check that the our religion does not have our belief, to prevent double counting
				{
					iModifier += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetBorderGrowthRateIncreaseGlobal();
				}
			}
		}
	}

	// Double border growth during GA or WLTKD? These intentionally do not stack with each other, but do stack multiplicatively with other modifiers.
	if ((GET_PLAYER(getOwner()).IsDoubleBorderGrowthGA() && GET_PLAYER(getOwner()).isGoldenAge())
		|| (GET_PLAYER(getOwner()).IsDoubleBorderGrowthWLTKD() && GetWeLoveTheKingDayCounter() > 0))
	{
		iModifier *= 2; // double the extra rate (if any)
		iModifier += 100; // double the base rate
	}

	return iModifier;
}

//	--------------------------------------------------------------------------------
int CvCity::GetBorderGrowthRateIncrease() const
{
	VALIDATE_OBJECT();
	return m_iBorderGrowthRateIncrease;
}


//	--------------------------------------------------------------------------------
void CvCity::ChangeBorderGrowthRateIncrease(int iChange)
{
	VALIDATE_OBJECT();
	m_iBorderGrowthRateIncrease += iChange;
}


//	--------------------------------------------------------------------------------
int CvCity::getPlotCultureCostModifier() const
{
	VALIDATE_OBJECT();
	return m_iPlotCultureCostModifier;
}


//	--------------------------------------------------------------------------------
void CvCity::changePlotCultureCostModifier(int iChange)
{
	VALIDATE_OBJECT();
	m_iPlotCultureCostModifier = (m_iPlotCultureCostModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvCity::getPlotBuyCostModifier() const
{
	VALIDATE_OBJECT();
	return m_iPlotBuyCostModifier;
}


//	--------------------------------------------------------------------------------
void CvCity::changePlotBuyCostModifier(int iChange)
{
	VALIDATE_OBJECT();
	m_iPlotBuyCostModifier = (m_iPlotBuyCostModifier + iChange);
}

#if defined(MOD_BUILDINGS_CITY_WORKING)
//	--------------------------------------------------------------------------------
int CvCity::GetCityWorkingChange() const
{
	VALIDATE_OBJECT();
	return m_iCityWorkingChange;
}

//	--------------------------------------------------------------------------------
void CvCity::changeCityWorkingChange(int iChange)
{
	VALIDATE_OBJECT();
	if (iChange != 0)
	{
		int iOldPlots = GetNumWorkablePlots();
		m_iCityWorkingChange = (m_iCityWorkingChange + iChange);
		int iNewPlots = GetNumWorkablePlots();

		for (int iI = std::min(iOldPlots, iNewPlots); iI < std::max(iOldPlots, iNewPlots); ++iI) {
			CvPlot* pLoopPlot = iterateRingPlots(getX(), getY(), iI);

			if (pLoopPlot) {
				pLoopPlot->changeCityRadiusCount(iChange);
				pLoopPlot->changePlayerCityRadiusCount(getOwner(), iChange);
			}
		}
	}
}
#endif

#if defined(MOD_BUILDINGS_CITY_AUTOMATON_WORKERS)
//	--------------------------------------------------------------------------------
int CvCity::GetCityAutomatonWorkersChange() const
{
	VALIDATE_OBJECT();
	return m_iCityAutomatonWorkersChange;
}

//	--------------------------------------------------------------------------------
void CvCity::changeCityAutomatonWorkersChange(int iChange)
{
	VALIDATE_OBJECT();
	if (iChange != 0)
	{
		changeAutomatons(iChange);

		m_iCityAutomatonWorkersChange = (m_iCityAutomatonWorkersChange + iChange);
	}
}
#endif

//	--------------------------------------------------------------------------------
int CvCity::getHealRate() const
{
	VALIDATE_OBJECT();
	return m_iHealRate;
}

//	--------------------------------------------------------------------------------
void CvCity::changeHealRate(int iChange)
{
	VALIDATE_OBJECT();
	m_iHealRate = (m_iHealRate + iChange);
	ASSERT_DEBUG(getHealRate() >= 0);
}

//	--------------------------------------------------------------------------------
int CvCity::GetEspionageModifier() const
{
	VALIDATE_OBJECT();
	return m_iEspionageModifier;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeEspionageModifier(int iChange)
{
	VALIDATE_OBJECT();
	m_iEspionageModifier = (m_iEspionageModifier + iChange);
}

//	--------------------------------------------------------------------------------
int CvCity::GetSpySecurityModifier() const
{
	VALIDATE_OBJECT();
	return m_iSpySecurityModifier;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeSpySecurityModifier(int iChange)
{
	VALIDATE_OBJECT();
	m_iSpySecurityModifier += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetSpySecurityModifierPerXPop() const
{
	VALIDATE_OBJECT();
	return m_iSpySecurityModifierPerXPop;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeSpySecurityModifierPerXPop(int iChange)
{
	VALIDATE_OBJECT();
	m_iSpySecurityModifierPerXPop = (m_iSpySecurityModifierPerXPop + iChange);
}


fraction CvCity::GetDefensePerWonder() const
{
	VALIDATE_OBJECT();
	return m_fDefensePerWonder;
}
void CvCity::ChangeDefensePerWonder(fraction fChange)
{
	VALIDATE_OBJECT();
	if (fChange != 0)
	{
		m_fDefensePerWonder = m_fDefensePerWonder + fChange;
		updateStrengthValue();
	}
}

#if defined(MOD_RELIGION_CONVERSION_MODIFIERS)
//	--------------------------------------------------------------------------------
int CvCity::GetConversionModifier() const
{
	VALIDATE_OBJECT();
	return m_iConversionModifier;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeConversionModifier(int iChange)
{
	VALIDATE_OBJECT();
	m_iConversionModifier = (m_iConversionModifier + iChange);
}
#endif

//	--------------------------------------------------------------------------------
/// Does this city not produce occupied Unhappiness?
bool CvCity::IsNoOccupiedUnhappiness() const
{
	VALIDATE_OBJECT();
	return GetNoOccupiedUnhappinessCount() > 0;
}

//	--------------------------------------------------------------------------------
/// Does this city not produce occupied Unhappiness?
int CvCity::GetNoOccupiedUnhappinessCount() const
{
	VALIDATE_OBJECT();
	return m_iNoOccupiedUnhappinessCount;
}

//	--------------------------------------------------------------------------------
/// Does this city not produce occupied Unhappiness?
void CvCity::ChangeNoOccupiedUnhappinessCount(int iChange)
{
	VALIDATE_OBJECT();
	if (iChange != 0)
		m_iNoOccupiedUnhappinessCount += iChange;
}

//	--------------------------------------------------------------------------------
/// +x% Food for each follower of the city's majority religion
int CvCity::GetFoodBonusPerCityMajorityFollower() const
{
	VALIDATE_OBJECT();
	return m_iFoodBonusPerCityMajorityFollower;
}

void CvCity::ChangeFoodBonusPerCityMajorityFollower(int iChange)
{
	VALIDATE_OBJECT();
	m_iFoodBonusPerCityMajorityFollower += iChange;
}

#if defined(HH_MOD_BUILDINGS_FRUITLESS_PILLAGE)
//	--------------------------------------------------------------------------------
/// see CvUnit@ CvUnit::pillage()
bool CvCity::IsLocalGainlessPillage() const
{
	VALIDATE_OBJECT();
	return m_iLocalGainlessPillageCount > 0;
}

//	--------------------------------------------------------------------------------
/// How many sources proof this city against the looting from a pillage of its tiles?
void CvCity::ChangeLocalGainlessPillageCount(int iChange)
{
	VALIDATE_OBJECT();
	if (iChange != 0)
		m_iLocalGainlessPillageCount += iChange;
}
#endif
//	--------------------------------------------------------------------------------
int CvCity::getFood() const
{
	VALIDATE_OBJECT();
	return m_iFood / 100;
}

//	--------------------------------------------------------------------------------
int CvCity::getFoodTimes100() const
{
	VALIDATE_OBJECT();
	return m_iFood;
}


//	--------------------------------------------------------------------------------
void CvCity::setFood(int iNewValue)
{
	VALIDATE_OBJECT();
	setFoodTimes100(iNewValue * 100);
}

//	--------------------------------------------------------------------------------
void CvCity::setFoodTimes100(int iNewValue)
{
	VALIDATE_OBJECT();
	if (GetID() == g_iCityToTrace)
	{
		OutputDebugString(CvString::format("Turn %d, food %d, delta %d\n", GC.getGame().getGameTurn(), getFood(), iNewValue / 100 - getFood()).c_str());
	}

	if (getFoodTimes100() != iNewValue)
	{
		m_iFood = max(0, iNewValue);
	}
}


//	--------------------------------------------------------------------------------
void CvCity::changeFood(int iChange)
{
	VALIDATE_OBJECT();
	setFoodTimes100(getFoodTimes100() + 100 * iChange);
}


//	--------------------------------------------------------------------------------
void CvCity::changeFoodTimes100(int iChange)
{
	VALIDATE_OBJECT();
	setFoodTimes100(getFoodTimes100() + iChange);
}

//	--------------------------------------------------------------------------------
int CvCity::getMaxFoodKeptPercent() const
{
	VALIDATE_OBJECT();
	return m_iMaxFoodKeptPercent;
}


//	--------------------------------------------------------------------------------
void CvCity::changeMaxFoodKeptPercent(int iChange)
{
	VALIDATE_OBJECT();
	m_iMaxFoodKeptPercent = (m_iMaxFoodKeptPercent + iChange);
	ASSERT_DEBUG(getMaxFoodKeptPercent() >= 0);
}


//	--------------------------------------------------------------------------------
int CvCity::getOverflowProduction() const
{
	VALIDATE_OBJECT();
	return m_iOverflowProduction / 100;
}


//	--------------------------------------------------------------------------------
void CvCity::setOverflowProduction(int iNewValue)
{
	VALIDATE_OBJECT();
	setOverflowProductionTimes100(iNewValue * 100);
}


//	--------------------------------------------------------------------------------
void CvCity::changeOverflowProduction(int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(iChange >= 0, "Production overflow is too low.");
	changeOverflowProductionTimes100(iChange * 100);
}


//	--------------------------------------------------------------------------------
int CvCity::getOverflowProductionTimes100() const
{
	VALIDATE_OBJECT();
	return m_iOverflowProduction;
}


//	--------------------------------------------------------------------------------
void CvCity::setOverflowProductionTimes100(int iNewValue)
{
	VALIDATE_OBJECT();
	m_iOverflowProduction = iNewValue;
	ASSERT_DEBUG(getOverflowProductionTimes100() >= 0);
}


//	--------------------------------------------------------------------------------
void CvCity::changeOverflowProductionTimes100(int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(iChange >= 0, "Production overflow is too low.");
	setOverflowProductionTimes100(getOverflowProductionTimes100() + iChange);
}


//	--------------------------------------------------------------------------------
int CvCity::getFeatureProduction() const
{
	VALIDATE_OBJECT();
	return m_iFeatureProduction;
}


//	--------------------------------------------------------------------------------
void CvCity::setFeatureProduction(int iNewValue)
{
	VALIDATE_OBJECT();
	m_iFeatureProduction = iNewValue;
	ASSERT_DEBUG(getFeatureProduction() >= 0);
}


//	--------------------------------------------------------------------------------
void CvCity::changeFeatureProduction(int iChange)
{
	VALIDATE_OBJECT();
	setFeatureProduction(getFeatureProduction() + iChange);
}


//	--------------------------------------------------------------------------------
int CvCity::getMilitaryProductionModifier()	const
{
	VALIDATE_OBJECT();
	return m_iMilitaryProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvCity::changeMilitaryProductionModifier(int iChange)
{
	VALIDATE_OBJECT();
	m_iMilitaryProductionModifier = (m_iMilitaryProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvCity::getSpaceProductionModifier() const
{
	VALIDATE_OBJECT();
	return m_iSpaceProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvCity::changeSpaceProductionModifier(int iChange)
{
	VALIDATE_OBJECT();
	m_iSpaceProductionModifier = (m_iSpaceProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvCity::getFreeExperience() const
{
	VALIDATE_OBJECT();
	return m_iFreeExperience;
}


//	--------------------------------------------------------------------------------
void CvCity::changeFreeExperience(int iChange)
{
	VALIDATE_OBJECT();
		m_iFreeExperience = (m_iFreeExperience + iChange);
	ASSERT_DEBUG(getFreeExperience() >= 0);
}

//	--------------------------------------------------------------------------------
bool CvCity::CanAirlift() const
{
	for (int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
	{
		BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iBuildingClassLoop);
		BuildingTypes eBuilding = GetBuildingTypeFromClass(eBuildingClass);
		if (eBuilding == NO_BUILDING)
			continue;

		if (HasBuilding(eBuilding))
		{
			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
			if (pkBuildingInfo && pkBuildingInfo->IsAirlift())
				return true;
		}
	}

	if (MOD_EVENTS_CITY_AIRLIFT)
	{
		if (GAMEEVENTINVOKE_TESTANY(GAMEEVENT_CityCanAirlift, getOwner(), GetID()) == GAMEEVENTRETURN_TRUE)
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
int CvCity::GetMaxAirUnits() const
{
	VALIDATE_OBJECT();
	return m_iMaxAirUnits + GET_PLAYER(getOwner()).getMaxAirUnits();
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeMaxAirUnits(int iChange)
{
	VALIDATE_OBJECT();
	m_iMaxAirUnits += iChange;
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvCity::getCitySupplyModifier() const
{
	VALIDATE_OBJECT();
	return m_iCitySupplyModifier;
}

//	--------------------------------------------------------------------------------
void CvCity::changeCitySupplyModifier(int iChange)
{
	VALIDATE_OBJECT();
	m_iCitySupplyModifier += iChange;
}
//	--------------------------------------------------------------------------------
int CvCity::getCitySupplyFlat() const
{
	VALIDATE_OBJECT();
	return m_iCitySupplyFlat;
}

//	--------------------------------------------------------------------------------
void CvCity::changeCitySupplyFlat(int iChange)
{
	VALIDATE_OBJECT();
	m_iCitySupplyFlat += iChange;
}
//	--------------------------------------------------------------------------------
int CvCity::getDamageReductionFlat() const
{
	VALIDATE_OBJECT();
	return m_iDamageReductionFlat;
}

//	--------------------------------------------------------------------------------
void CvCity::changeDamageReductionFlat(int iChange)
{
	VALIDATE_OBJECT();
	m_iDamageReductionFlat += iChange;
}

void CvCity::SetProductionRoutes(bool bValue)
{
	if (m_bAllowsProductionTradeRoutes != bValue)
	{
		m_bAllowsProductionTradeRoutes = bValue;
	}
}
bool CvCity::IsProductionRoutes() const
{
	return m_bAllowsProductionTradeRoutes;
}

void CvCity::SetFoodRoutes(bool bValue)
{
	if (m_bAllowsFoodTradeRoutes != bValue)
	{
		m_bAllowsFoodTradeRoutes = bValue;
	}
}
bool CvCity::IsFoodRoutes() const
{
	return m_bAllowsFoodTradeRoutes;
}

void CvCity::SetAllowPuppetPurchase(bool bValue)
{
	if (m_bAllowPuppetPurchase != bValue)
	{
		m_bAllowPuppetPurchase = bValue;
	}
}
bool CvCity::IsAllowPuppetPurchase() const
{
	return m_bAllowPuppetPurchase;
}
#endif

//	--------------------------------------------------------------------------------
int CvCity::getNukeModifier() const
{
	VALIDATE_OBJECT();
	return m_iNukeModifier;
}
//	--------------------------------------------------------------------------------
void CvCity::changeNukeModifier(int iChange)
{
	VALIDATE_OBJECT();
	m_iNukeModifier = (m_iNukeModifier + iChange);
}

//	--------------------------------------------------------------------------------
int CvCity::GetTradeRouteTargetBonus() const
{
	VALIDATE_OBJECT();
	return m_iTradeRouteTargetBonus;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeTradeRouteTargetBonus(int iChange)
{
	VALIDATE_OBJECT();
	m_iTradeRouteTargetBonus += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetTradeRouteRecipientBonus() const
{
	VALIDATE_OBJECT();
	return m_iTradeRouteRecipientBonus;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeTradeRouteRecipientBonus(int iChange)
{
	VALIDATE_OBJECT();
	m_iTradeRouteRecipientBonus += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetTradeRouteSeaGoldBonus() const
{
	VALIDATE_OBJECT();
	return m_iTradeRouteSeaGoldBonus;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeTradeRouteSeaGoldBonus(int iChange)
{
	VALIDATE_OBJECT();
	m_iTradeRouteSeaGoldBonus += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetTradeRouteLandGoldBonus() const
{
	VALIDATE_OBJECT();
	return m_iTradeRouteLandGoldBonus;
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeTradeRouteLandGoldBonus(int iChange)
{
	VALIDATE_OBJECT();
	m_iTradeRouteLandGoldBonus += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetNumTradeRouteBonus() const
{
	VALIDATE_OBJECT();
	return m_iNumTradeRouteBonus;
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeNumTradeRouteBonus(int iChange)
{
	VALIDATE_OBJECT();
	m_iNumTradeRouteBonus += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetCityConnectionTradeRouteGoldModifier() const
{
	VALIDATE_OBJECT();
	return m_iCityConnectionTradeRouteGoldModifier;
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeCityConnectionTradeRouteGoldModifier(int iChange)
{
	VALIDATE_OBJECT();
	m_iCityConnectionTradeRouteGoldModifier += iChange;
}

//	--------------------------------------------------------------------------------
bool CvCity::IsResistance() const
{
	VALIDATE_OBJECT();
	return GetResistanceTurns() > 0;
}

//	--------------------------------------------------------------------------------
int CvCity::GetResistanceTurns() const
{
	VALIDATE_OBJECT();
	return m_iResistanceTurns;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeResistanceTurns(int iChange)
{
	VALIDATE_OBJECT();
	if (iChange != 0)
	{
		m_iResistanceTurns += iChange;

		CvInterfacePtr<ICvCity1> pCity = GC.WrapCityPointer(this);
		DLLUI->SetSpecificCityInfoDirty(pCity.get(), CITY_UPDATE_TYPE_BANNER);
	}
}

//	--------------------------------------------------------------------------------
void CvCity::DoResistanceTurn()
{
	VALIDATE_OBJECT();
	if (IsResistance())
	{
		ChangeResistanceTurns(-1);
	}
}

//	--------------------------------------------------------------------------------
bool CvCity::IsRazing() const
{
	VALIDATE_OBJECT();
	return GetRazingTurns() > 0;
}

//	--------------------------------------------------------------------------------
int CvCity::GetRazingTurns() const
{
	VALIDATE_OBJECT();
	return m_iRazingTurns;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeRazingTurns(int iChange)
{
	VALIDATE_OBJECT();
	if (iChange != 0)
	{
		m_iRazingTurns += iChange;

		CvInterfacePtr<ICvCity1> pCity = GC.WrapCityPointer(this);
		DLLUI->SetSpecificCityInfoDirty(pCity.get(), CITY_UPDATE_TYPE_BANNER);
	}
}

//	--------------------------------------------------------------------------------
bool CvCity::DoRazingTurn()
{
	VALIDATE_OBJECT();
	if (IsRazing())
	{
		CvPlayer& kPlayer = GET_PLAYER(getOwner());
		int iPopulationDrop = 1;
		iPopulationDrop *= (100 + kPlayer.GetPlayerTraits()->GetRazeSpeedModifier() + kPlayer.GetRazingSpeedBonus());
		iPopulationDrop /= 100;

		ChangeRazingTurns(-1);
		changePopulation(-iPopulationDrop, true);

		bool bAllowRazingEvents = false;

		//set our lowest 'razing' population so we can't exploit pop growth
		if (getPopulation() < m_iLowestRazingPop)
		{
			m_iLowestRazingPop = getPopulation();
			bAllowRazingEvents = true;
		}

		//don't kill the city on an 'off' turn.
		if (GetRazingTurns() > 0 && getPopulation() <= 0)
			setPopulation(1);

		// Counter has reached 0, disband the City
		if (GetRazingTurns() <= 0 || getPopulation() <= 0)
		{
			CvPlot* pkPlot = plot();

			pkPlot->AddArchaeologicalRecord(CvTypes::getARTIFACT_RAZED_CITY(), getOwner(), getOriginalOwner());

			kPlayer.disband(this);
			GC.getGame().addReplayMessage(REPLAY_MESSAGE_CITY_DESTROYED, getOwner(), "", pkPlot->getX(), pkPlot->getY());
			return true;
		}

#if defined(MOD_BALANCE_CORE)
		PlayerTypes eFormerOwner = getPreviousOwner();
		if (eFormerOwner == NO_PLAYER || eFormerOwner == getOwner() || eFormerOwner == BARBARIAN_PLAYER)
		{
			return false;
		}
		if (GET_PLAYER(eFormerOwner).isMinorCiv() || !GET_PLAYER(eFormerOwner).isAlive())
		{
			return false;
		}

		if (bAllowRazingEvents)
		{
			int iRazeValue = /*175*/ GD_INT_GET(WAR_DAMAGE_LEVEL_CITY_WEIGHT);
			iRazeValue += getPopulation() * /*150*/ GD_INT_GET(WAR_DAMAGE_LEVEL_INVOLVED_CITY_POP_MULTIPLIER);
			iRazeValue += getNumWorldWonders() * /*200*/ GD_INT_GET(WAR_DAMAGE_LEVEL_WORLD_WONDER_MULTIPLIER);
			iRazeValue /= max(1, GetRazingTurns() / 2); // Divide by half the number of turns left until the city is destroyed

			GET_PLAYER(getOwner()).ApplyWarDamage(eFormerOwner, iRazeValue, true, true);

			// Diplomacy penalty for razing cities
			if (GET_PLAYER(getOwner()).isMajorCiv() && GET_PLAYER(eFormerOwner).isMajorCiv())
			{
				int iEra = GET_PLAYER(eFormerOwner).GetCurrentEra();
				if (iEra <= 0)
					iEra = 1;

				GET_PLAYER(eFormerOwner).GetDiplomacyAI()->ChangeCivilianKillerValue(getOwner(), 500 * iEra);
			}

			// Partisans?
			if (MOD_BALANCE_CORE_MILITARY_PROMOTION_ADVANCED && !GET_PLAYER(getOwner()).IsNoPartisans())
			{
				if (GET_PLAYER(getOwner()).GetSpawnCooldown() < 0)
				{
					GET_PLAYER(getOwner()).SetSpawnCooldown(0);
				}
				else
				{
					GET_PLAYER(getOwner()).ChangeSpawnCooldown(-1);
				}

				if (GET_PLAYER(getOwner()).GetSpawnCooldown() > 0)
				{
					return false;
				}

				// Based on city size, but min number scaling with era.
				const int iMinRebels = GC.getGame().getCurrentEra();
				const int iMaxRebels = max(iMinRebels, sqrti(getPopulation()));
				int iNumRebels = GC.getGame().randRangeInclusive(iMinRebels, iMaxRebels, plot()->GetPseudoRandomSeed().mix(GET_PLAYER(getOwner()).GetPseudoRandomSeed()));
				GET_PLAYER(getOwner()).SetSpawnCooldown(iNumRebels * 2);

				if (GET_TEAM(GET_PLAYER(eFormerOwner).getTeam()).isAtWar(getTeam()))
				{
					int iNumRebelSpawned = SpawnPlayerUnitsNearby(eFormerOwner, iNumRebels, true);
					if (iNumRebelSpawned > 0)
					{
						//the former owner hates the razing and wants it back
						if (!GET_PLAYER(eFormerOwner).GetTacticalAI()->IsInFocusArea(plot()))
							GET_PLAYER(eFormerOwner).GetTacticalAI()->AddFocusArea(plot(), 2, /*5*/ GD_INT_GET(AI_TACTICAL_MAP_TEMP_ZONE_TURNS));

						CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
						if (pNotifications)
						{
							Localization::String strMessage(GetLocalizedText("TXT_KEY_NOTIFICATION_PARTISANS_NEAR_RAZING_CITY", getName()));

							Localization::String strSummary(GetLocalizedText("TXT_KEY_NOTIFICATION_PARTISANS_NEAR_RAZING_CITY_S", getName()));
							pNotifications->Add(NOTIFICATION_CITY_REVOLT_POSSIBLE, strMessage.toUTF8(), strSummary.toUTF8(), getX(), getY(), -1);
						}
						CvNotifications* pNotifications2 = GET_PLAYER(eFormerOwner).GetNotifications();
						if (pNotifications2)
						{
							Localization::String strMessage(GetLocalizedText("TXT_KEY_NOTIFICATION_FRIENDLY_PARTISANS_NEAR_RAZING_CITY", getName()));

							Localization::String strSummary(GetLocalizedText("TXT_KEY_NOTIFICATION_FRIENDLY_PARTISANS_NEAR_RAZING_CITY_S", getName()));
							pNotifications2->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), getX(), getY(), -1);
						}
						if (GC.getLogging() && GC.getAILogging())
						{
							CvString strLogString;
							strLogString.Format("Unfriendly Partisans near %s. Number: %d.", getName().c_str(), iNumRebels);
							GET_PLAYER(getOwner()).GetHomelandAI()->LogHomelandMessage(strLogString);
						}
					}
				}
				else if (!GC.getGame().isOption(GAMEOPTION_NO_BARBARIANS) && GC.getGame().getGameTurn() >= GC.getGame().GetBarbarianReleaseTurn())
				{
					CvBarbarians::SpawnBarbarianUnits(plot(), iNumRebels, BARB_SPAWN_PARTISANS);
					CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
					if (pNotifications)
					{
						Localization::String strMessage(GetLocalizedText("TXT_KEY_NOTIFICATION_PARTISANS_NEAR_RAZING_CITY", getName()));

						Localization::String strSummary(GetLocalizedText("TXT_KEY_NOTIFICATION_PARTISANS_NEAR_RAZING_CITY_S", getName()));
						pNotifications->Add(NOTIFICATION_CITY_REVOLT_POSSIBLE, strMessage.toUTF8(), strSummary.toUTF8(), getX(), getY(), -1);
					}
					if (GC.getLogging() && GC.getAILogging())
					{
						CvString strLogString;
						strLogString.Format("Unfriendly Partisans near %s. Number: %d.", getName().c_str(), iNumRebels);
						GET_PLAYER(getOwner()).GetHomelandAI()->LogHomelandMessage(strLogString);
					}
				}
			}
		}
#endif
	}

	return false;
}

/// Has this City been taken from its owner?
//	--------------------------------------------------------------------------------
bool CvCity::IsOccupied() const
{
	VALIDATE_OBJECT();

	// If we're a puppet then we don't count as an occupied city
	if (IsPuppet())
		return false;

	return m_bOccupied;
}

//	--------------------------------------------------------------------------------
/// Has this City been taken from its owner?
void CvCity::SetOccupied(bool bValue)
{
	VALIDATE_OBJECT();
	if (IsOccupied() != bValue)
	{
		m_bOccupied = bValue;
	}
}

//	--------------------------------------------------------------------------------
/// Has this City been turned into a puppet by someone capturing it?
bool CvCity::IsPuppet() const
{
	VALIDATE_OBJECT();
	return m_bPuppet;
}

//	--------------------------------------------------------------------------------
/// Has this City been turned into a puppet by someone capturing it?
void CvCity::SetPuppet(bool bValue)
{
	VALIDATE_OBJECT();
	m_bPuppet = bValue;

	if (bValue)
	{
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityPuppeted, getOwner(), GetID());

		if (IsNoWarmongerYet())
		{
			PlayerTypes eFormerOwner = getPreviousOwner();
			if (eFormerOwner != NO_PLAYER)
			{
				CvDiplomacyAIHelpers::ApplyWarmongerPenalties(this, getOwner(), eFormerOwner);
				SetNoWarmonger(false);
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Turn this City into a puppet
void CvCity::DoCreatePuppet()
{
	VALIDATE_OBJECT();
	if (IsRazing())
		return;

	// Turn this off - used to display info for annex/puppet/raze popup
	SetIgnoreCityForHappiness(false);

	SetPuppet(true);

	setProductionAutomated(true, true);

	// Remove any buildings that are not applicable to puppets (but might have been earned through traits/policies)
	for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
		if (pkBuildingInfo && pkBuildingInfo->IsNoOccupiedUnhappiness())
		{
			SetNumFreeBuilding(eBuilding, 0);
		}
	}

	UpdateAllNonPlotYields(true);

	ResetHappinessFromEmpire();
	GET_PLAYER(getOwner()).CalculateNetHappiness();

	GET_PLAYER(getOwner()).DoUpdateNextPolicyCost();

	DLLUI->setDirty(CityInfo_DIRTY_BIT, true);
	DLLUI->setDirty(GameData_DIRTY_BIT, true);
}

//	--------------------------------------------------------------------------------
/// Un-puppet a City and force it into the empire
void CvCity::DoAnnex(bool bRaze)
{
	VALIDATE_OBJECT();

	if (!bRaze && GET_PLAYER(getOwner()).GetPlayerTraits()->IsNoAnnexing())
	{
		if (!IsPuppet())
			DoCreatePuppet();

		return;
	}

	// Turn this off - used to display info for annex/puppet/raze popup
	if (!isHuman())
		clearOrderQueue();

	// Apply warmongering
	if (IsNoWarmongerYet())
	{
		PlayerTypes eFormerOwner = getPreviousOwner();
		if (eFormerOwner != NO_PLAYER)
		{
			CvDiplomacyAIHelpers::ApplyWarmongerPenalties(this, getOwner(), eFormerOwner);
			SetNoWarmonger(false);
		}
	}

	//Immediate Annex? Bonus for Courthouse
	if (MOD_BALANCE_CORE_BUILDING_INVESTMENTS && !IsPuppet() && !GET_PLAYER(getOwner()).GetPlayerTraits()->IsNoAnnexing())
	{
		for (int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
		{
			const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

			if (pkBuildingInfo && pkBuildingInfo->IsNoOccupiedUnhappiness())
			{
				const BuildingClassTypes eBuildingClass = pkBuildingInfo->GetBuildingClassType();
				if (eBuildingClass != NO_BUILDINGCLASS)
				{
					SetBuildingInvestment(eBuildingClass, true);
				}
			}
		}
		if (IsResistance())
		{
			int iResistanceTurns = GetResistanceTurns();
			iResistanceTurns /= 2;
			ChangeResistanceTurns(-iResistanceTurns);
		}
	}

	SetPuppet(false);

	DoUpdateCheapestPlotInfluenceDistance(); // fix for extremely high cost of the first tile

	setProductionAutomated(false, true);
	UpdateAllNonPlotYields(true);

	if (MOD_API_ACHIEVEMENTS)
	{
		bool bUsingXP1Scenario1 = gDLL->IsModActivated(CIV5_XP1_SCENARIO1_MODID);
		if (!bRaze && !bUsingXP1Scenario1 && GET_PLAYER(getOwner()).isHuman() && getOriginalOwner() != GetID() && GET_PLAYER(getOriginalOwner()).isMinorCiv() && !GC.getGame().isGameMultiPlayer())
		{
			gDLL->UnlockAchievement(ACHIEVEMENT_CITYSTATE_ANNEX);
		}
	}

	// Update happiness
	SetIgnoreCityForHappiness(false);
	if (!bRaze)
		GET_PLAYER(getOwner()).CalculateNetHappiness();

	GET_PLAYER(getOwner()).DoUpdateNextPolicyCost();

	DLLUI->setDirty(CityInfo_DIRTY_BIT, true);
	DLLUI->setDirty(GameData_DIRTY_BIT, true);
}

int CvCity::GetHappinessFromPolicies(int iPopMod) const
{
	int iTotalHappiness = 0;
	CvPlayer& kPlayer = GET_PLAYER(m_eOwner);

	int iHappinessPerGarrison = kPlayer.GetHappinessPerGarrisonedUnit();
	if (iHappinessPerGarrison > 0 && HasGarrison())
	{
		iTotalHappiness += iHappinessPerGarrison;
	}

	int iHappinessPerCityOverStrengthThreshold = kPlayer.GetHappinessPerCityOverStrengthThreshold();
	if (iHappinessPerCityOverStrengthThreshold > 0 && getStrengthValue() >= GD_INT_GET(CITY_STRENGTH_THRESHOLD_FOR_BONUSES) * 100)
	{
		iTotalHappiness += iHappinessPerCityOverStrengthThreshold;
	}

	if (kPlayer.GetHappinessPerXGreatWorks() != 0)
	{
		int iGW = GetCityBuildings()->GetNumGreatWorks();
		iGW /= kPlayer.GetHappinessPerXGreatWorks();
		iTotalHappiness += iGW;
	}

	int iTotalPop = getPopulation() + iPopMod;

	if (MOD_BALANCE_VP)
	{
		int iHappinessPerXPopulationGlobal = kPlayer.GetHappinessPerXPopulationGlobal();

		if (iHappinessPerXPopulationGlobal > 0)
		{
			if (iTotalPop > 0)
			{
				iTotalHappiness += (iTotalPop / iHappinessPerXPopulationGlobal);
			}
		}
	}

	if (isCapital())
	{
		iTotalHappiness += kPlayer.GetPlayerPolicies()->GetNumericModifier(POLICYMOD_EXTRA_HAPPINESS);

		if (!MOD_BALANCE_VP)
		{
			int iHappinessPerXPopulationGlobal = kPlayer.GetHappinessPerXPopulationGlobal();

			if (iHappinessPerXPopulationGlobal > 0)
			{
				if (iTotalPop > 0)
				{
					iTotalHappiness += (iTotalPop / iHappinessPerXPopulationGlobal);
				}
			}
		}

		if (kPlayer.GetExtraHappinessPoliciesFromPolicies() > 0)
		{
			iTotalHappiness += (kPlayer.GetExtraHappinessPoliciesFromPolicies() * kPlayer.GetPlayerPolicies()->GetNumPoliciesOwned()).Truncate();
		}

		// Increase from num policies -- MOVE THIS CODE (and provide a new tool tip string) if we ever get happiness per X policies to something beside a building
		if (kPlayer.GetExtraHappinessPolicies() > 0)
		{
			iTotalHappiness += (kPlayer.GetExtraHappinessPolicies() * kPlayer.GetPlayerPolicies()->GetNumPoliciesOwned()).Truncate();
		}
	}

	if (kPlayer.GetHappfromXSpecialists() > 0)
	{
		int iSpecialistPopulation = GetCityCitizens()->GetTotalSpecialistCount();
		if (iSpecialistPopulation > 0)
		{
			int iHappinessPerPop = /*100*/ GD_INT_GET(UNHAPPINESS_PER_SPECIALIST);
			int iHappinessSpecialists = GET_PLAYER(getOwner()).GetHappfromXSpecialists();

			//Can't give more free happiness than specialists.
			if (iSpecialistPopulation > iHappinessSpecialists)
			{
				iSpecialistPopulation = iHappinessSpecialists;
			}
			if (iSpecialistPopulation > 0 && iHappinessPerPop > 0)
			{
				iSpecialistPopulation *= iHappinessPerPop;
				iSpecialistPopulation /= 100;

				iTotalHappiness += iSpecialistPopulation;
			}
		}
	}

	iTotalHappiness += kPlayer.GetPlayerPolicies()->GetNumericModifier(POLICYMOD_EXTRA_HAPPINESS_PER_CITY) + kPlayer.GetExtraHappinessPerCity();

	int iHappinessPerXPopulation = kPlayer.GetHappinessPerXPopulation();

	if (iHappinessPerXPopulation > 0 && !IsPuppet())
	{
		int iExtraHappiness = iTotalPop / iHappinessPerXPopulation;
		iTotalHappiness += iExtraHappiness;
	}

	if (kPlayer.GetHappinessPerActiveTradeRoute() > 0)
	{
		iTotalHappiness += (kPlayer.GetTrade()->GetNumberOfTradeRoutesFromCity(this) * kPlayer.GetHappinessPerActiveTradeRoute());
	}

	return iTotalHappiness;
}

int CvCity::GetHappinessFromReligion() const
{
	return m_iReligionHappiness;
}
void CvCity::UpdateHappinessFromReligion()
{
	// Follower beliefs
	int iHappinessFromReligion = 0;
	ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
	BeliefTypes eSecondaryPantheon = NO_BELIEF;
	if (eMajority != NO_RELIGION)
	{
		eSecondaryPantheon = GetCityReligions()->GetSecondaryReligionPantheonBelief();

		int iFollowers = GetCityReligions()->GetNumFollowers(eMajority);
		int iBuildingHappiness = 0;

		const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
		if (pReligion)
		{
			iHappinessFromReligion += pReligion->m_Beliefs.GetHappinessPerCity(getPopulation(), getOwner(), GET_PLAYER(getOwner()).getCity(GetID()));
			if (eSecondaryPantheon != NO_BELIEF && getPopulation() >= GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetMinPopulation())
			{
				iHappinessFromReligion += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetHappinessPerCity();
			}
			if (plot()->isRiver())
			{
				iHappinessFromReligion += pReligion->m_Beliefs.GetRiverHappiness(getOwner(), GET_PLAYER(getOwner()).getCity(GetID()));
				if (eSecondaryPantheon != NO_BELIEF)
				{
					iHappinessFromReligion += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetRiverHappiness();
				}
			}

			// Buildings
			const std::vector<BuildingTypes>& vBuildings = GetCityBuildings()->GetAllBuildingsHere();
			for (size_t jJ = 0; jJ < vBuildings.size(); jJ++)
			{
				BuildingTypes eBuilding = vBuildings[jJ];
				CvBuildingEntry* pkInfo = GC.getBuildingInfo(eBuilding);
				if (pkInfo)
				{
					BuildingClassTypes eBuildingClass = pkInfo->GetBuildingClassType();
					iBuildingHappiness += (pReligion->m_Beliefs.GetBuildingClassHappiness(eBuildingClass, iFollowers, getOwner(), this) * GetCityBuildings()->GetNumBuilding(eBuilding));
				}
			}

			iHappinessFromReligion += iBuildingHappiness;

			int iConvertHappiness = pReligion->m_Beliefs.GetFullyConvertedHappiness(getOwner(), this, false);
			if (iConvertHappiness > 0)
			{
				if (GetCityReligions()->GetFollowersOtherReligions(eMajority) <= 0)
					iHappinessFromReligion += iConvertHappiness;
			}
		}
	}

	// Mod for civs keeping their pantheon belief forever
	if (MOD_RELIGION_PERMANENT_PANTHEON)
	{
		if (GC.getGame().GetGameReligions()->HasCreatedPantheon(getOwner()))
		{
			const CvReligion* pPantheon = GC.getGame().GetGameReligions()->GetReligion(RELIGION_PANTHEON, getOwner());
			BeliefTypes ePantheonBelief = GC.getGame().GetGameReligions()->GetBeliefInPantheon(getOwner());
			if (pPantheon != NULL && ePantheonBelief != NO_BELIEF && ePantheonBelief != eSecondaryPantheon)
			{
				const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eMajority, getOwner());
				if (pReligion == NULL || (pReligion != NULL && !pReligion->m_Beliefs.IsPantheonBeliefInReligion(ePantheonBelief, eMajority, getOwner()))) // check that the our religion does not have our belief, to prevent double counting
				{
					iHappinessFromReligion += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetHappinessPerCity();
					if (plot()->isRiver())
					{
						iHappinessFromReligion += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetRiverHappiness();
					}
				}
			}
		}
	}

	m_iReligionHappiness = iHappinessFromReligion;
}

void CvCity::UpdateHappinessFromBuildingClasses()
{
	CvPlayer& kPlayer = GET_PLAYER(getOwner());
	int iTotalHappiness = 0;

	const std::vector<BuildingTypes>& veBuildings = GetCityBuildings()->GetAllBuildingsHere();
	for (vector<BuildingTypes>::const_iterator it = veBuildings.begin(); it != veBuildings.end(); ++it)
	{
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(*it);
		if (!pkBuildingInfo)
			continue;

		BuildingClassTypes eBuildingClass = pkBuildingInfo->GetBuildingClassType();
		int iNumBuilding = GetCityBuildings()->GetNumBuilding(*it);

		// Happiness from policies
		iTotalHappiness += kPlayer.GetPlayerPolicies()->GetBuildingClassHappinessModifier(eBuildingClass) * iNumBuilding;

		// Happiness from local buildings
		for (vector<BuildingTypes>::const_iterator it2 = veBuildings.begin(); it2 != veBuildings.end(); ++it2)
		{
			CvBuildingEntry* pkOtherBuildingInfo = GC.getBuildingInfo(*it2);
			if (!pkOtherBuildingInfo)
				continue;

			BuildingClassTypes eOtherBuildingClass = pkOtherBuildingInfo->GetBuildingClassType();
			int iNumOtherBuilding = GetCityBuildings()->GetNumBuilding(*it2);
			iTotalHappiness += pkBuildingInfo->GetBuildingClassLocalHappiness(eOtherBuildingClass) * iNumBuilding * iNumOtherBuilding;
		}

		// Happiness from buildings in all owned cities
		for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
		{
			BuildingTypes eBuildingGlobal = static_cast<BuildingTypes>(iI);
			CvBuildingEntry* pkBuildingInfoGlobal = GC.getBuildingInfo(eBuildingGlobal);
			if (!pkBuildingInfoGlobal)
				continue;

			int iNumBuildingGlobal = kPlayer.getNumBuildings(eBuildingGlobal);

			// Buildings in non-Venice puppets don't provide happiness
			bool bVenice = kPlayer.GetPlayerTraits()->IsNoAnnexing();
			if (MOD_BALANCE_CORE_PUPPET_CHANGES && !bVenice)
				iNumBuildingGlobal -= kPlayer.getNumBuildingsInPuppets(eBuildingGlobal);

			iTotalHappiness += pkBuildingInfoGlobal->GetBuildingClassHappiness(eBuildingClass) * iNumBuildingGlobal * iNumBuilding;
		}
	}

	m_iBuildingClassHappiness = iTotalHappiness;
}

int CvCity::GetHappinessFromBuildingClasses() const
{
	return m_iBuildingClassHappiness;
}
//	--------------------------------------------------------------------------------
int CvCity::GetLocalHappiness(int iPopMod, bool bExcludeEmpireContributions) const
{
	if (MOD_BALANCE_VP)
	{
		// Puppets produce no Happiness (except Venice)
		if (CityStrategyAIHelpers::IsTestCityStrategy_IsPuppetAndAnnexable(this))
			return 0;

		if (IsRazing() || IsResistance() || (IsOccupied() && !IsNoOccupiedUnhappiness()))
			return 0;
	}

	CvPlayer& kPlayer = GET_PLAYER(getOwner());
	int iLocalHappiness = 0;

	if (!bExcludeEmpireContributions)
		iLocalHappiness += GetHappinessFromEmpire();

	iLocalHappiness += GetBaseHappinessFromBuildings() + GetHappinessFromBuildingClasses();
	iLocalHappiness += GetHappinessFromPolicies(iPopMod);
	iLocalHappiness += GetHappinessFromReligion();
	iLocalHappiness += GetUnmoddedHappinessFromBuildings(); // misc. happiness

	if (isCapital())
	{
		if (MOD_BALANCE_VP && GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && kPlayer.isHuman())
			iLocalHappiness += kPlayer.getHandicapInfo().getHappinessDefaultCapital() * 2;
		else if (kPlayer.isHuman())
			iLocalHappiness += kPlayer.getHandicapInfo().getHappinessDefaultCapital();
		else
			iLocalHappiness += kPlayer.getHandicapInfo().getHappinessDefaultCapital() + GC.getGame().getHandicapInfo().getAIHappinessDefaultCapital();
	}

	if (MOD_BALANCE_CORE_JFD)
	{
		int iCrime = GetYieldFromCrime(YIELD_JFD_CRIME);
		int iDevelopment = GetYieldFromDevelopment(YIELD_JFD_CRIME);
		iLocalHappiness += iCrime + iDevelopment;
	}

	return iLocalHappiness;
}

CvString CvCity::GetCityHappinessBreakdown()
{
	CvPlayer& kPlayer = GET_PLAYER(m_eOwner);

	// Puppets produce no Happiness (except Venice)
	if (CityStrategyAIHelpers::IsTestCityStrategy_IsPuppetAndAnnexable(this))
		return GetLocalizedText("TXT_KEY_EO_CITY_LOCAL_HAPPINESS_EXPLANATION_PUPPET");

	if (IsRazing() || IsResistance() || (IsOccupied() && !IsNoOccupiedUnhappiness()))
		return GetLocalizedText("TXT_KEY_EO_CITY_LOCAL_HAPPINESS_EXPLANATION_PUPPET");

	int iEmpire = GetHappinessFromEmpire();
	int iBuildings = GetBaseHappinessFromBuildings() + GetHappinessFromBuildingClasses();
	int iPolicies = GetHappinessFromPolicies();
	int iReligion = GetHappinessFromReligion();
	int iOther = GetUnmoddedHappinessFromBuildings(); // misc. happiness
	int iHandicap = 0;
	if (isCapital())
	{
		if (MOD_BALANCE_VP && kPlayer.isHuman() && GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE))
			iHandicap += kPlayer.getHandicapInfo().getHappinessDefaultCapital() * 2;
		else if (kPlayer.isHuman())
			iHandicap += kPlayer.getHandicapInfo().getHappinessDefaultCapital();
		else
			iHandicap += kPlayer.getHandicapInfo().getHappinessDefaultCapital() + GC.getGame().getHandicapInfo().getAIHappinessDefaultCapital();
	}

	int iTotal = iEmpire + iBuildings + iPolicies + iReligion + iOther + iHandicap;

	CvString strTooltip = GetLocalizedText("TXT_KEY_EO_CITY_LOCAL_HAPPINESS_EXPLANATION");
	strTooltip += "[NEWLINE][NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_LOCAL_HAPPINESS", iTotal);

	if (iEmpire != 0)
		strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_HAPPY_EMPIRE_CBO", iEmpire);
	if (iBuildings != 0)
		strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_HAPPY_BUILDINGS_CBO", iBuildings);
	if (iPolicies != 0)
		strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_HAPPY_POLICY_CBO", iPolicies);
	if (iReligion != 0)
		strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_HAPPY_RELIGION_CBO", iReligion);
	if (iOther != 0)
		strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_HAPPY_OTHER_CBO", iOther);
	if (iHandicap != 0)
		strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_HAPPY_HANDICAP_CBO", iHandicap);

	strTooltip += GetPotentialHappinessWithGrowth();
	return strTooltip;
}

CvString CvCity::GetPotentialHappinessWithGrowth()
{
	int GrowthHappiness = GetPotentialHappinessWithGrowthVal();

	if (GrowthHappiness == 0)
		return "";

	return GetLocalizedText("TXT_KEY_POTENTIAL_HAPPINESS_GROWTH", GrowthHappiness);
}

int CvCity::GetPotentialHappinessWithGrowthVal() const
{
	return GetLocalHappiness(1) - GetLocalHappiness();
}

int CvCity::updateNetHappiness()
{
	CvPlayer& kPlayer = GET_PLAYER(getOwner());
	if (!kPlayer.isMajorCiv())
	{
		m_iHappinessDelta = 0;
		return 0;
	}

	if (IsRazing() || IsResistance())
	{
		m_iHappinessDelta = -getPopulation();
		return m_iHappinessDelta;
	}
	else if (IsPuppet() && (!MOD_BALANCE_VP || !kPlayer.GetPlayerTraits()->IsNoAnnexing()))
	{
		m_iHappinessDelta = 0;
		return 0;
	}

	m_iHappinessDelta = GetLocalHappiness() - GetUnhappinessAggregated();
	return m_iHappinessDelta;
}

int CvCity::getUnhappinessFromSpecialists(int iSpecialists) const
{
	CvPlayer& kPlayer = GET_PLAYER(getOwner());

	float iUnhappinessPerPop = 0;
	//Less unhappiness from specialists....
	if (MOD_BALANCE_VP)
	{
		iUnhappinessPerPop = (float)/*100*/ GD_INT_GET(UNHAPPINESS_PER_SPECIALIST);
		int iNoHappinessSpecialists = 0;
		if (iSpecialists > 0)
		{
			//...in capital?
			if (isCapital())
			{
				iNoHappinessSpecialists += kPlayer.GetNoUnhappfromXSpecialistsCapital();
			}
			//...elsewhere?	
			iNoHappinessSpecialists += kPlayer.GetNoUnhappfromXSpecialists() + GetNoUnhappfromXSpecialists();
		}
		//Can't give more free happiness than specialists.
		if (iNoHappinessSpecialists > iSpecialists)
		{
			iNoHappinessSpecialists = iSpecialists;
		}
		if (iNoHappinessSpecialists > 0)
		{
			iSpecialists -= iNoHappinessSpecialists;
		}
	}

	// No Unhappiness from Specialist Pop? (Policies, etc.)
	if (kPlayer.isHalfSpecialistUnhappiness())
	{
		iSpecialists++; // Round up
		iSpecialists /= 2;
	}

	return (int)(iSpecialists * iUnhappinessPerPop) / 100;
}

int CvCity::GetUnhappinessAggregated() const
{
	int iUnhappiness = 0;
	int iPopulation = getPopulation();

	if (IsRazing() || IsResistance())
	{
		return iPopulation;
	}
	else if (IsPuppet())
	{
		int iSpecialists = GetCityCitizens()->GetTotalSpecialistCount();
		return getUnhappinessFromSpecialists(iSpecialists) + (iPopulation / max(1, /*4*/ GD_INT_GET(UNHAPPINESS_PER_X_PUPPET_CITIZENS)));
	}

	if (MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS)
		iPopulation = INT_MAX;

	// Some of these calls are expensive, so avoid doing them if we've already reached the cap
	// Order is also nonstandard to save on performance
	int iSource = GetUnhappinessFromOccupation();
	if (iSource > 0)
		iUnhappiness += iSource;

	if (iUnhappiness < iPopulation)
	{
		iSource = GetUnhappinessFromEmpire();
		if (iSource > 0)
			iUnhappiness += iSource;
	}

	if (iUnhappiness < iPopulation)
	{
		iSource = GetUnhappinessFromIsolation();
		if (iSource > 0)
			iUnhappiness += iSource;
	}

	if (iUnhappiness < iPopulation)
	{
		iSource = GetUnhappinessFromReligiousUnrest();
		if (iSource > 0)
			iUnhappiness += iSource;
	}

	if (iUnhappiness < iPopulation)
	{
		iSource = GetUnhappinessFromPillagedTiles();
		if (iSource > 0)
			iUnhappiness += iSource;
	}

	if (iUnhappiness < iPopulation)
	{
		iSource = GetPoverty(false);
		if (iSource > 0)
			iUnhappiness += iSource;
	}

	if (iUnhappiness < iPopulation)
	{
		iSource = GetIlliteracy(false);
		if (iSource > 0)
			iUnhappiness += iSource;
	}

	if (iUnhappiness < iPopulation)
	{
		iSource = GetBoredom(false);
		if (iSource > 0)
			iUnhappiness += iSource;
	}

	if (iUnhappiness < iPopulation)
	{
		iSource = GetUnhappinessFromFamine();
		if (iSource > 0)
			iUnhappiness += iSource;
	}

	if (iUnhappiness < iPopulation)
	{
		iSource = GetDistress(false);
		if (iSource > 0)
			iUnhappiness += iSource;
	}

	// Unhappiness is capped at city population (except specialists)
	if (iUnhappiness > iPopulation)
		iUnhappiness = iPopulation;

	iSource = getUnhappinessFromSpecialists(GetCityCitizens()->GetTotalSpecialistCount());
	if (iSource > 0)
		iUnhappiness += iSource;

	return iUnhappiness;
}

CvString CvCity::getPotentialUnhappinessWithGrowth()
{
	int Distress = GetDistress(true) - GetDistress(false);
	int Poverty = GetPoverty(true) - GetPoverty(false);
	int Illiteracy = GetIlliteracy(true) - GetIlliteracy(false);
	int Boredom = GetBoredom(true) - GetBoredom(false);

	if (Distress == 0 && Poverty == 0 && Illiteracy == 0 && Boredom == 0)
		return "";

	CvString strTooltip = GetLocalizedText("TXT_KEY_POTENTIAL_UNHAPPINESS_GROWTH");

	if (Distress != 0)
	{
		if (Distress > 0)
			strTooltip = strTooltip + GetLocalizedText("TXT_KEY_POTENTIAL_UNHAPPINESS_DEFENSE", Distress);
		else
			strTooltip = strTooltip + GetLocalizedText("TXT_KEY_POTENTIAL_UNHAPPINESS_DEFENSE_POS", Distress);
	}
	if (Poverty != 0)
	{
		if (Poverty > 0)
			strTooltip = strTooltip + GetLocalizedText("TXT_KEY_POTENTIAL_UNHAPPINESS_GOLD", Poverty);
		else
			strTooltip = strTooltip + GetLocalizedText("TXT_KEY_POTENTIAL_UNHAPPINESS_GOLD_POS", Poverty);
	}
	if (Illiteracy != 0)
	{
		if (Illiteracy > 0)
			strTooltip = strTooltip + GetLocalizedText("TXT_KEY_POTENTIAL_UNHAPPINESS_SCIENCE", Illiteracy);
		else
			strTooltip = strTooltip + GetLocalizedText("TXT_KEY_POTENTIAL_UNHAPPINESS_SCIENCE_POS", Illiteracy);
	}
	if (Boredom != 0)
	{
		if (Boredom > 0)
			strTooltip = strTooltip + GetLocalizedText("TXT_KEY_POTENTIAL_UNHAPPINESS_CULTURE", Boredom);
		else
			strTooltip = strTooltip + GetLocalizedText("TXT_KEY_POTENTIAL_UNHAPPINESS_CULTURE_POS", Boredom);
	}

	return strTooltip;
}

int CvCity::getPotentialUnhappinessWithGrowthVal() const
{
	int Distress = GetDistress(true) - GetDistress(false);
	int Poverty = GetPoverty(true) - GetPoverty(false);
	int Illiteracy = GetIlliteracy(true) - GetIlliteracy(false);
	int Boredom = GetBoredom(true) - GetBoredom(false);

	return Distress + Poverty + Illiteracy + Boredom;
}

int CvCity::GetNumPillagedPlots() const
{
	return m_iPillagedPlots;
}
void CvCity::SetNumPillagedPlots(int iValue)
{
	if (m_iPillagedPlots != iValue)
	{
		m_iPillagedPlots = iValue;
		if (m_iPillagedPlots <= 0)
		{
			m_iPillagedPlots = 0;
		}
	}
}
void CvCity::ChangeNumPillagedPlots(int iValue)
{
	if (iValue != 0)
	{
		m_iPillagedPlots += iValue;
		if (m_iPillagedPlots <= 0)
		{
			m_iPillagedPlots = 0;
		}
	}
}

int CvCity::GetGrowthFromEvent() const
{
	return m_iGrowthEvent;
}
void CvCity::ChangeGrowthFromEvent(int iValue)
{
	m_iGrowthEvent += iValue;
}

int CvCity::GetEventGPPFromSpecialists() const
{
	return m_iEventGPPFromSpecialists;
}
void CvCity::ChangeEventGPPFromSpecialists(int iValue)
{
	m_iEventGPPFromSpecialists += iValue;
}

// as we can have multiple events that change "EventGPPFromSpecialists", we keep track of their expiry dates. this function is called when a new event is started
void CvCity::AddEventGPPFromSpecialistsCounter(int iExpiryTurn, int iGPP)
{
	// hack: if iGPP > 1, just add multiple items to the list
	for (int i = 0; i < iGPP; i++)
	{
		m_vEventGPPFromSpecialistsExpiryTurns.push_back(iExpiryTurn);
		ChangeEventGPPFromSpecialists(1);
	}
}

// as we can have multiple events that change "EventGPPFromSpecialists", we keep track of their expiry dates. this function is called every turn, updates turn times and cancels all events that have expired
void CvCity::UpdateEventGPPFromSpecialistsCounters()
{
	for (std::vector<int>::iterator it = m_vEventGPPFromSpecialistsExpiryTurns.begin(); it != m_vEventGPPFromSpecialistsExpiryTurns.end(); )
	{
		int iTurnsLeft= (*it);
		iTurnsLeft--;
		(*it) = iTurnsLeft;
		if (iTurnsLeft == 0)
		{
			// remove element from list
			it = m_vEventGPPFromSpecialistsExpiryTurns.erase(it);
			ChangeEventGPPFromSpecialists(-1);
			CvNotifications* pNotifications = GET_PLAYER(m_eOwner).GetNotifications();
			if (pNotifications)
			{
				Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_GPP_EVENT_ENDED");
				strText << getNameKey();
				Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_GPP_EVENT_ENDED_S");
				strSummary << getNameKey();
				pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), -1);
			}
		}
		else
		{
			++it;
		}
	}
}



int CvCity::GetGrowthFromTourism() const
{
	return m_iGrowthFromTourism;
}
void CvCity::SetGrowthFromTourism(int iValue)
{
	if (m_iGrowthFromTourism != iValue)
	{
		m_iGrowthFromTourism = iValue;
	}
}
void CvCity::ChangeGrowthFromTourism(int iValue)
{
	if (iValue != 0)
	{
		m_iGrowthFromTourism += iValue;
		if (m_iGrowthFromTourism <= 0)
		{
			m_iGrowthFromTourism = 0;
		}
	}
}
void CvCity::UpdateGrowthFromTourism()
{
	int iTotalGrowth = 0;
	CvGameTrade* pGameTrade = GC.getGame().GetGameTrade();
	for (uint ui = 0; ui < pGameTrade->GetNumTradeConnections(); ui++)
	{
		if (pGameTrade->IsTradeRouteIndexEmpty(ui))
		{
			continue;
		}

		if (pGameTrade->GetTradeConnection(ui).m_eConnectionType != TRADE_CONNECTION_INTERNATIONAL)
			continue;

		if (CvGameTrade::GetOriginCity(pGameTrade->GetTradeConnection(ui)) != this)
			continue;

		CvCity* pDestCity = CvGameTrade::GetDestCity(pGameTrade->GetTradeConnection(ui));

		if (pDestCity->getOwner() != NO_PLAYER && GET_PLAYER(pDestCity->getOwner()).isMajorCiv())
		{
			int iGrowthTourism = GET_PLAYER(getOwner()).GetCulture()->GetInfluenceTradeRouteGrowthBonus(pDestCity->getOwner());
			if (iGrowthTourism != 0)
			{
				iTotalGrowth += iGrowthTourism;
			}
		}
	}
	SetGrowthFromTourism(iTotalGrowth);
}
int CvCity::getHappinessDelta() const
{
	return m_iHappinessDelta;
}

//	--------------------------------------------------------------------------------
/// Sum up modifier increases/decreases which apply to all yields
/// Use bForceRecalc when estimating needs after city growth
int CvCity::GetAllNeedsModifier(bool bForceRecalc) const
{
	CvPlayer& kPlayer = GET_PLAYER(getOwner());

	// Increase from being the capital
	int iModifier = isCapital() ? /*25*/ GD_INT_GET(CAPITAL_NEED_MODIFIER) : 0;

	// Increase from tech
	iModifier += bForceRecalc ? kPlayer.GetTechNeedModifier() : GetCachedTechNeedModifier();

	// Decrease from city size
	iModifier += GetCitySizeModifier();

	// Increase from empire size
	iModifier += GetReducedEmpireSizeModifier(bForceRecalc, false);

	// Modifier from difficulty level
	iModifier += kPlayer.isHuman() ? kPlayer.getHandicapInfo().getPopulationUnhappinessMod() : kPlayer.getHandicapInfo().getPopulationUnhappinessMod() + GC.getGame().getHandicapInfo().getAIPopulationUnhappinessMod();

	// Decrease from Carnival (Brazil UA)
	if (GetWeLoveTheKingDayCounter() > 0)
		iModifier += kPlayer.GetPlayerTraits()->GetWLTKDUnhappinessNeedsMod();

	// Decrease from air units that are based here (policy)
	if (kPlayer.GetNeedsModifierFromAirUnits() != 0)
		iModifier += plot()->countNumAirUnits(getTeam(), true) * kPlayer.GetNeedsModifierFromAirUnits() * -1;

	return iModifier;
}

int CvCity::GetCitySizeModifier() const
{
	return getPopulation() * /*0*/ GD_INT_GET(CITY_SIZE_NEED_MODIFIER) / 100;
}

int CvCity::GetEmpireSizeModifier() const
{
	// x% per city, excluding puppets and the capital
	int iNumCitiesMod = (GET_PLAYER(getOwner()).getNumCities() - GET_PLAYER(getOwner()).GetNumPuppetCities() - 1) * /*500*/ GD_INT_GET(EMPIRE_SIZE_NEED_MODIFIER_CITIES) / 100;
	if (iNumCitiesMod < 0)
		iNumCitiesMod = 0;

	// x% per empire pop, excluding puppets
	int iLoop = 0;
	int iPopMod = 0;
	for (CvCity* pLoopCity = GET_PLAYER(getOwner()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(getOwner()).nextCity(&iLoop))
	{
		if (pLoopCity->IsPuppet())
			continue;

		iPopMod += pLoopCity->getPopulation();
	}
	iPopMod *= /*125*/ GD_INT_GET(EMPIRE_SIZE_NEED_MODIFIER_POP);
	iPopMod /= 1000;
	if (iPopMod < 0)
		iPopMod = 0;

	int iEmpireMod = iNumCitiesMod + iPopMod;

	// Scale with map size
	iEmpireMod *= std::min(100, GC.getMap().getWorldInfo().getNumCitiesUnhappinessPercent());
	iEmpireMod /= 100;

	// Difficulty level can modify this
	iEmpireMod *= GET_PLAYER(getOwner()).isHuman() ? 100 + GET_PLAYER(getOwner()).getHandicapInfo().getEmpireSizeUnhappinessMod() : 100 + GET_PLAYER(getOwner()).getHandicapInfo().getEmpireSizeUnhappinessMod() + GC.getGame().getHandicapInfo().getAIEmpireSizeUnhappinessMod();
	iEmpireMod /= 100;

	return range(iEmpireMod, 0, /*100000*/ GD_INT_GET(EMPIRE_SIZE_NEED_MODIFIER_CAP));
}

int CvCity::GetReducedEmpireSizeModifier(bool bForceRecalc, bool bCityOnly) const
{
	int iEmpireMod = bForceRecalc ? GetEmpireSizeModifier() : GetCachedEmpireSizeModifier();
	int iReduction = GetEmpireSizeModifierReduction(); // negative
	if (!bCityOnly)
		iReduction += GET_PLAYER(getOwner()).GetEmpireSizeModifierReductionGlobal(); // negative

	return range(iEmpireMod + iReduction, 0, iEmpireMod);
}

/// Sum up modifier increases/decreases which are specific to a particular yield
int CvCity::GetNeedModifierForYield(YieldTypes eYield) const
{
	CvPlayer& kPlayer = GET_PLAYER(getOwner());
	int iModifier = 0;

	// Distress = Production + Food, but because Food has a process (Farming), change eYield here for compatibility below
	if (eYield == YIELD_PRODUCTION)
		eYield = YIELD_FOOD;

	switch (eYield)
	{
	case YIELD_FOOD:
	{
		iModifier += GetBasicNeedsMedianModifier(); // Local modifier to the median
		iModifier += kPlayer.GetBasicNeedsMedianModifierGlobal(); // Global modifier to the median
		break;
	}
	case YIELD_GOLD:
	{
		iModifier += GetGoldMedianModifier(); // Local modifier to the median
		iModifier += kPlayer.GetGoldMedianModifierGlobal(); // Global modifier to the median
		break;
	}
	case YIELD_SCIENCE:
	{
		iModifier += GetScienceMedianModifier(); // Local modifier to the median
		iModifier += kPlayer.GetScienceMedianModifierGlobal(); // Global modifier to the median
		break;
	}
	case YIELD_CULTURE:
	{
		iModifier += GetCultureMedianModifier(); // Local modifier to the median
		iModifier += kPlayer.GetCultureMedianModifierGlobal(); // Global modifier to the median
		break;
	}
	case YIELD_FAITH:
	{
		iModifier += GetReligiousUnrestModifier(); // Local modifier
		iModifier += kPlayer.GetReligiousUnrestModifierGlobal(); // Global modifier
		break;
	}
	default: // Invalid input
		return 0;
	}

	// Is there a process running which reduces unhappiness for this need?
	if (getProductionProcess() != NO_PROCESS)
	{
		CvProcessInfo* pkProcessInfo = GC.getProcessInfo(getProductionProcess());
		if (pkProcessInfo)
		{
			iModifier += (pkProcessInfo->getProductionToYieldModifier(eYield) + GetYieldFromProcessModifier(eYield)) * -1;
		}
	}

	return iModifier;
}

int CvCity::GetTotalNeedModifierForYield(YieldTypes eYield, bool bForceRecalc) const
{
	return GetAllNeedsModifier(bForceRecalc) + GetNeedModifierForYield(eYield);
}

/// Sum up modifier increases/decreases that are local to this city
int CvCity::GetCityNeedModifierForYield(YieldTypes eYield) const
{
	CvPlayer& kPlayer = GET_PLAYER(getOwner());

	// Increase from being the capital
	int iModifier = isCapital() ? /*25*/ GD_INT_GET(CAPITAL_NEED_MODIFIER) : 0;

	// Decrease from city size
	iModifier += GetCitySizeModifier();

	// Local decrease of empire size modifier
	iModifier -= GetEmpireSizeModifier() - GetReducedEmpireSizeModifier(false, true);

	// Decrease from Carnival (Brazil UA)
	if (GetWeLoveTheKingDayCounter() > 0)
		iModifier += kPlayer.GetPlayerTraits()->GetWLTKDUnhappinessNeedsMod();

	// Decrease from air units that are based here (policy)
	if (kPlayer.GetNeedsModifierFromAirUnits() != 0)
		iModifier += plot()->countNumAirUnits(getTeam(), true) * kPlayer.GetNeedsModifierFromAirUnits() * -1;

	// Distress = Production + Food, but because Food has a process (Farming), change eYield here for compatibility below
	if (eYield == YIELD_PRODUCTION)
		eYield = YIELD_FOOD;

	switch (eYield) // Get the local modifier for this yield
	{
	case YIELD_FOOD:
		iModifier += GetBasicNeedsMedianModifier();
		break;
	case YIELD_GOLD:
		iModifier += GetGoldMedianModifier();
		break;
	case YIELD_SCIENCE:
		iModifier += GetScienceMedianModifier();
		break;
	case YIELD_CULTURE:
		iModifier += GetCultureMedianModifier();
		break;
	case YIELD_FAITH:
		iModifier += GetReligiousUnrestModifier();
		break;
	default:
		return 0;
	}

	// Is there a process running which reduces unhappiness for this need?
	if (getProductionProcess() != NO_PROCESS)
	{
		CvProcessInfo* pkProcessInfo = GC.getProcessInfo(getProductionProcess());
		if (pkProcessInfo)
		{
			iModifier += (pkProcessInfo->getProductionToYieldModifier(eYield) + GetYieldFromProcessModifier(eYield)) * -1;
		}
	}

	return iModifier;
}

CvString CvCity::GetCityUnhappinessBreakdown(bool bIncludeMedian, bool bCityBanner)
{
	int iPopulation = getPopulation();

	if (IsRazing() || IsResistance())
	{
		CvString strTooltip = GetLocalizedText("TXT_KEY_EO_CITY_LOCAL_UNHAPPINESS", iPopulation, GC.getGame().getGameTurn());

		if (bCityBanner)
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_RESISTANCE", iPopulation);
		else
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_RESISTANCE_UNHAPPINESS", iPopulation);

		return strTooltip;
	}
	else if (IsPuppet())
	{
		int iPuppetUnhappiness = iPopulation / max(1, /*4*/ GD_INT_GET(UNHAPPINESS_PER_X_PUPPET_CITIZENS));
		int iSpecialistUnhappiness = getUnhappinessFromSpecialists(GetCityCitizens()->GetTotalSpecialistCount());
		int iTotalUnhappiness = iPuppetUnhappiness + iSpecialistUnhappiness;
		CvString strTooltip = GetLocalizedText("TXT_KEY_EO_CITY_LOCAL_UNHAPPINESS", iTotalUnhappiness, GC.getGame().getGameTurn());

		if (bCityBanner)
		{
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_PUPPET", iPuppetUnhappiness);
			if (iSpecialistUnhappiness != 0)
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_SPECIALIST", iSpecialistUnhappiness);
		}
		else
		{
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_PUPPET_UNHAPPINESS", iPuppetUnhappiness);
			if (iSpecialistUnhappiness != 0)
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_SPECIALIST_UNHAPPINESS", iSpecialistUnhappiness);
		}

		return strTooltip;
	}

	CvWeightedVector<UnhappyReasons> vReasons;
	int iTotalUnhappiness = 0;
	int iSource = 0;

	iSource = GetUnhappinessFromOccupation();
	if (iSource > 0)
	{
		iTotalUnhappiness += iSource;
		vReasons.push_back(UNHAPPY_REASON_OCCUPIED, iSource);
	}

	iSource = GetUnhappinessFromEmpire();
	if (iSource > 0)
	{
		iTotalUnhappiness += iSource;
		vReasons.push_back(UNHAPPY_REASON_EMPIRE, iSource);
	}

	iSource = GetUnhappinessFromFamine();
	if (iSource > 0)
	{
		iTotalUnhappiness += iSource;
		vReasons.push_back(UNHAPPY_REASON_FAMINE, iSource);
	}

	iSource = GetUnhappinessFromPillagedTiles();
	if (iSource > 0)
	{
		iTotalUnhappiness += iSource;
		vReasons.push_back(UNHAPPY_REASON_PILLAGED_TILES, iSource);
	}

	int iDistress = GetDistress(false);
	if (iDistress > 0)
	{
		iTotalUnhappiness += iDistress;
		vReasons.push_back(UNHAPPY_REASON_DISTRESS, iDistress);
	}

	int iPoverty = GetPoverty(false);
	if (iPoverty > 0)
	{
		iTotalUnhappiness += iPoverty;
		vReasons.push_back(UNHAPPY_REASON_POVERTY, iPoverty);
	}

	int iIlliteracy = GetIlliteracy(false);
	if (iIlliteracy > 0)
	{
		iTotalUnhappiness += iIlliteracy;
		vReasons.push_back(UNHAPPY_REASON_ILLITERACY, iIlliteracy);
	}

	int iBoredom = GetBoredom(false);
	if (iBoredom > 0)
	{
		iTotalUnhappiness += iBoredom;
		vReasons.push_back(UNHAPPY_REASON_BOREDOM, iBoredom);
	}

	int iReligiousUnrest = GetUnhappinessFromReligiousUnrest();
	if (iReligiousUnrest > 0)
	{
		iTotalUnhappiness += iReligiousUnrest;
		vReasons.push_back(UNHAPPY_REASON_RELIGIOUS_UNREST, iReligiousUnrest);
	}

	iSource = GetUnhappinessFromIsolation();
	if (iSource > 0)
	{
		iTotalUnhappiness += iSource;
		vReasons.push_back(UNHAPPY_REASON_ISOLATION, iSource);
	}

	// Unhappiness is capped at city population (except specialists)
	if (iTotalUnhappiness > iPopulation && !MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS)
		iTotalUnhappiness = iPopulation;

	iSource = getUnhappinessFromSpecialists(GetCityCitizens()->GetTotalSpecialistCount());
	if (iSource > 0)
	{
		iTotalUnhappiness += iSource;
		vReasons.push_back(UNHAPPY_REASON_URBANIZATION, iSource);
	}

	// Sort sources of Unhappiness from highest to lowest
	vReasons.StableSortItems();

	CvString strTooltip = GetLocalizedText("TXT_KEY_EO_CITY_LOCAL_UNHAPPINESS", iTotalUnhappiness, GetYieldMediansCachedTurn());

	// City Banner Tooltip - Provide only the quick overview
	if (bCityBanner)
	{
		for (int i = 0; i < vReasons.size(); i++)
		{
			UnhappyReasons eReason = vReasons.GetElement(i);
			int iUnhappyCitizens = vReasons.GetWeight(i);

			switch (eReason)
			{
			case UNHAPPY_REASON_RESISTANCE:
				UNREACHABLE(); // Resistance is handled at the start of the function.
			case UNHAPPY_REASON_OCCUPIED:
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_OCCUPATION", iUnhappyCitizens);
				break;
			case UNHAPPY_REASON_EMPIRE:
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_EMPIRE", iUnhappyCitizens);
				break;
			case UNHAPPY_REASON_FAMINE:
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_STARVING", iUnhappyCitizens);
				break;
			case UNHAPPY_REASON_PILLAGED_TILES:
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_PILLAGED", iUnhappyCitizens);
				break;
			case UNHAPPY_REASON_DISTRESS:
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_UNDEFENDED", iUnhappyCitizens);
				break;
			case UNHAPPY_REASON_POVERTY:
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_POOR", iUnhappyCitizens);
				break;
			case UNHAPPY_REASON_ILLITERACY:
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_UNEDUCATED", iUnhappyCitizens);
				break;
			case UNHAPPY_REASON_BOREDOM:
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_UNCULTURED", iUnhappyCitizens);
				break;
			case UNHAPPY_REASON_RELIGIOUS_UNREST:
			{
				CvString strIcon = "";
				ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
				if (eMajority > RELIGION_PANTHEON)
				{
					strIcon = GC.getReligionInfo(eMajority)->GetIconString();
				}
				if (!strIcon.empty())
				{
					strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_RELIGION", iUnhappyCitizens, strIcon);
				}
				break;
			}
			case UNHAPPY_REASON_ISOLATION:
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_UNCONNECTED", iUnhappyCitizens);
				break;
			case UNHAPPY_REASON_URBANIZATION:
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_SPECIALIST", iUnhappyCitizens);
				break;
			}
		}

		strTooltip += getPotentialUnhappinessWithGrowth();
		return strTooltip;
	}

	CvPlayer& kPlayer = GET_PLAYER(getOwner());

	// City View Tooltip - Provide detailed information
	// Always sort as follows: Distress / Poverty / Illiteracy / Boredom / Religious Unrest / Highest Score
	int iDistressRaw = GetDistressRaw(false);
	float fBasicNeedsMedian = 0.00f;
	fBasicNeedsMedian += GetBasicNeedsMedian(false, 0) / 100;

	// Below Basic Needs requirement
	if (iDistressRaw > 0)
	{
		// Reduced By
		int iReduction = GetDistressFlatReduction() + kPlayer.GetDistressFlatReductionGlobal();

		// Total Deficit
		float fAmountNeeded = 0.00f;
		float fAmountHave = 0.00f;
		float fDeficit = 0.00f;
		float fAmountForNextReduction = 0.00f;
		fAmountNeeded += fBasicNeedsMedian * iPopulation;
		fAmountHave += ((float)getYieldRateTimes100(YIELD_FOOD, false, false) + (float)getYieldRateTimes100(YIELD_PRODUCTION, false, false)) / 100;
		fDeficit += fAmountNeeded - fAmountHave;

		// Increase by X for -1 Unhappiness
		fAmountForNextReduction += fBasicNeedsMedian * (iPopulation - iDistressRaw + 1) - fAmountHave;

		strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_DISTRESS_UNHAPPINESS", iDistress, fDeficit, iDistressRaw, iReduction, fAmountForNextReduction);
	}
	// Above Basic Needs requirement
	else
	{
		float fAmountNeeded = 0.00f;
		float fSurplus = 0.00f;
		fAmountNeeded += fBasicNeedsMedian * iPopulation;
		fSurplus += (((float)getYieldRateTimes100(YIELD_FOOD, false, false) + (float)getYieldRateTimes100(YIELD_PRODUCTION, false, false)) / 100) - fAmountNeeded;

		strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_DISTRESS_UNHAPPINESS_SURPLUS", fSurplus);
	}


	int iPovertyRaw = GetPovertyRaw(false);
	float fGoldMedian = 0.00f;
	fGoldMedian += GetGoldMedian(false, 0) / 100;

	// Below Gold requirement
	if (iPovertyRaw > 0)
	{
		// Reduced By
		int iReduction = GetPovertyFlatReduction() + kPlayer.GetPovertyFlatReductionGlobal();

		// Total Deficit
		float fAmountNeeded = 0.00f;
		float fAmountHave = 0.00f;
		float fDeficit = 0.00f;
		float fAmountForNextReduction = 0.00f;
		fAmountNeeded += fGoldMedian * iPopulation;
		fAmountHave += (float)getYieldRateTimes100(YIELD_GOLD, false, false) / 100;
		fDeficit += fAmountNeeded - fAmountHave;

		// Increase by X for -1 Unhappiness
		fAmountForNextReduction += fGoldMedian * (iPopulation - iPovertyRaw + 1) - fAmountHave;

		strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_POVERTY_UNHAPPINESS", iPoverty, fDeficit, iPovertyRaw, iReduction, fAmountForNextReduction);
	}
	// Above Gold requirement
	else
	{
		float fAmountNeeded = 0.00f;
		float fSurplus = 0.00f;
		fAmountNeeded += fGoldMedian * iPopulation;
		fSurplus += ((float)getYieldRateTimes100(YIELD_GOLD, false, false) / 100) - fAmountNeeded;

		strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_POVERTY_UNHAPPINESS_SURPLUS", fSurplus);
	}


	int iIlliteracyRaw = GetIlliteracyRaw(false);
	float fScienceMedian = 0.00f;
	fScienceMedian += GetScienceMedian(false, 0) / 100;

	// Below Science requirement
	if (iIlliteracyRaw > 0)
	{
		// Reduced By
		int iReduction = GetIlliteracyFlatReduction() + kPlayer.GetIlliteracyFlatReductionGlobal();

		// Total Deficit
		float fAmountNeeded = 0.00f;
		float fAmountHave = 0.00f;
		float fDeficit = 0.00f;
		float fAmountForNextReduction = 0.00f;
		fAmountNeeded += fScienceMedian * iPopulation;
		fAmountHave += (float)getYieldRateTimes100(YIELD_SCIENCE, false, false) / 100;
		fDeficit += fAmountNeeded - fAmountHave;

		// Increase by X for -1 Unhappiness
		fAmountForNextReduction += fScienceMedian * (iPopulation - iIlliteracyRaw + 1) - fAmountHave;

		strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_ILLITERACY_UNHAPPINESS", iIlliteracy, fDeficit, iIlliteracyRaw, iReduction, fAmountForNextReduction);
	}
	// Above Science requirement
	else
	{
		float fAmountNeeded = 0.00f;
		float fSurplus = 0.00f;
		fAmountNeeded += fScienceMedian * iPopulation;
		fSurplus += ((float)getYieldRateTimes100(YIELD_SCIENCE, false, false) / 100) - fAmountNeeded;

		strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_ILLITERACY_UNHAPPINESS_SURPLUS", fSurplus);
	}


	int iBoredomRaw = GetBoredomRaw(false);
	float fCultureMedian = 0.00f;
	fCultureMedian += GetCultureMedian(false, 0) / 100;

	// Below Culture requirement
	if (iBoredomRaw > 0)
	{
		// Reduced By
		int iReduction = GetBoredomFlatReduction() + kPlayer.GetBoredomFlatReductionGlobal();

		// Total Deficit
		float fAmountNeeded = 0.00f;
		float fAmountHave = 0.00f;
		float fDeficit = 0.00f;
		float fAmountForNextReduction = 0.00f;
		fAmountNeeded += fCultureMedian * iPopulation;
		fAmountHave += (float)getJONSCulturePerTurn(false);
		fDeficit += fAmountNeeded - fAmountHave;

		// Increase by X for -1 Unhappiness
		fAmountForNextReduction += fCultureMedian * (iPopulation - iBoredomRaw + 1) - fAmountHave;

		strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_BOREDOM_UNHAPPINESS", iBoredom, fDeficit, iBoredomRaw, iReduction, fAmountForNextReduction);
	}
	// Above Culture requirement
	else
	{
		float fAmountNeeded = 0.00f;
		float fSurplus = 0.00f;
		fAmountNeeded += fCultureMedian * iPopulation;
		fSurplus += (float)getJONSCulturePerTurn(false) - fAmountNeeded;

		strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_BOREDOM_UNHAPPINESS_SURPLUS", fSurplus);
	}


	// Religious Unrest
	bool bReligionOff = GC.getGame().isOption(GAMEOPTION_NO_RELIGION);
	CvString strIcon = "";
	if (!bReligionOff)
	{
		ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
		if (eMajority > RELIGION_PANTHEON)
		{
			strIcon = GC.getReligionInfo(eMajority)->GetIconString();
		}
		if (iReligiousUnrest != 0 && !strIcon.empty())
		{
			int iReduction = GetReligiousUnrestFlatReduction() + kPlayer.GetReligiousUnrestFlatReductionGlobal();
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_RELIGIOUS_UNREST_UNHAPPINESS", iReligiousUnrest, strIcon, iReduction);
		}
	}

	// Other Stuff (sort by highest to lowest # of unhappy citizens)
	for (int i = 0; i < vReasons.size(); i++)
	{
		UnhappyReasons eReason = vReasons.GetElement(i);
		int iUnhappyCitizens = vReasons.GetWeight(i);

		switch (eReason)
		{
		case UNHAPPY_REASON_RESISTANCE:
			UNREACHABLE(); // Resistance is handled at the start of the function.
		case UNHAPPY_REASON_DISTRESS:
		case UNHAPPY_REASON_POVERTY:
		case UNHAPPY_REASON_ILLITERACY:
		case UNHAPPY_REASON_BOREDOM:
		case UNHAPPY_REASON_RELIGIOUS_UNREST:
			break; // Already handled above!
		case UNHAPPY_REASON_OCCUPIED:
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_OCCUPATION_UNHAPPINESS", iUnhappyCitizens);
			break;
		case UNHAPPY_REASON_EMPIRE:
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EMPIRE_WIDE_UNHAPPINESS", iUnhappyCitizens);
			break;
		case UNHAPPY_REASON_FAMINE:
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_STARVING_UNHAPPINESS", iUnhappyCitizens);
			break;
		case UNHAPPY_REASON_PILLAGED_TILES:
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_PILLAGED_UNHAPPINESS", iUnhappyCitizens);
			break;
		case UNHAPPY_REASON_ISOLATION:
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_ISOLATION_UNHAPPINESS", iUnhappyCitizens);
			break;
		case UNHAPPY_REASON_URBANIZATION:
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_SPECIALIST_UNHAPPINESS", iUnhappyCitizens);
			break;
		}
	}

	if (bIncludeMedian)
	{
		// Yield Medians (Need Modifier %)
		strTooltip += "[NEWLINE][NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_GLOBAL_MEDIAN_MODS");

		// Basic Needs
		int iTotalDistressModifier = GetTotalNeedModifierForYield(YIELD_FOOD, false);
		if (iTotalDistressModifier > 0)
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_GLOBAL_MEDIAN_BASIC_NEEDS_POS", fBasicNeedsMedian, iTotalDistressModifier);
		else
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_GLOBAL_MEDIAN_BASIC_NEEDS", fBasicNeedsMedian, iTotalDistressModifier);

		// Gold
		int iTotalPovertyModifier = GetTotalNeedModifierForYield(YIELD_GOLD, false);
		if (iTotalPovertyModifier > 0)
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_GLOBAL_MEDIAN_GOLD_POS", fGoldMedian, iTotalPovertyModifier);
		else
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_GLOBAL_MEDIAN_GOLD", fGoldMedian, iTotalPovertyModifier);

		// Science
		int iTotalIlliteracyModifier = GetTotalNeedModifierForYield(YIELD_SCIENCE, false);
		if (iTotalIlliteracyModifier > 0)
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_GLOBAL_MEDIAN_SCIENCE_POS", fScienceMedian, iTotalIlliteracyModifier);
		else
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_GLOBAL_MEDIAN_SCIENCE", fScienceMedian, iTotalIlliteracyModifier);

		// Culture
		int iTotalBoredomModifier = GetTotalNeedModifierForYield(YIELD_CULTURE, false);
		if (iTotalBoredomModifier > 0)
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_GLOBAL_MEDIAN_CULTURE_POS", fCultureMedian, iTotalBoredomModifier);
		else
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_GLOBAL_MEDIAN_CULTURE", fCultureMedian, iTotalBoredomModifier);

		// Religious Unrest (only shows % modifier, and only shows up if city has a majority religion)
		int iTotalReligiousUnrestModifier = bReligionOff ? 0 : GetTotalNeedModifierForYield(YIELD_FAITH, false);
		if (!strIcon.empty())
		{
			float fUnhappyPerMinorityPop = 0.00f;
			fUnhappyPerMinorityPop += /*0.5f*/ GD_FLOAT_GET(UNHAPPINESS_PER_RELIGIOUS_MINORITY_POP);
			fUnhappyPerMinorityPop *= (100 + iTotalReligiousUnrestModifier);
			fUnhappyPerMinorityPop /= 100;
			
			if (iTotalReligiousUnrestModifier > 0)
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_GLOBAL_MEDIAN_RELIGIOUS_UNREST_POS", strIcon, fUnhappyPerMinorityPop, iTotalReligiousUnrestModifier);
			else
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_GLOBAL_MEDIAN_RELIGIOUS_UNREST", strIcon, fUnhappyPerMinorityPop, iTotalReligiousUnrestModifier);
		}

		// Need Modifier Breakdown
		int iCapitalMod = isCapital() ? /*25*/ GD_INT_GET(CAPITAL_NEED_MODIFIER) : 0;
		int iTechMod = GetCachedTechNeedModifier();
		int iCitySize = GetCitySizeModifier();
		int iEmpireSize = GetReducedEmpireSizeModifier(false,false);
		int iDifficultyMod = kPlayer.isHuman() ? kPlayer.getHandicapInfo().getPopulationUnhappinessMod() : kPlayer.getHandicapInfo().getPopulationUnhappinessMod() + GC.getGame().getHandicapInfo().getAIPopulationUnhappinessMod();
		int iCarnivalMod = GetWeLoveTheKingDayCounter() > 0 ? kPlayer.GetPlayerTraits()->GetWLTKDUnhappinessNeedsMod() : 0;
		int iAirUnitsMod = kPlayer.GetNeedsModifierFromAirUnits() != 0 ? plot()->countNumAirUnits(getTeam(), true) * kPlayer.GetNeedsModifierFromAirUnits() * -1 : 0;
		int iTotalMod = iCapitalMod + iTechMod + iCitySize + iEmpireSize + iDifficultyMod + iCarnivalMod + iAirUnitsMod;

		// Process Modifiers
		int iFarmingModifier = 0;
		int iWealthModifier = 0;
		int iResearchModifier = 0;
		int iArtsModifier = 0;
		int iPrayerModifier = 0;
		if (getProductionProcess() != NO_PROCESS)
		{
			CvProcessInfo* pkProcessInfo = GC.getProcessInfo(getProductionProcess());
			if (pkProcessInfo)
			{
				iFarmingModifier = (pkProcessInfo->getProductionToYieldModifier(YIELD_FOOD) + GetYieldFromProcessModifier(YIELD_FOOD)) * -1;
				iWealthModifier = (pkProcessInfo->getProductionToYieldModifier(YIELD_GOLD) + GetYieldFromProcessModifier(YIELD_GOLD)) * -1;
				iResearchModifier = (pkProcessInfo->getProductionToYieldModifier(YIELD_SCIENCE) + GetYieldFromProcessModifier(YIELD_SCIENCE)) * -1;
				iArtsModifier = (pkProcessInfo->getProductionToYieldModifier(YIELD_CULTURE) + GetYieldFromProcessModifier(YIELD_CULTURE)) * -1;
				iPrayerModifier = (pkProcessInfo->getProductionToYieldModifier(YIELD_FAITH) + GetYieldFromProcessModifier(YIELD_FAITH)) * -1;
			}
		}

		// Any misc. modifiers?
		int iExpectedDistressMod = iTotalMod + iFarmingModifier;
		int iExtraDistressMod = iTotalDistressModifier - iExpectedDistressMod;

		int iExpectedPovertyMod = iTotalMod + iWealthModifier;
		int iExtraPovertyMod = iTotalPovertyModifier - iExpectedPovertyMod;

		int iExpectedIlliteracyMod = iTotalMod + iResearchModifier;
		int iExtraIlliteracyMod = iTotalIlliteracyModifier - iExpectedIlliteracyMod;

		int iExpectedBoredomMod = iTotalMod + iArtsModifier;
		int iExtraBoredomMod = iTotalBoredomModifier - iExpectedBoredomMod;

		int iExpectedReligiousUnrestMod = iTotalMod + iPrayerModifier;
		int iExtraReligiousUnrestMod = iTotalReligiousUnrestModifier - iExpectedReligiousUnrestMod;

		// Only show the breakdown if the modifier is non-zero
		if (iTotalMod != 0 || iExtraDistressMod != 0 || iExtraIlliteracyMod != 0 || iExtraBoredomMod != 0 || iExtraReligiousUnrestMod != 0
		|| iFarmingModifier != 0 || iWealthModifier != 0 || iResearchModifier != 0 || iArtsModifier != 0 || iPrayerModifier != 0)
		{
			strTooltip += "[NEWLINE][NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_GLOBAL_MEDIAN_MODS_BREAKDOWN");

			// Is Capital
			if (iCapitalMod != 0)
			{
				if (iCapitalMod > 0)
					strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_CAPITAL_UNHAPPINESS_MOD_POS", iCapitalMod);
				else
					strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_CAPITAL_UNHAPPINESS_MOD", iCapitalMod);
			}

			// Technology
			if (iTechMod != 0)
			{
				if (iTechMod > 0)
					strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_TECH_UNHAPPINESS_MOD_POS", iTechMod);
				else
					strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_TECH_UNHAPPINESS_MOD", iTechMod);
			}

			// City Size
			if (iCitySize != 0)
			{
				if (iCitySize > 0)
					strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_POP_UNHAPPINESS_MOD_POS", iCitySize);
				else
					strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_POP_UNHAPPINESS_MOD", iCitySize);
			}

			// Empire Size
			if (iEmpireSize != 0)
			{
				if (iEmpireSize > 0)
					strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EMPIRE_UNHAPPINESS_MOD_POS", iEmpireSize);
				else
					strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EMPIRE_UNHAPPINESS_MOD", iEmpireSize);
			}

			// Difficulty Level
			if (iDifficultyMod != 0)
			{
				if (iDifficultyMod > 0)
					strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_DIFFICULTY_UNHAPPINESS_MOD_POS", iDifficultyMod);
				else
					strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_DIFFICULTY_UNHAPPINESS_MOD", iDifficultyMod);
			}

			// SPECIAL MODIFIERS

			// Carnival (Brazil UA)
			if (iCarnivalMod != 0)
			{
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_CARNIVAL_UNHAPPINESS_MOD", iCarnivalMod);
			}

			// Air Units (Policy)
			if (iAirUnitsMod != 0)
			{
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_AIR_UNITS_UNHAPPINESS_MOD", iAirUnitsMod);
			}

			// PROCESS MODIFIERS

			if (iFarmingModifier != 0)
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_FARMING_UNHAPPINESS_MOD", iFarmingModifier);

			if (iWealthModifier != 0)
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_WEALTH_UNHAPPINESS_MOD", iWealthModifier);

			if (iResearchModifier != 0)
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_RESEARCH_UNHAPPINESS_MOD", iResearchModifier);

			if (iArtsModifier != 0)
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_ARTS_UNHAPPINESS_MOD", iArtsModifier);

			if (iPrayerModifier != 0 && !strIcon.empty())
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_PRAYER_UNHAPPINESS_MOD", strIcon, iPrayerModifier);

			// OTHER MODIFIERS

			// If all modifiers are off by the same %, we assume it's the same cause (probably a spy event, since building/policy median modifiers are disabled in base VP) and use a special text key.
			if (iExtraDistressMod != 0 && iExtraDistressMod == iExtraPovertyMod && iExtraDistressMod == iExtraIlliteracyMod && iExtraDistressMod == iExtraBoredomMod && iExtraDistressMod == iExtraReligiousUnrestMod)
			{
				if (iExtraDistressMod > 0)
					strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_MISC_UNHAPPINESS_MOD_POS", iExtraDistressMod);
				else
					strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_MISC_UNHAPPINESS_MOD", iExtraDistressMod);
			}
			// Otherwise break it down individually.
			else
			{
				if (iExtraDistressMod != 0)
				{
					if (iExtraDistressMod > 0)
						strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_MISC_DISTRESS_UNHAPPINESS_MOD_POS", iExtraDistressMod);
					else
						strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_MISC_DISTRESS_UNHAPPINESS_MOD", iExtraDistressMod);
				}
				if (iExtraPovertyMod != 0)
				{
					if (iExtraPovertyMod > 0)
						strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_MISC_POVERTY_UNHAPPINESS_MOD_POS", iExtraPovertyMod);
					else
						strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_MISC_POVERTY_UNHAPPINESS_MOD", iExtraPovertyMod);
				}
				if (iExtraIlliteracyMod != 0)
				{
					if (iExtraIlliteracyMod > 0)
						strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_MISC_ILLITERACY_UNHAPPINESS_MOD_POS", iExtraIlliteracyMod);
					else
						strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_MISC_ILLITERACY_UNHAPPINESS_MOD", iExtraIlliteracyMod);
				}
				if (iExtraBoredomMod != 0)
				{
					if (iExtraBoredomMod > 0)
						strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_MISC_BOREDOM_UNHAPPINESS_MOD_POS", iExtraBoredomMod);
					else
						strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_MISC_BOREDOM_UNHAPPINESS_MOD", iExtraBoredomMod);
				}
				if (iExtraReligiousUnrestMod != 0 && !strIcon.empty())
				{
					if (iExtraReligiousUnrestMod > 0)
						strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_MISC_RELIGIOUS_UNREST_UNHAPPINESS_MOD_POS", strIcon, iExtraReligiousUnrestMod);
					else
						strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_MISC_RELIGIOUS_UNREST_UNHAPPINESS_MOD", strIcon, iExtraReligiousUnrestMod);
				}
			}
		}
	}

	strTooltip += getPotentialUnhappinessWithGrowth();
	return strTooltip;
}

//	--------------------------------------------------------------------------------
int CvCity::getUnhappyCitizenCount() const
{
	VALIDATE_OBJECT();
	//if we have more happiness than pop, unhappiness is zero (not negative)
	return max(0,getPopulation() - GetLocalHappiness());
}

//	--------------------------------------------------------------------------------
/// How much Unhappiness is this city generating from Distress?
/// bForceRecalc computes the amount of Distress generated after this city's next growth
int CvCity::GetDistress(bool bForceRecalc, int iAssumedExtraYieldRate) const
{
	if (IsPuppet() || IsResistance() || IsRazing())
		return 0;

	int iDistress = GetDistressRaw(bForceRecalc, iAssumedExtraYieldRate) - GetDistressFlatReduction() - GET_PLAYER(getOwner()).GetDistressFlatReductionGlobal();
	int iPopulation = bForceRecalc ? getPopulation() + 1 : getPopulation();
	int iLimit = MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS ? INT_MAX : iPopulation;
	return range(iDistress, 0, iLimit);
}

int CvCity::GetDistressRaw(bool bForceRecalc, int iAssumedExtraYieldRate) const
{
	// First, calculate the total yield
	// Include yields from trade routes in the yield, but not the median, to make unhappiness management easier
	int iTotalYield = getYieldRateTimes100(YIELD_FOOD, false, false) + getYieldRateTimes100(YIELD_PRODUCTION, false, false) + iAssumedExtraYieldRate;

	// Second, calculate the median (with need modifiers)
	float fMedianYieldPerPop = 0.00f;
	fMedianYieldPerPop += GetBasicNeedsMedian(bForceRecalc, 0);

	// Unhappiness = Population - (Total Yield / Modified Median)
	int iPopulation = bForceRecalc ? getPopulation() + 1 : getPopulation();
	float fDistress = ceil(iPopulation - (iTotalYield / fMedianYieldPerPop));

	int iLimit = MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS ? INT_MAX : iPopulation;
	return range((int)fDistress, 0, iLimit);
}

float CvCity::GetBasicNeedsMedian(bool bForceRecalc, int iAdditionalModifier) const
{
	float fMedianYieldPerPop = 0.00f;
	fMedianYieldPerPop += bForceRecalc ? (float)GC.getGame().GetBasicNeedsMedian() : (float)GetCachedBasicNeedsMedian();
	fMedianYieldPerPop *= (100 + GetTotalNeedModifierForYield(YIELD_PRODUCTION, bForceRecalc) + iAdditionalModifier);
	fMedianYieldPerPop /= 100;
	fMedianYieldPerPop *= /*100*/ std::max(GD_INT_GET(DISTRESS_MEDIAN_BASE_MODIFIER), 0);
	fMedianYieldPerPop /= 100;

	if (fMedianYieldPerPop <= 0.00f)
		return 0.00f;

	return fMedianYieldPerPop;
}

//	--------------------------------------------------------------------------------
/// How much Unhappiness is this city generating from Poverty?
/// bForceRecalc computes the amount of Poverty generated after this city's next growth
int CvCity::GetPoverty(bool bForceRecalc, int iAssumedExtraYieldRate) const
{
	if (IsPuppet() || IsResistance() || IsRazing())
		return 0;

	int iPoverty = GetPovertyRaw(bForceRecalc, iAssumedExtraYieldRate) - GetPovertyFlatReduction() - GET_PLAYER(getOwner()).GetPovertyFlatReductionGlobal();
	int iPopulation = bForceRecalc ? getPopulation() + 1 : getPopulation();
	int iLimit = MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS ? INT_MAX : iPopulation;
	return range(iPoverty, 0, iLimit);
}

int CvCity::GetPovertyRaw(bool bForceRecalc, int iAssumedExtraYieldRate) const
{
	// First, calculate the total yield
	// Include yields from trade routes in the yield, but not the median, to make unhappiness management easier
	int iTotalYield = getYieldRateTimes100(YIELD_GOLD, false, false) + iAssumedExtraYieldRate;

	// Second, calculate the median (with need modifiers)
	float fMedianYieldPerPop = 0.00f;
	fMedianYieldPerPop += GetGoldMedian(bForceRecalc, 0);

	// Unhappiness = Population - (Total Yield / Modified Median)
	int iPopulation = bForceRecalc ? getPopulation() + 1 : getPopulation();
	float fPoverty = ceil(iPopulation - (iTotalYield / fMedianYieldPerPop));

	int iLimit = MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS ? INT_MAX : iPopulation;
	return range((int)fPoverty, 0, iLimit);
}

float CvCity::GetGoldMedian(bool bForceRecalc, int iAdditionalModifier) const
{
	float fMedianYieldPerPop = 0.00f;
	fMedianYieldPerPop += bForceRecalc ? (float)GC.getGame().GetGoldMedian() : (float)GetCachedGoldMedian();
	fMedianYieldPerPop *= (100 + GetTotalNeedModifierForYield(YIELD_GOLD, bForceRecalc) + iAdditionalModifier);
	fMedianYieldPerPop /= 100;
	fMedianYieldPerPop *= /*100*/ std::max(GD_INT_GET(POVERTY_MEDIAN_BASE_MODIFIER), 0);
	fMedianYieldPerPop /= 100;

	if (fMedianYieldPerPop <= 0.00f)
		return 0.00f;

	return fMedianYieldPerPop;
}

//	--------------------------------------------------------------------------------
/// How much Unhappiness is this city generating from Illiteracy?
/// bForceRecalc computes the amount of Illiteracy generated after this city's next growth
int CvCity::GetIlliteracy(bool bForceRecalc, int iAssumedExtraYieldRate) const
{
	if (IsPuppet() || IsResistance() || IsRazing())
		return 0;

	int iIlliteracy = GetIlliteracyRaw(bForceRecalc, iAssumedExtraYieldRate) - GetIlliteracyFlatReduction() - GET_PLAYER(getOwner()).GetIlliteracyFlatReductionGlobal();
	int iPopulation = bForceRecalc ? getPopulation() + 1 : getPopulation();
	int iLimit = MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS ? INT_MAX : iPopulation;
	return range(iIlliteracy, 0, iLimit);
}

int CvCity::GetIlliteracyRaw(bool bForceRecalc, int iAssumedExtraYieldRate) const
{
	// First, calculate the total yield
	// Include yields from trade routes in the yield, but not the median, to make unhappiness management easier
	int iTotalYield = getYieldRateTimes100(YIELD_SCIENCE, false, false) + iAssumedExtraYieldRate;

	// Second, calculate the median (with need modifiers)
	float fMedianYieldPerPop = 0.00f;
	fMedianYieldPerPop += GetScienceMedian(bForceRecalc, 0);

	// Unhappiness = Population - (Total Yield / Modified Median)
	int iPopulation = bForceRecalc ? getPopulation() + 1 : getPopulation();
	float fIlliteracy = ceil(iPopulation - (iTotalYield / fMedianYieldPerPop));

	int iLimit = MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS ? INT_MAX : iPopulation;
	return range((int)fIlliteracy, 0, iLimit);
}

float CvCity::GetScienceMedian(bool bForceRecalc, int iAdditionalModifier) const
{
	float fMedianYieldPerPop = 0.00f;
	fMedianYieldPerPop += bForceRecalc ? (float)GC.getGame().GetScienceMedian() : (float)GetCachedScienceMedian();
	fMedianYieldPerPop *= (100 + GetTotalNeedModifierForYield(YIELD_SCIENCE, bForceRecalc) + iAdditionalModifier);
	fMedianYieldPerPop /= 100;
	fMedianYieldPerPop *= /*100*/ std::max(GD_INT_GET(ILLITERACY_MEDIAN_BASE_MODIFIER), 0);
	fMedianYieldPerPop /= 100;

	if (fMedianYieldPerPop <= 0.00f)
		return 0.00f;

	return fMedianYieldPerPop;
}

//	--------------------------------------------------------------------------------
/// How much Unhappiness is this city generating from Boredom?
/// bForceRecalc computes the amount of Boredom generated after this city's next growth
int CvCity::GetBoredom(bool bForceRecalc, int iAssumedExtraYieldRate) const
{
	if (IsPuppet() || IsResistance() || IsRazing())
		return 0;

	int iBoredom = GetBoredomRaw(bForceRecalc, iAssumedExtraYieldRate) - GetBoredomFlatReduction() - GET_PLAYER(getOwner()).GetBoredomFlatReductionGlobal();
	int iPopulation = bForceRecalc ? getPopulation() + 1 : getPopulation();
	int iLimit = MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS ? INT_MAX : iPopulation;
	return range(iBoredom, 0, iLimit);
}

int CvCity::GetBoredomRaw(bool bForceRecalc, int iAssumedExtraYieldRate) const
{
	// First, calculate the total yield
	// Include yields from trade routes in the yield, but not the median, to make unhappiness management easier
	int iTotalYield = getJONSCulturePerTurn(false) * 100 + iAssumedExtraYieldRate;

	// Second, calculate the median (with need modifiers)
	float fMedianYieldPerPop = 0.00f;
	fMedianYieldPerPop += GetCultureMedian(bForceRecalc, 0);

	// Unhappiness = Population - (Total Yield / Modified Median)
	int iPopulation = bForceRecalc ? getPopulation() + 1 : getPopulation();
	float fBoredom = ceil(iPopulation - (iTotalYield / fMedianYieldPerPop));

	int iLimit = MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS ? INT_MAX : iPopulation;
	return range((int)fBoredom, 0, iLimit);
}

float CvCity::GetCultureMedian(bool bForceRecalc, int iAdditionalModifier) const
{
	float fMedianYieldPerPop = 0.00f;
	fMedianYieldPerPop += bForceRecalc ? (float)GC.getGame().GetCultureMedian() : (float)GetCachedCultureMedian();
	fMedianYieldPerPop *= (100 + GetTotalNeedModifierForYield(YIELD_CULTURE, bForceRecalc) + iAdditionalModifier);
	fMedianYieldPerPop /= 100;
	fMedianYieldPerPop *= /*100*/ std::max(GD_INT_GET(ILLITERACY_MEDIAN_BASE_MODIFIER), 0);
	fMedianYieldPerPop /= 100;

	if (fMedianYieldPerPop <= 0.00f)
		return 0.00f;

	return fMedianYieldPerPop;
}

//	--------------------------------------------------------------------------------
int CvCity::GetUnhappinessFromPillagedTiles() const
{
	if (IsPuppet() || IsResistance() || IsRazing())
		return 0;

	int iPillagedTiles = GetNumPillagedPlots();
	if (iPillagedTiles > 0)
	{
		float fUnhappiness = 0.00f;
		float fUnhappyPerTile = /*0.5f*/ GD_FLOAT_GET(UNHAPPINESS_PER_PILLAGED_TILE);
		fUnhappiness += (float)iPillagedTiles * fUnhappyPerTile;

		int iLimit = MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS ? INT_MAX : getPopulation();
		return range((int)fUnhappiness, 0, iLimit);
	}

	return 0;
}

//	--------------------------------------------------------------------------------
int CvCity::GetUnhappinessFromOccupation() const
{
	if (IsPuppet() || !IsOccupied() || IsNoOccupiedUnhappiness())
		return 0;

	int iPopulation = getPopulation();
	if (!MOD_BALANCE_VP && GET_PLAYER(getOwner()).isHalfSpecialistUnhappiness())
	{
		int iSpecialistCount = GetCityCitizens()->GetTotalSpecialistCount();
		iSpecialistCount++; // Round up
		iPopulation -= (iSpecialistCount / 2);
	}

	float fUnhappiness = 0.00f;
	fUnhappiness += iPopulation * /*1.34f in CP, 1.00f in VP*/ GD_FLOAT_GET(UNHAPPINESS_PER_OCCUPIED_POPULATION);
	if (!MOD_BALANCE_VP)
		fUnhappiness *= 100;

	fUnhappiness *= 100 + GET_PLAYER(getOwner()).GetPlayerTraits()->GetPopulationUnhappinessModifier();
	fUnhappiness /= 100;

	if (HasGarrison())
	{
		fUnhappiness *= 100 + GET_PLAYER(getOwner()).GetGarrisonsOccupiedUnhappinessMod();
		fUnhappiness /= 100;
	}

	if (!MOD_BALANCE_VP)
		return (int)fUnhappiness;

	int iLimit = MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS ? INT_MAX : iPopulation;
	return range((int)fUnhappiness, 0, iLimit);
}

//	--------------------------------------------------------------------------------
int CvCity::GetUnhappinessFromFamine() const
{
	if (IsPuppet() || IsResistance() || IsRazing())
		return 0;

	int iDiff = foodDifference(true);
	if (iDiff < 0 && !isFoodProduction())
	{
		iDiff *= -1;

		float fUnhappiness = 0.00f;
		float fUnhappyPerDeficit = /*1.0f*/ GD_FLOAT_GET(UNHAPPINESS_PER_STARVING_POP);
		fUnhappiness += (float)iDiff * fUnhappyPerDeficit;

		int iLimit = MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS ? INT_MAX : getPopulation();
		return range((int)fUnhappiness, 0, iLimit);
	}

	return 0;
}

//	--------------------------------------------------------------------------------
int CvCity::GetUnhappinessFromReligiousUnrest() const
{
	if (IsPuppet() || IsResistance() || IsRazing() || GC.getGame().isOption(GAMEOPTION_NO_RELIGION))
		return 0;

	//Trait takes away unhappiness from religious strife.
	if (GET_PLAYER(getOwner()).GetPlayerTraits()->IsNoReligiousStrife())
		return 0;

	const CvReligion* pReligion = NULL;
	ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
	if (eMajority > RELIGION_PANTHEON)
	{
		pReligion = GC.getGame().GetGameReligions()->GetReligion(eMajority, getOwner());
	}
	if (pReligion)
	{
		float fUnhappiness = 0.00f;
		int iMajorityReligionFollowers = GetCityReligions()->GetNumFollowers(eMajority);
		int iReligiousMinorities = getPopulation() - iMajorityReligionFollowers;

		if (iReligiousMinorities > 0)
		{
			fUnhappiness += iReligiousMinorities * /*0.5f*/ GD_FLOAT_GET(UNHAPPINESS_PER_RELIGIOUS_MINORITY_POP);
			int iModifier = GetTotalNeedModifierForYield(YIELD_FAITH, false);

			fUnhappiness *= (100 + iModifier);
			fUnhappiness /= 100;

			int iUnhappiness = (int)fUnhappiness - GetReligiousUnrestFlatReduction() - GET_PLAYER(getOwner()).GetReligiousUnrestFlatReductionGlobal();
			int iLimit = MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS ? INT_MAX : getPopulation();
			return range(iUnhappiness, 0, iLimit);
		}
	}

	return 0;
}

//	--------------------------------------------------------------------------------
int CvCity::GetUnhappinessFromIsolation() const
{
	if (IsPuppet() || IsResistance() || IsRazing())
		return 0;

	// No Isolation in the capital
	if (isCapital())
		return 0;

	//Trait takes away unhappiness from Isolation.
	if (GET_PLAYER(getOwner()).GetPlayerTraits()->IsNoConnectionUnhappiness())
		return 0;
	//Policy takes away unhappiness from Isolation.
	if (GET_PLAYER(getOwner()).IsNoUnhappyIsolation())
		return 0;

	//note: it's only connected to the capital if it's not blockaded
	if (IsRouteToCapitalConnected())
		return 0;

	//if we have a trade route to our capital or to another city which has a route to the capital, it's just as good as a route
	int iLoop = 0;
	for (CvCity* pLoopCity = GET_PLAYER(getOwner()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(getOwner()).nextCity(&iLoop))
	{
		if (!pLoopCity)
			continue;

		if (pLoopCity->isCapital() || pLoopCity->IsRouteToCapitalConnected())
		{
			if (HasTradeRouteTo(pLoopCity) || HasTradeRouteFrom(pLoopCity))
				return 0;
		}
	}

	//ok, how much unhappiness do we generate?
	float fUnhappiness = 0.00f;
	if (GD_FLOAT_GET(UNHAPPINESS_PER_ISOLATED_POP) > 0)
	{
		fUnhappiness += (float)getPopulation() * /*0.34f*/ GD_FLOAT_GET(UNHAPPINESS_PER_ISOLATED_POP);
	}

	int iLimit = MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS ? INT_MAX : getPopulation();
	return range((int)fUnhappiness, 0, iLimit);
}

int CvCity::getJFDSpecialUnhappinessSources() const
{
	int iContribution = GetUnhappinessFromFamine();
	iContribution += GetUnhappinessFromPillagedTiles();
	iContribution += GetUnhappinessFromIsolation();

	return iContribution;
}

//	--------------------------------------------------------------------------------
int CvCity::GetHappinessFromBuildings() const
{
	return GetUnmoddedHappinessFromBuildings() + GetBaseHappinessFromBuildings();
}

//	--------------------------------------------------------------------------------
int CvCity::GetBaseHappinessFromBuildings() const
{
	return m_iBaseHappinessFromBuildings;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeBaseHappinessFromBuildings(int iChange)
{
	m_iBaseHappinessFromBuildings += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetUnmoddedHappinessFromBuildings() const
{
	return m_iUnmoddedHappinessFromBuildings;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeUnmoddedHappinessFromBuildings(int iChange)
{
	m_iUnmoddedHappinessFromBuildings += iChange;
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvCity::GetLocalUnhappinessMod() const
{
	return m_iLocalUnhappinessMod;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeLocalUnhappinessMod(int iChange)
{
	m_iLocalUnhappinessMod += iChange;
}
#endif
//	--------------------------------------------------------------------------------
/// Used when gathering info for "Annex/Puppet/Raze" popup
bool CvCity::IsIgnoreCityForHappiness() const
{
	return m_bIgnoreCityForHappiness;
}

//	--------------------------------------------------------------------------------
/// Used when gathering info for "Annex/Puppet/Raze" popup
void CvCity::SetIgnoreCityForHappiness(bool bValue)
{
	m_bIgnoreCityForHappiness = bValue;
}


//	--------------------------------------------------------------------------------
/// Units trained in this city start with additional XP for every golden age started
int CvCity::GetExperiencePerGoldenAge() const
{
	return m_iExperiencePerGoldenAge;
}

//	--------------------------------------------------------------------------------
/// Units trained in this city start with additional XP for every golden age started
void CvCity::ChangeExperiencePerGoldenAge(int iChange)
{
	m_iExperiencePerGoldenAge += iChange;
	ASSERT_DEBUG(m_iExperiencePerGoldenAge >= 0);
}

//	--------------------------------------------------------------------------------
/// Units trained in this city start with additional XP for every golden age started
int CvCity::GetExperiencePerGoldenAgeCap() const
{
	return m_iExperiencePerGoldenAgeCap;
}

//	--------------------------------------------------------------------------------
/// Units trained in this city start with additional XP for every golden age started
void CvCity::ChangeExperiencePerGoldenAgeCap(int iChange)
{
	m_iExperiencePerGoldenAgeCap += iChange;
	ASSERT_DEBUG(m_iExperiencePerGoldenAgeCap >= 0);
}

//	--------------------------------------------------------------------------------
/// Additional XP for Units trained in this city from previous golden ages
int CvCity::GetExperienceFromPreviousGoldenAges() const
{
	return m_iExperienceFromPreviousGoldenAges;
}

//	--------------------------------------------------------------------------------
/// Additional XP for Units trained in this city from previous golden ages
void CvCity::ChangeExperienceFromPreviousGoldenAges(int iChange)
{
	m_iExperienceFromPreviousGoldenAges += iChange;
	ASSERT_DEBUG(m_iExperienceFromPreviousGoldenAges >= 0);
}

//	--------------------------------------------------------------------------------
/// Find the non-wonder building that provides the highest culture at the least cost
BuildingTypes CvCity::ChooseFreeCultureBuilding() const
{
	BuildingTypes eRtnValue = NO_BUILDING;
	int iNumBuildingInfos = GC.getNumBuildingInfos();
	CvWeightedVector<int> buildingChoices;

	for (int iI = 0; iI < iNumBuildingInfos; iI++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
		if (pkBuildingInfo)
		{
			const CvBuildingClassInfo& kBuildingClassInfo = pkBuildingInfo->GetBuildingClassInfo();
			if (!isWorldWonderClass(kBuildingClassInfo) && !isNationalWonderClass(kBuildingClassInfo) && !isTeamWonderClass(kBuildingClassInfo))
			{
				int iCulture = pkBuildingInfo->GetYieldChange(YIELD_CULTURE);
				int iCost = pkBuildingInfo->GetProductionCost();
				if (getFirstBuildingOrder(eBuilding) != -1 || canConstruct(eBuilding))
				{
					if (iCulture > 0 && iCost > 0)
					{
						int iWeight = iCulture * 10000 / iCost;

						if (iWeight > 0)
						{
							buildingChoices.push_back(iI, iWeight);
						}
					}
				}
			}
		}
	}

	if (buildingChoices.size() > 0)
	{
		buildingChoices.StableSortItems();
		eRtnValue = (BuildingTypes)buildingChoices.GetElement(0);
	}

	return eRtnValue;
}

//	--------------------------------------------------------------------------------
/// Find the non-wonder building that provides the highest food kept at the least cost
BuildingTypes CvCity::ChooseFreeFoodBuilding() const
{
	BuildingTypes eRtnValue = NO_BUILDING;
	int iNumBuildingInfos = GC.getNumBuildingInfos();
	CvWeightedVector<int> buildingChoices;

	for (int iI = 0; iI < iNumBuildingInfos; iI++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
		if (pkBuildingInfo)
		{
			const CvBuildingClassInfo& kBuildingClassInfo = pkBuildingInfo->GetBuildingClassInfo();
			if (!isWorldWonderClass(kBuildingClassInfo) && !isNationalWonderClass(kBuildingClassInfo) && !isTeamWonderClass(kBuildingClassInfo))
			{
				if (getFirstBuildingOrder(eBuilding) != -1 || canConstruct(eBuilding))
				{
					int iFood = pkBuildingInfo->GetFoodKept();
					int iCost = pkBuildingInfo->GetProductionCost();
					if (iFood > 0 && iCost > 0)
					{
						int iWeight = iFood * 10000 / iCost;

						if (iWeight > 0)
						{
							buildingChoices.push_back(iI, iWeight);
						}
					}
				}
			}
		}
	}

	if (buildingChoices.size() > 0)
	{
		buildingChoices.StableSortItems();
		eRtnValue = (BuildingTypes)buildingChoices.GetElement(0);
	}

	return eRtnValue;
}

//	--------------------------------------------------------------------------------
int CvCity::getCitySizeBoost() const
{
	VALIDATE_OBJECT();
	return m_iCitySizeBoost;
}


//	--------------------------------------------------------------------------------
void CvCity::setCitySizeBoost(int iBoost)
{
	VALIDATE_OBJECT();
	if (getCitySizeBoost() != iBoost)
	{
		m_iCitySizeBoost = iBoost;
		setLayoutDirty(true);
	}
}


//	--------------------------------------------------------------------------------
bool CvCity::isNeverLost() const
{
	VALIDATE_OBJECT();
	return m_bNeverLost;
}


//	--------------------------------------------------------------------------------
void CvCity::setNeverLost(bool bNewValue)
{
	VALIDATE_OBJECT();
	m_bNeverLost = bNewValue;
}


//	--------------------------------------------------------------------------------
bool CvCity::isDrafted() const
{
	VALIDATE_OBJECT();
	return m_bDrafted;
}


//	--------------------------------------------------------------------------------
void CvCity::setDrafted(bool bNewValue)
{
	VALIDATE_OBJECT();
	m_bDrafted = bNewValue;
}

//	--------------------------------------------------------------------------------
bool CvCity::IsOwedCultureBuilding() const
{
	return m_bOwedCultureBuilding;
}

//	--------------------------------------------------------------------------------
void CvCity::SetOwedCultureBuilding(bool bNewValue)
{
	m_bOwedCultureBuilding = bNewValue;
}

//	--------------------------------------------------------------------------------
bool CvCity::IsOwedFoodBuilding() const
{
	return m_bOwedFoodBuilding;
}

//	--------------------------------------------------------------------------------
void CvCity::SetOwedFoodBuilding(bool bNewValue)
{
	m_bOwedFoodBuilding = bNewValue;
}

#if defined(MOD_BALANCE_CORE)

//	--------------------------------------------------------------------------------
bool CvCity::IsBorderObstacleLand() const
{
	VALIDATE_OBJECT();
	return (GetBorderObstacleLand() > 0);
}
//	--------------------------------------------------------------------------------
int CvCity::GetBorderObstacleLand() const
{
	VALIDATE_OBJECT();
	return m_iBorderObstacleCity;
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeBorderObstacleCity(int iChange)
{
	VALIDATE_OBJECT();
	SetBorderObstacleCity(GetBorderObstacleLand() + iChange);
}
//	--------------------------------------------------------------------------------
void CvCity::SetBorderObstacleCity(int iValue)
{
	VALIDATE_OBJECT();
	m_iBorderObstacleCity = iValue;
}

//	--------------------------------------------------------------------------------
bool CvCity::IsBorderObstacleWater() const
{
	VALIDATE_OBJECT();
	return (GetBorderObstacleWater() > 0);
}
//	--------------------------------------------------------------------------------
int CvCity::GetBorderObstacleWater() const
{
	VALIDATE_OBJECT();
	return m_iBorderObstacleWater;
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeBorderObstacleWater(int iChange)
{
	VALIDATE_OBJECT();
	SetBorderObstacleWater(GetBorderObstacleWater() + iChange);
}
//	--------------------------------------------------------------------------------
void CvCity::SetBorderObstacleWater(int iValue)
{
	VALIDATE_OBJECT();
	m_iBorderObstacleWater = iValue;
}

//	--------------------------------------------------------------------------------
int CvCity::GetDeepWaterTileDamage() const
{
	VALIDATE_OBJECT();
	return m_iDeepWaterTileDamage;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeDeepWaterTileDamage(int iChange)
{
	VALIDATE_OBJECT();
	m_iDeepWaterTileDamage += iChange;
}
//	--------------------------------------------------------------------------------
int CvCity::GetNearbyMountains() const
{
	VALIDATE_OBJECT();
	return m_iNumNearbyMountains;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeNearbyMountains(int iChange)
{
	VALIDATE_OBJECT();
	SetNearbyMountains(GetNearbyMountains() + iChange);
}
//	--------------------------------------------------------------------------------
void CvCity::SetNearbyMountains(int iValue)
{
	VALIDATE_OBJECT();
	m_iNumNearbyMountains = iValue;
}

#endif
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
bool CvCity::IsOwedChosenBuilding(BuildingClassTypes eBuildingClass) const
{
	ASSERT_DEBUG(eBuildingClass >= 0);
	ASSERT_DEBUG(eBuildingClass < GC.getNumBuildingClassInfos());

	return m_abOwedChosenBuilding[eBuildingClass];
}
//	--------------------------------------------------------------------------------
void CvCity::SetOwedChosenBuilding(BuildingClassTypes eBuildingClass, bool bNewValue)
{
	ASSERT_DEBUG(eBuildingClass >= 0);
	ASSERT_DEBUG(eBuildingClass < GC.getNumBuildingClassInfos());

	m_abOwedChosenBuilding[eBuildingClass] = bNewValue;
}
#endif

//	--------------------------------------------------------------------------------
bool CvCity::IsBlockadedWaterAndLand() const
{
	return IsBlockaded(NO_DOMAIN);
}

bool CvCity::IsBlockaded(DomainTypes eDomain) const
{
	if (GetSappedTurns() > 0)
		return true;

	for (int iLoop = 0; iLoop < NUM_DIRECTION_TYPES; ++iLoop)
	{
		CvPlot* pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iLoop));
		if (!pAdjacentPlot)
			continue;

		if (eDomain != NO_DOMAIN && pAdjacentPlot->getDomain() != eDomain)
			continue;

		if (pAdjacentPlot->isImpassable(getTeam()))
			continue;

		//finally, one unblocked plot breaks the whole thing
		if (!pAdjacentPlot->isBlockaded(getOwner()))
			return false;
	}

	//note: if a city is landlocked, it is permanently blockaded from sea side by definition
	return true;
}

//	--------------------------------------------------------------------------------
/// Number of turns city has demanded a resource for
int CvCity::GetResourceDemandedCounter() const
{
	VALIDATE_OBJECT();
	return m_iResourceDemandedCounter;
}

//	--------------------------------------------------------------------------------
///Sets number of turns city has demanded a resource for
void CvCity::SetResourceDemandedCounter(int iValue)
{
	VALIDATE_OBJECT();
	m_iResourceDemandedCounter = iValue;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeResourceDemandedCounter(int iChange)
{
	VALIDATE_OBJECT();
	SetResourceDemandedCounter(GetResourceDemandedCounter() + iChange);
}

//	--------------------------------------------------------------------------------
/// Amount of turns left in WLTKD
int CvCity::GetWeLoveTheKingDayCounter() const
{
	VALIDATE_OBJECT();
	return m_iWeLoveTheKingDayCounter;
}

//	--------------------------------------------------------------------------------
///Sets number of turns left in WLTKD
void CvCity::SetWeLoveTheKingDayCounter(int iValue)
{
	VALIDATE_OBJECT();
	m_iWeLoveTheKingDayCounter = iValue;
}

//	--------------------------------------------------------------------------------
///Changes number of turns left in WLTKD
void CvCity::ChangeWeLoveTheKingDayCounter(int iChange, bool bUATrigger)
{
	VALIDATE_OBJECT();

	bool bNewWLTKD = false;
	if (m_iWeLoveTheKingDayCounter <= 0 && iChange > 0)
		bNewWLTKD = true;

	SetWeLoveTheKingDayCounter(GetWeLoveTheKingDayCounter() + iChange);
	if (bNewWLTKD)
	{
#if defined(MOD_BALANCE_CORE)
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityBeginsWLTKD, getOwner(), getX(), getY(), iChange);
#endif
	}
	else if (iChange > 0)
	{
#if defined(MOD_BALANCE_CORE)
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityExtendsWLTKD, getOwner(), getX(), getY(), iChange);
#endif
	}
	if (iChange > 0 && bUATrigger)
	{
		for (int iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
		{
			if (GET_PLAYER(getOwner()).GetPlayerTraits()->GetPermanentYieldChangeWLTKD((YieldTypes)iJ) > 0)
			{
				ChangeBaseYieldRateFromMisc((YieldTypes)iJ, GET_PLAYER(getOwner()).GetPlayerTraits()->GetPermanentYieldChangeWLTKD((YieldTypes)iJ));
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Turn number when AI placed a garrison here
int CvCity::GetLastTurnGarrisonAssigned() const
{
	VALIDATE_OBJECT();
	return m_iLastTurnGarrisonAssigned;
}

//	--------------------------------------------------------------------------------
int CvCity::GetNumThingsProduced() const
{
	VALIDATE_OBJECT();
	return m_iThingsProduced;
}

//	--------------------------------------------------------------------------------
bool CvCity::isProductionAutomated() const
{
	VALIDATE_OBJECT();
	return m_bProductionAutomated;
}


//	--------------------------------------------------------------------------------
void CvCity::setProductionAutomated(bool bNewValue, bool bClear)
{
	VALIDATE_OBJECT();
	if (isProductionAutomated() != bNewValue)
	{
		m_bProductionAutomated = bNewValue;

		if ((getOwner() == GC.getGame().getActivePlayer()) && isCitySelected())
		{
			DLLUI->setDirty(SelectionButtons_DIRTY_BIT, true);
		}

		// if automated and not network game and all 3 modifiers down, clear the queue and choose again
		if (bNewValue && bClear)
		{
			clearOrderQueue();
		}
		if (!isProduction())
		{
			AI_chooseProduction(false /*bInterruptWonders*/, false);
		}
	}
}


//	--------------------------------------------------------------------------------
bool CvCity::isLayoutDirty() const
{
	VALIDATE_OBJECT();
	return m_bLayoutDirty;
}


//	--------------------------------------------------------------------------------
void CvCity::setLayoutDirty(bool bNewValue)
{
	VALIDATE_OBJECT();
	m_bLayoutDirty = bNewValue;
}

//	--------------------------------------------------------------------------------
PlayerTypes CvCity::getPreviousOwner() const
{
	VALIDATE_OBJECT();
	return m_ePreviousOwner;
}


//	--------------------------------------------------------------------------------
void CvCity::setPreviousOwner(PlayerTypes eNewValue)
{
	VALIDATE_OBJECT();
	m_ePreviousOwner = eNewValue;
}


//	--------------------------------------------------------------------------------
PlayerTypes CvCity::getOriginalOwner() const
{
	VALIDATE_OBJECT();
	return m_eOriginalOwner;
}


//	--------------------------------------------------------------------------------
void CvCity::setOriginalOwner(PlayerTypes eNewValue)
{
	VALIDATE_OBJECT();
	m_eOriginalOwner = eNewValue;
}


//	--------------------------------------------------------------------------------
PlayerTypes CvCity::GetPlayersReligion() const
{
	VALIDATE_OBJECT();
	return m_ePlayersReligion;
}


//	--------------------------------------------------------------------------------
void CvCity::SetPlayersReligion(PlayerTypes eNewValue)
{
	VALIDATE_OBJECT();
	m_ePlayersReligion = eNewValue;
}

void CvCity::SetNoWarmonger(bool bValue)
{
	VALIDATE_OBJECT();
	m_bNoWarmonger = bValue;
}
bool CvCity::IsNoWarmongerYet()
{
	VALIDATE_OBJECT();
	return m_bNoWarmonger;
}

void CvCity::ChangeNoStarvationNonSpecialist(int iValue)
{
	VALIDATE_OBJECT();
	m_iNoStarvationNonSpecialist += iValue;
}
bool CvCity::IsNoStarvationNonSpecialist() const
{
	VALIDATE_OBJECT();
	return m_iNoStarvationNonSpecialist > 0;
}

int CvCity::GetNumTimesOwned(PlayerTypes ePlayer) const
{
	VALIDATE_OBJECT();
	return m_aiNumTimesOwned[ePlayer];
}
void CvCity::SetNumTimesOwned(PlayerTypes ePlayer, int iValue)
{
	ASSERT_DEBUG(ePlayer >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(ePlayer < MAX_PLAYERS, "eIndex expected to be < MAX_PLAYERS");
	m_aiNumTimesOwned[ePlayer] = iValue;
}
void CvCity::ChangeNumTimesOwned(PlayerTypes ePlayer, int iValue)
{
	ASSERT_DEBUG(ePlayer >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(ePlayer < MAX_PLAYERS, "eIndex expected to be < MAX_PLAYERS");
	SetNumTimesOwned(ePlayer, (GetNumTimesOwned(ePlayer) + iValue));
}
bool CvCity::isEverOwned(PlayerTypes ePlayer) const
{
	return GetNumTimesOwned(ePlayer) > 0;
}

//	--------------------------------------------------------------------------------
TeamTypes CvCity::getTeam() const
{
	VALIDATE_OBJECT();
	return GET_PLAYER(getOwner()).getTeam();
}


//	--------------------------------------------------------------------------------
int CvCity::getSeaPlotYield(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiSeaPlotYield[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::changeSeaPlotYield(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiSeaPlotYield[eIndex] = m_aiSeaPlotYield[eIndex] + iChange;
		ASSERT_DEBUG(getSeaPlotYield(eIndex) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvCity::getRiverPlotYield(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiRiverPlotYield[eIndex];
}

//	--------------------------------------------------------------------------------
void CvCity::changeRiverPlotYield(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiRiverPlotYield[eIndex] = m_aiRiverPlotYield[eIndex] + iChange;
		ASSERT_DEBUG(getRiverPlotYield(eIndex) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvCity::getLakePlotYield(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiLakePlotYield[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::changeLakePlotYield(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiLakePlotYield[eIndex] = m_aiLakePlotYield[eIndex] + iChange;
		ASSERT_DEBUG(getLakePlotYield(eIndex) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvCity::getSeaResourceYield(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiSeaResourceYield[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::changeSeaResourceYield(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiSeaResourceYield[eIndex] = m_aiSeaResourceYield[eIndex] + iChange;
		ASSERT_DEBUG(getSeaResourceYield(eIndex) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
/// Yield per turn from Religion
int CvCity::GetYieldPerTurnFromReligion(YieldTypes eYield) const
{
	return GetSpecialReligionYields(eYield);
}

void CvCity::UpdateSpecialReligionYields(YieldTypes eYield)
{
	int iYieldValue = 0;
	ReligionTypes eReligion = GetCityReligions()->GetReligiousMajority();
	if (eReligion != NO_RELIGION)
	{
		CvPlayer& kPlayer = GET_PLAYER(getOwner());
		const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
		if (pReligion)
		{
			if (GetCityReligions()->IsHolyCityForReligion(pReligion->m_eReligion))
			{
				iYieldValue += pReligion->m_Beliefs.GetHolyCityYieldChange(eYield, getOwner(), this, true);
			}

			int iPantheon = 0;
			int iYield = pReligion->m_Beliefs.GetYieldFromKnownPantheons(eYield, getOwner(), this, true);
			if (iYield > 0)
			{
				iPantheon = GC.getGame().GetGameReligions()->GetNumPantheonsCreated();
				if (iPantheon > 0)
				{
					iPantheon = min(iPantheon, 8);

					iPantheon *= iYield;
					iPantheon /= 100;

					iYieldValue += iPantheon;
				}
			}

			int iTemp = pReligion->m_Beliefs.GetYieldChangePerForeignCity(eYield, getOwner(), this, true);
			if (iTemp > 0)
			{
				iYieldValue += (iTemp * kPlayer.GetReligions()->GetNumForeignCitiesFollowing(eReligion));
			}

			iTemp = pReligion->m_Beliefs.GetYieldChangePerXForeignFollowers(eYield, getOwner(), this, true);
			if (iTemp > 0)
			{
				int iFollowers = kPlayer.GetReligions()->GetNumForeignFollowers(false, eReligion);
				if (iFollowers > 0)
				{
					iYieldValue += (iFollowers / iTemp);
				}
			}

			iTemp = pReligion->m_Beliefs.GetYieldChangePerXCityStateFollowers(eYield, getOwner(), this, true);
			if (iTemp > 0)
			{
				int iFollowers = kPlayer.GetReligions()->GetNumCityStateFollowers(eReligion);
				if (iFollowers > 0)
				{
					iYieldValue += (iFollowers / iTemp);
				}
			}

			int iYieldPerXNonFollowers = pReligion->m_Beliefs.GetYieldPerOtherReligionFollower(eYield, getOwner(), this, true);
			if (iYieldPerXNonFollowers > 0)
			{
				int iLoop = 0;
				for (const CvCity* pLoopCity = GET_PLAYER(getOwner()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(getOwner()).nextCity(&iLoop))
				{
					if (pLoopCity != NULL)
					{
						iYieldValue += (pLoopCity->GetCityReligions()->GetFollowersOtherReligions(eReligion));
					}
				}
				iYieldValue /= iYieldPerXNonFollowers;
			}

			// This came from CvTreasury::GetGoldPerTurnFromReligion()
			//Only useable in religions!
			if (eYield == YIELD_GOLD)
			{
				if (eReligion != RELIGION_PANTHEON)
					iYieldValue += pReligion->m_Beliefs.GetGoldPerFollowingCity(getOwner(), this, true);

				int iGoldPerXFollowers = pReligion->m_Beliefs.GetGoldPerXFollowers(getOwner(), this, true);
				if (iGoldPerXFollowers > 0)
				{
					if (eReligion == RELIGION_PANTHEON)
						iYieldValue += (GC.getGame().GetGameReligions()->GetNumFollowers(eReligion, getOwner()) / iGoldPerXFollowers);
					else
						iYieldValue += (GC.getGame().GetGameReligions()->GetNumFollowers(eReligion) / iGoldPerXFollowers);
				}
			}

			int iYieldPerFollowingCity = pReligion->m_Beliefs.GetYieldPerFollowingCity(eYield, getOwner(), this);
			if (iYieldPerFollowingCity > 0)
			{
				iYieldValue += iYieldPerFollowingCity;
			}

			int iYieldPerXFollowers = pReligion->m_Beliefs.GetYieldPerXFollowers(eYield, getOwner(), this, true);
			if (iYieldPerXFollowers > 0)
			{
				iYieldValue += (GC.getGame().GetGameReligions()->GetNumFollowers(eReligion, getOwner()) / iYieldPerXFollowers);
			}

			int iLuxYield = pReligion->m_Beliefs.GetYieldPerLux(eYield, getOwner(), this, true);
			if (iLuxYield > 0)
			{
				int iNumBonuses = 0;
				ResourceTypes eResource;
				for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
				{
					eResource = (ResourceTypes)iResourceLoop;

					if (kPlayer.GetHappinessFromLuxury(eResource) > 0)
					{
						if ((kPlayer.getNumResourceTotal(eResource, true) + kPlayer.getResourceExport(eResource)) > 0)
							iNumBonuses++;
					}
				}
				if (iNumBonuses > 0)
				{
					iLuxYield *= iNumBonuses;
					iYieldValue += iLuxYield;
				}
			}

			int iYieldPerGPT = pReligion->m_Beliefs.GetYieldPerGPT(eYield, getOwner(), this);
			if (iYieldPerGPT > 0)
			{
				int iNetGold = getYieldRate(YIELD_GOLD, false);
				if (iNetGold > 0)
				{
					int iNumFollowers = GetCityReligions()->GetNumFollowers(eReligion);
					iNetGold = min((iNumFollowers / 2), (iNetGold / iYieldPerGPT));
					iYieldValue += iNetGold;
				}
			}

			int iYieldPerScience = pReligion->m_Beliefs.GetYieldPerScience(eYield, getOwner(), this);
			if (iYieldPerScience > 0)
			{
				int iNetScience = getYieldRate(YIELD_SCIENCE, false);
				if (iNetScience > 0)
				{
					int iNumFollowers = GetCityReligions()->GetNumFollowers(eReligion);
					iNetScience = min((iNumFollowers / 2), (iNetScience / iYieldPerScience));

					iYieldValue += iNetScience;
				}
			}

			CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
			if (pLeague != NULL)
			{
				int iEra = kPlayer.GetCurrentEra();
				if (iEra <= 1)
				{
					iEra = 1;
				}
				int iHostYield = (pReligion->m_Beliefs.GetYieldFromHost(eYield, getOwner(), this, true) * iEra);
				if (iHostYield > 0)
				{
					if (pLeague->GetHostMember() == getOwner())
					{
						iYieldValue += iHostYield;
					}
				}
			}

			iYieldValue += pReligion->m_Beliefs.GetYieldPerActiveTR(eYield, getOwner(), this);
		}
	}
	SetSpecialReligionYields(eYield, iYieldValue);
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetSpecialReligionYields(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromKnownPantheons[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::SetSpecialReligionYields(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != m_aiYieldFromKnownPantheons[eIndex])
	{
		m_aiYieldFromKnownPantheons[eIndex] = iChange;
		ASSERT_DEBUG(GetSpecialReligionYields(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvCity::getBaseYieldRateModifier(YieldTypes eIndex, int iExtra, CvString* toolTipSink) const
{
	VALIDATE_OBJECT();

	// Yield Rate Modifier
	int iTempMod = getYieldRateModifier(eIndex);
	int iModifier = iTempMod;
	if (toolTipSink)
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD", iTempMod);

#if defined(MOD_YIELD_MODIFIER_FROM_UNITS)
	if (MOD_YIELD_MODIFIER_FROM_UNITS)
	{
		CvPlot* pCityPlot = plot();
		for (int iUnitLoop = 0; iUnitLoop < pCityPlot->getNumUnits(); iUnitLoop++)
		{
			iTempMod = pCityPlot->getUnitByIndex(iUnitLoop)->GetYieldModifier(eIndex);
			if (iTempMod != 0)
			{
				iModifier += iTempMod;
				if (toolTipSink && iTempMod)
				{
					GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_UNITPROMOTION", iTempMod);
				}
			}
		}
	}
#endif

	// Resource Yield Rate Modifier
	iTempMod = getResourceYieldRateModifier(eIndex);
	iModifier += iTempMod;
	if (toolTipSink)
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_RESOURCES", iTempMod);

	// Empire Happiness Yield Rate Modifier
	iTempMod = getHappinessModifier(eIndex);
	iModifier += iTempMod;
	if (toolTipSink)
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_HAPPINESS", iTempMod);

	// Area Yield Rate Modifier
	CvArea* pArea = plot()->area();
	if (pArea != NULL)
	{
		iTempMod = pArea->getYieldRateModifier(getOwner(), eIndex);
		iModifier += iTempMod;
		if (toolTipSink)
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_AREA", iTempMod);
	}

	// Player Yield Rate Modifier
	iTempMod = GET_PLAYER(getOwner()).getYieldRateModifier(eIndex);
	iModifier += iTempMod;
	if (toolTipSink)
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_PLAYER", iTempMod);

	// Player Capital Yield Rate Modifier
	if (isCapital())
	{
		iTempMod = GET_PLAYER(getOwner()).getCapitalYieldRateModifier(eIndex);
		iModifier += iTempMod;
		if (toolTipSink)
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_CAPITAL", iTempMod);
	}

	//Blockade
	if (eIndex == YIELD_GOLD && isCoastal(/*10*/ GD_INT_GET(MIN_WATER_SIZE_FOR_OCEAN)))
	{
		if (/*0 in CP, -25 in VP*/ GD_INT_GET(BLOCKADE_GOLD_PENALTY) != 0 && IsBlockaded(DOMAIN_SEA))
		{
			iTempMod = GD_INT_GET(BLOCKADE_GOLD_PENALTY);
			iModifier += iTempMod;
			if (toolTipSink)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_GOLDMOD_YIELD_BLOCKADE", iTempMod);
		}
	}

	iTempMod = GetEventCityYieldModifier(eIndex);
	iModifier += iTempMod;
	if (toolTipSink)
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_EVENTMOD", iTempMod);
	

	iTempMod = (GetTradeRouteCityMod(eIndex));
	if (iTempMod > 0)
	{
		iModifier += iTempMod;
		if (toolTipSink)
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_CORPORATION", iTempMod);
	}
	if (GetYieldModifierFromHappiness(eIndex) != 0)
	{
		iTempMod = GetYieldModifierFromHappiness(eIndex);
		iModifier += iTempMod;
		if (toolTipSink)
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_YIELD_MODIFIER_HAPPINESS", iTempMod);
	}
	if (GetYieldModifierFromHealth(eIndex) != 0)
	{
		iTempMod = GetYieldModifierFromHealth(eIndex);
		iModifier += iTempMod;
		if (toolTipSink)
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_YIELD_MODIFIER_HEALTH", iTempMod);
	}
	if (GetYieldModifierFromCrime(eIndex) != 0 && eIndex != YIELD_JFD_CRIME)
	{
		iTempMod = GetYieldModifierFromCrime(eIndex);
		iModifier += iTempMod;
		if (toolTipSink)
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_YIELD_MODIFIER_CRIME", iTempMod);
	}
	if (GetYieldModifierFromDevelopment(eIndex) != 0 && eIndex != YIELD_JFD_CRIME)
	{
		iTempMod = GetYieldModifierFromDevelopment(eIndex);
		iModifier += iTempMod;
		if (toolTipSink)
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_YIELD_MODIFIER_DEVELOPMENT", iTempMod);
	}
	if (GET_PLAYER(getOwner()).getYieldModifierFromGreatWorks(eIndex) != 0)
	{
		iTempMod = min(20, (GET_PLAYER(getOwner()).getYieldModifierFromGreatWorks(eIndex) * GetCityBuildings()->GetNumGreatWorks()));
		iModifier += iTempMod;
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_GREAT_WORKS", iTempMod);
	}
	if (isCapital() && GET_PLAYER(getOwner()).getYieldModifierFromActiveSpies(eIndex) != 0)
	{
		iTempMod = min(30, (GET_PLAYER(getOwner()).getYieldModifierFromActiveSpies(eIndex) * GET_PLAYER(getOwner()).GetSpyPoints(true) / 100));
		iModifier += iTempMod;
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_SPIES", iTempMod);
	}

	// Golden Age Yield Modifier
	if (GET_PLAYER(getOwner()).isGoldenAge() && eIndex != YIELD_FOOD)
	{
		CvYieldInfo* pYield = GC.getYieldInfo(eIndex);
		if (pYield)
		{
			iTempMod = pYield->getGoldenAgeYieldMod();
			iModifier += iTempMod;
			if (toolTipSink)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_GOLDEN_AGE", iTempMod);
		}

		if (GetGoldenAgeYieldMod(eIndex) != 0)
		{
			iTempMod = GetGoldenAgeYieldMod(eIndex);
			iModifier += iTempMod;
			if (toolTipSink)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_GOLDEN_AGE_BUILDINGS", iTempMod);
		}

		if (GET_PLAYER(getOwner()).getGoldenAgeYieldMod(eIndex) != 0)
		{
			iTempMod = GET_PLAYER(getOwner()).getGoldenAgeYieldMod(eIndex);
			iModifier += iTempMod;
			if (toolTipSink)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_GOLDEN_AGE_POLICIES", iTempMod);
		}
		if (GET_PLAYER(getOwner()).GetPlayerTraits()->GetGoldenAgeYieldModifier(eIndex) != 0)
		{
			iTempMod = GET_PLAYER(getOwner()).GetPlayerTraits()->GetGoldenAgeYieldModifier(eIndex);
			iModifier += iTempMod;
			if (toolTipSink)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_GOLDEN_AGE_TRAITS", iTempMod);
		}
	}

	// Religion Yield Rate Modifier
	ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
	const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
	if (pReligion)
	{
		int iMaxVal = 0;
		int iReligionYieldMaxFollowersPercent = pReligion->m_Beliefs.GetMaxYieldModifierPerFollowerPercent(iMaxVal, eIndex, getOwner(), this);
		if (iReligionYieldMaxFollowersPercent > 0)
		{
			int iVal = GetCityReligions()->GetNumFollowers(eMajority) * iReligionYieldMaxFollowersPercent;
			if (iVal > 0)
			{
				iVal /= 100;

				if (iVal <= 0)
					iVal = 1;

				iTempMod = min(iMaxVal, iVal);
				iModifier += iTempMod;
				if (toolTipSink)
					GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_BELIEF", iTempMod);
			}
		}
		else
		{
			int iReligionYieldMaxFollowers = pReligion->m_Beliefs.GetMaxYieldModifierPerFollower(eIndex, getOwner(), this);
			if (iReligionYieldMaxFollowers > 0)
			{
				int iFollowers = GetCityReligions()->GetNumFollowers(eMajority);
				iTempMod = min(iFollowers, iReligionYieldMaxFollowers);
				iModifier += iTempMod;
				if (toolTipSink)
					GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_BELIEF", iTempMod);
			}
		}
	}

	// Production Yield Rate Modifier from City States
	if (eIndex == YIELD_PRODUCTION && GetCityBuildings()->GetCityStateTradeRouteProductionModifier() > 0)
	{
		iTempMod = GetCityBuildings()->GetCityStateTradeRouteProductionModifier();
		iModifier += iTempMod;
		if (toolTipSink) {
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_HANSE", iTempMod);
		}
	}
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	if (MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	{
		// Do we get increased yields from a resource monopoly?
		int iTempMod = GET_PLAYER(getOwner()).getCityYieldModFromMonopoly(eIndex);
		if (iTempMod != 0)
		{
			iTempMod += GET_PLAYER(getOwner()).GetMonopolyModPercent();
			iModifier += iTempMod;
			if (toolTipSink)
			{
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_MONOPOLY_RESOURCE", iTempMod);
			}
		}
	}
#endif

	ReligionTypes eStateReligion = GET_PLAYER(getOwner()).GetReligions()->GetStateReligion();
	if (MOD_BALANCE_CORE_BELIEFS && eStateReligion != NO_RELIGION)
	{
		const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eStateReligion, getOwner());
		if (pReligion)
		{
			int iGoldenAge = pReligion->m_Beliefs.GetYieldBonusGoldenAge(eIndex, getOwner(), GET_PLAYER(getOwner()).getCity(GetID()), true);
			if (iGoldenAge > 0)
			{
				if (GET_PLAYER(getOwner()).getGoldenAgeTurns() > 0)
				{
					iTempMod = iGoldenAge;
					iModifier += iTempMod;
					GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_GOLDEN_AGE_RELIGION", iTempMod);
				}
			}
			int iWLTKD = pReligion->m_Beliefs.GetYieldFromWLTKD(eIndex, getOwner(), GET_PLAYER(getOwner()).getCity(GetID()));
			if (iWLTKD != 0)
			{
				if (GetWeLoveTheKingDayCounter() > 0)
				{
					iTempMod = iWLTKD;
					iModifier += iTempMod;
					GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WLTKD_RELIGION", iTempMod);
				}
			}
		}
	}

	if (GetWeLoveTheKingDayCounter() > 0)
	{
		if (GET_PLAYER(getOwner()).GetYieldFromWLTKD(eIndex) + GetYieldFromWLTKD(eIndex) != 0)
		{
			iTempMod = (GetYieldFromWLTKD(eIndex) + GET_PLAYER(getOwner()).GetYieldFromWLTKD(eIndex));
			iModifier += iTempMod;
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WLTKD", iTempMod);
		}
		if (GET_PLAYER(getOwner()).GetPlayerTraits()->GetWLTKDCulture() != 0 && eIndex == YIELD_CULTURE)
		{
			iTempMod = GET_PLAYER(getOwner()).GetPlayerTraits()->GetWLTKDCulture();
			iModifier += iTempMod;
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WLTKD_TRAIT", iTempMod);
		}
	}

	// Trait Yield Rate Modifier per Follower
	if (eIndex == YIELD_FOOD && eMajority != NO_RELIGION)
	{
		iTempMod = 0;
		int iFollowers = GetCityReligions()->GetNumFollowers(eMajority);
		if (GET_PLAYER(getOwner()).GetPlayerTraits()->IsPopulationBoostReligion() && eMajority == GET_PLAYER(getOwner()).GetReligions()->GetStateReligion(true))
		{
			iTempMod += iFollowers * /*0*/ GD_INT_GET(BALANCE_FOLLOWER_FOOD_BONUS);
			iModifier += iTempMod;
		}
		if (GetFoodBonusPerCityMajorityFollower() > 0)
		{
			iTempMod += iFollowers * GetFoodBonusPerCityMajorityFollower();
			iModifier += iTempMod;
		}
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_FOLLOWERS", iTempMod);
	}

	// Puppet
	if (IsPuppet())
	{
		switch (eIndex)
		{
		case YIELD_SCIENCE:
			iTempMod = GET_PLAYER(getOwner()).GetPuppetYieldPenaltyMod() + GET_PLAYER(getOwner()).GetPlayerTraits()->GetPuppetPenaltyReduction() + /*-25 in CP, -80 in VP*/ GD_INT_GET(PUPPET_SCIENCE_MODIFIER);
			if (iTempMod > 0)
				iTempMod = 0;
			iModifier += iTempMod;
			if (iTempMod != 0 && toolTipSink)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_PUPPET", iTempMod);
			break;

		case YIELD_GOLD:
			iTempMod = GET_PLAYER(getOwner()).GetPuppetYieldPenaltyMod() + GET_PLAYER(getOwner()).GetPlayerTraits()->GetPuppetPenaltyReduction() + /*0 in CP, -80 in VP*/ GD_INT_GET(PUPPET_GOLD_MODIFIER);
			if (iTempMod > 0)
				iTempMod = 0;
			iModifier += iTempMod;
			if (iTempMod != 0 && toolTipSink)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_PUPPET", iTempMod);
			break;

		case YIELD_PRODUCTION:
			iTempMod = GET_PLAYER(getOwner()).GetPuppetYieldPenaltyMod() + GET_PLAYER(getOwner()).GetPlayerTraits()->GetPuppetPenaltyReduction() + /*0*/ GD_INT_GET(PUPPET_PRODUCTION_MODIFIER);
			if (iTempMod > 0)
				iTempMod = 0;
			iModifier += iTempMod;
			if (iTempMod != 0 && toolTipSink)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_PUPPET", iTempMod);
			break;

		case YIELD_TOURISM:
			iTempMod = GET_PLAYER(getOwner()).GetPuppetYieldPenaltyMod() + GET_PLAYER(getOwner()).GetPlayerTraits()->GetPuppetPenaltyReduction() + /*0 in CP, -80 in VP*/ GD_INT_GET(PUPPET_TOURISM_MODIFIER);
			if (iTempMod > 0)
				iTempMod = 0;
			iModifier += iTempMod;
			if (iTempMod != 0 && toolTipSink)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_PUPPET", iTempMod);
			break;

		case YIELD_GOLDEN_AGE_POINTS:
			iTempMod = GET_PLAYER(getOwner()).GetPuppetYieldPenaltyMod() + GET_PLAYER(getOwner()).GetPlayerTraits()->GetPuppetPenaltyReduction() + /*0 in CP, -80 in VP*/ GD_INT_GET(PUPPET_GOLDEN_AGE_MODIFIER);
			if (iTempMod > 0)
				iTempMod = 0;
			iModifier += iTempMod;
			if (iTempMod != 0 && toolTipSink)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_PUPPET", iTempMod);
			break;

		case YIELD_CULTURE: // taken from getJONSCulturePerTurn
			iTempMod = GET_PLAYER(getOwner()).GetPuppetYieldPenaltyMod() + GET_PLAYER(getOwner()).GetPlayerTraits()->GetPuppetPenaltyReduction() + /*-25 in CP, -80 in VP*/ GD_INT_GET(PUPPET_CULTURE_MODIFIER);
			if (GET_PLAYER(getOwner()).GetPlayerTraits()->GetPuppetPenaltyReduction() != 0 && iTempMod > 0)
				iTempMod = 0;
			iModifier += iTempMod;
			// FIXME: Disabled because EUI doesn't interact well with this.
			// EUI should be fixed and this re-enabled.
			/*
			if (iTempMod != 0 && toolTipSink)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_PUPPET", iTempMod);
			*/
			break;

		case YIELD_FAITH:
			// FIXME: EUI doesn't expect this information to be populated for faith.
			// Because of this, the calculation is handled in `CvCity::GetFaithPerTurn`.
			// EUI should be fixed and this re-enabled.
			/*
			iTempMod = GET_PLAYER(getOwner()).GetPuppetYieldPenaltyMod() + GET_PLAYER(getOwner()).GetPlayerTraits()->GetPuppetPenaltyReduction() + GD_INT_GET(PUPPET_FAITH_MODIFIER);
			if (iTempMod > 0)
				iTempMod = 0;
			iModifier += iTempMod;

			if (iTempMod != 0 && toolTipSink)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_PUPPET", iTempMod);
			*/
			break;

		case NO_YIELD:
		case YIELD_FOOD:
		case YIELD_GREAT_GENERAL_POINTS:
		case YIELD_GREAT_ADMIRAL_POINTS:
		case YIELD_POPULATION:
		case YIELD_CULTURE_LOCAL:
		case YIELD_JFD_HEALTH:
		case YIELD_JFD_DISEASE:
		case YIELD_JFD_CRIME:
		case YIELD_JFD_LOYALTY:
		case YIELD_JFD_SOVEREIGNTY:
			break; // Yield unaffected by being a puppet.
		}
	}

	// Culture specific modifiers taken from getJONSCulturePerTurn
	if (eIndex == YIELD_CULTURE)
	{
		// getCultureRateModifier() is just the culture specific building modifiers
		iTempMod = getCultureRateModifier();
		iModifier += iTempMod;
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_BUILDING_CITY", iTempMod);

		// Player modifier
		iTempMod = GET_PLAYER(getOwner()).GetJONSCultureCityModifier();
		iModifier += iTempMod;
		// we'll use the same tooltip as for Building_GlobalYieldModifiers
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_PLAYER", iTempMod);

		// Wonder here?
		if (getNumWorldWonders() > 0)
		{
			// policy that grants culture modifier from each wonder (field CultureWonderMultiplier)
			iTempMod = GET_PLAYER(getOwner()).GetCultureWonderMultiplier();
			iModifier += iTempMod;
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_POLICY", iTempMod);
		}

		if (MOD_BALANCE_VP && GET_PLAYER(getOwner()).IsLeagueAid())
		{
			iTempMod = GET_PLAYER(getOwner()).GetLeagueCultureCityModifier();
			iModifier += iTempMod;
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_LEAGUE", iTempMod);
		}
	}

	iModifier += iExtra;

	// note: player->invalidateYieldRankCache() must be called for anything that is checked here
	// so if any extra checked things are added here, the cache needs to be invalidated

	return std::max(0, (iModifier + 100));
}

//	--------------------------------------------------------------------------------
int CvCity::getHappinessModifier(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	if (MOD_BALANCE_VP)
		return 0;

	int iModifier = 0;
	CvPlayer& kPlayer = GET_PLAYER(getOwner());

	if (kPlayer.IsEmpireUnhappy())
	{
		int iUnhappy = -1 * kPlayer.GetExcessHappiness();

		// Production and Gold slow down when Empire is Unhappy
		if (eIndex == YIELD_PRODUCTION)
		{
			iModifier = iUnhappy * /*-2*/ GD_INT_GET(VERY_UNHAPPY_PRODUCTION_PENALTY_PER_UNHAPPY);
			iModifier = max(iModifier, /*-40*/ GD_INT_GET(VERY_UNHAPPY_MAX_PRODUCTION_PENALTY));
		}
		else if (eIndex == YIELD_GOLD)
		{
			iModifier = iUnhappy * /*-2*/ GD_INT_GET(VERY_UNHAPPY_GOLD_PENALTY_PER_UNHAPPY);
			iModifier = max(iModifier, /*-40*/ GD_INT_GET(VERY_UNHAPPY_MAX_GOLD_PENALTY));
		}
	}

	return iModifier;
}
//	--------------------------------------------------------------------------------
int CvCity::getYieldRate(YieldTypes eIndex, bool bIgnoreTrade, bool bStatic) const
{
	VALIDATE_OBJECT();

	if (bStatic && !bIgnoreTrade)
	{
		return (GetStaticYield(eIndex) / 100);
	}

	return (getYieldRateTimes100(eIndex, bIgnoreTrade) / 100);
}
//	--------------------------------------------------------------------------------
int CvCity::getYieldRateTimes100(YieldTypes eIndex, bool bIgnoreTrade, bool bStatic) const
{
	VALIDATE_OBJECT();

	if (bStatic && !bIgnoreTrade)
	{
		return GetStaticYield(eIndex);
	}

	// Anarchy, Resistance or Razing - no Science, Gold or Production (Prod handled in ProductionDifference)
	if (GET_PLAYER(getOwner()).IsAnarchy() || IsResistance() || IsRazing())
	{
		if (eIndex == YIELD_GOLD || eIndex == YIELD_SCIENCE)
		{
			return 0;
		}

		if (eIndex == YIELD_TOURISM)
		{
			return 0;
		}

		if (eIndex == YIELD_GOLDEN_AGE_POINTS)
		{
			return 0;
		}

		if (eIndex == YIELD_GREAT_GENERAL_POINTS)
		{
			return 0;
		}
		if (eIndex == YIELD_GREAT_ADMIRAL_POINTS)
		{
			return 0;
		}
		if (eIndex == YIELD_POPULATION)
		{
			return 0;
		}
		if (eIndex == YIELD_CULTURE_LOCAL)
		{
			return 0;
		}
	}

	int iPostModifierYield = 0;

	if (getProductionToYieldModifier(eIndex) != 0)
	{
		// We want to process production to production and call it stockpiling!
		int iTradeRouteBonus = bIgnoreTrade ? 0 : GET_PLAYER(m_eOwner).GetTrade()->GetTradeValuesAtCityTimes100(this, YIELD_PRODUCTION);
		iPostModifierYield = ((getBasicYieldRateTimes100(YIELD_PRODUCTION) + iTradeRouteBonus) * getProductionToYieldModifier(eIndex)) / 100;
	}

	if (!bIgnoreTrade)
	{
		iPostModifierYield += GET_PLAYER(m_eOwner).GetTrade()->GetTradeValuesAtCityTimes100(this, eIndex);
	}

	return getBasicYieldRateTimes100(eIndex) + iPostModifierYield;
}

int CvCity::getBasicYieldRateTimes100(YieldTypes eIndex) const
{
	// Sum up yield rate
	int iBaseYield = getBaseYieldRate(eIndex) * 100;
	iBaseYield += (GetYieldPerPopTimes100(eIndex) * getPopulation());
	iBaseYield += (GetYieldPerPopInEmpireTimes100(eIndex) * GET_PLAYER(m_eOwner).getTotalPopulation());

	// Yield from Industrial City Connections
	if (MOD_BALANCE_VP && IsIndustrialRouteToCapitalConnected() && eIndex == YIELD_PRODUCTION)
	{
		iBaseYield += GetConnectionGoldTimes100();
	}

	// Player-level yield per religion
	iBaseYield += GET_PLAYER(m_eOwner).GetYieldChangesPerReligionTimes100(eIndex) * GetCityReligions()->GetNumReligionsWithFollowers();

	int iNonSpecialist = GET_PLAYER(m_eOwner).getYieldFromNonSpecialistCitizens(eIndex);
	if (iNonSpecialist != 0)
	{
		int iBonusTimes100 = (iNonSpecialist * (getPopulation() - GetCityCitizens()->GetTotalSpecialistCount()));
		iBaseYield += iBonusTimes100;
	}

	int iModifiedYield = iBaseYield * getBaseYieldRateModifier(eIndex, 0, NULL);
	iModifiedYield /= 100;

	return iModifiedYield;
}

void CvCity::UpdateCityYieldFromYield(YieldTypes eIndex1, YieldTypes eIndex2, int iModifiedYield)
{
	if (iModifiedYield > 0)
	{
		int iYieldVal = GetBuildingYieldFromYield(eIndex1, eIndex2);
		if (iYieldVal > 0)
		{
			int iBonusYield = (iModifiedYield * iYieldVal / 100);
			if (iBonusYield > 0)
			{
				SetRealYieldFromYield(eIndex1, eIndex2, iBonusYield);
			}
			else
			{
				SetRealYieldFromYield(eIndex1, eIndex2, 0);
			}
		}
		else
		{
			SetRealYieldFromYield(eIndex1, eIndex2, 0);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvCity::getBaseYieldRate(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	int iValue = 0;
	iValue += GetBaseYieldRateFromGreatWorks(eIndex);
	iValue += GetBaseYieldRateFromTerrain(eIndex);
	iValue += GetBaseYieldRateFromBuildings(eIndex);
	iValue += GetBaseYieldRateFromSpecialists(eIndex);
	iValue += GetBaseYieldRateFromMisc(eIndex);
	iValue += GetBaseYieldRateFromReligion(eIndex);
#if defined(MOD_BALANCE_CORE)
	iValue += GetBaseYieldRateFromCSAlliance(eIndex);
	iValue += GetBaseYieldRateFromCSFriendship(eIndex);
	iValue += GetYieldFromMinors(eIndex);
	iValue += GetYieldPerTurnFromTraits(eIndex);
	iValue += GetYieldChangeFromCorporationFranchises(eIndex);
	iValue += GetEventCityYield(eIndex);
#endif

	if (IsRouteToCapitalConnected())
	{
		int iEra = GET_PLAYER(getOwner()).GetCurrentEra();
		if (iEra <= 0)
			iEra = 1;
		iValue += GET_PLAYER(getOwner()).GetYieldChangeTradeRoute(eIndex);
		iValue += GET_PLAYER(getOwner()).GetPlayerTraits()->GetYieldChangeTradeRoute(eIndex) * iEra;
	}

	if (GET_PLAYER(getOwner()).IsLeagueArt() && eIndex == YIELD_SCIENCE)
	{
		iValue += GetBaseScienceFromArt();
	}

	if (MOD_YIELD_MODIFIER_FROM_UNITS)
	{
		CvPlot* pCityPlot = plot();
		for (int iUnitLoop = 0; iUnitLoop < pCityPlot->getNumUnits(); iUnitLoop++)
		{
			int iTempVal = pCityPlot->getUnitByIndex(iUnitLoop)->GetYieldChange(eIndex);
			if (iTempVal != 0)
			{
				iValue += iTempVal;
			}
		}
	}

	ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
	if (eMajority != NO_RELIGION && eMajority > RELIGION_PANTHEON)
	{
		if (GET_PLAYER(getOwner()).GetReligions()->GetStateReligion() == eMajority)
		{
			iValue += GET_PLAYER(getOwner()).getReligionYieldRateModifier(eIndex);
		}
	}

#if defined(MOD_BALANCE_CORE)
	//Update Yields from yields ... need to sidestep constness
	CvCity* pThisCity = const_cast<CvCity*>(this);
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eIndex2 = (YieldTypes)iI;
		if (eIndex2 == NO_YIELD)
			continue;
		if (eIndex == eIndex2)
			continue;

		pThisCity->UpdateCityYieldFromYield(eIndex, eIndex2, iValue);

		//NOTE! We flip it here, because we want the OUT yield
		iValue += GetRealYieldFromYield(eIndex2, eIndex);
	}

	iValue += GetYieldFromHappiness(eIndex);
	iValue += GetYieldFromHealth(eIndex);
	if (eIndex != YIELD_JFD_CRIME)
	{
		iValue += GetYieldFromCrime(eIndex);
		iValue += GetYieldFromDevelopment(eIndex);
	}
#endif

	return iValue;
}

/// Where is our Science coming from?
int CvCity::GetBaseScienceFromArt() const
{
	return GetBaseYieldRateFromLeague(YIELD_SCIENCE);
}

//	--------------------------------------------------------------------------------
/// Base yield rate from Great Works
int CvCity::GetBaseYieldRateFromGreatWorks(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (m_GwYieldCache[eIndex] == -1)
		m_GwYieldCache[eIndex] = GetCityBuildings()->GetYieldFromGreatWorks(eIndex);

	return m_GwYieldCache[eIndex];
}

//	--------------------------------------------------------------------------------
/// Base yield rate from Terrain
int CvCity::GetBaseYieldRateFromTerrain(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	return m_aiBaseYieldRateFromTerrain[eIndex];
}

//	--------------------------------------------------------------------------------
/// Base yield rate from Terrain
void CvCity::ChangeBaseYieldRateFromTerrain(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		if (m_aiBaseYieldRateFromTerrain[eIndex] + iChange < 0)
			CUSTOMLOG("houston, we have a problem! inconsistent yield in %s\n", getNameKey());

		m_aiBaseYieldRateFromTerrain[eIndex] += iChange;

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			if (isCitySelected())
			{
				DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
			}
		}
	}
}

/// Base yield rate from Terrain
void CvCity::SetBaseYieldRateFromTerrain(YieldTypes eIndex, int iValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iValue != m_aiBaseYieldRateFromTerrain[eIndex])
	{
		m_aiBaseYieldRateFromTerrain[eIndex] = iValue;

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			if (isCitySelected())
			{
				DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Base yield rate from Buildings
int CvCity::GetBaseYieldRateFromBuildings(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiBaseYieldRateFromBuildings[eIndex];
}

//	--------------------------------------------------------------------------------
/// Base yield rate from Buildings
void CvCity::ChangeBaseYieldRateFromBuildings(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiBaseYieldRateFromBuildings[eIndex] += iChange;

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			if (isCitySelected())
			{
				DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Base yield rate from Specialists
int CvCity::GetBaseYieldRateFromSpecialists(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	return m_aiBaseYieldRateFromSpecialists[eIndex];
}

//	--------------------------------------------------------------------------------
/// Base yield rate from Specialists
void CvCity::ChangeBaseYieldRateFromSpecialists(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiBaseYieldRateFromSpecialists[eIndex] = m_aiBaseYieldRateFromSpecialists[eIndex] + iChange;

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			if (isCitySelected())
			{
				DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Base yield rate from Misc
int CvCity::GetBaseYieldRateFromMisc(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	return m_aiBaseYieldRateFromMisc[eIndex];
}

//	--------------------------------------------------------------------------------
/// Base yield rate from Misc
void CvCity::ChangeBaseYieldRateFromMisc(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiBaseYieldRateFromMisc[eIndex] = m_aiBaseYieldRateFromMisc[eIndex] + iChange;

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			if (isCitySelected())
			{
				DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
			}
		}
	}
}
//	--------------------------------------------------------------------------------
//	Base yield rate from active conversion Process
int CvCity::GetBaseYieldRateFromProcess(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	// Process production into specific yield
	int iTradeRouteBonus = GET_PLAYER(m_eOwner).GetTrade()->GetTradeValuesAtCityTimes100(this, YIELD_PRODUCTION);
	return ((getBasicYieldRateTimes100(YIELD_PRODUCTION) + iTradeRouteBonus) * getProductionToYieldModifier(eIndex)) / 10000;
}

// Base yield rate from League
int CvCity::GetBaseYieldRateFromLeague(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	return m_aiBaseYieldRateFromLeague[eIndex];
}

//	--------------------------------------------------------------------------------
/// Base yield rate from League
void CvCity::ChangeBaseYieldRateFromLeague(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiBaseYieldRateFromLeague[eIndex] = m_aiBaseYieldRateFromLeague[eIndex] + iChange;

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			if (isCitySelected())
			{
				DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
			}
		}
	}
}
//SCIENCY AID - Used for negation if cancelled
void CvCity::ChangeTotalScienceyAid(int iChange)
{
	SetTotalScienceyAid(GetTotalScienceyAid() + iChange);
}

int CvCity::GetTotalScienceyAid() const
{
	return m_iTotalScienceyAid;
}

void CvCity::SetTotalScienceyAid(int iValue)
{
	if (GetTotalScienceyAid() != iValue)
		m_iTotalScienceyAid = iValue;
}

//ARTSY AID TOTALS  - Used for negation if cancelled
void CvCity::ChangeTotalArtsyAid(int iChange)
{
	SetTotalArtsyAid(GetTotalArtsyAid() + iChange);
}

int CvCity::GetTotalArtsyAid() const
{
	return m_iTotalArtsyAid;
}

void CvCity::SetTotalArtsyAid(int iValue)
{
	if (GetTotalArtsyAid() != iValue)
		m_iTotalArtsyAid = iValue;
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetGrowthExtraYield(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiChangeGrowthExtraYield[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeGrowthExtraYield(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiChangeGrowthExtraYield[eIndex] = m_aiChangeGrowthExtraYield[eIndex] + iChange;
		ASSERT_DEBUG(GetGrowthExtraYield(eIndex) >= 0);
	}
}
#endif
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromVictory(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromVictory[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromVictory(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromVictory[eIndex] = m_aiYieldFromVictory[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldFromVictory(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromVictoryGlobal(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromVictoryGlobal[eIndex];
}

void CvCity::ChangeYieldFromVictoryGlobal(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromVictoryGlobal[eIndex] = m_aiYieldFromVictoryGlobal[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldFromVictoryGlobal(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from building, scaling with era
int CvCity::GetYieldFromVictoryGlobalEraScaling(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
		ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromVictoryGlobalEraScaling[eIndex];
}

void CvCity::ChangeYieldFromVictoryGlobalEraScaling(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
		ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromVictoryGlobalEraScaling[eIndex] = m_aiYieldFromVictoryGlobalEraScaling[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldFromVictoryGlobalEraScaling(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromVictoryGlobalInGoldenAge(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromVictoryGlobalInGoldenAge[eIndex];
}

void CvCity::ChangeYieldFromVictoryGlobalInGoldenAge(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromVictoryGlobalInGoldenAge[eIndex] = m_aiYieldFromVictoryGlobalInGoldenAge[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldFromVictoryGlobalInGoldenAge(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from building, scaling with era
int CvCity::GetYieldFromVictoryGlobalInGoldenAgeEraScaling(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromVictoryGlobalInGoldenAgeEraScaling[eIndex];
}

void CvCity::ChangeYieldFromVictoryGlobalInGoldenAgeEraScaling(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromVictoryGlobalInGoldenAgeEraScaling[eIndex] = m_aiYieldFromVictoryGlobalInGoldenAgeEraScaling[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldFromVictoryGlobalInGoldenAgeEraScaling(eIndex) >= 0);
	}
}



int CvCity::GetYieldFromPillage(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromPillage[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromPillage(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromPillage[eIndex] = m_aiYieldFromPillage[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldFromPillage(eIndex) >= 0);
	}
}

int CvCity::GetYieldFromPillageGlobal(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromPillageGlobal[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromPillageGlobal(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromPillageGlobal[eIndex] = m_aiYieldFromPillageGlobal[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldFromPillageGlobal(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Instant yield when starting a golden age
int CvCity::GetYieldFromGoldenAgeStart(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromGoldenAgeStart[eIndex];
}

//	--------------------------------------------------------------------------------
/// Instant yield when starting a golden age
void CvCity::ChangeYieldFromGoldenAgeStart(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromGoldenAgeStart[eIndex] = m_aiYieldFromGoldenAgeStart[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldFromGoldenAgeStart(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Yields permanantly added to the city whenever a golden age starts
int CvCity::GetYieldChangePerGoldenAge(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldChangePerGoldenAge[eIndex];
}

//	--------------------------------------------------------------------------------
/// Yields permanantly added to the city whenever a golden age starts
void CvCity::ChangeYieldChangePerGoldenAge(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldChangePerGoldenAge[eIndex] = m_aiYieldChangePerGoldenAge[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldChangePerGoldenAge(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Cap to the yields permanantly added to the city whenever a golden age starts
int CvCity::GetYieldChangePerGoldenAgeCap(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldChangePerGoldenAgeCap[eIndex];
}

//	--------------------------------------------------------------------------------
/// Cap to the yields permanantly added to the city whenever a golden age starts
void CvCity::ChangeYieldChangePerGoldenAgeCap(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldChangePerGoldenAgeCap[eIndex] = m_aiYieldChangePerGoldenAgeCap[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldChangePerGoldenAgeCap(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Yields accumulated in the city from previous golden age starts (see YieldChangePerGoldenAge)
int CvCity::GetYieldFromPreviousGoldenAges(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromPreviousGoldenAges[eIndex];
}

//	--------------------------------------------------------------------------------
/// Cap to the yields permanantly added to the city whenever a golden age starts
void CvCity::ChangeYieldFromPreviousGoldenAges(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromPreviousGoldenAges[eIndex] = m_aiYieldFromPreviousGoldenAges[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldFromPreviousGoldenAges(eIndex) >= 0);

		ChangeBaseYieldRateFromMisc(eIndex, iChange);
		UpdateAllNonPlotYields(false);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetGoldenAgeYieldMod(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiGoldenAgeYieldMod[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeGoldenAgeYieldMod(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiGoldenAgeYieldMod[eIndex] = m_aiGoldenAgeYieldMod[eIndex] + iChange;
		ASSERT_DEBUG(GetGoldenAgeYieldMod(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from themed buildings
int CvCity::GetYieldChangesPerLocalTheme(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldChangesPerLocalTheme[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from themed buildings
void CvCity::ChangeYieldChangesPerLocalTheme(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldChangesPerLocalTheme[eIndex] = m_aiYieldChangesPerLocalTheme[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldChangesPerLocalTheme(eIndex) >= 0);
		ResetGreatWorkYieldCache();
	}
}


//	--------------------------------------------------------------------------------
/// Instant yields from gifting units
int CvCity::GetYieldFromUnitGiftGlobal(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromUnitGiftGlobal[eIndex];
}

//	--------------------------------------------------------------------------------
/// Instant yields from gifting units
void CvCity::ChangeYieldFromUnitGiftGlobal(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromUnitGiftGlobal[eIndex] = m_aiYieldFromUnitGiftGlobal[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldFromUnitGiftGlobal(eIndex) >= 0, "YieldFromUnitGiftGlobal expected to be >= 0");
		if (GetYieldFromUnitGiftGlobal(eIndex) > 0)
		{
			GET_PLAYER(getOwner()).setInstantYieldsFromUnitGift(true);
		}
	}

}


//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromWLTKD(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromWLTKD[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromWLTKD(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromWLTKD[eIndex] = m_aiYieldFromWLTKD[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldFromWLTKD(eIndex) >= 0);
	}
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromConstruction(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromConstruction[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromConstruction(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromConstruction[eIndex] = m_aiYieldFromConstruction[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldFromConstruction(eIndex) >= 0);
	}
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromTech(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromTech[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromTech(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromTech[eIndex] = m_aiYieldFromTech[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldFromTech(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Instant yield from birth (not scaling with era)
int CvCity::GetYieldFromBirth(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromBirth[eIndex];
}

//	--------------------------------------------------------------------------------
/// Instant yield from birth (not scaling from era)
void CvCity::ChangeYieldFromBirth(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromBirth[eIndex] += iChange;
		ASSERT_DEBUG(GetYieldFromBirth(eIndex) >= 0);
	}
}
//	--------------------------------------------------------------------------------
/// Instant yield from birth (scaling with era)
int CvCity::GetYieldFromBirthEraScaling(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromBirthEraScaling[eIndex];
}

//	--------------------------------------------------------------------------------
/// Instant yield from birth (scaling with era)
void CvCity::ChangeYieldFromBirthEraScaling(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromBirthEraScaling[eIndex] += iChange;
		ASSERT_DEBUG(GetYieldFromBirthEraScaling(eIndex) >= 0);
	}
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromUnitProduction(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromUnitProduction[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromUnitProduction(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromUnitProduction[eIndex] = m_aiYieldFromUnitProduction[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldFromUnitProduction(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromBorderGrowth(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromBorderGrowth[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromBorderGrowth(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromBorderGrowth[eIndex] = m_aiYieldFromBorderGrowth[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldFromBorderGrowth(eIndex) >= 0);
	}
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromPolicyUnlock(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromPolicyUnlock[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromPolicyUnlock(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromPolicyUnlock[eIndex] = m_aiYieldFromPolicyUnlock[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldFromPolicyUnlock(eIndex) >= 0);
	}
}
//	--------------------------------------------------------------------------------
/// Extra yield in all cities when purchasing something with gold
int CvCity::GetYieldFromPurchase(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromPurchase[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield in all cities when purchasing something with gold
void CvCity::ChangeYieldFromPurchase(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromPurchase[eIndex] = m_aiYieldFromPurchase[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldFromPurchase(eIndex) >= 0);
	}
}


//	--------------------------------------------------------------------------------
/// Extra yield in all cities when purchasing something with gold
int CvCity::GetYieldFromPurchaseGlobal(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
		ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromPurchaseGlobal[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield in all cities when purchasing something with gold
void CvCity::ChangeYieldFromPurchaseGlobal(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
		ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromPurchaseGlobal[eIndex] = m_aiYieldFromPurchaseGlobal[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldFromPurchaseGlobal(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromFaithPurchase(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromFaithPurchase[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromFaithPurchase(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromFaithPurchase[eIndex] = m_aiYieldFromFaithPurchase[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldFromFaithPurchase(eIndex) >= 0);
	}
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromUnitLevelUp(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromUnitLevelUp[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromUnitLevelUp(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromUnitLevelUp[eIndex] = m_aiYieldFromUnitLevelUp[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldFromUnitLevelUp(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromCombatExperienceTimes100(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromCombatExperienceTimes100[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromCombatExperienceTimes100(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromCombatExperienceTimes100[eIndex] = m_aiYieldFromCombatExperienceTimes100[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldFromCombatExperienceTimes100(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldPerAlly(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldPerAlly[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldPerAlly(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldPerAlly[eIndex] = m_aiYieldPerAlly[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldPerAlly(eIndex) >= 0);
	}
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldPerFriend(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldPerFriend[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldPerFriend(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldPerFriend[eIndex] = m_aiYieldPerFriend[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldPerFriend(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetRealYieldFromYield(YieldTypes eIndex1, YieldTypes eIndex2) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex1 >= 0, "eIndex1 expected to be >= 0");
	ASSERT_DEBUG(eIndex1 < NUM_YIELD_TYPES, "eIndex1 expected to be < NUM_YIELD_TYPES");
	ASSERT_DEBUG(eIndex2 >= 0, "eIndex2 expected to be >= 0");
	ASSERT_DEBUG(eIndex2 < NUM_YIELD_TYPES, "eIndex2 expected to be < NUM_YIELD_TYPES");

	return ModifierLookup(m_yieldChanges[eIndex2].forActualYield, eIndex1);
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::SetRealYieldFromYield(YieldTypes eIndex1, YieldTypes eIndex2, int iValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex1 >= 0, "eIndex1 expected to be >= 0");
	ASSERT_DEBUG(eIndex1 < NUM_YIELD_TYPES, "eIndex1 expected to be < NUM_YIELD_TYPES");
	ASSERT_DEBUG(eIndex2 >= 0, "eIndex2 expected to be >= 0");
	ASSERT_DEBUG(eIndex2 < NUM_YIELD_TYPES, "eIndex2 expected to be < NUM_YIELD_TYPES");

	ModifierUpdateInsertRemove(m_yieldChanges[eIndex2].forActualYield, eIndex1, iValue, false);
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetBuildingYieldFromYield(YieldTypes eIndex1, YieldTypes eIndex2) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eIndex1 < NUM_YIELD_TYPES, "eIndex1 is expected to be within maximum bounds (invalid Index)");
	ASSERT_DEBUG(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	return ModifierLookup(m_yieldChanges[eIndex2].forYield, eIndex1);
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeBuildingYieldFromYield(YieldTypes eIndex1, YieldTypes eIndex2, int iValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eIndex1 < NUM_YIELD_TYPES, "eIndex1 is expected to be within maximum bounds (invalid Index)");
	ASSERT_DEBUG(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	ASSERT_DEBUG(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	ModifierUpdateInsertRemove(m_yieldChanges[eIndex2].forYield, eIndex1, iValue, true);
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromInternationalTREnd(YieldTypes eIndex1) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex1 >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex1 < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	return m_aiYieldFromInternationalTREnd[eIndex1];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromInternationalTREnd(YieldTypes eIndex1, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex1 >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex1 < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	if (iChange != 0)
	{
		m_aiYieldFromInternationalTREnd[eIndex1] = m_aiYieldFromInternationalTREnd[eIndex1] + iChange;
		ASSERT_DEBUG(GetYieldFromInternationalTREnd(eIndex1) >= 0, "YieldFromInternationalTREnd expected to be >= 0");
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromInternalTREnd(YieldTypes eIndex1) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex1 >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex1 < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	return m_aiYieldFromInternalTREnd[eIndex1];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromInternalTREnd(YieldTypes eIndex1, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex1 >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex1 < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	if (iChange != 0)
	{
		m_aiYieldFromInternalTREnd[eIndex1] = m_aiYieldFromInternalTREnd[eIndex1] + iChange;
		ASSERT_DEBUG(GetYieldFromInternalTREnd(eIndex1) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromInternalTR(YieldTypes eIndex1) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex1 >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex1 < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	return m_aiYieldFromInternalTR[eIndex1];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromInternalTR(YieldTypes eIndex1, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex1 >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex1 < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	if (iChange != 0)
	{
		m_aiYieldFromInternalTR[eIndex1] = m_aiYieldFromInternalTR[eIndex1] + iChange;
		ASSERT_DEBUG(GetYieldFromInternalTR(eIndex1) >= 0);
	}
}


//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromProcessModifier(YieldTypes eIndex1) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex1 >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex1 < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	return m_aiYieldFromProcessModifier[eIndex1];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromProcessModifier(YieldTypes eIndex1, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex1 >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex1 < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	if (iChange != 0)
	{
		m_aiYieldFromProcessModifier[eIndex1] = m_aiYieldFromProcessModifier[eIndex1] + iChange;
		ASSERT_DEBUG(GetYieldFromProcessModifier(eIndex1) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield when a b'ak'tun ends
int CvCity::GetYieldFromLongCount(YieldTypes eIndex1) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex1 >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex1 < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	return m_aiYieldFromLongCount[eIndex1];
}

//	--------------------------------------------------------------------------------
/// Extra yield when a b'ak'tun ends
void CvCity::ChangeYieldFromLongCount(YieldTypes eIndex1, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex1 >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex1 < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	if (iChange != 0)
	{
		m_aiYieldFromLongCount[eIndex1] = m_aiYieldFromLongCount[eIndex1] + iChange;
		ASSERT_DEBUG(GetYieldFromLongCount(eIndex1) >= 0, "YieldFromLongCount expected to be >= 0");
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield when a Great Writer is born
int CvCity::GetYieldFromGPBirthScaledWithWriterBulb(YieldTypes eIndex1) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex1 >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex1 < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	return m_aiYieldFromGPBirthScaledWithWriterBulb[eIndex1];
}

//	--------------------------------------------------------------------------------
/// Extra yield when a Great Writer is born
void CvCity::ChangeYieldFromGPBirthScaledWithWriterBulb(YieldTypes eIndex1, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex1 >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex1 < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	if (iChange != 0)
	{
		m_aiYieldFromGPBirthScaledWithWriterBulb[eIndex1] = m_aiYieldFromGPBirthScaledWithWriterBulb[eIndex1] + iChange;
		ASSERT_DEBUG(GetYieldFromGPBirthScaledWithWriterBulb(eIndex1) >= 0, "YieldFromGPBirthScaledWithWriterBulb expected to be >= 0");
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield when a Great Artist is born
int CvCity::GetYieldFromGPBirthScaledWithArtistBulb(YieldTypes eIndex1) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex1 >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex1 < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	return m_aiYieldFromGPBirthScaledWithArtistBulb[eIndex1];
}

//	--------------------------------------------------------------------------------
/// Extra yield when a Great Artist is born
void CvCity::ChangeYieldFromGPBirthScaledWithArtistBulb(YieldTypes eIndex1, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex1 >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex1 < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	if (iChange != 0)
	{
		m_aiYieldFromGPBirthScaledWithArtistBulb[eIndex1] = m_aiYieldFromGPBirthScaledWithArtistBulb[eIndex1] + iChange;
		ASSERT_DEBUG(GetYieldFromGPBirthScaledWithArtistBulb(eIndex1) >= 0, "YieldFromGPBirthScaledWithArtistBulb expected to be >= 0");
	}
}

//	--------------------------------------------------------------------------------
/// Instant yield when a Great Person is born based on the yield output of the city
map<GreatPersonTypes, map<std::pair<YieldTypes, YieldTypes>, int>> CvCity::GetYieldFromGPBirthScaledWithPerTurnYieldMap() const
{
	return m_miYieldFromGPBirthScaledWithPerTurnYield;
}
//	--------------------------------------------------------------------------------
/// Instant yield when a Great Person is born based on the yield output of the city
int CvCity::GetYieldFromGPBirthScaledWithPerTurnYield(GreatPersonTypes eGreatPerson, YieldTypes eYieldIn, YieldTypes eYieldOut) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eGreatPerson >= 0, "eYieldIn expected to be >= 0");
	ASSERT_DEBUG(eGreatPerson < GC.getNumGreatPersonInfos(), "eYieldIn expected to be < getNumGreatPersonInfos()");
	ASSERT_DEBUG(eYieldIn >= 0, "eYieldIn expected to be >= 0");
	ASSERT_DEBUG(eYieldIn < NUM_YIELD_TYPES, "eYieldIn expected to be < NUM_YIELD_TYPES");
	ASSERT_DEBUG(eYieldOut >= 0, "eYieldOut expected to be >= 0");
	ASSERT_DEBUG(eYieldOut < NUM_YIELD_TYPES, "eYieldOut expected to be < NUM_YIELD_TYPES");

	map<GreatPersonTypes, map<std::pair<YieldTypes, YieldTypes>, int>>::const_iterator it = m_miYieldFromGPBirthScaledWithPerTurnYield.find(eGreatPerson);
	if (it != m_miYieldFromGPBirthScaledWithPerTurnYield.end()) // find returns the iterator to map::end if the key i is not present in the map
	{
		map<std::pair<YieldTypes, YieldTypes>, int> miYieldMap = it->second;
		map<std::pair<YieldTypes, YieldTypes>, int>::const_iterator it2 = miYieldMap.find(std::make_pair(eYieldIn, eYieldOut));
		if (it2 != miYieldMap.end())
		{
			return it2->second;
		}
	}

	return 0;
}
//	--------------------------------------------------------------------------------
/// Instant yield when a Great Person is born based on the yield output of the city
void CvCity::ChangeYieldFromGPBirthScaledWithPerTurnYield(GreatPersonTypes eGreatPerson, std::pair<YieldTypes, YieldTypes> eYieldPair, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eGreatPerson >= 0, "eYieldIn expected to be >= 0");
	ASSERT_DEBUG(eGreatPerson < GC.getNumGreatPersonInfos(), "eYieldIn expected to be < getNumGreatPersonInfos()");
	ASSERT_DEBUG(eYieldPair.first >= 0, "eYieldIn expected to be >= 0");
	ASSERT_DEBUG(eYieldPair.first < NUM_YIELD_TYPES, "eYieldIn expected to be < NUM_YIELD_TYPES");
	ASSERT_DEBUG(eYieldPair.second >= 0, "eYieldOut expected to be >= 0");
	ASSERT_DEBUG(eYieldPair.second < NUM_YIELD_TYPES, "eYieldOut expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_miYieldFromGPBirthScaledWithPerTurnYield[eGreatPerson][eYieldPair] += iChange;
		ASSERT_DEBUG(m_miYieldFromGPBirthScaledWithPerTurnYield[eGreatPerson][eYieldPair] >= 0);

		if (m_miYieldFromGPBirthScaledWithPerTurnYield[eGreatPerson][eYieldPair] == 0)
		{
			m_miYieldFromGPBirthScaledWithPerTurnYield[eGreatPerson].erase(eYieldPair);
			if (m_miYieldFromGPBirthScaledWithPerTurnYield[eGreatPerson].empty())
			{
				m_miYieldFromGPBirthScaledWithPerTurnYield.erase(eGreatPerson);
			}
		}
	}
}

/// Extra yield from building
int CvCity::GetSpecialistRateModifierFromBuildings(SpecialistTypes eSpecialist) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eSpecialist >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eSpecialist < GC.getNumSpecialistInfos(), "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiSpecialistRateModifierFromBuildings[eSpecialist];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeSpecialistRateModifierFromBuildings(SpecialistTypes eSpecialist, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eSpecialist >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eSpecialist < GC.getNumSpecialistInfos(), "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiSpecialistRateModifierFromBuildings[eSpecialist] = m_aiSpecialistRateModifierFromBuildings[eSpecialist] + iChange;
		ASSERT_DEBUG(GetSpecialistRateModifierFromBuildings(eSpecialist) >= 0);
	}
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetThemingYieldBonus(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiThemingYieldBonus[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeThemingYieldBonus(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiThemingYieldBonus[eIndex] = m_aiThemingYieldBonus[eIndex] + iChange;
		ASSERT_DEBUG(GetThemingYieldBonus(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from spy attacks
int CvCity::GetYieldFromSpyAttack(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromSpyAttack[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromSpyAttack(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromSpyAttack[eIndex] = m_aiYieldFromSpyAttack[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldFromSpyAttack(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from spy defense
int CvCity::GetYieldFromSpyDefense(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromSpyDefense[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from spy defense
void CvCity::ChangeYieldFromSpyDefense(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromSpyDefense[eIndex] = m_aiYieldFromSpyDefense[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldFromSpyDefense(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from spy identify
int CvCity::GetYieldFromSpyIdentify(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromSpyIdentify[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from spy identify
void CvCity::ChangeYieldFromSpyIdentify(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromSpyIdentify[eIndex] = m_aiYieldFromSpyIdentify[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldFromSpyIdentify(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from spy defense or id
int CvCity::GetYieldFromSpyDefenseOrID(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromSpyDefenseOrID[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from spy defense or id
void CvCity::ChangeYieldFromSpyDefenseOrID(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromSpyDefenseOrID[eIndex] = m_aiYieldFromSpyDefenseOrID[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldFromSpyDefenseOrID(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from spy rig election
int CvCity::GetYieldFromSpyRigElection(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromSpyRigElection[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from rig election
void CvCity::ChangeYieldFromSpyRigElection(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromSpyRigElection[eIndex] = m_aiYieldFromSpyRigElection[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldFromSpyRigElection(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield per city strength
int CvCity::GetYieldChangesPerCityStrengthTimes100(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldChangesPerCityStrengthTimes100[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield per city strength
void CvCity::ChangeYieldChangesPerCityStrengthTimes100(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldChangesPerCityStrengthTimes100[eIndex] = m_aiYieldChangesPerCityStrengthTimes100[eIndex] + iChange;
		ASSERT_DEBUG(GetYieldChangesPerCityStrengthTimes100(eIndex) >= 0, "YieldChangesPerCityStrengthTimes100 expected to be >= 0");
	}
}
#endif
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Extra great person progress from constructing buildings
int CvCity::GetGreatPersonProgressFromConstruction(GreatPersonTypes eGreatPerson, EraTypes eEra) const
{
	VALIDATE_OBJECT();

	ASSERT_DEBUG(eGreatPerson >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eGreatPerson < GC.getNumGreatPersonInfos(), "eIndex expected to be < GC.getNumGreatPersonInfos()");

	ASSERT_DEBUG(eEra >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eEra < GC.getNumEraInfos(), "eIndex expected to be < GC.getNumEraInfos()");

	if (eGreatPerson != NO_GREATPERSON && eEra != NO_ERA)
	{
		std::map<std::pair<int, int>, short>::const_iterator it = m_ppiGreatPersonProgressFromConstruction.find(std::make_pair((int)eGreatPerson, (int)eEra));
		if (it != m_ppiGreatPersonProgressFromConstruction.end()) // find returns the iterator to map::end if the key eGreatPerson is not present in the map
		{
			return it->second;
		}
	}

	return 0;
}

//	--------------------------------------------------------------------------------
/// Extra great person progress from constructing buildings
void CvCity::ChangeGreatPersonProgressFromConstruction(GreatPersonTypes eGreatPerson, EraTypes eEra, int iChange)
{
	VALIDATE_OBJECT();

	ASSERT_DEBUG(eGreatPerson >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eGreatPerson < GC.getNumGreatPersonInfos(), "eIndex expected to be < GC.getNumGreatPersonInfos()");

	ASSERT_DEBUG(eEra >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eEra < GC.getNumEraInfos(), "eIndex expected to be < GC.getNumEraInfos()");

	if (eGreatPerson != NO_GREATPERSON && eEra != NO_ERA && iChange != 0)
	{
		std::map<std::pair<int, int>, short>::iterator it = m_ppiGreatPersonProgressFromConstruction.find(std::make_pair((int)eGreatPerson, (int)eEra));
		if (it == m_ppiGreatPersonProgressFromConstruction.end()) // if the key (eGreatPerson, eEra) does not exist
		{
			m_ppiGreatPersonProgressFromConstruction.insert(std::pair<std::pair<int, int>, short>(std::make_pair((int)eGreatPerson, (int)eEra), iChange));
		}
		else // if the key (eGreatPerson, eEra) does exist
		{
			it->second += iChange;
		}
	}
}
#endif

//	--------------------------------------------------------------------------------
int CvCity::GetEmpireSizeModifierReduction() const
{
	return m_iEmpireSizeModifierReduction;
}
void CvCity::ChangeEmpireSizeModifierReduction(int iChange)
{
	m_iEmpireSizeModifierReduction += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetDistressFlatReduction() const
{
	return m_iDistressFlatReduction;
}
void CvCity::ChangeDistressFlatReduction(int iChange)
{
	m_iDistressFlatReduction += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetPovertyFlatReduction() const
{
	return m_iPovertyFlatReduction;
}
void CvCity::ChangePovertyFlatReduction(int iChange)
{
	m_iPovertyFlatReduction += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetIlliteracyFlatReduction() const
{
	return m_iIlliteracyFlatReduction;
}
void CvCity::ChangeIlliteracyFlatReduction(int iChange)
{
	m_iIlliteracyFlatReduction += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetBoredomFlatReduction() const
{
	return m_iBoredomFlatReduction;
}
void CvCity::ChangeBoredomFlatReduction(int iChange)
{
	m_iBoredomFlatReduction += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetReligiousUnrestFlatReduction() const
{
	return m_iReligiousUnrestFlatReduction;
}
void CvCity::ChangeReligiousUnrestFlatReduction(int iChange)
{
	m_iReligiousUnrestFlatReduction += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetBasicNeedsMedianModifier() const
{
	if (isCapital())
		return m_iBasicNeedsMedianModifier + GET_PLAYER(getOwner()).GetBasicNeedsMedianModifierCapital();

	return m_iBasicNeedsMedianModifier;
}
void CvCity::ChangeBasicNeedsMedianModifier(int iChange)
{
	m_iBasicNeedsMedianModifier += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetGoldMedianModifier() const
{
	if (isCapital())
		return m_iGoldMedianModifier + GET_PLAYER(getOwner()).GetGoldMedianModifierCapital();

	return m_iGoldMedianModifier;
}
void CvCity::ChangeGoldMedianModifier(int iChange)
{
	m_iGoldMedianModifier += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetScienceMedianModifier() const
{
	if (isCapital())
		return m_iScienceMedianModifier + GET_PLAYER(getOwner()).GetScienceMedianModifierCapital();

	return m_iScienceMedianModifier;
}
void CvCity::ChangeScienceMedianModifier(int iChange)
{
	m_iScienceMedianModifier += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetCultureMedianModifier() const
{
	if (isCapital())
		return m_iCultureMedianModifier + GET_PLAYER(getOwner()).GetCultureMedianModifierCapital();

	return m_iCultureMedianModifier;
}
void CvCity::ChangeCultureMedianModifier(int iChange)
{
	m_iCultureMedianModifier += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetReligiousUnrestModifier() const
{
	if (isCapital())
		return m_iReligiousUnrestModifier + GET_PLAYER(getOwner()).GetReligiousUnrestModifierCapital();

	return m_iReligiousUnrestModifier;
}
void CvCity::ChangeReligiousUnrestModifier(int iChange)
{
	m_iReligiousUnrestModifier += iChange;
}

//	--------------------------------------------------------------------------------
/// Base yield rate from Religion
int CvCity::GetBaseYieldRateFromReligion(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	int iBaseYield = m_aiBaseYieldRateFromReligion[eIndex];

	const SCityExtraYields& y = GetYieldChanges(eIndex);
	for (vector<pair<TerrainTypes, int>>::const_iterator it = y.forTerrainFromReligion.begin(); it != y.forTerrainFromReligion.end(); ++it)
		iBaseYield += it->second;
	for (vector<pair<FeatureTypes, int>>::const_iterator it = y.forFeatureFromReligion.begin(); it != y.forFeatureFromReligion.end(); ++it)
		iBaseYield += it->second;

	if (GET_PLAYER(getOwner()).GetPlayerTraits()->GetYieldFromOwnPantheon(eIndex) > 0)
	{
		ReligionTypes eReligionFounded = GET_PLAYER(getOwner()).GetReligions()->GetOwnedReligion();
		if (eReligionFounded == NO_RELIGION)
			eReligionFounded = GET_PLAYER(getOwner()).GetReligions()->GetReligionCreatedByPlayer(true);

		if (MOD_BALANCE_CORE_BELIEFS && eReligionFounded >= RELIGION_PANTHEON)
		{
			ReligionTypes eMajorityReligion = GetCityReligions()->GetReligiousMajority();
			ReligionTypes ePlayerPantheon = GC.getGame().GetGameReligions()->GetPantheonCreatedByPlayer(getOwner());
			if (eMajorityReligion != NO_RELIGION && (eMajorityReligion == eReligionFounded || eMajorityReligion == ePlayerPantheon))
			{
				iBaseYield += GET_PLAYER(getOwner()).GetPlayerTraits()->GetYieldFromOwnPantheon(eIndex);
			}
		}
	}
	// This will only return a value for food and production
	iBaseYield += GetYieldPerTurnFromReligion(eIndex);

	return iBaseYield;
}
//	--------------------------------------------------------------------------------
/// Base yield rate from Religion
void CvCity::ChangeBaseYieldRateFromReligion(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiBaseYieldRateFromReligion[eIndex] = m_aiBaseYieldRateFromReligion[eIndex] + iChange;

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			if (isCitySelected())
			{
				DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
			}
		}
	}
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// EFFECTIVE yield rate from CS Alliances (name is misleading)
int CvCity::GetBaseYieldRateFromCSAlliance(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	int iValue = m_aiBaseYieldRateFromCSAlliance[eIndex];
	const CvPlayer& kPlayer = GET_PLAYER(getOwner());
	int iModifier = kPlayer.GetPlayerTraits()->GetCityStateBonusModifier();
	//policy effects
	iModifier += kPlayer.GetCSYieldBonusModifier();
	//cannot check for religion based modifier, we don't know the religion of the originating city state here ...

	if (MOD_CITY_STATE_SCALE)
		iModifier += max(0, GetPlayer()->getNumCities() - 1) * GD_INT_GET(CITY_STATE_SCALE_PER_CITY_MOD);

	if (iModifier > 0)
	{
		iValue *= 100 + iModifier;
		iValue /= 100;
	}

	int iBonus = GetYieldPerAlly(eIndex) * GET_PLAYER(getOwner()).GetNumCSAllies();
	return iValue + iBonus;
}
//	--------------------------------------------------------------------------------
/// Base yield rate from CS Alliances
void CvCity::ChangeBaseYieldRateFromCSAlliance(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiBaseYieldRateFromCSAlliance[eIndex] += iChange;
		ASSERT_DEBUG(GetBaseYieldRateFromCSAlliance(eIndex) >= 0);
	}
}
void CvCity::SetBaseYieldRateFromCSAlliance(YieldTypes eIndex, int iValue)
{
	if (GetBaseYieldRateFromCSAlliance(eIndex) != iValue)
	{
		m_aiBaseYieldRateFromCSAlliance[eIndex] = iValue;
	}
}
//	--------------------------------------------------------------------------------
/// EFFECTIVE yield rate from CS Friendships (name is misleading)
int CvCity::GetBaseYieldRateFromCSFriendship(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	int iValue = m_aiBaseYieldRateFromCSFriendship[eIndex];
	const CvPlayer& kPlayer = GET_PLAYER(getOwner());
	int iModifier = kPlayer.GetPlayerTraits()->GetCityStateBonusModifier();
	//policy effects
	iModifier += kPlayer.GetCSYieldBonusModifier();
	//cannot check for religion based modifier, we don't know the religion of the originating city state here ...

	if (MOD_CITY_STATE_SCALE)
		iModifier += max(0, GetPlayer()->getNumCities() - 1) * GD_INT_GET(CITY_STATE_SCALE_PER_CITY_MOD);

	if (iModifier > 0)
	{
		iValue *= 100 + iModifier;
		iValue /= 100;
	}

	int iBonus = GetYieldPerFriend(eIndex) * GET_PLAYER(getOwner()).GetNumCSFriends();
	return iValue + iBonus;

}
void CvCity::ChangeBaseYieldRateFromCSFriendship(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiBaseYieldRateFromCSFriendship[eIndex] += iChange;
		ASSERT_DEBUG(GetBaseYieldRateFromCSFriendship(eIndex) >= 0);
	}
}
void CvCity::SetBaseYieldRateFromCSFriendship(YieldTypes eIndex, int iValue)
{
	if (GetBaseYieldRateFromCSFriendship(eIndex) != iValue)
	{
		m_aiBaseYieldRateFromCSFriendship[eIndex] = iValue;
	}
}

void CvCity::SetYieldFromMinors(YieldTypes eYield, int iValue)
{
	m_aiYieldFromMinors[eYield] = iValue;
}
int CvCity::GetYieldFromMinors(YieldTypes eYield) const
{
	return m_aiYieldFromMinors[eYield];
}
//CORPORATIONS
//	--------------------------------------------------------------------------------
// Get the yield modifier change from having a Corporation
int CvCity::GetTradeRouteCityMod(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	CorporationTypes eCorporation = GET_PLAYER(getOwner()).GetCorporations()->GetFoundedCorporation();
	if (eCorporation == NO_CORPORATION)
		return 0;

	CvCorporationEntry* pkCorporationInfo = GC.getCorporationInfo(eCorporation);
	if (pkCorporationInfo == NULL)
		return 0;

	// If our Corporation does not have a city yield mod, remove
	if (pkCorporationInfo->GetTradeRouteCityMod(eIndex) == 0)
		return 0;

	if (!IsHasOffice())
		return 0;

	int iMod = 0;
	CvGameTrade* pGameTrade = GC.getGame().GetGameTrade();
	for (uint ui = 0; ui < pGameTrade->GetNumTradeConnections(); ui++)
	{
		if (pGameTrade->IsTradeRouteIndexEmpty(ui))
			continue;

		const TradeConnection& conn = pGameTrade->GetTradeConnection(ui);
		if (conn.m_eOriginOwner != getOwner()) //fast check
			continue;

		CvCity* pOriginCity = CvGameTrade::GetOriginCity(conn);
		if (pOriginCity != this)
			continue;

		CvCity* pDestCity = CvGameTrade::GetDestCity(conn);
		if (pOriginCity != NULL && pDestCity != NULL)
		{
			if (pOriginCity->IsHasOffice() && pDestCity->IsHasFranchise(eCorporation))
			{
				iMod += pkCorporationInfo->GetTradeRouteCityMod(eIndex);
			}
		}
	}
	return iMod;
}

int CvCity::GetGPRateModifierPerXFranchises() const
{
	CvPlayer& kOwner = GET_PLAYER(getOwner());
	CorporationTypes eCorporation = kOwner.GetCorporations()->GetFoundedCorporation();
	if (eCorporation == NO_CORPORATION)
		return 0;

	CvCorporationEntry* pkCorporationInfo = GC.getCorporationInfo(eCorporation);
	if (!pkCorporationInfo)
		return 0;

	BuildingClassTypes eOfficeClass = pkCorporationInfo->GetOfficeBuildingClass();
	BuildingTypes eOffice = GetBuildingTypeFromClass(eOfficeClass, true);

	if (eOffice == NO_BUILDING)
		return 0;

	CvBuildingEntry* pkOfficeInfo = GC.getBuildingInfo(eOffice);
	if (!pkOfficeInfo)
		return 0;

	int iNumFranchises = kOwner.GetCorporations()->GetNumFranchises();
	return pkOfficeInfo->GetGPRateModifierPerXFranchises() * iNumFranchises;
}

bool CvCity::IsHeadquarters() const
{
	VALIDATE_OBJECT();

	CorporationTypes eCorporation = GET_PLAYER(getOwner()).GetCorporations()->GetFoundedCorporation();
	if (eCorporation == NO_CORPORATION)
		return false;

	CvCorporationEntry* pkCorporationInfo = GC.getCorporationInfo(eCorporation);
	if (pkCorporationInfo == NULL)
		return false;

	BuildingClassTypes eHeadquarters = pkCorporationInfo->GetHeadquartersBuildingClass();
	if (eHeadquarters == NO_BUILDINGCLASS)
		return false;

	return HasBuildingClass(eHeadquarters);
}

bool CvCity::IsHasOffice() const
{
	VALIDATE_OBJECT();

	CorporationTypes eCorporation = GET_PLAYER(getOwner()).GetCorporations()->GetFoundedCorporation();
	if (eCorporation == NO_CORPORATION)
		return false;

	CvCorporationEntry* pkCorporationInfo = GC.getCorporationInfo(eCorporation);
	if (!pkCorporationInfo)
		return false;

	BuildingClassTypes eOfficeClass = pkCorporationInfo->GetOfficeBuildingClass();
	if (eOfficeClass == NO_BUILDINGCLASS)
		return false;

	return HasBuildingClass(eOfficeClass);
}

bool CvCity::IsHasFranchise(CorporationTypes eCorporation) const
{
	VALIDATE_OBJECT();

	if (eCorporation == NO_CORPORATION)
		return false;

	CvCorporationEntry* pkCorporationInfo = GC.getCorporationInfo(eCorporation);
	if (!pkCorporationInfo)
		return false;

	// Evaluate offices as franchises if we count Offices as Franchises
	bool bOfficesAsFranchises = GetPlayer()->GetCorporations()->IsCorporationOfficesAsFranchises();
	BuildingClassTypes eFranchiseClass = bOfficesAsFranchises ? pkCorporationInfo->GetOfficeBuildingClass() : pkCorporationInfo->GetFranchiseBuildingClass();
	if (eFranchiseClass == NO_BUILDINGCLASS)
		return false;

	// If nationalized, then the City owner and the corporation owner must be equal
	if (bOfficesAsFranchises)
	{
		CvCorporation* pCorporation = GC.getGame().GetGameCorporations()->GetCorporation(eCorporation);
		if (pCorporation)
		{
			if (getOwner() != pCorporation->m_eFounder)
				return false;
		}
	}

	return HasBuildingClass(eFranchiseClass);
}

// Returns the yield change for this building based on the number of franchises
int CvCity::GetBuildingYieldChangeFromCorporationFranchises(BuildingClassTypes eBuildingClass, YieldTypes eIndex) const
{
	VALIDATE_OBJECT();

	ASSERT_DEBUG(eBuildingClass >= 0, "eBuildingClass expected to be greater or equal to 0");
	ASSERT_DEBUG(eBuildingClass < GC.getNumBuildingClassInfos(), "eBuildingClass expected to be < GC.getNumBuildingClassInfos()");

	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	CvPlayer& kPlayer = GET_PLAYER(getOwner());

	BuildingTypes eBuilding = GetBuildingTypeFromClass(eBuildingClass, true);
	if (eBuilding == NO_BUILDING)
		return 0;

	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if (!pkBuildingInfo)
		return 0;

	int iYieldPerFranchise = pkBuildingInfo->GetYieldPerFranchise(eIndex);
	int iFranchises = kPlayer.GetCorporations()->GetNumFranchises();

	return iYieldPerFranchise * iFranchises;
}

void CvCity::SetYieldChangeFromCorporationFranchises(YieldTypes eIndex, int iTotal)
{
	if (GetYieldChangeFromCorporationFranchises(eIndex) != iTotal)
	{
		m_aiYieldChangeFromCorporationFranchises[eIndex] = iTotal;
	}
}
int CvCity::GetYieldChangeFromCorporationFranchises(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	return m_aiYieldChangeFromCorporationFranchises[eIndex];
}

void CvCity::UpdateYieldFromCorporationFranchises(YieldTypes eIndex)
{
	int iTotal = 0;
	for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
	{
		BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iI);
		int iNumBuildingClass = GetCityBuildings()->GetNumBuildingClass(eBuildingClass);
		iTotal += GetBuildingYieldChangeFromCorporationFranchises(eBuildingClass, eIndex) * iNumBuildingClass;
	}

	SetYieldChangeFromCorporationFranchises(eIndex, iTotal);
}

//	--------------------------------------------------------------------------------
int CvCity::GetResourceQuantityPerXFranchises(ResourceTypes eResource) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eResource >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eResource < GC.getNumResourceInfos(), "eIndex expected to be < GC.getNumResourceInfos()");
	return m_aiResourceQuantityPerXFranchises[eResource];
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeResourceQuantityPerXFranchises(ResourceTypes eResource, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eResource >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eResource < GC.getNumResourceInfos(), "eIndex expected to be < GC.getNumResourceInfos()");

	if (iChange != 0)
	{
		m_aiResourceQuantityPerXFranchises[eResource] = m_aiResourceQuantityPerXFranchises[eResource] + iChange;
		//		ASSERT_DEBUG(GetCorporationResourceQuantity(eResource) >= 0); 
	}
}
void CvCity::SetResourceQuantityPerXFranchises(ResourceTypes eResource, int iValue)
{
	if (GetResourceQuantityPerXFranchises(eResource) != iValue)
	{
		m_aiResourceQuantityPerXFranchises[eResource] = iValue;
	}
}
//	--------------------------------------------------------------------------------
int CvCity::GetResourceQuantityFromPOP(ResourceTypes eResource) const
{
	VALIDATE_OBJECT();
	return m_aiResourceQuantityFromPOP[eResource];
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeResourceQuantityFromPOP(ResourceTypes eResource, int iChange)
{
	VALIDATE_OBJECT();
	SetResourceQuantityFromPOP(eResource, GetResourceQuantityFromPOP(eResource) + iChange);
}
void CvCity::SetResourceQuantityFromPOP(ResourceTypes eResource, int iValue)
{
	m_aiResourceQuantityFromPOP[eResource] = iValue;
}
//	--------------------------------------------------------------------------------
/// Trade Route Religious Spread Boost
int CvCity::GetReligiousTradeModifier() const
{
	VALIDATE_OBJECT();
	return m_iReligiousTradeModifier;
}
void CvCity::ChangeReligiousTradeModifier(int iChange)
{
	VALIDATE_OBJECT();
	if (iChange != 0)
	{
		SetReligiousTradeModifier(GetReligiousTradeModifier() + iChange);
	}
}
void CvCity::SetReligiousTradeModifier(int iValue)
{
	VALIDATE_OBJECT();
	m_iReligiousTradeModifier = iValue;
}


int CvCity::GetCityAirStrikeDefense() const
{
	VALIDATE_OBJECT();
	return m_iCityAirStrikeDefense;
}
void CvCity::ChangeCityAirStrikeDefense(int iChange)
{
	VALIDATE_OBJECT();
	if (iChange != 0)
	{
		SetCityAirStrikeDefense(GetCityAirStrikeDefense() + iChange);
	}
}
void CvCity::SetCityAirStrikeDefense(int iValue)
{
	VALIDATE_OBJECT();
	m_iCityAirStrikeDefense = iValue;
}

//	--------------------------------------------------------------------------------
/// Free building built in target trade city (foreign)
int CvCity::GetFreeBuildingTradeTargetCity() const
{
	VALIDATE_OBJECT();
	return m_iFreeBuildingTradeTargetCity;
}
void CvCity::ChangeFreeBuildingTradeTargetCity(int iChange)
{
	VALIDATE_OBJECT();
	if (iChange != 0)
	{
		SetFreeBuildingTradeTargetCity(GetFreeBuildingTradeTargetCity() + iChange);
	}
}
void CvCity::SetFreeBuildingTradeTargetCity(int iValue)
{
	VALIDATE_OBJECT();
	m_iFreeBuildingTradeTargetCity = iValue;
}


//	--------------------------------------------------------------------------------
int CvCity::GetLandTourismBonus() const
{
	VALIDATE_OBJECT();
	return m_iLandTourismBonus;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeLandTourismBonus(int iChange)
{
	VALIDATE_OBJECT();
	m_iLandTourismBonus = (m_iLandTourismBonus + iChange);
}
//	--------------------------------------------------------------------------------
void CvCity::SetLandTourismBonus(int iChange)
{
	VALIDATE_OBJECT();
	m_iLandTourismBonus = iChange;
}


//	--------------------------------------------------------------------------------
int CvCity::GetSeaTourismBonus() const
{
	VALIDATE_OBJECT();
	return m_iSeaTourismBonus;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeSeaTourismBonus(int iChange)
{
	VALIDATE_OBJECT();
	m_iSeaTourismBonus = (m_iSeaTourismBonus + iChange);
}
//	--------------------------------------------------------------------------------
void CvCity::SetSeaTourismBonus(int iChange)
{
	VALIDATE_OBJECT();
	m_iSeaTourismBonus = iChange;
}

int CvCity::GetSeaTourismFromEvent()
{
	int iBonus = GetSeaTourismBonus();
	int iPreviousTurnsToCount = 7;
	// Calculate boost
	iBonus *= (GET_PLAYER(getOwner()).getYieldPerTurnHistory(YIELD_CULTURE, iPreviousTurnsToCount) + GET_PLAYER(getOwner()).getYieldPerTurnHistory(YIELD_TOURISM, iPreviousTurnsToCount) / 2);
	iBonus /= 100;

	return iBonus;
}
int CvCity::GetLandTourismFromEvent()
{
	int iBonus = GetLandTourismBonus();
	int iPreviousTurnsToCount = 7;
	// Calculate boost
	iBonus *= (GET_PLAYER(getOwner()).getYieldPerTurnHistory(YIELD_CULTURE, iPreviousTurnsToCount) + GET_PLAYER(getOwner()).getYieldPerTurnHistory(YIELD_TOURISM, iPreviousTurnsToCount) / 2);
	iBonus /= 100;

	return iBonus;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeNumPreviousSpyMissions(int iChange)
{
	VALIDATE_OBJECT();
	m_iNumPreviousSpyMissions = m_iNumPreviousSpyMissions + iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetNumPreviousSpyMissions() const
{
	VALIDATE_OBJECT();
	return m_iNumPreviousSpyMissions;
}

//	--------------------------------------------------------------------------------
int CvCity::CalculateCitySecurity(CvString* toolTipSink) const
{
	VALIDATE_OBJECT();
	if (!GET_PLAYER(getOwner()).isMajorCiv())
		return -1;

	int iCitySecurity = 0;
	int iTempMod = 0;

	// Base security
	iTempMod = GD_INT_GET(ESPIONAGE_SECURITY_BASE);
	GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_EO_CITY_SECURITY_BASE_TT", iTempMod);
	iCitySecurity += iTempMod;

	// Difficulty Bonus
	const CvHandicapInfo& playerHandicap = GET_PLAYER(getOwner()).getHandicapInfo();
	const CvHandicapInfo& gameHandicap = GC.getGame().getHandicapInfo();
	iTempMod = playerHandicap.getSpySecurityModifier();
	iTempMod += !GET_PLAYER(getOwner()).isHuman() ? gameHandicap.getSpySecurityModifier() : 0;
	GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_EO_CITY_SECURITY_DIFFICULTY_TT", iTempMod);
	iCitySecurity += iTempMod;

	// Not all players have spies
	bool bAllPlayersHaveSpies = true;
	for (uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
	{
		PlayerTypes ePlayer = (PlayerTypes)ui;
		if (GET_PLAYER(ePlayer).isAlive() && GET_PLAYER(ePlayer).GetEspionage()->GetNumSpies() == 0)
		{
			bAllPlayersHaveSpies = false;
			break;
		}
	}
	if (!bAllPlayersHaveSpies)
	{
		iTempMod = GD_INT_GET(ESPIONAGE_SECURITY_NOT_ALL_HAVE_SPIES);
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_EO_CITY_SECURITY_NOT_ALL_HAVE_SPIES_TT", iTempMod);
		iCitySecurity += iTempMod;
	}

	// Local Buildings
	iTempMod = GetSpySecurityModifier();
	iTempMod += GD_INT_GET(ESPIONAGE_SECURITY_PER_POPULATION_BUILDING_SCALER) != 0 ? getPopulation() * GetSpySecurityModifierPerXPop() / /*360*/ GD_INT_GET(ESPIONAGE_SECURITY_PER_POPULATION_BUILDING_SCALER) : 0;
	GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_EO_CITY_SECURITY_BUILDINGS_TT", iTempMod);
	iCitySecurity += iTempMod;

	// Everything on the player level (Policies, Wonders, Player Traits)
	iTempMod = GET_PLAYER(getOwner()).GetSpySecurityModifier();
	GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_EO_CITY_SECURITY_POLICIES_WONDERS_TT", iTempMod);
	iCitySecurity += iTempMod;

	// Previous Spy Missions
	iTempMod = GetNumPreviousSpyMissions() * GD_INT_GET(ESPIONAGE_SECURITY_PREVIOUS_CITY_MISSIONS);
	iTempMod *= 100;
	iTempMod /= GC.getGame().getGameSpeedInfo().getSpyRatePercent();
	GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_EO_CITY_SECURITY_PREVIOUS_SPY_MISSIONS_TT", iTempMod);
	iCitySecurity += iTempMod;

	// Population
	iTempMod = getPopulation() * GD_INT_GET(ESPIONAGE_SECURITY_PER_POPULATION);
	GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_EO_CITY_SECURITY_POPULATION_TT", iTempMod);
	iCitySecurity += iTempMod;

	// Trade Routes
	iTempMod = GET_PLAYER(getOwner()).GetTrade()->GetNumberOfTradeRoutesCity(this) * GD_INT_GET(ESPIONAGE_SECURITY_PER_TRADE_ROUTE);
	GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_EO_CITY_SECURITY_TRADE_ROUTES_TT", iTempMod);
	iCitySecurity += iTempMod;

	// Excess Unhappiness
	iTempMod = getHappinessDelta() < 0 ? (getHappinessDelta() * (-1) * GD_INT_GET(ESPIONAGE_SECURITY_PER_EXCESS_UNHAPPINESS)) : 0;
	GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_EO_CITY_SECURITY_UNHAPPINESS_TT", iTempMod);
	iCitySecurity += iTempMod;

	return max(0, min(GD_INT_GET(ESPIONAGE_MAX_NUM_SECURITY_POINTS), iCitySecurity));
}

//	--------------------------------------------------------------------------------
int CvCity::GetAlwaysHeal() const
{
	VALIDATE_OBJECT();
	return m_iAlwaysHeal;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeAlwaysHeal(int iChange)
{
	VALIDATE_OBJECT();
	m_iAlwaysHeal = (m_iAlwaysHeal + iChange);
}
//	--------------------------------------------------------------------------------
void CvCity::SetAlwaysHeal(int iChange)
{
	VALIDATE_OBJECT();
	m_iAlwaysHeal = iChange;
}

void CvCity::ChangeResourceDiversityModifier(int iChange)
{
	VALIDATE_OBJECT();
	m_iResourceDiversityModifier += iChange;
}
int CvCity::GetResourceDiversityModifier() const
{
	VALIDATE_OBJECT();
	return m_iResourceDiversityModifier;
}

void CvCity::ChangeNoUnhappfromXSpecialists(int iChange)
{
	VALIDATE_OBJECT();
	m_iNoUnhappfromXSpecialists += iChange;
}
int CvCity::GetNoUnhappfromXSpecialists() const
{
	VALIDATE_OBJECT();
	return m_iNoUnhappfromXSpecialists;
}

//	--------------------------------------------------------------------------------
bool CvCity::isBorderCity() const
{
	VALIDATE_OBJECT();
	return plot()->IsBorderLand(m_eOwner);
}
bool CvCity::isBorderCity(vector<PlayerTypes>& vUnfriendlyMajors) const
{
	VALIDATE_OBJECT();
	return plot()->IsBorderLand(m_eOwner, vUnfriendlyMajors);
}
#endif
void CvCity::changeNukeInterceptionChance(int iNewValue)
{
	VALIDATE_OBJECT();
	m_iNukeInterceptionChance += iNewValue;
}
int CvCity::getNukeInterceptionChance() const
{
	VALIDATE_OBJECT();
	return m_iNukeInterceptionChance;
}
#if defined(MOD_BALANCE_CORE)
void CvCity::SetPurchased(BuildingClassTypes eBuildingClass, bool bValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eBuildingClass >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eBuildingClass < GC.getNumBuildingClassInfos(), "eIndex expected to be < MAX_PLAYERS");
	if (m_abIsPurchased[eBuildingClass] != bValue)
	{
		m_abIsPurchased[eBuildingClass] = bValue;
	}
}
bool CvCity::IsPurchased(BuildingClassTypes eBuildingClass)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eBuildingClass >= 0, "eBuildingClass expected to be >= 0");
	ASSERT_DEBUG(eBuildingClass < GC.getNumBuildingClassInfos(), "eBuildingClass expected to be < GC.getNumBuildingClassInfos()");
	return m_abIsPurchased[eBuildingClass];
}
void CvCity::SetBestForWonder(BuildingClassTypes eBuildingClass, bool bValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eBuildingClass >= 0, "eBuildingClass expected to be >= 0");
	ASSERT_DEBUG(eBuildingClass < GC.getNumBuildingClassInfos(), "eBuildingClass expected to be < GC.getNumBuildingClassInfos()");
	if (m_abIsBestForWonder[eBuildingClass] != bValue)
	{
		m_abIsBestForWonder[eBuildingClass] = bValue;
	}
}
bool CvCity::IsBestForWonder(BuildingClassTypes eBuildingClass)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eBuildingClass >= 0, "eBuildingClass expected to be >= 0");
	ASSERT_DEBUG(eBuildingClass < GC.getNumBuildingClassInfos(), "eBuildingClass expected to be < GC.getNumBuildingClassInfos()");
	return m_abIsBestForWonder[eBuildingClass];
}

#endif
//	--------------------------------------------------------------------------------
/// Extra yield for each pop point
int CvCity::GetYieldPerPopTimes100(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	return m_aiYieldPerPop[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield for each pop point
void CvCity::ChangeYieldPerPopTimes100(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
		m_aiYieldPerPop[eIndex] = m_aiYieldPerPop[eIndex] + iChange;
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Extra yield for each pop point in empire
int CvCity::GetYieldPerPopInEmpireTimes100(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	std::map<int, int>::const_iterator it = m_aiYieldPerPopInEmpire.find((int)eIndex);
	if (it != m_aiYieldPerPopInEmpire.end()) // find returns the iterator to map::end if the key i is not present in the map
	{
		return it->second;
	}

	return 0;
}

//	--------------------------------------------------------------------------------
/// Extra yield for each pop point in empire
void CvCity::ChangeYieldPerPopInEmpireTimes100(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
		m_aiYieldPerPopInEmpire[(int)eIndex] += iChange;
}
#endif

//	--------------------------------------------------------------------------------
/// Extra yields when a tech is researched
std::map<int, std::map<int, int>> CvCity::GetTechEnhancedYieldsMap() const
{
	return m_miTechEnhancedYields;
}
int CvCity::GetTechEnhancedYields(TechTypes eTech, YieldTypes eYield) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eTech >= 0, "eTech expected to be >= 0");
	ASSERT_DEBUG(eTech < GC.getNumTechInfos(), "eTech expected to be < getNumTechInfos()");
	ASSERT_DEBUG(eYield >= 0, "eYield expected to be >= 0");
	ASSERT_DEBUG(eYield < NUM_YIELD_TYPES, "eYield expected to be < NUM_YIELD_TYPES");

	std::map<int, std::map<int, int>>::const_iterator it = m_miTechEnhancedYields.find((int)eTech);
	if (it != m_miTechEnhancedYields.end()) // find returns the iterator to map::end if the key i is not present in the map
	{
		std::map<int, int> miTechMap = it->second;
		std::map<int, int>::const_iterator it2 = miTechMap.find((int)eYield);
		if (it2 != miTechMap.end())
		{
			return it2->second;
		}
	}

	return 0;
}
bool CvCity::TechEnhancesAnyYield(TechTypes eTech) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eTech >= 0, "eTech expected to be >= 0");
	ASSERT_DEBUG(eTech < GC.getNumTechInfos(), "eTech expected to be < getNumTechInfos()");

	return m_miTechEnhancedYields.find((int)eTech) != m_miTechEnhancedYields.end();
}
void CvCity::ChangeTechEnhancedYields(TechTypes eTech, YieldTypes eYield, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eYield >= 0, "eYield expected to be >= 0");
	ASSERT_DEBUG(eYield < NUM_YIELD_TYPES, "eYield expected to be < NUM_YIELD_TYPES");
	ASSERT_DEBUG(eTech >= 0, "eTech expected to be >= 0");
	ASSERT_DEBUG(eTech < GC.getNumTechInfos(), "eTech expected to be < getNumTechInfos()");

	if (iChange != 0)
	{
		// if we already have the tech, we need to change the yields generated in the city
		if (GET_TEAM(GET_PLAYER(getOwner()).getTeam()).GetTeamTechs()->HasTech(eTech))
		{
			ChangeBaseYieldRateFromBuildings(eYield, iChange);
		}

		m_miTechEnhancedYields[eTech][eYield] += iChange;
		ASSERT_DEBUG(m_miTechEnhancedYields[eTech][eYield] >= 0, "negative value in m_miTechEnhancedYields");
		if (m_miTechEnhancedYields[eTech][eYield] == 0)
		{
			m_miTechEnhancedYields[eTech].erase(eYield);
			if (m_miTechEnhancedYields[eTech].size() == 0)
			{
				m_miTechEnhancedYields.erase(eTech);
			}
		}
		std::map<int, std::map<int, int>>(m_miTechEnhancedYields).swap(m_miTechEnhancedYields);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yields when a tech is researched
std::map<pair<GreatPersonTypes, EraTypes>, int> CvCity::GetGreatPersonPointFromConstructionMap() const
{
	return m_miGreatPersonPointFromConstruction;
}
int CvCity::GetGreatPersonPointFromConstruction(GreatPersonTypes eGreatPerson, EraTypes eEra) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eGreatPerson >= 0, "eGreatPerson expected to be >= 0");
	ASSERT_DEBUG(eGreatPerson < GC.getNumGreatPersonInfos(), "eGreatPerson expected to be < getNumGreatPersonInfos");
	ASSERT_DEBUG(eEra >= 0, "eEra expected to be >= 0");
	ASSERT_DEBUG(eEra < GC.getNumEraInfos(), "eEra expected to be < getNumEraInfos");

	std::map<pair<GreatPersonTypes, EraTypes>, int>::const_iterator it = m_miGreatPersonPointFromConstruction.find(std::make_pair(eGreatPerson, eEra));
	if (it != m_miGreatPersonPointFromConstruction.end()) // find returns the iterator to map::end if the key i is not present in the map
	{
		return it->second;
	}

	return 0;
}
void CvCity::ChangeGreatPersonPointFromConstruction(pair<GreatPersonTypes, EraTypes> pGreatPersonEra, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(pGreatPersonEra.first >= 0, "eGreatPerson expected to be >= 0");
	ASSERT_DEBUG(pGreatPersonEra.first < GC.getNumGreatPersonInfos(), "eGreatPerson expected to be < getNumGreatPersonInfos");
	ASSERT_DEBUG(pGreatPersonEra.second >= 0, "eEra expected to be >= 0");
	ASSERT_DEBUG(pGreatPersonEra.second < GC.getNumEraInfos(), "eEra expected to be < getNumEraInfos");

	if (iChange != 0)
	{
		m_miGreatPersonPointFromConstruction[pGreatPersonEra] += iChange;
		ASSERT_DEBUG(m_miGreatPersonPointFromConstruction[pGreatPersonEra] >= 0, "negative value in m_miTechEnhancedYields");
		if (m_miGreatPersonPointFromConstruction[pGreatPersonEra] == 0)
		{
			m_miGreatPersonPointFromConstruction.erase(pGreatPersonEra);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield for each religion with a follower
int CvCity::GetYieldPerReligionTimes100(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	return m_aiYieldPerReligion[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield for each religion with a follower
void CvCity::ChangeYieldPerReligionTimes100(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldPerReligion[eIndex] = m_aiYieldPerReligion[eIndex] + iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvCity::getYieldRateModifier(YieldTypes eIndex)	const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldRateModifier[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::changeYieldRateModifier(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	if (iChange != 0)
	{
		m_aiYieldRateModifier[eIndex] += iChange;
		GET_PLAYER(getOwner()).invalidateYieldRankCache(eIndex);
	}
}

#if defined(MOD_BALANCE_CORE_POLICIES)
//	--------------------------------------------------------------------------------
int CvCity::getReligionBuildingYieldRateModifier(BuildingClassTypes eBuilding, YieldTypes eYield)	const
{
	return ModifierLookup(m_yieldChanges[eYield].forReligionBuilding, eBuilding);
}


//	--------------------------------------------------------------------------------
void CvCity::changeReligionBuildingYieldRateModifier(BuildingClassTypes eBuilding, YieldTypes eYield, int iChange)
{
	SCityExtraYields& y = m_yieldChanges[eYield];
	ModifierUpdateInsertRemove(y.forReligionBuilding, eBuilding, iChange, true);
}
//	--------------------------------------------------------------------------------
int CvCity::getLocalBuildingClassYield(BuildingClassTypes eBuilding, YieldTypes eYield)	const
{
	return ModifierLookup(m_yieldChanges[eYield].forLocalBuilding, eBuilding);
}


//	--------------------------------------------------------------------------------
void CvCity::changeLocalBuildingClassYield(BuildingClassTypes eBuilding, YieldTypes eYield, int iChange)
{
	SCityExtraYields& y = m_yieldChanges[eYield];
	ModifierUpdateInsertRemove(y.forLocalBuilding, eBuilding, iChange, true);
}

//	--------------------------------------------------------------------------------
int CvCity::GetGreatWorkYieldChange(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiGreatWorkYieldChange[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::ChangeGreatWorkYieldChange(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiGreatWorkYieldChange[eIndex] = m_aiGreatWorkYieldChange[eIndex] + iChange;
	}
}
#endif

//	--------------------------------------------------------------------------------
int CvCity::getResourceYieldRateModifier(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiResourceYieldRateModifier[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::changeResourceYieldRateModifier(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiResourceYieldRateModifier[eIndex] = m_aiResourceYieldRateModifier[eIndex] + iChange;
		ASSERT_DEBUG(getYieldRate(eIndex, false) >= 0);

		GET_PLAYER(getOwner()).invalidateYieldRankCache(eIndex);
	}
}


//	--------------------------------------------------------------------------------
int CvCity::getExtraSpecialistYield(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiExtraSpecialistYield[eIndex];
}


//	--------------------------------------------------------------------------------
int CvCity::getExtraSpecialistYield(YieldTypes eIndex, SpecialistTypes eSpecialist) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	ASSERT_DEBUG(eSpecialist >= 0, "eSpecialist expected to be >= 0");
	ASSERT_DEBUG(eSpecialist < GC.getNumSpecialistInfos(), "GC.getNumSpecialistInfos expected to be >= 0");

	int iYieldMultiplier = 0;

	// Laborers don't get any non-specific specialist boosts
	if (eSpecialist != GD_INT_GET(DEFAULT_SPECIALIST))
		iYieldMultiplier += GET_PLAYER(getOwner()).getSpecialistExtraYield(eIndex);

	iYieldMultiplier += GET_PLAYER(getOwner()).getSpecialistExtraYield(eSpecialist, eIndex);

	iYieldMultiplier += GET_PLAYER(getOwner()).GetPlayerTraits()->GetSpecialistYieldChange(eSpecialist, eIndex);

#if defined(MOD_BALANCE_CORE_EVENTS)
	iYieldMultiplier += GetEventSpecialistYield(eSpecialist, eIndex);
#endif

	iYieldMultiplier += getSpecialistExtraYield(eSpecialist, eIndex);

	ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
	BeliefTypes eSecondaryPantheon = NO_BELIEF;
	if (eMajority >= RELIGION_PANTHEON)
	{
		const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
		if (pReligion)
		{
			iYieldMultiplier += pReligion->m_Beliefs.GetSpecialistYieldChange(eSpecialist, eIndex, getOwner(), GET_PLAYER(getOwner()).getCity(GetID()));
			eSecondaryPantheon = GetCityReligions()->GetSecondaryReligionPantheonBelief();
			if (eSecondaryPantheon != NO_BELIEF)
			{
				iYieldMultiplier += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetSpecialistYieldChange(eSpecialist, eIndex);
			}
		}
	}

#if defined(MOD_RELIGION_PERMANENT_PANTHEON)
	// Mod for civs keeping their pantheon belief forever
	if (MOD_RELIGION_PERMANENT_PANTHEON)
	{
		if (GC.getGame().GetGameReligions()->HasCreatedPantheon(getOwner()))
		{
			const CvReligion* pPantheon = GC.getGame().GetGameReligions()->GetReligion(RELIGION_PANTHEON, getOwner());
			BeliefTypes ePantheonBelief = GC.getGame().GetGameReligions()->GetBeliefInPantheon(getOwner());
			if (pPantheon != NULL && ePantheonBelief != NO_BELIEF && ePantheonBelief != eSecondaryPantheon)
			{
				const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
				if (pReligion == NULL || (pReligion != NULL && !pReligion->m_Beliefs.IsPantheonBeliefInReligion(ePantheonBelief, eMajority, getOwner()))) // check that the our religion does not have our belief, to prevent double counting
				{
					iYieldMultiplier += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetSpecialistYieldChange(eSpecialist, eIndex);
				}
			}
		}
	}
#endif

	int iExtraYield = GetCityCitizens()->GetSpecialistCount(eSpecialist) * iYieldMultiplier;

	return iExtraYield;
}


//	--------------------------------------------------------------------------------
void CvCity::updateExtraSpecialistYield(YieldTypes eYield)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eYield >= 0, "eYield expected to be >= 0");
	ASSERT_DEBUG(eYield < NUM_YIELD_TYPES, "eYield expected to be < NUM_YIELD_TYPES");

	int iOldYield = getExtraSpecialistYield(eYield);
	int iNewYield = 0;


	for (int iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
	{
		iNewYield += getExtraSpecialistYield(eYield, ((SpecialistTypes)iI));
	}

	if (iOldYield != iNewYield)
	{
		m_aiExtraSpecialistYield[eYield] = iNewYield;
		ASSERT_DEBUG(getExtraSpecialistYield(eYield) >= 0);

		ChangeBaseYieldRateFromSpecialists(eYield, (iNewYield - iOldYield));
	}
}


//	--------------------------------------------------------------------------------
void CvCity::updateExtraSpecialistYield()
{
	VALIDATE_OBJECT();
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		updateExtraSpecialistYield((YieldTypes)iI);
	}
}


//	--------------------------------------------------------------------------------
int CvCity::getProductionToYieldModifier(YieldTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiProductionToYieldModifier[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::changeProductionToYieldModifier(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiProductionToYieldModifier[eIndex] = m_aiProductionToYieldModifier[eIndex] + iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvCity::GetTradeYieldModifier(YieldTypes eIndex, CvString* toolTipSink) const
{
	int iReturnValue = GET_PLAYER(m_eOwner).GetTrade()->GetTradeValuesAtCityTimes100(this, eIndex);
	if (toolTipSink)
	{
		if (iReturnValue != 0)
		{
			switch (eIndex)
			{
			case YIELD_FOOD:
				*toolTipSink += "[NEWLINE][BULLET]";
				*toolTipSink += GetLocalizedText("TXT_KEY_FOOD_FROM_TRADE_ROUTES", iReturnValue / 100.0f);
				break;
			case YIELD_PRODUCTION:
				*toolTipSink += "[NEWLINE][BULLET]";
				*toolTipSink += GetLocalizedText("TXT_KEY_PRODUCTION_FROM_TRADE_ROUTES", iReturnValue / 100.0f);
				break;
			case YIELD_GOLD:
				*toolTipSink += "[NEWLINE][BULLET]";
				*toolTipSink += GetLocalizedText("TXT_KEY_GOLD_FROM_TRADE_ROUTES", iReturnValue / 100.0f);
				break;
			case YIELD_SCIENCE:
				*toolTipSink += "[NEWLINE][BULLET]";
				*toolTipSink += GetLocalizedText("TXT_KEY_SCIENCE_FROM_TRADE_ROUTES", iReturnValue / 100.0f);
				break;
			case YIELD_CULTURE:
				*toolTipSink += "[NEWLINE][BULLET]";
				*toolTipSink += GetLocalizedText("TXT_KEY_CULTURE_FROM_TRADE_ROUTES", iReturnValue / 100.0f);
				break;
			case YIELD_FAITH:
				*toolTipSink += "[NEWLINE][BULLET]";
				*toolTipSink += GetLocalizedText("TXT_KEY_FAITH_FROM_TRADE_ROUTES", iReturnValue / 100.0f);
				break;
			case YIELD_TOURISM:
				*toolTipSink += "[NEWLINE][BULLET]";
				*toolTipSink += GetLocalizedText("TXT_KEY_TOURISM_FROM_TRADE_ROUTES", iReturnValue / 100.0f);
				break;
			case YIELD_GOLDEN_AGE_POINTS:
				*toolTipSink += "[NEWLINE][BULLET]";
				*toolTipSink += GetLocalizedText("TXT_KEY_GOLDEN_AGE_POINTS_FROM_TRADE_ROUTES", iReturnValue / 100.0f);
				break;
			default:
				UNREACHABLE(); // All other yields cannot be acquired from trade.
			}
		}
	}
	return iReturnValue;
}

//	--------------------------------------------------------------------------------
int CvCity::getDomainFreeExperience(DomainTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_DOMAIN_TYPES, "eIndex expected to be < NUM_DOMAIN_TYPES");
	return m_aiDomainFreeExperience[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::changeDomainFreeExperience(DomainTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_DOMAIN_TYPES, "eIndex expected to be < NUM_DOMAIN_TYPES");
	m_aiDomainFreeExperience[eIndex] = m_aiDomainFreeExperience[eIndex] + iChange;
	ASSERT_DEBUG(getDomainFreeExperience(eIndex) >= 0);
}


//	--------------------------------------------------------------------------------
int CvCity::getDomainFreeExperienceFromGreatWorks(DomainTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_DOMAIN_TYPES, "eIndex expected to be < NUM_DOMAIN_TYPES");

	int iXP = 0;

	CvBuildingXMLEntries* pkBuildings = GetCityBuildings()->GetPossibleBuildings();
	for (int iBuilding = 0; iBuilding < pkBuildings->GetNumBuildings(); iBuilding++)
	{
		CvBuildingEntry* pInfo = pkBuildings->GetEntry(iBuilding);
		if (pInfo)
		{
			if (pInfo->GetDomainFreeExperiencePerGreatWork(eIndex) != 0)
			{
				int iGreatWorks = GetCityBuildings()->GetNumGreatWorksInBuilding(pInfo->GetBuildingClassType());
				iXP += (iGreatWorks * pInfo->GetDomainFreeExperiencePerGreatWork(eIndex));
			}
		}
	}

	return iXP;
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvCity::getDomainFreeExperienceFromGreatWorksGlobal(DomainTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_DOMAIN_TYPES, "eIndex expected to be < NUM_DOMAIN_TYPES");

	int iMod = GET_PLAYER(getOwner()).GetDomainFreeExperiencePerGreatWorkGlobal(eIndex);
	if (iMod <= 0)
	{
		return iMod;
	}

	int iXP = 0;
	int iLoop = 0;
	int iGreatWorks = 0;
	for (const CvCity* pLoopCity = GET_PLAYER(getOwner()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(getOwner()).nextCity(&iLoop))
	{
		if (pLoopCity != NULL)
		{
			iGreatWorks += pLoopCity->GetCityBuildings()->GetNumGreatWorks(CvTypes::getGREAT_WORK_SLOT_LITERATURE());
		}
	}
	iXP += (iGreatWorks * iMod);

	if (iXP > 45)
	{
		iXP = 45;
	}

	return iXP;
}
#endif

//	--------------------------------------------------------------------------------
int CvCity::getDomainProductionModifier(DomainTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_DOMAIN_TYPES, "eIndex expected to be < NUM_DOMAIN_TYPES");
	return m_aiDomainProductionModifier[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::changeDomainProductionModifier(DomainTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < NUM_DOMAIN_TYPES, "eIndex expected to be < NUM_DOMAIN_TYPES");
	m_aiDomainProductionModifier[eIndex] = m_aiDomainProductionModifier[eIndex] + iChange;
}


//	--------------------------------------------------------------------------------
bool CvCity::isEverLiberated(PlayerTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < MAX_PLAYERS, "eIndex expected to be < MAX_PLAYERS");
	return m_abEverLiberated[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::setEverLiberated(PlayerTypes eIndex, bool bNewValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < MAX_PLAYERS, "eIndex expected to be < MAX_PLAYERS");
	m_abEverLiberated[eIndex] = bNewValue;
}

//	--------------------------------------------------------------------------------
bool CvCity::isRevealed(TeamTypes eIndex, bool bDebug, bool bAdjacentIsGoodEnough) const
{
	if (!plot())
		return false;

	//humans can guess if there is a city so we give the AI some help sometimes
	if (bAdjacentIsGoodEnough)
		return plot()->isRevealed(eIndex, bDebug) || plot()->isAdjacentRevealed(eIndex);
	else
		return plot()->isRevealed(eIndex, bDebug);
}

bool CvCity::setRevealed(TeamTypes eIndex, bool bNewValue)
{
	if (!plot())
		return false;

	return plot()->setRevealed(eIndex, bNewValue);
}

//	--------------------------------------------------------------------------------
const char* CvCity::getNameKey() const
{
	VALIDATE_OBJECT();
	return m_strName;
}


//	--------------------------------------------------------------------------------
const CvString CvCity::getName() const
{
	VALIDATE_OBJECT();
	return GetLocalizedText(m_strName);
}

const CvString CvCity::getNameNoSpace() const
{
	CvString ret = getName();
	ret.Replace(' ', '_');
	ret.Replace('\'', '_');
	return ret;
}


//	--------------------------------------------------------------------------------
void CvCity::setName(const char* szNewValue, bool bFound, bool bForceChange)
{
	VALIDATE_OBJECT();
	CvString strName(szNewValue);
	gDLL->stripSpecialCharacters(strName);

	if (!strName.IsEmpty())
	{
		if (GET_PLAYER(getOwner()).isCityNameValid(strName, false, bForceChange))
		{
			m_strName = strName;

			if (isCitySelected())
			{
				DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
			}


			CvInterfacePtr<ICvCity1> pCity = GC.WrapCityPointer(this);
			DLLUI->SetSpecificCityInfoDirty(pCity.get(), CITY_UPDATE_TYPE_BANNER);
		}
		if (bFound)
		{
			doFoundMessage();
		}
	}
}

void CvCity::setCaptureData(int iTemp[5], bool bTemp[2])
{
	m_aiTempCaptureData[0] = iTemp[0];
	m_aiTempCaptureData[1] = iTemp[1];
	m_aiTempCaptureData[2] = iTemp[2];
	m_aiTempCaptureData[3] = iTemp[3];
	m_aiTempCaptureData[4] = iTemp[4];

	m_abTempCaptureData[0] = bTemp[0];
	m_abTempCaptureData[1] = bTemp[1];

	m_bIsPendingCapture = true;
}

std::vector<int> CvCity::getCaptureDataInt() const
{
	return m_aiTempCaptureData;
}

std::vector<bool> CvCity::getCaptureDataBool() const
{
	return m_abTempCaptureData;
}

bool CvCity::isPendingCapture() const
{
	return m_bIsPendingCapture;
}

void CvCity::resetCaptureData()
{
	for (int i = 0; i < 5; i++)
	{
		m_aiTempCaptureData[i] = 0;
	}
	for (int i = 0; i < 2; i++)
	{
		m_abTempCaptureData[i] = false;
	}

	m_bIsPendingCapture = false;
}

//	--------------------------------------------------------------------------------
void CvCity::doFoundMessage()
{
	VALIDATE_OBJECT();
	if (getOwner() == GC.getGame().getActivePlayer())
	{
		Localization::String localizedText = Localization::Lookup("TXT_KEY_MISC_CITY_HAS_BEEN_FOUNDED");
		localizedText << getNameKey();
		DLLUI->AddCityMessage(0, GetIDInfo(), getOwner(), false, -1, localizedText.toUTF8(), NULL /*ARTFILEMGR.getInterfaceArtInfo("WORLDBUILDER_CITY_EDIT")->getPath()*/, MESSAGE_TYPE_MAJOR_EVENT, NULL, NO_COLOR, getX(), getY());
	}

	Localization::String localizedText = Localization::Lookup("TXT_KEY_MISC_CITY_IS_FOUNDED");
	localizedText << getNameKey();
	GC.getGame().addReplayMessage(REPLAY_MESSAGE_CITY_FOUNDED, getOwner(), localizedText.toUTF8(), getX(), getY());
}

//	--------------------------------------------------------------------------------
bool CvCity::IsExtraLuxuryResources()
{
	return (m_iCountExtraLuxuries > 0);
}

//	--------------------------------------------------------------------------------
void CvCity::SetExtraLuxuryResources(int iNewValue)
{
	m_iCountExtraLuxuries = iNewValue;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeExtraLuxuryResources(int iChange)
{
	m_iCountExtraLuxuries += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::getProjectProduction(ProjectTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < GC.getNumProjectInfos(), "eIndex expected to be < GC.getNumProjectInfos()");
	return m_paiProjectProduction[eIndex] / 100;
}


//	--------------------------------------------------------------------------------
void CvCity::setProjectProduction(ProjectTypes eIndex, int iNewValue)
{
	VALIDATE_OBJECT();
	setProjectProductionTimes100(eIndex, iNewValue * 100);
}


//	--------------------------------------------------------------------------------
void CvCity::changeProjectProduction(ProjectTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	changeProjectProductionTimes100(eIndex, iChange * 100);
}

//	--------------------------------------------------------------------------------
int CvCity::getProjectProductionTimes100(ProjectTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < GC.getNumProjectInfos(), "eIndex expected to be < GC.getNumProjectInfos()");
	return m_paiProjectProduction[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::setProjectProductionTimes100(ProjectTypes eIndex, int iNewValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < GC.getNumProjectInfos(), "eIndex expected to be < GC.getNumProjectInfos()");

	if (getProjectProductionTimes100(eIndex) != iNewValue)
	{
		m_paiProjectProduction[eIndex] = max(0, iNewValue);
		ASSERT_DEBUG(getProjectProductionTimes100(eIndex) >= 0);

		if ((getOwner() == GC.getGame().getActivePlayer()) && isCitySelected())
		{
			DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
		}

		CvInterfacePtr<ICvCity1> pCity = GC.WrapCityPointer(this);
		DLLUI->SetSpecificCityInfoDirty(pCity.get(), CITY_UPDATE_TYPE_BANNER);
	}
}


//	--------------------------------------------------------------------------------
void CvCity::changeProjectProductionTimes100(ProjectTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < GC.getNumProjectInfos(), "eIndex expected to be < GC.getNumProjectInfos()");
	setProjectProductionTimes100(eIndex, (getProjectProductionTimes100(eIndex) + iChange));
}

#if defined(MOD_PROCESS_STOCKPILE)
//	--------------------------------------------------------------------------------
int CvCity::getProcessProduction(ProcessTypes eIndex) const
{
	return getProcessProductionTimes100(eIndex) / 100;
}

//	--------------------------------------------------------------------------------
int CvCity::getProcessProductionTimes100(ProcessTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < GC.getNumProcessInfos(), "eIndex expected to be < GC.getNumProcessInfos()");

	if (eIndex == GC.getInfoTypeForString("PROCESS_STOCKPILE"
		, true)) {
		return getBasicYieldRateTimes100(YIELD_PRODUCTION);
	}

	return 0;
}
#endif

//	--------------------------------------------------------------------------------
CvCityBuildings* CvCity::GetCityBuildings() const
{
	VALIDATE_OBJECT();
	return m_pCityBuildings;
}

//	--------------------------------------------------------------------------------
int CvCity::getUnitProduction(UnitTypes eIndex)	const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < GC.getNumUnitInfos(), "eIndex expected to be < GC.getNumUnitInfos()");
	return m_paiUnitProduction[eIndex] / 100;
}


//	--------------------------------------------------------------------------------
void CvCity::setUnitProduction(UnitTypes eIndex, int iNewValue)
{
	VALIDATE_OBJECT();
	setUnitProductionTimes100(eIndex, iNewValue * 100);
}


//	--------------------------------------------------------------------------------
void CvCity::changeUnitProduction(UnitTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	changeUnitProductionTimes100(eIndex, iChange * 100);
}


//	--------------------------------------------------------------------------------
int CvCity::getUnitProductionTimes100(UnitTypes eIndex)	const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < GC.getNumUnitInfos(), "eIndex expected to be < GC.getNumUnitInfos()");
	return m_paiUnitProduction[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::setUnitProductionTimes100(UnitTypes eIndex, int iNewValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < GC.getNumUnitInfos(), "eIndex expected to be < GC.getNumUnitInfos()");

	if (getUnitProductionTimes100(eIndex) != iNewValue)
	{
		m_paiUnitProduction[eIndex] = max(0, iNewValue);
		ASSERT_DEBUG(getUnitProductionTimes100(eIndex) >= 0);

		if ((getOwner() == GC.getGame().getActivePlayer()) && isCitySelected())
		{
			DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
		}

		CvInterfacePtr<ICvCity1> pCity = GC.WrapCityPointer(this);
		DLLUI->SetSpecificCityInfoDirty(pCity.get(), CITY_UPDATE_TYPE_BANNER);
	}
}


//	--------------------------------------------------------------------------------
void CvCity::changeUnitProductionTimes100(UnitTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	setUnitProductionTimes100(eIndex, (getUnitProductionTimes100(eIndex) + iChange));
}


//	--------------------------------------------------------------------------------
int CvCity::getUnitProductionTime(UnitTypes eIndex)	const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < GC.getNumUnitInfos(), "eIndex expected to be < GC.getNumUnitInfos()");
	return m_paiUnitProductionTime[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::setUnitProductionTime(UnitTypes eIndex, int iNewValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < GC.getNumUnitInfos(), "eIndex expected to be < GC.getNumUnitInfos()");
	m_paiUnitProductionTime[eIndex] = iNewValue;
	ASSERT_DEBUG(getUnitProductionTime(eIndex) >= 0);
}


//	--------------------------------------------------------------------------------
void CvCity::changeUnitProductionTime(UnitTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	setUnitProductionTime(eIndex, (getUnitProductionTime(eIndex) + iChange));
}


//	--------------------------------------------------------------------------------
int CvCity::getUnitCombatFreeExperience(UnitCombatTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < GC.getNumUnitCombatClassInfos(), "eIndex expected to be < GC.getNumUnitCombatInfos()");
	return m_paiUnitCombatFreeExperience[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::changeUnitCombatFreeExperience(UnitCombatTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < GC.getNumUnitCombatClassInfos(), "eIndex expected to be < GC.getNumUnitCombatInfos()");
	m_paiUnitCombatFreeExperience[eIndex] = m_paiUnitCombatFreeExperience[eIndex] + iChange;
	ASSERT_DEBUG(getUnitCombatFreeExperience(eIndex) >= 0);
}


//	--------------------------------------------------------------------------------
int CvCity::getUnitCombatProductionModifier(UnitCombatTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < GC.getNumUnitCombatClassInfos(), "eIndex expected to be < GC.getNumUnitCombatInfos()");
	return m_paiUnitCombatProductionModifier[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::changeUnitCombatProductionModifier(UnitCombatTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < GC.getNumUnitCombatClassInfos(), "eIndex expected to be < GC.getNumUnitCombatInfos()");
	m_paiUnitCombatProductionModifier[eIndex] = m_paiUnitCombatProductionModifier[eIndex] + iChange;
	ASSERT_DEBUG(getUnitCombatProductionModifier(eIndex) >= 0);
}


//	--------------------------------------------------------------------------------
int CvCity::getFreePromotionCount(PromotionTypes eIndex) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < GC.getNumPromotionInfos(), "eIndex expected to be < GC.getNumPromotionInfos()");
	if (m_paiFreePromotionCount.find(eIndex) != m_paiFreePromotionCount.end())
		return m_paiFreePromotionCount.find(eIndex)->second;

	return 0;
}

//	--------------------------------------------------------------------------------
vector<PromotionTypes> CvCity::getFreePromotions() const
{
	vector<PromotionTypes> result;
	for (map<PromotionTypes, int>::const_iterator it = m_paiFreePromotionCount.begin(); it != m_paiFreePromotionCount.end(); ++it)
		if (it->second > 0)
			result.push_back(it->first);

#if defined(MOD_RELIGION_EXTENSIONS)
	if (MOD_RELIGION_EXTENSIONS)
	{
		ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
		if (eMajority != NO_RELIGION)
		{
			const CvReligion* pMajority = GetCityReligions()->GetMajorityReligion();
			if (pMajority)
			{
				std::vector<int> aFreePromotions = pMajority->m_Beliefs.GetFreePromotions(getOwner(), this, false);
				for (std::vector<int>::iterator it = aFreePromotions.begin(); it != aFreePromotions.end(); ++it)
					result.push_back((PromotionTypes)*it);
			}
		}
	}
#endif

	return result;
}

//	--------------------------------------------------------------------------------
void CvCity::changeFreePromotionCount(PromotionTypes eIndex, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < GC.getNumPromotionInfos(), "eIndex expected to be < GC.getNumPromotionInfos()");
	m_paiFreePromotionCount[eIndex] += iChange;

	if (m_paiFreePromotionCount[eIndex] == 0)
		m_paiFreePromotionCount.erase(eIndex);
}

//	--------------------------------------------------------------------------------
void CvCity::SetRetroactivePromotion(PromotionTypes eIndex)
{
	ASSERT_DEBUG(eIndex >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(eIndex < GC.getNumPromotionInfos(), "eIndex expected to be < GC.getNumPromotionInfos()");

	if (eIndex != NO_PROMOTION)
	{
		CvPromotionEntry* pkPromotionInfo = GC.getPromotionInfo(eIndex);
		if (pkPromotionInfo)
		{
			int iUnitLoop = 0;
			CvUnit* pLoopUnit = NULL;
			for (pLoopUnit = GetPlayer()->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = GetPlayer()->nextUnit(&iUnitLoop))
			{
				if (pLoopUnit->getOriginCity() == NULL)
				{
					if (this == GetPlayer()->getCapitalCity())
					{
						if (((pLoopUnit->getUnitCombatType() != NO_UNITCOMBAT) && pkPromotionInfo->GetUnitCombatClass(pLoopUnit->getUnitCombatType())) || ::IsPromotionValidForCivilianUnitType(eIndex, pLoopUnit->getUnitType()))
						{
							pLoopUnit->setHasPromotion(eIndex, true);
						}
					}
				}
				else if (pLoopUnit->getOriginCity() != this)
					continue;

				if (((pLoopUnit->getUnitCombatType() != NO_UNITCOMBAT) && pkPromotionInfo->GetUnitCombatClass(pLoopUnit->getUnitCombatType())) || ::IsPromotionValidForCivilianUnitType(eIndex, pLoopUnit->getUnitType()))
				{
					pLoopUnit->setHasPromotion(eIndex, true);
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
int CvCity::getSpecialistFreeExperience() const
{
	VALIDATE_OBJECT();
	return m_iSpecialistFreeExperience;
}

//	--------------------------------------------------------------------------------
void CvCity::changeSpecialistFreeExperience(int iChange)
{
	VALIDATE_OBJECT();
	m_iSpecialistFreeExperience += iChange;
	ASSERT_DEBUG(m_iSpecialistFreeExperience >= 0);
}

//	--------------------------------------------------------------------------------
int CvCity::getAdjacentUnitsDefenseMod() const
{
	int iAdjacentUnitsDefenseMod = 0;
	CvPlot** aPlotsToCheck = GC.getMap().getNeighborsUnchecked(plot()->GetPlotIndex());
	for (int iCount = 0; iCount < NUM_DIRECTION_TYPES; iCount++)
	{
		CvPlot* pLoopPlot = aPlotsToCheck[iCount];
		if (pLoopPlot != NULL)
		{
			IDInfo* pUnitNode = pLoopPlot->headUnitNode();

			while (pUnitNode != NULL)
			{
				CvUnit* pLoopUnit = ::GetPlayerUnit(*pUnitNode);
				pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);

				if (pLoopUnit && pLoopUnit->getTeam() == getTeam())
				{
					iAdjacentUnitsDefenseMod += pLoopUnit->GetAdjacentCityDefenseMod();
				}
			}
		}
	}
	// also check the city plot itself
	IDInfo* pUnitNode = plot()->headUnitNode();

	while (pUnitNode != NULL)
	{
		CvUnit* pLoopUnit = ::GetPlayerUnit(*pUnitNode);
		pUnitNode = plot()->nextUnitNode(pUnitNode);

		if (pLoopUnit && pLoopUnit->getTeam() == getTeam())
		{
			iAdjacentUnitsDefenseMod += pLoopUnit->GetAdjacentCityDefenseMod();
		}
	}
	return iAdjacentUnitsDefenseMod;
}
//	--------------------------------------------------------------------------------
void CvCity::updateStrengthValue()
{
	// Default Strength
	int iStrengthValue = /*800 in CP, 500 in VP*/ GD_INT_GET(CITY_STRENGTH_DEFAULT);

	// Population mod
	if (GET_PLAYER(getOwner()).isMinorCiv() || !MOD_BALANCE_CORE_CITY_DEFENSE_SWITCH)
		iStrengthValue += getPopulation() * /*40*/ GD_INT_GET(CITY_STRENGTH_POPULATION_CHANGE);

	// Building Defense
	int iBuildingDefense = m_pCityBuildings->GetBuildingDefense();
	iBuildingDefense *= (100 + m_pCityBuildings->GetBuildingDefenseMod());
	iBuildingDefense /= 100;
	iStrengthValue += iBuildingDefense;

	// Tech Progress increases City Strength
	if (!MOD_BALANCE_CORE_CITY_DEFENSE_SWITCH)
	{
		double fTechProgress = float(GET_TEAM(getTeam()).GetTeamTechs()->GetNumTechsKnown()) / GC.getNumTechInfos() * /*5.5f in CP, 3.6f in VP*/ GD_FLOAT_GET(CITY_STRENGTH_TECH_BASE);
		double fTechExponent = /*2.8f in CP, 2.0f in VP*/ GD_FLOAT_GET(CITY_STRENGTH_TECH_EXPONENT);
		int iTechMultiplier = /*1 in CP, 0 in VP*/ GD_INT_GET(CITY_STRENGTH_TECH_MULTIPLIER);

		// The way all of this adds up...
		// 25% of the way through the game provides an extra 3.12
		// 50% of the way through the game provides an extra 12.50
		// 75% of the way through the game provides an extra 28.12
		// 100% of the way through the game provides an extra 50.00

		double fTechMod = pow(fTechProgress, fTechExponent) * iTechMultiplier * 100;
		iStrengthValue += (int)(fTechMod + 0.005f);	//is this really the way to get rid of fp inaccuracy?

	}

	if (getProductionProcess() != NO_PROCESS)
	{
		CvProcessInfo* pkProcessInfo = GC.getProcessInfo(getProductionProcess());
		if (pkProcessInfo && pkProcessInfo->getDefenseValue() != 0)
		{
			iStrengthValue += (getYieldRate(YIELD_PRODUCTION, false) * pkProcessInfo->getDefenseValue());
		}
	}

	if (GET_PLAYER(getOwner()).GetFlatDefenseFromAirUnits() != 0)
	{
		iStrengthValue += plot()->countNumAirUnits(getTeam(), true) * GET_PLAYER(getOwner()).GetFlatDefenseFromAirUnits() * 100;
	}

	if (GetDefensePerWonder() > 0)
	{
		iStrengthValue += (GetDefensePerWonder() * getNumWorldWonders() * 100).Truncate();
	}

	// Player-wide strength mod (Policies, etc.)
	int iStrengthMod = GET_PLAYER(getOwner()).GetCityStrengthMod();

	// Crime
	iStrengthValue += GetYieldModifierFromDevelopment(YIELD_JFD_CRIME);
	iStrengthMod += GetYieldModifierFromCrime(YIELD_JFD_CRIME);

	// Apply Mod
	iStrengthValue *= (100 + iStrengthMod);
	iStrengthValue /= 100;

	if (MOD_BALANCE_CORE_MINORS && GET_PLAYER(getOwner()).isMinorCiv() && isCapital())
	{
		PlayerTypes eAlly = GET_PLAYER(getOwner()).GetMinorCivAI()->GetAlly();
		if (eAlly != NO_PLAYER)
		{
			int iAllyBonus = GET_PLAYER(eAlly).GetPlayerTraits()->GetAllianceCSDefense() + /*25*/ GD_INT_GET(BALANCE_CS_ALLIANCE_DEFENSE_BONUS);
			if (iAllyBonus > 0)
			{
				iStrengthValue *= (100 + iAllyBonus);
				iStrengthValue /= 100;
			}
		}
		if (GET_PLAYER(getOwner()).GetMinorCivAI()->IsProtectedByAnyMajor())
		{
			int iProtections = 0;
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes)iPlayerLoop;
				if (eLoopPlayer != NO_PLAYER && GET_PLAYER(getOwner()).GetMinorCivAI()->IsProtectedByMajor(eLoopPlayer))
				{
					iProtections++;
				}
			}
			int iPtPBonus = iProtections * /*5*/ GD_INT_GET(BALANCE_CS_PLEDGE_TO_PROTECT_DEFENSE_BONUS);
			if (iPtPBonus > /*25*/ GD_INT_GET(BALANCE_CS_PLEDGE_TO_PROTECT_DEFENSE_BONUS_MAX))
			{
				iPtPBonus = GD_INT_GET(BALANCE_CS_PLEDGE_TO_PROTECT_DEFENSE_BONUS_MAX);
			}
			if (iPtPBonus > 0)
			{
				iStrengthValue *= (100 + iPtPBonus);
				iStrengthValue /= 100;
			}
		}
	}

	// Terrain mod
	if (plot()->isHills())
		iStrengthValue += /*500 in CP, 200 in VP*/ GD_INT_GET(CITY_STRENGTH_HILL_CHANGE);
	if (plot()->isMountain())
		iStrengthValue += /*1000 in CP, 400 in VP*/ GD_INT_GET(CITY_STRENGTH_HILL_CHANGE) * 2;

	// Policies
	iStrengthValue += GET_PLAYER(getOwner()).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_CITY_DEFENSE_BOOST);

	// Garrisoned Unit
	CvUnit* pGarrisonedUnit = GetGarrisonedUnit();
	if (pGarrisonedUnit && pGarrisonedUnit->getDomainType() == DOMAIN_LAND)
	{
		int iStrengthFromGarrison = (max(pGarrisonedUnit->GetBaseCombatStrength(), pGarrisonedUnit->GetBaseRangedCombatStrength()) * 100) / /*500 in CP, 200 in VP*/ GD_INT_GET(CITY_STRENGTH_UNIT_DIVISOR);

		iStrengthValue += (iStrengthFromGarrison * 100);
	}

	// Generals / Admirals also help (both the city and the garrison)
	if (GET_PLAYER(getOwner()).GetAreaEffectModifier(AE_GREAT_GENERAL, NO_DOMAIN, plot()) > 0)
	{
		iStrengthValue += /*500 in CP, 200 in VP*/ GD_INT_GET(CITY_STRENGTH_HILL_CHANGE);
	}

	// defense mod from adjacent units, not applied to ranged strength
	int iStrengthValueRanged = iStrengthValue;

	int iAdjacentUnitsDefenseMod = getAdjacentUnitsDefenseMod();
	if (iAdjacentUnitsDefenseMod > 0)
	{
		iStrengthValue *= 100 + iAdjacentUnitsDefenseMod;
		iStrengthValue /= 100;
	}

	//finally
	if (iStrengthValue != m_iStrengthValue || iStrengthValueRanged != m_iStrengthValueRanged)
	{
		// update bonuses from city strength
		bool bHadBonusesBefore = (m_iStrengthValue >= GD_INT_GET(CITY_STRENGTH_THRESHOLD_FOR_BONUSES) * 100);
		bool bHasBonusesNow = (iStrengthValue >= GD_INT_GET(CITY_STRENGTH_THRESHOLD_FOR_BONUSES) * 100);

		// set new strength values
		m_iStrengthValueRanged = iStrengthValueRanged;
		m_iStrengthValue = iStrengthValue;
		bool bHasCityYieldsPerCityStrength = false;
		for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
		{
			if (GetYieldChangesPerCityStrengthTimes100((YieldTypes)iI) > 0)
			{
				bHasCityYieldsPerCityStrength = true;
				break;
			}
		}
		if (bHadBonusesBefore != bHasBonusesNow)
		{
			// update happiness
			GET_PLAYER(getOwner()).CalculateNetHappiness();
			updateNetHappiness();
		}
		if (bHadBonusesBefore != bHasBonusesNow || bHasCityYieldsPerCityStrength)
		{
			// update yields
			updateYield();
		}

		DLLUI->setDirty(CityInfo_DIRTY_BIT, true);
	}
}

//	--------------------------------------------------------------------------------
int CvCity::getStrengthValue(bool bForRangeStrike, bool bIgnoreBuildings, const CvUnit* pDefender) const //result is times 100
{
	VALIDATE_OBJECT();

	// Attacks are weaker
	if (bForRangeStrike)
	{
		// Base values
		int iValue = m_iStrengthValueRanged;
		int iModifier = /*-40 in CP, 0 in VP*/ GD_INT_GET(CITY_RANGED_ATTACK_STRENGTH_MULTIPLIER);

		if (MOD_BALANCE_CORE_CITY_DEFENSE_SWITCH)
		{
			// Remove the garrisoned unit's strength
			CvUnit* pGarrisonedUnit = GetGarrisonedUnit();
			if (pGarrisonedUnit && pGarrisonedUnit->getDomainType() == DOMAIN_LAND)
			{
				int iStrengthFromGarrisonRaw = max(pGarrisonedUnit->GetBaseCombatStrength(), pGarrisonedUnit->GetBaseRangedCombatStrength());
				int iStrengthFromGarrison = (iStrengthFromGarrisonRaw * 100) / /*500 in CP, 200 in VP*/ GD_INT_GET(CITY_STRENGTH_UNIT_DIVISOR);
				iValue -= (iStrengthFromGarrison * 100);
			}
		}
		else
		{
			// Always ignore building defense here
			iValue -= m_pCityBuildings->GetBuildingDefense();
		}

		// Counterspy modifier
		if (getOwner() < static_cast<PlayerTypes>(MAX_MAJOR_CIVS))
		{
			CvCityEspionage* pCityEspionage = GetCityEspionage();
			if (pCityEspionage)
			{
				CityEventChoiceTypes eSpyFocus = pCityEspionage->GetCounterSpyFocus();
				if (eSpyFocus != NO_EVENT_CHOICE_CITY)
				{
					CvModEventCityChoiceInfo* pkEventChoiceInfo = GC.getCityEventChoiceInfo(eSpyFocus);
					if (pkEventChoiceInfo != NULL && pkEventChoiceInfo->getCityDefenseModifierBase() != 0)
						iModifier += pkEventChoiceInfo->getCityDefenseModifierBase();
					if (pkEventChoiceInfo != NULL && pkEventChoiceInfo->getCityDefenseModifier() != 0)
						iModifier += pkEventChoiceInfo->getCityDefenseModifier() * (pCityEspionage->GetCounterSpyRank() + 1);
				}
			}
		}

		// Defense process doesn't boost city strikes
		if (getProductionProcess() != NO_PROCESS)
		{
			CvProcessInfo* pkProcessInfo = GC.getProcessInfo(getProductionProcess());
			if (pkProcessInfo && pkProcessInfo->getDefenseValue() != 0)
			{
				iValue -= (getYieldRate(YIELD_PRODUCTION, false) * pkProcessInfo->getDefenseValue());
			}
		}

		// Building modifier
		iModifier += getCityBuildingRangeStrikeModifier();

		// Garrison modifier
		if (HasGarrison())
		{
			iModifier += GET_PLAYER(m_eOwner).GetGarrisonedCityRangeStrikeModifier();
		}

		// Trait attack bonus against the same target
		if (pDefender != NULL)
		{
			int iTempModifier = GET_PLAYER(getOwner()).GetPlayerTraits()->GetMultipleAttackBonus();
			if (iTempModifier != 0)
			{
				iTempModifier *= pDefender->GetNumTimesAttackedThisTurn(getOwner());
				iModifier += iTempModifier;
			}
		}

		// VS barbarian modifier
		if (pDefender != NULL && pDefender->isBarbarian())
		{
			iModifier += GET_PLAYER(getOwner()).GetBarbarianCombatBonus(false);
		}

		// Religion city strike mod
		ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
		BeliefTypes eSecondaryPantheon = NO_BELIEF;
		if (eMajority != NO_RELIGION)
		{
			const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
			if (pReligion)
			{
				iModifier += pReligion->m_Beliefs.GetCityRangeStrikeModifier(getOwner(), GET_PLAYER(getOwner()).getCity(GetID()));
				eSecondaryPantheon = GetCityReligions()->GetSecondaryReligionPantheonBelief();
				if (eSecondaryPantheon != NO_BELIEF)
				{
					iModifier += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetCityRangeStrikeModifier();
				}
			}
		}

		// Mod for civs keeping their pantheon belief forever
		if (MOD_RELIGION_PERMANENT_PANTHEON)
		{
			if (GC.getGame().GetGameReligions()->HasCreatedPantheon(getOwner()))
			{
				const CvReligion* pPantheon = GC.getGame().GetGameReligions()->GetReligion(RELIGION_PANTHEON, getOwner());
				BeliefTypes ePantheonBelief = GC.getGame().GetGameReligions()->GetBeliefInPantheon(getOwner());
				if (pPantheon != NULL && ePantheonBelief != NO_BELIEF && ePantheonBelief != eSecondaryPantheon)
				{
					// Check that the our religion does not have our belief, to prevent double counting
					const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
					if (pReligion == NULL || (pReligion != NULL && !pReligion->m_Beliefs.IsPantheonBeliefInReligion(ePantheonBelief, eMajority, getOwner())))
					{
						iModifier += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetCityRangeStrikeModifier();
					}
				}
			}
		}

		iValue *= (100 + iModifier);
		iValue /= 100;

		return iValue;
	}

	if (bIgnoreBuildings)
		return m_iStrengthValue - m_pCityBuildings->GetBuildingDefense();
	else
		return m_iStrengthValue;
}

//	--------------------------------------------------------------------------------
int CvCity::GetPower() const
{
	VALIDATE_OBJECT();
	return int(pow((double)getStrengthValue() / 100, 1.5));		// This is the same math used to calculate Unit Power in CvUnitEntry
}


//	--------------------------------------------------------------------------------
int CvCity::getDamage() const
{
	VALIDATE_OBJECT();
	return m_iDamage;
}

//	--------------------------------------------------------------------------------
void CvCity::setDamage(int iValue, bool noMessage)
{
	VALIDATE_OBJECT();

	if (iValue < 0)
		iValue = 0;
	else if (iValue > GetMaxHitPoints())
		iValue = GetMaxHitPoints();

	if (iValue != getDamage())
	{
		int iOldValue = getDamage();
		CvInterfacePtr<ICvCity1> pDllCity(new CvDllCity(this));
		gDLL->GameplayCitySetDamage(pDllCity.get(), iValue, iOldValue);

		// send the popup text if the player can see this plot
		if (!noMessage && plot()->GetActiveFogOfWarMode() == FOGOFWARMODE_OFF)
		{
			char text[256];
			text[0] = '\0';
			int iNewValue = MIN(GetMaxHitPoints(), iValue);
			int iDiff = iOldValue - iNewValue;
			if (iNewValue < iOldValue)
			{
				sprintf_s(text, "[COLOR_GREEN]+%d[ENDCOLOR]", iDiff);
			}
			else
			{
				sprintf_s(text, "[COLOR_RED]%d[ENDCOLOR]", iDiff);
			}

			SHOW_PLOT_POPUP(plot(), NO_PLAYER, text);
		}
		m_iDamage = iValue;
	}
}

//	--------------------------------------------------------------------------------
void CvCity::changeDamage(int iChange)
{
	VALIDATE_OBJECT();
	if (0 != iChange)
	{
		setDamage(getDamage() + iChange);
	}
}

//	--------------------------------------------------------------------------------
/// How many permyriads (1/10000th) of health have ePlayer dealt to this city?
int CvCity::GetDamagePermyriad(PlayerTypes ePlayer) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(ePlayer >= 0, "ePlayer expected to be >= 0");
	ASSERT_DEBUG(ePlayer < MAX_PLAYERS, "ePlayer expected to be < MAX_PLAYERS");
	return m_aiDamagePermyriad[ePlayer];
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeDamagePermyriad(PlayerTypes ePlayer, int iChange)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(ePlayer >= 0, "ePlayer expected to be >= 0");
	ASSERT_DEBUG(ePlayer < MAX_PLAYERS, "ePlayer expected to be < MAX_PLAYERS");
	m_aiDamagePermyriad[ePlayer] += iChange;
}

//	--------------------------------------------------------------------------------
void CvCity::SetDamagePermyriad(PlayerTypes ePlayer, int iValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(ePlayer >= 0, "ePlayer expected to be >= 0");
	ASSERT_DEBUG(ePlayer < MAX_PLAYERS, "ePlayer expected to be < MAX_PLAYERS");
	m_aiDamagePermyriad[ePlayer] = iValue;
}

//	--------------------------------------------------------------------------------
/// How much war damage is generated if this city is damaged from full health to 0?
int CvCity::GetWarValue() const
{
	int iCityValue = /*175*/ GD_INT_GET(WAR_DAMAGE_LEVEL_CITY_WEIGHT);
	iCityValue += getPopulation() * /*150*/ GD_INT_GET(WAR_DAMAGE_LEVEL_INVOLVED_CITY_POP_MULTIPLIER);
	iCityValue += getNumWorldWonders() * /*200*/ GD_INT_GET(WAR_DAMAGE_LEVEL_WORLD_WONDER_MULTIPLIER);

	CvPlayer& kOwner = GET_PLAYER(getOwner());
	if (IsOriginalCapitalForPlayer(getOwner()))
	{
		// This is the original capital of the city owner
		iCityValue *= /*200*/ GD_INT_GET(WAR_PROGRESS_CAPITAL_MULTIPLIER);
		iCityValue /= 100;
	}
	else if (kOwner.isMajorCiv() && GetCityReligions()->IsHolyCityForReligion(kOwner.GetReligions()->GetOriginalReligionCreatedByPlayer()))
	{
		// This is a holy city of a religion founded by the city owner
		iCityValue *= /*150*/ GD_INT_GET(WAR_PROGRESS_HOLY_CITY_MULTIPLIER);
		iCityValue /= 100;
	}
	else if (IsOriginalMajorCapital())
	{
		// This is the original capital of some major civ other than the city owner
		iCityValue *= 150;
		iCityValue /= 100;
	}
	else if (IsOriginalMinorCapital())
	{
		// This is the original capital of a City-State
		iCityValue *= 115;
		iCityValue /= 100;
	}

	return iCityValue;
}

//	--------------------------------------------------------------------------------
/// Can a specific plot be bought for the city
bool CvCity::CanBuyPlot(int iPlotX, int iPlotY, bool bIgnoreCost) const
{
	VALIDATE_OBJECT();

	if (/*0*/ GD_INT_GET(BUY_PLOTS_DISABLED) > 0)
		return false;

	if (getOwner() == NO_PLAYER)
		return false;

	if (IsResistance() || IsIgnoreCityForHappiness())
		return false;

	CvPlot* pTargetPlot = GC.getMap().plot(iPlotX, iPlotY);
	if (!pTargetPlot)
		return false;

	// if this plot belongs to someone, bail!
	if (pTargetPlot->getOwner() != NO_PLAYER)
	{
		if (!GET_PLAYER(getOwner()).GetPlayerTraits()->IsBuyOwnedTiles())
			return false;

		if (pTargetPlot->getOwner() == getOwner() || pTargetPlot->isCity())
			return false;

		if (pTargetPlot->IsStealBlockedByImprovement())
			return false;

		//can't buy the master's plots if you're a vassal
		if (GET_TEAM(getTeam()).IsVassal(pTargetPlot->getTeam()))
			return false;

		// Bad idea for AI to steal?
		if (!GET_PLAYER(getOwner()).isHuman() && GET_PLAYER(getOwner()).isMajorCiv())
		{
			CvDiplomacyAI* pDiplo = GET_PLAYER(getOwner()).GetDiplomacyAI();
			if (pDiplo->IsBadTheftTarget(pTargetPlot->getOwner(), THEFT_TYPE_PLOT, pTargetPlot))
				return false;

			if (GET_PLAYER(pTargetPlot->getOwner()).isMinorCiv() && pTargetPlot->IsImprovementEmbassy() && pDiplo->IsBadTheftTarget(pTargetPlot->GetPlayerThatBuiltImprovement(), THEFT_TYPE_EMBASSY))
				return false;
		}
	}

	//VP: can't buy plot with enemy combat units (except Barbarians)
	if (MOD_BALANCE_VP && pTargetPlot->isEnemyUnit(getOwner(), true, false, true, false))
		return false;

	// Must be adjacent to a plot owned by this city
	bool bFoundAdjacent = false;
	for (int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)
	{
		CvPlot* pAdjacentPlot = plotDirection(pTargetPlot->getX(), pTargetPlot->getY(), ((DirectionTypes)iI));
		if (pAdjacentPlot != NULL)
		{
			if (pAdjacentPlot->getOwner() == getOwner())
			{
				if (pAdjacentPlot->getOwningCityID() == GetID())
				{
					bFoundAdjacent = true;
					break;
				}
			}
		}
	}

	if (!bFoundAdjacent)
		return false;

	// Max range
	const int iMaxRange = getBuyPlotDistance();
	if (plotDistance(iPlotX, iPlotY, getX(), getY()) > iMaxRange)
		return false;

	// check money
	if (!bIgnoreCost)
	{
		if (GET_PLAYER(getOwner()).GetTreasury()->GetGold() < GetBuyPlotCost(pTargetPlot->getX(), pTargetPlot->getY()))
		{
			return false;
		}
	}

	//can only claim ocean tiles after we can cross oceans
	if (pTargetPlot->isDeepWater())
	{
		CvPlayer& kPlayer = GET_PLAYER(getOwner());
		if (!kPlayer.CanCrossOcean())
			return false;
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if (pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(getOwner());
		args->Push(GetID());
		args->Push(iPlotX);
		args->Push(iPlotY);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if (LuaSupport::CallTestAll(pkScriptSystem, "CityCanBuyPlot", args.get(), bResult))
		{
			// Check the result.
			if (!bResult)
				return false;
		}
	}

	return true;
}


//	--------------------------------------------------------------------------------
/// Can this city buy a plot, any plot?
bool CvCity::CanBuyAnyPlot(void)
{
	if (IsResistance() || IsIgnoreCityForHappiness())
		return false;

	VALIDATE_OBJECT();
	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if (pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(getOwner());
		args->Push(GetID());

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if (LuaSupport::CallTestAll(pkScriptSystem, "CityCanBuyAnyPlot", args.get(), bResult))
		{
			// Check the result.
			if (!bResult)
			{
				if (GC.getLogging() && GC.getAILogging())
				{
					const CvPlayerAI& kOwner = GET_PLAYER(getOwner());
					CvString strPlayerName = kOwner.getCivilizationShortDescription();
					CvString strBaseString = CvString::format("%03d, %s, %s, CanBuyAnyPlot failed in lua hook",
						GC.getGame().getElapsedGameTurns(), strPlayerName.c_str(), getName().GetCString());
					kOwner.GetCitySpecializationAI()->LogMsg(strBaseString);
				}

				return false;
			}
		}
	}

	vector<int> plots;
	GetBuyablePlotList(plots, true);
	return !plots.empty();
}


//	--------------------------------------------------------------------------------
/// Which plot will we buy next
CvPlot* CvCity::GetNextBuyablePlot(bool bForPurchase)
{
	VALIDATE_OBJECT();
	std::vector<int> aiPlotList;
	GetBuyablePlotList(aiPlotList, bForPurchase);

	if (aiPlotList.empty())
		return NULL;

	uint uPickedIndex = GC.getGame().urandLimitExclusive(aiPlotList.size(), CvSeeder(getFoodTimes100()).mix(GET_PLAYER(m_eOwner).GetNumPlots()));
	return GC.getMap().plotByIndex(aiPlotList[uPickedIndex]);
}

//	--------------------------------------------------------------------------------
void CvCity::GetBuyablePlotList(std::vector<int>& aiPlotList, bool bForPurchase, int nChoices)
{
	aiPlotList.clear();
	std::vector< pair<int, int> > resultList;

	CvPlot* pLoopPlot;
	CvPlot* pThisPlot = plot();
	const int iMaxRange = /*5*/ range(GD_INT_GET(MAXIMUM_ACQUIRE_PLOT_DISTANCE), 1, MAX_CITY_RADIUS);
	TeamTypes thisTeam = getTeam();

	int iPLOT_INFLUENCE_DISTANCE_MULTIPLIER = /*100*/ GD_INT_GET(PLOT_INFLUENCE_DISTANCE_MULTIPLIER);
	int iPLOT_INFLUENCE_RING_COST = /*200*/ GD_INT_GET(PLOT_INFLUENCE_RING_COST);
	int iPLOT_INFLUENCE_RESOURCE_COST = /*-180*/ GD_INT_GET(PLOT_INFLUENCE_RESOURCE_COST);
	int iPLOT_INFLUENCE_NW_COST = /*-500*/ GD_INT_GET(PLOT_INFLUENCE_NW_COST);
	int iPLOT_INFLUENCE_WATER_COST = /*20*/ GD_INT_GET(PLOT_INFLUENCE_WATER_COST);
	int iPLOT_INFLUENCE_YIELD_POINT_COST = /*-40*/ GD_INT_GET(PLOT_INFLUENCE_YIELD_POINT_COST);
	int iPLOT_INFLUENCE_ADJACENT_NW_COST = -60;
	int iPLOT_INFLUENCE_ADJACENT_RESOURCE_COST = -40;
	int iPLOT_INFLUENCE_ADJACENT_ENEMY_COST = -20;

	int iYieldLoop = 0;

	// We have to use a larger value than iMaxRange because straight lines may be blocked by mountains etc.
	SPathFinderUserData data(getOwner(), PT_CITY_INFLUENCE, 2 * iMaxRange);

	int iWorkPlotDistance = getWorkPlotDistance();

	for (int iDX = -iMaxRange; iDX <= iMaxRange; iDX++)
	{
		for (int iDY = -iMaxRange; iDY <= iMaxRange; iDY++)
		{
			pLoopPlot = plotXYWithRangeCheck(getX(), getY(), iDX, iDY, iMaxRange);
			if (pLoopPlot != NULL)
			{
				if (pLoopPlot->getOwner() != NO_PLAYER)
				{
					// Can't naturally gain owned plots
					if (!bForPurchase)
						continue;

					// Need the trait to buy owned plots
					if (!GET_PLAYER(getOwner()).GetPlayerTraits()->IsBuyOwnedTiles())
						continue;

					// Can't buy self-owned plots or city plots
					if (pLoopPlot->getOwner() == getOwner() || pLoopPlot->isCity())
						continue;

					if (pLoopPlot->IsStealBlockedByImprovement())
						continue;
				}

				// Check for adjacent plots
				bool bNoNeighbor = true;
				bool bPromiseNeighbor = false;
				for (int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; iDirectionLoop++)
				{
					CvPlot* pAdjacentPlot = plotDirection(pLoopPlot->getX(), pLoopPlot->getY(), static_cast<DirectionTypes>(iDirectionLoop));
					if (pAdjacentPlot == NULL)
						continue;

					PlayerTypes eAdjacentPlotOwner = pAdjacentPlot->getOwner();
					if (eAdjacentPlotOwner == NO_PLAYER)
						continue;

					// Make sure city already owns one of the adjacent plots
					if (eAdjacentPlotOwner == getOwner() && pAdjacentPlot->getOwningCityID() == GetID())
					{
						bNoNeighbor = false;
						continue;
					}

					// Don't buy plots adjacent to another civ if a promise was made
					if (bForPurchase && GET_PLAYER(eAdjacentPlotOwner).isMajorCiv() && GET_PLAYER(eAdjacentPlotOwner).GetDiplomacyAI()->MadeBorderPromise(getOwner()))
					{
						bPromiseNeighbor = true;
						break;
					}
				}
				if (bNoNeighbor || bPromiseNeighbor)
					continue;

				// This can be used to implement a 12-mile limit
				if (MOD_EVENTS_CITY_BORDERS)
				{
					if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_CityCanAcquirePlot, getOwner(), GetID(), pLoopPlot->getX(), pLoopPlot->getY()) == GAMEEVENTRETURN_FALSE)
						continue;
				}
				else
				{
					ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
					if (pkScriptSystem)
					{
						CvLuaArgsHandle args;
						args->Push(getOwner());
						args->Push(GetID());
						args->Push(pLoopPlot->getX());
						args->Push(pLoopPlot->getY());

						bool bResult = false;
						if (LuaSupport::CallTestAll(pkScriptSystem, "CityCanAcquirePlot", args.get(), bResult))
						{
							if (!bResult)
								continue;
						}
					}
				}

				SPath path = GC.GetStepFinder().GetPath(pThisPlot, pLoopPlot, data);
				if (!path)
					continue;

				int iInfluenceCost = path.iNormalizedDistanceRaw / SPath::getNormalizedDistanceBase();
				if (iInfluenceCost >= 0)
				{
					iInfluenceCost *= iPLOT_INFLUENCE_DISTANCE_MULTIPLIER;

					ResourceTypes eResource = pLoopPlot->getResourceType(thisTeam);
					FeatureTypes eFeature = pLoopPlot->getFeatureType();
					if (eResource != NO_RESOURCE)
					{
						// Resource plots claimed first
						int iResourceMod = 0;
						CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
						if (pkResource)
						{
							ResourceUsageTypes eResourceUsage = pkResource->getResourceUsage();

							// This resource is useful even outside of work radius
							if (eResourceUsage == RESOURCEUSAGE_LUXURY || eResourceUsage == RESOURCEUSAGE_STRATEGIC)
							{
								iResourceMod += iPLOT_INFLUENCE_RESOURCE_COST;
								if (GET_PLAYER(getOwner()).getNumResourceTotal(eResource) == 0)
									iResourceMod += iPLOT_INFLUENCE_RESOURCE_COST / 2;
							}

							// This resource provides a wonder production bonus
							if (pkResource->getWonderProductionMod() > 0 && GET_PLAYER(getOwner()).GetCurrentEra() < pkResource->getWonderProductionModObsoleteEra())
								iResourceMod += iPLOT_INFLUENCE_RESOURCE_COST * pkResource->getWonderProductionMod() / 100;

							// This is the copy we need to gain a monopoly!
							if (GET_PLAYER(getOwner()).WouldGainMonopoly(eResource, pLoopPlot->getNumResource()))
								iResourceMod += iPLOT_INFLUENCE_RESOURCE_COST;
						}
						iInfluenceCost += iResourceMod;
					}
					else if (pLoopPlot->IsNaturalWonder())
					{
						// Natural Wonders are great
						iInfluenceCost += iPLOT_INFLUENCE_NW_COST;
					}
					else
					{
						// Unworkable plots get a big penalty on top of the distance cost
						if (plotDistance(pLoopPlot->getX(), pLoopPlot->getY(), getX(), getY()) > iWorkPlotDistance)
						{
							iInfluenceCost += iPLOT_INFLUENCE_RING_COST;
						}

						// De-prioritize unimproveable plots a bit too
						if (pLoopPlot->isWater() || pLoopPlot->isMountain())
						{
							iInfluenceCost += iPLOT_INFLUENCE_WATER_COST;
						}
						else if (eFeature != NO_FEATURE)
						{
							CvFeatureInfo* pkFeature = GC.getFeatureInfo(eFeature);
							if (pkFeature && pkFeature->isNoImprovement())
								iInfluenceCost += iPLOT_INFLUENCE_WATER_COST;
						}
					}

					// Yields are good - note that this counts the yields as if the city has owned the plot
					for (iYieldLoop = 0; iYieldLoop < NUM_YIELD_TYPES; iYieldLoop++)
					{
						YieldTypes eYield = static_cast<YieldTypes>(iYieldLoop);

						// Skip errata yields
						if (!MOD_BALANCE_CORE_JFD && eYield > YIELD_CULTURE_LOCAL)
							break;

						int iWeight = (eYield == GetCityStrategyAI()->GetMostDeficientYield()) ? 3 : 1;
						int iYield = pLoopPlot->calculateYield(eYield, false, this);

						iInfluenceCost += iPLOT_INFLUENCE_YIELD_POINT_COST * iYield * iWeight;
					}

					// Check adjacent plots too
					bool bEnemyPlotAdjacent = false;
					TerrainTypes eTerrain = pLoopPlot->getTerrainType();
					bool bTraitExtraLand = !bForPurchase && GET_PLAYER(getOwner()).GetPlayerTraits()->TerrainClaimBoost(eTerrain);
					for (int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; iDirectionLoop++)
					{
						DirectionTypes eDirection = static_cast<DirectionTypes>(iDirectionLoop);
						CvPlot* pAdjacentPlot = plotDirection(pLoopPlot->getX(), pLoopPlot->getY(), eDirection);
						if (pAdjacentPlot == NULL)
							continue;

						if (pAdjacentPlot->getOwner() == NO_PLAYER)
						{
							int iPlotDistance = plotDistance(getX(), getY(), pAdjacentPlot->getX(), pAdjacentPlot->getY());
							ResourceTypes eAdjacentResource = pAdjacentPlot->getResourceType(thisTeam);
							bool bTraitClaimable = bTraitExtraLand && (pAdjacentPlot->getTerrainType() == eTerrain);

							if (!bTraitClaimable)
							{
								// Slight priority for each adjacent workable or sellable resource
								if (eAdjacentResource != NO_RESOURCE)
								{
									CvResourceInfo* pkAdjacentResource = GC.getResourceInfo(eAdjacentResource);
									if (pkAdjacentResource)
									{
										ResourceUsageTypes eResourceUsage = pkAdjacentResource->getResourceUsage();
										if (iPlotDistance <= iWorkPlotDistance || eResourceUsage == RESOURCEUSAGE_LUXURY || eResourceUsage == RESOURCEUSAGE_STRATEGIC)
										{
											iInfluenceCost += iPLOT_INFLUENCE_ADJACENT_RESOURCE_COST;
										}
										else if (pkAdjacentResource->getWonderProductionMod() > 0 && GET_PLAYER(getOwner()).GetCurrentEra() < pkAdjacentResource->getWonderProductionModObsoleteEra())
										{
											iInfluenceCost += iPLOT_INFLUENCE_ADJACENT_RESOURCE_COST;
										}
									}
								}

								// Priority for each adjacent Natural Wonder
								if (pAdjacentPlot->IsNaturalWonder())
									iInfluenceCost += iPLOT_INFLUENCE_ADJACENT_NW_COST;
							}
							else
							{
								// Special handling for the trait that grabs extra land on border growth:
								// Basically the same scoring scheme as above but without checking adjacent plots
								// Score is capped at -1 since claiming more plots can't be worse
								SPath adjacentPath = GC.GetStepFinder().GetPath(pThisPlot, pAdjacentPlot, data);
								int iAdjacentCost = iMaxRange * iPLOT_INFLUENCE_DISTANCE_MULTIPLIER;
								if (!adjacentPath.vPlots.empty())
									iAdjacentCost = adjacentPath.iNormalizedDistanceRaw / SPath::getNormalizedDistanceBase();

								FeatureTypes eAdjacentFeature = pAdjacentPlot->getFeatureType();
								if (eAdjacentResource != NO_RESOURCE)
								{
									CvResourceInfo* pkAdjacentResource = GC.getResourceInfo(eAdjacentResource);
									if (pkAdjacentResource)
									{
										ResourceUsageTypes eResourceUsage = pkAdjacentResource->getResourceUsage();
										if (eResourceUsage == RESOURCEUSAGE_LUXURY || eResourceUsage == RESOURCEUSAGE_STRATEGIC)
										{
											iAdjacentCost += iPLOT_INFLUENCE_RESOURCE_COST;
											if (GET_PLAYER(getOwner()).getNumResourceTotal(eAdjacentResource) == 0)
												iAdjacentCost += iPLOT_INFLUENCE_RESOURCE_COST / 2;
										}

										if (pkAdjacentResource->getWonderProductionMod() > 0 && GET_PLAYER(getOwner()).GetCurrentEra() < pkAdjacentResource->getWonderProductionModObsoleteEra())
											iAdjacentCost += iPLOT_INFLUENCE_RESOURCE_COST * pkAdjacentResource->getWonderProductionMod() / 100;

										if (GET_PLAYER(getOwner()).WouldGainMonopoly(eAdjacentResource, pAdjacentPlot->getNumResource()))
											iAdjacentCost += iPLOT_INFLUENCE_RESOURCE_COST;
									}
								}
								else if (pAdjacentPlot->IsNaturalWonder())
								{
									iAdjacentCost += iPLOT_INFLUENCE_NW_COST;
								}
								else
								{
									if (plotDistance(pAdjacentPlot->getX(), pAdjacentPlot->getY(), getX(), getY()) > iWorkPlotDistance)
									{
										iAdjacentCost += iPLOT_INFLUENCE_RING_COST;
									}

									if (pAdjacentPlot->isWater() || pAdjacentPlot->isMountain())
									{
										iAdjacentCost += iPLOT_INFLUENCE_WATER_COST;
									}
									else if (eAdjacentFeature != NO_FEATURE)
									{
										CvFeatureInfo* pkFeature = GC.getFeatureInfo(eAdjacentFeature);
										if (pkFeature && pkFeature->isNoImprovement())
											iAdjacentCost += iPLOT_INFLUENCE_WATER_COST;
									}
								}

								for (iYieldLoop = 0; iYieldLoop < NUM_YIELD_TYPES; iYieldLoop++)
								{
									YieldTypes eYield = static_cast<YieldTypes>(iYieldLoop);

									// Skip errata yields
									if (!MOD_BALANCE_CORE_JFD && eYield > YIELD_CULTURE_LOCAL)
										break;

									int iWeight = (eYield == GetCityStrategyAI()->GetMostDeficientYield()) ? 3 : 1;
									int iYield = pAdjacentPlot->calculateYield(eYield, false, this);

									iAdjacentCost += iPLOT_INFLUENCE_YIELD_POINT_COST * iYield * iWeight;
								}

								// Capped at -1 for each adjacent claimable plot
								iInfluenceCost += min(-1, iAdjacentCost);
							}
						}
						else if (pAdjacentPlot->getTeam() != getTeam())
						{
							bEnemyPlotAdjacent = true;
						}
					}

					// Prefer plots near other players (grab them before they do)
					if (bEnemyPlotAdjacent)
						iInfluenceCost += iPLOT_INFLUENCE_ADJACENT_ENEMY_COST;

					resultList.push_back(std::make_pair(iInfluenceCost, pLoopPlot->GetPlotIndex()));
				}
			}
		}
	}

	//we want only the best
	std::stable_sort(resultList.begin(), resultList.end());
	if (resultList.size() > (size_t)nChoices)
		resultList.erase(resultList.begin() + nChoices, resultList.end());

	//throw away the cost, return the plot index only
	for (size_t i = 0; i < resultList.size(); i++)
		//if there's a clear favorite, don't bother with the rest
		if (resultList[i].first - resultList[0].first <= 100)
			aiPlotList.push_back(resultList[i].second);
}

//	--------------------------------------------------------------------------------
int CvCity::calculateInfluenceDistance(CvPlot* pDest, int iMaxRange) const
{
	if (pDest == NULL)
		return -1;

	// We have to use a larger value than iMaxRange because straight lines may be blocked by mountains etc.
	SPathFinderUserData data(getOwner(), PT_CITY_INFLUENCE, 2 * iMaxRange);
	SPath path = GC.GetStepFinder().GetPath(getX(), getY(), pDest->getX(), pDest->getY(), data);
	if (!path)
		return -1; // no passable path exists
	else
		return (path.iNormalizedDistanceRaw * /*100*/ GD_INT_GET(PLOT_INFLUENCE_DISTANCE_MULTIPLIER)) / SPath::getNormalizedDistanceBase();
}

//	--------------------------------------------------------------------------------
/// How much will purchasing this plot cost -- (-1,-1) will return the generic price
int CvCity::GetBuyPlotCost(int iPlotX, int iPlotY) const
{
	VALIDATE_OBJECT();
	if (iPlotX == -1 && iPlotY == -1)
	{
		return GET_PLAYER(getOwner()).GetBuyPlotCost();
	}

	CvPlot* pPlot = GC.getMap().plot(iPlotX, iPlotY);
	if (!pPlot)
	{
		return -1;
	}

	// Base cost
	int iCost = GET_PLAYER(getOwner()).GetBuyPlotCost();

	const int iMaxRange = getBuyPlotDistance();
	if (plotDistance(iPlotX, iPlotY, getX(), getY()) > iMaxRange)
		return 9999; // Critical hit!

	int iPLOT_INFLUENCE_BASE = /*100*/ GD_INT_GET(PLOT_INFLUENCE_BASE_MULTIPLIER);
	int iPLOT_INFLUENCE_DISTANCE_DIVISOR = /*3*/ GD_INT_GET(PLOT_INFLUENCE_DISTANCE_DIVISOR);
	int iPLOT_BUY_RESOURCE_COST = /*-100 in CP, 0 in VP*/ GD_INT_GET(PLOT_BUY_RESOURCE_COST);

	// the path length can be larger than iMaxRange because there might not be a straight line of owned tiles from the city center to the plot
	int iDistance = calculateInfluenceDistance(pPlot, GetNumWorkablePlots());
	if (iDistance == -1)
		return 9999; // failsafe

	int iRefDistance = GetCheapestPlotInfluenceDistance();
	if (iRefDistance == INT_MAX)
		iRefDistance = 0;

	//note: we don't use getPLOT_INFLUENCE_DISTANCE_MULTIPLIER() here because the influence distance is already pre-multiplied
	int iInfluenceCostFactor = iPLOT_INFLUENCE_BASE + (iDistance - iRefDistance) / iPLOT_INFLUENCE_DISTANCE_DIVISOR;
	if (pPlot->getResourceType(getTeam()) != NO_RESOURCE)
	{
		iInfluenceCostFactor += iPLOT_BUY_RESOURCE_COST;
	}

	if (iInfluenceCostFactor > 100)
	{
		iCost *= iInfluenceCostFactor;
		iCost /= 100;
	}

#if defined(MOD_UI_CITY_EXPANSION)
	if (MOD_UI_CITY_EXPANSION && GET_PLAYER(getOwner()).isHuman()) {
		// If we have a culture surplus, we get a discount on the tile
		if (GetJONSCultureStored() >= GetJONSCultureThreshold()) {
			iCost -= GET_PLAYER(getOwner()).GetBuyPlotCost();
		}
	}
#endif

#if defined(MOD_BALANCE_CORE)
	//Owned by someone? Much more expensive!
	if (MOD_BALANCE_CORE && GET_PLAYER(getOwner()).GetPlayerTraits()->IsBuyOwnedTiles())
	{
		if ((pPlot->getOwner() != NO_PLAYER) && (pPlot->getOwner() != getOwner()))
		{
			iCost *= 3;
			iCost /= 2;
		}
	}
#endif

	// Discount for adjacent plots owned by us
	iCost = iCost * (105 - pPlot->countMatchingAdjacentPlots(NO_DOMAIN, getOwner(), NO_PLAYER, NO_PLAYER) * 5); //we know that one is always owned
	iCost /= 100;

	// Game Speed Mod
	iCost *= GC.getGame().getGameSpeedInfo().getGoldPercent();
	iCost /= 100;

	iCost *= (100 + getPlotBuyCostModifier());
	iCost /= 100;

	// Now round so the number looks neat
	int iDivisor = /*5*/ max(1, GD_INT_GET(PLOT_COST_APPEARANCE_DIVISOR));
	iCost = (iCost + iDivisor / 2) / iDivisor;
	iCost *= iDivisor;

	return iCost;
}

//	--------------------------------------------------------------------------------
/// Buy the plot and set it's owner to us (executed by the network code)
void CvCity::BuyPlot(int iPlotX, int iPlotY, bool bAutomaticPurchaseFromBuilding)
{
	VALIDATE_OBJECT();
	CvPlot* pPlot = GC.getMap().plot(iPlotX, iPlotY);
	if (!pPlot)
	{
		return;
	}

	CvPlayer& thisPlayer = GET_PLAYER(getOwner());
	bool bWithGold = false;

	int iCost = bAutomaticPurchaseFromBuilding ? 0 : GetBuyPlotCost(iPlotX, iPlotY);
	if (iCost > 0)
	{
		thisPlayer.GetTreasury()->LogExpenditure("buy plot", iCost, 1);
		thisPlayer.GetTreasury()->ChangeGold(-iCost);
		bWithGold = true;
		if (MOD_UI_CITY_EXPANSION && GET_PLAYER(getOwner()).isHuman()) {
			// If we have a culture surplus, we got a discount on the tile, so remove the surplus
			int iOverflow = GetJONSCultureStored() - GetJONSCultureThreshold();
			if (iOverflow >= 0) {
				SetJONSCultureStored(iOverflow);
				ChangeJONSCultureLevel(1);
				bWithGold = false;
			}
		}
	}

	// Did we buy this plot from someone? They're gonna be mad!
	PlayerTypes ePlotOwner = pPlot->getOwner();
	if (ePlotOwner != NO_PLAYER && (bAutomaticPurchaseFromBuilding || iCost > 0) && !GET_PLAYER(getOwner()).isBarbarian() && !GET_PLAYER(ePlotOwner).isBarbarian())
	{
		bool bStoleHighValueTile = false;
		int iTileValue = pPlot->GetStealPlotValue(getOwner(), bStoleHighValueTile);

		// Stole a major civ's embassy from a City-State?
		if (pPlot->IsImprovementEmbassy() && GET_PLAYER(ePlotOwner).isMinorCiv())
		{
			PlayerTypes eEmbassyOwner = pPlot->GetPlayerThatBuiltImprovement();
			if (GET_PLAYER(eEmbassyOwner).isAlive() && GET_PLAYER(eEmbassyOwner).isMajorCiv() && GET_PLAYER(eEmbassyOwner).getTeam() != GET_PLAYER(getOwner()).getTeam())
			{
				// Notify the embassy owner
				CvNotifications* pNotifications = GET_PLAYER(eEmbassyOwner).GetNotifications();
				if (pNotifications)
				{
					CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_GREAT_ARTIST_STOLE_PLOT", GET_PLAYER(getOwner()).getNameKey());
					CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_GREAT_ARTIST_STOLE_PLOT", GET_PLAYER(getOwner()).getNameKey());
					pNotifications->Add(NOTIFICATION_GENERIC, strBuffer, strSummary, pPlot->getX(), pPlot->getY(), -1);
				}

				// The embassy owner is mad (doubly so if they're diplomacy-inclined)!
				if (!GET_PLAYER(eEmbassyOwner).isHuman())
				{
					int iPenalty = (GET_PLAYER(eEmbassyOwner).GetDiplomacyAI()->IsDiplomat() || GET_PLAYER(eEmbassyOwner).GetPlayerTraits()->IsDiplomat()) ? 6 : 3;
					GET_PLAYER(eEmbassyOwner).GetDiplomacyAI()->ChangeNumTimesCultureBombed(getOwner(), iPenalty);
				}

				// Message for human
				if (!bAutomaticPurchaseFromBuilding)
				{
					if (!GET_PLAYER(ePlotOwner).isHuman() && getTeam() != GET_PLAYER(eEmbassyOwner).getTeam() && !GET_PLAYER(getOwner()).IsAtWarWith(eEmbassyOwner) && !CvPreGame::isNetworkMultiplayerGame() && GC.getGame().getActivePlayer() == getOwner() && !GC.getGame().IsInsultMessagesDisabled() && !GC.getGame().IsAllDiploStatementsDisabled())
					{
						DLLUI->SetForceDiscussionModeQuitOnBack(true);		// Set force quit so that when discuss mode pops up the Back button won't go to leader root
						const char* strText = GET_PLAYER(eEmbassyOwner).GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_CULTURE_BOMBED);
						gDLL->GameplayDiplomacyAILeaderMessage(eEmbassyOwner, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
					}
				}

				// Stole from the City-State's ally? The City-State is furious!
				if (GET_PLAYER(ePlotOwner).GetMinorCivAI()->GetAlly() == eEmbassyOwner)
				{
					GET_PLAYER(ePlotOwner).GetMinorCivAI()->SetFriendshipWithMajor(getOwner(), /*-60*/ GD_INT_GET(MINOR_FRIENDSHIP_AT_WAR));
				}
				// Stole from the City-State's friend and we're not their ally? Reset Influence to 0.
				else if (GET_PLAYER(ePlotOwner).GetMinorCivAI()->GetAlly() != getOwner() && GET_PLAYER(ePlotOwner).GetMinorCivAI()->IsFriends(eEmbassyOwner))
				{
					if (GET_PLAYER(ePlotOwner).GetMinorCivAI()->GetBaseFriendshipWithMajorTimes100(getOwner()) > 0)
					{
						GET_PLAYER(ePlotOwner).GetMinorCivAI()->SetFriendshipWithMajor(getOwner(), 0);
					}
				}
			}
		}
		// If the players are at war, this counts for war value!
		if (GET_PLAYER(getOwner()).IsAtWarWith(ePlotOwner))
		{
			GET_PLAYER(getOwner()).ApplyWarDamage(ePlotOwner, iTileValue, true);

			if (GET_PLAYER(getOwner()).isMajorCiv())
			{
				int iWarProgress = /*20*/ GD_INT_GET(WAR_PROGRESS_STOLE_TILE);
				if (bStoleHighValueTile)
				{
					iWarProgress *= /*200*/ GD_INT_GET(WAR_PROGRESS_HIGH_VALUE_PILLAGE_MULTIPLIER);
					iWarProgress /= 200; // not a typo
				}
				else
					iWarProgress /= 4;

				GET_PLAYER(getOwner()).GetDiplomacyAI()->ChangeWarProgressScore(ePlotOwner, iWarProgress);
			}
			if (GET_PLAYER(ePlotOwner).isMajorCiv())
			{
				int iWarProgress = /*-10*/ GD_INT_GET(WAR_PROGRESS_LOST_TILE);
				if (bStoleHighValueTile)
				{
					iWarProgress *= /*200*/ GD_INT_GET(WAR_PROGRESS_HIGH_VALUE_PILLAGE_MULTIPLIER);
					iWarProgress /= 200; // not a typo
				}
				else
					iWarProgress /= 4;

				GET_PLAYER(ePlotOwner).GetDiplomacyAI()->ChangeWarProgressScore(getOwner(), iWarProgress);
			}
		}
		// Diplomacy penalty for stealing territory during peacetime (for majors), always (for City-States)
		else if (GET_PLAYER(ePlotOwner).isMinorCiv())
		{
			int iEra = GC.getGame().getCurrentEra();
			if (iEra <= 0)
				iEra = 1;

			GET_PLAYER(ePlotOwner).GetMinorCivAI()->ChangeFriendshipWithMajor(getOwner(), iEra * -20);
		}
		else if (GET_PLAYER(getOwner()).isMajorCiv() && GET_PLAYER(ePlotOwner).isMajorCiv())
		{
			int iPenalty = bStoleHighValueTile ? 3 : 1;
			GET_PLAYER(ePlotOwner).GetDiplomacyAI()->ChangeNumTimesCultureBombed(getOwner(), iPenalty);
		}

		// Message for human
		if (!bAutomaticPurchaseFromBuilding && GET_PLAYER(ePlotOwner).isMajorCiv())
		{
			if (!GET_PLAYER(ePlotOwner).isHuman() && getTeam() != GET_PLAYER(ePlotOwner).getTeam() && !GET_PLAYER(getOwner()).IsAtWarWith(ePlotOwner) && !CvPreGame::isNetworkMultiplayerGame() && GC.getGame().getActivePlayer() == getOwner() && !GC.getGame().IsInsultMessagesDisabled() && !GC.getGame().IsAllDiploStatementsDisabled())
			{
				DLLUI->SetForceDiscussionModeQuitOnBack(true);		// Set force quit so that when discuss mode pops up the Back button won't go to leader root
				const char* strText = GET_PLAYER(ePlotOwner).GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_CULTURE_BOMBED);
				gDLL->GameplayDiplomacyAILeaderMessage(ePlotOwner, DIPLO_UI_STATE_BLANK_DISCUSSION, strText, LEADERHEAD_ANIM_HATE_NEGATIVE);
			}
		}
	}

	if (iCost > 0)
	{
		// Only do this if we actually paid for the plot (as opposed to getting it for free via city growth)
		thisPlayer.ChangeNumPlotsBought(1);

		//Let's look at plots in the vicinity of the bought plot
		for (int iI = 0; iI < RING3_PLOTS; iI++)
		{
			CvPlot* pLoopPlot = iterateRingPlots(iPlotX, iPlotY, iI);

			if (pLoopPlot != NULL)
			{
				// See if there's anyone else nearby that could get upset by this action
				int iPlotValue = 0;
				CvCity* pNearbyCity = pLoopPlot->getPlotCity();
				if (pNearbyCity)
				{
					PlayerTypes eOtherPlayer = pNearbyCity->getOwner();
					//We found another player? Good.
					if (eOtherPlayer != NO_PLAYER && !GET_PLAYER(eOtherPlayer).isMinorCiv() && eOtherPlayer != getOwner())
					{
						//Resource? Grr!
						if (pPlot->getResourceType(GET_PLAYER(eOtherPlayer).getTeam()) != NO_RESOURCE)
						{
							iPlotValue = 1;
						}
						//Natural Wonder? Grr!!!!
						else if (pPlot->IsNaturalWonder())
						{
							iPlotValue = 3;
						}
						else
						{
							//Neighbors? Grr!
							int iUsOwned = 0;
							int iThemOwned = 0;
							CvPlot* pAdjacentPlot = NULL;
							for (int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; iDirectionLoop++)
							{
								pAdjacentPlot = plotDirection(pPlot->getX(), pPlot->getY(), ((DirectionTypes)iDirectionLoop));

								if (pAdjacentPlot != NULL)
								{
									if (pAdjacentPlot->getOwner() == eOtherPlayer)
									{
										iThemOwned++;
									}
									if (pAdjacentPlot->getOwner() == getOwner())
									{
										iUsOwned++;
									}
								}
							}
							//We're buying land near their claimed tiles? Grr!
							if (iThemOwned > iUsOwned)
							{
								iPlotValue = 2;
							}
							//We're competing? Grr!
							else if (iThemOwned > 0)
							{
								iPlotValue = 1;
							}
						}
					}
					if (iPlotValue > 0)
					{
						pNearbyCity->AI_ChangeNumPlotsAcquiredByOtherPlayer(getOwner(), iPlotValue);
						// Test to see if a land buying promise was broken
						if (GET_PLAYER(eOtherPlayer).GetDiplomacyAI()->GetNumTurnsBorderPromise(getOwner()) > 0)
						{
							GET_PLAYER(eOtherPlayer).GetDiplomacyAI()->SetBorderPromiseState(getOwner(), PROMISE_STATE_BROKEN);
						}
						break;
					}
				}
			}
		}
	}

#if defined(MOD_BALANCE_CORE)
	GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_TILE_PURCHASE, true, NO_GREATPERSON, NO_BUILDING,
		0, true, NO_PLAYER, NULL, false, this, false, true, false, NO_YIELD, NULL, pPlot->getTerrainType());
#endif

	if (GC.getLogging() && GC.getAILogging())
	{
		CvPlayerAI& kOwner = GET_PLAYER(getOwner());
		CvString strBaseString;
		CvString strOutBuf;
		CvString playerName = kOwner.getCivilizationShortDescription();
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";
		strOutBuf.Format("%s, City Plot Purchased, X: %d, Y: %d", getName().GetCString(), iPlotX, iPlotY);
		strBaseString += strOutBuf;
		kOwner.GetCitySpecializationAI()->LogMsg(strBaseString);
	}

	if (pPlot->getOwner() != getOwner() && pPlot->getOwner() != NO_PLAYER && GET_PLAYER(pPlot->getOwner()).isHuman())
	{
		CvNotifications* pNotifications = GET_PLAYER(pPlot->getOwner()).GetNotifications();
		if (pNotifications)
		{
			CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_UA_STOLE_PLOT", GET_PLAYER(getOwner()).getNameKey());
			CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_UA_STOLE_PLOT", GET_PLAYER(getOwner()).getNameKey());
			pNotifications->Add(NOTIFICATION_GENERIC, strBuffer, strSummary, pPlot->getX(), pPlot->getY(), -1);
		}
	}

	DoAcquirePlot(iPlotX, iPlotY);

	if (MOD_EVENTS_CITY)
	{
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityBoughtPlot, getOwner(), GetID(), iPlotX, iPlotY, bWithGold, false);
	}
	else
	{
		ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
		if (pkScriptSystem)
		{
			CvLuaArgsHandle args;
			args->Push(getOwner());
			args->Push(GetID());
			args->Push(iPlotX);
			args->Push(iPlotY);
			args->Push(bWithGold); // bGold
			args->Push(false); // bFaith/bCulture

			bool bResult = false;
			LuaSupport::CallHook(pkScriptSystem, "CityBoughtPlot", args.get(), bResult);
		}
	}

	//Achievement test for purchasing 1000 tiles
	if (MOD_API_ACHIEVEMENTS && thisPlayer.isHuman() && !GC.getGame().isGameMultiPlayer() && !bAutomaticPurchaseFromBuilding)
	{
		gDLL->IncrementSteamStatAndUnlock(ESTEAMSTAT_TILESPURCHASED, 1000, ACHIEVEMENT_PURCHASE_1000TILES);
	}
}

//	--------------------------------------------------------------------------------
/// Acquire the plot and set it's owner to us
void CvCity::DoAcquirePlot(int iPlotX, int iPlotY)
{
	VALIDATE_OBJECT();
	CvPlot* pPlot = GC.getMap().plot(iPlotX, iPlotY);
	if (!pPlot)
	{
		return;
	}

	GET_PLAYER(getOwner()).AddAPlot(pPlot);
	pPlot->setOwner(getOwner(), GetID(), /*bCheckUnits*/ true, /*bUpdateResources*/ true);
	GC.getMap().updateDeferredFog();

	// If the plot is too far away for us to work, we should let nearby cities who can work it know
	if (plotDistance(getX(), getY(), iPlotX, iPlotY) > getWorkPlotDistance())
	{
		const CvPlayer& kOwner = GET_PLAYER(getOwner());
		int iLoop = 0;
		for (const CvCity* pLoopCity = kOwner.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kOwner.nextCity(&iLoop))
		{
			if (pLoopCity == this)
				continue;

			if (plotDistance(pLoopCity->getX(), pLoopCity->getY(), iPlotX, iPlotY) <= pLoopCity->getWorkPlotDistance())
			{
				pLoopCity->GetCityCitizens()->SetDirty(true);
				pLoopCity->GetCityCitizens()->DoReallocateCitizens();

				if (pLoopCity->GetCityCitizens()->IsWorkingPlot(pPlot))
				{
					break;
				}

				// Undo override in case the governor decided to work the plot but later changed their mind
				pPlot->setOwningCityOverride(NULL);
			}
		}
	}
	else
	{
		GetCityCitizens()->SetDirty(true);
		GetCityCitizens()->DoReallocateCitizens();
	}

	DoUpdateCheapestPlotInfluenceDistance();
}

//	--------------------------------------------------------------------------------
/// Compute how valuable buying a plot is to this city
int CvCity::GetBuyPlotScore(int& iBestX, int& iBestY)
{
	VALIDATE_OBJECT();
	int iBestScore = -1;

	vector<CvPlot*> validChoices;
	for (int iI = 0; iI < GetNumWorkablePlots(); iI++)
	{
		CvPlot* pLoopPlot = GetCityCitizens()->GetCityPlotFromIndex(iI);
		if (!pLoopPlot)
			continue;

		// Can we actually buy this plot?
		if (!CanBuyPlot(pLoopPlot->getX(), pLoopPlot->getY(), true))
			continue;

		int iTempScore = GetIndividualPlotScore(pLoopPlot);
		if (iTempScore > iBestScore)
		{
			iBestScore = iTempScore;
			iBestX = pLoopPlot->getX();
			iBestY = pLoopPlot->getY();
		}
	}

	return iBestScore;
}

//	--------------------------------------------------------------------------------
/// Compute value of a plot we might buy
int CvCity::GetIndividualPlotScore(const CvPlot* pPlot) const
{
	VALIDATE_OBJECT();

	int iRtnValue = 0;
	YieldTypes eSpecializationYield = NO_YIELD;
	CitySpecializationTypes eSpecialization = GetCityStrategyAI()->GetSpecialization();
	if (eSpecialization != NO_CITY_SPECIALIZATION)
	{
		eSpecializationYield = GC.getCitySpecializationInfo(eSpecialization)->GetYieldType();
	}

	// Does it have a resource?
	ResourceTypes eResource = pPlot->getResourceType(getTeam());
	if (eResource != NO_RESOURCE)
	{
		CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
		if (pkResource)
		{
			if (GET_PLAYER(getOwner()).IsResourceRevealed(eResource))
			{
				ResourceUsageTypes eResourceUsage = GC.getResourceInfo(eResource)->getResourceUsage();
				if (eResourceUsage == RESOURCEUSAGE_STRATEGIC)
				{
					iRtnValue += /*240*/ GD_INT_GET(AI_PLOT_VALUE_STRATEGIC_RESOURCE) * 3;
				}

				// Luxury resource?
				else if (eResourceUsage == RESOURCEUSAGE_LUXURY)
				{
					int iLuxuryValue = /*120*/ GD_INT_GET(AI_PLOT_VALUE_LUXURY_RESOURCE) * 3;

					// Luxury we don't have yet?
					if (GET_PLAYER(getOwner()).getNumResourceTotal(eResource) == 0)
						iLuxuryValue *= 2;

					iRtnValue += iLuxuryValue;
				}
			}
		}
	}

	int iYieldValue = 0;

	CvCityStrategyAI* pCityStrategyAI = GetCityStrategyAI();

	// Valuate the yields from this plot
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes)iI;

		int iYield = pPlot->calculateNatureYield(eYield, getOwner(), pPlot->getFeatureType(), pPlot->getResourceType(getTeam()), NULL);

		int iTempValue = 0;

		if (eYield == eSpecializationYield)
			iTempValue += iYield * /*20*/ GD_INT_GET(AI_PLOT_VALUE_SPECIALIZATION_MULTIPLIER);
		else
			iTempValue += iYield * /*10*/ GD_INT_GET(AI_PLOT_VALUE_YIELD_MULTIPLIER);

		// Deficient? If so, give it a boost
		if (pCityStrategyAI->GetMostDeficientYield() == eYield)
			iTempValue *= /*5*/ GD_INT_GET(AI_PLOT_VALUE_DEFICIENT_YIELD_MULTIPLIER);

		TerrainTypes eTerrain = pPlot->getTerrainType();

		int iTraitValue = GET_PLAYER(getOwner()).GetPlayerTraits()->GetYieldChangeFromTilePurchaseTerrainType(eTerrain, eYield);

		if (iTraitValue > 0)
		{
			if (eYield == eSpecializationYield)
			{
				iTempValue += iTraitValue * /*20*/ GD_INT_GET(AI_PLOT_VALUE_SPECIALIZATION_MULTIPLIER) / 10; // Dividing by 10 because this is an instant yield
			}
			else
			{
				iTempValue += iTraitValue * /*10*/ GD_INT_GET(AI_PLOT_VALUE_YIELD_MULTIPLIER) / 10;
			}
		}

		iYieldValue += iTempValue;
	}

	iRtnValue += iYieldValue;

	if (GET_PLAYER(getOwner()).GetBuilderTaskingAI()->GetBestRouteTypeAndValue(pPlot).first != NO_ROUTE)
	{
		iRtnValue += /*80*/ GD_INT_GET(AI_PLOT_VALUE_STRATEGIC_RESOURCE);
	}
	if (pPlot->IsChokePoint())
	{
		iRtnValue += /*80*/ GD_INT_GET(AI_PLOT_VALUE_STRATEGIC_RESOURCE);
	}
	if (pPlot->IsWaterAreaSeparator())
	{
		iRtnValue += /*80*/ GD_INT_GET(AI_PLOT_VALUE_STRATEGIC_RESOURCE);
	}

	// For each player not on our team, check how close their nearest city is to this plot
	CvPlayer& owningPlayer = GET_PLAYER(m_eOwner);
	CvDiplomacyAI* owningPlayerDiploAI = owningPlayer.GetDiplomacyAI();
	bool bAmerica = GET_PLAYER(getOwner()).GetPlayerTraits()->IsBuyOwnedTiles() && iRtnValue > 0;
	for (int iI = 0; iI < MAX_MAJOR_CIVS; iI++)
	{
		CvPlayer& loopPlayer = GET_PLAYER((PlayerTypes)iI);
		if (loopPlayer.isAlive())
		{
			if (loopPlayer.getTeam() != getTeam())
			{
				DisputeLevelTypes eLandDisputeLevel = owningPlayerDiploAI->GetLandDisputeLevel((PlayerTypes)iI);

				if (eLandDisputeLevel != DISPUTE_LEVEL_NONE)
				{
					CvCity* pCity = GC.getMap().findCity(pPlot->getX(), pPlot->getY(), (PlayerTypes)iI, NO_TEAM, true /*bSameArea */);

					if (pCity)
					{
						int iDistance = plotDistance(pPlot->getX(), pPlot->getY(), pCity->getX(), pCity->getY());

						// Only want to account for civs with a city within 10 tiles
						if (iDistance < 10)
						{
							bool bManifestDestiny = bAmerica && pPlot->getOwner() == loopPlayer.GetID();

							switch (eLandDisputeLevel)
							{
							case DISPUTE_LEVEL_FIERCE:
								iRtnValue += (10 - iDistance) * /*6*/ GD_INT_GET(AI_PLOT_VALUE_FIERCE_DISPUTE);

								if (bManifestDestiny)
									iRtnValue *= 8;

								break;
							case DISPUTE_LEVEL_STRONG:
								iRtnValue += (10 - iDistance) * /*4*/ GD_INT_GET(AI_PLOT_VALUE_STRONG_DISPUTE);

								if (bManifestDestiny)
									iRtnValue *= 4;

								break;
							case DISPUTE_LEVEL_WEAK:
								iRtnValue += (10 - iDistance) * /*2*/ GD_INT_GET(AI_PLOT_VALUE_WEAK_DISPUTE);

								if (bManifestDestiny)
									iRtnValue *= 2;

								break;
							case DISPUTE_LEVEL_NONE:
								UNREACHABLE();
							}
						}
					}
				}
			}
		}
	}
	// Modify value based on cost - the higher it is compared to the "base" cost the less the value
	int iCost = GetBuyPlotCost(pPlot->getX(), pPlot->getY());

	iRtnValue *= GET_PLAYER(getOwner()).GetBuyPlotCost();

	//protect against citadels
	CvUnit* pGeneral = pPlot->getFirstUnitOfAITypeOtherTeam(getTeam(), UNITAI_GENERAL);
	if (pGeneral && plotDistance(*plot(), *pPlot) < 4)
	{
		int iBonus = 50 * pPlot->countMatchingAdjacentPlots(NO_DOMAIN, getOwner(), NO_PLAYER, NO_PLAYER);
		iRtnValue += (iRtnValue * iBonus) / 100;
	}

	//try and snatch up natural wonders
	if (pPlot->IsNaturalWonder() && pPlot->IsAdjacentOwnedByTeamOtherThan(getTeam()))
	{
		iRtnValue *= 2;
	}

	// Protect against div by 0.
	ASSERT_DEBUG(iCost != 0, "Plot cost is 0");
	if (iCost != 0)
		iRtnValue /= iCost;
	else
		iRtnValue = 0;

	return iRtnValue;
}

//	--------------------------------------------------------------------------------
/// What is the cheapest plot we can get
int CvCity::GetCheapestPlotInfluenceDistance() const
{
	return m_iCheapestPlotInfluenceDistance;
}

//	--------------------------------------------------------------------------------
/// What is the cheapest plot we can get
void CvCity::SetCheapestPlotInfluenceDistance(int iValue)
{
	if (m_iCheapestPlotInfluenceDistance != iValue)
		m_iCheapestPlotInfluenceDistance = iValue;

	ASSERT_DEBUG(m_iCheapestPlotInfluenceDistance > 0, "Cheapest plot influence should never be 0 or less.");
}

//	--------------------------------------------------------------------------------
/// What is the cheapest plot we can get
void CvCity::DoUpdateCheapestPlotInfluenceDistance()
{
	vector<int> plots;
	GetBuyablePlotList(plots, false);

	int iInfluenceDistance = INT_MAX;
	if (!plots.empty())
	{
		iInfluenceDistance = calculateInfluenceDistance(GC.getMap().plotByIndex(plots.front()), /*5*/ range(GD_INT_GET(MAXIMUM_ACQUIRE_PLOT_DISTANCE), 1, MAX_CITY_RADIUS));
		ASSERT_DEBUG(iInfluenceDistance != -1, "Plots returned from GetBuyablePlotList() should always be reachable");
	}
	SetCheapestPlotInfluenceDistance(iInfluenceDistance);
}

void CvCity::UpdateYieldsFromExistingFriendsAndAllies(bool bRemove)
{
	//if a city is founded or conquered we have to make sure it gets the current bonuses so we can subtract the bonus later when it experies
	//this method should only be called once per city on its first turn or when the capital moves ...

	int iSign = bRemove ? -1 : +1;

	if (MOD_BALANCE_CORE && isCapital())
	{
		CvPlayer& kPlayer = GET_PLAYER(getOwner());
		int iNumAllies = kPlayer.GetNumCSAllies();
		int iNumFriends = kPlayer.GetNumCSFriends();
		if (iNumAllies > 0 || iNumFriends > 0)
		{
			int iEra = max(1, (int)kPlayer.GetCurrentEra());
			for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				YieldTypes eYield = (YieldTypes)iI;
				ChangeBaseYieldRateFromCSAlliance(eYield, (kPlayer.GetPlayerTraits()->GetYieldFromCSAlly(eYield) * iNumAllies * iEra * iSign));
				ChangeBaseYieldRateFromCSFriendship(eYield, (kPlayer.GetPlayerTraits()->GetYieldFromCSFriend(eYield) * iNumFriends * iEra * iSign));
			}
		}
	}

	for (int iPlayerLoop = MAX_MAJOR_CIVS; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes)iPlayerLoop;
		CvMinorCivAI* pMinor = GET_PLAYER(ePlayer).isMinorCiv() && GET_PLAYER(ePlayer).isAlive() ? GET_PLAYER(ePlayer).GetMinorCivAI() : 0;
		if (pMinor && pMinor->GetTrait() == MINOR_CIV_TRAIT_MARITIME)
		{
			if (pMinor->IsAllies(getOwner()))
			{
				int iBonus = isCapital() ? pMinor->GetAlliesCapitalFoodBonus() : pMinor->GetAlliesOtherCityFoodBonus();
				if (iBonus != 0)
				{
					ChangeBaseYieldRateFromCSAlliance(YIELD_FOOD, iSign * iBonus / 100);
					//CUSTOMLOG("adjusted food in %s by %d/100 for alliance with %s, current value is %d", getNameKey(), iSign * iBonus, GET_PLAYER(ePlayer).getNameKey(), GetBaseYieldRateFromCSAlliance(YIELD_FOOD));
				}
			}

			if (pMinor->IsFriends(getOwner()))
			{
				int iBonus = isCapital() ? pMinor->GetFriendsCapitalFoodBonus(getOwner()) : pMinor->GetFriendsOtherCityFoodBonus(getOwner());
				if (iBonus != 0)
				{
					ChangeBaseYieldRateFromCSFriendship(YIELD_FOOD, iSign * iBonus / 100);
					//CUSTOMLOG("adjusted food in %s by %d/100 for friendship with %s, current value is %d", getNameKey(), iSign * iBonus, GET_PLAYER(ePlayer).getNameKey(), GetBaseYieldRateFromCSAlliance(YIELD_FOOD));
				}
			}

			updateYield();
		}
	}
}

//	--------------------------------------------------------------------------------
/// Setting the danger value threat amount
void CvCity::setThreatValue(int iThreatValue)
{
	VALIDATE_OBJECT();
	m_iThreatValue = iThreatValue;
}

//	--------------------------------------------------------------------------------
/// Getting the danger value threat amount
int CvCity::getThreatValue() const
{
	VALIDATE_OBJECT();
	return m_iThreatValue;
}

//	--------------------------------------------------------------------------------
void CvCity::clearOrderQueue()
{
	VALIDATE_OBJECT();
	while (headOrderQueueNode() != NULL)
	{
		popOrder(0);
	}
}


//	--------------------------------------------------------------------------------
void CvCity::pushOrder(OrderTypes eOrder, int iData1, int iData2, bool bSave, bool bPop, bool bAppend, bool bRush)
{
	VALIDATE_OBJECT();
	OrderData order;
	bool bValid = false;

	if (bPop)
	{
		clearOrderQueue();
	}

	switch (eOrder)
	{
	case ORDER_TRAIN:
		if (canTrain((UnitTypes)iData1))
		{
			CvUnitEntry* pkUnitInfo = GC.getUnitInfo((UnitTypes)iData1);
			if (pkUnitInfo)
			{
				if (iData2 == -1)
				{
					iData2 = pkUnitInfo->GetDefaultUnitAIType();
				}

				GET_PLAYER(getOwner()).changeUnitClassMaking(((UnitClassTypes)(pkUnitInfo->GetUnitClassType())), 1);

				bValid = true;
			}
		}
		break;

	case ORDER_CONSTRUCT:
		// If city is a Venice puppet, it's a legal investment and don't move it off the queue
		if (canConstruct((BuildingTypes)iData1) || (IsPuppet() && GET_PLAYER(m_eOwner).GetPlayerTraits()->IsNoAnnexing()))
		{
			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo((BuildingTypes)iData1);
			if (pkBuildingInfo)
			{
				GET_PLAYER(getOwner()).changeBuildingClassMaking((pkBuildingInfo->GetBuildingClassType()), 1);
				bValid = true;
			}
		}
		break;

	case ORDER_CREATE:
		if (canCreate((ProjectTypes)iData1))
		{
			GET_TEAM(getTeam()).changeProjectMaking(((ProjectTypes)iData1), 1);
			GET_PLAYER(getOwner()).changeProjectMaking(((ProjectTypes)iData1), 1, this);

			bValid = true;
		}
		break;

	case ORDER_MAINTAIN:
		if (canMaintain((ProcessTypes)iData1))
		{
			bValid = true;
		}
		break;

	default:
		ASSERT_DEBUG(false, "iOrder did not match a valid option");
		break;
	}

	if (!bValid)
	{
		return;
	}

	order.eOrderType = eOrder;
	order.iData1 = iData1;
	order.iData2 = iData2;
	order.bSave = bSave;
	order.bRush = bRush;

	if (bAppend)
	{
		m_orderQueue.insertAtEnd(&order);

		if (order.eOrderType != ORDER_MAINTAIN || IsProcessInternationalProject((ProcessTypes)order.iData1))
		{
			// Bubble down non-process orders to in front of all processes at end of queue
			uint32 currOrderIdx = uint32(m_orderQueue.getLength()) - 1;
			while (currOrderIdx > 0
			  && m_orderQueue.getAt(currOrderIdx - 1)->eOrderType == ORDER_MAINTAIN
			  && !IsProcessInternationalProject((ProcessTypes)m_orderQueue.getAt(currOrderIdx - 1)->iData1))
			{
				swapOrder(currOrderIdx - 1);
				currOrderIdx--;
			}
		}
	}
	else
	{
		stopHeadOrder();
		m_orderQueue.insertAtBeginning(&order);
	}

	if (!bAppend || (getOrderQueueLength() == 1))
	{
		startHeadOrder();
	}

	if (eOrder == ORDER_MAINTAIN && (ProcessTypes)iData1 != NO_PROCESS)
	{
		CvProcessInfo* pkProcessInfo = GC.getProcessInfo((ProcessTypes)iData1);
		if (pkProcessInfo && pkProcessInfo->getDefenseValue() != 0)
		{
			updateStrengthValue();
		}
	}

	if ((getTeam() == GC.getGame().getActiveTeam()) || GC.getGame().isDebugMode())
	{
		if (isCitySelected())
		{
			DLLUI->setDirty(SelectionButtons_DIRTY_BIT, true);
			DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
			DLLUI->setDirty(PlotListButtons_DIRTY_BIT, true);
		}
	}

	DLLUI->setDirty(CityInfo_DIRTY_BIT, true);

	CvInterfacePtr<ICvCity1> pCity = GC.WrapCityPointer(this);
	DLLUI->SetSpecificCityInfoDirty(pCity.get(), CITY_UPDATE_TYPE_PRODUCTION);
}


//	--------------------------------------------------------------------------------
void CvCity::popOrder(int iNum, bool bFinish, bool bChoose)
{
	VALIDATE_OBJECT();

	CvPlayerAI& kOwner = GET_PLAYER(getOwner());	//Used often later on

	OrderData* pOrderNode = NULL;
	ProjectTypes eCreateProject;
	BuildingTypes eConstructBuilding;
	UnitTypes eTrainUnit;
	UnitAITypes eTrainAIUnit;
	bool bStart = false;
	bool bMessage = false;
	int iCount = 0;

	if (iNum == -1)
	{
		iNum = (getOrderQueueLength() - 1);
	}

	iCount = 0;

	pOrderNode = headOrderQueueNode();

	while (pOrderNode != NULL)
	{
		if (iCount == iNum)
		{
			break;
		}

		iCount++;

		pOrderNode = nextOrderQueueNode(pOrderNode);
	}

	if (pOrderNode == NULL)
	{
		return;
	}

	if (bFinish && pOrderNode->bSave)
	{
		pushOrder(pOrderNode->eOrderType, pOrderNode->iData1, pOrderNode->iData2, true, false, true);
	}
#if defined(MOD_BALANCE_CORE)
	bool bUpdateStrength = false;
#endif

	eTrainUnit = NO_UNIT;
	eConstructBuilding = NO_BUILDING;
	eCreateProject = NO_PROJECT;

	switch (pOrderNode->eOrderType)
	{
	case ORDER_TRAIN:
		eTrainUnit = ((UnitTypes)(pOrderNode->iData1));
		eTrainAIUnit = ((UnitAITypes)(pOrderNode->iData2));
		ASSERT_DEBUG(eTrainUnit != NO_UNIT, "eTrainUnit is expected to be assigned a valid unit type");
		ASSERT_DEBUG(eTrainAIUnit != NO_UNITAI, "eTrainAIUnit is expected to be assigned a valid unit AI type");

		kOwner.changeUnitClassMaking(((UnitClassTypes)(GC.getUnitInfo(eTrainUnit)->GetUnitClassType())), -1);

		if (bFinish)
		{
			produce(eTrainUnit);
		}
		break;

	case ORDER_CONSTRUCT:
	{
		eConstructBuilding = ((BuildingTypes)(pOrderNode->iData1));

		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eConstructBuilding);

		if (pkBuildingInfo)
		{
			kOwner.changeBuildingClassMaking((pkBuildingInfo->GetBuildingClassType()), -1);

			if (bFinish)
			{
				produce(eConstructBuilding);
			}
		}
		break;
	}

	case ORDER_CREATE:
		eCreateProject = ((ProjectTypes)(pOrderNode->iData1));

		GET_TEAM(getTeam()).changeProjectMaking(eCreateProject, -1);
		kOwner.changeProjectMaking(eCreateProject, -1);

		if (bFinish)
		{
			produce(eCreateProject);
		}
		break;

	case ORDER_MAINTAIN:
#if defined(MOD_BALANCE_CORE)
		if ((ProcessTypes)pOrderNode->iData1 != NO_PROCESS)
		{
			CvProcessInfo* pkProcessInfo = GC.getProcessInfo((ProcessTypes)pOrderNode->iData1);
			if (pkProcessInfo && pkProcessInfo->getDefenseValue() != 0)
			{
				bUpdateStrength = true;
			}
		}
#endif
		break;

	default:
		ASSERT_DEBUG(false, "pOrderNode->eOrderType is not a valid option");
		break;
	}

	if (m_unitBeingBuiltForOperation.IsValid())
	{
		kOwner.CityUncommitToBuildUnitForOperationSlot(m_unitBeingBuiltForOperation);
		m_unitBeingBuiltForOperation.Invalidate();
	}

	if (pOrderNode == headOrderQueueNode())
	{
		bStart = true;
		stopHeadOrder();
	}
	else
	{
		bStart = false;
	}

	m_orderQueue.deleteNode(pOrderNode);
	pOrderNode = NULL;
	if (bFinish)
	{
		CleanUpQueue(); // cleans out items from the queue that may be invalidated by the recent construction
	}

	if (bStart)
	{
		startHeadOrder();
	}

	if ((getTeam() == GC.getGame().getActiveTeam()) || GC.getGame().isDebugMode())
	{
		if (isCitySelected())
		{
			DLLUI->setDirty(SelectionButtons_DIRTY_BIT, true);
			DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
		}
	}

	bMessage = false;

	if (bChoose)
	{
		if (getOrderQueueLength() == 0)
		{
			if (!isHuman() || isProductionAutomated())
			{
				AI_chooseProduction(false /*bInterruptWonders*/, false);
			}
			else
			{
				chooseProduction(eTrainUnit, eConstructBuilding, eCreateProject, bFinish);

				bMessage = true;
			}
		}
	}

	if (bFinish && !bMessage)
	{
		if (getOwner() == GC.getGame().getActivePlayer())
		{
			Localization::String localizedText;
			if (eTrainUnit != NO_UNIT)
			{
				CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eTrainUnit);
				if (pkUnitInfo)
				{
					localizedText = Localization::Lookup(((isLimitedUnitClass((UnitClassTypes)(pkUnitInfo->GetUnitClassType()))) ? "TXT_KEY_MISC_TRAINED_UNIT_IN_LIMITED" : "TXT_KEY_MISC_TRAINED_UNIT_IN"));
					localizedText << pkUnitInfo->GetTextKey() << getNameKey();
				}
			}
			else if (eConstructBuilding != NO_BUILDING)
			{
				CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eConstructBuilding);
				if (pkBuildingInfo)
				{
					localizedText = Localization::Lookup(((isLimitedWonderClass(pkBuildingInfo->GetBuildingClassInfo())) ? "TXT_KEY_MISC_CONSTRUCTED_BUILD_IN_LIMITED" : "TXT_KEY_MISC_CONSTRUCTED_BUILD_IN"));
					localizedText << pkBuildingInfo->GetTextKey() << getNameKey();
				}
			}
			else if (eCreateProject != NO_PROJECT)
			{
				localizedText = Localization::Lookup(((isLimitedProject(eCreateProject)) ? "TXT_KEY_MISC_CREATED_PROJECT_IN_LIMITED" : "TXT_KEY_MISC_CREATED_PROJECT_IN"));
				localizedText << GC.getProjectInfo(eCreateProject)->GetTextKey() << getNameKey();
			}
			if (isProduction())
			{
				localizedText = Localization::Lookup(((isProductionLimited()) ? "TXT_KEY_MISC_WORK_HAS_BEGUN_IN_CITY_LIMITED" : "TXT_KEY_MISC_WORK_HAS_BEGUN_IN_CITY"));
				localizedText << getProductionNameKey() << getNameKey();
			}
			DLLUI->AddCityMessage(0, GetIDInfo(), getOwner(), false, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), localizedText.toUTF8()/*, szSound, MESSAGE_TYPE_MINOR_EVENT, szIcon, (ColorTypes)GC.getInfoTypeForString("COLOR_WHITE"), getX(), getY(), true, true*/);
		}
	}
#if defined(MOD_BALANCE_CORE)
	if (bUpdateStrength)
	{
		updateStrengthValue();
	}
#endif

	if ((getTeam() == GC.getGame().getActiveTeam()) || GC.getGame().isDebugMode())
	{
		if (isCitySelected())
		{
			DLLUI->setDirty(SelectionButtons_DIRTY_BIT, true);
			DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
			DLLUI->setDirty(PlotListButtons_DIRTY_BIT, true);
		}
		DLLUI->setDirty(CityInfo_DIRTY_BIT, true);
	}
}

//	--------------------------------------------------------------------------------
void CvCity::swapOrder(int iNum)
{
	// okay, this only swaps the order with the next one up in the queue
	VALIDATE_OBJECT();

	if (iNum == 0)
	{
		stopHeadOrder();
	}

	m_orderQueue.swapUp(iNum);

	if (iNum == 0)
	{
		startHeadOrder();
	}

	if ((getTeam() == GC.getGame().getActiveTeam()) || GC.getGame().isDebugMode())
	{
		if (isCitySelected())
		{
			//DLLUI->setDirty(InfoPane_DIRTY_BIT, true );
			DLLUI->setDirty(SelectionButtons_DIRTY_BIT, true);
			DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
			DLLUI->setDirty(PlotListButtons_DIRTY_BIT, true);
		}
		DLLUI->setDirty(CityInfo_DIRTY_BIT, true);
	}
}

bool CvCity::hasOrder(OrderTypes eOrder, int iData1, int iData2) const
{
	for (int iI = 0; iI < getOrderQueueLength(); iI++)
	{
		const OrderData* pOrder = getOrderFromQueue(iI);
		if (pOrder != NULL)
		{
			if (pOrder->eOrderType == eOrder && pOrder->iData1 == iData1 && pOrder->iData2 == iData2)
			{
				return true;
			}
		}
	}

	return false;
}

bool CvCity::hasOrder(OrderTypes eOrder, int iData1) const
{
	for (int iI = 0; iI < getOrderQueueLength(); iI++)
	{
		const OrderData* pOrder = getOrderFromQueue(iI);
		if (pOrder != NULL)
		{
			if (pOrder->eOrderType == eOrder && pOrder->iData1 == iData1)
			{
				return true;
			}
		}
	}

	return false;
}


//	--------------------------------------------------------------------------------
void CvCity::startHeadOrder()
{
	VALIDATE_OBJECT();
	OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		GetCityCitizens()->OptimizeWorkedPlots(false);

		if (pOrderNode->eOrderType == ORDER_MAINTAIN)
		{
			processProcess(((ProcessTypes)(pOrderNode->iData1)), 1);
		}
	}
}


//	--------------------------------------------------------------------------------
void CvCity::stopHeadOrder()
{
	VALIDATE_OBJECT();
	OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		if (pOrderNode->eOrderType == ORDER_MAINTAIN)
		{
			processProcess(((ProcessTypes)(pOrderNode->iData1)), -1);
		}
	}
}


//	--------------------------------------------------------------------------------
int CvCity::getOrderQueueLength() const
{
	VALIDATE_OBJECT();
	return m_orderQueue.getLength();
}


const OrderData* CvCity::getOrderFromQueue(int iIndex) const
{
	return m_orderQueue.getAt(iIndex);
}

//	--------------------------------------------------------------------------------
OrderData* CvCity::getOrderFromQueue(int iIndex)
{
	VALIDATE_OBJECT();
	return m_orderQueue.getAt(iIndex);
}


//	--------------------------------------------------------------------------------
OrderData* CvCity::nextOrderQueueNode(OrderData* pNode)
{
	VALIDATE_OBJECT();
	return m_orderQueue.next(pNode);
}

//	--------------------------------------------------------------------------------
const OrderData* CvCity::nextOrderQueueNode(const OrderData* pNode) const
{
	VALIDATE_OBJECT();
	return m_orderQueue.next(pNode);
}


//	--------------------------------------------------------------------------------
const OrderData* CvCity::headOrderQueueNode() const
{
	VALIDATE_OBJECT();
	return m_orderQueue.head();
}

//	--------------------------------------------------------------------------------
OrderData* CvCity::headOrderQueueNode()
{
	VALIDATE_OBJECT();
	return m_orderQueue.head();
}


//	--------------------------------------------------------------------------------
const OrderData* CvCity::tailOrderQueueNode() const
{
	VALIDATE_OBJECT();
	return m_orderQueue.tail();
}

//	--------------------------------------------------------------------------------
/// remove items in the queue that are no longer valid
bool CvCity::CleanUpQueue(void)
{
	VALIDATE_OBJECT();
	bool bOK = true;

	for (int iI = (getOrderQueueLength() - 1); iI >= 0; iI--)
	{
		OrderData* pOrder = getOrderFromQueue(iI);

		if (pOrder != NULL)
		{
			if (!canContinueProduction(*pOrder))
			{
				popOrder(iI, false, true);
				bOK = false;
			}
		}
	}

	return bOK;
}

//	--------------------------------------------------------------------------------
/// Create unit by completing production in city, separated out from popOrder() so other functions can call this
void CvCity::produce(UnitTypes eTrainUnit, UnitAITypes eTrainAIUnit, bool bCanOverflow)
{
	m_iThingsProduced++;

	CvPlayerAI& kOwner = GET_PLAYER(getOwner());

	CvUnit* pUnit = CreateUnit(eTrainUnit, eTrainAIUnit, REASON_TRAIN);
	if (pUnit)
	{
		if (pUnit->isFreeUpgrade() || kOwner.GetPlayerTraits()->IsFreeUpgrade())
		{
			UnitTypes eUpgradeUnit = pUnit->GetUpgradeUnitType();
			if (eUpgradeUnit != NO_UNIT && canTrain(eUpgradeUnit, false, false, true))
			{
				pUnit = pUnit->DoUpgrade(true);
			}
		}
		SetUnitInvestment(pUnit->getUnitClassType(), false);

		if (kOwner.GetPlayerTraits()->IsConquestOfTheWorld())
		{
			if (pUnit->isFound() || pUnit->IsFoundMid())
			{
				UnitTypes eFreeUnit = kOwner.GetCompetitiveSpawnUnitType(false, false, false, true, this);
				if (eFreeUnit != NO_UNIT)
				{
					CvUnitEntry* pUnitInfo = GC.getUnitInfo(eFreeUnit);
					if (pUnitInfo)
					{
						CvUnit* pFreeUnit = CreateUnit(eFreeUnit, NO_UNITAI, REASON_TRAIN);
						if (!pFreeUnit->jumpToNearestValidPlot())
							pFreeUnit->kill(false); // Could not find a valid spot!

						CvNotifications* pNotifications = kOwner.GetNotifications();
						if (pNotifications)
						{
							Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CONQUEST_OF_WORLD_UNIT");
							strText << pFreeUnit->getNameKey() << getNameKey();
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CONQUEST_OF_WORLD_UNIT");
							strSummary << getNameKey();
							pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pFreeUnit->getX(), pFreeUnit->getY(), -1);
						}
					}
				}
			}
		}

		//whoever invented this should be crucified
		if (kOwner.GetPlayerTraits()->IsFreeZuluPikemanToImpi())
		{
			UnitClassTypes ePikemanClass = (UnitClassTypes)GC.getInfoTypeForString("UNITCLASS_PIKEMAN");
			UnitTypes eZuluImpi = (UnitTypes)GC.getInfoTypeForString("UNIT_ZULU_IMPI");
			if (pUnit != NULL && pUnit->getUnitClassType() == ePikemanClass && canTrain(eZuluImpi, false, false, true))
			{
				CvUnitEntry* pkcUnitEntry = GC.getUnitInfo(eZuluImpi);
				if (pkcUnitEntry)
				{
					UnitAITypes eZuluImpiAI = pkcUnitEntry->GetDefaultUnitAIType();
					CvUnit* pZuluImpi = kOwner.initUnit(eZuluImpi, pUnit->getX(), pUnit->getY(), eZuluImpiAI);
					pZuluImpi->convert(pUnit, true);
					pUnit = pZuluImpi;
				}
			}
		}

		if (MOD_EVENTS_CITY)
		{
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityTrained, getOwner(), GetID(), pUnit->GetID(), false, false);
		}
		else
		{
			ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
			if (pkScriptSystem)
			{
				CvLuaArgsHandle args;
				args->Push(getOwner());
				args->Push(GetID());
				args->Push(pUnit->GetID());
				args->Push(false); // bGold
				args->Push(false); // bFaith/bCulture

				bool bResult = false;
				LuaSupport::CallHook(pkScriptSystem, "CityTrained", args.get(), bResult);
			}
		}

		int iProductionNeeded = getProductionNeeded(eTrainUnit) * 100;
		if (!pUnit->IsCivilianUnit())
		{
			GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_U_PROD, true, NO_GREATPERSON, NO_BUILDING, (iProductionNeeded / 100), false, NO_PLAYER, NULL, false, this);
		}

		if (bCanOverflow)
		{
			// max overflow is the value of the item produced (to eliminate prebuild exploits)
			int iOverflow = getUnitProductionTimes100(eTrainUnit) - iProductionNeeded;
			int iMaxOverflow = std::max(iProductionNeeded, getCurrentProductionDifferenceTimes100(false, false));
			int iLostProduction = std::max(0, iOverflow - iMaxOverflow);
			iOverflow = std::min(iMaxOverflow, iOverflow);

			if (iOverflow > 0)
			{
				changeOverflowProductionTimes100(iOverflow);
			}
			setUnitProduction(eTrainUnit, 0);

			int iProductionGold = ((iLostProduction * /*100*/ GD_INT_GET(MAXED_UNIT_GOLD_PERCENT)) / 100);
			if (iProductionGold > 0)
			{
				kOwner.GetTreasury()->ChangeGoldTimes100(iProductionGold);
			}
		}
		else
		{
			changeUnitProductionTimes100(eTrainUnit, -iProductionNeeded);
		}
	}
	else
	{
		// create notification
		setUnitProduction(eTrainUnit, getProductionNeeded(eTrainUnit) - 1);

		CvNotifications* pNotifications = kOwner.GetNotifications();
		if (pNotifications)
		{
			Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_REMOVED_UNIT");
			strText << getNameKey();
			strText << GC.getUnitInfo(eTrainUnit)->GetDescription();
			Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_REMOVED_UNIT");
			pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), -1);
		}
	}

	//immediately check if the AI should start a found city operation so we can queue up the escort for production
	if (!GET_PLAYER(m_eOwner).isHuman() && pUnit->isFound())
		EconomicAIHelpers::IsTestStrategy_FoundCity(NO_ECONOMICAISTRATEGY,&GET_PLAYER(m_eOwner));
}

//	--------------------------------------------------------------------------------
/// Create building by completing production in city, separated out from popOrder() so other functions can call this
void CvCity::produce(BuildingTypes eConstructBuilding, bool bCanOverflow)
{
	m_iThingsProduced++;

	CvPlayerAI& kOwner = GET_PLAYER(getOwner());

	int iProductionNeeded = getProductionNeeded(eConstructBuilding) * 100;
	bool bResult = CreateBuilding(eConstructBuilding);
	DEBUG_VARIABLE(bResult);
	ASSERT_DEBUG(bResult, "CreateBuilding failed");

#if defined(MOD_EVENTS_CITY)
	if (MOD_EVENTS_CITY) {
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityConstructed, getOwner(), GetID(), eConstructBuilding, false, false);
	}
	else {
#endif
		ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
		if (pkScriptSystem)
		{
			CvLuaArgsHandle args;
			args->Push(getOwner());
			args->Push(GetID());
			args->Push(eConstructBuilding);
			args->Push(false); // bGold
			args->Push(false); // bFaith/bCulture

			bool bScriptResult = false;
			LuaSupport::CallHook(pkScriptSystem, "CityConstructed", args.get(), bScriptResult);
		}
#if defined(MOD_EVENTS_CITY)
	}
#endif		
	if (bCanOverflow)
	{
		// max overflow is the value of the item produced (to eliminate prebuild exploits)
		int iOverflow = m_pCityBuildings->GetBuildingProductionTimes100(eConstructBuilding) - iProductionNeeded;
		int iMaxOverflow = std::max(iProductionNeeded, getCurrentProductionDifferenceTimes100(false, false));
		int iLostProduction = std::max(0, iOverflow - iMaxOverflow);
		iOverflow = std::min(iMaxOverflow, iOverflow);
		if (iOverflow > 0)
		{
			changeOverflowProductionTimes100(iOverflow);
		}
		m_pCityBuildings->SetBuildingProduction(eConstructBuilding, 0);

		int iProductionGold = ((iLostProduction * /*100*/ GD_INT_GET(MAXED_BUILDING_GOLD_PERCENT)) / 100);
		if (iProductionGold > 0)
		{
			kOwner.GetTreasury()->ChangeGoldTimes100(iProductionGold);
		}
	}
	else
	{
		m_pCityBuildings->ChangeBuildingProduction(eConstructBuilding, -iProductionNeeded);
	}

	if (GC.getLogging() && GC.getAILogging())
	{
		CvBuildingEntry* pkConstructBuildingInfo = GC.getBuildingInfo(eConstructBuilding);
		if (pkConstructBuildingInfo)
		{
			if (kOwner.GetWonderProductionAI()->IsWonder(*pkConstructBuildingInfo))
			{
				CvString strBaseString;
				CvString strOutBuf;
				CvString playerName = kOwner.getCivilizationShortDescription();
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				strBaseString += playerName + ", ";
				strOutBuf.Format("%s, WONDER - Finished %s", getName().GetCString(), pkConstructBuildingInfo->GetDescription());
				strBaseString += strOutBuf;
				kOwner.GetCitySpecializationAI()->LogMsg(strBaseString);
			}
		}

	}
}

//	--------------------------------------------------------------------------------
/// Create project by completing production in city, separated out from popOrder() so other functions can call this
void CvCity::produce(ProjectTypes eCreateProject, bool bCanOverflow)
{
	m_iThingsProduced++;

	CvPlayerAI& kOwner = GET_PLAYER(getOwner());

	bool bResult = CreateProject(eCreateProject);
	DEBUG_VARIABLE(bResult);
	ASSERT_DEBUG(bResult, "Failed to create project");

#if defined(MOD_EVENTS_CITY)
	if (MOD_EVENTS_CITY) {
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityCreated, getOwner(), GetID(), eCreateProject, false, false);
	}
	else {
#endif
		ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
		if (pkScriptSystem)
		{
			CvLuaArgsHandle args;
			args->Push(getOwner());
			args->Push(GetID());
			args->Push(eCreateProject);
			args->Push(false); // bGold
			args->Push(false); // bFaith/bCulture

			bool bScriptResult = false;
			LuaSupport::CallHook(pkScriptSystem, "CityCreated", args.get(), bScriptResult);
		}
#if defined(MOD_EVENTS_CITY)
	}
#endif

	int iProductionNeeded = getProductionNeeded(eCreateProject) * 100;
	if (bCanOverflow)
	{
		// max overflow is the value of the item produced (to eliminate prebuild exploits)
		int iOverflow = getProjectProductionTimes100(eCreateProject) - iProductionNeeded;
		int iMaxOverflow = std::max(iProductionNeeded, getCurrentProductionDifferenceTimes100(false, false));
		int iLostProduction = std::max(0, iOverflow - iMaxOverflow);
		iOverflow = std::min(iMaxOverflow, iOverflow);

		if (iOverflow > 0)
		{
			changeOverflowProductionTimes100(iOverflow);
		}
		setProjectProduction(eCreateProject, 0);

		int iProductionGold = ((iLostProduction * /*300*/ GD_INT_GET(MAXED_PROJECT_GOLD_PERCENT)) / 100);
		if (iProductionGold > 0)
		{
			kOwner.GetTreasury()->ChangeGoldTimes100(iProductionGold);
		}
	}
	else
	{
		changeProjectProductionTimes100(eCreateProject, -iProductionNeeded);
	}
}

//	--------------------------------------------------------------------------------
CvUnit* CvCity::CreateUnit(UnitTypes eUnitType, UnitAITypes eAIType, UnitCreationReason eReason)
{
	VALIDATE_OBJECT();
	CvPlot* pUnitPlot = GetPlotForNewUnit(eUnitType);

	// If there's no free plot around, then stack it in the city
	if (!pUnitPlot)
		pUnitPlot = plot();

	CvPlayer& kOwner = GET_PLAYER(getOwner());
	CvUnit* pUnit = kOwner.initUnit(eUnitType, pUnitPlot->getX(), pUnitPlot->getY(), eAIType, eReason);

	if (MOD_BALANCE_CORE_UNIT_CREATION_DAMAGED && !pUnit->IsCivilianUnit())
	{
		int iCityDamagePercent = min(80, (100 * getDamage()) / max(1, GetMaxHitPoints()));
		int iUnitDamage = (pUnit->GetCurrHitPoints() * iCityDamagePercent) / 100;
		pUnit->changeDamage(min(iUnitDamage, pUnit->GetMaxHitPoints() - 1));
	}

	bool bIsPurchased = (eReason == REASON_BUY || eReason == REASON_FAITH_BUY);

	addProductionExperience(pUnit, false, (eReason == REASON_BUY));

	if (!bIsPurchased || pUnit->getUnitInfo().CanMoveAfterPurchase())
		pUnit->restoreFullMoves();
	else
		pUnit->finishMoves();

	if (pUnit->isTrade())
	{
		if (GC.getLogging() && GC.getAILogging())
		{
			CvString strCiv = kOwner.getCivilizationAdjective();
			CvString strLogString;
			strLogString.Format("TRADE UNIT MADE: %s %s at %d,d", strCiv.c_str(), pUnit->getName().c_str(), pUnit->getX(), pUnit->getY());
			kOwner.GetHomelandAI()->LogHomelandMessage(strLogString);
		}
	}

	if (MOD_BALANCE_CORE_SETTLERS_CONSUME_POP)
	{
		if (pUnit->getUnitInfo().IsFoodProduction() && getPopulation() > 1)
			changePopulation(-1);
	}

	CvPlot* pRallyPlot = getRallyPlot();
	if (pRallyPlot)
	{
		pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pRallyPlot->getX(), pRallyPlot->getY());
	}
	// Any AI unit with explore AI as a secondary unit AI (e.g. warriors) are assigned that unit AI if this AI player needs to explore more
	else if (!pUnit->isHuman() && EconomicAIHelpers::CannotMinorCiv(&kOwner, (EconomicAIStrategyTypes)GC.getInfoTypeForString("ECONOMICAISTRATEGY_NEED_RECON")))
	{
		EconomicAIStrategyTypes eStrategy = (EconomicAIStrategyTypes)GC.getInfoTypeForString("ECONOMICAISTRATEGY_NEED_RECON");
		if (kOwner.GetEconomicAI()->IsUsingStrategy(eStrategy))
		{
			if (pUnit->getUnitInfo().GetUnitAIType(UNITAI_EXPLORE) && pUnit->AI_getUnitAIType() != UNITAI_EXPLORE)
			{
				// Now make sure there isn't a critical military threat
				if (kOwner.GetMilitaryAI()->ShouldFightBarbarians())
				{
					if (GC.getLogging() && GC.getAILogging())
					{
						CvString strLogString;
						strLogString.Format("Not assigning explore AI to %s due to threats, X: %d, Y: %d", pUnit->getName().GetCString(), pUnit->getX(), pUnit->getY());
						kOwner.GetHomelandAI()->LogHomelandMessage(strLogString);
					}
				}
				else
				{
					pUnit->AI_setUnitAIType(UNITAI_EXPLORE);
					if (GC.getLogging() && GC.getAILogging())
					{
						CvString strLogString;
						strLogString.Format("Assigning explore unit AI to %s, X: %d, Y: %d", pUnit->getName().GetCString(), pUnit->getX(), pUnit->getY());
						kOwner.GetHomelandAI()->LogHomelandMessage(strLogString);
					}
				}
			}
		}
		eStrategy = (EconomicAIStrategyTypes)GC.getInfoTypeForString("ECONOMICAISTRATEGY_NEED_RECON_SEA");
		EconomicAIStrategyTypes eOtherStrategy = (EconomicAIStrategyTypes)GC.getInfoTypeForString("ECONOMICAISTRATEGY_REALLY_NEED_RECON_SEA");
		if (kOwner.GetEconomicAI()->IsUsingStrategy(eStrategy) || kOwner.GetEconomicAI()->IsUsingStrategy(eOtherStrategy))
		{
			if (pUnit->getUnitInfo().GetUnitAIType(UNITAI_EXPLORE_SEA))
			{
				pUnit->AI_setUnitAIType(UNITAI_EXPLORE_SEA);
				if (GC.getLogging() && GC.getAILogging())
				{
					CvString strLogString;
					strLogString.Format("Assigning explore sea unit AI to %s, X: %d, Y: %d", pUnit->getName().GetCString(), pUnit->getX(), pUnit->getY());
					kOwner.GetHomelandAI()->LogHomelandMessage(strLogString);
				}
			}
		}
	}
	//Increment for stat tracking and achievements
	if (pUnit->isHuman())
	{
		IncrementUnitStatCount(pUnit);
	}

	if (eReason == REASON_TRAIN || eReason == REASON_BUY || eReason == REASON_FAITH_BUY)
		kOwner.changeUnitsBuiltCount(eUnitType, 1);

	doUnitCompletionYields(pUnit, eReason);

	return pUnit;
}

//	--------------------------------------------------------------------------------
bool CvCity::CreateBuilding(BuildingTypes eBuildingType)
{
	VALIDATE_OBJECT();

	if (eBuildingType == NO_BUILDING)
		return false;

	const CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuildingType);
	const BuildingClassTypes eBuildingClass = pkBuildingInfo->GetBuildingClassType();

	CvPlayerAI& kPlayer = GET_PLAYER(getOwner());

	if (kPlayer.isBuildingClassMaxedOut(eBuildingClass, 0))
	{
		kPlayer.removeBuildingClass(eBuildingClass);
	}

	m_pCityBuildings->SetNumRealBuilding(eBuildingType, m_pCityBuildings->GetNumRealBuilding(eBuildingType) + 1);

	//Achievements
	if (MOD_API_ACHIEVEMENTS && kPlayer.isHuman() && !GC.getGame().isGameMultiPlayer())
	{
		CvBuildingClassInfo* pBuildingClass = GC.getBuildingClassInfo(eBuildingClass);
		if (pBuildingClass && ::isWorldWonderClass(*pBuildingClass))
		{
			int iCount = 0;
			CvGameTrade* pGameTrade = GC.getGame().GetGameTrade();
			for (uint ui = 0; ui < pGameTrade->GetNumTradeConnections(); ui++)
			{
				if (pGameTrade->IsTradeRouteIndexEmpty(ui))
				{
					continue;
				}

				if (pGameTrade->GetTradeConnection(ui).m_eConnectionType == TRADE_CONNECTION_PRODUCTION)
				{
					CvCity* pDestCity = CvGameTrade::GetDestCity(pGameTrade->GetTradeConnection(ui));
					if (pDestCity->getX() == getX() && pDestCity->getY() == getY())
					{
						iCount++;
					}
				}
			}

			if (iCount >= 3)
			{
				gDLL->UnlockAchievement(ACHIEVEMENT_XP2_31);
			}
		}

		CheckForAchievementBuilding(eBuildingType);
	}

	return true;
}


//	--------------------------------------------------------------------------------
bool CvCity::CreateProject(ProjectTypes eProjectType)
{
	VALIDATE_OBJECT();

	CvPlayer& thisPlayer = GET_PLAYER(getOwner());
	CvTeam& thisTeam = GET_TEAM(getTeam());
	thisTeam.changeProjectCount(eProjectType, 1);

	changeProjectCount(eProjectType, 1);

	ProjectTypes ApolloProgram = (ProjectTypes)GD_INT_GET(SPACE_RACE_TRIGGER_PROJECT);
	ProjectTypes capsuleID = (ProjectTypes)GD_INT_GET(SPACESHIP_CAPSULE);
	ProjectTypes boosterID = (ProjectTypes)GD_INT_GET(SPACESHIP_BOOSTER);
	ProjectTypes stasisID = (ProjectTypes)GD_INT_GET(SPACESHIP_STASIS);
	ProjectTypes engineID = (ProjectTypes)GD_INT_GET(SPACESHIP_ENGINE);

	enum eSpaceshipState
	{
		eUnderConstruction = 0x0000,
		eFrame = 0x0001,
		eCapsule = 0x0002,
		eStasis_Chamber = 0x0004,
		eEngine = 0x0008,
		eBooster1 = 0x0010,
		eBooster2 = 0x0020,
		eBooster3 = 0x0040,
		eConstructed = 0x0080,
	};

	if (eProjectType == ApolloProgram)
	{
		CvCity* theCapital = thisPlayer.getCapitalCity();
		if (theCapital)
		{
			CvInterfacePtr<ICvPlot1> pDllPlot(new CvDllPlot(theCapital->plot()));
			gDLL->GameplaySpaceshipRemoved(pDllPlot.get());
			gDLL->GameplaySpaceshipCreated(pDllPlot.get(), eUnderConstruction + eFrame);
		}
	}
	else if (GC.getProjectInfo(eProjectType)->IsSpaceship())
	{
		VictoryTypes eVictory = (VictoryTypes)GC.getProjectInfo(eProjectType)->GetVictoryPrereq();

		if (NO_VICTORY != eVictory && GET_TEAM(getTeam()).canLaunch(eVictory))
		{
			CvInterfacePtr<ICvPlot1> pDllPlot(new CvDllPlot(plot()));
			gDLL->GameplaySpaceshipEdited(pDllPlot.get(), eConstructed);
			gDLL->sendLaunch(getOwner(), eVictory);
		}
		else
		{
			//show the spaceship progress

			// this section is kind of hard-coded but it is completely hard-coded on the engine-side so I have to give it the numbers it expects
			int spaceshipState = eFrame;

			if ((thisTeam.getProjectCount(capsuleID)) == 1)
			{
				spaceshipState += eCapsule;
			}

			if ((thisTeam.getProjectCount(stasisID)) == 1)
			{
				spaceshipState += eStasis_Chamber;
			}

			if ((thisTeam.getProjectCount(engineID)) == 1)
			{
				spaceshipState += eEngine;
			}

			if ((thisTeam.getProjectCount(boosterID)) >= 1)
			{
				spaceshipState += eBooster1;
			}

			if ((thisTeam.getProjectCount(boosterID)) >= 2)
			{
				spaceshipState += eBooster2;
			}

			if ((thisTeam.getProjectCount(boosterID)) == 3)
			{
				spaceshipState += eBooster3;
			}

			CvInterfacePtr<ICvPlot1> pDllPlot(new CvDllPlot(plot()));
			gDLL->GameplaySpaceshipEdited(pDllPlot.get(), spaceshipState);
		}
	}

	CvProjectEntry* pProject = GC.getProjectInfo(eProjectType);
	if (pProject)
	{
		GET_PLAYER(getOwner()).GetTreasury()->ChangeBaseBuildingGoldMaintenance(pProject->GetGoldMaintenance()); // Maintenance cost
		ChangeUnmoddedHappinessFromBuildings(pProject->GetHappiness());
		ChangeEmpireSizeModifierReduction(pProject->GetEmpireSizeModifierReduction());
		ChangeDistressFlatReduction(pProject->GetDistressFlatReduction());
		ChangePovertyFlatReduction(pProject->GetPovertyFlatReduction());
		ChangeIlliteracyFlatReduction(pProject->GetIlliteracyFlatReduction());
		ChangeBoredomFlatReduction(pProject->GetBoredomFlatReduction());
		ChangeReligiousUnrestFlatReduction(pProject->GetReligiousUnrestFlatReduction());
		ChangeBasicNeedsMedianModifier(pProject->GetBasicNeedsMedianModifier());
		ChangeGoldMedianModifier(pProject->GetGoldMedianModifier());
		ChangeScienceMedianModifier(pProject->GetScienceMedianModifier());
		ChangeCultureMedianModifier(pProject->GetCultureMedianModifier());
		ChangeReligiousUnrestModifier(pProject->GetReligiousUnrestModifier());
		ChangeSpySecurityModifier(pProject->GetSpySecurityModifier());
	}

	GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityProjectComplete, getOwner(), GetID(), eProjectType);

	return true;
}

void CvCity::changeProjectCount(ProjectTypes eProject, int iValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eProject >= 0, "ePlayer expected to be >= 0");
	ASSERT_DEBUG(eProject < GC.getNumProjectInfos(), "ePlayer expected to be < NUM_DOMAIN_TYPES");
	m_aiNumProjects[eProject] = m_aiNumProjects[eProject] + iValue;
}

int CvCity::getProjectCount(ProjectTypes eProject) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eProject >= 0, "ePlayer expected to be >= 0");
	ASSERT_DEBUG(eProject < GC.getNumProjectInfos(), "ePlayer expected to be < NUM_DOMAIN_TYPES");
	return m_aiNumProjects[eProject];
}

bool IsValidPlotForUnitType(CvPlot* pPlot, PlayerTypes ePlayer, CvUnitEntry* pkUnitInfo)
{
	if (!pPlot->isValidMovePlot(ePlayer))
		return false;

	bool bAccept = false;
	switch (pkUnitInfo->GetDomainType())
	{
	case NO_DOMAIN:
	case DOMAIN_IMMOBILE:
		break;
	case DOMAIN_AIR:
		bAccept = pPlot->isCity();
		break;
	case DOMAIN_LAND:
		bAccept = !pPlot->isWater();
		break;
	case DOMAIN_SEA:
		bAccept = pPlot->isWater() || pPlot->isCoastalCityOrPassableImprovement(ePlayer, true, true);
		break;
	case DOMAIN_HOVER:
		bAccept = true;
		break;
	}

	if (!bAccept)
		return false;

	//civilians can always stack
	//note that this also allows airplanes! (they may need to rebase later)
	if (pkUnitInfo->GetCombat() == 0)
		return true;

	const IDInfo* pUnitNode = pPlot->headUnitNode();
	while (pUnitNode != NULL)
	{
		const CvUnit* pLoopUnit = ::GetPlayerUnit(*pUnitNode);
		if (pLoopUnit != NULL)
		{
			// check stacking (see also CountStackingUnitsAtPlot)
			if (pLoopUnit->IsCombatUnit() && pLoopUnit->getDomainType() == pkUnitInfo->GetDomainType())
				return false;
		}

		pUnitNode = pPlot->nextUnitNode(pUnitNode);
	}

	return true;
}

CvPlot* CvCity::GetPlotForNewUnit(UnitTypes eUnitType, bool bAllowCenterPlot) const
{
	VALIDATE_OBJECT();
	CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnitType);
	if (pkUnitInfo == NULL)
		return NULL;

	//use city plot if free
	CvPlot* pCityPlot = plot();
	if (bAllowCenterPlot && IsValidPlotForUnitType(pCityPlot, getOwner(), pkUnitInfo))
		return pCityPlot;

	//don't be too predictable with the chosen plot - but zero always maps to zero
	int aiShuffle[3][7] = {
		{ 0, 5, 4, 2, 1, 3, 6 },
		{ 0, 3, 6, 4, 1, 2, 5 },
		{ 0, 1, 2, 4, 5, 6, 3 } };
	uint uShuffleType = GC.getGame().urandLimitExclusive(3, plot()->GetPseudoRandomSeed().mix(GET_PLAYER(m_eOwner).getNumUnits()));

	//check city plot and adjacent plots
	vector<CvPlot*> validChoices;
	for (int i = 0; i < RING1_PLOTS; i++)
	{
		CvPlot* pPlot = iterateRingPlots(plot(), aiShuffle[uShuffleType][i]);
		if (pPlot == NULL)
			continue;

		if (IsValidPlotForUnitType(pPlot, getOwner(), pkUnitInfo))
			validChoices.push_back(pPlot);
	}

	//first choice is route and no enemy
	for (size_t i = 0; i < validChoices.size(); i++)
		if (validChoices[i]->isValidRoute(NULL) && validChoices[i]->GetNumEnemyUnitsAdjacent(getTeam(), pkUnitInfo->GetDomainType()) == 0)
			return validChoices[i];

	//now check for plots with route
	for (size_t i = 0; i < validChoices.size(); i++)
		if (validChoices[i]->isValidRoute(NULL))
			return validChoices[i];

	//now try to find one without enemies around
	for (size_t i = 0; i < validChoices.size(); i++)
		if (validChoices[i]->GetNumEnemyUnitsAdjacent(getTeam(), pkUnitInfo->GetDomainType()) == 0)
			return validChoices[i];

	//ok, let's just take the first one
	if (!validChoices.empty())
		return validChoices.front();

	return NULL;
}

//	--------------------------------------------------------------------------------
bool CvCity::CanPlaceUnitHere(UnitTypes eUnitType) const
{
	CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnitType);

	//similar to GetPlotForNewUnit but without the RNG calls
	for (int i = 0; i < RING1_PLOTS; i++)
	{
		CvPlot* pPlot = iterateRingPlots(plot(), i);
		if (!pPlot)
			continue;

		if (IsValidPlotForUnitType(pPlot, getOwner(), pkUnitInfo))
			return true;
	}

	return false;
}

//	--------------------------------------------------------------------------------
// Is this city allowed to purchase something right now?
bool CvCity::IsCanPurchase(bool bTestPurchaseCost, bool bTestTrainable, UnitTypes eUnitType, BuildingTypes eBuildingType, ProjectTypes eProjectType, YieldTypes ePurchaseYield)
{
	std::vector<int> vTotalBuildingCount(GC.getNumBuildingInfos(), 0);
	int iLoop = 0;
	for (const CvCity* pLoopCity = GET_PLAYER(m_eOwner).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(m_eOwner).nextCity(&iLoop))
	{
		const std::vector<BuildingTypes>& vBuildings = pLoopCity->GetCityBuildings()->GetAllBuildingsHere();
		for (size_t i = 0; i < vBuildings.size(); i++)
			vTotalBuildingCount[vBuildings[i]]++;
	}

	return IsCanPurchase(vTotalBuildingCount, bTestPurchaseCost, bTestTrainable, eUnitType, eBuildingType, eProjectType, ePurchaseYield);
}

bool CvCity::IsCanPurchase(const std::vector<int>& vPreExistingBuildings, bool bTestPurchaseCost, bool bTestTrainable, UnitTypes eUnitType, BuildingTypes eBuildingType, ProjectTypes eProjectType, YieldTypes ePurchaseYield)
{
	ASSERT_DEBUG(eUnitType >= 0 || eBuildingType >= 0 || eProjectType >= 0, "No valid passed in");
	ASSERT_DEBUG(!(eUnitType >= 0 && eBuildingType >= 0) && !(eUnitType >= 0 && eProjectType >= 0) && !(eBuildingType >= 0 && eProjectType >= 0), "Only one being passed");

	// Can't purchase anything in a puppeted city
	// slewis - The Venetian Exception
	bool bIsPuppet = IsPuppet();
	bool bVenetianException = false;
	bool bPuppetExceptionUnit = false;
	bool bPuppetExceptionBuilding = false;
	bool bAllowsPuppetPurchase = IsAllowPuppetPurchase();
	if (MOD_BALANCE_CORE_PUPPET_PURCHASE && bIsPuppet && !bAllowsPuppetPurchase)
	{
		if (eUnitType >= 0)
		{
			CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnitType);
			if (pkUnitInfo)
			{
				if (pkUnitInfo->IsPuppetPurchaseOverride())
				{
					bPuppetExceptionUnit = true;
				}
			}
		}
		else if (eBuildingType >= 0)
		{
			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuildingType);
			if (pkBuildingInfo)
			{
				if (pkBuildingInfo->IsPuppetPurchaseOverride())
				{
					bPuppetExceptionBuilding = true;
				}
			}
		}
	}

	bool bPuppetExceptionFaithBuilding = false;
	if (MOD_GLOBAL_PURCHASE_FAITH_BUILDINGS_IN_PUPPETS && bIsPuppet && eBuildingType >= 0 && ePurchaseYield == YIELD_FAITH)
	{
		bPuppetExceptionFaithBuilding = true;
	}

	if (GET_PLAYER(m_eOwner).GetPlayerTraits()->IsNoAnnexing() && bIsPuppet)
	{
		bVenetianException = true;
	}

	if (bIsPuppet && !bVenetianException && !bPuppetExceptionBuilding && !bPuppetExceptionUnit && !bAllowsPuppetPurchase && !bPuppetExceptionFaithBuilding)
	{
		return false;
	}

	// Check situational reasons we can't purchase now (similar to not having enough gold or faith)
	if (bTestPurchaseCost)
	{
		// Can't purchase things if the city is in resistance or is being razed
		if (IsResistance() || IsRazing())
			return false;

		// if we're purchasing a unit
		if (eUnitType >= 0)
		{
			// if we can't add this unit to this tile, then don't!
			if (!CanPlaceUnitHere(eUnitType))
				return false;
		}
	}

	// What are we buying this with?
	switch (ePurchaseYield)
	{
	case YIELD_GOLD:
	{
		int iGoldCost = -1;

		// Unit
		if (eUnitType != NO_UNIT)
		{
			//there are weird effects here with units which have an instance limit
			//because it's unclear whether we're checking the entries in the build option list or in the build queue
			//so assume we're NOT building one already to be on the safe side
			//otherwise invalid entries can be shown in the build option list
			bool bAlreadyUnderConstruction = false; //getFirstUnitOrder(eUnitType) != -1;
			if (!canTrain(eUnitType, bAlreadyUnderConstruction, !bTestTrainable, false /*bIgnoreCost*/, true /*bWillPurchase*/))
				return false;

			iGoldCost = GetPurchaseCost(eUnitType);
#if defined(MOD_BALANCE_CORE_PUPPET_PURCHASE)
			if (MOD_BALANCE_CORE_PUPPET_PURCHASE && bIsPuppet && !bPuppetExceptionUnit && !bAllowsPuppetPurchase && !bVenetianException)
			{
				return false;
			}
			//Have we already invested here?
			CvUnitEntry* pGameUnit = GC.getUnitInfo(eUnitType);
			if (MOD_BALANCE_CORE_UNIT_INVESTMENTS || (MOD_BALANCE_VP && pGameUnit->GetSpaceshipProject() != NO_PROJECT))
			{
				const UnitClassTypes eUnitClass = (UnitClassTypes)(pGameUnit->GetUnitClassType());
				if (IsUnitInvestment(eUnitClass))
				{
					return false;
				}
			}
#endif
		}
		// Building
		else if (eBuildingType != NO_BUILDING)
		{
			if (!canConstruct(eBuildingType, vPreExistingBuildings, false, !bTestTrainable, false /*bIgnoreCost*/, true /*bWillPurchase*/))
			{
				bool bAlreadyUnderConstruction = canConstruct(eBuildingType, true, !bTestTrainable) && getFirstBuildingOrder(eBuildingType) != -1;
				if (!bAlreadyUnderConstruction)
				{
					return false;
				}
			}

			iGoldCost = GetPurchaseCost(eBuildingType);
#if defined(MOD_BALANCE_CORE_PUPPET_PURCHASE)
			if (MOD_BALANCE_CORE_PUPPET_PURCHASE && bIsPuppet && !bPuppetExceptionBuilding && !bAllowsPuppetPurchase && !bVenetianException)
			{
				return false;
			}
#endif
#if defined(MOD_BALANCE_CORE_BUILDING_INVESTMENTS)
			if (MOD_BALANCE_CORE_BUILDING_INVESTMENTS && (NO_BUILDING != eBuildingType))
			{
				//Have we already invested here?
				CvBuildingEntry* pGameBuilding = GC.getBuildingInfo(eBuildingType);
				if (!pGameBuilding)
					return false;

				const BuildingClassTypes eBuildingClass = pGameBuilding->GetBuildingClassType();
				if (IsBuildingInvestment(eBuildingClass))
				{
					return false;
				}

				if (getProductionTurnsLeft(eBuildingType, 0) == 1) //Can't invest when only 1 turn left, for parity with AI
				{
					return false;
				}
			}
		}
#endif	
		// Project
		else if (eProjectType != NO_PROJECT)
		{
			if (/*1*/ GD_INT_GET(PROJECT_PURCHASING_DISABLED) == 1)
				return false;

			if (!canCreate(eProjectType, false, !bTestTrainable))
				return false;

			iGoldCost = GetPurchaseCost(eProjectType);
		}

		if (iGoldCost == -1)
		{
			return false;
		}
		else
		{
			if (bTestPurchaseCost)
			{
				// Trying to buy something when you don't have enough money!!
				if (iGoldCost > GET_PLAYER(getOwner()).GetTreasury()->GetGold())
					return false;
#if defined(MOD_BALANCE_CORE)
				if (eUnitType != NO_UNIT && (GC.getUnitInfo(eUnitType)->GetCombat() <= 0 && GC.getUnitInfo(eUnitType)->GetRangedCombat() <= 0) && MOD_BALANCE_CORE && (GetUnitPurchaseCooldown(true) - GetUnitPurchaseCooldownMod(true)) > 0)
				{
					return false;
				}
				else if (eUnitType != NO_UNIT && (GC.getUnitInfo(eUnitType)->GetCombat() > 0 || GC.getUnitInfo(eUnitType)->GetRangedCombat() > 0) && MOD_BALANCE_CORE && (GetUnitPurchaseCooldown() - GetUnitPurchaseCooldownMod(false)) > 0)
				{
					return false;
				}
				if (NO_BUILDING != eBuildingType && MOD_BALANCE_CORE && GetBuildingPurchaseCooldown() > 0)
				{
					return false;
				}
				if (eUnitType != NO_UNIT)
				{
					CvUnitEntry* thisUnitInfo = GC.getUnitInfo(eUnitType);
					// See if there are any BuildingClass requirements
					const int iNumBuildingClassInfos = GC.getNumBuildingClassInfos();
					for (int iBuildingClassLoop = 0; iBuildingClassLoop < iNumBuildingClassInfos; iBuildingClassLoop++)
					{
						const BuildingClassTypes eBuildingClass = (BuildingClassTypes)iBuildingClassLoop;
						CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
						if (!pkBuildingClassInfo)
						{
							continue;
						}

						// Requires Building
						if (thisUnitInfo->GetBuildingClassPurchaseRequireds(eBuildingClass))
						{
							if (GetCityBuildings()->GetNumBuildingClass(eBuildingClass) == 0)
							{
								return false;
							}
						}
					}
				}
#endif	
			}
		}
	}
	break;

	case YIELD_FAITH:
	{
		int iFaithCost = -1;
		// Unit
		if (eUnitType != NO_UNIT)
		{
			iFaithCost = GetFaithPurchaseCost(eUnitType, true);
			if (iFaithCost < 1)
			{
				return false;
			}
#if defined(MOD_BALANCE_CORE_PUPPET_PURCHASE)
			if (MOD_BALANCE_CORE_PUPPET_PURCHASE && bIsPuppet && !bPuppetExceptionUnit && !bAllowsPuppetPurchase && !bVenetianException)
			{
				return false;
			}
#endif
			CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnitType);

			if (pkUnitInfo)
			{
				//naval units are only for the UA!
				if (pkUnitInfo->GetDomainType() == DOMAIN_SEA && pkUnitInfo->GetSpecialUnitType() == NO_SPECIALUNIT && !GET_PLAYER(m_eOwner).GetPlayerTraits()->IsCanPurchaseNavalUnitsFaith())
					return false;

				ReligionTypes eReligion;
				if (pkUnitInfo->IsFoundReligion())
				{
					eReligion = GET_PLAYER(m_eOwner).GetReligions()->GetOwnedReligion();
				}
				else
				{
					eReligion = GetCityReligions()->GetReligiousMajority();
				}
				const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, m_eOwner);
				bool bSpecificBeliefBlocked = false;
				if (pReligion)
				{
					if (pkUnitInfo->IsRequiresEnhancedReligion() && !(GC.getGame().GetGameReligions()->GetReligion(eReligion, m_eOwner)->m_bEnhanced))
					{
						return false;
					}

					BeliefTypes SpecificBelief = pReligion->m_Beliefs.GetSpecificFaithBuyingEnabledBelief(eUnitType);
					if (SpecificBelief != NO_BELIEF)
					{
						bSpecificBeliefBlocked = true;
						TechTypes ePrereqTech = (TechTypes)pkUnitInfo->GetPrereqAndTech();
						TechTypes eObsoleteTech = (TechTypes)pkUnitInfo->GetObsoleteTech();
						if (ePrereqTech != -1 || eObsoleteTech != -1)
						{
							if (!canTrain(eUnitType, false, !bTestTrainable, false /*bIgnoreCost*/, true /*bWillPurchase*/))
							{
								return false;
							}
						}
						if (pReligion->m_Beliefs.IsSpecificFaithBuyingEnabled(eUnitType, getOwner(), this))
						{
							bSpecificBeliefBlocked = false;
							if (canTrain(eUnitType, false, !bTestTrainable, false /*bIgnoreCost*/, true /*bWillPurchase*/))
							{
								if (!bTestPurchaseCost) {
									return true;
								}
								if (iFaithCost <= GET_PLAYER(getOwner()).GetFaith())
								{
									return true;
								}
							}
						}
					}
				}

				if (pkUnitInfo->IsRequiresFaithPurchaseEnabled())
				{

					if (pkUnitInfo->GetBeliefUnlock() != NO_BELIEF)
					{
						if (!HasBelief((BeliefTypes)pkUnitInfo->GetBeliefUnlock()))
						{
							return false;
						}
					}

					TechTypes ePrereqTech = (TechTypes)pkUnitInfo->GetPrereqAndTech();
					if (ePrereqTech == -1)
					{
						const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, m_eOwner);
						if (pReligion)
						{
							if (!pReligion->m_Beliefs.IsFaithBuyingEnabled((EraTypes)0, getOwner(), this)) // Ed?
							{
								return false;
							}
							if (!canTrain(eUnitType, false, !bTestTrainable, false /*bIgnoreCost*/, true /*bWillPurchase*/))
							{
								return false;
							}
						}
						else
							return false;
					}
					else
					{
						CvTechEntry* pkTechInfo = GC.GetGameTechs()->GetEntry(ePrereqTech);
						if (!pkTechInfo)
						{
							return false;
						}
						else
						{
							const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, m_eOwner);
							if (pReligion)
							{
								if (!pReligion->m_Beliefs.IsFaithBuyingEnabled((EraTypes)pkTechInfo->GetEra(), getOwner(), this))
								{
									return false;
								}
								else if (pkUnitInfo->GetDefaultUnitAIType() == UNITAI_ARCHAEOLOGIST)
								{
									return false;
								}

								if (!canTrain(eUnitType, false, !bTestTrainable, false /*bIgnoreCost*/, true /*bWillPurchase*/))
								{
									return false;
								}
							}
							else
								return false;
						}
					}
				}
				else
				{
					if (pkUnitInfo->GetBeliefUnlock() != NO_BELIEF)
					{
						if (!HasBelief((BeliefTypes)pkUnitInfo->GetBeliefUnlock()))
						{
							return false;
						}
					}
					if (bSpecificBeliefBlocked)
					{
						return false;
					}

					// Missionaries, Inquisitors and Prophets
					// We need a full religion and not just a pantheon,
					// and also to test that the player can build the unit, specifically the check for a civ specific version of the unit
					if (eReligion <= RELIGION_PANTHEON || !canTrain(eUnitType, false, !bTestTrainable, true /*bIgnoreCost*/, true /*bWillPurchase*/))
					{
						return false;
					}
				}
			}
		}
		// Building
		else if (eBuildingType != NO_BUILDING)
		{
			CvBuildingEntry* pkBuildingInfo = GC.GetGameBuildings()->GetEntry(eBuildingType);

			// Religion-enabled building
			if (pkBuildingInfo && pkBuildingInfo->IsUnlockedByBelief())
			{
				ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
				if (eMajority <= RELIGION_PANTHEON)
				{
					return false;
				}
				const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
				if (pReligion == NULL)
					return false;

				if (!pReligion->m_Beliefs.IsBuildingClassEnabled(pkBuildingInfo->GetBuildingClassType(), getOwner(), this))
				{
					return false;
				}
			}

			if (!canConstruct(eBuildingType, false, !bTestTrainable, true /*bIgnoreCost*/, true /*bWillPurchase*/))
			{
				return false;
			}

			if (GetCityBuildings()->GetNumBuilding(eBuildingType) > 0)
			{
				return false;
			}

			TechTypes ePrereqTech = (TechTypes)pkBuildingInfo->GetPrereqAndTech();
			if (ePrereqTech != NO_TECH)
			{
				CvTechEntry* pkTechInfo = GC.GetGameTechs()->GetEntry(ePrereqTech);
				if (pkTechInfo && !GET_TEAM(GET_PLAYER(getOwner()).getTeam()).GetTeamTechs()->HasTech(ePrereqTech))
				{
					return false;
				}
			}

			iFaithCost = GetFaithPurchaseCost(eBuildingType);
			if (iFaithCost < 1)
			{
				return false;
			}
		}

		if (iFaithCost > 0)
		{
			if (bTestPurchaseCost)
			{
#if defined(MOD_BALANCE_CORE)
				if (eUnitType != NO_UNIT)
				{
					CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnitType);
					if (pkUnitInfo && GET_PLAYER(getOwner()).GetFaithPurchaseCooldown() > 0 && pkUnitInfo->GetGlobalFaithCooldown() > 0)
					{
						return false;
					}
					// Faith counterpart to PurchaseCooldown
					if ((GC.getUnitInfo(eUnitType)->GetCombat() <= 0 && GC.getUnitInfo(eUnitType)->GetRangedCombat() <= 0) && GC.getUnitInfo(eUnitType)->GetLocalFaithCooldown() > 0 && GetUnitFaithPurchaseCooldown(true) > 0)
					{
						return false;
					}
					else if ((GC.getUnitInfo(eUnitType)->GetCombat() > 0 || GC.getUnitInfo(eUnitType)->GetRangedCombat() > 0) && GC.getUnitInfo(eUnitType)->GetLocalFaithCooldown() > 0 && GetUnitFaithPurchaseCooldown() > 0)
					{
						return false;
					}
				}
#endif
				// Trying to buy something when you don't have enough faith!!
				if (iFaithCost > GET_PLAYER(getOwner()).GetFaith())
				{
					return false;
				}
			}
		}
	}
	break;
	default:
		// This function is accessible from Lua scripts so it's incorrect to assume this is unreachable unless we make the Lua function
		// throw errors for non-gold/faith inputs.
		ASSERT_DEBUG(false, "CvCity::IsCanPurchase expects either YIELD_GOLD or YIELD_FAITH as ePurchaseYield");
		return false;
	}

	return true;
}

//	--------------------------------------------------------------------------------
// purchase something at the city
CvUnit* CvCity::PurchaseUnit(UnitTypes eUnitType, YieldTypes ePurchaseYield)
{
	// Can we actually buy this thing?
	if (eUnitType==NO_UNIT || !IsCanPurchase(/*bTestPurchaseCost*/ true, /*bTestTrainable*/ true, eUnitType, NO_BUILDING, NO_PROJECT, ePurchaseYield))
		return NULL;

	CvUnitEntry* pGameUnit = GC.getUnitInfo(eUnitType);
	if (!pGameUnit)
		return NULL;

	CvPlayer& kPlayer = GET_PLAYER(getOwner());
	CvUnit* pNewUnit = NULL;
	bool bInvest = (ePurchaseYield == YIELD_GOLD) && (MOD_BALANCE_CORE_UNIT_INVESTMENTS || (MOD_BALANCE_VP && pGameUnit->GetSpaceshipProject() != NO_PROJECT));

	switch (ePurchaseYield)
	{
	case YIELD_GOLD:
	{
		int	iGoldCost = GetPurchaseCost(eUnitType);

		if (bInvest)
		{
			const UnitClassTypes eUnitClass = (UnitClassTypes)(pGameUnit->GetUnitClassType());
			if (eUnitClass != NO_UNITCLASS)
			{
				SetUnitInvestment(eUnitClass, true);
				if (getProductionProcess() != NO_PROCESS)
				{
					clearOrderQueue();
				}

				if (!hasOrder(ORDER_TRAIN, eUnitType))
				{
					//we purchased it so let's assume it's urgent and put it at the head of the list
					pushOrder(ORDER_TRAIN, eUnitType, -1, false, false, false);
				}
			}
		}
		else
		{
			CvUnit* pUnit = CreateUnit(eUnitType, NO_UNITAI, REASON_BUY);
			if (pUnit == NULL)
				return NULL;	// Can't create the unit, most likely we have no place for it.  We have not deducted the cost yet so just exit
			else
				pNewUnit = pUnit;

			if (pUnit->isTrade())
			{
				if (GC.getLogging() && GC.getAILogging())
				{
					CvString strCiv = GET_PLAYER(getOwner()).getCivilizationAdjective();
					CvString strLogString;
					strLogString.Format("TRADE UNIT BOUGHT: %s %s at %d,d", strCiv.c_str(), pUnit->getName().c_str(), pUnit->getX(), pUnit->getY());
					GET_PLAYER(getOwner()).GetHomelandAI()->LogHomelandMessage(strLogString);
				}
			}

			if (MOD_EVENTS_CITY) {
				GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityTrained, getOwner(), GetID(), pUnit->GetID(), true, false);
			}
			else {
				ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
				if (pkScriptSystem)
				{
					CvLuaArgsHandle args;
					args->Push(getOwner());
					args->Push(GetID());
					args->Push(pUnit->GetID());
					args->Push(true); // bGold
					args->Push(false); // bFaith/bCulture

					bool bScriptResult = false;
					LuaSupport::CallHook(pkScriptSystem, "CityTrained", args.get(), bScriptResult);
				}
			}
		}

		kPlayer.GetTreasury()->LogExpenditure(CvString(pGameUnit->GetText()), iGoldCost, 2);

		bool bCivilian = (pGameUnit->GetCombat() <= 0 && pGameUnit->GetRangedCombat() <= 0);
		SetUnitPurchaseCooldown(bCivilian, pGameUnit->GetCooldown() - GetUnitPurchaseCooldownMod(bCivilian));

		GET_PLAYER(getOwner()).GetTreasury()->ChangeGold(-iGoldCost);
		if (iGoldCost > 0)
		{
			GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_PURCHASE, false, NO_GREATPERSON, NO_BUILDING, iGoldCost, false, NO_PLAYER, NULL, false, this);
			GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_PURCHASE, false, NO_GREATPERSON, NO_BUILDING, iGoldCost, false);
		}

		break;
	}
	case YIELD_FAITH:
	{
		int	iFaithCost = GetFaithPurchaseCost(eUnitType, true  /*bIncludeBeliefDiscounts*/);

		CvUnit* pUnit = CreateUnit(eUnitType, NO_UNITAI, REASON_FAITH_BUY);
		if (pUnit == NULL)
			return NULL;	// Can't create the unit, most likely we have no place for it.  We have not deducted the cost yet so just exit
		else
			pNewUnit = pUnit;

		if (pUnit->getUnitInfo().GetGlobalFaithCooldown() > 0)
		{
			int iCooldown = pUnit->getUnitInfo().GetGlobalFaithCooldown();
			iCooldown *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iCooldown /= 100;
			kPlayer.ChangeFaithPurchaseCooldown(iCooldown);
		}
		if (pUnit->getUnitInfo().GetLocalFaithCooldown() > 0)
		{
			bool bCivilian = (pUnit->getUnitInfo().GetCombat() <= 0 && pUnit->getUnitInfo().GetRangedCombat() <= 0);
			int iCooldown = pUnit->getUnitInfo().GetLocalFaithCooldown();
			iCooldown *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iCooldown /= 100;
			ChangeUnitFaithPurchaseCooldown(bCivilian, iCooldown);
		}

		if (MOD_EVENTS_CITY) {
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityTrained, getOwner(), GetID(), pUnit->GetID(), false, true);
		}
		else {
			ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
			if (pkScriptSystem)
			{
				CvLuaArgsHandle args;
				args->Push(getOwner());
				args->Push(GetID());
				args->Push(pUnit->GetID());
				args->Push(false); // bGold
				args->Push(true); // bFaith/bCulture

				bool bResult = false;
				LuaSupport::CallHook(pkScriptSystem, "CityTrained", args.get(), bResult);
			}
		}

		// Prophets are always of the religion the player founded
		ReligionTypes eReligion = pUnit->getUnitInfo().IsFoundReligion() ? kPlayer.GetReligions()->GetOwnedReligion() : GetCityReligions()->GetReligiousMajority();
		pUnit->GetReligionDataMutable()->SetFullStrength(pUnit->getOwner(), pUnit->getUnitInfo(), eReligion);

		kPlayer.ChangeFaith(-iFaithCost);
		if (iFaithCost > 0)
		{
			GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_FAITH_PURCHASE, true, NO_GREATPERSON, NO_BUILDING, iFaithCost, false, NO_PLAYER, NULL, false, this);
		}

		UnitClassTypes eUnitClass = pUnit->getUnitClassType();
		if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_WRITER"))
		{
			kPlayer.incrementWritersFromFaith();
		}
		else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_ARTIST"))
		{
			kPlayer.incrementArtistsFromFaith();
		}
		else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_MUSICIAN"))
		{
			kPlayer.incrementMusiciansFromFaith();
		}
		else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_SCIENTIST"))
		{
			kPlayer.incrementScientistsFromFaith();
		}
		else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_MERCHANT"))
		{
			kPlayer.incrementMerchantsFromFaith();
		}
		else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_ENGINEER"))
		{
			kPlayer.incrementEngineersFromFaith();
		}
		else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_GREAT_GENERAL"))
		{
			kPlayer.incrementGeneralsFromFaith();
		}
		else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_GREAT_ADMIRAL"))
		{
			kPlayer.incrementAdmiralsFromFaith();
			CvPlot* pSpawnPlot = kPlayer.GetBestCoastalSpawnPlot(pUnit);
			if (pUnit->plot() != pSpawnPlot)
			{
				pUnit->setXY(pSpawnPlot->getX(), pSpawnPlot->getY());
			}
		}
		else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_PROPHET"))
		{
			kPlayer.GetReligions()->ChangeNumProphetsSpawned(1, false);
		}
		else if (MOD_BALANCE_VP && eUnitClass == GC.getInfoTypeForString("UNITCLASS_GREAT_DIPLOMAT"))
		{
			kPlayer.incrementDiplomatsFromFaith();
		}
		else if (pUnit->getUnitInfo().IsGPExtra() == 1)
		{
			kPlayer.incrementGPExtra1FromFaith();
		}
		else if (pUnit->getUnitInfo().IsGPExtra() == 2)
		{
			kPlayer.incrementGPExtra2FromFaith();
		}
		else if (pUnit->getUnitInfo().IsGPExtra() == 3)
		{
			kPlayer.incrementGPExtra3FromFaith();
		}
		else if (pUnit->getUnitInfo().IsGPExtra() == 4)
		{
			kPlayer.incrementGPExtra4FromFaith();
		}
		else if (pUnit->getUnitInfo().IsGPExtra() == 5)
		{
			kPlayer.incrementGPExtra5FromFaith();
		}

		if (GC.getLogging())
		{
			CvString strLogMsg;
			CvString temp;
			strLogMsg = kPlayer.getCivilizationShortDescription();
			strLogMsg += ", FAITH UNIT PURCHASE, ";
			strLogMsg += pUnit->getName();
			strLogMsg += ", ";
			strLogMsg += getName();
			strLogMsg += ", Faith Cost: ";
			temp.Format("%d", iFaithCost);
			strLogMsg += temp;
			strLogMsg += ", Faith Left: ";
			temp.Format("%d", kPlayer.GetFaith());
			strLogMsg += temp;
			GC.getGame().GetGameReligions()->LogReligionMessage(strLogMsg);
		}

		break;
	}
	default:
		// This function is accessible from Lua scripts and network callbacks so it's incorrect to assume this is unreachable.
		ASSERT_DEBUG(false, "CvCity::Purchase expects either YIELD_GOLD or YIELD_FAITH as ePurchaseYield");
		return NULL;
	}

	if (!bInvest)
	{
		//autoupgrade
		if (pNewUnit->isFreeUpgrade() || GET_PLAYER(getOwner()).GetPlayerTraits()->IsFreeUpgrade())
		{
			UnitTypes eUpgradeUnit = pNewUnit->GetUpgradeUnitType();
			if (eUpgradeUnit != NO_UNIT && canTrain(eUpgradeUnit, false, false, true))
			{
				//return value must not be a zombie
				pNewUnit = pNewUnit->DoUpgrade(true);
			}
		}
		if (kPlayer.GetPlayerTraits()->IsFreeZuluPikemanToImpi())
		{
			UnitClassTypes ePikemanClass = (UnitClassTypes)GC.getInfoTypeForString("UNITCLASS_PIKEMAN");
			UnitTypes eZuluImpi = (UnitTypes)GC.getInfoTypeForString("UNIT_ZULU_IMPI");
			if (pNewUnit->getUnitClassType() == ePikemanClass && canTrain(eZuluImpi, false, false, true))
			{
				CvUnitEntry* pkcUnitEntry = GC.getUnitInfo(eZuluImpi);
				if (pkcUnitEntry)
				{
					UnitAITypes eZuluImpiAI = pkcUnitEntry->GetDefaultUnitAIType();
					CvUnit* pZuluImpi = kPlayer.initUnit(eZuluImpi, pNewUnit->getX(), pNewUnit->getY(), eZuluImpiAI);
					pZuluImpi->convert(pNewUnit, true);

					//return value must not be a zombie
					pNewUnit = pZuluImpi;
				}
			}
		}
	}

	return pNewUnit;
}

bool CvCity::PurchaseBuilding(BuildingTypes eBuildingType, YieldTypes ePurchaseYield)
{
	// Can we actually buy this thing?
	if (eBuildingType==NO_BUILDING || !IsCanPurchase(/*bTestPurchaseCost*/ true, /*bTestTrainable*/ true, NO_UNIT, eBuildingType, NO_PROJECT, ePurchaseYield))
		return false;
	CvBuildingEntry* pGameBuilding = GC.getBuildingInfo(eBuildingType);
	if (pGameBuilding == NULL)
		return false;

	CvPlayer& kPlayer = GET_PLAYER(getOwner());

	switch (ePurchaseYield)
	{
	case YIELD_GOLD:
	{
		int iGoldCost = GetPurchaseCost(eBuildingType);

		if (MOD_BALANCE_CORE_BUILDING_INVESTMENTS)
		{
			const BuildingClassTypes eBuildingClass = pGameBuilding->GetBuildingClassType();
			if (eBuildingClass != NO_BUILDINGCLASS)
			{
				SetBuildingInvestment(eBuildingClass, true);

				if (!hasOrder(ORDER_CONSTRUCT, eBuildingType, -1))
				{
					//we purchased it so let's assume it's urgent and put it at the head of the list
					pushOrder(ORDER_CONSTRUCT, eBuildingType, -1, false, false, false);
				}
			}
		}
		else
		{
			if (!CreateBuilding(eBuildingType))
				return false;

			CleanUpQueue(); // cleans out items from the queue that may be invalidated by the recent construction

			if (MOD_EVENTS_CITY)
			{
				GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityConstructed, getOwner(), GetID(), eBuildingType, true, false);
			}
			else
			{
				CvBuildingEntry* pkPurchasedBuildingInfo = GC.getBuildingInfo(eBuildingType);
				if (pkPurchasedBuildingInfo)
				{
					const BuildingClassTypes ePurchasedClass = pkPurchasedBuildingInfo->GetBuildingClassType();
					if (ePurchasedClass != NO_BUILDINGCLASS)
						SetPurchased(ePurchasedClass, true);
				}

				ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
				if (pkScriptSystem)
				{
					CvLuaArgsHandle args;
					args->Push(getOwner());
					args->Push(GetID());
					args->Push(eBuildingType);
					args->Push(true); // bGold
					args->Push(false); // bFaith/bCulture

					bool bScriptResult = false;
					LuaSupport::CallHook(pkScriptSystem, "CityConstructed", args.get(), bScriptResult);
				}
			}
		}

		kPlayer.GetTreasury()->LogExpenditure((CvString)pGameBuilding->GetText(), iGoldCost, 2);
		GET_PLAYER(getOwner()).GetTreasury()->ChangeGold(-iGoldCost);
		if (iGoldCost > 0)
		{
			GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_PURCHASE, false, NO_GREATPERSON, NO_BUILDING, iGoldCost, false, NO_PLAYER, NULL, false, this);
			GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_PURCHASE, false, NO_GREATPERSON, NO_BUILDING, iGoldCost, false);
		}

		break;
	}
	case YIELD_FAITH:
	{
		int iFaithCost = GetFaithPurchaseCost(eBuildingType);

		if (!CreateBuilding(eBuildingType))
			return false;

		CleanUpQueue(); // cleans out items from the queue that may be invalidated by the recent construction

		if (MOD_EVENTS_CITY)
		{
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityConstructed, getOwner(), GetID(), eBuildingType, false, true);
		}
		else
		{
			CvBuildingEntry* pkPurchasedBuildingInfo = GC.getBuildingInfo(eBuildingType);
			if (pkPurchasedBuildingInfo)
			{
				const BuildingClassTypes ePurchasedClass = pkPurchasedBuildingInfo->GetBuildingClassType();
				if (ePurchasedClass != NO_BUILDINGCLASS)
				{
					SetPurchased(ePurchasedClass, true);
				}
			}

			ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
			if (pkScriptSystem)
			{
				CvLuaArgsHandle args;
				args->Push(getOwner());
				args->Push(GetID());
				args->Push(eBuildingType);
				args->Push(false); // bGold
				args->Push(true); // bFaith/bCulture

				bool bScriptResult = false;
				LuaSupport::CallHook(pkScriptSystem, "CityConstructed", args.get(), bScriptResult);
			}
		}

		kPlayer.ChangeFaith(-iFaithCost);

		if (GC.getLogging())
		{
			CvString strLogMsg;
			CvString temp;
			strLogMsg = kPlayer.getCivilizationShortDescription();
			strLogMsg += ", FAITH BUILDING PURCHASE, ";

			CvBuildingXMLEntries* pGameBuildings = GC.GetGameBuildings();
			if (pGameBuildings != NULL)
			{
				CvBuildingEntry* pBuildingEntry = pGameBuildings->GetEntry(eBuildingType);
				if (pBuildingEntry != NULL)
				{
					strLogMsg += pBuildingEntry->GetDescription();
					strLogMsg += ", ";
				}
			}
			strLogMsg += getName();
			strLogMsg += ", Faith Cost: ";
			temp.Format("%d", iFaithCost);
			strLogMsg += temp;
			strLogMsg += ", Faith Left: ";
			temp.Format("%d", kPlayer.GetFaith());
			strLogMsg += temp;
			GC.getGame().GetGameReligions()->LogReligionMessage(strLogMsg);
		}

		if (iFaithCost > 0)
			GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_FAITH_PURCHASE, true, NO_GREATPERSON, NO_BUILDING, iFaithCost, false, NO_PLAYER, NULL, false, this);

		break;
	}
	default:
		// This function is accessible from Lua scripts and network callbacks so it's incorrect to assume this is unreachable.
		ASSERT_DEBUG(false, "CvCity::Purchase expects either YIELD_GOLD or YIELD_FAITH as ePurchaseYield");
		return false;
	}

	return true;
}

bool CvCity::PurchaseProject(ProjectTypes eProjectType, YieldTypes ePurchaseYield)
{
	// Can we actually buy this thing?
	if (eProjectType==NO_PROJECT || !IsCanPurchase(/*bTestPurchaseCost*/ true, /*bTestTrainable*/ true, NO_UNIT, NO_BUILDING, eProjectType, ePurchaseYield))
		return false;

	CvPlayer& kPlayer = GET_PLAYER(getOwner());

	switch (ePurchaseYield)
	{
	case YIELD_GOLD:
	{
		int iGoldCost = GetPurchaseCost(eProjectType);
		kPlayer.GetTreasury()->LogExpenditure((CvString)GC.getProjectInfo(eProjectType)->GetText(), iGoldCost, 2);

		GET_PLAYER(getOwner()).GetTreasury()->ChangeGold(-iGoldCost);
		if (iGoldCost > 0)
		{
			GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_PURCHASE, false, NO_GREATPERSON, NO_BUILDING, iGoldCost, false, NO_PLAYER, NULL, false, this);
			GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_PURCHASE, false, NO_GREATPERSON, NO_BUILDING, iGoldCost, false);
		}

		if (!CreateProject(eProjectType))
			return false;

		if (MOD_EVENTS_CITY) {
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityCreated, getOwner(), GetID(), eProjectType, true, false);
		}
		else {
			ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
			if (pkScriptSystem)
			{
				CvLuaArgsHandle args;
				args->Push(getOwner());
				args->Push(GetID());
				args->Push(eProjectType);
				args->Push(true); // bGold
				args->Push(false); // bFaith/bCulture

				bool bScriptResult = false;
				LuaSupport::CallHook(pkScriptSystem, "CityCreated", args.get(), bScriptResult);
			}
		}
		break;
	}
	default:
		// This function is accessible from Lua scripts and network callbacks so it's incorrect to assume this is unreachable.
		ASSERT_DEBUG(false, "CvCity::Purchase expects either YIELD_GOLD or YIELD_FAITH as ePurchaseYield");
		return false;
	}

	return true;
}

// Protected Functions...

//	--------------------------------------------------------------------------------
void CvCity::doGrowth()
{
	VALIDATE_OBJECT();
	// here would be a good place to override this in Lua

	// No growth or starvation if being razed
	if (IsRazing())
	{
		return;
	}
	//No growth or starvation if in resistance
	if (IsResistance())
	{
		return;
	}

	int iFoodPerTurn100 = foodDifferenceTimes100();
	int iFoodReqForGrowth = growthThreshold();

	if (iFoodPerTurn100 < 0)
	{
		CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
		if (pNotifications)
		{
			Localization::String text = Localization::Lookup("TXT_KEY_NTFN_CITY_STARVING");
			text << getNameKey();
			Localization::String summary = Localization::Lookup("TXT_KEY_NTFN_CITY_STARVING_S");
			summary << getNameKey();

			pNotifications->Add(NOTIFICATION_STARVING, text.toUTF8(), summary.toUTF8(), getX(), getY(), -1);
		}
	}

	changeFoodTimes100(iFoodPerTurn100);

	//can't grow while starving
	if (getFood() >= iFoodReqForGrowth)
	{
		if (GetCityCitizens()->IsForcedAvoidGrowth())  // don't grow a city if we are at *forced* avoid growth
		{
			setFood(iFoodReqForGrowth);
		}
		else
		{
			int iFoodKept = (iFoodReqForGrowth * getMaxFoodKeptPercent()) / 100;
			int iFoodStoreChange = max(0, iFoodReqForGrowth - iFoodKept);

			changeFood(-iFoodStoreChange);
			changePopulation(1);

			// Only show notification if the city is small
			if (getPopulation() <= 5)
			{
				CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
				if (pNotifications)
				{
					Localization::String localizedText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_GROWTH");
					localizedText << getNameKey() << getPopulation();
					Localization::String localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_GROWTH");
					localizedSummary << getNameKey();
					pNotifications->Add(NOTIFICATION_CITY_GROWTH, localizedText.toUTF8(), localizedSummary.toUTF8(), getX(), getY(), GetID());
				}
			}
		}
	}
	//starving
	else if (getFoodTimes100() == 0 && iFoodPerTurn100 < 0 && getPopulation()>1)
	{
		changePopulation(-1);
	}
}

//	--------------------------------------------------------------------------------
bool CvCity::doCheckProduction()
{
	VALIDATE_OBJECT();
	int iMaxedUnitGoldPercent = /*100*/ GD_INT_GET(MAXED_UNIT_GOLD_PERCENT);
	int iMaxedBuildingGoldPercent = /*100*/ GD_INT_GET(MAXED_BUILDING_GOLD_PERCENT);
	int iMaxedProjectGoldPercent = /*300*/ GD_INT_GET(MAXED_PROJECT_GOLD_PERCENT);

	CvPlayer& kOwner = GET_PLAYER(getOwner());

	// Convert unit production to gold if unit class limit is reached
	for (int iI = 0; iI < GC.getNumUnitInfos(); iI++)
	{
		const UnitTypes eUnit = static_cast<UnitTypes>(iI);
		int iUnitProduction = getUnitProduction(eUnit);
		if (iUnitProduction > 0)
		{
			const CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
			if (kOwner.isProductionMaxedUnitClass(static_cast<UnitClassTypes>(pkUnitInfo->GetUnitClassType())))
			{
				int iProductionGold = iUnitProduction * iMaxedUnitGoldPercent / 100;
				if (iProductionGold > 0)
				{
					kOwner.GetTreasury()->ChangeGold(iProductionGold);

					// Notification
					if (getOwner() == GC.getGame().getActivePlayer())
					{
						Localization::String localizedText = Localization::Lookup("TXT_KEY_MISC_LOST_WONDER_PROD_CONVERTED");
						localizedText << getNameKey() << pkUnitInfo->GetTextKey() << iProductionGold;
						DLLUI->AddCityMessage(0, GetIDInfo(), getOwner(), false, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), localizedText.toUTF8());
					}
				}

				setUnitProduction(eUnit, 0);
			}
		}
	}

	// Convert building production to gold (or other yields) if global building class limit is reached
	// For other buildings, the production is just lost
	for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);
		int iBuildingProduction = GetCityBuildings()->GetBuildingProduction(eBuilding);
		if (iBuildingProduction > 0)
		{
			const CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
			const BuildingClassTypes eBuildingClass = pkBuildingInfo->GetBuildingClassType();
			if (kOwner.isProductionMaxedBuildingClass(eBuildingClass))
			{
				// Beaten to a world wonder by someone?
				if (isWorldWonderClass(pkBuildingInfo->GetBuildingClassInfo()))
				{
					// Check diplomatic implications
					for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
					{
						PlayerTypes eLoopPlayer = static_cast<PlayerTypes>(iPlayerLoop);
						if (eLoopPlayer == getOwner())
							continue;

						// Found a culprit
						if (GET_PLAYER(eLoopPlayer).getBuildingClassCount(eBuildingClass) > 0)
						{
							kOwner.GetDiplomacyAI()->ChangeNumWondersBeatenTo(eLoopPlayer, 1);
						}
					}

					// Remove world map model
					CvInterfacePtr<ICvCity1> pDllCity(new CvDllCity(this));
					DLLUI->AddDeferredWonderCommand(WONDER_REMOVED, pDllCity.get(), eBuilding, 0);

					// Add "achievement" for sucking it up
					if (MOD_API_ACHIEVEMENTS)
						gDLL->IncrementSteamStatAndUnlock(ESTEAMSTAT_BEATWONDERS, 10, ACHIEVEMENT_SUCK_AT_WONDERS);

					// Give consolation yields
					int iProductionGold = iBuildingProduction * iMaxedBuildingGoldPercent / 100;
					if (iProductionGold > 0)
					{
						if (MOD_BALANCE_CORE_WONDERS_VARIABLE_REWARD)
						{
							switch (GD_INT_GET(BALANCE_WONDER_BEATEN_CONSOLATION_PRIZE))
							{
								case 1:
									// Convert into gold
									kOwner.GetTreasury()->ChangeGold(iProductionGold);
									break;

								case 2:
									// Convert into culture
									iProductionGold *= /*33*/ GD_INT_GET(BALANCE_CULTURE_PERCENTAGE_VALUE);
									iProductionGold /= 100;
									kOwner.changeJONSCulture(iProductionGold);
									ChangeJONSCultureStored(iProductionGold);
									break;

								case 3:
									// Convert into golden age points
									iProductionGold *= /*25*/ GD_INT_GET(BALANCE_GA_PERCENTAGE_VALUE);
									iProductionGold /= 100;
									kOwner.ChangeGoldenAgeProgressMeter(iProductionGold);
									ChangeJONSCultureStored(iProductionGold);
									break;

								case 4:
								{
									// Convert into science
									iProductionGold *= /*10*/ GD_INT_GET(BALANCE_SCIENCE_PERCENTAGE_VALUE);
									iProductionGold /= 100;
									TechTypes eCurrentTech = kOwner.GetPlayerTechs()->GetCurrentResearch();

									if (eCurrentTech == NO_TECH)
										kOwner.changeOverflowResearch(iProductionGold);
									else
										GET_TEAM(kOwner.getTeam()).GetTeamTechs()->ChangeResearchProgress(eCurrentTech, iProductionGold, getOwner());

									break;
								}

								case 5:
									// Convert into faith
									iProductionGold *= /*10*/ GD_INT_GET(BALANCE_FAITH_PERCENTAGE_VALUE);
									iProductionGold /= 100;
									kOwner.ChangeFaith(iProductionGold);
									break;

								default:
									iProductionGold = 0;
									break;
							}
						}
						else
						{
							kOwner.GetTreasury()->ChangeGold(iProductionGold);
						}

						// Notification
						if (getOwner() == GC.getGame().getActivePlayer() && iProductionGold > 0)
						{
							CvNotifications* pNotifications = kOwner.GetNotifications();
							if (pNotifications)
							{
								Localization::String strText = Localization::Lookup("TXT_KEY_MISC_LOST_WONDER_PROD_CONVERTED");
								strText << getNameKey();
								strText << pkBuildingInfo->GetTextKey();
								strText << iProductionGold;
								Localization::String strSummary = Localization::Lookup("TXT_KEY_MISC_LOST_WONDER_PROD_CONVERTED_S");
								strSummary << getNameKey();
								strSummary << pkBuildingInfo->GetTextKey();
								pNotifications->Add(NOTIFICATION_WONDER_BEATEN, strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), eBuilding, GetID());
							}
						}
					}
				}

				GetCityBuildings()->SetBuildingProduction(eBuilding, 0);
			}
		}
	}

	// Convert project production to gold if limit is reached
	for (int iI = 0; iI < GC.getNumProjectInfos(); iI++)
	{
		ProjectTypes eProject = static_cast<ProjectTypes>(iI);
		int iProjectProduction = getProjectProduction(eProject);
		if (iProjectProduction > 0)
		{
			if (kOwner.isProductionMaxedProject(eProject))
			{
				int iProductionGold = iProjectProduction * iMaxedProjectGoldPercent / 100;
				if (iProductionGold > 0)
				{
					kOwner.GetTreasury()->ChangeGold(iProductionGold);

					if (getOwner() == GC.getGame().getActivePlayer())
					{
						Localization::String localizedText = Localization::Lookup("TXT_KEY_MISC_LOST_WONDER_PROD_CONVERTED");
						localizedText << getNameKey() << GC.getProjectInfo(eProject)->GetTextKey() << iProductionGold;
						DLLUI->AddCityMessage(0, GetIDInfo(), getOwner(), false, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), localizedText.toUTF8());
					}
				}

				setProjectProduction(eProject, 0);
			}
		}
	}

	if (!isProduction() && isHuman() && !isProductionAutomated() && !IsIgnoreCityForHappiness())
	{
		chooseProduction();
		return true;
	}

	// Can now train an Upgraded version of this Unit, and the current one in queue is obsolete
	const UnitTypes eUnit = getProductionUnit();
	if (eUnit != NO_UNIT && !canTrain(eUnit, true))
	{
		UnitTypes eUpgradeUnit = allUpgradesAvailable(eUnit);
		if (eUpgradeUnit != NO_UNIT)
		{
			ASSERT_DEBUG(eUpgradeUnit != eUnit, "Trying to upgrade a Unit to itself");

			// Carry over the unit progress
			int iUpgradeProduction = getUnitProduction(eUnit);
			setUnitProduction(eUnit, 0);
			setUnitProduction(eUpgradeUnit, iUpgradeProduction);

			// Update the production queue
			OrderData* pOrderNode = headOrderQueueNode();
			pOrderNode->iData1 = eUpgradeUnit;
			kOwner.changeUnitClassMaking(static_cast<UnitClassTypes>(GC.getUnitInfo(eUnit)->GetUnitClassType()), -1);
			kOwner.changeUnitClassMaking(static_cast<UnitClassTypes>(GC.getUnitInfo(eUpgradeUnit)->GetUnitClassType()), 1);
		}
	}

	// Can now construct an Upgraded version of this Building
	const BuildingTypes eBuilding = getProductionBuilding();
	if (eBuilding != NO_BUILDING)
	{
		const CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
		BuildingClassTypes eUpgradeBuildingClass = static_cast<BuildingClassTypes>(pkBuildingInfo->GetReplacementBuildingClass());
		if (eUpgradeBuildingClass != NO_BUILDINGCLASS)
		{
			BuildingTypes eUpgradeBuilding = static_cast<BuildingTypes>(kOwner.getCivilizationInfo().getCivilizationBuildings(eUpgradeBuildingClass));
			if (canConstruct(eUpgradeBuilding))
			{
				ASSERT_DEBUG(eUpgradeBuilding != eBuilding, "Trying to upgrade a Building to itself");

				// Carry over the building progress
				int iUpgradeProduction = GetCityBuildings()->GetBuildingProduction(eBuilding);
				GetCityBuildings()->SetBuildingProduction(eBuilding, 0);
				GetCityBuildings()->SetBuildingProduction(eUpgradeBuilding, iUpgradeProduction);

				// Update the production queue
				OrderData* pOrderNode = headOrderQueueNode();
				const BuildingClassTypes eBuildingClass = pkBuildingInfo->GetBuildingClassType();
				pOrderNode->iData1 = eUpgradeBuilding;
				kOwner.changeBuildingClassMaking(eBuildingClass, -1);
				kOwner.changeBuildingClassMaking(eUpgradeBuildingClass, 1);
			}
		}
	}

	return CleanUpQueue();
}

bool CvCity::CrosscheckYieldsFromMinors()
{
#ifdef VPDEBUG
	CvPlayer& kMajor = GET_PLAYER(getOwner());
	int iEra = max(1, (int)kMajor.GetCurrentEra());

	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes)iI;
		int iMajorBonus = 0;
		int iMinorBonus = 0;

		for (int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)
		{
			PlayerTypes eMinorLoop = (PlayerTypes)iMinorLoop;
			CvMinorCivAI* pMinorLoop = GET_PLAYER(eMinorLoop).GetMinorCivAI();
			if (!pMinorLoop->GetPlayer()->isAlive())
				continue;

			//bonuses based on major traits
			if (isCapital())
			{
				if (pMinorLoop->IsAllies(getOwner()))
					iMajorBonus += kMajor.GetPlayerTraits()->GetYieldFromCSAlly(eYield)*iEra*100;

				if (pMinorLoop->IsFriends(getOwner()))
					iMajorBonus += kMajor.GetPlayerTraits()->GetYieldFromCSFriend(eYield)*iEra*100;
			}

			//bonuses based on minor traits (currently food only). do not consider any major-trait specific modifiers here!
			if (eYield == YIELD_FOOD && pMinorLoop->GetTrait() == MINOR_CIV_TRAIT_MARITIME)
			{
				if (isCapital())
				{
					if (pMinorLoop->IsAllies(getOwner()))
						iMinorBonus += pMinorLoop->GetAlliesCapitalFoodBonus();
					if (pMinorLoop->IsFriends(getOwner()))
						iMinorBonus += pMinorLoop->GetFriendsCapitalFoodBonus(getOwner());
				}
				else
				{
					if (pMinorLoop->IsAllies(getOwner()))
						iMinorBonus += pMinorLoop->GetAlliesOtherCityFoodBonus();
					if (pMinorLoop->IsFriends(getOwner()))
						iMinorBonus += pMinorLoop->GetFriendsOtherCityFoodBonus(getOwner());
				}
			}
		}

		//roman UA adds yields from conquered city states ...
		if (eYield == YIELD_FOOD)
			iMajorBonus += isCapital() ? kMajor.GetFoodInCapitalPerTurnFromAnnexedMinors()*100 : kMajor.GetFoodInOtherCitiesPerTurnFromAnnexedMinors()*100;

		if (m_aiBaseYieldRateFromCSAlliance[eYield]*100 + m_aiBaseYieldRateFromCSFriendship[eYield]*100 != iMajorBonus + iMinorBonus)
		{
			CUSTOMLOG("yield mismatch in %s!", getNameKey());
			return false;
		}
	}
#endif
	return true;
}

//	--------------------------------------------------------------------------------
void CvCity::doProduction(bool bAllowNoProduction)
{
	VALIDATE_OBJECT();

	if (!isHuman() || isProductionAutomated())
	{
		if (!isProduction() || isProductionProcess() || AI_isChooseProductionDirty())
		{
			AI_chooseProduction(false /*bInterruptWonders*/, false);
		}
	}

	if (!bAllowNoProduction && !isProduction())
	{
		return;
	}

	if (isProduction())
	{
		if (isProductionBuilding())
		{
			const OrderData* pOrderNode = headOrderQueueNode();
			int iData1 = -1;
			if (pOrderNode != NULL)
			{
				iData1 = pOrderNode->iData1;
			}

			const BuildingTypes eBuilding = static_cast<BuildingTypes>(iData1);
			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
			if (pkBuildingInfo)
			{
				if (isWorldWonderClass(pkBuildingInfo->GetBuildingClassInfo()))
				{
					if (m_pCityBuildings->GetBuildingProduction(eBuilding) == 0)  // otherwise we are probably already showing this
					{
						CvInterfacePtr<ICvCity1> pDllCity(new CvDllCity(this));
						DLLUI->AddDeferredWonderCommand(WONDER_CREATED, pDllCity.get(), eBuilding, 0);
					}
				}
			}
		}

		changeProductionTimes100(getCurrentProductionDifferenceTimes100(false, true));

		if (!(MOD_PROCESS_STOCKPILE && isProductionProcess()))
			setOverflowProduction(0);

		setFeatureProduction(0);

		if (getProduction() >= getProductionNeeded())
		{
			popOrder(0, !isProductionProcess(), true);
		}
	}
	else
	{
		changeOverflowProductionTimes100(getCurrentProductionDifferenceTimes100(false, false));
	}
}

//	--------------------------------------------------------------------------------
void CvCity::doProcess()
{
	ProcessTypes eProcess = getProductionProcess();
	ASSERT_DEBUG(eProcess != NO_PROCESS, "Invalid Process for city production.");
	if (eProcess == NO_PROCESS) return;

#if defined(MOD_PROCESS_STOCKPILE)
	if (MOD_PROCESS_STOCKPILE && eProcess == GC.getInfoTypeForString("PROCESS_STOCKPILE", true))
	{
		int iPile = getCurrentProductionDifferenceTimes100(false, false);
		// Can't use changeOverflowProductionTimes100() here as it asserts above 250 production
		setOverflowProductionTimes100(getOverflowProductionTimes100() + iPile);
		CUSTOMLOG("Adding %i production to the stockpile of %s (for a total of %i)", iPile / 100, getName().c_str(), getOverflowProduction());
	}
#endif
}


//	--------------------------------------------------------------------------------
void CvCity::doDecay()
{
	VALIDATE_OBJECT();
	int iBuildingProductionDecayTime = /*50*/ GD_INT_GET(BUILDING_PRODUCTION_DECAY_TIME);
	int iBuildingProductionDecayPercent = /*99*/ GD_INT_GET(BUILDING_PRODUCTION_DECAY_PERCENT);

	for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		if (getProductionBuilding() != ((BuildingTypes)iI))
		{
			if (m_pCityBuildings->GetBuildingProduction((BuildingTypes)iI) > 0)
			{
				m_pCityBuildings->ChangeBuildingProductionTime(((BuildingTypes)iI), 1);

				if (isHuman())
				{
					if (m_pCityBuildings->GetBuildingProductionTime((BuildingTypes)iI) > iBuildingProductionDecayTime)
					{
						m_pCityBuildings->SetBuildingProduction(((BuildingTypes)iI), ((m_pCityBuildings->GetBuildingProduction((BuildingTypes)iI) * iBuildingProductionDecayPercent) / 100));
					}
				}
			}
			else
			{
				m_pCityBuildings->SetBuildingProductionTime(((BuildingTypes)iI), 0);
			}
		}
	}

	int iUnitProductionDecayTime = /*10*/ GD_INT_GET(UNIT_PRODUCTION_DECAY_TIME);
	int iUnitProductionDecayPercent = /*98*/ GD_INT_GET(UNIT_PRODUCTION_DECAY_PERCENT);

	for (int iI = 0; iI < GC.getNumUnitInfos(); iI++)
	{
		const UnitTypes eUnit = static_cast<UnitTypes>(iI);
		CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
		if (pkUnitInfo)
		{
			if (getProductionUnit() != eUnit)
			{
				if (getUnitProduction(eUnit) > 0)
				{
					changeUnitProductionTime(eUnit, 1);

					if (isHuman())
					{
						if (getUnitProductionTime(eUnit) > iUnitProductionDecayTime)
						{
							setUnitProduction(eUnit, ((getUnitProduction(eUnit) * iUnitProductionDecayPercent) / 100));
						}
					}
				}
				else
				{
					setUnitProductionTime(eUnit, 0);
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
void CvCity::doMeltdown()
{
	VALIDATE_OBJECT();

	int iNumBuildingInfos = GC.getNumBuildingInfos();
	for (int iI = 0; iI < iNumBuildingInfos; iI++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
		if (NULL != pkBuildingInfo && m_pCityBuildings->GetNumBuilding((BuildingTypes)iI) > 0)
		{
			if (pkBuildingInfo->GetNukeExplosionRand() != 0)
			{
				if (GC.getGame().getJonRandNum(pkBuildingInfo->GetNukeExplosionRand(), "Meltdown!!!") == 0)
				{
					if (m_pCityBuildings->GetNumRealBuilding((BuildingTypes)iI) > 0)
					{
						m_pCityBuildings->SetNumRealBuilding(((BuildingTypes)iI), 0);
					}

					CvUnitCombat::ApplyNuclearExplosionDamage(plot(), 1);

					if (getOwner() == GC.getGame().getActivePlayer())
					{
						Localization::String localizedText = Localization::Lookup("TXT_KEY_MISC_MELTDOWN_CITY");
						localizedText << getNameKey();

						DLLUI->AddCityMessage(0, GetIDInfo(), getOwner(), false, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), localizedText.toUTF8()/*, "AS2D_MELTDOWN", MESSAGE_TYPE_MINOR_EVENT, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), getX(), getY(), true, true*/);
					}

					break;
				}
			}
		}
	}
}

//  --------------------------------------------------------------------------------
// Handles logic for Unit_YieldOnCompletion table, awarding instant yields for
// relevant units completed in this city
void CvCity::doUnitCompletionYields(CvUnit* pUnit, UnitCreationReason eReason)
{
	ASSERT_DEBUG(pUnit, "pUnit passed into doUnitCompletionYields was NULL");
	if (!(eReason == REASON_TRAIN || eReason == REASON_BUY || eReason == REASON_FAITH_BUY))
	{
		return;
	}
	
	for (int iYieldLoop = 0; iYieldLoop < NUM_YIELD_TYPES; iYieldLoop++)
	{
		int iYieldQuantityOnCompletion = pUnit->getUnitInfo().GetYieldOnCompletion((YieldTypes)iYieldLoop);
		if (iYieldQuantityOnCompletion > 0)
		{
			// Look up instant yield type based on unit creation reason
			InstantYieldType eIYieldType = INSTANT_YIELD_TYPE_INSTANT;
			switch (eReason) {
			case REASON_TRAIN:
				eIYieldType = INSTANT_YIELD_TYPE_U_PROD;
				break;
			case REASON_BUY:
				eIYieldType = INSTANT_YIELD_TYPE_PURCHASE;
				break;
			case REASON_FAITH_BUY:
				eIYieldType = INSTANT_YIELD_TYPE_FAITH_PURCHASE;
				break;
			}

			GET_PLAYER(getOwner()).doInstantYield(eIYieldType, false, NO_GREATPERSON, NO_BUILDING, iYieldQuantityOnCompletion, 
				false, NO_PLAYER, NULL, false, this, false, true, false, (YieldTypes)iYieldLoop, pUnit, NO_TERRAIN, NULL, NULL, NULL);
		}
	}
}

//	--------------------------------------------------------------------------------
CvCityStrategyAI* CvCity::GetCityStrategyAI() const
{
	VALIDATE_OBJECT();
	return m_pCityStrategyAI;
}

//	--------------------------------------------------------------------------------
CvCityCitizens* CvCity::GetCityCitizens() const
{
	VALIDATE_OBJECT();
	return m_pCityCitizens;
}

//	--------------------------------------------------------------------------------
CvCityReligions* CvCity::GetCityReligions() const
{
	VALIDATE_OBJECT();
	return m_pCityReligions;
}

//	--------------------------------------------------------------------------------
CvCityEmphases* CvCity::GetCityEmphases() const
{
	VALIDATE_OBJECT();
	return m_pEmphases;
}

//	--------------------------------------------------------------------------------
CvCityEspionage* CvCity::GetCityEspionage() const
{
	VALIDATE_OBJECT();
	return m_pCityEspionage;
}

//	--------------------------------------------------------------------------------
CvCityCulture* CvCity::GetCityCulture() const
{
	VALIDATE_OBJECT();
	return m_pCityCulture;
}

// Private Functions...

template<typename City, typename Visitor>
void CvCity::Serialize(City& city, Visitor& visitor)
{
	const bool bLoading = visitor.isLoading();
	const bool bSaving = visitor.isSaving();

	visitor(city.m_iAutomatons);

	// FIXME - Values in this chunk were formerly FAutoVariables. Remove any that shouldn't be saved.
	visitor(city.m_eOwner);
	visitor(city.m_iX);
	visitor(city.m_iY);
	visitor(city.m_iID);
	visitor(city.m_iRallyX);
	visitor(city.m_iRallyY);
	visitor(city.m_iGameTurnFounded);
	visitor(city.m_iGameTurnAcquired);
	visitor(city.m_iGameTurnLastExpanded);
	visitor(city.m_iPopulation);
	visitor(city.m_iHighestPopulation);
	visitor(city.m_iExtraHitPoints);
	visitor(city.m_iBaseGreatPeopleRate);
	visitor(city.m_iGreatPeopleRateModifier);
	visitor(city.m_iGPRateModifierPerMarriage);
	visitor(city.m_iGPRateModifierPerLocalTheme);
	visitor(city.m_iGPPOnCitizenBirth);
	visitor(city.m_iJONSCultureStored);
	visitor(city.m_iJONSCultureLevel);
	visitor(city.m_iJONSCulturePerTurnFromPolicies);
	visitor(city.m_iJONSCulturePerTurnFromSpecialists);
	visitor(city.m_iaAddedYieldPerTurnFromTraits);
	visitor(city.m_iFaithPerTurnFromPolicies);
	visitor(city.m_iAdditionalFood);
	visitor(city.m_iCityBuildingBombardRange);
	visitor(city.m_iCityIndirectFire);
	visitor(city.m_iCityBuildingRangeStrikeModifier);
	visitor(city.m_iGarrisonRangedAttackModifier);
	visitor(city.m_iCultureRateModifier);
	visitor(city.m_iNumWorldWonders);
	visitor(city.m_iNumTeamWonders);
	visitor(city.m_iNumNationalWonders);
	visitor(city.m_iWonderProductionModifier);
	visitor(city.m_iCapturePlunderModifier);
	visitor(city.m_iDiplomatInfluenceBoost);
	visitor(city.m_iBorderGrowthRateIncrease);
	visitor(city.m_iPlotCultureCostModifier);
	visitor(city.m_iPlotBuyCostModifier);
	visitor(city.m_iCityWorkingChange);
	visitor(city.m_iCitySupplyModifier);
	visitor(city.m_iCitySupplyFlat);
	visitor(city.m_iDamageReductionFlat);
	visitor(city.m_bAllowsProductionTradeRoutes);
	visitor(city.m_bAllowsFoodTradeRoutes);
	visitor(city.m_bAllowPuppetPurchase);
	visitor(city.m_iCityAutomatonWorkersChange);
	visitor(city.m_iMaintenance);
	visitor(city.m_iHealRate);
	visitor(city.m_iNoOccupiedUnhappinessCount);
	visitor(city.m_iFoodBonusPerCityMajorityFollower);
	visitor(city.m_iLocalGainlessPillageCount);
	visitor(city.m_iFood);
	visitor(city.m_iMaxFoodKeptPercent);
	visitor(city.m_iOverflowProduction);
	visitor(city.m_iFeatureProduction);
	visitor(city.m_iMilitaryProductionModifier);
	visitor(city.m_iSpaceProductionModifier);
	visitor(city.m_iFreeExperience);
	visitor(city.m_iMaxAirUnits);
	visitor(city.m_iNukeModifier);
	visitor(city.m_iTradeRouteTargetBonus);
	visitor(city.m_iTradeRouteRecipientBonus);
	visitor(city.m_iTradeRouteSeaGoldBonus);
	visitor(city.m_iTradeRouteLandGoldBonus);
	visitor(city.m_iNumTradeRouteBonus);
	visitor(city.m_iCityConnectionTradeRouteGoldModifier);
	visitor(city.m_iCitySizeBoost);
	visitor(city.m_iSpecialistFreeExperience);
	visitor(city.m_iStrengthValue);
	visitor(city.m_iStrengthValueRanged);
	visitor(city.m_iDamage);
	visitor(city.m_iThreatValue);
	visitor(city.m_hGarrison);
	visitor(city.m_iResourceDemanded);
	visitor(city.m_iResourceDemandedCounter);
	visitor(city.m_iWeLoveTheKingDayCounter);
	visitor(city.m_iLastTurnGarrisonAssigned);
	visitor(city.m_iThingsProduced);
	visitor(city.m_iDemandResourceCounter);
	visitor(city.m_iResistanceTurns);
	visitor(city.m_iRazingTurns);
	visitor(city.m_iLowestRazingPop);
	visitor(city.m_iCountExtraLuxuries);
	visitor(city.m_iCheapestPlotInfluenceDistance);
	visitor(city.m_iEspionageModifier);
	visitor(city.m_iSpySecurityModifier);
	visitor(city.m_iSpySecurityModifierPerXPop);
	visitor(city.m_iNumPreviousSpyMissions);
	visitor(city.m_fDefensePerWonder);
	visitor(city.m_iConversionModifier);
	visitor(city.m_bNeverLost);
	visitor(city.m_bDrafted);
	visitor(city.m_bProductionAutomated);
	visitor(city.m_bLayoutDirty);
	visitor(city.m_bMadeAttack);
	visitor(city.m_bOccupied);
	visitor(city.m_bPuppet);
	visitor(city.m_bIgnoreCityForHappiness);
	visitor(city.m_bIndustrialRouteToCapital);
	visitor(city.m_iTerrainImprovementNeed);
	visitor(city.m_ePreviousOwner);
	visitor(city.m_eOriginalOwner);
	visitor(city.m_ePlayersReligion);
	visitor(city.m_aiSeaPlotYield);
	visitor(city.m_aiRiverPlotYield);
	visitor(city.m_aiLakePlotYield);
	visitor(city.m_aiSeaResourceYield);
	visitor(city.m_aiBaseYieldRateFromTerrain);
	visitor(city.m_aiBaseYieldRateFromBuildings);
	visitor(city.m_aiBaseYieldRateFromSpecialists);
	visitor(city.m_aiBaseYieldRateFromMisc);
	visitor(city.m_aiBaseYieldRateFromLeague);
	visitor(city.m_siPlots);
	visitor(city.m_iTotalScienceyAid);
	visitor(city.m_iTotalArtsyAid);
	visitor(city.m_aiChangeGrowthExtraYield);
	visitor(city.m_iHappinessFromEmpire);
	visitor(city.m_iUnhappinessFromEmpire);
	visitor(city.m_iCachedBasicNeedsMedian);
	visitor(city.m_iCachedGoldMedian);
	visitor(city.m_iCachedScienceMedian);
	visitor(city.m_iCachedCultureMedian);
	visitor(city.m_iCachedTechNeedModifier);
	visitor(city.m_iCachedEmpireSizeModifier);
	visitor(city.m_iYieldMediansCachedTurn);
	visitor(city.m_aiNumProjects);
	visitor(city.m_aiNumTimesAttackedThisTurn);
	visitor(city.m_aiYieldFromKnownPantheons);
	visitor(city.m_aiYieldFromVictory);
	visitor(city.m_aiYieldFromVictoryGlobal);
	visitor(city.m_aiYieldFromVictoryGlobalEraScaling);
	visitor(city.m_aiYieldFromVictoryGlobalInGoldenAge);
	visitor(city.m_aiYieldFromVictoryGlobalInGoldenAgeEraScaling);
	visitor(city.m_aiYieldFromPillage);
	visitor(city.m_aiYieldFromPillageGlobal);
	visitor(city.m_aiYieldFromGoldenAgeStart);
	visitor(city.m_aiYieldChangePerGoldenAge);
	visitor(city.m_aiYieldChangePerGoldenAgeCap);
	visitor(city.m_aiGoldenAgeYieldMod);
	visitor(city.m_aiYieldChangesPerLocalTheme);
	visitor(city.m_aiYieldFromUnitGiftGlobal);
	visitor(city.m_aiYieldFromWLTKD);
	visitor(city.m_aiYieldFromConstruction);
	visitor(city.m_aiYieldFromTech);
	visitor(city.m_aiYieldFromBirth);
	visitor(city.m_aiYieldFromBirthEraScaling);
	visitor(city.m_aiYieldFromUnitProduction);
	visitor(city.m_aiYieldFromBorderGrowth);
	visitor(city.m_aiYieldFromPolicyUnlock);
	visitor(city.m_aiYieldFromPurchase);
	visitor(city.m_aiYieldFromFaithPurchase);
	visitor(city.m_aiYieldFromUnitLevelUp);
	visitor(city.m_aiYieldFromCombatExperienceTimes100);
	visitor(city.m_aiYieldPerAlly);
	visitor(city.m_aiYieldPerFriend);
	visitor(city.m_aiYieldFromInternalTREnd);
	visitor(city.m_aiYieldFromInternationalTREnd);
	visitor(city.m_aiYieldFromInternalTR);
	visitor(city.m_aiYieldFromProcessModifier);
	visitor(city.m_aiYieldFromLongCount);
	visitor(city.m_aiYieldFromGPBirthScaledWithWriterBulb);
	visitor(city.m_aiYieldFromGPBirthScaledWithArtistBulb);
	visitor(city.m_miYieldFromGPBirthScaledWithPerTurnYield);
	visitor(city.m_aiSpecialistRateModifierFromBuildings);
	visitor(city.m_aiThemingYieldBonus);
	visitor(city.m_aiYieldFromSpyAttack);
	visitor(city.m_aiYieldFromSpyDefense);
	visitor(city.m_aiYieldFromSpyIdentify);
	visitor(city.m_aiYieldFromSpyDefenseOrID);
	visitor(city.m_aiYieldFromSpyRigElection);
	visitor(city.m_aiYieldChangesPerCityStrengthTimes100);
	visitor(city.m_aiNumTimesOwned);
	visitor(city.m_aiStaticCityYield);
	visitor(city.m_iTradePriorityLand);
	visitor(city.m_iTradePrioritySea);
	visitor(city.m_iUnitPurchaseCooldown);
	visitor(city.m_iUnitPurchaseCooldownCivilian);
	visitor(city.m_iUnitPurchaseCooldownMod);
	visitor(city.m_iUnitPurchaseCooldownCivilianMod);
	visitor(city.m_iUnitFaithPurchaseCooldown);
	visitor(city.m_iUnitFaithPurchaseCooldownCivilian);
	visitor(city.m_iBuildingPurchaseCooldown);
	visitor(city.m_iReligiousTradeModifier);
	visitor(city.m_iCityAirStrikeDefense);
	visitor(city.m_iFreeBuildingTradeTargetCity);
	visitor(city.m_iBaseTourism);
	visitor(city.m_iBaseTourismBeforeModifiers);
	visitor(city.m_iBorderObstacleCity);
	visitor(city.m_iBorderObstacleWater);
	visitor(city.m_iDeepWaterTileDamage);
	visitor(city.m_iNumNearbyMountains);
	visitor(city.m_iLocalUnhappinessMod);
	visitor(city.m_iExperiencePerGoldenAge);
	visitor(city.m_iExperiencePerGoldenAgeCap);
	visitor(city.m_bNoWarmonger);
	visitor(city.m_iEmpireSizeModifierReduction);
	visitor(city.m_iNoStarvationNonSpecialist);
	visitor(city.m_iDistressFlatReduction);
	visitor(city.m_iPovertyFlatReduction);
	visitor(city.m_iIlliteracyFlatReduction);
	visitor(city.m_iBoredomFlatReduction);
	visitor(city.m_iReligiousUnrestFlatReduction);
	visitor(city.m_iBasicNeedsMedianModifier);
	visitor(city.m_iGoldMedianModifier);
	visitor(city.m_iScienceMedianModifier);
	visitor(city.m_iCultureMedianModifier);
	visitor(city.m_iReligiousUnrestModifier);
	visitor(city.m_iTradeRouteSeaDistanceModifier);
	visitor(city.m_iTradeRouteLandDistanceModifier);
	visitor(city.m_iNukeInterceptionChance);
	visitor(city.m_aiEconomicValue);
	visitor(city.m_miUnitClassTrainingAllowed);
	visitor(city.m_miInstantYieldsTotal);
	visitor(city.m_aiBaseYieldRateFromReligion);
	visitor(city.m_aiBaseYieldRateFromCSAlliance);
	visitor(city.m_aiBaseYieldRateFromCSFriendship);
	visitor(city.m_aiYieldFromMinors);
	visitor(city.m_aiResourceQuantityPerXFranchises);
	visitor(city.m_aiYieldChangeFromCorporationFranchises);
	visitor(city.m_aiResourceQuantityFromPOP);
	visitor(city.m_iLandTourismBonus);
	visitor(city.m_iSeaTourismBonus);
	visitor(city.m_iAlwaysHeal);
	visitor(city.m_iResourceDiversityModifier);
	visitor(city.m_iNoUnhappfromXSpecialists);
	visitor(city.m_aiGreatWorkYieldChange);
	visitor(city.m_aiDamagePermyriad);
	visitor(city.m_aiYieldRateModifier);
	visitor(city.m_aiYieldPerPop);
	visitor(city.m_aiYieldPerReligion);
	visitor(city.m_aiPowerYieldRateModifier);
	visitor(city.m_aiResourceYieldRateModifier);
	visitor(city.m_aiExtraSpecialistYield);
	visitor(city.m_aiProductionToYieldModifier);
	visitor(city.m_aiDomainFreeExperience);
	visitor(city.m_aiDomainProductionModifier);
	visitor(city.m_abEverLiberated);
	visitor(city.m_abIsBestForWonder);
	visitor(city.m_abIsPurchased);
	visitor(city.m_abTraded);
	visitor(city.m_abIgnoredForExpansionBickering);
	visitor(city.m_abPaidAdoptionBonus);
	visitor(city.m_aiReligiousPressureModifier);
	visitor(city.m_iExtraBuildingMaintenance);
	visitor(city.m_paiNumTerrainWorked);
	visitor(city.m_paiNumFeaturelessTerrainWorked);
	visitor(city.m_paiNumFeatureWorked);
	visitor(city.m_paiNumImprovementWorked);
	visitor(city.m_strScriptData);
	visitor(city.m_iDamageTakenThisTurn);
	visitor(city.m_iDamageTakenLastTurn);
	visitor(city.m_paiNoResource);
	visitor(city.m_paiFreeResource);
	visitor(city.m_paiNumResourcesLocal);
	visitor(city.m_paiNumUnimprovedResourcesLocal);
	visitor(city.m_paiProjectProduction);
	visitor(city.m_paiUnitProduction);
	visitor(city.m_paiUnitProductionTime);
	visitor(city.m_paiUnitCombatFreeExperience);
	visitor(city.m_paiUnitCombatProductionModifier);
	visitor(city.m_paiFreePromotionCount);
	visitor(city.m_paiBuildingClassCulture);
	visitor(city.m_paiHurryModifier);
	visitor(city.m_iHappinessDelta);
	visitor(city.m_iPillagedPlots);
	visitor(city.m_iGrowthEvent);
	visitor(city.m_iEventGPPFromSpecialists);
	visitor(city.m_vEventGPPFromSpecialistsExpiryTurns);
	visitor(city.m_iGrowthFromTourism);
	visitor(city.m_iBuildingClassHappiness);
	visitor(city.m_iReligionHappiness);
	visitor(city.m_vClosestNeighbors);
	visitor(city.m_iBaseHappinessFromBuildings);
	visitor(city.m_iUnmoddedHappinessFromBuildings);
	visitor(city.m_bRouteToCapitalConnectedLastTurn);
	visitor(city.m_bRouteToCapitalConnectedThisTurn);
	visitor(city.m_strName);
	visitor(city.m_bOwedCultureBuilding);
	visitor(city.m_bOwedFoodBuilding);
	visitor(city.m_aiEventCooldown);
	visitor(city.m_abEventActive);
	visitor(city.m_abEventChoiceActive);
	visitor(city.m_abEventChoiceFired);
	visitor(city.m_abEventFired);
	visitor(city.m_aiEventChoiceDuration);
	visitor(city.m_aiEventIncrement);
	visitor(city.m_aiEventCityYield);
	visitor(city.m_aiEventCityYieldModifier);
	visitor(city.m_iEventHappiness);
	visitor(city.m_iCityEventCooldown);
	visitor(city.m_bIsColony);
	visitor(city.m_iProvinceLevel);
	visitor(city.m_iOrganizedCrime);
	visitor(city.m_iResistanceCounter);
	visitor(city.m_iPlagueCounter);
	visitor(city.m_iPlagueTurns);
	visitor(city.m_iPlagueType);
	visitor(city.m_iSappedTurns);
	visitor(city.m_iBuildingProductionBlockedTurns);
	visitor(city.m_iNoTourismTurns);
	visitor(city.m_iLoyaltyCounter);
	visitor(city.m_iDisloyaltyCounter);
	visitor(city.m_iLoyaltyStateType);
	visitor(city.m_aiYieldModifierFromHappiness);
	visitor(city.m_aiYieldModifierFromHealth);
	visitor(city.m_aiYieldModifierFromCrime);
	visitor(city.m_aiYieldModifierFromDevelopment);
	visitor(city.m_aiYieldFromHappiness);
	visitor(city.m_aiYieldFromHealth);
	visitor(city.m_aiYieldFromCrime);
	visitor(city.m_aiYieldFromDevelopment);
	visitor(city.m_aiTempCaptureData);
	visitor(city.m_abTempCaptureData);
	visitor(city.m_bIsPendingCapture);
	visitor(city.m_iPopulationRank);
	visitor(city.m_bPopulationRankValid);
	visitor(city.m_aiBaseYieldRank);
	visitor(city.m_abBaseYieldRankValid);
	visitor(city.m_aiYieldRank);
	visitor(city.m_abYieldRankValid);
	visitor(city.m_abOwedChosenBuilding);
	visitor(city.m_abBuildingInvestment);
	visitor(city.m_aiBuildingCostInvestmentReduction);
	visitor(city.m_abUnitInvestment);
	visitor(city.m_aiUnitCostInvestmentReduction);
	visitor(city.m_abBuildingConstructed);
	visitor(city.m_abIsBuildingHidden);
	visitor(city.m_inumHiddenBuildings);
	visitor(city.m_iVassalLevyEra);

	visitor(*city.m_pCityBuildings);

	// m_orderQueue
	{
		uint32 uLength = 0;
		if (bSaving)
			uLength = uint32(city.m_orderQueue.getLength());
		visitor(uLength);

		for (uint32 uIdx = 0; uIdx < uLength; ++uIdx)
		{
			OrderData order;
			if (bSaving)
				order = *city.m_orderQueue.getAt(uIdx);

			visitor(order.eOrderType);

			// Now we have to translate the data because most of them contain indices into Infos tables and it is very bad to save an index since the table order can change
			switch (order.eOrderType)
			{
			case ORDER_TRAIN:
				visitor.template as<UnitTypes>(order.iData1);
				visitor.template as<UnitAITypes>(order.iData2);
				break;

			case ORDER_CONSTRUCT:
				visitor.template as<BuildingTypes>(order.iData1);
				visitor(order.iData2);
				break;

			case ORDER_CREATE:
				visitor.template as<ProjectTypes>(order.iData1);
				visitor(order.iData2);
				break;

			case ORDER_MAINTAIN:
				visitor.template as<ProcessTypes>(order.iData1);
				visitor(order.iData2);
				break;

			default:
				ASSERT_DEBUG(false, "order.eOrderType failed to match a valid option");
				visitor(order.iData1);
				visitor(order.iData2);
				break;
			}

			visitor(order.bSave);
			visitor(order.bRush);

			if (bLoading)
			{
				bool bIsValid = false;
				switch (order.eOrderType)
				{
				case NO_ORDER:
					break;

				case ORDER_TRAIN:
					bIsValid = GC.getUnitInfo(UnitTypes(order.iData1)) != NULL;
					break;

				case ORDER_CONSTRUCT:
					bIsValid = GC.getBuildingInfo(BuildingTypes(order.iData1)) != NULL;
					break;

				case ORDER_CREATE:
					bIsValid = GC.getProjectInfo(ProjectTypes(order.iData1)) != NULL;
					break;

				case ORDER_MAINTAIN:
					bIsValid = GC.getProcessInfo(ProcessTypes(order.iData1)) != NULL;
					break;
				}

				ASSERT_DEBUG(bIsValid, "Unit in build queue is invalid");
				if (bIsValid)
					city.m_orderQueue.insertAtEnd(&order);
			}
		}
	}

	visitor(*city.m_pCityStrategyAI);
	if (bLoading && city.m_eOwner != NO_PLAYER)
		GET_PLAYER(city.getOwner()).GetFlavorManager()->AddFlavorRecipient(city.m_pCityStrategyAI, false /* bPropogateFlavorValues */);

	visitor(*city.m_pCityCitizens);
	visitor(*city.m_pCityReligions);
	visitor(*city.m_pEmphases);
	visitor(*city.m_pCityEspionage);

	visitor(city.m_yieldChanges);
	visitor(city.m_eventYields);
	visitor(city.m_ppiGreatPersonProgressFromConstruction);
	visitor(city.m_aiYieldPerPopInEmpire);
	visitor(city.m_miTechEnhancedYields);
	visitor(city.m_miGreatPersonPointFromConstruction);
}

//	--------------------------------------------------------------------------------
void CvCity::read(FDataStream& kStream)
{
	VALIDATE_OBJECT();
	// Init data before load
	reset();

	// Perform shared serialize
	CvStreamLoadVisitor serialVisitor(kStream);
	Serialize(*this, serialVisitor);

#if defined(MOD_BALANCE_CORE)
	GetCityStrategyAI()->PrecalcYieldStats();
#endif

	CvCityManager::OnCityCreated(this);
}

//	--------------------------------------------------------------------------------
void CvCity::write(FDataStream& kStream) const
{
	VALIDATE_OBJECT();

	// Perform shared serialize
	CvStreamSaveVisitor serialVisitor(kStream);
	Serialize(*this, serialVisitor);
}


//	--------------------------------------------------------------------------------
bool CvCity::isValidBuildingLocation(BuildingTypes eBuilding) const
{
	if (eBuilding == NO_BUILDING)
		return false;

	VALIDATE_OBJECT();

	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

	// Requires coast
	if (pkBuildingInfo->IsWater())
	{
		// Pass no parameter for fast check
		if (!isCoastal() || !isCoastal(pkBuildingInfo->GetMinAreaSize()))
			return false;
	}

	// Requires River
	if (pkBuildingInfo->IsRiver())
	{
		if (!plot()->isRiver())
			return false;
	}

	// Requires Fresh Water
	if (pkBuildingInfo->IsFreshWater())
	{
		if (!plot()->isFreshWater())
			return false;
	}

	// Requires no fresh water
	if (pkBuildingInfo->IsNoWater())
	{
		if (plot()->isFreshWater())
			return false;
	}

	// Requires no river
	if (pkBuildingInfo->IsNoRiver())
	{
		if (plot()->isRiver())
			return false;
	}

	// Must not be on coast
	if (pkBuildingInfo->IsNoCoast())
	{
		if (isCoastal(-1))
			return false;
	}

	// Capital Only
	if (pkBuildingInfo->IsCapitalOnly())
	{
		if (!isCapital())
		{
			return false;
		}
	}

	// Requires adjacent Mountain
	if (pkBuildingInfo->IsMountain())
	{
		bool bFoundMountain = false;

		CvPlot* pAdjacentPlot = NULL;
		for (int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; iDirectionLoop++)
		{
			pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iDirectionLoop));

			if (pAdjacentPlot != NULL)
			{
				if (pAdjacentPlot->isMountain())
				{
					bFoundMountain = true;
					break;
				}
			}
		}

		if (!bFoundMountain)
			return false;
	}

	// Requires nearby Mountain (within 2 tiles)
	if (pkBuildingInfo->IsNearbyMountainRequired())
	{
		bool bFoundMountain = false;

		const int iMountainRange = 2;
		CvPlot* pLoopPlot = NULL;

		for (int iDX = -iMountainRange; iDX <= iMountainRange; iDX++)
		{
			for (int iDY = -iMountainRange; iDY <= iMountainRange; iDY++)
			{
				pLoopPlot = plotXYWithRangeCheck(getX(), getY(), iDX, iDY, iMountainRange);
				if (pLoopPlot)
				{
					if (pLoopPlot->isMountain() && !pLoopPlot->IsNaturalWonder() && pLoopPlot->getOwner() == getOwner())
					{
						bFoundMountain = true;
						break;
					}
				}
			}

			if (bFoundMountain)
				break;
		}

		if (!bFoundMountain)
			return false;
	}

	// Requires Hills
	if (pkBuildingInfo->IsHill())
	{
		if (!plot()->isHills())
			return false;
	}

	// Requires Flat
	if (pkBuildingInfo->IsFlat())
	{
		if (plot()->isHills())
			return false;
	}

	// Requires city not built on certain terrain?
	TerrainTypes eTerrainProhibited = (TerrainTypes)pkBuildingInfo->GetProhibitedCityTerrain();
	if (eTerrainProhibited != NO_TERRAIN)
	{
		if (plot()->getTerrainType() == eTerrainProhibited)
		{
			return false;
		}
	}

	// Requires city to be on or next to a particular terrain type?
	TerrainTypes eTerrainRequired = (TerrainTypes)pkBuildingInfo->GetNearbyTerrainRequired();
	if (eTerrainRequired != NO_TERRAIN)
	{
		bool bFoundTerrain = false;

		// City on the right terrain?
		if (plot()->getTerrainType() == eTerrainRequired)
			bFoundTerrain = true;

		// Check adjacent plots
		if (!bFoundTerrain)
		{
			CvPlot* pAdjacentPlot = NULL;
			for (int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; iDirectionLoop++)
			{
				pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iDirectionLoop));

				if (pAdjacentPlot != NULL)
				{
					// City adjacent to the right terrain?
					if (pAdjacentPlot->getTerrainType() == eTerrainRequired)
					{
						bFoundTerrain = true;
						break;
					}
				}
			}
		}

		// Didn't find nearby required terrain
		if (!bFoundTerrain)
			return false;
	}

	if (pkBuildingInfo->IsAnyBodyOfWater())
	{
		return plot()->isFreshWater() || isCoastal(pkBuildingInfo->GetMinAreaSize());
	}

	return true;
}


// CACHE: cache frequently used values
///////////////////////////////////////

//	--------------------------------------------------------------------------------
void CvCity::invalidatePopulationRankCache()
{
	VALIDATE_OBJECT();
	m_bPopulationRankValid = false;
}

//	--------------------------------------------------------------------------------
void CvCity::invalidateYieldRankCache(YieldTypes eYield)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eYield >= NO_YIELD && eYield < NUM_YIELD_TYPES, "invalidateYieldRankCache passed bogus yield index");

	if (eYield == NO_YIELD)
	{
		for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
		{
			m_abBaseYieldRankValid[iI] = false;
			m_abYieldRankValid[iI] = false;
		}
	}
	else
	{
		m_abBaseYieldRankValid[eYield] = false;
		m_abYieldRankValid[eYield] = false;
	}
}

//	--------------------------------------------------------------------------------
bool CvCity::isMadeAttack() const
{
	VALIDATE_OBJECT();
	return m_bMadeAttack;
}

//	--------------------------------------------------------------------------------
void CvCity::setMadeAttack(bool bNewValue)
{
	VALIDATE_OBJECT();
	m_bMadeAttack = bNewValue;
}

void CvCity::ChangeNumTimesAttackedThisTurn(PlayerTypes ePlayer, int iValue)
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(ePlayer >= 0, "ePlayer expected to be >= 0");
	ASSERT_DEBUG(ePlayer < REALLY_MAX_PLAYERS, "ePlayer expected to be < NUM_DOMAIN_TYPES");
	m_aiNumTimesAttackedThisTurn[ePlayer] = m_aiNumTimesAttackedThisTurn[ePlayer] + iValue;
}
int CvCity::GetNumTimesAttackedThisTurn(PlayerTypes ePlayer) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(ePlayer >= 0, "eIndex expected to be >= 0");
	ASSERT_DEBUG(ePlayer < REALLY_MAX_PLAYERS, "eIndex expected to be < NUM_DOMAIN_TYPES");
	return m_aiNumTimesAttackedThisTurn[ePlayer];
}

int CvCity::getCityBuildingBombardRange() const
{
	VALIDATE_OBJECT();
	return m_iCityBuildingBombardRange;
}
void CvCity::changeCityBuildingBombardRange(int iValue)
{
	if (iValue != 0)
	{
		m_iCityBuildingBombardRange += iValue;
	}
}
bool CvCity::getCityIndirectFire() const
{
	VALIDATE_OBJECT();
	return m_iCityIndirectFire > 0;
}
void CvCity::changeCityIndirectFire(int iValue)
{
	if (iValue != 0)
	{
		m_iCityIndirectFire += iValue;
	}
}

int CvCity::getCityBuildingRangeStrikeModifier() const
{
	VALIDATE_OBJECT();
	return m_iCityBuildingRangeStrikeModifier;
}
void CvCity::changeCityBuildingRangeStrikeModifier(int iValue)
{
	if (iValue != 0)
	{
		m_iCityBuildingRangeStrikeModifier += iValue;
	}
}

int CvCity::getGarrisonRangedAttackModifier() const
{
	VALIDATE_OBJECT();
	return m_iGarrisonRangedAttackModifier;
}
void CvCity::changeGarrisonRangedAttackModifier(int iValue)
{
	if (iValue != 0)
	{
		m_iGarrisonRangedAttackModifier += iValue;
	}
}


#if defined(MOD_EVENTS_CITY_BOMBARD)
//	--------------------------------------------------------------------------------
int CvCity::getBombardRange() const
{
	bool bIndirectFireAllowed = false;
	return getBombardRange(bIndirectFireAllowed);
}

//	--------------------------------------------------------------------------------
int CvCity::getBombardRange(bool& bIndirectFireAllowed) const
{
	VALIDATE_OBJECT();

	if (MOD_CORE_NO_RANGED_ATTACK_FROM_CITIES)
		return 0;

	if (MOD_BALANCE_CORE_BOMBARD_RANGE_BUILDINGS)
	{
		bIndirectFireAllowed = getCityIndirectFire();
		return 1 + getCityBuildingBombardRange();
	}

	if (MOD_EVENTS_CITY_BOMBARD) {
		int iValue = 0;
		if (GAMEEVENTINVOKE_VALUE(iValue, GAMEEVENT_GetBombardRange, getOwner(), GetID()) == GAMEEVENTRETURN_VALUE) {
			// Defend against modder stupidity!
			if (iValue != 0 && ::abs(iValue) <= /*2*/ GD_INT_GET(MAX_CITY_ATTACK_RANGE)) {
				bIndirectFireAllowed = (iValue < 0);
				return ::abs(iValue);
			}
		}
	}

	bIndirectFireAllowed = /*1*/ GD_INT_GET(CAN_CITY_USE_INDIRECT_FIRE) > 0;
	return /*2*/ GD_INT_GET(CITY_ATTACK_RANGE);
}
#endif

//	--------------------------------------------------------------------------------
bool CvCity::canRangeStrike() const
{
	VALIDATE_OBJECT();

	if (MOD_CORE_NO_RANGED_ATTACK_FROM_CITIES)
		return false;

	// Can't shoot when in resistance
	if (IsResistance() || IsRazing())
		return false;

	// Can't shoot if sapped
	if (GetSappedTurns() > 0)
		return false;

	// Can't shoot if we have no HP left (shouldn't really ever happen)
	if (getDamage() == GetMaxHitPoints())
		return false;

	return true;
}

//	--------------------------------------------------------------------------------
bool CvCity::CanRangeStrikeNow() const
{
	if (!canRangeStrike())
		return false;

	if (isMadeAttack())
		return false;

	int iRange = getBombardRange();

	CvPlot* pPlot = plot();
	for (int iRing=1; iRing<=min(5,iRange); iRing++)
	{
		for (int i = RING_PLOTS[iRing-1]; i < RING_PLOTS[iRing]; i++)
		{
			CvPlot* pTargetPlot = iterateRingPlots(pPlot, i);
			if (!pTargetPlot)
				continue;

			//this checks everything, visibility, LOS, target type etc
			if (canRangeStrikeAt(pTargetPlot->getX(), pTargetPlot->getY()))
				return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
/// Does this City have a Building that allows it to Range Strike?
bool CvCity::IsHasBuildingThatAllowsRangeStrike() const
{
	VALIDATE_OBJECT();
	bool bHasBuildingThatAllowsRangeStrike = false;

	for (int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

		if (pkBuildingInfo)
		{
			// Has this Building
			if (GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
			{
				// Does it grant Range Strike ability?
				if (pkBuildingInfo->IsAllowsRangeStrike())
				{
					bHasBuildingThatAllowsRangeStrike = true;
					break;
				}
			}
		}
	}

	return bHasBuildingThatAllowsRangeStrike;
}

//	--------------------------------------------------------------------------------
bool CvCity::canRangeStrikeAt(int iX, int iY) const
{
	VALIDATE_OBJECT();
	if (!canRangeStrike())
		return false;

	const CvPlot* pTargetPlot = GC.getMap().plot(iX, iY);

	if (!pTargetPlot)
		return false;

	if (!pTargetPlot->isVisible(getTeam()))
		return false;

	bool bIndirectFire = false;
	int iAttackRange = getBombardRange(bIndirectFire);

	if (plotDistance(plot()->getX(), plot()->getY(), pTargetPlot->getX(), pTargetPlot->getY()) > iAttackRange)
		return false;

	if (!bIndirectFire && !plot()->canSeePlot(pTargetPlot, getTeam(), iAttackRange, NO_DIRECTION))
		return false;

	// Can't attack other cities directly
	if (pTargetPlot->isCity())
		return false;

	if (!canRangedStrikeTarget(*pTargetPlot))
		return false;

	return true;
}

//	----------------------------------------------------------------------------
CityTaskResult CvCity::rangeStrike(int iX, int iY)
{
	VALIDATE_OBJECT();
	CvPlot* pPlot = GC.getMap().plot(iX, iY);
	if (!pPlot)
		return TASK_ABORTED;

	if (isMadeAttack())
		return TASK_ABORTED;

	// Apparently it's possible for someone to fire during another player's turn
	if (!GET_PLAYER(getOwner()).isTurnActive())
		return TASK_ABORTED;

	if (!canRangeStrikeAt(iX, iY))
		return TASK_ABORTED;

	if (pPlot->isCity())
		return TASK_ABORTED;

	CvUnit* pDefender = rangedStrikeTarget(pPlot);

	setMadeAttack(true);

	CvCombatInfo kCombatInfo;
	CvUnitCombat::GenerateRangedCombatInfo(*this, pDefender, *pPlot, &kCombatInfo);

	uint uiParentEventID = 0;
	CityTaskResult eResult = TASK_ABORTED;
	if (!CvPreGame::quickCombat())
	{
		// Center camera here!
		bool isTargetVisibleToActivePlayer = pPlot->isActiveVisible();
		if (isTargetVisibleToActivePlayer)
		{
			CvInterfacePtr<ICvPlot1> pDllPlot = GC.WrapPlotPointer(pPlot);
			DLLUI->lookAt(pDllPlot.get(), CAMERALOOKAT_NORMAL);
		}

		kCombatInfo.setVisualizeCombat(pPlot->isActiveVisible());

		CvInterfacePtr<ICvCombatInfo1> pDllCombatInfo(new CvDllCombatInfo(&kCombatInfo));
		uiParentEventID = gDLL->GameplayCityCombat(pDllCombatInfo.get());

		// Set the combat units so that other missions do not continue until combat is over.
		pDefender->setCombatCity(this);
		setCombatUnit(pDefender);
		eResult = TASK_QUEUED;
	}
	else
	{
		eResult = TASK_COMPLETED;
	}

	CvUnitCombat::ResolveCombat(kCombatInfo, uiParentEventID);

	return eResult;
}

//	--------------------------------------------------------------------------------
bool CvCity::canRangedStrikeTarget(const CvPlot& targetPlot) const
{
	VALIDATE_OBJECT();
	return (rangedStrikeTarget(&targetPlot) != NULL);
}

CvUnit* CvCity::getBestRangedStrikeTarget() const
{
	if (!canRangeStrike())
		return NULL;

	if (isMadeAttack())
		return NULL;

	int iRange = getBombardRange();

	int iBestScore = 0;
	CvUnit* pBestTarget = NULL;

	CvPlot* pPlot = plot();
	for (int iRing=1; iRing<=min(5,iRange); iRing++)
	{
		for (int i = RING_PLOTS[iRing-1]; i < RING_PLOTS[iRing]; i++)
		{
			CvPlot* pTargetPlot = iterateRingPlots(pPlot, i);
			if (!pTargetPlot)
				continue;

			//this checks everything, visibility, LOS, target type etc
			if (canRangeStrikeAt(pTargetPlot->getX(), pTargetPlot->getY()))
			{
				//a bit redundant with the internal of canRangeStrikeAt but that's life
				CvUnit* pTarget = rangedStrikeTarget(pTargetPlot);
				int iDamage = rangeCombatDamage(pTarget, false, NULL);
				if (iDamage > iBestScore)
				{
					iBestScore = iDamage;
					pBestTarget = pTarget;
				}
			}
		}
	}

	return pBestTarget;
}

//	--------------------------------------------------------------------------------
CvUnit* CvCity::rangedStrikeTarget(const CvPlot* pPlot) const
{
	VALIDATE_OBJECT();
	CvUnit* pDefender = pPlot->getBestDefender(NO_PLAYER, getOwner(), NULL, true, false, false, /*bNoncombatAllowed*/ true);

	if (pDefender)
	{
		if (!pDefender->IsDead())
		{
			if (MOD_GLOBAL_SUBS_UNDER_ICE_IMMUNITY)
			{
				// If the defender is a sub and the plot is ice, return NULL
				if (pDefender->getInvisibleType() == 0 && pPlot->getFeatureType() == FEATURE_ICE)
				{
					return NULL;
				}
			}

			return pDefender;
		}
	}

	return NULL;
}

//	--------------------------------------------------------------------------------
int CvCity::rangeCombatUnitDefense(const CvUnit* pDefender, const CvPlot* pInPlot, bool bQuickAndDirty) const
{
	if (pInPlot == NULL)
		pInPlot = pDefender->plot();

	int iDefenderStrength = 0;

	if (pDefender->CanEverEmbark() && pInPlot->needsEmbarkation(pDefender))
	{
		iDefenderStrength = pDefender->GetEmbarkedUnitDefense();
	}
	// Use Ranged combat value for defender, UNLESS it's an Impi (ranged support)
	else if (!pDefender->isRangedSupportFire() && pDefender->IsCanAttackRanged())
	{
		// Have to consider embarkation explicitly
		if ((!pInPlot && pDefender->isEmbarked()) || (pInPlot && pInPlot->needsEmbarkation(pDefender) && pDefender->CanEverEmbark()))
			iDefenderStrength = pDefender->GetEmbarkedUnitDefense();
		else
			iDefenderStrength = pDefender->GetMaxRangedCombatStrength(NULL, this, false, pInPlot, plot(), false, bQuickAndDirty);
	}
	else
	{
		iDefenderStrength = pDefender->GetMaxDefenseStrength(pInPlot, NULL, NULL, /*bFromRangedAttack*/ true, bQuickAndDirty);
	}

	return iDefenderStrength;
}

//	--------------------------------------------------------------------------------
int CvCity::rangeCombatDamage(const CvUnit* pDefender, bool bIncludeRand, const CvPlot* pInPlot, bool bQuickAndDirty) const
{
	if (pDefender == NULL)
		return 0;

	// If this is a defenseless unit, do a fixed amount of damage
	if (!pDefender->IsCanDefend())
		return /*40*/ GD_INT_GET(NONCOMBAT_UNIT_RANGED_DAMAGE);

	if (pInPlot == NULL)
		pInPlot = pDefender->plot();

	int iAttackerStrength = getStrengthValue(true, false, pDefender);
	int iDefenderStrength = rangeCombatUnitDefense(pDefender, pInPlot, bQuickAndDirty);
	int iModifier = 0 - pDefender->GetDamageReductionCityAssault(); //watch the minus
	CvSeeder randomSeed;
	if (bIncludeRand)
	{
		randomSeed
			.mixAssign(pDefender->plot()->GetPseudoRandomSeed())
			.mixAssign(iAttackerStrength)
			.mixAssign(iDefenderStrength);
	}

	return CvUnitCombat::DoDamageMath(
		iAttackerStrength,
		iDefenderStrength,
		/*2400*/ GD_INT_GET(RANGE_ATTACK_SAME_STRENGTH_MIN_DAMAGE), //ignore the min part, it's misleading
		/*1200*/ GD_INT_GET(RANGE_ATTACK_SAME_STRENGTH_POSSIBLE_EXTRA_DAMAGE),
		bIncludeRand,
		randomSeed,
		iModifier) / 100;
}

//	--------------------------------------------------------------------------------
int CvCity::GetAirStrikeDefenseDamage(const CvUnit* pAttacker, bool bIncludeRand) const
{
	//base value
	int iBaseValue = 15;

	if (MOD_BALANCE_CORE_MILITARY_PROMOTION_ADVANCED)
	{
		iBaseValue = GetCityAirStrikeDefense();

		if (pAttacker != NULL && pAttacker->GetInterceptionDefenseDamageModifier() != 0)
		{
			iBaseValue = iBaseValue * (100 + pAttacker->GetInterceptionDefenseDamageModifier());
			iBaseValue /= 100;
		}
	}

	if (bIncludeRand)
		return iBaseValue + GC.getGame().randRangeExclusive(0, 10, plot()->GetPseudoRandomSeed().mix(GET_PLAYER(getOwner()).GetPseudoRandomSeed()));
	else
		return iBaseValue;
}

bool CvCity::IsEnemyInRange(int iRange, bool bMustBeAbleToAttack)
{
	iRange = range(iRange, 1, 5);
	for (int i = RING0_PLOTS; i < RING_PLOTS[iRange]; i++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(plot(), i);
		if (!pLoopPlot)
			continue;

		if (bMustBeAbleToAttack)
		{
			if (canRangeStrikeAt(pLoopPlot->getX(), pLoopPlot->getY()))
				return true;
		}
		else
		{
			if (pLoopPlot->isEnemyUnit(getOwner(), true, true))
				return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
void CvCity::DoNearbyEnemy()
{
	// Can't actually range strike
	if (!canRangeStrike())
		return;

	if (isMadeAttack())
		return;

	int iSearchRange = getBombardRange();

	if (IsEnemyInRange(iSearchRange, true))
	{
		// Notification
		CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
		if (pNotifications)
		{
			Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_CAN_SHOOT");
			strText << getNameKey();
			Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_CAN_SHOOT");
			strSummary << getNameKey();
			pNotifications->Add(NOTIFICATION_CITY_RANGE_ATTACK, strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), GetID());
		}
	}
}

bool CvCity::IsInDanger(PlayerTypes eEnemy) const
{
	//unit strength doesn't matter if the city is low on hitpoints
	if (isInDangerOfFalling())
		return true;

	//cannot use the tactical zone here, because it's not specific to a certain enemy
	//but we can use the danger plots to exclude some cities
	if (GET_PLAYER(getOwner()).GetPlotDanger(this) == 0)
		return false;

	int iFriendlyLandPower = GetPower();
	int iFriendlySeaPower = 0;
	int iFriendlyOtherPower = 0;
	int iEnemyLandPower = 0;
	int iEnemySeaPower = 0;
	int iEnemyOtherPower = 0;
	bool bFriendlyGeneralInTheVicinity = false;
	bool bFriendlyAdmiralInTheVicinity = false;
	bool bEnemyGeneralInTheVicinity = false;
	bool bEnemyAdmiralInTheVicinity = false;

	for (int i = RING0_PLOTS; i < RING4_PLOTS; i++)
	{
		CvPlot* pPlot = iterateRingPlots(plot(), i);
		if (!pPlot)
			continue;

		for (int j = 0; j < pPlot->getNumUnits(); j++)
		{
			CvUnit* pUnit = pPlot->getUnitByIndex(j);
			if (pUnit->IsCombatUnit())
			{
				if (pUnit->getTeam() == getTeam())
				{
					DomainTypes eDomainType = pUnit->getDomainType();
					switch (eDomainType)
					{
					case DOMAIN_LAND:
						iFriendlyLandPower += pUnit->GetPower();
						break;
					case DOMAIN_SEA:
						iFriendlySeaPower += pUnit->GetPower();
						break;
					default:
						iFriendlyOtherPower += pUnit->GetPower();
					}
				}
				else if (pUnit->getOwner() == eEnemy)
				{
					DomainTypes eDomainType = pUnit->getDomainType();
					switch (eDomainType)
					{
					case DOMAIN_LAND:
						iEnemyLandPower += pUnit->GetPower();
						break;
					case DOMAIN_SEA:
						iEnemySeaPower += pUnit->GetPower();
						break;
					default:
						iEnemyOtherPower += pUnit->GetPower();
					}
				}
			}
			if (pUnit->GetGreatGeneralCount() > 0)
			{
				if (pUnit->getTeam() == getTeam())
					bFriendlyGeneralInTheVicinity = true;
				if (pUnit->getOwner() == eEnemy)
					bEnemyGeneralInTheVicinity = true;
			}
			if (pUnit->GetGreatAdmiralCount() > 0)
			{
				if (pUnit->getTeam() == getTeam())
					bFriendlyAdmiralInTheVicinity = true;
				if (pUnit->getOwner() == eEnemy)
					bEnemyAdmiralInTheVicinity = true;
			}
		}
	}

	if (bFriendlyGeneralInTheVicinity)
	{
		iFriendlyLandPower *= 11;
		iFriendlyLandPower /= 10;
	}
	if (bFriendlyAdmiralInTheVicinity)
	{
		iFriendlySeaPower *= 11;
		iFriendlySeaPower /= 10;
	}

	if (bEnemyGeneralInTheVicinity)
	{
		iEnemyLandPower *= 11;
		iEnemyLandPower /= 10;
	}
	if (bEnemyAdmiralInTheVicinity)
	{
		iEnemySeaPower *= 11;
		iEnemySeaPower /= 10;
	}

	// Final tally and assessment
	int iEnemyPower = iEnemyLandPower + iEnemySeaPower + iEnemyOtherPower;
	int iFriendlyPower = iFriendlyLandPower + iFriendlySeaPower + iFriendlyOtherPower;
	return iEnemyPower > iFriendlyPower;
}

bool CvCity::IsInDangerFromPlayers(vector<PlayerTypes>& vWarAllies) const
{
	if (vWarAllies.empty())
		return false;

	//unit strength doesn't matter if the city is low on hitpoints
	if (isInDangerOfFalling(true))
		return true;

	//cannot use the tactical zone here, because it's not specific to a certain enemy
	//but we can use the danger plots to exclude some cities
	if (GET_PLAYER(getOwner()).GetPlotDanger(this) == 0)
		return false;

	int iFriendlyLandPower = GetPower();
	int iFriendlySeaPower = 0;
	int iFriendlyOtherPower = 0;
	bool bFriendlyGeneralInTheVicinity = false;
	bool bFriendlyAdmiralInTheVicinity = false;

	// Store each enemy's power by domain in weighted vectors to facilitate the Great General/Admiral buffs applying to those players only
	vector<PlayerTypes> vOtherGGNearby;
	vector<PlayerTypes> vOtherGANearby;
	CvWeightedVector<PlayerTypes> veEnemyLandPowers;
	CvWeightedVector<PlayerTypes> veEnemySeaPowers;
	CvWeightedVector<PlayerTypes> veEnemyOtherPowers;
	std::map<PlayerTypes, int> vectorIndices;
	int iIndex = 0;
	for (std::vector<PlayerTypes>::iterator it = vWarAllies.begin(); it != vWarAllies.end(); ++it)
	{
		veEnemyLandPowers.push_back(*it, 0);
		veEnemySeaPowers.push_back(*it, 0);
		veEnemyOtherPowers.push_back(*it, 0);
		vectorIndices.insert(std::make_pair(*it, iIndex));
		iIndex++;
	}

	for (int i = RING0_PLOTS; i < RING4_PLOTS; i++)
	{
		CvPlot* pPlot = iterateRingPlots(plot(), i);
		if (!pPlot)
			continue;

		for (int j = 0; j < pPlot->getNumUnits(); j++)
		{
			CvUnit* pUnit = pPlot->getUnitByIndex(j);
			if (pUnit->IsCombatUnit() || pUnit->IsCanAttackRanged())
			{
				if (pUnit->getTeam() == getTeam())
				{
					DomainTypes eDomainType = pUnit->getDomainType();
					switch (eDomainType)
					{
					case DOMAIN_LAND:
						iFriendlyLandPower += pUnit->GetPower();
						break;
					case DOMAIN_SEA:
						iFriendlySeaPower += pUnit->GetPower();
						break;
					default:
						iFriendlyOtherPower += pUnit->GetPower();
					}
				}
				else
				{
					std::map<PlayerTypes, int>::iterator vectorIndexFinder = vectorIndices.find(pUnit->getOwner());
					if (vectorIndexFinder != vectorIndices.end())
					{
						iIndex = vectorIndexFinder->second;
						DomainTypes eDomainType = pUnit->getDomainType();
						switch (eDomainType)
						{
						case DOMAIN_LAND:
							veEnemyLandPowers.IncreaseWeight(iIndex, pUnit->GetPower());
							break;
						case DOMAIN_SEA:
							veEnemySeaPowers.IncreaseWeight(iIndex, pUnit->GetPower());
							break;
						default:
							veEnemyOtherPowers.IncreaseWeight(iIndex, pUnit->GetPower());
						}
					}
				}
			}
			else if (pUnit->canNuke())
			{
				// Is there a high chance of total interception?
				if (pUnit->GetNukeDamageLevel() == 1 && getNukeInterceptionChance() >= 75)
					continue;

				// Regardless of comparative unit power, a city is in danger if an enemy nuke is nearby.
				std::map<PlayerTypes, int>::iterator vectorIndexFinder = vectorIndices.find(pUnit->getOwner());
				if (vectorIndexFinder != vectorIndices.end())
					return true;
			}
			if (pUnit->GetGreatGeneralCount() > 0)
			{
				if (pUnit->getTeam() == getTeam())
					bFriendlyGeneralInTheVicinity = true;
				else
					vOtherGGNearby.push_back(pUnit->getOwner());
			}
			if (pUnit->GetGreatAdmiralCount() > 0)
			{
				if (pUnit->getTeam() == getTeam())
					bFriendlyAdmiralInTheVicinity = true;
				else
					vOtherGANearby.push_back(pUnit->getOwner());
			}
		}
	}

	// Tally up friendly power
	if (bFriendlyGeneralInTheVicinity)
	{
		iFriendlyLandPower *= 11;
		iFriendlyLandPower /= 10;
	}
	if (bFriendlyAdmiralInTheVicinity)
	{
		iFriendlySeaPower *= 11;
		iFriendlySeaPower /= 10;
	}
	int iFriendlyPower = iFriendlyLandPower + iFriendlySeaPower + iFriendlyOtherPower;


	// Tally up enemy power
	int iEnemyPower = 0;
	for (int i = 0; i < veEnemyLandPowers.size(); i++)
	{
		PlayerTypes eIndex = veEnemyLandPowers.GetElement(i);
		int iEnemyLandPower = veEnemyLandPowers.GetWeight(i);

		if (std::find(vOtherGGNearby.begin(), vOtherGGNearby.end(), eIndex) != vOtherGGNearby.end())
		{
			iEnemyLandPower *= 11;
			iEnemyLandPower /= 10;
		}

		iEnemyPower += iEnemyLandPower;
	}
	for (int i = 0; i < veEnemySeaPowers.size(); i++)
	{
		PlayerTypes eIndex = veEnemySeaPowers.GetElement(i);
		int iEnemySeaPower = veEnemySeaPowers.GetWeight(i);

		if (std::find(vOtherGANearby.begin(), vOtherGANearby.end(), eIndex) != vOtherGANearby.end())
		{
			iEnemySeaPower *= 11;
			iEnemySeaPower /= 10;
		}

		iEnemyPower += iEnemySeaPower;
	}
	for (int i = 0; i < veEnemyOtherPowers.size(); i++)
	{
		iEnemyPower += veEnemyOtherPowers.GetWeight(i);
	}

	// Final assessment
	return iEnemyPower > iFriendlyPower;
}

//	--------------------------------------------------------------------------------
void CvCity::CheckForAchievementBuilding(BuildingTypes eBuilding)
{
	ASSERT_DEBUG(eBuilding != NO_BUILDING);

	if (!MOD_API_ACHIEVEMENTS)
		return;

	const CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	const char* szBuildingTypeChar = pkBuildingInfo->GetType();
	CvString szBuilding = szBuildingTypeChar;

	if (szBuilding == "BUILDING_LONGHOUSE")
	{
		CvPlot* pLoopPlot = NULL;
		int nForests = 0;

		for (int iI = 0; iI < GetNumWorkablePlots(); iI++)
		{
			pLoopPlot = iterateRingPlots(getX(), getY(), iI);

			if (pLoopPlot != NULL)
			{
				if (pLoopPlot->getOwner() == getOwner())
				{
					if (pLoopPlot->getFeatureType() == FEATURE_FOREST)
					{
						nForests++;
					}
				}
			}
		}
		if (nForests >= 4)
		{
			gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_LONGHOUSE);
		}
	}
	if (szBuilding == "BUILDING_FLOATING_GARDENS")
	{
		int iCityX = getX();
		int iCityY = getY();
		PlayerTypes eCityOwner = getOwner();

		for (int iI = 0; iI < GetNumWorkablePlots(); iI++)
		{
			CvPlot* pLoopPlot = iterateRingPlots(iCityX, iCityY, iI);

			if (pLoopPlot != NULL && pLoopPlot->getOwner() == eCityOwner && pLoopPlot->isLake())
			{
				gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_GARDENS);
				break;
			}
		}
	}
	//DLC_06 achievement: Build Statue of Zeus and Temple of Artemis in same city
	if (szBuilding == "BUILDING_STATUE_ZEUS" || szBuilding == "BUILDING_TEMPLE_ARTEMIS")
	{
		CvString szOtherWonder = "";
		if (szBuilding == "BUILDING_STATUE_ZEUS")
		{
			szOtherWonder = "BUILDING_TEMPLE_ARTEMIS";
		}
		else
		{
			szOtherWonder = "BUILDING_STATUE_ZEUS";
		}
		BuildingTypes eOtherWonder = (BuildingTypes)GC.getInfoTypeForString(szOtherWonder, true);
		if (eOtherWonder != NO_BUILDING)
		{
			PlayerTypes eCityOwner = getOwner();
			if (GetCityBuildings()->GetNumBuilding(eOtherWonder) > 0)
			{
				if (GetCityBuildings()->GetBuildingOriginalOwner(eOtherWonder) == eCityOwner)
				{
					gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_ZEUS_AND_ARTEMIS);
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
void CvCity::IncrementUnitStatCount(CvUnit* pUnit)
{
	if (!MOD_API_ACHIEVEMENTS)
		return;

	CvString szUnitType = pUnit->getUnitInfo().GetType();

	if (szUnitType == "UNIT_WARRIOR")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_WARRIOR);
	}
	else if (szUnitType == "UNIT_SETTLER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_SETTLER);
	}
	else if (szUnitType == "UNIT_WORKER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_WORKER);
	}
	else if (szUnitType == "UNIT_WORKBOAT")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_WORKBOAT);
	}
	else if (szUnitType == "UNIT_GREAT_GENERAL")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_GREATGENERALS);
	}
	else if (szUnitType == "UNIT_SS_STASIS_CHAMBER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_SSSTASISCHAMBER);
	}
	else if (szUnitType == "UNIT_SS_ENGINE")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_SSENGINE);
	}
	else if (szUnitType == "UNIT_SS_COCKPIT")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_SSCOCKPIT);
	}
	else if (szUnitType == "UNIT_SS_BOOSTER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_SSBOOSTER);
	}
	else if (szUnitType == "UNIT_MISSILE_CRUISER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_MISSILECRUISER);
	}
	else if (szUnitType == "UNIT_NUCLEAR_SUBMARINE")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_NUCLEARSUBMARINE);
	}
	else if (szUnitType == "UNIT_CARRIER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_CARRIER);
	}
	else if (szUnitType == "UNIT_BATTLESHIP")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_BATTLESHIP);
	}
	else if (szUnitType == "UNIT_SUBMARINE")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_SUBMARINE);
	}
	else if (szUnitType == "UNIT_DESTROYER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_DESTROYER);
	}
	else if (szUnitType == "UNIT_IRONCLAD")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_IRONCLAD);
	}
	else if (szUnitType == "UNIT_FRIGATE")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_FRIGATE);
	}
	else if (szUnitType == "UNIT_ENGLISH_SHIPOFTHELINE")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_SHIPOFTHELINE);
	}
	else if (szUnitType == "UNIT_CARAVEL")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_CARAVEL);
	}
	else if (szUnitType == "UNIT_TRIREME")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_TRIREME);
	}
	else if (szUnitType == "UNIT_MECH")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_GIANTDEATHROBOT);
	}
	else if (szUnitType == "UNIT_NUCLEAR_MISSILE")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_NUCLEARMISSILE);
	}
	else if (szUnitType == "UNIT_STEALTH_BOMBER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_STEALTHBOMBER);
	}
	else if (szUnitType == "UNIT_JET_FIGHTER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_JETFIGHTER);
	}
	else if (szUnitType == "UNIT_GUIDED_MISSILE")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_GUIDEDMISSILE);
	}
	else if (szUnitType == "UNIT_MODERN_ARMOR")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_MODERNARMOR);
	}
	else if (szUnitType == "UNIT_HELICOPTER_GUNSHIP")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_HELICOPTERGUNSHIP);
	}
	else if (szUnitType == "UNIT_MOBILE_SAM")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_MOBILESAM);
	}
	else if (szUnitType == "UNIT_ROCKET_ARTILLERY")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_ROCKETARTILLERY);
	}
	else if (szUnitType == "UNIT_MECHANIZED_INFANTRY")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_MECHANIZEDINFANTRY);
	}
	else if (szUnitType == "UNIT_ATOMIC_BOMB")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_ATOMICBOMB);
	}
	else if (szUnitType == "UNIT_BOMBER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_BOMBER);
	}
	else if (szUnitType == "UNIT_AMERICAN_B17")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_B17);
	}
	else if (szUnitType == "UNIT_FIGHTER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_FIGHTER);
	}
	else if (szUnitType == "UNIT_JAPANESE_ZERO")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_ZERO);
	}
	else if (szUnitType == "UNIT_PARATROOPER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_PARATROOPER);
	}
	else if (szUnitType == "UNIT_TANK")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_TANK);
	}
	else if (szUnitType == "UNIT_GERMAN_PANZER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_PANZER);
	}
	else if (szUnitType == "UNIT_ARTILLERY")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_ARTILLERY);
	}
	else if (szUnitType == "UNIT_ANTI_AIRCRAFT_GUN")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_ANTIAIRCRAFTGUN);
	}
	else if (szUnitType == "UNIT_ANTI_TANK_GUN")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_ANTITANKGUN);
	}
	else if (szUnitType == "UNIT_INFANTRY")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_INFANTRY);
	}
	else if (szUnitType == "UNIT_FRENCH_FOREIGNLEGION")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_FOREIGNLEGION);
	}
	else if (szUnitType == "UNIT_CAVALRY")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_CAVALRY);
	}
	else if (szUnitType == "UNIT_RUSSIAN_COSSACK")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_COSSACK);
	}
	else if (szUnitType == "UNIT_RIFLEMAN")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_RIFLEMAN);
	}
	else if (szUnitType == "UNIT_LANCER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_LANCER);
	}
	else if (szUnitType == "UNIT_OTTOMAN_SIPAHI")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_SIPAHI);
	}
	else if (szUnitType == "UNIT_CANNON")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_CANNON);
	}
	else if (szUnitType == "UNIT_MUSKETMAN")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_MUSKETMAN);
	}
	else if (szUnitType == "UNIT_AMERICAN_MINUTEMAN")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_MINUTEMAN);
	}
	else if (szUnitType == "UNIT_FRENCH_MUSKETEER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_MUSKETEER);
	}
	else if (szUnitType == "UNIT_OTTOMAN_JANISSARY")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_JANISSARY);
	}
	else if (szUnitType == "UNIT_LONGSWORDSMAN")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_LONGSWORDSMAN);
	}
	else if (szUnitType == "UNIT_JAPANESE_SAMURAI")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_SAMURAI);
	}
	else if (szUnitType == "UNIT_TREBUCHET")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_TREBUCHET);
	}
	else if (szUnitType == "UNIT_KNIGHT")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_KNIGHT);
	}
	else if (szUnitType == "UNIT_SIAMESE_WARELEPHANT")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_NARESUANSELEPHANT);
	}
	else if (szUnitType == "UNIT_SONGHAI_MUSLIMCAVALRY")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_MANDEKALUCAVALRY);
	}
	else if (szUnitType == "UNIT_CROSSBOWMAN")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_CROSSBOWMAN);
	}
	else if (szUnitType == "UNIT_CHINESE_CHUKONU")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_CHUKONU);
	}
	else if (szUnitType == "UNIT_ARABIAN_CAMELARCHER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_CAMELARCHER);
	}
	else if (szUnitType == "UNIT_ENGLISH_LONGBOWMAN")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_LONGBOWMAN);
	}
	else if (szUnitType == "UNIT_PIKEMAN")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_PIKEMAN);
	}
	else if (szUnitType == "UNIT_GERMAN_LANDSKNECHT")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_LANDSKNECHT);
	}
	else if (szUnitType == "UNIT_CATAPULT")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_CATAPULT);
	}
	else if (szUnitType == "UNIT_ROMAN_BALLISTA")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_BALLISTA);
	}
	else if (szUnitType == "UNIT_HORSEMAN")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_HORSEMAN);
	}
	else if (szUnitType == "UNIT_GREEK_COMPANIONCAVALRY")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_COMPANIONCAVALRY);
	}
	else if (szUnitType == "UNIT_SWORDSMAN")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_SWORDSMAN);
	}
	else if (szUnitType == "UNIT_IROQUOIAN_MOHAWKWARRIOR")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_MOHAWKWARRIOR);
	}
	else if (szUnitType == "UNIT_ROMAN_LEGION")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_LEGION);
	}
	else if (szUnitType == "UNIT_CHARIOT_ARCHER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_CHARIOTARCHER);
	}
	else if (szUnitType == "UNIT_EGYPTIAN_WARCHARIOT")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_WARCHARIOT);
	}
	else if (szUnitType == "UNIT_INDIAN_WARELEPHANT")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_WARELEPHANT);
	}
	else if (szUnitType == "UNIT_SPEARMAN")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_SPEARMAN);
	}
	else if (szUnitType == "UNIT_GREEK_HOPLITE")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_HOPLITE);
	}
	else if (szUnitType == "UNIT_PERSIAN_IMMORTAL")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_IMMORTAL);
	}
	else if (szUnitType == "UNIT_ARCHER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_ARCHER);
	}
	else if (szUnitType == "UNIT_SCOUT")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_SCOUT);
	}
	else if (szUnitType == "UNIT_AZTEC_JAGUAR")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_JAGUAR);
	}
	else
	{
		//OutputDebugString("No stat for unit type %s.", szUnitType.c_str());
	}

	if (AreAllUnitsBuilt())
	{
		gDLL->UnlockAchievement(ACHIEVEMENT_ALL_UNITS);
	}
}

//	--------------------------------------------------------------------------------
// Check to see if all the units have been built
bool CvCity::AreAllUnitsBuilt()
{
	int iUnitStatStart = 1;   //As they're defined on the backend
	int iUnitStatEnd = 79;
	int32 nStat = 0;

	for (int iI = iUnitStatStart; iI < iUnitStatEnd; iI++)
	{
		if (gDLL->GetSteamStat((ESteamStat)iI, &nStat))
		{
			if (nStat <= 0)
			{
				return false;
			}
		}
	}
	//Whoops, one is out of order
	if (gDLL->GetSteamStat(ESTEAMSTAT_CAVALRY, &nStat))
	{
		if (nStat <= 0)
		{
			return false;
		}
	}
	return true;

}

//	--------------------------------------------------------------------------------
/// Which unit would we build if we are building one for an operation?
UnitTypes CvCity::GetUnitForOperation()
{
	VALIDATE_OBJECT();
	UnitTypes eBestUnit = NO_UNIT;
	UnitAITypes eUnitAI = NO_UNITAI;

	CvPlayerAI& kPlayer = GET_PLAYER(getOwner());

	bool bSameCity = false;
	OperationSlot thisOperationSlot = kPlayer.PeekAtNextUnitToBuildForOperationSlot(this, bSameCity);
	if (thisOperationSlot.IsValid() && bSameCity)
	{
		CvArmyAI* pThisArmy = kPlayer.getArmyAI(thisOperationSlot.m_iArmyID);
		CvAIOperation* pThisOperation = kPlayer.getAIOperation(thisOperationSlot.m_iOperationID);

		if (pThisArmy && pThisOperation)
		{
			if (!HasAccessToLandmassOrOcean(pThisOperation->GetMusterPlot()->getLandmass()))
				return NO_UNIT;

			// figure out the primary and secondary unit type to potentially build
			CvFormationSlotEntry slotEntry = pThisArmy->GetSlotInfo(thisOperationSlot.m_iSlotID);

			eUnitAI = slotEntry.m_primaryUnitType;
			eBestUnit = m_pCityStrategyAI->GetUnitProductionAI()->RecommendUnit(eUnitAI, true);
			if (eBestUnit == NO_UNIT)
			{
				eUnitAI = slotEntry.m_secondaryUnitType;
				eBestUnit = m_pCityStrategyAI->GetUnitProductionAI()->RecommendUnit(eUnitAI, true);
			}

			if (eBestUnit != NO_UNIT)
			{
				return eBestUnit;
			}
		}
	}
	return NO_UNIT;
}

//	--------------------------------------------------------------------------------
/// What does a City shoot when attacking a Unit?
const char* CvCity::GetCityBombardEffectTag() const
{
	EraTypes eCityEra = GET_TEAM(getTeam()).GetCurrentEra();

	return GC.getEraInfo(eCityEra)->GetCityBombardEffectTag();
}

//	--------------------------------------------------------------------------------
uint CvCity::GetCityBombardEffectTagHash() const
{
	EraTypes eCityEra = GET_TEAM(getTeam()).GetCurrentEra();

	return GC.getEraInfo(eCityEra)->GetCityBombardEffectTagHash();
}

//	---------------------------------------------------------------------------
int CvCity::GetMaxHitPoints() const
{
	return /*200 in CP, 250 in VP*/ GD_INT_GET(MAX_CITY_HIT_POINTS) + GetExtraHitPoints();
}

//	--------------------------------------------------------------------------------
int CvCity::GetExtraHitPoints() const
{
	// Population mod
	int iPopBonus = 0;
	if (MOD_BALANCE_CORE_CITY_DEFENSE_SWITCH)
		iPopBonus = getPopulation() * /*8*/ GD_INT_GET(CITY_STRENGTH_POPULATION_CHANGE);

	return m_iExtraHitPoints + iPopBonus;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeExtraHitPoints(int iValue)
{
	if (iValue != 0)
	{
		m_iExtraHitPoints += iValue;
		ASSERT_DEBUG(m_iExtraHitPoints >= 0, "Trying to set ExtraHitPoints to a negative value");
		if (m_iExtraHitPoints < 0)
			m_iExtraHitPoints = 0;

		int iCurrentDamage = getDamage();
		if (iCurrentDamage > GetMaxHitPoints())
			setDamage(iCurrentDamage);		// Call setDamage, it will clamp the value.
	}
}

//	--------------------------------------------------------------------------------
const CvSyncArchive<CvCity>& CvCity::getSyncArchive() const
{
	return m_syncArchive;
}

//	--------------------------------------------------------------------------------
CvSyncArchive<CvCity>& CvCity::getSyncArchive()
{
	return m_syncArchive;
}

//	--------------------------------------------------------------------------------
std::string CvCity::debugDump(const FAutoVariableBase& /*var*/) const
{
	std::string result = "Game Turn : ";
	char gameTurnBuffer[8] = { 0 };
	int gameTurn = GC.getGame().getGameTurn();
	sprintf_s(gameTurnBuffer, "%d\0", gameTurn);
	result += gameTurnBuffer;
	return result;
}

//	--------------------------------------------------------------------------------
std::string CvCity::stackTraceRemark(const FAutoVariableBase& var) const
{
	std::string result = debugDump(var);
	//example
	/*
	if(&var == &m_aiBaseYieldRateFromTerrain)
	{
		result += std::string("\nlast yield used to update from terrain = ") + FSerialization::toString(s_lastYieldUsedToUpdateRateFromTerrain) + std::string("\n");
		result += std::string("change value used for update = ") + FSerialization::toString(s_changeYieldFromTerreain) + std::string("\n");
	}
	*/
	return result;
}

//	---------------------------------------------------------------------------
bool CvCity::IsBusy() const
{
	return getCombatUnit() != NULL;
}

//	---------------------------------------------------------------------------
const CvUnit* CvCity::getCombatUnit() const
{
	return ::GetPlayerUnit(m_combatUnit);
}

//	---------------------------------------------------------------------------
CvUnit* CvCity::getCombatUnit()
{
	return ::GetPlayerUnit(m_combatUnit);
}

//	---------------------------------------------------------------------------
void CvCity::setCombatUnit(CvUnit* pCombatUnit, bool /*bAttacking*/)
{
	if (pCombatUnit != NULL)
	{
		ASSERT_DEBUG(getCombatUnit() == NULL, "Combat Unit is not expected to be assigned");
		ASSERT_DEBUG(!(plot()->isCityFighting()), "(plot()->isCityFighting()) did not return false as expected");
		m_combatUnit = pCombatUnit->GetIDInfo();
	}
	else
	{
		clearCombat();
	}
}

//	----------------------------------------------------------------------------
void CvCity::clearCombat()
{
	if (getCombatUnit() != NULL)
	{
		ASSERT_DEBUG(plot()->isCityFighting(), "plot()->isCityFighting is expected to be true");
		m_combatUnit.reset();
	}
}

//	----------------------------------------------------------------------------
//	Return true if the city is fighting with someone.	Equivalent to the CvUnit call.
bool CvCity::isFighting() const
{
	return getCombatUnit() != NULL;
}

//	----------------------------------------------------------------------------
bool CvCity::HasBelief(BeliefTypes iBeliefType) const
{
	const ReligionTypes iReligion = GetCityReligions()->GetReligiousMajority();
	const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(iReligion, getOwner());

	return (pReligion && pReligion->m_Beliefs.HasBelief(iBeliefType));
}

bool CvCity::HasBuilding(BuildingTypes iBuildingType) const
{
	return (GetCityBuildings()->GetNumBuilding(iBuildingType) > 0);
}

bool CvCity::HasBuildingClass(BuildingClassTypes iBuildingClassType) const
{
	if (MOD_BUILDINGS_THOROUGH_PREREQUISITES)
	{
		return GetCityBuildings()->HasBuildingClass(iBuildingClassType);
	}
	else
	{
		BuildingTypes eBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(iBuildingClassType);
		if (eBuilding == NO_BUILDING)
			return false;

		return HasBuilding(eBuilding);
	}
}

bool CvCity::HasAnyWonder() const
{
	return (getNumWorldWonders() > 0);
}

bool CvCity::HasWonder(BuildingTypes iBuildingType) const
{
	return HasBuilding(iBuildingType);
}

bool CvCity::IsBuildingWorldWonder() const
{
	if (getProductionBuilding() == NO_BUILDING)
		return false;

	const CvBuildingClassInfo& kBuildingClass = GC.getBuildingInfo(getProductionBuilding())->GetBuildingClassInfo();

	return ::isWorldWonderClass(kBuildingClass);
}

bool CvCity::IsCivilization(CivilizationTypes iCivilizationType) const
{
	return (GET_PLAYER(getOwner()).getCivilizationType() == iCivilizationType);
}

bool CvCity::HasFeature(FeatureTypes iFeatureType) const
{
	for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

		if (pLoopPlot->HasFeature(iFeatureType))
		{
			return true;
		}
	}

	return false;
}

bool CvCity::HasWorkedFeature(FeatureTypes iFeatureType) const
{
	for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

		// Not being worked by this city
		if (!GetCityCitizens()->IsWorkingPlot(pLoopPlot)) {
			continue;
		}

		if (pLoopPlot->HasFeature(iFeatureType)) {
			return true;
		}
	}

	return false;
}

bool CvCity::HasAnyNaturalWonder() const
{
	for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

		if (pLoopPlot->IsNaturalWonder()) {
			return true;
		}
	}

	return false;
}

bool CvCity::HasNaturalWonder(FeatureTypes iFeatureType) const
{
	return HasFeature(iFeatureType);
}

bool CvCity::HasImprovement(ImprovementTypes iImprovementType) const
{
	for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

		if (pLoopPlot->HasImprovement(iImprovementType)) {
			return true;
		}
	}

	return false;
}

bool CvCity::HasWorkedImprovement(ImprovementTypes iImprovementType) const
{
	for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

		// Not being worked by this city
		if (!GetCityCitizens()->IsWorkingPlot(pLoopPlot)) {
			continue;
		}

		if (pLoopPlot->HasImprovement(iImprovementType)) {
			return true;
		}
	}

	return false;
}

bool CvCity::HasPlotType(PlotTypes iPlotType) const
{
	for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

		if (pLoopPlot->HasPlotType(iPlotType)) {
			return true;
		}
	}

	return false;
}

bool CvCity::HasWorkedPlotType(PlotTypes iPlotType) const
{
	for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

		// Not being worked by this city
		if (!GetCityCitizens()->IsWorkingPlot(pLoopPlot)) {
			continue;
		}

		if (pLoopPlot->HasPlotType(iPlotType)) {
			return true;
		}
	}

	return false;
}

bool CvCity::HasAnyReligion() const
{
	return (GetCityReligions()->IsReligionInCity());
}

bool CvCity::HasReligion(ReligionTypes iReligionType) const
{
	return (HasAnyReligion() && GetCityReligions()->GetNumFollowers(iReligionType) > 0);
}

bool CvCity::HasResource(ResourceTypes iResourceType) const
{
	for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

		// Team can't see the resource here
		if (pLoopPlot->getResourceType(getTeam()) != iResourceType) {
			continue;
		}

		// Resource not linked to this city
		// if (pLoopPlot->GetResourceLinkedCity() != this) {
		// 	continue;
		// }

		if (pLoopPlot->HasResource(iResourceType)) {
			return true;
		}
	}

	return false;
}

bool CvCity::HasWorkedResource(ResourceTypes iResourceType) const
{
	for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

		// Team can't see the resource here
		if (pLoopPlot->getResourceType(getTeam()) != iResourceType) {
			continue;
		}

		// Not being worked by this city
		if (!GetCityCitizens()->IsWorkingPlot(pLoopPlot)) {
			continue;
		}

		if (pLoopPlot->HasResource(iResourceType)) {
			return true;
		}
	}

	return false;
}

bool CvCity::IsConnectedTo(CvCity* pCity) const
{
	return GET_PLAYER(getOwner()).IsCityConnectedToCity((CvCity*)this, pCity);
}

int CvCity::GetConnectionGoldTimes100() const
{
	return GET_PLAYER(getOwner()).GetTreasury()->GetCityConnectionRouteGoldTimes100(this);
}

bool CvCity::HasSpecialistSlot(SpecialistTypes iSpecialistType) const
{
	for (int iBuildingType = 0; iBuildingType < GC.getNumBuildingInfos(); iBuildingType++) {
		if (HasBuilding((BuildingTypes)iBuildingType)) {
			CvBuildingEntry* pkBuilding = GC.getBuildingInfo((BuildingTypes)iBuildingType);
			if (pkBuilding && pkBuilding->GetSpecialistType() == iSpecialistType && pkBuilding->GetSpecialistCount() > 0) {
				return true;
			}
		}
	}

	return false;
}

bool CvCity::HasSpecialist(SpecialistTypes iSpecialistType) const
{
	return (GetCityCitizens()->GetSpecialistCount(iSpecialistType) > 0);
}

bool CvCity::HasTerrain(TerrainTypes iTerrainType) const
{
	for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

		if (pLoopPlot->HasTerrain(iTerrainType)) {
			return true;
		}
	}

	return false;
}

bool CvCity::HasWorkedTerrain(TerrainTypes iTerrainType) const
{
	for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

		// Not being worked by this city
		if (!GetCityCitizens()->IsWorkingPlot(pLoopPlot)) {
			continue;
		}

		if (pLoopPlot->HasTerrain(iTerrainType)) {
			return true;
		}
	}

	return false;
}

bool CvCity::HasAnyDomesticTradeRoute(bool bOutgoing) const
{
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();
	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute))
			continue;

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));
		if (bOutgoing && GetID() == pConnection->m_iOriginID && getOwner() == pConnection->m_eDestOwner)
			return true;
		if (!bOutgoing && GetID() == pConnection->m_iDestID && getOwner() == pConnection->m_eOriginOwner)
			return true;
	}

	return false;
}

bool CvCity::HasAnyInternationalTradeRoute(bool bOutgoing) const
{
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();
	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute))
			continue;

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));
		if (bOutgoing && GetID() == pConnection->m_iOriginID && getOwner() != pConnection->m_eDestOwner)
			return true;
		if (!bOutgoing && GetID() == pConnection->m_iDestID && getOwner() != pConnection->m_eOriginOwner)
			return true;
	}

	return false;
}

bool CvCity::HasTradeRouteToAnyCity() const
{
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();
	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute))
			continue;

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));
		if (GetID() == pConnection->m_iOriginID)
			return true;
	}

	return false;
}

bool CvCity::HasTradeRouteTo(CvCity* pCity) const
{
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();
	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute))
			continue;

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));
		if (GetID() == pConnection->m_iOriginID && pCity->GetID() == pConnection->m_iDestID)
			return true;
	}

	return false;
}

bool CvCity::HasTradeRouteFromAnyCity() const
{
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();
	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute))
			continue;

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));
		if (GetID() == pConnection->m_iDestID)
			return true;
	}

	return false;
}

bool CvCity::HasTradeRouteFrom(CvCity* pCity) const
{
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();
	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute))
			continue;

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));
		if (GetID() == pConnection->m_iDestID && pCity->GetID() == pConnection->m_iOriginID)
			return true;
	}

	return false;
}

bool CvCity::IsOnFeature(FeatureTypes iFeatureType) const
{
	return plot()->HasFeature(iFeatureType);
}

bool CvCity::IsAdjacentToFeature(FeatureTypes iFeatureType) const
{
	return plot()->IsAdjacentToFeature(iFeatureType);
}

bool CvCity::IsWithinDistanceOfFeature(FeatureTypes iFeatureType, int iDistance) const
{
	return plot()->IsWithinDistanceOfFeature(iFeatureType, iDistance);
}
#if defined(MOD_BALANCE_CORE)
bool CvCity::IsWithinDistanceOfUnit(UnitTypes eOtherUnit, int iDistance, bool bIsFriendly, bool bIsEnemy) const
{
	return plot()->IsWithinDistanceOfUnit(getOwner(), eOtherUnit, iDistance, bIsFriendly, bIsEnemy);
}
bool CvCity::IsWithinDistanceOfUnitClass(UnitClassTypes eUnitClass, int iDistance, bool bIsFriendly, bool bIsEnemy) const
{
	return plot()->IsWithinDistanceOfUnitClass(getOwner(), eUnitClass, iDistance, bIsFriendly, bIsEnemy);
}
bool CvCity::IsWithinDistanceOfUnitCombatType(UnitCombatTypes eUnitCombat, int iDistance, bool bIsFriendly, bool bIsEnemy) const
{
	return plot()->IsWithinDistanceOfUnitCombatType(getOwner(), eUnitCombat, iDistance, bIsFriendly, bIsEnemy);
}
bool CvCity::IsWithinDistanceOfUnitPromotion(PromotionTypes eUnitPromotion, int iDistance, bool bIsFriendly, bool bIsEnemy) const
{
	return plot()->IsWithinDistanceOfUnitPromotion(getOwner(), eUnitPromotion, iDistance, bIsFriendly, bIsEnemy);
}
#endif
bool CvCity::IsOnImprovement(ImprovementTypes iImprovementType) const
{
	return plot()->HasImprovement(iImprovementType);
}

bool CvCity::IsAdjacentToImprovement(ImprovementTypes iImprovementType) const
{
	return plot()->IsAdjacentToImprovement(iImprovementType);
}

bool CvCity::IsWithinDistanceOfImprovement(ImprovementTypes iImprovementType, int iDistance) const
{
	return plot()->IsWithinDistanceOfImprovement(iImprovementType, iDistance);
}

bool CvCity::IsOnPlotType(PlotTypes iPlotType) const
{
	return plot()->HasPlotType(iPlotType);
}

bool CvCity::IsAdjacentToPlotType(PlotTypes iPlotType) const
{
	return plot()->IsAdjacentToPlotType(iPlotType);
}

bool CvCity::IsWithinDistanceOfPlotType(PlotTypes iPlotType, int iDistance) const
{
	return plot()->IsWithinDistanceOfPlotType(iPlotType, iDistance);
}

bool CvCity::IsOnResource(ResourceTypes iResourceType) const
{
	return plot()->HasResource(iResourceType);
}

bool CvCity::IsAdjacentToResource(ResourceTypes iResourceType) const
{
	return plot()->IsAdjacentToResource(iResourceType);
}

bool CvCity::IsWithinDistanceOfResource(ResourceTypes iResourceType, int iDistance) const
{
	return plot()->IsWithinDistanceOfResource(iResourceType, iDistance);
}

bool CvCity::IsOnTerrain(TerrainTypes iTerrainType) const
{
	return plot()->HasTerrain(iTerrainType);
}

bool CvCity::IsAdjacentToTerrain(TerrainTypes iTerrainType) const
{
	return plot()->IsAdjacentToTerrain(iTerrainType);
}

bool CvCity::IsWithinDistanceOfTerrain(TerrainTypes iTerrainType, int iDistance) const
{
	return plot()->IsWithinDistanceOfTerrain(iTerrainType, iDistance);
}

int CvCity::CountNumWorkedFeature(FeatureTypes iFeatureType)
{
	int iNum = 0;

	for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

		// Not being worked by this city
		if (!GetCityCitizens()->IsWorkingPlot(pLoopPlot))
		{
			continue;
		}

		if (pLoopPlot->HasFeature(iFeatureType))
		{
			iNum++;
		}
	}

	return iNum;
}

int CvCity::CountNumWorkedImprovement(ImprovementTypes eImprovement, bool IgnorePillaged)
{
	int iNum = 0;

	for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

		// Not being worked by this city
		if (!GetCityCitizens()->IsWorkingPlot(pLoopPlot))
		{
			continue;
		}

		if (pLoopPlot->IsImprovementPillaged() && IgnorePillaged)
			continue;

		if (pLoopPlot->getImprovementType() == eImprovement)
		{
			iNum++;
		}
	}

	return iNum;
}

int CvCity::CountNumWorkedResource(ResourceTypes eResource)
{
	int iNum = 0;

	for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

		// Not being worked by this city
		if (!GetCityCitizens()->IsWorkingPlot(pLoopPlot))
		{
			continue;
		}

		if (pLoopPlot->getResourceType(getTeam()) == eResource)
		{
			iNum++;
		}
	}

	return iNum;
}

int CvCity::CountNumImprovement(ImprovementTypes eImprovement)
{
	int iNum = 0;

	for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

		// Does not belong to this city
		if (!GetCityCitizens()->IsCanWork(pLoopPlot))
		{
			continue;
		}

		if (pLoopPlot->getImprovementType() == eImprovement)
		{
			iNum++;
		}
	}

	return iNum;
}
int CvCity::CountNumWorkedRiverTiles(TerrainTypes eTerrain)
{
	int iNum = 0;

	for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

		if (!pLoopPlot->isRiver())
		{
			continue;
		}

		// Does not belong to this city
		if (!GetCityCitizens()->IsWorkingPlot(pLoopPlot))
		{
			continue;
		}

		if (eTerrain == NO_TERRAIN)
		{
			iNum++;
		}
		else if (eTerrain == pLoopPlot->getTerrainType())
		{
			iNum++;
		}
	}

	return iNum;
}

//	--------------------------------------------------------------------------------
#if defined(MOD_CORE_PER_TURN_DAMAGE)
int CvCity::addDamageReceivedThisTurn(int iDamage, CvUnit* pAttacker)
{
	if (pAttacker && !isHuman())
		GET_PLAYER(getOwner()).AddKnownAttacker(pAttacker);

	m_iDamageTakenThisTurn += iDamage;
	return m_iDamageTakenThisTurn;
}

void CvCity::flipDamageReceivedPerTurn()
{
	//basic smoothing so we don't overeact if the enemy doesn't do damage in a particular turn
	m_iDamageTakenLastTurn = (m_iDamageTakenThisTurn * 80 + m_iDamageTakenLastTurn * 20) / 100;
	m_iDamageTakenThisTurn = 0;
}

bool CvCity::isInDangerOfFalling(bool bExtraCareful) const
{
	int iHitpoints = GetMaxHitPoints() - getDamage();
	int iExtraDamage = bExtraCareful ? m_iDamageTakenLastTurn / 3 : 0;

	if (m_iDamageTakenLastTurn+iExtraDamage > iHitpoints)
		return true;

	//special: if a city has just been conquered it's vulnerable but m_iDamageTakenLastTurn is zero
	if (GC.getGame().getGameTurn() - getGameTurnAcquired() < 2)
		if (GET_PLAYER(getOwner()).GetPlotDanger(this)*2 > iHitpoints)
			return true;

	return false;
}

bool CvCity::isUnderSiege() const
{
	//damage taken decays exponentially so check for >0
	return m_iDamageTakenLastTurn > 5 && GetCityCitizens()->AnyPlotBlockaded();
}

int CvCity::getDamageTakenLastTurn() const
{
	return m_iDamageTakenLastTurn;
}

#endif

#if defined(MOD_BALANCE_CORE)
//the closest friendly cities - up to 4 entries 
const std::vector<int>& CvCity::GetClosestFriendlyNeighboringCities() const
{
	return m_vClosestNeighbors;
}

void CvCity::UpdateClosestFriendlyNeighbors()
{
	struct SCityWithScore
	{
		CvCity* city;
		int score;
		SCityWithScore(CvCity* ptr, int i) : city(ptr), score(i) {}
		bool operator<(const SCityWithScore& rhs) const { return score < rhs.score; }
	};

	std::vector<SCityWithScore> allNeighbors;

	CvPlayer& kOwner = GET_PLAYER(getOwner());
	int iLoop = 0;
	for (CvCity* pCity = kOwner.firstCity(&iLoop); pCity != NULL; pCity = kOwner.nextCity(&iLoop))
	{
		//we are not our own neighbor
		if (pCity == this)
			continue;

		int iDistance = plotDistance(getX(), getY(), pCity->getX(), pCity->getY());
		allNeighbors.push_back(SCityWithScore(pCity, iDistance));
	}

	std::stable_sort(allNeighbors.begin(), allNeighbors.end());

	m_vClosestNeighbors.clear();
	for (size_t i = 0; i < min<size_t>(6, allNeighbors.size()); i++)
		m_vClosestNeighbors.push_back(allNeighbors[i].city->GetID());
}

void CvCity::AttachUnit(CvUnit* pUnit)
{
	if (pUnit)
		m_vAttachedUnits.push_back(pUnit->GetID());
}

void CvCity::ClearAttachedUnits()
{
	m_vAttachedUnits.clear();
}

const std::vector<int>& CvCity::GetAttachedUnits() const
{
	return m_vAttachedUnits;
}

int CvCity::CountFeature(FeatureTypes iFeatureType) const
{
	int iCount = 0;

	for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

		if (pLoopPlot->HasFeature(iFeatureType))
			++iCount;
	}

	return iCount;
}

int CvCity::CountWorkedFeature(FeatureTypes iFeatureType) const
{
	int iCount = 0;

	for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

		// Not being worked by this city
		if (!GetCityCitizens()->IsWorkingPlot(pLoopPlot)) {
			continue;
		}

		if (pLoopPlot->HasFeature(iFeatureType)) {
			++iCount;
		}
	}

	return iCount;
}

int CvCity::CountImprovement(ImprovementTypes iImprovementType, bool bOnlyCreated) const
{
	int iCount = 0;

	for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

		if (pLoopPlot->HasImprovement(iImprovementType))
		{
			if (bOnlyCreated && pLoopPlot->GetPlayerThatBuiltImprovement() != getOwner())
				continue;

			++iCount;
		}
	}

	return iCount;
}

int CvCity::CountWorkedImprovement(ImprovementTypes iImprovementType) const
{
	int iCount = 0;

	for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

		// Not being worked by this city
		if (!GetCityCitizens()->IsWorkingPlot(pLoopPlot)) {
			continue;
		}

		if (pLoopPlot->HasImprovement(iImprovementType)) {
			++iCount;
		}
	}

	return iCount;
}

int CvCity::CountPlotType(PlotTypes iPlotType) const
{
	int iCount = 0;

	for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

		if (pLoopPlot->HasPlotType(iPlotType))
			++iCount;
	}

	return iCount;
}

int CvCity::CountWorkedPlotType(PlotTypes iPlotType) const
{
	int iCount = 0;

	for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

		// Not being worked by this city
		if (!GetCityCitizens()->IsWorkingPlot(pLoopPlot)) {
			continue;
		}

		if (pLoopPlot->HasPlotType(iPlotType)) {
			++iCount;
		}
	}

	return iCount;
}

int CvCity::CountResource(ResourceTypes iResourceType) const
{
	int iCount = 0;

	for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

		// Not owned by this city
		if (!GetCityCitizens()->IsCanWork(pLoopPlot))
			continue;

		if (pLoopPlot->HasResource(iResourceType)) {
			++iCount;
		}
	}

	return iCount;
}

int CvCity::CountWorkedResource(ResourceTypes iResourceType) const
{
	int iCount = 0;

	for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

		// Not being worked by this city
		if (!GetCityCitizens()->IsWorkingPlot(pLoopPlot)) {
			continue;
		}

		if (pLoopPlot->HasResource(iResourceType)) {
			++iCount;
		}
	}

	return iCount;
}

int CvCity::CountTerrain(TerrainTypes iTerrainType) const
{
	int iCount = 0;

	for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

		if (pLoopPlot->HasTerrain(iTerrainType))
			++iCount;
	}

	return iCount;
}

int CvCity::CountWorkedTerrain(TerrainTypes iTerrainType) const
{
	int iCount = 0;

	for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndex(*it);

		// Not being worked by this city
		if (!GetCityCitizens()->IsWorkingPlot(pLoopPlot)) {
			continue;
		}

		if (pLoopPlot->HasTerrain(iTerrainType)) {
			++iCount;
		}
	}

	return iCount;
}

int CvCity::CountAllOwnedTerrain(TerrainTypes iTerrainType) const
{
	int iCount = 0;
	int iOwner = getOwner();

	// Loop through all plots in a map, rather than count x number of rings around the city (to cover niche cases such as someone making a citadel snake)
	for (int iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++) 
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);

		// Invalid plot or not owned by this player
		if (pLoopPlot == NULL || pLoopPlot->getOwner() != iOwner) {
			continue;
		}

		//should we check owner or effective owner?
		if (pLoopPlot->getOwningCityID() != GetID())
			continue;


		if (pLoopPlot->HasTerrain(iTerrainType)) {
			++iCount;
		}
	}

	return iCount;
}
#endif

#if defined(MOD_BALANCE_CORE_JFD)
bool CvCity::IsColony() const
{
	return m_bIsColony;
}
void CvCity::SetColony(bool bValue)
{
	if (m_bIsColony != bValue)
	{
		m_bIsColony = bValue;
	}
}
int CvCity::GetProvinceLevel() const
{
	return m_iProvinceLevel;
}
void CvCity::SetProvinceLevel(int iValue)
{
	if (iValue != m_iProvinceLevel)
	{
		int iOldLevel = m_iProvinceLevel;
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_ProvinceLevelChanged, getOwner(), GetID(), iOldLevel, iValue);
		m_iProvinceLevel = iValue;
	}
}

int CvCity::GetOrganizedCrime() const
{
	return m_iOrganizedCrime;
}
void CvCity::SetOrganizedCrime(int iValue)
{
	if (m_iOrganizedCrime != iValue)
	{
		m_iOrganizedCrime = iValue;
	}
}
bool CvCity::HasOrganizedCrime()
{
	return(m_iOrganizedCrime >= 0);
}

void CvCity::ChangeResistanceCounter(int iValue)
{
	if (iValue != 0)
	{
		m_iResistanceCounter += iValue;
	}
}
void CvCity::SetResistanceCounter(int iValue)
{
	if (iValue != m_iResistanceCounter)
	{
		m_iResistanceCounter = iValue;
	}
}
int CvCity::GetResistanceCounter() const
{
	return m_iResistanceCounter;
}

void CvCity::ChangePlagueCounter(int iValue)
{
	if (iValue != 0)
	{
		m_iPlagueCounter += iValue;
	}
}
void CvCity::SetPlagueCounter(int iValue)
{
	if (iValue != m_iPlagueCounter)
	{
		m_iPlagueCounter = iValue;
	}
}
int CvCity::GetPlagueCounter() const
{
	return m_iPlagueCounter;
}

int CvCity::GetPlagueTurns() const
{
	return m_iPlagueTurns;
}
void CvCity::ChangePlagueTurns(int iValue) //Set in city::doturn
{
	if (iValue != 0)
	{
		m_iPlagueTurns += iValue;
	}
}
void CvCity::SetPlagueTurns(int iValue)
{
	if (iValue != m_iPlagueTurns)
	{
		m_iPlagueTurns = iValue;
	}
}

int CvCity::GetSappedTurns() const
{
	return m_iSappedTurns;
}
void CvCity::SetSappedTurns(int iValue)
{
	m_iSappedTurns = iValue;
	updateStrengthValue();
}
void CvCity::ChangeSappedTurns(int iValue) //Set in city::doturn
{
	m_iSappedTurns += iValue;
	updateStrengthValue();
}

int CvCity::GetBuildingProductionBlockedTurns() const
{
	return m_iBuildingProductionBlockedTurns;
}
void CvCity::SetBuildingProductionBlockedTurns(int iValue)
{
	m_iBuildingProductionBlockedTurns = iValue;
}
void CvCity::ChangeBuildingProductionBlockedTurns(int iValue) //Set in city::doturn
{
	m_iBuildingProductionBlockedTurns += iValue;
}

int CvCity::GetNoTourismTurns() const
{
	return m_iNoTourismTurns;
}
void CvCity::SetNoTourismTurns(int iValue)
{
	m_iNoTourismTurns = iValue;
}
void CvCity::ChangeNoTourismTurns(int iValue) //Set in city::doturn
{
	m_iNoTourismTurns += iValue;
}

int CvCity::GetPlagueType() const
{
	return m_iPlagueType;
}
void CvCity::SetPlagueType(int iValue)
{
	if (iValue != m_iPlagueTurns)
	{
		m_iPlagueType = iValue;
	}
}
bool CvCity::HasPlague()
{
	return(m_iPlagueType >= 0);
}

void CvCity::ChangeLoyaltyCounter(int iValue)
{
	if (iValue != 0)
	{
		m_iLoyaltyCounter += iValue;
	}
}
void CvCity::SetLoyaltyCounter(int iValue)
{
	if (iValue != m_iLoyaltyCounter)
	{
		m_iLoyaltyCounter = iValue;
	}
}
int CvCity::GetLoyaltyCounter() const
{
	return m_iLoyaltyCounter;
}

void CvCity::ChangeDisloyaltyCounter(int iValue)
{
	if (iValue != 0)
	{
		m_iDisloyaltyCounter += iValue;
	}
}
void CvCity::SetDisloyaltyCounter(int iValue)
{
	if (iValue != m_iDisloyaltyCounter)
	{
		m_iDisloyaltyCounter = iValue;
	}
}
int CvCity::GetDisloyaltyCounter() const
{
	return m_iDisloyaltyCounter;
}

int CvCity::GetLoyaltyState() const
{
	return m_iLoyaltyStateType;
}
void CvCity::SetLoyaltyState(int iLoyalty)
{
	if (iLoyalty != m_iLoyaltyStateType)
	{
		int iOldLoyalty = m_iLoyaltyStateType;
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_LoyaltyStateChanged, getOwner(), GetID(), iOldLoyalty, iLoyalty);
		m_iLoyaltyStateType = iLoyalty;
	}
}

void CvCity::SetYieldModifierFromHappiness(YieldTypes eYield, int iValue)
{
	if (GetYieldModifierFromHappiness(eYield) != iValue)
	{
		m_aiYieldModifierFromHappiness[eYield] = iValue;
		UpdateCityYields(eYield);
	}
}
int CvCity::GetYieldModifierFromHappiness(YieldTypes eYield) const
{
	VALIDATE_OBJECT();
		ASSERT_DEBUG(eYield >= 0, "eYield expected to be >= 0");
	ASSERT_DEBUG(eYield < NUM_YIELD_TYPES, "eYield expected to be < NUM_YIELD_TYPES");

	return m_aiYieldModifierFromHappiness[eYield];
}

void CvCity::SetYieldModifierFromHealth(YieldTypes eYield, int iValue)
{
	if (GetYieldModifierFromHealth(eYield) != iValue)
	{
		m_aiYieldModifierFromHealth[eYield] = iValue;
		UpdateCityYields(eYield);
	}
}
int CvCity::GetYieldModifierFromHealth(YieldTypes eYield) const
{
	VALIDATE_OBJECT();
	return m_aiYieldModifierFromHealth[eYield];
}

void CvCity::SetYieldModifierFromCrime(YieldTypes eYield, int iValue)
{
	if (GetYieldModifierFromCrime(eYield) != iValue)
	{
		m_aiYieldModifierFromCrime[eYield] = iValue;
		UpdateCityYields(eYield);
	}
}
int CvCity::GetYieldModifierFromCrime(YieldTypes eYield) const
{
	VALIDATE_OBJECT();
	return m_aiYieldModifierFromCrime[eYield];
}

void CvCity::SetYieldModifierFromDevelopment(YieldTypes eYield, int iValue)
{
	if (GetYieldModifierFromDevelopment(eYield) != iValue)
	{
		m_aiYieldModifierFromDevelopment[eYield] = iValue;
		UpdateCityYields(eYield);
	}
}
int CvCity::GetYieldModifierFromDevelopment(YieldTypes eYield) const
{
	VALIDATE_OBJECT();
	return m_aiYieldModifierFromDevelopment[eYield];
}

void CvCity::SetYieldFromHappiness(YieldTypes eYield, int iValue)
{
	if (GetYieldFromHappiness(eYield) != iValue)
	{
		m_aiYieldFromHappiness[eYield] = iValue;
		UpdateCityYields(eYield);
	}
}
int CvCity::GetYieldFromHappiness(YieldTypes eYield) const
{
	VALIDATE_OBJECT();
	return m_aiYieldFromHappiness[eYield];
}

void CvCity::SetYieldFromHealth(YieldTypes eYield, int iValue)
{
	if (GetYieldFromHealth(eYield) != iValue)
	{
		m_aiYieldFromHealth[eYield] = iValue;
		UpdateCityYields(eYield);
	}
}
int CvCity::GetYieldFromHealth(YieldTypes eYield) const
{
	VALIDATE_OBJECT();
	return m_aiYieldFromHealth[eYield];
}
void CvCity::SetYieldFromCrime(YieldTypes eYield, int iValue)
{
	if (GetYieldFromCrime(eYield) != iValue)
	{
		m_aiYieldFromCrime[eYield] = iValue;
		UpdateCityYields(eYield);
	}
}
int CvCity::GetYieldFromCrime(YieldTypes eYield) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eYield >= 0, "eYield expected to be >= 0");
	ASSERT_DEBUG(eYield < NUM_YIELD_TYPES, "eYield expected to be < NUM_YIELD_TYPES");

	return m_aiYieldFromCrime[eYield];
}

void CvCity::SetYieldFromDevelopment(YieldTypes eYield, int iValue)
{
	if (GetYieldFromDevelopment(eYield) != iValue)
	{
		m_aiYieldFromDevelopment[eYield] = iValue;
		UpdateCityYields(eYield);
	}
}
int CvCity::GetYieldFromDevelopment(YieldTypes eYield) const
{
	VALIDATE_OBJECT();
	ASSERT_DEBUG(eYield >= 0, "eYield expected to be >= 0");
	ASSERT_DEBUG(eYield < NUM_YIELD_TYPES, "eYield expected to be < NUM_YIELD_TYPES");

	return m_aiYieldFromDevelopment[eYield];
}
#endif

void CvCity::ChangeVassalLevyEra(int iChange)
{
	m_iVassalLevyEra += iChange;
}

int CvCity::GetVassalLevyEra() const
{
	return m_iVassalLevyEra;
}

// Spawn one eUnit on city plot (moved to nearest valid plot)
void CvCity::SpawnFreeUnit(UnitTypes eUnit)
{
	CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
	ASSERT_DEBUG(pkUnitInfo, "Trying to spawn invalid unit");

	// Great Prophet goes the other path for proper initialization and popup notification
	if (pkUnitInfo->IsFoundReligion())
	{
		GetCityCitizens()->DoSpawnGreatPerson(eUnit, true /*bIncrementCount*/, true, MOD_GLOBAL_TRULY_FREE_GP);
		return;
	}

	CvPlayer& kPlayer = GET_PLAYER(getOwner());

	// Free non-Prophet religious units (from buildings and policies) take on the state religion. If no state religion, use the city's religion.
	ReligionTypes eReligion = NO_RELIGION;
	if (pkUnitInfo->IsSpreadReligion() || pkUnitInfo->IsRemoveHeresy())
	{
		if (GC.getGame().isOption(GAMEOPTION_NO_RELIGION))
			return;

		eReligion = kPlayer.GetReligions()->GetStateReligion(false);
		if (eReligion == NO_RELIGION)
			eReligion = GetCityReligions()->GetReligiousMajority();

		if (eReligion == NO_RELIGION || eReligion == RELIGION_PANTHEON)
			return;
	}

	CvUnit* pFreeUnit = kPlayer.initUnit(eUnit, getX(), getY());

	if (pFreeUnit->isTrade())
	{
		if (GC.getLogging() && GC.getAILogging())
		{
			CvString strCiv = GET_PLAYER(getOwner()).getCivilizationAdjective();
			CvString strLogString;
			strLogString.Format("FREE TRADE UNIT CREATED: %s %s at %d,d", strCiv.c_str(), pFreeUnit->getName().c_str(), pFreeUnit->getX(), pFreeUnit->getY());
			GET_PLAYER(getOwner()).GetHomelandAI()->LogHomelandMessage(strLogString);
		}
	}

	if (pFreeUnit->IsGreatAdmiral())
	{
		CvPlot* pSpawnPlot = kPlayer.GetBestCoastalSpawnPlot(pFreeUnit);
		if (pFreeUnit->plot() != pSpawnPlot)
		{
			pFreeUnit->setXY(pSpawnPlot->getX(), pSpawnPlot->getY());
		}
	}
	else if (!pFreeUnit->jumpToNearestValidPlot())
	{
		// Could not find a valid spot! Remove the unit and don't process further
		pFreeUnit->kill(false);
		return;
	}

	// Set up religious units properly
	if (pkUnitInfo->IsSpreadReligion() || pkUnitInfo->IsRemoveHeresy())
		pFreeUnit->GetReligionDataMutable()->SetFullStrength(kPlayer.GetID(), pFreeUnit->getUnitInfo(), eReligion);

	pFreeUnit->DoGreatPersonSpawnBonus(this);
	addProductionExperience(pFreeUnit);
	kPlayer.incrementGreatPersonCount(pFreeUnit->getUnitInfo(), false, MOD_GLOBAL_TRULY_FREE_GP);
}

// Spawn iNumber best military units owned by ePlayer around the best plot near this city
// ePlayer could be city owner, barbarian, or other players
// Returns the number of units successfully spawned
int CvCity::SpawnPlayerUnitsNearby(const PlayerTypes ePlayer, const int iNumber, const bool bIncludeUUs, bool bIncludeShips, const bool bNoResource) const
{
	if (iNumber <= 0)
		return 0;

	// Don't spawn ships if city isn't coastal
	if (!isCoastal())
		bIncludeShips = false;

	int iNumUnitSpawned = 0;
	CvPlayer& kPlayer = GET_PLAYER(ePlayer);

	// Melee -> Ranged -> Repeat
	bool bCanBeRanged = false;
	for (int i = 0; i < iNumber; i++)
	{
		// Pick a unit to spawn
		UnitTypes eUnit = kPlayer.GetCompetitiveSpawnUnitType(bCanBeRanged, bIncludeShips, false, bIncludeUUs, this, bNoResource, false, true);
		bCanBeRanged = !bCanBeRanged;
		if (eUnit == NO_UNIT)
			continue;

		// Pick the best plot to spawn this unit
		CvPlot* pBestPlot = NULL;
		int iBestPlotWeight = -1;
		CvUnitEntry* pUnitInfo = GC.getUnitInfo(eUnit);

		for (std::set<int>::const_iterator it = m_siPlots.begin(); it != m_siPlots.end(); ++it)
		{
			CvPlot* pPlot = GC.getMap().plotByIndex(*it);

			// Don't let foreign units spawn in the city!
			if (pPlot == plot() && ePlayer != getOwner())
				continue;

			// Can't be impassable
			if (!pPlot->isValidMovePlot(getOwner()))
				continue;

			// Can't be water for land units
			if (pPlot->isWater() && pUnitInfo->GetDomainType() != DOMAIN_SEA)
				continue;

			// Can't be land for naval units; this deliberately excludes the city plot
			if (!pPlot->isWater() && pUnitInfo->GetDomainType() == DOMAIN_SEA)
				continue;

			// Don't pick plots that aren't ours
			if (pPlot->getOwner() != getOwner())
				continue;

			// Don't place on a plot where a combat unit is already standing (that can include a unit that's just placed)
			if (pPlot->GetNumCombatUnits() > 0)
				continue;

			// Prioritize city plot if there's no garrison and it's spawning our land unit
			if (pPlot == plot())
			{
				pBestPlot = pPlot;
				break;
			}
			else
			{
				int iTempWeight = GC.getGame().randRangeExclusive(0, 10, CvSeeder(GET_PLAYER(getOwner()).GetMilitaryMight()).mix(pPlot->GetPseudoRandomSeed()));

				// Add weight if there's an improvement here!
				if (pPlot->getImprovementType() != NO_IMPROVEMENT)
				{
					iTempWeight += 10;

					// If there's also a resource, even more weight!
					if (pPlot->getResourceType(kPlayer.getTeam()) != NO_RESOURCE)
						iTempWeight += 10;
				}

				// Add weight if there's a defensive bonus for this plot
				iTempWeight += pPlot->defenseModifier(kPlayer.getTeam(), false, false);

				if (iTempWeight > iBestPlotWeight)
				{
					iBestPlotWeight = iTempWeight;
					pBestPlot = pPlot;
				}
			}
		}

		// Couldn't find a valid spot
		if (!pBestPlot)
			return iNumUnitSpawned;

		// Actually spawn the unit
		CvUnit* pUnit = kPlayer.initUnit(eUnit, pBestPlot->getX(), pBestPlot->getY());
		if (!pUnit->jumpToNearestValidPlotWithinRange(3))
		{
			ASSERT_DEBUG(false, "Couldn't spawn unit");
			pUnit->kill(false);
		}
		else
		{
			iNumUnitSpawned++;
			pUnit->finishMoves();
			if (!kPlayer.isBarbarian())
				addProductionExperience(pUnit);
		}
	}

	return iNumUnitSpawned;
}

// If existing number of free buildings < iValue, convert existing non-free buildings to free versions and give refund (if applicable)
// If existing number of free buildings > iValue, simply remove free buildings
bool CvCity::SetNumFreeBuilding(const BuildingTypes eBuilding, const int iValue, const bool bRefund, const bool bValidate)
{
	ASSERT_DEBUG(eBuilding != NO_BUILDING);

	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if (!pkBuildingInfo)
		return false;

	int iNumFreeBuilding = GetCityBuildings()->GetNumFreeBuilding(eBuilding);
	int iNumNewFreeBuilding = iValue - iNumFreeBuilding;
	if (iNumNewFreeBuilding == 0)
		return true;

	if (iNumNewFreeBuilding > 0)
	{
		if (bValidate && !isValidBuildingLocation(eBuilding))
			return false;

		CvPlayer& kOwner = GET_PLAYER(getOwner());
		int iNumRealBuilding = GetCityBuildings()->GetNumRealBuilding(eBuilding);
		int iNumReplacedBuilding = min(iNumRealBuilding, iNumNewFreeBuilding);
		if (iNumRealBuilding > 0)
		{
			GetCityBuildings()->SetNumRealBuilding(eBuilding, iNumRealBuilding - iNumReplacedBuilding);
			if (bRefund && !pkBuildingInfo->IsDummy())
			{
				if (pkBuildingInfo->IsFaithPurchaseOnly())
				{
					int iRefund = GetFaithPurchaseCost(eBuilding) * iNumReplacedBuilding;
					kOwner.doInstantYield(INSTANT_YIELD_TYPE_FAITH_REFUND, false, NO_GREATPERSON, NO_BUILDING, iRefund, false, NO_PLAYER, NULL, false, this);
				}
				else
				{
					int iRefund = getProductionNeeded(eBuilding, true) * iNumReplacedBuilding;
					kOwner.doInstantYield(INSTANT_YIELD_TYPE_REFUND, false, NO_GREATPERSON, NO_BUILDING, iRefund, false, NO_PLAYER, NULL, false, this);
				}
			}
		}

		if (getFirstBuildingOrder(eBuilding) == 0)
		{
			clearOrderQueue();
			chooseProduction(); // Send a notification to the user that what they were building was given to them, and they need to produce something else.
		}
	}

	GetCityBuildings()->SetNumFreeBuilding(eBuilding, iValue);
	return true;
}

// Get the corresponding building type of eBuildingClass of the player, OR an existing building type in the city if MOD_BUILDINGS_THOROUGH_PREREQUISITES is on
// This assumes there can only be at most one building of eBuildingClass here
// Also returns the former if bFallback is true and there's no building of eBuildingClass here
// A potentially generic version of CvCityBuildings::GetBuildingTypeFromClass()
BuildingTypes CvCity::GetBuildingTypeFromClass(const BuildingClassTypes eBuildingClass, const bool bFallback) const
{
	if (MOD_BUILDINGS_THOROUGH_PREREQUISITES)
	{
		BuildingTypes eBuilding = GetCityBuildings()->GetBuildingTypeFromClass(eBuildingClass);
		if (!bFallback || eBuilding != NO_BUILDING)
			return eBuilding;
	}

	return static_cast<BuildingTypes>(getCivilizationInfo().getCivilizationBuildings(eBuildingClass));
}

// Add palace and other CAPITAL-ONLY free buildings (from trait, policy, etc.) to this city (presumably the new capital)
// If bRemoveFromCurrent is true, also remove these buildings from the current capital
// Make sure to only call this with the flag if this city hasn't been set as the new capital!
void CvCity::AddFreeCapitalBuildings(const bool bRemoveFromCurrent)
{
	BuildingClassTypes ePalaceClass = static_cast<BuildingClassTypes>(GD_INT_GET(CAPITAL_BUILDINGCLASS));
	BuildingTypes ePalace = GetBuildingTypeFromClass(ePalaceClass, true);
	CvPlayer& kOwner = GET_PLAYER(getOwner());
	CvCity* pCurrentCapital = kOwner.getCapitalCity();

	if (bRemoveFromCurrent && isCapital())
		return;

	if (ePalace != NO_BUILDING)
	{
		// Remove the Palace from the current capital, if any
		if (bRemoveFromCurrent && pCurrentCapital)
		{
			pCurrentCapital->GetCityBuildings()->RemoveAllRealBuildingsOfClass(ePalaceClass);
		}

		// Add the Palace to the new capital (this city)
		GetCityBuildings()->SetNumRealBuilding(ePalace, 1);
	}

	// Check for policies that add capital buildings and transfer them.
	for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
	{
		BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iI);

		if (kOwner.GetNumCitiesFreeChosenBuilding(eBuildingClass) > 0 || kOwner.IsFreeChosenBuildingNewCity(eBuildingClass) || kOwner.IsFreeBuildingAllCity(eBuildingClass))
		{
			BuildingTypes eBuilding = GetBuildingTypeFromClass(eBuildingClass, true);
			if (eBuilding == NO_BUILDING || eBuilding == ePalace)
				continue;

			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
			if (!pkBuildingInfo)
				continue;

			if (!pkBuildingInfo->IsCapitalOnly())
				continue;

			// Delete from current capital
			if (bRemoveFromCurrent && pCurrentCapital)
			{
				pCurrentCapital->GetCityBuildings()->RemoveAllRealBuildingsOfClass(eBuildingClass);
			}

			// Add to new capital (this city)
			SetNumFreeBuilding(eBuilding, 1);
		}
	}

	// Free building in Capital from Trait?
	BuildingTypes eBuilding = kOwner.GetPlayerTraits()->GetFreeCapitalBuilding();
	if (eBuilding != NO_BUILDING)
	{
		TechTypes ePrereqTech = kOwner.GetPlayerTraits()->GetCapitalFreeBuildingPrereqTech();
		if (ePrereqTech != NO_TECH && kOwner.HasTech(ePrereqTech))
		{
			// Delete from current capital
			if (bRemoveFromCurrent && pCurrentCapital)
			{
				pCurrentCapital->SetNumFreeBuilding(eBuilding, 0);
			}

			// Add to new capital (this city)
			SetNumFreeBuilding(eBuilding, 1);
		}
	}
}

// Would this city be destroyed by a nuke of iNukeLevel?
bool CvCity::IsNukeKillable(int iNukeLevel)
{
	if (IsOriginalCapital())
		return false;

	if (iNukeLevel < 2)
		return false;

	if (iNukeLevel > 2)
		return true;

	return getPopulation() < /*5*/ GD_INT_GET(NUKE_LEVEL2_ELIM_POPULATION_THRESHOLD);
}

FDataStream& operator<<(FDataStream& saveTo, const SCityExtraYields& readFrom)
{
	saveTo << readFrom.forTerrain;
	saveTo << readFrom.forXTerrain;
	saveTo << readFrom.forTerrainFromBuildings;
	saveTo << readFrom.forTerrainFromReligion;

	saveTo << readFrom.forFeature;
	saveTo << readFrom.forXFeature;
	saveTo << readFrom.forFeatureFromBuildings;
	saveTo << readFrom.forFeatureFromReligion;
	saveTo << readFrom.forFeatureUnimproved;

	saveTo << readFrom.forImprovement;
	saveTo << readFrom.forSpecialist;
	saveTo << readFrom.forResource;
	saveTo << readFrom.forPlot;
	saveTo << readFrom.forYield;
	saveTo << readFrom.forActualYield;
	saveTo << readFrom.forLocalBuilding;
	saveTo << readFrom.forReligionBuilding;
	return saveTo;
}
FDataStream& operator>>(FDataStream& loadFrom, SCityExtraYields& writeTo)
{
	loadFrom >> writeTo.forTerrain;
	loadFrom >> writeTo.forXTerrain;
	loadFrom >> writeTo.forTerrainFromBuildings;
	loadFrom >> writeTo.forTerrainFromReligion;

	loadFrom >> writeTo.forFeature;
	loadFrom >> writeTo.forXFeature;
	loadFrom >> writeTo.forFeatureFromBuildings;
	loadFrom >> writeTo.forFeatureFromReligion;
	loadFrom >> writeTo.forFeatureUnimproved;

	loadFrom >> writeTo.forImprovement;
	loadFrom >> writeTo.forSpecialist;
	loadFrom >> writeTo.forResource;
	loadFrom >> writeTo.forPlot;
	loadFrom >> writeTo.forYield;
	loadFrom >> writeTo.forActualYield;
	loadFrom >> writeTo.forLocalBuilding;
	loadFrom >> writeTo.forReligionBuilding;
	return loadFrom;
}

FDataStream& operator<<(FDataStream& saveTo, const SCityEventYields& readFrom)
{
	saveTo << readFrom.forBuilding;
	saveTo << readFrom.forBuildingModifier;
	saveTo << readFrom.forFeature;
	saveTo << readFrom.forImprovement;
	saveTo << readFrom.forResource;
	saveTo << readFrom.forSpecialist;
	saveTo << readFrom.forTerrain;
	return saveTo;
}
FDataStream& operator>>(FDataStream& loadFrom, SCityEventYields& writeTo)
{
	loadFrom >> writeTo.forBuilding;
	loadFrom >> writeTo.forBuildingModifier;
	loadFrom >> writeTo.forFeature;
	loadFrom >> writeTo.forImprovement;
	loadFrom >> writeTo.forResource;
	loadFrom >> writeTo.forSpecialist;
	loadFrom >> writeTo.forTerrain;
	return loadFrom;
}
