/*	-------------------------------------------------------------------------------------------------------
	Â© 1991-2012 Take-Two Interactive Software and its subsidiaries.  Developed by Firaxis Games.
	Sid Meier's Civilization V, Civ, Civilization, 2K Games, Firaxis Games, Take-Two Interactive Software
	and their respective logos are all trademarks of Take-Two interactive Software, Inc.
	All other marks and trademarks are the property of their respective owners.
	All rights reserved.
	------------------------------------------------------------------------------------------------------- */

#include "CvGameCoreDLLPCH.h"
#include "CvGlobals.h"
#include "CvCity.h"
#include "CvArea.h"
#include "CvMap.h"
#include "CvPlot.h"
#include "CvTeam.h"
#include "CvGameCoreUtils.h"
#include "CvInternalGameCoreUtils.h"
#include "CvPlayerAI.h"
#include "CvUnit.h"
#include "CvInfos.h"
#include "CvRandom.h"
#include "CvImprovementClasses.h"
#include "CvCitySpecializationAI.h"
#include "CvEconomicAI.h"
#include "CvMilitaryAI.h"
#include "CvNotifications.h"
#include "CvUnitCombat.h"
#include "CvTypes.h"

// interfaces used
#include "CvEnumSerialization.h"
#include "CvDiplomacyAI.h"
#include "CvWonderProductionAI.h"

#include "CvDllCity.h"
#include "CvDllCombatInfo.h"
#include "CvDllPlot.h"
#include "CvDllUnit.h"
#include "CvGameQueries.h"

#include "CvInfosSerializationHelper.h"
#include "cvStopWatch.h"
#include "CvCityManager.h"
#if defined(MOD_BALANCE_CORE)
#include "CvBarbarians.h"
#endif

#include "CvDllNetMessageExt.h"
// include after all other headers
#include "LintFree.h"

OBJECT_VALIDATE_DEFINITION(CvCity)

int g_iCityToTrace = 0;

//	--------------------------------------------------------------------------------
namespace FSerialization
{

	//is it wise to store pointers here?
	//anyway vector seems better than set because of the defined ordering
	std::vector<CvCity*> citiesToCheck;

	void SyncCities()
	{
		if (GC.getGame().isNetworkMultiPlayer())
		{
			PlayerTypes authoritativePlayer = GC.getGame().getActivePlayer();

			std::vector<CvCity*>::const_iterator i;
			for (i = citiesToCheck.begin(); i != citiesToCheck.end(); ++i)
			{
				CvCity* city = *i;

				if (city)
				{
					const CvPlayer& player = GET_PLAYER(city->getOwner());
					if (city->getOwner() == authoritativePlayer || (gDLL->IsHost() && !player.isHuman() && player.isAlive()))
					{
						CvSyncArchive<CvCity>& archive = city->getSyncArchive();
						archive.collectDeltas();
						if (archive.hasDeltas())
						{
							FMemoryStream memoryStream;
							std::vector<std::pair<std::string, std::string> > callStacks;
							archive.saveDelta(memoryStream, callStacks);
							gDLL->sendCitySyncCheck(city->getOwner(), city->GetID(), memoryStream, callStacks);
						}
					}
				}
			}
		}
	}

	//	--------------------------------------------------------------------------------
	// clears ALL deltas for ALL units
	void ClearCityDeltas()
	{
		std::vector<CvCity*>::iterator i;
		for (i = citiesToCheck.begin(); i != citiesToCheck.end(); ++i)
		{
			CvCity* city = *i;

			if (city)
			{
				FAutoArchive& archive = city->getSyncArchive();
				archive.clearDelta();
			}
		}
	}
}

//helper function for managing extra yields
template <typename T>
bool ModifierUpdateInsertRemove(vector<pair<T, int>>& container, T key, int value, bool modifyExisting)
{
	for (typename vector<pair<T, int>>::iterator it = container.begin(); it != container.end(); ++it)
	{
		if (it->first == key)
		{
			if (modifyExisting && value != 0)
			{
				it->second += value;
				if (it->second == 0)
					container.erase(it);
				return true; //update was made
			}

			if (!modifyExisting && value != it->second)
			{
				it->second = value;
				if (it->second == 0)
					container.erase(it);
				return true; //update was made
			}

			return false; //no change
		}
	}

	//if we're here we don't have an entry yet
	if (value != 0)
	{
		container.push_back(make_pair(key, value));
		return true; //update was made
	}

	return false;
}

template <typename T>
int ModifierLookup(const vector<pair<T, int>>& container, T key)
{
	for (typename vector<pair<T, int>>::const_iterator it = container.begin(); it != container.end(); ++it)
		if (it->first == key)
			return it->second;

	return 0;
}

//	--------------------------------------------------------------------------------
// Public Functions...
CvCity::CvCity() :
	m_syncArchive()
	, m_eOwner(NO_PLAYER)
	, m_iX()
	, m_iY()
	, m_iID()
	, m_iRallyX()
	, m_iRallyY()
	, m_iGameTurnFounded()
	, m_iGameTurnAcquired()
	, m_iGameTurnLastExpanded()
#if defined(MOD_BALANCE_CORE)
	, m_iAdditionalFood()
	, m_iCityBuildingBombardRange()
	, m_iCityIndirectFire()
	, m_iCityBuildingRangeStrikeModifier()
#endif
	, m_iPopulation()
#if defined(MOD_GLOBAL_CITY_AUTOMATON_WORKERS)
	, m_iAutomatons(0)
#endif
	, m_iHighestPopulation()
	, m_iExtraHitPoints()
	, m_iNumGreatPeople()
	, m_iBaseGreatPeopleRate()
	, m_iGreatPeopleRateModifier()
	, m_iJONSCultureStored()
	, m_iJONSCultureLevel()
	, m_iJONSCulturePerTurnFromPolicies()
	, m_iJONSCulturePerTurnFromSpecialists()
	, m_iaAddedYieldPerTurnFromTraits()
	, m_iFaithPerTurnFromPolicies()
	, m_iCultureRateModifier()
	, m_iNumWorldWonders()
	, m_iNumTeamWonders()
	, m_iNumNationalWonders()
	, m_iWonderProductionModifier()
	, m_iCapturePlunderModifier()
	, m_iBorderGrowthRateIncrease()
	, m_iPlotCultureCostModifier()
	, m_iPlotBuyCostModifier()
	, m_iMaintenance()
	, m_iHealRate()
	, m_iNoOccupiedUnhappinessCount()
#if defined(HH_MOD_BUILDINGS_FRUITLESS_PILLAGE)
	, m_iLocalGainlessPillageCount()
#endif
	, m_iFood()
	, m_iMaxFoodKeptPercent()
	, m_iOverflowProduction()
	, m_iFeatureProduction()
	, m_iMilitaryProductionModifier()
	, m_iSpaceProductionModifier()
	, m_iFreeExperience()
	, m_iMaxAirUnits()
	, m_iNukeModifier()
	, m_iCitySizeBoost()
	, m_iSpecialistFreeExperience()
	, m_iStrengthValue()
	, m_iDamage()
	, m_iThreatValue()
	, m_hGarrison()
	, m_iResourceDemanded()
	, m_iResourceDemandedCounter()
	, m_iWeLoveTheKingDayCounter()
	, m_iLastTurnGarrisonAssigned()
	, m_iThingsProduced()
	, m_iDemandResourceCounter()
	, m_iResistanceTurns()
	, m_iRazingTurns()
	, m_iLowestRazingPop()
	, m_iCountExtraLuxuries()
	, m_iCheapestPlotInfluenceDistance()
	, m_iEspionageModifier()
	, m_iEspionageTurnsModifierEnemy()
	, m_iTradeRouteRecipientBonus()
	, m_iTradeRouteSeaGoldBonus()
	, m_iTradeRouteLandGoldBonus()
	, m_iTradeRouteTargetBonus()
	, m_iNumTradeRouteBonus()
	, m_iCityConnectionTradeRouteGoldModifier()
	, m_unitBeingBuiltForOperation()
	, m_bNeverLost()
	, m_bDrafted()
	, m_bProductionAutomated()
	, m_bLayoutDirty()
	, m_bMadeAttack()
	, m_bOccupied()
	, m_bPuppet()
	, m_bIgnoreCityForHappiness()
	, m_bIndustrialRouteToCapital()
	, m_iTerrainImprovementNeed()
	, m_ePreviousOwner()
	, m_eOriginalOwner()
	, m_ePlayersReligion()
	, m_aiSeaPlotYield()
	, m_aiRiverPlotYield()
	, m_aiLakePlotYield()
	, m_aiSeaResourceYield()
	, m_aiBaseYieldRateFromTerrain()
	, m_aiBaseYieldRateFromBuildings()
	, m_aiBaseYieldRateFromSpecialists()
	, m_aiBaseYieldRateFromMisc()
	, m_aiBaseYieldRateFromReligion()
	, m_aiYieldRateModifier()
	, m_aiYieldPerPop()
#if defined(MOD_BALANCE_CORE)
	, m_aiYieldPerPopInEmpire()
#endif
	, m_aiYieldPerReligion()
	, m_aiPowerYieldRateModifier()
	, m_aiResourceYieldRateModifier()
	, m_aiExtraSpecialistYield()
	, m_aiProductionToYieldModifier()
	, m_aiDomainFreeExperience()
	, m_aiDomainProductionModifier()
#if defined(MOD_BALANCE_CORE_EVENTS)
	, m_aiGreatWorkYieldChange()
	, m_aiEconomicValue()
	, m_miInstantYieldsTotal()
	, m_aiEventChoiceDuration()
	, m_aiEventIncrement()
	, m_abEventActive()
	, m_abEventChoiceActive()
	, m_abEventChoiceFired()
	, m_abEventFired()
	, m_aiEventCooldown()
	, m_aiEventCityYield()
	, m_aiEventCityYieldModifier()
	, m_iEventHappiness()
	, m_iCityEventCooldown()
	, m_iHappinessDelta()
	, m_iPillagedPlots()
	, m_iGrowthFromTourism()
	, m_iGrowthEvent()
	, m_iBuildingClassHappiness()
	, m_iReligionHappiness()
#endif
	, m_abEverLiberated()
	, m_strScriptData()
	, m_paiNoResource()
	, m_paiFreeResource()
	, m_paiNumResourcesLocal()
	, m_paiNumUnimprovedResourcesLocal()
	, m_paiProjectProduction()
	, m_paiSpecialistProduction()
	, m_paiUnitProduction()
	, m_paiUnitProductionTime()
	, m_paiSpecialistCount()
	, m_paiMaxSpecialistCount()
	, m_paiForceSpecialistCount()
	, m_paiFreeSpecialistCount()
	, m_paiImprovementFreeSpecialists()
	, m_paiUnitCombatFreeExperience()
	, m_paiUnitCombatProductionModifier()
	, m_paiFreePromotionCount()
	, m_iBaseHappinessFromBuildings()
	, m_iUnmoddedHappinessFromBuildings()
	, m_bRouteToCapitalConnectedLastTurn()
	, m_bRouteToCapitalConnectedThisTurn()
	, m_strName()
	, m_orderQueue()
	, m_pCityBuildings(FNEW(CvCityBuildings, c_eCiv5GameplayDLL, 0))
	, m_pCityStrategyAI(FNEW(CvCityStrategyAI, c_eCiv5GameplayDLL, 0))
	, m_pCityCitizens(FNEW(CvCityCitizens, c_eCiv5GameplayDLL, 0))
	, m_pCityReligions(FNEW(CvCityReligions, c_eCiv5GameplayDLL, 0))
	, m_pEmphases(FNEW(CvCityEmphases, c_eCiv5GameplayDLL, 0))
	, m_pCityEspionage(FNEW(CvCityEspionage, c_eCiv5GameplayDLL, 0))
	, m_pCityCulture(FNEW(CvCityCulture, c_eCiv5GameplayDLL, 0))
	, m_iPopulationRank()
	, m_bPopulationRankValid()
	, m_aiBaseYieldRank()
	, m_abBaseYieldRankValid()
	, m_aiYieldRank()
	, m_abYieldRankValid()
	, m_bOwedCultureBuilding()
#if defined(MOD_BUILDINGS_CITY_WORKING)
	, m_iCityWorkingChange()
	, m_iCitySupplyModifier()
	, m_iCitySupplyFlat()
	, m_iDamageReductionFlat()
	, m_bAllowsProductionTradeRoutes()
	, m_bAllowsFoodTradeRoutes()
	, m_bAllowPuppetPurchase()
	, m_iHappinessFromEmpire()
	, m_iUnhappinessFromEmpire()
	, m_iCachedBasicNeedsMedian()
	, m_iCachedGoldMedian()
	, m_iCachedScienceMedian()
	, m_iCachedCultureMedian()
	, m_iCachedTechNeedModifier()
	, m_iCachedEmpireSizeModifier()
	, m_iYieldMediansCachedTurn()
#endif
#if defined(MOD_BUILDINGS_CITY_AUTOMATON_WORKERS)
	, m_iCityAutomatonWorkersChange()
#endif
#if defined(MOD_RELIGION_CONVERSION_MODIFIERS)
	, m_iConversionModifier()
#endif
	, m_aiBaseYieldRateFromLeague()
	, m_iTotalScienceyAid()
	, m_iTotalArtsyAid()
	, m_iTotalGreatWorkAid()
	, m_iEmpireSizeModifierReduction()
	, m_iDistressFlatReduction()
	, m_iPovertyFlatReduction()
	, m_iIlliteracyFlatReduction()
	, m_iBoredomFlatReduction()
	, m_iReligiousUnrestFlatReduction()
	, m_iBasicNeedsMedianModifier()
	, m_iGoldMedianModifier()
	, m_iScienceMedianModifier()
	, m_iCultureMedianModifier()
	, m_iReligiousUnrestModifier()
	, m_aiChangeGrowthExtraYield()
#if defined(MOD_BALANCE_CORE)
	, m_iNukeInterceptionChance()
	, m_iTradeRouteSeaDistanceModifier()
	, m_iTradeRouteLandDistanceModifier()
	, m_iTradePriorityLand()
	, m_iTradePrioritySea()
	, m_iUnitPurchaseCooldown()
	, m_iUnitPurchaseCooldownCivilian()
	, m_iUnitPurchaseCooldownMod()
	, m_iUnitPurchaseCooldownCivilianMod()
	, m_iUnitFaithPurchaseCooldown()
	, m_iUnitFaithPurchaseCooldownCivilian()
	, m_iBuildingPurchaseCooldown()
	, m_iReligiousTradeModifier()
	, m_iCityAirStrikeDefense()
	, m_iFreeBuildingTradeTargetCity()
	, m_iBaseTourism()
	, m_iBaseTourismBeforeModifiers()
	, m_aiYieldFromVictory()
	, m_aiYieldFromVictoryGlobal()
	, m_aiYieldFromVictoryGlobalEraScaling()
	, m_aiYieldFromPillage()
	, m_aiYieldFromPillageGlobal()
	, m_aiNumTimesAttackedThisTurn()
	, m_aiLongestPotentialTradeRoute()
	, m_aiNumProjects()
	, m_aiYieldFromKnownPantheons()
	, m_aiGoldenAgeYieldMod()
	, m_aiYieldFromWLTKD()
	, m_aiYieldFromConstruction()
	, m_aiYieldFromTech()
	, m_aiYieldFromUnitProduction()
	, m_aiYieldFromBirth()
	, m_aiYieldFromBorderGrowth()
	, m_aiYieldFromPolicyUnlock()
	, m_aiYieldFromPurchase()
	, m_aiYieldFromFaithPurchase()
	, m_aiYieldFromUnitLevelUp()
	, m_aiYieldFromCombatExperience()
	, m_aiYieldPerAlly()
	, m_aiYieldPerFriend()
	, m_aiYieldFromInternalTREnd()
	, m_aiYieldFromInternalTR()
	, m_aiYieldFromProcessModifier()
	, m_aiSpecialistRateModifier()
	, m_aiNumTimesOwned()
	, m_aiStaticCityYield()
	, m_aiThemingYieldBonus()
	, m_aiYieldFromSpyAttack()
	, m_aiYieldFromSpyDefense()
	, m_aiBaseYieldRateFromCSAlliance()
	, m_aiBaseYieldRateFromCSFriendship()
	, m_aiYieldFromMinors()
	, m_aiResourceQuantityPerXFranchises()
	, m_aiYieldChangeFromCorporationFranchises()
	, m_aiResourceQuantityFromPOP()
	, m_iLandTourismBonus()
	, m_iSeaTourismBonus()
	, m_iAlwaysHeal()
	, m_iResourceDiversityModifier()
	, m_iNoUnhappfromXSpecialists()
	, m_bNoWarmonger()
#endif
#if defined(MOD_BALANCE_CORE_SPIES_ADVANCED)
	, m_iCitySpyRank()
	, m_iTurnsSinceRankAnnouncement()
#endif
#if defined(MOD_BALANCE_CORE)
	, m_abIsBestForWonder()
	, m_abIsPurchased()
	, m_abTraded()
	, m_abIgnoredForExpansionBickering()
	, m_abPaidAdoptionBonus()
	, m_aiReligiousPressureModifier()
	, m_iExtraBuildingMaintenance()
	, m_paiNumTerrainWorked()
	, m_paiNumFeaturelessTerrainWorked()
	, m_paiNumFeatureWorked()
	, m_paiNumResourceWorked()
	, m_paiNumImprovementWorked()
#endif
#if defined(MOD_BALANCE_CORE_POLICIES)
	, m_paiBuildingClassCulture()
	, m_paiHurryModifier()
#endif
#if defined(MOD_BALANCE_CORE)
	, m_vClosestNeighbors()
#endif
	, m_yieldChanges(NUM_YIELD_TYPES)
	, m_eventYields(NUM_YIELD_TYPES)
	, m_ppiGreatPersonProgressFromConstruction()
#if defined(MOD_BALANCE_CORE)
	, m_abOwedChosenBuilding()
	, m_abBuildingInvestment()
	, m_abUnitInvestment()
	, m_abBuildingConstructed()
	, m_iBorderObstacleCity()
	, m_iBorderObstacleWater()
	, m_iDeepWaterTileDamage()
	, m_iNumNearbyMountains()
	, m_iLocalUnhappinessMod()
	, m_aiBonusSightEspionage()
#endif
	, m_bOwedFoodBuilding()
#if defined(MOD_CORE_PER_TURN_DAMAGE)
	, m_iDamageTakenThisTurn()
	, m_iDamageTakenLastTurn()
#endif
#if defined(MOD_BALANCE_CORE)
	, m_bIsColony()
	, m_iProvinceLevel()
	, m_iOrganizedCrime()
	, m_iResistanceCounter()
	, m_iPlagueCounter()
	, m_iPlagueTurns()
	, m_iSappedTurns()
	, m_iPlagueType()
	, m_iLoyaltyCounter()
	, m_iDisloyaltyCounter()
	, m_iLoyaltyStateType()
	, m_aiYieldModifierFromHappiness()
	, m_aiYieldModifierFromHealth()
	, m_aiYieldModifierFromCrime()
	, m_aiYieldModifierFromDevelopment()
	, m_aiYieldFromHappiness()
	, m_aiYieldFromHealth()
	, m_aiYieldFromCrime()
	, m_aiYieldFromDevelopment()
	, m_aiTempCaptureData()
	, m_abTempCaptureData()
	, m_bIsPendingCapture()
#endif
{
	OBJECT_ALLOCATED
		FSerialization::citiesToCheck.push_back(this);

	reset(0, NO_PLAYER, 0, 0, true);

	if (GC.getGame().isNetworkMultiPlayer())
	{
		m_syncArchive.initSyncVars(*FNEW(CvSyncArchive<CvCity>::SyncVars(*this), c_eCiv5GameplayDLL, 0));
	}
}

//	--------------------------------------------------------------------------------
CvCity::~CvCity()
{
	CvCityManager::OnCityDestroyed(this);

	//really shouldn't happen that it's not present, but there was a crash here
	std::vector<CvCity*>::iterator it = std::find(FSerialization::citiesToCheck.begin(), FSerialization::citiesToCheck.end(), this);
	if (it != FSerialization::citiesToCheck.end())
		FSerialization::citiesToCheck.erase(it);

	uninit();

	delete m_pCityBuildings;
	delete m_pCityStrategyAI;
	delete m_pCityCitizens;
	delete m_pCityReligions;
	delete m_pEmphases;
	delete m_pCityEspionage;
	delete m_pCityCulture;

	OBJECT_DESTROYED
}


//	--------------------------------------------------------------------------------
void CvCity::init(int iID, PlayerTypes eOwner, int iX, int iY, bool bBumpUnits, bool bInitialFounding, ReligionTypes eInitialReligion, const char* szName, CvUnitEntry* pkSettlerUnitEntry)
{
	VALIDATE_OBJECT
	//CvPlot* pAdjacentPlot;
	CvPlot* pPlot = GC.getMap().plot(iX, iY);
	BuildingTypes eLoopBuilding;
	int iI = 0;

	//--------------------------------
	// Init saved data
	reset(iID, eOwner, pPlot->getX(), pPlot->getY());

	CvPlayerAI& owningPlayer = GET_PLAYER(getOwner());

	//--------------------------------
	// Init non-saved data

	//--------------------------------
	// Init other game data
	CvString strNewCityName = owningPlayer.getNewCityName();
	setName(strNewCityName.c_str());

	if (MOD_API_ACHIEVEMENTS && strcmp(strNewCityName.c_str(), "TXT_KEY_CITY_NAME_LLANFAIRPWLLGWYNGYLL") == 0)
	{
		gDLL->UnlockAchievement(ACHIEVEMENT_XP1_34);
	}

	if (bInitialFounding)
	{
		SetNumTimesOwned(eOwner, 1);
	}

	pPlot->SetPlayerThatDestroyedCityHere(NO_PLAYER);

	// Plot Ownership
	pPlot->setOwner(getOwner(), m_iID, bBumpUnits);

	// Clear the improvement before the city attaches itself to the plot, else the improvement does not
	// remove the resource allocation from the current owner.  This would result in double resource points because
	// the plot has already had setOwner called on it (above), giving the player the resource points.
	pPlot->setImprovementType(NO_IMPROVEMENT);

	//only after the owner is set!
	pPlot->setIsCity(true, m_iID, getWorkPlotDistance());

#if defined(MOD_EVENTS_TILE_IMPROVEMENTS)
	pPlot->SetImprovementPillaged(false, false);
	pPlot->SetRoutePillaged(false, false);
#else
	pPlot->SetImprovementPillaged(false);
	pPlot->SetRoutePillaged(false);
#endif

	//clear the first ring
	int iRange = min(1, /*1*/ GD_INT_GET(CITY_STARTING_RINGS));
	for (int iDX = -iRange; iDX <= iRange; iDX++)
	{
		for (int iDY = -iRange; iDY <= iRange; iDY++)
		{
			CvPlot* pLoopPlot = plotXYWithRangeCheck(getX(), getY(), iDX, iDY, iRange);
			if (pLoopPlot != NULL)
				pLoopPlot->setOwner(getOwner(), m_iID, bBumpUnits);
		}
	}

	// this is a list of plot that are owned by the player
	owningPlayer.UpdatePlots();
#if defined(MOD_GLOBAL_CITY_FOREST_BONUS)
	static BuildTypes eBuildRemoveForest = (BuildTypes)GC.getInfoTypeForString("BUILD_REMOVE_FOREST");
	static BuildTypes eBuildRemoveJungle = (BuildTypes)GC.getInfoTypeForString("BUILD_REMOVE_JUNGLE");
	bool bClearedForest = false;
	bool bClearedJungle = false;
	FeatureTypes eFeature = pPlot->getFeatureType();
#endif

	//SCRIPT call ' bool citiesDestroyFeatures(iX, iY);'
	if (pPlot->getFeatureType() != NO_FEATURE)
	{
#if defined(MOD_GLOBAL_CITY_FOREST_BONUS)
		// Only for major civs building on a forest
		if (MOD_GLOBAL_CITY_FOREST_BONUS && eBuildRemoveForest != -1 && !owningPlayer.isMinorCiv() && (eFeature == FEATURE_FOREST))
		{
			// Don't do this for the AI capitals - it's just too much of an initial boost!
			TechTypes iRequiredTech = (TechTypes)gCustomMods.getOption("GLOBAL_CITY_FOREST_BONUS_TECH", -1);
			bClearedForest = (iRequiredTech == -1 || GET_TEAM(owningPlayer.getTeam()).GetTeamTechs()->HasTech(iRequiredTech));
		}
		// OR only for major civs building on a jungle
		else if (MOD_GLOBAL_CITY_FOREST_BONUS && (eBuildRemoveJungle != -1) && (!owningPlayer.isMinorCiv()) && (eFeature == FEATURE_JUNGLE))
		{
			TechTypes iRequiredTech = (TechTypes)gCustomMods.getOption("GLOBAL_CITY_FOREST_BONUS_TECH", -1);
			bClearedJungle = (iRequiredTech == -1 || GET_TEAM(owningPlayer.getTeam()).GetTeamTechs()->HasTech(iRequiredTech));
		}
#endif

		pPlot->setFeatureType(NO_FEATURE);
	}

	// wipe out dig sites
	pPlot->ClearArchaeologicalRecord();

	setupGraphical();

	pPlot->updateCityRoute();

	//force recalculation of trade routes
	GC.getGame().GetGameTrade()->InvalidateTradePathCache(eOwner);

	for (iI = 0; iI < MAX_TEAMS; iI++)
	{
		if (GET_TEAM((TeamTypes)iI).isAlive())
		{
			if (pPlot->isVisible(((TeamTypes)iI)))
			{
				setRevealed(((TeamTypes)iI), true);
			}
		}
	}

	int iNumBuildingInfos = GC.getNumBuildingInfos();
	for (iI = 0; iI < iNumBuildingInfos; iI++)
	{
		if (owningPlayer.isBuildingFree((BuildingTypes)iI))
		{
			if (isValidBuildingLocation((BuildingTypes)iI))
			{
				m_pCityBuildings->SetNumFreeBuilding(((BuildingTypes)iI), 1);
			}
		}
	}

	// Free Buildings
	const CvCivilizationInfo& thisCiv = getCivilizationInfo();
	for (int iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
	{
		const BuildingClassTypes eBuildingClass = static_cast<BuildingClassTypes>(iBuildingClassLoop);
		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
		if (!pkBuildingClassInfo)
		{
			continue;
		}

		BuildingTypes eBuilding = ((BuildingTypes)(thisCiv.getCivilizationBuildings(eBuildingClass)));

		if (eBuilding != NO_BUILDING)
		{
			if (GET_PLAYER(getOwner()).GetNumCitiesFreeChosenBuilding(eBuildingClass) > 0
				|| GET_PLAYER(getOwner()).IsFreeChosenBuildingNewCity(eBuildingClass)
				|| GET_PLAYER(getOwner()).IsFreeBuildingAllCity(eBuildingClass)
				|| (GET_PLAYER(getOwner()).IsFreeBuildingNewFoundCity(eBuildingClass) && bInitialFounding))
			{
				CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
				if (pkBuildingInfo)
				{
					if (isValidBuildingLocation(eBuilding))
					{
						if (GetCityBuildings()->GetNumRealBuilding(eBuilding) > 0)
						{
							if (pkBuildingInfo->IsFaithPurchaseOnly())
							{
								int iFaithRefund = GetFaithPurchaseCost(eBuilding);
								GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_FAITH_REFUND, false, NO_GREATPERSON, NO_BUILDING, iFaithRefund, false, NO_PLAYER, NULL, false, this);
							}
							else
							{
								int iProductionRefund = getProductionNeeded(eBuilding);
								GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_REFUND, false, NO_GREATPERSON, NO_BUILDING, iProductionRefund, false, NO_PLAYER, NULL, false, this);
							}
							GetCityBuildings()->SetNumRealBuilding(eBuilding, 0);
						}

						GetCityBuildings()->SetNumFreeBuilding(eBuilding, 1);

						if (GetCityBuildings()->GetNumFreeBuilding(eBuilding) > 0)
						{
							GET_PLAYER(getOwner()).ChangeNumCitiesFreeChosenBuilding(eBuildingClass, -1);
						}
						if (getFirstBuildingOrder(eBuilding) == 0)
						{
							clearOrderQueue();
							chooseProduction();
							// Send a notification to the user that what they were building was given to them, and they need to produce something else.
						}
					}
				}
			}
		}
	}
	if (bInitialFounding)
	{
		for (int iUnitClassLoop = 0; iUnitClassLoop < GC.getNumUnitClassInfos(); iUnitClassLoop++)
		{
			const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iUnitClassLoop);
			CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
			if (!pkUnitClassInfo)
			{
				continue;
			}
			if (GET_PLAYER(getOwner()).IsFreeUnitNewFoundCity(eUnitClass))
			{
				UnitTypes eUnit = GET_PLAYER(getOwner()).GetSpecificUnitType(eUnitClass);
				if (eUnit != NO_UNIT)
				{
					CvUnit* pFreeUnit = owningPlayer.initUnit(eUnit, getX(), getY());
					bool bJumpSuccess = pFreeUnit->jumpToNearestValidPlot();
					if (bJumpSuccess)
					{
						addProductionExperience(pFreeUnit);
						if (getFirstUnitOrder(eUnit) == 0)
						{
							clearOrderQueue();
							chooseProduction();
						}
					}
					else
					{
						pFreeUnit->kill(false);
					}
				}
			}
		}
	}

	//don't need to update landmass stats, that is implied by area changes
	GC.getMap().getAreaById(pPlot->getArea())->changeCitiesPerPlayer(getOwner(), 1);
	std::vector<int> areas = pPlot->getAllAdjacentAreas();
	for (std::vector<int>::iterator it = areas.begin(); it != areas.end(); ++it)
	{
		CvArea* pkArea = GC.getMap().getAreaById(*it);
		if (pkArea->isWater())
			pkArea->changeCitiesPerPlayer(getOwner(), 1);
	}

	GET_TEAM(getTeam()).changeNumCities(1);

	GC.getGame().changeNumCities(1);
	// Tell the city manager now as well.
	CvCityManager::OnCityCreated(this);

	int iGameTurn = GC.getGame().getGameTurn();
	setGameTurnFounded(iGameTurn);
	setGameTurnAcquired(iGameTurn);
	setGameTurnLastExpanded(iGameTurn);

	GetCityCitizens()->DoFoundCity();

	// Default starting population
	changePopulation(/*1*/ GD_INT_GET(INITIAL_CITY_POPULATION) + GC.getGame().getStartEraInfo().getFreePopulation(), true, true);
	// Free population from things (e.g. Policies)
	changePopulation(GET_PLAYER(getOwner()).GetNewCityExtraPopulation(), true, true);

	// We do this here as changePopulation() sends a game event we may have caught to do funky renaming things
	if (szName) 
	{
		setName(szName);
	}

	// Free food from things (e.g. Policies)
	int iFreeFood = growthThreshold() * GET_PLAYER(getOwner()).GetFreeFoodBox();
	changeFoodTimes100(iFreeFood);

	if (bInitialFounding)
	{
		owningPlayer.setFoundedFirstCity(true);
		owningPlayer.ChangeNumCitiesFounded(1);

		if (MOD_BALANCE_CORE && isCapital())
		{
			int iNumAllies = GET_PLAYER(getOwner()).GetNumCSAllies();
			int iNumFriends = GET_PLAYER(getOwner()).GetNumCSFriends();
			if (iNumAllies > 0 || iNumFriends > 0)
			{
				//If we get a yield bonus in all cities because of CS alliance, this is a good place to change it.
				int iEra = owningPlayer.GetCurrentEra();
				if (iEra <= 0)
				{
					iEra = 1;
				}
				for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
				{
					YieldTypes eYield = (YieldTypes)iI;
					if (owningPlayer.GetPlayerTraits()->GetYieldFromCSAlly(eYield) > 0)
					{
						SetBaseYieldRateFromCSAlliance(eYield, (owningPlayer.GetPlayerTraits()->GetYieldFromCSAlly(eYield) * iNumAllies * iEra));
					}
					if (owningPlayer.GetPlayerTraits()->GetYieldFromCSFriend(eYield) > 0)
					{
						SetBaseYieldRateFromCSFriendship(eYield, (owningPlayer.GetPlayerTraits()->GetYieldFromCSFriend(eYield) * iNumFriends * iEra));
					}
				}
			}
		}

		// Free resources under city?
		for (int i = 0; i < GC.getNumResourceInfos(); i++)
		{
			ResourceTypes eResource = (ResourceTypes)i;
			FreeResourceXCities freeResource = owningPlayer.GetPlayerTraits()->GetFreeResourceXCities(eResource);

			if (freeResource.m_iResourceQuantity > 0)
			{
				if (owningPlayer.GetNumCitiesFounded() <= freeResource.m_iNumCities)
				{
					plot()->setResourceType(NO_RESOURCE, 0);
					plot()->setResourceType(eResource, freeResource.m_iResourceQuantity);
				}
			}
		}
#if defined(MOD_BALANCE_CORE_LUXURIES_TRAIT)
		if (MOD_BALANCE_CORE_LUXURIES_TRAIT && !owningPlayer.isMinorCiv() && (owningPlayer.GetPlayerTraits()->GetUniqueLuxuryQuantity() > 0))
		{
			owningPlayer.GetPlayerTraits()->AddUniqueLuxuriesAround(this, owningPlayer.GetPlayerTraits()->GetUniqueLuxuryQuantity());
		}
		else
		{
#endif
			owningPlayer.GetPlayerTraits()->AddUniqueLuxuries(this);
#if defined(MOD_BALANCE_CORE_LUXURIES_TRAIT)
		}
#endif
		if (owningPlayer.isMinorCiv())
		{
			owningPlayer.GetMinorCivAI()->DoAddStartingResources(plot());
		}
	}

	// make sure that all the team members get the city connection update
	for (int i = 0; i < MAX_PLAYERS; i++)
	{
		PlayerTypes ePlayer = (PlayerTypes)i;
		if (GET_PLAYER(ePlayer).getTeam() == owningPlayer.getTeam())
		{
			GET_PLAYER(ePlayer).GetCityConnections()->SetDirty();
		}
	}
	for (int iFeatureLoop = 0; iFeatureLoop < GC.getNumFeatureInfos(); iFeatureLoop++)
	{
		FeatureTypes eFeature2 = (FeatureTypes)iFeatureLoop;
		if (eFeature2 != NO_FEATURE)
		{
			GET_PLAYER(getOwner()).countCityFeatures(eFeature2, true);
		}
	}

	// Policy changes
	for (int iPoliciesLoop = 0; iPoliciesLoop < GC.getNumPolicyInfos(); iPoliciesLoop++)
	{
		PolicyTypes ePolicy = (PolicyTypes)iPoliciesLoop;

		if (owningPlayer.GetPlayerPolicies()->HasPolicy(ePolicy) && !owningPlayer.GetPlayerPolicies()->IsPolicyBlocked(ePolicy))
		{
			// Free Culture-per-turn in every City from Policies
			ChangeJONSCulturePerTurnFromPolicies(GC.getPolicyInfo(ePolicy)->GetCulturePerCity());
		}
	}

	// Add Resource Quantity to total
	if (plot()->getResourceType(getTeam()) != NO_RESOURCE)
	{
		if (GET_TEAM(getTeam()).IsResourceCityTradeable(plot()->getResourceType()))
		{
			owningPlayer.changeNumResourceTotal(plot()->getResourceType(), plot()->getNumResourceForPlayer(getOwner()));
		}
	}

	if (MOD_BALANCE_CORE_EVENTS && bInitialFounding)
		owningPlayer.CheckActivePlayerEvents(this);

	// Update Proximity between this Player and all others
	owningPlayer.DoUpdateProximityToPlayers();

	// Free Buildings in the first City
	if (GC.getGame().isFinalInitialized())
	{
		if (owningPlayer.getNumCities() == 1)
		{
#if defined(MOD_EVENTS_CITY_CAPITAL)
			int eCapitalBuilding = thisCiv.getCivilizationBuildings(GD_INT_GET(CAPITAL_BUILDINGCLASS));
#endif

			for (iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
			{
				CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo((BuildingClassTypes)iI);
				if (!pkBuildingClassInfo)
				{
					continue;
				}

				if (thisCiv.isCivilizationFreeBuildingClass(iI))
				{
					eLoopBuilding = ((BuildingTypes)(thisCiv.getCivilizationBuildings(iI)));

					if (eLoopBuilding != NO_BUILDING)
					{
						m_pCityBuildings->SetNumRealBuilding(eLoopBuilding, 1, true);
#if defined(MOD_EVENTS_CITY_CAPITAL)
						if (iI == eCapitalBuilding && MOD_EVENTS_CITY_CAPITAL) {
							GAMEEVENTINVOKE_HOOK(GAMEEVENT_CapitalChanged, getOwner(), GetID(), -1);
						}
#endif
					}
				}
			}

			//Free building in Capital from Trait?
			if (owningPlayer.GetPlayerTraits()->GetFreeCapitalBuilding() != NO_BUILDING)
			{
				if (owningPlayer.GetPlayerTraits()->GetCapitalFreeBuildingPrereqTech() == NO_TECH)
				{
					BuildingTypes eBuilding = owningPlayer.GetPlayerTraits()->GetFreeCapitalBuilding();
					if (eBuilding != NO_BUILDING)
					{
						if (isValidBuildingLocation(eBuilding))
						{
							m_pCityBuildings->SetNumFreeBuilding(eBuilding, 1);
						}
					}
				}
			}

			if (!isHuman())
			{
				changeOverflowProduction(/*0*/ GD_INT_GET(INITIAL_AI_CITY_PRODUCTION));
			}
			else if (MOD_API_ACHIEVEMENTS)
			{
				CvAchievementUnlocker::UnlockFromDatabase();
			}
		}
	}

	if (bInitialFounding)
	{
		owningPlayer.DoDifficultyBonus(owningPlayer.getNumCities() <= 1 ? DIFFICULTY_BONUS_CITY_FOUND_CAPITAL : DIFFICULTY_BONUS_CITY_FOUND);
	}

	// How long before this City picks a Resource to demand?
	DoSeedResourceDemandedCountdown();

	// Garrisoned?
	SetGarrison(plot()->getBestGarrison(getOwner()));

	// Update Unit Maintenance for the player
	CvPlayer& kPlayer = GET_PLAYER(getOwner());
	kPlayer.UpdateUnitProductionMaintenanceMod();

	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		UpdateYieldPerXUnimprovedFeature(((YieldTypes)iI));
	}
	int iRange3 = 3;
	int iMountain = 0;
	for (int iDX = -iRange3; iDX <= iRange3; iDX++)
	{
		for (int iDY = -iRange3; iDY <= iRange3; iDY++)
		{
			CvPlot* pLoopPlot = plotXYWithRangeCheck(getX(), getY(), iDX, iDY, iRange3);
			if (pLoopPlot != NULL)
			{
				if (pLoopPlot->isMountain() && !pLoopPlot->IsNaturalWonder())
				{
					iMountain++;
				}
			}
		}
	}
	SetNearbyMountains(iMountain);
	InitEspionageRanking();

	// Spread a pantheon here if one is active
	CvPlayerReligions* pReligions = kPlayer.GetReligions();
	if (pReligions->HasCreatedPantheon() && !pReligions->HasCreatedReligion())
	{
		//pantheon strength depends on population?
		int iInitialPressure = /*1000*/ GD_INT_GET(RELIGION_ATHEISM_PRESSURE_PER_POP) * getPopulation() * 2;
		GetCityReligions()->AddReligiousPressure(FOLLOWER_CHANGE_PANTHEON_FOUNDED, RELIGION_PANTHEON, iInitialPressure);
		GetCityReligions()->RecomputeFollowers(FOLLOWER_CHANGE_PANTHEON_FOUNDED);
	}

	if (bInitialFounding) 
	{
		if (eInitialReligion != NO_RELIGION) 
		{
			// Spread an initial religion here if one was given
			GetCityReligions()->AdoptReligionFully(eInitialReligion);
		}

		else if (MOD_RELIGION_LOCAL_RELIGIONS) 
		{
			// Spread a local religion here if one is active
			if (pReligions->HasCreatedReligion() && GC.getReligionInfo(pReligions->GetReligionCreatedByPlayer())->IsLocalReligion()) 
			{
				GetCityReligions()->AdoptReligionFully(pReligions->GetReligionCreatedByPlayer());
			}
		}
	}

	// A new City might change our victory progress
	GET_TEAM(getTeam()).DoTestSmallAwards();

	DLLUI->setDirty(NationalBorders_DIRTY_BIT, true);

#if defined(MOD_GLOBAL_CITY_FOREST_BONUS)
	if (bClearedForest || bClearedJungle)
	{
		int iProduction = 0;

		// Base value
		if (GET_PLAYER(getOwner()).GetAllFeatureProduction() > 0)
		{
			iProduction = GET_PLAYER(getOwner()).GetAllFeatureProduction();
		}
		else if (bClearedForest)
		{
			iProduction = GC.getBuildInfo(eBuildRemoveForest)->getFeatureProduction(FEATURE_FOREST);
		}
		else if (bClearedJungle)
		{
			iProduction = GC.getBuildInfo(eBuildRemoveJungle)->getFeatureProduction(FEATURE_JUNGLE);
		}

		if (MOD_BALANCE_CORE_SETTLER_ADVANCED)
		{
			iProduction *= std::max(0, (GET_PLAYER(getOwner()).getFeatureProductionModifier()));
			iProduction /= 100;
		}
		else
		{
			iProduction *= std::max(0, (GET_PLAYER(getOwner()).getFeatureProductionModifier() + 100));
			iProduction /= 100;
		}

		iProduction *= GC.getGame().getGameSpeedInfo().getFeatureProductionPercent();
		iProduction /= 100;

		if (iProduction > 0)
		{
			// Make the production higher than a "ring-1 chop"
			iProduction *= gCustomMods.getOption("GLOBAL_CITY_FOREST_BONUS_PERCENT", 125);
			iProduction /= 100;

			changeFeatureProduction(iProduction);
			if (bClearedForest)
			{
				//CUSTOMLOG("Founding of %s on a forest created %d initial production", getName().GetCString(), iProduction);
			}
			else if (bClearedJungle)
			{
				//CUSTOMLOG("Founding of %s on a jungle created %d initial production", getName().GetCString(), iProduction);
			}

			if (getOwner() == GC.getGame().getActivePlayer())
			{
				CvString strBuffer = GetLocalizedText("TXT_KEY_MISC_CLEARING_FEATURE_RESOURCE", GC.getFeatureInfo(eFeature)->GetTextKey(), iProduction, getNameKey());
				GC.GetEngineUserInterface()->AddCityMessage(0, GetIDInfo(), getOwner(), false, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), strBuffer);
			}
		}
	}
#endif

	// Stuff for Pioneers and Colonists
	if (MOD_BALANCE_CORE_SETTLER_ADVANCED && bInitialFounding && pkSettlerUnitEntry != NULL)
	{
		if (pkSettlerUnitEntry->IsFound())
		{
			kPlayer.cityBoost(getX(), getY(), pkSettlerUnitEntry, 0, 1, 1);
		}
		if (pkSettlerUnitEntry->GetNumColonyFound() > 0)
		{
			kPlayer.cityBoost(getX(), getY(), pkSettlerUnitEntry, /*3*/ GD_INT_GET(PIONEER_EXTRA_PLOTS), /*3*/ GD_INT_GET(PIONEER_POPULATION_CHANGE), 1);
			DoCreatePuppet();
		}

		if (pkSettlerUnitEntry->IsFoundMid())
		{
			kPlayer.cityBoost(getX(), getY(), pkSettlerUnitEntry, /*3*/ GD_INT_GET(PIONEER_EXTRA_PLOTS), /*3*/ GD_INT_GET(PIONEER_POPULATION_CHANGE), /*25*/ GD_INT_GET(PIONEER_FOOD_PERCENT));
		}
		if (pkSettlerUnitEntry->IsFoundLate())
		{
			kPlayer.cityBoost(getX(), getY(), pkSettlerUnitEntry, /*5*/ GD_INT_GET(COLONIST_EXTRA_PLOTS), /*5*/ GD_INT_GET(COLONIST_POPULATION_CHANGE), /*50*/ GD_INT_GET(COLONIST_FOOD_PERCENT));
		}
	}

	if (GET_PLAYER(getOwner()).GetPlayerTraits()->IsReconquista() && bInitialFounding)
	{
		ReligionTypes eReligion = GET_PLAYER(getOwner()).GetReligions()->GetStateReligion();
		if (eReligion != NO_RELIGION)
		{
			GetCityReligions()->AdoptReligionFully(eReligion);
		}
	}
	if (bInitialFounding)
	{
		owningPlayer.doInstantYield(INSTANT_YIELD_TYPE_FOUND, false, NO_GREATPERSON, NO_BUILDING, 0, true, NO_PLAYER, NULL, false, this);

		if (owningPlayer.GetPlayerTraits()->IsExpansionWLTKD())
		{
			int iWLTKD = /*6*/ GD_INT_GET(CITY_RESOURCE_WLTKD_TURNS) / 3;
			iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iWLTKD /= 100;

			if (iWLTKD > 0)
			{
				CvCity* pLoopCity = NULL;
				int iCityLoop = 0;

				// Loop through owner's cities.
				for (pLoopCity = owningPlayer.firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = owningPlayer.nextCity(&iCityLoop))
				{
					if (pLoopCity != NULL)
					{
						pLoopCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
					}
				}
				CvNotifications* pNotifications = owningPlayer.GetNotifications();
				if (pNotifications)
				{
					Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UA_CITY_SETTLING");
					strText << iWLTKD << /*25*/ GD_INT_GET(WLTKD_GROWTH_MULTIPLIER);
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UA_CITY_SETTLING");
					pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), this->getX(), this->getY(), -1);
				}
			}
		}
	}
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes)iI;
		if (eYield == NO_YIELD)
			continue;

		UpdateSpecialReligionYields(eYield);
		UpdateCityYields(eYield);

		for (int iK = 0; iK < NUM_YIELD_TYPES; iK++)
		{
			YieldTypes eYield2 = (YieldTypes)iK;

			if (eYield == eYield2)
				continue;

			int iGlobalConversionYield = owningPlayer.getYieldFromYieldGlobal(eYield, eYield2);
			if (iGlobalConversionYield > 0)
			{
				ChangeBuildingYieldFromYield(eYield, eYield2, iGlobalConversionYield);
			}
		}
	}
	if (bInitialFounding && owningPlayer.GetPlayerTraits()->GetStartingSpies() > 0 && owningPlayer.getNumCities() == 1)
	{
		CvPlayerEspionage* pEspionage = owningPlayer.GetEspionage();
		CvAssertMsg(pEspionage, "pEspionage is null! What's up with that?!");
		if (pEspionage)
		{
			int iNumSpies = owningPlayer.GetPlayerTraits()->GetStartingSpies();
			for (int i = 0; i < iNumSpies; i++)
			{
				pEspionage->CreateSpy();
			}
		}
	}

	owningPlayer.CalculateNetHappiness();

	//If this is a conquered city, the city value is not updated - it is copied over from the previous city (see in CvPlayer::acquireCity())
	//This is so that the AI sees the actual value of the city, not the value of the city in resistance, which will be much lower
	//However updateEconomicValue() is also called in doTurn() so it will only have the old value for 1 turn
	if (bInitialFounding)
	{
		updateEconomicValue();
	}

	UpdateCachedYieldMedians();

	AI_init();

	if (GC.getGame().getGameTurn() == 0)
	{
		chooseProduction();
	}
	if (!GET_PLAYER(getOwner()).isHuman())
	{
		AI_chooseProduction(false, false);
	}
}

//	--------------------------------------------------------------------------------
void CvCity::uninit()
{
	VALIDATE_OBJECT
	m_aiYieldPerPopInEmpire.clear();

#if defined(MOD_BALANCE_CORE)
	m_ppiGreatPersonProgressFromConstruction.clear();
#endif

	m_pCityBuildings->Uninit();
	m_pCityStrategyAI->Uninit();
	m_pCityCitizens->Uninit();
	m_pCityReligions->Uninit();
	m_pEmphases->Uninit();
	m_pCityEspionage->Uninit();

	m_orderQueue.clear();

	m_yieldChanges.clear();
	m_eventYields.clear();
}

//	--------------------------------------------------------------------------------
// FUNCTION: reset()
// Initializes data members that are serialized.
void CvCity::reset(int iID, PlayerTypes eOwner, int iX, int iY, bool bConstructorCall)
{
	VALIDATE_OBJECT
	m_syncArchive.reset();

	int iI = 0;

	//--------------------------------
	// Uninit class
	uninit();

	m_iID = iID;
	m_iX = iX;
	m_iY = iY;
	m_iRallyX = INVALID_PLOT_COORD;
	m_iRallyY = INVALID_PLOT_COORD;
	m_iGameTurnFounded = 0;
	m_iGameTurnAcquired = 0;
	m_iPopulation = 0;
#if defined(MOD_GLOBAL_CITY_AUTOMATON_WORKERS)
	m_iAutomatons = 0;
#endif
#if defined(MOD_BALANCE_CORE)
	m_iAdditionalFood = 0;
	m_iCityBuildingBombardRange = 0;
	m_iCityIndirectFire = 0;
	m_iCityBuildingRangeStrikeModifier = 0;
#endif
	m_iHighestPopulation = 0;
	m_iExtraHitPoints = 0;
	m_iNumGreatPeople = 0;
	m_iBaseGreatPeopleRate = 0;
	m_iGreatPeopleRateModifier = 0;
	m_iJONSCultureStored = 0;
	m_iJONSCultureLevel = 0;
	m_iJONSCulturePerTurnFromPolicies = 0;
	m_iJONSCulturePerTurnFromSpecialists = 0;
	m_iaAddedYieldPerTurnFromTraits.resize(NUM_YIELD_TYPES);
	m_iFaithPerTurnFromPolicies = 0;
	m_iCultureRateModifier = 0;
	m_iNumWorldWonders = 0;
	m_iNumTeamWonders = 0;
	m_iNumNationalWonders = 0;
	m_iWonderProductionModifier = 0;
	m_iCapturePlunderModifier = 0;
	m_iBorderGrowthRateIncrease = 0;
	m_iPlotCultureCostModifier = 0;
	m_iPlotBuyCostModifier = 0;
#if defined(MOD_BUILDINGS_CITY_WORKING)
	m_iCityWorkingChange = 0;
	m_iCitySupplyModifier = 0;
	m_iCitySupplyFlat = 0;
	m_iDamageReductionFlat = 0;
	m_bAllowsProductionTradeRoutes = false;
	m_bAllowsFoodTradeRoutes = false;
	m_bAllowPuppetPurchase = false;
#endif
#if defined(MOD_BUILDINGS_CITY_AUTOMATON_WORKERS)
	m_iCityAutomatonWorkersChange = 0;
#endif
	m_iMaintenance = 0;
	m_iHealRate = 0;
	m_iEspionageModifier = 0;
	m_iEspionageTurnsModifierEnemy = 0;
#if defined(MOD_RELIGION_CONVERSION_MODIFIERS)
	m_iConversionModifier = 0;
#endif
	m_iNoOccupiedUnhappinessCount = 0;
#if defined(HH_MOD_BUILDINGS_FRUITLESS_PILLAGE)
	m_iLocalGainlessPillageCount = 0;
#endif
	m_iFood = 0;
	m_iMaxFoodKeptPercent = 0;
	m_iOverflowProduction = 0;
	m_iFeatureProduction = 0;
	m_iMilitaryProductionModifier = 0;
	m_iSpaceProductionModifier = 0;
	m_iFreeExperience = 0;
	m_iMaxAirUnits = /*6 in CP, 2 in VP*/ GD_INT_GET(BASE_CITY_AIR_STACKING);
	m_iNukeModifier = 0;
	m_iTradeRouteRecipientBonus = 0;
	m_iTradeRouteSeaGoldBonus = 0;
	m_iTradeRouteLandGoldBonus = 0;
	m_iNumTradeRouteBonus = 0;
	m_iCityConnectionTradeRouteGoldModifier = 0;
	m_iTradeRouteTargetBonus = 0;
	m_iCitySizeBoost = 0;
	m_iSpecialistFreeExperience = 0;
	m_iStrengthValue = 0;
	m_iDamage = 0;
	m_iThreatValue = 0;
	m_hGarrison = -1;
	m_iResourceDemanded = -1;
	m_iResourceDemandedCounter = 0;
	m_iWeLoveTheKingDayCounter = 0;
	m_iLastTurnGarrisonAssigned = -1;
	m_iThingsProduced = 0;
	m_iDemandResourceCounter = 0;
	m_iResistanceTurns = 0;
	m_iRazingTurns = 0;
	m_iLowestRazingPop = 0;
	m_iCountExtraLuxuries = 0;
	m_iCheapestPlotInfluenceDistance = 0;
	m_unitBeingBuiltForOperation.Invalidate();
	m_hGarrisonOverride = -1;

	m_bNeverLost = true;
	m_bDrafted = false;
	m_bProductionAutomated = false;
	m_bLayoutDirty = false;
	m_bMadeAttack = false;
	m_bOccupied = false;
	m_bPuppet = false;
	m_bIgnoreCityForHappiness = false;
	m_bIndustrialRouteToCapital = false;
	m_iTerrainImprovementNeed = 0;
	m_bOwedCultureBuilding = false;
	m_bOwedFoodBuilding = false;

	m_eOwner = eOwner;
	m_ePreviousOwner = NO_PLAYER;
	m_eOriginalOwner = eOwner;
	m_ePlayersReligion = NO_PLAYER;


	m_aiSeaPlotYield.resize(NUM_YIELD_TYPES);
	m_aiRiverPlotYield.resize(NUM_YIELD_TYPES);
	m_aiSeaResourceYield.resize(NUM_YIELD_TYPES);
	m_aiLakePlotYield.resize(NUM_YIELD_TYPES);
	m_aiBaseYieldRateFromTerrain.resize(NUM_YIELD_TYPES);
	m_aiBaseYieldRateFromBuildings.resize(NUM_YIELD_TYPES);
	m_aiBaseYieldRateFromSpecialists.resize(NUM_YIELD_TYPES);
	m_aiBaseYieldRateFromMisc.resize(NUM_YIELD_TYPES);
	m_aiBaseYieldRateFromLeague.resize(NUM_YIELD_TYPES);
	m_iTotalScienceyAid = 0;
	m_iTotalArtsyAid = 0;
	m_iTotalGreatWorkAid = 0;
	m_iCachedTechNeedModifier = 0;
	m_iHappinessFromEmpire = 0;
	m_iUnhappinessFromEmpire = 0;
	m_iCachedBasicNeedsMedian = 0;
	m_iCachedGoldMedian = 0;
	m_iCachedScienceMedian = 0;
	m_iCachedCultureMedian = 0;
	m_iCachedTechNeedModifier = 0;
	m_iCachedEmpireSizeModifier = 0;
	m_iYieldMediansCachedTurn = GC.getGame().getGameTurn();
	m_iEmpireSizeModifierReduction = 0;
	m_iDistressFlatReduction = 0;
	m_iPovertyFlatReduction = 0;
	m_iIlliteracyFlatReduction = 0;
	m_iBoredomFlatReduction = 0;
	m_iReligiousUnrestFlatReduction = 0;
	m_iBasicNeedsMedianModifier = 0;
	m_iGoldMedianModifier = 0;
	m_iScienceMedianModifier = 0;
	m_iCultureMedianModifier = 0;
	m_iReligiousUnrestModifier = 0;
	m_iEventHappiness = 0;
	m_iCityEventCooldown = 0;
	m_aiChangeGrowthExtraYield.resize(NUM_YIELD_TYPES);
#if defined(MOD_BALANCE_CORE)
	m_iBorderObstacleWater = 0;
	m_iBorderObstacleCity = 0;
	m_iDeepWaterTileDamage = 0;
	m_iNumNearbyMountains = 0;
	m_iLocalUnhappinessMod = 0;
	m_iTradePriorityLand = 0;
	m_iNukeInterceptionChance = 0;
	m_iTradeRouteSeaDistanceModifier = 0;
	m_iTradeRouteLandDistanceModifier = 0;
	m_iTradePrioritySea = 0;
	m_iUnitPurchaseCooldown = 0;
	m_iUnitPurchaseCooldownCivilian = 0;
	m_iUnitPurchaseCooldownMod = 0;
	m_iUnitPurchaseCooldownCivilianMod = 0;
	m_iUnitFaithPurchaseCooldown = 0;
	m_iUnitFaithPurchaseCooldownCivilian = 0;
	m_iBuildingPurchaseCooldown = 0;
	m_iReligiousTradeModifier = 0;
	m_iCityAirStrikeDefense = 5;
	m_iFreeBuildingTradeTargetCity = -1;
	m_iBaseTourism = 0;
	m_iBaseTourismBeforeModifiers = 0;
	m_aiNumTimesAttackedThisTurn.resize(REALLY_MAX_PLAYERS);
	m_aiLongestPotentialTradeRoute.resize(NUM_DOMAIN_TYPES);
	m_aiNumProjects.resize(GC.getNumProjectInfos());
	m_aiSpecialistRateModifier.resize(GC.getNumSpecialistInfos());
	m_aiYieldFromVictory.resize(NUM_YIELD_TYPES);
	m_aiYieldFromVictoryGlobal.resize(NUM_YIELD_TYPES);
	m_aiYieldFromVictoryGlobalEraScaling.resize(NUM_YIELD_TYPES);
	m_aiYieldFromPillage.resize(NUM_YIELD_TYPES);
	m_aiYieldFromPillageGlobal.resize(NUM_YIELD_TYPES);
	m_aiYieldFromKnownPantheons.resize(NUM_YIELD_TYPES);
	m_aiGoldenAgeYieldMod.resize(NUM_YIELD_TYPES);
	m_aiYieldFromWLTKD.resize(NUM_YIELD_TYPES);
	m_aiYieldFromConstruction.resize(NUM_YIELD_TYPES);
	m_aiYieldFromTech.resize(NUM_YIELD_TYPES);
	m_aiYieldFromBirth.resize(NUM_YIELD_TYPES);
	m_aiYieldFromUnitProduction.resize(NUM_YIELD_TYPES);
	m_aiYieldFromBorderGrowth.resize(NUM_YIELD_TYPES);
	m_aiYieldFromPolicyUnlock.resize(NUM_YIELD_TYPES);
	m_aiYieldFromPurchase.resize(NUM_YIELD_TYPES);
	m_aiYieldFromFaithPurchase.resize(NUM_YIELD_TYPES);
	m_aiYieldFromUnitLevelUp.resize(NUM_YIELD_TYPES);
	m_aiYieldFromCombatExperience.resize(NUM_YIELD_TYPES);
	m_aiYieldPerAlly.resize(NUM_YIELD_TYPES);
	m_aiYieldPerFriend.resize(NUM_YIELD_TYPES);
	m_aiYieldFromInternalTREnd.resize(NUM_YIELD_TYPES);
	m_aiYieldFromInternalTR.resize(NUM_YIELD_TYPES);
	m_aiYieldFromProcessModifier.resize(NUM_YIELD_TYPES);
	m_aiThemingYieldBonus.resize(NUM_YIELD_TYPES);
	m_aiYieldFromSpyAttack.resize(NUM_YIELD_TYPES);
	m_aiYieldFromSpyDefense.resize(NUM_YIELD_TYPES);
	m_aiNumTimesOwned.resize(REALLY_MAX_PLAYERS);
	m_aiStaticCityYield.resize(NUM_YIELD_TYPES);
#endif
#if defined(MOD_BALANCE_CORE)
	m_iExtraBuildingMaintenance = 0;
	m_iLandTourismBonus = 0;
	m_iSeaTourismBonus = 0;
	m_iAlwaysHeal = 0;
	m_iResourceDiversityModifier = 0;
	m_iNoUnhappfromXSpecialists = 0;
	m_bNoWarmonger = false;
#endif
#if defined(MOD_BALANCE_CORE_SPIES_ADVANCED)
	m_iCitySpyRank = 0;
	m_iTurnsSinceRankAnnouncement = 0;
	m_aiEconomicValue.resize(MAX_CIV_PLAYERS);
	for (iI = 0; iI < MAX_CIV_PLAYERS; iI++)
	{
		m_aiEconomicValue[iI] = 0;
	}
	for (iI = 0; iI < REALLY_MAX_PLAYERS; iI++)
	{
		m_aiNumTimesAttackedThisTurn[iI] = 0;
	}
	for (iI = 0; iI < NUM_DOMAIN_TYPES; iI++)
	{
		m_aiLongestPotentialTradeRoute[iI] = 0;
	}
#endif
	m_miInstantYieldsTotal.clear();
	m_aiBaseYieldRateFromReligion.resize(NUM_YIELD_TYPES);
#if defined(MOD_BALANCE_CORE)	
	m_aiYieldFromMinors.resize(NUM_YIELD_TYPES);
	m_aiBaseYieldRateFromCSFriendship.resize(NUM_YIELD_TYPES);
	m_aiBaseYieldRateFromCSAlliance.resize(NUM_YIELD_TYPES);
	m_aiGreatWorkYieldChange.resize(NUM_YIELD_TYPES);
#endif
	m_aiYieldPerPop.resize(NUM_YIELD_TYPES);
#if defined(MOD_BALANCE_CORE)
	m_aiYieldPerPopInEmpire.clear();
#endif
	m_aiYieldPerReligion.resize(NUM_YIELD_TYPES);
	m_aiYieldRateModifier.resize(NUM_YIELD_TYPES);
	m_aiPowerYieldRateModifier.resize(NUM_YIELD_TYPES);
	m_aiResourceYieldRateModifier.resize(NUM_YIELD_TYPES);
	m_aiExtraSpecialistYield.resize(NUM_YIELD_TYPES);
	m_aiProductionToYieldModifier.resize(NUM_YIELD_TYPES);
	m_aiEventCityYield.resize(NUM_YIELD_TYPES);
	m_aiEventCityYieldModifier.resize(NUM_YIELD_TYPES);
	for (iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		m_aiSeaPlotYield[iI] = 0;
		m_aiRiverPlotYield[iI] = 0;
		m_aiLakePlotYield[iI] = 0;
		m_aiSeaResourceYield[iI] = 0;
		m_aiBaseYieldRateFromTerrain[iI] = 0;
		m_aiBaseYieldRateFromBuildings[iI] = 0;
		m_aiBaseYieldRateFromSpecialists[iI] = 0;
		m_aiBaseYieldRateFromMisc[iI] = 0;
		m_aiBaseYieldRateFromLeague[iI] = 0;
		m_aiChangeGrowthExtraYield[iI] = 0;
#if defined(MOD_BALANCE_CORE)
		m_aiGreatWorkYieldChange[iI] = 0;
		m_aiYieldFromKnownPantheons[iI] = 0;
		m_aiYieldFromVictory[iI] = 0;
		m_aiYieldFromVictoryGlobal[iI] = 0;
		m_aiYieldFromVictoryGlobalEraScaling[iI] = 0;
		m_aiYieldFromPillage[iI] = 0;
		m_aiYieldFromPillageGlobal[iI] = 0;
		m_aiGoldenAgeYieldMod[iI] = 0;
		m_aiYieldFromWLTKD[iI] = 0;
		m_aiYieldFromConstruction[iI] = 0;
		m_aiYieldFromTech[iI] = 0;
		m_aiYieldFromBirth[iI] = 0;
		m_aiYieldFromUnitProduction[iI] = 0;
		m_aiYieldFromBorderGrowth[iI] = 0;
		m_aiYieldFromPolicyUnlock[iI] = 0;
		m_aiYieldFromPurchase[iI] = 0;
		m_aiYieldFromFaithPurchase[iI] = 0;
		m_aiYieldFromUnitLevelUp[iI] = 0;
		m_aiYieldFromCombatExperience[iI] = 0;
		m_aiYieldPerAlly[iI] = 0;
		m_aiYieldPerFriend[iI] = 0;
		m_aiYieldFromInternalTREnd[iI] = 0;
		m_aiYieldFromInternalTR[iI] = 0;
		m_aiYieldFromProcessModifier[iI] = 0;
		m_aiThemingYieldBonus[iI] = 0;
		m_aiYieldFromSpyAttack[iI] = 0;
		m_aiYieldFromSpyDefense[iI] = 0;
		m_aiEventCityYield[iI] = 0;
		m_aiEventCityYieldModifier[iI] = 0;
#endif
		m_aiBaseYieldRateFromReligion[iI] = 0;
#if defined(MOD_BALANCE_CORE)
		m_aiYieldFromMinors[iI] = 0;
		m_aiBaseYieldRateFromCSFriendship[iI] = 0;
		m_aiBaseYieldRateFromCSAlliance[iI] = 0;
		m_aiStaticCityYield[iI] = 0;
#endif
		m_aiYieldPerPop[iI] = 0;
		m_aiYieldPerReligion[iI] = 0;
		m_aiYieldRateModifier[iI] = 0;
		m_aiPowerYieldRateModifier[iI] = 0;
		m_aiResourceYieldRateModifier[iI] = 0;
		m_aiExtraSpecialistYield[iI] = 0;
		m_aiProductionToYieldModifier[iI] = 0;
	}
#if defined(MOD_BALANCE_CORE_EVENTS)
	m_abEventChoiceFired.resize(GC.getNumCityEventChoiceInfos());
	m_aiEventChoiceDuration.resize(GC.getNumCityEventChoiceInfos());
	m_abEventChoiceActive.resize(GC.getNumCityEventChoiceInfos());
	for (iI = 0; iI < GC.getNumCityEventChoiceInfos(); iI++)
	{
		m_aiEventChoiceDuration[iI] = 0;
		m_abEventChoiceFired[iI] = false;
		m_abEventChoiceActive[iI] = false;
	}
	m_abEventFired.resize(GC.getNumCityEventInfos());
	m_abEventActive.resize(GC.getNumCityEventInfos());
	m_aiEventIncrement.resize(GC.getNumCityEventInfos());
	m_aiEventCooldown.resize(GC.getNumCityEventInfos());
	for (iI = 0; iI < GC.getNumCityEventInfos(); iI++)
	{
		m_abEventFired[iI] = false;
		m_abEventActive[iI] = false;
		m_aiEventIncrement[iI] = 0;
		m_aiEventCooldown[iI] = 0;
	}
#endif
	m_aiDomainFreeExperience.resize(NUM_DOMAIN_TYPES);
	m_aiDomainProductionModifier.resize(NUM_DOMAIN_TYPES);
	for (iI = 0; iI < NUM_DOMAIN_TYPES; iI++)
	{
		m_aiDomainFreeExperience[iI] = 0;
		m_aiDomainProductionModifier[iI] = 0;
	}

	m_abEverLiberated.resize(REALLY_MAX_PLAYERS);
#if defined(MOD_BALANCE_CORE)
	m_abIsBestForWonder.resize(GC.getNumBuildingClassInfos());
	m_abIsPurchased.resize(GC.getNumBuildingClassInfos());
	for (iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
	{
		m_abIsPurchased[iI] = false;
		m_abIsBestForWonder[iI] = false;
	}

	for (iI = 0; iI < GC.getNumProjectInfos(); iI++)
	{
		m_aiNumProjects[iI] = 0;
	}

	m_abTraded.resize(REALLY_MAX_PLAYERS);
	m_abIgnoredForExpansionBickering.resize(MAX_MAJOR_CIVS);
	m_aiBonusSightEspionage.resize(MAX_MAJOR_CIVS);
#endif
	for (iI = 0; iI < REALLY_MAX_PLAYERS; iI++)
	{
		m_abEverLiberated[iI] = false;
		m_abTraded[iI] = false;
		m_aiNumTimesOwned[iI] = 0;

		if (iI < MAX_MAJOR_CIVS)
		{
			m_abIgnoredForExpansionBickering[iI] = false;
			m_aiBonusSightEspionage[iI] = 0;
		}
	}
#if defined(MOD_BALANCE_CORE)
	m_abPaidAdoptionBonus.resize(GC.getNumReligionInfos());
	for (iI = 0; iI < GC.getNumReligionInfos(); iI++)
	{
		m_abPaidAdoptionBonus[iI] = false;
	}
	m_aiReligiousPressureModifier.resize(GC.getNumReligionInfos());
	for (iI = 0; iI < GC.getNumReligionInfos(); iI++)
	{
		m_aiReligiousPressureModifier[iI] = 0;
	}
#endif

	m_strName = "";
	m_strScriptData = "";

	m_bPopulationRankValid = false;
	m_iPopulationRank = -1;
	m_iBaseHappinessFromBuildings = 0;
	m_iUnmoddedHappinessFromBuildings = 0;
	m_bRouteToCapitalConnectedLastTurn = false;
	m_bRouteToCapitalConnectedThisTurn = false;

	m_abBaseYieldRankValid.resize(NUM_YIELD_TYPES);
	m_abYieldRankValid.resize(NUM_YIELD_TYPES);
	m_aiBaseYieldRank.resize(NUM_YIELD_TYPES);
	m_aiYieldRank.resize(NUM_YIELD_TYPES);
#if defined(MOD_BALANCE_CORE)
	m_iHappinessDelta = 0;
	m_iPillagedPlots = 0;
	m_iGrowthFromTourism = 0;
	m_iGrowthEvent = 0;
	m_iBuildingClassHappiness = 0;
	m_iReligionHappiness = 0;
	m_aiYieldChangeFromCorporationFranchises.resize(NUM_YIELD_TYPES);
	m_aiYieldModifierFromHappiness.resize(NUM_YIELD_TYPES);
	m_aiYieldModifierFromHealth.resize(NUM_YIELD_TYPES);
	m_aiYieldModifierFromCrime.resize(NUM_YIELD_TYPES);
	m_aiYieldModifierFromDevelopment.resize(NUM_YIELD_TYPES);
	m_aiYieldFromHappiness.resize(NUM_YIELD_TYPES);
	m_aiYieldFromHealth.resize(NUM_YIELD_TYPES);
	m_aiYieldFromCrime.resize(NUM_YIELD_TYPES);
	m_aiYieldFromDevelopment.resize(NUM_YIELD_TYPES);
	m_aiTempCaptureData.resize(5);
	m_abTempCaptureData.resize(2);
#endif
	for (iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		m_abBaseYieldRankValid[iI] = false;
		m_abYieldRankValid[iI] = false;
		m_aiBaseYieldRank[iI] = -1;
		m_aiYieldRank[iI] = -1;
#if defined(MOD_BALANCE_CORE)
		m_aiYieldChangeFromCorporationFranchises[iI] = 0;
		m_aiYieldModifierFromHappiness[iI] = 0;
		m_aiYieldModifierFromHealth[iI] = 0;
		m_aiYieldModifierFromCrime[iI] = 0;
		m_aiYieldModifierFromDevelopment[iI] = 0;
		m_aiYieldFromHappiness[iI] = 0;
		m_aiYieldFromHealth[iI] = 0;
		m_aiYieldFromCrime[iI] = 0;
		m_aiYieldFromDevelopment[iI] = 0;
#endif
	}
	for (int iI = 0; iI < 5; iI++)
	{
		m_aiTempCaptureData[iI] = 0;
	}
	for (int iI = 0; iI < 2; iI++)
	{
		m_abTempCaptureData[iI] = false;
	}
#if defined(MOD_BALANCE_CORE)
	m_abOwedChosenBuilding.resize(GC.getNumBuildingClassInfos());
	m_abBuildingInvestment.resize(GC.getNumBuildingClassInfos());
	m_abUnitInvestment.resize(GC.getNumUnitClassInfos());
	m_abBuildingConstructed.resize(GC.getNumBuildingClassInfos());
	for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
	{
		m_abOwedChosenBuilding[iI] = false;
		m_abBuildingInvestment[iI] = false;
		m_abBuildingConstructed[iI] = false;
	}
	for (int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
	{
		m_abUnitInvestment[iI] = false;
	}
#endif
#if defined(MOD_BALANCE_CORE_JFD)
	m_bIsColony = false;
	m_iProvinceLevel = 0;
	m_iOrganizedCrime = -1;
	m_iResistanceCounter = 0;
	m_iPlagueCounter = 0;
	m_iPlagueTurns = -1;
	m_iSappedTurns = -1;
	m_iPlagueType = -1;
	m_iLoyaltyCounter = 0;
	m_iDisloyaltyCounter = 0;
	m_iLoyaltyStateType = 0;
	m_bIsPendingCapture = false;
#endif
	if (!bConstructorCall)
	{
		int iNumResources = GC.getNumResourceInfos();
		CvAssertMsg((0 < iNumResources), "GC.getNumResourceInfos() is not greater than zero but an array is being allocated in CvCity::reset");
		m_paiNoResource.clear();
		m_paiNoResource.resize(iNumResources);
		m_paiFreeResource.clear();
		m_paiFreeResource.resize(iNumResources);
		m_paiNumResourcesLocal.clear();
		m_paiNumResourcesLocal.resize(iNumResources);

		m_paiNumUnimprovedResourcesLocal.clear();
		m_paiNumUnimprovedResourcesLocal.resize(iNumResources);
#if defined(MOD_BALANCE_CORE)
		m_aiResourceQuantityPerXFranchises.clear();
		m_aiResourceQuantityPerXFranchises.resize(iNumResources);
#endif
		m_aiResourceQuantityFromPOP.clear();
		m_aiResourceQuantityFromPOP.resize(iNumResources);
		for (iI = 0; iI < iNumResources; iI++)
		{
			m_paiNoResource[iI] = 0;
			m_paiFreeResource[iI] = 0;
			m_paiNumResourcesLocal[iI] = 0;
			m_paiNumUnimprovedResourcesLocal[iI] = 0;
#if defined(MOD_BALANCE_CORE)
			m_aiResourceQuantityPerXFranchises[iI] = 0;
#endif
			m_aiResourceQuantityFromPOP[iI] = 0;
		}
		int iNumProjectInfos = GC.getNumProjectInfos();
		m_paiProjectProduction.clear();
		m_paiProjectProduction.resize(iNumProjectInfos);
		for (iI = 0; iI < iNumProjectInfos; iI++)
		{
			m_paiProjectProduction[iI] = 0;
		}

		int iNumSpecialistInfos = GC.getNumSpecialistInfos();
		m_paiSpecialistProduction.clear();
		m_paiSpecialistProduction.resize(iNumSpecialistInfos);
		for (iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
		{
			m_paiSpecialistProduction[iI] = 0;
#if defined(MOD_BALANCE_CORE)
			m_aiSpecialistRateModifier[iI] = 0;
#endif
		}

		m_pCityBuildings->Init(GC.GetGameBuildings(), this);

		int iNumUnitInfos = GC.getNumUnitInfos();
		CvAssertMsg((0 < iNumUnitInfos), "GC.getNumUnitInfos() is not greater than zero but an array is being allocated in CvCity::reset");
		m_paiUnitProduction.clear();
		m_paiUnitProduction.resize(iNumUnitInfos);
		m_paiUnitProductionTime.clear();
		m_paiUnitProductionTime.resize(iNumUnitInfos);
		for (iI = 0; iI < iNumUnitInfos; iI++)
		{
			m_paiUnitProduction[iI] = 0;
			m_paiUnitProductionTime[iI] = 0;
		}

		CvAssertMsg((0 < iNumSpecialistInfos), "GC.getNumSpecialistInfos() is not greater than zero but an array is being allocated in CvCity::reset");
		m_paiSpecialistCount.clear();
		m_paiSpecialistCount.resize(iNumSpecialistInfos);
		m_paiMaxSpecialistCount.clear();
		m_paiMaxSpecialistCount.resize(iNumSpecialistInfos);
		m_paiForceSpecialistCount.clear();
		m_paiForceSpecialistCount.resize(iNumSpecialistInfos);
		m_paiFreeSpecialistCount.clear();
		m_paiFreeSpecialistCount.resize(iNumSpecialistInfos);

		for (iI = 0; iI < iNumSpecialistInfos; iI++)
		{
			m_paiSpecialistCount[iI] = 0;
			m_paiMaxSpecialistCount[iI] = 0;
			m_paiForceSpecialistCount[iI] = 0;
			m_paiFreeSpecialistCount[iI] = 0;
		}

		int iNumImprovementInfos = GC.getNumImprovementInfos();
		CvAssertMsg((0 < iNumImprovementInfos), "GC.getNumImprovementInfos() is not greater than zero but an array is being allocated in CvCity::reset");
		m_paiImprovementFreeSpecialists.clear();
		m_paiImprovementFreeSpecialists.resize(iNumImprovementInfos);
		for (iI = 0; iI < iNumImprovementInfos; iI++)
		{
			m_paiImprovementFreeSpecialists[iI] = 0;
		}

		int iNumUnitCombatClassInfos = GC.getNumUnitCombatClassInfos();
		CvAssertMsg((0 < iNumUnitCombatClassInfos), "GC.getNumUnitCombatClassInfos() is not greater than zero but an array is being allocated in CvCity::reset");
		m_paiUnitCombatFreeExperience.clear();
		m_paiUnitCombatFreeExperience.resize(iNumUnitCombatClassInfos);
		m_paiUnitCombatProductionModifier.clear();
		m_paiUnitCombatProductionModifier.resize(iNumUnitCombatClassInfos);
		for (iI = 0; iI < iNumUnitCombatClassInfos; iI++)
		{
			m_paiUnitCombatFreeExperience[iI] = 0;
			m_paiUnitCombatProductionModifier[iI] = 0;
		}

		m_paiFreePromotionCount.clear();

#if defined(MOD_BALANCE_CORE_POLICIES)
		int iNumBuildingClassInfos = GC.getNumBuildingClassInfos();
		CvAssertMsg((0 < iNumBuildingClassInfos), "GC.getNumBuildingClassInfos() is not greater than zero but an array is being allocated in CvCity::reset");
		m_paiBuildingClassCulture.clear();
		m_paiBuildingClassCulture.resize(iNumBuildingClassInfos);
		for (iI = 0; iI < iNumBuildingClassInfos; iI++)
		{
			m_paiBuildingClassCulture[iI] = 0;
		}

		int iNumHurryInfos = GC.getNumHurryInfos();
		CvAssertMsg((0 < iNumHurryInfos), "GC.getNumHurryInfos() is not greater than zero but an array is being allocated in CvCity::reset");
		m_paiHurryModifier.clear();
		m_paiHurryModifier.resize(iNumHurryInfos);
		for (iI = 0; iI < iNumHurryInfos; iI++)
		{
			m_paiHurryModifier[iI] = 0;
		}
#endif

		int iNumTerrainInfos = GC.getNumTerrainInfos();
		int iNumFeatureInfos = GC.getNumFeatureInfos();
		int iNumResourceInfos = GC.getNumResourceInfos();

#if defined(MOD_BALANCE_CORE)
		m_paiNumTerrainWorked.clear();
		m_paiNumFeaturelessTerrainWorked.clear();
		m_paiNumFeaturelessTerrainWorked.resize(iNumTerrainInfos);
		m_paiNumTerrainWorked.resize(iNumTerrainInfos);
		for (iI = 0; iI < iNumTerrainInfos; iI++)
		{
			m_paiNumTerrainWorked[iI] = 0;
			m_paiNumFeaturelessTerrainWorked[iI] = 0;
		}

		m_paiNumFeatureWorked.clear();
		m_paiNumFeatureWorked.resize(iNumFeatureInfos);
		for (iI = 0; iI < iNumFeatureInfos; iI++)
		{
			m_paiNumFeatureWorked[iI] = 0;
		}

		m_paiNumResourceWorked.clear();
		m_paiNumResourceWorked.resize(iNumResourceInfos);
		for (iI = 0; iI < iNumResourceInfos; iI++)
		{
			m_paiNumResourceWorked[iI] = 0;
		}

		m_paiNumImprovementWorked.clear();
		m_paiNumImprovementWorked.resize(iNumImprovementInfos);
		for (iI = 0; iI < iNumImprovementInfos; iI++)
		{
			m_paiNumImprovementWorked[iI] = 0;
		}
#endif
	}

#if defined(MOD_BALANCE_CORE)
	m_ppiGreatPersonProgressFromConstruction.clear();
#endif

	m_yieldChanges = vector<SCityExtraYields>(NUM_YIELD_TYPES);
	m_eventYields = vector<SCityEventYields>(NUM_YIELD_TYPES);
	m_GwYieldCache = vector<int>(NUM_YIELD_TYPES, -1);

	if (!bConstructorCall)
	{
		// Set up AI and hook it up to the flavor manager
		m_pCityStrategyAI->Init(GC.GetGameAICityStrategies(), this, true);
		if (m_eOwner != NO_PLAYER)
			GET_PLAYER(getOwner()).GetFlavorManager()->AddFlavorRecipient(m_pCityStrategyAI);

		m_pCityCitizens->Init(this);
		m_pCityReligions->Init(this);
		m_pEmphases->Init(this);
		m_pCityEspionage->Init(this);
		m_pCityCulture->Init(this);

		AI_reset();

#if defined(MOD_GLOBAL_CITY_AUTOMATON_WORKERS)
		if (m_eOwner != NO_PLAYER) {
			setAutomatons(GET_TEAM(GET_PLAYER(getOwner()).getTeam()).GetCityAutomatonWorkersChange());
			setAutomatons(GET_PLAYER(getOwner()).GetCityAutomatonWorkersChange());
		}
#endif
	}
}


//////////////////////////////////////
// graphical only setup
//////////////////////////////////////
void CvCity::setupGraphical()
{
	VALIDATE_OBJECT
	if (!GC.IsGraphicsInitialized())
	{
		return;
	}

	CvPlayer& player = GET_PLAYER(getOwner());
	EraTypes eCurrentEra = (EraTypes)player.GetCurrentEra();

	CvInterfacePtr<ICvCity1> pkDllCity(new CvDllCity(this));
	gDLL->GameplayCityCreated(pkDllCity.get(), eCurrentEra);
	gDLL->GameplayCitySetDamage(pkDllCity.get(), getDamage(), 0);

	// setup the wonders
	setupWonderGraphics();

	// setup any special buildings
	setupBuildingGraphics();

	// setup the spaceship
	setupSpaceshipGraphics();

	setLayoutDirty(true);
}

//	--------------------------------------------------------------------------------
void CvCity::setupWonderGraphics()
{
	VALIDATE_OBJECT
	PlayerTypes ePlayerID = getOwner();
	for (int eBuildingType = 0; eBuildingType < GC.getNumBuildingInfos(); eBuildingType++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(eBuildingType);
		CvBuildingEntry* buildingInfo = GC.getBuildingInfo(eBuilding);

		//Only work with valid buildings.
		if (buildingInfo == NULL)
			continue;

		// if this building exists
		int iExists = m_pCityBuildings->GetNumRealBuilding(eBuilding);
		int iPreferredPosition = buildingInfo->GetPreferredDisplayPosition();
		if (iPreferredPosition > 0)
		{
			if (iExists > 0)
			{
				// display the wonder
				CvInterfacePtr<ICvPlot1> pDllPlot(new CvDllPlot(plot()));
				gDLL->GameplayWonderCreated(ePlayerID, pDllPlot.get(), eBuilding, 1);
			}
			else
			{
				if (isWorldWonderClass(buildingInfo->GetBuildingClassInfo()))
				{
					bool bShowHalfBuilt = false;
					// Are we are constructing it?
					if (eBuilding == getProductionBuilding())
					{
						bShowHalfBuilt = true;
					}
					else
					{
						// Is it part of an international project?
						LeagueProjectTypes eThisBuildingProject = NO_LEAGUE_PROJECT;
						for (int i = 0; i < GC.getNumLeagueProjectInfos(); i++)
						{
							LeagueProjectTypes eProject = (LeagueProjectTypes)i;
							CvLeagueProjectEntry* pProjectInfo = GC.getLeagueProjectInfo(eProject);
							if (pProjectInfo != NULL && pProjectInfo->GetRewardTier3() != NO_LEAGUE_PROJECT_REWARD) // Only check top reward tier
							{
								CvLeagueProjectRewardEntry* pRewardInfo = GC.getLeagueProjectRewardInfo(pProjectInfo->GetRewardTier3());
								if (pRewardInfo != NULL && pRewardInfo->GetBuilding() == eBuilding)
								{
									eThisBuildingProject = eProject;
									break;
								}
							}
						}
						if (eThisBuildingProject != NO_LEAGUE_PROJECT)
						{
							// Have we contributed anything to it?
							if (GC.getGame().GetGameLeagues()->GetNumActiveLeagues() > 0)
							{
								CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
								if (pLeague != NULL)
								{
									if (pLeague->IsProjectActive(eThisBuildingProject) && pLeague->GetMemberContribution(ePlayerID, eThisBuildingProject, true) > 0)
									{
										// Only show the graphic in the capital, since that is where the wonder would go
										if (isCapital())
										{
											bShowHalfBuilt = true;
										}
									}
								}
							}
						}


					}

					if (bShowHalfBuilt)
					{
						CvInterfacePtr<ICvPlot1> pDllPlot(new CvDllPlot(plot()));
						gDLL->GameplayWonderCreated(ePlayerID, pDllPlot.get(), eBuilding, 0);
					}
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
void CvCity::setupBuildingGraphics()
{
	VALIDATE_OBJECT
	for (int eBuildingType = 0; eBuildingType < GC.getNumBuildingInfos(); eBuildingType++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(eBuildingType);
		CvBuildingEntry* buildingInfo = GC.getBuildingInfo(eBuilding);

		if (buildingInfo)
		{
			int iExists = m_pCityBuildings->GetNumBuilding(eBuilding);
			if (iExists > 0 && buildingInfo->IsCityWall())
			{
				CvInterfacePtr<ICvPlot1> pDllPlot(new CvDllPlot(plot()));
				gDLL->GameplayWallCreated(pDllPlot.get());
			}
		}
	}
}

//	--------------------------------------------------------------------------------
void CvCity::setupSpaceshipGraphics()
{
	VALIDATE_OBJECT

	CvTeam& thisTeam = GET_TEAM(getTeam());
	ProjectTypes ApolloProgram = (ProjectTypes)GD_INT_GET(SPACE_RACE_TRIGGER_PROJECT);
	int spaceshipState = 0;

	if (isCapital() && thisTeam.getProjectCount((ProjectTypes)ApolloProgram) == 1)
	{
		ProjectTypes capsuleID = (ProjectTypes)GC.getSPACESHIP_CAPSULE();
		ProjectTypes boosterID = (ProjectTypes)GC.getSPACESHIP_BOOSTER();
		ProjectTypes stasisID = (ProjectTypes)GC.getSPACESHIP_STASIS();
		ProjectTypes engineID = (ProjectTypes)GC.getSPACESHIP_ENGINE();

		enum eSpaceshipState
		{
			eUnderConstruction = 0x0000,
			eFrame = 0x0001,
			eCapsule = 0x0002,
			eStasis_Chamber = 0x0004,
			eEngine = 0x0008,
			eBooster1 = 0x0010,
			eBooster2 = 0x0020,
			eBooster3 = 0x0040,
			eConstructed = 0x0080,
		};

		CvInterfacePtr<ICvPlot1> pDllPlot(new CvDllPlot(plot()));
		gDLL->GameplaySpaceshipRemoved(pDllPlot.get());
		gDLL->GameplaySpaceshipCreated(pDllPlot.get(), eUnderConstruction + eFrame);

		spaceshipState = eFrame;

		if ((thisTeam.getProjectCount((ProjectTypes)capsuleID)) == 1)
		{
			spaceshipState += eCapsule;
		}

		if ((thisTeam.getProjectCount((ProjectTypes)stasisID)) == 1)
		{
			spaceshipState += eStasis_Chamber;
		}

		if ((thisTeam.getProjectCount((ProjectTypes)engineID)) == 1)
		{
			spaceshipState += eEngine;
		}

		if ((thisTeam.getProjectCount((ProjectTypes)boosterID)) >= 1)
		{
			spaceshipState += eBooster1;
		}

		if ((thisTeam.getProjectCount((ProjectTypes)boosterID)) >= 2)
		{
			spaceshipState += eBooster2;
		}

		if ((thisTeam.getProjectCount((ProjectTypes)boosterID)) == 3)
		{
			spaceshipState += eBooster3;
		}

		gDLL->GameplaySpaceshipEdited(pDllPlot.get(), spaceshipState);
	}
}

//	--------------------------------------------------------------------------------
void CvCity::PreKill()
{
	VALIDATE_OBJECT

	PlayerTypes eOwner;
	if (isCitySelected())
	{
		DLLUI->clearSelectedCities();
	}

#if defined(MOD_GLOBAL_CITY_AUTOMATON_WORKERS)
	setAutomatons(0);
#endif
	setPopulation(0);

	CvPlot* pPlot = plot();

	GC.getGame().GetGameTrade()->ClearAllCityTradeRoutes(pPlot, true);

	pPlot->removeMinorResources();

	for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		CvBuildingEntry* pkBuilding = GC.getBuildingInfo((BuildingTypes)iI);
		if (pkBuilding)
		{
			m_pCityBuildings->SetNumRealBuilding(((BuildingTypes)iI), 0);
			m_pCityBuildings->SetNumFreeBuilding(((BuildingTypes)iI), 0);
		}
	}

	clearOrderQueue();

	// Killing a city while in combat is not something we really expect to happen.
	// It is *mostly* safe for it to happen, but combat systems must be able to gracefully handle the disapperance of a city.
	CvAssertMsg_Debug(!isFighting(), "isFighting did not return false as expected");

	clearCombat();

	// Could also be non-garrisoned units here that we need to show
	for (int iUnitLoop = 0; iUnitLoop < pPlot->getNumUnits(); iUnitLoop++)
	{
		CvUnit* pLoopUnit = pPlot->getUnitByIndex(iUnitLoop);

		if (pLoopUnit->IsGarrisoned())
			pLoopUnit->SetGarrisonedCity(-1);

		// Only show units that belong to this city's owner - that way we don't show units on EVERY city capture (since the old city is deleted in this case)
		if (getOwner() == pLoopUnit->getOwner())
		{
			CvInterfacePtr<ICvUnit1> pDllUnit(new CvDllUnit(pLoopUnit));
			gDLL->GameplayUnitVisibility(pDllUnit.get(), !pLoopUnit->isInvisible(GC.getGame().getActiveTeam(), true) /*bVisible*/);
		}
	}

	for (int iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);
		if (!pLoopPlot)
			continue;
		
		//give up all plots owned by this city
		if (pLoopPlot->getOwningCityID() == GetID())
			pLoopPlot->setOwner(NO_PLAYER, NO_PLAYER, /*bCheckUnits*/ false, /*bUpdateResources*/ true);

		//but also give back any loaned plots to their original city
		if (pLoopPlot->isEffectiveOwner(this))
			pLoopPlot->setOwningCityOverride(NULL);
	}

	pPlot->setIsCity(false, m_iID, getWorkPlotDistance());

	//don't need to update landmass stats, that is implied by area changes
	GC.getMap().getAreaById(pPlot->getArea())->changeCitiesPerPlayer(getOwner(), -1);
	std::vector<int> areas = pPlot->getAllAdjacentAreas();
	for (std::vector<int>::iterator it = areas.begin(); it != areas.end(); ++it)
	{
		CvArea* pkArea = GC.getMap().getAreaById(*it);
		if (pkArea->isWater())
			pkArea->changeCitiesPerPlayer(getOwner(), -1);
	}

	GET_TEAM(getTeam()).changeNumCities(-1);

	GC.getGame().changeNumCities(-1);

	CvAssertMsg(getNumGreatPeople() == 0, "getNumGreatPeople is expected to be 0");
	CvAssertMsg(!isProduction(), "isProduction is expected to be false");

	eOwner = getOwner();

	GET_PLAYER(getOwner()).GetFlavorManager()->RemoveFlavorRecipient(m_pCityStrategyAI);

	if (m_unitBeingBuiltForOperation.IsValid())
	{
		GET_PLAYER(getOwner()).CityUncommitToBuildUnitForOperationSlot(m_unitBeingBuiltForOperation);
		m_unitBeingBuiltForOperation.Invalidate();
	}
}

//	--------------------------------------------------------------------------------
void CvCity::PostKill(bool bCapital, CvPlot* pPlot, int iWorkPlotDistance, PlayerTypes eOwner)
{
	VALIDATE_OBJECT

	CvPlayer& owningPlayer = GET_PLAYER(eOwner);
	owningPlayer.CalculateNetHappiness();

	// Update Unit Maintenance for the player
	owningPlayer.UpdateUnitProductionMaintenanceMod();

	GC.getMap().updateOwningCityForPlots(pPlot, iWorkPlotDistance * 2);
	if (bCapital)
	{
#if defined(MOD_GLOBAL_NO_CONQUERED_SPACESHIPS)
		owningPlayer.disassembleSpaceship(pPlot);
#endif
		owningPlayer.findNewCapital();
		owningPlayer.SetHasLostCapital(true, getOwner());
		GET_TEAM(owningPlayer.getTeam()).resetVictoryProgress();
	}

	pPlot->setImprovementType((ImprovementTypes)(GD_INT_GET(RUINS_IMPROVEMENT)));

	if (eOwner == GC.getGame().getActivePlayer())
	{
		DLLUI->setDirty(SelectionButtons_DIRTY_BIT, true);
	}

	DLLUI->setDirty(NationalBorders_DIRTY_BIT, true);

	if (GC.getGame().getActivePlayer() == eOwner)
	{
		CvMap& theMap = GC.getMap();
		theMap.updateDeferredFog();
	}

}

//	--------------------------------------------------------------------------------
void CvCity::kill()
{
	VALIDATE_OBJECT
	CvPlot* pPlot = plot();
	PlayerTypes eOwner = getOwner();
	bool bCapital = isCapital();

	IDInfo* pUnitNode = NULL;
	CvUnit* pLoopUnit = NULL;
	pUnitNode = pPlot->headUnitNode();

	FFastSmallFixedList<IDInfo, 25, true, c_eCiv5GameplayDLL > oldUnits;

	while (pUnitNode != NULL)
	{
		oldUnits.insertAtEnd(pUnitNode);
		pUnitNode = pPlot->nextUnitNode((IDInfo*)pUnitNode);
	}

	pUnitNode = oldUnits.head();

	while (pUnitNode != NULL)
	{
		pLoopUnit = ::GetPlayerUnit(*pUnitNode);
		pUnitNode = oldUnits.next(pUnitNode);

		if (pLoopUnit)
		{
			if (pLoopUnit->IsImmobile() && !pLoopUnit->isCargo())
			{
				pLoopUnit->kill(false);
			}
		}
	}

	PreKill();

	// get spies out of city
	CvCityEspionage* pCityEspionage = GetCityEspionage();
	if (pCityEspionage)
	{
		for (int i = 0; i < MAX_MAJOR_CIVS; i++)
		{
			int iAssignedSpy = pCityEspionage->m_aiSpyAssignment[i];
			// if there is a spy in the city
			if (iAssignedSpy != -1)
			{
				GET_PLAYER((PlayerTypes)i).GetEspionage()->ExtractSpyFromCity(iAssignedSpy);
			}
		}
	}

	// Delete the city's information here!!!
	CvGameTrade* pkGameTrade = GC.getGame().GetGameTrade();
	if (pkGameTrade)
	{
		pkGameTrade->ClearAllCityTradeRoutes(plot(), true);
	}

	//save this before deleting the city
	int iWorkPlotDistance = getWorkPlotDistance();

	GET_PLAYER(getOwner()).deleteCity(m_iID);
	GET_PLAYER(eOwner).GetCityConnections()->SetDirty();

	// clean up
	PostKill(bCapital, pPlot, iWorkPlotDistance, eOwner);
}

//	--------------------------------------------------------------------------------
CvPlayer* CvCity::GetPlayer() const
{
	VALIDATE_OBJECT
	return &GET_PLAYER(getOwner());
}

void CvCity::ResetGreatWorkYieldCache()
{
	//reset the cache
	m_GwYieldCache = vector<int>(NUM_YIELD_TYPES, -1);
}

//	--------------------------------------------------------------------------------
void CvCity::doTurn()
{
	VALIDATE_OBJECT

	ResetGreatWorkYieldCache();

	if (getDamage() > 0 && !IsBlockadedWaterAndLand())
	{
		int iHitsHealed = /*20 in CP, 8 in VP*/ GD_INT_GET(CITY_HIT_POINTS_HEALED_PER_TURN);

		int iBuildingDefense = m_pCityBuildings->GetBuildingDefense();
		iBuildingDefense *= (100 + m_pCityBuildings->GetBuildingDefenseMod());
		iBuildingDefense /= 100;

		iHitsHealed += iBuildingDefense / 1000;

		//cities heal much faster if there are no enemies around
		if (MOD_BALANCE_VP)
		{
			iHitsHealed += getPopulation();
			if (getDamageTakenLastTurn()==0 && !GetCityCitizens()->AnyPlotBlockaded())
				iHitsHealed *= 3;
		}

		if (getProductionProcess() != NO_PROCESS)
		{
			CvProcessInfo* pkProcessInfo = GC.getProcessInfo(getProductionProcess());
			if (pkProcessInfo && pkProcessInfo->getDefenseValue() != 0)
			{
				int iPile = getYieldRate(YIELD_PRODUCTION, false) * pkProcessInfo->getDefenseValue();
				iHitsHealed += iPile / 100;
			}
		}

		changeDamage(-iHitsHealed);
	}

	if (getDamage() < 0)
		setDamage(0);

	if (MOD_BALANCE_CORE_JFD)
	{
		if (GetPlagueTurns() > 0)
		{
			ChangePlagueTurns(-1);
		}
	}

	if (GetSappedTurns() > 0)
		ChangeSappedTurns(-1);

#if defined(MOD_BALANCE_CORE)
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		ChangeNumTimesAttackedThisTurn((PlayerTypes)iPlayerLoop, (-1 * GetNumTimesAttackedThisTurn((PlayerTypes)iPlayerLoop)));
	}

	updateEconomicValue();
	UpdateGrowthFromTourism();

	if (plot() != NULL)
	{
		for (int iUnitLoop = 0; iUnitLoop < plot()->getNumUnits(); iUnitLoop++)
		{
			CvUnit* pLoopUnit = plot()->getUnitByIndex(iUnitLoop);

			//Only get land combat units
			if (pLoopUnit != NULL && getOwner() == pLoopUnit->getOwner() && pLoopUnit->IsCombatUnit() && pLoopUnit->getDomainType() == DOMAIN_LAND)
			{
				if (pLoopUnit->getDamage() > 0)
				{
					if ((pLoopUnit->getDamage() - GetAlwaysHeal()) <= 0)
					{
						pLoopUnit->setDamage(0);
					}
					else
					{
						pLoopUnit->changeDamage(-GetAlwaysHeal());
					}
				}
			}
		}
	}
#endif
#if defined(MOD_BALANCE_CORE_EVENTS)
	if (MOD_BALANCE_CORE_EVENTS)
	{
		if (GC.getGame().isOption(GAMEOPTION_EVENTS))
		{
			DoEvents();
		}
		else
		{
			DoEvents(true);
		}
	}
#endif
	setDrafted(false);
	setMadeAttack(false);
	GetCityBuildings()->SetSoldBuildingThisTurn(false);

	//not a full re-allocation but see if we can shift some citizens around
	//DoReallocateCitizens() will be called less frequently when a building is added, a plot is claimed, population changes etc
	GetCityCitizens()->DoVerifyWorkingPlots();
	GetCityCitizens()->OptimizeWorkedPlots(false);
	updateNetHappiness();
	UpdateTerrainImprovementNeed();

	GetCityStrategyAI()->DoTurn();
	AI_doTurn();

#if defined(MOD_BALANCE_CORE)
	if (GetUnitPurchaseCooldown() > 0)
	{
		ChangeUnitPurchaseCooldown(false, -1);
	}
	if (GetUnitPurchaseCooldown(true) > 0)
	{
		ChangeUnitPurchaseCooldown(true, -1);
	}
	if (GetUnitFaithPurchaseCooldown() > 0)
	{
		ChangeUnitFaithPurchaseCooldown(false, -1);
	}
	if (GetUnitFaithPurchaseCooldown(true) > 0)
	{
		ChangeUnitFaithPurchaseCooldown(true, -1);
	}
	if (GetBuildingPurchaseCooldown() > 0)
	{
		ChangeBuildingPurchaseCooldown(-1);
	}
	if (!GET_PLAYER(getOwner()).isHuman())
	{
		CheckForOperationUnits();
	}
	if (isCapital() && IsPuppet())
	{
		SetPuppet(false);
	}
	if (isCapital() && IsOccupied() && !IsNoOccupiedUnhappiness())
	{
		ChangeNoOccupiedUnhappinessCount(1);
	}
	if (IsRazing())
	{
		DoSellBuilding();
	}

	if (MOD_BALANCE_CORE && !GET_PLAYER(getOwner()).isMinorCiv() && !GET_PLAYER(getOwner()).isBarbarian())
	{
		int iNumAllies = GET_PLAYER(getOwner()).GetNumCSAllies();
		int iNumFriends = GET_PLAYER(getOwner()).GetNumCSFriends();
		// Loop through all minors and get the total number we've met.
		if (isCapital())
		{
			//If we get a yield bonus in all cities because of CS alliance, this is a good place to refresh it.
			int iEra = GET_PLAYER(getOwner()).GetCurrentEra();
			if (iEra <= 0)
			{
				iEra = 1;
			}
			for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				YieldTypes eYield = (YieldTypes)iI;
				if (GET_PLAYER(getOwner()).GetPlayerTraits()->GetYieldFromCSAlly(eYield) > 0)
				{
					SetBaseYieldRateFromCSAlliance(eYield, (GET_PLAYER(getOwner()).GetPlayerTraits()->GetYieldFromCSAlly(eYield) * iNumAllies * iEra));
				}
				if (GET_PLAYER(getOwner()).GetPlayerTraits()->GetYieldFromCSFriend(eYield) > 0)
				{
					SetBaseYieldRateFromCSFriendship(eYield, (GET_PLAYER(getOwner()).GetPlayerTraits()->GetYieldFromCSFriend(eYield) * iNumFriends * iEra));
				}
			}
		}
		if (MOD_BALANCE_CORE_BUILDING_RESOURCE_MAINTENANCE)
		{
			int iBad = 0;
			for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
			{
				ResourceTypes eResourceLoop = (ResourceTypes)iResourceLoop;
				if (eResourceLoop != NO_RESOURCE)
				{
					const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResourceLoop);
					if (pkResourceInfo != NULL && pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)
					{
						// See if there are any BuildingClass requirements
						if (GET_PLAYER(getOwner()).getResourceShortageValue(eResourceLoop) > 0)
						{
							const int iNumBuildingClassInfos = GC.getNumBuildingClassInfos();
							const CvCivilizationInfo& thisCivilization = GET_PLAYER(getOwner()).getCivilizationInfo();
							for (int iBuildingClassLoop = 0; iBuildingClassLoop < iNumBuildingClassInfos; iBuildingClassLoop++)
							{
								const BuildingClassTypes eBuildingClass = (BuildingClassTypes)iBuildingClassLoop;
								CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
								if (!pkBuildingClassInfo)
								{
									continue;
								}

								BuildingTypes eResourceBuilding = NO_BUILDING;
								if (MOD_BUILDINGS_THOROUGH_PREREQUISITES)
								{
									eResourceBuilding = GetCityBuildings()->GetBuildingTypeFromClass(eBuildingClass);
								}
								else
								{
									eResourceBuilding = (BuildingTypes)(thisCivilization.getCivilizationBuildings(eBuildingClass));
								}

								if (eResourceBuilding == NO_BUILDING)
								{
									continue;
								}
								if (GetCityBuildings()->GetNumBuilding(eResourceBuilding) > 0)
								{
									CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eResourceBuilding);
									if (pkBuildingInfo)
									{
										int iResourceDelta = 0;
										//If amount we're under is less than resource quantity, take the lesser value.
										if (GET_PLAYER(getOwner()).getResourceShortageValue(eResourceLoop) < pkBuildingInfo->GetResourceQuantityRequirement(eResourceLoop))
										{
											iResourceDelta = GET_PLAYER(getOwner()).getResourceShortageValue(eResourceLoop);
										}
										//Otherwise, take the building's full value.
										else
										{
											iResourceDelta = pkBuildingInfo->GetResourceQuantityRequirement(eResourceLoop);
										}
										if (iResourceDelta > 0)
										{
											iBad += (iResourceDelta * 2);
											GET_PLAYER(getOwner()).changeResourceShortageValue(eResourceLoop, -iResourceDelta);
											if (GET_PLAYER(getOwner()).getResourceShortageValue(eResourceLoop) < 0)
											{
												GET_PLAYER(getOwner()).setResourceShortageValue(eResourceLoop, 0);
											}
											CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
											if (pNotifications)
											{
												Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_OVER_RESOURCE_LIMIT_CITY");
												strText << pkResourceInfo->GetTextKey();
												strText << getNameKey();
												strText << (iResourceDelta * 2);
												Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_OVER_RESOURCE_LIMIT_CITY");
												strSummary << pkResourceInfo->GetTextKey();
												strSummary << getNameKey();
												pNotifications->Add(NOTIFICATION_DISCOVERED_STRATEGIC_RESOURCE, strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), eResourceLoop);
											}
										}
									}
								}
							}
						}
					}
				}
			}
			if (iBad > 0)
			{
				SetExtraBuildingMaintenance(iBad);
			}
			else
			{
				SetExtraBuildingMaintenance(0);
			}
		}
	}
#endif

	bool bRazed = DoRazingTurn();

	if (!bRazed)
	{
		DoResistanceTurn();

		bool bAllowNoProduction = !doCheckProduction();
#if defined(MOD_BALANCE_CORE)
		bool bWeGrew = false;
		int iDifference = (getYieldRateTimes100(YIELD_FOOD, false) - foodConsumptionTimes100());
		if (isFoodProduction() || getFood() <= 5 || iDifference <= 0)
		{
			doGrowth();
			bWeGrew = true;
		}
#endif

		doProduction(bAllowNoProduction);
		doDecay();
		doMeltdown();

		for (int iI = 0; iI < GetNumWorkablePlots(); iI++)
		{
			CvPlot* pLoopPlot = GetCityCitizens()->GetCityPlotFromIndex(iI);
			if (pLoopPlot != NULL)
			{
				if (GetCityCitizens()->IsWorkingPlot(iI))
				{
					pLoopPlot->doImprovement();
				}
			}
		}

		// Following function also looks at WLTKD stuff
		DoTestResourceDemanded();

		int iBorderGrowth = 0;
		iBorderGrowth += getJONSCulturePerTurn();
		iBorderGrowth += getYieldRate(YIELD_CULTURE_LOCAL, false);
		// Culture accumulation
		if (iBorderGrowth > 0)
			ChangeJONSCultureStored(iBorderGrowth);

		// Enough Culture to acquire a new Plot?
		if (GetJONSCultureStored() >= GetJONSCultureThreshold())
		{
			DoJONSCultureLevelIncrease();
		}

		// Resource Demanded Counter
		if (GetResourceDemandedCountdown() > 0)
		{
			ChangeResourceDemandedCountdown(-1);

			if (GetResourceDemandedCountdown() <= 0)
			{
				// Pick a Resource to demand
				DoPickResourceDemanded();
			}
		}

		updateStrengthValue();

		DoNearbyEnemy();

		//Check for Achievements
		if (MOD_API_ACHIEVEMENTS && isHuman() && !GC.getGame().isGameMultiPlayer() && GET_PLAYER(GC.getGame().getActivePlayer()).isLocalPlayer())
		{
			if (getJONSCulturePerTurn() >= 100)
			{
				gDLL->UnlockAchievement(ACHIEVEMENT_CITY_100CULTURE);
			}
			if (getYieldRate(YIELD_GOLD, false) >= 100)
			{
				gDLL->UnlockAchievement(ACHIEVEMENT_CITY_100GOLD);
			}
			if (getYieldRate(YIELD_SCIENCE, false) >= 100)
			{
				gDLL->UnlockAchievement(ACHIEVEMENT_CITY_100SCIENCE);
			}
		}

#if defined(MOD_BALANCE_CORE)
		if (!bWeGrew)
		{
			doGrowth();
		}
#endif
		GetCityCitizens()->DoTurn();

		// sending notifications on when routes are connected to the capital
		if (!isCapital())
		{
			CvNotifications* pNotifications = GET_PLAYER(m_eOwner).GetNotifications();
			if (pNotifications)
			{
				CvCity* pPlayerCapital = GET_PLAYER(m_eOwner).getCapitalCity();
				CvAssertMsg(pPlayerCapital, "No capital city?");

				if (m_bRouteToCapitalConnectedLastTurn != m_bRouteToCapitalConnectedThisTurn && pPlayerCapital)
				{
					Localization::String strMessage;
					Localization::String strSummary;

					if (m_bRouteToCapitalConnectedThisTurn)  // connected this turn
					{
						strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_TRADE_ROUTE_ESTABLISHED");
						strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_TRADE_ROUTE_ESTABLISHED");
						strMessage << getNameKey();
						strMessage << pPlayerCapital->getNameKey();
						pNotifications->Add(NOTIFICATION_TRADE_ROUTE, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, -1);
					}
					else // lost connection this turn
					{
						strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_TRADE_ROUTE_BROKEN");
						strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_TRADE_ROUTE_BROKEN");
						strMessage << getNameKey();
						strMessage << pPlayerCapital->getNameKey();
						pNotifications->Add(NOTIFICATION_TRADE_ROUTE_BROKEN, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, -1);
					}
				}
			}
#if defined(MOD_BALANCE_CORE)
			updateYield();
#endif
			m_bRouteToCapitalConnectedLastTurn = m_bRouteToCapitalConnectedThisTurn;
		}
#if defined(MOD_BALANCE_CORE)
		for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
		{
			YieldTypes eYield = (YieldTypes)iI;
			if (eYield == NO_YIELD)
				continue;

			UpdateSpecialReligionYields(eYield);
			UpdateCityYields(eYield);
		}
#endif

#ifdef _DEBUG
		//checking if yields are correct ... there have been issues
		{
			for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				CvAssert(getBaseYieldRate((YieldTypes)iI) >= 0);
				CvAssert(getYieldRate((YieldTypes)iI, false) >= 0);

				int iCount = 0;
				for (int iJ = 0; iJ < GetNumWorkablePlots(); iJ++)
				{
					CvPlot* pPlot = GetCityCitizens()->GetCityPlotFromIndex(iJ);
					if (pPlot != NULL)
					{
						if (GetCityCitizens()->IsWorkingPlot(pPlot))
						{
							iCount += pPlot->getYield((YieldTypes)iI);
						}
					}
				}

				for (int iJ = 0; iJ < GC.getNumSpecialistInfos(); iJ++)
				{
					iCount += (GET_PLAYER(getOwner()).specialistYield(((SpecialistTypes)iJ), ((YieldTypes)iI)) * (GetCityCitizens()->GetSpecialistCount((SpecialistTypes)iJ)));
				}

				for (int iJ = 0; iJ < GC.getNumBuildingInfos(); iJ++)
				{
					const BuildingTypes eBuilding = static_cast<BuildingTypes>(iJ);
					CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
					if (pkBuildingInfo)
					{
						iCount += m_pCityBuildings->GetNumActiveBuilding(eBuilding) * (pkBuildingInfo->GetYieldChange(iI) + m_pCityBuildings->GetBuildingYieldChange(pkBuildingInfo->GetBuildingClassType(), (YieldTypes)iI));
					}
				}

				// Science from Population
				if ((YieldTypes)iI == YIELD_SCIENCE)
				{
					iCount += getPopulation() * /*1 in CP, 0 in VP*/ GD_INT_GET(SCIENCE_PER_POPULATION);
				}

				CvAssert(iCount == getBaseYieldRate((YieldTypes)iI));
			}
		}
#endif
	}
}


//	--------------------------------------------------------------------------------
bool CvCity::isCitySelected()
{
	VALIDATE_OBJECT
	CvInterfacePtr<ICvCity1> pCity = GC.WrapCityPointer(this);

	return DLLUI->isCitySelected(pCity.get());
}


//	--------------------------------------------------------------------------------
void CvCity::updateYield(bool bRecalcPlotYields)
{
	VALIDATE_OBJECT
	if (bRecalcPlotYields)
	{
		ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
		BeliefTypes eSecondaryPantheon = GetCityReligions()->GetSecondaryReligionPantheonBelief();
		const CvReligion* pReligion = (eMajority != NO_RELIGION) ? GC.getGame().GetGameReligions()->GetReligion(eMajority, getOwner()) : 0;
		const CvBeliefEntry* pPantheon = (eSecondaryPantheon != NO_BELIEF) ? GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon) : 0;

		//we look at all the plots we *could* work
		for (int iI = 0; iI < GetNumWorkablePlots(); iI++)
		{
			CvPlot* pLoopPlot = GetCityCitizens()->GetCityPlotFromIndex(iI);
			if (!pLoopPlot || !pLoopPlot->isEffectiveOwner(this))
				continue;

			pLoopPlot->updateYieldFast(this, pReligion, pPantheon);
		}
	}

	UpdateAllNonPlotYields(false);
}

#if defined(MOD_BALANCE_CORE)
void CvCity::UpdateAllNonPlotYields(bool bIncludePlayerHappiness)
{
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes)iI;
		if (eYield == NO_YIELD)
			continue;

		//Simplification - errata yields not worth considering.
		if ((YieldTypes)iI > YIELD_GOLDEN_AGE_POINTS && !MOD_BALANCE_CORE_JFD)
			break;

		UpdateCityYields(eYield);
		UpdateSpecialReligionYields(eYield);
	}

	//do not always update player happiness here, it's too expensive to update
	if (bIncludePlayerHappiness)
		GET_PLAYER(getOwner()).CalculateNetHappiness();

	updateNetHappiness();
}

void CvCity::UpdateCityYields(YieldTypes eYield)
{
	if (eYield == YIELD_CULTURE)
	{
		SetStaticYield(eYield, getJONSCulturePerTurn(false) * 100);
	}
	else if (eYield == YIELD_FAITH)
	{
		SetStaticYield(eYield, GetFaithPerTurn(false) * 100);
	}
	else
	{
		SetStaticYield(eYield, getYieldRateTimes100(eYield, false, false));
	}

	//don't forget tourism
	if (eYield == YIELD_CULTURE || eYield == YIELD_TOURISM)
	{
		GetCityCulture()->CalculateBaseTourismBeforeModifiers();
		GetCityCulture()->CalculateBaseTourism();
	}
}


void CvCity::SetStaticYield(YieldTypes eYield, int iValue)
{
	CvAssertMsg(eYield >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	m_aiStaticCityYield[eYield] = iValue;
}

int CvCity::GetStaticYield(YieldTypes eYield) const
{
	VALIDATE_OBJECT
	return m_aiStaticCityYield[eYield];
}

void CvCity::SetTradePriorityLand(int iValue)
{
	m_iTradePriorityLand = iValue;
}
int CvCity::GetTradePriorityLand() const
{
	VALIDATE_OBJECT
	return m_iTradePriorityLand;
}

void CvCity::SetTradePrioritySea(int iValue)
{
	m_iTradePrioritySea = iValue;
}
int CvCity::GetTradePrioritySea() const
{
	VALIDATE_OBJECT
	return m_iTradePrioritySea;
}

void CvCity::ChangeTradeRouteSeaDistanceModifier(int iValue)
{
	if (iValue != 0)
	{
		m_iTradeRouteSeaDistanceModifier += iValue;
	}
}
int CvCity::GetTradeRouteSeaDistanceModifier() const
{
	VALIDATE_OBJECT
	return m_iTradeRouteSeaDistanceModifier;
}

void CvCity::ChangeTradeRouteLandDistanceModifier(int iValue)
{
	if (iValue != 0)
	{
		m_iTradeRouteLandDistanceModifier += iValue;
	}
}
int CvCity::GetTradeRouteLandDistanceModifier() const
{
	VALIDATE_OBJECT
	return m_iTradeRouteLandDistanceModifier;
}


//	--------------------------------------------------------------------------------
int CvCity::GetLongestPotentialTradeRoute(DomainTypes eDomain) const
{
	return m_aiLongestPotentialTradeRoute[eDomain];
}
//	--------------------------------------------------------------------------------
void CvCity::SetLongestPotentialTradeRoute(int iValue, DomainTypes eDomain)
{
	VALIDATE_OBJECT
	CvAssertMsg(eDomain >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eDomain < NUM_DOMAIN_TYPES, "eIndex1 is expected to be within maximum bounds (invalid Index)");
	m_aiLongestPotentialTradeRoute[eDomain] = iValue;
}

bool CvCity::AreOurBordersTouching(PlayerTypes ePlayer)
{
	int iX = getX(); int iY = getY(); int iOwner = getOwner();

	for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(iX, iY, iCityPlotLoop);

		// Invalid plot or not owned by this player
		if (pLoopPlot == NULL || pLoopPlot->getOwner() != iOwner)
		{
			continue;
		}

		for (int jJ = 0; jJ < NUM_DIRECTION_TYPES; jJ++)
		{
			CvPlot* pAdjacentPlot = plotDirection(pLoopPlot->getX(), pLoopPlot->getY(), ((DirectionTypes)jJ));
			if (pAdjacentPlot != NULL && pAdjacentPlot->getOwner() == ePlayer)
				return true;
		}
	}
	return false;
}

//	--------------------------------------------------------------------------------
void CvCity::UpdateCachedYieldMedians()
{
	SetCachedBasicNeedsMedian(GC.getGame().GetBasicNeedsMedian());
	SetCachedGoldMedian(GC.getGame().GetGoldMedian());
	SetCachedScienceMedian(GC.getGame().GetScienceMedian());
	SetCachedCultureMedian(GC.getGame().GetCultureMedian());

	SetCachedTechNeedModifier(GET_PLAYER(getOwner()).GetTechNeedModifier());
	SetCachedEmpireSizeModifier(GetEmpireSizeModifier());

	SetYieldMediansCachedTurn(GC.getGame().getGameTurn());
}
//	--------------------------------------------------------------------------------
void CvCity::SetCachedBasicNeedsMedian(int iValue)
{
	m_iCachedBasicNeedsMedian = iValue;
}
void CvCity::SetCachedGoldMedian(int iValue)
{
	m_iCachedGoldMedian = iValue;
}
void CvCity::SetCachedScienceMedian(int iValue)
{
	m_iCachedScienceMedian = iValue;
}
void CvCity::SetCachedCultureMedian(int iValue)
{
	m_iCachedCultureMedian = iValue;
}
void CvCity::SetCachedTechNeedModifier(int iValue)
{
	m_iCachedTechNeedModifier = iValue;
}
void CvCity::SetCachedEmpireSizeModifier(int iValue)
{
	m_iCachedEmpireSizeModifier = iValue;
}
void CvCity::SetYieldMediansCachedTurn(int iTurn)
{
	m_iYieldMediansCachedTurn = iTurn;
}
//	--------------------------------------------------------------------------------
int CvCity::GetCachedBasicNeedsMedian() const
{
	return m_iCachedBasicNeedsMedian;
}
int CvCity::GetCachedGoldMedian() const
{
	return m_iCachedGoldMedian;
}
int CvCity::GetCachedScienceMedian() const
{
	return m_iCachedScienceMedian;
}
int CvCity::GetCachedCultureMedian() const
{
	return m_iCachedCultureMedian;
}
int CvCity::GetCachedTechNeedModifier() const
{
	return m_iCachedTechNeedModifier;
}
int CvCity::GetCachedEmpireSizeModifier() const
{
	return m_iCachedEmpireSizeModifier;
}
int CvCity::GetYieldMediansCachedTurn() const
{
	return m_iYieldMediansCachedTurn;
}
//	--------------------------------------------------------------------------------

int CvCity::GetHappinessFromEmpire() const
{
	VALIDATE_OBJECT
	return m_iHappinessFromEmpire;
}
void CvCity::ChangeHappinessFromEmpire(int iValue)
{
	m_iHappinessFromEmpire += iValue;
}
void CvCity::ResetHappinessFromEmpire()
{
	m_iHappinessFromEmpire = 0;
}

void CvCity::UpdateUnhappinessFromEmpire()
{
	CvPlayer& kPlayer = GET_PLAYER(getOwner());
	if (CityStrategyAIHelpers::IsTestCityStrategy_IsPuppetAndAnnexable(this))
	{
		m_iUnhappinessFromEmpire = 0;
		return;
	}

	if (kPlayer.GetUnhappiness() == 0)
	{
		m_iUnhappinessFromEmpire = 0;
		return;
	}

	int iCities = max(1, kPlayer.GetNumRealCities());
	int iRemainder = kPlayer.GetUnhappiness() % iCities;
	int iUnhappiness = kPlayer.GetUnhappiness() / iCities;

	int iThisCityUnhappiness = 0;
	const CvCity* pLoopCity = NULL;
	int iLoop = 0;
	while (iRemainder > 0)
	{
		for (pLoopCity = kPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kPlayer.nextCity(&iLoop))
		{
			if (CityStrategyAIHelpers::IsTestCityStrategy_IsPuppetAndAnnexable(pLoopCity))
				continue;

			if (pLoopCity->GetID() == GetID())
				iThisCityUnhappiness++;

			iRemainder--;
			if (iRemainder <= 0)
				break;
		}
	}

	m_iUnhappinessFromEmpire = iUnhappiness + iThisCityUnhappiness;
}
int CvCity::GetUnhappinessFromEmpire() const
{
	VALIDATE_OBJECT
	return m_iUnhappinessFromEmpire;
}

#endif
#if defined(MOD_BALANCE_CORE_EVENTS)
int CvCity::GetEventChoiceDuration(CityEventChoiceTypes eEventChoice) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEventChoice >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEventChoice < GC.getNumCityEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	return m_aiEventChoiceDuration[eEventChoice];
}
void CvCity::ChangeEventChoiceDuration(CityEventChoiceTypes eEventChoice, int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEventChoice >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEventChoice < GC.getNumCityEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	if (iValue != 0)
	{
		m_aiEventChoiceDuration[eEventChoice] = m_aiEventChoiceDuration[eEventChoice] + iValue;
	}
}
void CvCity::SetEventChoiceDuration(CityEventChoiceTypes eEventChoice, int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEventChoice >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEventChoice < GC.getNumCityEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	m_aiEventChoiceDuration[eEventChoice] = iValue;
}
int CvCity::GetEventIncrement(CityEventTypes eEvent) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumCityEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	return m_aiEventIncrement[eEvent];
}
void CvCity::IncrementEvent(CityEventTypes eEvent, int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumCityEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	if (iValue != 0)
	{
		m_aiEventIncrement[eEvent] = m_aiEventIncrement[eEvent] + iValue;
	}
}
int CvCity::GetCityEventCooldown() const
{
	VALIDATE_OBJECT
	return m_iCityEventCooldown;
}
void CvCity::ChangeCityEventCooldown(int iValue)
{
	VALIDATE_OBJECT
	if (iValue != 0)
	{
		m_iCityEventCooldown += iValue;
	}
}
void CvCity::ChangeEventCityYield(YieldTypes eYield, int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eYield >= 0, "eYield is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eYield is expected to be within maximum bounds (invalid Index)");
	if (iValue != 0)
	{
		m_aiEventCityYield[eYield] = m_aiEventCityYield[eYield] + iValue;
		updateYield(false);
	}
}
int CvCity::GetEventCityYield(YieldTypes eYield) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eYield >= 0, "eYield is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eYield is expected to be within maximum bounds (invalid Index)");
	return m_aiEventCityYield[eYield];
}

void CvCity::ChangeEventCityYieldModifier(YieldTypes eYield, int iValue)
{
	VALIDATE_OBJECT
		CvAssertMsg(eYield >= 0, "eYield is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eYield is expected to be within maximum bounds (invalid Index)");
	if (iValue != 0)
	{
		m_aiEventCityYieldModifier[eYield] = m_aiEventCityYieldModifier[eYield] + iValue;
		updateYield(false);
	}
}
int CvCity::GetEventCityYieldModifier(YieldTypes eYield) const
{
	VALIDATE_OBJECT
		CvAssertMsg(eYield >= 0, "eYield is expected to be non-negative (invalid Index)");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eYield is expected to be within maximum bounds (invalid Index)");
	return m_aiEventCityYieldModifier[eYield];
}


//	--------------------------------------------------------------------------------
int CvCity::GetEventBuildingClassCityYield(BuildingClassTypes eIndex1, YieldTypes eIndex2)	const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumBuildingClassInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return ModifierLookup(m_eventYields[eIndex2].forBuilding, eIndex1);
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeEventBuildingClassYield(BuildingClassTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumBuildingClassInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	SCityEventYields& y = m_eventYields[eIndex2];
	if (ModifierUpdateInsertRemove(y.forBuilding, eIndex1, iChange, true))
		updateYield(false);
}
//	--------------------------------------------------------------------------------
int CvCity::GetEventBuildingClassCityYieldModifier(BuildingClassTypes eIndex1, YieldTypes eIndex2)	const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumBuildingClassInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return ModifierLookup(m_eventYields[eIndex2].forBuildingModifier, eIndex1);
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeEventBuildingClassYieldModifier(BuildingClassTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < GC.getNumBuildingClassInfos(), "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	SCityEventYields& y = m_eventYields[eIndex2];
	if (ModifierUpdateInsertRemove(y.forBuildingModifier, eIndex1, iChange, true))
		updateYield(false);
}

//	--------------------------------------------------------------------------------
int CvCity::GetEventImprovementYield(ImprovementTypes eImprovement, YieldTypes eIndex2)	const
{
	CvAssertMsg(eImprovement >= 0, "eImprovement is expected to be non-negative (invalid Index)");
	CvAssertMsg(eImprovement < GC.getNumFeatureInfos(), "eImprovement is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return ModifierLookup(m_eventYields[eIndex2].forImprovement, eImprovement);
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeEventImprovementYield(ImprovementTypes eImprovement, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eImprovement >= 0, "eImprovement is expected to be non-negative (invalid Index)");
	CvAssertMsg(eImprovement < GC.getNumFeatureInfos(), "eImprovement is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	SCityEventYields& y = m_eventYields[eIndex2];
	if (ModifierUpdateInsertRemove(y.forImprovement, eImprovement, iChange, true))
		updateYield();
}
//	--------------------------------------------------------------------------------
int CvCity::GetEventResourceYield(ResourceTypes eResource, YieldTypes eIndex2)	const
{
	CvAssertMsg(eResource >= 0, "eResource is expected to be non-negative (invalid Index)");
	CvAssertMsg(eResource < GC.getNumResourceInfos(), "eResource is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return ModifierLookup(m_eventYields[eIndex2].forResource, eResource);
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeEventResourceYield(ResourceTypes eResource, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eResource >= 0, "eResource is expected to be non-negative (invalid Index)");
	CvAssertMsg(eResource < GC.getNumResourceInfos(), "eResource is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	SCityEventYields& y = m_eventYields[eIndex2];
	if (ModifierUpdateInsertRemove(y.forResource, eResource, iChange, true))
		updateYield();
}

//	--------------------------------------------------------------------------------
int CvCity::GetEventSpecialistYield(SpecialistTypes eSpecialist, YieldTypes eIndex2)	const
{
	CvAssertMsg(eSpecialist >= 0, "eSpecialist is expected to be non-negative (invalid Index)");
	CvAssertMsg(eSpecialist < GC.getNumSpecialistInfos(), "eSpecialist is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return ModifierLookup(m_eventYields[eIndex2].forSpecialist, eSpecialist);
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeEventSpecialistYield(SpecialistTypes eSpecialist, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eSpecialist >= 0, "eSpecialist is expected to be non-negative (invalid Index)");
	CvAssertMsg(eSpecialist < GC.getNumSpecialistInfos(), "eSpecialist is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	SCityEventYields& y = m_eventYields[eIndex2];
	if (ModifierUpdateInsertRemove(y.forSpecialist, eSpecialist, iChange, true))
		updateYield(false);
}

//	--------------------------------------------------------------------------------
int CvCity::GetEventTerrainYield(TerrainTypes eTerrain, YieldTypes eIndex2)	const
{
	CvAssertMsg(eTerrain >= 0, "eImprovement is expected to be non-negative (invalid Index)");
	CvAssertMsg(eTerrain < GC.getNumTerrainInfos(), "eImprovement is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return ModifierLookup(m_eventYields[eIndex2].forTerrain, eTerrain);
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeEventTerrainYield(TerrainTypes eTerrain, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eTerrain >= 0, "eTerrain is expected to be non-negative (invalid Index)");
	CvAssertMsg(eTerrain < GC.getNumTerrainInfos(), "eTerrain is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	SCityEventYields& y = m_eventYields[eIndex2];
	if (ModifierUpdateInsertRemove(y.forTerrain, eTerrain, iChange, true))
		updateYield();
}
//	--------------------------------------------------------------------------------
int CvCity::GetEventFeatureYield(FeatureTypes eFeature, YieldTypes eIndex2)	const
{
	CvAssertMsg(eFeature >= 0, "eFeature is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFeature < GC.getNumFeatureInfos(), "eFeature is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");
	return ModifierLookup(m_eventYields[eIndex2].forFeature, eFeature);
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeEventFeatureYield(FeatureTypes eFeature, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eFeature >= 0, "eFeature is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFeature < GC.getNumFeatureInfos(), "eFeature is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	SCityEventYields& y = m_eventYields[eIndex2];
	if (ModifierUpdateInsertRemove(y.forFeature, eFeature, iChange, true))
		updateYield();
}
void CvCity::DoEvents(bool bEspionageOnly)
{
	//Minors? Barbs? Get out!
	if (GET_PLAYER(getOwner()).isMinorCiv() || GET_PLAYER(getOwner()).isBarbarian())
		return;

	//Event Choice Duration First - if we're in one, let's do the countdown now.
	//We need to do this first so we can cancel the event(s).
	for (int iLoop = 0; iLoop < GC.getNumCityEventChoiceInfos(); iLoop++)
	{
		CityEventChoiceTypes eEventChoice = (CityEventChoiceTypes)iLoop;
		if (eEventChoice != NO_EVENT_CHOICE_CITY)
		{
			if (GetEventChoiceDuration(eEventChoice) > 0)
			{
				ChangeEventChoiceDuration(eEventChoice, -1);
				CvModEventCityChoiceInfo* pkEventInfo = GC.getCityEventChoiceInfo(eEventChoice);
				if (pkEventInfo != NULL)
				{
					//we expire these in a special way.
					if (pkEventInfo->isExpiresOnCounterSpyExit())
						continue;

					if (GC.getLogging())
					{

						CvString playerName;
						FILogFile* pLog = NULL;
						CvString strBaseString;
						CvString strOutBuf;
						CvString strFileName = "EventCityLogging.csv";
						playerName = getName();
						pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
						strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
						strBaseString += playerName + ", ";
						strOutBuf.Format("Event choice: %s. Cooldown Active. Changing Value by -1. Cooldown Remaining: %d", pkEventInfo->GetDescription(), GetEventChoiceDuration(eEventChoice));
						strBaseString += strOutBuf;
						pLog->Msg(strBaseString);
					}
				}
				if (GetEventChoiceDuration(eEventChoice) == 0)
				{
					DoCancelEventChoice(eEventChoice);
				}
			}
		}
	}

	///
	//Special Sight Shenanigans for Spies...
	///

	CityEventChoiceTypes eEspionageSight = (CityEventChoiceTypes)GC.getInfoTypeForString("ESPIONAGE_EVENT_CHOICE_REVEAL_AREA");
	int iSight = /*1*/ GD_INT_GET(ESPIONAGE_SURVEILLANCE_SIGHT_RANGE);
	if (eEspionageSight != NO_EVENT_CHOICE_CITY)
	{
		CvModEventCityChoiceInfo* pkEventInfo = GC.getCityEventChoiceInfo(eEspionageSight);
		if (pkEventInfo != NULL)
		{
			iSight = pkEventInfo->getSpyVisionRange();
		}
	}
	for (int i = 0; i < MAX_MAJOR_CIVS; i++)
	{
		PlayerTypes ePlayer = PlayerTypes(i);
		if (ePlayer == NO_PLAYER || !GET_PLAYER(ePlayer).isEverAlive())
			continue;

		if (GetBonusEspionageSightTurns(ePlayer) > 0)
		{
			UpdateBonusEspionageSightTurns(ePlayer, -1);
			if (GetBonusEspionageSightTurns(ePlayer) == 0)
			{
				plot()->changeAdjacentSight(GET_PLAYER(ePlayer).getTeam(), iSight, false, NO_INVISIBLE, NO_DIRECTION);

				CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();
				if (pNotifications && GC.getGame().getActivePlayer() == ePlayer)
				{
					Localization::String strMessage;
					Localization::String strSummary;
					strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_EXTRA_SIGHT_EVENT_HAS_ENDED_CITY");
					strMessage << getNameKey();
					strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_EXTRA_SIGHT_EVENT_HAS_ENDED_CITY_T");
					strSummary << getNameKey();

					pNotifications->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), getX(), getY(), GetID(), ePlayer);
				}

				uint uiSpyIndex = GET_PLAYER(ePlayer).GetEspionage()->GetSpyIndexInCity(this);
				// if we still have established surveillance in the city, keep the lights on a bit.
				if (GET_PLAYER(ePlayer).GetEspionage()->HasEstablishedSurveillance(uiSpyIndex))
				{
					plot()->changeAdjacentSight(GET_PLAYER(ePlayer).getTeam(), /*1*/ GD_INT_GET(ESPIONAGE_SURVEILLANCE_SIGHT_RANGE), true, NO_INVISIBLE, NO_DIRECTION);
				}
			}
		}

	}

	/////
	// End
	////

	if (bEspionageOnly)
		return;

	if (GetCityEventCooldown() > 0)
	{
		if (GC.getLogging())
		{
			CvString playerName;
			FILogFile* pLog = NULL;
			CvString strBaseString;
			CvString strOutBuf;
			CvString strFileName = "EventCityLogging.csv";
			playerName = getName();
			pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			strBaseString += playerName + ", ";
			strOutBuf.Format("City Event: Global Cooldown Active. Cooldown: %d", GetCityEventCooldown());
			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}
		ChangeCityEventCooldown(-1);
	}

	//Let's loop through all events.
	CvWeightedVector<int> veValidEvents;

	for (int iLoop = 0; iLoop < GC.getNumCityEventInfos(); iLoop++)
	{
		CityEventTypes eEvent = (CityEventTypes)iLoop;
		if (eEvent != NO_EVENT_CITY)
		{
			CvModCityEventInfo* pkEventInfo = GC.getCityEventInfo(eEvent);
			if (pkEventInfo == NULL)
			{
				continue;
			}

			if (pkEventInfo->getRandomChance() == -1)
				continue;

			if (pkEventInfo->isOneShot() && IsEventFired(eEvent))
				continue;

			//Lua Hook
			if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_CityEventCanTake, getOwner(), GetID(), eEvent) == GAMEEVENTRETURN_FALSE)
			{
				continue;
			}

			//Global Cooldown Second - if we've had this event recently, let's check this.
			if (GetEventCooldown(eEvent) > 0)
			{
				if (GC.getLogging())
				{
					CvModCityEventInfo* pkEventInfo = GC.getCityEventInfo(eEvent);
					if (pkEventInfo != NULL)
					{
						CvString playerName;
						FILogFile* pLog = NULL;
						CvString strBaseString;
						CvString strOutBuf;
						CvString strFileName = "EventCityLogging.csv";
						playerName = getName();
						pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
						strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
						strBaseString += playerName + ", ";
						strOutBuf.Format("City Event: %s. Cooldown Active. Cooldown: %d", pkEventInfo->GetDescription(), GetEventCooldown(eEvent));
						strBaseString += strOutBuf;
						pLog->Msg(strBaseString);
					}
				}
				//This is done at the player level, not the City level!
				ChangeEventCooldown(eEvent, -1);
				continue;
			}

			if (GetCityEventCooldown() > 0 && !pkEventInfo->IgnoresGlobalCooldown())
			{
				continue;
			}

			//most expensive check last
			if (IsCityEventValid(eEvent))
			{
				veValidEvents.push_back(eEvent, pkEventInfo->getRandomChance() + GetEventIncrement(eEvent));
			}
		}
	}

	CityEventTypes eChosenEvent = NO_EVENT_CITY;

	if (veValidEvents.size() > 0)
	{
		//		veValidEvents.StableSortItems();
		int iRandIndex = GC.getGame().getSmallFakeRandNum(2500, veValidEvents.size() + GetID());

		if (GC.getLogging())
		{
			CvString strBaseString;
			CvString strOutBuf;
			CvString strFileName = "EventCityLogging.csv";
			CvString playerName = getName();
			FILogFile* pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			strBaseString += playerName + ", ";
			strOutBuf.Format("Found %d Events for seeding. Random=%d", veValidEvents.size(), iRandIndex);
			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}

		//which one is it?
		int iWeight = 0;
		for (int iLoop = 0; iLoop < veValidEvents.size(); iLoop++)
		{
			CityEventTypes eEvent = (CityEventTypes)veValidEvents.GetElement(iLoop);
			CvModCityEventInfo* pkEventInfo = GC.getCityEventInfo(eEvent);
			if (!pkEventInfo)
				continue;

			iWeight = veValidEvents.GetWeight(iLoop);
			iWeight += veValidEvents.GetWeight(iLoop); //afw

			if (iRandIndex < iWeight)
			{
				eChosenEvent = eEvent;
				break;
			}
		}

		if (eChosenEvent != NO_EVENT_CITY)
		{
			CvModCityEventInfo* pkEventInfo = GC.getCityEventInfo(eChosenEvent);
			if (pkEventInfo != NULL)
			{
				DoStartEvent(eChosenEvent, false);

				ChangeCityEventCooldown(/*25*/ GD_INT_GET(CITY_EVENT_MIN_DURATION_BETWEEN));

				//We did it! But reset our increment.
				IncrementEvent(eChosenEvent, -GetEventIncrement(eChosenEvent));
				if (GC.getLogging())
				{
					CvString strBaseString;
					CvString strOutBuf;
					CvString strFileName = "EventCityLogging.csv";
					CvString playerName = getName();
					FILogFile* pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
					strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
					strBaseString += playerName + ", ";
					strOutBuf.Format("Resetting event chance: %s", pkEventInfo->GetDescription());
					strBaseString += strOutBuf;
					pLog->Msg(strBaseString);
				}
			}
		}
	}

	for (int iLoop = 0; iLoop < veValidEvents.size(); iLoop++)
	{
		CityEventTypes eEvent = (CityEventTypes)veValidEvents.GetElement(iLoop);
		if (eEvent != NO_EVENT_CITY)
		{
			CvModCityEventInfo* pkEventInfo = GC.getCityEventInfo(eEvent);
			if (!pkEventInfo)
				continue;

			//But not for the one we just did!
			if (eEvent == eChosenEvent)
				continue;

			//We didn't do it? Bummer. BUT if there's a delta, the chance gets higher next turn...
			if (pkEventInfo->getRandomChanceDelta() > 0)
			{
				IncrementEvent(eEvent, pkEventInfo->getRandomChanceDelta());
				if (GC.getLogging())
				{
					CvString strBaseString;
					CvString strOutBuf;
					CvString strFileName = "EventCityLogging.csv";
					CvString playerName = getName();
					FILogFile* pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
					strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
					strBaseString += playerName + ", ";
					strOutBuf.Format("Incrementing event chance: %s, Increment: %d", pkEventInfo->GetDescription(), GetEventIncrement(eEvent));
					strBaseString += strOutBuf;
					pLog->Msg(strBaseString);
				}
			}
		}
	}
}
void CvCity::DoStartEvent(CityEventTypes eChosenEvent, bool bSendMsg)
{
	if (eChosenEvent != NO_EVENT_CITY)
	{
		CvModCityEventInfo* pkEventInfo = GC.getCityEventInfo(eChosenEvent);
		if (pkEventInfo != NULL)
		{
			//Set true so we know we're doing an event right now.
			SetEventActive(eChosenEvent, true);

			//Set oneshot stuff so this event can't fire ever again.
			if (pkEventInfo->isOneShot())
			{
				SetEventFired(eChosenEvent, true);
			}
			//Lua Hook
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityEventActivated, getOwner(), GetID(), eChosenEvent);

			//Gamespeed.
			int iEventDuration = pkEventInfo->getCooldown();
			iEventDuration *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iEventDuration /= 100;
			ChangeEventCooldown(eChosenEvent, iEventDuration);
			if (GC.getLogging())
			{
				CvString playerName;
				FILogFile* pLog = NULL;
				CvString strBaseString;
				CvString strOutBuf;
				CvString strFileName = "EventCityLogging.csv";
				playerName = getName();
				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				strBaseString += playerName + ", ";
				strOutBuf.Format("Event started for city: %s. Cooldown: %d", pkEventInfo->GetDescription(), iEventDuration);
				strBaseString += strOutBuf;
				pLog->Msg(strBaseString);
			}
			int iNumEvent = 0;
			CityEventChoiceTypes eEventChoice = NO_EVENT_CHOICE_CITY;
			for (int iLoop = 0; iLoop < GC.getNumCityEventChoiceInfos(); iLoop++)
			{
				eEventChoice = (CityEventChoiceTypes)iLoop;
				if (eEventChoice != NO_EVENT_CHOICE_CITY)
				{
					CvModEventCityChoiceInfo* pkEventChoiceInfo = GC.getCityEventChoiceInfo(eEventChoice);
					if (pkEventChoiceInfo != NULL)
					{
						if (IsCityEventChoiceValid(eEventChoice, eChosenEvent))
						{
							iNumEvent++;
							if (pkEventInfo->getNumChoices() == 1)
							{
								DoEventChoice(eEventChoice, eChosenEvent, bSendMsg);
								if (isHuman())
								{
									CvPopupInfo kPopupInfo(BUTTONPOPUP_MODDER_7, eEventChoice, GetID(), getOwner());
									GC.GetEngineUserInterface()->AddPopup(kPopupInfo);
								}
								return;
							}
						}
					}
				}
			}
			if (iNumEvent > 0 && pkEventInfo->getNumChoices() > 1)
			{
				if (GET_PLAYER(getOwner()).isHuman())
				{
					CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
					if (pNotifications)
					{
						CvString strBuffer = GetLocalizedText("TXT_KEY_CHOOSE_EVENT_CHOICE_CITY");
						CvString strSummary = GetLocalizedText("TXT_KEY_CHOOSE_EVENT_CHOICE_CITY_TT");
						pNotifications->Add((NotificationTypes)FString::Hash("NOTIFICATION_EVENT_CHOICE_CITY"), strSummary.c_str(), strBuffer.c_str(), -1, -1, eChosenEvent, GetID());
					}
				}
				else
				{
					//Lua Hook
					if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_OverrideAICityEvent, getOwner(), GetID(), eChosenEvent) == GAMEEVENTRETURN_TRUE)
					{
						return;
					}
					AI_DoEventChoice(eChosenEvent);
				}
			}
		}
	}
}
bool CvCity::IsCityEventValid(CityEventTypes eEvent)
{
	CvModCityEventInfo* pkEventInfo = GC.getCityEventInfo(eEvent);
	if (pkEventInfo == NULL)
	{
		return false;
	}

	//Lua Hook
	if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_CityEventCanActivate, getOwner(), GetID(), eEvent) == GAMEEVENTRETURN_FALSE)
	{
		return false;
	}

	EventClassTypes eEventClass = (EventClassTypes)pkEventInfo->getEventClass();
	if (eEventClass != NO_EVENT_CLASS)
	{
		if (eEventClass == EVENT_CLASS_GOOD)
		{
			if (GC.getGame().isOption(GAMEOPTION_GOOD_EVENTS_OFF))
				return false;
		}
		else if (eEventClass == EVENT_CLASS_BAD)
		{
			if (GC.getGame().isOption(GAMEOPTION_BAD_EVENTS_OFF))
				return false;
		}
		else if (eEventClass == EVENT_CLASS_NEUTRAL)
		{
			if (GC.getGame().isOption(GAMEOPTION_NEUTRAL_EVENTS_OFF))
				return false;
		}
		else if (eEventClass == EVENT_CLASS_TRADE)
		{
			if (GC.getGame().isOption(GAMEOPTION_TRADE_EVENTS_OFF))
				return false;
		}
		else if (eEventClass == EVENT_CLASS_CIV_SPECIFIC)
		{
			if (GC.getGame().isOption(GAMEOPTION_CIV_SPECIFIC_EVENTS_OFF))
				return false;
		}
	}

	CvPlayer& kPlayer = GET_PLAYER(m_eOwner);

	//Let's do our linker checks here.
	for (int iI = 0; iI <= pkEventInfo->GetNumLinkers(); iI++)
	{
		CvCityEventLinkingInfo* pLinkerInfo = pkEventInfo->GetLinkerInfo(iI);
		if (pLinkerInfo)
		{
			EventTypes eLinkerEvent = (EventTypes)pLinkerInfo->GetLinkingEvent();
			EventChoiceTypes eLinkerEventChoice = (EventChoiceTypes)pLinkerInfo->GetLinkingEventChoice();
			CityEventTypes eLinkerCityEvent = (CityEventTypes)pLinkerInfo->GetCityLinkingEvent();
			CityEventChoiceTypes eLinkerCityEventChoice = (CityEventChoiceTypes)pLinkerInfo->GetCityLinkingEventChoice();

			PlayerTypes ePlayer;
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				ePlayer = (PlayerTypes)iPlayerLoop;
				if (ePlayer == NO_PLAYER)
					continue;

				CvPlayer& kPlayer2 = GET_PLAYER(ePlayer);

				if (!pLinkerInfo->CheckOtherPlayers() && ePlayer != getOwner())
					continue;

				if (eLinkerEvent != NO_EVENT)
				{
					bool bActive = (kPlayer2.GetEventCooldown(eLinkerEvent) > 0 || kPlayer2.IsEventFired(eLinkerEvent));
					if (bActive != pLinkerInfo->CheckForActive())
						return false;
				}

				if (eLinkerEventChoice != NO_EVENT_CHOICE)
				{
					bool bActive = (kPlayer2.GetEventChoiceDuration(eLinkerEventChoice) > 0 || kPlayer2.IsEventChoiceFired(eLinkerEventChoice));
					if (bActive != pLinkerInfo->CheckForActive())
						return false;
				}

				if (eLinkerCityEvent != NO_EVENT_CITY || eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
				{
					int iLoop = 0;
					CvCity* pLoopCity = NULL;
					for (pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))
					{
						if (pLoopCity != this && pLinkerInfo->CheckOnlyActiveCity())
							continue;

						if (eLinkerCityEvent != NO_EVENT_CITY)
						{
							bool bActive = (pLoopCity->GetEventCooldown(eLinkerCityEvent) > 0 || pLoopCity->IsEventFired(eLinkerCityEvent));
							if (bActive != pLinkerInfo->CheckForActive())
								return false;
						}

						if (eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
						{
							bool bActive = (pLoopCity->GetEventChoiceDuration(eLinkerCityEventChoice) > 0 || pLoopCity->IsEventChoiceFired(eLinkerCityEventChoice));
							if (bActive != pLinkerInfo->CheckForActive())
								return false;
						}
					}
				}
			}
		}
	}

	//Let's narrow down all events here!
	if (pkEventInfo->isCapital() && !isCapital())
		return false;

	if (pkEventInfo->isCoastal() && !isCoastal())
		return false;

	if (pkEventInfo->isRiver() && !plot()->isRiver())
		return false;

	if (pkEventInfo->isRequiresGarrison() && !HasGarrison())
		return false;

	if (pkEventInfo->hasStateReligion() && kPlayer.GetReligions()->GetStateReligion(false) == NO_RELIGION)
		return false;

	if (pkEventInfo->getPrereqTech() != -1 && !GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
		return false;

	if (pkEventInfo->getObsoleteTech() != -1 && GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getObsoleteTech()))
		return false;

	if (pkEventInfo->getRequiredEra() != -1 && kPlayer.GetCurrentEra() < (EraTypes)pkEventInfo->getRequiredEra())
		return false;

	if (pkEventInfo->getObsoleteEra() != -1 && kPlayer.GetCurrentEra() >= (EraTypes)pkEventInfo->getObsoleteEra())
		return false;

	if (pkEventInfo->getMinimumPopulation() > 0 && getPopulation() < pkEventInfo->getMinimumPopulation())
		return false;

	if (pkEventInfo->isResistance() && GetResistanceTurns() <= 0)
		return false;

	if (pkEventInfo->isWLTKD() && GetWeLoveTheKingDayCounter() <= 0)
		return false;

	if (pkEventInfo->isPuppet() && !IsPuppet())
		return false;

	if (pkEventInfo->isRazing() && !IsRazing())
		return false;

	if (pkEventInfo->isOccupied() && (!IsOccupied() || IsNoOccupiedUnhappiness()))
		return false;

	if (pkEventInfo->hasAnyReligion() && GetCityReligions()->GetReligiousMajority() <= RELIGION_PANTHEON)
		return false;

	if (pkEventInfo->getRequiredCiv() != -1 && getCivilizationType() != (CivilizationTypes)pkEventInfo->getRequiredCiv())
		return false;

	if (pkEventInfo->getRequiredPolicy() != -1 && !kPlayer.GetPlayerPolicies()->HasPolicy((PolicyTypes)pkEventInfo->getRequiredPolicy()))
		return false;

	if (pkEventInfo->getRequiredIdeology() != -1 && kPlayer.GetPlayerPolicies()->GetLateGamePolicyTree() != (PolicyBranchTypes)pkEventInfo->getRequiredIdeology())
		return false;

	if (pkEventInfo->hasPlayerReligion() && kPlayer.GetReligions()->GetOwnedReligion() != GetCityReligions()->GetReligiousMajority())
		return false;

	if (pkEventInfo->lacksPlayerReligion() && kPlayer.GetReligions()->GetOwnedReligion() == GetCityReligions()->GetReligiousMajority())
		return false;

	if (pkEventInfo->hasPlayerMajority() && kPlayer.GetReligions()->GetReligionInMostCities() != GetCityReligions()->GetReligiousMajority())
		return false;

	if (pkEventInfo->lacksPlayerMajority() && kPlayer.GetReligions()->GetReligionInMostCities() == GetCityReligions()->GetReligiousMajority())
		return false;

	if (pkEventInfo->getRequiredStateReligion() != -1)
	{
		if (kPlayer.GetReligions()->GetOwnedReligion() != pkEventInfo->getRequiredStateReligion())
			return false;
	}

	if (!pkEventInfo->isRequiresHolyCity() && pkEventInfo->getRequiredReligion() != -1)
	{
		if (GetCityReligions()->GetReligiousMajority() != (ReligionTypes)pkEventInfo->getRequiredReligion())
			return false;
	}

	if (pkEventInfo->isRequiresHolyCity())
	{
		if (pkEventInfo->getRequiredReligion() != -1)
		{
			if (!GetCityReligions()->IsHolyCityForReligion((ReligionTypes)pkEventInfo->getRequiredReligion()))
				return false;
		}
		else
		{
			if (!GetCityReligions()->IsHolyCityAnyReligion())
				return false;
		}
	}
	if (pkEventInfo->isRequiresIdeology() && kPlayer.GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
		return false;

	if (pkEventInfo->isRequiresWar() && kPlayer.GetMilitaryAI()->GetNumberCivsAtWarWith(false) <= 0)
		return false;

	if (pkEventInfo->hasCityConnection() && !IsRouteToCapitalConnected())
		return false;

	if (pkEventInfo->hasTradeConnection() && !HasTradeRouteFromAnyCity() && !HasTradeRouteToAnyCity())
		return false;

	if (pkEventInfo->isNearMountain() && GetNearbyMountains() <= 0)
		return false;

	if (pkEventInfo->isNearNaturalWonder() && !HasAnyNaturalWonder())
		return false;

	if (pkEventInfo->getMaximumPopulation() != 0 && getPopulation() > pkEventInfo->getMaximumPopulation())
		return false;

	if (pkEventInfo->hasPantheon() && GetCityReligions()->GetReligiousMajority() != RELIGION_PANTHEON)
		return false;

	if (pkEventInfo->isUnhappy() && !kPlayer.IsEmpireUnhappy())
		return false;

	if (pkEventInfo->isSuperUnhappy() && !kPlayer.IsEmpireSuperUnhappy())
		return false;

	if (pkEventInfo->hasMetAnotherCiv())
	{
		if (GET_TEAM(getTeam()).getHasMetCivCount(true) <= 0)
			return false;
	}

	if (pkEventInfo->isMaster() && GET_TEAM(getTeam()).GetNumVassals() <= 0)
		return false;

	if (pkEventInfo->isVassal() && !GET_TEAM(getTeam()).IsVassalOfSomeone())
		return false;

	if (pkEventInfo->isRequiresWarMinor())
	{
		bool bHas = false;
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes)iPlayerLoop;

			// Is this a player we have relations with?
			if (GET_PLAYER(eLoopPlayer).isBarbarian())
			{
				continue;
			}
			if (!GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				continue;
			}
			if (eLoopPlayer != getOwner())
			{
				if (GET_TEAM(getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
				{
					bHas = true;
					break;
				}
			}
		}
		if (!bHas)
		{
			return false;
		}
	}

	if (pkEventInfo->getBuildingRequired() != -1)
	{
		BuildingClassTypes eBuilding = (BuildingClassTypes)pkEventInfo->getBuildingRequired();
		if (eBuilding != NO_BUILDINGCLASS)
		{
			if (GetCityBuildings()->GetNumBuildingClass(eBuilding) <= 0)
				return false;
		}
	}
	if (pkEventInfo->getBuildingLimiter() != -1)
	{
		BuildingClassTypes eBuilding = (BuildingClassTypes)pkEventInfo->getBuildingLimiter();
		if (eBuilding != NO_BUILDINGCLASS)
		{
			if (GetCityBuildings()->GetNumBuildingClass(eBuilding) > 0)
				return false;
		}
	}
	if (pkEventInfo->getRequiredImprovement() != -1)
	{
		ImprovementTypes eImprovement = (ImprovementTypes)pkEventInfo->getRequiredImprovement();
		if (eImprovement != NO_IMPROVEMENT)
		{
			if (!HasImprovement(eImprovement))
				return false;
		}
	}
	if (pkEventInfo->getLocalResourceRequired() != -1)
	{
		ResourceTypes eResource = (ResourceTypes)pkEventInfo->getLocalResourceRequired();
		if (eResource != NO_RESOURCE)
		{
			if (!HasResource(eResource))
				return false;
		}
	}
	if (pkEventInfo->hasNearbyFeature() != -1)
	{
		FeatureTypes eFeature = (FeatureTypes)pkEventInfo->hasNearbyFeature();
		if (eFeature != NO_FEATURE)
		{
			if (!IsHasFeatureLocal(eFeature))
				return false;
		}
	}
	if (pkEventInfo->hasNearbyTerrain() != -1)
	{
		TerrainTypes eTerrain = (TerrainTypes)pkEventInfo->hasNearbyTerrain();
		if (eTerrain != NO_TERRAIN)
		{
			if (!HasTerrain(eTerrain))
				return false;
		}
	}
	//Check our minimum yields - this looks at stored values, not yields per turn.
	bool bHas = true;
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes)iI;
		if (eYield == NO_YIELD)
			return false;

		int iNeededYield = pkEventInfo->getYieldMinimum(eYield);
		iNeededYield *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
		iNeededYield /= 100;
		if (pkEventInfo->isEraScaling())
		{
			int iEra = kPlayer.GetCurrentEra();
			if (iEra <= 0)
			{
				iEra = 1;
			}
			iNeededYield *= iEra;
		}

		if (iNeededYield != 0)
		{
			if (eYield == YIELD_FOOD)
			{
				if (iNeededYield > getFood())
				{
					bHas = false;
					break;
				}
			}
			if (eYield == YIELD_PRODUCTION)
			{
				if (iNeededYield > getProduction())
				{
					bHas = false;
					break;
				}
			}
			if (eYield == YIELD_GOLD)
			{
				if (iNeededYield > kPlayer.GetTreasury()->GetGold())
				{
					bHas = false;
					break;
				}
			}
			else if (eYield == YIELD_SCIENCE)
			{
				TechTypes eCurrentTech = kPlayer.GetPlayerTechs()->GetCurrentResearch();
				int iTech = 0;
				if (eCurrentTech != NO_TECH)
				{
					iTech = kPlayer.GetPlayerTechs()->GetResearchProgress(eCurrentTech);
				}
				if (iNeededYield > iTech)
				{
					bHas = false;
					break;
				}
			}
			else if (eYield == YIELD_FAITH)
			{
				if (iNeededYield > kPlayer.GetFaith())
				{
					bHas = false;
					break;
				}
			}
			else if (eYield == YIELD_GOLDEN_AGE_POINTS)
			{
				if (iNeededYield > kPlayer.GetGoldenAgeProgressMeter())
				{
					bHas = false;
					break;
				}
			}
			else if (eYield == YIELD_CULTURE)
			{
				if (iNeededYield > kPlayer.getJONSCulture())
				{
					bHas = false;
					break;
				}
			}
		}
	}
	if (!bHas)
	{
		return false;
	}

	if (pkEventInfo->isInDebt() && kPlayer.GetTreasury()->GetGold() > 0)
		return false;

	if (pkEventInfo->isLosingMoney() && kPlayer.GetTreasury()->CalculateBaseNetGold() > 0)
		return false;

	return true;
}
bool CvCity::IsCityEventChoiceValid(CityEventChoiceTypes eChosenEventChoice, CityEventTypes eParentEvent, bool bIgnoreActive, bool bIgnorePlayer)
{
	if (eChosenEventChoice == NO_EVENT_CHOICE_CITY)
		return false;

	CvModEventCityChoiceInfo* pkEventInfo = GC.getCityEventChoiceInfo(eChosenEventChoice);
	if (pkEventInfo == NULL)
	{
		return false;
	}

	if (!pkEventInfo->isParentEvent(eParentEvent))
		return false;

	CvPlayer& kPlayer = GET_PLAYER(m_eOwner);

	if (!bIgnoreActive && !IsEventActive(eParentEvent))
		return false;

	//Lua Hook
	if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_CityEventChoiceCanTake, getOwner(), GetID(), eChosenEventChoice) == GAMEEVENTRETURN_FALSE) {
		return false;
	}

	if (pkEventInfo->isOneShot() && IsEventChoiceFired(eChosenEventChoice))
		return false;

	//Event Choice already active for this event? Abort!
	if (GetEventChoiceDuration(eChosenEventChoice) > 0)
	{
		if (GC.getLogging())
		{
			CvString playerName;
			FILogFile* pLog = NULL;
			CvString strBaseString;
			CvString strOutBuf;
			CvString strFileName = "EventCityLogging.csv";
			playerName = getName();
			pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			strBaseString += playerName + ", ";
			strOutBuf.Format("Event choice already active for city, skipping: %s, Event: %s. Cooldown: %d", pkEventInfo->GetDescription(), pkEventInfo->GetDescription(), GetEventChoiceDuration(eChosenEventChoice));
			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}
		return false;
	}

	//Let's do our linker checks here.
	for (int iI = 0; iI <= pkEventInfo->GetNumLinkers(); iI++)
	{
		CvCityEventChoiceLinkingInfo* pLinkerInfo = pkEventInfo->GetLinkerInfo(iI);
		if (pLinkerInfo)
		{
			EventTypes eLinkerEvent = (EventTypes)pLinkerInfo->GetLinkingEvent();
			EventChoiceTypes eLinkerEventChoice = (EventChoiceTypes)pLinkerInfo->GetLinkingEventChoice();
			CityEventTypes eLinkerCityEvent = (CityEventTypes)pLinkerInfo->GetCityLinkingEvent();
			CityEventChoiceTypes eLinkerCityEventChoice = (CityEventChoiceTypes)pLinkerInfo->GetCityLinkingEventChoice();

			PlayerTypes ePlayer;
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				ePlayer = (PlayerTypes)iPlayerLoop;
				if (ePlayer == NO_PLAYER)
					continue;

				CvPlayer& kPlayer2 = GET_PLAYER(ePlayer);

				if (!pLinkerInfo->CheckOtherPlayers() && ePlayer != getOwner())
					continue;

				if (eLinkerEvent != NO_EVENT)
				{
					bool bActive = (kPlayer2.GetEventCooldown(eLinkerEvent) > 0 || kPlayer2.IsEventFired(eLinkerEvent));
					if (bActive != pLinkerInfo->CheckForActive())
						return false;
				}

				if (eLinkerEventChoice != NO_EVENT_CHOICE)
				{
					bool bActive = (kPlayer2.GetEventChoiceDuration(eLinkerEventChoice) > 0 || kPlayer2.IsEventChoiceFired(eLinkerEventChoice));
					if (bActive != pLinkerInfo->CheckForActive())
						return false;
				}

				if (eLinkerCityEvent != NO_EVENT_CITY || eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
				{
					int iLoop = 0;
					CvCity* pLoopCity = NULL;
					for (pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))
					{
						if (pLoopCity != this && pLinkerInfo->CheckOnlyActiveCity())
							continue;

						if (eLinkerCityEvent != NO_EVENT_CITY)
						{
							bool bActive = (pLoopCity->GetEventCooldown(eLinkerCityEvent) > 0 || pLoopCity->IsEventFired(eLinkerCityEvent));
							if (bActive != pLinkerInfo->CheckForActive())
								return false;
						}

						if (eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
						{
							bool bActive = (pLoopCity->GetEventChoiceDuration(eLinkerCityEventChoice) > 0 || pLoopCity->IsEventChoiceFired(eLinkerCityEventChoice));
							if (bActive != pLinkerInfo->CheckForActive())
								return false;
						}
					}
				}
			}
		}
	}

	//Let's narrow down all events here!
	if (pkEventInfo->isCapital() && !isCapital())
		return false;

	if (pkEventInfo->isCoastal() && !isCoastal())
		return false;

	if (pkEventInfo->isRiver() && !plot()->isRiver())
		return false;

	if (pkEventInfo->isResistance() && GetResistanceTurns() <= 0)
		return false;

	if (pkEventInfo->getRandomBarbs() > 0)
	{
		if (GC.getGame().isOption(GAMEOPTION_NO_BARBARIANS))
			return false;

		if (GC.getGame().getGameTurn() < GC.getGame().GetBarbarianReleaseTurn())
			return false;
	}

	if (pkEventInfo->isWLTKD() && GetWeLoveTheKingDayCounter() <= 0)
		return false;

	if (pkEventInfo->isPuppet() && !IsPuppet())
		return false;

	if (pkEventInfo->isRazing() && !IsRazing())
		return false;

	if (pkEventInfo->isOccupied() && (!IsOccupied() || IsNoOccupiedUnhappiness()))
		return false;

	if (pkEventInfo->hasAnyReligion() && GetCityReligions()->GetReligiousMajority() <= RELIGION_PANTHEON)
		return false;

	if (pkEventInfo->isRequiresGarrison() && !HasGarrison())
		return false;

	if (pkEventInfo->getMinimumPopulation() > 0 && getPopulation() < pkEventInfo->getMinimumPopulation())
		return false;

	if (!pkEventInfo->isRequiresHolyCity() && pkEventInfo->getRequiredReligion() != -1)
	{
		if (GetCityReligions()->GetReligiousMajority() != (ReligionTypes)pkEventInfo->getRequiredReligion())
			return false;
	}

	if (!bIgnorePlayer)
	{
		if (pkEventInfo->hasStateReligion() && kPlayer.GetReligions()->GetStateReligion(false) == NO_RELIGION)
			return false;

		if (pkEventInfo->getPrereqTech() != -1 && !GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
			return false;

		if (pkEventInfo->getObsoleteTech() != -1 && GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
			return false;

		if (pkEventInfo->getRequiredEra() != -1 && kPlayer.GetCurrentEra() < (EraTypes)pkEventInfo->getRequiredEra())
			return false;

		if (pkEventInfo->getObsoleteEra() != -1 && kPlayer.GetCurrentEra() >= (EraTypes)pkEventInfo->getObsoleteEra())
			return false;

		if (pkEventInfo->getRequiredCiv() != -1 && getCivilizationType() != (CivilizationTypes)pkEventInfo->getRequiredCiv())
			return false;

		if (pkEventInfo->getRequiredPolicy() != -1 && !kPlayer.GetPlayerPolicies()->HasPolicy((PolicyTypes)pkEventInfo->getRequiredPolicy()))
			return false;

		if (pkEventInfo->getRequiredIdeology() != -1 && kPlayer.GetPlayerPolicies()->GetLateGamePolicyTree() != (PolicyBranchTypes)pkEventInfo->getRequiredIdeology())
			return false;

		if (pkEventInfo->hasPlayerReligion() && kPlayer.GetReligions()->GetOwnedReligion() != GetCityReligions()->GetReligiousMajority())
			return false;

		if (pkEventInfo->lacksPlayerReligion() && kPlayer.GetReligions()->GetOwnedReligion() == GetCityReligions()->GetReligiousMajority())
			return false;

		if (pkEventInfo->hasPlayerMajority() && kPlayer.GetReligions()->GetReligionInMostCities() != GetCityReligions()->GetReligiousMajority())
			return false;

		if (pkEventInfo->lacksPlayerMajority() && kPlayer.GetReligions()->GetReligionInMostCities() == GetCityReligions()->GetReligiousMajority())
			return false;

		if (pkEventInfo->getRequiredStateReligion() != -1)
		{
			if (kPlayer.GetReligions()->GetOwnedReligion() != pkEventInfo->getRequiredStateReligion())
				return false;
		}

		if (pkEventInfo->isRequiresIdeology() && kPlayer.GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
			return false;

		if (pkEventInfo->isRequiresWar() && kPlayer.GetMilitaryAI()->GetNumberCivsAtWarWith(false) <= 0)
			return false;


		if (pkEventInfo->isUnhappy() && !kPlayer.IsEmpireUnhappy())
			return false;

		if (pkEventInfo->isSuperUnhappy() && !kPlayer.IsEmpireSuperUnhappy())
			return false;

		if (pkEventInfo->hasMetAnotherCiv())
		{
			if (GET_TEAM(getTeam()).getHasMetCivCount(true) <= 0)
				return false;
		}

		if (pkEventInfo->isMaster() && GET_TEAM(getTeam()).GetNumVassals() <= 0)
			return false;

		if (pkEventInfo->isVassal() && !GET_TEAM(getTeam()).IsVassalOfSomeone())
			return false;

		if (pkEventInfo->isRequiresWarMinor())
		{
			bool bHas = false;
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes)iPlayerLoop;

				// Is this a player we have relations with?
				if (GET_PLAYER(eLoopPlayer).isBarbarian())
				{
					continue;
				}
				if (!GET_PLAYER(eLoopPlayer).isMinorCiv())
				{
					continue;
				}
				if (eLoopPlayer != getOwner())
				{
					if (GET_TEAM(getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
					{
						bHas = true;
						break;
					}
				}
			}
			if (!bHas)
			{
				return false;
			}
		}
	}

	if (pkEventInfo->isRequiresHolyCity())
	{
		if (pkEventInfo->getRequiredReligion() != -1)
		{
			if (!GetCityReligions()->IsHolyCityForReligion((ReligionTypes)pkEventInfo->getRequiredReligion()))
				return false;
		}
		else
		{
			if (!GetCityReligions()->IsHolyCityAnyReligion())
				return false;
		}
	}

	if (pkEventInfo->hasCityConnection() && !IsRouteToCapitalConnected())
		return false;

	if (pkEventInfo->hasTradeConnection() && !HasTradeRouteFromAnyCity() && !HasTradeRouteToAnyCity())
		return false;

	if (pkEventInfo->isNearMountain() && GetNearbyMountains() <= 0)
		return false;

	if (pkEventInfo->isNearNaturalWonder() && !HasAnyNaturalWonder())
		return false;

	if (pkEventInfo->getMaximumPopulation() != 0 && getPopulation() > pkEventInfo->getMaximumPopulation())
		return false;

	if (pkEventInfo->hasPantheon() && GetCityReligions()->GetReligiousMajority() != RELIGION_PANTHEON)
		return false;

	if (pkEventInfo->hasNearbyFeature() != -1)
	{
		FeatureTypes eFeature = (FeatureTypes)pkEventInfo->hasNearbyFeature();
		if (eFeature != NO_FEATURE)
		{
			if (!IsHasFeatureLocal(eFeature))
				return false;
		}
	}
	if (pkEventInfo->hasNearbyTerrain() != -1)
	{
		TerrainTypes eTerrain = (TerrainTypes)pkEventInfo->hasNearbyTerrain();
		if (eTerrain != NO_TERRAIN)
		{
			if (!HasTerrain(eTerrain))
				return false;
		}
	}

	if (pkEventInfo->getBuildingRequired() != -1)
	{
		BuildingClassTypes eBuilding = (BuildingClassTypes)pkEventInfo->getBuildingRequired();
		if (eBuilding != NO_BUILDINGCLASS)
		{
			if (GetCityBuildings()->GetNumBuildingClass(eBuilding) <= 0)
				return false;
		}
	}
	if (pkEventInfo->getBuildingLimiter() != -1)
	{
		BuildingClassTypes eBuilding = (BuildingClassTypes)pkEventInfo->getBuildingLimiter();
		if (eBuilding != NO_BUILDINGCLASS)
		{
			if (GetCityBuildings()->GetNumBuildingClass(eBuilding) > 0)
				return false;
		}
	}
	if (pkEventInfo->getRequiredImprovement() != -1)
	{
		ImprovementTypes eImprovement = (ImprovementTypes)pkEventInfo->getRequiredImprovement();
		if (eImprovement != NO_IMPROVEMENT)
		{
			if (!HasImprovement(eImprovement))
				return false;
		}
	}
	if (pkEventInfo->getLocalResourceRequired() != -1)
	{
		ResourceTypes eResource = (ResourceTypes)pkEventInfo->getLocalResourceRequired();
		if (eResource != NO_RESOURCE)
		{
			if (!HasResource(eResource))
				return false;
		}
	}
	//Check our minimum yields - this looks at stored values, not yields per turn.
	bool bHas = true;
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes)iI;
		if (eYield == NO_YIELD)
			continue;

		int iNeededYield = pkEventInfo->getYieldMinimum(eYield);
		if (pkEventInfo->getPreCheckEventYield(eYield) != 0)
		{
			if (iNeededYield < pkEventInfo->getPreCheckEventYield(eYield))
			{
				iNeededYield = pkEventInfo->getPreCheckEventYield(eYield);
			}
		}
		iNeededYield *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
		iNeededYield /= 100;
		if (pkEventInfo->IsEraScaling())
		{
			int iEra = kPlayer.GetCurrentEra();
			if (iEra <= 0)
			{
				iEra = 1;
			}
			iNeededYield *= iEra;
		}
		if (iNeededYield != 0)
		{
			if (eYield == YIELD_FOOD)
			{
				if (iNeededYield > getFood())
				{
					bHas = false;
					break;
				}
			}
			if (eYield == YIELD_PRODUCTION)
			{
				if (iNeededYield > getProduction())
				{
					bHas = false;
					break;
				}
			}
			if (eYield == YIELD_GOLD)
			{
				if (iNeededYield > kPlayer.GetTreasury()->GetGold())
				{
					bHas = false;
					break;
				}
			}
			else if (eYield == YIELD_SCIENCE)
			{
				TechTypes eCurrentTech = kPlayer.GetPlayerTechs()->GetCurrentResearch();
				int iTech = 0;
				if (eCurrentTech != NO_TECH)
				{
					iTech = kPlayer.GetPlayerTechs()->GetResearchProgress(eCurrentTech);
				}
				if (iNeededYield > iTech)
				{
					bHas = false;
					break;
				}
			}
			else if (eYield == YIELD_FAITH)
			{
				if (iNeededYield > kPlayer.GetFaith())
				{
					bHas = false;
					break;
				}
			}
			else if (eYield == YIELD_GOLDEN_AGE_POINTS)
			{
				if (iNeededYield > kPlayer.GetGoldenAgeProgressMeter())
				{
					bHas = false;
					break;
				}
			}
			else if (eYield == YIELD_CULTURE)
			{
				if (iNeededYield > kPlayer.getJONSCulture())
				{
					bHas = false;
					break;
				}
			}
		}
	}
	if (!bHas)
	{
		return false;
	}

	if (pkEventInfo->isInDebt() && kPlayer.GetTreasury()->GetGold() > 0)
		return false;

	if (pkEventInfo->isLosingMoney() && kPlayer.GetTreasury()->CalculateBaseNetGold() > 0)
		return false;

	return true;
}

bool CvCity::IsCityEventChoiceValidEspionage(CityEventChoiceTypes eEventChoice, CityEventTypes eEvent, int uiSpyIndex, PlayerTypes eSpyOwner, bool bStartMission)
{
	if (eSpyOwner == NO_PLAYER)
		return false;

	CvEspionageSpy* pSpy = GET_PLAYER(eSpyOwner).GetEspionage()->GetSpyByID(uiSpyIndex);
	if (!pSpy)
		return false;

	CvModEventCityChoiceInfo* pkEventInfo = GC.getCityEventChoiceInfo(eEventChoice);
	if (pkEventInfo == NULL)
		return false;

	if (eEvent == NO_EVENT_CITY)
	{
		for (int iLoop = 0; iLoop < GC.getNumCityEventInfos(); iLoop++)
		{
			CityEventTypes eParentEvent = (CityEventTypes)iLoop;
			if (eParentEvent != NO_EVENT_CITY)
			{
				if (pkEventInfo->isParentEvent(eParentEvent))
				{
					eEvent = eParentEvent;
					break;
				}
			}
		}
	}

	if (eEvent == NO_EVENT_CITY)
		return false;

	// The mission to establish surveillance can always be chosen
	if (pkEventInfo->isSurveillance())
		return true;

	if (pkEventInfo->GetSpyLevelRequired() > pSpy->GetSpyRank(eSpyOwner))
		return false;

	if (pkEventInfo->isRequiresCounterSpy() && !GetCityEspionage()->HasCounterSpy())
		return false;

	//check to see if another spy is already doing this here. We can only have one spy operation of the same type going on in a city at one time.
	if (!pkEventInfo->IsIgnoreLocalSpies())
	{
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes)iPlayerLoop;
			if (eLoopPlayer == NO_PLAYER)
				continue;

			CvPlayer& kPlayer = GET_PLAYER(eLoopPlayer);

			if (!kPlayer.isAlive())
				continue;
			if (eLoopPlayer == getOwner())
				continue;
			if (eLoopPlayer == eSpyOwner)
				continue;
			if (kPlayer.isBarbarian())
				continue;
			if (kPlayer.isMinorCiv())
				continue;
			if (!kPlayer.GetEspionage())
				continue;
			if (kPlayer.GetEspionage()->GetNumSpies() <= 0)
				continue;

			int iSpyID = kPlayer.GetEspionage()->GetSpyIndexInCity(this);
			if (iSpyID == -1)
				continue;

			CvEspionageSpy* pSpy = kPlayer.GetEspionage()->GetSpyByID(iSpyID);
			if (pSpy && pSpy->m_eSpyFocus == eEventChoice)
				return false;
		}
	}

	if (bStartMission)
	{
		// these missions can be started only if a tech/GW is available to steal, but they are not canceled if that changes during the mission
		if (pkEventInfo->getStealTech() > 0)
		{
			GET_PLAYER(eSpyOwner).GetEspionage()->BuildStealableTechList(getOwner());
			int iNumTechsWeDontHave = GET_PLAYER(eSpyOwner).GetEspionage()->GetNumTechsToSteal(getOwner());
			if (iNumTechsWeDontHave < pkEventInfo->getStealTech())
				return false;
		}

		if (pkEventInfo->getForgeGW() > 0)
		{
			int iNumGWInCity = GetCityCulture()->GetNumGreatWorks();
			if (iNumGWInCity < pkEventInfo->getForgeGW())
				return false;
		}
	}

	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes)iI;
		if (eYield == NO_YIELD)
			continue;

		int iSiphonYield = pkEventInfo->getYieldSiphon(eYield);
		if (iSiphonYield <= 0)
			continue;

		int iCityYield = getYieldRate(eYield, false);
		iCityYield *= iSiphonYield;
		iCityYield /= 100;

		if (iCityYield <= 0)
		{
			return false;
		}
	}

	if (!IsCityEventChoiceValid(eEventChoice, eEvent, true, true))
		return false;

	if (pkEventInfo->hasStateReligion() && GET_PLAYER(eSpyOwner).GetReligions()->GetStateReligion(false) == NO_RELIGION)
		return false;

	if (pkEventInfo->getPrereqTech() != -1 && !GET_TEAM(GET_PLAYER(eSpyOwner).getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
		return false;

	if (pkEventInfo->getObsoleteTech() != -1 && GET_TEAM(GET_PLAYER(eSpyOwner).getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
		return false;

	if (pkEventInfo->getRequiredEra() != -1 && GET_PLAYER(eSpyOwner).GetCurrentEra() < (EraTypes)pkEventInfo->getRequiredEra())
		return false;

	if (pkEventInfo->getObsoleteEra() != -1 && GET_PLAYER(eSpyOwner).GetCurrentEra() >= (EraTypes)pkEventInfo->getObsoleteEra())
		return false;

	if (pkEventInfo->getRequiredCiv() != -1 && GET_PLAYER(eSpyOwner).getCivilizationType() != (CivilizationTypes)pkEventInfo->getRequiredCiv())
		return false;

	if (pkEventInfo->getRequiredPolicy() != -1 && !GET_PLAYER(eSpyOwner).GetPlayerPolicies()->HasPolicy((PolicyTypes)pkEventInfo->getRequiredPolicy()))
		return false;

	if (pkEventInfo->getRequiredIdeology() != -1 && GET_PLAYER(eSpyOwner).GetPlayerPolicies()->GetLateGamePolicyTree() != (PolicyBranchTypes)pkEventInfo->getRequiredIdeology())
		return false;

	if (pkEventInfo->hasPlayerReligion() && GET_PLAYER(eSpyOwner).GetReligions()->GetOwnedReligion() != GetCityReligions()->GetReligiousMajority())
		return false;

	if (pkEventInfo->lacksPlayerReligion() && GET_PLAYER(eSpyOwner).GetReligions()->GetOwnedReligion() == GetCityReligions()->GetReligiousMajority())
		return false;

	if (pkEventInfo->hasPlayerMajority() && GET_PLAYER(eSpyOwner).GetReligions()->GetReligionInMostCities() != GetCityReligions()->GetReligiousMajority())
		return false;

	if (pkEventInfo->lacksPlayerMajority() && GET_PLAYER(eSpyOwner).GetReligions()->GetReligionInMostCities() == GetCityReligions()->GetReligiousMajority())
		return false;

	if (pkEventInfo->getRequiredStateReligion() != -1)
	{
		if (GET_PLAYER(eSpyOwner).GetReligions()->GetOwnedReligion() != pkEventInfo->getRequiredStateReligion())
			return false;
	}

	if (pkEventInfo->isRequiresIdeology() && GET_PLAYER(eSpyOwner).GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
		return false;

	if (pkEventInfo->isRequiresWar() && GET_PLAYER(eSpyOwner).GetMilitaryAI()->GetNumberCivsAtWarWith(false) <= 0)
		return false;


	if (pkEventInfo->isUnhappy() && !GET_PLAYER(eSpyOwner).IsEmpireUnhappy())
		return false;

	if (pkEventInfo->isSuperUnhappy() && !GET_PLAYER(eSpyOwner).IsEmpireSuperUnhappy())
		return false;

	if (pkEventInfo->isEnemyUnhappy() && !GET_PLAYER(getOwner()).IsEmpireUnhappy())
		return false;

	if (pkEventInfo->isEnemySuperUnhappy() && !GET_PLAYER(getOwner()).IsEmpireSuperUnhappy())
		return false;

	if (pkEventInfo->hasMetAnotherCiv())
	{
		if (GET_TEAM(GET_PLAYER(eSpyOwner).getTeam()).getHasMetCivCount(true) <= 0)
			return false;
	}

	if (pkEventInfo->isMaster() && GET_TEAM(GET_PLAYER(eSpyOwner).getTeam()).GetNumVassals() <= 0)
		return false;

	if (pkEventInfo->isVassal() && !GET_TEAM(GET_PLAYER(eSpyOwner).getTeam()).IsVassalOfSomeone())
		return false;

	if (pkEventInfo->isRequiresWarMinor())
	{
		bool bHas = false;
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes)iPlayerLoop;

			// Is this a player we have relations with?
			if (GET_PLAYER(eLoopPlayer).isBarbarian())
			{
				continue;
			}
			if (!GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				continue;
			}
			if (eLoopPlayer != getOwner())
			{
				if (GET_TEAM(GET_PLAYER(eSpyOwner).getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
				{
					bHas = true;
					break;
				}
			}
		}
		if (!bHas)
		{
			return false;
		}
	}

	return true;
}

bool CvCity::IsCityEventChoiceValidEspionageTest(CityEventChoiceTypes eEventChoice, CityEventTypes eEvent, int iAssumedLevel, PlayerTypes eSpyOwner)
{
	if (eSpyOwner == NO_PLAYER)
		return false;

	CvModEventCityChoiceInfo* pkEventInfo = GC.getCityEventChoiceInfo(eEventChoice);
	if (pkEventInfo == NULL)
		return false;

	if (eEvent == NO_EVENT_CITY)
	{
		for (int iLoop = 0; iLoop < GC.getNumCityEventInfos(); iLoop++)
		{
			CityEventTypes eParentEvent = (CityEventTypes)iLoop;
			if (eParentEvent != NO_EVENT_CITY)
			{
				if (pkEventInfo->isParentEvent(eParentEvent))
				{
					eEvent = eParentEvent;
					break;
				}
			}
		}
	}

	if (eEvent == NO_EVENT_CITY)
		return false;

	if (pkEventInfo->GetSpyLevelRequired() > iAssumedLevel)
		return false;

	if (pkEventInfo->isRequiresCounterSpy() && !GetCityEspionage()->HasCounterSpy())
		return false;

	//check to see if another spy is already doing this here. We can only have one spy operation of the same type going on in a city at one time.
	if (!pkEventInfo->IsIgnoreLocalSpies())
	{
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes)iPlayerLoop;
			if (eLoopPlayer == NO_PLAYER)
				continue;

			CvPlayer& kPlayer = GET_PLAYER(eLoopPlayer);

			if (!kPlayer.isAlive())
				continue;
			if (eLoopPlayer == getOwner())
				continue;
			if (eLoopPlayer == eSpyOwner)
				continue;
			if (kPlayer.isBarbarian())
				continue;
			if (kPlayer.isMinorCiv())
				continue;
			if (!kPlayer.GetEspionage())
				continue;
			if (kPlayer.GetEspionage()->GetNumSpies() <= 0)
				continue;

			int iSpyID = kPlayer.GetEspionage()->GetSpyIndexInCity(this);
			if (iSpyID == -1)
				continue;

			CvEspionageSpy* pSpy = kPlayer.GetEspionage()->GetSpyByID(iSpyID);
			if (pSpy && pSpy->m_eSpyFocus == eEventChoice)
				return false;
		}
	}

	if (pkEventInfo->getStealTech() > 0)
	{
		GET_PLAYER(eSpyOwner).GetEspionage()->BuildStealableTechList(getOwner());
		int iNumTechsWeDontHave = GET_PLAYER(eSpyOwner).GetEspionage()->GetNumTechsToSteal(getOwner());
		if (iNumTechsWeDontHave < pkEventInfo->getStealTech())
			return false;
	}

	if (pkEventInfo->getForgeGW() > 0)
	{
		int iNumGWInCity = GetCityCulture()->GetNumGreatWorks();
		if (iNumGWInCity < pkEventInfo->getForgeGW())
			return false;
	}

	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes)iI;
		if (eYield == NO_YIELD)
			continue;

		int iSiphonYield = pkEventInfo->getYieldSiphon(eYield);
		if (iSiphonYield <= 0)
			continue;

		int iCityYield = getYieldRate(eYield, false);
		iCityYield *= iSiphonYield;
		iCityYield /= 100;

		if (iCityYield <= 0)
		{
			return false;
		}
	}

	if (!IsCityEventChoiceValid(eEventChoice, eEvent, true, true))
		return false;

	if (pkEventInfo->hasStateReligion() && GET_PLAYER(eSpyOwner).GetReligions()->GetStateReligion(false) == NO_RELIGION)
		return false;

	if (pkEventInfo->getPrereqTech() != -1 && !GET_TEAM(GET_PLAYER(eSpyOwner).getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
		return false;

	if (pkEventInfo->getObsoleteTech() != -1 && GET_TEAM(GET_PLAYER(eSpyOwner).getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
		return false;

	if (pkEventInfo->getRequiredEra() != -1 && GET_PLAYER(eSpyOwner).GetCurrentEra() < (EraTypes)pkEventInfo->getRequiredEra())
		return false;

	if (pkEventInfo->getObsoleteEra() != -1 && GET_PLAYER(eSpyOwner).GetCurrentEra() >= (EraTypes)pkEventInfo->getObsoleteEra())
		return false;

	if (pkEventInfo->getRequiredCiv() != -1 && GET_PLAYER(eSpyOwner).getCivilizationType() != (CivilizationTypes)pkEventInfo->getRequiredCiv())
		return false;

	if (pkEventInfo->getRequiredPolicy() != -1 && !GET_PLAYER(eSpyOwner).GetPlayerPolicies()->HasPolicy((PolicyTypes)pkEventInfo->getRequiredPolicy()))
		return false;

	if (pkEventInfo->getRequiredIdeology() != -1 && GET_PLAYER(eSpyOwner).GetPlayerPolicies()->GetLateGamePolicyTree() != (PolicyBranchTypes)pkEventInfo->getRequiredIdeology())
		return false;

	if (pkEventInfo->hasPlayerReligion() && GET_PLAYER(eSpyOwner).GetReligions()->GetOwnedReligion() != GetCityReligions()->GetReligiousMajority())
		return false;

	if (pkEventInfo->lacksPlayerReligion() && GET_PLAYER(eSpyOwner).GetReligions()->GetOwnedReligion() == GetCityReligions()->GetReligiousMajority())
		return false;

	if (pkEventInfo->hasPlayerMajority() && GET_PLAYER(eSpyOwner).GetReligions()->GetReligionInMostCities() != GetCityReligions()->GetReligiousMajority())
		return false;

	if (pkEventInfo->lacksPlayerMajority() && GET_PLAYER(eSpyOwner).GetReligions()->GetReligionInMostCities() == GetCityReligions()->GetReligiousMajority())
		return false;

	if (pkEventInfo->getRequiredStateReligion() != -1)
	{
		if (GET_PLAYER(eSpyOwner).GetReligions()->GetOwnedReligion() != pkEventInfo->getRequiredStateReligion())
			return false;
	}

	if (pkEventInfo->isRequiresIdeology() && GET_PLAYER(eSpyOwner).GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
		return false;

	if (pkEventInfo->isRequiresWar() && GET_PLAYER(eSpyOwner).GetMilitaryAI()->GetNumberCivsAtWarWith(false) <= 0)
		return false;


	if (pkEventInfo->isUnhappy() && !GET_PLAYER(eSpyOwner).IsEmpireUnhappy())
		return false;

	if (pkEventInfo->isSuperUnhappy() && !GET_PLAYER(eSpyOwner).IsEmpireSuperUnhappy())
		return false;

	if (pkEventInfo->hasMetAnotherCiv())
	{
		if (GET_TEAM(GET_PLAYER(eSpyOwner).getTeam()).getHasMetCivCount(true) <= 0)
			return false;
	}

	if (pkEventInfo->isMaster() && GET_TEAM(GET_PLAYER(eSpyOwner).getTeam()).GetNumVassals() <= 0)
		return false;

	if (pkEventInfo->isVassal() && !GET_TEAM(GET_PLAYER(eSpyOwner).getTeam()).IsVassalOfSomeone())
		return false;

	if (pkEventInfo->isRequiresWarMinor())
	{
		bool bHas = false;
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes)iPlayerLoop;

			// Is this a player we have relations with?
			if (GET_PLAYER(eLoopPlayer).isBarbarian())
			{
				continue;
			}
			if (!GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				continue;
			}
			if (eLoopPlayer != getOwner())
			{
				if (GET_TEAM(GET_PLAYER(eSpyOwner).getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
				{
					bHas = true;
					break;
				}
			}
		}
		if (!bHas)
		{
			return false;
		}
	}

	return true;
}
void CvCity::DoCancelEventChoice(CityEventChoiceTypes eChosenEventChoice)
{
	if (eChosenEventChoice == NO_EVENT_CHOICE_CITY)
		return;

	CvModEventCityChoiceInfo* pkEventChoiceInfo = GC.getCityEventChoiceInfo(eChosenEventChoice);
	if (pkEventChoiceInfo != NULL)
	{
		//Lua Hook
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityEventChoiceEnded, getOwner(), GetID(), eChosenEventChoice);
		bool bChanged = false;
		if (GC.getLogging())
		{
			CvString playerName;
			FILogFile* pLog = NULL;
			CvString strBaseString;
			CvString strOutBuf;
			CvString strFileName = "EventCityLogging.csv";
			playerName = getName();
			pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
			strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
			strBaseString += playerName + ", ";
			strOutBuf.Format("Event choice ended for city: %s", pkEventChoiceInfo->GetDescription());
			strBaseString += strOutBuf;
			pLog->Msg(strBaseString);
		}
		//Let's make sure this is at zero.
		ChangeEventChoiceDuration(eChosenEventChoice, -GetEventChoiceDuration(eChosenEventChoice));

		//Let's only reverse if it expires, and it was active.
		if (IsEventChoiceActive(eChosenEventChoice) && (pkEventChoiceInfo->Expires() || pkEventChoiceInfo->isExpiresOnCounterSpyExit()))
		{
			if (pkEventChoiceInfo->getEventBuilding() != -1)
			{
				BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventChoiceInfo->getEventBuilding();
				if (eBuildingClass != NO_BUILDINGCLASS)
				{
					const CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);

					if (pkBuildingClassInfo)
					{
						CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());

						if (pCivilizationInfo != NULL)
						{
							BuildingTypes eBuildingType = NO_BUILDING;
							if (MOD_BUILDINGS_THOROUGH_PREREQUISITES)
							{
								eBuildingType = GetCityBuildings()->GetBuildingTypeFromClass(eBuildingClass);
							}
							else
							{
								eBuildingType = (BuildingTypes)pCivilizationInfo->getCivilizationBuildings(eBuildingClass);
							}

							if (eBuildingType != NO_BUILDING)
							{
								GetCityBuildings()->SetNumRealBuilding(eBuildingType, 0);
								bChanged = true;
							}
						}
					}
				}
			}

			if (pkEventChoiceInfo->getGrowthMod() != 0)
			{
				ChangeGrowthFromEvent(pkEventChoiceInfo->getGrowthMod() * -1);
			}

			if (pkEventChoiceInfo->getEventPromotion() != -1)
			{
				PromotionTypes ePromotion = (PromotionTypes)pkEventChoiceInfo->getEventPromotion();
				if (ePromotion != -1)
				{
					changeFreePromotionCount(ePromotion, -1);
				}
			}
			for (int iI = 0; iI < GC.getNumResourceInfos(); iI++)
			{
				ResourceTypes eResource = (ResourceTypes)iI;
				if (eResource != NO_RESOURCE)
				{
					int iBonus = pkEventChoiceInfo->getEventResourceChange(eResource);
					iBonus *= -1;
					if (iBonus != 0)
					{
						GET_PLAYER(getOwner()).changeNumResourceTotal(eResource, iBonus * -1);
					}
				}
			}
			for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				YieldTypes eYield = (YieldTypes)iI;
				if (eYield == NO_YIELD)
					continue;

				int iYieldChange = pkEventChoiceInfo->getCityYield(eYield);
				if (iYieldChange != 0)
				{
					ChangeEventCityYield(eYield, iYieldChange * -1);
				}

				int iYieldMod = pkEventChoiceInfo->getCityYieldModifier(eYield);
				if (iYieldMod != 0)
				{
					ChangeEventCityYieldModifier(eYield, iYieldMod * -1);
				}

				
				// Building modifiers
				for (int iJ = 0; iJ < GC.getNumBuildingClassInfos(); iJ++)
				{
					BuildingClassTypes eBuildingClass = (BuildingClassTypes)iJ;

					CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
					if (!pkBuildingClassInfo)
					{
						continue;
					}
					if (pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield) != 0)
					{
						BuildingTypes eBuilding = NO_BUILDING;
						if (MOD_BUILDINGS_THOROUGH_PREREQUISITES)
						{
							eBuilding = GetCityBuildings()->GetBuildingTypeFromClass(eBuildingClass);
						}
						else
						{
							eBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(eBuildingClass);
						}

						if (eBuilding != NO_BUILDING)
						{
							CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
							if (pkBuilding)
							{
								ChangeEventBuildingClassYield(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield) * -1);
								if (MOD_BUILDINGS_THOROUGH_PREREQUISITES || GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
								{
									ChangeBaseYieldRateFromBuildings(eYield, pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield) * -1);
									bChanged = true;
								}
							}
						}
					}
					if (pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield) != 0)
					{
						BuildingTypes eBuilding = NO_BUILDING;
						if (MOD_BUILDINGS_THOROUGH_PREREQUISITES)
						{
							eBuilding = GetCityBuildings()->GetBuildingTypeFromClass(eBuildingClass);
						}
						else
						{
							eBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(eBuildingClass);
						}

						if (eBuilding != NO_BUILDING)
						{
							CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
							if (pkBuilding)
							{
								ChangeEventBuildingClassYieldModifier(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield) * -1);
								bChanged = true;
								if (MOD_BUILDINGS_THOROUGH_PREREQUISITES || GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
								{
									changeYieldRateModifier(eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield) * -1);
								}
							}
						}
					}
				}
				for (int iJ = 0; iJ < GC.getNumImprovementInfos(); iJ++)
				{
					ImprovementTypes eImprovement = (ImprovementTypes)iJ;
					if (eImprovement != NO_IMPROVEMENT && pkEventChoiceInfo->getImprovementYield(eImprovement, eYield) != 0)
					{
						ChangeEventImprovementYield(eImprovement, eYield, pkEventChoiceInfo->getImprovementYield(eImprovement, eYield) * -1);
						bChanged = true;
					}
				}
				for (int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
				{
					FeatureTypes eFeature = (FeatureTypes)iJ;
					if (eFeature != NO_FEATURE && pkEventChoiceInfo->getFeatureYield(eFeature, eYield) != 0)
					{
						ChangeEventFeatureYield(eFeature, eYield, pkEventChoiceInfo->getFeatureYield(eFeature, eYield) * -1);
						bChanged = true;
					}
				}
				for (int iJ = 0; iJ < GC.getNumTerrainInfos(); iJ++)
				{
					TerrainTypes eTerrain = (TerrainTypes)iJ;
					if (eTerrain != NO_TERRAIN && pkEventChoiceInfo->getTerrainYield(eTerrain, eYield) != 0)
					{
						ChangeEventTerrainYield(eTerrain, eYield, pkEventChoiceInfo->getTerrainYield(eTerrain, eYield) * -1);
						bChanged = true;
					}
				}
				for (int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
				{
					ResourceTypes eResource = (ResourceTypes)iJ;
					if (eResource != NO_RESOURCE && pkEventChoiceInfo->getResourceYield(eResource, eYield) != 0)
					{
						ChangeEventResourceYield(eResource, eYield, pkEventChoiceInfo->getResourceYield(eResource, eYield) * -1);
						bChanged = true;
					}
				}
				for (int iJ = 0; iJ < GC.getNumSpecialistInfos(); iJ++)
				{
					const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iJ);
					CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
					if (pkSpecialistInfo)
					{
						ChangeEventSpecialistYield(eSpecialist, eYield, pkEventChoiceInfo->getCitySpecialistYieldChange(eSpecialist, eYield) * -1);
						bChanged = true;
					}
				}
			}
			if (pkEventChoiceInfo->getCityHappiness() != 0)
			{
				ChangeEventHappiness(pkEventChoiceInfo->getCityHappiness() * -1);
				bChanged = true;
			}
			if (pkEventChoiceInfo->getBasicNeedsMedianModifier() != 0)
			{
				ChangeBasicNeedsMedianModifier(pkEventChoiceInfo->getBasicNeedsMedianModifier() * -1);
				bChanged = true;
			}
			if (pkEventChoiceInfo->getGoldMedianModifier() != 0)
			{
				ChangeGoldMedianModifier(pkEventChoiceInfo->getGoldMedianModifier() * -1);
				bChanged = true;
			}
			if (pkEventChoiceInfo->getScienceMedianModifier() != 0)
			{
				ChangeScienceMedianModifier(pkEventChoiceInfo->getScienceMedianModifier() * -1);
				bChanged = true;
			}
			if (pkEventChoiceInfo->getCultureMedianModifier() != 0)
			{
				ChangeCultureMedianModifier(pkEventChoiceInfo->getCultureMedianModifier() * -1);
				bChanged = true;
			}
			if (pkEventChoiceInfo->getReligiousUnrestModifier() != 0)
			{
				ChangeReligiousUnrestModifier(pkEventChoiceInfo->getReligiousUnrestModifier() * -1);
				bChanged = true;
			}
			if (bChanged)
			{
				CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
				if (pNotifications && GC.getGame().getActivePlayer() == getOwner())
				{
					Localization::String strMessage;
					Localization::String strSummary;
					strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_EVENT_HAS_ENDED_CITY");
					strMessage << GetScaledHelpText(eChosenEventChoice, false, -1, NO_PLAYER);
					strMessage << getNameKey();
					strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_EVENT_HAS_ENDED_CITY_T");
					strSummary << getNameKey();

					pNotifications->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), getX(), getY(), GetID(), getOwner());
				}
				for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
				{
					YieldTypes eYield = (YieldTypes)iI;
					if (eYield == NO_YIELD)
						continue;

					UpdateSpecialReligionYields(eYield);
					UpdateCityYields(eYield);
				}
				UpdateReligion(GetCityReligions()->GetReligiousMajority());

				GET_PLAYER(getOwner()).CalculateNetHappiness();
				updateNetHappiness();
			}
		}
		if (!pkEventChoiceInfo->isOneShot())
		{
			//Set it false here so we know the event choice is over now.
			SetEventChoiceActive(eChosenEventChoice, false);
		}
	}
}
CvString CvCity::GetScaledHelpText(CityEventChoiceTypes eEventChoice, bool bYieldsOnly, int iSpyIndex, PlayerTypes eSpyOwner, bool bSpyMissionEnd)
{
	CvString CoreYieldTip = "";
	CvModEventCityChoiceInfo* pkEventChoiceInfo = GC.getCityEventChoiceInfo(eEventChoice);
	if (pkEventChoiceInfo == NULL)
	{
		return "";
	}
	Localization::String localizedCoreText;
	if (bYieldsOnly)
	{
		localizedCoreText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_CITY_HEADER");
	}
	else
	{
		localizedCoreText = Localization::Lookup(pkEventChoiceInfo->GetHelp());
	}

	int iEra = GET_PLAYER(getOwner()).GetCurrentEra();
	if (iEra <= 0)
	{
		iEra = 1;
	}

	CvString spyTip = "";
	CvString playerEventTip = "";
	CvString yieldCostTip = "";
	CvString yieldInstantTip = "";
	CvString yieldCityTip = "";
	CvString yieldSpecialistTip = "";
	CvString turnsTip = "";
	CvString durationTip = "";

	if (pkEventChoiceInfo->GetTriggerPlayerEventChoice() != NO_EVENT_CHOICE)
	{
		CvModEventChoiceInfo* pPlayerEvent = GC.getEventChoiceInfo(pkEventChoiceInfo->GetTriggerPlayerEventChoice());
		if (pPlayerEvent)
		{
			if (eSpyOwner != NO_PLAYER && iSpyIndex != -1)
			{
				playerEventTip += "[NEWLINE]";
				playerEventTip += GetLocalizedText("TXT_KEY_ESPIONAGE_EVENT_CHOICE_BENEFIT");
			}
			if (eSpyOwner != NO_PLAYER)
				playerEventTip += GET_PLAYER(eSpyOwner).GetScaledHelpText(pkEventChoiceInfo->GetTriggerPlayerEventChoice(), false);
			else
				playerEventTip += GET_PLAYER(getOwner()).GetScaledHelpText(pkEventChoiceInfo->GetTriggerPlayerEventChoice(), false);
		}
	}

	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eIndex = (YieldTypes)iI;
		if (eIndex == NO_YIELD)
		{
			continue;
		}
		CvYieldInfo* pYield = GC.getYieldInfo(eIndex);
		if (pYield)
		{
			int iPreValue = pkEventChoiceInfo->getPreCheckEventYield(eIndex);
			if (pkEventChoiceInfo->IsEraScaling())
			{
				iPreValue *= iEra;
			}
			iPreValue *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
			iPreValue /= 100;
			if (iPreValue != 0)
			{
				iPreValue *= -1;
				if (yieldCostTip != "")
				{
					yieldCostTip += ", ";
				}
				Localization::String localizedCostText;
				if (bYieldsOnly)
				{
					localizedCostText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_SPENT");
				}
				else
				{
					localizedCostText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED");
				}
				localizedCostText << pYield->GetDescription();
				localizedCostText << pYield->getIconString();
				localizedCostText << iPreValue;

				const char* const localized = localizedCostText.toUTF8();
				if (localized)
				{
					yieldCostTip += localized;
				}
			}
			int iYieldValue = pkEventChoiceInfo->getEventYield(eIndex);
			if (iYieldValue != 0)
			{

				if (pkEventChoiceInfo->IsEraScaling())
				{
					iYieldValue *= iEra;
				}
				iYieldValue *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
				iYieldValue /= 100;
				if (iYieldValue != 0)
				{
					if (yieldInstantTip != "")
					{
						yieldInstantTip += ", ";
					}
					Localization::String localizedEventText;
					if (bYieldsOnly)
					{
						localizedEventText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_INSTANT");
					}
					else
					{
						localizedEventText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED");
					}
					localizedEventText << pYield->GetDescription();
					localizedEventText << pYield->getIconString();
					localizedEventText << iYieldValue;

					const char* const localized = localizedEventText.toUTF8();
					if (localized)
					{
						yieldInstantTip += localized;
					}
				}
			}

			int iCityValue = pkEventChoiceInfo->getCityYield(eIndex);
			if (iCityValue != 0)
			{
				if (yieldCityTip != "")
				{
					yieldCityTip += ", ";
				}

				Localization::String localizedCityText;
				if (bYieldsOnly)
				{
					localizedCityText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_CITY");
				}
				else
				{
					localizedCityText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED");
				}
				localizedCityText << pYield->GetDescription();
				localizedCityText << pYield->getIconString();
				localizedCityText << iCityValue;

				const char* const localized = localizedCityText.toUTF8();
				if (localized)
				{
					yieldCityTip += localized;
				}
			}
		}
	}
	for (int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
	{
		const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iSpecialistLoop);
		CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
		if (pkSpecialistInfo)
		{
			int iValue = pkEventChoiceInfo->getEventGPChange(eSpecialist);
			if (pkEventChoiceInfo->IsEraScaling())
			{
				iValue *= iEra;
				iValue *= GC.getGame().getGameSpeedInfo().getGreatPeoplePercent();
				iValue /= 100;
			}
			if (iValue != 0)
			{
				if (yieldSpecialistTip != "")
				{
					yieldSpecialistTip += ", ";
				}
				Localization::String localizedSpecialistText;
				if (bYieldsOnly)
				{
					localizedSpecialistText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_GPP");
				}
				else
				{
					localizedSpecialistText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_SPECIALIST");
				}

				CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo((UnitClassTypes)pkSpecialistInfo->getGreatPeopleUnitClass());
				if (pkUnitClassInfo)
				{
					localizedSpecialistText << pkUnitClassInfo->GetDescription();
					localizedSpecialistText << iValue;
				}

				const char* const localized = localizedSpecialistText.toUTF8();
				if (localized)
				{
					yieldSpecialistTip += localized;
				}
			}
		}
	}

	//Duration
	int iDuration = pkEventChoiceInfo->getEventDuration();
	if (pkEventChoiceInfo->getSpyVisionDuration() > 0)
	{
		iDuration = pkEventChoiceInfo->getSpyVisionDuration();
		iDuration *= GC.getGame().getGameSpeedInfo().getSpyRatePercent();
		iDuration /= 100;
	}
	else if (pkEventChoiceInfo->getEspionageMissionDuration() > 0)
	{
		iDuration = pkEventChoiceInfo->getEspionageMissionDuration();
		iDuration *= GC.getGame().getGameSpeedInfo().getSpyRatePercent();
		iDuration /= 100;
	}
	else
	{
		iDuration *= GC.getGame().getGameSpeedInfo().getTrainPercent();
		iDuration /= 100;
	}

	if (iDuration > 0)
	{
		Localization::String localizedDurationText;
		if (bYieldsOnly)
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_TURNS");
		}
		else
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_YIELD_DURATION");
		}
		localizedDurationText << iDuration;
		const char* const localized = localizedDurationText.toUTF8();
		if (localized)
		{
			turnsTip += localized;
		}
	}
	if (eSpyOwner != NO_PLAYER && iSpyIndex != -1)
	{
		CvEspionageSpy* pSpy = (GET_PLAYER(eSpyOwner).GetEspionage()->GetSpyByID(iSpyIndex));

		if (!bSpyMissionEnd)
		{
			int iKillChance = GET_PLAYER(eSpyOwner).GetEspionage()->GetDefenseChance(ESPIONAGE_TYPE_KILL, this, eEventChoice, true);
			int iIdentifyChance = GET_PLAYER(eSpyOwner).GetEspionage()->GetDefenseChance(ESPIONAGE_TYPE_IDENTIFY, this, eEventChoice, true);

			Localization::String localizedKillChance;
			localizedKillChance = Localization::Lookup("TXT_KEY_EVENT_SPY_KILL_CHANCE");
			localizedKillChance << iIdentifyChance;
			localizedKillChance << iKillChance;

			const char* const localized = localizedKillChance.toUTF8();
			if (localized)
			{
				spyTip += "[NEWLINE]";
				spyTip += localized;
			}

			int iProgress = GetCityEspionage()->m_aiAmount[eSpyOwner];

			YieldTypes eSiphonYield = NO_YIELD;
			for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				if (pkEventChoiceInfo->getYieldSiphon((YieldTypes)iI) > 0)
				{
					eSiphonYield = (YieldTypes)iI;
					break;
				}
			}

			if (eSiphonYield != NO_YIELD)
			{
				Localization::String localizedSiphonText;
				int iSiphonEstimated = 0;
				if (iProgress == 0)
				{
					iSiphonEstimated = getYieldRate(eSiphonYield, false) * pkEventChoiceInfo->getYieldSiphon(eSiphonYield);
					iSiphonEstimated /= 100;
				}
				else
				{
					iSiphonEstimated = pSpy->m_iYieldSiphon / iProgress;
				}
				CvYieldInfo* pYield = GC.getYieldInfo(eSiphonYield);
				if (pYield)
				{
					Localization::String localizedYieldText;
					localizedYieldText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED");
					localizedYieldText << pYield->GetDescription();
					localizedYieldText << pYield->getIconString();
					localizedYieldText << iSiphonEstimated;
					CvString tempYieldStr = localizedYieldText.toUTF8();
					localizedSiphonText = Localization::Lookup("TXT_KEY_ESPIONAGE_EVENT_YIELD_SIPHON_ESTIMATED");
					localizedSiphonText << tempYieldStr;
					localizedSiphonText << turnsTip;
					CvString tempStr = localizedSiphonText.toUTF8();

					yieldCityTip += "[NEWLINE][NEWLINE]";
					yieldCityTip += tempStr;
				}
			}

			durationTip += "[NEWLINE][NEWLINE]";
			durationTip += GetMissionDurationText(eSpyOwner, eEventChoice, iSpyIndex, iProgress);
		}
		else
		{
			if (pSpy->GetSiphonHistory() != "")
			{
				Localization::String localizedSiphonText;
				localizedSiphonText = Localization::Lookup("TXT_KEY_ESPIONAGE_EVENT_YIELD_SIPHON_PAST");
				localizedSiphonText << pSpy->GetSiphonHistory();
				localizedSiphonText << turnsTip;
				yieldCityTip += "[NEWLINE][NEWLINE]";
				yieldCityTip += localizedSiphonText.toUTF8();
			}
		}
	}

	localizedCoreText << yieldCostTip;	
	localizedCoreText << yieldInstantTip;	
	localizedCoreText << yieldCityTip;	
	localizedCoreText << yieldSpecialistTip;
	localizedCoreText << turnsTip;
	localizedCoreText << spyTip;
	localizedCoreText << playerEventTip;
	localizedCoreText << durationTip;

	const char* const finallocalized = localizedCoreText.toUTF8();
	if (finallocalized)
	{
		CoreYieldTip = finallocalized;
	}
	return CoreYieldTip.c_str();
}
CvString CvCity::GetDisabledTooltip(CityEventChoiceTypes eChosenEventChoice, int iSpyIndex, PlayerTypes eSpyOwner)
{
	CvString DisabledTT = Localization::Lookup("TXT_KEY_EVENT_DISABLED_REASONS_HEADER").toUTF8();
	Localization::String localizedDurationText;

	if (eChosenEventChoice == NO_EVENT_CHOICE_CITY)
		return "";

	CvModEventCityChoiceInfo* pkEventInfo = GC.getCityEventChoiceInfo(eChosenEventChoice);
	if (pkEventInfo == NULL)
	{
		return "";
	}

	CvPlayer& kPlayer = GET_PLAYER(m_eOwner);

	//Lua Hook
	if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_CityEventChoiceCanTake, getOwner(), GetID(), eChosenEventChoice) == GAMEEVENTRETURN_FALSE)
	{
		CvString strOverrideText = GetLocalizedText(pkEventInfo->getDisabledTooltip());
		if (strOverrideText != "")
		{
			DisabledTT += strOverrideText;
		}
		else
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_DISABLED_LUA");
			DisabledTT += localizedDurationText.toUTF8();
		}
	}

	if (iSpyIndex != -1 && eSpyOwner != NO_PLAYER)
	{
		if (pkEventInfo->GetSpyLevelRequired() > 0)
		{
			CvEspionageSpy* pSpy = (GET_PLAYER(eSpyOwner).GetEspionage()->GetSpyByID(iSpyIndex));
			if (pSpy && pSpy->GetSpyRank(eSpyOwner) < pkEventInfo->GetSpyLevelRequired())
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_SPY_RANK");
				DisabledTT += localizedDurationText.toUTF8();
			}
		}

		if (!pkEventInfo->IsIgnoreLocalSpies())
		{
			//check to see if another spy is already doing this here. We can only have one spy operation of the same type going on in a city at one time.
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes)iPlayerLoop;
				if (eLoopPlayer == NO_PLAYER)
					continue;

				CvPlayer& kPlayer = GET_PLAYER(eLoopPlayer);

				if (!kPlayer.isAlive())
					continue;
				if (eLoopPlayer == getOwner())
					continue;
				if (eLoopPlayer == eSpyOwner)
					continue;
				if (kPlayer.isBarbarian())
					continue;
				if (kPlayer.isMinorCiv())
					continue;
				if (!kPlayer.GetEspionage())
					continue;
				if (kPlayer.GetEspionage()->GetNumSpies() <= 0)
					continue;

				int iSpyID = kPlayer.GetEspionage()->GetSpyIndexInCity(this);
				if (iSpyID == -1)
					continue;

				CvEspionageSpy* pSpy = kPlayer.GetEspionage()->GetSpyByID(iSpyID);
				if (pSpy && pSpy->m_eSpyFocus == eChosenEventChoice)
				{
					localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_SPY_ALREADY_HERE");
					DisabledTT += localizedDurationText.toUTF8();
					break;
				}
			}
		}

		if (pkEventInfo->getStealTech() > 0)
		{
			GET_PLAYER(eSpyOwner).GetEspionage()->BuildStealableTechList(getOwner());
			int iNumTechsWeDontHave = GET_PLAYER(eSpyOwner).GetEspionage()->GetNumTechsToSteal(getOwner());
			if (iNumTechsWeDontHave < pkEventInfo->getStealTech())
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_NO_TECH_STEAL");
				DisabledTT += localizedDurationText.toUTF8();
			}
		}

		if (pkEventInfo->getForgeGW() > 0)
		{
			int iNumGWInCity = GetCityCulture()->GetNumGreatWorks();
			if (iNumGWInCity < pkEventInfo->getForgeGW())
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_NO_GW_FORGE");
				DisabledTT += localizedDurationText.toUTF8();
			}
		}


		CvCity* pCity = GET_PLAYER(eSpyOwner).GetEspionage()->GetCityWithSpy(iSpyIndex);
		if (pCity)
		{
			if (pkEventInfo->isEnemyUnhappy() && !GET_PLAYER(pCity->getOwner()).IsEmpireUnhappy())
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ENEMY_UNHAPPY");
				DisabledTT += localizedDurationText.toUTF8();
			}

			if (pkEventInfo->isEnemySuperUnhappy() && !GET_PLAYER(pCity->getOwner()).IsEmpireSuperUnhappy())
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ENEMY_SUPER_UNHAPPY");
				DisabledTT += localizedDurationText.toUTF8();
			}


			bool bSiphon = true;
			for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				YieldTypes eYield = (YieldTypes)iI;
				if (eYield == NO_YIELD)
					continue;

				int iSiphonYield = pkEventInfo->getYieldSiphon(eYield);
				if (iSiphonYield <= 0)
					continue;

				int iCityYield = pCity->getYieldRate(eYield, false);
				iCityYield *= iSiphonYield;
				iCityYield /= 100;

				if (iCityYield <= 0)
				{
					bSiphon = false;
					break;
				}
			}
			if (!bSiphon)
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_MIN_SIPHON_NOT_MET");
				DisabledTT += localizedDurationText.toUTF8();
			}
		}
	}
	if (pkEventInfo->isRequiresCounterSpy() && !GetCityEspionage()->HasCounterSpy())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_NO_COUNTERSPY");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isOneShot() && IsEventChoiceFired(eChosenEventChoice))
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_ONESHOT");
		DisabledTT += localizedDurationText.toUTF8();
	}

	//Let's do our linker checks here.
	for (int iI = 0; iI <= pkEventInfo->GetNumLinkers(); iI++)
	{
		CvCityEventChoiceLinkingInfo* pLinkerInfo = pkEventInfo->GetLinkerInfo(iI);
		if (pLinkerInfo)
		{
			EventTypes eLinkerEvent = (EventTypes)pLinkerInfo->GetLinkingEvent();
			EventChoiceTypes eLinkerEventChoice = (EventChoiceTypes)pLinkerInfo->GetLinkingEventChoice();
			CityEventTypes eLinkerCityEvent = (CityEventTypes)pLinkerInfo->GetCityLinkingEvent();
			CityEventChoiceTypes eLinkerCityEventChoice = (CityEventChoiceTypes)pLinkerInfo->GetCityLinkingEventChoice();

			PlayerTypes ePlayer;

			bool bEventFound = false;
			bool bEventChoiceFound = false;
			bool bCityEventFound = false;
			bool bCityEventChoiceFound = false;
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				ePlayer = (PlayerTypes)iPlayerLoop;
				if (ePlayer == NO_PLAYER)
					continue;

				CvPlayer& kPlayer2 = GET_PLAYER(ePlayer);

				if (!pLinkerInfo->CheckOtherPlayers() && ePlayer != getOwner())
					continue;

				if (eLinkerEvent != NO_EVENT && !bEventFound)
				{
					bool bActive = (kPlayer2.GetEventCooldown(eLinkerEvent) > 0 || kPlayer2.IsEventFired(eLinkerEvent));
					if (bActive != pLinkerInfo->CheckForActive())
					{
						if (bActive)
						{
							if (pLinkerInfo->CheckOtherPlayers())
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_EVENT_ACTIVE");
							}
							else
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ACTIVE_EVENT");
							}
						}
						else
						{
							if (pLinkerInfo->CheckOtherPlayers())
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_EVENT_NO_ACTIVE");
							}
							else
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NO_ACTIVE_PLAYER_EVENT");

							}
						}
						localizedDurationText << GC.getEventInfo(eLinkerEvent)->GetDescription();
						DisabledTT += localizedDurationText.toUTF8();
						bEventFound = true;
					}
				}

				if (eLinkerEventChoice != NO_EVENT_CHOICE && !bEventChoiceFound)
				{
					bool bActive = (kPlayer2.GetEventChoiceDuration(eLinkerEventChoice) > 0 || kPlayer2.IsEventChoiceFired(eLinkerEventChoice));
					if (bActive != pLinkerInfo->CheckForActive())
					{
						if (bActive)
						{
							if (pLinkerInfo->CheckOtherPlayers())
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_EVENT_CHOICE_ACTIVE");

							}
							else
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ACTIVE_EVENT_CHOICE");
							}
						}
						else
						{
							if (pLinkerInfo->CheckOtherPlayers())
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_NO_EVENT_CHOICE_ACTIVE");
							}
							else
							{
								localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NO_ACTIVE_PLAYER_EVENT_CHOICE");
							}
						}
						localizedDurationText << GC.getEventChoiceInfo(eLinkerEventChoice)->GetDescription();
						DisabledTT += localizedDurationText.toUTF8();
						bEventChoiceFound = true;
						break;
					}
				}

				if (eLinkerCityEvent != NO_EVENT_CITY || eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
				{
					int iLoop = 0;
					CvCity* pLoopCity = NULL;
					for (pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))
					{
						if (pLoopCity != this && pLinkerInfo->CheckOnlyActiveCity())
							continue;

						if (eLinkerCityEvent != NO_EVENT_CITY && !bCityEventFound)
						{
							bool bActive = (pLoopCity->GetEventCooldown(eLinkerCityEvent) > 0 || pLoopCity->IsEventFired(eLinkerCityEvent));
							if (bActive != pLinkerInfo->CheckForActive())
							{
								if (bActive)
								{
									if (pLinkerInfo->CheckOtherPlayers())
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_CITY_EVENT_ACTIVE");
									}
									else
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ACTIVE_CITY_EVENT");
									}
								}
								else
								{
									if (pLinkerInfo->CheckOtherPlayers())
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_NO_CITY_EVENT_ACTIVE");
									}
									else
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NO_ACTIVE_CITY_EVENT");
									}
								}
								localizedDurationText << GC.getCityEventInfo(eLinkerCityEvent)->GetDescription();
								DisabledTT += localizedDurationText.toUTF8();
								bCityEventFound = true;
								break;
							}
						}

						if (!bCityEventChoiceFound && eLinkerCityEventChoice != NO_EVENT_CHOICE_CITY)
						{
							bool bActive = (pLoopCity->GetEventChoiceDuration(eLinkerCityEventChoice) > 0 || pLoopCity->IsEventChoiceFired(eLinkerCityEventChoice));
							if (bActive != pLinkerInfo->CheckForActive())
							{
								if (bActive)
								{
									if (pLinkerInfo->CheckOtherPlayers())
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_CITY_EVENT_CHOICE_ACTIVE");
									}
									else
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ACTIVE_CITY_EVENT_CHOICE");
									}
								}
								else
								{
									if (pLinkerInfo->CheckOtherPlayers())
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_OTHER_PLAYER_CITY_EVENT_CHOICE_NO_ACTIVE");
									}
									else
									{
										localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NO_ACTIVE_CITY_EVENT_CHOICE");
									}
								}
								localizedDurationText << GC.getCityEventChoiceInfo(eLinkerCityEventChoice)->GetDescription();
								DisabledTT += localizedDurationText.toUTF8();
								bCityEventChoiceFound = true;
								break;
							}
						}
					}
				}
			}
		}
	}

	//Let's narrow down all events here!
	if (GetEventChoiceDuration(eChosenEventChoice) > 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_ACTIVE");
		DisabledTT += localizedDurationText.toUTF8();
	}

	//Let's narrow down all events here!
	if (pkEventInfo->isCapital() && !isCapital())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_BE_CAPITAL");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isCoastal() && !isCoastal())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_BE_COASTAL");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isRiver() && !plot()->isRiver())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_BE_RIVER");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isResistance() && GetResistanceTurns() <= 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_BE_RESISTANCE");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->getRandomBarbs() > 0)
	{
		if (GC.getGame().isOption(GAMEOPTION_NO_BARBARIANS))
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_BARBARIANS_ENABLED");
			DisabledTT += localizedDurationText.toUTF8();
		}
		else if (GC.getGame().getGameTurn() < GC.getGame().GetBarbarianReleaseTurn())
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_TOO_EARLY_FOR_BARBARIANS");
			DisabledTT += localizedDurationText.toUTF8();
		}
	}

	if (pkEventInfo->isWLTKD() && GetWeLoveTheKingDayCounter() <= 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_BE_WLTKD");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isPuppet() && !IsPuppet())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_BE_PUPPET");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isRazing() && !IsRazing())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_BE_RAZING");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isOccupied() && (!IsOccupied() || IsNoOccupiedUnhappiness()))
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_BE_OCCUPIED");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->hasAnyReligion() && GetCityReligions()->GetReligiousMajority() <= RELIGION_PANTHEON)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ANY_RELIGION");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isRequiresGarrison() && !HasGarrison())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_GARRISON");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->hasStateReligion() && kPlayer.GetReligions()->GetStateReligion(false) == NO_RELIGION)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ANY_STATE_RELIGION");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->getPrereqTech() != -1 && !GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getPrereqTech()))
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_TECH");
		localizedDurationText << GC.getTechInfo((TechTypes)pkEventInfo->getPrereqTech())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->getObsoleteTech() != -1 && GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)pkEventInfo->getObsoleteTech()))
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_OBSOLETE_TECH");
		localizedDurationText << GC.getTechInfo((TechTypes)pkEventInfo->getObsoleteTech())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->getRequiredEra() != -1 && kPlayer.GetCurrentEra() < (EraTypes)pkEventInfo->getRequiredEra())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ERA");
		localizedDurationText << GC.getEraInfo((EraTypes)pkEventInfo->getRequiredEra())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->getObsoleteEra() != -1 && kPlayer.GetCurrentEra() >= (EraTypes)pkEventInfo->getObsoleteEra())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_OBSOLETE_ERA");
		localizedDurationText << GC.getEraInfo((EraTypes)pkEventInfo->getObsoleteEra())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->getMinimumPopulation() > 0 && getPopulation() < pkEventInfo->getMinimumPopulation())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_POP_LOCAL");
		localizedDurationText << pkEventInfo->getMinimumPopulation();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->getRequiredCiv() != -1 && getCivilizationType() != (CivilizationTypes)pkEventInfo->getRequiredCiv())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_CIV");
		localizedDurationText << GC.getCivilizationInfo((CivilizationTypes)pkEventInfo->getRequiredCiv())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->getRequiredPolicy() != -1 && !kPlayer.GetPlayerPolicies()->HasPolicy((PolicyTypes)pkEventInfo->getRequiredPolicy()))
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_POLICY");
		localizedDurationText << GC.getPolicyInfo((PolicyTypes)pkEventInfo->getRequiredPolicy())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->getRequiredIdeology() != -1 && kPlayer.GetPlayerPolicies()->GetLateGamePolicyTree() != (PolicyBranchTypes)pkEventInfo->getRequiredIdeology())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_IDEOLOGY");
		localizedDurationText << GC.getPolicyBranchInfo((PolicyBranchTypes)pkEventInfo->getRequiredIdeology())->GetDescription();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->hasPlayerReligion() && kPlayer.GetReligions()->GetOwnedReligion() != GetCityReligions()->GetReligiousMajority())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_PLAYER_RELIGION");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->lacksPlayerReligion() && kPlayer.GetReligions()->GetOwnedReligion() == GetCityReligions()->GetReligiousMajority())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NO_PLAYER_RELIGION");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->hasPlayerMajority() && kPlayer.GetReligions()->GetReligionInMostCities() != GetCityReligions()->GetReligiousMajority())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_PLAYER_MAJORITY_RELIGION");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->lacksPlayerMajority() && kPlayer.GetReligions()->GetReligionInMostCities() == GetCityReligions()->GetReligiousMajority())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NO_PLAYER_MAJORITY_RELIGION");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->getRequiredStateReligion() != -1)
	{
		if (kPlayer.GetReligions()->GetOwnedReligion() != pkEventInfo->getRequiredStateReligion())
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_SPECIFIC_STATE_RELIGION");
			localizedDurationText << GC.getReligionInfo((ReligionTypes)pkEventInfo->getRequiredStateReligion())->GetDescription();
			DisabledTT += localizedDurationText.toUTF8();
		}
	}

	if (!pkEventInfo->isRequiresHolyCity() && pkEventInfo->getRequiredReligion() != -1)
	{
		if (GetCityReligions()->GetReligiousMajority() != (ReligionTypes)pkEventInfo->getRequiredReligion())
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_SPECIFIC_RELIGION");
			localizedDurationText << GC.getReligionInfo((ReligionTypes)pkEventInfo->getRequiredReligion())->GetDescription();
			DisabledTT += localizedDurationText.toUTF8();
		}
	}

	if (pkEventInfo->isRequiresHolyCity())
	{
		if (pkEventInfo->getRequiredReligion() != -1)
		{
			if (!GetCityReligions()->IsHolyCityForReligion((ReligionTypes)pkEventInfo->getRequiredReligion()))
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_NEED_HOLY_CITY_SPECIFIC_LOCAL");
				localizedDurationText << GC.getReligionInfo((ReligionTypes)pkEventInfo->getRequiredReligion())->GetDescription();
				DisabledTT += localizedDurationText.toUTF8();
			}
		}
		else
		{
			if (!GetCityReligions()->IsHolyCityAnyReligion())
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_NEED_HOLY_CITY_LOCAL");
				DisabledTT += localizedDurationText.toUTF8();
			}
		}
	}
	if (pkEventInfo->isRequiresIdeology() && kPlayer.GetPlayerPolicies()->GetLateGamePolicyTree() == NO_POLICY_BRANCH_TYPE)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ANY_IDEOLOGY");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isRequiresWar() && kPlayer.GetMilitaryAI()->GetNumberCivsAtWarWith(false) <= 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_WAR_MAJOR");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->hasCityConnection() && !IsRouteToCapitalConnected())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_CITY_CONNECTION");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->hasTradeConnection() && !HasTradeRouteFromAnyCity() && !HasTradeRouteToAnyCity())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_TRADE_CONNECTION");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isNearMountain() && GetNearbyMountains() <= 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_MOUNTAIN");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isNearNaturalWonder() && !HasAnyNaturalWonder())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NATURAL_WONDER");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->getMaximumPopulation() != 0 && getPopulation() > pkEventInfo->getMaximumPopulation())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_OVER_MAX_POPULATION");
		localizedDurationText << pkEventInfo->getMaximumPopulation();
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->hasPantheon() && GetCityReligions()->GetReligiousMajority() != RELIGION_PANTHEON)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_ANY_PANTHEON");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isUnhappy() && !kPlayer.IsEmpireUnhappy())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_UNHAPPY");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isSuperUnhappy() && !kPlayer.IsEmpireSuperUnhappy())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_SUPER_UNHAPPY");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->hasMetAnotherCiv())
	{
		if (GET_TEAM(getTeam()).getHasMetCivCount(true) <= 0)
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_MET_OTHER_CIV");
			DisabledTT += localizedDurationText.toUTF8();
		}
	}

	if (pkEventInfo->isMaster() && GET_TEAM(getTeam()).GetNumVassals() <= 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_VASSAL");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isVassal() && !GET_TEAM(getTeam()).IsVassalOfSomeone())
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_BE_VASSAL");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->hasNearbyFeature() != -1)
	{
		FeatureTypes eFeature = (FeatureTypes)pkEventInfo->hasNearbyFeature();
		if (eFeature != NO_FEATURE)
		{
			if (!IsHasFeatureLocal(eFeature))
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_NEED_FEATURE_NEARBY");
				localizedDurationText << GC.getFeatureInfo((FeatureTypes)pkEventInfo->hasNearbyFeature())->GetDescription();
				DisabledTT += localizedDurationText.toUTF8();
			}
		}
	}
	if (pkEventInfo->hasNearbyTerrain() != -1)
	{
		TerrainTypes eTerrain = (TerrainTypes)pkEventInfo->hasNearbyTerrain();
		if (eTerrain != NO_TERRAIN)
		{
			if (!HasTerrain(eTerrain))
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_NEED_TERRAIN_NEARBY");
				localizedDurationText << GC.getTerrainInfo((TerrainTypes)pkEventInfo->hasNearbyTerrain())->GetDescription();
				DisabledTT += localizedDurationText.toUTF8();
			}
		}
	}

	if (pkEventInfo->isRequiresWarMinor())
	{
		bool bHas = false;
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes)iPlayerLoop;

			// Is this a player we have relations with?
			if (GET_PLAYER(eLoopPlayer).isBarbarian())
			{
				continue;
			}
			if (!GET_PLAYER(eLoopPlayer).isMinorCiv())
			{
				continue;
			}
			if (eLoopPlayer != getOwner())
			{
				if (GET_TEAM(getTeam()).isAtWar(GET_PLAYER(eLoopPlayer).getTeam()))
				{
					bHas = true;
					break;
				}
			}
		}
		if (!bHas)
		{
			localizedDurationText = Localization::Lookup("TXT_KEY_NEED_WAR_MINOR");
			DisabledTT += localizedDurationText.toUTF8();
		}
	}

	if (pkEventInfo->getBuildingRequired() != -1)
	{
		BuildingClassTypes eBuilding = (BuildingClassTypes)pkEventInfo->getBuildingRequired();
		if (eBuilding != NO_BUILDINGCLASS)
		{
			if (GetCityBuildings()->GetNumBuildingClass(eBuilding) <= 0)
			{
				CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());

				if (pCivilizationInfo != NULL)
				{
					BuildingTypes eBuildingType = (BuildingTypes)pCivilizationInfo->getCivilizationBuildings((BuildingClassTypes)pkEventInfo->getBuildingRequired());
					if (eBuildingType != NO_BUILDING)
					{
						localizedDurationText = Localization::Lookup("TXT_KEY_NEED_BUILDING_CLASS_LOCAL");
						localizedDurationText << GC.getBuildingInfo(eBuildingType)->GetDescription();
						DisabledTT += localizedDurationText.toUTF8();
					}
				}
			}
		}
	}
	if (pkEventInfo->getBuildingLimiter() != -1)
	{
		BuildingClassTypes eBuilding = (BuildingClassTypes)pkEventInfo->getBuildingLimiter();
		if (eBuilding != NO_BUILDINGCLASS)
		{
			if (GetCityBuildings()->GetNumBuildingClass(eBuilding) > 0)
			{
				CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());

				if (pCivilizationInfo != NULL)
				{
					BuildingTypes eBuildingType = NO_BUILDING;
					if (MOD_BUILDINGS_THOROUGH_PREREQUISITES)
					{
						eBuildingType = GetCityBuildings()->GetBuildingTypeFromClass(eBuilding);
					}
					else
					{
						eBuildingType = (BuildingTypes)pCivilizationInfo->getCivilizationBuildings((BuildingClassTypes)pkEventInfo->getBuildingLimiter());
					}
					if (eBuildingType != NO_BUILDING)
					{
						localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NO_BUILDING_CLASS_LOCAL");
						localizedDurationText << GC.getBuildingInfo(eBuildingType)->GetDescription();
						DisabledTT += localizedDurationText.toUTF8();
					}
				}
			}
		}
	}
	if (pkEventInfo->getRequiredImprovement() != -1)
	{
		ImprovementTypes eImprovement = (ImprovementTypes)pkEventInfo->getRequiredImprovement();
		if (eImprovement != NO_IMPROVEMENT)
		{
			if (!HasImprovement(eImprovement))
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_NEED_IMPROVEMENT_LOCAL");
				localizedDurationText << GC.getImprovementInfo((ImprovementTypes)pkEventInfo->getRequiredImprovement())->GetDescription();
				DisabledTT += localizedDurationText.toUTF8();
			}
		}
	}
	if (pkEventInfo->getLocalResourceRequired() != -1)
	{
		ResourceTypes eResource = (ResourceTypes)pkEventInfo->getLocalResourceRequired();
		if (eResource != NO_RESOURCE)
		{
			if (!HasResource(eResource))
			{
				localizedDurationText = Localization::Lookup("TXT_KEY_NEED_RESOURCE_LOCAL");
				localizedDurationText << GC.getResourceInfo((ResourceTypes)pkEventInfo->getLocalResourceRequired())->GetDescription();
				DisabledTT += localizedDurationText.toUTF8();
			}
		}
	}
	//Check our minimum yields - this looks at stored values, not yields per turn.
	bool bHas = true;
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes)iI;
		if (eYield == NO_YIELD)
			continue;

		int iNeededYield = pkEventInfo->getYieldMinimum(eYield);
		if (pkEventInfo->getPreCheckEventYield(eYield) != 0)
		{
			if (iNeededYield < pkEventInfo->getPreCheckEventYield(eYield))
			{
				iNeededYield = pkEventInfo->getPreCheckEventYield(eYield);
			}
		}
		iNeededYield *= GC.getGame().getGameSpeedInfo().getInstantYieldPercent();
		iNeededYield /= 100;
		if (pkEventInfo->IsEraScaling())
		{
			int iEra = kPlayer.GetCurrentEra();
			if (iEra <= 0)
			{
				iEra = 1;
			}
			iNeededYield *= iEra;
		}
		if (iNeededYield != 0)
		{
			if (eYield == YIELD_FOOD)
			{
				if (iNeededYield > getFood())
				{
					bHas = false;
					break;
				}
			}
			if (eYield == YIELD_PRODUCTION)
			{
				if (iNeededYield > getProduction())
				{
					bHas = false;
					break;
				}
			}
			if (eYield == YIELD_GOLD)
			{
				if (iNeededYield > kPlayer.GetTreasury()->GetGold())
				{
					bHas = false;
					break;
				}
			}
			else if (eYield == YIELD_SCIENCE)
			{
				TechTypes eCurrentTech = kPlayer.GetPlayerTechs()->GetCurrentResearch();
				int iTech = 0;
				if (eCurrentTech != NO_TECH)
				{
					iTech = kPlayer.GetPlayerTechs()->GetResearchProgress(eCurrentTech);
				}
				if (iNeededYield > iTech)
				{
					bHas = false;
					break;
				}
			}
			else if (eYield == YIELD_FAITH)
			{
				if (iNeededYield > kPlayer.GetFaith())
				{
					bHas = false;
					break;
				}
			}
			else if (eYield == YIELD_GOLDEN_AGE_POINTS)
			{
				if (iNeededYield > kPlayer.GetGoldenAgeProgressMeter())
				{
					bHas = false;
					break;
				}
			}
			else if (eYield == YIELD_CULTURE)
			{
				if (iNeededYield > kPlayer.getJONSCulture())
				{
					bHas = false;
					break;
				}
			}
		}
	}
	if (!bHas)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_YIELDS");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isInDebt() && kPlayer.GetTreasury()->GetGold() > 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_DEBT");
		DisabledTT += localizedDurationText.toUTF8();
	}

	if (pkEventInfo->isLosingMoney() && kPlayer.GetTreasury()->CalculateBaseNetGold() > 0)
	{
		localizedDurationText = Localization::Lookup("TXT_KEY_NEED_NEGATIVE_GPT");
		DisabledTT += localizedDurationText.toUTF8();
	}

	return DisabledTT.c_str();

}
void CvCity::DoEventChoice(CityEventChoiceTypes eEventChoice, CityEventTypes eCityEvent, bool bSendMsg, int iEspionageValue, PlayerTypes eSpyOwner)
{
	if (GC.getGame().isNetworkMultiPlayer() && bSendMsg && (GET_PLAYER(getOwner()).isHuman() || (eSpyOwner != NO_PLAYER && GET_PLAYER(eSpyOwner).isHuman()))) {
		NetMessageExt::Send::DoCityEventChoice(getOwner(), GetID(), eEventChoice, eCityEvent, iEspionageValue, eSpyOwner);
		return;
	}
	if (eEventChoice != NO_EVENT_CHOICE_CITY)
	{
		CvModEventCityChoiceInfo* pkEventChoiceInfo = GC.getCityEventChoiceInfo(eEventChoice);
		if (pkEventChoiceInfo != NULL)
		{
			//Set oneshot stuff so this event can't fire ever again.
			if (pkEventChoiceInfo->isOneShot())
			{
				SetEventChoiceFired(eEventChoice, true);
			}
			//Set false so we know we've completed the city event.
			//Loop through all city events and set any related to this to false, just to be sure.
			if (eCityEvent == NO_EVENT_CITY)
			{
				for (int iLoop = 0; iLoop < GC.getNumCityEventInfos(); iLoop++)
				{
					CityEventTypes eEvent = (CityEventTypes)iLoop;
					if (eEvent != NO_EVENT_CITY)
					{
						if (pkEventChoiceInfo->isParentEvent(eEvent))
						{
							SetEventActive(eEvent, false);
						}
					}
				}
			}
			else
			{
				SetEventActive(eCityEvent, false);
			}

			if (GC.getLogging())
			{
				CvString playerName;
				FILogFile* pLog = NULL;
				CvString strBaseString;
				CvString strOutBuf;
				CvString strFileName = "EventCityLogging.csv";
				playerName = getName();
				pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				strBaseString += playerName + ", ";
				strOutBuf.Format("Event choice chosen by City: %s", pkEventChoiceInfo->GetDescription());
				strBaseString += strOutBuf;
				pLog->Msg(strBaseString);
			}
			bool bAlreadyActive = false;
			//Set the cooldown for the event choice.
			if (pkEventChoiceInfo->getEventDuration() > 0)
			{
				bool bDefer = false;
				if (eSpyOwner != NO_PLAYER && iEspionageValue != -1)
				{
					CvEspionageSpy* pSpy = GET_PLAYER(eSpyOwner).GetEspionage()->GetSpyByID(iEspionageValue);
					if (pSpy)
						bDefer = pSpy->m_eSpyFocus == NO_EVENT_CHOICE_CITY;
				}

				//already active? Apply the extended duration, but don't duplicate the yield effect.
				if (pkEventChoiceInfo->IsEspionageEffect() && GetEventChoiceDuration(eEventChoice) > 0)
					bAlreadyActive = true;

				if (!bDefer)
				{
					//Gamespeed.
					int iEventDuration = pkEventChoiceInfo->getEventDuration();
					iEventDuration *= GC.getGame().getGameSpeedInfo().getSpyRatePercent();
					iEventDuration /= 100;
					ChangeEventChoiceDuration(eEventChoice, max(1, iEventDuration));
				}
			}

			//Lua Hook
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityEventChoiceActivated, getOwner(), GetID(), eEventChoice);

			EventChoiceTypes eEventChoicePlayer = pkEventChoiceInfo->GetTriggerPlayerEventChoice();
			bool bAlreadyApplied = false;
			if (eEventChoicePlayer != NO_EVENT_CHOICE)
			{
				if (pkEventChoiceInfo->IsApplyEffectToSpyOwner())
				{
					if (eSpyOwner != NO_PLAYER && iEspionageValue != -1)
					{
						CvEspionageSpy* pSpy = GET_PLAYER(eSpyOwner).GetEspionage()->GetSpyByID(iEspionageValue);
						if (pSpy)
						{
							if (pSpy->m_eSpyFocus == eEventChoice)
							{
								GET_PLAYER(eSpyOwner).DoEventChoice(eEventChoicePlayer, NO_EVENT, false, true);
								bAlreadyApplied = true;
							}
						}
					}
				}
				else
				{
					GET_PLAYER(getOwner()).DoEventChoice(eEventChoicePlayer, NO_EVENT, false, pkEventChoiceInfo->IsEspionageEffect());
				}
			}

			CvSpyResult eResult = NUM_SPY_RESULTS;
			int iSiphonValue = 0;
			YieldTypes eSiphonYield = NO_YIELD;
			int iTurnSiphonMissionStarted = 0;
			if (eSpyOwner != NO_PLAYER && iEspionageValue != -1)
			{
				CvEspionageSpy* pSpy = GET_PLAYER(eSpyOwner).GetEspionage()->GetSpyByID(iEspionageValue);
				if (pSpy)
				{
					iSiphonValue = pSpy->m_iYieldSiphon;
					eSiphonYield = pSpy->m_eSiphonYield;
					iTurnSiphonMissionStarted = pSpy->m_iTurnSiphonMissionStarted;

					bool bDefer = false;
					if (pSpy->m_eSpyFocus == NO_EVENT_CHOICE_CITY)
						bDefer = true;

					eResult = GET_PLAYER(eSpyOwner).GetEspionage()->ProcessSpyFocusResult(eSpyOwner, this, iEspionageValue, eEventChoice, bDefer);
					//if we were killed, we don't get anything
					if (eResult == SPY_RESULT_KILLED)
						return;

					if (!pkEventChoiceInfo->isSurveillance())
					{
						pSpy->UpdateLastMissionOutcome(this, eSpyOwner, iEspionageValue, eResult);
					}

					//if setup, we don't actually fire the choice right now...we wait!
					if (bDefer && !pkEventChoiceInfo->isExpiresOnCounterSpyExit())
						return;

					if (pkEventChoiceInfo->IsEspionageEffect() && !bAlreadyApplied)
					{
						if (pkEventChoiceInfo->IsApplyEffectToSpyOwner())
						{
							if (GET_PLAYER(eSpyOwner).getCapitalCity() != NULL)
								GET_PLAYER(eSpyOwner).getCapitalCity()->DoEventChoice(eEventChoice, NO_EVENT_CITY, false, -1, getOwner());

							return;
						}
					}
				}
			}

			//Do the cost first, as that goes through whether or not the event succeeds!
			for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				YieldTypes eYield = (YieldTypes)iI;
				if (eYield == NO_YIELD)
					continue;

				int iPassYield = pkEventChoiceInfo->getPreCheckEventYield(eYield);
				iPassYield *= -1;

				if (iPassYield != 0)
				{
					GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_INSTANT, false, NO_GREATPERSON, NO_BUILDING, iPassYield, pkEventChoiceInfo->IsEraScaling(), NO_PLAYER, NULL, true, this, false, true, true, eYield);
				}
			}
			int iRandom = GC.getGame().getSmallFakeRandNum(100, getFood());
			int iLimit = pkEventChoiceInfo->getEventChance();
			if (iLimit > 0 && iRandom > iLimit)
			{
				if (!pkEventChoiceInfo->IsEspionageEffect())
				{
					//Notify if it did not work.
					CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
					if (pNotifications && GC.getGame().getActivePlayer() == getOwner())
					{
						for (int iLoop = 0; iLoop < GC.getNumCityEventInfos(); iLoop++)
						{
							CityEventTypes eEvent = (CityEventTypes)iLoop;
							if (eEvent != NO_EVENT_CITY)
							{
								if (pkEventChoiceInfo->isParentEvent(eEvent))
								{
									CvModCityEventInfo* pkEventInfo = GC.getCityEventInfo(eEvent);
									if (pkEventInfo != NULL)
									{
										Localization::String strMessage;
										Localization::String strSummary;
										strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_EVENT_FAILED_CITY");
										strMessage << pkEventChoiceInfo->GetDescription();
										strMessage << GetScaledHelpText(eEventChoice, false, -1, NO_PLAYER);
										strMessage << pkEventInfo->GetDescription();
										strMessage << getNameKey();
										strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_EVENT_FAILED_CITY_T");
										strSummary << pkEventInfo->GetDescription();
										strSummary << getNameKey();

										pNotifications->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), getX(), getY(), GetID(), getOwner());
										break;
									}
								}
							}
						}
					}
				}
				return;
			}
			//Set the event choice active if it succeeded, so we know to cancel it later.
			SetEventChoiceActive(eEventChoice, true);

			//Now do the bonuses.

			//respect the neg!
			if (pkEventChoiceInfo->getDamageGarrison() != 0)
			{
				CvUnit* pUnit = GetGarrisonedUnit();
				if (pUnit)
					pUnit->changeDamage(pkEventChoiceInfo->getDamageGarrison());
			}

			//respect the neg!
			if (pkEventChoiceInfo->getDamageCity() != 0)
			{
				changeDamage(pkEventChoiceInfo->getDamageCity());
			}

			if (pkEventChoiceInfo->getStealTech() > 0 && eSpyOwner != NO_PLAYER)
			{
				GET_PLAYER(eSpyOwner).GetEspionage()->BuildStealableTechList(getOwner());
				int iNumTechsWeDontHave = GET_PLAYER(eSpyOwner).GetEspionage()->GetNumTechsToSteal(getOwner());
				if (iNumTechsWeDontHave > 0)
				{
					for (int i = 0; i < min(pkEventChoiceInfo->getStealTech(), iNumTechsWeDontHave); i++)
					{
						GET_PLAYER(eSpyOwner).GetEspionage()->DoStealTechnology(getOwner());
					}
				}
				else
				{
					int iGoldenAgeTurns = GET_PLAYER(eSpyOwner).getGoldenAgeLength(pkEventChoiceInfo->getStealTech() * 10);
					GET_PLAYER(eSpyOwner).changeGoldenAgeTurns(iGoldenAgeTurns);
				}
			}

			if (pkEventChoiceInfo->getForgeGW() > 0 && eSpyOwner != NO_PLAYER)
			{
				std::vector<int> GWIDs = GET_PLAYER(eSpyOwner).GetEspionage()->BuildGWList(this);
				if (GWIDs.size() > 0)
				{
					int iMinLoop = min(pkEventChoiceInfo->getForgeGW(), (int)GWIDs.size());
					while (iMinLoop > 0)
					{
						int iGrab = GC.getGame().getSmallFakeRandNum(iMinLoop - 1, GET_PLAYER(eSpyOwner).GetPseudoRandomSeed() + GWIDs[0] + GET_PLAYER(getOwner()).GetTreasury()->CalculateGrossGold());
						if (GET_PLAYER(eSpyOwner).GetEspionage()->DoStealGW(this, GWIDs[iGrab]))
						{
							GET_PLAYER(eSpyOwner).GetEspionage()->m_aiNumSpyActionsDone[getOwner()]++;

							GET_PLAYER(eSpyOwner).doInstantYield(INSTANT_YIELD_TYPE_SPY_ATTACK, false, NO_GREATPERSON, NO_BUILDING, 1);
						}
						iMinLoop--;
					}
				}
				else
				{
					int iGoldenAgeTurns = GET_PLAYER(eSpyOwner).getGoldenAgeLength(pkEventChoiceInfo->getForgeGW() * 10);
					GET_PLAYER(eSpyOwner).changeGoldenAgeTurns(iGoldenAgeTurns);
				}
			}

			if (pkEventChoiceInfo->getSapCityTurns() != 0)
			{
				ChangeSappedTurns(pkEventChoiceInfo->getSapCityTurns());
			}
			if (pkEventChoiceInfo->getGrowthMod() != 0)
			{
				ChangeGrowthFromEvent(pkEventChoiceInfo->getGrowthMod());
			}

			if (pkEventChoiceInfo->getSpyVisionRange() != 0 && eSpyOwner != NO_PLAYER)
			{
				plot()->changeAdjacentSight(GET_PLAYER(eSpyOwner).getTeam(), pkEventChoiceInfo->getSpyVisionRange(), true, NO_INVISIBLE, NO_DIRECTION);
				int iDuration = pkEventChoiceInfo->getSpyVisionDuration();
				iDuration *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iDuration /= 100;

				SetBonusEspionageSightTurns(eSpyOwner, iDuration);
			}

			if (pkEventChoiceInfo->getEventPromotion() != -1)
			{
				PromotionTypes ePromotion = (PromotionTypes)pkEventChoiceInfo->getEventPromotion();
				if (ePromotion != -1)
				{
					changeFreePromotionCount(ePromotion, 1);
				}
			}
			for (int iI = 0; iI < GC.getNumResourceInfos(); iI++)
			{
				ResourceTypes eResource = (ResourceTypes)iI;
				if (eResource != NO_RESOURCE)
				{
					int iBonus = pkEventChoiceInfo->getEventResourceChange(eResource);
					if (iBonus != 0)
					{
						GET_PLAYER(getOwner()).changeNumResourceTotal(eResource, iBonus);
					}
				}
			}
			if (pkEventChoiceInfo->getEventBuilding() != -1)
			{
				BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventChoiceInfo->getEventBuilding();
				if (eBuildingClass != NO_BUILDINGCLASS)
				{
					const CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);

					if (pkBuildingClassInfo)
					{
						CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());

						if (pCivilizationInfo != NULL)
						{
							if (!HasBuildingClass(eBuildingClass))
							{
								BuildingTypes eBuildingType = (BuildingTypes)pCivilizationInfo->getCivilizationBuildings(eBuildingClass);
								if (eBuildingType != NO_BUILDING)
								{
									GetCityBuildings()->SetNumRealBuilding(eBuildingType, 1, true);
								}
							}
						}
					}
				}
			}
			if (pkEventChoiceInfo->getEventBuildingDestruction() != -1)
			{
				BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkEventChoiceInfo->getEventBuildingDestruction();
				if (eBuildingClass != NO_BUILDINGCLASS)
				{
					const CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);

					if (pkBuildingClassInfo)
					{
						CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());

						if (pCivilizationInfo != NULL)
						{
							BuildingTypes eBuildingType = NO_BUILDING;
							if (MOD_BUILDINGS_THOROUGH_PREREQUISITES)
							{
								eBuildingType = GetCityBuildings()->GetBuildingTypeFromClass(eBuildingClass);
							}
							else
							{
								eBuildingType = (BuildingTypes)pCivilizationInfo->getCivilizationBuildings(eBuildingClass);
							}
							if (eBuildingType != NO_BUILDING)
							{
								GetCityBuildings()->SetNumRealBuilding(eBuildingType, 0, true);
							}
						}
					}
				}
			}

			for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
			{
				BuildingClassTypes eBuildingClass = (BuildingClassTypes)iI;
				if (eBuildingClass == NO_BUILDINGCLASS || GetCityBuildings()->GetNumBuildingClass(eBuildingClass) <= 0)
					continue;

				const CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);

				if (!pkBuildingClassInfo)
				{
					continue;
				}

				int iChance = pkEventChoiceInfo->getBuildingDestructionChance(iI);
				if (pkEventChoiceInfo->getCityWideDestructionChance() > iChance && pkEventChoiceInfo->getCityWideDestructionChance() > 0)
				{
					if (pkBuildingClassInfo->getMaxGlobalInstances() != -1)
					{
						continue;
					}
					else if (pkBuildingClassInfo->getMaxPlayerInstances() != -1)
					{
						continue;
					}
					iChance = pkEventChoiceInfo->getCityWideDestructionChance();
				}
				if (iChance <= 0)
				{
					continue;
				}
				else
				{
					CvCivilizationInfo* pCivilizationInfo = GC.getCivilizationInfo(getCivilizationType());

					if (pCivilizationInfo != NULL)
					{
						BuildingTypes eBuildingType = NO_BUILDING;
						if (MOD_BUILDINGS_THOROUGH_PREREQUISITES)
						{
							eBuildingType = GetCityBuildings()->GetBuildingTypeFromClass(eBuildingClass);
						}
						else
						{
							eBuildingType = (BuildingTypes)pCivilizationInfo->getCivilizationBuildings(eBuildingClass);
						}

						if (eBuildingType != NO_BUILDING)
						{
							CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuildingType);
							if (!pkBuildingInfo || pkBuildingInfo->IsDummy())
								continue;

							if (GetCityBuildings()->GetNumFreeBuilding(eBuildingType) > 0)
								continue;

							int iRandom = GC.getGame().getJonRandNum(100, "Random Event Chance");
							if (iRandom < iChance)
							{
								GetCityBuildings()->SetNumRealBuilding(eBuildingType, 0, true);
								if (getOwner() == GC.getGame().getActivePlayer())
								{
									CvString strBuffer = GetLocalizedText("TXT_KEY_MISC_BUILDING_DESTROYED_EVENT", GC.getBuildingInfo(eBuildingType)->GetTextKey(), getNameKey());
									GC.GetEngineUserInterface()->AddCityMessage(0, GetIDInfo(), getOwner(), false, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), strBuffer);
								}
							}
						}
					}
				}
			}
			for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				YieldTypes eYield = (YieldTypes)iI;
				if (eYield == NO_YIELD)
					continue;

				//espionage tweak - if already active, simply increase duration
				if (!bAlreadyActive)
				{
					int iYieldChange = pkEventChoiceInfo->getCityYield(eYield);
					if (iYieldChange != 0)
					{
						ChangeEventCityYield(eYield, iYieldChange);
					}

					int iYieldMod = pkEventChoiceInfo->getCityYieldModifier(eYield);
					if (iYieldMod != 0)
					{
						ChangeEventCityYieldModifier(eYield, iYieldMod);
					}

					// Building modifiers
					for (int iJ = 0; iJ < GC.getNumBuildingClassInfos(); iJ++)
					{
						BuildingClassTypes eBuildingClass = (BuildingClassTypes)iJ;

						CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
						if (!pkBuildingClassInfo)
						{
							continue;
						}
						if (pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield) != 0)
						{
							BuildingTypes eBuilding = NO_BUILDING;
							if (MOD_BUILDINGS_THOROUGH_PREREQUISITES)
							{
								eBuilding = GetCityBuildings()->GetBuildingTypeFromClass(eBuildingClass);
							}
							else
							{
								eBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(eBuildingClass);
							}

							if (MOD_BUILDINGS_THOROUGH_PREREQUISITES || eBuilding != NO_BUILDING)
							{
								ChangeEventBuildingClassYield(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield));
								if (eBuilding != NO_BUILDING && GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
								{
									ChangeBaseYieldRateFromBuildings(eYield, pkEventChoiceInfo->getBuildingClassYield(eBuildingClass, eYield));
								}
							}
						}
						if (pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield) != 0)
						{
							BuildingTypes eBuilding = NO_BUILDING;
							if (MOD_BUILDINGS_THOROUGH_PREREQUISITES)
							{
								eBuilding = GetCityBuildings()->GetBuildingTypeFromClass(eBuildingClass);
							}
							else
							{
								eBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(eBuildingClass);
							}

							if (MOD_BUILDINGS_THOROUGH_PREREQUISITES || eBuilding != NO_BUILDING)
							{
								ChangeEventBuildingClassYieldModifier(eBuildingClass, eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield));
								if (eBuilding != NO_BUILDING && GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
								{
									changeYieldRateModifier(eYield, pkEventChoiceInfo->getBuildingClassYieldModifier(eBuildingClass, eYield));
								}
							}
						}
					}
				}

				int iPassYield = pkEventChoiceInfo->getEventYield(eYield);
				if (iPassYield != 0)
				{
					GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_INSTANT, false, NO_GREATPERSON, NO_BUILDING, iPassYield, pkEventChoiceInfo->IsEraScaling(), NO_PLAYER, NULL, true, this, false, true, true, eYield);
				}
				int iSiphonYield = pkEventChoiceInfo->getYieldSiphon(eYield);
				if (iSiphonYield > 0)
				{
					CvEspionageSpy* pSpy = GET_PLAYER(eSpyOwner).GetEspionage()->GetSpyByID(iEspionageValue);
					if (pSpy)
					{
						if (eSiphonYield == eYield)
						{
							int iMissionDuration = GC.getGame().getGameTurn() - iTurnSiphonMissionStarted;
							CvAssertMsg(iMissionDuration > 0, "Spy Mission Duration <= 0");
							int iAmount = iSiphonValue / iMissionDuration;
							bool bIdentified = (eResult == SPY_RESULT_IDENTIFIED);
							int iEffectDuration = pkEventChoiceInfo->getEspionageMissionDuration();
							iEffectDuration *= GC.getGame().getGameSpeedInfo().getSpyRatePercent();
							iEffectDuration /= 100;

							GET_PLAYER(eSpyOwner).AddEspionageEvent(getOwner(), true, bIdentified, GC.getGame().getGameTurn(), GC.getGame().getGameTurn() + iEffectDuration, eYield, iAmount);

							int iTurnIncrease = (getOwner() < eSpyOwner) ? 1 : 0; // if the targeted player plays his turns before the spy owner, start and end turn numbers needs to be increased by 1 because in the current turn the effect isn't yet active for the targeted player
							GET_PLAYER(getOwner()).AddEspionageEvent(eSpyOwner, false, bIdentified, GC.getGame().getGameTurn() + iTurnIncrease, GC.getGame().getGameTurn() + iEffectDuration + iTurnIncrease, eYield, iAmount);

							if (GC.getLogging())
							{
								CvString strMsg;
								strMsg.Format("Siphoning %d Yield per Turn for Spy Event! %d, ", (int)eYield, iAmount);
								strMsg += GetLocalizedText(pSpy->GetSpyName(&GET_PLAYER(eSpyOwner)));
								GET_PLAYER(eSpyOwner).GetEspionage()->LogEspionageMsg(strMsg);
							}
						}
					}
				}
				if (!bAlreadyActive)
				{
					for (int iJ = 0; iJ < GC.getNumImprovementInfos(); iJ++)
					{
						ImprovementTypes eImprovement = (ImprovementTypes)iJ;
						if (eImprovement != NO_IMPROVEMENT && pkEventChoiceInfo->getImprovementYield(eImprovement, eYield) != 0)
						{
							ChangeEventImprovementYield(eImprovement, eYield, pkEventChoiceInfo->getImprovementYield(eImprovement, eYield));
						}
					}
					for (int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
					{
						FeatureTypes eFeature = (FeatureTypes)iJ;
						if (eFeature != NO_FEATURE && pkEventChoiceInfo->getFeatureYield(eFeature, eYield) != 0)
						{
							ChangeEventFeatureYield(eFeature, eYield, pkEventChoiceInfo->getFeatureYield(eFeature, eYield));
						}
					}
					for (int iJ = 0; iJ < GC.getNumTerrainInfos(); iJ++)
					{
						TerrainTypes eTerrain = (TerrainTypes)iJ;
						if (eTerrain != NO_TERRAIN && pkEventChoiceInfo->getTerrainYield(eTerrain, eYield) != 0)
						{
							ChangeEventTerrainYield(eTerrain, eYield, pkEventChoiceInfo->getTerrainYield(eTerrain, eYield));
						}
					}
					for (int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
					{
						ResourceTypes eResource = (ResourceTypes)iJ;
						if (eResource != NO_RESOURCE && pkEventChoiceInfo->getResourceYield(eResource, eYield) != 0)
						{
							ChangeEventResourceYield(eResource, eYield, pkEventChoiceInfo->getResourceYield(eResource, eYield));
						}
					}
					for (int iJ = 0; iJ < GC.getNumSpecialistInfos(); iJ++)
					{
						const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iJ);
						CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
						if (pkSpecialistInfo)
						{
							ChangeEventSpecialistYield(eSpecialist, eYield, pkEventChoiceInfo->getCitySpecialistYieldChange(eSpecialist, eYield));
						}
					}
				}
			}
			for (int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
			{
				const SpecialistTypes eSpecialist = static_cast<SpecialistTypes>(iSpecialistLoop);
				CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
				if (pkSpecialistInfo)
				{
					int iBonus = pkEventChoiceInfo->getEventGPChange(eSpecialist);
					if (pkEventChoiceInfo->IsEraScaling())
					{
						int iEra = GET_PLAYER(getOwner()).GetCurrentEra();
						if (iEra <= 0)
						{
							iEra = 1;
						}
						iBonus *= iEra;
						iBonus *= GC.getGame().getGameSpeedInfo().getGreatPeoplePercent();
						iBonus /= 100;
					}
					if (iBonus != 0)
					{
						if (iBonus < 0)
						{
							int iMinimum = GetCityCitizens()->GetSpecialistGreatPersonProgressTimes100(eSpecialist) / 100;
							if ((iBonus * -1) > iMinimum)
								iBonus = (iMinimum * -1);
						}
						GetCityCitizens()->ChangeSpecialistGreatPersonProgressTimes100(eSpecialist, iBonus * 100, true);
					}
				}
			}

			typedef CvWeightedVector<CvPlot*> WeightedPlotVector;
			WeightedPlotVector aBestPlots;
			for (int iI = 0; iI < GC.getNumImprovementInfos(); iI++)
			{
				ImprovementTypes eImprovement = (ImprovementTypes)iI;
				if (eImprovement != NO_IMPROVEMENT && pkEventChoiceInfo->getImprovementDestruction(eImprovement) > 0)
				{
					aBestPlots.clear();
					int iX = getX(); int iY = getY(); int iOwner = getOwner();

					for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
					{
						CvPlot* pLoopPlot = iterateRingPlots(iX, iY, iCityPlotLoop);

						// Invalid plot or not owned by this player
						if (pLoopPlot == NULL || pLoopPlot->getOwner() != iOwner)
						{
							continue;
						}

						if (pLoopPlot->HasImprovement(eImprovement))
						{
							int iValue = GC.getGame().getJonRandNum(100, "Improvement Destruction");
							if (pkEventChoiceInfo->isCoastal() && pLoopPlot->isCoastalLand())
							{
								iValue += 100;
							}
							if (pkEventChoiceInfo->isRiver() && pLoopPlot->isRiver())
							{
								iValue += 100;
							}
							if (pkEventChoiceInfo->isNearMountain() && pLoopPlot->GetNumAdjacentMountains() > 0)
							{
								iValue += 100;
							}
							aBestPlots.push_back(pLoopPlot, iValue);
						}
					}
					if (aBestPlots.size() > 0)
					{
						aBestPlots.StableSortItems();
						//Delete improvents up to the total on the event.
						int iNumber = 0;
						int iRuns = pkEventChoiceInfo->getImprovementDestruction(eImprovement);
						if (aBestPlots.size() < iRuns)
						{
							iRuns = aBestPlots.size();
						}
						for (int iI = 0; iI < iRuns; iI++)
						{
							CvPlot* pPlot = aBestPlots.GetElement(iI);
							if (pPlot != NULL && pPlot->getOwner() == getOwner() && pPlot->getImprovementType() == eImprovement)
							{
								pPlot->SetImprovementPillaged(true);
								iNumber++;
							}
						}
						if (getOwner() == GC.getGame().getActivePlayer())
						{
							CvString strBuffer = GetLocalizedText("TXT_KEY_MISC_IMPROVEMENT_DESTROYED_EVENT", GC.getImprovementInfo(eImprovement)->GetTextKey(), iNumber, getNameKey());
							GC.GetEngineUserInterface()->AddCityMessage(0, GetIDInfo(), getOwner(), false, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), strBuffer);
						}
					}
				}
			}
			int iNumStrategicsToDestroy = pkEventChoiceInfo->getCityStrategicResourcePillage();
			if (iNumStrategicsToDestroy > 0)
			{
				for (int iI = 0; iI < GC.getNumResourceInfos(); iI++)
				{
					ResourceTypes eResource = (ResourceTypes)iI;
					if (eResource != NO_RESOURCE)
					{
						CvResourceInfo* pResource = GC.getResourceInfo(eResource);
						if (pResource && pResource->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)
						{
							aBestPlots.clear();
							int iX = getX(); int iY = getY(); int iOwner = getOwner();

							for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
							{
								CvPlot* pLoopPlot = iterateRingPlots(iX, iY, iCityPlotLoop);

								// Invalid plot or not owned by this player
								if (pLoopPlot == NULL || pLoopPlot->getOwner() != iOwner)
								{
									continue;
								}

								if (pLoopPlot->HasResource(eResource) && (pLoopPlot->getImprovementTypeNeededToImproveResource(getOwner()) == pLoopPlot->getImprovementType()))
								{
									int iValue = GC.getGame().getJonRandNum(100, "Improvement Destruction");
									if (pkEventChoiceInfo->isCoastal() && pLoopPlot->isCoastalLand())
									{
										iValue += 100;
									}
									if (pkEventChoiceInfo->isRiver() && pLoopPlot->isRiver())
									{
										iValue += 100;
									}
									if (pkEventChoiceInfo->isNearMountain() && pLoopPlot->GetNumAdjacentMountains() > 0)
									{
										iValue += 100;
									}
									aBestPlots.push_back(pLoopPlot, iValue);
								}
							}
							if (aBestPlots.size() > 0)
							{
								aBestPlots.StableSortItems();
								//Delete improvents up to the total on the event.
								int iNumber = 0;
								int iRuns = iNumStrategicsToDestroy;
								if (aBestPlots.size() < iRuns)
								{
									iRuns = aBestPlots.size();
								}
								for (int iI = 0; iI < iRuns; iI++)
								{
									CvPlot* pPlot = aBestPlots.GetElement(iI);
									if (pPlot != NULL && pPlot->getOwner() == getOwner() && pPlot->getResourceType() == eResource && pPlot->getImprovementType() != NO_IMPROVEMENT)
									{
										pPlot->SetImprovementPillaged(true);
										iNumber++;
									}
								}
								if (getOwner() == GC.getGame().getActivePlayer())
								{
									CvString strBuffer = GetLocalizedText("TXT_KEY_MISC_STRATEGIC_RESOURCE_PILLAGED_EVENT", pResource->GetTextKey(), iNumber, getNameKey());
									GC.GetEngineUserInterface()->AddCityMessage(0, GetIDInfo(), getOwner(), false, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), strBuffer);
								}
							}
						}
					}
				}
			}
			for (int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
			{
				const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
				CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
				if (pkUnitClassInfo)
				{
					if (pkEventChoiceInfo->getNumFreeUnits((UnitClassTypes)iI) <= 0)
						continue;

					const UnitTypes eLoopUnit = GET_PLAYER(getOwner()).GetSpecificUnitType(eUnitClass);
					if (eLoopUnit != NO_UNIT)
					{
						CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eLoopUnit);
						if (pkUnitEntry)
						{
							for (int iJ = 0; iJ < pkEventChoiceInfo->getNumFreeUnits((UnitClassTypes)iI); iJ++)
							{
								UnitAITypes eUnitAI = pkUnitEntry->GetDefaultUnitAIType();
								CvUnit* pUnit = CreateUnit(eLoopUnit, eUnitAI, REASON_GIFT);
								if (pUnit)
								{
									if (!pUnit->IsCivilianUnit() && !pUnit->jumpToNearestValidPlot())
									{
										pUnit->kill(false);	// Could not find a valid spot!
									}
									else
									{
										pUnit->finishMoves();
										//Lua Hook
										GAMEEVENTINVOKE_HOOK(GAMEEVENT_EventUnitCreated, getOwner(), eEventChoice, pUnit);
									}
								}
							}
						}
					}
				}
			}
			for (int iI = 0; iI < GC.getNumUnitInfos(); iI++)
			{
				const UnitTypes eUnit = static_cast<UnitTypes>(iI);
				CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eUnit);
				if (pkUnitEntry)
				{
					if (pkEventChoiceInfo->getNumFreeSpecificUnits((UnitTypes)iI) <= 0)
						continue;

					for (int iJ = 0; iJ < pkEventChoiceInfo->getNumFreeSpecificUnits((UnitTypes)iI); iJ++)
					{
						UnitAITypes eUnitAI = pkUnitEntry->GetDefaultUnitAIType();
						CvUnit* pUnit = CreateUnit(eUnit, eUnitAI, REASON_GIFT);
						if (pUnit)
						{
							if (!pUnit->IsCivilianUnit() && !pUnit->jumpToNearestValidPlot())
							{
								pUnit->kill(false);	// Could not find a valid spot!
							}
							else
							{
								pUnit->finishMoves();
								//Lua Hook
								GAMEEVENTINVOKE_HOOK(GAMEEVENT_EventUnitCreated, getOwner(), eEventChoice, pUnit);
							}
						}
					}
				}
			}
			if (pkEventChoiceInfo->ConvertsCityToPlayerReligion() != 0)
			{
				ReligionTypes eReligion = GET_PLAYER(getOwner()).GetReligions()->GetOwnedReligion();
				if (eReligion != NO_RELIGION)
				{
					GetCityReligions()->ConvertPercentAllOtherFollowers(eReligion, pkEventChoiceInfo->ConvertsCityToPlayerReligion());
				}
			}
			if (pkEventChoiceInfo->ConvertsCityToPlayerMajorityReligion() != 0)
			{
				ReligionTypes eReligion = GET_PLAYER(getOwner()).GetReligions()->GetStateReligion();
				if (eReligion != NO_RELIGION)
				{
					GetCityReligions()->ConvertPercentAllOtherFollowers(eReligion, pkEventChoiceInfo->ConvertsCityToPlayerMajorityReligion());
				}
			}
			if (pkEventChoiceInfo->getResistanceTurns() != 0)
			{
				int iTurns = pkEventChoiceInfo->getResistanceTurns();
				iTurns *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iTurns /= 100;
				ChangeResistanceTurns(max(1, iTurns));
			}
			if (pkEventChoiceInfo->getWLTKD() != 0)
			{
				int iTurns = pkEventChoiceInfo->getWLTKD();
				iTurns *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iTurns /= 100;
				ChangeWeLoveTheKingDayCounter(max(1, iTurns));
			}
			if (pkEventChoiceInfo->getCityHappiness() != 0)
			{
				ChangeEventHappiness(pkEventChoiceInfo->getCityHappiness());
			}
			if (pkEventChoiceInfo->getBasicNeedsMedianModifier() != 0)
			{
				ChangeBasicNeedsMedianModifier(pkEventChoiceInfo->getBasicNeedsMedianModifier());
			}
			if (pkEventChoiceInfo->getGoldMedianModifier() != 0)
			{
				ChangeGoldMedianModifier(pkEventChoiceInfo->getGoldMedianModifier());
			}
			if (pkEventChoiceInfo->getScienceMedianModifier() != 0)
			{
				ChangeScienceMedianModifier(pkEventChoiceInfo->getScienceMedianModifier());
			}
			if (pkEventChoiceInfo->getCultureMedianModifier() != 0)
			{
				ChangeCultureMedianModifier(pkEventChoiceInfo->getCultureMedianModifier());
			}
			if (pkEventChoiceInfo->getReligiousUnrestModifier() != 0)
			{
				ChangeReligiousUnrestModifier(pkEventChoiceInfo->getReligiousUnrestModifier());
			}
			for (int iI = 0; iI < GC.getNumReligionInfos(); iI++)
			{
				ReligionTypes eReligion = (ReligionTypes)iI;
				if (eReligion == NO_RELIGION)
					continue;

				int iPercent = (ReligionTypes)pkEventChoiceInfo->getEventConvertReligionPercent(iI);
				if (iPercent > 0)
				{
					GetCityReligions()->ConvertPercentAllOtherFollowers(eReligion, iPercent);
				}
				int iPop = (ReligionTypes)pkEventChoiceInfo->getEventConvertReligion(iI);
				if (iPop > 0)
				{
					GetCityReligions()->ConvertNumberAllOtherFollowers(eReligion, iPop);
				}
			}
			if (pkEventChoiceInfo->getRandomBarbs() > 0)
			{
				// In hundreds
				int iNumRebels = pkEventChoiceInfo->getRandomBarbs();
				CvBarbarians::SpawnBarbarianUnits(plot(), iNumRebels, BARB_SPAWN_EVENT);
			}
			if (pkEventChoiceInfo->getFreeScaledUnits() > 0)
			{
				// In hundreds
				int iNumRecruits = pkEventChoiceInfo->getFreeScaledUnits();

				GC.getGame().DoSpawnUnitsAroundTargetCity(getOwner(), this, iNumRecruits, false, isCoastal(), false, false);
			}
			//Let's do our notification stuff here.
			for (int iI = 0; iI < pkEventChoiceInfo->GetNumNotifications(); iI++)
			{
				if (pkEventChoiceInfo->GetNotificationInfo(iI)->IsEspionageEvent())
					continue;

				CvString strNotificationString = pkEventChoiceInfo->GetNotificationInfo(iI)->GetNotificationString();
				if (strNotificationString != NULL && strNotificationString != "")
				{
					NotificationTypes eNotificationType = (NotificationTypes)FString::Hash(strNotificationString);

					if (eNotificationType != NO_NOTIFICATION_TYPE)
					{
						Localization::String strMessage;
						Localization::String strSummary;
						strSummary = Localization::Lookup(pkEventChoiceInfo->GetNotificationInfo(iI)->GetShortDescription());
						strSummary << GET_PLAYER(getOwner()).getCivilizationShortDescriptionKey();
						strSummary << getNameKey();
						strSummary << GET_PLAYER(getOwner()).getCivilizationDescription();
						strSummary << GET_PLAYER(getOwner()).getName();
						strMessage = Localization::Lookup(pkEventChoiceInfo->GetNotificationInfo(iI)->GetDescription());
						strMessage << GET_PLAYER(getOwner()).getCivilizationShortDescriptionKey();
						strMessage << getNameKey();
						strMessage << GET_PLAYER(getOwner()).getCivilizationDescription();
						strMessage << GET_PLAYER(getOwner()).getName();
						strMessage << GetScaledHelpText(eEventChoice, true, -1, NO_PLAYER);
						bool bGlobal = pkEventChoiceInfo->GetNotificationInfo(iI)->IsWorldEvent();
						int iX = -1;
						int iY = -1;
						int iVariable = pkEventChoiceInfo->GetNotificationInfo(iI)->GetVariable();
						if (pkEventChoiceInfo->GetNotificationInfo(iI)->IsNeedCityCoordinates())
						{
							iX = getX();
							iY = getY();
						}

						for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
						{
							PlayerTypes ePlayer = (PlayerTypes)iPlayerLoop;
							if (ePlayer != NO_PLAYER && GET_PLAYER(ePlayer).isMajorCiv())
							{
								//Not global? Skip all but me.
								if (!bGlobal && ePlayer != getOwner())
									continue;

								//Global? Seed only to known players.
								if (bGlobal && ePlayer != getOwner() && !GET_TEAM(GET_PLAYER(ePlayer).getTeam()).isHasMet(getTeam()))
									continue;

								//Send out notifications!
								CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();
								if (pNotifications && GC.getGame().getActivePlayer() == ePlayer)
								{
									if (pkEventChoiceInfo->GetNotificationInfo(iI)->IsNeedPlayerID())
									{
										pNotifications->Add(eNotificationType, strMessage.toUTF8(), strSummary.toUTF8(), iX, iY, getOwner(), GetID());
									}
									else
									{
										pNotifications->Add(eNotificationType, strMessage.toUTF8(), strSummary.toUTF8(), iX, iY, iVariable, GetID());
									}
								}
							}
						}
					}
				}
			}

			UpdateReligion(GetCityReligions()->GetReligiousMajority());

			//Some yield cleanup and refresh here - note that not all of this has to do with religion, however any time religion is updated, that's a good time to update the city's yields.
			for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				YieldTypes eYield = (YieldTypes)iI;
				if (eYield == NO_YIELD)
					continue;

				UpdateSpecialReligionYields(eYield);
				UpdateCityYields(eYield);
			}

			GET_PLAYER(getOwner()).CalculateNetHappiness();
			updateNetHappiness();
		}
	}
}
void CvCity::SetEventActive(CityEventTypes eEvent, bool bValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumCityEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	m_abEventActive[eEvent] = bValue;
}
bool CvCity::IsEventActive(CityEventTypes eEvent) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumCityEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	return m_abEventActive[eEvent];
}
void CvCity::SetEventChoiceActive(CityEventChoiceTypes eEventChoice, bool bValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEventChoice >= 0, "eEventChoice is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEventChoice < GC.getNumCityEventChoiceInfos(), "eEventChoice is expected to be within maximum bounds (invalid Index)");

	m_abEventChoiceActive[eEventChoice] = bValue;
}
bool CvCity::IsEventChoiceActive(CityEventChoiceTypes eEventChoice) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEventChoice >= 0, "eEventChoice is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEventChoice < GC.getNumCityEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	return m_abEventChoiceActive[eEventChoice];
}

void CvCity::SetEventChoiceFired(CityEventChoiceTypes eEvent, bool bValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumCityEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	m_abEventChoiceFired[eEvent] = bValue;
}
bool CvCity::IsEventChoiceFired(CityEventChoiceTypes eEvent) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumCityEventChoiceInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	return m_abEventChoiceFired[eEvent];
}
void CvCity::SetEventFired(CityEventTypes eEvent, bool bValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumCityEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	m_abEventFired[eEvent] = bValue;
}
bool CvCity::IsEventFired(CityEventTypes eEvent) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumCityEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");

	return m_abEventFired[eEvent];
}
int CvCity::GetEventCooldown(CityEventTypes eEvent) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumCityEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	return m_aiEventCooldown[eEvent];
}
void CvCity::ChangeEventCooldown(CityEventTypes eEvent, int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumCityEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	if (iValue != 0)
	{
		m_aiEventCooldown[eEvent] = m_aiEventCooldown[eEvent] + iValue;
	}
}
void CvCity::SetEventCooldown(CityEventTypes eEvent, int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eEvent >= 0, "eEvent is expected to be non-negative (invalid Index)");
	CvAssertMsg(eEvent < GC.getNumCityEventInfos(), "eEvent is expected to be within maximum bounds (invalid Index)");
	m_aiEventCooldown[eEvent] = iValue;
}
int CvCity::GetEventHappiness() const
{
	VALIDATE_OBJECT
	return m_iEventHappiness;
}
void CvCity::ChangeEventHappiness(int iValue)
{
	VALIDATE_OBJECT
	m_iEventHappiness += iValue;
}

int CvCity::maxXPValue() const
{
	VALIDATE_OBJECT
	int iMaxValue = MAX_INT; // negative values mean no XP limit, and MAX_INT is the same in effect

	if (isBarbarian())
	{
		iMaxValue = std::min(iMaxValue, /*30 in CP, 45 in VP*/ GD_INT_GET(BARBARIAN_MAX_XP_VALUE));
	}
	if (GET_PLAYER(getOwner()).isMinorCiv())
	{
		iMaxValue = std::min(iMaxValue, /*-1 in CP, 70 in VP*/ GD_INT_GET(MINOR_MAX_XP_VALUE));
	}

	if (MOD_BALANCE_CORE_SCALING_XP && iMaxValue > 0)
	{
		iMaxValue *= GC.getGame().getGameSpeedInfo().getTrainPercent();
		iMaxValue /= 100;
	}

	return iMaxValue;
}
#endif
//	--------------------------------------------------------------------------------
/// Connected to capital with industrial route? (Railroads)
bool CvCity::IsIndustrialRouteToCapitalConnected() const
{
	return m_bIndustrialRouteToCapital;
}

//	--------------------------------------------------------------------------------
/// Connected to capital with industrial route? (Railroads)
void CvCity::SetIndustrialRouteToCapitalConnected(bool bValue)
{
	m_bIndustrialRouteToCapital = bValue;
}

//	--------------------------------------------------------------------------------
void CvCity::SetRouteToCapitalConnected(bool bValue, bool bSuppressReligionUpdate)
{
	bool bUpdateReligion = !bSuppressReligionUpdate && (bValue != m_bRouteToCapitalConnectedThisTurn);

	//do this before the religion recalculation ...
	m_bRouteToCapitalConnectedThisTurn = bValue;

	if (bUpdateReligion)
	{
		UpdateReligion(GetCityReligions()->GetReligiousMajority());
	}
}

//	--------------------------------------------------------------------------------
bool CvCity::IsRouteToCapitalConnected(void) const
{
	return m_bRouteToCapitalConnectedThisTurn;
}


//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
void CvCity::createGreatGeneral(UnitTypes eGreatPersonUnit, bool bIsFree)
#else
void CvCity::createGreatGeneral(UnitTypes eGreatPersonUnit)
#endif
{
	VALIDATE_OBJECT
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
	GET_PLAYER(getOwner()).createGreatGeneral(eGreatPersonUnit, getX(), getY(), bIsFree);
#else
	GET_PLAYER(getOwner()).createGreatGeneral(eGreatPersonUnit, getX(), getY());
#endif
}

//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
void CvCity::createGreatAdmiral(UnitTypes eGreatPersonUnit, bool bIsFree)
#else
void CvCity::createGreatAdmiral(UnitTypes eGreatPersonUnit)
#endif
{
	VALIDATE_OBJECT
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
	GET_PLAYER(getOwner()).createGreatAdmiral(eGreatPersonUnit, getX(), getY(), bIsFree);
#else
	GET_PLAYER(getOwner()).createGreatAdmiral(eGreatPersonUnit, getX(), getY());
#endif
}

//	--------------------------------------------------------------------------------
CityTaskResult CvCity::doTask(TaskTypes eTask, int iData1, int iData2, bool bOption, bool bAlt, bool bShift, bool bCtrl)
{
	VALIDATE_OBJECT
	CityTaskResult eResult = TASK_COMPLETED;
	switch (eTask)
	{
	case TASK_RAZE:
		GET_PLAYER(getOwner()).raze(this);
		resetCaptureData();
		break;

	case TASK_UNRAZE:
		GET_PLAYER(getOwner()).unraze(this);
		break;

	case TASK_DISBAND:
		GET_PLAYER(getOwner()).disband(this);
		break;

	case TASK_GIFT:
		GET_PLAYER((PlayerTypes)iData1).acquireCity(this, false, true);
		break;

	case TASK_SET_AUTOMATED_CITIZENS:
		break;

	case TASK_SET_AUTOMATED_PRODUCTION:
		setProductionAutomated(bOption, bAlt && bShift && bCtrl);
		break;

	case TASK_SET_EMPHASIZE:
		m_pEmphases->SetEmphasize(((EmphasizeTypes)iData1), bOption);
		break;

	case TASK_NO_AUTO_ASSIGN_SPECIALISTS:
		GetCityCitizens()->SetNoAutoAssignSpecialists(bOption, true);
		break;

	case TASK_ADD_SPECIALIST:
		GetCityCitizens()->DoAddSpecialistToBuilding(/*eBuilding*/ (BuildingTypes)iData2, true, CvCity::YIELD_UPDATE_GLOBAL);
		break;

	case TASK_REMOVE_SPECIALIST:
	{
		GetCityCitizens()->DoRemoveSpecialistFromBuilding(/*eBuilding*/ (BuildingTypes)iData2, true, CvCity::YIELD_UPDATE_LOCAL);
		GetCityCitizens()->DoAddBestCitizenFromUnassigned(CvCity::YIELD_UPDATE_GLOBAL);
		break;
	}

	case TASK_UNSLOT_SPECIALIST:
	{
		GetCityCitizens()->DoRemoveSpecialistFromBuilding(/*eBuilding*/ (BuildingTypes)iData2, bOption, CvCity::YIELD_UPDATE_LOCAL);
		GetCityCitizens()->DoAddBestCitizenFromUnassigned(CvCity::YIELD_UPDATE_GLOBAL, false, true);
		break;
	}
	case TASK_RESET_SPECIALISTS:
	{
		GetCityCitizens()->SetNoAutoAssignSpecialists(false, true);
		break;
	}

	case TASK_CHANGE_WORKING_PLOT:
		GetCityCitizens()->DoAlterWorkingPlot(/*CityPlotIndex*/ iData1);
		break;

	case TASK_REMOVE_SLACKER:
		if (GetCityCitizens()->GetNumDefaultSpecialists() > 0)
		{
			GetCityCitizens()->ChangeNumDefaultSpecialists(-1, CvCity::YIELD_UPDATE_LOCAL);
			GetCityCitizens()->DoReallocateCitizens(true);
		}
		break;

	case TASK_CLEAR_WORKING_OVERRIDE:
		clearWorkingOverride(iData1);
		break;

	case TASK_HURRY:
		hurry((HurryTypes)iData1);
		break;

	case TASK_CONSCRIPT:
		conscript();
		break;

	case TASK_CLEAR_ORDERS:
		clearOrderQueue();
		break;

	case TASK_RALLY_PLOT:
		setRallyPlot(GC.getMap().plot(iData1, iData2));
		break;

	case TASK_CLEAR_RALLY_PLOT:
		setRallyPlot(NULL);
		break;

	case TASK_RANGED_ATTACK:
		eResult = rangeStrike(iData1, iData2);
		break;

	case TASK_CREATE_PUPPET:
		DoCreatePuppet();
		resetCaptureData();
		break;

	case TASK_ANNEX_PUPPET:
		DoAnnex();
		resetCaptureData();
		break;

	default:
		CvAssertMsg(false, "eTask failed to match a valid option");
		break;
	}

	return eResult;
}


//	--------------------------------------------------------------------------------
void CvCity::chooseProduction(UnitTypes eTrainUnit, BuildingTypes eConstructBuilding, ProjectTypes eCreateProject, bool /*bFinish*/, bool /*bFront*/)
{
	VALIDATE_OBJECT
	CvString strTooltip = GetLocalizedText("TXT_KEY_NOTIFICATION_NEW_CONSTRUCTION", getNameKey());
#if defined(MOD_BALANCE_CORE)
	if (IsRazing())
	{
		//No popup if razing.
		return;
	}
#endif
	CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
	if (pNotifications)
	{
		// Figure out what we just finished so we can package it into something the lua will understand
		OrderTypes eOrder = NO_ORDER;
		int iItemID = -1;

		if (eTrainUnit != NO_UNIT)
		{
			eOrder = ORDER_TRAIN;
			iItemID = eTrainUnit;
		}
		else if (eConstructBuilding != NO_BUILDING)
		{
			eOrder = ORDER_CONSTRUCT;
			iItemID = eConstructBuilding;
		}
		else if (eCreateProject != NO_PROJECT)
		{
			eOrder = ORDER_CREATE;
			iItemID = eCreateProject;
		}

		pNotifications->Add(NOTIFICATION_PRODUCTION, strTooltip, strTooltip, getX(), getY(), eOrder, iItemID);
	}
}

void CvCity::updateEconomicValue()
{
	//todo: take into account player personality
	int iYieldValue = 0;

	CvWeightedVector<int> validResources;

	//notes:
	//- economic value is in gold, so use a rough conversion factor for the others
	//- for food and gold only surplus is interesting, rest is converted to other yields already
	//- ignore trade, as the city might the change owner
	iYieldValue += (getYieldRateTimes100(YIELD_FOOD, true) - foodConsumptionTimes100()) * 3;
	iYieldValue += getYieldRateTimes100(YIELD_PRODUCTION, true) * 4;
	iYieldValue += getYieldRateTimes100(YIELD_SCIENCE, true) * 3;
	iYieldValue += (getYieldRateTimes100(YIELD_GOLD, true) - GetCityBuildings()->GetTotalBaseBuildingMaintenance() * 100) * 1;
	iYieldValue += getJONSCulturePerTurn() * 3;
	iYieldValue += GetFaithPerTurn() * 3;
	iYieldValue += getYieldRateTimes100(YIELD_TOURISM, true) * 3;
	iYieldValue += getYieldRateTimes100(YIELD_GOLDEN_AGE_POINTS, true) * 3;

	//divide by avg conversion factor
	iYieldValue /= 3;

	//arbitrary conversion factor ... yields are already covered?
	iYieldValue += getNumWorldWonders() * 23;

	//now check access to resources
	//todo: call CvDealAI::GetResourceValue() for each resource

	for (int iI = 0; iI < GetNumWorkablePlots(); iI++)
	{
		CvPlot* pLoopPlot = GetCityCitizens()->GetCityPlotFromIndex(iI);
		if (!pLoopPlot)
			continue;

		ResourceTypes eResource = pLoopPlot->getResourceType(getTeam());
		if (eResource == NO_RESOURCE)
			continue;

		//for plots owned by this city or reasonably likely to be claimed
		bool bGood = false;
		if (pLoopPlot->isOwned())
			bGood = (GetID() == pLoopPlot->getOwningCityID());
		else
			bGood = pLoopPlot->isAdjacentPlayer(getOwner()) && !pLoopPlot->IsAdjacentOwnedByTeamOtherThan(getTeam());

		if (bGood)
		{
			const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);
			if (!pkResourceInfo)
				continue;

			validResources.push_back(eResource, pLoopPlot->getNumResource());
		}
	}

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes ePossibleOwner = (PlayerTypes)iPlayerLoop;
		m_aiEconomicValue[iPlayerLoop] = 0; //everybody gets a new value

		if (ePossibleOwner != NO_PLAYER && GET_PLAYER(ePossibleOwner).isAlive())
		{
			int iResourceValue = 0;
			if (validResources.size() > 0)
			{
				for (int iResourceLoop = 0; iResourceLoop < validResources.size(); iResourceLoop++)
				{
					//todo: add something for currently unworked plots (future potential)
					ResourceTypes eResource = (ResourceTypes)validResources.GetElement(iResourceLoop);
					if (eResource == NO_RESOURCE)
						continue;

					if (GET_TEAM(GET_PLAYER(ePossibleOwner).getTeam()).IsResourceObsolete(eResource))
						continue;

					const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);
					if (!pkResourceInfo)
						continue;

					int iResourceQuantity = validResources.GetWeight(iResourceLoop);
					if (iResourceQuantity > 0)
					{
						ResourceUsageTypes eUsage = pkResourceInfo->getResourceUsage();
						if (eUsage == RESOURCEUSAGE_LUXURY)
						{
							int iValue = 200;

							if (GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(getOwner(), eResource))
								iValue = 100;

							// If the new owner doesn't have it or the old owner would lose it completely, it's worth more
							if ((GET_PLAYER(ePossibleOwner).getNumResourceAvailable(eResource) == 0) ||
								(GET_PLAYER(getOwner()).getNumResourceAvailable(eResource) == iResourceQuantity) ||
								(GET_PLAYER(ePossibleOwner).WouldGainMonopoly(eResource, iResourceQuantity)))
								iValue = 600;

							int iHappinessFromResource = pkResourceInfo->getHappiness() + GET_PLAYER(ePossibleOwner).GetExtraHappinessPerLuxury();
							iResourceValue += iResourceQuantity * iHappinessFromResource * iValue;
						}
						else if (eUsage == RESOURCEUSAGE_STRATEGIC)
						{
							int iValue = 400;

							// If the new owner doesn't have it or the old owner would lose it completely, it's worth more
							if ((GET_PLAYER(ePossibleOwner).getNumResourceAvailable(eResource) == 0) ||
								(GET_PLAYER(getOwner()).getNumResourceAvailable(eResource) == iResourceQuantity) ||
								(GET_PLAYER(ePossibleOwner).WouldGainMonopoly(eResource, iResourceQuantity)))
								iValue = 800;

							iResourceValue += iResourceQuantity * iValue;
						}
					}
				}
			}

			m_aiEconomicValue[ePossibleOwner] = iYieldValue + iResourceValue;
		}
	}
}

int CvCity::getEconomicValue(PlayerTypes ePossibleOwner)
{
	if (ePossibleOwner == NO_PLAYER || ePossibleOwner >= MAX_CIV_PLAYERS)
		return 0;

	if ((int)m_aiEconomicValue.size() <= ePossibleOwner)
		updateEconomicValue();

	return m_aiEconomicValue[ePossibleOwner];
}

void CvCity::setEconomicValue(PlayerTypes ePossibleOwner, int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(ePossibleOwner >= 0, "ePossibleOwner expected to be >= 0");
	CvAssertMsg(ePossibleOwner < MAX_CIV_PLAYERS, "ePossibleOwner expected to be < MAX_CIV_PLAYERS");
	m_aiEconomicValue[ePossibleOwner] = iValue;
}

 /// Keeps track of local instant yield. use this in conjunction with getGameTurnFounded() to get an average
 void CvCity::ChangeInstantYieldTotal(YieldTypes eYield, int iValue)
 {
	VALIDATE_OBJECT;
	m_miInstantYieldsTotal[eYield] += iValue;
 }
 
 int CvCity::GetInstantYieldTotal(YieldTypes eYield)
 {
	 return m_miInstantYieldsTotal[eYield];
 }

int CvCity::GetContestedPlotScore(PlayerTypes eOtherPlayer) const
{
	TeamTypes eOtherTeam = (eOtherPlayer == NO_PLAYER) ? NO_TEAM : GET_PLAYER(eOtherPlayer).getTeam();

	int iCounter = 0;
	int iRange = range(getWorkPlotDistance(), 1, 5);

	for (int i = RING0_PLOTS; i < RING_PLOTS[iRange]; i++)
	{
		CvPlot* pPlot = iterateRingPlots(plot(), i);
		if (!pPlot || !pPlot->isOwned() || pPlot->getOwningCity() == NULL)
			continue;

		int iWeight = 1;
		if (i < RING1_PLOTS)
			iWeight = 3;
		else if (i < RING2_PLOTS)
			iWeight = 2;

		bool bRelevant = false;
		if (eOtherTeam == NO_TEAM && pPlot->getTeam() != getTeam())
			bRelevant = true;
		if (eOtherTeam != NO_TEAM && pPlot->getTeam() == eOtherTeam)
			bRelevant = true;

		if (bRelevant && pPlot->hasYield())
			iCounter += iWeight;
	}

	return iCounter;
}

#if defined(MOD_BALANCE_CORE_SPIES_ADVANCED)

void CvCity::SetEspionageRanking(int iValue)
{
	VALIDATE_OBJECT
	m_iCitySpyRank = iValue;
	CvAssert(GetEspionageRanking() >= 0);
}
void CvCity::SetTurnsSinceLastRankMessage(int iTurns)
{
	VALIDATE_OBJECT
	m_iTurnsSinceRankAnnouncement = iTurns;
	CvAssert(GetTurnsSinceLastRankMessage() >= 0);
}
int CvCity::GetTurnsSinceLastRankMessage() const
{
	VALIDATE_OBJECT
	return m_iTurnsSinceRankAnnouncement;
}
void CvCity::ChangeTurnsSinceLastRankMessage(int iTurns)
{
	VALIDATE_OBJECT
	SetTurnsSinceLastRankMessage(GetTurnsSinceLastRankMessage() + iTurns);
}
int CvCity::GetEspionageRanking() const
{
	VALIDATE_OBJECT
	return m_iCitySpyRank;
}

CvString CvCity::GetSpyMissionOutcome(CityEventChoiceTypes eEventChoice, uint iSpyIndex, PlayerTypes ePlayer, bool bOwnSpy, bool bShowPopup) {
	CvString strSpyResult = "";
	CvEspionageSpy* pSpy = GET_PLAYER(ePlayer).GetEspionage()->GetSpyByID(iSpyIndex);
	if (!pSpy)
		return strSpyResult;
	CvModEventCityChoiceInfo* pkEventChoiceInfo = GC.getCityEventChoiceInfo(eEventChoice);
	if (pkEventChoiceInfo == NULL)
		return strSpyResult;

	if (bShowPopup)
	{
		strSpyResult += pSpy->GetLastMissionOutcome(); // Detection Status
		strSpyResult += "[NEWLINE]";
		CvString strMissionDetails = GetScaledHelpText(eEventChoice, false, iSpyIndex, ePlayer, true);
		strSpyResult += GetLocalizedText("TXT_KEY_SPY_MISSION", strMissionDetails);
	}
	else
	{
		int iDuration = pkEventChoiceInfo->getEspionageMissionDuration();
		iDuration *= GC.getGame().getGameSpeedInfo().getSpyRatePercent();
		iDuration /= 100;

		strSpyResult += pkEventChoiceInfo->GetDescription();
		strSpyResult += ".";
		CvString strSiphonHistory = pSpy->GetSiphonHistory();
		if (strSiphonHistory != "")
		{
			strSpyResult += "[NEWLINE]";
			Localization::String localizedDurationText;
			localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_YIELD_DURATION");
			localizedDurationText << iDuration;
			const char* const localized = localizedDurationText.toUTF8();
			Localization::String localizedSiphonText;
			localizedSiphonText = bOwnSpy ? Localization::Lookup("TXT_KEY_ESPIONAGE_EVENT_YIELD_SIPHON_PAST") : Localization::Lookup("TXT_KEY_ESPIONAGE_EVENT_YIELD_SIPHON_PAST_ENEMY");
			localizedSiphonText << strSiphonHistory;
			localizedSiphonText << localized;
			strSpyResult += localizedSiphonText.toUTF8();
		}
		else if (pkEventChoiceInfo->getSpyVisionDuration() > 0)
		{
			iDuration = pkEventChoiceInfo->getSpyVisionDuration();
			iDuration *= GC.getGame().getGameSpeedInfo().getSpyRatePercent();
			iDuration /= 100;
			Localization::String localizedDurationText;
			localizedDurationText = Localization::Lookup("TXT_KEY_EVENT_YIELD_SCALED_NOTIFICATION_TURNS");
			localizedDurationText << iDuration;
			strSpyResult += localizedDurationText.toUTF8();
		}
	}
	return strSpyResult;
}
int CvCity::GetSpyTurnsToCompleteMission(PlayerTypes ePlayer, CityEventChoiceTypes eEventChoice, uint iSpyIndex, int iProgress) const
{
	CvEspionageSpy* pSpy = GET_PLAYER(ePlayer).GetEspionage()->GetSpyByID(iSpyIndex);
	if (!pSpy)
		return 30;

	CvModEventCityChoiceInfo* pkEventChoiceInfo = GC.getCityEventChoiceInfo(eEventChoice == NO_EVENT_CHOICE_CITY ? pSpy->m_eSpyFocus : eEventChoice);
	if (pkEventChoiceInfo == NULL)
		//basic value?
		return 30;

	//TURNS!
	int iStandardMissionDuration = pkEventChoiceInfo->getEspionageMissionDuration();
	iStandardMissionDuration *= GC.getGame().getGameSpeedInfo().getSpyRatePercent();
	iStandardMissionDuration /= 100;

	/* Spy Level*/
	int iDurationModifier = 100;
	if (pSpy->GetSpyRank(ePlayer) == 1)
	{
		iDurationModifier += GD_INT_GET(ESPIONAGE_MODIFIER_SPY_LEVEL_AGENT);
	}
	else if (pSpy->GetSpyRank(ePlayer) >= 2)
	{
		iDurationModifier += GD_INT_GET(ESPIONAGE_MODIFIER_SPY_LEVEL_SPECIAL_AGENT);
	}
	iDurationModifier += GET_PLAYER(ePlayer).GetPlayerTraits()->GetEspionageModifier();

	int iMissionDuration = iStandardMissionDuration * iDurationModifier;
	iMissionDuration /= 100;

	/* Building and Policies */
	iMissionDuration += GET_PLAYER(ePlayer).GetEspionageTurnsModifierFriendly();
	iMissionDuration += GET_PLAYER(getOwner()).GetEspionageTurnsModifierEnemy();
	iMissionDuration += GetEspionageTurnsModifierEnemy();

	iMissionDuration = range(iMissionDuration, iStandardMissionDuration * 2 / 3, iStandardMissionDuration * 4 / 3);

	if (iProgress == 0)
		return iMissionDuration;

	return iMissionDuration - iProgress;
}
CvString CvCity::GetMissionDurationText(PlayerTypes ePlayer, CityEventChoiceTypes eEventChoice, uint iSpyIndex, int iProgress) const
{
	CvString durationTip = "";
	CvEspionageSpy* pSpy = GET_PLAYER(ePlayer).GetEspionage()->GetSpyByID(iSpyIndex);
	if (!pSpy)
		return "";

	CvModEventCityChoiceInfo* pkEventChoiceInfo = GC.getCityEventChoiceInfo(eEventChoice == NO_EVENT_CHOICE_CITY ? pSpy->m_eSpyFocus : eEventChoice);
	if (pkEventChoiceInfo == NULL)
		//basic value?
		return "";

	int iStandardDuration = pkEventChoiceInfo->getEspionageMissionDuration();
	iStandardDuration *= GC.getGame().getGameSpeedInfo().getSpyRatePercent();
	iStandardDuration /= 100;
	durationTip += GetLocalizedText("TXT_KEY_ESPIONAGE_MISSION_BASE_DURATION", iStandardDuration);

	/* Spy Level*/
	int iDurationModifier = 0;
	if (pSpy->GetSpyRank(ePlayer) == 1)
	{
		iDurationModifier += GD_INT_GET(ESPIONAGE_MODIFIER_SPY_LEVEL_AGENT);
	}
	else if (pSpy->GetSpyRank(ePlayer) >= 2)
	{
		iDurationModifier += GD_INT_GET(ESPIONAGE_MODIFIER_SPY_LEVEL_SPECIAL_AGENT);
	}
	if (iDurationModifier != 0)
	{
		Localization::String tmpStr;
		tmpStr = Localization::Lookup("TXT_KEY_SPY_DURATION_LEVEL_MODIFIER");
		tmpStr << iDurationModifier;
		durationTip += tmpStr.toUTF8();
	}

	/* England */
	iDurationModifier = GET_PLAYER(ePlayer).GetPlayerTraits()->GetEspionageModifier();
	if (iDurationModifier != 0)
	{
		Localization::String tmpStr;
		tmpStr = Localization::Lookup("TXT_KEY_SPY_DURATION_TRAIT_MODIFIER");
		tmpStr << iDurationModifier;
		durationTip += tmpStr.toUTF8();
	}
	/* Building and Policies */
	int iTurnsModifierFriendly = GET_PLAYER(ePlayer).GetEspionageTurnsModifierFriendly();
	if (iTurnsModifierFriendly != 0)
	{
		Localization::String tmpStr;
		durationTip += "[NEWLINE]";
		tmpStr = Localization::Lookup("TXT_KEY_SPY_MISSION_TURN_MODIFIER_FRIENDLY");
		tmpStr << (iTurnsModifierFriendly * -1);
		durationTip += tmpStr.toUTF8();
	}
	int iTurnsModifierEnemy = GET_PLAYER(getOwner()).GetEspionageTurnsModifierEnemy() + GetEspionageTurnsModifierEnemy();
	if (iTurnsModifierEnemy != 0)
	{
		Localization::String tmpStr;
		durationTip += "[NEWLINE]";
		tmpStr = Localization::Lookup("TXT_KEY_SPY_MISSION_TURN_MODIFIER_ENEMY");
		tmpStr << iTurnsModifierEnemy;
		durationTip += tmpStr.toUTF8();
	}

	Localization::String localizedDurationText;
	localizedDurationText = Localization::Lookup("TXT_KEY_ESPIONAGE_MISSION_DURATION");
	int iTotalMissionDuration = GetSpyTurnsToCompleteMission(ePlayer, eEventChoice, iSpyIndex, 0);
	localizedDurationText << iTotalMissionDuration;
	const char* const localizedDuration = localizedDurationText.toUTF8();
	if (localizedDuration)
	{
		durationTip += "[NEWLINE]";
		durationTip += localizedDuration;
	}
	if (iProgress > 0)
	{
		durationTip += " ";
		durationTip += GetLocalizedText("TXT_KEY_ESPIONAGE_TURNS_COMPLETED", iProgress);
	}
	return durationTip;
}
void CvCity::ChangeEspionageRanking(int iAmount, bool bNotify)
{
	int iNewRank = m_iCitySpyRank + iAmount;

	if (bNotify)
	{
		if (GetTurnsSinceLastRankMessage() >= GD_INT_GET(BALANCE_SPY_SABOTAGE_RATE) * 2)
		{
			if (iNewRank < GetEspionageRanking() && GetEspionageRanking() < 600 && GetEspionageRanking() > 100)
			{
				CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
				if (pNotifications)
				{
					int iNewRankNotification = iNewRank / 20;
					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_RANK_INCREASING_SUMMARY");
					strSummary << getNameKey();
					Localization::String strNotification = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_RANK_INCREASING");
					strNotification << getNameKey();
					strNotification << iNewRankNotification;
					pNotifications->Add(NOTIFICATION_SPY_YOU_STAGE_COUP_FAILURE, strNotification.toUTF8(), strSummary.toUTF8(), getX(), getY(), -1);
				}
				if (GC.getLogging())
				{
					CvString strMsg;
					strMsg.Format("Advanced Action: Sent out Rank warning. Rank: %d,", iNewRank);
					strMsg += " , ";
					strMsg += GET_PLAYER(getOwner()).getCivilizationShortDescription();
					strMsg += " , ";
					strMsg += getName();
					GET_PLAYER(getOwner()).GetEspionage()->LogEspionageMsg(strMsg);
				}
				SetTurnsSinceLastRankMessage(0);
			}
		}
		else
		{
			if (GetTurnsSinceLastRankMessage() <= 0)
			{
				SetTurnsSinceLastRankMessage(0);
			}
			ChangeTurnsSinceLastRankMessage(1);
		}
	}
	
	m_iCitySpyRank = iNewRank;

	//limiters
	if (m_iCitySpyRank <= 100)
		m_iCitySpyRank = 100;
	if (m_iCitySpyRank >= /*1000*/ GD_INT_GET(ESPIONAGE_SPY_RESISTANCE_MAXIMUM))
		m_iCitySpyRank = GD_INT_GET(ESPIONAGE_SPY_RESISTANCE_MAXIMUM);
}
void CvCity::ResetEspionageRanking()
{
	m_iCitySpyRank = !MOD_BALANCE_CORE_SPIES_ADVANCED ? 10 : /*1000*/ GD_INT_GET(ESPIONAGE_SPY_RESISTANCE_MAXIMUM);
	if (GC.getLogging())
	{
		CvString strMsg;
		strMsg.Format("Advanced Action: Rank reset to max level after spy event.");
		strMsg += " , ";
		strMsg += GET_PLAYER(getOwner()).getCivilizationShortDescription();
		strMsg += " , ";
		strMsg += getName();
		GET_PLAYER(getOwner()).GetEspionage()->LogEspionageMsg(strMsg);
	}
}
void CvCity::InitEspionageRanking()
{
	m_iCitySpyRank = !MOD_BALANCE_CORE_SPIES_ADVANCED ? 10 : /*1000*/ GD_INT_GET(ESPIONAGE_SPY_RESISTANCE_MAXIMUM);

	if (GC.getLogging())
	{
		CvString strMsg;
		strMsg.Format("Advanced Action: Rank initialized to max.");
		strMsg += " , ";
		strMsg += GET_PLAYER(getOwner()).getCivilizationShortDescription();
		strMsg += " , ";
		strMsg += getName();
		GET_PLAYER(getOwner()).GetEspionage()->LogEspionageMsg(strMsg);
	}
}
#endif

//	--------------------------------------------------------------------------------
/// How far out this city may buy plots
int CvCity::getBuyPlotDistance() const
{
	int iDistance = GET_PLAYER(getOwner()).getBuyPlotDistance();

	iDistance = std::min(MAX_CITY_RADIUS, std::max(getWorkPlotDistance(), iDistance));
	return iDistance;
}

//	--------------------------------------------------------------------------------
/// How far out this city may buy/work plots
int CvCity::getWorkPlotDistance(int iChange) const
{
	int iDistance = GET_PLAYER(getOwner()).getWorkPlotDistance();

	// Change distance based on buildings/wonders in this city
	iDistance += GetCityWorkingChange();

	iDistance = std::min(MAX_CITY_RADIUS, std::max(MIN_CITY_RADIUS, iDistance + iChange));
	return iDistance;
}

//	--------------------------------------------------------------------------------
/// How many plots this city may work
int CvCity::GetNumWorkablePlots(int iChange) const
{
	int iWorkablePlots = ((6 * (1 + getWorkPlotDistance(iChange)) * getWorkPlotDistance(iChange) / 2) + 1);
	return iWorkablePlots;
}

bool CvCity::IsWithinWorkRange(CvPlot * pPlot) const
{
	if (pPlot)
	{
		int iDistance = plotDistance(pPlot->getX(), pPlot->getY(), getX(), getY());
		return iDistance <= getWorkPlotDistance();
	}

	return false;
}

//	--------------------------------------------------------------------------------
void CvCity::clearWorkingOverride(int iIndex)
{
	VALIDATE_OBJECT
	CvPlot* pPlot = GetCityCitizens()->GetCityPlotFromIndex(iIndex);

	if (pPlot != NULL)
	{
		pPlot->setOwningCityOverride(NULL);
	}
}


//	--------------------------------------------------------------------------------
int CvCity::countNumImprovedPlots(ImprovementTypes eImprovement) const
{
	VALIDATE_OBJECT
	int iCount = 0;

	CvCityCitizens* pCityCitizens = GetCityCitizens();
	for (int iI = 0; iI < GetNumWorkablePlots(); iI++)
	{
		CvPlot* pLoopPlot = pCityCitizens->GetCityPlotFromIndex(iI);
		if (pLoopPlot != NULL)
		{
			if (!GetCityCitizens()->IsCanWork(pLoopPlot))
			{
				if (eImprovement != NO_IMPROVEMENT)
				{
					if (pLoopPlot->getImprovementType() == eImprovement && !pLoopPlot->IsImprovementPillaged())
					{
						++iCount;
					}
				}
				else if (pLoopPlot->getImprovementType() != NO_IMPROVEMENT && !pLoopPlot->IsImprovementPillaged())
				{
					iCount++;
				}
			}
		}
	}

	return iCount;
}

//	--------------------------------------------------------------------------------
int CvCity::countNumImprovablePlots(ImprovementTypes eImprovement, DomainTypes eDomain) const
{
	VALIDATE_OBJECT
	int iCount = 0;

	CvCityCitizens* pCityCitizens = GetCityCitizens();
	for (int iI = 0; iI < GetNumWorkablePlots(); iI++)
	{
		CvPlot* pLoopPlot = pCityCitizens->GetCityPlotFromIndex(iI);
		if (pLoopPlot != NULL && !pLoopPlot->isCity() && (eDomain == NO_DOMAIN || pLoopPlot->getDomain() == eDomain))
		{
			if (GetCityCitizens()->IsCanWork(pLoopPlot))
			{
				if (pLoopPlot->getImprovementType() == NO_IMPROVEMENT || pLoopPlot->IsImprovementPillaged())
				{
					if (eImprovement != NO_IMPROVEMENT)
					{
						if (pLoopPlot->canHaveImprovement(eImprovement, getOwner()))
						{
							++iCount;
						}
					}
					else if (pLoopPlot->getDomain() == DOMAIN_LAND || (pLoopPlot->getDomain() == DOMAIN_SEA && pLoopPlot->getResourceType(getTeam()) != NO_RESOURCE))
					{
						++iCount;
					}
				}
			}
		}
	}

	return iCount;
}

//	--------------------------------------------------------------------------------
int CvCity::countNumWaterPlots() const
{
	VALIDATE_OBJECT
	int iCount = 0;

	CvCityCitizens* pCityCitizens = GetCityCitizens();
	for (int iI = 0; iI < GetNumWorkablePlots(); iI++)
	{
		CvPlot* pLoopPlot = pCityCitizens->GetCityPlotFromIndex(iI);
		if (pLoopPlot != NULL)
		{
			if (pLoopPlot->isWater())
			{
				if (GetCityCitizens()->IsCanWork(pLoopPlot))
				{
					iCount++;
				}
			}
		}
	}

	return iCount;
}

//	--------------------------------------------------------------------------------
int CvCity::countNumRiverPlots() const
{
	VALIDATE_OBJECT
	int iCount = 0;

	CvCityCitizens* pCityCitizens = GetCityCitizens();
	for (int iI = 0; iI < GetNumWorkablePlots(); iI++)
	{
		CvPlot* pLoopPlot = pCityCitizens->GetCityPlotFromIndex(iI);

		if (pLoopPlot != NULL)
		{
			if (pLoopPlot->isRiver())
			{
				if (GetCityCitizens()->IsCanWork(pLoopPlot))
				{
					++iCount;
				}
			}
		}
	}

	return iCount;
}

//	--------------------------------------------------------------------------------
int CvCity::countNumForestPlots() const
{
	VALIDATE_OBJECT
	int iCount = 0;
	for (int iI = 0; iI < GetNumWorkablePlots(); iI++)
	{
		CvPlot* pLoopPlot = GetCityCitizens()->GetCityPlotFromIndex(iI);

		if (pLoopPlot != NULL)
		{
			if (pLoopPlot->getFeatureType() == FEATURE_FOREST)
			{
				if (GetCityCitizens()->IsCanWork(pLoopPlot))
				{
					++iCount;
				}
			}
		}
	}

	return iCount;
}

//	--------------------------------------------------------------------------------
int CvCity::findPopulationRank()
{
	VALIDATE_OBJECT
	if (!m_bPopulationRankValid)
	{
		int iRank = 1;
		int iLoop = 0;
		for (CvCity* pLoopCity = GET_PLAYER(getOwner()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(getOwner()).nextCity(&iLoop))
		{
			if ((pLoopCity->getPopulation() > getPopulation()) ||
				((pLoopCity->getPopulation() == getPopulation()) && (pLoopCity->GetID() < GetID())))
			{
				iRank++;
			}
		}

		// shenanigans are to get around the const check
		m_bPopulationRankValid = true;
		m_iPopulationRank = iRank;
	}

	return m_iPopulationRank;
}


//	--------------------------------------------------------------------------------
int CvCity::findBaseYieldRateRank(YieldTypes eYield)
{
	VALIDATE_OBJECT
	if (!m_abBaseYieldRankValid[eYield])
	{
		int iRate = getBaseYieldRate(eYield);
		int iRank = 1;
		int iLoop = 0;
		for (CvCity* pLoopCity = GET_PLAYER(getOwner()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(getOwner()).nextCity(&iLoop))
		{
			if ((pLoopCity->getBaseYieldRate(eYield) > iRate) ||
				((pLoopCity->getBaseYieldRate(eYield) == iRate) && (pLoopCity->GetID() < GetID())))
			{
				iRank++;
			}
		}

		m_abBaseYieldRankValid[eYield] = true;
		m_aiBaseYieldRank[eYield] = iRank;
	}

	return m_aiBaseYieldRank[eYield];
}


//	--------------------------------------------------------------------------------
int CvCity::findYieldRateRank(YieldTypes eYield)
{
	if (!m_abYieldRankValid[eYield])
	{
		int iRate = getYieldRateTimes100(eYield, false);
		int iRank = 1;
		int iLoop = 0;
		for (CvCity* pLoopCity = GET_PLAYER(getOwner()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(getOwner()).nextCity(&iLoop))
		{
			if ((pLoopCity->getYieldRateTimes100(eYield, false) > iRate) ||
				((pLoopCity->getYieldRateTimes100(eYield, false) == iRate) && (pLoopCity->GetID() < GetID())))
			{
				iRank++;
			}
		}

		m_abYieldRankValid[eYield] = true;
		m_aiYieldRank[eYield] = iRank;
	}

	return m_aiYieldRank[eYield];
}


//	--------------------------------------------------------------------------------
// Returns one of the upgrades...
UnitTypes CvCity::allUpgradesAvailable(UnitTypes eUnit, int iUpgradeCount) const
{
	VALIDATE_OBJECT
	UnitTypes eUpgradeUnit;
	bool bUpgradeFound = false;
	bool bUpgradeAvailable = false;
	bool bUpgradeUnavailable = false;

	CvAssertMsg(eUnit != NO_UNIT, "eUnit is expected to be assigned (not NO_UNIT)");

	CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
	if (pkUnitInfo == NULL)
		return NO_UNIT;

	if (iUpgradeCount > GC.getNumUnitClassInfos())
	{
		return NO_UNIT;
	}

	eUpgradeUnit = NO_UNIT;

	bUpgradeFound = false;
	bUpgradeAvailable = false;
	bUpgradeUnavailable = false;

	for (int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
	{
		const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
		CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
		if (pkUnitClassInfo)
		{
			if (pkUnitInfo->GetUpgradeUnitClass(iI))
			{
				const UnitTypes eLoopUnit = GET_PLAYER(getOwner()).GetSpecificUnitType(eUnitClass);

				if (eLoopUnit != NO_UNIT)
				{
					bUpgradeFound = true;

					const UnitTypes eTempUnit = allUpgradesAvailable(eLoopUnit, (iUpgradeCount + 1));

					if (eTempUnit != NO_UNIT)
					{
						eUpgradeUnit = eTempUnit;
						bUpgradeAvailable = true;
					}
					else
					{
						bUpgradeUnavailable = true;
					}
				}
			}
			if (GET_PLAYER(getOwner()).GetPlayerTraits()->HasSpecialUnitUpgrade(eUnitClass, eUnit))
			{
				const UnitTypes eLoopUnit = GET_PLAYER(getOwner()).GetSpecificUnitType(eUnitClass);

				if (eLoopUnit != NO_UNIT)
				{
					bUpgradeFound = true;

					const UnitTypes eTempUnit = allUpgradesAvailable(eLoopUnit, (iUpgradeCount + 1));

					if (eTempUnit != NO_UNIT)
					{
						eUpgradeUnit = eTempUnit;
						bUpgradeAvailable = true;
					}
					else
					{
						bUpgradeUnavailable = true;
					}
				}
			}
		}
	}

	if (iUpgradeCount > 0)
	{
		if (bUpgradeFound && bUpgradeAvailable)
		{
			CvAssertMsg(eUpgradeUnit != NO_UNIT, "eUpgradeUnit is expected to be assigned (not NO_UNIT)");
			return eUpgradeUnit;
		}

		if (canTrain(eUnit, false, false, false, true))
		{
			return eUnit;
		}
	}
	else
	{
		if (bUpgradeFound && !bUpgradeUnavailable)
		{
			return eUpgradeUnit;
		}
	}

	return NO_UNIT;
}


//	--------------------------------------------------------------------------------
bool CvCity::isWorldWondersMaxed() const
{
	VALIDATE_OBJECT
	if (GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && isHuman())
	{
		return false;
	}

	if (/*-1*/ GD_INT_GET(MAX_WORLD_WONDERS_PER_CITY) == -1)
	{
		return false;
	}

	if (getNumWorldWonders() >= GD_INT_GET(MAX_WORLD_WONDERS_PER_CITY))
	{
		return true;
	}

	return false;
}


//	--------------------------------------------------------------------------------
bool CvCity::isTeamWondersMaxed() const
{
	VALIDATE_OBJECT
	if (GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && isHuman())
	{
		return false;
	}

	if (/*-1*/ GD_INT_GET(MAX_TEAM_WONDERS_PER_CITY) == -1)
	{
		return false;
	}

	if (getNumTeamWonders() >= GD_INT_GET(MAX_TEAM_WONDERS_PER_CITY))
	{
		return true;
	}

	return false;
}


//	--------------------------------------------------------------------------------
bool CvCity::isNationalWondersMaxed() const
{
	VALIDATE_OBJECT
	int iMaxNumWonders = (GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && isHuman()) ? /*-1*/ GD_INT_GET(MAX_NATIONAL_WONDERS_PER_CITY_FOR_OCC) : /*-1*/ GD_INT_GET(MAX_NATIONAL_WONDERS_PER_CITY);

	if (iMaxNumWonders == -1)
	{
		return false;
	}

	if (getNumNationalWonders() >= iMaxNumWonders)
	{
		return true;
	}

	return false;
}


//	--------------------------------------------------------------------------------
bool CvCity::isBuildingsMaxed() const
{
	VALIDATE_OBJECT
	if (/*-1*/ GD_INT_GET(MAX_BUILDINGS_PER_CITY) == -1)
	{
		return false;
	}

	if (GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && isHuman())
	{
		return false;
	}

	if (m_pCityBuildings->GetNumBuildings() >= GD_INT_GET(MAX_BUILDINGS_PER_CITY))
	{
		return true;
	}

	return false;
}


//	--------------------------------------------------------------------------------
bool CvCity::hasBuildingPrerequisites(BuildingTypes eBuilding) const
{
	VALIDATE_OBJECT
	if (eBuilding == NO_BUILDING)
	{
		return false;
	}

	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if (pkBuildingInfo == NULL)
	{
		return false;
	}

	const CvCivilizationInfo& thisCivInfo = *GC.getCivilizationInfo(getCivilizationType());

	// Does this city have prereq buildings?
	for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
	{
		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo((BuildingClassTypes)iI);
		if (!pkBuildingClassInfo)
		{
			continue;
		}

		BuildingTypes ePrereqBuilding = ((BuildingTypes)(thisCivInfo.getCivilizationBuildings(iI)));

		if (pkBuildingInfo->IsBuildingClassNeededInCity(iI))
		{
			//Exception for new Rome UA, because civ type doesn't help you here.
			//Also use this if the option to check for all buildings in a class is enabled.
			if (MOD_BUILDINGS_THOROUGH_PREREQUISITES)
			{
				if (!HasBuildingClass((BuildingClassTypes)iI))
				{
					return false;
				}
			}
			else if (ePrereqBuilding != NO_BUILDING)
			{
				if (0 == m_pCityBuildings->GetNumBuilding(ePrereqBuilding) /* && (bContinue || (getFirstBuildingOrder(ePrereqBuilding) == -1))*/)
				{
					return false;
				}
			}
		}

		if (MOD_BALANCE_CORE)
		{
			if (pkBuildingInfo->IsBuildingClassNeededAnywhere(iI))
			{
				bool bHasBuildingClass = false;

				//Exception if the option to check for all buildings in a class is enabled.
				if (MOD_BUILDINGS_THOROUGH_PREREQUISITES)
				{
					int iLoop = 0;
					for (CvCity* pLoopCity = GET_PLAYER(getOwner()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(getOwner()).nextCity(&iLoop))
					{
						if (pLoopCity->HasBuildingClass((BuildingClassTypes)iI))
						{
							bHasBuildingClass = true;
							break;
						}
					}
					if (bHasBuildingClass == false)
					{
						return false;
					}
				}
				else if (ePrereqBuilding != NO_BUILDING)
				{
					int iLoop = 0;
					for (CvCity* pLoopCity = GET_PLAYER(getOwner()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(getOwner()).nextCity(&iLoop))
					{
						if (pLoopCity->GetCityBuildings()->GetNumBuilding(ePrereqBuilding) > 0)
						{
							bHasBuildingClass = true;
							break;
						}
					}
					if (bHasBuildingClass == false)
					{
						return false;
					}
				}
			}
			// Does this city have prereq buildings?
			if (pkBuildingInfo->IsBuildingClassNeededNowhere(iI))
			{
				//Exception if the option to check for all buildings in a class is enabled.
				if (MOD_BUILDINGS_THOROUGH_PREREQUISITES)
				{
					int iLoop = 0;
					for (CvCity* pLoopCity = GET_PLAYER(getOwner()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(getOwner()).nextCity(&iLoop))
					{
						if (pLoopCity->HasBuildingClass((BuildingClassTypes)iI))
						{
							return false;
						}
					}
				}
				else if (ePrereqBuilding != NO_BUILDING)
				{
					int iLoop = 0;
					for (CvCity* pLoopCity = GET_PLAYER(getOwner()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(getOwner()).nextCity(&iLoop))
					{
						if (pLoopCity->GetCityBuildings()->GetNumBuilding(ePrereqBuilding) > 0)
						{
							return false;
						}
					}
				}
			}
		}
	}

	if (MOD_BALANCE_CORE && pkBuildingInfo->GetNeedBuildingThisCity() != NO_BUILDING)
	{
		BuildingTypes ePrereqBuilding = (BuildingTypes)pkBuildingInfo->GetNeedBuildingThisCity();
		if (m_pCityBuildings->GetNumBuilding(ePrereqBuilding) <= 0)
		{
			return false;
		}
	}

	return true;
}


//	--------------------------------------------------------------------------------
bool CvCity::canTrain(UnitTypes eUnit, bool bContinue, bool bTestVisible, bool bIgnoreCost, bool bWillPurchase, CvString* toolTipSink) const
{
	VALIDATE_OBJECT
	if (eUnit == NO_UNIT)
	{
		return false;
	}

	CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eUnit);
	if (pkUnitEntry == NULL)
	{
		return false;
	}

	if (!(GET_PLAYER(getOwner()).canTrainUnit(eUnit, bContinue, bTestVisible, bIgnoreCost, false, toolTipSink)))
	{
		return false;
	}

	if (!bWillPurchase && pkUnitEntry->IsPurchaseOnly())
	{
		return false;
	}

	// check whether we can supply the units. do not check this on player level, all the dynamic checks should happen here
	if (MOD_BALANCE_CORE_MILITARY && !isHuman() && !isBarbarian() && !pkUnitEntry->IsNoSupply() && (pkUnitEntry->GetCombat() > 0 || pkUnitEntry->GetRangedCombat() > 0))
	{
		bool bCanSupply = GET_PLAYER(getOwner()).GetNumUnitsToSupply() < GET_PLAYER(getOwner()).GetNumUnitsSupplied(); // this works when we're at the limit
		if (!bCanSupply)
		{
			return false;
		}
	}

	// If Zulu Player has this trait and Pikeman are an immediate upgrade to Impi, let's not let player exploit lower production cost of pikeman->impi. So, let's make it immediately obsolete.
	CvUnitEntry& pUnitInfo = *pkUnitEntry;
	const UnitClassTypes eUnitClass = (UnitClassTypes)pUnitInfo.GetUnitClassType();
	UnitClassTypes ePikemanClass = (UnitClassTypes)GC.getInfoTypeForString("UNITCLASS_PIKEMAN");
	UnitTypes eZuluImpi = (UnitTypes)GC.getInfoTypeForString("UNIT_ZULU_IMPI");
	if (GET_PLAYER(getOwner()).GetPlayerTraits()->IsFreeZuluPikemanToImpi())
	{
		if (eUnitClass != NO_UNITCLASS && (eUnitClass == ePikemanClass) && GET_PLAYER(getOwner()).canTrainUnit(eZuluImpi, false, false, true))
		{
			return false;
		}
	}

	//this flag seems to be needed to check whether we should show the unit in the build list at all, and if it's greyed out generate a tooltip why
	if (!bTestVisible)
	{
		CvUnitEntry& thisUnitInfo = *pkUnitEntry;
		// Settlers may not be trained in Cities that are too small
		if (thisUnitInfo.IsFound() || thisUnitInfo.IsFoundAbroad())
		{
			int iSizeRequirement = /*2 in CP, 4 in VP*/ GD_INT_GET(CITY_MIN_SIZE_FOR_SETTLERS);
			if (getPopulation() < iSizeRequirement)
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_SETTLER_SIZE_LIMIT", "", "", iSizeRequirement);
				if (toolTipSink == NULL)
					return false;
			}
		}

		if (MOD_BALANCE_VP && !isBarbarian() && !pUnitInfo.IsNoSupply() && (pUnitInfo.GetCombat() > 0 || pUnitInfo.GetRangedCombat() > 0))
		{
			int iMaxSupplyPenalty = /*70*/ GD_INT_GET(MAX_UNIT_SUPPLY_PRODMOD);
			int iSupplyPenaltyPerUnit = /*10 in CP, 5 in VP*/ GD_INT_GET(PRODUCTION_PENALTY_PER_UNIT_OVER_SUPPLY);
			int iMaxUnitsOverSupply = (iMaxSupplyPenalty > 0 && iSupplyPenaltyPerUnit > 0) ? iMaxSupplyPenalty / iSupplyPenaltyPerUnit : INT_MAX;

			if (GET_PLAYER(getOwner()).GetNumUnitsOutOfSupply() >= iMaxUnitsOverSupply)
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_NO_SUPPLY");
				if (toolTipSink == NULL)
					return false;
			}
		}

		// See if there are any BuildingClass requirements
		const int iNumBuildingClassInfos = GC.getNumBuildingClassInfos();
		const CvCivilizationInfo& thisCivilization = getCivilizationInfo();
		for (int iBuildingClassLoop = 0; iBuildingClassLoop < iNumBuildingClassInfos; iBuildingClassLoop++)
		{
			const BuildingClassTypes eBuildingClass = (BuildingClassTypes)iBuildingClassLoop;
			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
			if (!pkBuildingClassInfo)
			{
				continue;
			}

			// Requires Building
			if (thisUnitInfo.GetBuildingClassRequireds(eBuildingClass))
			{
				BuildingTypes ePrereqBuilding = NO_BUILDING;

				if (MOD_BUILDINGS_THOROUGH_PREREQUISITES)
				{
					if (HasBuildingClass(eBuildingClass))
					{
						ePrereqBuilding = GetCityBuildings()->GetBuildingTypeFromClass(eBuildingClass);
					}
					else
					{
						ePrereqBuilding = (BuildingTypes)(thisCivilization.getCivilizationBuildings(eBuildingClass));
					}
				}
				else
				{
					ePrereqBuilding = (BuildingTypes)(thisCivilization.getCivilizationBuildings(eBuildingClass));
				}

				if (ePrereqBuilding != NO_BUILDING)
				{
					if (GetCityBuildings()->GetNumBuilding(ePrereqBuilding) == 0)
					{
						CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(ePrereqBuilding);
						if (pkBuildingInfo)
						{
							GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_UNIT_REQUIRES_BUILDING", pkBuildingInfo->GetDescriptionKey());
							if (toolTipSink == NULL)
								return false;
						}
					}
				}
			}
		}

		// Air units can't be built above capacity
		if (pkUnitEntry->GetDomainType() == DOMAIN_AIR)
		{
			int iNumAirUnits = plot()->countNumAirUnits(getTeam());
			if (iNumAirUnits >= GetMaxAirUnits())
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_CITY_AT_AIR_CAPACITY");
				if (toolTipSink == NULL)
					return false;
			}
		}
	}

	if (!plot()->canTrain(eUnit))
	{
		return false;
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if (pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(getOwner());
		args->Push(GetID());
		args->Push(eUnit);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if (LuaSupport::CallTestAll(pkScriptSystem, "CityCanTrain", args.get(), bResult))
		{
			// Check the result.
			if (bResult == false)
			{
				return false;
			}
		}
	}

	return true;
}

//	--------------------------------------------------------------------------------
bool CvCity::canTrain(UnitCombatTypes eUnitCombat) const
{
	VALIDATE_OBJECT
	for (int i = 0; i < GC.getNumUnitInfos(); i++)
	{
		const UnitTypes eUnit = static_cast<UnitTypes>(i);
		CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
		if (pkUnitInfo)
		{
			if (pkUnitInfo->GetUnitCombatType() == eUnitCombat)
			{
				if (canTrain(eUnit))
				{
					return true;
				}
			}
		}
	}

	return false;
}


//	--------------------------------------------------------------------------------
// slow version to call for a single building in a single city
bool CvCity::canConstruct(BuildingTypes eBuilding, bool bContinue, bool bTestVisible, bool bIgnoreCost, bool bWillPurchase, CvString* toolTipSink) const
{
	return canConstruct(eBuilding, GET_PLAYER(m_eOwner).GetTotalBuildingCount(), bContinue, bTestVisible, bIgnoreCost, bWillPurchase, toolTipSink);
}

//fast version to call in loops over building types / cities
bool CvCity::canConstruct(BuildingTypes eBuilding, const std::vector<int>& vPreExistingBuildings, bool bContinue, bool bTestVisible, bool bIgnoreCost, bool bWillPurchase, CvString* toolTipSink) const
{
	if (eBuilding == NO_BUILDING)
	{
		return false;
	}

	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if (pkBuildingInfo == NULL)
	{
		return false;
	}

	//no wonders in puppets (also affects venice unless invest or already invested)
	if (IsPuppet() && !(GET_PLAYER(m_eOwner).GetPlayerTraits()->IsNoAnnexing() && (bContinue || bWillPurchase)))
	{
		if (isWorldWonderClass(pkBuildingInfo->GetBuildingClassInfo()) || isNationalWonderClass(pkBuildingInfo->GetBuildingClassInfo()))
		{
			return false;
		}
	}

	if (!(GET_PLAYER(getOwner()).canConstruct(eBuilding, vPreExistingBuildings, bContinue, bTestVisible, bIgnoreCost, toolTipSink)))
	{
		return false;
	}

	if (!bWillPurchase && pkBuildingInfo->IsPurchaseOnly())
	{
		return false;
	}
	if (pkBuildingInfo->IsRequiresRail() && !GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE))
	{
		//this flag is also set for water connection once railroad is available
		if (!IsIndustrialRouteToCapitalConnected())
			return false;

		//therefore also check for an actual railroad here
		bool bRailroad = false;
		for (int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; iDirectionLoop++)
		{
			CvPlot* pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iDirectionLoop));
			if (pAdjacentPlot && pAdjacentPlot->getRouteType() == ROUTE_RAILROAD && pAdjacentPlot->IsCityConnection(getOwner()))
			{
				bRailroad = true;
				break;
			}
		}
		if (!bRailroad)
			return false;
	}

	if ((pkBuildingInfo->GetCivType() != NO_CIVILIZATION) && (getCivilizationType() != pkBuildingInfo->GetCivType()))
	{
		return false;
	}

	if (pkBuildingInfo->GetEventRequiredActive() != NO_EVENT_CHOICE)
	{
		if (!GET_PLAYER(getOwner()).IsEventChoiceActive((EventChoiceTypes)pkBuildingInfo->GetEventRequiredActive()))
			return false;
	}
	if (pkBuildingInfo->GetCityEventRequiredActive() != NO_EVENT_CHOICE_CITY)
	{
		if (!IsEventChoiceActive((CityEventChoiceTypes)pkBuildingInfo->GetEventRequiredActive()))
			return false;
	}

	if (m_pCityBuildings->GetNumBuilding(eBuilding) >= /*1*/ GD_INT_GET(CITY_MAX_NUM_BUILDINGS))
	{
		return false;
	}

	if (!isValidBuildingLocation(eBuilding))
	{
		return false;
	}

	// Religion-enabled national wonder
	if (pkBuildingInfo && pkBuildingInfo->IsUnlockedByBelief() && pkBuildingInfo->IsReformation())
	{
		CvGameReligions* pReligions = GC.getGame().GetGameReligions();
		ReligionTypes eReligion = GET_PLAYER(getOwner()).GetReligions()->GetOwnedReligion();
		if (eReligion != NO_RELIGION)
		{
			const CvReligion* pReligion = pReligions->GetReligion(eReligion, getOwner());
			if (pReligion == NULL || !pReligion->m_Beliefs.IsBuildingClassEnabled(pkBuildingInfo->GetBuildingClassType(), getOwner(), GET_PLAYER(getOwner()).getCity(GetID()), true))
			{
				return false;
			}
		}
		else
		{
			return false;
		}
	}

	// Local Resource requirements met?
	if (!IsBuildingLocalResourceValid(eBuilding, bTestVisible, toolTipSink))
	{
		return false;
	}
	// Resource Monopoly requirements met?
	if (!IsBuildingResourceMonopolyValid(eBuilding, toolTipSink))
	{
		return false;
	}
#if defined(MOD_BALANCE_CORE)
	if (!IsBuildingFeatureValid(eBuilding, toolTipSink))
	{
		return false;
	}
#endif
#if defined(MOD_BALANCE_CORE)
	// Corporation building?
	if (pkBuildingInfo->GetBuildingClassInfo().getCorporationType() != NO_CORPORATION)
	{
		// Must have Corporations tech
		if (!GET_TEAM(GET_PLAYER(getOwner()).getTeam()).IsCorporationsEnabled())
		{
			return false;
		}

		// This building is a franchise - cannot construct EVER
		if (pkBuildingInfo->GetBuildingClassInfo().IsFranchise())
		{
			return false;
		}
		// Corporation HQ
		if (pkBuildingInfo->GetBuildingClassInfo().IsHeadquarters())
		{
			CvPlayerCorporations* pPlayerCorporation = GET_PLAYER(getOwner()).GetCorporations();
			// Cannot construct if corporation exists or we've founded a corporation already
			if (pPlayerCorporation->HasFoundedCorporation() ||
				GC.getGame().GetGameCorporations()->IsCorporationFounded(pkBuildingInfo->GetBuildingClassInfo().getCorporationType()))
			{
				return false;
			}
		}
		// Corporation Office
		if (pkBuildingInfo->GetBuildingClassInfo().IsOffice())
		{
			CvPlayerCorporations* pPlayerCorporation = GET_PLAYER(getOwner()).GetCorporations();
			// Cannot construct if we do not have this corporation
			if (pPlayerCorporation->GetFoundedCorporation() != pkBuildingInfo->GetBuildingClassInfo().getCorporationType())
			{
				return false;
			}
		}
	}
#endif
	// Holy city requirement
	if (pkBuildingInfo->IsRequiresHolyCity() && !GetCityReligions()->IsHolyCityAnyReligion())
	{
		return false;
	}

	const CvCivilizationInfo& thisCivInfo = *GC.getCivilizationInfo(getCivilizationType());
	int iNumBuildingClassInfos = GC.getNumBuildingClassInfos();

	// Can't construct a building to reduce occupied unhappiness if the city isn't occupied
#if defined(MOD_BALANCE_CORE)
	if (pkBuildingInfo->IsNoOccupiedUnhappiness() && !IsOccupied() && !pkBuildingInfo->IsBuildAnywhere())
#else
	if (pkBuildingInfo->IsNoOccupiedUnhappiness() && !IsOccupied())
#endif
		return false;

	// Does this city have prereq buildings?
	if (!hasBuildingPrerequisites(eBuilding))
	{
		return false;
	}

#if defined(MOD_BALANCE_CORE)
	//Check for uniques of the same type.
	vector<BuildingTypes> allBuildings = GetCityBuildings()->GetAllBuildingsHere();
	for (size_t iI = 0; iI < allBuildings.size(); iI++)
	{
		CvBuildingEntry* pkBuildingInfo2 = GC.getBuildingInfo(allBuildings[iI]);
		if (pkBuildingInfo2 && pkBuildingInfo2->GetBuildingClassType() == pkBuildingInfo->GetBuildingClassType())
		{
			return false;
		}
	}
#endif

	///////////////////////////////////////////////////////////////////////////////////
	// Everything above this is what is checked to see if Building shows up in the list of construction items
	///////////////////////////////////////////////////////////////////////////////////

	const CvBuildingClassInfo& kBuildingClassInfo = pkBuildingInfo->GetBuildingClassInfo();
	if (!bTestVisible)
	{
		if (!bContinue)
		{
#if defined(MOD_BALANCE_CORE_BUILDING_INVESTMENTS)
			if (!MOD_BALANCE_CORE_BUILDING_INVESTMENTS && getFirstBuildingOrder(eBuilding) != -1)
#else
			if (getFirstBuildingOrder(eBuilding) != -1)
#endif
			{
				return false;
			}
		}

		if (!(kBuildingClassInfo.isNoLimit()))
		{
			if (isWorldWonderClass(kBuildingClassInfo))
			{
				if (isWorldWondersMaxed())
				{
					return false;
				}
			}
			else if (isTeamWonderClass(kBuildingClassInfo))
			{
				if (isTeamWondersMaxed())
				{
					return false;
				}
			}
			else if (isNationalWonderClass(kBuildingClassInfo))
			{
				if (isNationalWondersMaxed())
				{
					return false;
				}
			}
			else
			{
				if (isBuildingsMaxed())
				{
					return false;
				}
			}
		}
	}

	// Locked Buildings (Mutually Exclusive Buildings?) - not quite sure how this works
	for (int iI = 0; iI < iNumBuildingClassInfos; iI++)
	{
		BuildingClassTypes eLockedBuildingClass = (BuildingClassTypes)pkBuildingInfo->GetLockedBuildingClasses(iI);

		if (eLockedBuildingClass != NO_BUILDINGCLASS)
		{
			BuildingTypes eLockedBuilding = (BuildingTypes)(thisCivInfo.getCivilizationBuildings(eLockedBuildingClass));

			if (eLockedBuilding != NO_BUILDING)
			{
				if (m_pCityBuildings->GetNumBuilding(eLockedBuilding) > 0)
				{
					return false;
				}
			}
		}
	}

	// Mutually Exclusive Buildings 2
	if (pkBuildingInfo->GetMutuallyExclusiveGroup() != -1)
	{
		int iNumBuildingInfos = GC.getNumBuildingInfos();
		for (int iI = 0; iI < iNumBuildingInfos; iI++)
		{
			const BuildingTypes eBuildingLoop = static_cast<BuildingTypes>(iI);
			if (eBuildingLoop == eBuilding)
				continue;

			CvBuildingEntry* pkLoopBuilding = GC.getBuildingInfo(eBuildingLoop);
			if (pkLoopBuilding)
			{
				// Buildings are in a Mutually Exclusive Group, so only one is allowed
				if (pkLoopBuilding->GetMutuallyExclusiveGroup() == pkBuildingInfo->GetMutuallyExclusiveGroup())
				{
					if (m_pCityBuildings->GetNumBuilding(eBuildingLoop) > 0 || isBuildingInQueue(eBuildingLoop))
					{
						return false;
					}
				}
			}
		}
	}

#if defined(MOD_BALANCE_CORE)
	if (!bTestVisible) // Test visible check here is so that the buildings will show up in the build list, but can't be selected (for every other city!)
	{
		// Check if it's a Corporation headquarters
		if (pkBuildingInfo->GetBuildingClassInfo().IsHeadquarters())
		{
			CvCity* pLoopCity = NULL;
			int iLoop = 0;
			for (pLoopCity = GET_PLAYER(getOwner()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(getOwner()).nextCity(&iLoop))
			{
				if (pLoopCity == NULL)
					continue;

				if (pLoopCity->GetID() == GetID())
					continue;

				BuildingTypes eTestBuilding = pLoopCity->getProductionBuilding();
				if (eTestBuilding != NO_BUILDING)
				{
					CvBuildingEntry* pkLoopBuildingInfo = GC.getBuildingInfo(eTestBuilding);
					if (pkLoopBuildingInfo && pkLoopBuildingInfo->GetBuildingClassInfo().IsHeadquarters())
					{
						GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_ONE_CORP_ONLY", pkBuildingInfo->GetTextKey(), pkLoopBuildingInfo->GetDescription());
						if (toolTipSink == NULL)
							return false;
					}
				}
			}
		}
	}
#endif

#if defined(MOD_BALANCE_CORE_POP_REQ_BUILDINGS)
	//Requires a certain population size, either nationally or locally.
	if (MOD_BALANCE_CORE_POP_REQ_BUILDINGS)
	{
		if (pkBuildingInfo->GetLocalPopulationRequired() > 0)
		{
			int iPopRequired = pkBuildingInfo->GetLocalPopulationRequired();
			if (getPopulation() < iPopRequired)
			{
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_NEED_LOCAL_POP", pkBuildingInfo->GetTextKey(), "", iPopRequired - getPopulation());
				if (toolTipSink == NULL)
					return false;
			}
		}
	}
#endif

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if (pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(getOwner());
		args->Push(GetID());
		args->Push(eBuilding);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if (LuaSupport::CallTestAll(pkScriptSystem, "CityCanConstruct", args.get(), bResult))
		{
			// Check the result.
			if (bResult == false)
			{
				return false;
			}
		}
	}

	return true;
}


//	--------------------------------------------------------------------------------
bool CvCity::canCreate(ProjectTypes eProject, bool bContinue, bool bTestVisible) const
{
	VALIDATE_OBJECT

	//no projects in puppets except venice
	if (eProject == NO_PROJECT || CityStrategyAIHelpers::IsTestCityStrategy_IsPuppetAndAnnexable(this))
	{
		return false;
	}

	if (!(GET_PLAYER(getOwner()).canCreate(eProject, bContinue, bTestVisible)))
	{
		return false;
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if (pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(getOwner());
		args->Push(GetID());
		args->Push(eProject);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if (LuaSupport::CallTestAll(pkScriptSystem, "CityCanCreate", args.get(), bResult))
		{
			// Check the result.
			if (bResult == false)
			{
				return false;
			}
		}
	}

	return true;
}


//	--------------------------------------------------------------------------------
bool CvCity::canPrepare(SpecialistTypes eSpecialist, bool bContinue) const
{
	VALIDATE_OBJECT

	if (!(GET_PLAYER(getOwner()).canPrepare(eSpecialist, bContinue)))
	{
		return false;
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if (pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(getOwner());
		args->Push(GetID());
		args->Push(eSpecialist);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if (LuaSupport::CallTestAll(pkScriptSystem, "CityCanPrepare", args.get(), bResult))
		{
			// Check the result.
			if (bResult == false)
			{
				return false;
			}
		}
	}

	return true;
}

//	--------------------------------------------------------------------------------
bool CvCity::canMaintain(ProcessTypes eProcess, bool bContinue) const
{
	VALIDATE_OBJECT

	if (!(GET_PLAYER(getOwner()).canMaintain(eProcess, bContinue)))
	{
		return false;
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if (pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(getOwner());
		args->Push(GetID());
		args->Push(eProcess);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if (LuaSupport::CallTestAll(pkScriptSystem, "CityCanMaintain", args.get(), bResult))
		{
			// Check the result.
			if (bResult == false)
			{
				return false;
			}
		}
	}

	return true;
}


//	--------------------------------------------------------------------------------
bool CvCity::canJoinCity() const
{
	VALIDATE_OBJECT
	return true;
}

//	--------------------------------------------------------------------------------
int CvCity::GetTerrainImprovementNeed() const
{
	return m_iTerrainImprovementNeed;
}

//	--------------------------------------------------------------------------------
void CvCity::UpdateTerrainImprovementNeed()
{
	int iImprovablePlots = 0;

	//start at one, ignore the city plot itself
	for (int iI = 1; iI < GetNumWorkablePlots(); iI++)
	{
		CvPlot* pLoopPlot = GetCityCitizens()->GetCityPlotFromIndex(iI);

		if (!pLoopPlot)
			continue;

		if (pLoopPlot->getDomain() != DOMAIN_LAND)
			continue;

		if (pLoopPlot->getOwner() != getOwner())
			continue;

		if (pLoopPlot->IsTeamImpassable(getTeam()))
			continue;

		if (pLoopPlot->isCity())
			continue;

		//the most interesting case, empty plots
		if (pLoopPlot->getImprovementType() == NO_IMPROVEMENT)
		{
			//can't assume that there is an improvement for every type of unimproved plot (especially in the beginning). need to check individually
			for (int iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
			{
				BuildTypes eBuild = (BuildTypes)iBuildIndex;
				if (!pLoopPlot->canBuild(eBuild, getOwner(), false, true))
					continue;

				if (GET_PLAYER(getOwner()).GetPlayerTraits()->IsNoBuild(eBuild))
					continue;

				if (GC.getBuildInfo(eBuild)->getTechPrereq() != NO_TECH && !GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)GC.getBuildInfo(eBuild)->getTechPrereq()))
					continue;

				if (GC.getBuildInfo(eBuild)->getTechObsolete() != NO_TECH && GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes)GC.getBuildInfo(eBuild)->getTechObsolete()))
					continue;

				// Is this an improvement that is only useable by a specific civ?
				ImprovementTypes eImprovement = (ImprovementTypes)GC.getBuildInfo(eBuild)->getImprovement();
				if (eImprovement != NO_IMPROVEMENT)
				{
					CvImprovementEntry* pkEntry = GC.getImprovementInfo(eImprovement);
					if (pkEntry->IsSpecificCivRequired())
					{
						CivilizationTypes eCiv = pkEntry->GetRequiredCivilization();
						if (eCiv != getCivilizationType())
							continue;
					}
				}

				//if we get here it seems to be applicable
				iImprovablePlots++;

				//todo: should we add more of the improvement is very valuable?
				//for now give extra weight to resource plots
				if (pLoopPlot->getResourceType() != NO_RESOURCE)
					iImprovablePlots++;

				break;
			}
		}
		//ignore plots which have a working improvement ...
		else if (pLoopPlot->IsImprovementPillaged())
			iImprovablePlots++;
		//if there is a route, see if we have better ones
		else if (pLoopPlot->getRouteType() != NO_ROUTE && (GET_TEAM(getTeam()).GetBestPossibleRoute() != pLoopPlot->getRouteType() || pLoopPlot->IsRoutePillaged()))
			iImprovablePlots++;
	}

	//should we take into account the population of the city or whether any of these plots are worked or will be worked?
	m_iTerrainImprovementNeed = iImprovablePlots;
}

//	--------------------------------------------------------------------------------
/// Extra yield for a resource this city is working?
int CvCity::GetResourceExtraYield(ResourceTypes eResource, YieldTypes eYield) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eResource > -1 && eResource < GC.getNumResourceInfos(), "Invalid resource index.");
	CvAssertMsg(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	return ModifierLookup(m_yieldChanges[eYield].forResource, eResource);
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeResourceExtraYield(ResourceTypes eResource, YieldTypes eYield, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eResource > -1 && eResource < GC.getNumResourceInfos(), "Invalid resource index.");
	CvAssertMsg(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	SCityExtraYields& y = m_yieldChanges[eYield];
	if (ModifierUpdateInsertRemove(y.forResource, eResource, iChange, true))
		updateYield();
}

//	--------------------------------------------------------------------------------
/// Extra yield for a Feature this city is working?
int CvCity::GetFeatureExtraYield(FeatureTypes eFeature, YieldTypes eYield) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eFeature > -1 && eFeature < GC.getNumFeatureInfos(), "Invalid Feature index.");
	CvAssertMsg(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	return ModifierLookup(m_yieldChanges[eYield].forFeature, eFeature);
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeFeatureExtraYield(FeatureTypes eFeature, YieldTypes eYield, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eFeature > -1 && eFeature < GC.getNumFeatureInfos(), "Invalid Feature index.");
	CvAssertMsg(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	SCityExtraYields& y = m_yieldChanges[eYield];
	if (ModifierUpdateInsertRemove(y.forFeature, eFeature, iChange, true))
		updateYield();
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Extra yield for a improvement this city is working?
int CvCity::GetImprovementExtraYield(ImprovementTypes eImprovement, YieldTypes eYield) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eImprovement > -1 && eImprovement < GC.getNumImprovementInfos(), "Invalid Improvement index.");
	CvAssertMsg(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");
	return ModifierLookup(m_yieldChanges[eYield].forImprovement, eImprovement);
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeImprovementExtraYield(ImprovementTypes eImprovement, YieldTypes eYield, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eImprovement > -1 && eImprovement < GC.getNumImprovementInfos(), "Invalid Improvement index.");
	CvAssertMsg(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	SCityExtraYields& y = m_yieldChanges[eYield];
	if (ModifierUpdateInsertRemove(y.forImprovement, eImprovement, iChange, true))
		updateYield();
}

/// Extra yield for a building this city is lacking resources for?
int CvCity::GetExtraBuildingMaintenance() const
{
	VALIDATE_OBJECT
	return m_iExtraBuildingMaintenance;
}

//	--------------------------------------------------------------------------------
void CvCity::SetExtraBuildingMaintenance(int iChange)
{
	VALIDATE_OBJECT
	m_iExtraBuildingMaintenance = iChange;
}
#endif
//	--------------------------------------------------------------------------------
/// Extra yield for a Terrain this city is working?
int CvCity::GetTerrainExtraYield(TerrainTypes eTerrain, YieldTypes eYield) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eTerrain > -1 && eTerrain < GC.getNumTerrainInfos(), "Invalid Terrain index.");
	CvAssertMsg(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	return ModifierLookup(m_yieldChanges[eYield].forTerrain, eTerrain);
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeTerrainExtraYield(TerrainTypes eTerrain, YieldTypes eYield, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eTerrain > -1 && eTerrain < GC.getNumTerrainInfos(), "Invalid Terrain index.");
	CvAssertMsg(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	SCityExtraYields& y = m_yieldChanges[eYield];
	if (ModifierUpdateInsertRemove(y.forTerrain, eTerrain, iChange, true))
		updateYield();
}

//	--------------------------------------------------------------------------------
/// Extra yield for a Plot this city is working?
int CvCity::GetPlotExtraYield(PlotTypes ePlot, YieldTypes eYield) const
{
	VALIDATE_OBJECT
	return ModifierLookup(m_yieldChanges[eYield].forPlot, ePlot);
}

//	--------------------------------------------------------------------------------
void CvCity::ChangePlotExtraYield(PlotTypes ePlot, YieldTypes eYield, int iChange)
{
	SCityExtraYields& y = m_yieldChanges[eYield];
	if (ModifierUpdateInsertRemove(y.forPlot, ePlot, iChange, true))
		updateYield();
}

#if defined(MOD_BALANCE_CORE)
bool CvCity::IsHasFeatureLocal(FeatureTypes eFeature) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eFeature > -1 && eFeature < GC.getNumFeatureInfos(), "Invalid resource index.");

	// See if we have the resource linked to this city, but not connected yet
	bool bFoundFeature = false;

	// Loop through all plots near this City to see if we can find eResource - tests are ordered to optimize performance
	for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(getX(), getY(), iCityPlotLoop);

		// Invalid plot
		if (pLoopPlot == NULL)
			continue;

		// Doesn't have the resource (ignore team first to save time)
		if (pLoopPlot->getFeatureType() != eFeature)
			continue;

		// Not owned by this player
		if (pLoopPlot->getOwner() != getOwner())
			continue;

		if (pLoopPlot->getOwningCityID() != GetID())
			continue;

		bFoundFeature = true;
		break;
	}

	return bFoundFeature;
}
#endif
//	--------------------------------------------------------------------------------
/// Does this City have eResource nearby?
bool CvCity::IsHasResourceLocal(ResourceTypes eResource, bool bTestVisible) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eResource > -1 && eResource < GC.getNumResourceInfos(), "Invalid resource index.");

	// Actually check to see if we have this Resource to use right now
	if (!bTestVisible)
	{
		return m_paiNumResourcesLocal[eResource] > 0;
	}
	else
	{
		return (m_paiNumUnimprovedResourcesLocal[eResource] + m_paiNumResourcesLocal[eResource]) > 0;
	}
}

#if defined(MOD_TRADE_WONDER_RESOURCE_ROUTES)
int CvCity::GetNumResourceLocal(ResourceTypes eResource, bool bImproved)
{
	VALIDATE_OBJECT
	CvAssertMsg(eResource > -1 && eResource < GC.getNumResourceInfos(), "Invalid resource index.");
	return bImproved ? m_paiNumResourcesLocal[eResource] : m_paiNumUnimprovedResourcesLocal[eResource];
}
#endif

int CvCity::GetNumTotalResource(ResourceTypes eResource) const
{
	return m_paiNumUnimprovedResourcesLocal[eResource] + m_paiNumResourcesLocal[eResource];
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeNumResourceLocal(ResourceTypes eResource, int iChange, bool bUnimproved)
{
	VALIDATE_OBJECT

	CvAssertMsg(eResource >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eResource < GC.getNumResourceInfos(), "eIndex expected to be < GC.getNumResourceInfos()");

	if (iChange != 0)
	{
		bool bOldHasResource = IsHasResourceLocal(eResource, /*bTestVisible*/ false);

		//unimproved is just here for the cache.
		if (bUnimproved)
		{
			m_paiNumUnimprovedResourcesLocal[eResource] = max(0, m_paiNumUnimprovedResourcesLocal[eResource] + iChange);
			return;
		}
		else
			m_paiNumResourcesLocal[eResource] = max(0, m_paiNumResourcesLocal[eResource] + iChange);

		if (bOldHasResource != IsHasResourceLocal(eResource, /*bTestVisible*/ false))
		{
			if (IsHasResourceLocal(eResource, /*bTestVisible*/ false))
			{
				processResource(eResource, 1);

				CvResourceInfo* pkResource = GC.getResourceInfo(eResource);

				// Notification letting player know his city gets a bonus for wonders
				int iWonderMod = pkResource->getWonderProductionMod();
				if (iWonderMod != 0)
				{
#if defined(MOD_BALANCE_CORE_RESOURCE_FLAVORS)
					if (MOD_BALANCE_CORE_RESOURCE_FLAVORS && pkResource->getWonderProductionModObsoleteEra() == GC.getInfoTypeForString("ERA_MEDIEVAL", true /*bHideAssert*/))
					{
						if (GET_PLAYER(getOwner()).GetCurrentEra() < GC.getInfoTypeForString("ERA_MEDIEVAL", true /*bHideAssert*/))
						{
							CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
							if (pNotifications)
							{
								Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_RESOURCE_WONDER_MOD");
								strText << getNameKey() << pkResource->GetTextKey() << iWonderMod;
								Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_RESOURCE_WONDER_MOD_SUMMARY");
								strSummary << getNameKey() << pkResource->GetTextKey();
								pNotifications->Add(NOTIFICATION_DISCOVERED_BONUS_RESOURCE, strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), eResource);
							}
						}
					}
					else if (MOD_BALANCE_CORE_RESOURCE_FLAVORS && pkResource->getWonderProductionModObsoleteEra() == GC.getInfoTypeForString("ERA_INDUSTRIAL", true /*bHideAssert*/))
					{
						if (GET_PLAYER(getOwner()).GetCurrentEra() < GC.getInfoTypeForString("ERA_INDUSTRIAL", true /*bHideAssert*/))
						{
							CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
							if (pNotifications)
							{
								Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_RESOURCE_WONDER_MOD_LATE");
								strText << getNameKey() << pkResource->GetTextKey() << iWonderMod;
								Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_RESOURCE_WONDER_MOD_SUMMARY");
								strSummary << getNameKey() << pkResource->GetTextKey();
								pNotifications->Add(NOTIFICATION_DISCOVERED_BONUS_RESOURCE, strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), eResource);
							}
						}
					}
					else
					{
#endif
						CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
						if (pNotifications)
						{
							Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_RESOURCE_WONDER_MOD");
							strText << getNameKey() << pkResource->GetTextKey() << iWonderMod;
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_RESOURCE_WONDER_MOD_SUMMARY");
							strSummary << getNameKey() << pkResource->GetTextKey();
							pNotifications->Add(NOTIFICATION_DISCOVERED_BONUS_RESOURCE, strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), eResource);
						}
#if defined(MOD_BALANCE_CORE_RESOURCE_FLAVORS)
					}
#endif
				}

#if defined(MOD_RESOURCES_PRODUCTION_COST_MODIFIERS)

				// Notification letting player know his city gets a production cost modifier
				if (MOD_RESOURCES_PRODUCTION_COST_MODIFIERS)
				{

					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_RESOURCE_WONDER_MOD_SUMMARY");
					strSummary << getNameKey() << pkResource->GetTextKey();

					CvString strList = "";

					// Unit combat cost modifier
					if (pkResource->isHasUnitCombatProductionCostModifiersLocal())
					{
						for (int iUnitCombat = 0; iUnitCombat < GC.getNumUnitCombatClassInfos(); iUnitCombat++)
						{
							UnitCombatTypes eUnitCombat = (UnitCombatTypes)iUnitCombat;
							CvBaseInfo* pkUnitCombat = GC.getUnitCombatClassInfo(eUnitCombat);

							if (eUnitCombat == NO_UNITCOMBAT)
							{
								continue;
							}
							std::vector<ProductionCostModifiers> aiiiUnitCostMod = pkResource->getUnitCombatProductionCostModifiersLocal(eUnitCombat);
							for (std::vector<ProductionCostModifiers>::const_iterator it = aiiiUnitCostMod.begin(); it != aiiiUnitCostMod.end(); ++it)
							{
								EraTypes eRequiredEra = (EraTypes)it->m_iRequiredEra;
								EraTypes eObsoleteEra = (EraTypes)it->m_iObsoleteEra;
								int iCostModifier = it->m_iCostModifier;

								CvString strEraText = "";

								if (iCostModifier != 0)
								{
									if (eRequiredEra != NO_ERA)
									{
										strEraText += " ";
										strEraText += GetLocalizedText("TXT_KEY_NOTIFICATION_CITY_RESOURCE_PROD_COST_MOD_ERA_PREREQUISITE", GC.getEraInfo(eRequiredEra)->getShortDesc());
									}

									if (eObsoleteEra != NO_ERA)
									{
										strEraText += " ";
										strEraText += GetLocalizedText("TXT_KEY_NOTIFICATION_CITY_RESOURCE_PROD_COST_MOD_ERA_OBSOLETE", GC.getEraInfo(eObsoleteEra)->getShortDesc());
									}

									strList += "[NEWLINE]" + GetLocalizedText("TXT_KEY_NOTIFICATION_CITY_RESOURCE_PROD_COST_MOD_LIST", pkUnitCombat->GetDescriptionKey(), iCostModifier, strEraText);
								}
							}
						}
					}

					// Building cost modifier
					if (pkResource->isHasBuildingProductionCostModifiersLocal())
					{
						std::vector<ProductionCostModifiers> aiiiBuildingCostMod = pkResource->getBuildingProductionCostModifiersLocal();
						for (std::vector<ProductionCostModifiers>::const_iterator it = aiiiBuildingCostMod.begin(); it != aiiiBuildingCostMod.end(); ++it)
						{
							EraTypes eRequiredEra = (EraTypes)it->m_iRequiredEra;
							EraTypes eObsoleteEra = (EraTypes)it->m_iObsoleteEra;
							int iCostModifier = it->m_iCostModifier;

							CvString strEraText = "";

							if (iCostModifier != 0)
							{
								if (eRequiredEra != NO_ERA)
								{
									strEraText += " ";
									strEraText += GetLocalizedText("TXT_KEY_NOTIFICATION_CITY_RESOURCE_PROD_COST_MOD_ERA_PREREQUISITE", GC.getEraInfo(eRequiredEra)->getShortDesc());
								}

								if (eObsoleteEra != NO_ERA)
								{
									strEraText += " ";
									strEraText += GetLocalizedText("TXT_KEY_NOTIFICATION_CITY_RESOURCE_PROD_COST_MOD_ERA_OBSOLETE", GC.getEraInfo(eObsoleteEra)->getShortDesc());
								}

								strList += "[NEWLINE]" + GetLocalizedText("TXT_KEY_NOTIFICATION_CITY_RESOURCE_PROD_COST_MOD_LIST", "TXT_KEY_NOTIFICATION_CITY_RESOURCE_PROD_COST_MOD_BUILDING", iCostModifier, strEraText);
							}
						}
					}

					// Combine the list we just made with the header text
					if (strList != "")
					{
						Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_RESOURCE_PROD_COST_MOD");
						strText << getNameKey() << pkResource->GetTextKey() << strList;

						CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
						if (pNotifications)
						{
							pNotifications->Add((NotificationTypes)FString::Hash("NOTIFICATION_PRODUCTION_COST_MODIFIERS_FROM_RESOURCES"), strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), eResource);
						}
					}
				}
#endif
			}
			else
			{
				processResource(eResource, -1);
			}
		}

		// Building Culture change for a local resource
		for (int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
		{
			const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
			if (pkBuildingInfo)
			{
				// Do we have this building?
				if (GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
				{
					// Does eBuilding give culture with eResource?
					int iCulture = pkBuildingInfo->GetResourceCultureChange(eResource);

					if (iCulture != 0)
						iCulture *= GetCityBuildings()->GetNumBuilding(eBuilding);

					ChangeBaseYieldRateFromBuildings(YIELD_CULTURE, iCulture * iChange);

					// Does eBuilding give faith with eResource?
					int iFaith = pkBuildingInfo->GetResourceFaithChange(eResource);

					if (iFaith != 0)
						iFaith *= GetCityBuildings()->GetNumBuilding(eBuilding);

					ChangeBaseYieldRateFromBuildings(YIELD_FAITH, iFaith * iChange);

#if defined(MOD_BALANCE_CORE)
					int iHappiness = pkBuildingInfo->GetResourceHappiness(eResource);
					if (iHappiness != 0)
						iHappiness *= GetCityBuildings()->GetNumBuilding(eBuilding);
					ChangeBaseHappinessFromBuildings(iHappiness * iChange);
#endif
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Does eBuilding pass the local resource requirement test?
bool CvCity::IsBuildingLocalResourceValid(BuildingTypes eBuilding, bool bTestVisible, CvString* toolTipSink) const
{
	VALIDATE_OBJECT
	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if (pkBuildingInfo == NULL)
		return false;

	// ANDs: City must have ALL of these nearby
	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResource = (ResourceTypes)pkBuildingInfo->GetLocalResourceAnd(iResourceLoop);

		// Doesn't require a resource in this AND slot
		if (eResource == NO_RESOURCE)
			continue;

		CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
		if (pkResource == NULL)
			continue;

		// City doesn't have resource locally - return false immediately
		if (!IsHasResourceLocal(eResource, bTestVisible))
		{
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_LOCAL_RESOURCE", pkResource->GetTextKey(), pkResource->GetIconString());
			return false;
		}
	}

	int iOrResources = 0;

	// ORs: City must have ONE of these nearby
	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResource = (ResourceTypes)pkBuildingInfo->GetLocalResourceOr(iResourceLoop);

		// Doesn't require a resource in this AND slot
		if (eResource == NO_RESOURCE)
			continue;

		CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
		if (pkResource == NULL)
			continue;

		// City has resource locally - return true immediately
		if (IsHasResourceLocal(eResource, bTestVisible))
			return true;

		// If we get here it means we passed the AND tests but not one of the OR tests
		GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_LOCAL_RESOURCE", pkResource->GetTextKey(), pkResource->GetIconString());

		// Increment counter for OR we don't have
		iOrResources++;
	}

	// No OR resource requirements (and passed the AND test above)
	if (iOrResources == 0)
		return true;

	return false;
}

//	--------------------------------------------------------------------------------
/// Does eBuilding pass the resource monopoly requirement test?
bool CvCity::IsBuildingResourceMonopolyValid(BuildingTypes eBuilding, CvString* toolTipSink) const
{
	VALIDATE_OBJECT
	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if (pkBuildingInfo == NULL)
		return false;

	// ANDs: City must have ALL of these nearby
	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResource = NO_RESOURCE;

		// If this is a corporation HQ, consider it's corporation resource ANDs instead!
		// Still want to support Buildings
		const CvBuildingClassInfo& kBuildingClass = pkBuildingInfo->GetBuildingClassInfo();
		CorporationTypes eCorporation = kBuildingClass.getCorporationType();
		if (kBuildingClass.IsHeadquarters() && eCorporation != NO_CORPORATION)
		{
			CvCorporationEntry* pkCorporationInfo = GC.getCorporationInfo(eCorporation);
			if (pkCorporationInfo)
			{
				eResource = (ResourceTypes)pkCorporationInfo->GetResourceMonopolyAnd(iResourceLoop);
			}
		}
		else
		{
			eResource = (ResourceTypes)pkBuildingInfo->GetResourceMonopolyAnd(iResourceLoop);
		}

		// Doesn't require a resource in this AND slot
		if (eResource == NO_RESOURCE)
			continue;

		CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
		if (pkResource == NULL)
			continue;

		if (!GET_PLAYER(getOwner()).HasGlobalMonopoly(eResource))
		{
			int iOwnedNumResource = GET_PLAYER(getOwner()).getNumResourceTotal(eResource, false) + GET_PLAYER(getOwner()).getResourceExport(eResource);
			if (iOwnedNumResource > 0)
			{
				int iTotalNumResource = GC.getMap().getNumResources(eResource);
				if (iTotalNumResource > 0)
				{
					int iValue = ((iOwnedNumResource * 100) / iTotalNumResource);
					GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_NEED_MONOPOLY", pkResource->GetTextKey(), pkResource->GetIconString(), iValue);
				}
			}
			return false;
		}
		else if (GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(getOwner(), eResource))
		{
			return false;
		}
	}

	int iOrResources = 0;

	// ORs: City must have ONE of these nearby
	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResource = NO_RESOURCE;

		// If this is a corporation HQ, consider it's corporation resource ORs instead!
		// Still want to support Buildings
		const CvBuildingClassInfo& kBuildingClass = pkBuildingInfo->GetBuildingClassInfo();
		CorporationTypes eCorporation = kBuildingClass.getCorporationType();
		if (kBuildingClass.IsHeadquarters() && eCorporation != NO_CORPORATION)
		{

			CvCorporationEntry* pkCorporationInfo = GC.getCorporationInfo(eCorporation);
			if (pkCorporationInfo)
			{
				eResource = (ResourceTypes)pkCorporationInfo->GetResourceMonopolyOr(iResourceLoop);
			}
		}
		else
		{
			eResource = (ResourceTypes)pkBuildingInfo->GetResourceMonopolyOr(iResourceLoop);
		}

		// Doesn't require a resource in this AND slot
		if (eResource == NO_RESOURCE)
			continue;

		CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
		if (pkResource == NULL)
			continue;

		if (GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(getOwner(), eResource))
			continue;

		if (GET_PLAYER(getOwner()).HasGlobalMonopoly(eResource))
			return true;

		// If we get here it means we passed the AND tests but not one of the OR tests
		int iOwnedNumResource = GET_PLAYER(getOwner()).getNumResourceTotal(eResource, false) + GET_PLAYER(getOwner()).getResourceExport(eResource);
		if (iOwnedNumResource > 0)
		{
			int iTotalNumResource = GC.getMap().getNumResources(eResource);
			if (iTotalNumResource > 0)
			{
				int iValue = ((iOwnedNumResource * 100) / iTotalNumResource);
				GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_NEED_MONOPOLY", pkResource->GetTextKey(), pkResource->GetIconString(), iValue);
			}
		}

		// Increment counter for OR we don't have
		iOrResources++;
	}

	// No OR resource requirements (and passed the AND test above)
	if (iOrResources == 0)
		return true;

	return false;
}

#if defined(MOD_BALANCE_CORE)
bool CvCity::IsBuildingFeatureValid(BuildingTypes eBuilding, CvString* toolTipSink) const
{
	VALIDATE_OBJECT
	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if (pkBuildingInfo == NULL)
		return false;

	// ANDs: City must have ALL of these nearby
	for (int iFeatureLoop = 0; iFeatureLoop < GC.getNumFeatureInfos(); iFeatureLoop++)
	{
		FeatureTypes eFeature = (FeatureTypes)pkBuildingInfo->GetFeatureAnd(iFeatureLoop);

		// Doesn't require a feature in this AND slot
		if (eFeature == NO_FEATURE)
			continue;

		CvFeatureInfo* pkFeature = GC.getFeatureInfo(eFeature);
		if (pkFeature == NULL)
			continue;

		// City doesn't have feature locally - return false immediately
		if (!IsHasFeatureLocal(eFeature))
		{
			GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_LOCAL_FEATURE", pkFeature->GetTextKey());
			return false;
		}
	}

	int iOrFeatures = 0;

	// ORs: City must have ONE of these nearby
	for (int iFeatureLoop = 0; iFeatureLoop < GC.getNumFeatureInfos(); iFeatureLoop++)
	{
		FeatureTypes eFeature = (FeatureTypes)pkBuildingInfo->GetFeatureOr(iFeatureLoop);

		// Doesn't require a feature in this AND slot
		if (eFeature == NO_FEATURE)
			continue;

		CvFeatureInfo* pkFeature = GC.getFeatureInfo(eFeature);
		if (pkFeature == NULL)
			continue;

		// City has feature locally - return true immediately
		if (IsHasFeatureLocal(eFeature))
			return true;

		// If we get here it means we passed the AND tests but not one of the OR tests
		GC.getGame().BuildCannotPerformActionHelpText(toolTipSink, "TXT_KEY_NO_ACTION_BUILDING_LOCAL_FEATURE", pkFeature->GetTextKey());

		// Increment counter for OR we don't have
		iOrFeatures++;
	}

	// No OR resource requirements (and passed the AND test above)
	if (iOrFeatures == 0)
		return true;

	return false;
}
#endif
//	--------------------------------------------------------------------------------
/// What Resource does this City want so that it goes into WLTKD?
ResourceTypes CvCity::GetResourceDemanded(bool bHideUnknown) const
{
	VALIDATE_OBJECT
	ResourceTypes eResourceDemanded = static_cast<ResourceTypes>(m_iResourceDemanded);

	// If we're not hiding the result then don't bother with looking at tech
	if (!bHideUnknown)
	{
		return eResourceDemanded;
	}

	if (eResourceDemanded != NO_RESOURCE)
	{
		CvResourceInfo* pInfo = GC.getResourceInfo(eResourceDemanded);
		if (pInfo)
		{
			// Is there no Reveal Tech or do we have it?
			if (GET_TEAM(getTeam()).IsResourceRevealed(eResourceDemanded))
			{
				return eResourceDemanded;
			}
		}
	}

	// We don't have the Tech to reveal the currently demanded Resource
	return NO_RESOURCE;
}

//	--------------------------------------------------------------------------------
/// Sets what Resource this City wants so that it goes into WLTKD
void CvCity::SetResourceDemanded(ResourceTypes eResource)
{
	VALIDATE_OBJECT
	m_iResourceDemanded = (ResourceTypes)eResource;
}

//	--------------------------------------------------------------------------------
/// Picks a Resource for this City to want
void CvCity::DoPickResourceDemanded()
{
	if (!GET_PLAYER(getOwner()).isMajorCiv())
		return;

	ResourceTypes ePreviousResource = GetResourceDemanded(false);
	SetResourceDemanded(NO_RESOURCE);
	SetResourceDemandedCounter(0);

	if (MOD_BALANCE_CORE_HAPPINESS && GetWeLoveTheKingDayCounter() > 0)
		return;

	// Create the list of invalid Luxury Resources
	set<ResourceTypes> localLuxuryResources;

	// Loop through all Plots near this City to see if there's Luxuries we should invalidate
	for (int iPlotLoop = 0; iPlotLoop < GetNumWorkablePlots(); iPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(getX(), getY(), iPlotLoop);
		if (pLoopPlot != NULL)
		{
			ResourceTypes eResource = pLoopPlot->getResourceType();
			if (eResource != NO_RESOURCE)
			{
				if (GC.getResourceInfo(eResource)->getResourceUsage() == RESOURCEUSAGE_LUXURY)
				{
					localLuxuryResources.insert(eResource);
				}
			}
		}
	}

	// VP: Only resources discovered by this player (or a player met by this player) are valid prior to researching Astronomy
	bool bOnlyAllowDiscoveredResources = MOD_BALANCE_VP && !GET_TEAM(getTeam()).canEmbarkAllWaterPassage();
	set<ResourceTypes> DiscoveredLuxuryResources;
	if (bOnlyAllowDiscoveredResources)
	{
		// First compile a list of the major civ teams this player has met
		vector<TeamTypes> vTeamsMet;
		vTeamsMet.push_back(getTeam());
		CvDiplomacyAI* pDiplo = GET_PLAYER(getOwner()).GetDiplomacyAI();
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes)iPlayerLoop;
			if (pDiplo->IsPlayerValid(eLoopPlayer) && std::find(vTeamsMet.begin(), vTeamsMet.end(), GET_PLAYER(eLoopPlayer).getTeam()) == vTeamsMet.end())
				vTeamsMet.push_back(GET_PLAYER(eLoopPlayer).getTeam());
		}

		// Now go through the map and see which resources have been discovered by civs this player has met
		CvMap& theMap = GC.getMap();
		int iNumPlots = theMap.numPlots();
		for (int iI = 0; iI < iNumPlots; iI++)
		{
			CvPlot* pLoopPlot = theMap.plotByIndexUnchecked(iI);
			ResourceTypes eResource = pLoopPlot->getResourceType(getTeam()); // This check will ignore resources that haven't been discovered by this player (tech)
			if (eResource != NO_RESOURCE)
			{
				CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
				if (pkResource && pkResource->getResourceUsage() == RESOURCEUSAGE_LUXURY && localLuxuryResources.find(eResource) == localLuxuryResources.end()
					&& DiscoveredLuxuryResources.find(eResource) == DiscoveredLuxuryResources.end())
				{
					for (std::vector<TeamTypes>::iterator it = vTeamsMet.begin(); it != vTeamsMet.end(); it++)
					{
						if (pLoopPlot->isRevealed(*it, false))
							DiscoveredLuxuryResources.insert(eResource);
					}
				}
			}
		}
	}

	// Create list of valid Luxuries
	vector<ResourceTypes> veValidLuxuryResources;
	CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
	for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
	{
		ResourceTypes eResource = (ResourceTypes)iResourceLoop;

		// Is this a Luxury Resource?
		CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
		if (pkResource && pkResource->getResourceUsage() == RESOURCEUSAGE_LUXURY)
		{
			// VP: Can't reroll the same resource as before!
			if (MOD_BALANCE_VP && ePreviousResource == eResource)
				continue;

			// VP: No unknown tech resources
			if (MOD_BALANCE_VP && !GET_TEAM(getTeam()).IsResourceRevealed(eResource))
				continue;

			// Is the Resource actually on the map?
			if (GC.getMap().getNumResources(eResource) <= 0)
				continue;

			if (pkResource->isOnlyMinorCivs())
				continue;

			if (pLeague && pLeague->IsLuxuryHappinessBanned(eResource))
				continue;

			if (localLuxuryResources.find(eResource) != localLuxuryResources.end())
				continue;

			if (bOnlyAllowDiscoveredResources && DiscoveredLuxuryResources.find(eResource) == DiscoveredLuxuryResources.end())
				continue;

			if (!MOD_BALANCE_VP && GET_PLAYER(getOwner()).getNumResourceAvailable(eResource) > 0)
				continue;

			veValidLuxuryResources.push_back(eResource);
		}
	}

	// Is there actually anything in our vector? - 0 can be valid if we already have everything, for example
	if (veValidLuxuryResources.size() == 0)
	{
		return;
	}

	// Now pick a Luxury we can use
	int iVectorIndex = GC.getGame().getSmallFakeRandNum(veValidLuxuryResources.size(), plot()->GetPlotIndex() + GET_PLAYER(getOwner()).GetPseudoRandomSeed());
	ResourceTypes eResource = (ResourceTypes)veValidLuxuryResources[iVectorIndex];

	//hurk! STOP.
	if (eResource == NO_RESOURCE)
		return;

	SetResourceDemanded(eResource);

	// Notification
	CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
	if (pNotifications)
	{
		if (GET_PLAYER(getOwner()).GetPlayerTraits()->IsExpansionWLTKD())
		{
			Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_RESOURCE_DEMAND_UA");
			strText << getNameKey() << GC.getResourceInfo(eResource)->GetTextKey();
			Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_RESOURCE_DEMAND");
			strSummary << getNameKey() << GC.getResourceInfo(eResource)->GetTextKey();
			pNotifications->Add(NOTIFICATION_REQUEST_RESOURCE, strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), eResource);
		}
		else
		{
			Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_RESOURCE_DEMAND");
			strText << getNameKey() << GC.getResourceInfo(eResource)->GetTextKey();
			Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_RESOURCE_DEMAND");
			strSummary << getNameKey() << GC.getResourceInfo(eResource)->GetTextKey();
			pNotifications->Add(NOTIFICATION_REQUEST_RESOURCE, strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), eResource);
		}
	}

	// If we're on the debug map it's too small for us to care
	if (GC.getMap().getWorldSize() != WORLDSIZE_DEBUG)
	{
		CvAssertMsg(false, "Gameplay: Didn't find a Luxury for City to demand.");
	}
}

//	--------------------------------------------------------------------------------
/// Checks to see if we have the Resource demanded and if so starts WLTKD in this City
void CvCity::DoTestResourceDemanded()
{
	VALIDATE_OBJECT
	ResourceTypes eResource = GetResourceDemanded();

	if (eResource == NO_RESOURCE && GetResourceDemandedCountdown() <= 0)
		DoPickResourceDemanded();

	if (GetWeLoveTheKingDayCounter() > 0)
	{
		ChangeWeLoveTheKingDayCounter(-1);

		// WLTKD over!
		if (GetWeLoveTheKingDayCounter() == 0)
		{
#if defined(MOD_BALANCE_CORE)
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityEndsWLTKD, getOwner(), getX(), getY(), 0);
#endif
			DoPickResourceDemanded();

			if (getOwner() == GC.getGame().getActivePlayer())
			{
				Localization::String localizedText;
				// Know what the next Demanded Resource is
				if (GetResourceDemanded() != NO_RESOURCE)
				{
					localizedText = Localization::Lookup("TXT_KEY_MISC_CITY_WLTKD_ENDED_KNOWN_RESOURCE");
					localizedText << getNameKey() << GC.getResourceInfo(GetResourceDemanded())->GetTextKey();
				}
				// Don't know what the next Demanded Resource is
				else
				{
					localizedText = Localization::Lookup("TXT_KEY_MISC_CITY_WLTKD_ENDED_UNKNOWN_RESOURCE");
					localizedText << getNameKey();
				}

				DLLUI->AddCityMessage(0, GetIDInfo(), getOwner(), false, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), localizedText.toUTF8());
			}
		}
	}
	else
	{
		if (eResource != NO_RESOURCE)
		{
			// Do we have the right Resource?
			if (GET_PLAYER(getOwner()).getNumResourceTotal(eResource) > 0)
			{
				int iWLTKD = MOD_BALANCE_VP ? /*20 in CP, 10 in VP*/ (GD_INT_GET(CITY_RESOURCE_WLTKD_TURNS) / 2) : GD_INT_GET(CITY_RESOURCE_WLTKD_TURNS);
				iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iWLTKD /= 100;

				ChangeWeLoveTheKingDayCounter(iWLTKD);

				CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
				if (pNotifications)
				{
					if (GET_PLAYER(getOwner()).GetPlayerTraits()->IsExpansionWLTKD())
					{
						Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UA_RESOURCE");
						strText << GC.getResourceInfo(eResource)->GetTextKey() << getNameKey() << iWLTKD << /*25*/ GD_INT_GET(WLTKD_GROWTH_MULTIPLIER);
						Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UA_RESOURCE");
						strSummary << getNameKey();
						pNotifications->Add(NOTIFICATION_REQUEST_RESOURCE, strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), eResource);
					}
					else
					{
						Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD");
						strText << GC.getResourceInfo(eResource)->GetTextKey() << getNameKey();
						Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD");
						strSummary << getNameKey();
						pNotifications->Add(NOTIFICATION_REQUEST_RESOURCE, strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), eResource);
					}
				}
			}
			else
			{
				ChangeResourceDemandedCounter(1);

				// Is it time to pick something new?
				if (GD_INT_GET(WLTKD_RESOURCE_RESET_TURNS) > 0)
				{
					int iResetTurns = /*0 in CP, 30 in VP*/ GD_INT_GET(WLTKD_RESOURCE_RESET_TURNS);
					iResetTurns *= GC.getGame().getGameSpeedInfo().getTrainPercent();
					iResetTurns /= 100;

					if (GetResourceDemandedCounter() >= iResetTurns)
						DoPickResourceDemanded();
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Figure out how long it should be before this City demands a Resource
void CvCity::DoSeedResourceDemandedCountdown()
{
	VALIDATE_OBJECT

	int iNumTurns = /*15*/ GD_INT_GET(RESOURCE_DEMAND_COUNTDOWN_BASE);

	if (isCapital())
	{
		iNumTurns += /*25*/ GD_INT_GET(RESOURCE_DEMAND_COUNTDOWN_CAPITAL_ADD);
	}

	int iRand = /*10*/ GD_INT_GET(RESOURCE_DEMAND_COUNTDOWN_RAND);
#if defined(MOD_CORE_REDUCE_RANDOMNESS)
	iNumTurns += GC.getGame().getSmallFakeRandNum(iRand, plot()->GetPlotIndex() + GET_PLAYER(getOwner()).GetPseudoRandomSeed());
#else
	iNumTurns += GC.getGame().getJonRandNum(iRand, "City Resource demanded rand.");
#endif

	SetResourceDemandedCountdown(iNumTurns);
}

//	--------------------------------------------------------------------------------
/// How long before we pick a Resource to demand
int CvCity::GetResourceDemandedCountdown() const
{
	VALIDATE_OBJECT
	return m_iDemandResourceCounter;
}

//	--------------------------------------------------------------------------------
/// How long before we pick a Resource to demand
void CvCity::SetResourceDemandedCountdown(int iValue)
{
	VALIDATE_OBJECT
	m_iDemandResourceCounter = iValue;
}

//	--------------------------------------------------------------------------------
/// How long before we pick a Resource to demand
void CvCity::ChangeResourceDemandedCountdown(int iChange)
{
	VALIDATE_OBJECT
	if (iChange != 0)
		m_iDemandResourceCounter += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::getFoodTurnsLeft() const
{
	VALIDATE_OBJECT
	int iDeltaPerTurn = foodDifferenceTimes100(false);
	int iFoodStored = getFoodTimes100();
	int iFoodNeededToGrow = (growthThreshold() * 100 - iFoodStored);

	//growing
	if (iDeltaPerTurn > 0)
	{
		if (iFoodNeededToGrow > 0)
		{
			int iTurnsLeft = iFoodNeededToGrow / iDeltaPerTurn;
			//correct for truncation
			if (iTurnsLeft * iDeltaPerTurn < iFoodNeededToGrow)
				iTurnsLeft++;

			return iTurnsLeft;
		}
		else //already over the threshold
			return 0;
	}
	//starving
	else if (iDeltaPerTurn < 0)
	{
		int iTurnsLeft = iFoodStored / iDeltaPerTurn;
		//correct for truncation
		if (iTurnsLeft * iDeltaPerTurn < iFoodStored)
			iTurnsLeft++;

		return -iTurnsLeft;
	}

	//stagnation, let's assume this is a large number
	return iFoodNeededToGrow;
}

//	--------------------------------------------------------------------------------
bool CvCity::isProduction() const
{
	VALIDATE_OBJECT
	return (headOrderQueueNode() != NULL);
}


//	--------------------------------------------------------------------------------
bool CvCity::isProductionLimited() const
{
	VALIDATE_OBJECT
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_TRAIN:
		{
			CvUnitEntry* pkUnitInfo = GC.getUnitInfo((UnitTypes)(pOrderNode->iData1));
			if (pkUnitInfo)
			{
				return isLimitedUnitClass((UnitClassTypes)(pkUnitInfo->GetUnitClassType()));
			}
		}
		break;

		case ORDER_CONSTRUCT:
		{
			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo((BuildingTypes)pOrderNode->iData1);
			if (pkBuildingInfo)
			{
				return isLimitedWonderClass(pkBuildingInfo->GetBuildingClassInfo());
			}
		}
		break;

		case ORDER_CREATE:
			return isLimitedProject((ProjectTypes)(pOrderNode->iData1));
			break;

		case ORDER_PREPARE:
			break;

		case ORDER_MAINTAIN:
			break;

		default:
			CvAssertMsg(false, "pOrderNode->eOrderType failed to match a valid option");
			break;
		}
	}

	return false;
}


//	--------------------------------------------------------------------------------
bool CvCity::isProductionUnit() const
{
	VALIDATE_OBJECT
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		return (pOrderNode->eOrderType == ORDER_TRAIN);
	}

	return false;
}


//	--------------------------------------------------------------------------------
bool CvCity::isProductionBuilding() const
{
	VALIDATE_OBJECT
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		return (pOrderNode->eOrderType == ORDER_CONSTRUCT);
	}

	return false;
}


//	--------------------------------------------------------------------------------
bool CvCity::isProductionProject() const
{
	VALIDATE_OBJECT
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		return (pOrderNode->eOrderType == ORDER_CREATE);
	}

	return false;
}


//	--------------------------------------------------------------------------------
bool CvCity::isProductionSpecialist() const
{
	VALIDATE_OBJECT
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		return (pOrderNode->eOrderType == ORDER_PREPARE);
	}

	return false;
}


//	--------------------------------------------------------------------------------
bool CvCity::isProductionProcess() const
{
	VALIDATE_OBJECT
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		return (pOrderNode->eOrderType == ORDER_MAINTAIN);
	}

	return false;
}


//	--------------------------------------------------------------------------------
bool CvCity::canContinueProduction(OrderData order)
{
	VALIDATE_OBJECT
	switch (order.eOrderType)
	{
	case ORDER_TRAIN:
		return canTrain((UnitTypes)(order.iData1), true);
		break;

	case ORDER_CONSTRUCT:
		return canConstruct((BuildingTypes)(order.iData1), true);
		break;

	case ORDER_CREATE:
		return canCreate((ProjectTypes)(order.iData1), true);
		break;

	case ORDER_PREPARE:
		return canPrepare((SpecialistTypes)(order.iData1), true);
		break;

	case ORDER_MAINTAIN:
		return canMaintain((ProcessTypes)(order.iData1), true);
		break;

	default:
		CvAssertMsg(false, "order.eOrderType failed to match a valid option");
		break;
	}

	return false;
}


//	--------------------------------------------------------------------------------
int CvCity::getProductionExperience(UnitTypes eUnit)
{
	VALIDATE_OBJECT
	CvPlayerAI& kOwner = GET_PLAYER(getOwner());
	int iExperience = getFreeExperience() + kOwner.getFreeExperience();
	int iExperienceModifier = 0;

	if (eUnit != NO_UNIT)
	{
		CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
		if (pkUnitInfo)
		{
			DomainTypes eDomain = (DomainTypes)pkUnitInfo->GetDomainType();
			UnitCombatTypes eUnitCombat = (UnitCombatTypes)(pkUnitInfo->GetUnitCombatType());

			if (eUnitCombat != NO_UNITCOMBAT)
			{
				iExperience += getUnitCombatFreeExperience(eUnitCombat);
				iExperience += kOwner.getUnitCombatFreeExperiences(eUnitCombat);
			}
			if (eDomain != NO_DOMAIN)
			{
				iExperience += getDomainFreeExperience(eDomain);
				iExperience += getDomainFreeExperienceFromGreatWorks(eDomain);
				iExperience += getDomainFreeExperienceFromGreatWorksGlobal(eDomain);
				iExperience += kOwner.GetDomainFreeExperience(eDomain);
				iExperienceModifier += kOwner.GetPlayerTraits()->GetDomainFreeExperienceModifier((DomainTypes)(pkUnitInfo->GetDomainType()));
			}

			iExperience += getSpecialistFreeExperience();
		}
	}

	if (iExperienceModifier != 0)
	{
		iExperience *= (100 + iExperienceModifier);
		iExperience /= 100;
	}

	return std::max(0, iExperience);
}


//	--------------------------------------------------------------------------------
void CvCity::addProductionExperience(CvUnit* pUnit, bool bConscript, bool bGoldPurchase)
{
	VALIDATE_OBJECT
	bool HalveXP = (bConscript || (bGoldPurchase && MOD_BALANCE_CORE_HALF_XP_PURCHASE && GET_PLAYER(getOwner()).GetNoXPLossUnitPurchase() <= 0 && !pUnit->getUnitInfo().CanMoveAfterPurchase()));

	if (pUnit->canAcquirePromotionAny())
	{
		pUnit->changeExperienceTimes100(getProductionExperience(pUnit->getUnitType()) * 100 / ((HalveXP) ? 2 : 1));

		// XP2 Achievement
		if (MOD_API_ACHIEVEMENTS && getOwner() != NO_PLAYER)
		{
			CvPlayer& kOwner = GET_PLAYER(getOwner());
			if (!GC.getGame().isGameMultiPlayer() && kOwner.isHuman() && kOwner.isLocalPlayer())
			{
				// This unit begins with a promotion from XP, and part of that XP came from filled Great Work slots
				if ((pUnit->getExperienceTimes100() / 100) >= pUnit->experienceNeeded() && getDomainFreeExperienceFromGreatWorks((DomainTypes)pUnit->getUnitInfo().GetDomainType()) > 0)
				{
					// We have a Royal Library
					BuildingTypes eRoyalLibrary = (BuildingTypes)GC.getInfoTypeForString("BUILDING_ROYAL_LIBRARY", true);
					if (eRoyalLibrary != NO_BUILDING && GetCityBuildings()->GetNumBuilding(eRoyalLibrary) > 0)
					{
						gDLL->UnlockAchievement(ACHIEVEMENT_XP2_19);
					}
				}
			}
		}
	}

	vector<PromotionTypes> freePromotions = getFreePromotions();
	for (size_t iI = 0; iI < freePromotions.size(); iI++)
	{
		CvPromotionEntry* pkPromotionInfo = GC.getPromotionInfo(freePromotions[iI]);
		if (pkPromotionInfo)
		{
			if ((pUnit->getUnitCombatType() != NO_UNITCOMBAT && pkPromotionInfo->GetUnitCombatClass(pUnit->getUnitCombatType()))
				|| (::IsPromotionValidForCivilianUnitType(freePromotions[iI], pUnit->getUnitType())))
			{
				pUnit->setHasPromotion(freePromotions[iI], true);
			}
		}
	}

	pUnit->testPromotionReady();
}


//	--------------------------------------------------------------------------------
UnitTypes CvCity::getProductionUnit() const
{
	VALIDATE_OBJECT
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_TRAIN:
			return ((UnitTypes)(pOrderNode->iData1));
			break;

		case ORDER_CONSTRUCT:
		case ORDER_CREATE:
		case ORDER_PREPARE:
		case ORDER_MAINTAIN:
			break;

		default:
			CvAssertMsg(false, "pOrderNode->eOrderType failed to match a valid option");
			break;
		}
	}

	return NO_UNIT;
}


//	--------------------------------------------------------------------------------
UnitAITypes CvCity::getProductionUnitAI() const
{
	VALIDATE_OBJECT
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_TRAIN:
			return ((UnitAITypes)(pOrderNode->iData2));
			break;

		case ORDER_CONSTRUCT:
		case ORDER_CREATE:
		case ORDER_PREPARE:
		case ORDER_MAINTAIN:
			break;

		default:
			CvAssertMsg(false, "pOrderNode->eOrderType failed to match a valid option");
			break;
		}
	}

	return NO_UNITAI;
}


//	--------------------------------------------------------------------------------
BuildingTypes CvCity::getProductionBuilding() const
{
	VALIDATE_OBJECT
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_TRAIN:
			break;

		case ORDER_CONSTRUCT:
			return ((BuildingTypes)(pOrderNode->iData1));
			break;

		case ORDER_CREATE:
		case ORDER_PREPARE:
		case ORDER_MAINTAIN:
			break;

		default:
			CvAssertMsg(false, "pOrderNode->eOrderType failed to match a valid option");
			break;
		}
	}

	return NO_BUILDING;
}


//	--------------------------------------------------------------------------------
ProjectTypes CvCity::getProductionProject() const
{
	VALIDATE_OBJECT
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_TRAIN:
		case ORDER_CONSTRUCT:
			break;

		case ORDER_CREATE:
			return ((ProjectTypes)(pOrderNode->iData1));
			break;

		case ORDER_PREPARE:
		case ORDER_MAINTAIN:
			break;

		default:
			CvAssertMsg(false, "pOrderNode->eOrderType failed to match a valid option");
			break;
		}
	}

	return NO_PROJECT;
}


//	--------------------------------------------------------------------------------
SpecialistTypes CvCity::getProductionSpecialist() const
{
	VALIDATE_OBJECT
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_TRAIN:
		case ORDER_CONSTRUCT:
		case ORDER_CREATE:
			break;

		case ORDER_PREPARE:
			return ((SpecialistTypes)(pOrderNode->iData1));
			break;

		case ORDER_MAINTAIN:
			break;

		default:
			CvAssertMsg(false, "pOrderNode->eOrderType failed to match a valid option");
			break;
		}
	}

	return NO_SPECIALIST;
}

//	--------------------------------------------------------------------------------
ProcessTypes CvCity::getProductionProcess() const
{
	VALIDATE_OBJECT
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_TRAIN:
		case ORDER_CONSTRUCT:
		case ORDER_CREATE:
		case ORDER_PREPARE:
			break;

		case ORDER_MAINTAIN:
			return ((ProcessTypes)(pOrderNode->iData1));
			break;

		default:
			CvAssertMsg(false, "pOrderNode->eOrderType failed to match a valid option");
			break;
		}
	}

	return NO_PROCESS;
}


//	--------------------------------------------------------------------------------
const char* CvCity::getProductionName() const
{
	VALIDATE_OBJECT
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_TRAIN:
		{
			CvUnitEntry* pkUnitInfo = GC.getUnitInfo((UnitTypes)pOrderNode->iData1);
			if (pkUnitInfo)
			{
				return pkUnitInfo->GetDescription();
			}
		}
		break;

		case ORDER_CONSTRUCT:
		{
			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo((BuildingTypes)pOrderNode->iData1);
			if (pkBuildingInfo)
			{
				return pkBuildingInfo->GetDescription();
			}
		}
		break;

		case ORDER_CREATE:
		{
			CvProjectEntry* pkProjectInfo = GC.getProjectInfo((ProjectTypes)pOrderNode->iData1);
			if (pkProjectInfo)
			{
				return pkProjectInfo->GetDescription();
			}
		}
		break;

		case ORDER_PREPARE:
		{
			CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo((SpecialistTypes)pOrderNode->iData1);
			if (pkSpecialistInfo)
			{
				return pkSpecialistInfo->GetDescription();
			}
		}
		break;

		case ORDER_MAINTAIN:
		{
			CvProcessInfo* pkProcessInfo = GC.getProcessInfo((ProcessTypes)pOrderNode->iData1);
			if (pkProcessInfo)
			{
				return pkProcessInfo->GetDescription();
			}
		}
		break;

		default:
			CvAssertMsg(false, "pOrderNode->eOrderType failed to match a valid option");
			break;
		}
	}

	return "";
}


//	--------------------------------------------------------------------------------
int CvCity::getGeneralProductionTurnsLeft() const
{
	VALIDATE_OBJECT
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_TRAIN:
			return getProductionTurnsLeft((UnitTypes)pOrderNode->iData1, 0);
			break;

		case ORDER_CONSTRUCT:
			return getProductionTurnsLeft((BuildingTypes)pOrderNode->iData1, 0);
			break;

		case ORDER_CREATE:
			return getProductionTurnsLeft((ProjectTypes)pOrderNode->iData1, 0);
			break;

		case ORDER_PREPARE:
			return getProductionTurnsLeft((SpecialistTypes)pOrderNode->iData1, 0);
			break;

		case ORDER_MAINTAIN:
#if defined(MOD_PROCESS_STOCKPILE)
			return getProductionTurnsLeft((ProcessTypes)pOrderNode->iData1, 0);
#else
			return 0;
#endif
			break;

		default:
			CvAssertMsg(false, "pOrderNode->eOrderType failed to match a valid option");
			break;
		}
	}

	return 0;
}


//	--------------------------------------------------------------------------------
const char* CvCity::getProductionNameKey() const
{
	VALIDATE_OBJECT
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_TRAIN:
		{
			CvUnitEntry* pkUnitInfo = GC.getUnitInfo((UnitTypes)pOrderNode->iData1);
			if (pkUnitInfo)
			{
				return pkUnitInfo->GetTextKey();
			}
		}
		break;

		case ORDER_CONSTRUCT:
		{
			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo((BuildingTypes)pOrderNode->iData1);
			if (pkBuildingInfo)
			{
				return pkBuildingInfo->GetTextKey();
			}
		}
		break;

		case ORDER_CREATE:
		{
			CvProjectEntry* pkProjectInfo = GC.getProjectInfo((ProjectTypes)pOrderNode->iData1);
			if (pkProjectInfo)
			{
				return pkProjectInfo->GetTextKey();
			}
		}
		break;

		case ORDER_PREPARE:
		{
			CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo((SpecialistTypes)pOrderNode->iData1);
			if (pkSpecialistInfo)
			{
				return pkSpecialistInfo->GetTextKey();
			}
		}
		break;

		case ORDER_MAINTAIN:
		{
			CvProcessInfo* pkProcessInfo = GC.getProcessInfo((ProcessTypes)pOrderNode->iData1);
			if (pkProcessInfo)
			{
				return pkProcessInfo->GetTextKey();
			}
		}
		break;

		default:
			CvAssertMsg(false, "pOrderNode->eOrderType failed to match a valid option");
			break;
		}
	}

	return "";
}

//	--------------------------------------------------------------------------------
bool isUnitTypeFoodProduction(PlayerTypes ePlayer, UnitTypes eUnit)
{
	CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
	if (pkUnitInfo == NULL)
		return false;

	if (pkUnitInfo->IsFoodProduction())
	{
		return true;
	}

	if (GET_PLAYER(ePlayer).isMilitaryFoodProduction())
	{
		if (pkUnitInfo->IsMilitaryProduction())
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
bool CvCity::isFoodProduction() const
{
	VALIDATE_OBJECT
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_TRAIN:
			return isUnitTypeFoodProduction(getOwner(), (UnitTypes)(pOrderNode->iData1));
			break;

		case ORDER_CONSTRUCT:
		case ORDER_CREATE:
		case ORDER_PREPARE:
		case ORDER_MAINTAIN:
			break;

		default:
			CvAssertMsg(false, "pOrderNode->eOrderType failed to match a valid option");
			break;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
int CvCity::getFirstUnitOrder(UnitTypes eUnit) const
{
	VALIDATE_OBJECT
	int iCount = 0;
	const OrderData* pOrderNode = headOrderQueueNode();

	while (pOrderNode != NULL)
	{
		if (pOrderNode->eOrderType == ORDER_TRAIN)
		{
			if (pOrderNode->iData1 == eUnit)
			{
				return iCount;
			}
		}

		iCount++;

		pOrderNode = nextOrderQueueNode(pOrderNode);
	}

	return -1;
}


//	--------------------------------------------------------------------------------
int CvCity::getFirstBuildingOrder(BuildingTypes eBuilding) const
{
	VALIDATE_OBJECT
	int iCount = 0;
	const OrderData* pOrderNode = headOrderQueueNode();

	while (pOrderNode != NULL)
	{
		if (pOrderNode->eOrderType == ORDER_CONSTRUCT)
		{
			if (pOrderNode->iData1 == eBuilding)
			{
				return iCount;
			}
		}

		iCount++;

		pOrderNode = nextOrderQueueNode(pOrderNode);
	}

	return -1;
}
bool CvCity::isBuildingInQueue(BuildingTypes eBuilding) const
{
	VALIDATE_OBJECT
	const OrderData* pOrderNode = headOrderQueueNode();

	while (pOrderNode != NULL)
	{
		if (pOrderNode->eOrderType == ORDER_CONSTRUCT)
		{
			if (pOrderNode->iData1 == eBuilding)
			{
				return true;
			}
		}

		pOrderNode = nextOrderQueueNode(pOrderNode);
	}

	return false;
}


//	--------------------------------------------------------------------------------
int CvCity::getFirstProjectOrder(ProjectTypes eProject) const
{
	VALIDATE_OBJECT
	int iCount = 0;
	const OrderData* pOrderNode = headOrderQueueNode();

	while (pOrderNode != NULL)
	{
		if (pOrderNode->eOrderType == ORDER_CREATE)
		{
			if (pOrderNode->iData1 == eProject)
			{
				return iCount;
			}
		}

		iCount++;

		pOrderNode = nextOrderQueueNode(pOrderNode);
	}

	return -1;
}


//	--------------------------------------------------------------------------------
int CvCity::getFirstSpecialistOrder(SpecialistTypes eSpecialist) const
{
	VALIDATE_OBJECT
	int iCount = 0;
	const OrderData* pOrderNode = headOrderQueueNode();

	while (pOrderNode != NULL)
	{
		if (pOrderNode->eOrderType == ORDER_PREPARE)
		{
			if (pOrderNode->iData1 == eSpecialist)
			{
				return iCount;
			}
		}

		iCount++;

		pOrderNode = nextOrderQueueNode(pOrderNode);
	}

	return -1;
}

//	--------------------------------------------------------------------------------
int CvCity::getNumTrainUnitAI(UnitAITypes eUnitAI) const
{
	VALIDATE_OBJECT
	int iCount = 0;
	const OrderData* pOrderNode = headOrderQueueNode();

	while (pOrderNode != NULL)
	{
		if (pOrderNode->eOrderType == ORDER_TRAIN)
		{
			if (pOrderNode->iData2 == eUnitAI)
			{
				iCount++;
			}
		}

		pOrderNode = nextOrderQueueNode(pOrderNode);
	}

	return iCount;
}


//	--------------------------------------------------------------------------------
int CvCity::getProduction() const
{
	VALIDATE_OBJECT
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_TRAIN:
			return getUnitProduction((UnitTypes)(pOrderNode->iData1));
			break;

		case ORDER_CONSTRUCT:
			return m_pCityBuildings->GetBuildingProduction((BuildingTypes)(pOrderNode->iData1));
			break;

		case ORDER_CREATE:
			return getProjectProduction((ProjectTypes)(pOrderNode->iData1));
			break;

		case ORDER_PREPARE:
			return getSpecialistProduction((SpecialistTypes)(pOrderNode->iData1));
			break;

		case ORDER_MAINTAIN:
#if defined(MOD_PROCESS_STOCKPILE)
			return getProcessProduction((ProcessTypes)(pOrderNode->iData1));
#endif
			break;

		default:
			CvAssertMsg(false, "pOrderNode->eOrderType failed to match a valid option");
			break;
		}
	}

	return 0;
}


//	--------------------------------------------------------------------------------
int CvCity::getProductionTimes100() const
{
	VALIDATE_OBJECT
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_TRAIN:
			return getUnitProductionTimes100((UnitTypes)(pOrderNode->iData1));
			break;

		case ORDER_CONSTRUCT:
			return m_pCityBuildings->GetBuildingProductionTimes100((BuildingTypes)(pOrderNode->iData1));
			break;

		case ORDER_CREATE:
			return getProjectProductionTimes100((ProjectTypes)(pOrderNode->iData1));
			break;

		case ORDER_PREPARE:
			return getSpecialistProductionTimes100((SpecialistTypes)(pOrderNode->iData1));
			break;

		case ORDER_MAINTAIN:
#if defined(MOD_PROCESS_STOCKPILE)
			return getProcessProductionTimes100((ProcessTypes)(pOrderNode->iData1));
#endif
			break;

		default:
			CvAssertMsg(false, "pOrderNode->eOrderType failed to match a valid option");
			break;
		}
	}

	return 0;
}


//	--------------------------------------------------------------------------------
int CvCity::getProductionNeeded() const
{
	VALIDATE_OBJECT
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_TRAIN:
			return getProductionNeeded((UnitTypes)(pOrderNode->iData1));
			break;

		case ORDER_CONSTRUCT:
			return getProductionNeeded((BuildingTypes)(pOrderNode->iData1));
			break;

		case ORDER_CREATE:
			return getProductionNeeded((ProjectTypes)(pOrderNode->iData1));
			break;

		case ORDER_PREPARE:
			return getProductionNeeded((SpecialistTypes)(pOrderNode->iData1));
			break;

		case ORDER_MAINTAIN:
#if defined(MOD_PROCESS_STOCKPILE)
			return getProductionNeeded((ProcessTypes)(pOrderNode->iData1));
#endif
			break;

		default:
			CvAssertMsg(false, "pOrderNode->eOrderType failed to match a valid option");
			break;
		}
	}

	return INT_MAX;
}

//	--------------------------------------------------------------------------------
int CvCity::getProductionNeeded(UnitTypes eUnit) const
{
	VALIDATE_OBJECT
	int iNumProductionNeeded = GET_PLAYER(getOwner()).getProductionNeeded(eUnit, false);

	if (eUnit != NO_UNIT)
	{
		CvUnitEntry* pGameUnit = GC.getUnitInfo(eUnit);

#if defined(MOD_RESOURCES_PRODUCTION_COST_MODIFIERS)
		int iCostMod = 0;

		UnitCombatTypes eUnitCombat = (UnitCombatTypes)pGameUnit->GetUnitCombatType();
		EraTypes eUnitEra = (EraTypes)pGameUnit->GetEra();

		if (eUnitEra == NO_ERA)
		{
			eUnitEra = GET_PLAYER(getOwner()).GetCurrentEra();
		}

		if (MOD_RESOURCES_PRODUCTION_COST_MODIFIERS && eUnitCombat != NO_UNITCOMBAT && eUnitEra != NO_ERA)
		{
			for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
			{
				const ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);
				CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
				if (pkResource && pkResource->isHasUnitCombatProductionCostModifiersLocal() && IsHasResourceLocal(eResource, false))
				{
					iCostMod += pkResource->getUnitCombatProductionCostModifiersLocal(eUnitCombat, eUnitEra);
				}
			}
		}

		// Cost modifiers must be applied before the investment code
		iNumProductionNeeded *= (iCostMod + 100);
		iNumProductionNeeded /= 100;
#endif
#if defined(MOD_BALANCE_CORE_UNIT_INVESTMENTS)
		if (MOD_BALANCE_CORE_UNIT_INVESTMENTS || (MOD_BALANCE_CORE && pGameUnit->GetSpaceshipProject() != NO_PROJECT))
		{
			const UnitClassTypes eUnitClass = (UnitClassTypes)(pGameUnit->GetUnitClassType());
			if (IsUnitInvestment(eUnitClass))
			{
				int iTotalDiscount = (/*-50*/ GD_INT_GET(BALANCE_UNIT_INVESTMENT_BASELINE) + GET_PLAYER(getOwner()).GetPlayerTraits()->GetInvestmentModifier() + GET_PLAYER(getOwner()).GetInvestmentModifier());
				iNumProductionNeeded *= (iTotalDiscount + 100);
				iNumProductionNeeded /= 100;
			}
		}
#endif
	}

	return max(1, iNumProductionNeeded);
}

//	--------------------------------------------------------------------------------
int CvCity::getProductionNeeded(BuildingTypes eBuilding) const
{
	VALIDATE_OBJECT
	int iNumProductionNeeded = GET_PLAYER(getOwner()).getProductionNeeded(eBuilding);

	if (eBuilding != NO_BUILDING)
	{
		CvBuildingEntry* pGameBuilding = GC.getBuildingInfo(eBuilding);
		if (pGameBuilding)
		{
			const BuildingClassTypes eBuildingClass = (BuildingClassTypes)(pGameBuilding->GetBuildingClassType());

#if defined(MOD_RESOURCES_PRODUCTION_COST_MODIFIERS)
			int iCostMod = 0;
			EraTypes eBuildingEra = (EraTypes)pGameBuilding->GetEra();

			bool bWonder = false;
			if (eBuildingClass != NO_BUILDINGCLASS)
			{
				const CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
				if (pkBuildingClassInfo)
				{
					bWonder = isWorldWonderClass(*pkBuildingClassInfo) || isTeamWonderClass(*pkBuildingClassInfo) || isNationalWonderClass(*pkBuildingClassInfo);
				}
			}

			if (eBuildingEra == NO_ERA)
			{
				eBuildingEra = GET_PLAYER(getOwner()).GetCurrentEra();
			}

			if (MOD_RESOURCES_PRODUCTION_COST_MODIFIERS && bWonder == false && eBuildingEra != NO_ERA)
			{
				for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
				{
					const ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);
					CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
					if (pkResource && pkResource->isHasBuildingProductionCostModifiersLocal() && IsHasResourceLocal(eResource, false))
					{
						iCostMod += pkResource->getBuildingProductionCostModifiersLocal(eBuildingEra);
					}
				}
			}

			// Cost modifiers must be applied before the investment code
			iNumProductionNeeded *= (iCostMod + 100);
			iNumProductionNeeded /= 100;
#endif
#if defined(MOD_BALANCE_CORE_BUILDING_INVESTMENTS)
			if (MOD_BALANCE_CORE_BUILDING_INVESTMENTS && eBuildingClass != NO_BUILDINGCLASS && IsBuildingInvestment(eBuildingClass))
			{
				int iTotalDiscount = (/*-50*/ GD_INT_GET(BALANCE_BUILDING_INVESTMENT_BASELINE) + GET_PLAYER(getOwner()).GetPlayerTraits()->GetInvestmentModifier() + GET_PLAYER(getOwner()).GetInvestmentModifier());
				const CvBuildingClassInfo& kBuildingClassInfo = pGameBuilding->GetBuildingClassInfo();
				if (::isWorldWonderClass(kBuildingClassInfo))

				{
					iTotalDiscount /= 2;
				}
				iNumProductionNeeded *= (iTotalDiscount + 100);
				iNumProductionNeeded /= 100;

				// Investment checks when AmountComplete >= 50 moved here
				int AmountComplete = GetCityBuildings()->GetBuildingProduction(eBuilding);
				int AmountNeeded = max(1, iNumProductionNeeded);
				if (AmountComplete >= AmountNeeded)
				{
					int iProductionDifference = getProductionDifference(iNumProductionNeeded, AmountComplete, getProductionModifier(), false, false);
					return max(AmountNeeded, AmountComplete - iProductionDifference); //allow one turn of overflow
				}
			}
#endif
		}
	}

	return max(1, iNumProductionNeeded);
}

//	--------------------------------------------------------------------------------
int CvCity::getProductionNeeded(ProjectTypes eProject) const
{
	VALIDATE_OBJECT
	int iNumProductionNeeded = GET_PLAYER(getOwner()).getProductionNeeded(eProject);

	CvProjectEntry* pProject = GC.getProjectInfo(eProject);
	if (pProject != NULL)
	{
		iNumProductionNeeded += pProject->CostScalerNumberOfRepeats() * getProjectCount(eProject);
		iNumProductionNeeded += pProject->CostScalerEra() * GET_PLAYER(getOwner()).GetCurrentEra();
	}

	return max(1, iNumProductionNeeded);
}

//	--------------------------------------------------------------------------------
int CvCity::getProductionNeeded(SpecialistTypes eSpecialist) const
{
	VALIDATE_OBJECT
	int iNumProductionNeeded = GET_PLAYER(getOwner()).getProductionNeeded(eSpecialist);

	return max(1, iNumProductionNeeded);
}

//	--------------------------------------------------------------------------------
int CvCity::getProductionTurnsLeft() const
{
	VALIDATE_OBJECT
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_TRAIN:
			return getProductionTurnsLeft(((UnitTypes)(pOrderNode->iData1)), 0);
			break;

		case ORDER_CONSTRUCT:
			return getProductionTurnsLeft(((BuildingTypes)(pOrderNode->iData1)), 0);
			break;

		case ORDER_CREATE:
			return getProductionTurnsLeft(((ProjectTypes)(pOrderNode->iData1)), 0);
			break;

		case ORDER_PREPARE:
			return getProductionTurnsLeft(((SpecialistTypes)(pOrderNode->iData1)), 0);
			break;

		case ORDER_MAINTAIN:
#if defined(MOD_PROCESS_STOCKPILE)
			return getProductionTurnsLeft(((ProcessTypes)(pOrderNode->iData1)), 0);
#endif
			break;

		default:
			CvAssertMsg(false, "pOrderNode->eOrderType failed to match a valid option");
			break;
		}
	}

	return INT_MAX;
}


//	--------------------------------------------------------------------------------
int CvCity::getProductionTurnsLeft(UnitTypes eUnit, int iNum) const
{
	VALIDATE_OBJECT
	int iProduction = 0;
	int iFirstUnitOrder = getFirstUnitOrder(eUnit);

	if ((iFirstUnitOrder == -1) || (iFirstUnitOrder == iNum))
	{
		iProduction += getUnitProductionTimes100(eUnit);
	}

	int iProductionNeeded = getProductionNeeded(eUnit) * 100;
	int iProductionModifier = getProductionModifier(eUnit);

	return getProductionTurnsLeft(iProductionNeeded, iProduction,
		getProductionDifferenceTimes100(iProductionNeeded, iProduction, iProductionModifier, isUnitTypeFoodProduction(getOwner(), eUnit), (iNum == 0)),
		getProductionDifferenceTimes100(iProductionNeeded, iProduction, iProductionModifier, isUnitTypeFoodProduction(getOwner(), eUnit), false));
}


//	--------------------------------------------------------------------------------
int CvCity::getProductionTurnsLeft(BuildingTypes eBuilding, int iNum) const
{
	VALIDATE_OBJECT
	int iProduction = 0;
	int iFirstBuildingOrder = getFirstBuildingOrder(eBuilding);

	if ((iFirstBuildingOrder == -1) || (iFirstBuildingOrder == iNum))
	{
		iProduction += m_pCityBuildings->GetBuildingProductionTimes100(eBuilding);
	}

	int iProductionNeeded = getProductionNeeded(eBuilding) * 100;
	int iProductionModifier = getProductionModifier(eBuilding);

	return getProductionTurnsLeft(iProductionNeeded, iProduction,
		getProductionDifferenceTimes100(iProductionNeeded, iProduction, iProductionModifier, false, (iNum == 0)),
		getProductionDifferenceTimes100(iProductionNeeded, iProduction, iProductionModifier, false, false));
}


//	--------------------------------------------------------------------------------
int CvCity::getProductionTurnsLeft(ProjectTypes eProject, int iNum) const
{
	VALIDATE_OBJECT
	int iProduction = 0;
	int iFirstProjectOrder = getFirstProjectOrder(eProject);

	if ((iFirstProjectOrder == -1) || (iFirstProjectOrder == iNum))
	{
		iProduction += getProjectProductionTimes100(eProject);
	}

	int iProductionNeeded = getProductionNeeded(eProject) * 100;
	int iProductionModifier = getProductionModifier(eProject);

	return getProductionTurnsLeft(iProductionNeeded, iProduction, getProductionDifferenceTimes100(iProductionNeeded, iProduction, iProductionModifier, false, (iNum == 0)), getProductionDifferenceTimes100(iProductionNeeded, iProduction, iProductionModifier, false, false));
}


//	--------------------------------------------------------------------------------
int CvCity::getProductionTurnsLeft(SpecialistTypes eSpecialist, int iNum) const
{
	VALIDATE_OBJECT
	int iProduction = 0;
	int iFirstSpecialistOrder = getFirstSpecialistOrder(eSpecialist);

	if ((iFirstSpecialistOrder == -1) || (iFirstSpecialistOrder == iNum))
	{
		iProduction += getSpecialistProductionTimes100(eSpecialist);
	}

	int iProductionNeeded = getProductionNeeded(eSpecialist) * 100;
	int iProductionModifier = getProductionModifier(eSpecialist);

	return getProductionTurnsLeft(iProductionNeeded, iProduction, getProductionDifferenceTimes100(iProductionNeeded, iProduction, iProductionModifier, false, (iNum == 0)), getProductionDifferenceTimes100(iProductionNeeded, iProduction, iProductionModifier, false, false));
}

#if defined(MOD_PROCESS_STOCKPILE)
//	--------------------------------------------------------------------------------
int CvCity::getProductionNeeded(ProcessTypes eProcess) const
{
	VALIDATE_OBJECT
	if (eProcess == GC.getInfoTypeForString("PROCESS_STOCKPILE")) 
	{
		return GET_PLAYER(getOwner()).getMaxStockpile();
	}

	return INT_MAX;
}

//	--------------------------------------------------------------------------------
int CvCity::getProductionTurnsLeft(ProcessTypes eProcess, int) const
{
	VALIDATE_OBJECT
	if (eProcess == GC.getInfoTypeForString("PROCESS_STOCKPILE")) 
	{
		int iProduction = getOverflowProduction();
		int iProductionNeeded = GET_PLAYER(getOwner()).getMaxStockpile();
		int iProductionModifier = getProductionModifier(eProcess);
		int iProductionDifference = getProductionDifference(iProductionNeeded, iProduction, iProductionModifier, false, false);

		return getProductionTurnsLeft(iProductionNeeded, iProduction, iProductionDifference, iProductionDifference);
	}

	return INT_MAX;
}
#endif
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
bool CvCity::IsBuildingInvestment(BuildingClassTypes eBuildingClass) const
{
	FAssert(eBuildingClass >= 0);
	FAssert(eBuildingClass < GC.getNumBuildingClassInfos());

	return m_abBuildingInvestment[eBuildingClass];
}
//	--------------------------------------------------------------------------------
void CvCity::SetBuildingInvestment(BuildingClassTypes eBuildingClass, bool bNewValue)
{
	FAssert(eBuildingClass >= 0);
	FAssert(eBuildingClass < GC.getNumBuildingClassInfos());

	if (bNewValue)
	{
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityInvestedBuilding, getOwner(), GetID(), eBuildingClass, bNewValue);
	}

	m_abBuildingInvestment[eBuildingClass] = bNewValue;
}
//	--------------------------------------------------------------------------------
bool CvCity::IsProcessInternationalProject(ProcessTypes eProcess) const
{
	for (int iI = 0; iI < GC.getNumLeagueProjectInfos(); iI++)
	{
		LeagueProjectTypes eLeagueProject = (LeagueProjectTypes)iI;
		CvLeagueProjectEntry* pInfo = GC.getLeagueProjectInfo(eLeagueProject);
		if (pInfo && pInfo->GetProcess() == eProcess) {
			return true;
		}
	}
	return false;
}
//	--------------------------------------------------------------------------------
bool CvCity::IsUnitInvestment(UnitClassTypes eUnitClass) const
{
	FAssert(eUnitClass >= 0);
	FAssert(eUnitClass < GC.getNumUnitClassInfos());

	return m_abUnitInvestment[eUnitClass];
}
//	--------------------------------------------------------------------------------
void CvCity::SetUnitInvestment(UnitClassTypes eUnitClass, bool bNewValue)
{
	FAssert(eUnitClass >= 0);
	FAssert(eUnitClass < GC.getNumUnitClassInfos());

	if (bNewValue)
	{
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityInvestedUnit, getOwner(), GetID(), eUnitClass, bNewValue);
	}

	m_abUnitInvestment[eUnitClass] = bNewValue;
}

//	--------------------------------------------------------------------------------
bool CvCity::IsBuildingConstructed(BuildingClassTypes eBuildingClass) const
{
	FAssert(eBuildingClass >= 0);
	FAssert(eBuildingClass < GC.getNumBuildingClassInfos());

	return m_abBuildingConstructed[eBuildingClass];
}
//	--------------------------------------------------------------------------------
void CvCity::SetBuildingConstructed(BuildingClassTypes eBuildingClass, bool bNewValue)
{
	FAssert(eBuildingClass >= 0);
	FAssert(eBuildingClass < GC.getNumBuildingClassInfos());

	m_abBuildingConstructed[eBuildingClass] = bNewValue;
}
#endif
//	--------------------------------------------------------------------------------
int CvCity::getProductionTurnsLeft(int iProductionNeeded, int iProduction, int iFirstProductionDifference, int iProductionDifference) const
{
	VALIDATE_OBJECT
	int iProductionLeft = std::max(0, (iProductionNeeded - iProduction - iFirstProductionDifference));

	if (iProductionDifference == 0)
	{
		return iProductionLeft + 1;
	}

	int iTurnsLeft = (iProductionLeft / iProductionDifference);

	if ((iTurnsLeft * iProductionDifference) < iProductionLeft)
	{
		iTurnsLeft++;
	}

	iTurnsLeft++;

	return std::max(1, iTurnsLeft);
}

//	--------------------------------------------------------------------------------
int CvCity::GetPurchaseCost(UnitTypes eUnit)
{
	VALIDATE_OBJECT
	CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
	if (pkUnitInfo == NULL)
	{
		//Should never happen
		return 0;
	}

	bool bIsSpaceshipPart = pkUnitInfo->GetSpaceshipProject() != NO_PROJECT;

	if (bIsSpaceshipPart && !GET_PLAYER(getOwner()).IsEnablesSSPartPurchase())
		return -1;

	int iModifier = pkUnitInfo->GetHurryCostModifier();
	if (!bIsSpaceshipPart && iModifier == -1)
	{
		return -1;
	}

	int iCost = GetPurchaseCostFromProduction(getProductionNeeded(eUnit));
	iCost *= (100 + iModifier);
	iCost /= 100;

	// Cost of purchasing units modified?
	iCost *= (100 + GET_PLAYER(getOwner()).GetUnitPurchaseCostModifier());
	iCost /= 100;

	int iLimitSpaceshipPurchase = GC.getGame().GetGameLeagues()->GetSpaceShipPurchaseMod(getOwner());
	if (bIsSpaceshipPart && iLimitSpaceshipPurchase != 0)
	{
		iCost *= (100 + GC.getGame().GetGameLeagues()->GetSpaceShipPurchaseMod(getOwner()));
		iCost /= 100;
	}

	if (MOD_BALANCE_CORE_PURCHASE_COST_INCREASE)
	{
		//Increase cost based on # of techs researched.
		int iTechProgress = (GET_TEAM(getTeam()).GetTeamTechs()->GetNumTechsKnown() * 100) / GC.getNumTechInfos();

		iTechProgress /= 2;
		if (iTechProgress > 0)
		{
			iCost *= (100 + iTechProgress);
			iCost /= 100;
		}
	}

	if (MOD_BALANCE_VP)
	{
		bool bCombat = pkUnitInfo->GetCombat() > 0 || pkUnitInfo->GetRangedCombat() > 0 || pkUnitInfo->GetNukeDamageLevel() != -1;

		// If a unit can fight AND settle, use the highest of the two penalties, don't add them
		if (bCombat && pkUnitInfo->IsFound())
		{
			int iWarWeariness = GET_PLAYER(getOwner()).GetCulture()->GetWarWeariness();
			int iSettlerPenalty = std::min(0, getHappinessDelta() * /*10*/ GD_INT_GET(LOCAL_UNHAPPY_SETTLER_PRODUCTION_PENALTY) * -1) + GET_PLAYER(getOwner()).GetUnhappinessSettlerCostPenalty();
			// Can't be lower than -75% from Unhappiness.
			if (iSettlerPenalty < /*-75*/ GD_INT_GET(UNHAPPY_MAX_UNIT_PRODUCTION_PENALTY))
			{
				iSettlerPenalty = GD_INT_GET(UNHAPPY_MAX_UNIT_PRODUCTION_PENALTY);
			}

			int iCostMod = std::max(iWarWeariness, iSettlerPenalty*-1);
			if (iCostMod > 0)
			{
				iCost *= 100 + iCostMod;
				iCost /= 100;
			}
		}
		else if (bCombat)
		{
			int iWarWeariness = GET_PLAYER(getOwner()).GetCulture()->GetWarWeariness();
			if (iWarWeariness > 0)
			{
				//Let's do the yield mods.			
				iCost *= 100 + iWarWeariness;
				iCost /= 100;
			}
		}
		else if (pkUnitInfo->IsFound())
		{
			int iTempMod = min(0, getHappinessDelta() * /*10*/ GD_INT_GET(LOCAL_UNHAPPY_SETTLER_PRODUCTION_PENALTY) * -1);
			iTempMod += GET_PLAYER(getOwner()).GetUnhappinessSettlerCostPenalty();

			// Can't be lower than -75% from Unhappiness.
			if (iTempMod < /*-75*/ GD_INT_GET(UNHAPPY_MAX_UNIT_PRODUCTION_PENALTY))
			{
				iTempMod = GD_INT_GET(UNHAPPY_MAX_UNIT_PRODUCTION_PENALTY);
			}

			iTempMod *= -1;

			//Let's do the yield mods.
			iCost *= 100 + iTempMod;
			iCost /= 100;
		}
	}

	if (MOD_BALANCE_CORE_PURCHASE_COST_INCREASE)
	{
		//Decrease base cost, then increase based on # of cities in empire.
		iCost *= 8;
		iCost /= 10;
	}

	// Make the number not be funky
	int iDivisor = /*10*/ GD_INT_GET(GOLD_PURCHASE_VISIBLE_DIVISOR);
	iCost /= iDivisor;
	iCost *= iDivisor;

	return iCost;
}

//	--------------------------------------------------------------------------------
int CvCity::GetFaithPurchaseCost(UnitTypes eUnit, bool bIncludeBeliefDiscounts)
{
	VALIDATE_OBJECT
	int iCost = 0;
	CvPlayer& kPlayer = GET_PLAYER(m_eOwner);

	CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
	if (pkUnitInfo == NULL)
	{
		//Should never happen
		return iCost;
	}

	ReligionTypes eFoundedReligion = kPlayer.GetReligions()->GetOwnedReligion();
	ReligionTypes eFollowingReligion = kPlayer.GetReligions()->GetStateReligion();
	ReligionTypes eCityReligion = GetCityReligions()->GetReligiousMajority();

	// LATE-GAME GREAT PERSON
	SpecialUnitTypes eSpecialUnitGreatPerson = (SpecialUnitTypes)GC.getInfoTypeForString("SPECIALUNIT_PEOPLE");
	if (pkUnitInfo->GetSpecialUnitType() == eSpecialUnitGreatPerson)
	{
		// We must be into the industrial era
		if (kPlayer.GetCurrentEra() >= GC.getGame().GetGameReligions()->GetFaithPurchaseGreatPeopleEra(&kPlayer))
		{
			// Must be proper great person for our civ
			const UnitClassTypes eUnitClass = (UnitClassTypes)pkUnitInfo->GetUnitClassType();
			if (eUnitClass != NO_UNITCLASS)
			{
				const UnitTypes eThisPlayersUnitType = kPlayer.GetSpecificUnitType(eUnitClass);

				if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_PROPHET", true /*bHideAssert*/)) //here
				{
					// Can't be bought if didn't start religion
					if (eFoundedReligion == NO_RELIGION)
					{
						iCost = -1;
					}
					else
					{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
						iCost = kPlayer.GetReligions()->GetCostNextProphet(true /*bIncludeBeliefDiscounts*/, false /*bAdjustForSpeedDifficulty*/, MOD_GLOBAL_TRULY_FREE_GP);
#else
						iCost = kPlayer.GetReligions()->GetCostNextProphet(true /*bIncludeBeliefDiscounts*/, false /*bAdjustForSpeedDifficulty*/);
#endif
					}
				}
				else if (eThisPlayersUnitType == eUnit)
				{
					PolicyBranchTypes eBranch = NO_POLICY_BRANCH_TYPE;
					int iNum = 0;

					// Check social policy tree
					if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_WRITER", true /*bHideAssert*/))
					{
						eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_AESTHETICS", true /*bHideAssert*/);
						iNum = kPlayer.getWritersFromFaith();
					}
					else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_ARTIST", true /*bHideAssert*/))
					{
						eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_AESTHETICS", true /*bHideAssert*/);
						iNum = kPlayer.getArtistsFromFaith();
					}
					else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_MUSICIAN", true /*bHideAssert*/))
					{
						eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_AESTHETICS", true /*bHideAssert*/);
						iNum = kPlayer.getMusiciansFromFaith();
					}
					else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_SCIENTIST", true /*bHideAssert*/))
					{
						eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_RATIONALISM", true /*bHideAssert*/);
						iNum = kPlayer.getScientistsFromFaith();
					}
					else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_MERCHANT", true /*bHideAssert*/))
					{
						eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_COMMERCE", true /*bHideAssert*/);
						iNum = kPlayer.getMerchantsFromFaith();
					}
					else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_ENGINEER", true /*bHideAssert*/))
					{
						eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_TRADITION", true /*bHideAssert*/);
						iNum = kPlayer.getEngineersFromFaith();
					}
					else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_GREAT_GENERAL", true /*bHideAssert*/))
					{
						eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_HONOR", true /*bHideAssert*/);
						iNum = kPlayer.getGeneralsFromFaith();
					}
					else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_GREAT_ADMIRAL", true /*bHideAssert*/))
					{
						eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_EXPLORATION", true /*bHideAssert*/);
						iNum = kPlayer.getAdmiralsFromFaith();
					}
					else if (MOD_BALANCE_VP && eUnitClass == GC.getInfoTypeForString("UNITCLASS_GREAT_DIPLOMAT", true /*bHideAssert*/))
					{
						eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_PATRONAGE", true /*bHideAssert*/);
						iNum = kPlayer.getDiplomatsFromFaith();
					}
#if defined(MOD_BALANCE_CORE)
					if (pkUnitInfo->IsGPExtra() == 1)
					{
						eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_PATRONAGE", true /*bHideAssert*/);
						iNum = kPlayer.getGPExtra1FromFaith();
					}
					else if (pkUnitInfo->IsGPExtra() == 2)
					{
						eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_PATRONAGE", true /*bHideAssert*/);
						iNum = kPlayer.getGPExtra2FromFaith();
					}

					else if (pkUnitInfo->IsGPExtra() == 3)
					{
						eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_PATRONAGE", true /*bHideAssert*/);
						iNum = kPlayer.getGPExtra3FromFaith();
					}

					else if (pkUnitInfo->IsGPExtra() == 4)
					{
						eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_PATRONAGE", true /*bHideAssert*/);
						iNum = kPlayer.getGPExtra4FromFaith();
					}

					else if (pkUnitInfo->IsGPExtra() == 5)
					{
						eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_PATRONAGE", true /*bHideAssert*/);
						iNum = kPlayer.getGPExtra5FromFaith();
					}
#endif

					bool bAllUnlockedByBelief = false;
					const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eFoundedReligion, getOwner());

					if (pReligion == NULL)
						pReligion = GC.getGame().GetGameReligions()->GetReligion(eFollowingReligion, getOwner());

					if (pReligion)
					{
						if (pReligion->m_Beliefs.IsFaithPurchaseAllGreatPeople(getOwner(), this) && kPlayer.GetCurrentEra() >= GC.getGame().GetGameReligions()->GetFaithPurchaseGreatPeopleEra(NULL))
						{
							bAllUnlockedByBelief = true;
						}
					}

#if defined(MOD_RELIGION_POLICY_BRANCH_FAITH_GP)
					if (MOD_RELIGION_POLICY_BRANCH_FAITH_GP)
					{
						bool bIsUnlocked = bAllUnlockedByBelief;

						if (!bIsUnlocked)
						{
							EraTypes eCurrentEra = kPlayer.GetCurrentEra();

							for (int iPolicyLoop = 0; iPolicyLoop < kPlayer.GetPlayerPolicies()->GetPolicies()->GetNumPolicies(); iPolicyLoop++)
							{
								const PolicyTypes eLoopPolicy = static_cast<PolicyTypes>(iPolicyLoop);
								CvPolicyEntry* pkLoopPolicyInfo = GC.getPolicyInfo(eLoopPolicy);
								if (pkLoopPolicyInfo)
								{
									// We have this policy
									if (kPlayer.HasPolicy(eLoopPolicy))
									{
										if (pkLoopPolicyInfo->IsFaithPurchaseUnitClass(eUnitClass, eCurrentEra))
										{
											bIsUnlocked = true;
											break;
										}
									}
								}
							}
						}

						if (bIsUnlocked)
						{
							iCost = GC.getGame().GetGameReligions()->GetFaithGreatPersonNumber(iNum + 1);
						}
					}
					else
					{
#endif

						if (bAllUnlockedByBelief || (eBranch != NO_POLICY_BRANCH_TYPE && kPlayer.GetPlayerPolicies()->IsPolicyBranchFinished(eBranch) && !kPlayer.GetPlayerPolicies()->IsPolicyBranchBlocked(eBranch)))
						{
							iCost = GC.getGame().GetGameReligions()->GetFaithGreatPersonNumber(iNum + 1);
						}
#if defined(MOD_RELIGION_POLICY_BRANCH_FAITH_GP)
					}
#endif
				}
			}
		}
	}

	// ALL OTHERS
	else
	{
		iCost = pkUnitInfo->GetFaithCost();
		int iMultiplier;

		// Cost goes up in later eras
		// Only Missionaries and Inquisitors for VP
		if (!MOD_BALANCE_VP || pkUnitInfo->IsSpreadReligion() || pkUnitInfo->IsRemoveHeresy())
		{
			EraTypes eEra = GET_TEAM(GET_PLAYER(getOwner()).getTeam()).GetCurrentEra();
			iMultiplier = GC.getEraInfo(eEra)->getFaithCostMultiplier();
			iCost = iCost * iMultiplier / 100;
		}

		if (pkUnitInfo->IsSpreadReligion() || pkUnitInfo->IsRemoveHeresy())
		{
			if (eCityReligion == NO_RELIGION || eCityReligion == RELIGION_PANTHEON)
				return 0;

			iMultiplier = (100 + GET_PLAYER(getOwner()).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_FAITH_COST_MODIFIER));
			iCost = iCost * iMultiplier / 100;
		}
	}

	// Adjust for game speed
	iCost *= GC.getGame().getGameSpeedInfo().getTrainPercent();
	iCost /= 100;

	// Adjust for difficulty
	if (pkUnitInfo->IsFoundReligion())
	{
		iCost *= GET_PLAYER(getOwner()).getHandicapInfo().getProphetPercent();
		iCost /= 100;

		if (!GET_PLAYER(getOwner()).isHuman())
		{
			iCost *= GC.getGame().getHandicapInfo().getAIProphetPercent();
			iCost /= 100;
		}
	}
	else
	{
		bool bCombat = pkUnitInfo->GetCombat() > 0 || pkUnitInfo->GetRangedCombat() > 0 || pkUnitInfo->GetNukeDamageLevel() != -1;
		if (bCombat)
		{
			iCost *= GET_PLAYER(getOwner()).getHandicapInfo().getTrainPercent();
			iCost /= 100;

			iCost *= std::max(0, GET_PLAYER(getOwner()).getHandicapInfo().getTrainPerEraModifier() * GC.getGame().getCurrentEra() + 100);
			iCost /= 100;

			if (!isHuman())
			{
				iCost *= GC.getGame().getHandicapInfo().getAITrainPercent();
				iCost /= 100;

				iCost *= std::max(0, GC.getGame().getHandicapInfo().getAITrainPerEraModifier() * GC.getGame().getCurrentEra() + 100);
				iCost /= 100;
			}
		}
		else
		{
			iCost *= GET_PLAYER(getOwner()).getHandicapInfo().getCivilianPercent();
			iCost /= 100;

			iCost *= std::max(0, GET_PLAYER(getOwner()).getHandicapInfo().getCivilianPerEraModifier() * GC.getGame().getCurrentEra() + 100);
			iCost /= 100;

			if (!isHuman())
			{
				iCost *= GC.getGame().getHandicapInfo().getAICivilianPercent();
				iCost /= 100;

				iCost *= std::max(0, GC.getGame().getHandicapInfo().getAICivilianPerEraModifier() * GC.getGame().getCurrentEra() + 100);
				iCost /= 100;
			}
		}
	}

	// Modify by any beliefs
	if (bIncludeBeliefDiscounts && !pkUnitInfo->IsFoundReligion() && eCityReligion > RELIGION_PANTHEON)
	{
		const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
		if (pReligion)
		{
			int iReligionCostMod = 0;

			if (pkUnitInfo->IsSpreadReligion())
				iReligionCostMod = pReligion->m_Beliefs.GetMissionaryCostModifier(getOwner(), this);
			else if (pkUnitInfo->IsRemoveHeresy())
				iReligionCostMod = pReligion->m_Beliefs.GetInquisitorCostModifier(getOwner(), this);

			if (iReligionCostMod != 0)
			{
				iCost *= (100 + iReligionCostMod);
				iCost /= 100;
			}
		}
	}

	//Modify for Resolution
	int iGetSpaceShipPurchaseMod = GC.getGame().GetGameLeagues()->GetSpaceShipPurchaseMod(getOwner());
	if ((pkUnitInfo->GetBaseHurry() > 0) && (iGetSpaceShipPurchaseMod != 0))
	{
		iCost *= (100 + iGetSpaceShipPurchaseMod);
		iCost /= 100;
	}

#if defined(MOD_BALANCE_CORE_PURCHASE_COST_INCREASE)

	/*
	if(MOD_BALANCE_CORE_PURCHASE_COST_INCREASE)
	{
		//Increase cost based on # of techs researched.
		int iTechProgress = (GET_TEAM(getTeam()).GetTeamTechs()->GetNumTechsKnown() * 100) / GC.getNumTechInfos();
		iTechProgress /= 2;
		if(iTechProgress > 0)
		{
			iCost *= (100 + iTechProgress);
			iCost /= 100;
		}
	}
	*/

	if (!pkUnitInfo->IsFoundReligion())
	{
		int iTraitValue = kPlayer.GetPlayerTraits()->GetFaithCostModifier();
		iCost *= (100 + iTraitValue);
		iCost /= 100;
	}
#endif

	if (MOD_BALANCE_VP)
	{
		bool bCombat = pkUnitInfo->GetCombat() > 0 || pkUnitInfo->GetRangedCombat() > 0 || pkUnitInfo->GetNukeDamageLevel() != -1;

		// If a unit can fight AND settle, use the highest of the two penalties, don't add them
		if (bCombat && pkUnitInfo->IsFound())
		{
			int iWarWeariness = GET_PLAYER(getOwner()).GetCulture()->GetWarWeariness();
			int iSettlerPenalty = std::min(0, getHappinessDelta() * /*10*/ GD_INT_GET(LOCAL_UNHAPPY_SETTLER_PRODUCTION_PENALTY) * -1) + GET_PLAYER(getOwner()).GetUnhappinessSettlerCostPenalty();
			// Can't be lower than -75% from Unhappiness.
			if (iSettlerPenalty < /*-75*/ GD_INT_GET(UNHAPPY_MAX_UNIT_PRODUCTION_PENALTY))
			{
				iSettlerPenalty = GD_INT_GET(UNHAPPY_MAX_UNIT_PRODUCTION_PENALTY);
			}

			int iCostMod = std::max(iWarWeariness, iSettlerPenalty*-1);
			if (iCostMod > 0)
			{
				iCost *= 100 + iCostMod;
				iCost /= 100;
			}
		}
		else if (bCombat)
		{
			int iWarWeariness = GET_PLAYER(getOwner()).GetCulture()->GetWarWeariness();
			if (iWarWeariness > 0)
			{
				//Let's do the yield mods.			
				iCost *= 100 + iWarWeariness;
				iCost /= 100;
			}
		}
		else if (pkUnitInfo->IsFound())
		{
			int iTempMod = min(0, getHappinessDelta() * /*10*/ GD_INT_GET(LOCAL_UNHAPPY_SETTLER_PRODUCTION_PENALTY) * -1);
			iTempMod += GET_PLAYER(getOwner()).GetUnhappinessSettlerCostPenalty();

			// Can't be lower than -75% from Unhappiness.
			if (iTempMod < /*-75*/ GD_INT_GET(UNHAPPY_MAX_UNIT_PRODUCTION_PENALTY))
			{
				iTempMod = GD_INT_GET(UNHAPPY_MAX_UNIT_PRODUCTION_PENALTY);
			}

			iTempMod *= -1;

			//Let's do the yield mods.
			iCost *= 100 + iTempMod;
			iCost /= 100;
		}
	}

	// Make the number not be funky
	int iDivisor = /*10*/ GD_INT_GET(GOLD_PURCHASE_VISIBLE_DIVISOR);
	iCost /= iDivisor;
	iCost *= iDivisor;

	return iCost;
}

//	--------------------------------------------------------------------------------
int CvCity::GetPurchaseCost(BuildingTypes eBuilding)
{
	VALIDATE_OBJECT
	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if (pkBuildingInfo == NULL)
		return -1;

	int iModifier = pkBuildingInfo->GetHurryCostModifier();

	if (iModifier == -1)
		return -1;

#if defined(MOD_BALANCE_CORE_BUILDING_INVESTMENTS)
	if (MOD_BALANCE_CORE_BUILDING_INVESTMENTS && (NO_BUILDING != eBuilding))
	{
		//Have we already invested here?
		CvBuildingEntry* pGameBuilding = GC.getBuildingInfo(eBuilding);
		const BuildingClassTypes eBuildingClass = (BuildingClassTypes)(pGameBuilding->GetBuildingClassType());
		if (IsBuildingInvestment(eBuildingClass))
		{
			return -1;
		}
	}
#endif
#if defined(MOD_BUILDINGS_PRO_RATA_PURCHASE)
	int iProductionNeeded = getProductionNeeded(eBuilding);

	if (MOD_BUILDINGS_PRO_RATA_PURCHASE) {
		// Deduct any current production towards this building
		int iProductionToDate = m_pCityBuildings->GetBuildingProduction(eBuilding);
		iProductionNeeded -= (iProductionToDate * gCustomMods.getOption("BUILDINGS_PRO_RATA_PURCHASE_DEPRECIATION", 80)) / 100;
	}

	int iCost = GetPurchaseCostFromProduction(iProductionNeeded);
#else
	int iCost = GetPurchaseCostFromProduction(getProductionNeeded(eBuilding));
#endif
	iCost *= (100 + iModifier);
	iCost /= 100;

	// Cost of purchasing buildings modified?
	iCost *= (100 + GET_PLAYER(getOwner()).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_BUILDING_PURCHASE_COST_MODIFIER));
	iCost /= 100;

#if defined(MOD_BALANCE_CORE)
	if (MOD_BALANCE_CORE_PURCHASE_COST_INCREASE)
	{
		//Increase cost based on # of techs researched.
		int iTechProgress = (GET_TEAM(getTeam()).GetTeamTechs()->GetNumTechsKnown() * 100) / GC.getNumTechInfos();
		iTechProgress /= 3;
		if (iTechProgress > 0)
		{
			iCost *= (100 + iTechProgress);
			iCost /= 100;
		}
	}
	if (MOD_BALANCE_CORE_BUILDING_INVESTMENTS)
	{
		//Decrease base cost, then increase based on # of cities in empire.
		iCost *= 6;
		iCost /= 10;
	}
#endif

	// Make the number not be funky
	int iDivisor = /*10*/ GD_INT_GET(GOLD_PURCHASE_VISIBLE_DIVISOR);
	iCost /= iDivisor;
	iCost *= iDivisor;

	return iCost;
}

//	--------------------------------------------------------------------------------
int CvCity::GetFaithPurchaseCost(BuildingTypes eBuilding)
{
	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if (pkBuildingInfo == NULL)
	{
		//Should never happen
		return 0;
	}

	int iCost = pkBuildingInfo->GetFaithCost();
	int iMultiplier;

	// Cost goes up in later eras (CP only)
	if (!MOD_BALANCE_VP)
	{
		EraTypes eEra = GET_TEAM(GET_PLAYER(getOwner()).getTeam()).GetCurrentEra();
		iMultiplier = GC.getEraInfo(eEra)->getFaithCostMultiplier();
		iCost = iCost * iMultiplier / 100;
	}

	iMultiplier = (100 + GET_PLAYER(getOwner()).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_FAITH_COST_MODIFIER));
	iCost = iCost * iMultiplier / 100;

	// Adjust for game speed
	iCost *= GC.getGame().getGameSpeedInfo().getConstructPercent();
	iCost /= 100;

	// Adjust for difficulty
	if (!isBarbarian())
	{
		iCost *= getHandicapInfo().getConstructPercent();
		iCost /= 100;

		if (!isHuman())
		{
			iCost *= GC.getGame().getHandicapInfo().getAIConstructPercent();
			iCost /= 100;
		}
	}
#if defined(MOD_BALANCE_CORE_PURCHASE_COST_INCREASE)
	/*
	if(MOD_BALANCE_CORE_PURCHASE_COST_INCREASE)
	{
		//Increase cost based on # of techs researched.
		int iTechProgress = (GET_TEAM(getTeam()).GetTeamTechs()->GetNumTechsKnown() * 100) / GC.getNumTechInfos();
		iTechProgress /= 2;
		if(iTechProgress > 0)
		{
			iCost *= (100 + iTechProgress);
			iCost /= 100;
		}
	}
	*/

	int iTraitValue = GET_PLAYER(getOwner()).GetPlayerTraits()->GetFaithCostModifier();
	iCost *= (100 + iTraitValue);
	iCost /= 100;

#endif

	// Make the number not be funky
	int iDivisor = /*10*/ GD_INT_GET(GOLD_PURCHASE_VISIBLE_DIVISOR);
	iCost /= iDivisor;
	iCost *= iDivisor;

	return iCost;
}

//	--------------------------------------------------------------------------------
int CvCity::GetPurchaseCost(ProjectTypes eProject)
{
	VALIDATE_OBJECT
	int iCost = GetPurchaseCostFromProduction(getProductionNeeded(eProject));

	// Make the number not be funky
	int iDivisor = /*10*/ GD_INT_GET(GOLD_PURCHASE_VISIBLE_DIVISOR);
	iCost /= iDivisor;
	iCost *= iDivisor;

	return iCost;
}

//	--------------------------------------------------------------------------------
/// Cost of Purchasing something based on the amount of Production it requires to construct
int CvCity::GetPurchaseCostFromProduction(int iProduction)
{
	VALIDATE_OBJECT
	// Gold per Production
	int iPurchaseCostBase = iProduction * /*30*/ GD_INT_GET(GOLD_PURCHASE_GOLD_PER_PRODUCTION);
	// Cost ramps up
	int iPurchaseCost = (int)pow((double)iPurchaseCostBase, (double) /*0.75f in CP, 0.68f in VP*/ GD_FLOAT_GET(HURRY_GOLD_PRODUCTION_EXPONENT));

	// Hurry Mod (Policies, etc.)
	HurryTypes eHurry = (HurryTypes)GC.getInfoTypeForString("HURRY_GOLD");

	if (eHurry != NO_HURRY)
	{
		int iHurryMod = GET_PLAYER(getOwner()).getHurryModifier(eHurry);

		if (iHurryMod != 0)
		{
			iPurchaseCost *= (100 + iHurryMod);
			iPurchaseCost /= 100;
		}
#if defined(MOD_BALANCE_CORE)
		if (getHurryModifier(eHurry) != 0)
		{
			iPurchaseCost *= (100 + getHurryModifier(eHurry));
			iPurchaseCost /= 100;
		}
#endif
	}

	// Game Speed modifier
	iPurchaseCost *= GC.getGame().getGameSpeedInfo().getHurryPercent();
	iPurchaseCost /= 100;

	return iPurchaseCost;
}

//	--------------------------------------------------------------------------------
void CvCity::setProduction(int iNewValue)
{
	VALIDATE_OBJECT
	if (isProductionUnit())
	{
		setUnitProduction(getProductionUnit(), iNewValue);
	}
	else if (isProductionBuilding())
	{
		m_pCityBuildings->SetBuildingProduction(getProductionBuilding(), iNewValue);
	}
	else if (isProductionProject())
	{
		setProjectProduction(getProductionProject(), iNewValue);
	}
	else if (isProductionSpecialist())
	{
		setSpecialistProduction(getProductionSpecialist(), iNewValue);
	}
}


//	--------------------------------------------------------------------------------
void CvCity::changeProduction(int iChange)
{
	VALIDATE_OBJECT
	if (isProductionUnit())
	{
		changeUnitProduction(getProductionUnit(), iChange);
	}
	else if (isProductionBuilding())
	{
		m_pCityBuildings->ChangeBuildingProduction(getProductionBuilding(), iChange);
	}
	else if (isProductionProject())
	{
		changeProjectProduction(getProductionProject(), iChange);
	}
	else if (isProductionSpecialist())
	{
		changeSpecialistProduction(getProductionSpecialist(), iChange);
	}
#if defined(MOD_BALANCE_CORE)
	else
	{
		changeOverflowProduction(iChange);
		if (GC.getLogging() && GC.getAILogging())
		{
			CvString strLogString;
			strLogString.Format("MOD - overflow production from policy/belief/trait/ruin/etc added: %d in %s.",
				iChange, getName().GetCString());
			GET_PLAYER(getOwner()).GetHomelandAI()->LogHomelandMessage(strLogString);
		}
	}
#endif
}

//	--------------------------------------------------------------------------------
void CvCity::setProductionTimes100(int iNewValue)
{
	VALIDATE_OBJECT
	if (isProductionUnit())
	{
		setUnitProductionTimes100(getProductionUnit(), iNewValue);
	}
	else if (isProductionBuilding())
	{
		m_pCityBuildings->SetBuildingProductionTimes100(getProductionBuilding(), iNewValue);
	}
	else if (isProductionProject())
	{
		setProjectProductionTimes100(getProductionProject(), iNewValue);
	}
	else if (isProductionSpecialist())
	{
		setSpecialistProductionTimes100(getProductionSpecialist(), iNewValue);
	}
}

//	--------------------------------------------------------------------------------
void CvCity::changeProductionTimes100(int iChange)
{
	VALIDATE_OBJECT
	if (isProductionUnit())
	{
		changeUnitProductionTimes100(getProductionUnit(), iChange);
	}
	else if (isProductionBuilding())
	{
		m_pCityBuildings->ChangeBuildingProductionTimes100(getProductionBuilding(), iChange);
	}
	else if (isProductionProject())
	{
		changeProjectProductionTimes100(getProductionProject(), iChange);
	}
	else if (isProductionSpecialist())
	{
		changeSpecialistProductionTimes100(getProductionSpecialist(), iChange);
	}
	else if (isProductionProcess())
	{
		doProcess();
	}

#if defined(MOD_TRAITS_TRADE_ROUTE_PRODUCTION_SIPHON)
	if (MOD_TRAITS_TRADE_ROUTE_PRODUCTION_SIPHON)
	{
		PlayerTypes iPlayer = getOwner();
		if (iPlayer != NO_PLAYER)
		{
			CvPlayer* pPlayer = &GET_PLAYER(iPlayer);
			CvGameTrade* pTrade = GC.getGame().GetGameTrade();

			for (uint ui = 0; ui < pTrade->GetNumTradeConnections(); ui++)
			{
				if (pTrade->IsTradeRouteIndexEmpty(ui))
				{
					continue;
				}

				const TradeConnection* pConnection = &(pTrade->GetTradeConnection(ui));

				CvCity* pOriginCity = GC.getMap().plot(pConnection->m_iOriginX, pConnection->m_iOriginY)->getPlotCity();
				CvCity* pDestCity = GC.getMap().plot(pConnection->m_iDestX, pConnection->m_iDestY)->getPlotCity();

				if (pDestCity == this && pOriginCity != NULL)
				{
					if (pConnection->m_eOriginOwner != NO_PLAYER)
					{
						CvPlayer* pOtherPlayer = &GET_PLAYER(pConnection->m_eOriginOwner);
						if (pOtherPlayer->GetPlayerTraits()->IsTradeRouteProductionSiphon())
						{
							Localization::String localizedText;
							int iSiphonPercent = pOtherPlayer->GetTradeRouteProductionSiphonPercent(false, pPlayer);
							if (pPlayer->GetID() != pOtherPlayer->GetID())
							{
								iSiphonPercent += pOtherPlayer->GetTradeRouteProductionSiphonPercent(true, pPlayer);
							}

							int iSiphonAmount = iChange * iSiphonPercent / 100;

							if (iSiphonAmount > 0)
							{
								int iOverflow = 0;
								int iProductionNeeded = 0;

								if (this->isProductionUnit())
								{
									UnitTypes eUnit = getProductionUnit();
									CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
									UnitClassTypes eUnitClass = (UnitClassTypes)pkUnitInfo->GetUnitClassType();

									// check if this unit is valid in the origin city
									// we are going very light on restrictions, so we are not using CanTrain()
									bool bValid = true;

									// no ships in land-locked cities
									if (!pOriginCity->isCoastal() && (DomainTypes)pkUnitInfo->GetDomainType() == DOMAIN_SEA)
									{
										bValid = false;
									}
									// no trade units if our trade route slots are maxed
									else if (pkUnitInfo->IsTrade() && pOtherPlayer->GetTrade()->GetNumTradeUnitsRemaining(false) <= 0)
									{
										bValid = false;
									}
									// settler related
									else if (pkUnitInfo->IsFound() || pkUnitInfo->IsFoundAbroad())
									{
										// require certain city population
										int iSizeRequirement = /*2 in CP, 4 in VP*/ GD_INT_GET(CITY_MIN_SIZE_FOR_SETTLERS);
										if (pOriginCity->getPopulation() < iSizeRequirement)
										{
											bValid = false;
										}
										// one city challenge
										else if (GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && pOtherPlayer->isHuman())
										{
											bValid = false;
										}
									}
									// air units can't be built above capacity
									else if (pkUnitInfo->GetDomainType() == DOMAIN_AIR)
									{
										int iNumAirUnits = pOriginCity->plot()->countNumAirUnits(pOriginCity->getTeam());
										if (iNumAirUnits >= pOriginCity->GetMaxAirUnits())
										{
											bValid = false;
										}
									}
									// cannot exceed max instance
									else if (GC.getGame().isUnitClassMaxedOut(eUnitClass) || GET_TEAM(pOtherPlayer->getTeam()).isUnitClassMaxedOut(eUnitClass) || pOtherPlayer->isUnitClassMaxedOut(eUnitClass))
									{
										bValid = false;
									}

									//proceed only if valid
									if (bValid)
									{
										// siphon production to the required unit in the origin
										pOriginCity->changeUnitProductionTimes100(eUnit, iSiphonAmount);

										// check if the origin have completed production
										iProductionNeeded = pOriginCity->getProductionNeeded(eUnit) * 100;
										iOverflow = pOriginCity->getUnitProductionTimes100(eUnit) - iProductionNeeded;

										// if origin has completed production
										if (iOverflow >= 0)
										{
											pOriginCity->produce(eUnit, NO_UNITAI, false);

											if (pkUnitInfo)
											{
												localizedText = Localization::Lookup(((isLimitedUnitClass(eUnitClass)) ? "TXT_KEY_MISC_TRAINED_UNIT_IN_LIMITED" : "TXT_KEY_MISC_TRAINED_UNIT_IN"));
												localizedText << pkUnitInfo->GetTextKey() << getNameKey();
											}
										}
									}
								}
								else if (this->isProductionBuilding())
								{
									// what building is the destination city making?
									BuildingTypes eBuilding = getProductionBuilding();
									CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
									BuildingClassTypes eBuildingClass = pkBuildingInfo->GetBuildingClassType();

									// check if this building is valid in the origin city
									// we are going very light on restrictions, so we are not using CanConstruct()
									bool bValid = true;

									// cannot build if city already has the exact building
									if (pOriginCity->m_pCityBuildings->GetNumBuilding(eBuilding) >= /*1*/ GD_INT_GET(CITY_MAX_NUM_BUILDINGS))
									{
										bValid = false;
									}
									// cannot exceed max instance
									else if (GC.getGame().isBuildingClassMaxedOut(eBuildingClass) || GET_TEAM(pOtherPlayer->getTeam()).isBuildingClassMaxedOut(eBuildingClass) || pOtherPlayer->isBuildingClassMaxedOut(eBuildingClass))
									{
										bValid = false;
									}
									// If the building class exists in the city, but the default building in the city doesn't, that means we already managed to siphon a unique building. Do not replace in this case.
									else if (pOriginCity->HasBuildingClass(eBuildingClass) && pOriginCity->m_pCityBuildings->GetNumBuilding((BuildingTypes)GC.getBuildingClassInfo(eBuildingClass)->getDefaultBuildingIndex()) == 0)
									{
										bValid = false;
									}
									// Mutually Exclusive Buildings
									else if (pkBuildingInfo->GetMutuallyExclusiveGroup() != -1)
									{
										int iNumBuildingInfos = GC.getNumBuildingInfos();
										for (int iI = 0; iI < iNumBuildingInfos; iI++)
										{
											const BuildingTypes eBuildingLoop = static_cast<BuildingTypes>(iI);

											CvBuildingEntry* pkLoopBuilding = GC.getBuildingInfo(eBuildingLoop);
											if (pkLoopBuilding)
											{
												if (eBuildingLoop == eBuilding)
													continue;

												// Buildings are in a Mutually Exclusive Group, so only one is allowed
												if (pkLoopBuilding->GetMutuallyExclusiveGroup() == pkBuildingInfo->GetMutuallyExclusiveGroup())
												{
													if (m_pCityBuildings->GetNumBuilding(eBuildingLoop) > 0 || isBuildingInQueue(eBuildingLoop))
													{
														bValid = false;
														break;
													}
												}
											}
										}
									}

									// proceed only if valid
									if (bValid)
									{
										// siphon production to the required building
										pOriginCity->m_pCityBuildings->ChangeBuildingProductionTimes100(eBuilding, iSiphonAmount);

										// check if the origin have completed production
										iProductionNeeded = pOriginCity->getProductionNeeded(eBuilding) * 100;
										iOverflow = pOriginCity->m_pCityBuildings->GetBuildingProductionTimes100(eBuilding) - iProductionNeeded;

										// if origin has completed production
										if (iOverflow >= 0)
										{
											// due to above check, if building class already exists, it means we are replacing the default building with a unique building
											if (pOriginCity->HasBuildingClass(eBuildingClass))
											{
												BuildingTypes eClassDefault = (BuildingTypes)GC.getBuildingClassInfo(eBuildingClass)->getDefaultBuildingIndex();
												pOriginCity->m_pCityBuildings->SetNumRealBuilding(eClassDefault, 0);
												pOriginCity->m_pCityBuildings->SetNumFreeBuilding(eClassDefault, 0);
											}

											pOriginCity->produce(eBuilding, false);

											CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
											if (pkBuildingInfo)
											{
												localizedText = Localization::Lookup(((isLimitedWonderClass(pkBuildingInfo->GetBuildingClassInfo())) ? "TXT_KEY_MISC_CONSTRUCTED_BUILD_IN_LIMITED" : "TXT_KEY_MISC_CONSTRUCTED_BUILD_IN"));
												localizedText << pkBuildingInfo->GetTextKey() << getNameKey();
											}
										}
									}
								}
								else if (isProductionProject())
								{
									// siphon production to the required project in the origin
									ProjectTypes eProject = getProductionProject();
									pOriginCity->changeProjectProductionTimes100(eProject, iSiphonAmount);

									// check if the origin have completed production
									iProductionNeeded = pOriginCity->getProductionNeeded(eProject) * 100;
									iOverflow = pOriginCity->getProjectProductionTimes100(eProject) - iProductionNeeded;

									// if origin has completed production (code below is a brief version of popOrder())
									if (iOverflow >= 0)
									{
										pOriginCity->produce(eProject, false);

										localizedText = Localization::Lookup(((isLimitedProject(eProject)) ? "TXT_KEY_MISC_CREATED_PROJECT_IN_LIMITED" : "TXT_KEY_MISC_CREATED_PROJECT_IN"));
										localizedText << GC.getProjectInfo(eProject)->GetTextKey() << getNameKey();
									}
								}
								else if (isProductionSpecialist())
								{
									// siphon production to the required specialist in the origin
									SpecialistTypes eSpecialist = getProductionSpecialist();
									pOriginCity->changeSpecialistProductionTimes100(this->getProductionSpecialist(), iSiphonAmount);

									// check if the origin have completed production
									iProductionNeeded = pOriginCity->getProductionNeeded(eSpecialist) * 100;
									iOverflow = pOriginCity->getSpecialistProductionTimes100(eSpecialist) - iProductionNeeded;

									// if origin has completed production (code below is a brief version of popOrder())
									if (iOverflow >= 0)
									{
										pOriginCity->produce(eSpecialist, false);
									}
								}
#if defined(MOD_BALANCE_CORE)
								else if (isProductionProcess())
								{
									if (getProductionProcess() != NO_PROCESS)
									{
										for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
										{
											//Simplification - errata yields not worth considering.
											if ((YieldTypes)iI > YIELD_GOLDEN_AGE_POINTS && !MOD_BALANCE_CORE_JFD)
												break;

											int iYield = (getBasicYieldRateTimes100(YIELD_PRODUCTION) / 100) * getProductionToYieldModifier((YieldTypes)iI) / 100;

											pOtherPlayer->doInstantYield(INSTANT_YIELD_TYPE_TR_PRODUCTION_SIPHON, false, NO_GREATPERSON, NO_BUILDING, iYield, false, NO_PLAYER, NULL, false, pOriginCity, false, true, false, (YieldTypes)iI);
										}
									}
								}
#endif
								if (!localizedText.IsEmpty())
								{
									DLLUI->AddCityMessage(0, pOriginCity->GetIDInfo(), pOriginCity->getOwner(), false, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), localizedText.toUTF8()/*, szSound, MESSAGE_TYPE_MINOR_EVENT, szIcon, (ColorTypes)GC.getInfoTypeForString("COLOR_WHITE"), getX(), getY(), true, true*/);
								}
							}
						}
					}
				}
			}
		}
	}
#endif
}


//	--------------------------------------------------------------------------------
int CvCity::getProductionModifier(CvString* toolTipSink) const
{
	VALIDATE_OBJECT
	const OrderData* pOrderNode = headOrderQueueNode();

	int iMultiplier = 0;

	if (pOrderNode != NULL)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_TRAIN:
			iMultiplier += getProductionModifier((UnitTypes)(pOrderNode->iData1), toolTipSink);
			break;

		case ORDER_CONSTRUCT:
			iMultiplier += getProductionModifier((BuildingTypes)(pOrderNode->iData1), toolTipSink);
			break;

		case ORDER_CREATE:
			iMultiplier += getProductionModifier((ProjectTypes)(pOrderNode->iData1), toolTipSink);
			break;

		case ORDER_PREPARE:
			iMultiplier += getProductionModifier((SpecialistTypes)(pOrderNode->iData1), toolTipSink);
			break;

		case ORDER_MAINTAIN:
			iMultiplier += getProductionModifier((ProcessTypes)(pOrderNode->iData1), toolTipSink);
			break;

		default:
			CvAssertMsg(false, "pOrderNode->eOrderType failed to match a valid option");
			break;
		}
	}

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvCity::getGeneralProductionModifiers(CvString* toolTipSink) const
{
	int iMultiplier = 0;

	// Railroad to capital?
	if (IsIndustrialRouteToCapitalConnected())
	{
		const int iTempMod = /*25 in CP, 0 in VP*/ GD_INT_GET(INDUSTRIAL_ROUTE_PRODUCTION_MOD);
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod != 0)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_RAILROAD_CONNECTION", iTempMod);
		}
	}

	if (MOD_BALANCE_VP && GetBaseYieldRateFromLeague(YIELD_PRODUCTION) > 0)
	{
		int iTempLeagueMod = GetBaseYieldRateFromLeague(YIELD_PRODUCTION);
		iMultiplier += iTempLeagueMod;
		if (toolTipSink && iTempLeagueMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_LEAGUE", iTempLeagueMod);
		}
	}

#if defined(MOD_BALANCE_CORE_POLICIES)
	if (MOD_BALANCE_CORE_POLICIES && GET_PLAYER(getOwner()).IsPuppetProdMod() && IsPuppet())
	{
		int iTempMod = GET_PLAYER(getOwner()).GetPuppetProdMod();
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_PUPPET_POLICY", iTempMod);
		}
	}
	if (MOD_BALANCE_CORE_POLICIES && GET_PLAYER(getOwner()).IsOccupiedProdMod() && IsOccupied() && !IsNoOccupiedUnhappiness())
	{
		int iTempMod = GET_PLAYER(getOwner()).GetOccupiedProdMod();
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_OCCUPIED_POLICY", iTempMod);
		}
	}
#endif
#if defined(MOD_BALANCE_CORE)
	if (GET_PLAYER(getOwner()).GetPlayerTraits()->IsProductionModFromNumSpecialists())
	{
		if (GetCityCitizens()->GetTotalSpecialistCount() > 0)
		{
			int iTempMod = GetCityCitizens()->GetTotalSpecialistCount();
			iMultiplier += iTempMod;
			if (toolTipSink && iTempMod)
			{
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_NUM_SPECIALISTS", iTempMod);
			}
		}
	}
#endif
	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvCity::getProductionModifier(UnitTypes eUnit, CvString* toolTipSink, bool bIgnoreHappiness) const
{
	VALIDATE_OBJECT
	CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
	if (pkUnitInfo == NULL)
	{
		//Unit type doesn't exist!
		return 0;
	}

	CvPlayerAI& thisPlayer = GET_PLAYER(getOwner());
	int iMultiplier = getGeneralProductionModifiers(toolTipSink) + thisPlayer.getProductionModifier(eUnit, toolTipSink);
	int iTempMod = 0;

	// Capital Settler bonus
	if (isCapital() && pkUnitInfo->IsFound())
	{
		iTempMod = GET_PLAYER(getOwner()).getCapitalSettlerProductionModifier();
		iMultiplier += iTempMod;
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_CAPITAL_SETTLER_PLAYER", iTempMod);
	}

#if defined(MOD_BALANCE_CORE)
	// Class Production Bonus
	if (thisPlayer.GetUnitClassProductionModifier((UnitClassTypes)pkUnitInfo->GetUnitClassType()) != 0)
	{
		iTempMod = GET_PLAYER(getOwner()).GetUnitClassProductionModifier((UnitClassTypes)pkUnitInfo->GetUnitClassType());
		iMultiplier += iTempMod;
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_UNIT_CLASS", iTempMod);
	}

	// Trait Bonus from Conquest
	if (thisPlayer.GetProductionBonusTurnsConquest() > 0)
	{
		iTempMod = thisPlayer.GetPlayerTraits()->GetProductionBonusModifierConquest();
		iMultiplier += iTempMod;
		int iTurns = thisPlayer.GetProductionBonusTurnsConquest();
		CvString strMessage = GetLocalizedText("TXT_KEY_PRODMOD_TRAIT_BONUS_CONQUEST_TURNS", iTurns);
		const char* szTurnsRemaining = strMessage.GetCString();
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_TRAIT_BONUS_CONQUEST", iTempMod, szTurnsRemaining);
	}
#endif

	// Domain bonus
	iTempMod = getDomainProductionModifier((DomainTypes)(pkUnitInfo->GetDomainType()));
	iMultiplier += iTempMod;
	if (toolTipSink && iTempMod)
	{
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_UNIT_DOMAIN", iTempMod);
	}
#if defined(MOD_BALANCE_CORE)
	if (thisPlayer.GetPlayerTraits()->GetNumPledgeDomainProductionModifier((DomainTypes)(pkUnitInfo->GetDomainType())) != NO_DOMAIN)
	{
		int iProtections = 0;
		for (int iMinorLoop = 0; iMinorLoop < MAX_MINOR_CIVS; iMinorLoop++)
		{
			PlayerTypes eLoopPlayer = (PlayerTypes)iMinorLoop;
			if (eLoopPlayer != NO_PLAYER && GET_PLAYER(eLoopPlayer).GetMinorCivAI()->IsProtectedByMajor(GetPlayer()->GetID()))
			{
				iProtections++;
			}
		}
		iTempMod = (thisPlayer.GetPlayerTraits()->GetNumPledgeDomainProductionModifier((DomainTypes)(pkUnitInfo->GetDomainType())) * iProtections);
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_PLEDGES_UNIT_DOMAIN", iTempMod);
		}
	}
#endif

	// UnitCombat class bonus
	UnitCombatTypes eUnitCombatType = (UnitCombatTypes)(pkUnitInfo->GetUnitCombatType());
	if (eUnitCombatType != NO_UNITCOMBAT)
	{
		iTempMod = getUnitCombatProductionModifier(eUnitCombatType);
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_UNIT_COMBAT_TYPE", iTempMod);
		}
	}

	// Production bonus from Corporation
	CorporationTypes eCorporation = GET_PLAYER(getOwner()).GetCorporations()->GetFoundedCorporation();
	if (eCorporation != NO_CORPORATION)
	{
		CvCorporationEntry* pkCorporationInfo = GC.getCorporationInfo(eCorporation);
		if (pkCorporationInfo)
		{
			for (int iResource = 0; iResource < GC.getNumResourceInfos(); iResource++)
			{
#if defined(MOD_UNITS_RESOURCE_QUANTITY_TOTALS)
				if (pkUnitInfo->GetResourceQuantityRequirement(iResource) > 0 || (MOD_UNITS_RESOURCE_QUANTITY_TOTALS && pkUnitInfo->GetResourceQuantityTotal(iResource) > 0))
#else
				if (pkUnitInfo->GetResourceQuantityRequirement(iResource) > 0)
#endif
				{
					iTempMod = pkCorporationInfo->GetUnitResourceProductionModifier(iResource);
					iMultiplier += iTempMod;
					if (toolTipSink && iTempMod)
					{
						GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_UNIT_CORPORATION", iTempMod);
					}
				}
			}
		}
	}

	UnitTypes prodUnit = getProductionUnit();
	if (MOD_BALANCE_VP && !bIgnoreHappiness && prodUnit != NO_UNIT)
	{
		CvUnitEntry* pUnitEntry = GC.getUnitInfo(prodUnit);
		int iTempMod = 0;
		bool bCombat = pUnitEntry->GetCombat() > 0 || pUnitEntry->GetRangedCombat() > 0 || pUnitEntry->GetNukeDamageLevel() != -1;

		// If a unit can fight AND settle, use the highest of the two penalties, don't add them
		if (bCombat && pUnitEntry->IsFound())
		{
			int iCombatPenalty = std::min(0, getHappinessDelta() * /*10*/ GD_INT_GET(LOCAL_UNHAPPY_COMBAT_UNIT_PRODUCTION_PENALTY) * -1);
			int iSettlerPenalty = std::min(0, getHappinessDelta() * /*10*/ GD_INT_GET(LOCAL_UNHAPPY_SETTLER_PRODUCTION_PENALTY) * -1) + GET_PLAYER(getOwner()).GetUnhappinessSettlerCostPenalty();
			iTempMod = std::min(iCombatPenalty, iSettlerPenalty);
		}
		else if (bCombat)
		{
			iTempMod = min(0, getHappinessDelta() * /*10*/ GD_INT_GET(LOCAL_UNHAPPY_COMBAT_UNIT_PRODUCTION_PENALTY) * -1);
		}
		else if (pUnitEntry->IsFound())
		{
			iTempMod = min(0, getHappinessDelta() * /*10*/ GD_INT_GET(LOCAL_UNHAPPY_SETTLER_PRODUCTION_PENALTY) * -1);
			iTempMod += GET_PLAYER(getOwner()).GetUnhappinessSettlerCostPenalty();
		}

		// Can't be lower than -75% from Unhappiness.
		if (iTempMod < /*-75*/ GD_INT_GET(UNHAPPY_MAX_UNIT_PRODUCTION_PENALTY))
			iTempMod = GD_INT_GET(UNHAPPY_MAX_UNIT_PRODUCTION_PENALTY);

		iMultiplier += iTempMod;
		if (iTempMod != 0 && toolTipSink)
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_BALANCE_HAPPINESS_MOD", iTempMod);
	}

	// Military production bonus
	if (pkUnitInfo->IsMilitaryProduction())
	{
		iTempMod = getMilitaryProductionModifier();
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_MILITARY", iTempMod);
		}
		CvPlot* pCityPlot = plot();
		for (int iUnitLoop = 0; iUnitLoop < pCityPlot->getNumUnits(); iUnitLoop++)
		{
			iTempMod = pCityPlot->getUnitByIndex(iUnitLoop)->getMilitaryProductionModifier();
			if (iTempMod != 0)
			{
				iMultiplier += iTempMod;
				if (toolTipSink && iTempMod)
				{
					GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_MILITARY_UNITPROMOTION", iTempMod);
				}
			}
		}
	}

	// City Space mod
	if (pkUnitInfo->GetSpaceshipProject() != NO_PROJECT)
	{
		iTempMod = getSpaceProductionModifier();
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_SPACE", iTempMod);
		}

		iTempMod = thisPlayer.getSpaceProductionModifier();

		int iLimitSpaceshipProduction = GC.getGame().GetGameLeagues()->GetSpaceShipProductionMod(getOwner());
		if (iLimitSpaceshipProduction != 0)
		{
			iTempMod += iLimitSpaceshipProduction;
		}

		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_SPACE_PLAYER", iTempMod);
		}
	}
	else
	{
		ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
		if (eMajority != NO_RELIGION && (pkUnitInfo->GetCombat() > 0 || pkUnitInfo->GetRangedCombat() > 0))
		{
			const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
			if (pReligion)
			{
				iTempMod = pReligion->m_Beliefs.GetUnitProductionModifier();
				iMultiplier += iTempMod;
				if (toolTipSink && iTempMod)
				{
					GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_RELIGION_UNIT", iTempMod);
				}
			}
		}
	}

	// Production bonus for having a particular building
	iTempMod = 0;
	int iBuildingMod = 0;
	BuildingTypes eBuilding;
	for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		eBuilding = (BuildingTypes)iI;
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
		if (pkBuildingInfo)
		{
			if (GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
			{
				iTempMod = pkUnitInfo->GetBuildingProductionModifier(eBuilding);

				if (iTempMod != 0)
				{
					iTempMod *= GetCityBuildings()->GetNumBuilding(eBuilding);

					iBuildingMod += iTempMod;
					if (toolTipSink && iTempMod)
					{
						GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_UNIT_WITH_BUILDING", iTempMod, pkBuildingInfo->GetDescription());
					}
				}
			}
		}
	}
	if (iBuildingMod != 0)
	{
		iMultiplier += iBuildingMod;
	}

	return iMultiplier;
}


//	--------------------------------------------------------------------------------
int CvCity::getProductionModifier(BuildingTypes eBuilding, CvString* toolTipSink) const
{
	VALIDATE_OBJECT
	CvBuildingEntry* thisBuildingEntry = GC.getBuildingInfo(eBuilding);
	if (thisBuildingEntry == NULL)	//should never happen
		return -1;

	int iMultiplier = getGeneralProductionModifiers(toolTipSink) + GET_PLAYER(getOwner()).getProductionModifier(eBuilding, toolTipSink);
	const CvBuildingClassInfo& kBuildingClassInfo = thisBuildingEntry->GetBuildingClassInfo();
	int iTempMod = 0;

	EraTypes eEra = NO_ERA;
	TechTypes eTech = (TechTypes)thisBuildingEntry->GetPrereqAndTech();
	CvTechEntry* pEntry = GC.GetGameTechs()->GetEntry(eTech);
	if (pEntry)
	{
		eEra = (EraTypes)pEntry->GetEra();
	}

	// Wonder bonus
	if (::isWorldWonderClass(kBuildingClassInfo) ||
		::isTeamWonderClass(kBuildingClassInfo) ||
		::isNationalWonderClass(kBuildingClassInfo))
	{
		iTempMod = GetWonderProductionModifier();
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_CITY", iTempMod);
		}

		iTempMod = GET_PLAYER(getOwner()).getWonderProductionModifier();
#if defined(MOD_BALANCE_CORE)
		if (GET_PLAYER(getOwner()).isGoldenAge() && GET_PLAYER(getOwner()).GetPlayerTraits()->GetWonderProductionModGA() > 0)
		{
			iTempMod += GET_PLAYER(getOwner()).GetPlayerTraits()->GetWonderProductionModGA();
		}
#endif
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_PLAYER", iTempMod);
		}

		iTempMod = GetLocalResourceWonderProductionMod(eBuilding, toolTipSink);
		iMultiplier += iTempMod;

		ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
		BeliefTypes eSecondaryPantheon = NO_BELIEF;
		iTempMod = 0;
		if (eMajority != NO_RELIGION)
		{
			const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
			if (pReligion)
			{
				// Depends on era of wonder
				if (eTech != NO_TECH)
				{
					if (pEntry)
					{
						if (eEra != NO_ERA)
						{
							iTempMod = pReligion->m_Beliefs.GetWonderProductionModifier(eEra, getOwner(), GET_PLAYER(getOwner()).getCity(GetID()));
							eSecondaryPantheon = GetCityReligions()->GetSecondaryReligionPantheonBelief();
							if (eSecondaryPantheon != NO_BELIEF)
							{
								if ((int)eEra < GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetObsoleteEra())
								{
									iTempMod += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetWonderProductionModifier();
								}
							}
						}
					}
				}
			}
		}

#if defined(MOD_RELIGION_PERMANENT_PANTHEON)
		// Mod for civs keeping their pantheon belief forever
		if (MOD_RELIGION_PERMANENT_PANTHEON)
		{
			if (GC.getGame().GetGameReligions()->HasCreatedPantheon(getOwner()))
			{
				const CvReligion* pPantheon = GC.getGame().GetGameReligions()->GetReligion(RELIGION_PANTHEON, getOwner());
				BeliefTypes ePantheonBelief = GC.getGame().GetGameReligions()->GetBeliefInPantheon(getOwner());
				if (pPantheon != NULL && ePantheonBelief != NO_BELIEF && ePantheonBelief != eSecondaryPantheon)
				{
					const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
					if (pReligion == NULL || (pReligion != NULL && !pReligion->m_Beliefs.IsPantheonBeliefInReligion(ePantheonBelief, eMajority, getOwner()))) // check that the our religion does not have our belief, to prevent double counting
					{
						if (eEra != NO_ERA)
						{
							if ((int)eEra < GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetObsoleteEra())
							{
								iTempMod += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetWonderProductionModifier();
							}
						}
					}
				}
			}
		}
#endif

		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_RELIGION", iTempMod);
		}

		CvPlot* pCityPlot = plot();
		for (int iUnitLoop = 0; iUnitLoop < pCityPlot->getNumUnits(); iUnitLoop++)
		{
			iTempMod = pCityPlot->getUnitByIndex(iUnitLoop)->getWonderProductionModifier();
			if (iTempMod != 0)
			{
				iMultiplier += iTempMod;
				if (toolTipSink && iTempMod)
				{
					GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_UNITPROMOTION", iTempMod);
				}
			}
		}
		int iNumberOfImprovements = 0;
		CvPlot* pLoopPlot = NULL;
		for (int iJ = 0; iJ < GetNumWorkablePlots(); iJ++)
		{
			pLoopPlot = iterateRingPlots(getX(), getY(), iJ);
			if (pLoopPlot != NULL && pLoopPlot->getOwner() == getOwner())
			{
				if (pLoopPlot->getImprovementType() != NO_IMPROVEMENT && !pLoopPlot->IsImprovementPillaged())
				{
					CvImprovementEntry* pImprovementInfo = GC.getImprovementInfo(pLoopPlot->getImprovementType());
					if (pImprovementInfo->GetWonderProductionModifier() > 0)
					{
						iTempMod = pImprovementInfo->GetWonderProductionModifier();
						iMultiplier += iTempMod;
						iNumberOfImprovements++;
					}
				}
			}
		}
		if (toolTipSink && iTempMod && iNumberOfImprovements)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_IMPROVEMENT", iTempMod * iNumberOfImprovements);
		}
	}
	// Not-wonder bonus
	else
	{
		iTempMod = m_pCityBuildings->GetBuildingProductionModifier();
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_BUILDING_CITY", iTempMod);
		}
	}

	// From policies
	iTempMod = GET_PLAYER(getOwner()).GetPlayerPolicies()->GetBuildingClassProductionModifier((BuildingClassTypes)kBuildingClassInfo.GetID());
	if (iTempMod != 0)
	{
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_BUILDING_POLICY", iTempMod);
		}
	}

	// From traits
	iTempMod = GET_PLAYER(getOwner()).GetPlayerTraits()->GetCapitalBuildingDiscount(eBuilding);
	if (iTempMod != 0)
	{
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_CAPITAL_BUILDING_TRAIT", iTempMod);
		}
	}

	if (GET_PLAYER(getOwner()).GetPlayerTraits()->GetWonderProductionModifierToBuilding() > 0)
	{
		int iMod = GET_PLAYER(getOwner()).GetPlayerTraits()->GetWonderProductionToBuildingDiscount(eBuilding);
		iTempMod = (GetWonderProductionModifier() * iMod) / 100;
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_TO_BUILDING_FROM_CITY_TRAIT", iTempMod);
		}

		iTempMod = (GET_PLAYER(getOwner()).getWonderProductionModifier() * iMod) / 100;
		if (GET_PLAYER(getOwner()).isGoldenAge() && GET_PLAYER(getOwner()).GetPlayerTraits()->GetWonderProductionModGA() > 0)
		{
			iTempMod += (GET_PLAYER(getOwner()).GetPlayerTraits()->GetWonderProductionModGA() * iMod) / 100;
		}
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_TO_BUILDING_FROM_PLAYER_TRAIT", iTempMod);
		}

		BuildingTypes ePyramidWonder = (BuildingTypes)GC.getInfoTypeForString("BUILDING_PYRAMID");
		iTempMod = (GetLocalResourceWonderProductionMod(ePyramidWonder) * iMod) / 100;
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_TO_BUILDING_FROM_RESOURCE_TRAIT", iTempMod);
		}

		ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
		BeliefTypes eSecondaryPantheon = NO_BELIEF;
		if (eMajority != NO_RELIGION)
		{
			const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
			if (pReligion)
			{
				// Depends on era of wonder
				if (eTech != NO_TECH)
				{
					if (pEntry)
					{
						eEra = (EraTypes)pEntry->GetEra();
						if (eEra != NO_ERA)
						{
							iTempMod = (pReligion->m_Beliefs.GetWonderProductionModifier(eEra, getOwner(), GET_PLAYER(getOwner()).getCity(GetID())) * iMod) / 100;
							eSecondaryPantheon = GetCityReligions()->GetSecondaryReligionPantheonBelief();
							if (eSecondaryPantheon != NO_BELIEF)
							{
								if ((int)eEra < GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetObsoleteEra())
								{
									iTempMod += (GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetWonderProductionModifier() * iMod) / 100;
								}
							}
						}
					}
				}
			}
		}
#if defined(MOD_RELIGION_PERMANENT_PANTHEON)
		// Mod for civs keeping their pantheon belief forever
		if (MOD_RELIGION_PERMANENT_PANTHEON)
		{
			if (GC.getGame().GetGameReligions()->HasCreatedPantheon(getOwner()))
			{
				const CvReligion* pPantheon = GC.getGame().GetGameReligions()->GetReligion(RELIGION_PANTHEON, getOwner());
				BeliefTypes ePantheonBelief = GC.getGame().GetGameReligions()->GetBeliefInPantheon(getOwner());
				if (pPantheon != NULL && ePantheonBelief != NO_BELIEF && ePantheonBelief != eSecondaryPantheon)
				{
					const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
					if (pReligion == NULL || (pReligion != NULL && !pReligion->m_Beliefs.IsPantheonBeliefInReligion(ePantheonBelief, eMajority, getOwner()))) // check that the our religion does not have our belief, to prevent double counting
					{
						if (eEra != NO_ERA)
						{
							if ((int)eEra < GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetObsoleteEra())
							{
								iTempMod += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetWonderProductionModifier();
							}
						}
					}
				}
			}
		}
#endif
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_RELIGION", iTempMod);
		}
		iTempMod = (GET_PLAYER(getOwner()).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_WONDER_PRODUCTION_MODIFIER) * iMod) / 100;
		iMultiplier += iTempMod;
		if (toolTipSink && iTempMod)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_TO_BUILDING_FROM_POLICY_TRAIT", iTempMod);
		}

		CvPlot* pCityPlot = plot();
		for (int iUnitLoop = 0; iUnitLoop < pCityPlot->getNumUnits(); iUnitLoop++)
		{
			iTempMod = (pCityPlot->getUnitByIndex(iUnitLoop)->getWonderProductionModifier() * iMod) / 100;
			if (iTempMod != 0)
			{
				iMultiplier += iTempMod;
				if (toolTipSink && iTempMod)
				{
					GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_TO_BUILDING_FROM_UNIT_TRAIT", iTempMod);
				}
			}
		}
		int iNumberOfImprovements = 0;
		CvPlot* pLoopPlot = NULL;
		for (int iJ = 0; iJ < GetNumWorkablePlots(); iJ++)
		{
			pLoopPlot = iterateRingPlots(getX(), getY(), iJ);
			if (pLoopPlot != NULL && pLoopPlot->getOwner() == getOwner())
			{
				if (pLoopPlot->getImprovementType() != NO_IMPROVEMENT && !pLoopPlot->IsImprovementPillaged())
				{
					CvImprovementEntry* pImprovementInfo = GC.getImprovementInfo(pLoopPlot->getImprovementType());
					if (pImprovementInfo->GetWonderProductionModifier() > 0)
					{
						iTempMod = (pImprovementInfo->GetWonderProductionModifier() * iMod) / 100;
						iMultiplier += iTempMod;
						iNumberOfImprovements++;
					}
				}
			}
		}
		if (toolTipSink && iTempMod && iNumberOfImprovements)
		{
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_TO_BUILDING_FROM_IMPROVEMENT_TRAIT", iTempMod * iNumberOfImprovements);
		}
	}

	if (GET_PLAYER(getOwner()).GetConquestPerEraBuildingProductionMod() != 0)
	{
		if (IsPuppet() || IsNoOccupiedUnhappiness())
		{
			iTempMod = GET_PLAYER(getOwner()).GetConquestPerEraBuildingProductionMod();
			EraTypes eBuildingEra = (EraTypes)0;

			if (thisBuildingEntry->IsCorp())
				eBuildingEra = NO_ERA;

			if (eTech != NO_TECH)
			{
				if (pEntry)
				{
					eBuildingEra = (EraTypes)pEntry->GetEra();
				}
			}

			if (eBuildingEra != NO_ERA)
			{
				int iEraDelta = GET_PLAYER(getOwner()).GetCurrentEra() - eBuildingEra;
				if (iEraDelta > 0)
				{
					iTempMod += GET_PLAYER(getOwner()).GetConquestPerEraBuildingProductionMod() * iEraDelta;
				}
			}
			iMultiplier += iTempMod;
			if (toolTipSink && iTempMod)
			{
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_CONQUEST_BUILDINGS_PRIOR_ERAS", iTempMod);
			}
		}
	}

	// Trait Bonus from Conquest
	if (GET_PLAYER(getOwner()).GetProductionBonusTurnsConquest() > 0)
	{
		iTempMod = GET_PLAYER(getOwner()).GetPlayerTraits()->GetProductionBonusModifierConquest();
		iMultiplier += iTempMod;
		int iTurns = GET_PLAYER(getOwner()).GetProductionBonusTurnsConquest();
		CvString strMessage = GetLocalizedText("TXT_KEY_PRODMOD_TRAIT_BONUS_CONQUEST_TURNS", iTurns);
		const char* szTurnsRemaining = strMessage.GetCString();
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_TRAIT_BONUS_CONQUEST", iTempMod, szTurnsRemaining);
	}

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvCity::getProductionModifier(ProjectTypes eProject, CvString* toolTipSink) const
{
	VALIDATE_OBJECT
	int iMultiplier = getGeneralProductionModifiers(toolTipSink) + GET_PLAYER(getOwner()).getProductionModifier(eProject, toolTipSink);
	int iTempMod = 0;

	// City Space mod
	if (GC.getProjectInfo(eProject)->IsSpaceship())
	{
		iTempMod = getSpaceProductionModifier();
		iMultiplier += iTempMod;
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_SPACE", iTempMod);
	}

	// Trait Bonus from Conquest
	if (GET_PLAYER(getOwner()).GetProductionBonusTurnsConquest() > 0)
	{
		iTempMod = GET_PLAYER(getOwner()).GetPlayerTraits()->GetProductionBonusModifierConquest();
		iMultiplier += iTempMod;
		int iTurns = GET_PLAYER(getOwner()).GetProductionBonusTurnsConquest();
		CvString strMessage = GetLocalizedText("TXT_KEY_PRODMOD_TRAIT_BONUS_CONQUEST_TURNS", iTurns);
		const char* szTurnsRemaining = strMessage.GetCString();
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_TRAIT_BONUS_CONQUEST", iTempMod, szTurnsRemaining);
	}

	return iMultiplier;
}


//	--------------------------------------------------------------------------------
int CvCity::getProductionModifier(SpecialistTypes eSpecialist, CvString* toolTipSink) const
{
	VALIDATE_OBJECT
	int iMultiplier = getGeneralProductionModifiers(toolTipSink) + GET_PLAYER(getOwner()).getProductionModifier(eSpecialist, toolTipSink);

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvCity::getProductionModifier(ProcessTypes eProcess, CvString* toolTipSink) const
{
	VALIDATE_OBJECT
	int iMultiplier = getGeneralProductionModifiers(toolTipSink) + GET_PLAYER(getOwner()).getProductionModifier(eProcess, toolTipSink);

	// Trait Bonus from Conquest
	if (GET_PLAYER(getOwner()).GetProductionBonusTurnsConquest() > 0)
	{
		int iTempMod = GET_PLAYER(getOwner()).GetPlayerTraits()->GetProductionBonusModifierConquest();
		iMultiplier += iTempMod;
	}

	return iMultiplier;
}

//	--------------------------------------------------------------------------------
int CvCity::getProductionDifference(int /*iProductionNeeded*/, int /*iProduction*/, int iProductionModifier, bool bFoodProduction, bool bOverflow) const
{
	VALIDATE_OBJECT
	// Anarchy, Resistance or Razing? Then no Production is done!
	if (GET_PLAYER(getOwner()).IsAnarchy() || IsResistance() || IsRazing())
		return 0;

	int iFoodProduction = ((bFoodProduction) ? (GetFoodProductionTimes100(getYieldRateTimes100(YIELD_FOOD, false) - foodConsumptionTimes100(true))) / 100 : 0);
	int iOverflow = ((bOverflow) ? (getOverflowProduction() + getFeatureProduction()) : 0);

	// Sum up difference
	int iBaseProduction = getBaseYieldRate(YIELD_PRODUCTION) * 100;
	iBaseProduction += (GetYieldPerPopTimes100(YIELD_PRODUCTION) * getPopulation());
	iBaseProduction += (GetYieldPerPopInEmpireTimes100(YIELD_PRODUCTION) * GET_PLAYER(getOwner()).getTotalPopulation());

	int iModifiedProduction = iBaseProduction * getBaseYieldRateModifier(YIELD_PRODUCTION, iProductionModifier);
	iModifiedProduction /= 10000;

	iModifiedProduction += iOverflow;
	iModifiedProduction += iFoodProduction;

	return iModifiedProduction;

}


//	--------------------------------------------------------------------------------
int CvCity::getCurrentProductionDifference(bool bIgnoreFood, bool bOverflow) const
{
	VALIDATE_OBJECT
	return getProductionDifference(getProductionNeeded(), getProduction(), getProductionModifier(), (!bIgnoreFood && isFoodProduction()), bOverflow);
}

//	--------------------------------------------------------------------------------
// What is the production of this city, not counting modifiers specific to what we happen to be building?
int CvCity::getRawProductionDifference(bool bIgnoreFood, bool bOverflow) const
{
	VALIDATE_OBJECT
	return getProductionDifference(getProductionNeeded(), getProduction(), getGeneralProductionModifiers(), (!bIgnoreFood && isFoodProduction()), bOverflow);
}


//	--------------------------------------------------------------------------------
int CvCity::getProductionDifferenceTimes100(int /*iProductionNeeded*/, int /*iProduction*/, int iProductionModifier, bool bFoodProduction, bool bOverflow) const
{
	VALIDATE_OBJECT
	// Anarchy, Resistance or Razing? Then no Production is done!
	if (GET_PLAYER(getOwner()).IsAnarchy() || IsResistance() || IsRazing())
		return 0;

	int iFoodProduction = ((bFoodProduction) ? (GetFoodProductionTimes100(getYieldRateTimes100(YIELD_FOOD, false) - foodConsumptionTimes100(true))) / 100 : 0);
	iFoodProduction *= 100;

	int iOverflow = ((bOverflow) ? (getOverflowProductionTimes100() + getFeatureProduction() * 100) : 0);

	// Sum up difference
	int iBaseProduction = getBaseYieldRate(YIELD_PRODUCTION) * 100;
	iBaseProduction += (GetYieldPerPopTimes100(YIELD_PRODUCTION) * getPopulation());
	iBaseProduction += (GetYieldPerPopInEmpireTimes100(YIELD_PRODUCTION) * GET_PLAYER(getOwner()).getTotalPopulation());

	int iModifiedProduction = iBaseProduction * getBaseYieldRateModifier(YIELD_PRODUCTION, iProductionModifier);
	iModifiedProduction /= 100;

	iModifiedProduction += iOverflow;
	iModifiedProduction += iFoodProduction;

	int iTradeYield = GET_PLAYER(m_eOwner).GetTrade()->GetTradeValuesAtCityTimes100(this, YIELD_PRODUCTION);
	iModifiedProduction += iTradeYield;

	return iModifiedProduction;
}


//	--------------------------------------------------------------------------------
int CvCity::getCurrentProductionDifferenceTimes100(bool bIgnoreFood, bool bOverflow) const
{
	VALIDATE_OBJECT
	return getProductionDifferenceTimes100(getProductionNeeded(), getProductionTimes100(), getProductionModifier(), (!bIgnoreFood && isFoodProduction()), bOverflow);
}

//	--------------------------------------------------------------------------------
// What is the production of this city, not counting modifiers specific to what we happen to be building?
int CvCity::getRawProductionDifferenceTimes100(bool bIgnoreFood, bool bOverflow) const
{
	VALIDATE_OBJECT
	return getProductionDifferenceTimes100(getProductionNeeded(), getProductionTimes100(), getGeneralProductionModifiers(), (!bIgnoreFood && isFoodProduction()), bOverflow);
}


//	--------------------------------------------------------------------------------
int CvCity::getExtraProductionDifference(int iExtra) const
{
	VALIDATE_OBJECT
	return getExtraProductionDifference(iExtra, getProductionModifier());
}

//	--------------------------------------------------------------------------------
int CvCity::getExtraProductionDifference(int iExtra, UnitTypes eUnit) const
{
	VALIDATE_OBJECT
	return getExtraProductionDifference(iExtra, getProductionModifier(eUnit));
}

//	--------------------------------------------------------------------------------
int CvCity::getExtraProductionDifference(int iExtra, BuildingTypes eBuilding) const
{
	VALIDATE_OBJECT
	return getExtraProductionDifference(iExtra, getProductionModifier(eBuilding));
}

//	--------------------------------------------------------------------------------
int CvCity::getExtraProductionDifference(int iExtra, ProjectTypes eProject) const
{
	VALIDATE_OBJECT
	return getExtraProductionDifference(iExtra, getProductionModifier(eProject));
}

//	--------------------------------------------------------------------------------
int CvCity::getExtraProductionDifference(int iExtra, int iModifier) const
{
	VALIDATE_OBJECT
	return ((iExtra * getBaseYieldRateModifier(YIELD_PRODUCTION, iModifier)) / 100);
}

//	--------------------------------------------------------------------------------
/// Convert extra food to production if building a unit built partially from food
int CvCity::GetFoodProduction(int iExcessFood) const
{
	return GetFoodProductionTimes100(iExcessFood * 100);
}

//	--------------------------------------------------------------------------------
/// Convert extra food to production if building a unit built partially from food
int CvCity::GetFoodProductionTimes100(int iExcessFoodTimes100) const
{
	int iRtnValue = 0;

	if (iExcessFoodTimes100 <= 0)
	{
		iRtnValue = 0;
	}
	else if (iExcessFoodTimes100 <= 200)
	{
		iRtnValue = iExcessFoodTimes100;
	}
	else if (iExcessFoodTimes100 > 200 && iExcessFoodTimes100 <= 400)
	{
		iRtnValue = 200 + (iExcessFoodTimes100 - 200) * 50 / 100;
	}
	else
	{
		iRtnValue = 300 + (iExcessFoodTimes100 - 400) * 25 / 100;
	}

	return (iRtnValue);
}

//	--------------------------------------------------------------------------------
bool CvCity::canHurry(HurryTypes eHurry, bool bTestVisible) const
{
	VALIDATE_OBJECT
	if (!(GET_PLAYER(getOwner()).IsHasAccessToHurry(eHurry)))
	{
		return false;
	}

	if (getProduction() >= getProductionNeeded())
	{
		return false;
	}

	CvHurryInfo* pkHurryInfo = GC.getHurryInfo(eHurry);
	if (pkHurryInfo == NULL)
		return false;

	// City cannot Hurry Player-level things
	if (pkHurryInfo->getGoldPerBeaker() > 0 || pkHurryInfo->getGoldPerCulture() > 0)
	{
		return false;
	}

	if (!bTestVisible)
	{
		if (!isProductionUnit() && !isProductionBuilding())
		{
			return false;
		}

		if (GET_PLAYER(getOwner()).GetTreasury()->GetGold() < hurryGold(eHurry))
		{
			return false;
		}

		if (maxHurryPopulation() < hurryPopulation(eHurry))
		{
			return false;
		}
	}

	return true;
}

//	--------------------------------------------------------------------------------
bool CvCity::canHurryUnit(HurryTypes eHurry, UnitTypes eUnit, bool bIgnoreNew) const
{
	VALIDATE_OBJECT
	if (!(GET_PLAYER(getOwner()).IsHasAccessToHurry(eHurry)))
	{
		return false;
	}

	if (getUnitProduction(eUnit) >= getProductionNeeded(eUnit))
	{
		return false;
	}

	if (GET_PLAYER(getOwner()).GetTreasury()->GetGold() < getHurryGold(eHurry, getHurryCost(eHurry, false, eUnit, bIgnoreNew), getProductionNeeded(eUnit)))
	{
		return false;
	}

	if (maxHurryPopulation() < getHurryPopulation(eHurry, getHurryCost(eHurry, true, eUnit, bIgnoreNew)))
	{
		return false;
	}

	return true;
}

//	--------------------------------------------------------------------------------
bool CvCity::canHurryBuilding(HurryTypes eHurry, BuildingTypes eBuilding, bool bIgnoreNew) const
{
	VALIDATE_OBJECT
	if (!(GET_PLAYER(getOwner()).IsHasAccessToHurry(eHurry)))
	{
		return false;
	}

	if (m_pCityBuildings->GetBuildingProduction(eBuilding) >= getProductionNeeded(eBuilding))
	{
		return false;
	}

	if (GET_PLAYER(getOwner()).GetTreasury()->GetGold() < getHurryGold(eHurry, getHurryCost(eHurry, false, eBuilding, bIgnoreNew), getProductionNeeded(eBuilding)))
	{
		return false;
	}

	if (maxHurryPopulation() < getHurryPopulation(eHurry, getHurryCost(eHurry, true, eBuilding, bIgnoreNew)))
	{
		return false;
	}

	return true;
}


//	--------------------------------------------------------------------------------
void CvCity::hurry(HurryTypes eHurry)
{
	VALIDATE_OBJECT
	if (!canHurry(eHurry))
	{
		return;
	}

	int iHurryGold = hurryGold(eHurry);
	int iHurryPopulation = hurryPopulation(eHurry);

	changeProduction(hurryProduction(eHurry));

	GET_PLAYER(getOwner()).GetTreasury()->ChangeGold(-(iHurryGold));
	changePopulation(-(iHurryPopulation));

	if ((getOwner() == GC.getGame().getActivePlayer()) && isCitySelected())
	{
		DLLUI->setDirty(SelectionButtons_DIRTY_BIT, true);
	}
}


//	--------------------------------------------------------------------------------
UnitTypes CvCity::getConscriptUnit() const
{
	VALIDATE_OBJECT
	UnitTypes eBestUnit = NO_UNIT;
	int iBestValue = 0;

	for (int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
	{
		const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
		CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
		if (pkUnitClassInfo)
		{
			const UnitTypes eLoopUnit = (UnitTypes)getCivilizationInfo().getCivilizationUnits(iI);
			if (eLoopUnit != NO_UNIT)
			{
				CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eLoopUnit);
				if (pkUnitInfo && pkUnitInfo->GetDomainType() == DOMAIN_LAND)
				{
					if (canTrain(eLoopUnit))
					{
						const int iValue = pkUnitInfo->GetConscriptionValue();
						if (iValue > iBestValue)
						{
							iBestValue = iValue;
							eBestUnit = eLoopUnit;
						}
					}
				}
			}
		}
	}

	return eBestUnit;
}


//	--------------------------------------------------------------------------------
int CvCity::getConscriptPopulation() const
{
	VALIDATE_OBJECT
	UnitTypes eConscriptUnit = getConscriptUnit();

	if (eConscriptUnit == NO_UNIT)
	{
		return 0;
	}

	CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eConscriptUnit);
	if (pkUnitInfo == NULL)
	{
		return 0;
	}

	int iConscriptPopulationPerCost = /*60*/ GD_INT_GET(CONSCRIPT_POPULATION_PER_COST);
	if (iConscriptPopulationPerCost == 0)
	{
		return 0;
	}

	return std::max(1, ((pkUnitInfo->GetProductionCost()) / iConscriptPopulationPerCost));
}

//	--------------------------------------------------------------------------------
int CvCity::conscriptMinCityPopulation() const
{
	VALIDATE_OBJECT
	return getConscriptPopulation() + /*5*/ GC.getCONSCRIPT_MIN_CITY_POPULATION();
}

//	--------------------------------------------------------------------------------
bool CvCity::canConscript() const
{
	VALIDATE_OBJECT
	if (isDrafted())
	{
		return false;
	}

	if (GET_PLAYER(getOwner()).getConscriptCount() >= GET_PLAYER(getOwner()).getMaxConscript())
	{
		return false;
	}

	if (getPopulation() <= getConscriptPopulation())
	{
		return false;
	}

	if (getPopulation() < conscriptMinCityPopulation())
	{
		return false;
	}

	if (getConscriptUnit() == NO_UNIT)
	{
		return false;
	}

	return true;
}

//	--------------------------------------------------------------------------------
CvUnit* CvCity::initConscriptedUnit()
{
	VALIDATE_OBJECT
	UnitAITypes eCityAI = NO_UNITAI;
	UnitTypes eConscriptUnit = getConscriptUnit();

	if (NO_UNIT == eConscriptUnit)
	{
		return NULL;
	}

	CvUnit* pUnit = GET_PLAYER(getOwner()).initUnit(eConscriptUnit, getX(), getY(), eCityAI);
	CvAssertMsg(pUnit != NULL, "pUnit expected to be assigned (not NULL)");

	if (NULL != pUnit)
	{
		addProductionExperience(pUnit, true);
		pUnit->restoreFullMoves();
	}

	return pUnit;
}


//	--------------------------------------------------------------------------------
void CvCity::conscript()
{
	VALIDATE_OBJECT
	if (!canConscript())
	{
		return;
	}

	changePopulation(-(getConscriptPopulation()));

	setDrafted(true);

	GET_PLAYER(getOwner()).changeConscriptCount(1);

	CvUnit* pUnit = initConscriptedUnit();
	CvAssertMsg(pUnit != NULL, "pUnit expected to be assigned (not NULL)");

	if (NULL != pUnit)
	{
		if (GC.getGame().getActivePlayer() == getOwner())
		{
			CvInterfacePtr<ICvUnit1> pDllUnit = GC.WrapUnitPointer(pUnit);
			DLLUI->selectUnit(pDllUnit.get(), true, false, true);
		}
	}
}

SPlotStats::SPlotStats():
	vTerrainCount( GC.getNumTerrainInfos(), 0 ),
	vFeatureCount( GC.getNumFeatureInfos(), 0 ),
	vResourceCount( GC.getNumResourceInfos(), 0 ),
	vImprovementCount( GC.getNumImprovementInfos(), 0 )
{
}

SPlotStats CvCity::getPlotStats() const
{
	SPlotStats result;

	for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(getX(), getY(), iCityPlotLoop);

		// Invalid plot or not owned by this city
		if (pLoopPlot == NULL || pLoopPlot->getOwningCityID() != GetID())
			continue;

		if (pLoopPlot->getImprovementType() != NO_IMPROVEMENT)
			result.vImprovementCount[pLoopPlot->getImprovementType()]++;

		if (pLoopPlot->getTerrainType() != NO_TERRAIN)
			result.vTerrainCount[pLoopPlot->getTerrainType()]++;

		if (pLoopPlot->getFeatureType() != NO_FEATURE)
			result.vFeatureCount[pLoopPlot->getFeatureType()]++;

		if (pLoopPlot->getResourceType()!=NO_RESOURCE && pLoopPlot->getResourceType(getTeam()) != NO_RESOURCE)
			result.vResourceCount[pLoopPlot->getResourceType(getTeam())]++;
	}

	return result;
}

//	--------------------------------------------------------------------------------
int CvCity::getResourceYieldRateModifier(YieldTypes eIndex, ResourceTypes eResource) const
{
	VALIDATE_OBJECT
	int iModifier = 0;

	for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
		if (pkBuildingInfo)
		{
			iModifier += m_pCityBuildings->GetNumActiveBuilding(eBuilding) * pkBuildingInfo->GetResourceYieldModifier(eResource, eIndex);
		}
	}

	return iModifier;
}


//	--------------------------------------------------------------------------------
void CvCity::processResource(ResourceTypes eResource, int iChange)
{
	VALIDATE_OBJECT

	// Yield modifier for having a local resource
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		const YieldTypes eYield = static_cast<YieldTypes>(iI);
		changeResourceYieldRateModifier(eYield, (getResourceYieldRateModifier(eYield, eResource) * iChange));
#if defined(MOD_BALANCE_CORE)
		UpdateCityYields(eYield);
#endif
	}
}


//	--------------------------------------------------------------------------------
#if defined(MOD_BALANCE_CORE)
void CvCity::processBuilding(BuildingTypes eBuilding, int iChange, bool bFirst, bool bObsolete, bool /*bApplyingAllCitiesBonus*/, bool bNoBonus)
#else
void CvCity::processBuilding(BuildingTypes eBuilding, int iChange, bool bFirst, bool bObsolete, bool /*bApplyingAllCitiesBonus*/)
#endif
{
	VALIDATE_OBJECT

	CvBuildingEntry* pBuildingInfo = GC.getBuildingInfo(eBuilding);
	if (pBuildingInfo == NULL)
		return;

	BuildingClassTypes eBuildingClass = (BuildingClassTypes)pBuildingInfo->GetBuildingClassType();

	CvPlayer& owningPlayer = GET_PLAYER(getOwner());
	CvTeam& owningTeam = GET_TEAM(getTeam());
	const CvCivilizationInfo& thisCiv = getCivilizationInfo();
	if (!(owningTeam.isObsoleteBuilding(eBuilding)) || bObsolete)
	{
		changeFreeExperience(pBuildingInfo->GetFreeExperience() * iChange);
		for (int iI = 0; iI < GC.getNumUnitCombatClassInfos(); iI++)
		{
			const UnitCombatTypes eUnitCombatClass = static_cast<UnitCombatTypes>(iI);
			CvBaseInfo* pkUnitCombatClassInfo = GC.getUnitCombatClassInfo(eUnitCombatClass);
			if (pkUnitCombatClassInfo)
			{
				changeUnitCombatFreeExperience(eUnitCombatClass, pBuildingInfo->GetUnitCombatFreeExperience(iI) * iChange);
				changeUnitCombatProductionModifier(eUnitCombatClass, pBuildingInfo->GetUnitCombatProductionModifier(iI) * iChange);
			}
		}
		for (int iI = 0; iI < NUM_DOMAIN_TYPES; iI++)
		{
			changeDomainFreeExperience(((DomainTypes)iI), pBuildingInfo->GetDomainFreeExperience(iI) * iChange);
			changeDomainProductionModifier(((DomainTypes)iI), pBuildingInfo->GetDomainProductionModifier(iI) * iChange);
		}
		// One-shot items
		if (bFirst && iChange > 0)
		{
			// Global Pop change
			if (pBuildingInfo->GetPopulationChange() != 0)
			{
				setPopulation(std::max(1, (getPopulation() + iChange * GC.getBuildingInfo(eBuilding)->GetPopulationChange())));
			}

			// Capital
			if (pBuildingInfo->IsCapital())
				owningPlayer.setCapitalCity(this);
#if defined(MOD_BALANCE_CORE)
			bool bIsWonder = ::isWorldWonderClass(pBuildingInfo->GetBuildingClassInfo());
			if (bIsWonder)
			{
				owningPlayer.GetCitySpecializationAI()->SetSpecializationsDirty(SPECIALIZATION_UPDATE_WONDER_BUILT_BY_US);
				if (!pBuildingInfo->IsUnlockedByLeague() && !pBuildingInfo->IsCorp())
					owningPlayer.ChangeWondersConstructed(1);
			}
			if (!bNoBonus && bIsWonder)
			{
				int iTourism = owningPlayer.GetHistoricEventTourism(HISTORIC_EVENT_WORLD_WONDER);
				owningPlayer.ChangeNumHistoricEvents(HISTORIC_EVENT_WORLD_WONDER, 1);

				if (iTourism > 0)
				{
					owningPlayer.GetCulture()->AddTourismAllKnownCivsWithModifiers(iTourism);
					if (owningPlayer.GetID() == GC.getGame().getActivePlayer())
					{
						char text[256] = { 0 };

						sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_TOURISM]", iTourism);
						SHOW_PLOT_POPUP(plot(), m_eOwner, text);

						CvNotifications* pNotification = owningPlayer.GetNotifications();
						if (pNotification)
						{
							CvString strMessage;
							CvString strSummary;
							strMessage = GetLocalizedText("TXT_KEY_TOURISM_EVENT_WW", iTourism);
							strSummary = GetLocalizedText("TXT_KEY_TOURISM_EVENT_SUMMARY");
							pNotification->Add(NOTIFICATION_CULTURE_VICTORY_SOMEONE_INFLUENTIAL, strMessage, strSummary, getX(), getY(), owningPlayer.GetID());
						}
					}
				}
			}
#endif
			// Free Units
			CvUnit* pFreeUnit = NULL;

			int iFreeUnitLoop = 0;
			int iFreeSpecUnitLoop = 0;
			for (int iUnitLoop = 0; iUnitLoop < GC.getNumUnitInfos(); iUnitLoop++)
			{
				const UnitTypes eUnit = static_cast<UnitTypes>(iUnitLoop);
				CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
				if (pkUnitInfo)
				{
					for (iFreeUnitLoop = 0; iFreeUnitLoop < pBuildingInfo->GetNumFreeUnits(iUnitLoop); iFreeUnitLoop++)
					{
						// Get the right unit of this class for this civ
						const UnitTypes eFreeUnitType = owningPlayer.GetSpecificUnitType((UnitClassTypes)pkUnitInfo->GetUnitClassType());
#if defined(MOD_BALANCE_CORE)
						//Test for forbidden or locked units.
						if (eFreeUnitType == NO_UNIT)
						{
							// Great prophet?
							if (GC.GetGameUnits()->GetEntry(eUnit)->IsFoundReligion())
							{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
								GetCityCitizens()->DoSpawnGreatPerson(eUnit, true /*bIncrementCount*/, true, MOD_GLOBAL_TRULY_FREE_GP);
#else
								GetCityCitizens()->DoSpawnGreatPerson(eUnit, true /*bIncrementCount*/, true);
#endif
							}
							else
							{
#if defined(MOD_BALANCE_CORE)
								// for venice
								pFreeUnit = NULL;
								if (pkUnitInfo->IsFound() && owningPlayer.GetPlayerTraits()->IsNoAnnexing())
								{
									// drop a merchant of venice instead
									// find the eUnit replacement that's the merchant of venice
									for (int iVeniceSearch = 0; iVeniceSearch < GC.getNumUnitClassInfos(); iVeniceSearch++)
									{
										const UnitClassTypes eVeniceUnitClass = static_cast<UnitClassTypes>(iVeniceSearch);
										CvUnitClassInfo* pkVeniceUnitClassInfo = GC.getUnitClassInfo(eVeniceUnitClass);
										if (pkVeniceUnitClassInfo)
										{
											const UnitTypes eMerchantOfVeniceUnit = owningPlayer.GetSpecificUnitType(eVeniceUnitClass);
											if (eMerchantOfVeniceUnit != NO_UNIT)
											{
												CvUnitEntry* pVeniceUnitEntry = GC.getUnitInfo(eMerchantOfVeniceUnit);
												if (pVeniceUnitEntry->IsCanBuyCityState())
												{
													pFreeUnit = owningPlayer.initUnit(eMerchantOfVeniceUnit, getX(), getY());
													break;
												}
											}
										}
									}
								}
								else
								{
#endif
									pFreeUnit = owningPlayer.initUnit(eUnit, getX(), getY());
									bool bJumpSuccess = pFreeUnit->jumpToNearestValidPlot();
									if (bJumpSuccess)
									{
										addProductionExperience(pFreeUnit);
										if (getFirstUnitOrder(eUnit) == 0)
										{
											clearOrderQueue();
											chooseProduction();
										}
									}
									else
									{
										pFreeUnit->kill(false);
									}
#if defined(MOD_BALANCE_CORE)
								}
								if (pFreeUnit->IsGreatPerson())
								{
									if (owningPlayer.GetPlayerTraits()->IsGPWLTKD())
									{
										int iWLTKD = /*6*/ GD_INT_GET(CITY_RESOURCE_WLTKD_TURNS) / 3;
										iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
										iWLTKD /= 100;

										if (iWLTKD > 0)
										{
											this->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
											CvNotifications* pNotifications = owningPlayer.GetNotifications();
											if (pNotifications)
											{
												Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UA");
												strText << pFreeUnit->getNameKey() << this->getNameKey();
												Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UA");
												strSummary << this->getNameKey();
												pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), this->getX(), this->getY(), -1);
											}
										}
									}
									if (pFreeUnit->isWLKTKDOnBirth())
									{
										CvCity* pLoopCity = NULL;
										int iLoop = 0;
										for (pLoopCity = owningPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = owningPlayer.nextCity(&iLoop))
										{
											if (pLoopCity != NULL && pLoopCity->getOwner() == owningPlayer.GetID())
											{
												int iWLTKD = /*6*/ GD_INT_GET(CITY_RESOURCE_WLTKD_TURNS) / 3;
												iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
												iWLTKD /= 100;

												if (iWLTKD > 0)
												{
													pLoopCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
													CvNotifications* pNotifications = owningPlayer.GetNotifications();
													if (pNotifications)
													{
														Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UNIT");
														strText << pFreeUnit->getNameKey() << pLoopCity->getNameKey();
														Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UNIT");
														strSummary << pLoopCity->getNameKey();
														pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pLoopCity->getX(), pLoopCity->getY(), -1);
													}
												}
											}
										}
									}
									if (pFreeUnit->isGoldenAgeOnBirth())
									{
										owningPlayer.changeGoldenAgeTurns(owningPlayer.getGoldenAgeLength());
									}
									if (pFreeUnit->isCultureBoost())
									{
										int iValue = owningPlayer.GetTotalJONSCulturePerTurn() * 4;
										owningPlayer.changeJONSCulture(iValue);
										if (owningPlayer.getCapitalCity() != NULL)
											owningPlayer.getCapitalCity()->ChangeJONSCultureStored(iValue);

										CvNotifications* pNotifications = owningPlayer.GetNotifications();
										if (pNotifications)
										{
											Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CULTURE_UNIT");
											strText << pFreeUnit->getNameKey();
											Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CULTURE_UNIT");
											strSummary << pFreeUnit->getNameKey();
											pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pFreeUnit->getX(), pFreeUnit->getY(), -1);
										}
									}
								}
#endif
								// Bump up the count
								if (pFreeUnit->IsGreatGeneral())
								{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
									owningPlayer.incrementGreatGeneralsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
									owningPlayer.incrementGreatGeneralsCreated();
#endif
									bool bJumpSuccess = pFreeUnit->jumpToNearestValidPlot();
									if (bJumpSuccess)
									{
										addProductionExperience(pFreeUnit);
									}
									else
									{
										pFreeUnit->kill(false);
									}
								}
								else if (pFreeUnit->IsGreatAdmiral())
								{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
									owningPlayer.incrementGreatAdmiralsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
									owningPlayer.incrementGreatAdmiralsCreated();
#endif
									CvPlot* pSpawnPlot = owningPlayer.GetBestCoastalSpawnPlot(pFreeUnit);
									if (pFreeUnit->plot() != pSpawnPlot)
									{
										pFreeUnit->setXY(pSpawnPlot->getX(), pSpawnPlot->getY());
										addProductionExperience(pFreeUnit);
									}
								}
								else if (pkUnitInfo->GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_WRITER"))
								{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
									owningPlayer.incrementGreatWritersCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
									owningPlayer.incrementGreatWritersCreated();
#endif
									if (!pFreeUnit->jumpToNearestValidPlot())
										pFreeUnit->kill(false);	// Could not find a valid spot!
								}
								else if (pkUnitInfo->GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_ARTIST"))
								{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
									owningPlayer.incrementGreatArtistsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
									owningPlayer.incrementGreatArtistsCreated();
#endif
									if (!pFreeUnit->jumpToNearestValidPlot())
										pFreeUnit->kill(false);	// Could not find a valid spot!
								}
								else if (pkUnitInfo->GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_MUSICIAN"))
								{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
									owningPlayer.incrementGreatMusiciansCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
									owningPlayer.incrementGreatMusiciansCreated();
#endif
									if (!pFreeUnit->jumpToNearestValidPlot())
										pFreeUnit->kill(false);	// Could not find a valid spot!
								}
								else if (MOD_BALANCE_VP && pkUnitInfo->GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_GREAT_DIPLOMAT"))
								{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
									owningPlayer.incrementGreatDiplomatsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
									owningPlayer.incrementGreatDiplomatsCreated();
#endif
									if (!pFreeUnit->jumpToNearestValidPlot())
										pFreeUnit->kill(false);	// Could not find a valid spot!
								}
#if defined(MOD_BALANCE_CORE)
								else if (pkUnitInfo->IsGPExtra() == 1)
								{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
									owningPlayer.incrementGPExtra1Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
									owningPlayer.incrementGPExtra1Created();
#endif
									if (!pFreeUnit->jumpToNearestValidPlot())
										pFreeUnit->kill(false);	// Could not find a valid spot!
								}
								else if (pkUnitInfo->IsGPExtra() == 2)
								{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
									owningPlayer.incrementGPExtra2Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
									owningPlayer.incrementGPExtra2Created();
#endif
									if (!pFreeUnit->jumpToNearestValidPlot())
										pFreeUnit->kill(false);	// Could not find a valid spot!
								}
								else if (pkUnitInfo->IsGPExtra() == 3)
								{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
									owningPlayer.incrementGPExtra3Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
									owningPlayer.incrementGPExtra3Created();
#endif
									if (!pFreeUnit->jumpToNearestValidPlot())
										pFreeUnit->kill(false);	// Could not find a valid spot!
								}
								else if (pkUnitInfo->IsGPExtra() == 4)
								{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
									owningPlayer.incrementGPExtra4Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
									owningPlayer.incrementGPExtra4Created();
#endif
									if (!pFreeUnit->jumpToNearestValidPlot())
										pFreeUnit->kill(false);	// Could not find a valid spot!
								}
								else if (pkUnitInfo->IsGPExtra() == 5)
								{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
									owningPlayer.incrementGPExtra5Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
									owningPlayer.incrementGPExtra5Created();
#endif
									if (!pFreeUnit->jumpToNearestValidPlot())
										pFreeUnit->kill(false);	// Could not find a valid spot!
								}
#endif
								else if (pFreeUnit->IsGreatPerson())
								{
#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
									if (MOD_GLOBAL_SEPARATE_GP_COUNTERS)
									{
										if (pkUnitInfo->GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_MERCHANT"))
										{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
											owningPlayer.incrementGreatMerchantsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
											owningPlayer.incrementGreatMerchantsCreated();
#endif
										}
										else if (pkUnitInfo->GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_SCIENTIST"))
										{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
											owningPlayer.incrementGreatScientistsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
											owningPlayer.incrementGreatScientistsCreated();
#endif
										}
										else
										{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
											owningPlayer.incrementGreatEngineersCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
											owningPlayer.incrementGreatEngineersCreated();
#endif
										}
									}
									else
#endif
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										owningPlayer.incrementGreatPeopleCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
										owningPlayer.incrementGreatPeopleCreated();
#endif
									bool bJumpSuccess = pFreeUnit->jumpToNearestValidPlot();
									if (bJumpSuccess)
									{
										addProductionExperience(pFreeUnit);
									}
									else
									{
										pFreeUnit->kill(false);
									}
								}
							}
						}
#endif
#if defined(MOD_BALANCE_CORE)
						//Test for forbidden or locked units.
						if (eFreeUnitType != NO_UNIT)
						{
#endif
							// Great prophet?
							if (GC.GetGameUnits()->GetEntry(eFreeUnitType)->IsFoundReligion())
							{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
								GetCityCitizens()->DoSpawnGreatPerson(eFreeUnitType, true /*bIncrementCount*/, true, MOD_GLOBAL_TRULY_FREE_GP);
#else
								GetCityCitizens()->DoSpawnGreatPerson(eFreeUnitType, true /*bIncrementCount*/, true);
#endif
							}
							else
							{
#if defined(MOD_BALANCE_CORE)
								// for venice
								pFreeUnit = NULL;
								if (pkUnitInfo->IsFound() && owningPlayer.GetPlayerTraits()->IsNoAnnexing())
								{
									// drop a merchant of venice instead
									// find the eUnit replacement that's the merchant of venice
									for (int iVeniceSearch = 0; iVeniceSearch < GC.getNumUnitClassInfos(); iVeniceSearch++)
									{
										const UnitClassTypes eVeniceUnitClass = static_cast<UnitClassTypes>(iVeniceSearch);
										CvUnitClassInfo* pkVeniceUnitClassInfo = GC.getUnitClassInfo(eVeniceUnitClass);
										if (pkVeniceUnitClassInfo)
										{
											const UnitTypes eMerchantOfVeniceUnit = owningPlayer.GetSpecificUnitType(eVeniceUnitClass);
											if (eMerchantOfVeniceUnit != NO_UNIT)
											{
												CvUnitEntry* pVeniceUnitEntry = GC.getUnitInfo(eMerchantOfVeniceUnit);
												if (pVeniceUnitEntry->IsCanBuyCityState())
												{
													pFreeUnit = owningPlayer.initUnit(eMerchantOfVeniceUnit, getX(), getY());
													break;
												}
											}
										}
									}
								}
								else
								{
#endif
									pFreeUnit = owningPlayer.initUnit(eFreeUnitType, getX(), getY());
#if defined(MOD_BALANCE_CORE)
									if (pFreeUnit)
									{
										if (pFreeUnit->isTrade())
										{
											if (GC.getLogging() && GC.getAILogging())
											{
												CvString strCiv = GET_PLAYER(getOwner()).getCivilizationAdjective();
												CvString strLogString;
												strLogString.Format("FREE TRADE UNIT CREATED: %s %s at %d,d", strCiv.c_str(), pFreeUnit->getName().c_str(), pFreeUnit->getX(), pFreeUnit->getY());
												GET_PLAYER(getOwner()).GetHomelandAI()->LogHomelandMessage(strLogString);
											}
										}
										bool bJumpSuccess = pFreeUnit->jumpToNearestValidPlot();
										if (bJumpSuccess)
										{
											addProductionExperience(pFreeUnit);
										}
										else
										{
											pFreeUnit->kill(false);
										}
									}
#endif
#if defined(MOD_BALANCE_CORE)
								}
								if (pFreeUnit->IsGreatPerson())
								{
									if (owningPlayer.GetPlayerTraits()->IsGPWLTKD())
									{
										int iWLTKD = /*6*/ GD_INT_GET(CITY_RESOURCE_WLTKD_TURNS) / 3;
										iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
										iWLTKD /= 100;

										if (iWLTKD > 0)
										{
											this->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
											CvNotifications* pNotifications = owningPlayer.GetNotifications();
											if (pNotifications)
											{
												Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UA");
												strText << pFreeUnit->getNameKey() << this->getNameKey();
												Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UA");
												strSummary << this->getNameKey();
												pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), this->getX(), this->getY(), -1);
											}
										}
									}
									if (pFreeUnit->isWLKTKDOnBirth())
									{
										CvCity* pLoopCity = NULL;
										int iLoop = 0;
										for (pLoopCity = owningPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = owningPlayer.nextCity(&iLoop))
										{
											if (pLoopCity != NULL && pLoopCity->getOwner() == owningPlayer.GetID())
											{
												int iWLTKD = /*6*/ GD_INT_GET(CITY_RESOURCE_WLTKD_TURNS) / 3;
												iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
												iWLTKD /= 100;

												if (iWLTKD > 0)
												{
													pLoopCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
													CvNotifications* pNotifications = owningPlayer.GetNotifications();
													if (pNotifications)
													{
														Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UNIT");
														strText << pFreeUnit->getNameKey() << pLoopCity->getNameKey();
														Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UNIT");
														strSummary << pLoopCity->getNameKey();
														pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pLoopCity->getX(), pLoopCity->getY(), -1);
													}
												}
											}
										}
									}
									if (pFreeUnit->isGoldenAgeOnBirth())
									{
										owningPlayer.changeGoldenAgeTurns(owningPlayer.getGoldenAgeLength());
									}
									if (pFreeUnit->isCultureBoost())
									{
										int iValue = owningPlayer.GetTotalJONSCulturePerTurn() * 4;
										owningPlayer.changeJONSCulture(iValue);
										if (owningPlayer.getCapitalCity() != NULL)
											owningPlayer.getCapitalCity()->ChangeJONSCultureStored(iValue);

										CvNotifications* pNotifications = owningPlayer.GetNotifications();
										if (pNotifications)
										{
											Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CULTURE_UNIT");
											strText << pFreeUnit->getNameKey();
											Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CULTURE_UNIT");
											strSummary << pFreeUnit->getNameKey();
											pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pFreeUnit->getX(), pFreeUnit->getY(), -1);
										}
									}
								}
#endif
								// Bump up the count
								if (pFreeUnit->IsGreatGeneral())
								{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
									owningPlayer.incrementGreatGeneralsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
									owningPlayer.incrementGreatGeneralsCreated();
#endif
									bool bJumpSuccess = pFreeUnit->jumpToNearestValidPlot();
									if (bJumpSuccess)
									{
										addProductionExperience(pFreeUnit);
									}
									else
									{
										pFreeUnit->kill(false);
									}
								}
								else if (pFreeUnit->IsGreatAdmiral())
								{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
									owningPlayer.incrementGreatAdmiralsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
									owningPlayer.incrementGreatAdmiralsCreated();
#endif
									CvPlot* pSpawnPlot = owningPlayer.GetBestCoastalSpawnPlot(pFreeUnit);
									if (pFreeUnit->plot() != pSpawnPlot)
									{
										pFreeUnit->setXY(pSpawnPlot->getX(), pSpawnPlot->getY());
										addProductionExperience(pFreeUnit);
									}
								}
								else if (pkUnitInfo->GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_WRITER"))
								{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
									owningPlayer.incrementGreatWritersCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
									owningPlayer.incrementGreatWritersCreated();
#endif
									if (!pFreeUnit->jumpToNearestValidPlot())
										pFreeUnit->kill(false);	// Could not find a valid spot!
								}
								else if (pkUnitInfo->GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_ARTIST"))
								{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
									owningPlayer.incrementGreatArtistsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
									owningPlayer.incrementGreatArtistsCreated();
#endif
									if (!pFreeUnit->jumpToNearestValidPlot())
										pFreeUnit->kill(false);	// Could not find a valid spot!
								}
								else if (pkUnitInfo->GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_MUSICIAN"))
								{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
									owningPlayer.incrementGreatMusiciansCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
									owningPlayer.incrementGreatMusiciansCreated();
#endif
									if (!pFreeUnit->jumpToNearestValidPlot())
										pFreeUnit->kill(false);	// Could not find a valid spot!
								}
								else if (MOD_BALANCE_VP && pkUnitInfo->GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_GREAT_DIPLOMAT"))
								{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
									owningPlayer.incrementGreatDiplomatsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
									owningPlayer.incrementGreatDiplomatsCreated();
#endif
									if (!pFreeUnit->jumpToNearestValidPlot())
										pFreeUnit->kill(false);	// Could not find a valid spot!
								}
#if defined(MOD_BALANCE_CORE)
								else if (pkUnitInfo->IsGPExtra() == 1)
								{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
									owningPlayer.incrementGPExtra1Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
									owningPlayer.incrementGPExtra1Created();
#endif
									if (!pFreeUnit->jumpToNearestValidPlot())
										pFreeUnit->kill(false);	// Could not find a valid spot!
								}
								else if (pkUnitInfo->IsGPExtra() == 2)
								{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
									owningPlayer.incrementGPExtra2Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
									owningPlayer.incrementGPExtra2Created();
#endif
									if (!pFreeUnit->jumpToNearestValidPlot())
										pFreeUnit->kill(false);	// Could not find a valid spot!
								}
								else if (pkUnitInfo->IsGPExtra() == 3)
								{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
									owningPlayer.incrementGPExtra3Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
									owningPlayer.incrementGPExtra3Created();
#endif
									if (!pFreeUnit->jumpToNearestValidPlot())
										pFreeUnit->kill(false);	// Could not find a valid spot!
								}
								else if (pkUnitInfo->IsGPExtra() == 4)
								{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
									owningPlayer.incrementGPExtra4Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
									owningPlayer.incrementGPExtra4Created();
#endif
									if (!pFreeUnit->jumpToNearestValidPlot())
										pFreeUnit->kill(false);	// Could not find a valid spot!
								}
								else if (pkUnitInfo->IsGPExtra() == 5)
								{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
									owningPlayer.incrementGPExtra5Created(MOD_GLOBAL_TRULY_FREE_GP);
#else
									owningPlayer.incrementGPExtra5Created();
#endif
									if (!pFreeUnit->jumpToNearestValidPlot())
										pFreeUnit->kill(false);	// Could not find a valid spot!
								}
#endif
								else if (pFreeUnit->IsGreatPerson())
								{
#if defined(MOD_GLOBAL_SEPARATE_GP_COUNTERS)
									if (MOD_GLOBAL_SEPARATE_GP_COUNTERS)
									{
										if (pkUnitInfo->GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_MERCHANT"))
										{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
											owningPlayer.incrementGreatMerchantsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
											owningPlayer.incrementGreatMerchantsCreated();
#endif
										}
										else if (pkUnitInfo->GetUnitClassType() == GC.getInfoTypeForString("UNITCLASS_SCIENTIST"))
										{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
											owningPlayer.incrementGreatScientistsCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
											owningPlayer.incrementGreatScientistsCreated();
#endif
										}
										else
										{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
											owningPlayer.incrementGreatEngineersCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
											owningPlayer.incrementGreatEngineersCreated();
#endif
										}
									}
									else
#endif
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
										owningPlayer.incrementGreatPeopleCreated(MOD_GLOBAL_TRULY_FREE_GP);
#else
										owningPlayer.incrementGreatPeopleCreated();
#endif
									bool bJumpSuccess = pFreeUnit->jumpToNearestValidPlot();
									if (bJumpSuccess)
									{
										addProductionExperience(pFreeUnit);
									}
									else
									{
										pFreeUnit->kill(false);
									}
								}
#if defined(MOD_BALANCE_CORE)
							}
#endif
						}
					}
#if defined(MOD_BALANCE_CORE)
					for (iFreeSpecUnitLoop = 0; iFreeSpecUnitLoop < pBuildingInfo->GetNumFreeSpecialUnits(iUnitLoop); iFreeSpecUnitLoop++)
					{
						pFreeUnit = NULL;
						const UnitTypes eFreeSpecUnitType = (UnitTypes)pkUnitInfo->GetUnitClassType();
						if (eFreeSpecUnitType != NO_UNIT)
						{
							pFreeUnit = owningPlayer.initUnit(eUnit, getX(), getY());
						}
						bool bJumpSuccess = pFreeUnit->jumpToNearestValidPlot();
						if (bJumpSuccess)
						{
							addProductionExperience(pFreeUnit);
						}
						else
						{
							pFreeUnit->kill(false);
						}
					}
#endif
				}
			}

#if defined(MOD_BALANCE_CORE)
			// Is this a Corporation building?
			CvBuildingClassInfo* pkBuildingClass = GC.getBuildingClassInfo(eBuildingClass);
			if (pkBuildingClass)
			{
				CorporationTypes eCorporation = pkBuildingClass->getCorporationType();
				if (eCorporation != NO_CORPORATION)
				{
					// Valid corporation
					CvCorporationEntry* pkCorporationInfo = GC.getCorporationInfo(eCorporation);
					if (pkCorporationInfo != NULL)
					{
						// Should we found this Corporation?
						if (pkCorporationInfo->GetHeadquartersBuildingClass() == eBuildingClass)
						{
							if (iChange > 0)
							{
								GC.getGame().GetGameCorporations()->FoundCorporation(getOwner(), eCorporation, this);
							}
						}
					}
				}
			}
#endif

			// Free building
			BuildingClassTypes eFreeBuildingClassThisCity = (BuildingClassTypes)pBuildingInfo->GetFreeBuildingThisCity();
			if (eFreeBuildingClassThisCity != NO_BUILDINGCLASS)
			{
				BuildingTypes eFreeBuildingThisCity = (BuildingTypes)(thisCiv.getCivilizationBuildings(eFreeBuildingClassThisCity));

				if (MOD_BUILDINGS_THOROUGH_PREREQUISITES)
				{
					if (HasBuildingClass(eFreeBuildingClassThisCity))
					{
						eFreeBuildingThisCity = GetCityBuildings()->GetBuildingTypeFromClass(eFreeBuildingClassThisCity);
					}
				}

				if (eFreeBuildingThisCity != NO_BUILDING)
				{
					CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eFreeBuildingThisCity);
					if (pkBuildingInfo && m_pCityBuildings->GetNumRealBuilding(eFreeBuildingThisCity) > 0)
					{
						if (pkBuildingInfo->IsFaithPurchaseOnly())
						{
							int iFaithRefund = GetFaithPurchaseCost(eFreeBuildingThisCity);
							GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_FAITH_REFUND, false, NO_GREATPERSON, NO_BUILDING, iFaithRefund, false, NO_PLAYER, NULL, false, this);
						}
						else
						{
							int iProductionRefund = getProductionNeeded(eFreeBuildingThisCity);
							GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_REFUND, false, NO_GREATPERSON, NO_BUILDING, iProductionRefund, false, NO_PLAYER, NULL, false, this);
						}
						m_pCityBuildings->SetNumRealBuilding(eFreeBuildingThisCity, 0);
					}
					m_pCityBuildings->SetNumFreeBuilding(eFreeBuildingThisCity, 1);
				}
			}

			// Free Great Work
			GreatWorkType eGWType = pBuildingInfo->GetFreeGreatWork();
			if (eGWType != NO_GREAT_WORK)
			{
				GreatWorkClass eClass = CultureHelpers::GetGreatWorkClass(eGWType);
				int iGWindex = GC.getGame().GetGameCulture()->CreateGreatWork(eGWType, eClass, m_eOwner, owningPlayer.GetCurrentEra(), pBuildingInfo->GetDescription());
				m_pCityBuildings->SetBuildingGreatWork(eBuildingClass, 0, iGWindex);
#if defined(MOD_BALANCE_CORE)
				GetCityCulture()->CalculateBaseTourismBeforeModifiers();
				GetCityCulture()->CalculateBaseTourism();
#endif
#if defined(MOD_BALANCE_CORE)
				if (owningPlayer.GetPlayerTraits()->IsGreatWorkWLTKD())
				{
					int iWLTKD = /*6*/ GD_INT_GET(CITY_RESOURCE_WLTKD_TURNS) / 3;
					iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
					iWLTKD /= 100;

					if (iWLTKD > 0)
					{
						CvCity* pLoopCity = NULL;
						int iCityLoop = 0;

						// Loop through owner's cities.
						for (pLoopCity = owningPlayer.firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = owningPlayer.nextCity(&iCityLoop))
						{
							if (pLoopCity != NULL)
							{
								pLoopCity->ChangeWeLoveTheKingDayCounter(iWLTKD, true);
							}
						}
						CvNotifications* pNotifications = owningPlayer.GetNotifications();
						if (pNotifications)
						{
							Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_WLTKD_UA_GREAT_WORK");
							strText << iWLTKD << /*25*/ GD_INT_GET(WLTKD_GROWTH_MULTIPLIER);
							Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_WLTKD_UA_GREAT_WORK");
							pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), this->getX(), this->getY(), -1);
						}
					}
				}
#endif
			}

			// Tech boost for science buildings in capital
			if (owningPlayer.GetPlayerTraits()->IsTechBoostFromCapitalScienceBuildings())
			{
				if (isCapital())
				{
					if (pBuildingInfo->IsScienceBuilding())
					{
						int iMedianTechResearch = owningPlayer.GetPlayerTechs()->GetMedianTechResearch();
						iMedianTechResearch = (iMedianTechResearch * owningPlayer.GetMedianTechPercentage()) / 100;
#if defined(MOD_BALANCE_CORE)
						owningPlayer.doInstantYield(INSTANT_YIELD_TYPE_INSTANT, false, NO_GREATPERSON, eBuilding, iMedianTechResearch, false, NO_PLAYER, NULL, false, this);
#else

						TechTypes eCurrentTech = owningPlayer.GetPlayerTechs()->GetCurrentResearch();
						if (eCurrentTech == NO_TECH)
						{
							owningPlayer.changeOverflowResearch(iMedianTechResearch);
						}
						else
						{
							owningTeam.GetTeamTechs()->ChangeResearchProgress(eCurrentTech, iMedianTechResearch, owningPlayer.GetID());
						}
#endif
					}
				}
			}

			// TERRA COTTA AWESOME
			if (pBuildingInfo->GetInstantMilitaryIncrease())
			{
				std::vector<UnitTypes> aExtraUnits;
				std::vector<UnitAITypes> aExtraUnitAITypes;
				CvUnit* pLoopUnit = NULL;
				int iLoop = 0;
				for (pLoopUnit = GET_PLAYER(m_eOwner).firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = GET_PLAYER(m_eOwner).nextUnit(&iLoop))
				{
					if (pLoopUnit->getDomainType() == DOMAIN_LAND && pLoopUnit->IsCombatUnit())
					{
						UnitTypes eCurrentUnitType = pLoopUnit->getUnitType();
						UnitAITypes eCurrentUnitAIType = pLoopUnit->AI_getUnitAIType();

						// check for duplicate unit
						bool bAddUnit = true;
						for (uint ui = 0; ui < aExtraUnits.size(); ui++)
						{
							if (aExtraUnits[ui] == eCurrentUnitType)
							{
								bAddUnit = false;
							}
						}

						if (bAddUnit)
						{
							aExtraUnits.push_back(eCurrentUnitType);
							aExtraUnitAITypes.push_back(eCurrentUnitAIType);
						}
					}
				}

				for (uint ui = 0; ui < aExtraUnits.size(); ui++)
				{
					CvUnit* pNewUnit = GET_PLAYER(m_eOwner).initUnit(aExtraUnits[ui], m_iX, m_iY, aExtraUnitAITypes[ui]);
					bool bJumpSuccess = pNewUnit->jumpToNearestValidPlot();
#if defined(MOD_BALANCE_CORE)
					if (bJumpSuccess)
					{
						addProductionExperience(pNewUnit);
					}
#endif
					if (!bJumpSuccess)
					{
						pNewUnit->kill(false);
						break;
					}
				}
			}
			// END TERRA COTTA AWESOME
#if defined(MOD_BALANCE_CORE)
			if (MOD_BALANCE_CORE && pBuildingInfo->IsReformation() && (iChange > 0) && bFirst)
			{
				GET_PLAYER(getOwner()).SetReformation(true);
			}
			if (MOD_BALANCE_CORE && (pBuildingInfo->GrantsRandomResourceTerritory() > 0) && (iChange > 0) && bFirst)
			{
				CvPlayer& kPlayer = GET_PLAYER(getOwner());
				if (!kPlayer.GetPlayerTraits()->GetUniqueLuxuryCities())
				{
					// Does this building add resources?
					int iNumResourceTotal = pBuildingInfo->GrantsRandomResourceTerritory();
					if (iNumResourceTotal != 0)
					{
						// Find our unique resources
						vector<ResourceTypes> vPossibleResources;
						for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
						{
							ResourceTypes eResource = (ResourceTypes)iResourceLoop;
							CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
							if (pkResource != NULL && pkResource->GetRequiredCivilization() == kPlayer.getCivilizationType())
							{
								vPossibleResources.push_back(eResource);

								//if this is one we haven't got so far, boost the chance
								if (kPlayer.getNumResourceTotal(eResource, false) == 0)
									vPossibleResources.push_back(eResource);
							}
						}

						if (vPossibleResources.size() > 0)
						{
							//choose one
							int iChoice = GC.getGame().getSmallFakeRandNum(vPossibleResources.size(), plot()->GetPlotIndex() + GET_PLAYER(getOwner()).GetPseudoRandomSeed());
							ResourceTypes eResourceToGive = vPossibleResources[iChoice];

							int iNumResourceGiven = 0;
							CvPlot* pLoopPlot = NULL;

							for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
							{
								pLoopPlot = iterateRingPlots(getX(), getY(), iCityPlotLoop);
								if (pLoopPlot != NULL && pLoopPlot->getOwner() == owningPlayer.GetID() && !pLoopPlot->isCity() &&
									pLoopPlot->isValidMovePlot(getOwner()) && !pLoopPlot->isWater() && !pLoopPlot->IsNaturalWonder() && !pLoopPlot->isMountain() && (pLoopPlot->getFeatureType() == NO_FEATURE))
								{
									if (pLoopPlot->getResourceType() == NO_RESOURCE && pLoopPlot->getImprovementType() == NO_IMPROVEMENT)
									{
										pLoopPlot->setResourceType(NO_RESOURCE, 0, false);
										pLoopPlot->setResourceType(eResourceToGive, 1, false);
										iNumResourceGiven++;
										if (iNumResourceGiven >= iNumResourceTotal)
										{
											break;
										}
									}
								}
							}
							if (iNumResourceGiven < iNumResourceTotal)
							{
								for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
								{
									pLoopPlot = iterateRingPlots(getX(), getY(), iCityPlotLoop);
									if (pLoopPlot != NULL && (pLoopPlot->getOwner() == NO_PLAYER) && pLoopPlot->isValidMovePlot(getOwner()) &&
										!pLoopPlot->isWater() && !pLoopPlot->IsNaturalWonder() && (pLoopPlot->getFeatureType() != FEATURE_OASIS))
									{
										if (pLoopPlot->getResourceType() == NO_RESOURCE && pLoopPlot->getImprovementType() == NO_IMPROVEMENT)
										{
											pLoopPlot->setResourceType(NO_RESOURCE, 0, false);
											pLoopPlot->setResourceType(eResourceToGive, 1, false);
											iNumResourceGiven++;
											if (iNumResourceGiven >= iNumResourceTotal)
											{
												break;
											}
										}
									}
								}
							}
							if (iNumResourceGiven < iNumResourceTotal)
							{
								ResourceTypes eCurrentResource = plot()->getResourceType();
								if (eCurrentResource == NO_RESOURCE)
									plot()->setResourceType(eResourceToGive, 1, false);
							}
						}
					}
				}
				else
				{
					GET_PLAYER(getOwner()).GetPlayerTraits()->AddUniqueLuxuriesAround(this, pBuildingInfo->GrantsRandomResourceTerritory() * iChange);
				}
			}
#endif
#if defined(MOD_BALANCE_CORE_BUILDING_INSTANT_YIELD)
			if (MOD_BALANCE_CORE_BUILDING_INSTANT_YIELD && (iChange > 0))
			{
				if (!IsBuildingConstructed(eBuildingClass))
				{
					SetBuildingConstructed(eBuildingClass, true);
					GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_INSTANT, false, NO_GREATPERSON, eBuilding, 0, false, NO_PLAYER, NULL, false, this);
					
					if (pBuildingInfo->GetInstantReligionPressure() > 0) 
					{
						ReligionTypes eReligion = GET_PLAYER(getOwner()).getCapitalCity()->GetCityReligions()->GetReligiousMajority();
						if (eReligion > RELIGION_PANTHEON)
						{
							GetCityReligions()->AddReligiousPressure(FOLLOWER_CHANGE_INSTANT_YIELD, eReligion, pBuildingInfo->GetInstantReligionPressure());
							GetCityReligions()->RecomputeFollowers(FOLLOWER_CHANGE_INSTANT_YIELD);
						}
					}
				}
			}
#endif
		}

		if (pBuildingInfo->GetTrainedFreePromotion() != NO_PROMOTION)
		{
			changeFreePromotionCount(((PromotionTypes)(pBuildingInfo->GetTrainedFreePromotion())), iChange);
#if defined(MOD_BALANCE_CORE)
			//Let's give this to all units from this city.
			if (MOD_BALANCE_RETROACTIVE_PROMOS)
			{
				SetRetroactivePromotion((PromotionTypes)(pBuildingInfo->GetTrainedFreePromotion()));
			}
#endif
		}
#if defined(MOD_BALANCE_CORE)
		GetCityBuildings()->ChangeBuildingDefenseMod(pBuildingInfo->GetBuildingDefenseModifier() * iChange);
		changeCitySupplyModifier(pBuildingInfo->GetCitySupplyModifier() * iChange);
		changeCitySupplyFlat(pBuildingInfo->GetCitySupplyFlat() * iChange);
		changeCityBuildingBombardRange(pBuildingInfo->CityRangedStrikeRange() * iChange);
		changeCityIndirectFire(pBuildingInfo->CityIndirectFire() * iChange);
		changeCityBuildingRangeStrikeModifier(pBuildingInfo->CityRangedStrikeModifier() * iChange);

		if (pBuildingInfo->AllowsProductionTradeRoutes())
		{
			SetProductionRoutes(pBuildingInfo->AllowsProductionTradeRoutes() * iChange > 0);
		}
		if (pBuildingInfo->AllowsFoodTradeRoutes())
		{
			SetFoodRoutes(pBuildingInfo->AllowsFoodTradeRoutes() * iChange > 0);
		}
		if (pBuildingInfo->IsAllowsPuppetPurchase())
		{
			SetAllowPuppetPurchase(pBuildingInfo->IsAllowsPuppetPurchase() * iChange > 0);
		}
#endif
		changeGreatPeopleRateModifier(pBuildingInfo->GetGreatPeopleRateModifier() * iChange);

		ChangeMaxAirUnits(pBuildingInfo->GetAirModifier() * iChange);
		changeNukeModifier(pBuildingInfo->GetNukeModifier() * iChange);
		changeHealRate(pBuildingInfo->GetHealRateChange() * iChange);
		ChangeExtraHitPoints(pBuildingInfo->GetExtraCityHitPoints() * iChange);
		changeDamageReductionFlat(pBuildingInfo->GetDamageReductionFlat() * iChange);

		ChangeNoOccupiedUnhappinessCount(pBuildingInfo->IsNoOccupiedUnhappiness() * iChange);

#if defined(HH_MOD_BUILDINGS_FRUITLESS_PILLAGE)
		ChangeLocalGainlessPillageCount(pBuildingInfo->IsCityGainlessPillage() * iChange); //bool promotion
#endif

		ChangeBaseHappinessFromBuildings(pBuildingInfo->GetHappiness() * iChange);

		if (pBuildingInfo->GetUnmoddedHappiness() != 0)
		{
			ChangeUnmoddedHappinessFromBuildings(pBuildingInfo->GetUnmoddedHappiness() * iChange);
		}

		if (pBuildingInfo->GetUnhappinessModifier() != 0)
		{
			owningPlayer.ChangeUnhappinessMod(pBuildingInfo->GetUnhappinessModifier() * iChange);
		}
#if defined(MOD_BALANCE_CORE)
		if (pBuildingInfo->GetLocalUnhappinessModifier() != 0)
		{
			ChangeLocalUnhappinessMod(pBuildingInfo->GetLocalUnhappinessModifier() * iChange);
		}
#endif
		int iBuildingCulture = pBuildingInfo->GetYieldChange(YIELD_CULTURE);
		if (iBuildingCulture != 0)
		{
			iBuildingCulture = owningPlayer.GetPlayerTraits()->GetCultureBuildingYieldChange();
		}

		ChangeBaseYieldRateFromBuildings(YIELD_CULTURE, iBuildingCulture * iChange);
		changeCultureRateModifier(pBuildingInfo->GetCultureRateModifier() * iChange);
		ChangeBorderGrowthRateIncrease(pBuildingInfo->GetBorderGrowthRateIncrease() * iChange);
		changePlotCultureCostModifier(pBuildingInfo->GetPlotCultureCostModifier() * iChange);
		changePlotBuyCostModifier(pBuildingInfo->GetPlotBuyCostModifier() * iChange);
#if defined(MOD_BUILDINGS_CITY_WORKING)
		changeCityWorkingChange(pBuildingInfo->GetCityWorkingChange() * iChange);
#endif
#if defined(MOD_BUILDINGS_CITY_AUTOMATON_WORKERS)
		changeCityAutomatonWorkersChange(pBuildingInfo->GetCityAutomatonWorkersChange() * iChange);
#endif

		if (pBuildingInfo->GetReligiousPressureModifier() != 0)
		{
			bool bSpecificFaithOnly = false;
			if (pBuildingInfo->IsUnlockedByBelief())
			{
				ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
				if (eMajority > RELIGION_PANTHEON)
				{
					const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
					if (pReligion != NULL)
					{
						if (pReligion->m_Beliefs.IsBuildingClassEnabled((BuildingClassTypes)pBuildingInfo->GetBuildingClassType(), getOwner(), this))
						{
							ChangeReligiousPressureModifier(eMajority, pBuildingInfo->GetReligiousPressureModifier() * iChange);
							bSpecificFaithOnly = true;
						}
					}
				}
			}
			if (!bSpecificFaithOnly)
			{
				for (int iI = RELIGION_PANTHEON + 1; iI < GC.GetGameReligions()->GetNumReligions(); iI++)
				{
					ReligionTypes eReligion = (ReligionTypes)iI;
					ChangeReligiousPressureModifier(eReligion, pBuildingInfo->GetReligiousPressureModifier() * iChange);
				}
			}
		}

		PolicyTypes ePolicy;
		for (int iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)
		{
			ePolicy = (PolicyTypes)iPolicyLoop;

			if (owningPlayer.GetPlayerPolicies()->HasPolicy(ePolicy) && !owningPlayer.GetPlayerPolicies()->IsPolicyBlocked(ePolicy))
			{
				ChangeJONSCulturePerTurnFromPolicies(GC.getPolicyInfo(ePolicy)->GetBuildingClassCultureChange(eBuildingClass) * iChange);
#if defined(MOD_BALANCE_CORE_POLICIES)
				changeBuildingClassCultureChange(eBuildingClass, GC.getPolicyInfo(ePolicy)->GetBuildingClassCultureChange(eBuildingClass) * iChange);
#endif
			}
		}

		ChangeEmpireSizeModifierReduction(pBuildingInfo->GetEmpireSizeModifierReduction() * iChange);
		ChangeDistressFlatReduction(pBuildingInfo->GetDistressFlatReduction() * iChange);
		ChangePovertyFlatReduction(pBuildingInfo->GetPovertyFlatReduction() * iChange);
		ChangeIlliteracyFlatReduction(pBuildingInfo->GetIlliteracyFlatReduction() * iChange);
		ChangeBoredomFlatReduction(pBuildingInfo->GetBoredomFlatReduction() * iChange);
		ChangeReligiousUnrestFlatReduction(pBuildingInfo->GetReligiousUnrestFlatReduction() * iChange);

		ChangeBasicNeedsMedianModifier(pBuildingInfo->GetBasicNeedsMedianModifier() * iChange);
		ChangeGoldMedianModifier(pBuildingInfo->GetGoldMedianModifier() * iChange);
		ChangeScienceMedianModifier(pBuildingInfo->GetScienceMedianModifier() * iChange);
		ChangeCultureMedianModifier(pBuildingInfo->GetCultureMedianModifier() * iChange);
		ChangeReligiousUnrestModifier(pBuildingInfo->GetReligiousUnrestModifier() * iChange);

#if defined(MOD_BALANCE_CORE)
		if ((pBuildingInfo->GetTradeReligionModifier() != 0))
		{
			ChangeReligiousTradeModifier(pBuildingInfo->GetTradeReligionModifier() * iChange);
		}
		if ((pBuildingInfo->GetCityAirStrikeDefense() > 0))
		{
			ChangeCityAirStrikeDefense(pBuildingInfo->GetCityAirStrikeDefense() * iChange);
		}
		if ((pBuildingInfo->GetBorderObstacleLand() > 0))
		{
			ChangeBorderObstacleCity(pBuildingInfo->GetBorderObstacleLand() * iChange);
		}
		if ((pBuildingInfo->GetBorderObstacleWater() > 0))
		{
			ChangeBorderObstacleWater(pBuildingInfo->GetBorderObstacleWater() * iChange);
		}
		if ((pBuildingInfo->GetDeepWaterTileDamage() > 0))
		{
			ChangeDeepWaterTileDamage(pBuildingInfo->GetDeepWaterTileDamage() * iChange);
		}
		if (bFirst && (iChange > 0) && (pBuildingInfo->GetWLTKDTurns() > 0))
		{
			int iWLTKD = pBuildingInfo->GetWLTKDTurns();
			iWLTKD *= GC.getGame().getGameSpeedInfo().getTrainPercent();
			iWLTKD /= 100;
			if (iWLTKD > 0)
			{
				ChangeWeLoveTheKingDayCounter(iWLTKD);
			}
		}
		if (pBuildingInfo->GetLandTourismEnd() > 0)
		{
			ChangeLandTourismBonus(pBuildingInfo->GetLandTourismEnd() * iChange);
		}
		if (pBuildingInfo->GetSeaTourismEnd() > 0)
		{
			ChangeSeaTourismBonus(pBuildingInfo->GetSeaTourismEnd() * iChange);
		}
		if (pBuildingInfo->GetAlwaysHeal() > 0)
		{
			ChangeAlwaysHeal(pBuildingInfo->GetAlwaysHeal() * iChange);
		}
		if (pBuildingInfo->GetResourceDiversityModifier() != 0)
		{
			ChangeResourceDiversityModifier(pBuildingInfo->GetResourceDiversityModifier() * iChange);
		}

		if (pBuildingInfo->GetNoUnhappfromXSpecialists() != 0)
		{
			ChangeNoUnhappfromXSpecialists(pBuildingInfo->GetNoUnhappfromXSpecialists() * iChange);
		}

		if (bFirst && iChange > 0 && pBuildingInfo->GetNumFreeArtifacts() > 0)
		{
			for (int iI = 0; iI < pBuildingInfo->GetNumFreeArtifacts(); iI++)
			{
				if (iI <= pBuildingInfo->GetGreatWorkCount())
				{
					if (GET_PLAYER(getOwner()).GetPlayerTraits()->GetWonderProductionModifier() > 0)
					{
						plot()->AddArchaeologicalRecord(CvTypes::getARTIFACT_SARCOPHAGUS(), GET_PLAYER(getOwner()).GetCurrentEra(), getOwner(), NO_PLAYER);
					}
					else
					{
						plot()->AddArchaeologicalRecord(CvTypes::getARTIFACT_ANCIENT_RUIN(), GET_PLAYER(getOwner()).GetCurrentEra(), getOwner(), NO_PLAYER);
					}
					GreatWorkType eGreatArtifact = CultureHelpers::GetArtifact(plot());
					if (eGreatArtifact != NO_GREAT_WORK)
					{
						GreatWorkClass eClass = CultureHelpers::GetGreatWorkClass(eGreatArtifact);
						if (eClass != NO_GREAT_WORK_CLASS)
						{
							int iGWindex = GC.getGame().GetGameCulture()->CreateGreatWork(eGreatArtifact, eClass, plot()->GetArchaeologicalRecord().m_ePlayer1, plot()->GetArchaeologicalRecord().m_eEra, "");
							if (iGWindex != -1)
							{
								GetCityBuildings()->SetBuildingGreatWork(eBuildingClass, iI, iGWindex);
							}
						}
					}
				}
			}
		}
		// Hurries
		for (int iI = 0; iI < GC.getNumHurryInfos(); iI++)
		{
			changeHurryModifier((HurryTypes)iI, (pBuildingInfo->GetHurryModifierLocal(iI) * iChange));
		}
		for (int iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
		{
			for (int iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
			{
				changeSpecialistExtraYield(((SpecialistTypes)iI), ((YieldTypes)iJ), (pBuildingInfo->GetSpecialistYieldChangeLocal(iI, iJ) * iChange));
			}
		}

		//Trade Routes
		if (pBuildingInfo->GetTradeRouteLandDistanceModifier() != 0)
		{
			ChangeTradeRouteLandDistanceModifier(pBuildingInfo->GetTradeRouteLandDistanceModifier() * iChange);
		}
		if (pBuildingInfo->GetTradeRouteSeaDistanceModifier() != 0)
		{
			ChangeTradeRouteSeaDistanceModifier(pBuildingInfo->GetTradeRouteSeaDistanceModifier() * iChange);
		}

		ChangeUnitPurchaseCooldownMod(true, pBuildingInfo->GetPurchaseCooldownReduction(true) * iChange);
		ChangeUnitPurchaseCooldownMod(false, pBuildingInfo->GetPurchaseCooldownReduction(false) * iChange);
#endif
#if defined(MOD_BALANCE_CORE)
		if (pBuildingInfo->GetBuildingClassInfo().IsOffice() || pBuildingInfo->GetBuildingClassInfo().IsHeadquarters() || pBuildingInfo->GetBuildingClassInfo().IsFranchise())
		{
			for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
			{
				UpdateYieldFromCorporationFranchises((YieldTypes)iI);
			}
		}
		if (pBuildingInfo->GetSpecialistType() != NO_SPECIALIST && pBuildingInfo->GetSpecialistCount() > 0)
		{
			GetCityCitizens()->ChangeNumSpecialistSlots((SpecialistTypes)pBuildingInfo->GetSpecialistType(), (pBuildingInfo->GetSpecialistCount() * iChange));
		}
#endif
		changeMaxFoodKeptPercent(pBuildingInfo->GetFoodKept() * iChange);
		changeMilitaryProductionModifier(pBuildingInfo->GetMilitaryProductionModifier() * iChange);
		changeSpaceProductionModifier(pBuildingInfo->GetSpaceProductionModifier() * iChange);
		m_pCityBuildings->ChangeBuildingProductionModifier(pBuildingInfo->GetBuildingProductionModifier() * iChange);
		m_pCityBuildings->ChangeBuildingProductionModifierPotentialFromMinorTrade(pBuildingInfo->GetCityStateTradeRouteProductionModifier() * iChange);
		m_pCityBuildings->ChangeMissionaryExtraSpreads(pBuildingInfo->GetExtraMissionarySpreads() * iChange);
		m_pCityBuildings->ChangeLandmarksTourismPercent(pBuildingInfo->GetLandmarksTourismPercent() * iChange);
		m_pCityBuildings->ChangeGreatWorksTourismModifier(pBuildingInfo->GetGreatWorksTourismModifier() * iChange);
		ChangeWonderProductionModifier(pBuildingInfo->GetWonderProductionModifier() * iChange);
		changeCapturePlunderModifier(pBuildingInfo->GetCapturePlunderModifier() * iChange);
		ChangeEspionageTurnsModifierEnemy(pBuildingInfo->GetEspionageTurnsModifierEnemyCity() * iChange);
		if (pBuildingInfo->GetEspionageTurnsModifierEnemyCity() * iChange != 0)
		{
			for (uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
			{
				PlayerTypes ePlayer = (PlayerTypes)ui;
				GET_PLAYER(ePlayer).GetEspionage()->UpdateCity(this);
			}
		}
#if defined(MOD_RELIGION_CONVERSION_MODIFIERS)
		ChangeConversionModifier(pBuildingInfo->GetConversionModifier() * iChange);
		owningPlayer.ChangeConversionModifier(pBuildingInfo->GetGlobalConversionModifier() * iChange);

		changeNukeInterceptionChance(pBuildingInfo->GetNukeInterceptionChance() * iChange);
#endif

		ChangeTradeRouteTargetBonus(pBuildingInfo->GetTradeRouteTargetBonus() * iChange);
		ChangeTradeRouteSeaGoldBonus(pBuildingInfo->GetTradeRouteSeaGoldBonus() * iChange);
		ChangeTradeRouteLandGoldBonus(pBuildingInfo->GetTradeRouteLandGoldBonus() * iChange);
		ChangeTradeRouteRecipientBonus(pBuildingInfo->GetTradeRouteRecipientBonus() * iChange);
		ChangeNumTradeRouteBonus(pBuildingInfo->GetTradeRouteLandGoldBonus() * iChange);
		ChangeCityConnectionTradeRouteGoldModifier(pBuildingInfo->GetCityConnectionTradeRouteGoldModifier() * iChange);


		if (pBuildingInfo->AffectSpiesNow() && iChange > 0)
		{
			for (uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
			{
				PlayerTypes ePlayer = (PlayerTypes)ui;
				GET_PLAYER(ePlayer).GetEspionage()->UpdateCity(this);
			}
		}

#if defined(MOD_BALANCE_CORE)
		std::multimap<int, std::pair<int, int>> piiGreatPersonProgressFromConstruction = pBuildingInfo->GetGreatPersonProgressFromConstructionArray();
		if (piiGreatPersonProgressFromConstruction.empty() == false)
		{
			for (std::multimap<int, std::pair<int, int>>::const_iterator it = piiGreatPersonProgressFromConstruction.begin(); it != piiGreatPersonProgressFromConstruction.end(); ++it)
			{
				if (it->first >= 0 && it->first < GC.getNumGreatPersonInfos() && it->second.first >= 0 && it->second.first < GC.getNumEraInfos())
				{
					ChangeGreatPersonProgressFromConstruction((GreatPersonTypes)it->first, (EraTypes)it->second.first, it->second.second);
				}
			}
		}
#endif

		// Resource loop
		int iCulture = 0, iFaith = 0;
		ResourceTypes eResource;
		for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
		{
			eResource = (ResourceTypes)iResourceLoop;

			// Does this building add resources?
			int iNumResource = pBuildingInfo->GetResourceQuantity(iResourceLoop) * iChange;
			if (iNumResource != 0)
			{
				owningPlayer.changeNumResourceTotal(eResource, iNumResource);
			}

#if defined(MOD_BALANCE_CORE)
			if (pBuildingInfo->IsResourcePlotsToPlace())
			{
				std::map<int, int> piResourcePlotsToPlace = pBuildingInfo->GetResourcePlotsToPlace(iResourceLoop);

				for (std::map<int, int>::const_iterator it = piResourcePlotsToPlace.begin(); it != piResourcePlotsToPlace.end(); ++it)
				{
					int iNumResourcePlotsGiven = 0;
					int iNumResourceTotalPlots = it->second;
					if (iNumResourceTotalPlots > 0 && (iChange > 0) && bFirst)
					{
						//const ResourceTypes eResourceToPlace = static_cast<ResourceTypes>(iResourceLoop);
						CvPlot* pLoopPlot;
						for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
						{
							pLoopPlot = iterateRingPlots(getX(), getY(), iCityPlotLoop);
							if (pLoopPlot != NULL && ((pLoopPlot->getOwner() == owningPlayer.GetID()) || (pLoopPlot->getOwner() == NO_PLAYER && pLoopPlot->isValidMovePlot(getOwner()))) && !pLoopPlot->isCity())
							{
								if (pLoopPlot->canHaveResource(eResource, false, true) && pLoopPlot->getResourceType() == NO_RESOURCE)
								{
									ImprovementTypes eImprovement = pLoopPlot->getImprovementType();
									if (eImprovement != NO_IMPROVEMENT)
									{
										CvImprovementEntry* ImprovementEntry = GC.getImprovementInfo(eImprovement);
										if (ImprovementEntry && ImprovementEntry->IsCreatedByGreatPerson() && ImprovementEntry->IsImprovementResourceMakesValid(eResource) == false)
										{
											continue;
										}
									}

									int iResourceQuantityPerPlot = MAX(it->first, 1);
									pLoopPlot->setResourceType(NO_RESOURCE, 0, false);
									pLoopPlot->setResourceType(eResource, iResourceQuantityPerPlot, false);
									iNumResourcePlotsGiven++;
									if (eImprovement != NO_IMPROVEMENT && !pLoopPlot->IsImprovementPillaged())
									{
										CvImprovementEntry* ImprovementEntry = GC.getImprovementInfo(eImprovement);
										if (ImprovementEntry)
										{
											if (ImprovementEntry->IsImprovementResourceMakesValid(eResource))
											{
												owningPlayer.changeNumResourceTotal(eResource, iResourceQuantityPerPlot);
											}
										}
									}
									if (pLoopPlot->getOwner() == GC.getGame().getActivePlayer())
									{
										if (!CvPreGame::loadWBScenario() || GC.getGame().getGameTurn() > 0)
										{
											CvString strBuffer;
											CvResourceInfo* pResourceInfo = GC.getResourceInfo(eResource);
											CvAssert(pResourceInfo);
											NotificationTypes eNotificationType = NO_NOTIFICATION_TYPE;
											strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_FOUND_RESOURCE", pResourceInfo->GetTextKey());

											CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_FOUND_RESOURCE", pResourceInfo->GetTextKey());

											switch (pResourceInfo->getResourceUsage())
											{
											case RESOURCEUSAGE_LUXURY:
												eNotificationType = NOTIFICATION_DISCOVERED_LUXURY_RESOURCE;
												break;
											case RESOURCEUSAGE_STRATEGIC:
												eNotificationType = NOTIFICATION_DISCOVERED_STRATEGIC_RESOURCE;
												break;
											case RESOURCEUSAGE_BONUS:
												eNotificationType = NOTIFICATION_DISCOVERED_BONUS_RESOURCE;
												break;
											}

											CvNotifications* pNotifications = GET_PLAYER(pLoopPlot->getOwner()).GetNotifications();
											if (pNotifications)
											{
												pNotifications->Add(eNotificationType, strBuffer, strSummary, pLoopPlot->getX(), pLoopPlot->getY(), eResource);
											}
										}
									}
									if (iNumResourcePlotsGiven >= iNumResourceTotalPlots)
									{
										break;
									}
								}
							}
						}
					}
				}
			}
			if (MOD_BALANCE_CORE && (pBuildingInfo->GetResourceQuantityPerXFranchises(iResourceLoop) > 0))
			{
				ChangeResourceQuantityPerXFranchises(eResource, pBuildingInfo->GetResourceQuantityPerXFranchises(iResourceLoop) * iChange);
			}
			if (MOD_BALANCE_CORE && (pBuildingInfo->GetResourceQuantityFromPOP(iResourceLoop) > 0))
			{
				ChangeResourceQuantityFromPOP(eResource, pBuildingInfo->GetResourceQuantityFromPOP(iResourceLoop) * iChange);
			}
#endif

			// Do we have this resource local?
			if (IsHasResourceLocal(eResource, /*bTestVisible*/ false))
			{
				// Our Building does give culture with eResource
				iCulture = GC.getBuildingInfo(eBuilding)->GetResourceCultureChange(eResource);

				if (iCulture != 0)
				{
					ChangeBaseYieldRateFromBuildings(YIELD_CULTURE, iCulture * m_paiNumResourcesLocal[eResource]);
				}

				// What about faith?
				iFaith = GC.getBuildingInfo(eBuilding)->GetResourceFaithChange(eResource);

				if (iFaith != 0)
				{
					ChangeBaseYieldRateFromBuildings(YIELD_FAITH, iFaith * m_paiNumResourcesLocal[eResource]);
				}
			}
		}

		if (pBuildingInfo->IsExtraLuxuries())
		{
			CvPlot* pLoopPlot = NULL;

			// Subtract off old luxury counts

			for (int iJ = 0; iJ < GetNumWorkablePlots(); iJ++)
			{
				pLoopPlot = iterateRingPlots(getX(), getY(), iJ);

				if (pLoopPlot != NULL && pLoopPlot->getOwner() == getOwner())
				{
					ResourceTypes eLoopResource = pLoopPlot->getResourceType();
					if (eLoopResource != NO_RESOURCE && GC.getResourceInfo(eLoopResource)->getResourceUsage() == RESOURCEUSAGE_LUXURY)
					{
						if (owningTeam.IsResourceCityTradeable(eLoopResource))
						{
							if (pLoopPlot == plot() || (pLoopPlot->getImprovementType() != NO_IMPROVEMENT && GC.getImprovementInfo(pLoopPlot->getImprovementType())->IsConnectsResource(eLoopResource)))
							{
								if (!pLoopPlot->IsImprovementPillaged())
								{
									owningPlayer.changeNumResourceTotal(pLoopPlot->getResourceType(), -pLoopPlot->getNumResourceForPlayer(getOwner()), /*bIgnoreResourceWarning*/ true);
								}
							}
						}
					}
				}
			}

			ChangeExtraLuxuryResources(iChange);

			// Add in new luxury counts

			for (int iJ = 0; iJ < GetNumWorkablePlots(); iJ++)
			{
				pLoopPlot = iterateRingPlots(getX(), getY(), iJ);

				if (pLoopPlot != NULL && pLoopPlot->getOwner() == getOwner())
				{
					ResourceTypes eLoopResource = pLoopPlot->getResourceType();
					if (eLoopResource != NO_RESOURCE && GC.getResourceInfo(eLoopResource)->getResourceUsage() == RESOURCEUSAGE_LUXURY)
					{
						if (owningTeam.IsResourceCityTradeable(eLoopResource))
						{
							if (pLoopPlot == plot() || (pLoopPlot->getImprovementType() != NO_IMPROVEMENT && GC.getImprovementInfo(pLoopPlot->getImprovementType())->IsConnectsResource(eLoopResource)))
							{
								if (!pLoopPlot->IsImprovementPillaged())
								{
									owningPlayer.changeNumResourceTotal(pLoopPlot->getResourceType(), pLoopPlot->getNumResourceForPlayer(getOwner()));
								}
							}
						}
					}
				}
			}
		}

		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);

#if defined(MOD_BALANCE_CORE)
		for (int iL = 0; iL < GC.getNumSpecialistInfos(); iL++)
		{
			SpecialistTypes eSpecialist = (SpecialistTypes)iL;
			CvSpecialistInfo* pSpecialistInfo = GC.getSpecialistInfo((SpecialistTypes)iL);
			if (pSpecialistInfo)
			{
				int iValue = pBuildingInfo->GetSpecificGreatPersonRateModifier((SpecialistTypes)iL);
				if (iValue > 0)
				{
					ChangeSpecialistRateModifier(eSpecialist, (pBuildingInfo->GetSpecificGreatPersonRateModifier((SpecialistTypes)iL) * iChange));
				}
			}
		}
#endif
		YieldTypes eYield;

		for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
		{
			eYield = (YieldTypes)iI;

			//Yield from growth
			if (pBuildingInfo->GetGrowthExtraYield(eYield) != 0)
			{
				ChangeGrowthExtraYield(eYield, pBuildingInfo->GetGrowthExtraYield(eYield) * iChange);
			}

#if defined(MOD_BALANCE_CORE)
			int iMod = pBuildingInfo->GetGreatWorkYieldChangeLocal(iI) * iChange;
			if (iMod != 0)
			{
				ChangeGreatWorkYieldChange((YieldTypes)iI, iMod);
			}

			if ((pBuildingInfo->GetYieldFromVictory(eYield) > 0))
			{
				ChangeYieldFromVictory(eYield, pBuildingInfo->GetYieldFromVictory(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldFromVictoryGlobal(eYield) > 0))
			{
				ChangeYieldFromVictoryGlobal(eYield, pBuildingInfo->GetYieldFromVictoryGlobal(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldFromVictoryGlobalEraScaling(eYield) > 0))
			{
				ChangeYieldFromVictoryGlobalEraScaling(eYield, pBuildingInfo->GetYieldFromVictoryGlobalEraScaling(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldFromPillage(eYield) > 0))
			{
				ChangeYieldFromPillage(eYield, pBuildingInfo->GetYieldFromPillage(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldFromPillageGlobal(eYield) > 0))
			{
				ChangeYieldFromPillageGlobal(eYield, pBuildingInfo->GetYieldFromPillageGlobal(eYield) * iChange);
			}

			if ((pBuildingInfo->GetGoldenAgeYieldMod(eYield) > 0))
			{
				ChangeGoldenAgeYieldMod(eYield, pBuildingInfo->GetGoldenAgeYieldMod(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldFromWLTKD(eYield) > 0))
			{
				ChangeYieldFromWLTKD(eYield, pBuildingInfo->GetYieldFromWLTKD(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldFromConstruction(eYield) > 0))
			{
				ChangeYieldFromConstruction(eYield, pBuildingInfo->GetYieldFromConstruction(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldFromTech(eYield) > 0))
			{
				ChangeYieldFromTech(eYield, pBuildingInfo->GetYieldFromTech(eYield) * iChange);
			}

			for (int iK = 0; iK < NUM_YIELD_TYPES; iK++)
			{
				YieldTypes eYield2 = (YieldTypes)iK;

				//protect against modder stupidity!
				if (eYield == eYield2)
					continue;

				int iBuildingVal = pBuildingInfo->GetYieldFromYield(eYield, eYield2);
				if (iBuildingVal > 0)
				{
					ChangeBuildingYieldFromYield(eYield, eYield2, (iBuildingVal * iChange));
				}

				int iGlobalConversionYield = pBuildingInfo->GetYieldFromYieldGlobal(eYield, eYield2);
				if (iGlobalConversionYield > 0)
				{
					GET_PLAYER(getOwner()).changeYieldFromYieldGlobal(eYield, eYield2, iGlobalConversionYield);
					int iLoop = 0;
					for (CvCity* pLoopCity = GET_PLAYER(getOwner()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(getOwner()).nextCity(&iLoop))
					{
						pLoopCity->ChangeBuildingYieldFromYield(eYield, eYield2, (iGlobalConversionYield * iChange));
					}
				}
			}

			if ((pBuildingInfo->GetYieldFromInternalTREnd(eYield) > 0))
			{
				ChangeYieldFromInternalTREnd(eYield, (pBuildingInfo->GetYieldFromInternalTREnd(eYield) * iChange));
			}

			if ((pBuildingInfo->GetYieldFromInternal(eYield) > 0))
			{
				ChangeYieldFromInternalTR(eYield, (pBuildingInfo->GetYieldFromInternal(eYield) * iChange));
			}

			if ((pBuildingInfo->GetYieldFromProcessModifier(eYield) > 0))
			{
				ChangeYieldFromProcessModifier(eYield, (pBuildingInfo->GetYieldFromProcessModifier(eYield) * iChange));
			}


			if ((pBuildingInfo->GetThemingYieldBonus(eYield) > 0))
			{
				ChangeThemingYieldBonus(eYield, pBuildingInfo->GetThemingYieldBonus(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldFromSpyAttack(eYield) > 0))
			{
				ChangeYieldFromSpyAttack(eYield, pBuildingInfo->GetYieldFromSpyAttack(eYield) * iChange);
			}
			if ((pBuildingInfo->GetYieldFromSpyDefense(eYield) > 0))
			{
				ChangeYieldFromSpyDefense(eYield, pBuildingInfo->GetYieldFromSpyDefense(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldFromBirth(eYield) > 0))
			{
				ChangeYieldFromBirth(eYield, pBuildingInfo->GetYieldFromBirth(eYield) * iChange);
			}
			if ((pBuildingInfo->GetYieldFromUnitProduction(eYield) > 0))
			{
				ChangeYieldFromUnitProduction(eYield, pBuildingInfo->GetYieldFromUnitProduction(eYield) * iChange);
			}
			if ((pBuildingInfo->GetYieldFromBorderGrowth(eYield) > 0))
			{
				ChangeYieldFromBorderGrowth(eYield, pBuildingInfo->GetYieldFromBorderGrowth(eYield) * iChange);
			}
			if ((pBuildingInfo->GetYieldFromPolicyUnlock(eYield) > 0))
			{
				ChangeYieldFromPolicyUnlock(eYield, pBuildingInfo->GetYieldFromPolicyUnlock(eYield) * iChange);
			}
			if ((pBuildingInfo->GetYieldFromPurchase(eYield) > 0))
			{
				ChangeYieldFromPurchase(eYield, pBuildingInfo->GetYieldFromPurchase(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldFromFaithPurchase(eYield) > 0))
			{
				ChangeYieldFromFaithPurchase(eYield, pBuildingInfo->GetYieldFromFaithPurchase(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldFromUnitLevelUp(eYield) > 0))
			{
				ChangeYieldFromUnitLevelUp(eYield, pBuildingInfo->GetYieldFromUnitLevelUp(eYield) * iChange);
			}

			if ((pBuildingInfo->GetYieldFromCombatExperience(eYield) > 0))
			{
				ChangeYieldFromCombatExperience(eYield, pBuildingInfo->GetYieldFromCombatExperience(eYield) * iChange);
			}

			ChangeYieldPerAlly(eYield, pBuildingInfo->GetYieldPerAlly(eYield) * iChange);
			ChangeYieldPerFriend(eYield, pBuildingInfo->GetYieldPerFriend(eYield) * iChange);
#endif
#if defined(MOD_BALANCE_CORE_EVENTS)
			if (GetEventBuildingClassCityYield(eBuildingClass, eYield) != 0)
			{
				ChangeBaseYieldRateFromBuildings(eYield, GetEventBuildingClassCityYield(eBuildingClass, eYield) * iChange);
			}
			if (GetEventBuildingClassCityYieldModifier(eBuildingClass, eYield) != 0)
			{
				changeYieldRateModifier(eYield, GetEventBuildingClassCityYieldModifier(eBuildingClass, eYield) * iChange);
			}
#endif
			changeSeaPlotYield(eYield, (pBuildingInfo->GetSeaPlotYieldChange(eYield) * iChange));
			changeRiverPlotYield(eYield, (pBuildingInfo->GetRiverPlotYieldChange(eYield) * iChange));
			changeLakePlotYield(eYield, (pBuildingInfo->GetLakePlotYieldChange(eYield) * iChange));
			changeSeaResourceYield(eYield, (pBuildingInfo->GetSeaResourceYieldChange(eYield) * iChange));
			ChangeBaseYieldRateFromBuildings(eYield, ((pBuildingInfo->GetYieldChange(eYield) + m_pCityBuildings->GetBuildingYieldChange(eBuildingClass, eYield)) * iChange));
			ChangeYieldPerPopTimes100(eYield, pBuildingInfo->GetYieldChangePerPop(eYield) * iChange);
#if defined(MOD_BALANCE_CORE)
			ChangeYieldPerPopInEmpireTimes100(eYield, pBuildingInfo->GetYieldChangePerPopInEmpire(eYield) * iChange);
#endif
			ChangeYieldPerReligionTimes100(eYield, pBuildingInfo->GetYieldChangePerReligion(eYield) * iChange);
			changeYieldRateModifier(eYield, (pBuildingInfo->GetYieldModifier(eYield) * iChange));

			CvPlayerPolicies* pPolicies = GET_PLAYER(getOwner()).GetPlayerPolicies();
			changeYieldRateModifier(eYield, pPolicies->GetBuildingClassYieldModifier(eBuildingClass, eYield) * iChange);
			ChangeBaseYieldRateFromBuildings(eYield, pPolicies->GetBuildingClassYieldChange(eBuildingClass, eYield) * iChange);

			int iYieldMod = pBuildingInfo->GetBuildingClassYieldModifier(eBuildingClass, eYield);
			if (iYieldMod != 0)
			{
				changeYieldRateModifier(eYield, iYieldMod * iChange);
			}

			ChangeBaseYieldRateFromBuildings(eYield, GET_PLAYER(getOwner()).GetPlayerTraits()->GetBuildingClassYieldChange(eBuildingClass, eYield) * iChange);

#if defined(MOD_BALANCE_CORE)
			// Building modifiers
			BuildingClassTypes eBuildingClassLocal;
			for (int iJ = 0; iJ < GC.getNumBuildingClassInfos(); iJ++)
			{
				eBuildingClassLocal = (BuildingClassTypes)iJ;

				CvBuildingClassInfo* pkBuildingClassLocalInfo = GC.getBuildingClassInfo(eBuildingClassLocal);
				if (!pkBuildingClassLocalInfo)
				{
					continue;
				}

				BuildingTypes eLocalBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(eBuildingClassLocal);

				if (MOD_BUILDINGS_THOROUGH_PREREQUISITES && eLocalBuilding == NO_BUILDING)
				{
					eLocalBuilding = (BuildingTypes)pkBuildingClassLocalInfo->getDefaultBuildingIndex();
				}

				if (eLocalBuilding != NO_BUILDING)
				{
					CvBuildingEntry* pkLocalBuilding = GC.getBuildingInfo(eLocalBuilding);
					if (pkLocalBuilding)
					{
						int iYieldChange = pBuildingInfo->GetBuildingClassLocalYieldChange(iJ, iI);

						if (isWorldWonderClass(*pkBuildingClassLocalInfo) && pBuildingInfo->GetYieldChangeWorldWonder(iI) != 0)
						{
							iYieldChange += pBuildingInfo->GetYieldChangeWorldWonder(iI);
						}

						if (iYieldChange != 0)
						{
							m_pCityBuildings->ChangeBuildingYieldChange(eBuildingClassLocal, eYield, (iYieldChange * iChange));
							changeLocalBuildingClassYield(eBuildingClassLocal, eYield, (iYieldChange * iChange));
						}
					}
				}
			}
			CorporationTypes eCorporation = GET_PLAYER(getOwner()).GetCorporations()->GetFoundedCorporation();
			if (eCorporation != NO_CORPORATION)
			{
				CvCorporationEntry* pkCorporationInfo = GC.getCorporationInfo(eCorporation);
				if (pkCorporationInfo)
				{
					ChangeBaseYieldRateFromBuildings(eYield, pkCorporationInfo->GetBuildingClassYieldChange(eBuildingClass, eYield) * iChange);
				}
			}
#endif

			//Policy-Religion Fusion Yield Changes
			if (MOD_BALANCE_CORE_POLICIES)
			{
				changeReligionBuildingYieldRateModifier(eBuildingClass, eYield, (pPolicies->GetReligionBuildingClassYieldModifier(eBuildingClass, eYield) * iChange));
			}

			if (pkBuildingClassInfo && isWorldWonderClass(*pkBuildingClassInfo))
			{
				ChangeBaseYieldRateFromBuildings(eYield, GetPlayer()->GetYieldChangeWorldWonder(eYield) * iChange);
				ChangeBaseYieldRateFromBuildings(eYield, GetPlayer()->GetPlayerTraits()->GetYieldChangeWorldWonder(eYield) * iChange);
				int iGlobalWonderBonus = owningPlayer.GetWorldWonderYieldChange(iI);
				if (iGlobalWonderBonus != 0)
				{
					m_pCityBuildings->ChangeBuildingYieldChange(eBuildingClass, eYield, (iGlobalWonderBonus * iChange));
					changeLocalBuildingClassYield(eBuildingClass, eYield, (iGlobalWonderBonus * iChange));
				}
			}

			for (int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
			{
				ChangeResourceExtraYield(((ResourceTypes)iJ), eYield, (GC.getBuildingInfo(eBuilding)->GetResourceYieldChange(iJ, eYield) * iChange));
			}

			for (int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
			{
				ChangeFeatureExtraYield(((FeatureTypes)iJ), eYield, (GC.getBuildingInfo(eBuilding)->GetFeatureYieldChange(iJ, eYield) * iChange));
			}

			// Is this building part of a Corporation?
			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
			if (pkBuildingClassInfo)
			{
				CorporationTypes eCorporation = pkBuildingClassInfo->getCorporationType();
				if (eCorporation != NO_CORPORATION)
				{
					CvCorporationEntry* pkCorporationInfo = GC.getCorporationInfo(eCorporation);
					if (pkCorporationInfo)
					{
						// Only if this is the Franchise
						if (pkCorporationInfo->GetFranchiseBuildingClass() == eBuildingClass)
						{
							for (int iJ = 0; iJ < GC.getNumResourceInfos(); iJ++)
							{
								ChangeResourceExtraYield(((ResourceTypes)iJ), eYield, (pkCorporationInfo->GetResourceYieldChange(iJ, eYield) * iChange));
							}
						}
					}
				}
			}

			for (int iJ = 0; iJ < GC.getNumImprovementInfos(); iJ++)
			{
				ImprovementTypes eImprovement = (ImprovementTypes)iJ;
				if (eImprovement != NO_IMPROVEMENT)
				{
					int iYieldChange = pBuildingInfo->GetImprovementYieldChange(eImprovement, eYield);
					if (iYieldChange > 0)
					{
						ChangeImprovementExtraYield(eImprovement, eYield, (iYieldChange * iChange));
					}
				}
			}

			for (int iJ = 0; iJ < GC.getNumTerrainInfos(); iJ++)
			{
				ChangeTerrainExtraYield(((TerrainTypes)iJ), eYield, (GC.getBuildingInfo(eBuilding)->GetTerrainYieldChange(iJ, eYield) * iChange));
				ChangeYieldPerXTerrainFromBuildingsTimes100(((TerrainTypes)iJ), eYield, (GC.getBuildingInfo(eBuilding)->GetYieldPerXTerrain(iJ, eYield) * iChange));
			}

			for (int iJ = 0; iJ < GC.getNumPlotInfos(); iJ++)
			{
				ChangePlotExtraYield(((PlotTypes)iJ), eYield, (GC.getBuildingInfo(eBuilding)->GetPlotYieldChange(iJ, eYield) * iChange));
			}

			for (int iJ = 0; iJ < GC.getNumFeatureInfos(); iJ++)
			{
				ChangeYieldPerXFeatureFromBuildingsTimes100(((FeatureTypes)iJ), eYield, (GC.getBuildingInfo(eBuilding)->GetYieldPerXFeature(iJ, eYield) * iChange));
			}

			// Research agreements are not active, therefore this building now increases science yield by 25%
			if (MOD_BALANCE_VP && !GC.getGame().isOption(GAMEOPTION_RESEARCH_AGREEMENTS))
			{
				if (pBuildingInfo->GetMedianTechPercentChange() > 0)
				{
					if (eYield == YIELD_SCIENCE)
					{
						int iChange = pBuildingInfo->GetMedianTechPercentChange(); //default 25

						changeYieldRateModifier(eYield, iChange);
					}
				}
			}

			if (pBuildingInfo->GetEnhancedYieldTech() != NO_TECH)
			{
				if (owningTeam.GetTeamTechs()->HasTech((TechTypes)pBuildingInfo->GetEnhancedYieldTech()))
				{
					ChangeBaseYieldRateFromBuildings(eYield, pBuildingInfo->GetTechEnhancedYieldChange(eYield) * iChange);
				}
			}

			int iBuildingClassBonus = owningPlayer.GetBuildingClassYieldChange(eBuildingClass, eYield);
			if (iBuildingClassBonus > 0)
			{
				ChangeBaseYieldRateFromBuildings(eYield, iBuildingClassBonus * iChange);
			}
		}

		if (GC.getBuildingInfo(eBuilding)->GetSpecialistType() != NO_SPECIALIST)
		{
			GetCityCitizens()->ChangeBuildingGreatPeopleRateChanges((SpecialistTypes)GC.getBuildingInfo(eBuilding)->GetSpecialistType(), pBuildingInfo->GetGreatPeopleRateChange() * iChange);
		}

		// Process for our player
		for (int iI = 0; iI < MAX_PLAYERS; iI++)
		{
			if (GET_PLAYER((PlayerTypes)iI).getTeam() == getTeam())
			{
				if (pBuildingInfo->IsTeamShare() || (iI == getOwner()))
				{
					GET_PLAYER((PlayerTypes)iI).processBuilding(eBuilding, iChange, bFirst, plot()->area());
				}
			}
		}

		// Process for our team
		owningTeam.processBuilding(eBuilding, iChange, bFirst);
	}

	if (!bObsolete)
	{
		m_pCityBuildings->ChangeBuildingDefense(pBuildingInfo->GetDefenseModifier() * iChange);

		owningTeam.changeBuildingClassCount(eBuildingClass, iChange);
		owningPlayer.changeBuildingClassCount(eBuildingClass, iChange);
	}

	UpdateReligion(GetCityReligions()->GetReligiousMajority());
	GET_PLAYER(getOwner()).CalculateNetHappiness();
	updateNetHappiness();

	GetCityCitizens()->SetDirty(true);

	if (IsPurchased(eBuildingClass) || pBuildingInfo->IsDummy())
	{
		bNoBonus = true;
	}
	//If a building is being processed, it has been here before. No more bonuses!
	if (!IsResistance() && !IsRazing() && !bNoBonus && bFirst && iChange > 0)
	{
		if (GetCityBuildings()->IsFirstTimeBuilding(eBuilding) <= 0)
		{
			GetCityBuildings()->SetFirstTimeBuilding(eBuilding, 1);

			if (::isWorldWonderClass(*GC.getBuildingClassInfo(eBuildingClass)))
			{
				GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_CONSTRUCTION_WONDER, false, NO_GREATPERSON, eBuilding, 0, true, NO_PLAYER, NULL, false, this);
			}
			else
			{
				GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_CONSTRUCTION, true, NO_GREATPERSON, eBuilding, 0, true, NO_PLAYER, NULL, false, this);
				GET_PLAYER(getOwner()).doInstantGreatPersonProgress(INSTANT_YIELD_TYPE_CONSTRUCTION, false, this, eBuilding);
			}
		}
	}

	setLayoutDirty(true);
}


//	--------------------------------------------------------------------------------
void CvCity::processProcess(ProcessTypes eProcess, int iChange)
{
	VALIDATE_OBJECT
	const CvProcessInfo* pkProcessInfo = GC.getProcessInfo(eProcess);
	CvAssertFmt(pkProcessInfo != NULL, "Process type %d is invalid", eProcess);
	if (pkProcessInfo != NULL)
	{
		// Convert to another yield
		for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
		{
			if (pkProcessInfo->getProductionToYieldModifier((YieldTypes)iI) <= 0)
				continue;

			int iDifficultyMod = GET_PLAYER(getOwner()).getHandicapInfo().getProcessBonus();
			iDifficultyMod += GET_PLAYER(getOwner()).getHandicapInfo().getProcessPerEraModifier() * GC.getGame().getCurrentEra();
			iDifficultyMod += GET_PLAYER(getOwner()).isHuman() ? 0 : GC.getGame().getHandicapInfo().getAIProcessBonus();
			iDifficultyMod += GET_PLAYER(getOwner()).isHuman() ? 0 : GC.getGame().getHandicapInfo().getAIProcessPerEraModifier() * GC.getGame().getCurrentEra();

			changeProductionToYieldModifier((YieldTypes)iI, (pkProcessInfo->getProductionToYieldModifier(iI) + GetYieldFromProcessModifier((YieldTypes)iI) + iDifficultyMod) * iChange);

			UpdateCityYields((YieldTypes)iI);
		}
	}
}


//	--------------------------------------------------------------------------------
void CvCity::processSpecialist(SpecialistTypes eSpecialist, int iChange, CvCity::eUpdateMode updateMode)
{
	VALIDATE_OBJECT
	CvSpecialistInfo* pkSpecialist = GC.getSpecialistInfo(eSpecialist);
	if (pkSpecialist == NULL)
	{
		//This function requires a valid specialist type.
		return;
	}

	changeBaseGreatPeopleRate(pkSpecialist->getGreatPeopleRateChange() * iChange);

	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		ChangeBaseYieldRateFromSpecialists(((YieldTypes)iI), (pkSpecialist->getYieldChange(iI) * iChange));
	}
	updateExtraSpecialistYield();
	changeSpecialistFreeExperience(pkSpecialist->getExperience() * iChange);

	// Culture
	int iCulturePerSpecialist = GetCultureFromSpecialist(eSpecialist);
	ChangeJONSCulturePerTurnFromSpecialists(iCulturePerSpecialist * iChange);

	for (int iI = 0; iI < NUM_DOMAIN_TYPES; iI++)
	{
		DomainTypes eDomain = (DomainTypes)iI;
		if (eDomain == NO_DOMAIN)
			continue;

		int iModifierPerSpecialist = GET_PLAYER(getOwner()).GetPlayerTraits()->GetDomainProductionModifiersPerSpecialist(eDomain);

		if (iModifierPerSpecialist != 0)
		{
			changeDomainProductionModifier(eDomain, iModifierPerSpecialist * iChange);
		}
	}

	if (updateMode == CvCity::YIELD_UPDATE_GLOBAL)
		UpdateAllNonPlotYields(true);
	else if (updateMode == CvCity::YIELD_UPDATE_LOCAL)
		UpdateAllNonPlotYields(false);
}

//very reduced version of UpdateReligion() which assumes only the number of specialists changed
void CvCity::UpdateReligiousYieldFromSpecialist(bool bFirstOneAdded)
{
	const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion( GetCityReligions()->GetReligiousMajority(), getOwner() );
	if (pReligion)
	{
		for (int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)
		{
			int iChange = pReligion->m_Beliefs.GetYieldChangeAnySpecialist((YieldTypes)iYield, getOwner(), this);

			//surgically add or remove some yields but don't recalculate from scratch
			if (bFirstOneAdded)
				ChangeBaseYieldRateFromReligion((YieldTypes)iYield, +iChange);
			else
				ChangeBaseYieldRateFromReligion((YieldTypes)iYield, -iChange);
		}
	}
}

//	--------------------------------------------------------------------------------
/// Process the majority religion changing for a city
void CvCity::UpdateReligion(ReligionTypes eNewMajority, bool bRecalcPlotYields)
{
	updateYield(bRecalcPlotYields);

	// Reset city level yields
	for (int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)
	{
		m_aiBaseYieldRateFromReligion[iYield] = 0;
	}

	for (int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)
	{
		int iYieldPerReligion = GetYieldPerReligionTimes100((YieldTypes)iYield);

		// Player-level yield per religion
		iYieldPerReligion += GET_PLAYER(getOwner()).GetYieldChangesPerReligionTimes100((YieldTypes)iYield);

		if (iYieldPerReligion > 0)
		{
			ChangeBaseYieldRateFromReligion((YieldTypes)iYield, (GetCityReligions()->GetNumReligionsWithFollowers() * iYieldPerReligion) / 100);
		}

		if (eNewMajority != NO_RELIGION)
		{
			const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eNewMajority, getOwner());
			if (pReligion)
			{
				int iFollowers = GetCityReligions()->GetNumFollowers(eNewMajority);

				int iReligionYieldChange = pReligion->m_Beliefs.GetCityYieldChange(getPopulation(), (YieldTypes)iYield, getOwner(), this);
#if defined(MOD_BALANCE_CORE_BELIEFS)
				int iReligionPop = pReligion->m_Beliefs.GetYieldPerPop((YieldTypes)iYield, getOwner(), this);
				if ((getPopulation() > 0) && (iReligionPop > 0))
				{
					int iFaithPerPop = (getPopulation() / iReligionPop);
					if (iFaithPerPop != 0)
					{
						iReligionYieldChange += iFaithPerPop;
					}
				}

				int iReligionYieldMaxFollowers = pReligion->m_Beliefs.GetMaxYieldPerFollower((YieldTypes)iYield, getOwner(), this);
				int iReligionYieldMaxFollowersPercent = pReligion->m_Beliefs.GetMaxYieldPerFollowerPercent((YieldTypes)iYield, getOwner(), this);
				if (iReligionYieldMaxFollowersPercent > 0)
				{
					int iVal = iFollowers * iReligionYieldMaxFollowersPercent;
					if (iVal > 0)
					{
						iVal /= 100;

						if (iVal <= 0)
							iVal = 1;

						int iTempMod = min(iVal, iReligionYieldMaxFollowers);
						iReligionYieldChange += iTempMod;
					}
				}
				else
				{
					if (iReligionYieldMaxFollowers > 0)
					{
						int iTempMod = min(iFollowers, iReligionYieldMaxFollowers);
						iReligionYieldChange += iTempMod;
					}
				}
#endif

				if (isCapital()) 
				{
					iReligionYieldChange += pReligion->m_Beliefs.GetCapitalYieldChange(getPopulation(), (YieldTypes)iYield, getOwner(), this);
				}
				if (isCoastal()) 
				{
					iReligionYieldChange += pReligion->m_Beliefs.GetCoastalCityYieldChange(getPopulation(), (YieldTypes)iYield, getOwner(), this);
				}

				BeliefTypes eSecondaryPantheon = GetCityReligions()->GetSecondaryReligionPantheonBelief();
				if (eSecondaryPantheon != NO_BELIEF && getPopulation() >= GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetMinPopulation())
				{
					iReligionYieldChange += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetCityYieldChange((YieldTypes)iYield);

					if ((getPopulation() > 0) && (GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetYieldPerPop((YieldTypes)iYield) > 0))
					{
						int iFaithPerPop = (getPopulation() / GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetYieldPerPop((YieldTypes)iYield));
						if (iFaithPerPop != 0)
						{
							iReligionYieldChange += iFaithPerPop;
						}
					}

					if (isCapital()) 
					{
						iReligionYieldChange += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetCapitalYieldChange((YieldTypes)iYield);
					}
					if (isCoastal()) 
					{
						iReligionYieldChange += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetCoastalCityYieldChange((YieldTypes)iYield);
					}
				}

				ChangeBaseYieldRateFromReligion((YieldTypes)iYield, iReligionYieldChange);

				if (IsRouteToCapitalConnected())
				{
					int iReligionChange = pReligion->m_Beliefs.GetYieldChangeTradeRoute((YieldTypes)iYield, getOwner(), this);
					//BeliefTypes eSecondaryPantheon = GetCityReligions()->GetSecondaryReligionPantheonBelief();
					if (eSecondaryPantheon != NO_BELIEF)
					{
						iReligionChange += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetYieldChangeTradeRoute((YieldTypes)iYield);
					}

					ChangeBaseYieldRateFromReligion((YieldTypes)iYield, iReligionChange);
				}

				if (GetCityCitizens()->GetTotalSpecialistCount() > 0)
				{
					ChangeBaseYieldRateFromReligion((YieldTypes)iYield, pReligion->m_Beliefs.GetYieldChangeAnySpecialist((YieldTypes)iYield, getOwner(), this));
				}

				vector<BuildingTypes> allBuildings = GetCityBuildings()->GetAllBuildingsHere();
				for (size_t iI = 0; iI < allBuildings.size(); iI++)
				{
					CvBuildingEntry* pkBuilding = GC.getBuildingInfo(allBuildings[iI]);
					if (pkBuilding)
					{
						BuildingClassTypes eBuildingClass = pkBuilding->GetBuildingClassType();
						int iYieldFromBuilding = pReligion->m_Beliefs.GetBuildingClassYieldChange(eBuildingClass, (YieldTypes)iYield, iFollowers, getOwner(), this);

						iYieldFromBuilding *= GetCityBuildings()->GetNumBuilding(allBuildings[iI]);

						if (isWorldWonderClass(*GC.getBuildingClassInfo(eBuildingClass)))
						{
							iYieldFromBuilding += pReligion->m_Beliefs.GetYieldChangeWorldWonder((YieldTypes)iYield, getOwner(), this);
						}

						//New majority, not a pantheon
						if (eNewMajority > RELIGION_PANTHEON)
						{
							//Our new majority matches our state religion, so let's add in our new yields.
							if (GET_PLAYER(getOwner()).GetReligions()->GetStateReligion() == eNewMajority)
							{
								iYieldFromBuilding += getReligionBuildingYieldRateModifier(eBuildingClass, (YieldTypes)iYield);
							}
						}

						ChangeBaseYieldRateFromReligion((YieldTypes)iYield, iYieldFromBuilding);
					}
				}
			}
		}

#if defined(MOD_RELIGION_PERMANENT_PANTHEON)
		// Mod for civs keeping their pantheon belief forever
		if (MOD_RELIGION_PERMANENT_PANTHEON)
		{
			if (GC.getGame().GetGameReligions()->HasCreatedPantheon(getOwner()))
			{
				const CvReligion* pPantheon = GC.getGame().GetGameReligions()->GetReligion(RELIGION_PANTHEON, getOwner());
				BeliefTypes ePantheonBelief = GC.getGame().GetGameReligions()->GetBeliefInPantheon(getOwner());
				BeliefTypes eSecondaryPantheon = GetCityReligions()->GetSecondaryReligionPantheonBelief();
				if (pPantheon != NULL && ePantheonBelief != NO_BELIEF && ePantheonBelief != eSecondaryPantheon)
				{
					const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eNewMajority, getOwner());
					if (pReligion == NULL || (pReligion != NULL && !pReligion->m_Beliefs.IsPantheonBeliefInReligion(ePantheonBelief, eNewMajority, getOwner()))) // check that the our religion does not have our belief, to prevent double counting
					{
						int iReligionYieldChange = GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetCityYieldChange((YieldTypes)iYield);
#if defined(MOD_BALANCE_CORE_BELIEFS)
						if ((getPopulation() > 0) && (GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetYieldPerPop((YieldTypes)iYield) > 0))
						{
							int iFaithPerPop = (getPopulation() / GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetYieldPerPop((YieldTypes)iYield));
							if (iFaithPerPop != 0)
							{
								iReligionYieldChange += iFaithPerPop;
							}
						}
#endif
						if (isCapital()) 
						{
							iReligionYieldChange += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetCapitalYieldChange((YieldTypes)iYield);
						}
						if (isCoastal()) 
						{
							iReligionYieldChange += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetCoastalCityYieldChange((YieldTypes)iYield);
						}

						iReligionYieldChange += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetYieldChangeTradeRoute((YieldTypes)iYield);
						ChangeBaseYieldRateFromReligion((YieldTypes)iYield, iReligionYieldChange);

						vector<BuildingTypes> allBuildings = GetCityBuildings()->GetAllBuildingsHere();
						for (size_t iI = 0; iI < allBuildings.size(); iI++)
						{
							CvBuildingEntry* pkBuilding = GC.getBuildingInfo(allBuildings[iI]);
							if (pkBuilding)
							{
								BuildingClassTypes eBuildingClass = pkBuilding->GetBuildingClassType();
								int iYieldFromBuilding = GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetBuildingClassYieldChange((int)eBuildingClass, iYield);

								iYieldFromBuilding *= GetCityBuildings()->GetNumBuilding(allBuildings[iI]);

								if (isWorldWonderClass(*GC.getBuildingClassInfo(eBuildingClass)))
								{
									iYieldFromBuilding += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetYieldChangeWorldWonder(iYield);
								}

								ChangeBaseYieldRateFromReligion((YieldTypes)iYield, iYieldFromBuilding);
							}
						}
					}
				}
			}
		}
#endif
	}
#if defined(MOD_BALANCE_CORE)
	//Some yield cleanup and refresh here - note that not all of this has to do with religion, however any time religion is updated, that's a good time to update the city's yields.
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes)iI;
		if (eYield == NO_YIELD)
			continue;

		UpdateSpecialReligionYields(eYield);
		UpdateCityYields(eYield);

		//Also mountains, because they aren't called anywhere else!
		UpdateYieldPerXTerrainFromReligion(eYield);
		UpdateYieldPerXFeature(eYield);
		UpdateYieldPerXTerrain(eYield, TERRAIN_MOUNTAIN);
		UpdateYieldPerXFeature(eYield);
		updateExtraSpecialistYield(eYield);
	}
#endif

#if defined(MOD_RELIGION_EXTENSIONS)
	if (MOD_RELIGION_EXTENSIONS && MOD_BALANCE_RETROACTIVE_PROMOS)
	{
		PlayerTypes eCityOwner = getOwner();
		if (eNewMajority != NO_RELIGION)
		{
			const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eNewMajority, eCityOwner);
			if (pReligion)
			{
				std::vector<int> aFreePromotions = pReligion->m_Beliefs.GetFreePromotions(eCityOwner, this, false);
				if (aFreePromotions.size() > 0)
				{
					for (std::vector<int>::iterator it = aFreePromotions.begin(); it != aFreePromotions.end(); ++it)
					{
						PromotionTypes ePromotion = (PromotionTypes)*it;
						SetRetroactivePromotion(ePromotion);
					}
				}
			}
		}
	}
#endif
	GET_PLAYER(getOwner()).UpdateReligion();
	UpdateHappinessFromReligion();
}
#if defined(MOD_BALANCE_CORE)
bool CvCity::HasPaidAdoptionBonus(ReligionTypes eReligion) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eReligion >= 0, "eReligion expected to be >= 0");
	CvAssertMsg(eReligion < GC.getNumReligionInfos(), "eReligion expected to be < getNumReligionInfos");
	return m_abPaidAdoptionBonus[eReligion];
}
void CvCity::SetPaidAdoptionBonus(ReligionTypes eReligion, bool bNewValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eReligion >= 0, "eReligion expected to be >= 0");
	CvAssertMsg(eReligion < GC.getNumReligionInfos(), "eReligion expected to be < getNumReligionInfos");
	m_abPaidAdoptionBonus[eReligion] = bNewValue;
}

int CvCity::GetReligiousPressureModifier(ReligionTypes eReligion) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eReligion >= 0, "eReligion expected to be >= 0");
	CvAssertMsg(eReligion < GC.getNumReligionInfos(), "eReligion expected to be < getNumReligionInfos");
	return m_aiReligiousPressureModifier[eReligion];
}
void CvCity::SetReligiousPressureModifier(ReligionTypes eReligion, int iNewValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eReligion >= 0, "eReligion expected to be >= 0");
	CvAssertMsg(eReligion < GC.getNumReligionInfos(), "eReligion expected to be < getNumReligionInfos");
	m_aiReligiousPressureModifier[eReligion] = iNewValue;
}
void CvCity::ChangeReligiousPressureModifier(ReligionTypes eReligion, int iNewValue)
{
	SetReligiousPressureModifier(eReligion, (GetReligiousPressureModifier(eReligion) + iNewValue));
}
#endif
//	--------------------------------------------------------------------------------
/// Culture from eSpecialist
int CvCity::GetCultureFromSpecialist(SpecialistTypes eSpecialist) const
{
	CvSpecialistInfo* pkSpecialistInfo = GC.getSpecialistInfo(eSpecialist);
	if (pkSpecialistInfo == NULL)
	{
		//This function REQUIRES a valid specialist type.
		return 0;
	}

	int iCulture = pkSpecialistInfo->getCulturePerTurn() + GET_PLAYER(getOwner()).GetSpecialistCultureChange();
	return iCulture;
}

//	--------------------------------------------------------------------------------
const CvHandicapInfo& CvCity::getHandicapInfo() const
{
	return GET_PLAYER(getOwner()).getHandicapInfo();
}

//	--------------------------------------------------------------------------------
HandicapTypes CvCity::getHandicapType() const
{
	VALIDATE_OBJECT
	return GET_PLAYER(getOwner()).getHandicapType();
}

//	--------------------------------------------------------------------------------
const CvCivilizationInfo& CvCity::getCivilizationInfo() const
{
	return GET_PLAYER(getOwner()).getCivilizationInfo();
}

//	--------------------------------------------------------------------------------
CivilizationTypes CvCity::getCivilizationType() const
{
	VALIDATE_OBJECT
	return GET_PLAYER(getOwner()).getCivilizationType();
}


//	--------------------------------------------------------------------------------
LeaderHeadTypes CvCity::getPersonalityType() const
{
	VALIDATE_OBJECT
	return GET_PLAYER(getOwner()).getPersonalityType();
}


//	--------------------------------------------------------------------------------
ArtStyleTypes CvCity::getArtStyleType() const
{
	VALIDATE_OBJECT
	return GET_PLAYER(getOwner()).getArtStyleType();
}


//	--------------------------------------------------------------------------------
CitySizeTypes CvCity::getCitySizeType() const
{
	VALIDATE_OBJECT
	return ((CitySizeTypes)(range((getPopulation() / 7), 0, (NUM_CITYSIZE_TYPES - 1))));
}


//	--------------------------------------------------------------------------------
bool CvCity::isBarbarian() const
{
	VALIDATE_OBJECT
	return GET_PLAYER(getOwner()).isBarbarian();
}


//	--------------------------------------------------------------------------------
bool CvCity::isHuman() const
{
	VALIDATE_OBJECT
	return GET_PLAYER(getOwner()).isHuman();
}

//	Automated City Production
bool CvCity::isHumanAutomated() const
{
	VALIDATE_OBJECT
	return GET_PLAYER(getOwner()).isHuman() && isProductionAutomated() && !IsPuppet();
}

//	--------------------------------------------------------------------------------
bool CvCity::isVisible(TeamTypes eTeam, bool bDebug) const
{
	VALIDATE_OBJECT
	return plot()->isVisible(eTeam, bDebug);
}


//	--------------------------------------------------------------------------------
bool CvCity::isCapital() const
{
	VALIDATE_OBJECT
	return (GET_PLAYER(getOwner()).getCapitalCityID() == GetID());
}

//	--------------------------------------------------------------------------------
/// Was this city originally any player's capital?
bool CvCity::IsOriginalCapital() const
{
	VALIDATE_OBJECT

	CvPlayerAI& kPlayer = GET_PLAYER(m_eOriginalOwner);
	if (getX() == kPlayer.GetOriginalCapitalX() && getY() == kPlayer.GetOriginalCapitalY())
	{
		return true;
	}

	return false;
}

//	--------------------------------------------------------------------------------
/// Was this city originally a major civ's capital?
bool CvCity::IsOriginalMajorCapital() const
{
	VALIDATE_OBJECT

	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes)iPlayerLoop;
		CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);
		if (getX() == kPlayer.GetOriginalCapitalX() && getY() == kPlayer.GetOriginalCapitalY())
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
/// Was this city originally a major civ's capital?
bool CvCity::IsOriginalMinorCapital() const
{
	VALIDATE_OBJECT

	for (int iPlayerLoop = MAX_MAJOR_CIVS; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes ePlayer = (PlayerTypes)iPlayerLoop;
		CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);
		if (getX() == kPlayer.GetOriginalCapitalX() && getY() == kPlayer.GetOriginalCapitalY())
		{
			return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
/// Was this city a player's original capital?
bool CvCity::IsOriginalCapitalForPlayer(PlayerTypes ePlayer) const
{
	VALIDATE_OBJECT

	if (ePlayer == NO_PLAYER || ePlayer == BARBARIAN_PLAYER)
		return false;

	CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);
	if (getX() == kPlayer.GetOriginalCapitalX() && getY() == kPlayer.GetOriginalCapitalY())
	{
		return true;
	}

	return false;
}

//	--------------------------------------------------------------------------------
/// Who owns this city for the purposes of a Domination Victory?
/// Note: This function assumes the city is an original major capital.
PlayerTypes CvCity::GetOwnerForDominationVictory() const
{
	PlayerTypes eCapitalOwner = getOwner();
	TeamTypes eOwnerTeam = getTeam();

	// A City-State's ally controls their capital.
	if (GET_PLAYER(eCapitalOwner).isMinorCiv())
	{
		PlayerTypes eAlly = GET_PLAYER(eCapitalOwner).GetMinorCivAI()->GetAlly();
		if (eAlly != NO_PLAYER)
		{
			// However, if the ally is a vassal, then their master controls the City-State's capital.
			if (GET_TEAM(GET_PLAYER(eAlly).getTeam()).IsVassalOfSomeone())
			{
				TeamTypes eMasterTeam = GET_TEAM(GET_PLAYER(eAlly).getTeam()).GetMaster();
				if (GET_TEAM(eMasterTeam).getLeaderID() != NO_PLAYER)
					return GET_TEAM(eMasterTeam).getLeaderID();
			}
			else
				return eAlly;
		}
	}
	// If a vassal owns a capital, their master controls it.
	else if (GET_TEAM(eOwnerTeam).IsVassalOfSomeone())
	{
		TeamTypes eMasterTeam = GET_TEAM(eOwnerTeam).GetMaster();
		if (GET_TEAM(eMasterTeam).getLeaderID() != NO_PLAYER)
			return GET_TEAM(eMasterTeam).getLeaderID();
	}

	// Otherwise, the owner controls the capital.
	return eCapitalOwner;
}

//	--------------------------------------------------------------------------------
bool CvCity::isCoastal(int iMinWaterSize) const
{
	VALIDATE_OBJECT
	return plot()->isCoastalLand(iMinWaterSize);
}

//	--------------------------------------------------------------------------------
bool CvCity::isAddsFreshWater() const 
{
	VALIDATE_OBJECT

	//ideally this should be cached and changed when a building is added/removed ...
	const std::vector<BuildingTypes>& vBuildings = GetCityBuildings()->GetAllBuildingsHere();
	for (size_t iBuilding = 0; iBuilding < vBuildings.size(); iBuilding++)
	{
		CvBuildingEntry* pInfo = GC.getBuildingInfo(vBuildings[iBuilding]);
		if (pInfo && pInfo->IsAddsFreshWater())
			return true;
	}

	return false;
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvCity::GetUnitPurchaseCooldown(bool bCivilian) const
{
	VALIDATE_OBJECT
	if (bCivilian)
		return m_iUnitPurchaseCooldownCivilian;

	return m_iUnitPurchaseCooldown;
}
//	--------------------------------------------------------------------------------
void CvCity::SetUnitPurchaseCooldown(bool bCivilian, int iValue)
{
	VALIDATE_OBJECT
	if (bCivilian)
		m_iUnitPurchaseCooldownCivilian = iValue;
	else
		m_iUnitPurchaseCooldown = iValue;
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeUnitPurchaseCooldown(bool bCivilian, int iValue)
{
	VALIDATE_OBJECT
	if (iValue != 0)
	{
		if (bCivilian)
			m_iUnitPurchaseCooldownCivilian += iValue;
		else
			m_iUnitPurchaseCooldown += iValue;
	}
}
//	--------------------------------------------------------------------------------
int CvCity::GetUnitPurchaseCooldownMod(bool bCivilian) const
{
	VALIDATE_OBJECT
		if (bCivilian)
			return m_iUnitPurchaseCooldownCivilianMod;

	return m_iUnitPurchaseCooldownMod;
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeUnitPurchaseCooldownMod(bool bCivilian, int iValue)
{
	VALIDATE_OBJECT
	if (bCivilian)
		m_iUnitPurchaseCooldownCivilianMod += iValue;
	else
		m_iUnitPurchaseCooldownMod += iValue;
}
//	--------------------------------------------------------------------------------
int CvCity::GetUnitFaithPurchaseCooldown(bool bCivilian) const
{
	VALIDATE_OBJECT
	if (bCivilian)
		return m_iUnitFaithPurchaseCooldownCivilian;

	return m_iUnitFaithPurchaseCooldown;
}
//	--------------------------------------------------------------------------------
void CvCity::SetUnitFaithPurchaseCooldown(bool bCivilian, int iValue)
{
	VALIDATE_OBJECT
	if (bCivilian)
		m_iUnitFaithPurchaseCooldownCivilian = iValue;
	else
		m_iUnitFaithPurchaseCooldown = iValue;
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeUnitFaithPurchaseCooldown(bool bCivilian, int iValue)
{
	VALIDATE_OBJECT
	if (iValue != 0)
	{
		if (bCivilian)
			m_iUnitFaithPurchaseCooldownCivilian += iValue;
		else
			m_iUnitFaithPurchaseCooldown += iValue;
	}
}
//	--------------------------------------------------------------------------------
int CvCity::GetBuildingPurchaseCooldown() const
{
	VALIDATE_OBJECT
	return m_iBuildingPurchaseCooldown;
}
//	--------------------------------------------------------------------------------
void CvCity::SetBuildingPurchaseCooldown(int iValue)
{
	VALIDATE_OBJECT
	m_iBuildingPurchaseCooldown = iValue;
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeBuildingPurchaseCooldown(int iValue)
{
	VALIDATE_OBJECT
	if (iValue != 0)
	{
		m_iBuildingPurchaseCooldown += iValue;
	}
}
void CvCity::DoSellBuilding()
{
	// Only sell buildings if we're razing
	if (!IsRazing())
		return;

	// Can't sell anything?
	if (IsResistance() || GetCityBuildings()->IsSoldBuildingThisTurn() || GET_PLAYER(getOwner()).GetPlayerTraits()->IsNoAnnexing())
		return;

	int iBestRefund = 0;
	BuildingTypes eBestBuilding = NO_BUILDING;
	for (int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

		if (pkBuildingInfo)
		{
			// Has this Building
			if (GetCityBuildings()->GetNumBuilding(eBuilding) > 0 && GetCityBuildings()->IsBuildingSellable(*pkBuildingInfo))
			{
				int iRefund = GetCityBuildings()->GetSellBuildingRefund(eBuilding);
				if (iRefund > iBestRefund)
				{
					iBestRefund = iRefund;
					eBestBuilding = eBuilding;
				}
			}
		}
	}
	if (eBestBuilding != NO_BUILDING)
	{
		GetCityBuildings()->DoSellBuilding(eBestBuilding);
		if (GC.getLogging() && GC.getAILogging())
		{
			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBestBuilding);
			if (pkBuildingInfo)
			{
				CvString strLogString;
				strLogString.Format("MOD - Selling building in a razed city: %s in %s. Gold Recovered: %d",
					pkBuildingInfo->GetDescription(), getName().c_str(), iBestRefund);

				GET_PLAYER(getOwner()).GetHomelandAI()->LogHomelandMessage(strLogString);
			}
		}
	}
}
void CvCity::SetTraded(PlayerTypes ePlayer, bool bValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(ePlayer >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(ePlayer < MAX_PLAYERS, "eIndex expected to be < MAX_PLAYERS");
	m_abTraded[ePlayer] = bValue;
}
bool CvCity::IsTraded(PlayerTypes ePlayer)
{
	VALIDATE_OBJECT
	CvAssertMsg(ePlayer >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(ePlayer < MAX_PLAYERS, "eIndex expected to be < MAX_PLAYERS");
	return m_abTraded[ePlayer];
}

void CvCity::SetIgnoredForExpansionBickering(PlayerTypes ePlayer, bool bValue)
{
	VALIDATE_OBJECT
	m_abIgnoredForExpansionBickering[ePlayer] = bValue;
}
bool CvCity::IsIgnoredForExpansionBickering(PlayerTypes ePlayer) const
{
	return m_abIgnoredForExpansionBickering[ePlayer];
}

void CvCity::CheckForOperationUnits()
{
	VALIDATE_OBJECT
	UnitTypes eBestUnit;
	UnitAITypes eUnitAI;
	if (CityStrategyAIHelpers::IsTestCityStrategy_IsPuppetAndAnnexable(this) || IsRazing())
		return;

	if (GET_PLAYER(getOwner()).isMinorCiv() || isBarbarian())
		return;

	if (isHumanAutomated()) // absolutely no units in automated cities
		return;

	CvPlayerAI& kPlayer = GET_PLAYER(getOwner());

	//Don't if we're in debt.
	if (kPlayer.GetTreasury()->AverageIncome100(10) < 0)
	{
		return;
	}

	//Do we already have a military unit in the queue? If so, let's not flood the queue.
	bool bAlreadyUnderConstruction = false;
	const OrderData* pOrderNode = headOrderQueueNode();

	while (pOrderNode != NULL)
	{
		if (pOrderNode->eOrderType == ORDER_TRAIN)
		{
			bAlreadyUnderConstruction = true;
			break;
		}
		pOrderNode = nextOrderQueueNode(pOrderNode);
	}
	if (bAlreadyUnderConstruction)
	{
		return;
	}
	bool bAppend = true;
	if (kPlayer.GetMilitaryAI()->GetNumberCivsAtWarWith(false) > 0)
	{
		bAppend = false;
	}

	bool bCitySameAsMuster = false;
	OperationSlot thisOperationSlot = kPlayer.PeekAtNextUnitToBuildForOperationSlot(this, bCitySameAsMuster);
	if (thisOperationSlot.IsValid() && bCitySameAsMuster)
	{
		CvArmyAI* pThisArmy = kPlayer.getArmyAI(thisOperationSlot.m_iArmyID);

		if (pThisArmy)
		{
			CvFormationSlotEntry slotEntry = pThisArmy->GetSlotInfo(thisOperationSlot.m_iSlotID);
			int iTempWeight = 100;
			eUnitAI = (UnitAITypes)slotEntry.m_primaryUnitType;
			eBestUnit = m_pCityStrategyAI->GetUnitProductionAI()->RecommendUnit(eUnitAI, true);
			if (eBestUnit == NO_UNIT)
			{
				eUnitAI = (UnitAITypes)slotEntry.m_secondaryUnitType;
				eBestUnit = m_pCityStrategyAI->GetUnitProductionAI()->RecommendUnit(eUnitAI, true);
			}
			if (eBestUnit != NO_UNIT)
			{
				iTempWeight = GetCityStrategyAI()->GetUnitProductionAI()->CheckUnitBuildSanity(eBestUnit, true, iTempWeight, true);
				if (iTempWeight > 0)
				{
					int iGoldCost = GetPurchaseCost(eBestUnit);
					CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eBestUnit);
					if (pkUnitEntry && kPlayer.GetEconomicAI()->CanWithdrawMoneyForPurchase(PURCHASE_TYPE_UNIT, iGoldCost) && IsCanPurchase(/*bTestPurchaseCost*/ true, /*bTestTrainable*/ true, eBestUnit, NO_BUILDING, NO_PROJECT, YIELD_GOLD))
					{
						//Log it
						CvString strLogString;
						strLogString.Format("MOD - Buying unit for active operation from City root function: %s in %s. Cost: %d, Balance (before buy): %d",
							pkUnitEntry->GetDescription(), getName().c_str(), iGoldCost, GET_PLAYER(getOwner()).GetTreasury()->GetGold());
						GetCityStrategyAI()->LogHurryMessage(strLogString);

						//take the money...
						kPlayer.GetTreasury()->ChangeGold(-iGoldCost);

						bool bInvest = MOD_BALANCE_CORE_UNIT_INVESTMENTS || (MOD_BALANCE_VP && pkUnitEntry->GetSpaceshipProject() != NO_PROJECT);
						if (bInvest)
						{
							const UnitClassTypes eUnitClass = (UnitClassTypes)(pkUnitEntry->GetUnitClassType());
							if (eUnitClass != NO_UNITCLASS)
							{
								SetUnitInvestment(eUnitClass, true);
								if (CityStrategyAIHelpers::IsTestCityStrategy_IsPuppetAndAnnexable(this))
								{
									if (getProductionProcess() != NO_PROCESS)
									{
										clearOrderQueue();
									}
									pushOrder(ORDER_TRAIN, eBestUnit, -1, false, false, true, false);
								}
								else if (!GET_PLAYER(getOwner()).isHuman() && !IsPuppet())
								{
									if (getProductionProcess() != NO_PROCESS)
									{
										clearOrderQueue();
									}
									pushOrder(ORDER_TRAIN, eBestUnit, -1, false, false, true, false);
								}
							}
						}
						else
						{
							//and train it!
							UnitAITypes eUnitAI = pkUnitEntry->GetDefaultUnitAIType();
							CvUnit* pUnit = CreateUnit(eBestUnit, eUnitAI, REASON_BUY, true);
							if (pUnit)
							{
								//assume the unit will be recruited automatically?
								kPlayer.GetMilitaryAI()->ResetNumberOfTimesOpsBuildSkippedOver();

								CleanUpQueue();
								return;
							}
						}
					}
				}
				else
				{
					if (getProductionTurnsLeft(eBestUnit, 0) >= 7)
					{
						return;
					}

					iTempWeight = GetCityStrategyAI()->GetUnitProductionAI()->CheckUnitBuildSanity(eBestUnit, true, iTempWeight);
					if (iTempWeight > 0)
					{
						pushOrder(ORDER_TRAIN, eBestUnit, eUnitAI, false, false, bAppend, false /*bRush*/);
						if (!bAppend)
						{
							kPlayer.CityCommitToBuildUnitForOperationSlot(thisOperationSlot);
							m_unitBeingBuiltForOperation = thisOperationSlot;
							kPlayer.GetMilitaryAI()->ResetNumberOfTimesOpsBuildSkippedOver();
						}
						//Log it
						CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eBestUnit);
						if (pkUnitEntry)
						{
							if (GC.getLogging() && GC.getAILogging())
							{
								CvString strLogString;
								strLogString.Format("MOD - Building unit for active operation from City root function: %s in %s. Turns: %d",
									pkUnitEntry->GetDescription(), getName().c_str(), getProductionTurnsLeft(eBestUnit, 0));
								GetCityStrategyAI()->LogHurryMessage(strLogString);
							}
						}
						return;
					}
				}
			}
		}
	}
	eBestUnit = kPlayer.GetMilitaryAI()->GetUnitTypeForArmy(this);
	if (eBestUnit != NO_UNIT)
	{
		if (getProductionTurnsLeft(eBestUnit, 0) >= 10)
		{
			return;
		}
	}
	bool bTarget = false;
	for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
	{
		PlayerTypes eLoopPlayer = (PlayerTypes) iPlayerLoop;

		if (eLoopPlayer != NO_PLAYER && GET_PLAYER(eLoopPlayer).isAlive() && eLoopPlayer != getOwner())
		{
			if (kPlayer.GetDiplomacyAI()->IsWantsSneakAttack(eLoopPlayer))
			{
				bTarget = true;
				break;
			}
		}
	}
	if (bTarget)
	{
		if (eBestUnit != NO_UNIT)
		{
			int iGoldCost = GetPurchaseCost(eBestUnit);
			CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eBestUnit);
			if (pkUnitEntry && kPlayer.GetEconomicAI()->CanWithdrawMoneyForPurchase(PURCHASE_TYPE_UNIT, iGoldCost) && IsCanPurchase(/*bTestPurchaseCost*/ true, /*bTestTrainable*/ true, eBestUnit, NO_BUILDING, NO_PROJECT, YIELD_GOLD))
			{
				//Log it
				CvString strLogString;
				strLogString.Format("MOD - Buying unit for sneak attack from City root function: %s in %s. Cost: %d, Balance (before buy): %d",
					pkUnitEntry->GetDescription(), getName().c_str(), iGoldCost, GET_PLAYER(getOwner()).GetTreasury()->GetGold());
				kPlayer.GetHomelandAI()->LogHomelandMessage(strLogString);

				//take the money...
				kPlayer.GetTreasury()->ChangeGold(-iGoldCost);

				bool bInvest = MOD_BALANCE_CORE_UNIT_INVESTMENTS || (MOD_BALANCE_VP && pkUnitEntry->GetSpaceshipProject() != NO_PROJECT);
				if (bInvest)
				{
					const UnitClassTypes eUnitClass = (UnitClassTypes)(pkUnitEntry->GetUnitClassType());
					if (eUnitClass != NO_UNITCLASS)
					{
						SetUnitInvestment(eUnitClass, true);
						if (CityStrategyAIHelpers::IsTestCityStrategy_IsPuppetAndAnnexable(this))
						{
							if (getProductionProcess() != NO_PROCESS)
							{
								clearOrderQueue();
							}
							pushOrder(ORDER_TRAIN, eBestUnit, -1, false, false, true, false);
						}
						else if (!GET_PLAYER(getOwner()).isHuman() && !IsPuppet())
						{
							if (getProductionProcess() != NO_PROCESS)
							{
								clearOrderQueue();
							}
							pushOrder(ORDER_TRAIN, eBestUnit, -1, false, false, true, false);
						}
					}
				}
				else
				{
					//and train it!
					UnitAITypes eUnitAI = pkUnitEntry->GetDefaultUnitAIType();
					CvUnit* pUnit = CreateUnit(eBestUnit, eUnitAI, REASON_BUY, false);
					if (pUnit)
					{
						CleanUpQueue();

						kPlayer.GetMilitaryAI()->ResetNumberOfTimesOpsBuildSkippedOver();
					}
				}
				return;
			}
			else
			{
				CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eBestUnit);
				if (pkUnitEntry)
				{
					UnitAITypes eUnitAI = pkUnitEntry->GetDefaultUnitAIType();
					pushOrder(ORDER_TRAIN, eBestUnit, eUnitAI, false, false, bAppend, false /*bRush*/);
					if (GC.getLogging() && GC.getAILogging())
					{
						CvString strLogString;
						strLogString.Format("MOD - Building unit for sneak attack (or at war) from City root function: %s in %s. Turns: %d",
							pkUnitEntry->GetDescription(), getName().c_str(), getProductionTurnsLeft(eBestUnit, 0));
						kPlayer.GetHomelandAI()->LogHomelandMessage(strLogString);
					}

					kPlayer.GetMilitaryAI()->ResetNumberOfTimesOpsBuildSkippedOver();
				}
				return;
			}
		}
	}
}
#endif

//	--------------------------------------------------------------------------------
//	Returns food consumed by a non-specialist citizen
int CvCity::foodConsumptionNonSpecialistTimes100() const
{
	VALIDATE_OBJECT

	int iFoodPerPop = /*2*/ GD_INT_GET(FOOD_CONSUMPTION_PER_POPULATION) * 100;
	iFoodPerPop += GetAdditionalFood() * 100;
	iFoodPerPop += GET_PLAYER(getOwner()).GetPlayerTraits()->GetNonSpecialistFoodChange();
	iFoodPerPop = max(100, iFoodPerPop); //cannot reduce food per citizen to less than 1
	return iFoodPerPop;
}

//	--------------------------------------------------------------------------------
//	Returns food consumed by a specialist depending on Era and applicable modifiers
int CvCity::foodConsumptionSpecialistTimes100() const
{
	VALIDATE_OBJECT
	int iFoodPerSpec = 0;
	if (MOD_BALANCE_YIELD_SCALE_ERA)
	{
		iFoodPerSpec = max((int)GET_PLAYER(getOwner()).GetCurrentEra(), /*2*/ GD_INT_GET(FOOD_CONSUMPTION_PER_POPULATION)) + 1;
		iFoodPerSpec = min(iFoodPerSpec, 10) * 100;
	}
	else
	{
		iFoodPerSpec = /*2*/ GD_INT_GET(FOOD_CONSUMPTION_PER_POPULATION) * 100;
	}

	iFoodPerSpec += GET_PLAYER(getOwner()).GetSpecialistFoodChange() * 100;

	// Specialists eat less food? (Policies, etc.)
	if (GET_PLAYER(getOwner()).isHalfSpecialistFood())
	{
		iFoodPerSpec /= 2;
	}
#if defined(MOD_BALANCE_CORE)
	if (GET_PLAYER(getOwner()).isHalfSpecialistFoodCapital() && isCapital())
	{
		iFoodPerSpec /= 2;
	}
#endif

	return max(100, iFoodPerSpec);
}

// --------------------------------------------------------------------------------
int CvCity::foodConsumption(bool bNoAngry, int iExtra) const
{
	return foodConsumptionTimes100(bNoAngry, iExtra * 100) / 100;
}
//	--------------------------------------------------------------------------------
int CvCity::foodConsumptionTimes100(bool /*bNoAngry*/, int iExtra) const
{
	VALIDATE_OBJECT

	int iSpecialists = GetCityCitizens()->GetTotalSpecialistCount();
	int iNonSpecialists = max(0, (getPopulation() - iSpecialists)) + iExtra;

	return max(100, foodConsumptionNonSpecialistTimes100() * iNonSpecialists + foodConsumptionSpecialistTimes100() * iSpecialists);
}


//	--------------------------------------------------------------------------------
int CvCity::foodDifference(bool bJustCheckingStarve) const
{
	VALIDATE_OBJECT
	return foodDifferenceTimes100(bJustCheckingStarve) / 100;
}


//	--------------------------------------------------------------------------------
int CvCity::foodDifferenceTimes100(bool bJustCheckingStarve, CvString* toolTipSink) const
{
	VALIDATE_OBJECT
	int iDifference = 0;

	if (isFoodProduction())
	{
		iDifference = std::min(0, GetFoodProductionTimes100(getYieldRateTimes100(YIELD_FOOD, false) - foodConsumptionTimes100()));
	}
	else
	{
		iDifference = (getYieldRateTimes100(YIELD_FOOD, false) - foodConsumptionTimes100());
	}

	//can starve if at size 1 and nothing stored
	if (getPopulation() == 1 && getFood() == 0)
	{
		iDifference = std::max(0, iDifference);
	}

	if (bJustCheckingStarve) //important, otherwise we can get into endless recursion (happiness depends on food which depends on happiness!)
		return iDifference;

	// Growth Mods - Only apply if the City is growing (and not starving, otherwise it would actually have the OPPOSITE of the intended effect!)
	if (iDifference > 0)
	{
		int iTotalMod = 100;

		// Capital Mod for player. Used for Policies and such
		if (isCapital())
		{
			int iCapitalGrowthMod = GET_PLAYER(getOwner()).GetCapitalGrowthMod();
			if (iCapitalGrowthMod != 0)
			{
				iTotalMod += iCapitalGrowthMod;
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_CAPITAL", iCapitalGrowthMod);
			}
		}

		// City Mod for player. Used for Policies and such
		int iCityGrowthMod = GET_PLAYER(getOwner()).GetCityGrowthMod();
		if (iCityGrowthMod != 0)
		{
			iTotalMod += iCityGrowthMod;
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_PLAYER", iCityGrowthMod);
		}

#if defined(MOD_BALANCE_CORE)
		if (GET_PLAYER(getOwner()).isGoldenAge() && (GetGoldenAgeYieldMod(YIELD_FOOD) != 0))
		{
			int iBuildingMod = GetGoldenAgeYieldMod(YIELD_FOOD);
			iTotalMod += iBuildingMod;
			if (toolTipSink)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_YIELD_GOLDEN_AGE_BUILDINGS", iBuildingMod);
		}
		if (GET_PLAYER(getOwner()).isGoldenAge() && GET_PLAYER(getOwner()).getGoldenAgeYieldMod(YIELD_FOOD) != 0)
		{
			int iPolicyMod = GET_PLAYER(getOwner()).getGoldenAgeYieldMod(YIELD_FOOD);
			iTotalMod += iPolicyMod;
			if (toolTipSink)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_YIELD_GOLDEN_AGE_POLICIES", iPolicyMod);
		}
		if (GET_PLAYER(getOwner()).GetPlayerTraits()->GetGoldenAgeYieldModifier(YIELD_FOOD) != 0)
		{
			int iTraitMod = GET_PLAYER(getOwner()).GetPlayerTraits()->GetGoldenAgeYieldModifier(YIELD_FOOD);
			iTotalMod += iTraitMod;
			if (toolTipSink)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_YIELD_GOLDEN_AGE_TRAITS", iTraitMod);
		}

		int iSupply = GET_PLAYER(getOwner()).GetNumUnitsOutOfSupply();
		if (MOD_BALANCE_VP && iSupply > 0)
		{
			int iSupplyMod = GET_PLAYER(getOwner()).GetUnitGrowthMaintenanceMod();
			iTotalMod += iSupplyMod;
			if (toolTipSink)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_YIELD_OVER_SUPPLY", iSupplyMod);
		}
#endif
		if (MOD_BALANCE_CORE)
		{
			int iGetGrowthModEvent = GetGrowthFromEvent();
			iTotalMod += iGetGrowthModEvent;
			if (iGetGrowthModEvent != 0)
			{
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_EVENT", iGetGrowthModEvent);
			}

			int iGrowthTourism = GetGrowthFromTourism();
			iTotalMod += iGrowthTourism;
			if (iGrowthTourism != 0)
			{
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_TOURISM", iGrowthTourism);
			}
		}

		if (IsPuppet())
		{
			int iTempMod = GET_PLAYER(getOwner()).GetPuppetYieldPenaltyMod() + GET_PLAYER(getOwner()).GetPlayerTraits()->GetPuppetPenaltyReduction() + /*0*/ GD_INT_GET(PUPPET_GROWTH_MODIFIER);
			if (iTempMod > 0)
				iTempMod = 0;
			iTotalMod += iTempMod;
			if (iTempMod != 0)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_PUPPET", iTempMod);
		}
		// Religion growth mod
		int iReligionGrowthMod = 0;
		ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
		if (eMajority != NO_RELIGION)
		{
			const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
			if (pReligion)
			{
				bool bAtPeace = GET_TEAM(getTeam()).getAtWarCount(false) == 0;
				iReligionGrowthMod = pReligion->m_Beliefs.GetCityGrowthModifier(bAtPeace, getOwner(), GET_PLAYER(getOwner()).getCity(GetID()));
				BeliefTypes eSecondaryPantheon = GetCityReligions()->GetSecondaryReligionPantheonBelief();

				if (GET_PLAYER(getOwner()).GetPlayerTraits()->IsPopulationBoostReligion() && eMajority == GET_PLAYER(getOwner()).GetReligions()->GetStateReligion(true))
				{
					int iFollowers = GetCityReligions()->GetNumFollowers(eMajority);
					iReligionGrowthMod += (iFollowers * /*0*/ GD_INT_GET(BALANCE_FOLLOWER_GROWTH_BONUS));
				}

				if (eSecondaryPantheon != NO_BELIEF)
				{
					iReligionGrowthMod += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetCityGrowthModifier();
				}
			}
		}

		// Mod for civs keeping their pantheon belief forever
		if (MOD_RELIGION_PERMANENT_PANTHEON)
		{
			if (GC.getGame().GetGameReligions()->HasCreatedPantheon(getOwner()))
			{
				const CvReligion* pPantheon = GC.getGame().GetGameReligions()->GetReligion(RELIGION_PANTHEON, getOwner());
				BeliefTypes ePantheonBelief = GC.getGame().GetGameReligions()->GetBeliefInPantheon(getOwner());
				if (pPantheon != NULL && ePantheonBelief != NO_BELIEF && ePantheonBelief != GetCityReligions()->GetSecondaryReligionPantheonBelief())
				{
					const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
					if (pReligion == NULL || (pReligion != NULL && !pReligion->m_Beliefs.IsPantheonBeliefInReligion(ePantheonBelief, pReligion->m_eReligion, getOwner()))) // check that the our religion does not have our belief, to prevent double counting
					{
						iReligionGrowthMod += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetCityGrowthModifier();
					}
				}
			}
		}

		iTotalMod += iReligionGrowthMod;
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_RELIGION", iReligionGrowthMod);

		if (MOD_BALANCE_VP)
		{
			int iHappiness = getHappinessDelta();

			if (iHappiness > 0)
				iHappiness *= /*2*/ GD_INT_GET(LOCAL_HAPPINESS_FOOD_MODIFIER);
			else
				iHappiness *= /*10*/ GD_INT_GET(LOCAL_UNHAPPINESS_FOOD_MODIFIER);

			if (GET_PLAYER(getOwner()).IsEmpireUnhappy())
			{
				if (iHappiness > 0)
					iHappiness = 0;

				iHappiness += GET_PLAYER(getOwner()).GetUnhappinessGrowthPenalty();
			}

			iHappiness = range(iHappiness, -100, 100);

			iTotalMod += iHappiness;

			if (iHappiness > 0)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_HAPPY", iHappiness);
			else if (iHappiness < 0)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_UNHAPPY", iHappiness);
		}
		else
		{
			// Cities stop growing when empire is very unhappy
			if (GET_PLAYER(getOwner()).IsEmpireVeryUnhappy())
			{
				int iMod = /*-100*/ GD_INT_GET(VERY_UNHAPPY_GROWTH_PENALTY);
				iTotalMod += iMod;
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_UNHAPPY", iMod);
			}
			// Cities grow slower if the player is over his Happiness Limit
			else if (GET_PLAYER(getOwner()).IsEmpireUnhappy())
			{
				int iMod = /*-75*/ GD_INT_GET(UNHAPPY_GROWTH_PENALTY);
				iTotalMod += iMod;
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_UNHAPPY", iMod);
			}
		}

		// WLTKD Growth Bonus
		if (GetWeLoveTheKingDayCounter() > 0)
		{
			int iMod = /*25*/ GD_INT_GET(WLTKD_GROWTH_MULTIPLIER) + GET_PLAYER(getOwner()).GetPlayerTraits()->GetGrowthBoon();
			iTotalMod += iMod;
			if (GET_PLAYER(getOwner()).GetPlayerTraits()->IsExpansionWLTKD())
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_WLTKD_UA", iMod);
			else
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_WLTKD", iMod);
		}

		//Resolution League Bonus	
		if (MOD_BALANCE_VP && GetBaseYieldRateFromLeague(YIELD_FOOD) > 0)
		{
			int iMod = GetBaseYieldRateFromLeague(YIELD_FOOD);
			iTotalMod += iMod;
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_LEAGUE", iMod);
		}

		if (iTotalMod <= 0)
			return 0;

		iDifference *= iTotalMod;
		iDifference /= 100;
	}

	return iDifference;
}

int CvCity::getGrowthMods() const
{
	int iTotalMod = 0;

	// Capital Mod for player. Used for Policies and such
	if (isCapital())
	{
		int iCapitalGrowthMod = GET_PLAYER(getOwner()).GetCapitalGrowthMod();
		if (iCapitalGrowthMod != 0)
		{
			iTotalMod += iCapitalGrowthMod;
		}
	}

	// City Mod for player. Used for Policies and such
	int iCityGrowthMod = GET_PLAYER(getOwner()).GetCityGrowthMod();
	if (iCityGrowthMod != 0)
	{
		iTotalMod += iCityGrowthMod;
	}

	int iCorpMod = GetTradeRouteCityMod(YIELD_FOOD);
	if (iCorpMod > 0)
	{
		iTotalMod += iCorpMod;
	}

	if (GET_PLAYER(getOwner()).isGoldenAge() && (GetGoldenAgeYieldMod(YIELD_FOOD) != 0))
	{
		int iBuildingMod = GetGoldenAgeYieldMod(YIELD_FOOD);
		iTotalMod += iBuildingMod;
	}
	if (GET_PLAYER(getOwner()).isGoldenAge() && GET_PLAYER(getOwner()).getGoldenAgeYieldMod(YIELD_FOOD) != 0)
	{
		int iPolicyMod = GET_PLAYER(getOwner()).getGoldenAgeYieldMod(YIELD_FOOD);
		iTotalMod += iPolicyMod;
	}
	if (GET_PLAYER(getOwner()).GetPlayerTraits()->GetGoldenAgeYieldModifier(YIELD_FOOD) != 0)
	{
		int iTraitMod = GET_PLAYER(getOwner()).GetPlayerTraits()->GetGoldenAgeYieldModifier(YIELD_FOOD);
		iTotalMod += iTraitMod;
	}

	int iSupply = GET_PLAYER(getOwner()).GetNumUnitsOutOfSupply();
	if (MOD_BALANCE_VP && iSupply > 0)
	{
		int iSupplyMod = GET_PLAYER(getOwner()).GetUnitGrowthMaintenanceMod();
		iTotalMod += iSupplyMod;
	}

	if (MOD_BALANCE_CORE)
	{
		int iGrowthTourism = GetGrowthFromTourism();
		iTotalMod += iGrowthTourism;
	}

	if (IsPuppet())
	{
		int iTempMod = GET_PLAYER(getOwner()).GetPuppetYieldPenaltyMod() + GET_PLAYER(getOwner()).GetPlayerTraits()->GetPuppetPenaltyReduction() + /*0*/ GD_INT_GET(PUPPET_GROWTH_MODIFIER);
		if (iTempMod > 0)
			iTempMod = 0;
		iTotalMod += iTempMod;

	}
	// Religion growth mod
	int iReligionGrowthMod = 0;
	ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
	BeliefTypes eSecondaryPantheon = NO_BELIEF;
	if (eMajority != NO_RELIGION)
	{
		const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
		if (pReligion)
		{
			bool bAtPeace = GET_TEAM(getTeam()).getAtWarCount(false) == 0;
			iReligionGrowthMod = pReligion->m_Beliefs.GetCityGrowthModifier(bAtPeace, getOwner(), GET_PLAYER(getOwner()).getCity(GetID()));
			eSecondaryPantheon = GetCityReligions()->GetSecondaryReligionPantheonBelief();

			if (GET_PLAYER(getOwner()).GetPlayerTraits()->IsPopulationBoostReligion() && eMajority == GET_PLAYER(getOwner()).GetReligions()->GetStateReligion(true))
			{
				int iFollowers = GetCityReligions()->GetNumFollowers(eMajority);
				iReligionGrowthMod += (iFollowers * /*0*/ GD_INT_GET(BALANCE_FOLLOWER_GROWTH_BONUS));
			}

			if (eSecondaryPantheon != NO_BELIEF)
			{
				iReligionGrowthMod += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetCityGrowthModifier();
			}
			iTotalMod += iReligionGrowthMod;
		}
	}

	// Mod for civs keeping their pantheon belief forever
	if (MOD_RELIGION_PERMANENT_PANTHEON)
	{
		if (GC.getGame().GetGameReligions()->HasCreatedPantheon(getOwner()))
		{
			const CvReligion* pPantheon = GC.getGame().GetGameReligions()->GetReligion(RELIGION_PANTHEON, getOwner());
			BeliefTypes ePantheonBelief = GC.getGame().GetGameReligions()->GetBeliefInPantheon(getOwner());
			if (pPantheon != NULL && ePantheonBelief != NO_BELIEF && ePantheonBelief != eSecondaryPantheon)
			{
				const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
				if (pReligion == NULL || (pReligion != NULL && !pReligion->m_Beliefs.IsPantheonBeliefInReligion(ePantheonBelief, eMajority, getOwner()))) // check that the our religion does not have our belief, to prevent double counting
				{
					iTotalMod += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetCityGrowthModifier();
				}
			}
		}
	}

	if (MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	{
		// Do we get increased yields from a resource monopoly?
		int iTempMod = GET_PLAYER(getOwner()).getCityYieldModFromMonopoly(YIELD_FOOD);
		if (iTempMod != 0)
		{
			iTempMod += GET_PLAYER(getOwner()).GetMonopolyModPercent();
			// this one is applied to the base yield, so showing a tooltip here is very confusing!
			//GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_FOODMOD_MONOPOLY_RESOURCE", iTempMod);
		}
	}

	if (MOD_BALANCE_VP)
	{
		int iHappiness = getHappinessDelta();

		if (iHappiness > 0)
			iHappiness *= /*2*/ GD_INT_GET(LOCAL_HAPPINESS_FOOD_MODIFIER);
		else
			iHappiness *= /*10*/ GD_INT_GET(LOCAL_UNHAPPINESS_FOOD_MODIFIER);

		if (GET_PLAYER(getOwner()).IsEmpireUnhappy())
		{
			if (iHappiness > 0)
				iHappiness = 0;

			iHappiness += GET_PLAYER(getOwner()).GetUnhappinessGrowthPenalty();
		}

		iTotalMod += std::max(iHappiness, -100);
	}
	else
	{
		// Cities stop growing when empire is very unhappy
		if (GET_PLAYER(getOwner()).IsEmpireVeryUnhappy())
		{
			iTotalMod += std::max(/*-100*/ GD_INT_GET(VERY_UNHAPPY_GROWTH_PENALTY), -100);
		}
		// Cities grow much slower if the player is over his Happiness Limit
		else if (GET_PLAYER(getOwner()).IsEmpireUnhappy())
		{
			iTotalMod += std::max(/*-75*/ GD_INT_GET(UNHAPPY_GROWTH_PENALTY), -100);
		}
	}

	// WLTKD Growth Bonus
	if (GetWeLoveTheKingDayCounter() > 0)
	{
		int iMod = /*25*/ GD_INT_GET(WLTKD_GROWTH_MULTIPLIER);
		iTotalMod += iMod;
	}

	//Resolution League Bonus	
	if (MOD_BALANCE_VP && GetBaseYieldRateFromLeague(YIELD_FOOD) > 0)
	{
		int iMod = GetBaseYieldRateFromLeague(YIELD_FOOD);
		iTotalMod += iMod;
	}

	if (iTotalMod <= -100)
		return 0;

	return iTotalMod;
}

//	--------------------------------------------------------------------------------
int CvCity::growthThreshold() const
{
	VALIDATE_OBJECT
	return GET_PLAYER(getOwner()).getGrowthThreshold(getPopulation());
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvCity::GetNumFreeSpecialists()
{
	int iFreeSpecialists = 0;
	if (isCapital())
	{
		iFreeSpecialists += GET_PLAYER(getOwner()).GetNoUnhappfromXSpecialistsCapital();
	}
	//...elsewhere?	
	iFreeSpecialists += GET_PLAYER(getOwner()).GetNoUnhappfromXSpecialists() + GetNoUnhappfromXSpecialists();
	return iFreeSpecialists;
}
//	--------------------------------------------------------------------------------
int CvCity::GetUnhappinessFromCitySpecialists()
{
	float iUnhappiness = 0;
	float iUnhappinessFromThisCity;
	float iUnhappinessPerPop = /*1*/ (/*1*/ GD_INT_GET(UNHAPPINESS_PER_POPULATION) + GD_FLOAT_GET(UNHAPPINESS_PER_POPULATION_FLOAT)) * 100;
	int iPopulation = 0;

	bool bCityValid = false;

	bCityValid = false;

	// Assume city doesn't exist, and does NOT count
	if (IsIgnoreCityForHappiness())
		bCityValid = false;
	// Occupied Cities don't get counted here (see the next function)
	else if (!IsOccupied() || IsNoOccupiedUnhappiness())
		bCityValid = true;

	if (bCityValid)
	{
		iPopulation = GetCityCitizens()->GetTotalSpecialistCount();

		// No Unhappiness from Specialist Pop? (Policies, etc.)
		if (GET_PLAYER(getOwner()).isHalfSpecialistUnhappiness())
		{
			iPopulation++; // Round up
			iPopulation /= 2;
		}
#if defined(MOD_BALANCE_CORE_HAPPINESS_MODIFIERS)
		//Less unhappiness from specialists....
		if (MOD_BALANCE_CORE_HAPPINESS_MODIFIERS)
		{
			iUnhappinessPerPop = (float)/*100*/ GD_INT_GET(UNHAPPINESS_PER_SPECIALIST);
			int iNoHappinessSpecialists = GetNumFreeSpecialists();
			//Can't give more free happiness than specialists.
			if (iNoHappinessSpecialists > iPopulation)
			{
				iNoHappinessSpecialists = iPopulation;
			}
			if (iNoHappinessSpecialists > 0)
			{
				iPopulation -= iNoHappinessSpecialists;
			}
		}
#endif

		iUnhappinessFromThisCity = iPopulation * iUnhappinessPerPop;

#if defined(MOD_BALANCE_CORE_HAPPINESS)
		if (MOD_BALANCE_CORE_HAPPINESS)
		{
			iUnhappiness += iUnhappinessFromThisCity;
		}
		if (!MOD_BALANCE_CORE_HAPPINESS)
		{
			//Took these away as they were making specialists do weird things.
#endif
			if (isCapital() && GET_PLAYER(getOwner()).GetCapitalUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + GET_PLAYER(getOwner()).GetCapitalUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#if defined(MOD_BALANCE_CORE)
			if (GetLocalUnhappinessMod() != 0)
			{
				iUnhappinessFromThisCity *= (100 + GetLocalUnhappinessMod());
				iUnhappinessFromThisCity /= 100;
			}
#endif

			iUnhappiness += iUnhappinessFromThisCity;
#if defined(MOD_BALANCE_CORE_HAPPINESS)
		}
#endif
	}
#if defined(MOD_BALANCE_CORE_HAPPINESS)
	if (!MOD_BALANCE_CORE_HAPPINESS)
	{
#endif
		iUnhappiness *= (100 + GET_PLAYER(getOwner()).GetUnhappinessMod());
		iUnhappiness /= 100;

		iUnhappiness *= 100 + GET_PLAYER(getOwner()).GetPlayerTraits()->GetPopulationUnhappinessModifier();
		iUnhappiness /= 100;

		// Handicap mod
		iUnhappiness *= GET_PLAYER(getOwner()).isHuman() ? 100 + GET_PLAYER(getOwner()).getHandicapInfo().getPopulationUnhappinessMod() : 100 + GET_PLAYER(getOwner()).getHandicapInfo().getPopulationUnhappinessMod() + GC.getGame().getHandicapInfo().getAIPopulationUnhappinessMod();
		iUnhappiness /= 100;

#if defined(MOD_BALANCE_CORE_HAPPINESS)
	}
#endif
	return (int)iUnhappiness;
}
#endif

//	--------------------------------------------------------------------------------
int CvCity::productionLeft() const
{
	VALIDATE_OBJECT
	return (getProductionNeeded() - getProduction());
}

//	--------------------------------------------------------------------------------
int CvCity::getHurryCostModifier(HurryTypes eHurry, bool bIgnoreNew) const
{
	VALIDATE_OBJECT
	int iModifier = 100;
	const OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		switch (pOrderNode->eOrderType)
		{
		case ORDER_TRAIN:
			iModifier = getHurryCostModifier(eHurry, (UnitTypes)pOrderNode->iData1, bIgnoreNew);
			break;

		case ORDER_CONSTRUCT:
			iModifier = getHurryCostModifier(eHurry, (BuildingTypes)pOrderNode->iData1, bIgnoreNew);
			break;

		case ORDER_CREATE:
		case ORDER_PREPARE:
		case ORDER_MAINTAIN:
			break;

		default:
			CvAssertMsg(false, "pOrderNode->eOrderType did not match a valid option");
			break;
		}
	}

	return iModifier;
}

//	--------------------------------------------------------------------------------
int CvCity::getHurryCostModifier(HurryTypes eHurry, UnitTypes eUnit, bool bIgnoreNew) const
{
	VALIDATE_OBJECT
	CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
	if (pkUnitInfo)
	{
		return getHurryCostModifier(eHurry, pkUnitInfo->GetHurryCostModifier(), getUnitProduction(eUnit), bIgnoreNew);
	}

	return 0;
}

//	--------------------------------------------------------------------------------
int CvCity::getHurryCostModifier(HurryTypes eHurry, BuildingTypes eBuilding, bool bIgnoreNew) const
{
	VALIDATE_OBJECT
	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if (pkBuildingInfo)
	{
		return getHurryCostModifier(eHurry, pkBuildingInfo->GetHurryCostModifier(), m_pCityBuildings->GetBuildingProduction(eBuilding), bIgnoreNew);
	}

	return 0;
}

//	--------------------------------------------------------------------------------
int CvCity::getHurryCostModifier(HurryTypes eHurry, int iBaseModifier, int iProduction, bool bIgnoreNew) const
{
	VALIDATE_OBJECT
	int iModifier = 100 * std::max(0, iBaseModifier + 100);
	iModifier /= 100;

	if (iProduction == 0 && !bIgnoreNew)
	{
		iModifier *= std::max(0, (/*50*/ GD_INT_GET(NEW_HURRY_MODIFIER) + 100));
		iModifier /= 100;
	}

	// Some places just don't care what kind of Hurry it is (leftover from Civ 4)
	if (eHurry != NO_HURRY)
	{
		if (GET_PLAYER(getOwner()).getHurryModifier(eHurry) != 0)
		{
			iModifier *= (100 + GET_PLAYER(getOwner()).getHurryModifier(eHurry));
			iModifier /= 100;
		}
		if (getHurryModifier(eHurry) != 0)
		{
			iModifier *= (100 + getHurryModifier(eHurry));
			iModifier /= 100;
		}
	}

	return iModifier;
}


//	--------------------------------------------------------------------------------
int CvCity::hurryCost(HurryTypes eHurry, bool bExtra) const
{
	VALIDATE_OBJECT
	return (getHurryCost(bExtra, productionLeft(), getHurryCostModifier(eHurry), getProductionModifier()));
}

//	--------------------------------------------------------------------------------
int CvCity::getHurryCost(HurryTypes eHurry, bool bExtra, UnitTypes eUnit, bool bIgnoreNew) const
{
	VALIDATE_OBJECT
	int iProductionLeft = getProductionNeeded(eUnit) - getUnitProduction(eUnit);

	return getHurryCost(bExtra, iProductionLeft, getHurryCostModifier(eHurry, eUnit, bIgnoreNew), getProductionModifier(eUnit));
}

//	--------------------------------------------------------------------------------
int CvCity::getHurryCost(HurryTypes eHurry, bool bExtra, BuildingTypes eBuilding, bool bIgnoreNew) const
{
	VALIDATE_OBJECT
	int iProductionLeft = getProductionNeeded(eBuilding) - m_pCityBuildings->GetBuildingProduction(eBuilding);

	return getHurryCost(bExtra, iProductionLeft, getHurryCostModifier(eHurry, eBuilding, bIgnoreNew), getProductionModifier(eBuilding));
}

//	--------------------------------------------------------------------------------
int CvCity::getHurryCost(bool bExtra, int iProductionLeft, int iHurryModifier, int iModifier) const
{
	VALIDATE_OBJECT
	int iProduction = (iProductionLeft * iHurryModifier + 99) / 100; // round up

	if (bExtra)
	{
		int iExtraProduction = getExtraProductionDifference(iProduction, iModifier);
		if (iExtraProduction > 0)
		{
			int iAdjustedProd = iProduction * iProduction;

			// round up
			iProduction = (iAdjustedProd + (iExtraProduction - 1)) / iExtraProduction;
		}
	}

	return std::max(0, iProduction);
}

//	--------------------------------------------------------------------------------
int CvCity::hurryGold(HurryTypes eHurry) const
{
	VALIDATE_OBJECT
	int iFullCost = getProductionNeeded();

	return getHurryGold(eHurry, hurryCost(eHurry, false), iFullCost);
}

//	--------------------------------------------------------------------------------
/// Amount of Gold required to hurry Production in a City.  Full cost is the original Production cost of whatever we're rushing - the more expensive the ORIGINAL cost, the more it also costs to Gold rush
int CvCity::getHurryGold(HurryTypes /*eHurry*/, int /*iHurryCost*/, int /*iFullCost*/) const
{
	VALIDATE_OBJECT
	// This should not be used any more. Check GetPurchaseCostFromProduction()
	return 0;
}

//	--------------------------------------------------------------------------------
int CvCity::hurryPopulation(HurryTypes eHurry) const
{
	VALIDATE_OBJECT
	return (getHurryPopulation(eHurry, hurryCost(eHurry, true)));
}

//	--------------------------------------------------------------------------------
int CvCity::getHurryPopulation(HurryTypes eHurry, int iHurryCost) const
{
	VALIDATE_OBJECT
	CvHurryInfo* pkHurryInfo = GC.getHurryInfo(eHurry);
	if (pkHurryInfo == NULL)
	{
		return 0;
	}

	if (pkHurryInfo->getProductionPerPopulation() == 0)
	{
		return 0;
	}

	int iPopulation = (iHurryCost - 1) / GC.getGame().getProductionPerPopulation(eHurry);

	return std::max(1, (iPopulation + 1));
}

//	--------------------------------------------------------------------------------
int CvCity::hurryProduction(HurryTypes eHurry) const
{
	VALIDATE_OBJECT
	int iProduction = 0;

	CvHurryInfo* pkHurryInfo = GC.getHurryInfo(eHurry);
	if (pkHurryInfo)
	{
		if (pkHurryInfo->getProductionPerPopulation() > 0)
		{
			iProduction = (100 * getExtraProductionDifference(hurryPopulation(eHurry) * GC.getGame().getProductionPerPopulation(eHurry))) / std::max(1, getHurryCostModifier(eHurry));
			CvAssert(iProduction >= productionLeft());
		}
		else
		{
			iProduction = productionLeft();
		}
	}

	return iProduction;
}

//	--------------------------------------------------------------------------------
int CvCity::maxHurryPopulation() const
{
	VALIDATE_OBJECT
	return (getPopulation() / 2);
}

//	--------------------------------------------------------------------------------
bool CvCity::hasActiveWorldWonder() const
{
	VALIDATE_OBJECT
	CvTeam& kTeam = GET_TEAM(getTeam());

	for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);

		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
		if (pkBuildingInfo)
		{
			if (isWorldWonderClass(pkBuildingInfo->GetBuildingClassInfo()))
			{
				if (m_pCityBuildings->GetNumRealBuilding(eBuilding) > 0 && !(kTeam.isObsoleteBuilding(eBuilding)))
				{
					return true;
				}
			}
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
IDInfo CvCity::GetIDInfo() const
{
	VALIDATE_OBJECT
	return IDInfo(getOwner(), GetID());
}


//	--------------------------------------------------------------------------------
void CvCity::SetID(int iID)
{
	VALIDATE_OBJECT
	m_iID = iID;
}

//	--------------------------------------------------------------------------------
CvPlot* CvCity::plot() const
{
	if ((m_iX != INVALID_PLOT_COORD) && (m_iY != INVALID_PLOT_COORD))
		return GC.getMap().plotUnchecked(m_iX, m_iY);
	return NULL;
}

//	--------------------------------------------------------------------------------
bool CvCity::at(int iX, int iY) const
{
	VALIDATE_OBJECT
	return ((getX() == iX) && (getY() == iY));
}


//	--------------------------------------------------------------------------------
bool CvCity::at(CvPlot* pPlot) const
{
	VALIDATE_OBJECT
	return (plot() == pPlot);
}

//	--------------------------------------------------------------------------------
bool CvCity::HasAccessToArea(int iAreaID) const
{
	CvPlot* pPlot = plot();
	if (pPlot)
	{
		if (pPlot->getArea() == iAreaID)
			return true;
		else
		{
			std::vector<int> allAreas = pPlot->getAllAdjacentAreas();
			return std::find(allAreas.begin(), allAreas.end(), iAreaID) != allAreas.end();
		}
	}

	return false;
}

bool CvCity::HasSharedAreaWith(const CvCity * pOther, bool bAllowLand, bool bAllowWater) const
{
	if (!pOther)
		return false;

	//shortcut ...
	if (plot()->getArea() == pOther->plot()->getArea())
		return true;

	return plot()->hasSharedAdjacentArea(pOther->plot(),bAllowLand,bAllowWater);
}

//	--------------------------------------------------------------------------------
bool CvCity::HasAccessToLandmass(int iLandmassID) const
{
	CvPlot* pPlot = plot();
	if (pPlot)
	{
		if (pPlot->getLandmass() == iLandmassID)
			return true;
		else
		{
			std::vector<int> allLandmasses = pPlot->getAllAdjacentLandmasses();
			return std::find(allLandmasses.begin(), allLandmasses.end(), iLandmassID) != allLandmasses.end();
		}
	}

	return false;
}

bool CvCity::HasSharedLandmassWith(const CvCity * pOther, bool bAllowLand, bool bAllowWater) const
{
	if (!pOther)
		return false;

	//shortcut ...
	if (plot()->getLandmass() == pOther->plot()->getLandmass())
		return true;

	return plot()->hasSharedAdjacentLandmass(pOther->plot(),bAllowLand,bAllowWater);
}

//	--------------------------------------------------------------------------------
// if called with an invalid unit as argument, the current garrison is removed but no new garrison created!
void CvCity::SetGarrison(CvUnit* pUnit)
{
	bool bPreviousGarrison = (m_hGarrison != -1);
	CvUnit* pOldGarrison = bPreviousGarrison ? GET_PLAYER(getOwner()).getUnit(m_hGarrison) : NULL;
	if (pOldGarrison)
	{
		if (pOldGarrison == pUnit)
			//nothing to do
			return;
		else
			//will be replaced
			pOldGarrison->SetGarrisonedCity(-1);
	}

	if (pUnit && pUnit->CanGarrison() && pUnit->getOwner() == getOwner())
	{
		m_hGarrison = pUnit->GetID();
		m_iLastTurnGarrisonAssigned = GC.getGame().getGameTurn();

		pUnit->SetGarrisonedCity(GetID());

		//no previous garrison. we might earn culture / happiness from this
		if (!bPreviousGarrison)
		{
			ChangeJONSCulturePerTurnFromPolicies(GET_PLAYER(getOwner()).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_CULTURE_FROM_GARRISON));
			UpdateCityYields(YIELD_CULTURE);

			if (pUnit != NULL && pUnit->GetReligiousPressureModifier() != 0)
			{
				ReligionTypes eReligion = GET_PLAYER(getOwner()).GetReligions()->GetOwnedReligion();
				if (eReligion != NO_RELIGION)
				{
					if (m_pCityReligions->IsReligionInCity())
					{
						ReligionTypes eMajority = m_pCityReligions->GetReligiousMajority();
						ReligionTypes eSecondary = m_pCityReligions->GetReligionByAccumulatedPressure(1);
						if (eMajority != NO_RELIGION && eMajority == eReligion)
						{
							ChangeReligiousPressureModifier(eReligion, pUnit->GetReligiousPressureModifier());
						}
						else if (eSecondary != NO_RELIGION && eSecondary == eReligion)
						{
							ChangeReligiousPressureModifier(eReligion, pUnit->GetReligiousPressureModifier());
						}
					}
				}
			}
		}
	}
	else
	{
		m_hGarrison = -1;

		//had a previous garrison. bonuses be gone
		if (bPreviousGarrison)
		{
			ChangeJONSCulturePerTurnFromPolicies(-(GET_PLAYER(getOwner()).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_CULTURE_FROM_GARRISON)));
			UpdateCityYields(YIELD_CULTURE);

			if (pOldGarrison != NULL && pOldGarrison->GetReligiousPressureModifier() != 0)
			{
				ReligionTypes eReligion = GET_PLAYER(getOwner()).GetReligions()->GetOwnedReligion();
				if (eReligion != NO_RELIGION)
				{
					if (m_pCityReligions->IsReligionInCity())
					{
						ReligionTypes eMajority = m_pCityReligions->GetReligiousMajority();
						ReligionTypes eSecondary = m_pCityReligions->GetReligionByAccumulatedPressure(1);
						if (eMajority != NO_RELIGION && eMajority == eReligion)
						{
							ChangeReligiousPressureModifier(eReligion, -pOldGarrison->GetReligiousPressureModifier());
						}
						else if (eSecondary != NO_RELIGION && eSecondary == eReligion)
						{
							ChangeReligiousPressureModifier(eReligion, -pOldGarrison->GetReligiousPressureModifier());
						}
					}
				}
			}
		}
	}

	// Update City Strength
	updateStrengthValue();

	GET_PLAYER(getOwner()).CalculateNetHappiness();
	updateNetHappiness();
}

bool CvCity::HasGarrison() const
{
	if (m_hGarrison > -1 && GetGarrisonedUnit() == NULL)
	{
		CUSTOMLOG("Invalid garrison %d is set in %s!\n", m_hGarrison, getName().c_str());
		(const_cast<CvCity*>(this))->m_hGarrison = -1;
		return false;
	}

	return m_hGarrison > -1;
}

CvUnit* CvCity::GetGarrisonedUnit() const
{
	if (m_hGarrisonOverride != -1)
	{
		CvUnit* pGarrison = GET_PLAYER(getOwner()).getUnit(m_hGarrisonOverride);
		if (pGarrison)
			return pGarrison;
		else
			CUSTOMLOG("warning: invalid garrison override!\n");
	}

	if (m_hGarrison > -1)
		return GET_PLAYER(getOwner()).getUnit(m_hGarrison);

	return NULL;
}

void CvCity::OverrideGarrison(const CvUnit* pUnit) const
{
	if (pUnit && pUnit->getDomainType() == DOMAIN_LAND)
		m_hGarrisonOverride = pUnit->GetID();
	else
		m_hGarrisonOverride = -1;
}

//	--------------------------------------------------------------------------------
CvPlot* CvCity::getRallyPlot() const
{
	VALIDATE_OBJECT
	if ((m_iRallyX != INVALID_PLOT_COORD) && (m_iRallyY != INVALID_PLOT_COORD))
	{
		return GC.getMap().plotUnchecked(m_iRallyX, m_iRallyY);
	}
	else
		return NULL;
}


//	--------------------------------------------------------------------------------
void CvCity::setRallyPlot(CvPlot* pPlot)
{
	VALIDATE_OBJECT
	if (getRallyPlot() != pPlot)
	{
		if (pPlot != NULL)
		{
			m_iRallyX = pPlot->getX();
			m_iRallyY = pPlot->getY();
		}
		else
		{
			m_iRallyX = INVALID_PLOT_COORD;
			m_iRallyY = INVALID_PLOT_COORD;
		}

		if (isCitySelected())
		{
			DLLUI->setDirty(ColoredPlots_DIRTY_BIT, true);
		}
	}
}


//	--------------------------------------------------------------------------------
int CvCity::getGameTurnFounded() const
{
	VALIDATE_OBJECT
	return m_iGameTurnFounded;
}


//	--------------------------------------------------------------------------------
void CvCity::setGameTurnFounded(int iNewValue)
{
	VALIDATE_OBJECT
	if (m_iGameTurnFounded != iNewValue)
	{
		m_iGameTurnFounded = iNewValue;
		CvAssert(getGameTurnFounded() >= 0);
	}
}


//	--------------------------------------------------------------------------------
int CvCity::getGameTurnAcquired() const
{
	VALIDATE_OBJECT
	return m_iGameTurnAcquired;
}


//	--------------------------------------------------------------------------------
void CvCity::setGameTurnAcquired(int iNewValue)
{
	VALIDATE_OBJECT
	m_iGameTurnAcquired = iNewValue;
	CvAssert(getGameTurnAcquired() >= 0);
}


//	--------------------------------------------------------------------------------
int CvCity::getGameTurnLastExpanded() const
{
	VALIDATE_OBJECT
	return m_iGameTurnLastExpanded;
}


//	--------------------------------------------------------------------------------
void CvCity::setGameTurnLastExpanded(int iNewValue)
{
	VALIDATE_OBJECT
	if (m_iGameTurnLastExpanded != iNewValue)
	{
		m_iGameTurnLastExpanded = iNewValue;
		CvAssert(m_iGameTurnLastExpanded >= 0);
	}
}

#if defined(MOD_BALANCE_CORE)
int CvCity::GetAdditionalFood() const
{
	VALIDATE_OBJECT
	return m_iAdditionalFood;
}
void CvCity::SetAdditionalFood(int iValue)
{
	VALIDATE_OBJECT
	m_iAdditionalFood = iValue;
}
#endif
//	--------------------------------------------------------------------------------
#if defined(MOD_GLOBAL_CITY_AUTOMATON_WORKERS)
int CvCity::getPopulation(bool bIncludeAutomatons /* = false */) const
#else
int CvCity::getPopulation() const
#endif
{
	VALIDATE_OBJECT
#if defined(MOD_GLOBAL_CITY_AUTOMATON_WORKERS)
	return m_iPopulation + (bIncludeAutomatons ? getAutomatons() : 0);
#else
	return m_iPopulation;
#endif
}

//	---------------------------------------------------------------------------------
//	Be very careful with setting bReassignPop to false.  This assumes that the caller
//  is manually adjusting the worker assignments *and* handling the setting of
//  the CityCitizens unassigned worker value.
void CvCity::setPopulation(int iNewValue, bool bReassignPop /* = true */, bool bNoBonus)
{
	VALIDATE_OBJECT
	//make sure this is valid
	iNewValue = max(0, iNewValue);

	int iOldPopulation = getPopulation();
	int iPopChange = iNewValue - iOldPopulation;

	if (iOldPopulation != iNewValue)
	{
		// If we are reducing population, remove the workers first
		if (bReassignPop)
		{
			if (iPopChange < 0)
			{
				// Need to Remove Citizens
				for (int iNewPopLoop = -iPopChange; iNewPopLoop--;)
				{
					//first try and remove an non-forced plot, if that fails, we need to pick a forced plot
					if (!GetCityCitizens()->DoRemoveWorstCitizen(CvCity::YIELD_UPDATE_GLOBAL, false, NO_SPECIALIST))
						GetCityCitizens()->DoRemoveWorstCitizen(CvCity::YIELD_UPDATE_GLOBAL, true, NO_SPECIALIST);
				}

				// Fixup the unassigned workers
				int iUnassignedWorkers = GetCityCitizens()->GetNumUnassignedCitizens();
				CvAssert(iUnassignedWorkers >= -iPopChange);
				GetCityCitizens()->ChangeNumUnassignedCitizens(std::max(iPopChange, -iUnassignedWorkers));
			}
		}

		m_iPopulation = iNewValue;

		GET_PLAYER(getOwner()).invalidatePopulationRankCache();

		if (getPopulation() > getHighestPopulation())
		{
			setHighestPopulation(getPopulation());
#if defined(MOD_BALANCE_CORE_BELIEFS)
			int iGameTurn = GC.getGame().getGameTurn() - getGameTurnFounded();
			if (!IsResistance() && iGameTurn > 0 && !bNoBonus)
			{
				GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_BIRTH, true, NO_GREATPERSON, NO_BUILDING, iPopChange, true, NO_PLAYER, NULL, false, this);

				ReligionTypes eOwnerReligion = GET_PLAYER(getOwner()).GetReligions()->GetOwnedReligion();
				if (eOwnerReligion != NO_RELIGION && GetCityReligions()->IsHolyCityForReligion(eOwnerReligion))
				{
					GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_BIRTH_HOLY_CITY, false, NO_GREATPERSON, NO_BUILDING, iPopChange, false, NO_PLAYER, NULL, false, this);
				}
			}
#endif
#if defined(MOD_BALANCE_CORE_POLICIES)
			if (MOD_BALANCE_CORE_POLICIES && GET_PLAYER(getOwner()).GetXPopulationConscription() > 0 && !IsRazing())
			{
				int iRemainder = (getPopulation() % GET_PLAYER(getOwner()).GetXPopulationConscription());
				if (iRemainder == 0)
				{
					GET_PLAYER(getOwner()).DoXPopulationConscription(this);
				}
			}
#endif
		}

		plot()->area()->changePopulationPerPlayer(getOwner(), (getPopulation() - iOldPopulation));

#if defined(MOD_BALANCE_CORE)
		//we track population on the coast of water areas as well
		std::vector<int> areas = plot()->getAllAdjacentAreas();
		for (std::vector<int>::iterator it = areas.begin(); it != areas.end(); ++it)
		{
			CvArea* pkArea = GC.getMap().getAreaById(*it);
			if (pkArea->isWater())
				pkArea->changePopulationPerPlayer(getOwner(), (getPopulation() - iOldPopulation));
		}
#endif

		GET_PLAYER(getOwner()).changeTotalPopulation(getPopulation() - iOldPopulation);
		GET_TEAM(getTeam()).changeTotalPopulation(getPopulation() - iOldPopulation);
		GC.getGame().changeTotalPopulation(getPopulation() - iOldPopulation);

		plot()->updateYield();

		UpdateReligion(GetCityReligions()->GetReligiousMajority());

		ChangeBaseYieldRateFromMisc(YIELD_SCIENCE, (iNewValue - iOldPopulation) * /*1 in CP, 0 in VP*/ GD_INT_GET(SCIENCE_PER_POPULATION));

		if (iPopChange > 0)
		{
			// Give new Population something to do in the City
			if (bReassignPop)
			{
				GetCityCitizens()->ChangeNumUnassignedCitizens(iPopChange);

				// Need to Add Citizens
				for (int iNewPopLoop = 0; iNewPopLoop < iPopChange; iNewPopLoop++)
				{
					GetCityCitizens()->DoAddBestCitizenFromUnassigned(CvCity::YIELD_UPDATE_GLOBAL);
				}
			}
		}

		setLayoutDirty(true);
		{
			CvInterfacePtr<ICvCity1> pkDllCity(new CvDllCity(this));
			gDLL->GameplayCityPopulationChanged(pkDllCity.get(), iNewValue);
		}

		plot()->plotAction(PUF_makeInfoBarDirty);

		if ((getOwner() == GC.getGame().getActivePlayer()) && isCitySelected())
		{
			DLLUI->setDirty(SelectionButtons_DIRTY_BIT, true);
			DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
		}

		// Update Unit Maintenance for the player
		GET_PLAYER(getOwner()).UpdateUnitProductionMaintenanceMod();
		GET_PLAYER(getOwner()).CalculateNetHappiness();
		updateNetHappiness();

		//updateGenericBuildings();
		updateStrengthValue();

		DLLUI->setDirty(CityInfo_DIRTY_BIT, true);
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if (pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(getX());
		args->Push(getY());
		args->Push(iOldPopulation);
		args->Push(iNewValue);

		bool bResult = false;
		LuaSupport::CallHook(pkScriptSystem, "SetPopulation", args.get(), bResult);
	}
}

//	---------------------------------------------------------------------------------
//	Be very careful with setting bReassignPop to false.  This assumes that the caller
//  is manually adjusting the worker assignments *and* handling the setting of
//  the CityCitizens unassigned worker value.
void CvCity::changePopulation(int iChange, bool bReassignPop, bool bIgnoreStaticUpdate)
{
	VALIDATE_OBJECT
	setPopulation(getPopulation() + iChange, bReassignPop);

	// When the population changes (for most reasons), fetch the current global yield medians (for Needs Unhappiness) and cache them
	if (iChange != 0 && !bIgnoreStaticUpdate)
		UpdateCachedYieldMedians();

	// Update the religious system
	GetCityReligions()->DoPopulationChange(iChange);
}

void CvCity::setLowestRazingPop(int iValue)
{
	m_iLowestRazingPop = iValue;
}
#if defined(MOD_GLOBAL_CITY_AUTOMATON_WORKERS)
//	--------------------------------------------------------------------------------
int CvCity::getAutomatons() const
{
	VALIDATE_OBJECT
	return m_iAutomatons;
}
//	---------------------------------------------------------------------------------
//	Be very careful with setting bReassignPop to false.  This assumes that the caller
//  is manually adjusting the worker assignments *and* handling the setting of
//  the CityCitizens unassigned worker value.
void CvCity::setAutomatons(int iNewValue, bool bReassignPop /* = true */)
{
	VALIDATE_OBJECT
	int iChange = iNewValue - getAutomatons();
	if (iChange != 0) {
		if (bReassignPop && iChange < 0)
		{
			// If we are reducing automatons, remove the workers first
			for (int iNewPopLoop = -iChange; iNewPopLoop--;)
			{
				GetCityCitizens()->DoRemoveWorstCitizen(CvCity::YIELD_UPDATE_GLOBAL, false, NO_SPECIALIST);
			}
			// Fixup the unassigned workers
			int iUnassignedWorkers = GetCityCitizens()->GetNumUnassignedCitizens();
			CvAssert(iUnassignedWorkers >= -iChange);
			GetCityCitizens()->ChangeNumUnassignedCitizens(std::max(iChange, -iUnassignedWorkers));
		}
		m_iAutomatons = iNewValue;
		CvAssert(getAutomatons() >= 0);
		if (bReassignPop && iChange > 0) {
			// Give new automatons something to do in the City
			GetCityCitizens()->ChangeNumUnassignedCitizens(iChange);
			// Need to Add Citizens
			for (int iNewPopLoop = 0; iNewPopLoop < iChange; iNewPopLoop++)
			{
				GetCityCitizens()->DoAddBestCitizenFromUnassigned(CvCity::YIELD_UPDATE_GLOBAL);
			}
		}
		setLayoutDirty(true);
		plot()->plotAction(PUF_makeInfoBarDirty);
		if ((getOwner() == GC.getGame().getActivePlayer()) && isCitySelected())
		{
			DLLUI->setDirty(SelectionButtons_DIRTY_BIT, true);
			DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
		}
		DLLUI->setDirty(CityInfo_DIRTY_BIT, true);
	}
}
//	---------------------------------------------------------------------------------
void CvCity::changeAutomatons(int iChange, bool bReassignPop)
{
	VALIDATE_OBJECT
	setAutomatons(getAutomatons() + iChange, bReassignPop);
}
#endif

//	--------------------------------------------------------------------------------
long CvCity::getRealPopulation() const
{
	VALIDATE_OBJECT
	return (((long)(pow((double)getPopulation(), 2.8))) * 1000);
}

//	--------------------------------------------------------------------------------
int CvCity::getHighestPopulation() const
{
	VALIDATE_OBJECT
	return m_iHighestPopulation;
}


//	--------------------------------------------------------------------------------
void CvCity::setHighestPopulation(int iNewValue)
{
	VALIDATE_OBJECT
	m_iHighestPopulation = iNewValue;
	CvAssert(getHighestPopulation() >= 0);
}

//	--------------------------------------------------------------------------------
int CvCity::getNumGreatPeople() const
{
	VALIDATE_OBJECT
	return m_iNumGreatPeople;
}


//	--------------------------------------------------------------------------------
void CvCity::changeNumGreatPeople(int iChange)
{
	VALIDATE_OBJECT
	if (iChange != 0)
	{
		m_iNumGreatPeople = (m_iNumGreatPeople + iChange);
		CvAssert(getNumGreatPeople() >= 0);
	}
}


//	--------------------------------------------------------------------------------
int CvCity::getBaseGreatPeopleRate() const
{
	VALIDATE_OBJECT
	return m_iBaseGreatPeopleRate;
}


//	--------------------------------------------------------------------------------
int CvCity::getGreatPeopleRate() const
{
	VALIDATE_OBJECT
	return ((getBaseGreatPeopleRate() * getTotalGreatPeopleRateModifier()) / 100);
}


//	--------------------------------------------------------------------------------
int CvCity::getTotalGreatPeopleRateModifier() const
{
	VALIDATE_OBJECT
	int iModifier = getGreatPeopleRateModifier() + GET_PLAYER(getOwner()).getGreatPeopleRateModifier();

	if (GET_PLAYER(getOwner()).isGoldenAge())
	{
		iModifier += /*100*/ GD_INT_GET(GOLDEN_AGE_GREAT_PEOPLE_MODIFIER);
	}

	return std::max(0, (iModifier + 100));
}


//	--------------------------------------------------------------------------------
void CvCity::changeBaseGreatPeopleRate(int iChange)
{
	VALIDATE_OBJECT
	m_iBaseGreatPeopleRate = (m_iBaseGreatPeopleRate + iChange);
	CvAssert(getBaseGreatPeopleRate() >= 0);
}


//	--------------------------------------------------------------------------------
int CvCity::getGreatPeopleRateModifier() const
{
	VALIDATE_OBJECT
	int iNewValue = 0;
	if (isCapital() && GET_PLAYER(getOwner()).GetPlayerTraits()->IsDiplomaticMarriage())
	{
		int iNumMarried = 0;
		// Loop through all minors and get the total number we've met.
		for (int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)
		{
			PlayerTypes eMinor = (PlayerTypes)iPlayerLoop;

			if (eMinor != getOwner() && GET_PLAYER(eMinor).isAlive() && GET_PLAYER(eMinor).isMinorCiv())
			{
				if (!GET_PLAYER(eMinor).IsAtWarWith(GetPlayer()->GetID()) && GET_PLAYER(eMinor).GetMinorCivAI()->IsMarried(getOwner()))
				{
					iNumMarried++;
				}
			}
		}
		if (iNumMarried > 0)
		{
			iNewValue = (iNumMarried * /*15*/ GD_INT_GET(BALANCE_MARRIAGE_GP_RATE));
		}
	}

	// Corporations: Great people rate modifier by number of franchises
	int iGPRateCorp = GetGPRateModifierPerXFranchises();
	if (iGPRateCorp > 0)
	{
		iNewValue += iGPRateCorp;
	}
	return m_iGreatPeopleRateModifier + iNewValue;
}

//	--------------------------------------------------------------------------------
void CvCity::changeGreatPeopleRateModifier(int iChange)
{
	VALIDATE_OBJECT
	m_iGreatPeopleRateModifier = (m_iGreatPeopleRateModifier + iChange);
}

//	--------------------------------------------------------------------------------
/// Amount of Culture in this City
int CvCity::GetJONSCultureStored() const
{
	VALIDATE_OBJECT
	return m_iJONSCultureStored;
}

//	--------------------------------------------------------------------------------
/// Sets the amount of Culture in this City
void CvCity::SetJONSCultureStored(int iValue)
{
	VALIDATE_OBJECT

	if (GetID() == g_iCityToTrace)
	{
		OutputDebugString(CvString::format("Turn %d, culture %d, delta %d\n", GC.getGame().getGameTurn(), m_iJONSCultureStored, iValue - m_iJONSCultureStored).c_str());
	}

	m_iJONSCultureStored = max(iValue, 0);
}

//	--------------------------------------------------------------------------------
/// Changes the amount of Culture in this City
void CvCity::ChangeJONSCultureStored(int iChange)
{
	VALIDATE_OBJECT

	// Positive modifier to border growth rate?
	int iModifier = GetBorderGrowthRateIncreaseTotal();
	if (iChange > 0 && iModifier > 0)
	{
		iChange *= 100 + iModifier;
		iChange /= 100;
	}

	SetJONSCultureStored(GetJONSCultureStored() + iChange);
}


//	--------------------------------------------------------------------------------
/// Culture level of this City
int CvCity::GetJONSCultureLevel() const
{
	VALIDATE_OBJECT
	return m_iJONSCultureLevel;
}

//	--------------------------------------------------------------------------------
/// Sets the Culture level of this City
void CvCity::SetJONSCultureLevel(int iValue)
{
	VALIDATE_OBJECT
	m_iJONSCultureLevel = iValue;
}

//	--------------------------------------------------------------------------------
/// Changes the Culture level of this City
void CvCity::ChangeJONSCultureLevel(int iChange)
{
	VALIDATE_OBJECT
	SetJONSCultureLevel(GetJONSCultureLevel() + iChange);
}

//	--------------------------------------------------------------------------------
/// What happens when you have enough Culture to acquire a new Plot?
void CvCity::DoJONSCultureLevelIncrease()
{
	VALIDATE_OBJECT

	int iOverflow = GetJONSCultureStored() - GetJONSCultureThreshold();
#if defined(MOD_UI_CITY_EXPANSION)
	bool bIsHumanControlled = (GET_PLAYER(getOwner()).isHuman() && !IsPuppet());
	bool bSendEvent = true;
	if (!(MOD_UI_CITY_EXPANSION && bIsHumanControlled)) {
		// We need to defer this for humans picking their own tiles
#endif
		SetJONSCultureStored(iOverflow);
		ChangeJONSCultureLevel(1);
#if defined(MOD_UI_CITY_EXPANSION)
	}
#endif
#if defined(MOD_BALANCE_CORE)
	CvPlot* pPlotToAcquire = GetNextBuyablePlot(false);
#else
	CvPlot* pPlotToAcquire = GetNextBuyablePlot();
#endif

	// maybe the player owns ALL of the plots or there are none avaialable?
	if (pPlotToAcquire)
	{
#if defined(MOD_UI_CITY_EXPANSION)
		// For human players, let them decide which plot to acquire
		if (MOD_UI_CITY_EXPANSION && bIsHumanControlled)
		{
			// Yep CITY_PLOTS_RADIUS is a #define and not taken from the database - well done Firaxis!

			bool bCanAcquirePlot = plotDistance(getX(), getY(), pPlotToAcquire->getX(), pPlotToAcquire->getY()) <= getWorkPlotDistance();
			if (bCanAcquirePlot && GetBuyPlotCost(pPlotToAcquire->getX(), pPlotToAcquire->getY()) < 1) {
				// Within working/buying distance
				bSendEvent = false;

				CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
				if (pNotifications) {
					Localization::String localizedText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_CULTURE_ACQUIRED_NEW_PLOT");
					localizedText << getNameKey();
					Localization::String localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_CULTURE_ACQUIRED_NEW_PLOT");
					localizedSummary << getNameKey();
					pNotifications->Add(NOTIFICATION_CITY_TILE, localizedText.toUTF8(), localizedSummary.toUTF8(), getX(), getY(), GetID());
				}
			}
			else
			{
				// The cheapest plot we can have is outside our working/buying distance, so just acquire it
				DoAcquirePlot(pPlotToAcquire->getX(), pPlotToAcquire->getY());

				ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
				if (pkScriptSystem)
				{
					CvLuaArgsHandle args;
					args->Push(getOwner());
					args->Push(GetID());
					args->Push(pPlotToAcquire->getX());
					args->Push(pPlotToAcquire->getY());
					args->Push(false); // bGold
					args->Push(true); // bFaith/bCulture

					bool bResult = false;
					LuaSupport::CallHook(pkScriptSystem, "CityBoughtPlot", args.get(), bResult);
				}
				// and also the deferred stuff
				SetJONSCultureStored(iOverflow);
				ChangeJONSCultureLevel(1);
			}
		}
		else
		{
			// AI or dis-interested human, just acquire the plot normally
#endif
			if (GC.getLogging() && GC.getAILogging())
			{
				CvPlayerAI& kOwner = GET_PLAYER(getOwner());
				CvString strBaseString;
				CvString strOutBuf;
				CvString playerName = kOwner.getCivilizationShortDescription();
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				strBaseString += playerName + ", ";
				strOutBuf.Format("%s, City Culture Leveled Up. Level: %d Border Expanded, X: %d, Y: %d", getName().GetCString(),
					GetJONSCultureLevel(), pPlotToAcquire->getX(), pPlotToAcquire->getY());
				strBaseString += strOutBuf;
				kOwner.GetCitySpecializationAI()->LogMsg(strBaseString);
			}
			DoAcquirePlot(pPlotToAcquire->getX(), pPlotToAcquire->getY());
#if defined(MOD_UI_CITY_EXPANSION)
		}
#endif

#if defined(MOD_UI_CITY_EXPANSION)
		// If the human is picking their own tile, the event will be sent when the tile is "bought"
		if (bSendEvent)
		{
#endif
#if defined(MOD_EVENTS_CITY)
			if (MOD_EVENTS_CITY)
			{
				GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityBoughtPlot, getOwner(), GetID(), pPlotToAcquire->getX(), pPlotToAcquire->getY(), false, true);
			}
			else
			{
#endif
				ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
				if (pkScriptSystem)
				{
					CvLuaArgsHandle args;
					args->Push(getOwner());
					args->Push(GetID());
					args->Push(pPlotToAcquire->getX());
					args->Push(pPlotToAcquire->getY());
					args->Push(false); // bGold
					args->Push(true); // bFaith/bCulture

					bool bResult = false;
					LuaSupport::CallHook(pkScriptSystem, "CityBoughtPlot", args.get(), bResult);
				}
#if defined(MOD_EVENTS_CITY)
			}
#endif
#if defined(MOD_UI_CITY_EXPANSION)
		}
#endif
#if defined(MOD_BALANCE_CORE)
		GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_BORDERS, true, NO_GREATPERSON, NO_BUILDING, 0, true, NO_PLAYER, NULL, false, this, false, true, false, NO_YIELD, NULL, pPlotToAcquire->getTerrainType());
#endif
#if defined(MOD_BALANCE_CORE)
		if (pPlotToAcquire->getTerrainType() != NO_TERRAIN && GET_PLAYER(getOwner()).GetPlayerTraits()->TerrainClaimBoost(pPlotToAcquire->getTerrainType()))
		{
			for (int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; ++iDirectionLoop)
			{
				CvPlot* pAdjacentPlot = plotDirection(pPlotToAcquire->getX(), pPlotToAcquire->getY(), ((DirectionTypes)iDirectionLoop));
				if (pAdjacentPlot && pAdjacentPlot->getTerrainType() == pPlotToAcquire->getTerrainType())
				{
					if (pAdjacentPlot->getOwner() == NO_PLAYER)
					{
						DoAcquirePlot(pAdjacentPlot->getX(), pAdjacentPlot->getY());
					}
				}
			}
		}
#endif
#if defined(MOD_UI_CITY_EXPANSION)
	}
	else if (MOD_UI_CITY_EXPANSION && bIsHumanControlled)
	{
		// Do the stuff we deferred as we though we'd do it when the human bought a tile but can't as there are no tiles to buy!
		SetJONSCultureStored(iOverflow);
		ChangeJONSCultureLevel(1);
#endif
	}
}

//	--------------------------------------------------------------------------------
/// Amount of Culture needed in this City to acquire a new Plot
int CvCity::GetJONSCultureThreshold() const
{
	VALIDATE_OBJECT
	int iCultureThreshold = /*15 in CP, 20 in VP*/ GD_INT_GET(CULTURE_COST_FIRST_PLOT);

	float fExponent = /*1.1f in CP, 1.35f in VP*/ GD_FLOAT_GET(CULTURE_COST_LATER_PLOT_EXPONENT);

	int iPolicyExponentMod = GET_PLAYER(m_eOwner).GetPlotCultureExponentModifier();
	if (iPolicyExponentMod != 0)
	{
		fExponent = fExponent * (float)((100 + iPolicyExponentMod));
		fExponent /= 100.0f;
	}

	int iAdditionalCost = GetJONSCultureLevel() * /*10 in CP, 15 in VP*/ GD_INT_GET(CULTURE_COST_LATER_PLOT_MULTIPLIER);
	double dAdditionalCost = pow((double)iAdditionalCost, (double)fExponent);

	//watch out for overflow ...
	iCultureThreshold += (dAdditionalCost < INT_MAX / 256 ? int(dAdditionalCost) : INT_MAX / 256);

	// More expensive for Minors to claim territory
	if (GET_PLAYER(getOwner()).isMinorCiv())
	{
		iCultureThreshold *= /*150 in CP, 115 in VP*/ GD_INT_GET(MINOR_CIV_PLOT_CULTURE_COST_MULTIPLIER);
		iCultureThreshold /= 100;
	}

	// Religion modifier
	int iReligionMod = 0;
	ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
	BeliefTypes eSecondaryPantheon = NO_BELIEF;
	if (eMajority != NO_RELIGION)
	{
		const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
		if (pReligion)
		{
			iReligionMod = pReligion->m_Beliefs.GetPlotCultureCostModifier(getOwner(), GET_PLAYER(getOwner()).getCity(GetID()));
			eSecondaryPantheon = GetCityReligions()->GetSecondaryReligionPantheonBelief();
			if (eSecondaryPantheon != NO_BELIEF)
			{
				iReligionMod += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetPlotCultureCostModifier();
			}
		}
	}

#if defined(MOD_RELIGION_PERMANENT_PANTHEON)
	// Mod for civs keeping their pantheon belief forever
	if (MOD_RELIGION_PERMANENT_PANTHEON)
	{
		if (GC.getGame().GetGameReligions()->HasCreatedPantheon(getOwner()))
		{
			const CvReligion* pPantheon = GC.getGame().GetGameReligions()->GetReligion(RELIGION_PANTHEON, getOwner());
			BeliefTypes ePantheonBelief = GC.getGame().GetGameReligions()->GetBeliefInPantheon(getOwner());
			if (pPantheon != NULL && ePantheonBelief != NO_BELIEF && ePantheonBelief != eSecondaryPantheon)
			{
				const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eMajority, getOwner());
				if (pReligion == NULL || (pReligion != NULL && !pReligion->m_Beliefs.IsPantheonBeliefInReligion(ePantheonBelief, eMajority, getOwner()))) // check that the our religion does not have our belief, to prevent double counting
				{
					iReligionMod += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetPlotCultureCostModifier();
				}
			}
		}
	}
#endif

	// -50 = 50% cost
	int iModifier = GET_PLAYER(getOwner()).GetPlotCultureCostModifier() + m_iPlotCultureCostModifier + iReligionMod;
	if (iModifier != 0)
	{
		iModifier = max(iModifier, /*-85*/ GD_INT_GET(CULTURE_PLOT_COST_MOD_MINIMUM));	// value cannot reduced by more than 85%
		iCultureThreshold *= (100 + iModifier);
		iCultureThreshold /= 100;
	}

	// Game Speed Mod
	iCultureThreshold *= GC.getGame().getGameSpeedInfo().getCulturePercent();
	iCultureThreshold /= 100;

	// Make the number not be funky
	int iDivisor = /*5*/ GD_INT_GET(CULTURE_COST_VISIBLE_DIVISOR);
	if (iCultureThreshold > iDivisor * 2)
	{
		iCultureThreshold /= iDivisor;
		iCultureThreshold *= iDivisor;
	}

	return iCultureThreshold;
}


//	--------------------------------------------------------------------------------
int CvCity::getJONSCulturePerTurn(bool bStatic) const
{
	VALIDATE_OBJECT
	// Anarchy, Resistance or Razing? Then no Culture is given!
	if (GET_PLAYER(getOwner()).IsAnarchy() || IsResistance() || IsRazing())
		return 0;

	if (bStatic)
	{
		return (GetStaticYield(YIELD_CULTURE) / 100);
	}

	int iCulture = GetBaseJONSCulturePerTurn();

	// City modifier
	iCulture *= getBaseYieldRateModifier(YIELD_CULTURE, 0, NULL);
	iCulture /= 100;

	// Culture from having trade routes
	iCulture += GET_PLAYER(m_eOwner).GetTrade()->GetTradeValuesAtCityTimes100(this, YIELD_CULTURE) / 100;

	// Process production into culture
	if (getProductionToYieldModifier(YIELD_CULTURE) > 0)
		iCulture += (getBasicYieldRateTimes100(YIELD_PRODUCTION) * getProductionToYieldModifier(YIELD_CULTURE)) / 10000;

	return iCulture;
}

//	--------------------------------------------------------------------------------
int CvCity::GetBaseJONSCulturePerTurn() const
{
	VALIDATE_OBJECT

	int iCulturePerTurn = 0;
	iCulturePerTurn += GetJONSCulturePerTurnFromBuildings();
	iCulturePerTurn += GetJONSCulturePerTurnFromPolicies();
	iCulturePerTurn += GetJONSCulturePerTurnFromSpecialists();

	// GetJONSCulturePerTurnFromSpecialists() uses the Specialists.CulturePerTurn column,
	// GetBaseYieldRateFromSpecialists(YIELD_CULTURE) gets everything else!
	iCulturePerTurn += GetBaseYieldRateFromSpecialists(YIELD_CULTURE);
	iCulturePerTurn += (GetYieldPerPopTimes100(YIELD_CULTURE) * getPopulation()) / 100;
	iCulturePerTurn += (GetYieldPerPopInEmpireTimes100(YIELD_CULTURE) * GET_PLAYER(getOwner()).getTotalPopulation()) / 100;

	if (IsRouteToCapitalConnected())
	{
		int iEra = GET_PLAYER(getOwner()).GetCurrentEra();
		if (iEra <= 0)
			iEra = 1;
		iCulturePerTurn += GET_PLAYER(getOwner()).GetYieldChangeTradeRoute(YIELD_CULTURE);
		iCulturePerTurn += GET_PLAYER(getOwner()).GetPlayerTraits()->GetYieldChangeTradeRoute(YIELD_CULTURE) * iEra;
	}

	iCulturePerTurn += GetBaseYieldRateFromGreatWorks(YIELD_CULTURE);
	iCulturePerTurn += GetBaseYieldRateFromTerrain(YIELD_CULTURE);

	for (int iI = 0; iI < GC.getNumFeatureInfos(); iI++)
	{
		FeatureTypes eFeature = (FeatureTypes)iI;
		if (eFeature != NO_FEATURE)
		{
			iCulturePerTurn += GetYieldPerTurnFromUnimprovedFeatures(eFeature, YIELD_CULTURE);
		}
	}

	iCulturePerTurn += GetJONSCulturePerTurnFromTraits();
	iCulturePerTurn += GetJONSCulturePerTurnFromReligion();
	iCulturePerTurn += GetJONSCulturePerTurnFromLeagues();

	CvPlot* pCityPlot = plot();
	for (int iUnitLoop = 0; iUnitLoop < pCityPlot->getNumUnits(); iUnitLoop++)
	{
		int iTempVal = pCityPlot->getUnitByIndex(iUnitLoop)->GetYieldChange(YIELD_CULTURE);
		if (iTempVal != 0)
		{
			iCulturePerTurn += iTempVal;
		}
	}

	ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
	if (MOD_BALANCE_CORE_POLICIES && eMajority != NO_RELIGION && eMajority > RELIGION_PANTHEON)
	{
		if (GET_PLAYER(getOwner()).GetReligions()->GetStateReligion() == eMajority)
		{
			iCulturePerTurn += GET_PLAYER(getOwner()).getReligionYieldRateModifier(YIELD_CULTURE);
		}
	}

	iCulturePerTurn += GetBaseYieldRateFromCSAlliance(YIELD_CULTURE);
	iCulturePerTurn += GetBaseYieldRateFromCSFriendship(YIELD_CULTURE);
	iCulturePerTurn += GetYieldFromMinors(YIELD_CULTURE);
	iCulturePerTurn += GetYieldPerTurnFromTraits(YIELD_CULTURE);
	iCulturePerTurn += GetYieldChangeFromCorporationFranchises(YIELD_CULTURE);
	iCulturePerTurn += GetEventCityYield(YIELD_CULTURE);
	iCulturePerTurn += GetBaseYieldRateFromMisc(YIELD_CULTURE);

	//Update Yields from yields ... need to sidestep constness
	CvCity* pThisCity = const_cast<CvCity*>(this);
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eIndex2 = (YieldTypes)iI;
		if (eIndex2 == NO_YIELD)
			continue;
		if (YIELD_CULTURE == eIndex2)
			continue;

		pThisCity->UpdateCityYieldFromYield(YIELD_CULTURE, eIndex2, iCulturePerTurn);

		//NOTE! We flip it here, because we want the OUT yield
		iCulturePerTurn += GetRealYieldFromYield(eIndex2, YIELD_CULTURE);
	}

	if (MOD_BALANCE_CORE_JFD)
	{
		iCulturePerTurn += GetYieldFromHappiness(YIELD_CULTURE);
		iCulturePerTurn += GetYieldFromHealth(YIELD_CULTURE);

		iCulturePerTurn += GetYieldFromCrime(YIELD_CULTURE);
		iCulturePerTurn += GetYieldFromDevelopment(YIELD_CULTURE);
	}

	return iCulturePerTurn;
}

//	--------------------------------------------------------------------------------
int CvCity::GetJONSCulturePerTurnFromBuildings() const
{
	VALIDATE_OBJECT
	return GetBaseYieldRateFromBuildings(YIELD_CULTURE);
}

//	--------------------------------------------------------------------------------
int CvCity::GetJONSCulturePerTurnFromPolicies() const
{
	VALIDATE_OBJECT

	int iNonSpecialist = GET_PLAYER(m_eOwner).getYieldFromNonSpecialistCitizens(YIELD_CULTURE);
	int iValue = 0;
	if (iNonSpecialist != 0)
	{
		int iBonusTimes100 = (iNonSpecialist * (getPopulation() - GetCityCitizens()->GetTotalSpecialistCount()));
		iBonusTimes100 /= 100;
		iValue += iBonusTimes100;
	}
	if (MOD_BALANCE_CORE_HAPPINESS && GET_PLAYER(m_eOwner).getHappinessToCulture() != 0)
	{
		int iFreeCulture = GetLocalHappiness() * GET_PLAYER(m_eOwner).getHappinessToCulture();
		iFreeCulture /= 100;
		if (iFreeCulture > 0)
			iValue += iFreeCulture;
	}

	return (m_iJONSCulturePerTurnFromPolicies + iValue);
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeJONSCulturePerTurnFromPolicies(int iChange)
{
	VALIDATE_OBJECT
	if (iChange != 0)
	{
		m_iJONSCulturePerTurnFromPolicies = (m_iJONSCulturePerTurnFromPolicies + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvCity::GetJONSCulturePerTurnFromSpecialists() const
{
	VALIDATE_OBJECT
	return m_iJONSCulturePerTurnFromSpecialists;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeJONSCulturePerTurnFromSpecialists(int iChange)
{
	VALIDATE_OBJECT
	if (iChange != 0)
	{
		m_iJONSCulturePerTurnFromSpecialists = (m_iJONSCulturePerTurnFromSpecialists + iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvCity::GetJONSCulturePerTurnFromGreatWorks() const
{
	return GetCityBuildings()->GetYieldFromGreatWorks(YIELD_CULTURE);
}

//	--------------------------------------------------------------------------------
int CvCity::GetJONSCulturePerTurnFromTraits() const
{
	VALIDATE_OBJECT
	return GET_PLAYER(m_eOwner).GetPlayerTraits()->GetCityCultureBonus();
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeYieldFromTraits(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_iaAddedYieldPerTurnFromTraits[eIndex] = m_iaAddedYieldPerTurnFromTraits[eIndex] + iChange;

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			if (isCitySelected())
			{
				DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
				//DLLUI->setDirty(InfoPane_DIRTY_BIT, true );
			}
		}
	}
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvCity::GetYieldPerTurnFromTraits(YieldTypes eYield) const
{
	int iYield = 0;

	if (isCapital() || !GET_PLAYER(m_eOwner).GetPlayerTraits()->IsCapitalOnly())
	{
		vector<ImprovementTypes> relevantTypes = GET_PLAYER(m_eOwner).GetPlayerTraits()->GetImprovementTypesWithYieldChange();
		for (size_t i = 0; i < relevantTypes.size(); i++)
		{
			ImprovementTypes eImprovement = relevantTypes[i];
			int iYieldChangePerImprovementBuilt = GET_PLAYER(m_eOwner).GetPlayerTraits()->GetYieldChangePerImprovementBuilt(eImprovement, eYield);
			if (iYieldChangePerImprovementBuilt == 0)
				continue;

			iYield += iYieldChangePerImprovementBuilt * GET_PLAYER(m_eOwner).getTotalImprovementsBuilt(eImprovement);
			if (GET_PLAYER(m_eOwner).GetPlayerTraits()->IsOddEraScaler())
			{
				if ((EraTypes)GET_PLAYER(m_eOwner).GetCurrentEra() >= (EraTypes)GC.getInfoTypeForString("ERA_MEDIEVAL", true))
				{
					iYield += iYieldChangePerImprovementBuilt * GET_PLAYER(m_eOwner).getTotalImprovementsBuilt(eImprovement);
				}
				if ((EraTypes)GET_PLAYER(m_eOwner).GetCurrentEra() >= (EraTypes)GC.getInfoTypeForString("ERA_INDUSTRIAL", true))
				{
					iYield += iYieldChangePerImprovementBuilt * GET_PLAYER(m_eOwner).getTotalImprovementsBuilt(eImprovement);
				}
				if ((EraTypes)GET_PLAYER(m_eOwner).GetCurrentEra() >= (EraTypes)GC.getInfoTypeForString("ERA_POSTMODERN", true))
				{
					iYield += iYieldChangePerImprovementBuilt * GET_PLAYER(m_eOwner).getTotalImprovementsBuilt(eImprovement);
				}
			}
		}
	}

	if (eYield == YIELD_SCIENCE && MOD_BALANCE_CORE_HAPPINESS)
	{
		if (GET_PLAYER(m_eOwner).getHappinessToScience() != 0)
		{
			int iFreeScience = getYieldRateTimes100(YIELD_SCIENCE, false) * GET_PLAYER(m_eOwner).getHappinessToScience();
			iFreeScience /= 100;
			if (iFreeScience > 0)
				iYield += iFreeScience;
		}
	}

	//Currently only used by Arabian CBP UA.
	if (isCapital())
	{
		iYield += (GET_PLAYER(m_eOwner).GetPlayerTraits()->GetYieldFromHistoricEvent(eYield) * GET_PLAYER(m_eOwner).GetNumHistoricEvents());
#if defined(MOD_BALANCE_YIELD_SCALE_ERA)
		if (MOD_BALANCE_YIELD_SCALE_ERA)
		{
			int iEra = GET_PLAYER(m_eOwner).GetCurrentEra();
			int iChange = GET_PLAYER(m_eOwner).GetPlayerTraits()->GetYieldChangePerTradePartner(eYield);
			if (iChange > 0)
				iYield += (max(1, iEra) * GET_PLAYER(m_eOwner).GetPlayerTraits()->GetYieldChangePerTradePartner(eYield) * GET_PLAYER(m_eOwner).GetTrade()->GetNumDifferentTradingPartners());
		}
	}
#endif

	return (iYield + m_iaAddedYieldPerTurnFromTraits[eYield]);
}
#endif
//	--------------------------------------------------------------------------------
int CvCity::GetJONSCulturePerTurnFromReligion() const
{
	VALIDATE_OBJECT
	return GetBaseYieldRateFromReligion(YIELD_CULTURE);
}

//	--------------------------------------------------------------------------------
int CvCity::GetJONSCulturePerTurnFromLeagues() const
{
	VALIDATE_OBJECT
	return (getNumWorldWonders() * GC.getGame().GetGameLeagues()->GetWorldWonderYieldChange(getOwner(), YIELD_CULTURE));
}

//	--------------------------------------------------------------------------------
#if defined(MOD_BALANCE_CORE)
int CvCity::GetFaithPerTurn(bool bStatic) const
#else
int CvCity::GetFaithPerTurn() const
#endif
{
	VALIDATE_OBJECT
	// Anarchy, Resistance or Razing? Then no Faith is given!
	if (GET_PLAYER(getOwner()).IsAnarchy() || IsResistance() || IsRazing())
		return 0;

	if (bStatic)
	{
		return (GetStaticYield(YIELD_FAITH) / 100);
	}

	int iFaith = GetFaithPerTurnFromBuildings();
	iFaith += GetBaseYieldRateFromSpecialists(YIELD_FAITH);
	iFaith += (GetYieldPerPopTimes100(YIELD_FAITH) * getPopulation()) / 100;

#if defined(MOD_BALANCE_CORE)
	iFaith += (GetYieldPerPopInEmpireTimes100(YIELD_FAITH) * GET_PLAYER(getOwner()).getTotalPopulation()) / 100;
#endif

	if (IsRouteToCapitalConnected())
	{
		int iEra = GET_PLAYER(getOwner()).GetCurrentEra();
		if (iEra <= 0)
			iEra = 1;
		iFaith += GET_PLAYER(getOwner()).GetYieldChangeTradeRoute(YIELD_FAITH);
		iFaith += GET_PLAYER(getOwner()).GetPlayerTraits()->GetYieldChangeTradeRoute(YIELD_FAITH) * iEra;
	}

	iFaith += GetBaseYieldRateFromGreatWorks(YIELD_FAITH);
	iFaith += GetBaseYieldRateFromTerrain(YIELD_FAITH);
	iFaith += GetFaithPerTurnFromPolicies();

	for (int iI = 0; iI < GC.getNumFeatureInfos(); iI++)
	{
		FeatureTypes eFeature = (FeatureTypes)iI;
		if (eFeature != NO_FEATURE)
		{
			iFaith += GetYieldPerTurnFromUnimprovedFeatures(eFeature, YIELD_FAITH);
		}
	}

	iFaith += GetFaithPerTurnFromReligion();

	ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
	if (MOD_BALANCE_CORE_POLICIES && eMajority != NO_RELIGION && eMajority > RELIGION_PANTHEON)
	{
		if (GET_PLAYER(getOwner()).GetReligions()->GetStateReligion() == eMajority)
		{
			iFaith += GET_PLAYER(getOwner()).getReligionYieldRateModifier(YIELD_FAITH);
		}
	}

#if defined(MOD_BALANCE_CORE)
	iFaith += GetBaseYieldRateFromCSAlliance(YIELD_FAITH);
	iFaith += GetBaseYieldRateFromCSFriendship(YIELD_FAITH);
	iFaith += GetYieldFromMinors(YIELD_FAITH);
	iFaith += GetYieldPerTurnFromTraits(YIELD_FAITH);
	iFaith += GetYieldChangeFromCorporationFranchises(YIELD_FAITH);
#endif
#if defined(MOD_BALANCE_CORE)
	iFaith += GetEventCityYield(YIELD_FAITH);

	//Update Yields from yields ... need to sidestep constness
	CvCity* pThisCity = const_cast<CvCity*>(this);
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eIndex2 = (YieldTypes)iI;
		if (eIndex2 == NO_YIELD)
			continue;
		if (YIELD_FAITH == eIndex2)
			continue;

		pThisCity->UpdateCityYieldFromYield(YIELD_FAITH, eIndex2, iFaith);

		//NOTE! We flip it here, because we want the OUT yield
		iFaith += GetRealYieldFromYield(eIndex2, YIELD_FAITH);
	}
#endif

	if (MOD_BALANCE_CORE_JFD)
	{
		iFaith += GetYieldFromHappiness(YIELD_FAITH);
		iFaith += GetYieldFromHealth(YIELD_FAITH);
		iFaith += GetYieldFromCrime(YIELD_FAITH);
		iFaith += GetYieldFromDevelopment(YIELD_FAITH);
	}

	CvPlot* pCityPlot = plot();
	for (int iUnitLoop = 0; iUnitLoop < pCityPlot->getNumUnits(); iUnitLoop++)
	{
		int iTempVal = pCityPlot->getUnitByIndex(iUnitLoop)->GetYieldChange(YIELD_FAITH);
		if (iTempVal != 0)
		{
			iFaith += iTempVal;
		}
	}

	int iModifier = 100;

	// City modifier
	iModifier = getBaseYieldRateModifier(YIELD_FAITH);

	// FIXME: EUI doesn't expect `CvCity::getBaseYieldRateModifier` to populate the puppet modifier for faith.
	// EUI should be fixed and this behavior moved to `CvCity::getBaseYieldRateModifier`.
	if (IsPuppet())
	{
		int iTempMod = GET_PLAYER(getOwner()).GetPuppetYieldPenaltyMod() + GET_PLAYER(getOwner()).GetPlayerTraits()->GetPuppetPenaltyReduction() + /*0 in CP, -80 in VP*/ GD_INT_GET(PUPPET_FAITH_MODIFIER);
		if (iTempMod > 0)
			iTempMod = 0;
		iModifier += iTempMod;
	}

	iFaith *= iModifier;
	iFaith /= 100;

	// Process production into faith
	if (getProductionToYieldModifier(YIELD_FAITH) > 0)
		iFaith += (getBasicYieldRateTimes100(YIELD_PRODUCTION) * getProductionToYieldModifier(YIELD_FAITH)) / 10000;

	// Faith from having trade routes
	iFaith += GET_PLAYER(m_eOwner).GetTrade()->GetTradeValuesAtCityTimes100(this, YIELD_FAITH) / 100;

	return iFaith;
}

//	--------------------------------------------------------------------------------
int CvCity::GetFaithPerTurnFromBuildings() const
{
	VALIDATE_OBJECT
	return GetBaseYieldRateFromBuildings(YIELD_FAITH);
}

//	--------------------------------------------------------------------------------
int CvCity::GetFaithPerTurnFromPolicies() const
{
	VALIDATE_OBJECT
	int iNonSpecialist = GET_PLAYER(m_eOwner).getYieldFromNonSpecialistCitizens(YIELD_FAITH);
	int iValue = 0;
	if (iNonSpecialist != 0)
	{
		int iBonusTimes100 = (iNonSpecialist * (getPopulation() - GetCityCitizens()->GetTotalSpecialistCount()));
		iBonusTimes100 /= 100;
		iValue += iBonusTimes100;
	}

	return (m_iFaithPerTurnFromPolicies + iValue);
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeFaithPerTurnFromPolicies(int iChange)
{
	VALIDATE_OBJECT
	if (iChange != 0)
	{
		m_iFaithPerTurnFromPolicies = (m_iFaithPerTurnFromPolicies + iChange);
	}
}

//	--------------------------------------------------------------------------------
void CvCity::UpdateYieldPerXTerrain(YieldTypes eYield, TerrainTypes eTerrain)
{
	VALIDATE_OBJECT
	int iYield = 0;

	int iValidTilesTerrain = 0;
	int iBaseYieldBuildings = 0;

	//Passed in a terrain? Let's only update that.
	if (eTerrain != NO_TERRAIN)
	{
		iBaseYieldBuildings = GetYieldPerXTerrainFromBuildingsTimes100(eTerrain, eYield);

		if (iBaseYieldBuildings > 0)
		{
			if (eTerrain == TERRAIN_MOUNTAIN)
			{
				iValidTilesTerrain = GetNearbyMountains();
			}
			else if (eTerrain == TERRAIN_SNOW)
			{
				iValidTilesTerrain = CountTerrain(TERRAIN_SNOW);
			}
			else
			{
				iValidTilesTerrain = GetNumTerrainWorked(eTerrain);
			}

			iYield = (iValidTilesTerrain * iBaseYieldBuildings) / 100;

			//iDifference determines +/- of difference of old value
			int iDifference = iYield - GetYieldPerXTerrain(eTerrain, eYield);

			//Change base rate first
			ChangeBaseYieldRateFromBuildings(eYield, iDifference);

			//then set base rate for retrieval next time.
			SetYieldPerXTerrain(eTerrain, eYield, iYield);
		}
		else if (GetYieldPerXTerrain(eTerrain, eYield) > 0)
		{
			//No bonuses? Clear it out.
			ChangeBaseYieldRateFromBuildings(eYield, -GetYieldPerXTerrain(eTerrain, eYield));
			SetYieldPerXTerrain(eTerrain, eYield, 0);
		}
	}
	else
	{
		for (int iI = 0; iI < GC.getNumTerrainInfos(); iI++)
		{
			eTerrain = (TerrainTypes)iI;
			if (eTerrain == NO_TERRAIN)
			{
				continue;
			}

			iBaseYieldBuildings = GetYieldPerXTerrainFromBuildingsTimes100(eTerrain, eYield);

			if (iBaseYieldBuildings > 0)
			{
				if (eTerrain == TERRAIN_MOUNTAIN)
				{
					iValidTilesTerrain = GetNearbyMountains();
				}
				else if (eTerrain == TERRAIN_SNOW)
				{
					iValidTilesTerrain = CountTerrain(TERRAIN_SNOW);
				}
				else
				{
					iValidTilesTerrain = GetNumTerrainWorked(eTerrain);
				}

				iYield = (iValidTilesTerrain * iBaseYieldBuildings) / 100;

				//iDifference determines +/- of difference of old value
				int iDifference = iYield - GetYieldPerXTerrain(eTerrain, eYield);

				//Change base rate first
				ChangeBaseYieldRateFromBuildings(eYield, iDifference);

				//then set base rate for retrieval next time.
				SetYieldPerXTerrain(eTerrain, eYield, iYield);
			}
			else if (GetYieldPerXTerrain(eTerrain, eYield) > 0)
			{
				//No bonuses? Clear it out.
				ChangeBaseYieldRateFromBuildings(eYield, -GetYieldPerXTerrain(eTerrain, eYield));
				SetYieldPerXTerrain(eTerrain, eYield, 0);
			}
		}
	}
}
void CvCity::UpdateYieldPerXTerrainFromReligion(YieldTypes eYield, TerrainTypes eTerrain)
{
	VALIDATE_OBJECT
	int iYield = 0;

	int iValidTilesTerrain = 0;
	int iBaseYieldReligion = 0;
	ReligionTypes eReligionFounded = GetCityReligions()->GetReligiousMajority();
	if (eReligionFounded != NO_RELIGION)
	{
		const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eReligionFounded, getOwner());
		if (pReligion)
		{
			//Passed in a Terrain? Use that.
			if (eTerrain != NO_TERRAIN)
			{
				iYield = 0;
				iBaseYieldReligion = pReligion->m_Beliefs.GetYieldPerXTerrainTimes100(eTerrain, eYield, getOwner(), this);
				if (iBaseYieldReligion > 0)
				{
					if (eTerrain == TERRAIN_MOUNTAIN)
					{
						iValidTilesTerrain = GetNearbyMountains();
					}
					else if (eTerrain == TERRAIN_SNOW)
					{
						iValidTilesTerrain = CountTerrain(TERRAIN_SNOW);
					}
					else if (pReligion->m_Beliefs.RequiresNoFeature(getOwner()))
					{
						iValidTilesTerrain = GetNumFeaturelessTerrainWorked(eTerrain);
					}
					else
					{
						iValidTilesTerrain = GetNumTerrainWorked(eTerrain);
					}

					iYield += ((iValidTilesTerrain * iBaseYieldReligion) / 100);

					if (eTerrain == TERRAIN_MOUNTAIN && iYield > getPopulation())
					{
						iYield = getPopulation();
					}
					if (eTerrain == TERRAIN_SNOW && iYield > getPopulation())
					{
						iYield = getPopulation();
					}

					SetYieldPerXTerrainFromReligion(eTerrain, eYield, iYield);
				}
				else if (GetYieldPerXTerrainFromReligion(eTerrain, eYield) > 0)
				{
					SetYieldPerXTerrainFromReligion(eTerrain, eYield, 0);
				}
			}
			else
			{
				for (int iI = 0; iI < GC.getNumTerrainInfos(); iI++)
				{
					eTerrain = (TerrainTypes)iI;
					iYield = 0;
					if (eTerrain == NO_TERRAIN)
					{
						continue;
					}
					iBaseYieldReligion = pReligion->m_Beliefs.GetYieldPerXTerrainTimes100(eTerrain, eYield, getOwner(), this);
					if (iBaseYieldReligion > 0)
					{
						if (eTerrain == TERRAIN_MOUNTAIN)
						{
							iValidTilesTerrain = GetNearbyMountains();
						}
						else if (eTerrain == TERRAIN_SNOW)
						{
							iValidTilesTerrain = CountTerrain(TERRAIN_SNOW);
						}
						else if (pReligion->m_Beliefs.RequiresNoFeature(getOwner()))
						{
							iValidTilesTerrain = GetNumFeaturelessTerrainWorked(eTerrain);
						}
						else
						{
							iValidTilesTerrain = GetNumTerrainWorked(eTerrain);
						}

						iYield += ((iValidTilesTerrain * iBaseYieldReligion) / 100);

						if (eTerrain == TERRAIN_MOUNTAIN && iYield > getPopulation())
						{
							iYield = getPopulation();
						}
						if (eTerrain == TERRAIN_SNOW && iYield > getPopulation())
						{
							iYield = getPopulation();
						}

						SetYieldPerXTerrainFromReligion(eTerrain, eYield, iYield);
					}
					else if (GetYieldPerXTerrainFromReligion(eTerrain, eYield) > 0)
					{
						SetYieldPerXTerrainFromReligion(eTerrain, eYield, 0);
					}
				}
			}
		}
	}
}
//	--------------------------------------------------------------------------------
int CvCity::GetNumTerrainWorked(TerrainTypes eTerrain)
{
	CvAssertMsg(eTerrain >= 0, "eTerrain is expected to be non-negative (invalid Index)");
	CvAssertMsg(eTerrain < GC.getNumTerrainInfos(), "eTerrain is expected to be within maximum bounds (invalid Index)");
	return m_paiNumTerrainWorked[eTerrain];
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeNumTerrainWorked(TerrainTypes eTerrain, int iChange)
{
	CvAssertMsg(eTerrain >= 0, "eTerrain is expected to be non-negative (invalid Index)");
	CvAssertMsg(eTerrain < GC.getNumTerrainInfos(), "eTerrain is expected to be within maximum bounds (invalid Index)");
	m_paiNumTerrainWorked[eTerrain] = m_paiNumTerrainWorked[eTerrain] + iChange;
	CvAssert(GetNumTerrainWorked(eTerrain) >= 0);

	//Update yields
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		//Simplification - errata yields not worth considering.
		if ((YieldTypes)iI > YIELD_GOLDEN_AGE_POINTS && !MOD_BALANCE_CORE_JFD)
			break;

		UpdateYieldPerXTerrain(((YieldTypes)iI), eTerrain);
		UpdateYieldPerXTerrainFromReligion(((YieldTypes)iI), eTerrain);
	}
}

int CvCity::GetNumFeaturelessTerrainWorked(TerrainTypes eTerrain)
{
	CvAssertMsg(eTerrain >= 0, "eTerrain is expected to be non-negative (invalid Index)");
	CvAssertMsg(eTerrain < GC.getNumTerrainInfos(), "eTerrain is expected to be within maximum bounds (invalid Index)");
	return m_paiNumFeaturelessTerrainWorked[eTerrain];
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeNumFeaturelessTerrainWorked(TerrainTypes eTerrain, int iChange)
{
	CvAssertMsg(eTerrain >= 0, "eTerrain is expected to be non-negative (invalid Index)");
	CvAssertMsg(eTerrain < GC.getNumTerrainInfos(), "eTerrain is expected to be within maximum bounds (invalid Index)");
	m_paiNumFeaturelessTerrainWorked[eTerrain] = m_paiNumFeaturelessTerrainWorked[eTerrain] + iChange;
	CvAssert(GetNumFeaturelessTerrainWorked(eTerrain) >= 0);

	//Update yields
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		//Simplification - errata yields not worth considering.
		if ((YieldTypes)iI > YIELD_GOLDEN_AGE_POINTS && !MOD_BALANCE_CORE_JFD)
			break;

		UpdateYieldPerXTerrain(((YieldTypes)iI), eTerrain);
		UpdateYieldPerXTerrainFromReligion(((YieldTypes)iI), eTerrain);
	}
}
//	--------------------------------------------------------------------------------
int CvCity::GetNumFeatureWorked(FeatureTypes eFeature)
{
	CvAssertMsg(eFeature >= 0, "eFeature is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFeature < GC.getNumFeatureInfos(), "eFeature is expected to be within maximum bounds (invalid Index)");
	return m_paiNumFeatureWorked[eFeature];
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeNumFeatureWorked(FeatureTypes eFeature, int iChange)
{
	CvAssertMsg(eFeature >= 0, "eFeature is expected to be non-negative (invalid Index)");
	CvAssertMsg(eFeature < GC.getNumFeatureInfos(), "eFeature is expected to be within maximum bounds (invalid Index)");
	m_paiNumFeatureWorked[eFeature] = m_paiNumFeatureWorked[eFeature] + iChange;
	CvAssert(GetNumFeatureWorked(eFeature) >= 0);

	//Update yields
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		//Simplification - errata yields not worth considering.
		if ((YieldTypes)iI > YIELD_GOLDEN_AGE_POINTS && !MOD_BALANCE_CORE_JFD)
			break;

		UpdateYieldPerXFeature(((YieldTypes)iI), eFeature);
	}
}
//	--------------------------------------------------------------------------------
int CvCity::GetNumResourceWorked(ResourceTypes eResource)
{
	CvAssertMsg(eResource >= 0, "eResource is expected to be non-negative (invalid Index)");
	CvAssertMsg(eResource < GC.getNumResourceInfos(), "eResource is expected to be within maximum bounds (invalid Index)");
	return m_paiNumResourceWorked[eResource];
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeNumResourceWorked(ResourceTypes eResource, int iChange)
{
	CvAssertMsg(eResource >= 0, "eResource is expected to be non-negative (invalid Index)");
	CvAssertMsg(eResource < GC.getNumResourceInfos(), "eResource is expected to be within maximum bounds (invalid Index)");
	m_paiNumResourceWorked[eResource] = m_paiNumResourceWorked[eResource] + iChange;
	CvAssert(GetNumResourceWorked(eResource) >= 0);
}
//	--------------------------------------------------------------------------------
int CvCity::GetNumImprovementWorked(ImprovementTypes eImprovement)
{
	CvAssertMsg(eImprovement >= 0, "eImprovement is expected to be non-negative (invalid Index)");
	CvAssertMsg(eImprovement < GC.getNumImprovementInfos(), "eImprovement is expected to be within maximum bounds (invalid Index)");
	return m_paiNumImprovementWorked[eImprovement];
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeNumImprovementWorked(ImprovementTypes eImprovement, int iChange)
{
	CvAssertMsg(eImprovement >= 0, "eImprovement is expected to be non-negative (invalid Index)");
	CvAssertMsg(eImprovement < GC.getNumImprovementInfos(), "eImprovement is expected to be within maximum bounds (invalid Index)");
	m_paiNumImprovementWorked[eImprovement] = m_paiNumImprovementWorked[eImprovement] + iChange;
	CvAssert(GetNumImprovementWorked(eImprovement) >= 0);
}

//	--------------------------------------------------------------------------------
void CvCity::SetYieldPerXTerrain(TerrainTypes eTerrain, YieldTypes eYield, int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eTerrain > -1 && eTerrain < GC.getNumTerrainInfos(), "Invalid Terrain index.");
	CvAssertMsg(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	SCityExtraYields& y = m_yieldChanges[eYield];
	if (ModifierUpdateInsertRemove(y.forXTerrain, eTerrain, iValue, false))
		updateYield(false);
}
//	--------------------------------------------------------------------------------
void CvCity::SetYieldPerXTerrainFromReligion(TerrainTypes eTerrain, YieldTypes eYield, int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eTerrain > -1 && eTerrain < GC.getNumTerrainInfos(), "Invalid Terrain index.");
	CvAssertMsg(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	SCityExtraYields& y = m_yieldChanges[eYield];
	if (ModifierUpdateInsertRemove(y.forTerrainFromReligion, eTerrain, iValue, false))
		updateYield(false);
}
//	--------------------------------------------------------------------------------
/// Extra yield for a Terrain this city is working?
int CvCity::GetYieldPerXTerrain(TerrainTypes eTerrain, YieldTypes eYield) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eTerrain > -1 && eTerrain < GC.getNumTerrainInfos(), "Invalid Terrain index.");
	CvAssertMsg(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	return ModifierLookup(m_yieldChanges[eYield].forXTerrain, eTerrain);
}
//	--------------------------------------------------------------------------------
/// Extra yield for a Terrain this city is working?
int CvCity::GetYieldPerXTerrainFromReligion(TerrainTypes eTerrain, YieldTypes eYield) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eTerrain > -1 && eTerrain < GC.getNumTerrainInfos(), "Invalid Terrain index.");
	CvAssertMsg(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	return ModifierLookup(m_yieldChanges[eYield].forTerrainFromReligion, eTerrain);
}
//	--------------------------------------------------------------------------------
/// Extra yield for a Terrain this city is working?
int CvCity::GetYieldPerXTerrainFromBuildingsTimes100(TerrainTypes eTerrain, YieldTypes eYield) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eTerrain > -1 && eTerrain < GC.getNumTerrainInfos(), "Invalid Terrain index.");
	CvAssertMsg(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	return ModifierLookup(m_yieldChanges[eYield].forTerrainFromBuildings, eTerrain);
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeYieldPerXTerrainFromBuildingsTimes100(TerrainTypes eTerrain, YieldTypes eYield, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eTerrain > -1 && eTerrain < GC.getNumTerrainInfos(), "Invalid Terrain index.");
	CvAssertMsg(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	SCityExtraYields& y = m_yieldChanges[eYield];
	if (ModifierUpdateInsertRemove(y.forTerrainFromBuildings, eTerrain, iChange, true))
		updateYield(false);
}

//	--------------------------------------------------------------------------------
/// Extra yield for a Feature this city is working?
int CvCity::GetYieldPerXFeatureFromBuildingsTimes100(FeatureTypes eFeature, YieldTypes eYield) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eFeature > -1 && eFeature < GC.getNumFeatureInfos(), "Invalid Feature index.");
	CvAssertMsg(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	return ModifierLookup(m_yieldChanges[eYield].forFeatureFromBuildings, eFeature);
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeYieldPerXFeatureFromBuildingsTimes100(FeatureTypes eFeature, YieldTypes eYield, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eFeature > -1 && eFeature < GC.getNumFeatureInfos(), "Invalid Feature index.");
	CvAssertMsg(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	SCityExtraYields& y = m_yieldChanges[eYield];
	if (ModifierUpdateInsertRemove(y.forFeatureFromBuildings, eFeature, iChange, true))
	{
		updateYield(false);
		UpdateYieldPerXFeature(eYield, eFeature);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield for a Feature this city is working?
int CvCity::GetYieldPerXFeature(FeatureTypes eFeature, YieldTypes eYield) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eFeature > -1 && eFeature < GC.getNumFeatureInfos(), "Invalid Terrain index.");
	CvAssertMsg(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	return ModifierLookup(m_yieldChanges[eYield].forXFeature, eFeature);
}

int CvCity::GetYieldPerXFeatureFromReligion(FeatureTypes eFeature, YieldTypes eYield) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eFeature > -1 && eFeature < GC.getNumFeatureInfos(), "Invalid Terrain index.");
	CvAssertMsg(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	return ModifierLookup(m_yieldChanges[eYield].forFeatureFromReligion, eFeature);
}

//	--------------------------------------------------------------------------------
/// Extra yield for an unimproved Feature this city is working?
int CvCity::GetYieldPerTurnFromUnimprovedFeatures(FeatureTypes eFeature, YieldTypes eYield) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eFeature > -1 && eFeature < GC.getNumFeatureInfos(), "Invalid Terrain index.");
	CvAssertMsg(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	return ModifierLookup(m_yieldChanges[eYield].forFeatureUnimproved, eFeature);
}
//	--------------------------------------------------------------------------------
void CvCity::SetYieldPerXFeature(FeatureTypes eFeature, YieldTypes eYield, int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eFeature > -1 && eFeature < GC.getNumFeatureInfos(), "Invalid Feature index.");
	CvAssertMsg(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	SCityExtraYields& y = m_yieldChanges[eYield];
	if (ModifierUpdateInsertRemove(y.forXFeature, eFeature, iValue, false))
		updateYield(false);
}

//	--------------------------------------------------------------------------------
void CvCity::SetYieldPerXFeatureFromReligion(FeatureTypes eFeature, YieldTypes eYield, int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eFeature > -1 && eFeature < GC.getNumFeatureInfos(), "Invalid Feature index.");
	CvAssertMsg(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	SCityExtraYields& y = m_yieldChanges[eYield];
	if (ModifierUpdateInsertRemove(y.forFeatureFromReligion, eFeature, iValue, false))
		updateYield(false);
}
//	--------------------------------------------------------------------------------
void CvCity::SetYieldPerXUnimprovedFeature(FeatureTypes eFeature, YieldTypes eYield, int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eFeature > -1 && eFeature < GC.getNumFeatureInfos(), "Invalid Feature index.");
	CvAssertMsg(eYield > -1 && eYield < NUM_YIELD_TYPES, "Invalid yield index.");

	SCityExtraYields& y = m_yieldChanges[eYield];
	if (ModifierUpdateInsertRemove(y.forFeatureUnimproved, eFeature, iValue, false))
		updateYield(false);
}

void CvCity::UpdateYieldPerXUnimprovedFeature(YieldTypes eYield, FeatureTypes eFeature)
{
	VALIDATE_OBJECT
	int iYield = 0;

	CvPlayer& kPlayer = GET_PLAYER(getOwner());
	const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
	BeliefTypes eSecondaryPantheon = GetCityReligions()->GetSecondaryReligionPantheonBelief();

	const CvReligion* pPantheon = NULL;
	BeliefTypes ePantheonBelief = NO_BELIEF;
	// Mod for civs keeping their pantheon belief forever
	if (MOD_RELIGION_PERMANENT_PANTHEON)
	{
		if (GC.getGame().GetGameReligions()->HasCreatedPantheon(getOwner()))
		{
			pPantheon = GC.getGame().GetGameReligions()->GetReligion(RELIGION_PANTHEON, getOwner());
			ePantheonBelief = GC.getGame().GetGameReligions()->GetBeliefInPantheon(getOwner());
		}
	}

	//Passed in a feature? Use that.
	if (eFeature != NO_FEATURE)
	{
		if (!GC.getFeatureInfo(eFeature)->IsNaturalWonder())
		{
			int iBaseYield = kPlayer.getCityYieldFromUnimprovedFeature(eFeature, eYield);
			iBaseYield += kPlayer.GetPlayerTraits()->GetCityYieldFromUnimprovedFeature(eFeature, eYield);

			if (pReligion)
			{
				iBaseYield += pReligion->m_Beliefs.GetCityYieldFromUnimprovedFeature(eFeature, eYield, getOwner(), this);
				if (eSecondaryPantheon != NO_BELIEF)
				{
					iBaseYield += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetCityYieldFromUnimprovedFeature(eFeature, eYield);
				}
			}

			if (MOD_RELIGION_PERMANENT_PANTHEON)
			{
				if (pPantheon != NULL && ePantheonBelief != NO_BELIEF && ePantheonBelief != eSecondaryPantheon)
				{
					if (pReligion == NULL || (pReligion != NULL && !pReligion->m_Beliefs.IsPantheonBeliefInReligion(ePantheonBelief, pReligion->m_eReligion, getOwner()))) // check that the our religion does not have our belief, to prevent double counting
					{
						iBaseYield += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetCityYieldFromUnimprovedFeature(eFeature, eYield);
					}
				}
			}

			if (eYield == YIELD_FAITH && eFeature == FEATURE_FOREST && kPlayer.GetPlayerTraits()->IsFaithFromUnimprovedForest())
			{
				++iBaseYield;
			}

			if (iBaseYield > 0)
			{
				int iAdjacentFeatures = 0;

				for (int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; ++iDirectionLoop)
				{
					CvPlot* pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iDirectionLoop));
					if (pAdjacentPlot && pAdjacentPlot->getFeatureType() == eFeature && pAdjacentPlot->getImprovementType() == NO_IMPROVEMENT)
					{
						iAdjacentFeatures++;
					}
				}
				if (iAdjacentFeatures > 2)
				{
#if defined(MOD_ALTERNATE_CELTS)
					if (MOD_ALTERNATE_CELTS)
					{
						iYield += iBaseYield * 3;
					}
					else
					{
						iYield += iBaseYield * 2;
					}
#else
					iYield += iBaseYield * 2;
#endif
				}
#if defined(MOD_ALTERNATE_CELTS)
				else if (iAdjacentFeatures > 1 && MOD_ALTERNATE_CELTS)
				{
					iYield += iBaseYield * 2;
				}
#endif
				else if (iAdjacentFeatures > 0)
				{
					iYield += iBaseYield;
				}
				SetYieldPerXUnimprovedFeature(eFeature, eYield, iYield);
			}
		}
	}
	else
	{
		for (int iI = 0; iI < GC.getNumFeatureInfos(); iI++)
		{
			eFeature = (FeatureTypes)iI;
#if defined(MOD_PSEUDO_NATURAL_WONDER)
			if (!GC.getFeatureInfo(eFeature)->IsNaturalWonder(true))
#else
			if (!GC.getFeatureInfo(eFeature)->IsNaturalWonder())
#endif
			{
				int iBaseYield = kPlayer.getCityYieldFromUnimprovedFeature(eFeature, eYield);
				iBaseYield += kPlayer.GetPlayerTraits()->GetCityYieldFromUnimprovedFeature(eFeature, eYield);

				if (pReligion)
				{
					iBaseYield += pReligion->m_Beliefs.GetCityYieldFromUnimprovedFeature(eFeature, eYield, getOwner(), this);
					if (eSecondaryPantheon != NO_BELIEF)
					{
						iBaseYield += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetCityYieldFromUnimprovedFeature(eFeature, eYield);
					}
				}

				if (MOD_RELIGION_PERMANENT_PANTHEON)
				{
					if (pPantheon != NULL && ePantheonBelief != NO_BELIEF && ePantheonBelief != eSecondaryPantheon)
					{
						if (pReligion == NULL || (pReligion != NULL && !pReligion->m_Beliefs.IsPantheonBeliefInReligion(ePantheonBelief, pReligion->m_eReligion, getOwner()))) // check that the our religion does not have our belief, to prevent double counting
						{
							iBaseYield += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetCityYieldFromUnimprovedFeature(eFeature, eYield);
						}
					}
				}

				if (eYield == YIELD_FAITH && eFeature == FEATURE_FOREST && kPlayer.GetPlayerTraits()->IsFaithFromUnimprovedForest())
				{
					++iBaseYield;
				}

				if (iBaseYield > 0)
				{
					int iAdjacentFeatures = 0;

					for (int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; ++iDirectionLoop)
					{
						CvPlot* pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iDirectionLoop));
						if (pAdjacentPlot && pAdjacentPlot->getFeatureType() == eFeature && pAdjacentPlot->getImprovementType() == NO_IMPROVEMENT)
						{
							iAdjacentFeatures++;
						}
					}
					if (iAdjacentFeatures > 2)
					{
#if defined(MOD_ALTERNATE_CELTS)
						if (MOD_ALTERNATE_CELTS)
						{
							iYield += iBaseYield * 3;
						}
						else
						{
							iYield += iBaseYield * 2;
						}
#else
						iYield += iBaseYield * 2;
#endif
					}
#if defined(MOD_ALTERNATE_CELTS)
					else if (iAdjacentFeatures > 1 && MOD_ALTERNATE_CELTS)
					{
						iYield += iBaseYield * 2;
					}
#endif
					else if (iAdjacentFeatures > 0)
					{
						iYield += iBaseYield;
					}
					SetYieldPerXUnimprovedFeature(eFeature, eYield, iYield);
				}
			}
		}
	}
}
void CvCity::UpdateYieldPerXFeature(YieldTypes eYield, FeatureTypes eFeature)
{
	VALIDATE_OBJECT
	int iYieldBase = 0;
	int iYieldReligion = 0;

	int iValidTiles = 0;
	int iBaseYield = 0;
	int iBaseYieldReligion = 0;

	const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();

	//If we passed in a feature, let's only refresh that.
	if (eFeature != NO_FEATURE)
	{
		iYieldBase = 0;
		iYieldReligion = 0;
		if (pReligion)
		{
			iBaseYieldReligion = pReligion->m_Beliefs.GetYieldPerXFeatureTimes100(eFeature, eYield, getOwner(), this);
		}

		iBaseYield = GetYieldPerXFeatureFromBuildingsTimes100(eFeature, eYield);

		bool bTest = false;
		if (iBaseYield <= 0)
		{
			ChangeBaseYieldRateFromBuildings(eYield, -GetYieldPerXFeature(eFeature, eYield));
			SetYieldPerXFeature(eFeature, eYield, 0);
		}
		else
			bTest = true;
		if (iBaseYieldReligion <= 0)
		{
			SetYieldPerXFeatureFromReligion(eFeature, eYield, iYieldReligion);
		}
		else
			bTest = true;

		if (bTest)
		{
			iValidTiles = GetNumFeatureWorked(eFeature);
			if (iValidTiles > 0)
			{
				//Gain 1 yield per x valid tiles - so if 'x' is 3, and you have 3 tiles that match, you get 1 yield
				iYieldBase = (iValidTiles * iBaseYield) / 100;
				iYieldReligion = (iValidTiles * iBaseYieldReligion) / 100;

				//iDifference determines +/- of difference of old value
				int iBaseDifference = iYieldBase - GetYieldPerXFeature(eFeature, eYield);

				//Change base rate first
				ChangeBaseYieldRateFromBuildings(eYield, iBaseDifference);
				SetYieldPerXFeature(eFeature, eYield, iYieldBase);

				SetYieldPerXFeatureFromReligion(eFeature, eYield, iYieldReligion);
			}
			else
			{
				ChangeBaseYieldRateFromBuildings(eYield, -GetYieldPerXFeature(eFeature, eYield));
				SetYieldPerXFeature(eFeature, eYield, 0);

				SetYieldPerXFeatureFromReligion(eFeature, eYield, 0);
			}
		}
	}
	else
	{
		for (int iI = 0; iI < GC.getNumFeatureInfos(); iI++)
		{
			eFeature = (FeatureTypes)iI;
			if (eFeature == NO_FEATURE)
			{
				continue;
			}
			iYieldBase = 0;
			iYieldReligion = 0;
			if (pReligion)
			{
				iBaseYieldReligion = pReligion->m_Beliefs.GetYieldPerXFeatureTimes100(eFeature, eYield, getOwner(), this);
			}

			iBaseYield = GetYieldPerXFeatureFromBuildingsTimes100(eFeature, eYield);

			bool bTest = false;
			if (iBaseYield <= 0)
			{
				ChangeBaseYieldRateFromBuildings(eYield, -GetYieldPerXFeature(eFeature, eYield));
				SetYieldPerXFeature(eFeature, eYield, 0);
			}
			else
				bTest = true;
			if (iBaseYieldReligion <= 0)
			{
				SetYieldPerXFeatureFromReligion(eFeature, eYield, iYieldReligion);
			}
			else
				bTest = true;

			if (bTest)
			{
				iValidTiles = GetNumFeatureWorked(eFeature);
				if (iValidTiles > 0)
				{
					//Gain 1 yield per x valid tiles - so if 'x' is 3, and you have 3 tiles that match, you get 1 yield
					iYieldBase = (iValidTiles * iBaseYield) / 100;
					iYieldReligion = (iValidTiles * iBaseYieldReligion) / 100;

					//iDifference determines +/- of difference of old value
					int iDifference = iYieldBase - GetYieldPerXFeature(eFeature, eYield);

					//Change base rate first
					ChangeBaseYieldRateFromBuildings(eYield, iDifference);
					SetYieldPerXFeature(eFeature, eYield, iYieldBase);

					SetYieldPerXFeatureFromReligion(eFeature, eYield, iYieldReligion);
				}
				else
				{
					ChangeBaseYieldRateFromBuildings(eYield, -GetYieldPerXFeature(eFeature, eYield));
					SetYieldPerXFeature(eFeature, eYield, 0);

					SetYieldPerXFeatureFromReligion(eFeature, eYield, 0);
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
int CvCity::getHurryModifier(HurryTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumHurryInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiHurryModifier[eIndex];
}

//	--------------------------------------------------------------------------------
void CvCity::changeHurryModifier(HurryTypes eIndex, int iChange)
{
	if (iChange != 0)
	{
		CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
		CvAssertMsg(eIndex < GC.getNumHurryInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
		m_paiHurryModifier[eIndex] = m_paiHurryModifier[eIndex] + iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvCity::getSpecialistExtraYield(SpecialistTypes eIndex1, YieldTypes eIndex2) const
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 expected to be >= 0");
	CvAssertMsg(eIndex1 < GC.getNumSpecialistInfos(), "eIndex1 expected to be < GC.getNumSpecialistInfos()");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 expected to be >= 0");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 expected to be < NUM_YIELD_TYPES");
	return ModifierLookup(m_yieldChanges[eIndex2].forSpecialist, eIndex1);
}


//	--------------------------------------------------------------------------------
void CvCity::changeSpecialistExtraYield(SpecialistTypes eIndex1, YieldTypes eIndex2, int iChange)
{
	CvAssertMsg(eIndex1 >= 0, "eIndex1 expected to be >= 0");
	CvAssertMsg(eIndex1 < GC.getNumSpecialistInfos(), "eIndex1 expected to be < GC.getNumSpecialistInfos()");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 expected to be >= 0");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 expected to be < NUM_YIELD_TYPES");

	SCityExtraYields& y = m_yieldChanges[eIndex2];
	if (ModifierUpdateInsertRemove(y.forSpecialist, eIndex1, iChange, true))
		updateExtraSpecialistYield();
}

//	--------------------------------------------------------------------------------
int CvCity::GetFaithPerTurnFromReligion() const
{
	VALIDATE_OBJECT
	return GetBaseYieldRateFromReligion(YIELD_FAITH);
}

//	--------------------------------------------------------------------------------
int CvCity::getCultureRateModifier() const
{
	VALIDATE_OBJECT
	return m_iCultureRateModifier;
}

//	--------------------------------------------------------------------------------
void CvCity::changeCultureRateModifier(int iChange)
{
	VALIDATE_OBJECT
	if (iChange != 0)
	{
		m_iCultureRateModifier = (m_iCultureRateModifier + iChange);
	}
}
#if defined(MOD_BALANCE_CORE_POLICIES)
//	--------------------------------------------------------------------------------
int CvCity::getBuildingClassCultureChange(BuildingClassTypes eIndex) const
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	return m_paiBuildingClassCulture[eIndex];
}
//	--------------------------------------------------------------------------------
void CvCity::changeBuildingClassCultureChange(BuildingClassTypes eIndex, int iChange)
{
	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex < GC.getNumBuildingClassInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
	m_paiBuildingClassCulture[eIndex] = m_paiBuildingClassCulture[eIndex] + iChange;
	CvAssert(getBuildingClassCultureChange(eIndex) >= 0);
}
#endif
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvCity::GetBaseTourism() const
{
	VALIDATE_OBJECT
	return m_iBaseTourism;
}

//	--------------------------------------------------------------------------------
void CvCity::SetBaseTourism(int iValue)
{
	VALIDATE_OBJECT
	m_iBaseTourism = iValue;
}
//	--------------------------------------------------------------------------------
int CvCity::GetBaseTourismBeforeModifiers() const
{
	VALIDATE_OBJECT
	return m_iBaseTourismBeforeModifiers;
}

//	--------------------------------------------------------------------------------
void CvCity::SetBaseTourismBeforeModifiers(int iValue)
{
	VALIDATE_OBJECT
	m_iBaseTourismBeforeModifiers = iValue;
}
#endif

//	--------------------------------------------------------------------------------
int CvCity::getTourismRateModifier() const
{
	VALIDATE_OBJECT
	return (GetCityBuildings()->GetGreatWorksTourismModifier() + GET_PLAYER(getOwner()).GetGreatWorksTourismModifierGlobal());
}

//	--------------------------------------------------------------------------------
void CvCity::changeTourismRateModifier(int iChange)
{
	VALIDATE_OBJECT
	if (iChange != 0)
	{
		GetCityBuildings()->ChangeGreatWorksTourismModifier(iChange);
	}
}

//	--------------------------------------------------------------------------------
int CvCity::getNumWorldWonders() const
{
	VALIDATE_OBJECT
	return m_iNumWorldWonders;
}


//	--------------------------------------------------------------------------------
void CvCity::changeNumWorldWonders(int iChange)
{
	VALIDATE_OBJECT
	if (iChange != 0)
	{
		m_iNumWorldWonders = (m_iNumWorldWonders + iChange);
		CvAssert(getNumWorldWonders() >= 0);

		// Extra culture for Wonders (Policies, etc.)
		ChangeJONSCulturePerTurnFromPolicies(GET_PLAYER(getOwner()).GetCulturePerWonder() * iChange);
	}
}


//	--------------------------------------------------------------------------------
int CvCity::getNumTeamWonders() const
{
	VALIDATE_OBJECT
	return m_iNumTeamWonders;
}


//	--------------------------------------------------------------------------------
void CvCity::changeNumTeamWonders(int iChange)
{
	VALIDATE_OBJECT
	m_iNumTeamWonders = (m_iNumTeamWonders + iChange);
	CvAssert(getNumTeamWonders() >= 0);
}


//	--------------------------------------------------------------------------------
int CvCity::getNumNationalWonders() const
{
	VALIDATE_OBJECT
	return m_iNumNationalWonders;
}


//	--------------------------------------------------------------------------------
void CvCity::changeNumNationalWonders(int iChange)
{
	VALIDATE_OBJECT
	m_iNumNationalWonders = (m_iNumNationalWonders + iChange);
	CvAssert(getNumNationalWonders() >= 0);
}


//	--------------------------------------------------------------------------------
int CvCity::GetWonderProductionModifier() const
{
	VALIDATE_OBJECT
	return m_iWonderProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvCity::ChangeWonderProductionModifier(int iChange)
{
	VALIDATE_OBJECT
	m_iWonderProductionModifier = (m_iWonderProductionModifier + iChange);
	CvAssert(GetWonderProductionModifier() >= 0);
}

//	--------------------------------------------------------------------------------
int CvCity::GetLocalResourceWonderProductionMod(BuildingTypes eBuilding, CvString* toolTipSink) const
{
	VALIDATE_OBJECT
	int iMultiplier = 0;

	CvAssertMsg(eBuilding > -1 && eBuilding < GC.getNumBuildingInfos(), "Invalid building index. Please show Jon.");
	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if (pkBuildingInfo)
	{
		// Is this even a wonder?
		const CvBuildingClassInfo& kBuildingClassInfo = pkBuildingInfo->GetBuildingClassInfo();
		if (!::isWorldWonderClass(kBuildingClassInfo) &&
			!::isTeamWonderClass(kBuildingClassInfo) &&
			!::isNationalWonderClass(kBuildingClassInfo))
		{
			return 0;
		}

#if defined(MOD_TRADE_WONDER_RESOURCE_ROUTES)
		// Are we using a trade route to ship the wonder resource from/to this city?
		bool bWonderResourceIn = false;
		bool bWonderResourceOut = false;
		if (MOD_TRADE_WONDER_RESOURCE_ROUTES) {
			CvGameTrade* pGameTrade = GC.getGame().GetGameTrade();
			for (uint ui = 0; ui < pGameTrade->GetNumTradeConnections(); ui++)
			{
				if (pGameTrade->IsTradeRouteIndexEmpty(ui))
				{
					continue;
				}

				if (pGameTrade->GetTradeConnection(ui).m_eConnectionType == TRADE_CONNECTION_WONDER_RESOURCE)
				{
					CvCity* pOriginCity = CvGameTrade::GetOriginCity(pGameTrade->GetTradeConnection(ui));
					CvCity* pDestCity = CvGameTrade::GetDestCity(pGameTrade->GetTradeConnection(ui));

					if (pDestCity->getX() == getX() && pDestCity->getY() == getY())
					{
						ResourceTypes eWonderResource = ::getWonderResource();
						bWonderResourceIn = (eWonderResource != NO_RESOURCE && pOriginCity->GetNumResourceLocal(eWonderResource) > 0);
					}
					else
					{
						if (pOriginCity->getX() == getX() && pOriginCity->getY() == getY())
						{
							bWonderResourceOut = true;
						}
					}

					break;
				}
			}
			// if (bWonderResourceIn) CUSTOMLOG("Shipping a wonder resource into %s", getName().c_str());
			// if (bWonderResourceOut) CUSTOMLOG("Shipping a wonder resource out of %s", getName().c_str());
		}
#endif

		// Resource wonder bonus
		int iTotalBonus = 0;
		for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
		{
			const ResourceTypes eResource = static_cast<ResourceTypes>(iResourceLoop);
			CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
			if (pkResource)
			{
				int iBonus = pkResource->getWonderProductionMod();
				if (iBonus != 0)
				{
#if defined(MOD_TRADE_WONDER_RESOURCE_ROUTES)
					bool bHasLocalResource = IsHasResourceLocal(eResource, /*bTestVisible*/ false);
					if (MOD_TRADE_WONDER_RESOURCE_ROUTES) {
						// We're shipping one in, or we're not shipping our only one out, or we have more than one
						bHasLocalResource = bWonderResourceIn || (m_paiNumResourcesLocal[eResource] == 1 && !bWonderResourceOut) || (m_paiNumResourcesLocal[eResource] > 1);
					}
					if (bHasLocalResource)
#else
					if (IsHasResourceLocal(eResource, /*bTestVisible*/ false))
#endif
					{
						// Depends on era of wonder?
						EraTypes eResourceObsoleteEra = pkResource->getWonderProductionModObsoleteEra();
						if (eResourceObsoleteEra != NO_ERA)
						{
							EraTypes eWonderEra;
							TechTypes eTech = (TechTypes)pkBuildingInfo->GetPrereqAndTech();
							if (eTech != NO_TECH)
							{
								CvTechEntry* pEntry = GC.GetGameTechs()->GetEntry(eTech);
								if (pEntry)
								{
									eWonderEra = (EraTypes)pEntry->GetEra();
									if (eWonderEra != NO_ERA)
									{
										if (eWonderEra >= eResourceObsoleteEra)
										{
											continue;
										}
									}
								}
							}
						}

						iTotalBonus += iBonus;
					}
				}
			}
		}
		if (iTotalBonus != 0)
		{
			iMultiplier += iTotalBonus;
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_LOCAL_RES", iTotalBonus, pkBuildingInfo->GetDescription());
		}
	}

	return iMultiplier;
}


//	--------------------------------------------------------------------------------
int CvCity::getCapturePlunderModifier() const
{
	VALIDATE_OBJECT
	return m_iCapturePlunderModifier;
}


//	--------------------------------------------------------------------------------
void CvCity::changeCapturePlunderModifier(int iChange)
{
	VALIDATE_OBJECT
	m_iCapturePlunderModifier = (m_iCapturePlunderModifier + iChange);
	CvAssert(m_iCapturePlunderModifier >= 0);
}

/// Total % rate increase to border growth in this city
int CvCity::GetBorderGrowthRateIncreaseTotal()
{
	int iModifier = GetBorderGrowthRateIncrease() + GET_PLAYER(getOwner()).GetBorderGrowthRateIncreaseGlobal();

	// Religion modifier
	ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
	BeliefTypes eSecondaryPantheon = NO_BELIEF;
	if (eMajority != NO_RELIGION)
	{
		const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
		if (pReligion)
		{
			iModifier += pReligion->m_Beliefs.GetBorderGrowthRateIncreaseGlobal(getOwner(), GET_PLAYER(getOwner()).getCity(GetID()));
			eSecondaryPantheon = GetCityReligions()->GetSecondaryReligionPantheonBelief();
			if (eSecondaryPantheon != NO_BELIEF)
			{
				iModifier += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetBorderGrowthRateIncreaseGlobal();
			}
		}
	}

	// Mod for civs keeping their pantheon belief forever
	if (MOD_RELIGION_PERMANENT_PANTHEON)
	{
		if (GC.getGame().GetGameReligions()->HasCreatedPantheon(getOwner()))
		{
			const CvReligion* pPantheon = GC.getGame().GetGameReligions()->GetReligion(RELIGION_PANTHEON, getOwner());
			BeliefTypes ePantheonBelief = GC.getGame().GetGameReligions()->GetBeliefInPantheon(getOwner());
			if (pPantheon != NULL && ePantheonBelief != NO_BELIEF && ePantheonBelief != eSecondaryPantheon)
			{
				const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eMajority, getOwner());
				if (pReligion == NULL || (pReligion != NULL && !pReligion->m_Beliefs.IsPantheonBeliefInReligion(ePantheonBelief, eMajority, getOwner()))) // check that the our religion does not have our belief, to prevent double counting
				{
					iModifier += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetBorderGrowthRateIncreaseGlobal();
				}
			}
		}
	}

	// Double border growth during GA or WLTKD? These intentionally do not stack with each other, but do stack multiplicatively with other modifiers.
	if ((GET_PLAYER(getOwner()).IsDoubleBorderGrowthGA() && GET_PLAYER(getOwner()).isGoldenAge())
		|| (GET_PLAYER(getOwner()).IsDoubleBorderGrowthWLTKD() && GetWeLoveTheKingDayCounter() > 0))
	{
		iModifier *= 2; // double the extra rate (if any)
		iModifier += 100; // double the base rate
	}

	return iModifier;
}

//	--------------------------------------------------------------------------------
int CvCity::GetBorderGrowthRateIncrease() const
{
	VALIDATE_OBJECT
	return m_iBorderGrowthRateIncrease;
}


//	--------------------------------------------------------------------------------
void CvCity::ChangeBorderGrowthRateIncrease(int iChange)
{
	VALIDATE_OBJECT
	m_iBorderGrowthRateIncrease = (m_iBorderGrowthRateIncrease + iChange);
}


//	--------------------------------------------------------------------------------
int CvCity::getPlotCultureCostModifier() const
{
	VALIDATE_OBJECT
	return m_iPlotCultureCostModifier;
}


//	--------------------------------------------------------------------------------
void CvCity::changePlotCultureCostModifier(int iChange)
{
	VALIDATE_OBJECT
	m_iPlotCultureCostModifier = (m_iPlotCultureCostModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvCity::getPlotBuyCostModifier() const
{
	VALIDATE_OBJECT
	return m_iPlotBuyCostModifier;
}


//	--------------------------------------------------------------------------------
void CvCity::changePlotBuyCostModifier(int iChange)
{
	VALIDATE_OBJECT
	m_iPlotBuyCostModifier = (m_iPlotBuyCostModifier + iChange);
}

#if defined(MOD_BUILDINGS_CITY_WORKING)
//	--------------------------------------------------------------------------------
int CvCity::GetCityWorkingChange() const
{
	VALIDATE_OBJECT
	return m_iCityWorkingChange;
}

//	--------------------------------------------------------------------------------
void CvCity::changeCityWorkingChange(int iChange)
{
	VALIDATE_OBJECT
	if (iChange != 0)
	{
		int iOldPlots = GetNumWorkablePlots();
		m_iCityWorkingChange = (m_iCityWorkingChange + iChange);
		int iNewPlots = GetNumWorkablePlots();

		for (int iI = std::min(iOldPlots, iNewPlots); iI < std::max(iOldPlots, iNewPlots); ++iI) {
			CvPlot* pLoopPlot = iterateRingPlots(getX(), getY(), iI);

			if (pLoopPlot) {
				pLoopPlot->changeCityRadiusCount(iChange);
				pLoopPlot->changePlayerCityRadiusCount(getOwner(), iChange);
			}
		}
	}
}
#endif

#if defined(MOD_BUILDINGS_CITY_AUTOMATON_WORKERS)
//	--------------------------------------------------------------------------------
int CvCity::GetCityAutomatonWorkersChange() const
{
	VALIDATE_OBJECT
	return m_iCityAutomatonWorkersChange;
}

//	--------------------------------------------------------------------------------
void CvCity::changeCityAutomatonWorkersChange(int iChange)
{
	VALIDATE_OBJECT
	if (iChange != 0)
	{
		changeAutomatons(iChange);

		m_iCityAutomatonWorkersChange = (m_iCityAutomatonWorkersChange + iChange);
	}
}
#endif

//	--------------------------------------------------------------------------------
int CvCity::getHealRate() const
{
	VALIDATE_OBJECT
	return m_iHealRate;
}

//	--------------------------------------------------------------------------------
void CvCity::changeHealRate(int iChange)
{
	VALIDATE_OBJECT
	m_iHealRate = (m_iHealRate + iChange);
	CvAssert(getHealRate() >= 0);
}

//	--------------------------------------------------------------------------------
int CvCity::GetEspionageModifier() const
{
	VALIDATE_OBJECT
	return m_iEspionageModifier;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeEspionageModifier(int iChange)
{
	VALIDATE_OBJECT
	m_iEspionageModifier = (m_iEspionageModifier + iChange);
}

//	--------------------------------------------------------------------------------
int CvCity::GetEspionageTurnsModifierEnemy() const
{
	VALIDATE_OBJECT
		return m_iEspionageTurnsModifierEnemy;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeEspionageTurnsModifierEnemy(int iChange)
{
	VALIDATE_OBJECT
		m_iEspionageTurnsModifierEnemy = (m_iEspionageTurnsModifierEnemy + iChange);
}

#if defined(MOD_RELIGION_CONVERSION_MODIFIERS)
//	--------------------------------------------------------------------------------
int CvCity::GetConversionModifier() const
{
	VALIDATE_OBJECT
	return m_iConversionModifier;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeConversionModifier(int iChange)
{
	VALIDATE_OBJECT
	m_iConversionModifier = (m_iConversionModifier + iChange);
}
#endif

//	--------------------------------------------------------------------------------
/// Does this city not produce occupied Unhappiness?
bool CvCity::IsNoOccupiedUnhappiness() const
{
	VALIDATE_OBJECT
	return GetNoOccupiedUnhappinessCount() > 0;
}

//	--------------------------------------------------------------------------------
/// Does this city not produce occupied Unhappiness?
int CvCity::GetNoOccupiedUnhappinessCount() const
{
	VALIDATE_OBJECT
	return m_iNoOccupiedUnhappinessCount;
}

//	--------------------------------------------------------------------------------
/// Does this city not produce occupied Unhappiness?
void CvCity::ChangeNoOccupiedUnhappinessCount(int iChange)
{
	VALIDATE_OBJECT
	if (iChange != 0)
		m_iNoOccupiedUnhappinessCount += iChange;
}


#if defined(HH_MOD_BUILDINGS_FRUITLESS_PILLAGE)
//	--------------------------------------------------------------------------------
/// see CvUnit@ CvUnit::pillage()
bool CvCity::IsLocalGainlessPillage() const
{
	VALIDATE_OBJECT
	return m_iLocalGainlessPillageCount > 0;
}

//	--------------------------------------------------------------------------------
/// How many sources proof this city against the looting from a pillage of its tiles?
void CvCity::ChangeLocalGainlessPillageCount(int iChange)
{
	VALIDATE_OBJECT
	if (iChange != 0)
		m_iLocalGainlessPillageCount += iChange;
}
#endif
//	--------------------------------------------------------------------------------
int CvCity::getFood() const
{
	VALIDATE_OBJECT
	return m_iFood / 100;
}

//	--------------------------------------------------------------------------------
int CvCity::getFoodTimes100() const
{
	VALIDATE_OBJECT
	return m_iFood;
}


//	--------------------------------------------------------------------------------
void CvCity::setFood(int iNewValue)
{
	VALIDATE_OBJECT
	setFoodTimes100(iNewValue * 100);
}

//	--------------------------------------------------------------------------------
void CvCity::setFoodTimes100(int iNewValue)
{
	VALIDATE_OBJECT
	if (GetID() == g_iCityToTrace)
	{
		OutputDebugString(CvString::format("Turn %d, food %d, delta %d\n", GC.getGame().getGameTurn(), getFood(), iNewValue / 100 - getFood()).c_str());
	}

	if (getFoodTimes100() != iNewValue)
	{
		m_iFood = max(0, iNewValue);
	}
}


//	--------------------------------------------------------------------------------
void CvCity::changeFood(int iChange)
{
	VALIDATE_OBJECT
	setFoodTimes100(getFoodTimes100() + 100 * iChange);
}


//	--------------------------------------------------------------------------------
void CvCity::changeFoodTimes100(int iChange)
{
	VALIDATE_OBJECT
	setFoodTimes100(getFoodTimes100() + iChange);
}

//	--------------------------------------------------------------------------------
int CvCity::getMaxFoodKeptPercent() const
{
	VALIDATE_OBJECT
	return m_iMaxFoodKeptPercent;
}


//	--------------------------------------------------------------------------------
void CvCity::changeMaxFoodKeptPercent(int iChange)
{
	VALIDATE_OBJECT
	m_iMaxFoodKeptPercent = (m_iMaxFoodKeptPercent + iChange);
	CvAssert(getMaxFoodKeptPercent() >= 0);
}


//	--------------------------------------------------------------------------------
int CvCity::getOverflowProduction() const
{
	VALIDATE_OBJECT
	return m_iOverflowProduction / 100;
}


//	--------------------------------------------------------------------------------
void CvCity::setOverflowProduction(int iNewValue)
{
	VALIDATE_OBJECT
	setOverflowProductionTimes100(iNewValue * 100);
}


//	--------------------------------------------------------------------------------
void CvCity::changeOverflowProduction(int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(iChange >= 0, "Production overflow is too low.  Please send a save to Ed.");
	CvAssertMsg(iChange < 250, "Production overflow is too high.  Please send a save to Ed.");
	changeOverflowProductionTimes100(iChange * 100);
}


//	--------------------------------------------------------------------------------
int CvCity::getOverflowProductionTimes100() const
{
	VALIDATE_OBJECT
	return m_iOverflowProduction;
}


//	--------------------------------------------------------------------------------
void CvCity::setOverflowProductionTimes100(int iNewValue)
{
	VALIDATE_OBJECT
	m_iOverflowProduction = iNewValue;
	CvAssert(getOverflowProductionTimes100() >= 0);
}


//	--------------------------------------------------------------------------------
void CvCity::changeOverflowProductionTimes100(int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(iChange >= 0, "Production overflow is too low.  Please send a save to Ed.");
	CvAssertMsg(iChange < 25000, "Production overflow is too high.  Please send a save to Ed.");
	setOverflowProductionTimes100(getOverflowProductionTimes100() + iChange);
}


//	--------------------------------------------------------------------------------
int CvCity::getFeatureProduction() const
{
	VALIDATE_OBJECT
	return m_iFeatureProduction;
}


//	--------------------------------------------------------------------------------
void CvCity::setFeatureProduction(int iNewValue)
{
	VALIDATE_OBJECT
	m_iFeatureProduction = iNewValue;
	CvAssert(getFeatureProduction() >= 0);
}


//	--------------------------------------------------------------------------------
void CvCity::changeFeatureProduction(int iChange)
{
	VALIDATE_OBJECT
	setFeatureProduction(getFeatureProduction() + iChange);
}


//	--------------------------------------------------------------------------------
int CvCity::getMilitaryProductionModifier()	const
{
	VALIDATE_OBJECT
	return m_iMilitaryProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvCity::changeMilitaryProductionModifier(int iChange)
{
	VALIDATE_OBJECT
	m_iMilitaryProductionModifier = (m_iMilitaryProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvCity::getSpaceProductionModifier() const
{
	VALIDATE_OBJECT
	return m_iSpaceProductionModifier;
}


//	--------------------------------------------------------------------------------
void CvCity::changeSpaceProductionModifier(int iChange)
{
	VALIDATE_OBJECT
	m_iSpaceProductionModifier = (m_iSpaceProductionModifier + iChange);
}


//	--------------------------------------------------------------------------------
int CvCity::getFreeExperience() const
{
	VALIDATE_OBJECT
	return m_iFreeExperience;
}


//	--------------------------------------------------------------------------------
void CvCity::changeFreeExperience(int iChange)
{
	VALIDATE_OBJECT
		m_iFreeExperience = (m_iFreeExperience + iChange);
	CvAssert(getFreeExperience() >= 0);
}

//	--------------------------------------------------------------------------------
bool CvCity::CanAirlift() const
{
	int iBuildingClassLoop = 0;
	BuildingClassTypes eBuildingClass;
	CvPlayer& kPlayer = GET_PLAYER(getOwner());

	for (iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)
	{
		eBuildingClass = (BuildingClassTypes)iBuildingClassLoop;

		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
		if (!pkBuildingClassInfo)
		{
			continue;
		}

		BuildingTypes eBuilding = NO_BUILDING;
		// If the option to check for all buildings in a class is enabled, we loop through all buildings in the city
		if (MOD_BUILDINGS_THOROUGH_PREREQUISITES)
		{
			eBuilding = GetCityBuildings()->GetBuildingTypeFromClass((BuildingClassTypes)iBuildingClassLoop);
		}
		else
		{
			eBuilding = (BuildingTypes)kPlayer.getCivilizationInfo().getCivilizationBuildings(eBuildingClass);
		}

		if (eBuilding != NO_BUILDING && (MOD_BUILDINGS_THOROUGH_PREREQUISITES || GetCityBuildings()->GetNumBuilding(eBuilding) > 0)) // slewis - added the NO_BUILDING check for the ConquestDLX scenario which has civ specific wonders
		{
			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
			if (!pkBuildingInfo)
			{
				continue;
			}

			if (pkBuildingInfo->IsAirlift())
			{
				return true;
			}
		}
	}

#if defined(MOD_EVENTS_CITY_AIRLIFT)
	if (MOD_EVENTS_CITY_AIRLIFT) {
		if (GAMEEVENTINVOKE_TESTANY(GAMEEVENT_CityCanAirlift, getOwner(), GetID()) == GAMEEVENTRETURN_TRUE) {
			return true;
		}
	}
#endif				

	return false;
}

//	--------------------------------------------------------------------------------
int CvCity::GetMaxAirUnits() const
{
	VALIDATE_OBJECT
	return m_iMaxAirUnits + GET_PLAYER(getOwner()).getMaxAirUnits();
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeMaxAirUnits(int iChange)
{
	VALIDATE_OBJECT
	m_iMaxAirUnits += iChange;
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvCity::getCitySupplyModifier() const
{
	VALIDATE_OBJECT
	return m_iCitySupplyModifier;
}

//	--------------------------------------------------------------------------------
void CvCity::changeCitySupplyModifier(int iChange)
{
	VALIDATE_OBJECT
	m_iCitySupplyModifier += iChange;
}
//	--------------------------------------------------------------------------------
int CvCity::getCitySupplyFlat() const
{
	VALIDATE_OBJECT
	return m_iCitySupplyFlat;
}

//	--------------------------------------------------------------------------------
void CvCity::changeCitySupplyFlat(int iChange)
{
	VALIDATE_OBJECT
	m_iCitySupplyFlat += iChange;
}
//	--------------------------------------------------------------------------------
int CvCity::getDamageReductionFlat() const
{
	VALIDATE_OBJECT
	return m_iDamageReductionFlat;
}

//	--------------------------------------------------------------------------------
void CvCity::changeDamageReductionFlat(int iChange)
{
	VALIDATE_OBJECT
	m_iDamageReductionFlat += iChange;
}

void CvCity::SetProductionRoutes(bool bValue)
{
	if (m_bAllowsProductionTradeRoutes != bValue)
	{
		m_bAllowsProductionTradeRoutes = bValue;
	}
}
bool CvCity::IsProductionRoutes() const
{
	return m_bAllowsProductionTradeRoutes;
}

void CvCity::SetFoodRoutes(bool bValue)
{
	if (m_bAllowsFoodTradeRoutes != bValue)
	{
		m_bAllowsFoodTradeRoutes = bValue;
	}
}
bool CvCity::IsFoodRoutes() const
{
	return m_bAllowsFoodTradeRoutes;
}

void CvCity::SetAllowPuppetPurchase(bool bValue)
{
	if (m_bAllowPuppetPurchase != bValue)
	{
		m_bAllowPuppetPurchase = bValue;
	}
}
bool CvCity::IsAllowPuppetPurchase() const
{
	return m_bAllowPuppetPurchase;
}
#endif

//	--------------------------------------------------------------------------------
int CvCity::getNukeModifier() const
{
	VALIDATE_OBJECT
	return m_iNukeModifier;
}
//	--------------------------------------------------------------------------------
void CvCity::changeNukeModifier(int iChange)
{
	VALIDATE_OBJECT
	m_iNukeModifier = (m_iNukeModifier + iChange);
}

//	--------------------------------------------------------------------------------
int CvCity::GetTradeRouteTargetBonus() const
{
	VALIDATE_OBJECT
	return m_iTradeRouteTargetBonus;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeTradeRouteTargetBonus(int iChange)
{
	VALIDATE_OBJECT
	m_iTradeRouteTargetBonus += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetTradeRouteRecipientBonus() const
{
	VALIDATE_OBJECT
	return m_iTradeRouteRecipientBonus;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeTradeRouteRecipientBonus(int iChange)
{
	VALIDATE_OBJECT
	m_iTradeRouteRecipientBonus += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetTradeRouteSeaGoldBonus() const
{
	VALIDATE_OBJECT
	return m_iTradeRouteSeaGoldBonus;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeTradeRouteSeaGoldBonus(int iChange)
{
	VALIDATE_OBJECT
	m_iTradeRouteSeaGoldBonus += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetTradeRouteLandGoldBonus() const
{
	VALIDATE_OBJECT
	return m_iTradeRouteLandGoldBonus;
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeTradeRouteLandGoldBonus(int iChange)
{
	VALIDATE_OBJECT
	m_iTradeRouteLandGoldBonus += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetNumTradeRouteBonus() const
{
	VALIDATE_OBJECT
	return m_iNumTradeRouteBonus;
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeNumTradeRouteBonus(int iChange)
{
	VALIDATE_OBJECT
	m_iNumTradeRouteBonus += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetCityConnectionTradeRouteGoldModifier() const
{
	VALIDATE_OBJECT
	return m_iCityConnectionTradeRouteGoldModifier;
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeCityConnectionTradeRouteGoldModifier(int iChange)
{
	VALIDATE_OBJECT
	m_iCityConnectionTradeRouteGoldModifier += iChange;
}

//	--------------------------------------------------------------------------------
bool CvCity::IsResistance() const
{
	VALIDATE_OBJECT
	return GetResistanceTurns() > 0;
}

//	--------------------------------------------------------------------------------
int CvCity::GetResistanceTurns() const
{
	VALIDATE_OBJECT
	return m_iResistanceTurns;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeResistanceTurns(int iChange)
{
	VALIDATE_OBJECT
	if (iChange != 0)
	{
		m_iResistanceTurns += iChange;

		CvInterfacePtr<ICvCity1> pCity = GC.WrapCityPointer(this);
		DLLUI->SetSpecificCityInfoDirty(pCity.get(), CITY_UPDATE_TYPE_BANNER);
	}
}

//	--------------------------------------------------------------------------------
void CvCity::DoResistanceTurn()
{
	VALIDATE_OBJECT
	if (IsResistance())
	{
		ChangeResistanceTurns(-1);
	}
}

//	--------------------------------------------------------------------------------
bool CvCity::IsRazing() const
{
	VALIDATE_OBJECT
	return GetRazingTurns() > 0;
}

//	--------------------------------------------------------------------------------
int CvCity::GetRazingTurns() const
{
	VALIDATE_OBJECT
	return m_iRazingTurns;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeRazingTurns(int iChange)
{
	VALIDATE_OBJECT
	if (iChange != 0)
	{
		m_iRazingTurns += iChange;

		CvInterfacePtr<ICvCity1> pCity = GC.WrapCityPointer(this);
		DLLUI->SetSpecificCityInfoDirty(pCity.get(), CITY_UPDATE_TYPE_BANNER);
	}
}

//	--------------------------------------------------------------------------------
bool CvCity::DoRazingTurn()
{
	VALIDATE_OBJECT
	if (IsRazing())
	{
		CvPlayer& kPlayer = GET_PLAYER(getOwner());
		int iPopulationDrop = 1;
		iPopulationDrop *= (100 + kPlayer.GetPlayerTraits()->GetRazeSpeedModifier() + kPlayer.GetRazingSpeedBonus());
		iPopulationDrop /= 100;

		ChangeRazingTurns(-1);
		changePopulation(-iPopulationDrop, true);

		bool bAllowRazingEvents = false;

		//set our lowest 'razing' population so we can't exploit pop growth
		if (getPopulation() < m_iLowestRazingPop)
		{
			m_iLowestRazingPop = getPopulation();
			bAllowRazingEvents = true;
		}

		//don't kill the city on an 'off' turn.
		if (GetRazingTurns() > 0 && getPopulation() <= 0)
			setPopulation(1);

		// Counter has reached 0, disband the City
		if (GetRazingTurns() <= 0 || getPopulation() <= 0)
		{
			CvPlot* pkPlot = plot();

			pkPlot->AddArchaeologicalRecord(CvTypes::getARTIFACT_RAZED_CITY(), getOwner(), getOriginalOwner());

			kPlayer.disband(this);
			GC.getGame().addReplayMessage(REPLAY_MESSAGE_CITY_DESTROYED, getOwner(), "", pkPlot->getX(), pkPlot->getY());
			return true;
		}

#if defined(MOD_BALANCE_CORE)
		PlayerTypes eFormerOwner = getPreviousOwner();
		if (eFormerOwner == NO_PLAYER || eFormerOwner == getOwner() || eFormerOwner == BARBARIAN_PLAYER)
		{
			return false;
		}
		if (GET_PLAYER(eFormerOwner).isMinorCiv() || !GET_PLAYER(eFormerOwner).isAlive())
		{
			return false;
		}

		if (bAllowRazingEvents)
		{
			int iRazeValue = /*175*/ GD_INT_GET(WAR_DAMAGE_LEVEL_CITY_WEIGHT);
			iRazeValue += (getPopulation() * /*150*/ GD_INT_GET(WAR_DAMAGE_LEVEL_INVOLVED_CITY_POP_MULTIPLIER));
			iRazeValue += (getNumWorldWonders() * /*200*/ GD_INT_GET(WAR_DAMAGE_LEVEL_WORLD_WONDER_MULTIPLIER));
			iRazeValue /= max(1, (GetRazingTurns() / 2)); // Divide by half the number of turns left until the city is destroyed

			// Does the owner have a bonus to war score accumulation?
			iRazeValue *= (100 + GET_PLAYER(getOwner()).GetWarScoreModifier());
			iRazeValue /= 100;

			GET_PLAYER(eFormerOwner).ChangeWarValueLost(getOwner(), iRazeValue);

			// Diplomacy penalty for razing cities
			if (GET_PLAYER(getOwner()).isMajorCiv() && GET_PLAYER(eFormerOwner).isMajorCiv())
			{
				int iEra = GET_PLAYER(eFormerOwner).GetCurrentEra();
				if (iEra <= 0)
				{
					iEra = 1;
				}

				GET_PLAYER(eFormerOwner).GetDiplomacyAI()->ChangeCivilianKillerValue(getOwner(), (500 * iEra));
			}

			if (MOD_BALANCE_CORE_MILITARY_PROMOTION_ADVANCED && !GET_PLAYER(getOwner()).IsNoPartisans())
			{
				if (GET_PLAYER(getOwner()).GetSpawnCooldown() < 0)
				{
					GET_PLAYER(getOwner()).SetSpawnCooldown(0);
				}
				else
				{
					GET_PLAYER(getOwner()).ChangeSpawnCooldown(-1);
				}

				if (GET_PLAYER(getOwner()).GetSpawnCooldown() > 0)
				{
					return false;
				}

				//Based on city size
				int iNumRebels = GC.getGame().getSmallFakeRandNum(sqrti(getPopulation()), plot()->GetPlotIndex() + GET_PLAYER(getOwner()).GetPseudoRandomSeed());

				//But min number scaling with era
				if (iNumRebels < GC.getGame().getCurrentEra())
					iNumRebels = GC.getGame().getCurrentEra();

				GET_PLAYER(getOwner()).SetSpawnCooldown(iNumRebels * 2);

				if (GET_TEAM(GET_PLAYER(eFormerOwner).getTeam()).isAtWar(getTeam()))
				{
					bool bNotification = GC.getGame().DoSpawnUnitsAroundTargetCity(eFormerOwner, this, iNumRebels, true, false, false, true);
					if (bNotification)
					{
						//the former owner hates the razing and wants it back
						if (!GET_PLAYER(eFormerOwner).GetTacticalAI()->IsInFocusArea(plot()))
							GET_PLAYER(eFormerOwner).GetTacticalAI()->AddFocusArea(plot(), 2, /*5*/ GD_INT_GET(AI_TACTICAL_MAP_TEMP_ZONE_TURNS));

						CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
						if (pNotifications)
						{
							Localization::String strMessage(GetLocalizedText("TXT_KEY_NOTIFICATION_PARTISANS_NEAR_RAZING_CITY", getName()));

							Localization::String strSummary(GetLocalizedText("TXT_KEY_NOTIFICATION_PARTISANS_NEAR_RAZING_CITY_S", getName()));
							pNotifications->Add(NOTIFICATION_CITY_REVOLT_POSSIBLE, strMessage.toUTF8(), strSummary.toUTF8(), getX(), getY(), -1);
						}
						CvNotifications* pNotifications2 = GET_PLAYER(eFormerOwner).GetNotifications();
						if (pNotifications2)
						{
							Localization::String strMessage(GetLocalizedText("TXT_KEY_NOTIFICATION_FRIENDLY_PARTISANS_NEAR_RAZING_CITY", getName()));

							Localization::String strSummary(GetLocalizedText("TXT_KEY_NOTIFICATION_FRIENDLY_PARTISANS_NEAR_RAZING_CITY_S", getName()));
							pNotifications2->Add(NOTIFICATION_GENERIC, strMessage.toUTF8(), strSummary.toUTF8(), getX(), getY(), -1);
						}
						if (GC.getLogging() && GC.getAILogging())
						{
							CvString strLogString;
							strLogString.Format("Unfriendly Partisans near %s. Number: %d.", getName().c_str(), iNumRebels);
							GET_PLAYER(getOwner()).GetHomelandAI()->LogHomelandMessage(strLogString);
						}
					}
				}
				else if (!GC.getGame().isOption(GAMEOPTION_NO_BARBARIANS) && GC.getGame().getGameTurn() >= GC.getGame().GetBarbarianReleaseTurn())
				{
					CvBarbarians::SpawnBarbarianUnits(plot(), iNumRebels, BARB_SPAWN_PARTISANS);
					CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
					if (pNotifications)
					{
						Localization::String strMessage(GetLocalizedText("TXT_KEY_NOTIFICATION_PARTISANS_NEAR_RAZING_CITY", getName()));

						Localization::String strSummary(GetLocalizedText("TXT_KEY_NOTIFICATION_PARTISANS_NEAR_RAZING_CITY_S", getName()));
						pNotifications->Add(NOTIFICATION_CITY_REVOLT_POSSIBLE, strMessage.toUTF8(), strSummary.toUTF8(), getX(), getY(), -1);
					}
					if (GC.getLogging() && GC.getAILogging())
					{
						CvString strLogString;
						strLogString.Format("Unfriendly Partisans near %s. Number: %d.", getName().c_str(), iNumRebels);
						GET_PLAYER(getOwner()).GetHomelandAI()->LogHomelandMessage(strLogString);
					}
				}
			}
		}
#endif
	}

	return false;
}

/// Has this City been taken from its owner?
//	--------------------------------------------------------------------------------
bool CvCity::IsOccupied() const
{
	VALIDATE_OBJECT

	// If we're a puppet then we don't count as an occupied city
	if (IsPuppet())
		return false;

	return m_bOccupied;
}

//	--------------------------------------------------------------------------------
/// Has this City been taken from its owner?
void CvCity::SetOccupied(bool bValue)
{
	VALIDATE_OBJECT
	if (IsOccupied() != bValue)
	{
		m_bOccupied = bValue;
	}
}

//	--------------------------------------------------------------------------------
/// Has this City been turned into a puppet by someone capturing it?
bool CvCity::IsPuppet() const
{
	VALIDATE_OBJECT
	return m_bPuppet;
}

//	--------------------------------------------------------------------------------
/// Has this City been turned into a puppet by someone capturing it?
void CvCity::SetPuppet(bool bValue)
{
	VALIDATE_OBJECT
	m_bPuppet = bValue;

	if (bValue)
	{
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityPuppeted, getOwner(), GetID());

		if (IsNoWarmongerYet())
		{
			PlayerTypes eFormerOwner = getPreviousOwner();
			if (eFormerOwner != NO_PLAYER)
			{
				CvDiplomacyAIHelpers::ApplyWarmongerPenalties(this, getOwner(), eFormerOwner);
				SetNoWarmonger(false);
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Turn this City into a puppet
void CvCity::DoCreatePuppet()
{
	VALIDATE_OBJECT
	if (IsRazing())
		return;

	// Turn this off - used to display info for annex/puppet/raze popup
	SetIgnoreCityForHappiness(false);

	SetPuppet(true);

	setProductionAutomated(true, true);

	// Remove any buildings that are not applicable to puppets (but might have been earned through traits/policies)
	for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		BuildingTypes eBuilding = (BuildingTypes)iI;
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
		if (pkBuildingInfo)
		{
			if (pkBuildingInfo->IsNoOccupiedUnhappiness())
			{
				GetCityBuildings()->SetNumFreeBuilding(eBuilding, 0);
			}
		}
	}

	UpdateAllNonPlotYields(true);

	ResetHappinessFromEmpire();
	GET_PLAYER(getOwner()).CalculateNetHappiness();

	GET_PLAYER(getOwner()).DoUpdateNextPolicyCost();

	DLLUI->setDirty(CityInfo_DIRTY_BIT, true);
	DLLUI->setDirty(GameData_DIRTY_BIT, true);
}

//	--------------------------------------------------------------------------------
/// Un-puppet a City and force it into the empire
void CvCity::DoAnnex(bool bRaze)
{
	VALIDATE_OBJECT

	if (!bRaze && GET_PLAYER(getOwner()).GetPlayerTraits()->IsNoAnnexing())
	{
		if (!IsPuppet())
			DoCreatePuppet();

		return;
	}

	// Turn this off - used to display info for annex/puppet/raze popup
	if (!isHuman())
		clearOrderQueue();

	// Apply warmongering
	if (IsNoWarmongerYet())
	{
		PlayerTypes eFormerOwner = getPreviousOwner();
		if (eFormerOwner != NO_PLAYER)
		{
			CvDiplomacyAIHelpers::ApplyWarmongerPenalties(this, getOwner(), eFormerOwner);
			SetNoWarmonger(false);
		}
	}

	//Immediate Annex? Bonus for Courthouse
	if (MOD_BALANCE_CORE_BUILDING_INVESTMENTS && !IsPuppet() && !GET_PLAYER(getOwner()).GetPlayerTraits()->IsNoAnnexing())
	{
		for (int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
		{
			const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

			if (pkBuildingInfo && pkBuildingInfo->IsNoOccupiedUnhappiness())
			{
				const BuildingClassTypes eBuildingClass = (BuildingClassTypes)(pkBuildingInfo->GetBuildingClassType());
				if (eBuildingClass != NO_BUILDINGCLASS)
				{
					SetBuildingInvestment(eBuildingClass, true);
				}
			}
		}
		if (IsResistance())
		{
			int iResistanceTurns = GetResistanceTurns();
			iResistanceTurns /= 2;
			ChangeResistanceTurns(-iResistanceTurns);
		}
	}

	SetPuppet(false);

	DoUpdateCheapestPlotInfluenceDistance(); // fix for extremely high cost of the first tile

	setProductionAutomated(false, true);
	UpdateAllNonPlotYields(true);

	if (MOD_API_ACHIEVEMENTS)
	{
		bool bUsingXP1Scenario1 = gDLL->IsModActivated(CIV5_XP1_SCENARIO1_MODID);
		if (!bRaze && !bUsingXP1Scenario1 && GET_PLAYER(getOwner()).isHuman() && getOriginalOwner() != GetID() && GET_PLAYER(getOriginalOwner()).isMinorCiv() && !GC.getGame().isGameMultiPlayer())
		{
			gDLL->UnlockAchievement(ACHIEVEMENT_CITYSTATE_ANNEX);
		}
	}

	// Update happiness
	SetIgnoreCityForHappiness(false);
	if (!bRaze)
		GET_PLAYER(getOwner()).CalculateNetHappiness();

	GET_PLAYER(getOwner()).DoUpdateNextPolicyCost();

	DLLUI->setDirty(CityInfo_DIRTY_BIT, true);
	DLLUI->setDirty(GameData_DIRTY_BIT, true);
}

int CvCity::GetHappinessFromPolicies(int iPopMod) const
{
	int iTotalHappiness = 0;
	CvPlayer& kPlayer = GET_PLAYER(m_eOwner);

	int iHappinessPerGarrison = kPlayer.GetHappinessPerGarrisonedUnit();
	if (iHappinessPerGarrison > 0 && HasGarrison())
	{
		iTotalHappiness += iHappinessPerGarrison;
	}

	if (kPlayer.GetHappinessPerXGreatWorks() != 0)
	{
		int iGW = GetCityBuildings()->GetNumGreatWorks();
		iGW /= kPlayer.GetHappinessPerXGreatWorks();
		iTotalHappiness += iGW;
	}

	int iTotalPop = getPopulation() + iPopMod;

	if (MOD_BALANCE_CORE_HAPPINESS)
	{
		int iHappinessPerXPopulationGlobal = kPlayer.GetHappinessPerXPopulationGlobal();

		if (iHappinessPerXPopulationGlobal > 0)
		{
			if (iTotalPop > 0)
			{
				iTotalHappiness += (iTotalPop / iHappinessPerXPopulationGlobal);
			}
		}
	}

	if (isCapital())
	{
		iTotalHappiness += kPlayer.GetPlayerPolicies()->GetNumericModifier(POLICYMOD_EXTRA_HAPPINESS);

		if (!MOD_BALANCE_CORE_HAPPINESS)
		{
			int iHappinessPerXPopulationGlobal = kPlayer.GetHappinessPerXPopulationGlobal();

			if (iHappinessPerXPopulationGlobal > 0)
			{
				if (iTotalPop > 0)
				{
					iTotalHappiness += (iTotalPop / iHappinessPerXPopulationGlobal);
				}
			}
		}

		if (kPlayer.GetExtraHappinessPerXPoliciesFromPolicies() > 0)
		{
			iTotalHappiness += kPlayer.GetPlayerPolicies()->GetNumPoliciesOwned() / kPlayer.GetExtraHappinessPerXPoliciesFromPolicies();
		}

		// Increase from num policies -- MOVE THIS CODE (and provide a new tool tip string) if we ever get happiness per X policies to something beside a building
		if (kPlayer.GetExtraHappinessPerXPolicies() > 0)
		{
			iTotalHappiness += kPlayer.GetPlayerPolicies()->GetNumPoliciesOwned() / kPlayer.GetExtraHappinessPerXPolicies();
		}
	}

	if (kPlayer.GetHappfromXSpecialists() > 0)
	{
		int iSpecialistPopulation = GetCityCitizens()->GetTotalSpecialistCount();
		if (iSpecialistPopulation > 0)
		{
			int iHappinessPerPop = /*100*/ GD_INT_GET(UNHAPPINESS_PER_SPECIALIST);
			int iHappinessSpecialists = GET_PLAYER(getOwner()).GetHappfromXSpecialists();

			//Can't give more free happiness than specialists.
			if (iSpecialistPopulation > iHappinessSpecialists)
			{
				iSpecialistPopulation = iHappinessSpecialists;
			}
			if (iSpecialistPopulation > 0 && iHappinessPerPop > 0)
			{
				iSpecialistPopulation *= iHappinessPerPop;
				iSpecialistPopulation /= 100;

				iTotalHappiness += iSpecialistPopulation;
			}
		}
	}

	iTotalHappiness += kPlayer.GetPlayerPolicies()->GetNumericModifier(POLICYMOD_EXTRA_HAPPINESS_PER_CITY) + kPlayer.GetExtraHappinessPerCity();

	int iHappinessPerXPopulation = kPlayer.GetHappinessPerXPopulation();

	if (iHappinessPerXPopulation > 0 && !IsPuppet())
	{
		int iExtraHappiness = iTotalPop / iHappinessPerXPopulation;
		iTotalHappiness += iExtraHappiness;
	}

	if (kPlayer.GetHappinessPerActiveTradeRoute() > 0)
	{
		iTotalHappiness += (kPlayer.GetTrade()->GetNumberOfTradeRoutesFromCity(this) * kPlayer.GetHappinessPerActiveTradeRoute());
	}

	return iTotalHappiness;
}

int CvCity::GetHappinessFromReligion() const
{
	return m_iReligionHappiness;
}
void CvCity::UpdateHappinessFromReligion()
{
	// Follower beliefs
	int iHappinessFromReligion = 0;
	ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
	BeliefTypes eSecondaryPantheon = NO_BELIEF;
	if (eMajority != NO_RELIGION)
	{
		eSecondaryPantheon = GetCityReligions()->GetSecondaryReligionPantheonBelief();

		int iFollowers = GetCityReligions()->GetNumFollowers(eMajority);
		int iBuildingHappiness = 0;

		const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
		if (pReligion)
		{
			iHappinessFromReligion += pReligion->m_Beliefs.GetHappinessPerCity(getPopulation(), getOwner(), GET_PLAYER(getOwner()).getCity(GetID()));
			if (eSecondaryPantheon != NO_BELIEF && getPopulation() >= GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetMinPopulation())
			{
				iHappinessFromReligion += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetHappinessPerCity();
			}
			if (plot()->isRiver())
			{
				iHappinessFromReligion += pReligion->m_Beliefs.GetRiverHappiness(getOwner(), GET_PLAYER(getOwner()).getCity(GetID()));
				if (eSecondaryPantheon != NO_BELIEF)
				{
					iHappinessFromReligion += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetRiverHappiness();
				}
			}

			// Buildings
			const std::vector<BuildingTypes>& vBuildings = GetCityBuildings()->GetAllBuildingsHere();
			for (size_t jJ = 0; jJ < vBuildings.size(); jJ++)
			{
				BuildingTypes eBuilding = vBuildings[jJ];
				CvBuildingEntry* pkInfo = GC.getBuildingInfo(eBuilding);
				if (pkInfo)
				{
					BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkInfo->GetBuildingClassType();
					iBuildingHappiness += (pReligion->m_Beliefs.GetBuildingClassHappiness(eBuildingClass, iFollowers, getOwner(), this) * GetCityBuildings()->GetNumBuilding(eBuilding));
				}
			}

			iHappinessFromReligion += iBuildingHappiness;

			int iConvertHappiness = pReligion->m_Beliefs.GetFullyConvertedHappiness(getOwner(), this, false);
			if (iConvertHappiness > 0)
			{
				if (GetCityReligions()->GetFollowersOtherReligions(eMajority) <= 0)
					iHappinessFromReligion += iConvertHappiness;
			}
		}
	}

#if defined(MOD_RELIGION_PERMANENT_PANTHEON)
	// Mod for civs keeping their pantheon belief forever
	if (MOD_RELIGION_PERMANENT_PANTHEON)
	{
		if (GC.getGame().GetGameReligions()->HasCreatedPantheon(getOwner()))
		{
			const CvReligion* pPantheon = GC.getGame().GetGameReligions()->GetReligion(RELIGION_PANTHEON, getOwner());
			BeliefTypes ePantheonBelief = GC.getGame().GetGameReligions()->GetBeliefInPantheon(getOwner());
			if (pPantheon != NULL && ePantheonBelief != NO_BELIEF && ePantheonBelief != eSecondaryPantheon)
			{
				const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eMajority, getOwner());
				if (pReligion == NULL || (pReligion != NULL && !pReligion->m_Beliefs.IsPantheonBeliefInReligion(ePantheonBelief, eMajority, getOwner()))) // check that the our religion does not have our belief, to prevent double counting
				{
					iHappinessFromReligion += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetHappinessPerCity();
					if (plot()->isRiver())
					{
						iHappinessFromReligion += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetRiverHappiness();
					}
				}
			}
		}
	}
#endif

	if (m_iReligionHappiness != iHappinessFromReligion)
		m_iReligionHappiness = iHappinessFromReligion;
}

void CvCity::UpdateHappinessFromBuildingClasses()
{
	CvPlayer& kPlayer = GET_PLAYER(m_eOwner);
	int iTotalHappiness = 0;
	// Building Class Combo Mods
	int iSpecialBuildingHappiness = 0;

	const std::vector<BuildingTypes>& vBuildings = GetCityBuildings()->GetAllBuildingsHere();
	for (size_t jJ = 0; jJ < vBuildings.size(); jJ++)
	{
		BuildingTypes eBuildingA = vBuildings[jJ];

		if (GetCityBuildings()->GetNumBuilding(eBuildingA) <= 0)
			continue;

		CvBuildingEntry* pkBuildingA = GC.getBuildingInfo(eBuildingA);
		if (!pkBuildingA)
			continue;

		for (size_t kK = 0; kK < vBuildings.size(); kK++)
		{
			BuildingTypes eBuildingB = vBuildings[kK];

			if (GetCityBuildings()->GetNumBuilding(eBuildingB) <= 0)
				continue;

			CvBuildingEntry* pkBuildingB = GC.getBuildingInfo(eBuildingB);
			if (!pkBuildingB)
				continue;

			BuildingClassTypes eBuildingClassB = (BuildingClassTypes)pkBuildingB->GetBuildingClassType();

			int iHappinessPerBuilding = pkBuildingA->GetBuildingClassLocalHappiness(eBuildingClassB);
			if (iHappinessPerBuilding > 0)
				iSpecialBuildingHappiness += iHappinessPerBuilding;
		}
	}

	iTotalHappiness += iSpecialBuildingHappiness;

	// Policy Building Mods
	int iSpecialPolicyBuildingHappiness = 0;
	for (size_t jJ = 0; jJ < vBuildings.size(); jJ++)
	{
		BuildingTypes eBuilding = vBuildings[jJ];
		CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
		if (!pkBuilding)
			continue;

		int iHappinessMod = kPlayer.GetPlayerPolicies()->GetBuildingClassHappinessModifier(pkBuilding->GetBuildingClassType());
		if (iHappinessMod != 0)
			iSpecialPolicyBuildingHappiness += iHappinessMod * GetCityBuildings()->GetNumBuilding(eBuilding);
	}

	iTotalHappiness += iSpecialPolicyBuildingHappiness;

	// Building Class Mods
	iSpecialBuildingHappiness = 0;
	if (!MOD_BUILDINGS_THOROUGH_PREREQUISITES)
	{
		for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
		{
			BuildingClassTypes eBuildingClass = (BuildingClassTypes)iI;
			CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
			if (!pkBuildingClassInfo)
			{
				continue;
			}

			BuildingTypes eBuilding = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(eBuildingClass);
			bool bVenice = kPlayer.GetPlayerTraits()->IsNoAnnexing();
			int iNumTotal = kPlayer.countNumBuildings(eBuilding) - (MOD_BALANCE_CORE_PUPPET_CHANGES && !bVenice ? kPlayer.countNumBuildingsInPuppets(eBuilding) : 0);

			if (eBuilding != NO_BUILDING && iNumTotal > 0)
			{
				CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
				if (pkBuilding)
				{
					for (int jJ = 0; jJ < GC.getNumBuildingClassInfos(); jJ++)
					{
						BuildingClassTypes eBuildingClassThatGivesHappiness = (BuildingClassTypes)jJ;
						int iHappinessPerBuilding = pkBuilding->GetBuildingClassHappiness(eBuildingClassThatGivesHappiness) * iNumTotal;
						if (iHappinessPerBuilding > 0)
						{
							BuildingTypes eBuildingThatGivesHappiness = (BuildingTypes)getCivilizationInfo().getCivilizationBuildings(eBuildingClassThatGivesHappiness);
							if (eBuildingThatGivesHappiness != NO_BUILDING)
							{
								int iNumTotal2 = GetCityBuildings()->GetNumBuilding(eBuildingThatGivesHappiness);

								iSpecialBuildingHappiness += iHappinessPerBuilding * iNumTotal2;
							}
						}
					}
				}
			}
		}
	}
	else
	{
		for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
		{
			BuildingTypes eBuilding = (BuildingTypes)iI;
			if (eBuilding == NO_BUILDING)
			{
				continue;
			}
			bool bVenice = kPlayer.GetPlayerTraits()->IsNoAnnexing();
			int iNumTotal = kPlayer.countNumBuildings(eBuilding) - (MOD_BALANCE_CORE_PUPPET_CHANGES && !bVenice ? kPlayer.countNumBuildingsInPuppets(eBuilding) : 0);

			if (iNumTotal > 0)
			{
				CvBuildingEntry* pkBuilding = GC.getBuildingInfo(eBuilding);
				if (pkBuilding)
				{
					for (int jJ = 0; jJ < GC.getNumBuildingClassInfos(); jJ++)
					{
						BuildingClassTypes eBuildingClassThatGivesHappiness = (BuildingClassTypes)jJ;
						int iHappinessPerBuilding = pkBuilding->GetBuildingClassHappiness(eBuildingClassThatGivesHappiness) * iNumTotal;
						if (iHappinessPerBuilding > 0)
						{
							int iNumTotal2 = GetCityBuildings()->GetNumBuildingClass(eBuildingClassThatGivesHappiness);

							iSpecialBuildingHappiness += iHappinessPerBuilding * iNumTotal2;
						}
					}
				}
			}
		}
	}

	iTotalHappiness += iSpecialBuildingHappiness;

	if (m_iBuildingClassHappiness != iTotalHappiness)
		m_iBuildingClassHappiness = iTotalHappiness;
}
int CvCity::GetHappinessFromBuildingClasses() const
{
	return m_iBuildingClassHappiness;
}
//	--------------------------------------------------------------------------------
int CvCity::GetLocalHappiness(int iPopMod, bool bExcludeEmpireContributions) const
{
	if (MOD_BALANCE_VP)
	{
		// Puppets produce no Happiness (except Venice)
		if (CityStrategyAIHelpers::IsTestCityStrategy_IsPuppetAndAnnexable(this))
			return 0;

		if (IsRazing() || IsResistance() || (IsOccupied() && !IsNoOccupiedUnhappiness()))
			return 0;
	}

	CvPlayer& kPlayer = GET_PLAYER(m_eOwner);
	int iLocalHappiness = 0;

	if (!bExcludeEmpireContributions)
		iLocalHappiness += GetHappinessFromEmpire();

	iLocalHappiness += GetBaseHappinessFromBuildings() + GetHappinessFromBuildingClasses();
	iLocalHappiness += GetHappinessFromPolicies(iPopMod);
	iLocalHappiness += GetHappinessFromReligion();
	iLocalHappiness += GetUnmoddedHappinessFromBuildings(); // misc. happiness

	if (isCapital())
	{
		if (MOD_BALANCE_VP && GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && kPlayer.isHuman())
			iLocalHappiness += kPlayer.getHandicapInfo().getHappinessDefaultCapital() * 2;
		else if (kPlayer.isHuman())
			iLocalHappiness += kPlayer.getHandicapInfo().getHappinessDefaultCapital();
		else
			iLocalHappiness += kPlayer.getHandicapInfo().getHappinessDefaultCapital() + GC.getGame().getHandicapInfo().getAIHappinessDefaultCapital();
	}

	if (MOD_BALANCE_CORE_JFD)
	{
		int iCrime = GetYieldFromCrime(YIELD_JFD_CRIME);
		int iDevelopment = GetYieldFromDevelopment(YIELD_JFD_CRIME);
		iLocalHappiness += iCrime + iDevelopment;
	}

	return iLocalHappiness;
}

CvString CvCity::GetCityHappinessBreakdown()
{
	CvPlayer& kPlayer = GET_PLAYER(m_eOwner);

	// Puppets produce no Happiness (except Venice)
	if (CityStrategyAIHelpers::IsTestCityStrategy_IsPuppetAndAnnexable(this))
		return GetLocalizedText("TXT_KEY_EO_CITY_LOCAL_HAPPINESS_EXPLANATION_PUPPET");

	if (IsRazing() || IsResistance() || (IsOccupied() && !IsNoOccupiedUnhappiness()))
		return GetLocalizedText("TXT_KEY_EO_CITY_LOCAL_HAPPINESS_EXPLANATION_PUPPET");

	int iEmpire = GetHappinessFromEmpire();
	int iBuildings = GetBaseHappinessFromBuildings() + GetHappinessFromBuildingClasses();
	int iPolicies = GetHappinessFromPolicies();
	int iReligion = GetHappinessFromReligion();
	int iOther = GetUnmoddedHappinessFromBuildings(); // misc. happiness
	int iHandicap = 0;
	if (isCapital())
	{
		if (MOD_BALANCE_VP && kPlayer.isHuman() && GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE))
			iHandicap += kPlayer.getHandicapInfo().getHappinessDefaultCapital() * 2;
		else if (kPlayer.isHuman())
			iHandicap += kPlayer.getHandicapInfo().getHappinessDefaultCapital();
		else
			iHandicap += kPlayer.getHandicapInfo().getHappinessDefaultCapital() + GC.getGame().getHandicapInfo().getAIHappinessDefaultCapital();
	}

	int iTotal = iEmpire + iBuildings + iPolicies + iReligion + iOther + iHandicap;

	CvString strTooltip = GetLocalizedText("TXT_KEY_EO_CITY_LOCAL_HAPPINESS_EXPLANATION");
	strTooltip += "[NEWLINE][NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_LOCAL_HAPPINESS", iTotal);

	if (iEmpire != 0)
		strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_HAPPY_EMPIRE_CBO", iEmpire);
	if (iBuildings != 0)
		strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_HAPPY_BUILDINGS_CBO", iBuildings);
	if (iPolicies != 0)
		strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_HAPPY_POLICY_CBO", iPolicies);
	if (iReligion != 0)
		strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_HAPPY_RELIGION_CBO", iReligion);
	if (iOther != 0)
		strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_HAPPY_OTHER_CBO", iOther);
	if (iHandicap != 0)
		strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_HAPPY_HANDICAP_CBO", iHandicap);

	strTooltip += GetPotentialHappinessWithGrowth();
	return strTooltip;
}

CvString CvCity::GetPotentialHappinessWithGrowth()
{
	int GrowthHappiness = GetPotentialHappinessWithGrowthVal();

	if (GrowthHappiness == 0)
		return "";

	return GetLocalizedText("TXT_KEY_POTENTIAL_HAPPINESS_GROWTH", GrowthHappiness);
}

int CvCity::GetPotentialHappinessWithGrowthVal() const
{
	return GetLocalHappiness(1) - GetLocalHappiness();
}

int CvCity::updateNetHappiness()
{
	CvPlayer& kPlayer = GET_PLAYER(getOwner());
	if (!kPlayer.isMajorCiv())
	{
		m_iHappinessDelta = 0;
		return 0;
	}

	if (IsRazing() || IsResistance())
	{
		m_iHappinessDelta = -getPopulation();
		return m_iHappinessDelta;
	}
	else if (IsPuppet())
	{
		m_iHappinessDelta = 0;
		return 0;
	}

	m_iHappinessDelta = GetLocalHappiness() - GetUnhappinessAggregated();
	return m_iHappinessDelta;
}

int CvCity::getUnhappinessFromSpecialists(int iSpecialists) const
{
	CvPlayer& kPlayer = GET_PLAYER(getOwner());

	float iUnhappinessPerPop = 0;
	//Less unhappiness from specialists....
	if (MOD_BALANCE_VP)
	{
		iUnhappinessPerPop = (float)/*100*/ GD_INT_GET(UNHAPPINESS_PER_SPECIALIST);
		int iNoHappinessSpecialists = 0;
		if (iSpecialists > 0)
		{
			//...in capital?
			if (isCapital())
			{
				iNoHappinessSpecialists += kPlayer.GetNoUnhappfromXSpecialistsCapital();
			}
			//...elsewhere?	
			iNoHappinessSpecialists += kPlayer.GetNoUnhappfromXSpecialists() + GetNoUnhappfromXSpecialists();
		}
		//Can't give more free happiness than specialists.
		if (iNoHappinessSpecialists > iSpecialists)
		{
			iNoHappinessSpecialists = iSpecialists;
		}
		if (iNoHappinessSpecialists > 0)
		{
			iSpecialists -= iNoHappinessSpecialists;
		}
	}

	// No Unhappiness from Specialist Pop? (Policies, etc.)
	if (kPlayer.isHalfSpecialistUnhappiness())
	{
		iSpecialists++; // Round up
		iSpecialists /= 2;
	}

	return (int)(iSpecialists * iUnhappinessPerPop) / 100;
}

int CvCity::GetUnhappinessAggregated() const
{
	int iUnhappiness = 0;
	int iPopulation = getPopulation();

	if (IsRazing() || IsResistance())
	{
		return iPopulation;
	}
	else if (IsPuppet())
	{
		int iSpecialists = GetCityCitizens()->GetTotalSpecialistCount();
		return getUnhappinessFromSpecialists(iSpecialists) + (iPopulation / max(1, /*4*/ GD_INT_GET(UNHAPPINESS_PER_X_PUPPET_CITIZENS)));
	}

	if (MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS)
		iPopulation = INT_MAX;

	// Some of these calls are expensive, so avoid doing them if we've already reached the cap
	// Order is also nonstandard to save on performance
	int iSource = GetUnhappinessFromOccupation();

	if (iUnhappiness < iPopulation)
	{
		iSource = GetUnhappinessFromEmpire();
		if (iSource > 0)
			iUnhappiness += iSource;
	}

	if (iUnhappiness < iPopulation)
	{
		iSource = GetUnhappinessFromIsolation();
		if (iSource > 0)
			iUnhappiness += iSource;
	}

	if (iUnhappiness < iPopulation)
	{
		iSource = GetUnhappinessFromReligiousUnrest();
		if (iSource > 0)
			iUnhappiness += iSource;
	}

	if (iUnhappiness < iPopulation)
	{
		iSource = GetUnhappinessFromPillagedTiles();
		if (iSource > 0)
			iUnhappiness += iSource;
	}

	if (iUnhappiness < iPopulation)
	{
		iSource = GetPoverty(false);
		if (iSource > 0)
			iUnhappiness += iSource;
	}

	if (iUnhappiness < iPopulation)
	{
		iSource = GetIlliteracy(false);
		if (iSource > 0)
			iUnhappiness += iSource;
	}

	if (iUnhappiness < iPopulation)
	{
		iSource = GetBoredom(false);
		if (iSource > 0)
			iUnhappiness += iSource;
	}

	if (iUnhappiness < iPopulation)
	{
		iSource = GetUnhappinessFromFamine();
		if (iSource > 0)
			iUnhappiness += iSource;
	}

	if (iUnhappiness < iPopulation)
	{
		iSource = GetDistress(false);
		if (iSource > 0)
			iUnhappiness += iSource;
	}

	// Unhappiness is capped at city population (except specialists)
	if (iUnhappiness > iPopulation)
		iUnhappiness = iPopulation;

	iSource = getUnhappinessFromSpecialists(GetCityCitizens()->GetTotalSpecialistCount());
	if (iSource > 0)
		iUnhappiness += iSource;

	return iUnhappiness;
}

CvString CvCity::getPotentialUnhappinessWithGrowth()
{
	int Distress = GetDistress(true) - GetDistress(false);
	int Poverty = GetPoverty(true) - GetPoverty(false);
	int Illiteracy = GetIlliteracy(true) - GetIlliteracy(false);
	int Boredom = GetBoredom(true) - GetBoredom(false);

	if (Distress == 0 && Poverty == 0 && Illiteracy == 0 && Boredom == 0)
		return "";

	CvString strTooltip = GetLocalizedText("TXT_KEY_POTENTIAL_UNHAPPINESS_GROWTH");

	if (Distress != 0)
	{
		if (Distress > 0)
			strTooltip = strTooltip + GetLocalizedText("TXT_KEY_POTENTIAL_UNHAPPINESS_DEFENSE", Distress);
		else
			strTooltip = strTooltip + GetLocalizedText("TXT_KEY_POTENTIAL_UNHAPPINESS_DEFENSE_POS", Distress);
	}
	if (Poverty != 0)
	{
		if (Poverty > 0)
			strTooltip = strTooltip + GetLocalizedText("TXT_KEY_POTENTIAL_UNHAPPINESS_GOLD", Poverty);
		else
			strTooltip = strTooltip + GetLocalizedText("TXT_KEY_POTENTIAL_UNHAPPINESS_GOLD_POS", Poverty);
	}
	if (Illiteracy != 0)
	{
		if (Illiteracy > 0)
			strTooltip = strTooltip + GetLocalizedText("TXT_KEY_POTENTIAL_UNHAPPINESS_SCIENCE", Illiteracy);
		else
			strTooltip = strTooltip + GetLocalizedText("TXT_KEY_POTENTIAL_UNHAPPINESS_SCIENCE_POS", Illiteracy);
	}
	if (Boredom != 0)
	{
		if (Boredom > 0)
			strTooltip = strTooltip + GetLocalizedText("TXT_KEY_POTENTIAL_UNHAPPINESS_CULTURE", Boredom);
		else
			strTooltip = strTooltip + GetLocalizedText("TXT_KEY_POTENTIAL_UNHAPPINESS_CULTURE_POS", Boredom);
	}

	return strTooltip;
}

int CvCity::getPotentialUnhappinessWithGrowthVal() const
{
	int Distress = GetDistress(true) - GetDistress(false);
	int Poverty = GetPoverty(true) - GetPoverty(false);
	int Illiteracy = GetIlliteracy(true) - GetIlliteracy(false);
	int Boredom = GetBoredom(true) - GetBoredom(false);

	return Distress + Poverty + Illiteracy + Boredom;
}

int CvCity::GetNumPillagedPlots() const
{
	return m_iPillagedPlots;
}
void CvCity::SetNumPillagedPlots(int iValue)
{
	if (m_iPillagedPlots != iValue)
	{
		m_iPillagedPlots = iValue;
		if (m_iPillagedPlots <= 0)
		{
			m_iPillagedPlots = 0;
		}
	}
}
void CvCity::ChangeNumPillagedPlots(int iValue)
{
	if (iValue != 0)
	{
		m_iPillagedPlots += iValue;
		if (m_iPillagedPlots <= 0)
		{
			m_iPillagedPlots = 0;
		}
	}
}

int CvCity::GetGrowthFromEvent() const
{
	return m_iGrowthEvent;
}
void CvCity::ChangeGrowthFromEvent(int iValue)
{
	m_iGrowthEvent += iValue;
}


int CvCity::GetGrowthFromTourism() const
{
	return m_iGrowthFromTourism;
}
void CvCity::SetGrowthFromTourism(int iValue)
{
	if (m_iGrowthFromTourism != iValue)
	{
		m_iGrowthFromTourism = iValue;
	}
}
void CvCity::ChangeGrowthFromTourism(int iValue)
{
	if (iValue != 0)
	{
		m_iGrowthFromTourism += iValue;
		if (m_iGrowthFromTourism <= 0)
		{
			m_iGrowthFromTourism = 0;
		}
	}
}
void CvCity::UpdateGrowthFromTourism()
{
	int iTotalGrowth = 0;
	CvGameTrade* pGameTrade = GC.getGame().GetGameTrade();
	for (uint ui = 0; ui < pGameTrade->GetNumTradeConnections(); ui++)
	{
		if (pGameTrade->IsTradeRouteIndexEmpty(ui))
		{
			continue;
		}

		if (pGameTrade->GetTradeConnection(ui).m_eConnectionType != TRADE_CONNECTION_INTERNATIONAL)
			continue;

		if (CvGameTrade::GetOriginCity(pGameTrade->GetTradeConnection(ui)) != this)
			continue;

		CvCity* pDestCity = CvGameTrade::GetDestCity(pGameTrade->GetTradeConnection(ui));

		if (pDestCity->getOwner() != NO_PLAYER && GET_PLAYER(pDestCity->getOwner()).isMajorCiv())
		{
			int iGrowthTourism = GET_PLAYER(getOwner()).GetCulture()->GetInfluenceTradeRouteGrowthBonus(pDestCity->getOwner());
			if (iGrowthTourism != 0)
			{
				iTotalGrowth += iGrowthTourism;
			}
		}
	}
	SetGrowthFromTourism(iTotalGrowth);
}
int CvCity::getHappinessDelta() const
{
	return m_iHappinessDelta;
}

//	--------------------------------------------------------------------------------
/// Sum up modifier increases/decreases which apply to all yields
/// Use bForceRecalc when estimating needs after city growth
int CvCity::GetAllNeedsModifier(bool bForceRecalc) const
{
	CvPlayer& kPlayer = GET_PLAYER(getOwner());

	// Increase from being the capital
	int iModifier = isCapital() ? /*25*/ GD_INT_GET(CAPITAL_NEED_MODIFIER) : 0;

	// Increase from tech
	iModifier += bForceRecalc ? kPlayer.GetTechNeedModifier() : GetCachedTechNeedModifier();

	// Decrease from city size
	iModifier += GetCitySizeModifier();

	// Increase from empire size
	iModifier += GetReducedEmpireSizeModifier(bForceRecalc, false);

	// Modifier from difficulty level
	iModifier += kPlayer.isHuman() ? kPlayer.getHandicapInfo().getPopulationUnhappinessMod() : kPlayer.getHandicapInfo().getPopulationUnhappinessMod() + GC.getGame().getHandicapInfo().getAIPopulationUnhappinessMod();

	// Decrease from Carnival (Brazil UA)
	if (GetWeLoveTheKingDayCounter() > 0)
		iModifier += kPlayer.GetPlayerTraits()->GetWLTKDUnhappinessNeedsMod();

	// Decrease from air units that are based here (policy)
	if (kPlayer.GetNeedsModifierFromAirUnits() != 0)
		iModifier += plot()->countNumAirUnits(getTeam(), true) * kPlayer.GetNeedsModifierFromAirUnits() * -1;

	return iModifier;
}

int CvCity::GetCitySizeModifier() const
{
	return getPopulation() * /*0*/ GD_INT_GET(CITY_SIZE_NEED_MODIFIER) / 100;
}

int CvCity::GetEmpireSizeModifier() const
{
	// x% per city, excluding puppets and the capital
	int iNumCitiesMod = (GET_PLAYER(getOwner()).getNumCities() - GET_PLAYER(getOwner()).GetNumPuppetCities() - 1) * /*500*/ GD_INT_GET(EMPIRE_SIZE_NEED_MODIFIER_CITIES) / 100;
	if (iNumCitiesMod < 0)
		iNumCitiesMod = 0;

	// x% per empire pop, excluding puppets
	int iLoop = 0, iPopMod = 0;
	for (CvCity* pLoopCity = GET_PLAYER(getOwner()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(getOwner()).nextCity(&iLoop))
	{
		if (pLoopCity->IsPuppet())
			continue;

		iPopMod += pLoopCity->getPopulation();
	}
	iPopMod *= /*125*/ GD_INT_GET(EMPIRE_SIZE_NEED_MODIFIER_POP);
	iPopMod /= 1000;
	if (iPopMod < 0)
		iPopMod = 0;

	int iEmpireMod = iNumCitiesMod + iPopMod;

	// Scale with map size
	iEmpireMod *= std::min(100, GC.getMap().getWorldInfo().getNumCitiesUnhappinessPercent());
	iEmpireMod /= 100;

	// Difficulty level can modify this
	iEmpireMod *= GET_PLAYER(getOwner()).isHuman() ? 100 + GET_PLAYER(getOwner()).getHandicapInfo().getEmpireSizeUnhappinessMod() : 100 + GET_PLAYER(getOwner()).getHandicapInfo().getEmpireSizeUnhappinessMod() + GC.getGame().getHandicapInfo().getAIEmpireSizeUnhappinessMod();
	iEmpireMod /= 100;

	return std::max(iEmpireMod, 0);
}

int CvCity::GetReducedEmpireSizeModifier(bool bForceRecalc, bool bCityOnly) const
{
	int iEmpireMod = bForceRecalc ? GetEmpireSizeModifier() : GetCachedEmpireSizeModifier();
	int iReduction = GetEmpireSizeModifierReduction(); // negative
	if (!bCityOnly)
		iReduction += GET_PLAYER(getOwner()).GetEmpireSizeModifierReductionGlobal(); // negative

	return range(iEmpireMod + iReduction, 0, iEmpireMod);
}

/// Sum up modifier increases/decreases which are specific to a particular yield
int CvCity::GetNeedModifierForYield(YieldTypes eYield) const
{
	CvPlayer& kPlayer = GET_PLAYER(getOwner());
	int iModifier = 0;

	// Distress = Production + Food, but because Food has a process (Farming), change eYield here for compatibility below
	if (eYield == YIELD_PRODUCTION)
		eYield = YIELD_FOOD;

	switch (eYield)
	{
	case YIELD_FOOD:
	{
		iModifier += GetBasicNeedsMedianModifier(); // Local modifier to the median
		iModifier += kPlayer.GetBasicNeedsMedianModifierGlobal(); // Global modifier to the median
		break;
	}
	case YIELD_GOLD:
	{
		iModifier += GetGoldMedianModifier(); // Local modifier to the median
		iModifier += kPlayer.GetGoldMedianModifierGlobal(); // Global modifier to the median
		break;
	}
	case YIELD_SCIENCE:
	{
		iModifier += GetScienceMedianModifier(); // Local modifier to the median
		iModifier += kPlayer.GetScienceMedianModifierGlobal(); // Global modifier to the median
		break;
	}
	case YIELD_CULTURE:
	{
		iModifier += GetCultureMedianModifier(); // Local modifier to the median
		iModifier += kPlayer.GetCultureMedianModifierGlobal(); // Global modifier to the median
		break;
	}
	case YIELD_FAITH:
	{
		iModifier += GetReligiousUnrestModifier(); // Local modifier
		iModifier += kPlayer.GetReligiousUnrestModifierGlobal(); // Global modifier
		break;
	}
	default: // Invalid input
		return 0;
	}

	// Is there a process running which reduces unhappiness for this need?
	if (getProductionProcess() != NO_PROCESS)
	{
		CvProcessInfo* pkProcessInfo = GC.getProcessInfo(getProductionProcess());
		if (pkProcessInfo)
		{
			iModifier += (pkProcessInfo->getProductionToYieldModifier(eYield) + GetYieldFromProcessModifier(eYield)) * -1;
		}
	}

	return iModifier;
}

int CvCity::GetTotalNeedModifierForYield(YieldTypes eYield, bool bForceRecalc) const
{
	return GetAllNeedsModifier(bForceRecalc) + GetNeedModifierForYield(eYield);
}

/// Sum up modifier increases/decreases that are local to this city
int CvCity::GetCityNeedModifierForYield(YieldTypes eYield) const
{
	CvPlayer& kPlayer = GET_PLAYER(getOwner());

	// Increase from being the capital
	int iModifier = isCapital() ? /*25*/ GD_INT_GET(CAPITAL_NEED_MODIFIER) : 0;

	// Decrease from city size
	iModifier += GetCitySizeModifier();

	// Local decrease of empire size modifier
	iModifier -= GetEmpireSizeModifier() - GetReducedEmpireSizeModifier(false, true);

	// Decrease from Carnival (Brazil UA)
	if (GetWeLoveTheKingDayCounter() > 0)
		iModifier += kPlayer.GetPlayerTraits()->GetWLTKDUnhappinessNeedsMod();

	// Decrease from air units that are based here (policy)
	if (kPlayer.GetNeedsModifierFromAirUnits() != 0)
		iModifier += plot()->countNumAirUnits(getTeam(), true) * kPlayer.GetNeedsModifierFromAirUnits() * -1;

	// Distress = Production + Food, but because Food has a process (Farming), change eYield here for compatibility below
	if (eYield == YIELD_PRODUCTION)
		eYield = YIELD_FOOD;

	switch (eYield) // Get the local modifier for this yield
	{
	case YIELD_FOOD:
		iModifier += GetBasicNeedsMedianModifier();
		break;
	case YIELD_GOLD:
		iModifier += GetGoldMedianModifier();
		break;
	case YIELD_SCIENCE:
		iModifier += GetScienceMedianModifier();
		break;
	case YIELD_CULTURE:
		iModifier += GetCultureMedianModifier();
		break;
	case YIELD_FAITH:
		iModifier += GetReligiousUnrestModifier();
		break;
	default:
		return 0;
	}

	// Is there a process running which reduces unhappiness for this need?
	if (getProductionProcess() != NO_PROCESS)
	{
		CvProcessInfo* pkProcessInfo = GC.getProcessInfo(getProductionProcess());
		if (pkProcessInfo)
		{
			iModifier += (pkProcessInfo->getProductionToYieldModifier(eYield) + GetYieldFromProcessModifier(eYield)) * -1;
		}
	}

	return iModifier;
}

CvString CvCity::GetCityUnhappinessBreakdown(bool bIncludeMedian, bool bCityBanner)
{
	int iPopulation = getPopulation();

	if (IsRazing() || IsResistance())
	{
		CvString strTooltip = GetLocalizedText("TXT_KEY_EO_CITY_LOCAL_UNHAPPINESS", iPopulation, GC.getGame().getGameTurn());

		if (bCityBanner)
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_RESISTANCE", iPopulation);
		else
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_RESISTANCE_UNHAPPINESS", iPopulation);

		return strTooltip;
	}
	else if (IsPuppet())
	{
		int iPuppetUnhappiness = iPopulation / max(1, /*4*/ GD_INT_GET(UNHAPPINESS_PER_X_PUPPET_CITIZENS));
		int iSpecialistUnhappiness = getUnhappinessFromSpecialists(GetCityCitizens()->GetTotalSpecialistCount());
		int iTotalUnhappiness = iPuppetUnhappiness + iSpecialistUnhappiness;
		CvString strTooltip = GetLocalizedText("TXT_KEY_EO_CITY_LOCAL_UNHAPPINESS", iTotalUnhappiness, GC.getGame().getGameTurn());

		if (bCityBanner)
		{
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_PUPPET", iPuppetUnhappiness);
			if (iSpecialistUnhappiness != 0)
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_SPECIALIST", iSpecialistUnhappiness);
		}
		else
		{
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_PUPPET_UNHAPPINESS", iPuppetUnhappiness);
			if (iSpecialistUnhappiness != 0)
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_SPECIALIST_UNHAPPINESS", iSpecialistUnhappiness);
		}

		return strTooltip;
	}

	CvWeightedVector<UnhappyReasons> vReasons;
	int iTotalUnhappiness = 0;
	int iSource = 0;

	iSource = GetUnhappinessFromOccupation();
	if (iSource > 0)
	{
		iTotalUnhappiness += iSource;
		vReasons.push_back(UNHAPPY_REASON_OCCUPIED, iSource);
	}

	iSource = GetUnhappinessFromEmpire();
	if (iSource > 0)
	{
		iTotalUnhappiness += iSource;
		vReasons.push_back(UNHAPPY_REASON_EMPIRE, iSource);
	}

	iSource = GetUnhappinessFromFamine();
	if (iSource > 0)
	{
		iTotalUnhappiness += iSource;
		vReasons.push_back(UNHAPPY_REASON_FAMINE, iSource);
	}

	iSource = GetUnhappinessFromPillagedTiles();
	if (iSource > 0)
	{
		iTotalUnhappiness += iSource;
		vReasons.push_back(UNHAPPY_REASON_PILLAGED_TILES, iSource);
	}

	int iDistress = GetDistress(false);
	if (iDistress > 0)
	{
		iTotalUnhappiness += iDistress;
		vReasons.push_back(UNHAPPY_REASON_DISTRESS, iDistress);
	}

	int iPoverty = GetPoverty(false);
	if (iPoverty > 0)
	{
		iTotalUnhappiness += iPoverty;
		vReasons.push_back(UNHAPPY_REASON_POVERTY, iPoverty);
	}

	int iIlliteracy = GetIlliteracy(false);
	if (iIlliteracy > 0)
	{
		iTotalUnhappiness += iIlliteracy;
		vReasons.push_back(UNHAPPY_REASON_ILLITERACY, iIlliteracy);
	}

	int iBoredom = GetBoredom(false);
	if (iBoredom > 0)
	{
		iTotalUnhappiness += iBoredom;
		vReasons.push_back(UNHAPPY_REASON_BOREDOM, iBoredom);
	}

	int iReligiousUnrest = GetUnhappinessFromReligiousUnrest();
	if (iReligiousUnrest > 0)
	{
		iTotalUnhappiness += iReligiousUnrest;
		vReasons.push_back(UNHAPPY_REASON_RELIGIOUS_UNREST, iReligiousUnrest);
	}

	iSource = GetUnhappinessFromIsolation();
	if (iSource > 0)
	{
		iTotalUnhappiness += iSource;
		vReasons.push_back(UNHAPPY_REASON_ISOLATION, iSource);
	}

	// Unhappiness is capped at city population (except specialists)
	if (iTotalUnhappiness > iPopulation && !MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS)
		iTotalUnhappiness = iPopulation;

	iSource = getUnhappinessFromSpecialists(GetCityCitizens()->GetTotalSpecialistCount());
	if (iSource > 0)
	{
		iTotalUnhappiness += iSource;
		vReasons.push_back(UNHAPPY_REASON_URBANIZATION, iSource);
	}

	// Sort sources of Unhappiness from highest to lowest
	vReasons.StableSortItems();

	CvString strTooltip = GetLocalizedText("TXT_KEY_EO_CITY_LOCAL_UNHAPPINESS", iTotalUnhappiness, GetYieldMediansCachedTurn());

	// City Banner Tooltip - Provide only the quick overview
	if (bCityBanner)
	{
		for (int i = 0; i < vReasons.size(); i++)
		{
			UnhappyReasons eReason = vReasons.GetElement(i);
			int iUnhappyCitizens = vReasons.GetWeight(i);

			switch (eReason)
			{
			case UNHAPPY_REASON_RESISTANCE:
				UNREACHABLE(); // Resistance is handled at the start of the function.
			case UNHAPPY_REASON_OCCUPIED:
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_OCCUPATION", iUnhappyCitizens);
				break;
			case UNHAPPY_REASON_EMPIRE:
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_EMPIRE", iUnhappyCitizens);
				break;
			case UNHAPPY_REASON_FAMINE:
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_STARVING", iUnhappyCitizens);
				break;
			case UNHAPPY_REASON_PILLAGED_TILES:
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_PILLAGED", iUnhappyCitizens);
				break;
			case UNHAPPY_REASON_DISTRESS:
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_UNDEFENDED", iUnhappyCitizens);
				break;
			case UNHAPPY_REASON_POVERTY:
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_POOR", iUnhappyCitizens);
				break;
			case UNHAPPY_REASON_ILLITERACY:
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_UNEDUCATED", iUnhappyCitizens);
				break;
			case UNHAPPY_REASON_BOREDOM:
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_UNCULTURED", iUnhappyCitizens);
				break;
			case UNHAPPY_REASON_RELIGIOUS_UNREST:
			{
				CvString strIcon = "";
				ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
				if (eMajority > RELIGION_PANTHEON)
				{
					strIcon = GC.getReligionInfo(eMajority)->GetIconString();
				}
				if (strIcon != "")
				{
					strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_RELIGION", iUnhappyCitizens, strIcon);
				}
				break;
			}
			case UNHAPPY_REASON_ISOLATION:
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_UNCONNECTED", iUnhappyCitizens);
				break;
			case UNHAPPY_REASON_URBANIZATION:
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_SPECIALIST", iUnhappyCitizens);
				break;
			}
		}

		strTooltip += getPotentialUnhappinessWithGrowth();
		return strTooltip;
	}

	CvPlayer& kPlayer = GET_PLAYER(getOwner());

	// City View Tooltip - Provide detailed information
	// Always sort as follows: Distress / Poverty / Illiteracy / Boredom / Religious Unrest / Highest Score
	int iDistressRaw = GetDistressRaw(false);
	float fBasicNeedsMedian = 0.00f;
	fBasicNeedsMedian += GetBasicNeedsMedian(false, 0) / 100;

	// Below Basic Needs requirement
	if (iDistressRaw > 0)
	{
		// Reduced By
		int iReduction = GetDistressFlatReduction() + kPlayer.GetDistressFlatReductionGlobal();

		// Total Deficit
		float fAmountNeeded = 0.00f, fAmountHave = 0.00f, fDeficit = 0.00f, fAmountForNextReduction = 0.00f;
		fAmountNeeded += fBasicNeedsMedian * iPopulation;
		fAmountHave += ((float)getYieldRateTimes100(YIELD_FOOD, false, false) + (float)getYieldRateTimes100(YIELD_PRODUCTION, false, false)) / 100;
		fDeficit += fAmountNeeded - fAmountHave;

		// Increase by X for -1 Unhappiness
		fAmountForNextReduction += fBasicNeedsMedian * (iPopulation - iDistressRaw + 1) - fAmountHave;

		strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_DISTRESS_UNHAPPINESS", iDistress, fDeficit, iDistressRaw, iReduction, fAmountForNextReduction);
	}
	// Above Basic Needs requirement
	else
	{
		float fAmountNeeded = 0.00f, fSurplus = 0.00f;
		fAmountNeeded += fBasicNeedsMedian * iPopulation;
		fSurplus += (((float)getYieldRateTimes100(YIELD_FOOD, false, false) + (float)getYieldRateTimes100(YIELD_PRODUCTION, false, false)) / 100) - fAmountNeeded;

		strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_DISTRESS_UNHAPPINESS_SURPLUS", fSurplus);
	}


	int iPovertyRaw = GetPovertyRaw(false);
	float fGoldMedian = 0.00f;
	fGoldMedian += GetGoldMedian(false, 0) / 100;

	// Below Gold requirement
	if (iPovertyRaw > 0)
	{
		// Reduced By
		int iReduction = GetPovertyFlatReduction() + kPlayer.GetPovertyFlatReductionGlobal();

		// Total Deficit
		float fAmountNeeded = 0.00f, fAmountHave = 0.00f, fDeficit = 0.00f, fAmountForNextReduction = 0.00f;
		fAmountNeeded += fGoldMedian * iPopulation;
		fAmountHave += (float)getYieldRateTimes100(YIELD_GOLD, false, false) / 100;
		fDeficit += fAmountNeeded - fAmountHave;

		// Increase by X for -1 Unhappiness
		fAmountForNextReduction += fGoldMedian * (iPopulation - iPovertyRaw + 1) - fAmountHave;

		strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_POVERTY_UNHAPPINESS", iPoverty, fDeficit, iPovertyRaw, iReduction, fAmountForNextReduction);
	}
	// Above Gold requirement
	else
	{
		float fAmountNeeded = 0.00f, fSurplus = 0.00f;
		fAmountNeeded += fGoldMedian * iPopulation;
		fSurplus += ((float)getYieldRateTimes100(YIELD_GOLD, false, false) / 100) - fAmountNeeded;

		strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_POVERTY_UNHAPPINESS_SURPLUS", fSurplus);
	}


	int iIlliteracyRaw = GetIlliteracyRaw(false);
	float fScienceMedian = 0.00f;
	fScienceMedian += GetScienceMedian(false, 0) / 100;

	// Below Science requirement
	if (iIlliteracyRaw > 0)
	{
		// Reduced By
		int iReduction = GetIlliteracyFlatReduction() + kPlayer.GetIlliteracyFlatReductionGlobal();

		// Total Deficit
		float fAmountNeeded = 0.00f, fAmountHave = 0.00f, fDeficit = 0.00f, fAmountForNextReduction = 0.00f;
		fAmountNeeded += fScienceMedian * iPopulation;
		fAmountHave += (float)getYieldRateTimes100(YIELD_SCIENCE, false, false) / 100;
		fDeficit += fAmountNeeded - fAmountHave;

		// Increase by X for -1 Unhappiness
		fAmountForNextReduction += fScienceMedian * (iPopulation - iIlliteracyRaw + 1) - fAmountHave;

		strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_ILLITERACY_UNHAPPINESS", iIlliteracy, fDeficit, iIlliteracyRaw, iReduction, fAmountForNextReduction);
	}
	// Above Science requirement
	else
	{
		float fAmountNeeded = 0.00f, fSurplus = 0.00f;
		fAmountNeeded += fScienceMedian * iPopulation;
		fSurplus += ((float)getYieldRateTimes100(YIELD_SCIENCE, false, false) / 100) - fAmountNeeded;

		strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_ILLITERACY_UNHAPPINESS_SURPLUS", fSurplus);
	}


	int iBoredomRaw = GetBoredomRaw(false);
	float fCultureMedian = 0.00f;
	fCultureMedian += GetCultureMedian(false, 0) / 100;

	// Below Culture requirement
	if (iBoredomRaw > 0)
	{
		// Reduced By
		int iReduction = GetBoredomFlatReduction() + kPlayer.GetBoredomFlatReductionGlobal();

		// Total Deficit
		float fAmountNeeded = 0.00f, fAmountHave = 0.00f, fDeficit = 0.00f, fAmountForNextReduction = 0.00f;
		fAmountNeeded += fCultureMedian * iPopulation;
		fAmountHave += (float)getJONSCulturePerTurn(false);
		fDeficit += fAmountNeeded - fAmountHave;

		// Increase by X for -1 Unhappiness
		fAmountForNextReduction += fCultureMedian * (iPopulation - iBoredomRaw + 1) - fAmountHave;

		strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_BOREDOM_UNHAPPINESS", iBoredom, fDeficit, iBoredomRaw, iReduction, fAmountForNextReduction);
	}
	// Above Culture requirement
	else
	{
		float fAmountNeeded = 0.00f, fSurplus = 0.00f;
		fAmountNeeded += fCultureMedian * iPopulation;
		fSurplus += (float)getJONSCulturePerTurn(false) - fAmountNeeded;

		strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_BOREDOM_UNHAPPINESS_SURPLUS", fSurplus);
	}


	// Religious Unrest
	bool bReligionOff = GC.getGame().isOption(GAMEOPTION_NO_RELIGION);
	CvString strIcon = "";
	if (!bReligionOff)
	{
		ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
		if (eMajority > RELIGION_PANTHEON)
		{
			strIcon = GC.getReligionInfo(eMajority)->GetIconString();
		}
		if (iReligiousUnrest != 0 && strIcon != "")
		{
			int iReduction = GetReligiousUnrestFlatReduction() + kPlayer.GetReligiousUnrestFlatReductionGlobal();
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_RELIGIOUS_UNREST_UNHAPPINESS", iReligiousUnrest, strIcon, iReduction);
		}
	}

	// Other Stuff (sort by highest to lowest # of unhappy citizens)
	for (int i = 0; i < vReasons.size(); i++)
	{
		UnhappyReasons eReason = vReasons.GetElement(i);
		int iUnhappyCitizens = vReasons.GetWeight(i);

		switch (eReason)
		{
		case UNHAPPY_REASON_RESISTANCE:
			UNREACHABLE(); // Resistance is handled at the start of the function.
		case UNHAPPY_REASON_DISTRESS:
		case UNHAPPY_REASON_POVERTY:
		case UNHAPPY_REASON_ILLITERACY:
		case UNHAPPY_REASON_BOREDOM:
		case UNHAPPY_REASON_RELIGIOUS_UNREST:
			break; // Already handled above!
		case UNHAPPY_REASON_OCCUPIED:
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_OCCUPATION_UNHAPPINESS", iUnhappyCitizens);
			break;
		case UNHAPPY_REASON_EMPIRE:
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EMPIRE_WIDE_UNHAPPINESS", iUnhappyCitizens);
			break;
		case UNHAPPY_REASON_FAMINE:
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_STARVING_UNHAPPINESS", iUnhappyCitizens);
			break;
		case UNHAPPY_REASON_PILLAGED_TILES:
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_PILLAGED_UNHAPPINESS", iUnhappyCitizens);
			break;
		case UNHAPPY_REASON_ISOLATION:
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_ISOLATION_UNHAPPINESS", iUnhappyCitizens);
			break;
		case UNHAPPY_REASON_URBANIZATION:
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_SPECIALIST_UNHAPPINESS", iUnhappyCitizens);
			break;
		}
	}

	if (bIncludeMedian)
	{
		// Yield Medians (Need Modifier %)
		strTooltip += "[NEWLINE][NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_GLOBAL_MEDIAN_MODS");

		// Basic Needs
		int iTotalDistressModifier = GetTotalNeedModifierForYield(YIELD_FOOD, false);
		if (iTotalDistressModifier > 0)
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_GLOBAL_MEDIAN_BASIC_NEEDS_POS", fBasicNeedsMedian, iTotalDistressModifier);
		else
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_GLOBAL_MEDIAN_BASIC_NEEDS", fBasicNeedsMedian, iTotalDistressModifier);

		// Gold
		int iTotalPovertyModifier = GetTotalNeedModifierForYield(YIELD_GOLD, false);
		if (iTotalPovertyModifier > 0)
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_GLOBAL_MEDIAN_GOLD_POS", fGoldMedian, iTotalPovertyModifier);
		else
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_GLOBAL_MEDIAN_GOLD", fGoldMedian, iTotalPovertyModifier);

		// Science
		int iTotalIlliteracyModifier = GetTotalNeedModifierForYield(YIELD_SCIENCE, false);
		if (iTotalIlliteracyModifier > 0)
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_GLOBAL_MEDIAN_SCIENCE_POS", fScienceMedian, iTotalIlliteracyModifier);
		else
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_GLOBAL_MEDIAN_SCIENCE", fScienceMedian, iTotalIlliteracyModifier);

		// Culture
		int iTotalBoredomModifier = GetTotalNeedModifierForYield(YIELD_CULTURE, false);
		if (iTotalBoredomModifier > 0)
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_GLOBAL_MEDIAN_CULTURE_POS", fCultureMedian, iTotalBoredomModifier);
		else
			strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_GLOBAL_MEDIAN_CULTURE", fCultureMedian, iTotalBoredomModifier);

		// Religious Unrest (only shows % modifier, and only shows up if city has a majority religion)
		int iTotalReligiousUnrestModifier = bReligionOff ? 0 : GetTotalNeedModifierForYield(YIELD_FAITH, false);
		if (strIcon != "")
		{
			float fUnhappyPerMinorityPop = 0.00f;
			fUnhappyPerMinorityPop += /*0.5f*/ GD_FLOAT_GET(UNHAPPINESS_PER_RELIGIOUS_MINORITY_POP);
			fUnhappyPerMinorityPop *= (100 + iTotalReligiousUnrestModifier);
			fUnhappyPerMinorityPop /= 100;
			
			if (iTotalReligiousUnrestModifier > 0)
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_GLOBAL_MEDIAN_RELIGIOUS_UNREST_POS", strIcon, fUnhappyPerMinorityPop, iTotalReligiousUnrestModifier);
			else
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_GLOBAL_MEDIAN_RELIGIOUS_UNREST", strIcon, fUnhappyPerMinorityPop, iTotalReligiousUnrestModifier);
		}

		// Need Modifier Breakdown
		int iCapitalMod = isCapital() ? /*25*/ GD_INT_GET(CAPITAL_NEED_MODIFIER) : 0;
		int iTechMod = GetCachedTechNeedModifier();
		int iCitySize = GetCitySizeModifier();
		int iEmpireSize = GetReducedEmpireSizeModifier(false,false);
		int iDifficultyMod = kPlayer.isHuman() ? kPlayer.getHandicapInfo().getPopulationUnhappinessMod() : kPlayer.getHandicapInfo().getPopulationUnhappinessMod() + GC.getGame().getHandicapInfo().getAIPopulationUnhappinessMod();
		int iCarnivalMod = GetWeLoveTheKingDayCounter() > 0 ? kPlayer.GetPlayerTraits()->GetWLTKDUnhappinessNeedsMod() : 0;
		int iAirUnitsMod = kPlayer.GetNeedsModifierFromAirUnits() != 0 ? plot()->countNumAirUnits(getTeam(), true) * kPlayer.GetNeedsModifierFromAirUnits() * -1 : 0;
		int iTotalMod = iCapitalMod + iTechMod + iCitySize + iEmpireSize + iDifficultyMod + iCarnivalMod + iAirUnitsMod;

		// Process Modifiers
		int iFarmingModifier = 0, iWealthModifier = 0, iResearchModifier = 0, iArtsModifier = 0, iPrayerModifier = 0;
		if (getProductionProcess() != NO_PROCESS)
		{
			CvProcessInfo* pkProcessInfo = GC.getProcessInfo(getProductionProcess());
			if (pkProcessInfo)
			{
				iFarmingModifier = (pkProcessInfo->getProductionToYieldModifier(YIELD_FOOD) + GetYieldFromProcessModifier(YIELD_FOOD)) * -1;
				iWealthModifier = (pkProcessInfo->getProductionToYieldModifier(YIELD_GOLD) + GetYieldFromProcessModifier(YIELD_GOLD)) * -1;
				iResearchModifier = (pkProcessInfo->getProductionToYieldModifier(YIELD_SCIENCE) + GetYieldFromProcessModifier(YIELD_SCIENCE)) * -1;
				iArtsModifier = (pkProcessInfo->getProductionToYieldModifier(YIELD_CULTURE) + GetYieldFromProcessModifier(YIELD_CULTURE)) * -1;
				iPrayerModifier = (pkProcessInfo->getProductionToYieldModifier(YIELD_FAITH) + GetYieldFromProcessModifier(YIELD_FAITH)) * -1;
			}
		}

		// Any misc. modifiers?
		int iExpectedDistressMod = iTotalMod + iFarmingModifier;
		int iExtraDistressMod = iTotalDistressModifier - iExpectedDistressMod;

		int iExpectedPovertyMod = iTotalMod + iWealthModifier;
		int iExtraPovertyMod = iTotalPovertyModifier - iExpectedPovertyMod;

		int iExpectedIlliteracyMod = iTotalMod + iResearchModifier;
		int iExtraIlliteracyMod = iTotalIlliteracyModifier - iExpectedIlliteracyMod;

		int iExpectedBoredomMod = iTotalMod + iArtsModifier;
		int iExtraBoredomMod = iTotalBoredomModifier - iExpectedBoredomMod;

		int iExpectedReligiousUnrestMod = iTotalMod + iPrayerModifier;
		int iExtraReligiousUnrestMod = iTotalReligiousUnrestModifier - iExpectedReligiousUnrestMod;

		// Only show the breakdown if the modifier is non-zero
		if (iTotalMod != 0 || iExtraDistressMod != 0 || iExtraIlliteracyMod != 0 || iExtraBoredomMod != 0 || iExtraReligiousUnrestMod != 0
		|| iFarmingModifier != 0 || iWealthModifier != 0 || iResearchModifier != 0 || iArtsModifier != 0 || iPrayerModifier != 0)
		{
			strTooltip += "[NEWLINE][NEWLINE]" + GetLocalizedText("TXT_KEY_EO_CITY_GLOBAL_MEDIAN_MODS_BREAKDOWN");

			// Is Capital
			if (iCapitalMod != 0)
			{
				if (iCapitalMod > 0)
					strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_CAPITAL_UNHAPPINESS_MOD_POS", iCapitalMod);
				else
					strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_CAPITAL_UNHAPPINESS_MOD", iCapitalMod);
			}

			// Technology
			if (iTechMod != 0)
			{
				if (iTechMod > 0)
					strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_TECH_UNHAPPINESS_MOD_POS", iTechMod);
				else
					strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_TECH_UNHAPPINESS_MOD", iTechMod);
			}

			// City Size
			if (iCitySize != 0)
			{
				if (iCitySize > 0)
					strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_POP_UNHAPPINESS_MOD_POS", iCitySize);
				else
					strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_POP_UNHAPPINESS_MOD", iCitySize);
			}

			// Empire Size
			if (iEmpireSize != 0)
			{
				if (iEmpireSize > 0)
					strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EMPIRE_UNHAPPINESS_MOD_POS", iEmpireSize);
				else
					strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_EMPIRE_UNHAPPINESS_MOD", iEmpireSize);
			}

			// Difficulty Level
			if (iDifficultyMod != 0)
			{
				if (iDifficultyMod > 0)
					strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_DIFFICULTY_UNHAPPINESS_MOD_POS", iDifficultyMod);
				else
					strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_DIFFICULTY_UNHAPPINESS_MOD", iDifficultyMod);
			}

			// SPECIAL MODIFIERS

			// Carnival (Brazil UA)
			if (iCarnivalMod != 0)
			{
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_CARNIVAL_UNHAPPINESS_MOD", iCarnivalMod);
			}

			// Air Units (Policy)
			if (iAirUnitsMod != 0)
			{
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_AIR_UNITS_UNHAPPINESS_MOD", iAirUnitsMod);
			}

			// PROCESS MODIFIERS

			if (iFarmingModifier != 0)
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_FARMING_UNHAPPINESS_MOD", iFarmingModifier);

			if (iWealthModifier != 0)
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_WEALTH_UNHAPPINESS_MOD", iWealthModifier);

			if (iResearchModifier != 0)
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_RESEARCH_UNHAPPINESS_MOD", iResearchModifier);

			if (iArtsModifier != 0)
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_ARTS_UNHAPPINESS_MOD", iArtsModifier);

			if (iPrayerModifier != 0 && strIcon != "")
				strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_PRAYER_UNHAPPINESS_MOD", strIcon, iPrayerModifier);

			// OTHER MODIFIERS

			// If all modifiers are off by the same %, we assume it's the same cause (probably a spy event, since building/policy median modifiers are disabled in base VP) and use a special text key.
			if (iExtraDistressMod != 0 && iExtraDistressMod == iExtraPovertyMod && iExtraDistressMod == iExtraIlliteracyMod && iExtraDistressMod == iExtraBoredomMod && iExtraDistressMod == iExtraReligiousUnrestMod)
			{
				if (iExtraDistressMod > 0)
					strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_MISC_UNHAPPINESS_MOD_POS", iExtraDistressMod);
				else
					strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_MISC_UNHAPPINESS_MOD", iExtraDistressMod);
			}
			// Otherwise break it down individually.
			else
			{
				if (iExtraDistressMod != 0)
				{
					if (iExtraDistressMod > 0)
						strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_MISC_DISTRESS_UNHAPPINESS_MOD_POS", iExtraDistressMod);
					else
						strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_MISC_DISTRESS_UNHAPPINESS_MOD", iExtraDistressMod);
				}
				if (iExtraPovertyMod != 0)
				{
					if (iExtraPovertyMod > 0)
						strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_MISC_POVERTY_UNHAPPINESS_MOD_POS", iExtraPovertyMod);
					else
						strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_MISC_POVERTY_UNHAPPINESS_MOD", iExtraPovertyMod);
				}
				if (iExtraIlliteracyMod != 0)
				{
					if (iExtraIlliteracyMod > 0)
						strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_MISC_ILLITERACY_UNHAPPINESS_MOD_POS", iExtraIlliteracyMod);
					else
						strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_MISC_ILLITERACY_UNHAPPINESS_MOD", iExtraIlliteracyMod);
				}
				if (iExtraBoredomMod != 0)
				{
					if (iExtraBoredomMod > 0)
						strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_MISC_BOREDOM_UNHAPPINESS_MOD_POS", iExtraBoredomMod);
					else
						strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_MISC_BOREDOM_UNHAPPINESS_MOD", iExtraBoredomMod);
				}
				if (iExtraReligiousUnrestMod != 0 && strIcon != "")
				{
					if (iExtraReligiousUnrestMod > 0)
						strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_MISC_RELIGIOUS_UNREST_UNHAPPINESS_MOD_POS", strIcon, iExtraReligiousUnrestMod);
					else
						strTooltip += "[NEWLINE]" + GetLocalizedText("TXT_KEY_MISC_RELIGIOUS_UNREST_UNHAPPINESS_MOD", strIcon, iExtraReligiousUnrestMod);
				}
			}
		}
	}

	strTooltip += getPotentialUnhappinessWithGrowth();
	return strTooltip;
}

//	--------------------------------------------------------------------------------
int CvCity::getUnhappyCitizenCount() const
{
	VALIDATE_OBJECT
	//if we have more happiness than pop, unhappiness is zero (not negative)
	return max(0,getPopulation() - GetLocalHappiness());
}

//	--------------------------------------------------------------------------------
/// How much Unhappiness is this city generating from Distress?
/// bForceRecalc computes the amount of Distress generated after this city's next growth
int CvCity::GetDistress(bool bForceRecalc) const
{
	if (IsPuppet() || IsResistance() || IsRazing())
		return 0;

	int iDistress = GetDistressRaw(bForceRecalc) - GetDistressFlatReduction() - GET_PLAYER(getOwner()).GetDistressFlatReductionGlobal();
	int iPopulation = bForceRecalc ? getPopulation() + 1 : getPopulation();
	int iLimit = MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS ? INT_MAX : iPopulation;
	return range(iDistress, 0, iLimit);
}

int CvCity::GetDistressRaw(bool bForceRecalc) const
{
	// First, calculate the total yield
	// Include yields from trade routes in the yield, but not the median, to make unhappiness management easier
	int iTotalYield = getYieldRateTimes100(YIELD_FOOD, false, false) + getYieldRateTimes100(YIELD_PRODUCTION, false, false);

	// Second, calculate the median (with need modifiers)
	float fMedianYieldPerPop = 0.00f;
	fMedianYieldPerPop += GetBasicNeedsMedian(bForceRecalc, 0);

	// Unhappiness = Population - (Total Yield / Modified Median)
	int iPopulation = bForceRecalc ? getPopulation() + 1 : getPopulation();
	float fDistress = ceil(iPopulation - (iTotalYield / fMedianYieldPerPop));

	int iLimit = MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS ? INT_MAX : iPopulation;
	return range((int)fDistress, 0, iLimit);
}

float CvCity::GetBasicNeedsMedian(bool bForceRecalc, int iAdditionalModifier) const
{
	float fMedianYieldPerPop = 0.00f;
	fMedianYieldPerPop += bForceRecalc ? (float)GC.getGame().GetBasicNeedsMedian() : (float)GetCachedBasicNeedsMedian();
	fMedianYieldPerPop *= (100 + GetTotalNeedModifierForYield(YIELD_PRODUCTION, bForceRecalc) + iAdditionalModifier);
	fMedianYieldPerPop /= 100;
	fMedianYieldPerPop *= /*100*/ std::max(GD_INT_GET(DISTRESS_MEDIAN_BASE_MODIFIER), 0);
	fMedianYieldPerPop /= 100;

	if (fMedianYieldPerPop <= 0.00f)
		return 0.00f;

	return fMedianYieldPerPop;
}

//	--------------------------------------------------------------------------------
/// How much Unhappiness is this city generating from Poverty?
/// bForceRecalc computes the amount of Poverty generated after this city's next growth
int CvCity::GetPoverty(bool bForceRecalc) const
{
	if (IsPuppet() || IsResistance() || IsRazing())
		return 0;

	int iPoverty = GetPovertyRaw(bForceRecalc) - GetPovertyFlatReduction() - GET_PLAYER(getOwner()).GetPovertyFlatReductionGlobal();
	int iPopulation = bForceRecalc ? getPopulation() + 1 : getPopulation();
	int iLimit = MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS ? INT_MAX : iPopulation;
	return range(iPoverty, 0, iLimit);
}

int CvCity::GetPovertyRaw(bool bForceRecalc) const
{
	// First, calculate the total yield
	// Include yields from trade routes in the yield, but not the median, to make unhappiness management easier
	int iTotalYield = getYieldRateTimes100(YIELD_GOLD, false, false);

	// Second, calculate the median (with need modifiers)
	float fMedianYieldPerPop = 0.00f;
	fMedianYieldPerPop += GetGoldMedian(bForceRecalc, 0);

	// Unhappiness = Population - (Total Yield / Modified Median)
	int iPopulation = bForceRecalc ? getPopulation() + 1 : getPopulation();
	float fPoverty = ceil(iPopulation - (iTotalYield / fMedianYieldPerPop));

	int iLimit = MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS ? INT_MAX : iPopulation;
	return range((int)fPoverty, 0, iLimit);
}

float CvCity::GetGoldMedian(bool bForceRecalc, int iAdditionalModifier) const
{
	float fMedianYieldPerPop = 0.00f;
	fMedianYieldPerPop += bForceRecalc ? (float)GC.getGame().GetGoldMedian() : (float)GetCachedGoldMedian();
	fMedianYieldPerPop *= (100 + GetTotalNeedModifierForYield(YIELD_GOLD, bForceRecalc) + iAdditionalModifier);
	fMedianYieldPerPop /= 100;
	fMedianYieldPerPop *= /*100*/ std::max(GD_INT_GET(POVERTY_MEDIAN_BASE_MODIFIER), 0);
	fMedianYieldPerPop /= 100;

	if (fMedianYieldPerPop <= 0.00f)
		return 0.00f;

	return fMedianYieldPerPop;
}

//	--------------------------------------------------------------------------------
/// How much Unhappiness is this city generating from Illiteracy?
/// bForceRecalc computes the amount of Illiteracy generated after this city's next growth
int CvCity::GetIlliteracy(bool bForceRecalc) const
{
	if (IsPuppet() || IsResistance() || IsRazing())
		return 0;

	int iIlliteracy = GetIlliteracyRaw(bForceRecalc) - GetIlliteracyFlatReduction() - GET_PLAYER(getOwner()).GetIlliteracyFlatReductionGlobal();
	int iPopulation = bForceRecalc ? getPopulation() + 1 : getPopulation();
	int iLimit = MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS ? INT_MAX : iPopulation;
	return range(iIlliteracy, 0, iLimit);
}

int CvCity::GetIlliteracyRaw(bool bForceRecalc) const
{
	// First, calculate the total yield
	// Include yields from trade routes in the yield, but not the median, to make unhappiness management easier
	int iTotalYield = getYieldRateTimes100(YIELD_SCIENCE, false, false);

	// Second, calculate the median (with need modifiers)
	float fMedianYieldPerPop = 0.00f;
	fMedianYieldPerPop += GetScienceMedian(bForceRecalc, 0);

	// Unhappiness = Population - (Total Yield / Modified Median)
	int iPopulation = bForceRecalc ? getPopulation() + 1 : getPopulation();
	float fIlliteracy = ceil(iPopulation - (iTotalYield / fMedianYieldPerPop));

	int iLimit = MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS ? INT_MAX : iPopulation;
	return range((int)fIlliteracy, 0, iLimit);
}

float CvCity::GetScienceMedian(bool bForceRecalc, int iAdditionalModifier) const
{
	float fMedianYieldPerPop = 0.00f;
	fMedianYieldPerPop += bForceRecalc ? (float)GC.getGame().GetScienceMedian() : (float)GetCachedScienceMedian();
	fMedianYieldPerPop *= (100 + GetTotalNeedModifierForYield(YIELD_SCIENCE, bForceRecalc) + iAdditionalModifier);
	fMedianYieldPerPop /= 100;
	fMedianYieldPerPop *= /*100*/ std::max(GD_INT_GET(ILLITERACY_MEDIAN_BASE_MODIFIER), 0);
	fMedianYieldPerPop /= 100;

	if (fMedianYieldPerPop <= 0.00f)
		return 0.00f;

	return fMedianYieldPerPop;
}

//	--------------------------------------------------------------------------------
/// How much Unhappiness is this city generating from Boredom?
/// bForceRecalc computes the amount of Boredom generated after this city's next growth
int CvCity::GetBoredom(bool bForceRecalc) const
{
	if (IsPuppet() || IsResistance() || IsRazing())
		return 0;

	int iBoredom = GetBoredomRaw(bForceRecalc) - GetBoredomFlatReduction() - GET_PLAYER(getOwner()).GetBoredomFlatReductionGlobal();
	int iPopulation = bForceRecalc ? getPopulation() + 1 : getPopulation();
	int iLimit = MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS ? INT_MAX : iPopulation;
	return range(iBoredom, 0, iLimit);
}

int CvCity::GetBoredomRaw(bool bForceRecalc) const
{
	// First, calculate the total yield
	// Include yields from trade routes in the yield, but not the median, to make unhappiness management easier
	int iTotalYield = getJONSCulturePerTurn(false) * 100;

	// Second, calculate the median (with need modifiers)
	float fMedianYieldPerPop = 0.00f;
	fMedianYieldPerPop += GetCultureMedian(bForceRecalc, 0);

	// Unhappiness = Population - (Total Yield / Modified Median)
	int iPopulation = bForceRecalc ? getPopulation() + 1 : getPopulation();
	float fBoredom = ceil(iPopulation - (iTotalYield / fMedianYieldPerPop));

	int iLimit = MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS ? INT_MAX : iPopulation;
	return range((int)fBoredom, 0, iLimit);
}

float CvCity::GetCultureMedian(bool bForceRecalc, int iAdditionalModifier) const
{
	float fMedianYieldPerPop = 0.00f;
	fMedianYieldPerPop += bForceRecalc ? (float)GC.getGame().GetCultureMedian() : (float)GetCachedCultureMedian();
	fMedianYieldPerPop *= (100 + GetTotalNeedModifierForYield(YIELD_CULTURE, bForceRecalc) + iAdditionalModifier);
	fMedianYieldPerPop /= 100;
	fMedianYieldPerPop *= /*100*/ std::max(GD_INT_GET(ILLITERACY_MEDIAN_BASE_MODIFIER), 0);
	fMedianYieldPerPop /= 100;

	if (fMedianYieldPerPop <= 0.00f)
		return 0.00f;

	return fMedianYieldPerPop;
}

//	--------------------------------------------------------------------------------
int CvCity::GetUnhappinessFromPillagedTiles() const
{
	if (IsPuppet() || IsResistance() || IsRazing())
		return 0;

	int iPillagedTiles = GetNumPillagedPlots();
	if (iPillagedTiles > 0)
	{
		float fUnhappiness = 0.00f;
		float fUnhappyPerTile = /*0.50f*/ GD_FLOAT_GET(UNHAPPINESS_PER_PILLAGED_TILE);
		fUnhappiness += (float)iPillagedTiles * fUnhappyPerTile;

		int iLimit = MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS ? INT_MAX : getPopulation();
		return range((int)fUnhappiness, 0, iLimit);
	}

	return 0;
}

//	--------------------------------------------------------------------------------
int CvCity::GetUnhappinessFromOccupation() const
{
	if (IsPuppet() || !IsOccupied() || IsNoOccupiedUnhappiness())
		return 0;

	int iPopulation = getPopulation();
	float fUnhappiness = 0.00f;
	fUnhappiness += iPopulation * /*1.00f*/ GD_FLOAT_GET(UNHAPPINESS_PER_OCCUPIED_POPULATION);

	if (HasGarrison())
	{
		fUnhappiness *= 100 + GET_PLAYER(getOwner()).GetGarrisonsOccupiedUnhappinessMod();
		fUnhappiness /= 100;
	}

	int iLimit = MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS ? INT_MAX : iPopulation;
	return range((int)fUnhappiness, 0, iLimit);
}

//	--------------------------------------------------------------------------------
int CvCity::GetUnhappinessFromFamine() const
{
	if (IsPuppet() || IsResistance() || IsRazing())
		return 0;

	int iDiff = foodDifference(true);
	if (iDiff < 0 && !isFoodProduction())
	{
		iDiff *= -1;

		float fUnhappiness = 0.00f;
		float fUnhappyPerDeficit = /*1.0f*/ GD_FLOAT_GET(UNHAPPINESS_PER_STARVING_POP);
		fUnhappiness += (float)iDiff * fUnhappyPerDeficit;

		int iLimit = MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS ? INT_MAX : getPopulation();
		return range((int)fUnhappiness, 0, iLimit);
	}

	return 0;
}

//	--------------------------------------------------------------------------------
int CvCity::GetUnhappinessFromReligiousUnrest() const
{
	if (IsPuppet() || IsResistance() || IsRazing() || GC.getGame().isOption(GAMEOPTION_NO_RELIGION))
		return 0;

	//Trait takes away unhappiness from religious strife.
	if (GET_PLAYER(getOwner()).GetPlayerTraits()->IsNoReligiousStrife())
		return 0;

	const CvReligion* pReligion = NULL;
	ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
	if (eMajority > RELIGION_PANTHEON)
	{
		pReligion = GC.getGame().GetGameReligions()->GetReligion(eMajority, getOwner());
	}
	if (pReligion)
	{
		float fUnhappiness = 0.00f;
		int iMajorityReligionFollowers = GetCityReligions()->GetNumFollowers(eMajority);
		int iReligiousMinorities = getPopulation() - iMajorityReligionFollowers;

		if (iReligiousMinorities > 0)
		{
			fUnhappiness += iReligiousMinorities * /*0.5f*/ GD_FLOAT_GET(UNHAPPINESS_PER_RELIGIOUS_MINORITY_POP);
			int iModifier = GetTotalNeedModifierForYield(YIELD_FAITH, false);

			fUnhappiness *= (100 + iModifier);
			fUnhappiness /= 100;

			int iUnhappiness = (int)fUnhappiness - GetReligiousUnrestFlatReduction() - GET_PLAYER(getOwner()).GetReligiousUnrestFlatReductionGlobal();
			int iLimit = MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS ? INT_MAX : getPopulation();
			return range(iUnhappiness, 0, iLimit);
		}
	}

	return 0;
}

//	--------------------------------------------------------------------------------
int CvCity::GetUnhappinessFromIsolation() const
{
	if (IsPuppet() || IsResistance() || IsRazing())
		return 0;

	// No Isolation in the capital
	if (isCapital())
		return 0;

	//Trait takes away unhappiness from Isolation.
	if (GET_PLAYER(getOwner()).GetPlayerTraits()->IsNoConnectionUnhappiness())
		return 0;
	//Policy takes away unhappiness from Isolation.
	if (GET_PLAYER(getOwner()).IsNoUnhappyIsolation())
		return 0;

	//note: it's only connected to the capital if it's not blockaded
	if (IsRouteToCapitalConnected())
		return 0;

	//if we have a trade route to our capital or to another city which has a route to the capital, it's just as good as a route
	int iLoop = 0;
	for (CvCity* pLoopCity = GET_PLAYER(getOwner()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(getOwner()).nextCity(&iLoop))
	{
		if (!pLoopCity)
			continue;

		if (pLoopCity->isCapital() || pLoopCity->IsRouteToCapitalConnected())
		{
			if (HasTradeRouteTo(pLoopCity) || HasTradeRouteFrom(pLoopCity))
				return 0;
		}
	}

	//ok, how much unhappiness do we generate?
	float fUnhappiness = 0.00f;
	if (GD_FLOAT_GET(UNHAPPINESS_PER_ISOLATED_POP) > 0)
	{
		fUnhappiness += (float)getPopulation() * /*0.34f*/ GD_FLOAT_GET(UNHAPPINESS_PER_ISOLATED_POP);
	}

	int iLimit = MOD_BALANCE_CORE_UNCAPPED_UNHAPPINESS ? INT_MAX : getPopulation();
	return range((int)fUnhappiness, 0, iLimit);
}

int CvCity::getJFDSpecialUnhappinessSources() const
{
	int iContribution = GetUnhappinessFromFamine();
	iContribution += GetUnhappinessFromPillagedTiles();
	iContribution += GetUnhappinessFromIsolation();

	return iContribution;
}

//	--------------------------------------------------------------------------------
int CvCity::GetHappinessFromBuildings() const
{
	return GetUnmoddedHappinessFromBuildings() + GetBaseHappinessFromBuildings();
}

//	--------------------------------------------------------------------------------
int CvCity::GetBaseHappinessFromBuildings() const
{
	return m_iBaseHappinessFromBuildings;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeBaseHappinessFromBuildings(int iChange)
{
	m_iBaseHappinessFromBuildings += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetUnmoddedHappinessFromBuildings() const
{
	return m_iUnmoddedHappinessFromBuildings;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeUnmoddedHappinessFromBuildings(int iChange)
{
	m_iUnmoddedHappinessFromBuildings += iChange;
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvCity::GetLocalUnhappinessMod() const
{
	return m_iLocalUnhappinessMod;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeLocalUnhappinessMod(int iChange)
{
	m_iLocalUnhappinessMod += iChange;
}
#endif
//	--------------------------------------------------------------------------------
/// Used when gathering info for "Annex/Puppet/Raze" popup
bool CvCity::IsIgnoreCityForHappiness() const
{
	return m_bIgnoreCityForHappiness;
}

//	--------------------------------------------------------------------------------
/// Used when gathering info for "Annex/Puppet/Raze" popup
void CvCity::SetIgnoreCityForHappiness(bool bValue)
{
	m_bIgnoreCityForHappiness = bValue;
}

//	--------------------------------------------------------------------------------
/// Find the non-wonder building that provides the highest culture at the least cost
BuildingTypes CvCity::ChooseFreeCultureBuilding() const
{
	BuildingTypes eRtnValue = NO_BUILDING;
	int iNumBuildingInfos = GC.getNumBuildingInfos();
	CvWeightedVector<int> buildingChoices;

	for (int iI = 0; iI < iNumBuildingInfos; iI++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
		if (pkBuildingInfo)
		{
			const CvBuildingClassInfo& kBuildingClassInfo = pkBuildingInfo->GetBuildingClassInfo();
			if (!isWorldWonderClass(kBuildingClassInfo) && !isNationalWonderClass(kBuildingClassInfo))
			{
				int iCulture = pkBuildingInfo->GetYieldChange(YIELD_CULTURE);
				int iCost = pkBuildingInfo->GetProductionCost();
				if (getFirstBuildingOrder(eBuilding) != -1 || canConstruct(eBuilding))
				{
					if (iCulture > 0 && iCost > 0)
					{
						int iWeight = iCulture * 10000 / iCost;

						if (iWeight > 0)
						{
							buildingChoices.push_back(iI, iWeight);
						}
					}
				}
			}
		}
	}

	if (buildingChoices.size() > 0)
	{
		buildingChoices.StableSortItems();
		eRtnValue = (BuildingTypes)buildingChoices.GetElement(0);
	}

	return eRtnValue;
}

//	--------------------------------------------------------------------------------
/// Find the non-wonder building that provides the highest culture at the least cost
BuildingTypes CvCity::ChooseFreeFoodBuilding() const
{
	BuildingTypes eRtnValue = NO_BUILDING;
	int iNumBuildingInfos = GC.getNumBuildingInfos();
	CvWeightedVector<int> buildingChoices;

	for (int iI = 0; iI < iNumBuildingInfos; iI++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
		if (pkBuildingInfo)
		{
			const CvBuildingClassInfo& kBuildingClassInfo = pkBuildingInfo->GetBuildingClassInfo();
			if (!isWorldWonderClass(kBuildingClassInfo) && !isNationalWonderClass(kBuildingClassInfo))
			{
				if (getFirstBuildingOrder(eBuilding) != -1 || canConstruct(eBuilding))
				{
					int iFood = pkBuildingInfo->GetFoodKept();
					int iCost = pkBuildingInfo->GetProductionCost();
					if (iFood > 0 && iCost > 0)
					{
						int iWeight = iFood * 10000 / iCost;

						if (iWeight > 0)
						{
							buildingChoices.push_back(iI, iWeight);
						}
					}
				}
			}
		}
	}

	if (buildingChoices.size() > 0)
	{
		buildingChoices.StableSortItems();
		eRtnValue = (BuildingTypes)buildingChoices.GetElement(0);
	}

	return eRtnValue;
}

//	--------------------------------------------------------------------------------
int CvCity::getCitySizeBoost() const
{
	VALIDATE_OBJECT
	return m_iCitySizeBoost;
}


//	--------------------------------------------------------------------------------
void CvCity::setCitySizeBoost(int iBoost)
{
	VALIDATE_OBJECT
	if (getCitySizeBoost() != iBoost)
	{
		m_iCitySizeBoost = iBoost;
		setLayoutDirty(true);
	}
}


//	--------------------------------------------------------------------------------
bool CvCity::isNeverLost() const
{
	VALIDATE_OBJECT
	return m_bNeverLost;
}


//	--------------------------------------------------------------------------------
void CvCity::setNeverLost(bool bNewValue)
{
	VALIDATE_OBJECT
	m_bNeverLost = bNewValue;
}


//	--------------------------------------------------------------------------------
bool CvCity::isDrafted() const
{
	VALIDATE_OBJECT
	return m_bDrafted;
}


//	--------------------------------------------------------------------------------
void CvCity::setDrafted(bool bNewValue)
{
	VALIDATE_OBJECT
	m_bDrafted = bNewValue;
}

//	--------------------------------------------------------------------------------
bool CvCity::IsOwedCultureBuilding() const
{
	return m_bOwedCultureBuilding;
}

//	--------------------------------------------------------------------------------
void CvCity::SetOwedCultureBuilding(bool bNewValue)
{
	m_bOwedCultureBuilding = bNewValue;
}

//	--------------------------------------------------------------------------------
bool CvCity::IsOwedFoodBuilding() const
{
	return m_bOwedFoodBuilding;
}

//	--------------------------------------------------------------------------------
void CvCity::SetOwedFoodBuilding(bool bNewValue)
{
	m_bOwedFoodBuilding = bNewValue;
}

#if defined(MOD_BALANCE_CORE)

//	--------------------------------------------------------------------------------
int CvCity::GetBorderObstacleLand() const
{
	VALIDATE_OBJECT
	return m_iBorderObstacleCity;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeBorderObstacleCity(int iChange)
{
	VALIDATE_OBJECT
	SetBorderObstacleCity(GetBorderObstacleLand() + iChange);
}
//	--------------------------------------------------------------------------------
void CvCity::SetBorderObstacleCity(int iValue)
{
	VALIDATE_OBJECT
	m_iBorderObstacleCity = iValue;
}

//	--------------------------------------------------------------------------------
int CvCity::GetBorderObstacleWater() const
{
	VALIDATE_OBJECT
	return m_iBorderObstacleWater;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeBorderObstacleWater(int iChange)
{
	VALIDATE_OBJECT
	SetBorderObstacleWater(GetBorderObstacleWater() + iChange);
}
//	--------------------------------------------------------------------------------
void CvCity::SetBorderObstacleWater(int iValue)
{
	VALIDATE_OBJECT
	m_iBorderObstacleWater = iValue;
}

//	--------------------------------------------------------------------------------
int CvCity::GetDeepWaterTileDamage() const
{
	VALIDATE_OBJECT
	return m_iDeepWaterTileDamage;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeDeepWaterTileDamage(int iChange)
{
	VALIDATE_OBJECT
	m_iDeepWaterTileDamage += iChange;
}
//	--------------------------------------------------------------------------------
int CvCity::GetNearbyMountains() const
{
	VALIDATE_OBJECT
	return m_iNumNearbyMountains;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeNearbyMountains(int iChange)
{
	VALIDATE_OBJECT
	SetNearbyMountains(GetNearbyMountains() + iChange);
}
//	--------------------------------------------------------------------------------
void CvCity::SetNearbyMountains(int iValue)
{
	VALIDATE_OBJECT
	m_iNumNearbyMountains = iValue;
}

#endif
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
bool CvCity::IsOwedChosenBuilding(BuildingClassTypes eBuildingClass) const
{
	FAssert(eBuildingClass >= 0);
	FAssert(eBuildingClass < GC.getNumBuildingClassInfos());

	return m_abOwedChosenBuilding[eBuildingClass];
}
//	--------------------------------------------------------------------------------
void CvCity::SetOwedChosenBuilding(BuildingClassTypes eBuildingClass, bool bNewValue)
{
	FAssert(eBuildingClass >= 0);
	FAssert(eBuildingClass < GC.getNumBuildingClassInfos());

	m_abOwedChosenBuilding[eBuildingClass] = bNewValue;
}
#endif

//	--------------------------------------------------------------------------------
bool CvCity::IsBlockadedWaterAndLand() const
{
	return IsBlockaded(NO_DOMAIN);
}

bool CvCity::IsBlockaded(DomainTypes eDomain) const
{
	if (GetSappedTurns() > 0)
		return true;

	for (int iLoop = 0; iLoop < NUM_DIRECTION_TYPES; ++iLoop)
	{
		CvPlot* pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iLoop));
		if (!pAdjacentPlot)
			continue;

		if (eDomain != NO_DOMAIN && pAdjacentPlot->getDomain() != eDomain)
			continue;

		if (pAdjacentPlot->isImpassable(getTeam()))
			continue;

		//finally, one unblocked plot breaks the whole thing
		if (!pAdjacentPlot->isBlockaded(getOwner()))
			return false;
	}

	//note: if a city is landlocked, it is permanently blockaded from sea side by definition
	return true;
}

//	--------------------------------------------------------------------------------
/// Number of turns city has demanded a resource for
int CvCity::GetResourceDemandedCounter() const
{
	VALIDATE_OBJECT
	return m_iResourceDemandedCounter;
}

//	--------------------------------------------------------------------------------
///Sets number of turns city has demanded a resource for
void CvCity::SetResourceDemandedCounter(int iValue)
{
	VALIDATE_OBJECT
	m_iResourceDemandedCounter = iValue;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeResourceDemandedCounter(int iChange)
{
	VALIDATE_OBJECT
	SetResourceDemandedCounter(GetResourceDemandedCounter() + iChange);
}

//	--------------------------------------------------------------------------------
/// Amount of turns left in WLTKD
int CvCity::GetWeLoveTheKingDayCounter() const
{
	VALIDATE_OBJECT
	return m_iWeLoveTheKingDayCounter;
}

//	--------------------------------------------------------------------------------
///Sets number of turns left in WLTKD
void CvCity::SetWeLoveTheKingDayCounter(int iValue)
{
	VALIDATE_OBJECT
	m_iWeLoveTheKingDayCounter = iValue;
}

//	--------------------------------------------------------------------------------
///Changes number of turns left in WLTKD
void CvCity::ChangeWeLoveTheKingDayCounter(int iChange, bool bUATrigger)
{
	VALIDATE_OBJECT

	bool bNewWLTKD = false;
	if (m_iWeLoveTheKingDayCounter <= 0 && iChange > 0)
		bNewWLTKD = true;

	SetWeLoveTheKingDayCounter(GetWeLoveTheKingDayCounter() + iChange);
	if (bNewWLTKD)
	{
#if defined(MOD_BALANCE_CORE)
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityBeginsWLTKD, getOwner(), getX(), getY(), iChange);
#endif
	}
	else if (iChange > 0)
	{
#if defined(MOD_BALANCE_CORE)
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityExtendsWLTKD, getOwner(), getX(), getY(), iChange);
#endif
	}
	if (iChange > 0 && bUATrigger)
	{
		for (int iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
		{
			if (GET_PLAYER(getOwner()).GetPlayerTraits()->GetPermanentYieldChangeWLTKD((YieldTypes)iJ) > 0)
			{
				ChangeBaseYieldRateFromMisc((YieldTypes)iJ, GET_PLAYER(getOwner()).GetPlayerTraits()->GetPermanentYieldChangeWLTKD((YieldTypes)iJ));
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Turn number when AI placed a garrison here
int CvCity::GetLastTurnGarrisonAssigned() const
{
	VALIDATE_OBJECT
	return m_iLastTurnGarrisonAssigned;
}

//	--------------------------------------------------------------------------------
int CvCity::GetNumThingsProduced() const
{
	VALIDATE_OBJECT
	return m_iThingsProduced;
}

//	--------------------------------------------------------------------------------
bool CvCity::isProductionAutomated() const
{
	VALIDATE_OBJECT
	return m_bProductionAutomated;
}


//	--------------------------------------------------------------------------------
void CvCity::setProductionAutomated(bool bNewValue, bool bClear)
{
	VALIDATE_OBJECT
	if (isProductionAutomated() != bNewValue)
	{
		m_bProductionAutomated = bNewValue;

		if ((getOwner() == GC.getGame().getActivePlayer()) && isCitySelected())
		{
			DLLUI->setDirty(SelectionButtons_DIRTY_BIT, true);
		}

		// if automated and not network game and all 3 modifiers down, clear the queue and choose again
		if (bNewValue && bClear)
		{
			clearOrderQueue();
		}
		if (!isProduction())
		{
			AI_chooseProduction(false /*bInterruptWonders*/, false);
		}
	}
}


//	--------------------------------------------------------------------------------
bool CvCity::isLayoutDirty() const
{
	VALIDATE_OBJECT
	return m_bLayoutDirty;
}


//	--------------------------------------------------------------------------------
void CvCity::setLayoutDirty(bool bNewValue)
{
	VALIDATE_OBJECT
	m_bLayoutDirty = bNewValue;
}

//	--------------------------------------------------------------------------------
PlayerTypes CvCity::getPreviousOwner() const
{
	VALIDATE_OBJECT
	return m_ePreviousOwner;
}


//	--------------------------------------------------------------------------------
void CvCity::setPreviousOwner(PlayerTypes eNewValue)
{
	VALIDATE_OBJECT
	m_ePreviousOwner = eNewValue;
}


//	--------------------------------------------------------------------------------
PlayerTypes CvCity::getOriginalOwner() const
{
	VALIDATE_OBJECT
	return m_eOriginalOwner;
}


//	--------------------------------------------------------------------------------
void CvCity::setOriginalOwner(PlayerTypes eNewValue)
{
	VALIDATE_OBJECT
	m_eOriginalOwner = eNewValue;
}


//	--------------------------------------------------------------------------------
PlayerTypes CvCity::GetPlayersReligion() const
{
	VALIDATE_OBJECT
	return m_ePlayersReligion;
}


//	--------------------------------------------------------------------------------
void CvCity::SetPlayersReligion(PlayerTypes eNewValue)
{
	VALIDATE_OBJECT
	m_ePlayersReligion = eNewValue;
}

void CvCity::SetNoWarmonger(bool bValue)
{
	VALIDATE_OBJECT
	m_bNoWarmonger = bValue;
}
bool CvCity::IsNoWarmongerYet()
{
	VALIDATE_OBJECT
	return m_bNoWarmonger;
}

int CvCity::GetNumTimesOwned(PlayerTypes ePlayer) const
{
	VALIDATE_OBJECT
	return m_aiNumTimesOwned[ePlayer];
}
void CvCity::SetNumTimesOwned(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(ePlayer < MAX_PLAYERS, "eIndex expected to be < MAX_PLAYERS");
	m_aiNumTimesOwned[ePlayer] = iValue;
}
void CvCity::ChangeNumTimesOwned(PlayerTypes ePlayer, int iValue)
{
	CvAssertMsg(ePlayer >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(ePlayer < MAX_PLAYERS, "eIndex expected to be < MAX_PLAYERS");
	SetNumTimesOwned(ePlayer, (GetNumTimesOwned(ePlayer) + iValue));
}
bool CvCity::isEverOwned(PlayerTypes ePlayer) const
{
	return GetNumTimesOwned(ePlayer) > 0;
}

//	--------------------------------------------------------------------------------
TeamTypes CvCity::getTeam() const
{
	VALIDATE_OBJECT
	return GET_PLAYER(getOwner()).getTeam();
}


//	--------------------------------------------------------------------------------
int CvCity::getSeaPlotYield(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiSeaPlotYield[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::changeSeaPlotYield(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiSeaPlotYield[eIndex] = m_aiSeaPlotYield[eIndex] + iChange;
		CvAssert(getSeaPlotYield(eIndex) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvCity::getRiverPlotYield(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiRiverPlotYield[eIndex];
}

//	--------------------------------------------------------------------------------
void CvCity::changeRiverPlotYield(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiRiverPlotYield[eIndex] = m_aiRiverPlotYield[eIndex] + iChange;
		CvAssert(getRiverPlotYield(eIndex) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvCity::getLakePlotYield(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiLakePlotYield[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::changeLakePlotYield(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiLakePlotYield[eIndex] = m_aiLakePlotYield[eIndex] + iChange;
		CvAssert(getLakePlotYield(eIndex) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
int CvCity::getSeaResourceYield(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiSeaResourceYield[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::changeSeaResourceYield(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiSeaResourceYield[eIndex] = m_aiSeaResourceYield[eIndex] + iChange;
		CvAssert(getSeaResourceYield(eIndex) >= 0);

		updateYield();
	}
}

//	--------------------------------------------------------------------------------
/// Yield per turn from Religion
int CvCity::GetYieldPerTurnFromReligion(YieldTypes eYield) const
{
	return GetSpecialReligionYields(eYield);
}

void CvCity::UpdateSpecialReligionYields(YieldTypes eYield)
{
	int iYieldValue = 0;
	ReligionTypes eReligion = GetCityReligions()->GetReligiousMajority();
	if (eReligion != NO_RELIGION)
	{
		CvPlayer& kPlayer = GET_PLAYER(getOwner());
		const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
		if (pReligion)
		{
			if (GetCityReligions()->IsHolyCityForReligion(pReligion->m_eReligion))
			{
				iYieldValue += pReligion->m_Beliefs.GetHolyCityYieldChange(eYield, getOwner(), this, true);
			}

			int iPantheon = 0;
			int iYield = pReligion->m_Beliefs.GetYieldFromKnownPantheons(eYield, getOwner(), this, true);
			if (iYield > 0)
			{
				iPantheon = GC.getGame().GetGameReligions()->GetNumPantheonsCreated();
				if (iPantheon > 0)
				{
					iPantheon = min(iPantheon, 8);

					iPantheon *= iYield;
					iPantheon /= 100;

					iYieldValue += iPantheon;
				}
			}

			int iTemp = pReligion->m_Beliefs.GetYieldChangePerForeignCity(eYield, getOwner(), this, true);
			if (iTemp > 0)
			{
				iYieldValue += (iTemp * kPlayer.GetReligions()->GetNumForeignCitiesFollowing(eReligion));
			}

			iTemp = pReligion->m_Beliefs.GetYieldChangePerXForeignFollowers(eYield, getOwner(), this, true);
			if (iTemp > 0)
			{
				int iFollowers = kPlayer.GetReligions()->GetNumForeignFollowers(false, eReligion);
				if (iFollowers > 0)
				{
					iYieldValue += (iFollowers / iTemp);
				}
			}

			iTemp = pReligion->m_Beliefs.GetYieldChangePerXCityStateFollowers(eYield, getOwner(), this, true);
			if (iTemp > 0)
			{
				int iFollowers = kPlayer.GetReligions()->GetNumCityStateFollowers(eReligion);
				if (iFollowers > 0)
				{
					iYieldValue += (iFollowers / iTemp);
				}
			}

			int iYieldPerXNonFollowers = pReligion->m_Beliefs.GetYieldPerOtherReligionFollower(eYield, getOwner(), this, true);
			if (iYieldPerXNonFollowers > 0)
			{
				int iLoop = 0;
				for (const CvCity* pLoopCity = GET_PLAYER(getOwner()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(getOwner()).nextCity(&iLoop))
				{
					if (pLoopCity != NULL)
					{
						iYieldValue += (pLoopCity->GetCityReligions()->GetFollowersOtherReligions(eReligion));
					}
				}
				iYieldValue /= iYieldPerXNonFollowers;
			}

			// This came from CvTreasury::GetGoldPerTurnFromReligion()
			//Only useable in religions!
			if (eYield == YIELD_GOLD)
			{
				if (eReligion != RELIGION_PANTHEON)
					iYieldValue += pReligion->m_Beliefs.GetGoldPerFollowingCity(getOwner(), this, true);

				int iGoldPerXFollowers = pReligion->m_Beliefs.GetGoldPerXFollowers(getOwner(), this, true);
				if (iGoldPerXFollowers > 0)
				{
					if (eReligion == RELIGION_PANTHEON)
						iYieldValue += (GC.getGame().GetGameReligions()->GetNumFollowers(eReligion, getOwner()) / iGoldPerXFollowers);
					else
						iYieldValue += (GC.getGame().GetGameReligions()->GetNumFollowers(eReligion) / iGoldPerXFollowers);
				}
			}

			int iYieldPerFollowingCity = pReligion->m_Beliefs.GetYieldPerFollowingCity(eYield, getOwner(), this);
			if (iYieldPerFollowingCity > 0)
			{
				iYieldValue += iYieldPerFollowingCity;
			}

			int iYieldPerXFollowers = pReligion->m_Beliefs.GetYieldPerXFollowers(eYield, getOwner(), this, true);
			if (iYieldPerXFollowers > 0)
			{
				iYieldValue += (GC.getGame().GetGameReligions()->GetNumFollowers(eReligion, getOwner()) / iYieldPerXFollowers);
			}

			int iLuxYield = pReligion->m_Beliefs.GetYieldPerLux(eYield, getOwner(), this, true);
			if (iLuxYield > 0)
			{
				int iNumBonuses = 0;
				ResourceTypes eResource;
				for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
				{
					eResource = (ResourceTypes)iResourceLoop;

					if (kPlayer.GetHappinessFromLuxury(eResource) > 0)
					{
						if ((kPlayer.getNumResourceTotal(eResource, true) + kPlayer.getResourceExport(eResource)) > 0)
							iNumBonuses++;
					}
				}
				if (iNumBonuses > 0)
				{
					iLuxYield *= iNumBonuses;
					iYieldValue += iLuxYield;
				}
			}

			int iYieldPerGPT = pReligion->m_Beliefs.GetYieldPerGPT(eYield, getOwner(), this);
			if (iYieldPerGPT > 0)
			{
				int iNetGold = getYieldRate(YIELD_GOLD, false);
				if (iNetGold > 0)
				{
					int iNumFollowers = GetCityReligions()->GetNumFollowers(eReligion);
					iNetGold = min((iNumFollowers / 2), (iNetGold / iYieldPerGPT));
					iYieldValue += iNetGold;
				}
			}

			int iYieldPerScience = pReligion->m_Beliefs.GetYieldPerScience(eYield, getOwner(), this);
			if (iYieldPerScience > 0)
			{
				int iNetScience = getYieldRate(YIELD_SCIENCE, false);
				if (iNetScience > 0)
				{
					int iNumFollowers = GetCityReligions()->GetNumFollowers(eReligion);
					iNetScience = min((iNumFollowers / 2), (iNetScience / iYieldPerScience));

					iYieldValue += iNetScience;
				}
			}

			CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();
			if (pLeague != NULL)
			{
				int iEra = kPlayer.GetCurrentEra();
				if (iEra <= 1)
				{
					iEra = 1;
				}
				int iHostYield = (pReligion->m_Beliefs.GetYieldFromHost(eYield, getOwner(), this, true) * iEra);
				if (iHostYield > 0)
				{
					if (pLeague->GetHostMember() == getOwner())
					{
						iYieldValue += iHostYield;
					}
				}
			}

			iYieldValue += pReligion->m_Beliefs.GetYieldPerActiveTR(eYield, getOwner(), this);
		}
	}
	SetSpecialReligionYields(eYield, iYieldValue);
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetSpecialReligionYields(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromKnownPantheons[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::SetSpecialReligionYields(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != m_aiYieldFromKnownPantheons[eIndex])
	{
		m_aiYieldFromKnownPantheons[eIndex] = iChange;
		CvAssert(GetSpecialReligionYields(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
int CvCity::getBaseYieldRateModifier(YieldTypes eIndex, int iExtra, CvString* toolTipSink) const
{
	VALIDATE_OBJECT

	// Yield Rate Modifier
	int iTempMod = getYieldRateModifier(eIndex);
	int iModifier = iTempMod;
	if (toolTipSink)
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD", iTempMod);

#if defined(MOD_YIELD_MODIFIER_FROM_UNITS)
	if (MOD_YIELD_MODIFIER_FROM_UNITS)
	{
		CvPlot* pCityPlot = plot();
		for (int iUnitLoop = 0; iUnitLoop < pCityPlot->getNumUnits(); iUnitLoop++)
		{
			iTempMod = pCityPlot->getUnitByIndex(iUnitLoop)->GetYieldModifier(eIndex);
			if (iTempMod != 0)
			{
				iModifier += iTempMod;
				if (toolTipSink && iTempMod)
				{
					GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_UNITPROMOTION", iTempMod);
				}
			}
		}
	}
#endif

	// Resource Yield Rate Modifier
	iTempMod = getResourceYieldRateModifier(eIndex);
	iModifier += iTempMod;
	if (toolTipSink)
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_RESOURCES", iTempMod);

	// Empire Happiness Yield Rate Modifier
	iTempMod = getHappinessModifier(eIndex);
	iModifier += iTempMod;
	if (toolTipSink)
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_HAPPINESS", iTempMod);

	// Area Yield Rate Modifier
	CvArea* pArea = plot()->area();
	if (pArea != NULL)
	{
		iTempMod = pArea->getYieldRateModifier(getOwner(), eIndex);
		iModifier += iTempMod;
		if (toolTipSink)
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_AREA", iTempMod);
	}

	// Player Yield Rate Modifier
	iTempMod = GET_PLAYER(getOwner()).getYieldRateModifier(eIndex);
	iModifier += iTempMod;
	if (toolTipSink)
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_PLAYER", iTempMod);

	// Player Capital Yield Rate Modifier
	if (isCapital())
	{
		iTempMod = GET_PLAYER(getOwner()).getCapitalYieldRateModifier(eIndex);
		iModifier += iTempMod;
		if (toolTipSink)
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_CAPITAL", iTempMod);
	}

	//Blockade
	if (eIndex == YIELD_GOLD && isCoastal(/*10*/ GD_INT_GET(MIN_WATER_SIZE_FOR_OCEAN)))
	{
		if (/*0 in CP, -25 in VP*/ GD_INT_GET(BLOCKADE_GOLD_PENALTY) != 0 && IsBlockaded(DOMAIN_SEA))
		{
			iTempMod = GD_INT_GET(BLOCKADE_GOLD_PENALTY);
			iModifier += iTempMod;
			if (toolTipSink)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_GOLDMOD_YIELD_BLOCKADE", iTempMod);
		}
	}

	iTempMod = GetEventCityYieldModifier(eIndex);
	iModifier += iTempMod;
	if (toolTipSink)
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_EVENTMOD", iTempMod);
	

	iTempMod = (GetTradeRouteCityMod(eIndex));
	if (iTempMod > 0)
	{
		iModifier += iTempMod;
		if (toolTipSink)
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_CORPORATION", iTempMod);
	}
	if (GetYieldModifierFromHappiness(eIndex) != 0)
	{
		iTempMod = GetYieldModifierFromHappiness(eIndex);
		iModifier += iTempMod;
		if (toolTipSink)
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_YIELD_MODIFIER_HAPPINESS", iTempMod);
	}
	if (GetYieldModifierFromHealth(eIndex) != 0)
	{
		iTempMod = GetYieldModifierFromHealth(eIndex);
		iModifier += iTempMod;
		if (toolTipSink)
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_YIELD_MODIFIER_HEALTH", iTempMod);
	}
	if (GetYieldModifierFromCrime(eIndex) != 0 && eIndex != YIELD_JFD_CRIME)
	{
		iTempMod = GetYieldModifierFromCrime(eIndex);
		iModifier += iTempMod;
		if (toolTipSink)
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_YIELD_MODIFIER_CRIME", iTempMod);
	}
	if (GetYieldModifierFromDevelopment(eIndex) != 0 && eIndex != YIELD_JFD_CRIME)
	{
		iTempMod = GetYieldModifierFromDevelopment(eIndex);
		iModifier += iTempMod;
		if (toolTipSink)
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_YIELD_MODIFIER_DEVELOPMENT", iTempMod);
	}
	if (GET_PLAYER(getOwner()).getYieldModifierFromGreatWorks(eIndex) != 0)
	{
		iTempMod = min(20, (GET_PLAYER(getOwner()).getYieldModifierFromGreatWorks(eIndex) * GetCityBuildings()->GetNumGreatWorks()));
		iModifier += iTempMod;
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_GREAT_WORKS", iTempMod);
	}
	if (isCapital() && GET_PLAYER(getOwner()).getYieldModifierFromActiveSpies(eIndex) != 0)
	{
		iTempMod = min(30, (GET_PLAYER(getOwner()).getYieldModifierFromActiveSpies(eIndex) * GET_PLAYER(getOwner()).GetEspionage()->GetNumAssignedSpies()));
		iModifier += iTempMod;
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_SPIES", iTempMod);
	}

	// Golden Age Yield Modifier
	if (GET_PLAYER(getOwner()).isGoldenAge() && eIndex != YIELD_FOOD)
	{
		CvYieldInfo* pYield = GC.getYieldInfo(eIndex);
		if (pYield)
		{
			iTempMod = pYield->getGoldenAgeYieldMod();
			iModifier += iTempMod;
			if (toolTipSink)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_GOLDEN_AGE", iTempMod);
		}

		if (GetGoldenAgeYieldMod(eIndex) != 0)
		{
			iTempMod = GetGoldenAgeYieldMod(eIndex);
			iModifier += iTempMod;
			if (toolTipSink)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_GOLDEN_AGE_BUILDINGS", iTempMod);
		}

		if (GET_PLAYER(getOwner()).getGoldenAgeYieldMod(eIndex) != 0)
		{
			iTempMod = GET_PLAYER(getOwner()).getGoldenAgeYieldMod(eIndex);
			iModifier += iTempMod;
			if (toolTipSink)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_GOLDEN_AGE_POLICIES", iTempMod);
		}
		if (GET_PLAYER(getOwner()).GetPlayerTraits()->GetGoldenAgeYieldModifier(eIndex) != 0)
		{
			iTempMod = GET_PLAYER(getOwner()).GetPlayerTraits()->GetGoldenAgeYieldModifier(eIndex);
			iModifier += iTempMod;
			if (toolTipSink)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_GOLDEN_AGE_TRAITS", iTempMod);
		}
	}

	// Religion Yield Rate Modifier
	ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
	const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
	if (pReligion)
	{
		int iMaxVal = 0;
		int iReligionYieldMaxFollowersPercent = pReligion->m_Beliefs.GetMaxYieldModifierPerFollowerPercent(iMaxVal, eIndex, getOwner(), this);
		if (iReligionYieldMaxFollowersPercent > 0)
		{
			int iVal = GetCityReligions()->GetNumFollowers(eMajority) * iReligionYieldMaxFollowersPercent;
			if (iVal > 0)
			{
				iVal /= 100;

				if (iVal <= 0)
					iVal = 1;

				iTempMod = min(iMaxVal, iVal);
				iModifier += iTempMod;
				if (toolTipSink)
					GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_BELIEF", iTempMod);
			}
		}
		else
		{
			int iReligionYieldMaxFollowers = pReligion->m_Beliefs.GetMaxYieldModifierPerFollower(eIndex, getOwner(), this);
			if (iReligionYieldMaxFollowers > 0)
			{
				int iFollowers = GetCityReligions()->GetNumFollowers(eMajority);
				iTempMod = min(iFollowers, iReligionYieldMaxFollowers);
				iModifier += iTempMod;
				if (toolTipSink)
					GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_BELIEF", iTempMod);
			}
		}
	}

	// Production Yield Rate Modifier from City States
	if (eIndex == YIELD_PRODUCTION && GetCityBuildings()->GetCityStateTradeRouteProductionModifier() > 0)
	{
		iTempMod = GetCityBuildings()->GetCityStateTradeRouteProductionModifier();
		iModifier += iTempMod;
		if (toolTipSink) {
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_HANSE", iTempMod);
		}
	}
#if defined(MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	if (MOD_BALANCE_CORE_RESOURCE_MONOPOLIES)
	{
		// Do we get increased yields from a resource monopoly?
		int iTempMod = GET_PLAYER(getOwner()).getCityYieldModFromMonopoly(eIndex);
		if (iTempMod != 0)
		{
			iTempMod += GET_PLAYER(getOwner()).GetMonopolyModPercent();
			iModifier += iTempMod;
			if (toolTipSink)
			{
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_MONOPOLY_RESOURCE", iTempMod);
			}
		}
	}
#endif

	ReligionTypes eStateReligion = GET_PLAYER(getOwner()).GetReligions()->GetStateReligion();
	if (MOD_BALANCE_CORE_BELIEFS && eStateReligion != NO_RELIGION)
	{
		const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eStateReligion, getOwner());
		if (pReligion)
		{
			int iGoldenAge = pReligion->m_Beliefs.GetYieldBonusGoldenAge(eIndex, getOwner(), GET_PLAYER(getOwner()).getCity(GetID()), true);
			if (iGoldenAge > 0)
			{
				if (GET_PLAYER(getOwner()).getGoldenAgeTurns() > 0)
				{
					iTempMod = iGoldenAge;
					iModifier += iTempMod;
					GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_GOLDEN_AGE_RELIGION", iTempMod);
				}
			}
			int iWLTKD = pReligion->m_Beliefs.GetYieldFromWLTKD(eIndex, getOwner(), GET_PLAYER(getOwner()).getCity(GetID()));
			if (iWLTKD != 0)
			{
				if (GetWeLoveTheKingDayCounter() > 0)
				{
					iTempMod = iWLTKD;
					iModifier += iTempMod;
					GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WLTKD_RELIGION", iTempMod);
				}
			}
		}
	}

	if (GetWeLoveTheKingDayCounter() > 0)
	{
		if (GET_PLAYER(getOwner()).GetYieldFromWLTKD(eIndex) + GetYieldFromWLTKD(eIndex) != 0)
		{
			iTempMod = (GetYieldFromWLTKD(eIndex) + GET_PLAYER(getOwner()).GetYieldFromWLTKD(eIndex));
			iModifier += iTempMod;
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WLTKD", iTempMod);
		}
		if (GET_PLAYER(getOwner()).GetPlayerTraits()->GetWLTKDCulture() != 0 && eIndex == YIELD_CULTURE)
		{
			iTempMod = GET_PLAYER(getOwner()).GetPlayerTraits()->GetWLTKDCulture();
			iModifier += iTempMod;
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WLTKD_TRAIT", iTempMod);
		}
	}

	// Trait Yield Rate Modifier per Follower
	if (eIndex == YIELD_FOOD && eMajority != NO_RELIGION)
	{
		if (GET_PLAYER(getOwner()).GetPlayerTraits()->IsPopulationBoostReligion() && eMajority == GET_PLAYER(getOwner()).GetReligions()->GetStateReligion(true))
		{
			int iFollowers = GetCityReligions()->GetNumFollowers(eMajority);
			iTempMod = iFollowers * /*1*/ GD_INT_GET(BALANCE_FOLLOWER_FOOD_BONUS);
			iModifier += iTempMod;
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_TRAIT", iTempMod);
		}
	}

	// Puppet
	if (IsPuppet())
	{
		switch (eIndex)
		{
		case YIELD_SCIENCE:
			iTempMod = GET_PLAYER(getOwner()).GetPuppetYieldPenaltyMod() + GET_PLAYER(getOwner()).GetPlayerTraits()->GetPuppetPenaltyReduction() + /*-25 in CP, -80 in VP*/ GD_INT_GET(PUPPET_SCIENCE_MODIFIER);
			if (iTempMod > 0)
				iTempMod = 0;
			iModifier += iTempMod;
			if (iTempMod != 0 && toolTipSink)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_PUPPET", iTempMod);
			break;

		case YIELD_GOLD:
			iTempMod = GET_PLAYER(getOwner()).GetPuppetYieldPenaltyMod() + GET_PLAYER(getOwner()).GetPlayerTraits()->GetPuppetPenaltyReduction() + /*0 in CP, -80 in VP*/ GD_INT_GET(PUPPET_GOLD_MODIFIER);
			if (iTempMod > 0)
				iTempMod = 0;
			iModifier += iTempMod;
			if (iTempMod != 0 && toolTipSink)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_PUPPET", iTempMod);
			break;

		case YIELD_PRODUCTION:
			iTempMod = GET_PLAYER(getOwner()).GetPuppetYieldPenaltyMod() + GET_PLAYER(getOwner()).GetPlayerTraits()->GetPuppetPenaltyReduction() + /*0*/ GD_INT_GET(PUPPET_PRODUCTION_MODIFIER);
			if (iTempMod > 0)
				iTempMod = 0;
			iModifier += iTempMod;
			if (iTempMod != 0 && toolTipSink)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_PUPPET", iTempMod);
			break;

		case YIELD_TOURISM:
			iTempMod = GET_PLAYER(getOwner()).GetPuppetYieldPenaltyMod() + GET_PLAYER(getOwner()).GetPlayerTraits()->GetPuppetPenaltyReduction() + /*0 in CP, -80 in VP*/ GD_INT_GET(PUPPET_TOURISM_MODIFIER);
			if (iTempMod > 0)
				iTempMod = 0;
			iModifier += iTempMod;
			if (iTempMod != 0 && toolTipSink)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_PUPPET", iTempMod);
			break;

		case YIELD_GOLDEN_AGE_POINTS:
			iTempMod = GET_PLAYER(getOwner()).GetPuppetYieldPenaltyMod() + GET_PLAYER(getOwner()).GetPlayerTraits()->GetPuppetPenaltyReduction() + /*0 in CP, -80 in VP*/ GD_INT_GET(PUPPET_GOLDEN_AGE_MODIFIER);
			if (iTempMod > 0)
				iTempMod = 0;
			iModifier += iTempMod;
			if (iTempMod != 0 && toolTipSink)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_PUPPET", iTempMod);
			break;

		case YIELD_CULTURE: // taken from getJONSCulturePerTurn
			iTempMod = GET_PLAYER(getOwner()).GetPuppetYieldPenaltyMod() + GET_PLAYER(getOwner()).GetPlayerTraits()->GetPuppetPenaltyReduction() + /*-25 in CP, -80 in VP*/ GD_INT_GET(PUPPET_CULTURE_MODIFIER);
			if (GET_PLAYER(getOwner()).GetPlayerTraits()->GetPuppetPenaltyReduction() != 0 && iTempMod > 0)
				iTempMod = 0;
			iModifier += iTempMod;
			// FIXME: Disabled because EUI doesn't interact well with this.
			// EUI should be fixed and this re-enabled.
			/*
			if (iTempMod != 0 && toolTipSink)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_PUPPET", iTempMod);
			*/
			break;

		case YIELD_FAITH:
			// FIXME: EUI doesn't expect this information to be populated for faith.
			// Because of this, the calculation is handled in `CvCity::GetFaithPerTurn`.
			// EUI should be fixed and this re-enabled.
			/*
			iTempMod = GET_PLAYER(getOwner()).GetPuppetYieldPenaltyMod() + GET_PLAYER(getOwner()).GetPlayerTraits()->GetPuppetPenaltyReduction() + GD_INT_GET(PUPPET_FAITH_MODIFIER);
			if (iTempMod > 0)
				iTempMod = 0;
			iModifier += iTempMod;

			if (iTempMod != 0 && toolTipSink)
				GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_PUPPET", iTempMod);
			*/
			break;

		case NO_YIELD:
		case YIELD_FOOD:
		case YIELD_GREAT_GENERAL_POINTS:
		case YIELD_GREAT_ADMIRAL_POINTS:
		case YIELD_POPULATION:
		case YIELD_CULTURE_LOCAL:
		case YIELD_JFD_HEALTH:
		case YIELD_JFD_DISEASE:
		case YIELD_JFD_CRIME:
		case YIELD_JFD_LOYALTY:
		case YIELD_JFD_SOVEREIGNTY:
			break; // Yield unaffected by being a puppet.
		}
	}

	// Culture specific modifiers taken from getJONSCulturePerTurn
	if (eIndex == YIELD_CULTURE)
	{
		// getCultureRateModifier() is just the culture specific building modifiers
		iTempMod = getCultureRateModifier();
		iModifier += iTempMod;
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_BUILDING_CITY", iTempMod);

		// Player modifier
		iTempMod = GET_PLAYER(getOwner()).GetJONSCultureCityModifier();
		iModifier += iTempMod;
		// we'll use the same tooltip as for Building_GlobalYieldModifiers
		GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_YIELD_PLAYER", iTempMod);

		// Wonder here?
		if (getNumWorldWonders() > 0)
		{
			// policy that grants culture modifier from each wonder (field CultureWonderMultiplier)
			iTempMod = GET_PLAYER(getOwner()).GetCultureWonderMultiplier();
			iModifier += iTempMod;
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_WONDER_POLICY", iTempMod);
		}

		if (MOD_BALANCE_VP && GET_PLAYER(getOwner()).IsLeagueAid())
		{
			iTempMod = GET_PLAYER(getOwner()).GetLeagueCultureCityModifier();
			iModifier += iTempMod;
			GC.getGame().BuildProdModHelpText(toolTipSink, "TXT_KEY_PRODMOD_LEAGUE", iTempMod);
		}
	}

	iModifier += iExtra;

	// note: player->invalidateYieldRankCache() must be called for anything that is checked here
	// so if any extra checked things are added here, the cache needs to be invalidated

	return std::max(0, (iModifier + 100));
}

//	--------------------------------------------------------------------------------
int CvCity::getHappinessModifier(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	if (MOD_BALANCE_VP)
		return 0;

	int iModifier = 0;
	CvPlayer& kPlayer = GET_PLAYER(getOwner());

	if (kPlayer.IsEmpireUnhappy())
	{
		int iUnhappy = -1 * kPlayer.GetExcessHappiness();

		// Production and Gold slow down when Empire is Unhappy
		if (eIndex == YIELD_PRODUCTION)
		{
			iModifier = iUnhappy * /*-2*/ GD_INT_GET(VERY_UNHAPPY_PRODUCTION_PENALTY_PER_UNHAPPY);
			iModifier = max(iModifier, /*-40*/ GD_INT_GET(VERY_UNHAPPY_MAX_PRODUCTION_PENALTY));
		}
		else if (eIndex == YIELD_GOLD)
		{
			iModifier = iUnhappy * /*-2*/ GD_INT_GET(VERY_UNHAPPY_GOLD_PENALTY_PER_UNHAPPY);
			iModifier = max(iModifier, /*-40*/ GD_INT_GET(VERY_UNHAPPY_MAX_GOLD_PENALTY));
		}
	}

	return iModifier;
}
//	--------------------------------------------------------------------------------
int CvCity::getYieldRate(YieldTypes eIndex, bool bIgnoreTrade, bool bStatic) const
{
	VALIDATE_OBJECT

	if (bStatic && !bIgnoreTrade)
	{
		return (GetStaticYield(eIndex) / 100);
	}

	return (getYieldRateTimes100(eIndex, bIgnoreTrade) / 100);
}
//	--------------------------------------------------------------------------------
int CvCity::getYieldRateTimes100(YieldTypes eIndex, bool bIgnoreTrade, bool bStatic) const
{
	VALIDATE_OBJECT

	if (bStatic && !bIgnoreTrade)
	{
		return GetStaticYield(eIndex);
	}

	// Anarchy, Resistance or Razing - no Science, Gold or Production (Prod handled in ProductionDifference)
	if (GET_PLAYER(getOwner()).IsAnarchy() || IsResistance() || IsRazing())
	{
		if (eIndex == YIELD_GOLD || eIndex == YIELD_SCIENCE)
		{
			return 0;
		}

		if (eIndex == YIELD_TOURISM)
		{
			return 0;
		}

		if (eIndex == YIELD_GOLDEN_AGE_POINTS)
		{
			return 0;
		}

		if (eIndex == YIELD_GREAT_GENERAL_POINTS)
		{
			return 0;
		}
		if (eIndex == YIELD_GREAT_ADMIRAL_POINTS)
		{
			return 0;
		}
		if (eIndex == YIELD_POPULATION)
		{
			return 0;
		}
		if (eIndex == YIELD_CULTURE_LOCAL)
		{
			return 0;
		}
	}

	int iPostModifierYield = 0;

	if (getProductionToYieldModifier(eIndex) != 0)
	{
		// We want to process production to production and call it stockpiling!
		iPostModifierYield = (getBasicYieldRateTimes100(YIELD_PRODUCTION) * getProductionToYieldModifier(eIndex)) / 100;
	}

	if (!bIgnoreTrade)
	{
		iPostModifierYield += GET_PLAYER(m_eOwner).GetTrade()->GetTradeValuesAtCityTimes100(this, eIndex);
	}

	return getBasicYieldRateTimes100(eIndex) + iPostModifierYield;
}

int CvCity::getBasicYieldRateTimes100(YieldTypes eIndex) const
{
	// Sum up yield rate
	int iBaseYield = getBaseYieldRate(eIndex) * 100;
	iBaseYield += (GetYieldPerPopTimes100(eIndex) * getPopulation());
	iBaseYield += (GetYieldPerPopInEmpireTimes100(eIndex) * GET_PLAYER(m_eOwner).getTotalPopulation());

	// Player-level yield per religion
	iBaseYield += GET_PLAYER(m_eOwner).GetYieldChangesPerReligionTimes100(eIndex) * GetCityReligions()->GetNumReligionsWithFollowers();

	int iNonSpecialist = GET_PLAYER(m_eOwner).getYieldFromNonSpecialistCitizens(eIndex);
	if (iNonSpecialist != 0)
	{
		int iBonusTimes100 = (iNonSpecialist * (getPopulation() - GetCityCitizens()->GetTotalSpecialistCount()));
		iBaseYield += iBonusTimes100;
	}

	int iModifiedYield = iBaseYield * getBaseYieldRateModifier(eIndex, 0, NULL);
	iModifiedYield /= 100;

	return iModifiedYield;
}

void CvCity::UpdateCityYieldFromYield(YieldTypes eIndex1, YieldTypes eIndex2, int iModifiedYield)
{
	if (iModifiedYield > 0)
	{
		int iYieldVal = GetBuildingYieldFromYield(eIndex1, eIndex2);
		if (iYieldVal > 0)
		{
			int iBonusYield = (iModifiedYield * iYieldVal / 100);
			if (iBonusYield > 0)
			{
				SetRealYieldFromYield(eIndex1, eIndex2, iBonusYield);
			}
			else
			{
				SetRealYieldFromYield(eIndex1, eIndex2, 0);
			}
		}
		else
		{
			SetRealYieldFromYield(eIndex1, eIndex2, 0);
		}
	}
}

//	--------------------------------------------------------------------------------
int CvCity::getBaseYieldRate(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	int iValue = 0;
	iValue += GetBaseYieldRateFromGreatWorks(eIndex);
	iValue += GetBaseYieldRateFromTerrain(eIndex);
	iValue += GetBaseYieldRateFromBuildings(eIndex);
	iValue += GetBaseYieldRateFromSpecialists(eIndex);
	iValue += GetBaseYieldRateFromMisc(eIndex);
	iValue += GetBaseYieldRateFromReligion(eIndex);
#if defined(MOD_BALANCE_CORE)
	iValue += GetBaseYieldRateFromCSAlliance(eIndex);
	iValue += GetBaseYieldRateFromCSFriendship(eIndex);
	iValue += GetYieldFromMinors(eIndex);
	iValue += GetYieldPerTurnFromTraits(eIndex);
	iValue += GetYieldChangeFromCorporationFranchises(eIndex);
	iValue += GetEventCityYield(eIndex);
#endif

	if (IsRouteToCapitalConnected())
	{
		int iEra = GET_PLAYER(getOwner()).GetCurrentEra();
		if (iEra <= 0)
			iEra = 1;
		iValue += GET_PLAYER(getOwner()).GetYieldChangeTradeRoute(eIndex);
		iValue += GET_PLAYER(getOwner()).GetPlayerTraits()->GetYieldChangeTradeRoute(eIndex) * iEra;
	}

	if (GET_PLAYER(getOwner()).IsLeagueArt() && eIndex == YIELD_SCIENCE)
	{
		iValue += GetBaseScienceFromArt();
	}

	if (MOD_YIELD_MODIFIER_FROM_UNITS)
	{
		CvPlot* pCityPlot = plot();
		for (int iUnitLoop = 0; iUnitLoop < pCityPlot->getNumUnits(); iUnitLoop++)
		{
			int iTempVal = pCityPlot->getUnitByIndex(iUnitLoop)->GetYieldChange(eIndex);
			if (iTempVal != 0)
			{
				iValue += iTempVal;
			}
		}
	}

	ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
	if (eMajority != NO_RELIGION && eMajority > RELIGION_PANTHEON)
	{
		if (GET_PLAYER(getOwner()).GetReligions()->GetStateReligion() == eMajority)
		{
			iValue += GET_PLAYER(getOwner()).getReligionYieldRateModifier(eIndex);
		}
	}

#if defined(MOD_BALANCE_CORE)
	//Update Yields from yields ... need to sidestep constness
	CvCity* pThisCity = const_cast<CvCity*>(this);
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eIndex2 = (YieldTypes)iI;
		if (eIndex2 == NO_YIELD)
			continue;
		if (eIndex == eIndex2)
			continue;

		pThisCity->UpdateCityYieldFromYield(eIndex, eIndex2, iValue);

		//NOTE! We flip it here, because we want the OUT yield
		iValue += GetRealYieldFromYield(eIndex2, eIndex);
	}

	iValue += GetYieldFromHappiness(eIndex);
	iValue += GetYieldFromHealth(eIndex);
	if (eIndex != YIELD_JFD_CRIME)
	{
		iValue += GetYieldFromCrime(eIndex);
		iValue += GetYieldFromDevelopment(eIndex);
	}
#endif

	return iValue;
}

/// Where is our Science coming from?
int CvCity::GetBaseScienceFromArt() const
{
	return GetBaseYieldRateFromLeague(YIELD_SCIENCE);
}

//	--------------------------------------------------------------------------------
/// Base yield rate from Great Works
int CvCity::GetBaseYieldRateFromGreatWorks(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (m_GwYieldCache[eIndex] == -1)
		m_GwYieldCache[eIndex] = GetCityBuildings()->GetYieldFromGreatWorks(eIndex);

	return m_GwYieldCache[eIndex];
}

//	--------------------------------------------------------------------------------
/// Base yield rate from Terrain
int CvCity::GetBaseYieldRateFromTerrain(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	return m_aiBaseYieldRateFromTerrain[eIndex];
}

//	--------------------------------------------------------------------------------
/// Base yield rate from Terrain
void CvCity::ChangeBaseYieldRateFromTerrain(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		if (m_aiBaseYieldRateFromTerrain[eIndex] + iChange < 0)
			CUSTOMLOG("houston, we have a problem! inconsistent yield in %s\n", getNameKey());

		m_aiBaseYieldRateFromTerrain[eIndex] += iChange;

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			if (isCitySelected())
			{
				DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
			}
		}
	}
}

/// Base yield rate from Terrain
void CvCity::SetBaseYieldRateFromTerrain(YieldTypes eIndex, int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iValue != m_aiBaseYieldRateFromTerrain[eIndex])
	{
		m_aiBaseYieldRateFromTerrain[eIndex] = iValue;

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			if (isCitySelected())
			{
				DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Base yield rate from Buildings
int CvCity::GetBaseYieldRateFromBuildings(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiBaseYieldRateFromBuildings[eIndex];
}

//	--------------------------------------------------------------------------------
/// Base yield rate from Buildings
void CvCity::ChangeBaseYieldRateFromBuildings(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiBaseYieldRateFromBuildings[eIndex] = m_aiBaseYieldRateFromBuildings[eIndex] + iChange;

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			if (isCitySelected())
			{
				DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
				//DLLUI->setDirty(InfoPane_DIRTY_BIT, true );
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Base yield rate from Specialists
int CvCity::GetBaseYieldRateFromSpecialists(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	return m_aiBaseYieldRateFromSpecialists[eIndex];
}

//	--------------------------------------------------------------------------------
/// Base yield rate from Specialists
void CvCity::ChangeBaseYieldRateFromSpecialists(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiBaseYieldRateFromSpecialists[eIndex] = m_aiBaseYieldRateFromSpecialists[eIndex] + iChange;

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			if (isCitySelected())
			{
				DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
			}
		}
	}
}

//	--------------------------------------------------------------------------------
/// Base yield rate from Misc
int CvCity::GetBaseYieldRateFromMisc(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	return m_aiBaseYieldRateFromMisc[eIndex];
}

//	--------------------------------------------------------------------------------
/// Base yield rate from Misc
void CvCity::ChangeBaseYieldRateFromMisc(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiBaseYieldRateFromMisc[eIndex] = m_aiBaseYieldRateFromMisc[eIndex] + iChange;

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			if (isCitySelected())
			{
				DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
			}
		}
	}
}
//	--------------------------------------------------------------------------------
//	Base yield rate from active conversion Process
int CvCity::GetBaseYieldRateFromProcess(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	// Process production into specific yield
	return (getBasicYieldRateTimes100(YIELD_PRODUCTION) * getProductionToYieldModifier(eIndex)) / 10000;
}

// Base yield rate from League
int CvCity::GetBaseYieldRateFromLeague(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	return m_aiBaseYieldRateFromLeague[eIndex];
}

//	--------------------------------------------------------------------------------
/// Base yield rate from League
void CvCity::ChangeBaseYieldRateFromLeague(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiBaseYieldRateFromLeague[eIndex] = m_aiBaseYieldRateFromLeague[eIndex] + iChange;

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			if (isCitySelected())
			{
				DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
			}
		}
	}
}
//SCIENCY AID - Used for negation if cancelled
void CvCity::ChangeTotalScienceyAid(int iChange)
{
	SetTotalScienceyAid(GetTotalScienceyAid() + iChange);
}

int CvCity::GetTotalScienceyAid() const
{
	return m_iTotalScienceyAid;
}

void CvCity::SetTotalScienceyAid(int iValue)
{
	if (GetTotalScienceyAid() != iValue)
		m_iTotalScienceyAid = iValue;
}

//ARTSY AID TOTALS  - Used for negation if cancelled
void CvCity::ChangeTotalArtsyAid(int iChange)
{
	SetTotalArtsyAid(GetTotalArtsyAid() + iChange);
}

int CvCity::GetTotalArtsyAid() const
{
	return m_iTotalArtsyAid;
}

void CvCity::SetTotalArtsyAid(int iValue)
{
	if (GetTotalArtsyAid() != iValue)
		m_iTotalArtsyAid = iValue;
}

//GREAT WORK AID TOTALS  - Used for negation if cancelled
void CvCity::ChangeTotalGreatWorkAid(int iChange)
{
	SetTotalGreatWorkAid(GetTotalGreatWorkAid() + iChange);
}

int CvCity::GetTotalGreatWorkAid() const
{
	return m_iTotalGreatWorkAid;
}

void CvCity::SetTotalGreatWorkAid(int iValue)
{
	if (GetTotalGreatWorkAid() != iValue)
		m_iTotalGreatWorkAid = iValue;
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetGrowthExtraYield(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiChangeGrowthExtraYield[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeGrowthExtraYield(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiChangeGrowthExtraYield[eIndex] = m_aiChangeGrowthExtraYield[eIndex] + iChange;
		CvAssert(GetGrowthExtraYield(eIndex) >= 0);
	}
}
#endif
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromVictory(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromVictory[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromVictory(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromVictory[eIndex] = m_aiYieldFromVictory[eIndex] + iChange;
		CvAssert(GetYieldFromVictory(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromVictoryGlobal(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromVictoryGlobal[eIndex];
}

void CvCity::ChangeYieldFromVictoryGlobal(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromVictoryGlobal[eIndex] = m_aiYieldFromVictoryGlobal[eIndex] + iChange;
		CvAssert(GetYieldFromVictoryGlobal(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from building, scaling with era
int CvCity::GetYieldFromVictoryGlobalEraScaling(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
		CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromVictoryGlobalEraScaling[eIndex];
}

void CvCity::ChangeYieldFromVictoryGlobalEraScaling(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
		CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromVictoryGlobalEraScaling[eIndex] = m_aiYieldFromVictoryGlobalEraScaling[eIndex] + iChange;
		CvAssert(GetYieldFromVictoryGlobalEraScaling(eIndex) >= 0);
	}
}



int CvCity::GetYieldFromPillage(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromPillage[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromPillage(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromPillage[eIndex] = m_aiYieldFromPillage[eIndex] + iChange;
		CvAssert(GetYieldFromPillage(eIndex) >= 0);
	}
}

int CvCity::GetYieldFromPillageGlobal(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromPillageGlobal[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromPillageGlobal(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromPillageGlobal[eIndex] = m_aiYieldFromPillageGlobal[eIndex] + iChange;
		CvAssert(GetYieldFromPillageGlobal(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetGoldenAgeYieldMod(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiGoldenAgeYieldMod[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeGoldenAgeYieldMod(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiGoldenAgeYieldMod[eIndex] = m_aiGoldenAgeYieldMod[eIndex] + iChange;
		CvAssert(GetGoldenAgeYieldMod(eIndex) >= 0);
	}
}


//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromWLTKD(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromWLTKD[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromWLTKD(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromWLTKD[eIndex] = m_aiYieldFromWLTKD[eIndex] + iChange;
		CvAssert(GetYieldFromWLTKD(eIndex) >= 0);
	}
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromConstruction(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromConstruction[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromConstruction(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromConstruction[eIndex] = m_aiYieldFromConstruction[eIndex] + iChange;
		CvAssert(GetYieldFromConstruction(eIndex) >= 0);
	}
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromTech(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromTech[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromTech(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromTech[eIndex] = m_aiYieldFromTech[eIndex] + iChange;
		CvAssert(GetYieldFromTech(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromBirth(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromBirth[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromBirth(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromBirth[eIndex] = m_aiYieldFromBirth[eIndex] + iChange;
		CvAssert(GetYieldFromBirth(eIndex) >= 0);
	}
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromUnitProduction(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromUnitProduction[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromUnitProduction(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromUnitProduction[eIndex] = m_aiYieldFromUnitProduction[eIndex] + iChange;
		CvAssert(GetYieldFromUnitProduction(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromBorderGrowth(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromBorderGrowth[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromBorderGrowth(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromBorderGrowth[eIndex] = m_aiYieldFromBorderGrowth[eIndex] + iChange;
		CvAssert(GetYieldFromBorderGrowth(eIndex) >= 0);
	}
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromPolicyUnlock(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromPolicyUnlock[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromPolicyUnlock(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromPolicyUnlock[eIndex] = m_aiYieldFromPolicyUnlock[eIndex] + iChange;
		CvAssert(GetYieldFromPolicyUnlock(eIndex) >= 0);
	}
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromPurchase(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromPurchase[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromPurchase(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromPurchase[eIndex] = m_aiYieldFromPurchase[eIndex] + iChange;
		CvAssert(GetYieldFromPurchase(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromFaithPurchase(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromFaithPurchase[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromFaithPurchase(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromFaithPurchase[eIndex] = m_aiYieldFromFaithPurchase[eIndex] + iChange;
		CvAssert(GetYieldFromFaithPurchase(eIndex) >= 0);
	}
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromUnitLevelUp(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromUnitLevelUp[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromUnitLevelUp(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromUnitLevelUp[eIndex] = m_aiYieldFromUnitLevelUp[eIndex] + iChange;
		CvAssert(GetYieldFromUnitLevelUp(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromCombatExperience(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromCombatExperience[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromCombatExperience(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromCombatExperience[eIndex] = m_aiYieldFromCombatExperience[eIndex] + iChange;
		CvAssert(GetYieldFromCombatExperience(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldPerAlly(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldPerAlly[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldPerAlly(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldPerAlly[eIndex] = m_aiYieldPerAlly[eIndex] + iChange;
		CvAssert(GetYieldPerAlly(eIndex) >= 0);
	}
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldPerFriend(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldPerFriend[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldPerFriend(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldPerFriend[eIndex] = m_aiYieldPerFriend[eIndex] + iChange;
		CvAssert(GetYieldPerFriend(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetRealYieldFromYield(YieldTypes eIndex1, YieldTypes eIndex2) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex1 >= 0, "eIndex1 expected to be >= 0");
	CvAssertMsg(eIndex1 < NUM_YIELD_TYPES, "eIndex1 expected to be < NUM_YIELD_TYPES");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 expected to be >= 0");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 expected to be < NUM_YIELD_TYPES");

	return ModifierLookup(m_yieldChanges[eIndex2].forActualYield, eIndex1);
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::SetRealYieldFromYield(YieldTypes eIndex1, YieldTypes eIndex2, int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex1 >= 0, "eIndex1 expected to be >= 0");
	CvAssertMsg(eIndex1 < NUM_YIELD_TYPES, "eIndex1 expected to be < NUM_YIELD_TYPES");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 expected to be >= 0");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 expected to be < NUM_YIELD_TYPES");

	ModifierUpdateInsertRemove(m_yieldChanges[eIndex2].forActualYield, eIndex1, iValue, false);
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetBuildingYieldFromYield(YieldTypes eIndex1, YieldTypes eIndex2) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < NUM_YIELD_TYPES, "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	return ModifierLookup(m_yieldChanges[eIndex2].forYield, eIndex1);
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeBuildingYieldFromYield(YieldTypes eIndex1, YieldTypes eIndex2, int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex1 < NUM_YIELD_TYPES, "eIndex1 is expected to be within maximum bounds (invalid Index)");
	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be non-negative (invalid Index)");
	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be within maximum bounds (invalid Index)");

	ModifierUpdateInsertRemove(m_yieldChanges[eIndex2].forYield, eIndex1, iValue, true);
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromInternalTREnd(YieldTypes eIndex1) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex1 >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex1 < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	return m_aiYieldFromInternalTREnd[eIndex1];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromInternalTREnd(YieldTypes eIndex1, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex1 >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex1 < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	if (iChange != 0)
	{
		m_aiYieldFromInternalTREnd[eIndex1] = m_aiYieldFromInternalTREnd[eIndex1] + iChange;
		CvAssert(GetYieldFromInternalTREnd(eIndex1) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromInternalTR(YieldTypes eIndex1) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex1 >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex1 < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	return m_aiYieldFromInternalTR[eIndex1];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromInternalTR(YieldTypes eIndex1, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex1 >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex1 < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	if (iChange != 0)
	{
		m_aiYieldFromInternalTR[eIndex1] = m_aiYieldFromInternalTR[eIndex1] + iChange;
		CvAssert(GetYieldFromInternalTR(eIndex1) >= 0);
	}
}


//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetYieldFromProcessModifier(YieldTypes eIndex1) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex1 >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex1 < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	return m_aiYieldFromProcessModifier[eIndex1];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromProcessModifier(YieldTypes eIndex1, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex1 >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex1 < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	if (iChange != 0)
	{
		m_aiYieldFromProcessModifier[eIndex1] = m_aiYieldFromProcessModifier[eIndex1] + iChange;
		CvAssert(GetYieldFromProcessModifier(eIndex1) >= 0);
	}
}

/// Extra yield from building
int CvCity::GetSpecialistRateModifier(SpecialistTypes eSpecialist) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eSpecialist >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eSpecialist < GC.getNumSpecialistInfos(), "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiSpecialistRateModifier[eSpecialist];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeSpecialistRateModifier(SpecialistTypes eSpecialist, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eSpecialist >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eSpecialist < GC.getNumSpecialistInfos(), "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiSpecialistRateModifier[eSpecialist] = m_aiSpecialistRateModifier[eSpecialist] + iChange;
		CvAssert(GetSpecialistRateModifier(eSpecialist) >= 0);
	}
}
//	--------------------------------------------------------------------------------
/// Extra yield from building
int CvCity::GetThemingYieldBonus(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiThemingYieldBonus[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeThemingYieldBonus(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiThemingYieldBonus[eIndex] = m_aiThemingYieldBonus[eIndex] + iChange;
		CvAssert(GetThemingYieldBonus(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from spy attacks
int CvCity::GetYieldFromSpyAttack(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromSpyAttack[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromSpyAttack(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromSpyAttack[eIndex] = m_aiYieldFromSpyAttack[eIndex] + iChange;
		CvAssert(GetYieldFromSpyAttack(eIndex) >= 0);
	}
}

//	--------------------------------------------------------------------------------
/// Extra yield from spy defense
int CvCity::GetYieldFromSpyDefense(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldFromSpyDefense[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield from building
void CvCity::ChangeYieldFromSpyDefense(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldFromSpyDefense[eIndex] = m_aiYieldFromSpyDefense[eIndex] + iChange;
		CvAssert(GetYieldFromSpyDefense(eIndex) >= 0);
	}
}
#endif
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Extra great person progress from constructing buildings
int CvCity::GetGreatPersonProgressFromConstruction(GreatPersonTypes eGreatPerson, EraTypes eEra) const
{
	VALIDATE_OBJECT

	CvAssertMsg(eGreatPerson >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eGreatPerson < GC.getNumGreatPersonInfos(), "eIndex expected to be < GC.getNumGreatPersonInfos()");

	CvAssertMsg(eEra >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eEra < GC.getNumEraInfos(), "eIndex expected to be < GC.getNumEraInfos()");

	if (eGreatPerson != NO_GREATPERSON && eEra != NO_ERA)
	{
		std::map<std::pair<int, int>, short>::const_iterator it = m_ppiGreatPersonProgressFromConstruction.find(std::make_pair((int)eGreatPerson, (int)eEra));
		if (it != m_ppiGreatPersonProgressFromConstruction.end()) // find returns the iterator to map::end if the key eGreatPerson is not present in the map
		{
			return it->second;
		}
	}

	return 0;
}

//	--------------------------------------------------------------------------------
/// Extra great person progress from constructing buildings
void CvCity::ChangeGreatPersonProgressFromConstruction(GreatPersonTypes eGreatPerson, EraTypes eEra, int iChange)
{
	VALIDATE_OBJECT

	CvAssertMsg(eGreatPerson >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eGreatPerson < GC.getNumGreatPersonInfos(), "eIndex expected to be < GC.getNumGreatPersonInfos()");

	CvAssertMsg(eEra >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eEra < GC.getNumEraInfos(), "eIndex expected to be < GC.getNumEraInfos()");

	if (eGreatPerson != NO_GREATPERSON && eEra != NO_ERA && iChange != 0)
	{
		std::map<std::pair<int, int>, short>::iterator it = m_ppiGreatPersonProgressFromConstruction.find(std::make_pair((int)eGreatPerson, (int)eEra));
		if (it == m_ppiGreatPersonProgressFromConstruction.end()) // if the key (eGreatPerson, eEra) does not exist
		{
			m_ppiGreatPersonProgressFromConstruction.insert(std::pair<std::pair<int, int>, short>(std::make_pair((int)eGreatPerson, (int)eEra), iChange));
		}
		else // if the key (eGreatPerson, eEra) does exist
		{
			it->second += iChange;
		}
	}
}
#endif

//	--------------------------------------------------------------------------------
int CvCity::GetEmpireSizeModifierReduction() const
{
	return m_iEmpireSizeModifierReduction;
}
void CvCity::ChangeEmpireSizeModifierReduction(int iChange)
{
	m_iEmpireSizeModifierReduction += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetDistressFlatReduction() const
{
	return m_iDistressFlatReduction;
}
void CvCity::ChangeDistressFlatReduction(int iChange)
{
	m_iDistressFlatReduction += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetPovertyFlatReduction() const
{
	return m_iPovertyFlatReduction;
}
void CvCity::ChangePovertyFlatReduction(int iChange)
{
	m_iPovertyFlatReduction += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetIlliteracyFlatReduction() const
{
	return m_iIlliteracyFlatReduction;
}
void CvCity::ChangeIlliteracyFlatReduction(int iChange)
{
	m_iIlliteracyFlatReduction += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetBoredomFlatReduction() const
{
	return m_iBoredomFlatReduction;
}
void CvCity::ChangeBoredomFlatReduction(int iChange)
{
	m_iBoredomFlatReduction += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetReligiousUnrestFlatReduction() const
{
	return m_iReligiousUnrestFlatReduction;
}
void CvCity::ChangeReligiousUnrestFlatReduction(int iChange)
{
	m_iReligiousUnrestFlatReduction += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetBasicNeedsMedianModifier() const
{
	if (isCapital())
		return m_iBasicNeedsMedianModifier + GET_PLAYER(getOwner()).GetBasicNeedsMedianModifierCapital();

	return m_iBasicNeedsMedianModifier;
}
void CvCity::ChangeBasicNeedsMedianModifier(int iChange)
{
	m_iBasicNeedsMedianModifier += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetGoldMedianModifier() const
{
	if (isCapital())
		return m_iGoldMedianModifier + GET_PLAYER(getOwner()).GetGoldMedianModifierCapital();

	return m_iGoldMedianModifier;
}
void CvCity::ChangeGoldMedianModifier(int iChange)
{
	m_iGoldMedianModifier += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetScienceMedianModifier() const
{
	if (isCapital())
		return m_iScienceMedianModifier + GET_PLAYER(getOwner()).GetScienceMedianModifierCapital();

	return m_iScienceMedianModifier;
}
void CvCity::ChangeScienceMedianModifier(int iChange)
{
	m_iScienceMedianModifier += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetCultureMedianModifier() const
{
	if (isCapital())
		return m_iCultureMedianModifier + GET_PLAYER(getOwner()).GetCultureMedianModifierCapital();

	return m_iCultureMedianModifier;
}
void CvCity::ChangeCultureMedianModifier(int iChange)
{
	m_iCultureMedianModifier += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::GetReligiousUnrestModifier() const
{
	if (isCapital())
		return m_iReligiousUnrestModifier + GET_PLAYER(getOwner()).GetReligiousUnrestModifierCapital();

	return m_iReligiousUnrestModifier;
}
void CvCity::ChangeReligiousUnrestModifier(int iChange)
{
	m_iReligiousUnrestModifier += iChange;
}

//	--------------------------------------------------------------------------------
/// Base yield rate from Religion
int CvCity::GetBaseYieldRateFromReligion(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	int iBaseYield = m_aiBaseYieldRateFromReligion[eIndex];

	const SCityExtraYields& y = GetYieldChanges(eIndex);
	for (vector<pair<TerrainTypes, int>>::const_iterator it = y.forTerrainFromReligion.begin(); it != y.forTerrainFromReligion.end(); ++it)
		iBaseYield += it->second;
	for (vector<pair<FeatureTypes, int>>::const_iterator it = y.forFeatureFromReligion.begin(); it != y.forFeatureFromReligion.end(); ++it)
		iBaseYield += it->second;

	if (GET_PLAYER(getOwner()).GetPlayerTraits()->GetYieldFromOwnPantheon(eIndex) > 0)
	{
		ReligionTypes eReligionFounded = GET_PLAYER(getOwner()).GetReligions()->GetOwnedReligion();
		if (eReligionFounded == NO_RELIGION)
			eReligionFounded = GET_PLAYER(getOwner()).GetReligions()->GetReligionCreatedByPlayer(true);

		if (MOD_BALANCE_CORE_BELIEFS && eReligionFounded >= RELIGION_PANTHEON)
		{
			ReligionTypes eMajorityReligion = GetCityReligions()->GetReligiousMajority();
			ReligionTypes ePlayerPantheon = GC.getGame().GetGameReligions()->GetPantheonCreatedByPlayer(getOwner());
			if (eMajorityReligion != NO_RELIGION && (eMajorityReligion == eReligionFounded || eMajorityReligion == ePlayerPantheon))
			{
				iBaseYield += GET_PLAYER(getOwner()).GetPlayerTraits()->GetYieldFromOwnPantheon(eIndex);
			}
		}
	}
	// This will only return a value for food and production
	iBaseYield += GetYieldPerTurnFromReligion(eIndex);

	return iBaseYield;
}
//	--------------------------------------------------------------------------------
/// Base yield rate from Religion
void CvCity::ChangeBaseYieldRateFromReligion(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiBaseYieldRateFromReligion[eIndex] = m_aiBaseYieldRateFromReligion[eIndex] + iChange;

		if (getTeam() == GC.getGame().getActiveTeam())
		{
			if (isCitySelected())
			{
				DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
			}
		}
	}
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Base yield rate from CS Alliances
int CvCity::GetBaseYieldRateFromCSAlliance(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	int iValue = 0;
	if (GetYieldPerAlly(eIndex) != 0)
	{
		iValue += (GetYieldPerAlly(eIndex) * GET_PLAYER(getOwner()).GetNumCSAllies());
	}
	return (m_aiBaseYieldRateFromCSAlliance[eIndex] + iValue);
}
//	--------------------------------------------------------------------------------
/// Base yield rate from CS Alliances
void CvCity::ChangeBaseYieldRateFromCSAlliance(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiBaseYieldRateFromCSAlliance[eIndex] = m_aiBaseYieldRateFromCSAlliance[eIndex] + iChange;
		CvAssert(GetBaseYieldRateFromCSAlliance(eIndex) >= 0);
	}
}
void CvCity::SetBaseYieldRateFromCSAlliance(YieldTypes eIndex, int iValue)
{
	if (GetBaseYieldRateFromCSAlliance(eIndex) != iValue)
	{
		m_aiBaseYieldRateFromCSAlliance[eIndex] = iValue;
	}
}
//	--------------------------------------------------------------------------------
/// Base yield rate from CS Friendships
int CvCity::GetBaseYieldRateFromCSFriendship(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	int iValue = 0;
	if (GetYieldPerFriend(eIndex) != 0)
	{
		iValue += (GetYieldPerFriend(eIndex) * GET_PLAYER(getOwner()).GetNumCSFriends());
	}
	return (m_aiBaseYieldRateFromCSFriendship[eIndex] + iValue);
}
void CvCity::ChangeBaseYieldRateFromCSFriendship(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiBaseYieldRateFromCSFriendship[eIndex] = m_aiBaseYieldRateFromCSFriendship[eIndex] + iChange;
		CvAssert(GetBaseYieldRateFromCSFriendship(eIndex) >= 0);
	}
}
void CvCity::SetBaseYieldRateFromCSFriendship(YieldTypes eIndex, int iValue)
{
	if (GetBaseYieldRateFromCSFriendship(eIndex) != iValue)
	{
		m_aiBaseYieldRateFromCSFriendship[eIndex] = iValue;
	}
}

void CvCity::SetYieldFromMinors(YieldTypes eYield, int iValue)
{
	m_aiYieldFromMinors[eYield] = iValue;
}
int CvCity::GetYieldFromMinors(YieldTypes eYield) const
{
	return m_aiYieldFromMinors[eYield];
}
//CORPORATIONS
//	--------------------------------------------------------------------------------
// Get the yield modifier change from having a Corporation
int CvCity::GetTradeRouteCityMod(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	CorporationTypes eCorporation = GET_PLAYER(getOwner()).GetCorporations()->GetFoundedCorporation();
	if (eCorporation == NO_CORPORATION)
		return 0;

	CvCorporationEntry* pkCorporationInfo = GC.getCorporationInfo(eCorporation);
	if (pkCorporationInfo == NULL)
		return 0;

	// If our Corporation does not have a city yield mod, remove
	if (pkCorporationInfo->GetTradeRouteCityMod(eIndex) == 0)
		return 0;

	if (!IsHasOffice())
		return 0;

	int iMod = 0;
	CvGameTrade* pGameTrade = GC.getGame().GetGameTrade();
	for (uint ui = 0; ui < pGameTrade->GetNumTradeConnections(); ui++)
	{
		if (pGameTrade->IsTradeRouteIndexEmpty(ui))
			continue;

		const TradeConnection& conn = pGameTrade->GetTradeConnection(ui);
		if (conn.m_eOriginOwner != getOwner()) //fast check
			continue;

		CvCity* pOriginCity = CvGameTrade::GetOriginCity(conn);
		if (pOriginCity != this)
			continue;

		CvCity* pDestCity = CvGameTrade::GetDestCity(conn);
		if (pOriginCity != NULL && pDestCity != NULL)
		{
			if (pOriginCity->IsHasOffice() && pDestCity->IsHasFranchise(eCorporation))
			{
				iMod += pkCorporationInfo->GetTradeRouteCityMod(eIndex);
			}
		}
	}
	return iMod;
}

int CvCity::GetGPRateModifierPerXFranchises() const
{
	CorporationTypes eCorporation = GET_PLAYER(getOwner()).GetCorporations()->GetFoundedCorporation();
	if (eCorporation == NO_CORPORATION)
		return false;

	CvCorporationEntry* pkCorporationInfo = GC.getCorporationInfo(eCorporation);
	if (pkCorporationInfo == NULL || !pkCorporationInfo)
		return 0;

	// Calculate what our input into the corporation helper we need
	int iCurrentValue = 0;

	BuildingTypes eOffice = NO_BUILDING;
	if (MOD_BUILDINGS_THOROUGH_PREREQUISITES)
	{
		if (HasBuildingClass(pkCorporationInfo->GetOfficeBuildingClass()))
		{
			eOffice = GetCityBuildings()->GetBuildingTypeFromClass(pkCorporationInfo->GetOfficeBuildingClass());
		}
		else
		{
			eOffice = (BuildingTypes)GET_PLAYER(getOwner()).getCivilizationInfo().getCivilizationBuildings(pkCorporationInfo->GetOfficeBuildingClass());
		}
	}
	else
	{
		eOffice = (BuildingTypes)GET_PLAYER(getOwner()).getCivilizationInfo().getCivilizationBuildings(pkCorporationInfo->GetOfficeBuildingClass());
	}
	if (eOffice == NO_BUILDING)
		return 0;

	CvBuildingEntry* pkOfficeInfo = GC.getBuildingInfo(eOffice);
	if (pkOfficeInfo == NULL)
		return 0;

	int iNumFranchises = GET_PLAYER(getOwner()).GetCorporations()->GetNumFranchises();

	if (iNumFranchises > 0)
	{
		// Civilized Jewelers
		if (pkOfficeInfo->GetGPRateModifierPerXFranchises() > 0)
		{
			iCurrentValue = iNumFranchises * pkOfficeInfo->GetGPRateModifierPerXFranchises();
		}
	}
	return iCurrentValue;
}

bool CvCity::IsHeadquarters() const
{
	VALIDATE_OBJECT

	CorporationTypes eCorporation = GET_PLAYER(getOwner()).GetCorporations()->GetFoundedCorporation();
	if (eCorporation == NO_CORPORATION)
		return false;

	CvCorporationEntry* pkCorporationInfo = GC.getCorporationInfo(eCorporation);
	if (pkCorporationInfo == NULL)
		return false;

	BuildingClassTypes eHeadquarters = pkCorporationInfo->GetHeadquartersBuildingClass();
	if (eHeadquarters == NO_BUILDINGCLASS)
		return false;

	return HasBuildingClass(eHeadquarters);
}

bool CvCity::IsHasOffice() const
{
	VALIDATE_OBJECT

	CorporationTypes eCorporation = GET_PLAYER(getOwner()).GetCorporations()->GetFoundedCorporation();
	if (eCorporation == NO_CORPORATION)
		return false;

	CvCorporationEntry* pkCorporationInfo = GC.getCorporationInfo(eCorporation);
	if (pkCorporationInfo == NULL)
		return false;

	BuildingClassTypes eOffice = pkCorporationInfo->GetOfficeBuildingClass();
	if (eOffice == NO_BUILDINGCLASS)
		return false;

	const CvCivilizationInfo& thisCivInfo = getCivilizationInfo();
	BuildingTypes eBuilding = NO_BUILDING;

	if (MOD_BUILDINGS_THOROUGH_PREREQUISITES)
	{
		eBuilding = GetCityBuildings()->GetBuildingTypeFromClass(eOffice);
	}
	else
	{
		eBuilding = (BuildingTypes)thisCivInfo.getCivilizationBuildings(eOffice);
	}

	if (eBuilding == NO_BUILDING)
		return false;

	return (m_pCityBuildings->GetNumBuilding(eBuilding) > 0 || m_pCityBuildings->GetNumFreeBuilding(eBuilding) > 0);
}

bool CvCity::IsHasFranchise(CorporationTypes eCorporation) const
{
	VALIDATE_OBJECT

	if (eCorporation == NO_CORPORATION)
		return false;

	CvCorporationEntry* pkCorporationInfo = GC.getCorporationInfo(eCorporation);
	if (pkCorporationInfo == NULL)
		return false;

	// Evaluate offices as franchises if we count Offices as Franchises
	bool bOfficesAsFranchises = GetPlayer()->GetCorporations()->GetCorporationOfficesAsFranchises() > 0;
	BuildingClassTypes eFranchise = bOfficesAsFranchises ? pkCorporationInfo->GetOfficeBuildingClass() : pkCorporationInfo->GetFranchiseBuildingClass();
	if (eFranchise == NO_BUILDINGCLASS)
		return false;

	// If nationalized, then the City owner and the corporation owner must be equal
	if (bOfficesAsFranchises)
	{
		CvCorporation* pCorporation = GC.getGame().GetGameCorporations()->GetCorporation(eCorporation);
		if (pCorporation)
		{
			if (getOwner() != pCorporation->m_eFounder)
				return false;
		}
	}

	const CvCivilizationInfo& thisCivInfo = getCivilizationInfo();
	BuildingTypes eBuilding = NO_BUILDING;

	if (MOD_BUILDINGS_THOROUGH_PREREQUISITES)
	{
		eBuilding = GetCityBuildings()->GetBuildingTypeFromClass(eFranchise);
	}
	else
	{
		eBuilding = (BuildingTypes)thisCivInfo.getCivilizationBuildings(eFranchise);
	}

	if (eBuilding == NO_BUILDING)
		return false;

	return m_pCityBuildings->GetNumBuilding(eBuilding) > 0;
}

// Returns the yield change for this building based on the number of franchises
int CvCity::GetBuildingYieldChangeFromCorporationFranchises(BuildingClassTypes eBuildingClass, YieldTypes eIndex) const
{
	VALIDATE_OBJECT

	CvAssertMsg(eBuildingClass >= 0, "eBuildingClass expected to be greater or equal to 0");
	CvAssertMsg(eBuildingClass < GC.getNumBuildingClassInfos(), "eBuildingClass expected to be < GC.getNumBuildingClassInfos()");

	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	CvPlayer& kPlayer = GET_PLAYER(getOwner());

	CvCorporationEntry* pkCorporationInfo = kPlayer.GetCorporations()->GetCorporationEntry();
	if (!pkCorporationInfo)
		return 0;

	BuildingTypes eBuilding = NO_BUILDING;
	if (MOD_BUILDINGS_THOROUGH_PREREQUISITES)
	{
		if (HasBuildingClass(eBuildingClass))
		{
			eBuilding = GetCityBuildings()->GetBuildingTypeFromClass(eBuildingClass);
		}
		else
		{
			eBuilding = (BuildingTypes)kPlayer.getCivilizationInfo().getCivilizationBuildings(eBuildingClass);
		}
	}
	else
	{
		eBuilding = (BuildingTypes)kPlayer.getCivilizationInfo().getCivilizationBuildings(eBuildingClass);
	}
	CvBuildingEntry* pBuildingInfo = GC.getBuildingInfo(eBuilding);
	if (pBuildingInfo == NULL)
		return 0;

	int iYieldPerFranchise = pBuildingInfo->GetYieldPerFranchise(eIndex);
	int iFranchises = kPlayer.GetCorporations()->GetNumFranchises();

	return iYieldPerFranchise * iFranchises;
}
void CvCity::SetYieldChangeFromCorporationFranchises(YieldTypes eIndex, int iTotal)
{
	if (GetYieldChangeFromCorporationFranchises(eIndex) != iTotal)
	{
		m_aiYieldChangeFromCorporationFranchises[eIndex] = iTotal;
	}
}
int CvCity::GetYieldChangeFromCorporationFranchises(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	return m_aiYieldChangeFromCorporationFranchises[eIndex];
}
void CvCity::UpdateYieldFromCorporationFranchises(YieldTypes eIndex)
{
	int iTotal = 0;
	const CvCivilizationInfo& thisCivInfo = getCivilizationInfo();
	for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
	{
		CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo((BuildingClassTypes)iI);
		if (!pkBuildingClassInfo)
		{
			continue;
		}
		BuildingTypes eLoopBuilding = NO_BUILDING;

		if (MOD_BUILDINGS_THOROUGH_PREREQUISITES)
		{
			eLoopBuilding = GetCityBuildings()->GetBuildingTypeFromClass((BuildingClassTypes)iI);
		}
		else
		{
			eLoopBuilding = ((BuildingTypes)(thisCivInfo.getCivilizationBuildings(iI)));
		}

		if (eLoopBuilding != NO_BUILDING && m_pCityBuildings->GetNumBuilding(eLoopBuilding) > 0)
		{
			iTotal += GetBuildingYieldChangeFromCorporationFranchises((BuildingClassTypes)iI, eIndex);
		}
	}

	SetYieldChangeFromCorporationFranchises(eIndex, iTotal);
}

//	--------------------------------------------------------------------------------
int CvCity::GetResourceQuantityPerXFranchises(ResourceTypes eResource) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eResource >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eResource < GC.getNumResourceInfos(), "eIndex expected to be < GC.getNumResourceInfos()");
	return m_aiResourceQuantityPerXFranchises[eResource];
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeResourceQuantityPerXFranchises(ResourceTypes eResource, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eResource >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eResource < GC.getNumResourceInfos(), "eIndex expected to be < GC.getNumResourceInfos()");

	if (iChange != 0)
	{
		m_aiResourceQuantityPerXFranchises[eResource] = m_aiResourceQuantityPerXFranchises[eResource] + iChange;
		//		CvAssert(GetCorporationResourceQuantity(eResource) >= 0); 
	}
}
void CvCity::SetResourceQuantityPerXFranchises(ResourceTypes eResource, int iValue)
{
	if (GetResourceQuantityPerXFranchises(eResource) != iValue)
	{
		m_aiResourceQuantityPerXFranchises[eResource] = iValue;
	}
}
//	--------------------------------------------------------------------------------
int CvCity::GetResourceQuantityFromPOP(ResourceTypes eResource) const
{
	VALIDATE_OBJECT
	return m_aiResourceQuantityFromPOP[eResource];
}
//	--------------------------------------------------------------------------------
void CvCity::ChangeResourceQuantityFromPOP(ResourceTypes eResource, int iChange)
{
	VALIDATE_OBJECT
	SetResourceQuantityFromPOP(eResource, GetResourceQuantityFromPOP(eResource) + iChange);
}
void CvCity::SetResourceQuantityFromPOP(ResourceTypes eResource, int iValue)
{
	m_aiResourceQuantityFromPOP[eResource] = iValue;
}
//	--------------------------------------------------------------------------------
/// Trade Route Religious Spread Boost
int CvCity::GetReligiousTradeModifier() const
{
	VALIDATE_OBJECT
	return m_iReligiousTradeModifier;
}
void CvCity::ChangeReligiousTradeModifier(int iChange)
{
	VALIDATE_OBJECT
	if (iChange != 0)
	{
		SetReligiousTradeModifier(GetReligiousTradeModifier() + iChange);
	}
}
void CvCity::SetReligiousTradeModifier(int iValue)
{
	VALIDATE_OBJECT
	m_iReligiousTradeModifier = iValue;
}


int CvCity::GetCityAirStrikeDefense() const
{
	VALIDATE_OBJECT
	return m_iCityAirStrikeDefense;
}
void CvCity::ChangeCityAirStrikeDefense(int iChange)
{
	VALIDATE_OBJECT
	if (iChange != 0)
	{
		SetCityAirStrikeDefense(GetCityAirStrikeDefense() + iChange);
	}
}
void CvCity::SetCityAirStrikeDefense(int iValue)
{
	VALIDATE_OBJECT
	m_iCityAirStrikeDefense = iValue;
}

//	--------------------------------------------------------------------------------
/// Free building built in target trade city (foreign)
int CvCity::GetFreeBuildingTradeTargetCity() const
{
	VALIDATE_OBJECT
	return m_iFreeBuildingTradeTargetCity;
}
void CvCity::ChangeFreeBuildingTradeTargetCity(int iChange)
{
	VALIDATE_OBJECT
	if (iChange != 0)
	{
		SetFreeBuildingTradeTargetCity(GetFreeBuildingTradeTargetCity() + iChange);
	}
}
void CvCity::SetFreeBuildingTradeTargetCity(int iValue)
{
	VALIDATE_OBJECT
	m_iFreeBuildingTradeTargetCity = iValue;
}


//	--------------------------------------------------------------------------------
int CvCity::GetLandTourismBonus() const
{
	VALIDATE_OBJECT
	return m_iLandTourismBonus;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeLandTourismBonus(int iChange)
{
	VALIDATE_OBJECT
	m_iLandTourismBonus = (m_iLandTourismBonus + iChange);
}
//	--------------------------------------------------------------------------------
void CvCity::SetLandTourismBonus(int iChange)
{
	VALIDATE_OBJECT
	m_iLandTourismBonus = iChange;
}


//	--------------------------------------------------------------------------------
int CvCity::GetSeaTourismBonus() const
{
	VALIDATE_OBJECT
	return m_iSeaTourismBonus;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeSeaTourismBonus(int iChange)
{
	VALIDATE_OBJECT
	m_iSeaTourismBonus = (m_iSeaTourismBonus + iChange);
}
//	--------------------------------------------------------------------------------
void CvCity::SetSeaTourismBonus(int iChange)
{
	VALIDATE_OBJECT
	m_iSeaTourismBonus = iChange;
}

int CvCity::GetSeaTourismFromEvent()
{
	int iBonus = GetSeaTourismBonus();
	int iPreviousTurnsToCount = 7;
	// Calculate boost
	iBonus *= (GET_PLAYER(getOwner()).getYieldPerTurnHistory(YIELD_CULTURE, iPreviousTurnsToCount) + GET_PLAYER(getOwner()).getYieldPerTurnHistory(YIELD_TOURISM, iPreviousTurnsToCount) / 2);
	iBonus /= 100;

	return iBonus;
}
int CvCity::GetLandTourismFromEvent()
{
	int iBonus = GetLandTourismBonus();
	int iPreviousTurnsToCount = 7;
	// Calculate boost
	iBonus *= (GET_PLAYER(getOwner()).getYieldPerTurnHistory(YIELD_CULTURE, iPreviousTurnsToCount) + GET_PLAYER(getOwner()).getYieldPerTurnHistory(YIELD_TOURISM, iPreviousTurnsToCount) / 2);
	iBonus /= 100;

	return iBonus;
}

//	--------------------------------------------------------------------------------
int CvCity::GetAlwaysHeal() const
{
	VALIDATE_OBJECT
	return m_iAlwaysHeal;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeAlwaysHeal(int iChange)
{
	VALIDATE_OBJECT
	m_iAlwaysHeal = (m_iAlwaysHeal + iChange);
}
//	--------------------------------------------------------------------------------
void CvCity::SetAlwaysHeal(int iChange)
{
	VALIDATE_OBJECT
	m_iAlwaysHeal = iChange;
}

void CvCity::ChangeResourceDiversityModifier(int iChange)
{
	VALIDATE_OBJECT
	m_iResourceDiversityModifier += iChange;
}
int CvCity::GetResourceDiversityModifier() const
{
	VALIDATE_OBJECT
	return m_iResourceDiversityModifier;
}

void CvCity::ChangeNoUnhappfromXSpecialists(int iChange)
{
	VALIDATE_OBJECT
	m_iNoUnhappfromXSpecialists += iChange;
}
int CvCity::GetNoUnhappfromXSpecialists() const
{
	VALIDATE_OBJECT
	return m_iNoUnhappfromXSpecialists;
}

//	--------------------------------------------------------------------------------
bool CvCity::isBorderCity() const
{
	VALIDATE_OBJECT
	return plot()->IsBorderLand(m_eOwner);
}
bool CvCity::isBorderCity(vector<PlayerTypes>& vUnfriendlyMajors) const
{
	VALIDATE_OBJECT
	return plot()->IsBorderLand(m_eOwner, vUnfriendlyMajors);
}
#endif
void CvCity::changeNukeInterceptionChance(int iNewValue)
{
	VALIDATE_OBJECT
	m_iNukeInterceptionChance += iNewValue;
}
int CvCity::getNukeInterceptionChance() const
{
	VALIDATE_OBJECT
	return m_iNukeInterceptionChance;
}
#if defined(MOD_BALANCE_CORE)
void CvCity::SetPurchased(BuildingClassTypes eBuildingClass, bool bValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eBuildingClass >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eBuildingClass < GC.getNumBuildingClassInfos(), "eIndex expected to be < MAX_PLAYERS");
	if (m_abIsPurchased[eBuildingClass] != bValue)
	{
		m_abIsPurchased[eBuildingClass] = bValue;
	}
}
bool CvCity::IsPurchased(BuildingClassTypes eBuildingClass)
{
	VALIDATE_OBJECT
	CvAssertMsg(eBuildingClass >= 0, "eBuildingClass expected to be >= 0");
	CvAssertMsg(eBuildingClass < GC.getNumBuildingClassInfos(), "eBuildingClass expected to be < GC.getNumBuildingClassInfos()");
	return m_abIsPurchased[eBuildingClass];
}
void CvCity::SetBestForWonder(BuildingClassTypes eBuildingClass, bool bValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eBuildingClass >= 0, "eBuildingClass expected to be >= 0");
	CvAssertMsg(eBuildingClass < GC.getNumBuildingClassInfos(), "eBuildingClass expected to be < GC.getNumBuildingClassInfos()");
	if (m_abIsBestForWonder[eBuildingClass] != bValue)
	{
		m_abIsBestForWonder[eBuildingClass] = bValue;
	}
}
bool CvCity::IsBestForWonder(BuildingClassTypes eBuildingClass)
{
	VALIDATE_OBJECT
	CvAssertMsg(eBuildingClass >= 0, "eBuildingClass expected to be >= 0");
	CvAssertMsg(eBuildingClass < GC.getNumBuildingClassInfos(), "eBuildingClass expected to be < GC.getNumBuildingClassInfos()");
	return m_abIsBestForWonder[eBuildingClass];
}

#endif
//	--------------------------------------------------------------------------------
/// Extra yield for each pop point
int CvCity::GetYieldPerPopTimes100(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	return m_aiYieldPerPop[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield for each pop point
void CvCity::ChangeYieldPerPopTimes100(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
		m_aiYieldPerPop[eIndex] = m_aiYieldPerPop[eIndex] + iChange;
}

#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
/// Extra yield for each pop point in empire
int CvCity::GetYieldPerPopInEmpireTimes100(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	std::map<int, int>::const_iterator it = m_aiYieldPerPopInEmpire.find((int)eIndex);
	if (it != m_aiYieldPerPopInEmpire.end()) // find returns the iterator to map::end if the key i is not present in the map
	{
		return it->second;
	}

	return 0;
}

//	--------------------------------------------------------------------------------
/// Extra yield for each pop point in empire
void CvCity::ChangeYieldPerPopInEmpireTimes100(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
		m_aiYieldPerPopInEmpire[(int)eIndex] += iChange;
}
#endif

//	--------------------------------------------------------------------------------
/// Extra yield for each religion with a follower
int CvCity::GetYieldPerReligionTimes100(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	return m_aiYieldPerReligion[eIndex];
}

//	--------------------------------------------------------------------------------
/// Extra yield for each religion with a follower
void CvCity::ChangeYieldPerReligionTimes100(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiYieldPerReligion[eIndex] = m_aiYieldPerReligion[eIndex] + iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvCity::getYieldRateModifier(YieldTypes eIndex)	const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiYieldRateModifier[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::changeYieldRateModifier(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	if (iChange != 0)
	{
		m_aiYieldRateModifier[eIndex] = m_aiYieldRateModifier[eIndex] + iChange;
		CvAssert(getYieldRate(eIndex, false) != 0);

		GET_PLAYER(getOwner()).invalidateYieldRankCache(eIndex);
	}
}

#if defined(MOD_BALANCE_CORE_POLICIES)
//	--------------------------------------------------------------------------------
int CvCity::getReligionBuildingYieldRateModifier(BuildingClassTypes eBuilding, YieldTypes eYield)	const
{
	return ModifierLookup(m_yieldChanges[eYield].forReligionBuilding, eBuilding);
}


//	--------------------------------------------------------------------------------
void CvCity::changeReligionBuildingYieldRateModifier(BuildingClassTypes eBuilding, YieldTypes eYield, int iChange)
{
	SCityExtraYields& y = m_yieldChanges[eYield];
	ModifierUpdateInsertRemove(y.forReligionBuilding, eBuilding, iChange, true);
}
//	--------------------------------------------------------------------------------
int CvCity::getLocalBuildingClassYield(BuildingClassTypes eBuilding, YieldTypes eYield)	const
{
	return ModifierLookup(m_yieldChanges[eYield].forLocalBuilding, eBuilding);
}


//	--------------------------------------------------------------------------------
void CvCity::changeLocalBuildingClassYield(BuildingClassTypes eBuilding, YieldTypes eYield, int iChange)
{
	SCityExtraYields& y = m_yieldChanges[eYield];
	ModifierUpdateInsertRemove(y.forLocalBuilding, eBuilding, iChange, true);
}

//	--------------------------------------------------------------------------------
int CvCity::GetGreatWorkYieldChange(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiGreatWorkYieldChange[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::ChangeGreatWorkYieldChange(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiGreatWorkYieldChange[eIndex] = m_aiGreatWorkYieldChange[eIndex] + iChange;
	}
}
#endif

//	--------------------------------------------------------------------------------
int CvCity::getResourceYieldRateModifier(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiResourceYieldRateModifier[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::changeResourceYieldRateModifier(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiResourceYieldRateModifier[eIndex] = m_aiResourceYieldRateModifier[eIndex] + iChange;
		CvAssert(getYieldRate(eIndex, false) >= 0);

		GET_PLAYER(getOwner()).invalidateYieldRankCache(eIndex);
	}
}


//	--------------------------------------------------------------------------------
int CvCity::getExtraSpecialistYield(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiExtraSpecialistYield[eIndex];
}


//	--------------------------------------------------------------------------------
int CvCity::getExtraSpecialistYield(YieldTypes eIndex, SpecialistTypes eSpecialist) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	CvAssertMsg(eSpecialist >= 0, "eSpecialist expected to be >= 0");
	CvAssertMsg(eSpecialist < GC.getNumSpecialistInfos(), "GC.getNumSpecialistInfos expected to be >= 0");

	int iYieldMultiplier = GET_PLAYER(getOwner()).getSpecialistExtraYield(eSpecialist, eIndex) +
		GET_PLAYER(getOwner()).getSpecialistExtraYield(eIndex) +
		GET_PLAYER(getOwner()).GetPlayerTraits()->GetSpecialistYieldChange(eSpecialist, eIndex);
#if defined(MOD_BALANCE_CORE_EVENTS)
	iYieldMultiplier += GetEventSpecialistYield(eSpecialist, eIndex);
#endif

	iYieldMultiplier += getSpecialistExtraYield(eSpecialist, eIndex);
	iYieldMultiplier += GET_PLAYER(getOwner()).getSpecialistYieldChange(eSpecialist, eIndex);

	ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
	BeliefTypes eSecondaryPantheon = NO_BELIEF;
	if (eMajority >= RELIGION_PANTHEON)
	{
		const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
		if (pReligion)
		{
			iYieldMultiplier += pReligion->m_Beliefs.GetSpecialistYieldChange(eSpecialist, eIndex, getOwner(), GET_PLAYER(getOwner()).getCity(GetID()));
			eSecondaryPantheon = GetCityReligions()->GetSecondaryReligionPantheonBelief();
			if (eSecondaryPantheon != NO_BELIEF)
			{
				iYieldMultiplier += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetSpecialistYieldChange(eSpecialist, eIndex);
			}
		}
	}

#if defined(MOD_RELIGION_PERMANENT_PANTHEON)
	// Mod for civs keeping their pantheon belief forever
	if (MOD_RELIGION_PERMANENT_PANTHEON)
	{
		if (GC.getGame().GetGameReligions()->HasCreatedPantheon(getOwner()))
		{
			const CvReligion* pPantheon = GC.getGame().GetGameReligions()->GetReligion(RELIGION_PANTHEON, getOwner());
			BeliefTypes ePantheonBelief = GC.getGame().GetGameReligions()->GetBeliefInPantheon(getOwner());
			if (pPantheon != NULL && ePantheonBelief != NO_BELIEF && ePantheonBelief != eSecondaryPantheon)
			{
				const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
				if (pReligion == NULL || (pReligion != NULL && !pReligion->m_Beliefs.IsPantheonBeliefInReligion(ePantheonBelief, eMajority, getOwner()))) // check that the our religion does not have our belief, to prevent double counting
				{
					iYieldMultiplier += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetSpecialistYieldChange(eSpecialist, eIndex);
				}
			}
		}
	}
#endif

	int iExtraYield = GetCityCitizens()->GetSpecialistCount(eSpecialist) * iYieldMultiplier;

	return iExtraYield;
}


//	--------------------------------------------------------------------------------
void CvCity::updateExtraSpecialistYield(YieldTypes eYield)
{
	VALIDATE_OBJECT
	CvAssertMsg(eYield >= 0, "eYield expected to be >= 0");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eYield expected to be < NUM_YIELD_TYPES");

	int iOldYield = getExtraSpecialistYield(eYield);
	int iNewYield = 0;


	for (int iI = 0; iI < GC.getNumSpecialistInfos(); iI++)
	{
		iNewYield += getExtraSpecialistYield(eYield, ((SpecialistTypes)iI));
	}

	if (iOldYield != iNewYield)
	{
		m_aiExtraSpecialistYield[eYield] = iNewYield;
		CvAssert(getExtraSpecialistYield(eYield) >= 0);

		ChangeBaseYieldRateFromSpecialists(eYield, (iNewYield - iOldYield));
	}
}


//	--------------------------------------------------------------------------------
void CvCity::updateExtraSpecialistYield()
{
	VALIDATE_OBJECT
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		updateExtraSpecialistYield((YieldTypes)iI);
	}
}


//	--------------------------------------------------------------------------------
int CvCity::getProductionToYieldModifier(YieldTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");
	return m_aiProductionToYieldModifier[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::changeProductionToYieldModifier(YieldTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex expected to be < NUM_YIELD_TYPES");

	if (iChange != 0)
	{
		m_aiProductionToYieldModifier[eIndex] = m_aiProductionToYieldModifier[eIndex] + iChange;
	}
}

//	--------------------------------------------------------------------------------
int CvCity::GetTradeYieldModifier(YieldTypes eIndex, CvString* toolTipSink) const
{
	int iReturnValue = GET_PLAYER(m_eOwner).GetTrade()->GetTradeValuesAtCityTimes100(this, eIndex);
	if (toolTipSink)
	{
		if (iReturnValue != 0)
		{
			switch (eIndex)
			{
			case YIELD_FOOD:
				*toolTipSink += "[NEWLINE][BULLET]";
				*toolTipSink += GetLocalizedText("TXT_KEY_FOOD_FROM_TRADE_ROUTES", iReturnValue / 100.0f);
				break;
			case YIELD_PRODUCTION:
				*toolTipSink += "[NEWLINE][BULLET]";
				*toolTipSink += GetLocalizedText("TXT_KEY_PRODUCTION_FROM_TRADE_ROUTES", iReturnValue / 100.0f);
				break;
			case YIELD_GOLD:
				*toolTipSink += "[NEWLINE][BULLET]";
				*toolTipSink += GetLocalizedText("TXT_KEY_GOLD_FROM_TRADE_ROUTES", iReturnValue / 100.0f);
				break;
			case YIELD_SCIENCE:
				*toolTipSink += "[NEWLINE][BULLET]";
				*toolTipSink += GetLocalizedText("TXT_KEY_SCIENCE_FROM_TRADE_ROUTES", iReturnValue / 100.0f);
				break;
			case YIELD_CULTURE:
				*toolTipSink += "[NEWLINE][BULLET]";
				*toolTipSink += GetLocalizedText("TXT_KEY_CULTURE_FROM_TRADE_ROUTES", iReturnValue / 100.0f);
				break;
			case YIELD_FAITH:
				*toolTipSink += "[NEWLINE][BULLET]";
				*toolTipSink += GetLocalizedText("TXT_KEY_FAITH_FROM_TRADE_ROUTES", iReturnValue / 100.0f);
				break;
			case YIELD_TOURISM:
				*toolTipSink += "[NEWLINE][BULLET]";
				*toolTipSink += GetLocalizedText("TXT_KEY_TOURISM_FROM_TRADE_ROUTES", iReturnValue / 100.0f);
				break;
			case YIELD_GOLDEN_AGE_POINTS:
				*toolTipSink += "[NEWLINE][BULLET]";
				*toolTipSink += GetLocalizedText("TXT_KEY_GOLDEN_AGE_POINTS_FROM_TRADE_ROUTES", iReturnValue / 100.0f);
				break;
			default:
				UNREACHABLE(); // All other yields cannot be acquired from trade.
			}
		}
	}
	return iReturnValue;
}

//	--------------------------------------------------------------------------------
int CvCity::getDomainFreeExperience(DomainTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_DOMAIN_TYPES, "eIndex expected to be < NUM_DOMAIN_TYPES");
	return m_aiDomainFreeExperience[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::changeDomainFreeExperience(DomainTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_DOMAIN_TYPES, "eIndex expected to be < NUM_DOMAIN_TYPES");
	m_aiDomainFreeExperience[eIndex] = m_aiDomainFreeExperience[eIndex] + iChange;
	CvAssert(getDomainFreeExperience(eIndex) >= 0);
}


//	--------------------------------------------------------------------------------
int CvCity::getDomainFreeExperienceFromGreatWorks(DomainTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_DOMAIN_TYPES, "eIndex expected to be < NUM_DOMAIN_TYPES");

	int iXP = 0;

	CvBuildingXMLEntries* pkBuildings = GetCityBuildings()->GetPossibleBuildings();
	for (int iBuilding = 0; iBuilding < pkBuildings->GetNumBuildings(); iBuilding++)
	{
		CvBuildingEntry* pInfo = pkBuildings->GetEntry(iBuilding);
		if (pInfo)
		{
			if (pInfo->GetDomainFreeExperiencePerGreatWork(eIndex) != 0)
			{
				int iGreatWorks = GetCityBuildings()->GetNumGreatWorksInBuilding((BuildingClassTypes)pInfo->GetBuildingClassType());
				iXP += (iGreatWorks * pInfo->GetDomainFreeExperiencePerGreatWork(eIndex));
			}
		}
	}

	return iXP;
}
#if defined(MOD_BALANCE_CORE)
//	--------------------------------------------------------------------------------
int CvCity::getDomainFreeExperienceFromGreatWorksGlobal(DomainTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_DOMAIN_TYPES, "eIndex expected to be < NUM_DOMAIN_TYPES");

	int iMod = GET_PLAYER(getOwner()).GetDomainFreeExperiencePerGreatWorkGlobal(eIndex);
	if (iMod <= 0)
	{
		return iMod;
	}

	int iXP = 0;
	int iLoop = 0;
	int iGreatWorks = 0;
	for (const CvCity* pLoopCity = GET_PLAYER(getOwner()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(getOwner()).nextCity(&iLoop))
	{
		if (pLoopCity != NULL)
		{
			iGreatWorks += pLoopCity->GetCityBuildings()->GetNumGreatWorks(CvTypes::getGREAT_WORK_SLOT_LITERATURE());
		}
	}
	iXP += (iGreatWorks * iMod);

	if (iXP > 45)
	{
		iXP = 45;
	}

	return iXP;
}
#endif

//	--------------------------------------------------------------------------------
int CvCity::getDomainProductionModifier(DomainTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_DOMAIN_TYPES, "eIndex expected to be < NUM_DOMAIN_TYPES");
	return m_aiDomainProductionModifier[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::changeDomainProductionModifier(DomainTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < NUM_DOMAIN_TYPES, "eIndex expected to be < NUM_DOMAIN_TYPES");
	m_aiDomainProductionModifier[eIndex] = m_aiDomainProductionModifier[eIndex] + iChange;
}


//	--------------------------------------------------------------------------------
bool CvCity::isEverLiberated(PlayerTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex expected to be < MAX_PLAYERS");
	return m_abEverLiberated[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::setEverLiberated(PlayerTypes eIndex, bool bNewValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex expected to be < MAX_PLAYERS");
	m_abEverLiberated[eIndex] = bNewValue;
}

//	--------------------------------------------------------------------------------
bool CvCity::isRevealed(TeamTypes eIndex, bool bDebug, bool bAdjacentIsGoodEnough) const
{
	if (!plot())
		return false;

	//humans can guess if there is a city so we give the AI some help sometimes
	if (bAdjacentIsGoodEnough)
		return plot()->isRevealed(eIndex, bDebug) || plot()->isAdjacentRevealed(eIndex);
	else
		return plot()->isRevealed(eIndex, bDebug);
}

bool CvCity::setRevealed(TeamTypes eIndex, bool bNewValue)
{
	if (!plot())
		return false;

	return plot()->setRevealed(eIndex, bNewValue);
}

//	--------------------------------------------------------------------------------
const char* CvCity::getNameKey() const
{
	VALIDATE_OBJECT
	return m_strName;
}


//	--------------------------------------------------------------------------------
const CvString CvCity::getName() const
{
	VALIDATE_OBJECT
	return GetLocalizedText(m_strName);
}

const CvString CvCity::getNameNoSpace() const
{
	CvString ret = getName();
	ret.Replace(' ', '_');
	ret.Replace('\'', '_');
	return ret;
}


//	--------------------------------------------------------------------------------
void CvCity::setName(const char* szNewValue, bool bFound, bool bForceChange)
{
	VALIDATE_OBJECT
	CvString strName(szNewValue);
	gDLL->stripSpecialCharacters(strName);

	if (!strName.IsEmpty())
	{
		if (GET_PLAYER(getOwner()).isCityNameValid(strName, false, bForceChange))
		{
			m_strName = strName;

			if (isCitySelected())
			{
				DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
			}


			CvInterfacePtr<ICvCity1> pCity = GC.WrapCityPointer(this);
			DLLUI->SetSpecificCityInfoDirty(pCity.get(), CITY_UPDATE_TYPE_BANNER);
		}
		if (bFound)
		{
			doFoundMessage();
		}
	}
}

void CvCity::setCaptureData(int iTemp[5], bool bTemp[2])
{
	m_aiTempCaptureData[0] = iTemp[0];
	m_aiTempCaptureData[1] = iTemp[1];
	m_aiTempCaptureData[2] = iTemp[2];
	m_aiTempCaptureData[3] = iTemp[3];
	m_aiTempCaptureData[4] = iTemp[4];

	m_abTempCaptureData[0] = bTemp[0];
	m_abTempCaptureData[1] = bTemp[1];

	m_bIsPendingCapture = true;
}

std::vector<int> CvCity::getCaptureDataInt() const
{
	return m_aiTempCaptureData;
}

std::vector<bool> CvCity::getCaptureDataBool() const
{
	return m_abTempCaptureData;
}

bool CvCity::isPendingCapture() const
{
	return m_bIsPendingCapture;
}

void CvCity::resetCaptureData()
{
	for (int i = 0; i < 5; i++)
	{
		m_aiTempCaptureData[i] = 0;
	}
	for (int i = 0; i < 2; i++)
	{
		m_abTempCaptureData[i] = false;
	}

	m_bIsPendingCapture = false;
}

//	--------------------------------------------------------------------------------
void CvCity::doFoundMessage()
{
	VALIDATE_OBJECT
	if (getOwner() == GC.getGame().getActivePlayer())
	{
		Localization::String localizedText = Localization::Lookup("TXT_KEY_MISC_CITY_HAS_BEEN_FOUNDED");
		localizedText << getNameKey();
		DLLUI->AddCityMessage(0, GetIDInfo(), getOwner(), false, -1, localizedText.toUTF8(), NULL /*ARTFILEMGR.getInterfaceArtInfo("WORLDBUILDER_CITY_EDIT")->getPath()*/, MESSAGE_TYPE_MAJOR_EVENT, NULL, NO_COLOR, getX(), getY());
	}

	Localization::String localizedText = Localization::Lookup("TXT_KEY_MISC_CITY_IS_FOUNDED");
	localizedText << getNameKey();
	GC.getGame().addReplayMessage(REPLAY_MESSAGE_CITY_FOUNDED, getOwner(), localizedText.toUTF8(), getX(), getY());
}

//	--------------------------------------------------------------------------------
bool CvCity::IsExtraLuxuryResources()
{
	return (m_iCountExtraLuxuries > 0);
}

//	--------------------------------------------------------------------------------
void CvCity::SetExtraLuxuryResources(int iNewValue)
{
	m_iCountExtraLuxuries = iNewValue;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeExtraLuxuryResources(int iChange)
{
	m_iCountExtraLuxuries += iChange;
}

//	--------------------------------------------------------------------------------
int CvCity::getProjectProduction(ProjectTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex expected to be < GC.getNumProjectInfos()");
	return m_paiProjectProduction[eIndex] / 100;
}


//	--------------------------------------------------------------------------------
void CvCity::setProjectProduction(ProjectTypes eIndex, int iNewValue)
{
	VALIDATE_OBJECT
	setProjectProductionTimes100(eIndex, iNewValue * 100);
}


//	--------------------------------------------------------------------------------
void CvCity::changeProjectProduction(ProjectTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	changeProjectProductionTimes100(eIndex, iChange * 100);
}

//	--------------------------------------------------------------------------------
int CvCity::getProjectProductionTimes100(ProjectTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex expected to be < GC.getNumProjectInfos()");
	return m_paiProjectProduction[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::setProjectProductionTimes100(ProjectTypes eIndex, int iNewValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex expected to be < GC.getNumProjectInfos()");

	if (getProjectProductionTimes100(eIndex) != iNewValue)
	{
		m_paiProjectProduction[eIndex] = max(0, iNewValue);
		CvAssert(getProjectProductionTimes100(eIndex) >= 0);

		if ((getOwner() == GC.getGame().getActivePlayer()) && isCitySelected())
		{
			DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
		}

		CvInterfacePtr<ICvCity1> pCity = GC.WrapCityPointer(this);
		DLLUI->SetSpecificCityInfoDirty(pCity.get(), CITY_UPDATE_TYPE_BANNER);
	}
}


//	--------------------------------------------------------------------------------
void CvCity::changeProjectProductionTimes100(ProjectTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < GC.getNumProjectInfos(), "eIndex expected to be < GC.getNumProjectInfos()");
	setProjectProductionTimes100(eIndex, (getProjectProductionTimes100(eIndex) + iChange));
}


//	--------------------------------------------------------------------------------
int CvCity::getSpecialistProduction(SpecialistTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < GC.getNumSpecialistInfos(), "eIndex expected to be < GC.getNumSpecialistInfos()");
	return m_paiSpecialistProduction[eIndex] / 100;
}


//	--------------------------------------------------------------------------------
void CvCity::setSpecialistProduction(SpecialistTypes eIndex, int iNewValue)
{
	VALIDATE_OBJECT
	setSpecialistProductionTimes100(eIndex, iNewValue * 100);
}


//	--------------------------------------------------------------------------------
void CvCity::changeSpecialistProduction(SpecialistTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	changeSpecialistProductionTimes100(eIndex, iChange * 100);
}

//	--------------------------------------------------------------------------------
int CvCity::getSpecialistProductionTimes100(SpecialistTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < GC.getNumSpecialistInfos(), "eIndex expected to be < GC.getNumSpecialistInfos()");
	return m_paiSpecialistProduction[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::setSpecialistProductionTimes100(SpecialistTypes eIndex, int iNewValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < GC.getNumSpecialistInfos(), "eIndex expected to be < GC.getNumSpecialistInfos()");

	if (getSpecialistProductionTimes100(eIndex) != iNewValue)
	{
		m_paiSpecialistProduction[eIndex] = iNewValue;
		CvAssert(getSpecialistProductionTimes100(eIndex) >= 0);

		if ((getOwner() == GC.getGame().getActivePlayer()) && isCitySelected())
		{
			DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
		}

		CvInterfacePtr<ICvCity1> pCity = GC.WrapCityPointer(this);
		DLLUI->SetSpecificCityInfoDirty(pCity.get(), CITY_UPDATE_TYPE_BANNER);
	}
}


//	--------------------------------------------------------------------------------
void CvCity::changeSpecialistProductionTimes100(SpecialistTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < GC.getNumSpecialistInfos(), "eIndex expected to be < GC.getNumSpecialistInfos()");
	setSpecialistProductionTimes100(eIndex, (getSpecialistProductionTimes100(eIndex) + iChange));
}

#if defined(MOD_PROCESS_STOCKPILE)
//	--------------------------------------------------------------------------------
int CvCity::getProcessProduction(ProcessTypes eIndex) const
{
	return getProcessProductionTimes100(eIndex) / 100;
}

//	--------------------------------------------------------------------------------
int CvCity::getProcessProductionTimes100(ProcessTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < GC.getNumProcessInfos(), "eIndex expected to be < GC.getNumProcessInfos()");

	if (eIndex == GC.getInfoTypeForString("PROCESS_STOCKPILE")) {
		return getBasicYieldRateTimes100(YIELD_PRODUCTION);
	}

	return 0;
}
#endif

//	--------------------------------------------------------------------------------
CvCityBuildings* CvCity::GetCityBuildings() const
{
	VALIDATE_OBJECT
	return m_pCityBuildings;
}

//	--------------------------------------------------------------------------------
int CvCity::getUnitProduction(UnitTypes eIndex)	const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < GC.getNumUnitInfos(), "eIndex expected to be < GC.getNumUnitInfos()");
	return m_paiUnitProduction[eIndex] / 100;
}


//	--------------------------------------------------------------------------------
void CvCity::setUnitProduction(UnitTypes eIndex, int iNewValue)
{
	VALIDATE_OBJECT
	setUnitProductionTimes100(eIndex, iNewValue * 100);
}


//	--------------------------------------------------------------------------------
void CvCity::changeUnitProduction(UnitTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	changeUnitProductionTimes100(eIndex, iChange * 100);
}


//	--------------------------------------------------------------------------------
int CvCity::getUnitProductionTimes100(UnitTypes eIndex)	const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < GC.getNumUnitInfos(), "eIndex expected to be < GC.getNumUnitInfos()");
	return m_paiUnitProduction[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::setUnitProductionTimes100(UnitTypes eIndex, int iNewValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < GC.getNumUnitInfos(), "eIndex expected to be < GC.getNumUnitInfos()");

	if (getUnitProductionTimes100(eIndex) != iNewValue)
	{
		m_paiUnitProduction[eIndex] = max(0, iNewValue);
		CvAssert(getUnitProductionTimes100(eIndex) >= 0);

		if ((getOwner() == GC.getGame().getActivePlayer()) && isCitySelected())
		{
			DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
		}

		CvInterfacePtr<ICvCity1> pCity = GC.WrapCityPointer(this);
		DLLUI->SetSpecificCityInfoDirty(pCity.get(), CITY_UPDATE_TYPE_BANNER);
	}
}


//	--------------------------------------------------------------------------------
void CvCity::changeUnitProductionTimes100(UnitTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	setUnitProductionTimes100(eIndex, (getUnitProductionTimes100(eIndex) + iChange));
}


//	--------------------------------------------------------------------------------
int CvCity::getUnitProductionTime(UnitTypes eIndex)	const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < GC.getNumUnitInfos(), "eIndex expected to be < GC.getNumUnitInfos()");
	return m_paiUnitProductionTime[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::setUnitProductionTime(UnitTypes eIndex, int iNewValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < GC.getNumUnitInfos(), "eIndex expected to be < GC.getNumUnitInfos()");
	m_paiUnitProductionTime[eIndex] = iNewValue;
	CvAssert(getUnitProductionTime(eIndex) >= 0);
}


//	--------------------------------------------------------------------------------
void CvCity::changeUnitProductionTime(UnitTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	setUnitProductionTime(eIndex, (getUnitProductionTime(eIndex) + iChange));
}


//	--------------------------------------------------------------------------------
int CvCity::getUnitCombatFreeExperience(UnitCombatTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < GC.getNumUnitCombatClassInfos(), "eIndex expected to be < GC.getNumUnitCombatInfos()");
	return m_paiUnitCombatFreeExperience[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::changeUnitCombatFreeExperience(UnitCombatTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < GC.getNumUnitCombatClassInfos(), "eIndex expected to be < GC.getNumUnitCombatInfos()");
	m_paiUnitCombatFreeExperience[eIndex] = m_paiUnitCombatFreeExperience[eIndex] + iChange;
	CvAssert(getUnitCombatFreeExperience(eIndex) >= 0);
}


//	--------------------------------------------------------------------------------
int CvCity::getUnitCombatProductionModifier(UnitCombatTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < GC.getNumUnitCombatClassInfos(), "eIndex expected to be < GC.getNumUnitCombatInfos()");
	return m_paiUnitCombatProductionModifier[eIndex];
}


//	--------------------------------------------------------------------------------
void CvCity::changeUnitCombatProductionModifier(UnitCombatTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < GC.getNumUnitCombatClassInfos(), "eIndex expected to be < GC.getNumUnitCombatInfos()");
	m_paiUnitCombatProductionModifier[eIndex] = m_paiUnitCombatProductionModifier[eIndex] + iChange;
	CvAssert(getUnitCombatProductionModifier(eIndex) >= 0);
}


//	--------------------------------------------------------------------------------
int CvCity::getFreePromotionCount(PromotionTypes eIndex) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < GC.getNumPromotionInfos(), "eIndex expected to be < GC.getNumPromotionInfos()");
	if (m_paiFreePromotionCount.find(eIndex) != m_paiFreePromotionCount.end())
		return m_paiFreePromotionCount.find(eIndex)->second;

	return 0;
}

//	--------------------------------------------------------------------------------
vector<PromotionTypes> CvCity::getFreePromotions() const
{
	vector<PromotionTypes> result;
	for (map<PromotionTypes, int>::const_iterator it = m_paiFreePromotionCount.begin(); it != m_paiFreePromotionCount.end(); ++it)
		if (it->second > 0)
			result.push_back(it->first);

#if defined(MOD_RELIGION_EXTENSIONS)
	if (MOD_RELIGION_EXTENSIONS)
	{
		ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
		if (eMajority != NO_RELIGION)
		{
			const CvReligion* pMajority = GetCityReligions()->GetMajorityReligion();
			if (pMajority)
			{
				std::vector<int> aFreePromotions = pMajority->m_Beliefs.GetFreePromotions(getOwner(), this, false);
				for (std::vector<int>::iterator it = aFreePromotions.begin(); it != aFreePromotions.end(); ++it)
					result.push_back((PromotionTypes)*it);
			}
		}
	}
#endif

	return result;
}

//	--------------------------------------------------------------------------------
void CvCity::changeFreePromotionCount(PromotionTypes eIndex, int iChange)
{
	VALIDATE_OBJECT
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < GC.getNumPromotionInfos(), "eIndex expected to be < GC.getNumPromotionInfos()");
	m_paiFreePromotionCount[eIndex] += iChange;

	if (m_paiFreePromotionCount[eIndex] == 0)
		m_paiFreePromotionCount.erase(eIndex);
}

//	--------------------------------------------------------------------------------
void CvCity::SetRetroactivePromotion(PromotionTypes eIndex)
{
	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(eIndex < GC.getNumPromotionInfos(), "eIndex expected to be < GC.getNumPromotionInfos()");

	if (eIndex != NO_PROMOTION)
	{
		CvPromotionEntry* pkPromotionInfo = GC.getPromotionInfo(eIndex);
		if (pkPromotionInfo)
		{
			int iUnitLoop = 0;
			CvUnit* pLoopUnit = NULL;
			for (pLoopUnit = GetPlayer()->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = GetPlayer()->nextUnit(&iUnitLoop))
			{
				if (pLoopUnit->getOriginCity() == NULL)
				{
					if (this == GetPlayer()->getCapitalCity())
					{
						if (((pLoopUnit->getUnitCombatType() != NO_UNITCOMBAT) && pkPromotionInfo->GetUnitCombatClass(pLoopUnit->getUnitCombatType())) || ::IsPromotionValidForCivilianUnitType(eIndex, pLoopUnit->getUnitType()))
						{
							pLoopUnit->setHasPromotion(eIndex, true);
						}
					}
				}
				else if (pLoopUnit->getOriginCity() != this)
					continue;

				if (((pLoopUnit->getUnitCombatType() != NO_UNITCOMBAT) && pkPromotionInfo->GetUnitCombatClass(pLoopUnit->getUnitCombatType())) || ::IsPromotionValidForCivilianUnitType(eIndex, pLoopUnit->getUnitType()))
				{
					pLoopUnit->setHasPromotion(eIndex, true);
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
int CvCity::getSpecialistFreeExperience() const
{
	VALIDATE_OBJECT
	return m_iSpecialistFreeExperience;
}

//	--------------------------------------------------------------------------------
void CvCity::changeSpecialistFreeExperience(int iChange)
{
	VALIDATE_OBJECT
	m_iSpecialistFreeExperience += iChange;
	CvAssert(m_iSpecialistFreeExperience >= 0);
}

//	--------------------------------------------------------------------------------
void CvCity::updateStrengthValue()
{
	// Default Strength
	int iStrengthValue = /*800 in CP, 500 in VP*/ GD_INT_GET(CITY_STRENGTH_DEFAULT);

	// Population mod
	if (GET_PLAYER(getOwner()).isMinorCiv() || !MOD_BALANCE_CORE_CITY_DEFENSE_SWITCH)
		iStrengthValue += getPopulation() * /*40 in CP, 10 in VP*/ GD_INT_GET(CITY_STRENGTH_POPULATION_CHANGE);

	// Building Defense
	int iBuildingDefense = m_pCityBuildings->GetBuildingDefense();
	iBuildingDefense *= (100 + m_pCityBuildings->GetBuildingDefenseMod());
	iBuildingDefense /= 100;
	iStrengthValue += iBuildingDefense;

	// Tech Progress increases City Strength
	if (!MOD_BALANCE_CORE_CITY_DEFENSE_SWITCH)
	{
		double fTechProgress = float(GET_TEAM(getTeam()).GetTeamTechs()->GetNumTechsKnown()) / GC.getNumTechInfos() * /*5.5f in CP, 3.6f in VP*/ GD_FLOAT_GET(CITY_STRENGTH_TECH_BASE);
		double fTechExponent = /*2.8f in CP, 2.0f in VP*/ GD_FLOAT_GET(CITY_STRENGTH_TECH_EXPONENT);
		int iTechMultiplier = /*1 in CP, 0 in VP*/ GD_INT_GET(CITY_STRENGTH_TECH_MULTIPLIER);

		// The way all of this adds up...
		// 25% of the way through the game provides an extra 3.12
		// 50% of the way through the game provides an extra 12.50
		// 75% of the way through the game provides an extra 28.12
		// 100% of the way through the game provides an extra 50.00

		double fTechMod = pow(fTechProgress, fTechExponent) * iTechMultiplier * 100;
		iStrengthValue += (int)(fTechMod + 0.005f);	//is this really the way to get rid of fp inaccuracy?

	}
#if defined(MOD_BALANCE_CORE)
	if (getProductionProcess() != NO_PROCESS)
	{
		CvProcessInfo* pkProcessInfo = GC.getProcessInfo(getProductionProcess());
		if (pkProcessInfo && pkProcessInfo->getDefenseValue() != 0)
		{
			iStrengthValue += (getYieldRate(YIELD_PRODUCTION, false) * pkProcessInfo->getDefenseValue());
		}
	}

	if (GET_PLAYER(getOwner()).GetFlatDefenseFromAirUnits() != 0)
	{
		iStrengthValue += plot()->countNumAirUnits(getTeam(), true) * GET_PLAYER(getOwner()).GetFlatDefenseFromAirUnits() * 100;
	}
#endif

	// Player-wide strength mod (Policies, etc.)
	int iStrengthMod = GET_PLAYER(getOwner()).GetCityStrengthMod();

	// Crime
	iStrengthValue += GetYieldModifierFromDevelopment(YIELD_JFD_CRIME);
	iStrengthMod += GetYieldModifierFromCrime(YIELD_JFD_CRIME);

	// Apply Mod
	iStrengthValue *= (100 + iStrengthMod);
	iStrengthValue /= 100;

	if (MOD_BALANCE_CORE_MINORS && GET_PLAYER(getOwner()).isMinorCiv() && isCapital())
	{
		PlayerTypes eAlly = GET_PLAYER(getOwner()).GetMinorCivAI()->GetAlly();
		if (eAlly != NO_PLAYER)
		{
			int iAllyBonus = GET_PLAYER(eAlly).GetPlayerTraits()->GetAllianceCSDefense() + /*25*/ GD_INT_GET(BALANCE_CS_ALLIANCE_DEFENSE_BONUS);
			if (iAllyBonus > 0)
			{
				iStrengthValue *= (100 + iAllyBonus);
				iStrengthValue /= 100;
			}
		}
		if (GET_PLAYER(getOwner()).GetMinorCivAI()->IsProtectedByAnyMajor())
		{
			int iProtections = 0;
			for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
			{
				PlayerTypes eLoopPlayer = (PlayerTypes)iPlayerLoop;
				if (eLoopPlayer != NO_PLAYER && GET_PLAYER(getOwner()).GetMinorCivAI()->IsProtectedByMajor(eLoopPlayer))
				{
					iProtections++;
				}
			}
			int iPtPBonus = iProtections * /*5*/ GD_INT_GET(BALANCE_CS_PLEDGE_TO_PROTECT_DEFENSE_BONUS);
			if (iPtPBonus > /*25*/ GD_INT_GET(BALANCE_CS_PLEDGE_TO_PROTECT_DEFENSE_BONUS_MAX))
			{
				iPtPBonus = GD_INT_GET(BALANCE_CS_PLEDGE_TO_PROTECT_DEFENSE_BONUS_MAX);
			}
			if (iPtPBonus > 0)
			{
				iStrengthValue *= (100 + iPtPBonus);
				iStrengthValue /= 100;
			}
		}
	}

	// Terrain mod
	if (plot()->isHills())
		iStrengthValue += /*500 in CP, 200 in VP*/ GD_INT_GET(CITY_STRENGTH_HILL_CHANGE);
	if (plot()->isMountain())
		iStrengthValue += /*1000 in CP, 400 in VP*/ GD_INT_GET(CITY_STRENGTH_HILL_CHANGE) * 2;

	// Policies
	iStrengthValue += GET_PLAYER(getOwner()).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_CITY_DEFENSE_BOOST);

	// Garrisoned Unit
	CvUnit* pGarrisonedUnit = GetGarrisonedUnit();
	if (pGarrisonedUnit && pGarrisonedUnit->getDomainType() == DOMAIN_LAND)
	{
		int iStrengthFromGarrison = (max(pGarrisonedUnit->GetBaseCombatStrength(), pGarrisonedUnit->GetBaseRangedCombatStrength()) * 100) / /*500 in CP, 200 in VP*/ GD_INT_GET(CITY_STRENGTH_UNIT_DIVISOR);

		iStrengthValue += (iStrengthFromGarrison * 100);
	}

	// Generals / Admirals also help (both the city and the garrison)
	if (GET_PLAYER(getOwner()).GetAreaEffectModifier(AE_GREAT_GENERAL, NO_DOMAIN, plot()) > 0)
	{
		iStrengthValue += /*500 in CP, 200 in VP*/ GD_INT_GET(CITY_STRENGTH_HILL_CHANGE);
	}

	//finally
	if (iStrengthValue != m_iStrengthValue)
	{
		m_iStrengthValue = iStrengthValue;
		DLLUI->setDirty(CityInfo_DIRTY_BIT, true);
	}
}

//	--------------------------------------------------------------------------------
int CvCity::getStrengthValue(bool bForRangeStrike, bool bIgnoreBuildings, const CvUnit* pDefender) const //result is times 100
{
	VALIDATE_OBJECT
	if (MOD_BALANCE_CORE_CITY_DEFENSE_SWITCH)
	{
		// Attacks are weaker
		if (bForRangeStrike)
		{
			//always ignore building defense here
			int iValue = m_iStrengthValue;

			//this is kind of stupid but the cached value includes the bonus from the defense process
			//we need to subtract it again otherwise humans can exploit it
			if (getProductionProcess() != NO_PROCESS)
			{
				CvProcessInfo* pkProcessInfo = GC.getProcessInfo(getProductionProcess());
				if (pkProcessInfo && pkProcessInfo->getDefenseValue() != 0)
				{
					iValue -= ((getYieldRate(YIELD_PRODUCTION, false) * pkProcessInfo->getDefenseValue()) / 100);
				}
			}

			// We also remove the garrisoned unit's strength
			CvUnit* pGarrisonedUnit = GetGarrisonedUnit();
			if (pGarrisonedUnit && pGarrisonedUnit->getDomainType() == DOMAIN_LAND)
			{
				int iStrengthFromGarrisonRaw = max(pGarrisonedUnit->GetBaseCombatStrength(), pGarrisonedUnit->GetBaseRangedCombatStrength());
				int iStrengthFromGarrison = (iStrengthFromGarrisonRaw * 100) / /*500 in CP, 200 in VP*/ GD_INT_GET(CITY_STRENGTH_UNIT_DIVISOR);
				iValue -= (iStrengthFromGarrison * 100);
			}

			// buildings
			int iModifier = /*-40 in CP, 0 in VP*/ GD_INT_GET(CITY_RANGED_ATTACK_STRENGTH_MULTIPLIER);
			iModifier += getCityBuildingRangeStrikeModifier();
			if (HasGarrison())
			{
				iModifier += GET_PLAYER(m_eOwner).GetGarrisonedCityRangeStrikeModifier();
			}

			if (getOwner() < static_cast<PlayerTypes>(MAX_MAJOR_CIVS))
			{
				int iSpyID = GetCityEspionage() != NULL ? GetCityEspionage()->m_aiSpyAssignment[getOwner()] : -1;
				if (iSpyID != -1)
				{
					CvEspionageSpy* pSpy = GET_PLAYER(getOwner()).GetEspionage()->GetSpyByID(iSpyID);
					if (pSpy != NULL && pSpy->m_eSpyFocus != NO_EVENT_CHOICE_CITY)
					{
						CvModEventCityChoiceInfo* pkEventChoiceInfo = GC.getCityEventChoiceInfo(pSpy->m_eSpyFocus);
						if (pkEventChoiceInfo != NULL && pkEventChoiceInfo->getCityDefenseModifier() != 0)
							iModifier += pkEventChoiceInfo->getCityDefenseModifier();
					}
				}
			}

			// Religion city strike mod
			ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
			BeliefTypes eSecondaryPantheon = NO_BELIEF;
			if (eMajority != NO_RELIGION)
			{
				const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
				if (pReligion)
				{
					iModifier += pReligion->m_Beliefs.GetCityRangeStrikeModifier(getOwner(), GET_PLAYER(getOwner()).getCity(GetID()));
					eSecondaryPantheon = GetCityReligions()->GetSecondaryReligionPantheonBelief();
					if (eSecondaryPantheon != NO_BELIEF)
					{
						iModifier += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetCityRangeStrikeModifier();
					}
				}
			}
#if defined(MOD_RELIGION_PERMANENT_PANTHEON)
			// Mod for civs keeping their pantheon belief forever
			if (MOD_RELIGION_PERMANENT_PANTHEON)
			{
				if (GC.getGame().GetGameReligions()->HasCreatedPantheon(getOwner()))
				{
					const CvReligion* pPantheon = GC.getGame().GetGameReligions()->GetReligion(RELIGION_PANTHEON, getOwner());
					BeliefTypes ePantheonBelief = GC.getGame().GetGameReligions()->GetBeliefInPantheon(getOwner());
					if (pPantheon != NULL && ePantheonBelief != NO_BELIEF && ePantheonBelief != eSecondaryPantheon)
					{
						const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
						if (pReligion == NULL || (pReligion != NULL && !pReligion->m_Beliefs.IsPantheonBeliefInReligion(ePantheonBelief, eMajority, getOwner()))) // check that the our religion does not have our belief, to prevent double counting
						{
							iModifier += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetCityRangeStrikeModifier();
						}
					}
				}
			}
#endif

			// OTHER UNIT is a Barbarian
			if (pDefender != NULL && pDefender->isBarbarian())
			{
				// Generic Barb Combat Bonus
				iModifier += GET_PLAYER(getOwner()).GetBarbarianCombatBonus(false);
			}

			iValue *= (100 + iModifier);
			iValue /= 100;

			return iValue;
		}
	}
	else
	{
		// Attacks are weaker
		if (bForRangeStrike)
		{
			//always ignore building defense here
			int iValue = m_iStrengthValue - m_pCityBuildings->GetBuildingDefense();

			//this is kind of stupid but the cached value includes the bonus from the defense process
			//we need to subtract it again otherwise humans can exploit it
			if (getProductionProcess() != NO_PROCESS)
			{
				CvProcessInfo* pkProcessInfo = GC.getProcessInfo(getProductionProcess());
				if (pkProcessInfo && pkProcessInfo->getDefenseValue() != 0)
				{
					iValue -= ((getYieldRate(YIELD_PRODUCTION, false) * pkProcessInfo->getDefenseValue()) / 100);
				}
			}

			int iModifier = /*-40 in CP, 0 in VP*/ GD_INT_GET(CITY_RANGED_ATTACK_STRENGTH_MULTIPLIER);
			if (HasGarrison())
			{
				iModifier += GET_PLAYER(m_eOwner).GetGarrisonedCityRangeStrikeModifier();
			}

			//bonus for attacking same unit over and over in a turn?
			//cannot apply this here because we don't know the defender and cannot change the interface. stupid lua.
			/*
			if (pDefender != NULL)
			{
			int iTempModifier = GET_PLAYER(getOwner()).GetPlayerTraits()->GetMultipleAttackBonus();
			if (iTempModifier != 0)
			{
			iTempModifier *= pDefender->GetNumTimesAttackedThisTurn(getOwner());
			iModifier += iTempModifier;
			}
			}
			*/

			// buildings
			iModifier += getCityBuildingRangeStrikeModifier();

			// Religion city strike mod
			int iReligionCityStrikeMod = 0;
			ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
			BeliefTypes eSecondaryPantheon = NO_BELIEF;
			if (eMajority != NO_RELIGION)
			{
				const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
				if (pReligion)
				{
					iReligionCityStrikeMod = pReligion->m_Beliefs.GetCityRangeStrikeModifier(getOwner(), GET_PLAYER(getOwner()).getCity(GetID()));
					eSecondaryPantheon = GetCityReligions()->GetSecondaryReligionPantheonBelief();
					if (eSecondaryPantheon != NO_BELIEF)
					{
						iReligionCityStrikeMod += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetCityRangeStrikeModifier();
					}
					if (iReligionCityStrikeMod > 0)
					{
						iModifier += iReligionCityStrikeMod;
					}
				}
			}
#if defined(MOD_RELIGION_PERMANENT_PANTHEON)
			// Mod for civs keeping their pantheon belief forever
			if (MOD_RELIGION_PERMANENT_PANTHEON)
			{
				if (GC.getGame().GetGameReligions()->HasCreatedPantheon(getOwner()))
				{
					const CvReligion* pPantheon = GC.getGame().GetGameReligions()->GetReligion(RELIGION_PANTHEON, getOwner());
					BeliefTypes ePantheonBelief = GC.getGame().GetGameReligions()->GetBeliefInPantheon(getOwner());
					if (pPantheon != NULL && ePantheonBelief != NO_BELIEF && ePantheonBelief != eSecondaryPantheon)
					{
						const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
						if (pReligion == NULL || (pReligion != NULL && !pReligion->m_Beliefs.IsPantheonBeliefInReligion(ePantheonBelief, eMajority, getOwner()))) // check that the our religion does not have our belief, to prevent double counting
						{
							iModifier += GC.GetGameBeliefs()->GetEntry(ePantheonBelief)->GetCityRangeStrikeModifier();
						}
					}
				}
			}
#endif

			iValue *= (100 + iModifier);
			iValue /= 100;

			return iValue;
		}
	}

	if (bIgnoreBuildings)
		return m_iStrengthValue - m_pCityBuildings->GetBuildingDefense();
	else
		return m_iStrengthValue;
}

//	--------------------------------------------------------------------------------
int CvCity::GetPower() const
{
	VALIDATE_OBJECT
	return int(pow((double)getStrengthValue() / 100, 1.5));		// This is the same math used to calculate Unit Power in CvUnitEntry
}


//	--------------------------------------------------------------------------------
int CvCity::getDamage() const
{
	VALIDATE_OBJECT
	return m_iDamage;
}

//	--------------------------------------------------------------------------------
void CvCity::setDamage(int iValue, bool noMessage)
{
	float fDelay = 0.0f;

	VALIDATE_OBJECT

	if (iValue < 0)
		iValue = 0;
	else if (iValue > GetMaxHitPoints())
		iValue = GetMaxHitPoints();

	if (iValue != getDamage())
	{
		int iOldValue = getDamage();
		CvInterfacePtr<ICvCity1> pDllCity(new CvDllCity(this));
		gDLL->GameplayCitySetDamage(pDllCity.get(), iValue, iOldValue);

		// send the popup text if the player can see this plot
		if (!noMessage && plot()->GetActiveFogOfWarMode() == FOGOFWARMODE_OFF)
		{
			char text[256];
			text[0] = '\0';
			int iNewValue = MIN(GetMaxHitPoints(), iValue);
			int iDiff = iOldValue - iNewValue;
			if (iNewValue < iOldValue)
			{
				sprintf_s(text, "[COLOR_GREEN]+%d[ENDCOLOR]", iDiff);
				fDelay = /*2.0f*/ GD_FLOAT_GET(POST_COMBAT_TEXT_DELAY) * 2;
			}
			else
			{
				sprintf_s(text, "[COLOR_RED]%d[ENDCOLOR]", iDiff);
			}

			SHOW_PLOT_POPUP(plot(), NO_PLAYER, text);
		}
		m_iDamage = iValue;
	}
}

//	--------------------------------------------------------------------------------
void CvCity::changeDamage(int iChange)
{
	VALIDATE_OBJECT
	if (0 != iChange)
	{
		setDamage(getDamage() + iChange);
	}
}

//	--------------------------------------------------------------------------------
/// Can a specific plot be bought for the city
bool CvCity::CanBuyPlot(int iPlotX, int iPlotY, bool bIgnoreCost)
{
	VALIDATE_OBJECT

	if (/*0*/ GD_INT_GET(BUY_PLOTS_DISABLED) > 0)
		return false;

	if (getOwner() == NO_PLAYER)
		return false;

	if (IsResistance() || IsIgnoreCityForHappiness())
		return false;

	CvPlot* pTargetPlot = GC.getMap().plot(iPlotX, iPlotY);
	if (!pTargetPlot)
		return false;

	// if this plot belongs to someone, bail!
	if (pTargetPlot->getOwner() != NO_PLAYER)
	{
		if (GET_PLAYER(getOwner()).GetPlayerTraits()->IsBuyOwnedTiles())
		{
			if (pTargetPlot->getOwner() == getOwner() || pTargetPlot->isCity())
				return false;

			//can't buy the master's plots if you're a vassal
			if (GET_TEAM(getTeam()).IsVassal(pTargetPlot->getTeam()))
				return false;

			// Bad idea for AI to steal?
			if (!GET_PLAYER(getOwner()).isHuman() && GET_PLAYER(getOwner()).isMajorCiv() && GET_PLAYER(getOwner()).GetDiplomacyAI()->IsPlayerBadTheftTarget(pTargetPlot->getOwner(), THEFT_TYPE_PLOT, pTargetPlot))
				return false;
		}
		else
		{
			return false;
		}
	}

	//VP: can't buy plot with enemy combat units (except Barbarians)
	if (MOD_BALANCE_VP && pTargetPlot->isEnemyUnit(getOwner(), true, false, true, false))
		return false;

	// Must be adjacent to a plot owned by this city
	bool bFoundAdjacent = false;
	for (int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)
	{
		CvPlot* pAdjacentPlot = plotDirection(pTargetPlot->getX(), pTargetPlot->getY(), ((DirectionTypes)iI));
		if (pAdjacentPlot != NULL)
		{
			if (pAdjacentPlot->getOwner() == getOwner())
			{
				if (pAdjacentPlot->getOwningCityID() == GetID())
				{
					bFoundAdjacent = true;
					break;
				}
			}
		}
	}

	if (!bFoundAdjacent)
		return false;

	// Max range
	const int iMaxRange = getBuyPlotDistance();
	if (plotDistance(iPlotX, iPlotY, getX(), getY()) > iMaxRange)
		return false;

	// check money
	if (!bIgnoreCost)
	{
		if (GET_PLAYER(getOwner()).GetTreasury()->GetGold() < GetBuyPlotCost(pTargetPlot->getX(), pTargetPlot->getY()))
		{
			return false;
		}
	}

	//can only claim ocean tiles after we can cross oceans
	if (pTargetPlot->isDeepWater())
	{
		CvPlayer& kPlayer = GET_PLAYER(getOwner());
		if (!kPlayer.CanCrossOcean())
			return false;
	}

	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if (pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(getOwner());
		args->Push(GetID());
		args->Push(iPlotX);
		args->Push(iPlotY);

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if (LuaSupport::CallTestAll(pkScriptSystem, "CityCanBuyPlot", args.get(), bResult))
		{
			// Check the result.
			if (!bResult)
				return false;
		}
	}

	return true;
}


//	--------------------------------------------------------------------------------
/// Can this city buy a plot, any plot?
bool CvCity::CanBuyAnyPlot(void)
{
	if (IsResistance() || IsIgnoreCityForHappiness())
		return false;

	VALIDATE_OBJECT
	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
	if (pkScriptSystem)
	{
		CvLuaArgsHandle args;
		args->Push(getOwner());
		args->Push(GetID());

		// Attempt to execute the game events.
		// Will return false if there are no registered listeners.
		bool bResult = false;
		if (LuaSupport::CallTestAll(pkScriptSystem, "CityCanBuyAnyPlot", args.get(), bResult))
		{
			// Check the result.
			if (!bResult)
			{
				if (GC.getLogging() && GC.getAILogging())
				{
					const CvPlayerAI& kOwner = GET_PLAYER(getOwner());
					CvString strPlayerName = kOwner.getCivilizationShortDescription();
					CvString strBaseString = CvString::format("%03d, %s, %s, CanBuyAnyPlot failed in lua hook",
						GC.getGame().getElapsedGameTurns(), strPlayerName.c_str(), getName().GetCString());
					kOwner.GetCitySpecializationAI()->LogMsg(strBaseString);
				}

				return false;
			}
		}
	}

	vector<int> plots;
	GetBuyablePlotList(plots, true);
	return !plots.empty();
}


//	--------------------------------------------------------------------------------
/// Which plot will we buy next
CvPlot* CvCity::GetNextBuyablePlot(bool bForPurchase)
{
	VALIDATE_OBJECT
	std::vector<int> aiPlotList;
	GetBuyablePlotList(aiPlotList, bForPurchase);

	if (aiPlotList.empty())
		return NULL;

	int iPickedIndex = GC.getGame().getSmallFakeRandNum(aiPlotList.size(), getFoodTimes100() + GET_PLAYER(m_eOwner).GetNumPlots());
	return GC.getMap().plotByIndex(aiPlotList[iPickedIndex]);
}

//	--------------------------------------------------------------------------------
void CvCity::GetBuyablePlotList(std::vector<int>& aiPlotList, bool bForPurchase, int nChoices)
{
	aiPlotList.clear();
	std::vector< pair<int, int> > resultList;

	CvPlot* pLoopPlot = NULL;
	CvPlot* pThisPlot = plot();
	const int iMaxRange = /*5*/ range(GD_INT_GET(MAXIMUM_ACQUIRE_PLOT_DISTANCE), 1, MAX_CITY_RADIUS);
	TeamTypes thisTeam = getTeam();

	int iPLOT_INFLUENCE_DISTANCE_MULTIPLIER =	/*100*/ GD_INT_GET(PLOT_INFLUENCE_DISTANCE_MULTIPLIER);
	int iPLOT_INFLUENCE_RING_COST =				/*100*/ GD_INT_GET(PLOT_INFLUENCE_RING_COST);
	int iPLOT_INFLUENCE_RESOURCE_COST =			/*-105 in CP, -180 in VP*/ GD_INT_GET(PLOT_INFLUENCE_RESOURCE_COST);
	int iPLOT_INFLUENCE_NW_COST =				/*-105 in CP, -500 in VP*/ GD_INT_GET(PLOT_INFLUENCE_NW_COST);
	int iPLOT_INFLUENCE_WATER_COST =			/*25 in CP, 20 in VP*/ GD_INT_GET(PLOT_INFLUENCE_WATER_COST);
	int iPLOT_INFLUENCE_YIELD_POINT_COST =		/*-1 in CP, -40 in VP*/ GD_INT_GET(PLOT_INFLUENCE_YIELD_POINT_COST);
	int iPLOT_INFLUENCE_NO_ADJACENT_OWNED_COST = /*1000*/ GD_INT_GET(PLOT_INFLUENCE_NO_ADJACENT_OWNED_COST);
	int iPLOT_INFLUENCE_ADJACENT_NW_COST = -3;
	int iPLOT_INFLUENCE_ADJACENT_RESOURCE_COST = -2;
	int iPLOT_INFLUENCE_ADJACENT_ENEMY_COST = -1;

	int iYieldLoop = 0;
	int iDirectionLoop = 0;
	bool bFoundAdjacentOwnedByCity = false;

	SPathFinderUserData data(getOwner(), PT_CITY_INFLUENCE, iMaxRange);
	ReachablePlots influencePlots = GC.GetStepFinder().GetPlotsInReach(pThisPlot, data);

	int iWorkPlotDistance = getWorkPlotDistance();
	ImprovementTypes eBarbCamptype = (ImprovementTypes)GD_INT_GET(BARBARIAN_CAMP_IMPROVEMENT);

	for (int iDX = -iMaxRange; iDX <= iMaxRange; iDX++)
	{
		for (int iDY = -iMaxRange; iDY <= iMaxRange; iDY++)
		{
			pLoopPlot = plotXYWithRangeCheck(getX(), getY(), iDX, iDY, iMaxRange);
			if (pLoopPlot != NULL)
			{
				if (pLoopPlot->getOwner() != NO_PLAYER)
				{
#if defined(MOD_BALANCE_CORE)
					if (MOD_BALANCE_CORE && GET_PLAYER(getOwner()).GetPlayerTraits()->IsBuyOwnedTiles() && bForPurchase)
					{
						if (pLoopPlot->getOwner() == getOwner() || pLoopPlot->isCity())
						{
							continue;
						}
					}
					else
					{
#endif
						continue;
#if defined(MOD_BALANCE_CORE)
					}
#endif
				}
#if defined(MOD_BALANCE_CORE)
				//Let's rule out getting plots for which we lack an adjacent owned plot.
				bool bNoNeighbor = true;
				bool bPromiseNeighbor = false;
				for (int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)
				{
					CvPlot* pAdjacentPlot = plotDirection(pLoopPlot->getX(), pLoopPlot->getY(), ((DirectionTypes)iI));

					if (pAdjacentPlot != NULL)
					{
						if (pAdjacentPlot->getOwner() == getOwner() && pAdjacentPlot->getOwningCityID() == GetID())
						{
							bNoNeighbor = false;
							break;
						}
						if (bForPurchase && pAdjacentPlot->getOwner() != NO_PLAYER && GET_PLAYER(pAdjacentPlot->getOwner()).isMajorCiv())
						{
							if (GET_PLAYER(pAdjacentPlot->getOwner()).GetDiplomacyAI()->IsPlayerMadeBorderPromise(getOwner()))
							{
								bPromiseNeighbor = true;
								break;
							}
						}
					}
				}
				if (bNoNeighbor)
				{
					continue;
				}
				if (bPromiseNeighbor)
				{
					continue;
				}
#endif
#if defined(MOD_EVENTS_CITY_BORDERS)
				// This can be used to implement a 12-mile limit
				if (MOD_EVENTS_CITY_BORDERS) {
					if (GAMEEVENTINVOKE_TESTALL(GAMEEVENT_CityCanAcquirePlot, getOwner(), GetID(), pLoopPlot->getX(), pLoopPlot->getY()) == GAMEEVENTRETURN_FALSE) {
						continue;
					}
				}
				else {
#endif				
					ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
					if (pkScriptSystem)
					{
						CvLuaArgsHandle args;
						args->Push(getOwner());
						args->Push(GetID());
						args->Push(pLoopPlot->getX());
						args->Push(pLoopPlot->getY());

						bool bResult = false;
						if (LuaSupport::CallTestAll(pkScriptSystem, "CityCanAcquirePlot", args.get(), bResult))
						{
							if (bResult == false) {
								continue;
							}
						}
					}
#if defined(MOD_EVENTS_CITY_BORDERS)
				}
#endif			

				ReachablePlots::iterator it = influencePlots.find(pLoopPlot->GetPlotIndex());
				int iInfluenceCost = (it != influencePlots.end()) ? (it->iNormalizedDistanceRaw / SPath::getNormalizedDistanceBase()) : -1;

				if (iInfluenceCost >= 0)
				{
					iInfluenceCost *= iPLOT_INFLUENCE_DISTANCE_MULTIPLIER;

					// Resource Plots claimed first
					int iResourceMod = 0;
					ResourceTypes eResource = pLoopPlot->getResourceType(thisTeam);
					if (eResource != NO_RESOURCE)
					{
						CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
						if (pkResource)
						{
							//bonus resources are preferred because of their added yields anyway ... here it's just about trade
							if (pkResource->getResourceUsage() == RESOURCEUSAGE_LUXURY || pkResource->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)
							{
								iResourceMod += iPLOT_INFLUENCE_RESOURCE_COST;
								if (GET_PLAYER(getOwner()).getNumResourceTotal(eResource) == 0)
									iResourceMod += iPLOT_INFLUENCE_RESOURCE_COST / 2;
							}

							if (GET_PLAYER(getOwner()).WouldGainMonopoly(eResource, pLoopPlot->getNumResource()))
								iResourceMod += iPLOT_INFLUENCE_RESOURCE_COST;

						}
					}

					if (iResourceMod == 0) //no resource or ignored resource
					{
						// Water Plots claimed later
						if (pLoopPlot->isWater() && !pLoopPlot->isLake())
							iInfluenceCost += iPLOT_INFLUENCE_WATER_COST;
					}
					else
						iInfluenceCost += iResourceMod;

					// if we can't work this tile in this city make it much less likely to be picked
					if (plotDistance(pLoopPlot->getX(), pLoopPlot->getY(), getX(), getY()) > iWorkPlotDistance)
					{
						iInfluenceCost += iPLOT_INFLUENCE_RING_COST * 2;
					}

					// avoid barbarian camps
					ImprovementTypes thisImprovement = pLoopPlot->getImprovementType();
					if (thisImprovement == eBarbCamptype)
					{
						iInfluenceCost += iPLOT_INFLUENCE_RING_COST;
					}

					// while we're at it grab Natural Wonders quickly also
					if (pLoopPlot->IsNaturalWonder())
					{
						iInfluenceCost += iPLOT_INFLUENCE_NW_COST;
					}

					if (pLoopPlot->isLake())
					{
						iInfluenceCost += (iPLOT_INFLUENCE_NW_COST / 2);
					}

					// More Yield == more desirable
					for (iYieldLoop = 0; iYieldLoop < NUM_YIELD_TYPES; iYieldLoop++)
					{
						//Simplification - errata yields not worth considering.
						if ((YieldTypes)iYieldLoop > YIELD_GOLDEN_AGE_POINTS && !MOD_BALANCE_CORE_JFD)
							break;

						int iWeight = (iYieldLoop == GetCityStrategyAI()->GetMostDeficientYield()) ? 3 : 1;

						iInfluenceCost += (iPLOT_INFLUENCE_YIELD_POINT_COST * pLoopPlot->getYield((YieldTypes)iYieldLoop) * iWeight);
					}

					// all other things being equal move towards unclaimed resources
					bool bUnownedNaturalWonderAdjacentCount = false;
					bool bEnemyPlotAdjacent = false;
					for (int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)
					{
						CvPlot* pAdjacentPlot = plotDirection(pLoopPlot->getX(), pLoopPlot->getY(), ((DirectionTypes)iI));

						if (pAdjacentPlot != NULL)
						{
							if (pAdjacentPlot->getOwner() == NO_PLAYER)
							{
								int iPlotDistance = plotDistance(getX(), getY(), pAdjacentPlot->getX(), pAdjacentPlot->getY());
								ResourceTypes eAdjacentResource = pAdjacentPlot->getResourceType(thisTeam);
								if (eAdjacentResource != NO_RESOURCE)
								{
									// if we are close enough to work, or this is not a bonus resource
									if (iPlotDistance <= iWorkPlotDistance || GC.getResourceInfo(eAdjacentResource)->getResourceUsage() != RESOURCEUSAGE_BONUS)
									{
										iInfluenceCost += iPLOT_INFLUENCE_ADJACENT_RESOURCE_COST;
									}
								}

								if (iPlotDistance <= iWorkPlotDistance) // grab for this city
								{
									if (pAdjacentPlot->IsNaturalWonder())
										bUnownedNaturalWonderAdjacentCount = true;

									if (pAdjacentPlot->getOwner() != NO_PLAYER && pAdjacentPlot->getTeam() != getTeam())
										bEnemyPlotAdjacent = true;
								}
							}
						}
					}

					// move towards unclaimed NW
					if (bUnownedNaturalWonderAdjacentCount)
						iInfluenceCost += iPLOT_INFLUENCE_ADJACENT_NW_COST;

					// move towards enemy
					if (bEnemyPlotAdjacent)
						iInfluenceCost += iPLOT_INFLUENCE_ADJACENT_ENEMY_COST;

					// Plots not adjacent to another Plot acquired by this City are pretty much impossible to get
					bFoundAdjacentOwnedByCity = false;
					for (iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; iDirectionLoop++)
					{
						CvPlot* pAdjacentPlot = plotDirection(pLoopPlot->getX(), pLoopPlot->getY(), (DirectionTypes)iDirectionLoop);

						if (pAdjacentPlot != NULL)
						{
							if (pAdjacentPlot->getOwner() == getOwner() && pAdjacentPlot->getOwningCityID() == GetID())
							{
								bFoundAdjacentOwnedByCity = true;
								break;
							}
						}
					}

					if (!bFoundAdjacentOwnedByCity)
					{
						iInfluenceCost += iPLOT_INFLUENCE_NO_ADJACENT_OWNED_COST;
					}

					resultList.push_back(std::make_pair(iInfluenceCost, pLoopPlot->GetPlotIndex()));
				}
			}
		}
	}

	//we want only the best
	std::stable_sort(resultList.begin(), resultList.end());
	if (resultList.size() > (size_t)nChoices)
		resultList.erase(resultList.begin() + nChoices, resultList.end());

	//throw away the cost, return the plot index only
	for (size_t i = 0; i < resultList.size(); i++)
		//if there's a clear favorite, don't bother with the rest
		if (resultList[i].first - resultList[0].first <= 100)
			aiPlotList.push_back(resultList[i].second);
}

//	--------------------------------------------------------------------------------
int CvCity::calculateInfluenceDistance(CvPlot* pDest, int iMaxRange) const
{
	if (pDest == NULL)
		return -1;

	SPathFinderUserData data(getOwner(), PT_CITY_INFLUENCE, iMaxRange);
	SPath path = GC.GetStepFinder().GetPath(getX(), getY(), pDest->getX(), pDest->getY(), data);
	if (!path)
		return -1; // no passable path exists
	else
		return (path.iNormalizedDistanceRaw * /*100*/ GD_INT_GET(PLOT_INFLUENCE_DISTANCE_MULTIPLIER)) / SPath::getNormalizedDistanceBase();
}

//	--------------------------------------------------------------------------------
/// How much will purchasing this plot cost -- (-1,-1) will return the generic price
int CvCity::GetBuyPlotCost(int iPlotX, int iPlotY) const
{
	VALIDATE_OBJECT
	if (iPlotX == -1 && iPlotY == -1)
	{
		return GET_PLAYER(getOwner()).GetBuyPlotCost();
	}

	CvPlot* pPlot = GC.getMap().plot(iPlotX, iPlotY);
	if (!pPlot)
	{
		return -1;
	}

	// Base cost
	int iCost = GET_PLAYER(getOwner()).GetBuyPlotCost();

	const int iMaxRange = getBuyPlotDistance();
	if (plotDistance(iPlotX, iPlotY, getX(), getY()) > iMaxRange)
		return 9999; // Critical hit!

	int iPLOT_INFLUENCE_BASE = /*100*/ GD_INT_GET(PLOT_INFLUENCE_BASE_MULTIPLIER);
	int iPLOT_INFLUENCE_DISTANCE_DIVISOR = /*3*/ GD_INT_GET(PLOT_INFLUENCE_DISTANCE_DIVISOR);
	int iPLOT_BUY_RESOURCE_COST = /*-100 in CP, 0 in VP*/ GD_INT_GET(PLOT_BUY_RESOURCE_COST);

	int iDistance = calculateInfluenceDistance(pPlot, iMaxRange);
	int iRefDistance = GetCheapestPlotInfluenceDistance();
	if (iRefDistance == INT_MAX)
		iRefDistance = 0;

	//note: we don't use getPLOT_INFLUENCE_DISTANCE_MULTIPLIER() here because the influence distance is already pre-multiplied
	int iInfluenceCostFactor = iPLOT_INFLUENCE_BASE + (iDistance - iRefDistance) / iPLOT_INFLUENCE_DISTANCE_DIVISOR;
	if (pPlot->getResourceType(getTeam()) != NO_RESOURCE)
	{
		iInfluenceCostFactor += iPLOT_BUY_RESOURCE_COST;
	}

	if (iInfluenceCostFactor > 100)
	{
		iCost *= iInfluenceCostFactor;
		iCost /= 100;
	}

#if defined(MOD_UI_CITY_EXPANSION)
	if (MOD_UI_CITY_EXPANSION && GET_PLAYER(getOwner()).isHuman()) {
		// If we have a culture surplus, we get a discount on the tile
		if (GetJONSCultureStored() >= GetJONSCultureThreshold()) {
			iCost -= GET_PLAYER(getOwner()).GetBuyPlotCost();
		}
	}
#endif

#if defined(MOD_BALANCE_CORE)
	//Owned by someone? Much more expensive!
	if (MOD_BALANCE_CORE && GET_PLAYER(getOwner()).GetPlayerTraits()->IsBuyOwnedTiles())
	{
		if ((pPlot->getOwner() != NO_PLAYER) && (pPlot->getOwner() != getOwner()))
		{
			iCost *= 3;
			iCost /= 2;
		}
	}
#endif

	// Discount for adjacent plots owned by us
	iCost = iCost * (105 - pPlot->countMatchingAdjacentPlots(NO_DOMAIN, getOwner(), NO_PLAYER, NO_PLAYER) * 5); //we know that one is always owned
	iCost /= 100;

	// Game Speed Mod
	iCost *= GC.getGame().getGameSpeedInfo().getGoldPercent();
	iCost /= 100;

	iCost *= (100 + getPlotBuyCostModifier());
	iCost /= 100;

	// Now round so the number looks neat
	int iDivisor = /*5*/ max(1, GD_INT_GET(PLOT_COST_APPEARANCE_DIVISOR));
	iCost = (iCost + iDivisor / 2) / iDivisor;
	iCost *= iDivisor;

	return iCost;
}

//	--------------------------------------------------------------------------------
/// Buy the plot and set it's owner to us (executed by the network code)
void CvCity::BuyPlot(int iPlotX, int iPlotY)
{
	VALIDATE_OBJECT
	CvPlot* pPlot = GC.getMap().plot(iPlotX, iPlotY);
	if (!pPlot)
	{
		return;
	}

	int iCost = GetBuyPlotCost(iPlotX, iPlotY);
	CvPlayer& thisPlayer = GET_PLAYER(getOwner());
	thisPlayer.GetTreasury()->LogExpenditure("buy plot", iCost, 1);
	thisPlayer.GetTreasury()->ChangeGold(-iCost);

#if defined(MOD_UI_CITY_EXPANSION)
	bool bWithGold = true;
	if (MOD_UI_CITY_EXPANSION && GET_PLAYER(getOwner()).isHuman()) {
		// If we have a culture surplus, we got a discount on the tile, so remove the surplus
		int iOverflow = GetJONSCultureStored() - GetJONSCultureThreshold();
		if (iOverflow >= 0) {
			SetJONSCultureStored(iOverflow);
			ChangeJONSCultureLevel(1);
			bWithGold = false;
		}
	}
#endif

#if defined(MOD_BALANCE_CORE)
	if (iCost > 0 && !GET_PLAYER(getOwner()).isBarbarian() && !GET_PLAYER(pPlot->getOwner()).isBarbarian())
	{
		// Did we buy this plot from someone? They're gonna be mad!
		PlayerTypes ePlotOwner = pPlot->getOwner();
		int iTileValue = /*80*/ GD_INT_GET(STOLEN_TILE_BASE_WAR_VALUE);
		int iValueMultiplier = 0;
		bool bStoleHighValueTile = false;

		if (pPlot->IsNaturalWonder())
		{
			iValueMultiplier += 200;
			bStoleHighValueTile = true;
		}
		else
		{
			if (pPlot->getResourceType(GET_PLAYER(ePlotOwner).getTeam()) != NO_RESOURCE)
			{
				CvResourceInfo* pInfo = GC.getResourceInfo(pPlot->getResourceType(GET_PLAYER(ePlotOwner).getTeam()));
				if (pInfo)
				{
					switch (pInfo->getResourceUsage())
					{
					case RESOURCEUSAGE_STRATEGIC:
						iValueMultiplier += 100;
						bStoleHighValueTile = true;
						break;
					case RESOURCEUSAGE_LUXURY:
						iValueMultiplier += 50;
						bStoleHighValueTile = true;
						break;
					case RESOURCEUSAGE_BONUS:
						iValueMultiplier += 20;
						break;
					}
				}
			}
			CvImprovementEntry* pkImprovement = GC.getImprovementInfo(pPlot->getImprovementType());
			if (pPlot->IsChokePoint())
			{
				iValueMultiplier += 50;
				bStoleHighValueTile = true;

				if (pkImprovement)
				{
					static const ImprovementTypes eCitadel = (ImprovementTypes)GC.getInfoTypeForString("IMPROVEMENT_CITADEL");
					static const ImprovementTypes eFort = (ImprovementTypes)GC.getInfoTypeForString("IMPROVEMENT_FORT");

					if (eCitadel != NO_IMPROVEMENT && pPlot->getImprovementType() == eCitadel)
					{
						iValueMultiplier += 100;
					}
					else if (eFort != NO_IMPROVEMENT && pPlot->getImprovementType() == eFort)
					{
						iValueMultiplier += 50;
					}
				}
			}
			if (pkImprovement)
			{
				if (pkImprovement->IsCreatedByGreatPerson())
				{
					iValueMultiplier += 100;
					bStoleHighValueTile = true;
				}
			}
			// Stole a major civ's embassy from a City-State?
			if (pPlot->IsImprovementEmbassy() && GET_PLAYER(ePlotOwner).isMinorCiv())
			{
				PlayerTypes eEmbassyOwner = pPlot->GetPlayerThatBuiltImprovement();
				if (GET_PLAYER(eEmbassyOwner).isAlive() && GET_PLAYER(eEmbassyOwner).isMajorCiv() && GET_PLAYER(eEmbassyOwner).getTeam() != GET_PLAYER(getOwner()).getTeam())
				{
					// Notify the embassy owner
					CvNotifications* pNotifications = GET_PLAYER(eEmbassyOwner).GetNotifications();
					if (pNotifications)
					{
						CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_GREAT_ARTIST_STOLE_PLOT", GET_PLAYER(getOwner()).getNameKey());
						CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_GREAT_ARTIST_STOLE_PLOT", GET_PLAYER(getOwner()).getNameKey());
						pNotifications->Add(NOTIFICATION_GENERIC, strBuffer, strSummary, pPlot->getX(), pPlot->getY(), -1);
					}

					// The embassy owner is mad (doubly so if they're diplomacy-inclined)!
					if (!GET_PLAYER(eEmbassyOwner).isHuman())
					{
						int iPenalty = (GET_PLAYER(eEmbassyOwner).GetDiplomacyAI()->IsDiplomat() || GET_PLAYER(eEmbassyOwner).GetPlayerTraits()->IsDiplomat()) ? 6 : 3;
						GET_PLAYER(eEmbassyOwner).GetDiplomacyAI()->ChangeNumTimesCultureBombed(getOwner(), iPenalty);
					}

					// Stole from the City-State's ally? The City-State is furious!
					if (GET_PLAYER(ePlotOwner).GetMinorCivAI()->GetAlly() == eEmbassyOwner)
					{
						GET_PLAYER(ePlotOwner).GetMinorCivAI()->SetFriendshipWithMajor(getOwner(), /*-60*/ GD_INT_GET(MINOR_FRIENDSHIP_AT_WAR));
					}
					// Stole from the City-State's friend and we're not their ally? Reset Influence to 0.
					else if (GET_PLAYER(ePlotOwner).GetMinorCivAI()->GetAlly() != getOwner() && GET_PLAYER(ePlotOwner).GetMinorCivAI()->IsFriends(eEmbassyOwner))
					{
						if (GET_PLAYER(ePlotOwner).GetMinorCivAI()->GetBaseFriendshipWithMajorTimes100(getOwner()) > 0)
						{
							GET_PLAYER(ePlotOwner).GetMinorCivAI()->SetFriendshipWithMajor(getOwner(), 0);
						}
					}
				}
			}
		}

		iTileValue *= (100 + iValueMultiplier);
		iTileValue /= 100;

		// If the players are at war, this counts for war value!
		if (GET_PLAYER(getOwner()).IsAtWarWith(ePlotOwner))
		{
			// Update military rating for both players
			if (GET_PLAYER(getOwner()).isMajorCiv())
			{
				GET_PLAYER(getOwner()).ChangeMilitaryRating(iTileValue); // rating up for thief (us)

				int iWarProgress = /*20*/ GD_INT_GET(WAR_PROGRESS_STOLE_TILE);
				if (bStoleHighValueTile)
				{
					iWarProgress *= /*200*/ GD_INT_GET(WAR_PROGRESS_HIGH_VALUE_PILLAGE_MULTIPLIER);
					iWarProgress /= 200;
				}
				else
					iWarProgress /= 4;

				GET_PLAYER(getOwner()).GetDiplomacyAI()->ChangeWarProgressScore(ePlotOwner, iWarProgress);
			}
			if (GET_PLAYER(ePlotOwner).isMajorCiv())
			{
				GET_PLAYER(ePlotOwner).ChangeMilitaryRating(-iTileValue); // rating down for victim (them)

				int iWarProgress = /*-10*/ GD_INT_GET(WAR_PROGRESS_LOST_TILE);
				if (bStoleHighValueTile)
				{
					iWarProgress *= /*200*/ GD_INT_GET(WAR_PROGRESS_HIGH_VALUE_PILLAGE_MULTIPLIER);
					iWarProgress /= 200;
				}
				else
					iWarProgress /= 4;

				GET_PLAYER(ePlotOwner).GetDiplomacyAI()->ChangeWarProgressScore(getOwner(), iWarProgress);
			}

			// Does the city owner have a bonus to war score accumulation?
			iTileValue *= (100 + GET_PLAYER(getOwner()).GetWarScoreModifier());
			iTileValue /= 100;

			GET_PLAYER(ePlotOwner).ChangeWarValueLost(getOwner(), iTileValue);
		}

		// Diplomacy penalty for stealing territory!
		if (GET_PLAYER(getOwner()).isMajorCiv())
		{
			if (GET_PLAYER(ePlotOwner).isMajorCiv())
			{
				int iPenalty = bStoleHighValueTile ? 3 : 1;
				GET_PLAYER(ePlotOwner).GetDiplomacyAI()->ChangeNumTimesCultureBombed(getOwner(), iPenalty);
			}
			else if (GET_PLAYER(ePlotOwner).isMinorCiv())
			{
				int iEra = GC.getGame().getCurrentEra();
				if (iEra <= 0)
				{
					iEra = 1;
				}

				GET_PLAYER(ePlotOwner).GetMinorCivAI()->ChangeFriendshipWithMajor(getOwner(), (iEra * -20));
			}
		}
	}
#endif

#if defined(MOD_UI_CITY_EXPANSION)
	if (iCost > 0)
	{
		// Only do this if we actually paid for the plot (as opposed to getting it for free via city growth)
#endif
		thisPlayer.ChangeNumPlotsBought(1);

		//Let's look at max range for plot purchases for this City.
		//Buying plots further and further from your city will make this more likely to trigger bad diplo.
		for (int iI = 0; iI < GetNumWorkablePlots(); iI++)
		{
			CvPlot* pLoopPlot = iterateRingPlots(iPlotX, iPlotY, iI);

			if (pLoopPlot != NULL)
			{
				// See if there's anyone else nearby that could get upset by this action
				CvCity* pNearbyCity = pLoopPlot->getPlotCity();
				if (pNearbyCity)
				{
					PlayerTypes ePlayer = pNearbyCity->getOwner();
					//We found another player? Good.
					if (ePlayer != NO_PLAYER && !GET_PLAYER(ePlayer).isMinorCiv() && ePlayer != getOwner())
					{
						//Resource? Grr!
						if (pPlot->getResourceType(GET_PLAYER(ePlayer).getTeam()) != NO_RESOURCE)
						{
							pNearbyCity->AI_ChangeNumPlotsAcquiredByOtherPlayer(getOwner(), 1);
							break;
						}
						//Natural Wonder? Grr!!!!
						if (pPlot->IsNaturalWonder())
						{
							pNearbyCity->AI_ChangeNumPlotsAcquiredByOtherPlayer(getOwner(), 3);
							break;
						}
						//Neighbors? Grr!
						int iUsOwned = 0;
						int iThemOwned = 0;
						CvPlot* pAdjacentPlot = NULL;
						for (int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; iDirectionLoop++)
						{
							pAdjacentPlot = plotDirection(pPlot->getX(), pPlot->getY(), ((DirectionTypes)iDirectionLoop));

							if (pAdjacentPlot != NULL)
							{
								if (pAdjacentPlot->getOwner() == ePlayer)
								{
									iThemOwned++;
								}
								if (pAdjacentPlot->getOwner() == getOwner())
								{
									iUsOwned++;
								}
							}
						}
						//We're buying land near their claimed tiles? Grr!
						if (iThemOwned > iUsOwned)
						{
							pNearbyCity->AI_ChangeNumPlotsAcquiredByOtherPlayer(getOwner(), 2);
							break;
						}
						//We're competing? Grr!
						else if (iThemOwned >= iUsOwned)
						{
							pNearbyCity->AI_ChangeNumPlotsAcquiredByOtherPlayer(getOwner(), 1);
							break;
						}
					}
				}
			}
		}

#if defined(MOD_UI_CITY_EXPANSION)
	}
#endif

#if defined(MOD_BALANCE_CORE)
	GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_TILE_PURCHASE, true, NO_GREATPERSON, NO_BUILDING,
		0, true, NO_PLAYER, NULL, false, this, false, true, false, NO_YIELD, NULL, pPlot->getTerrainType());
#endif

	if (GC.getLogging() && GC.getAILogging())
	{
		CvPlayerAI& kOwner = GET_PLAYER(getOwner());
		CvString strBaseString;
		CvString strOutBuf;
		CvString playerName = kOwner.getCivilizationShortDescription();
		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
		strBaseString += playerName + ", ";
		strOutBuf.Format("%s, City Plot Purchased, X: %d, Y: %d", getName().GetCString(), iPlotX, iPlotY);
		strBaseString += strOutBuf;
		kOwner.GetCitySpecializationAI()->LogMsg(strBaseString);
	}

	DoAcquirePlot(iPlotX, iPlotY);

#if defined(MOD_EVENTS_CITY)
	if (MOD_EVENTS_CITY) {
#if defined(MOD_UI_CITY_EXPANSION)
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityBoughtPlot, getOwner(), GetID(), iPlotX, iPlotY, bWithGold, !bWithGold);
#else
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityBoughtPlot, getOwner(), GetID(), iPlotX, iPlotY, true, false);
#endif
	}
	else {
#endif

		ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
		if (pkScriptSystem)
		{
			CvLuaArgsHandle args;
			args->Push(getOwner());
			args->Push(GetID());
			args->Push(iPlotX);
			args->Push(iPlotY);
			args->Push(true); // bGold
			args->Push(false); // bFaith/bCulture

			bool bResult = false;
			LuaSupport::CallHook(pkScriptSystem, "CityBoughtPlot", args.get(), bResult);
		}
#if defined(MOD_EVENTS_CITY)
	}
#endif

	//Achievement test for purchasing 1000 tiles
	if (MOD_API_ACHIEVEMENTS && thisPlayer.isHuman() && !GC.getGame().isGameMultiPlayer())
	{
		gDLL->IncrementSteamStatAndUnlock(ESTEAMSTAT_TILESPURCHASED, 1000, ACHIEVEMENT_PURCHASE_1000TILES);
	}
}

//	--------------------------------------------------------------------------------
/// Acquire the plot and set it's owner to us
void CvCity::DoAcquirePlot(int iPlotX, int iPlotY)
{
	VALIDATE_OBJECT
	CvPlot* pPlot = GC.getMap().plot(iPlotX, iPlotY);
	if (!pPlot)
	{
		return;
	}

	GET_PLAYER(getOwner()).AddAPlot(pPlot);
#if defined(MOD_BALANCE_CORE)
	if (pPlot->getOwner() != getOwner() && pPlot->getOwner() != NO_PLAYER && GET_PLAYER(pPlot->getOwner()).isHuman())
	{
		CvNotifications* pNotifications = GET_PLAYER(pPlot->getOwner()).GetNotifications();
		if (pNotifications)
		{
			CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_UA_STOLE_PLOT", GET_PLAYER(getOwner()).getNameKey());
			CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_UA_STOLE_PLOT", GET_PLAYER(getOwner()).getNameKey());
			pNotifications->Add(NOTIFICATION_GENERIC, strBuffer, strSummary, pPlot->getX(), pPlot->getY(), -1);
		}
	}
#endif
	pPlot->setOwner(getOwner(), GetID(), /*bCheckUnits*/ true, /*bUpdateResources*/ true);
	GC.getMap().updateDeferredFog();

	// If the plot is too far away for us to work, we should let nearby cities who can work it know
	if (plotDistance(getX(), getY(), iPlotX, iPlotY) > getWorkPlotDistance())
	{
		const CvPlayer& kOwner = GET_PLAYER(getOwner());
		int iLoop = 0;
		for (const CvCity* pLoopCity = kOwner.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kOwner.nextCity(&iLoop))
		{
			if (pLoopCity == this)
				continue;

			if (plotDistance(pLoopCity->getX(), pLoopCity->getY(), iPlotX, iPlotY) <= pLoopCity->getWorkPlotDistance())
			{
				pLoopCity->GetCityCitizens()->SetDirty(true);
				pLoopCity->GetCityCitizens()->DoReallocateCitizens();

				if (pLoopCity->GetCityCitizens()->IsWorkingPlot(pPlot))
				{
					break;
				}

				// Undo override in case the governor decided to work the plot but later changed their mind
				pPlot->setOwningCityOverride(NULL);
			}
		}
	}
	else
	{
		GetCityCitizens()->SetDirty(true);
		GetCityCitizens()->DoReallocateCitizens();
	}

	DoUpdateCheapestPlotInfluenceDistance();
}

//	--------------------------------------------------------------------------------
/// Compute how valuable buying a plot is to this city
int CvCity::GetBuyPlotScore(int& iBestX, int& iBestY)
{
	VALIDATE_OBJECT
	int iBestScore = -1;

	vector<CvPlot*> validChoices;
	for (int iI = 0; iI < GetNumWorkablePlots(); iI++)
	{
		CvPlot* pLoopPlot = GetCityCitizens()->GetCityPlotFromIndex(iI);
		if (!pLoopPlot)
			continue;

		// Can we actually buy this plot?
		if (!CanBuyPlot(pLoopPlot->getX(), pLoopPlot->getY(), true))
			continue;

		int iTempScore = GetIndividualPlotScore(pLoopPlot);
		if (iTempScore > iBestScore)
		{
			iBestScore = iTempScore;
			iBestX = pLoopPlot->getX();
			iBestY = pLoopPlot->getY();
		}
	}

	return iBestScore;
}

//	--------------------------------------------------------------------------------
/// Compute value of a plot we might buy
int CvCity::GetIndividualPlotScore(const CvPlot* pPlot) const
{
	VALIDATE_OBJECT

	int iRtnValue = 0;
	YieldTypes eSpecializationYield = NO_YIELD;
	CitySpecializationTypes eSpecialization = GetCityStrategyAI()->GetSpecialization();
	if (eSpecialization != NO_CITY_SPECIALIZATION)
	{
		eSpecializationYield = GC.getCitySpecializationInfo(eSpecialization)->GetYieldType();
	}

	// Does it have a resource?
	ResourceTypes eResource = pPlot->getResourceType(getTeam());
	if (eResource != NO_RESOURCE)
	{
		CvResourceInfo* pkResource = GC.getResourceInfo(eResource);
		if (pkResource)
		{
			if (GET_PLAYER(getOwner()).IsResourceRevealed(eResource))
			{
				ResourceUsageTypes eResourceUsage = GC.getResourceInfo(eResource)->getResourceUsage();
				if (eResourceUsage == RESOURCEUSAGE_STRATEGIC)
				{
					iRtnValue += /*240*/ GD_INT_GET(AI_PLOT_VALUE_STRATEGIC_RESOURCE) * 3;
				}

				// Luxury resource?
				else if (eResourceUsage == RESOURCEUSAGE_LUXURY)
				{
					int iLuxuryValue = /*120*/ GD_INT_GET(AI_PLOT_VALUE_LUXURY_RESOURCE) * 3;

					// Luxury we don't have yet?
					if (GET_PLAYER(getOwner()).getNumResourceTotal(eResource) == 0)
						iLuxuryValue *= 2;

					iRtnValue += iLuxuryValue;
				}
			}
		}
	}

	int iYieldValue = 0;

	CvCityStrategyAI* pCityStrategyAI = GetCityStrategyAI();

	// Valuate the yields from this plot
	for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
	{
		YieldTypes eYield = (YieldTypes)iI;

		int iYield = pPlot->calculateNatureYield(eYield, getOwner(), NULL);

		int iTempValue = 0;

		if (eYield == eSpecializationYield)
			iTempValue += iYield * /*20*/ GD_INT_GET(AI_PLOT_VALUE_SPECIALIZATION_MULTIPLIER);
		else
			iTempValue += iYield * /*10*/ GD_INT_GET(AI_PLOT_VALUE_YIELD_MULTIPLIER);

		// Deficient? If so, give it a boost
		if (pCityStrategyAI->GetMostDeficientYield() == eYield)
			iTempValue *= /*5*/ GD_INT_GET(AI_PLOT_VALUE_DEFICIENT_YIELD_MULTIPLIER);

		TerrainTypes eTerrain = pPlot->getTerrainType();

		int iTraitValue = GET_PLAYER(getOwner()).GetPlayerTraits()->GetYieldChangeFromTilePurchaseTerrainType(eTerrain, eYield);

		if (iTraitValue > 0)
		{
			if (eYield == eSpecializationYield)
			{
				iTempValue += iTraitValue * /*20*/ GD_INT_GET(AI_PLOT_VALUE_SPECIALIZATION_MULTIPLIER) / 10; // Dividing by 10 because this is an instant yield
			}
			else
			{
				iTempValue += iTraitValue * /*10*/ GD_INT_GET(AI_PLOT_VALUE_YIELD_MULTIPLIER) / 10;
			}
		}

		iYieldValue += iTempValue;
	}

	iRtnValue += iYieldValue;

	if (GET_PLAYER(getOwner()).GetBuilderTaskingAI()->WantRouteAtPlot(pPlot))
	{
		iRtnValue += /*80*/ GD_INT_GET(AI_PLOT_VALUE_STRATEGIC_RESOURCE);
	}
	if (pPlot->IsChokePoint())
	{
		iRtnValue += /*80*/ GD_INT_GET(AI_PLOT_VALUE_STRATEGIC_RESOURCE);
	}
	if (pPlot->IsWaterAreaSeparator())
	{
		iRtnValue += /*80*/ GD_INT_GET(AI_PLOT_VALUE_STRATEGIC_RESOURCE);
	}

	// For each player not on our team, check how close their nearest city is to this plot
	CvPlayer& owningPlayer = GET_PLAYER(m_eOwner);
	CvDiplomacyAI* owningPlayerDiploAI = owningPlayer.GetDiplomacyAI();
	bool bAmerica = GET_PLAYER(getOwner()).GetPlayerTraits()->IsBuyOwnedTiles() && iRtnValue > 0;
	for (int iI = 0; iI < MAX_MAJOR_CIVS; iI++)
	{
		CvPlayer& loopPlayer = GET_PLAYER((PlayerTypes)iI);
		if (loopPlayer.isAlive())
		{
			if (loopPlayer.getTeam() != getTeam())
			{
				DisputeLevelTypes eLandDisputeLevel = owningPlayerDiploAI->GetLandDisputeLevel((PlayerTypes)iI);

				if (eLandDisputeLevel != DISPUTE_LEVEL_NONE)
				{
					CvCity* pCity = GC.getMap().findCity(pPlot->getX(), pPlot->getY(), (PlayerTypes)iI, NO_TEAM, true /*bSameArea */);

					if (pCity)
					{
						int iDistance = plotDistance(pPlot->getX(), pPlot->getY(), pCity->getX(), pCity->getY());

						// Only want to account for civs with a city within 10 tiles
						if (iDistance < 10)
						{
							bool bManifestDestiny = bAmerica && pPlot->getOwner() == loopPlayer.GetID();

							switch (eLandDisputeLevel)
							{
							case DISPUTE_LEVEL_FIERCE:
								iRtnValue += (10 - iDistance) * /*6*/ GD_INT_GET(AI_PLOT_VALUE_FIERCE_DISPUTE);

								if (bManifestDestiny)
									iRtnValue *= 8;

								break;
							case DISPUTE_LEVEL_STRONG:
								iRtnValue += (10 - iDistance) * /*4*/ GD_INT_GET(AI_PLOT_VALUE_STRONG_DISPUTE);

								if (bManifestDestiny)
									iRtnValue *= 4;

								break;
							case DISPUTE_LEVEL_WEAK:
								iRtnValue += (10 - iDistance) * /*2*/ GD_INT_GET(AI_PLOT_VALUE_WEAK_DISPUTE);

								if (bManifestDestiny)
									iRtnValue *= 2;

								break;
							case DISPUTE_LEVEL_NONE:
								UNREACHABLE();
							}
						}
					}
				}
			}
		}
	}
	// Modify value based on cost - the higher it is compared to the "base" cost the less the value
	int iCost = GetBuyPlotCost(pPlot->getX(), pPlot->getY());

	iRtnValue *= GET_PLAYER(getOwner()).GetBuyPlotCost();

	//protect against citadels
	CvUnit* pGeneral = pPlot->getFirstUnitOfAITypeOtherTeam(getTeam(), UNITAI_GENERAL);
	if (pGeneral && plotDistance(*plot(), *pPlot) < 4)
	{
		int iBonus = 50 * pPlot->countMatchingAdjacentPlots(NO_DOMAIN, getOwner(), NO_PLAYER, NO_PLAYER);
		iRtnValue += (iRtnValue * iBonus) / 100;
	}

	//try and snatch up natural wonders
	if (pPlot->IsNaturalWonder() && pPlot->IsAdjacentOwnedByTeamOtherThan(getTeam()))
	{
		iRtnValue *= 2;
	}

	// Protect against div by 0.
	CvAssertMsg(iCost != 0, "Plot cost is 0");
	if (iCost != 0)
		iRtnValue /= iCost;
	else
		iRtnValue = 0;

	return iRtnValue;
}

//	--------------------------------------------------------------------------------
/// What is the cheapest plot we can get
int CvCity::GetCheapestPlotInfluenceDistance() const
{
	return m_iCheapestPlotInfluenceDistance;
}

//	--------------------------------------------------------------------------------
/// What is the cheapest plot we can get
void CvCity::SetCheapestPlotInfluenceDistance(int iValue)
{
	if (m_iCheapestPlotInfluenceDistance != iValue)
		m_iCheapestPlotInfluenceDistance = iValue;

	CvAssertMsg(m_iCheapestPlotInfluenceDistance > 0, "Cheapest plot influence should never be 0 or less.");
}

//	--------------------------------------------------------------------------------
/// What is the cheapest plot we can get
void CvCity::DoUpdateCheapestPlotInfluenceDistance()
{
	vector<int> plots;
	GetBuyablePlotList(plots, false);

	if (!plots.empty())
	{
		SetCheapestPlotInfluenceDistance(calculateInfluenceDistance(GC.getMap().plotByIndex(plots.front()), /*5*/ range(GD_INT_GET(MAXIMUM_ACQUIRE_PLOT_DISTANCE), 1, MAX_CITY_RADIUS)));
	}
	else
		SetCheapestPlotInfluenceDistance(INT_MAX);
}

//	--------------------------------------------------------------------------------
/// Setting the danger value threat amount
void CvCity::setThreatValue(int iThreatValue)
{
	VALIDATE_OBJECT
	m_iThreatValue = iThreatValue;
}

//	--------------------------------------------------------------------------------
/// Getting the danger value threat amount
int CvCity::getThreatValue() const
{
	VALIDATE_OBJECT
	return m_iThreatValue;
}

//	--------------------------------------------------------------------------------
void CvCity::clearOrderQueue()
{
	VALIDATE_OBJECT
	while (headOrderQueueNode() != NULL)
	{
		popOrder(0);
	}
}


//	--------------------------------------------------------------------------------
void CvCity::pushOrder(OrderTypes eOrder, int iData1, int iData2, bool bSave, bool bPop, bool bAppend, bool bRush)
{
	VALIDATE_OBJECT
	OrderData order;
	bool bValid = false;

	if (bPop)
	{
		clearOrderQueue();
	}

	switch (eOrder)
	{
	case ORDER_TRAIN:
		if (canTrain((UnitTypes)iData1))
		{
			CvUnitEntry* pkUnitInfo = GC.getUnitInfo((UnitTypes)iData1);
			if (pkUnitInfo)
			{
				if (iData2 == -1)
				{
					iData2 = pkUnitInfo->GetDefaultUnitAIType();
				}

				GET_PLAYER(getOwner()).changeUnitClassMaking(((UnitClassTypes)(pkUnitInfo->GetUnitClassType())), 1);

				bValid = true;
			}
		}
		break;

	case ORDER_CONSTRUCT:
		// If city is a Venice puppet, it's a legal investment and don't move it off the queue
		if (canConstruct((BuildingTypes)iData1) || (IsPuppet() && GET_PLAYER(m_eOwner).GetPlayerTraits()->IsNoAnnexing()))
		{
			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo((BuildingTypes)iData1);
			if (pkBuildingInfo)
			{
				GET_PLAYER(getOwner()).changeBuildingClassMaking(((BuildingClassTypes)(pkBuildingInfo->GetBuildingClassType())), 1);
				bValid = true;
			}
		}
		break;

	case ORDER_CREATE:
		if (canCreate((ProjectTypes)iData1))
		{
			GET_TEAM(getTeam()).changeProjectMaking(((ProjectTypes)iData1), 1);
			GET_PLAYER(getOwner()).changeProjectMaking(((ProjectTypes)iData1), 1, this);

			bValid = true;
		}
		break;

	case ORDER_PREPARE:
		if (canPrepare((SpecialistTypes)iData1))
		{
			bValid = true;
		}
		break;

	case ORDER_MAINTAIN:
		if (canMaintain((ProcessTypes)iData1))
		{
			bValid = true;
		}
		break;

	default:
		CvAssertMsg(false, "iOrder did not match a valid option");
		break;
	}

	if (!bValid)
	{
		return;
	}

	order.eOrderType = eOrder;
	order.iData1 = iData1;
	order.iData2 = iData2;
	order.bSave = bSave;
	order.bRush = bRush;

	if (bAppend)
	{
		m_orderQueue.insertAtEnd(&order);

		if (order.eOrderType != ORDER_MAINTAIN || IsProcessInternationalProject((ProcessTypes)order.iData1))
		{
			// Bubble down non-process orders to in front of all processes at end of queue
			uint32 currOrderIdx = uint32(m_orderQueue.getLength()) - 1;
			while (currOrderIdx > 0
			  && m_orderQueue.getAt(currOrderIdx - 1)->eOrderType == ORDER_MAINTAIN
			  && !IsProcessInternationalProject((ProcessTypes)m_orderQueue.getAt(currOrderIdx - 1)->iData1))
			{
				swapOrder(currOrderIdx - 1);
				currOrderIdx--;
			}
		}
	}
	else
	{
		stopHeadOrder();
		m_orderQueue.insertAtBeginning(&order);
	}

	if (!bAppend || (getOrderQueueLength() == 1))
	{
		startHeadOrder();
	}

	if (eOrder == ORDER_MAINTAIN && (ProcessTypes)iData1 != NO_PROCESS)
	{
		CvProcessInfo* pkProcessInfo = GC.getProcessInfo((ProcessTypes)iData1);
		if (pkProcessInfo && pkProcessInfo->getDefenseValue() != 0)
		{
			updateStrengthValue();
		}
	}

	if ((getTeam() == GC.getGame().getActiveTeam()) || GC.getGame().isDebugMode())
	{
		if (isCitySelected())
		{
			DLLUI->setDirty(SelectionButtons_DIRTY_BIT, true);
			DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
			DLLUI->setDirty(PlotListButtons_DIRTY_BIT, true);
		}
	}

	DLLUI->setDirty(CityInfo_DIRTY_BIT, true);

	CvInterfacePtr<ICvCity1> pCity = GC.WrapCityPointer(this);
	DLLUI->SetSpecificCityInfoDirty(pCity.get(), CITY_UPDATE_TYPE_PRODUCTION);
}


//	--------------------------------------------------------------------------------
void CvCity::popOrder(int iNum, bool bFinish, bool bChoose)
{
	VALIDATE_OBJECT

	CvPlayerAI& kOwner = GET_PLAYER(getOwner());	//Used often later on

	OrderData* pOrderNode = NULL;
	SpecialistTypes eSpecialist;
	ProjectTypes eCreateProject;
	BuildingTypes eConstructBuilding;
	UnitTypes eTrainUnit;
	UnitAITypes eTrainAIUnit;
	bool bStart = false;
	bool bMessage = false;
	int iCount = 0;

	if (iNum == -1)
	{
		iNum = (getOrderQueueLength() - 1);
	}

	iCount = 0;

	pOrderNode = headOrderQueueNode();

	while (pOrderNode != NULL)
	{
		if (iCount == iNum)
		{
			break;
		}

		iCount++;

		pOrderNode = nextOrderQueueNode(pOrderNode);
	}

	if (pOrderNode == NULL)
	{
		return;
	}

	if (bFinish && pOrderNode->bSave)
	{
		pushOrder(pOrderNode->eOrderType, pOrderNode->iData1, pOrderNode->iData2, true, false, true);
	}
#if defined(MOD_BALANCE_CORE)
	bool bUpdateStrength = false;
#endif

	eTrainUnit = NO_UNIT;
	eConstructBuilding = NO_BUILDING;
	eCreateProject = NO_PROJECT;
	eSpecialist = NO_SPECIALIST;

	switch (pOrderNode->eOrderType)
	{
	case ORDER_TRAIN:
		eTrainUnit = ((UnitTypes)(pOrderNode->iData1));
		eTrainAIUnit = ((UnitAITypes)(pOrderNode->iData2));
		CvAssertMsg(eTrainUnit != NO_UNIT, "eTrainUnit is expected to be assigned a valid unit type");
		CvAssertMsg(eTrainAIUnit != NO_UNITAI, "eTrainAIUnit is expected to be assigned a valid unit AI type");

		kOwner.changeUnitClassMaking(((UnitClassTypes)(GC.getUnitInfo(eTrainUnit)->GetUnitClassType())), -1);

		if (bFinish)
		{
			produce(eTrainUnit);
		}
		break;

	case ORDER_CONSTRUCT:
	{
		eConstructBuilding = ((BuildingTypes)(pOrderNode->iData1));

		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eConstructBuilding);

		if (pkBuildingInfo)
		{
			kOwner.changeBuildingClassMaking(((BuildingClassTypes)(pkBuildingInfo->GetBuildingClassType())), -1);

			if (bFinish)
			{
				produce(eConstructBuilding);
			}
		}
		break;
	}

	case ORDER_CREATE:
		eCreateProject = ((ProjectTypes)(pOrderNode->iData1));

		GET_TEAM(getTeam()).changeProjectMaking(eCreateProject, -1);
		kOwner.changeProjectMaking(eCreateProject, -1);

		if (bFinish)
		{
			produce(eCreateProject);
		}
		break;

	case ORDER_PREPARE:

		if (bFinish)
		{
			eSpecialist = (SpecialistTypes)(pOrderNode->iData1);
			produce(eSpecialist);
		}

		break;

	case ORDER_MAINTAIN:
#if defined(MOD_BALANCE_CORE)
		if ((ProcessTypes)pOrderNode->iData1 != NO_PROCESS)
		{
			CvProcessInfo* pkProcessInfo = GC.getProcessInfo((ProcessTypes)pOrderNode->iData1);
			if (pkProcessInfo && pkProcessInfo->getDefenseValue() != 0)
			{
				bUpdateStrength = true;
			}
		}
#endif
		break;

	default:
		CvAssertMsg(false, "pOrderNode->eOrderType is not a valid option");
		break;
	}

	if (m_unitBeingBuiltForOperation.IsValid())
	{
		kOwner.CityUncommitToBuildUnitForOperationSlot(m_unitBeingBuiltForOperation);
		m_unitBeingBuiltForOperation.Invalidate();
	}

	if (pOrderNode == headOrderQueueNode())
	{
		bStart = true;
		stopHeadOrder();
	}
	else
	{
		bStart = false;
	}

	m_orderQueue.deleteNode(pOrderNode);
	pOrderNode = NULL;
	if (bFinish)
	{
		CleanUpQueue(); // cleans out items from the queue that may be invalidated by the recent construction
	}

	if (bStart)
	{
		startHeadOrder();
	}

	if ((getTeam() == GC.getGame().getActiveTeam()) || GC.getGame().isDebugMode())
	{
		if (isCitySelected())
		{
			DLLUI->setDirty(SelectionButtons_DIRTY_BIT, true);
			DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
		}
	}

	bMessage = false;

	if (bChoose)
	{
		if (getOrderQueueLength() == 0)
		{
			if (!isHuman() || isProductionAutomated())
			{
				AI_chooseProduction(false /*bInterruptWonders*/, false);
			}
			else
			{
				chooseProduction(eTrainUnit, eConstructBuilding, eCreateProject, bFinish);

				bMessage = true;
			}
		}
	}

	if (bFinish && !bMessage)
	{
		if (getOwner() == GC.getGame().getActivePlayer())
		{
			Localization::String localizedText;
			if (eTrainUnit != NO_UNIT)
			{
				CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eTrainUnit);
				if (pkUnitInfo)
				{
					localizedText = Localization::Lookup(((isLimitedUnitClass((UnitClassTypes)(pkUnitInfo->GetUnitClassType()))) ? "TXT_KEY_MISC_TRAINED_UNIT_IN_LIMITED" : "TXT_KEY_MISC_TRAINED_UNIT_IN"));
					localizedText << pkUnitInfo->GetTextKey() << getNameKey();
				}
			}
			else if (eConstructBuilding != NO_BUILDING)
			{
				CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eConstructBuilding);
				if (pkBuildingInfo)
				{
					localizedText = Localization::Lookup(((isLimitedWonderClass(pkBuildingInfo->GetBuildingClassInfo())) ? "TXT_KEY_MISC_CONSTRUCTED_BUILD_IN_LIMITED" : "TXT_KEY_MISC_CONSTRUCTED_BUILD_IN"));
					localizedText << pkBuildingInfo->GetTextKey() << getNameKey();
				}
			}
			else if (eCreateProject != NO_PROJECT)
			{
				localizedText = Localization::Lookup(((isLimitedProject(eCreateProject)) ? "TXT_KEY_MISC_CREATED_PROJECT_IN_LIMITED" : "TXT_KEY_MISC_CREATED_PROJECT_IN"));
				localizedText << GC.getProjectInfo(eCreateProject)->GetTextKey() << getNameKey();
			}
			if (isProduction())
			{
				localizedText = Localization::Lookup(((isProductionLimited()) ? "TXT_KEY_MISC_WORK_HAS_BEGUN_IN_CITY_LIMITED" : "TXT_KEY_MISC_WORK_HAS_BEGUN_IN_CITY"));
				localizedText << getProductionNameKey() << getNameKey();
			}
			DLLUI->AddCityMessage(0, GetIDInfo(), getOwner(), false, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), localizedText.toUTF8()/*, szSound, MESSAGE_TYPE_MINOR_EVENT, szIcon, (ColorTypes)GC.getInfoTypeForString("COLOR_WHITE"), getX(), getY(), true, true*/);
		}
	}
#if defined(MOD_BALANCE_CORE)
	if (bUpdateStrength)
	{
		updateStrengthValue();
	}
#endif

	if ((getTeam() == GC.getGame().getActiveTeam()) || GC.getGame().isDebugMode())
	{
		if (isCitySelected())
		{
			DLLUI->setDirty(SelectionButtons_DIRTY_BIT, true);
			DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
			DLLUI->setDirty(PlotListButtons_DIRTY_BIT, true);
		}
		DLLUI->setDirty(CityInfo_DIRTY_BIT, true);
	}
}

//	--------------------------------------------------------------------------------
void CvCity::swapOrder(int iNum)
{
	// okay, this only swaps the order with the next one up in the queue
	VALIDATE_OBJECT

	if (iNum == 0)
	{
		stopHeadOrder();
	}

	m_orderQueue.swapUp(iNum);

	if (iNum == 0)
	{
		startHeadOrder();
	}

	if ((getTeam() == GC.getGame().getActiveTeam()) || GC.getGame().isDebugMode())
	{
		if (isCitySelected())
		{
			//DLLUI->setDirty(InfoPane_DIRTY_BIT, true );
			DLLUI->setDirty(SelectionButtons_DIRTY_BIT, true);
			DLLUI->setDirty(CityScreen_DIRTY_BIT, true);
			DLLUI->setDirty(PlotListButtons_DIRTY_BIT, true);
		}
		DLLUI->setDirty(CityInfo_DIRTY_BIT, true);
	}
}

bool CvCity::hasOrder(OrderTypes eOrder, int iData1, int iData2) const
{
	for (int iI = 0; iI < getOrderQueueLength(); iI++)
	{
		const OrderData* pOrder = getOrderFromQueue(iI);
		if (pOrder != NULL)
		{
			if (pOrder->eOrderType == eOrder && pOrder->iData1 == iData1 && pOrder->iData2 == iData2)
			{
				return true;
			}
		}
	}

	return false;
}


//	--------------------------------------------------------------------------------
void CvCity::startHeadOrder()
{
	VALIDATE_OBJECT
	OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		GetCityCitizens()->OptimizeWorkedPlots(false);

		if (pOrderNode->eOrderType == ORDER_MAINTAIN)
		{
			processProcess(((ProcessTypes)(pOrderNode->iData1)), 1);
		}
	}
}


//	--------------------------------------------------------------------------------
void CvCity::stopHeadOrder()
{
	VALIDATE_OBJECT
	OrderData* pOrderNode = headOrderQueueNode();

	if (pOrderNode != NULL)
	{
		if (pOrderNode->eOrderType == ORDER_MAINTAIN)
		{
			processProcess(((ProcessTypes)(pOrderNode->iData1)), -1);
		}
	}
}


//	--------------------------------------------------------------------------------
int CvCity::getOrderQueueLength() const
{
	VALIDATE_OBJECT
	return m_orderQueue.getLength();
}


const OrderData* CvCity::getOrderFromQueue(int iIndex) const
{
	return m_orderQueue.getAt(iIndex);
}

//	--------------------------------------------------------------------------------
OrderData* CvCity::getOrderFromQueue(int iIndex)
{
	VALIDATE_OBJECT
	return m_orderQueue.getAt(iIndex);
}


//	--------------------------------------------------------------------------------
OrderData* CvCity::nextOrderQueueNode(OrderData* pNode)
{
	VALIDATE_OBJECT
	return m_orderQueue.next(pNode);
}

//	--------------------------------------------------------------------------------
const OrderData* CvCity::nextOrderQueueNode(const OrderData* pNode) const
{
	VALIDATE_OBJECT
	return m_orderQueue.next(pNode);
}


//	--------------------------------------------------------------------------------
const OrderData* CvCity::headOrderQueueNode() const
{
	VALIDATE_OBJECT
	return m_orderQueue.head();
}

//	--------------------------------------------------------------------------------
OrderData* CvCity::headOrderQueueNode()
{
	VALIDATE_OBJECT
	return m_orderQueue.head();
}


//	--------------------------------------------------------------------------------
const OrderData* CvCity::tailOrderQueueNode() const
{
	VALIDATE_OBJECT
	return m_orderQueue.tail();
}

//	--------------------------------------------------------------------------------
/// remove items in the queue that are no longer valid
bool CvCity::CleanUpQueue(void)
{
	VALIDATE_OBJECT
	bool bOK = true;

	for (int iI = (getOrderQueueLength() - 1); iI >= 0; iI--)
	{
		OrderData* pOrder = getOrderFromQueue(iI);

		if (pOrder != NULL)
		{
			if (!canContinueProduction(*pOrder))
			{
				popOrder(iI, false, true);
				bOK = false;
			}
		}
	}

	return bOK;
}

//	--------------------------------------------------------------------------------
/// Create unit by completing production in city, separated out from popOrder() so other functions can call this
void CvCity::produce(UnitTypes eTrainUnit, UnitAITypes eTrainAIUnit, bool bCanOverflow)
{
	m_iThingsProduced++;

	CvPlayerAI& kOwner = GET_PLAYER(getOwner());

	CvUnit* pUnit = CreateUnit(eTrainUnit, eTrainAIUnit, REASON_TRAIN);
	if (pUnit)
	{
#if defined(MOD_BALANCE_CORE)
		if (pUnit->isFreeUpgrade() || GET_PLAYER(getOwner()).GetPlayerTraits()->IsFreeUpgrade())
		{
			UnitTypes eUpgradeUnit = pUnit->GetUpgradeUnitType();
			if (eUpgradeUnit != NO_UNIT && this->canTrain(eUpgradeUnit, false, false, true))
			{
				pUnit = pUnit->DoUpgrade(true);
			}
		}
		SetUnitInvestment(pUnit->getUnitClassType(), false);
		if (GET_PLAYER(getOwner()).GetPlayerTraits()->IsConquestOfTheWorld())
		{
			if (pUnit->isFound() || pUnit->IsFoundMid())
			{
				UnitTypes eBestLandUnit = NO_UNIT;
				int iStrengthBestLandCombat = 0;
				for (int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
				{
					const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);
					CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);
					if (pkUnitClassInfo)
					{
						const UnitTypes eUnit = (UnitTypes)getCivilizationInfo().getCivilizationUnits(eUnitClass);
						CvUnitEntry* pUnitEntry = GC.getUnitInfo(eUnit);
						if (pUnitEntry)
						{
							if (!canTrain(eUnit))
							{
								continue;
							}
							if (pUnitEntry->GetRangedCombat() > 0)
							{
								continue;
							}
							if (pUnitEntry->GetDomainType() == DOMAIN_LAND)
							{
								bool bBad = false;
								ResourceTypes eResource;
								for (int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
								{
									eResource = (ResourceTypes)iResourceLoop;
									int iNumResource = pUnitEntry->GetResourceQuantityRequirement(eResource);
									if (iNumResource > 0)
									{
										if (GET_PLAYER(getOwner()).getNumResourceAvailable(eResource, true) < iNumResource)
										{
											bBad = true;
											break;
										}
									}
#if defined(MOD_UNITS_RESOURCE_QUANTITY_TOTALS)
									if (MOD_UNITS_RESOURCE_QUANTITY_TOTALS)
									{
										iNumResource = pUnitEntry->GetResourceQuantityTotal(eResource);
										if (iNumResource > 0)
										{
											if (GET_PLAYER(getOwner()).getNumResourceTotal(eResource, true) < iNumResource || GET_PLAYER(getOwner()).getNumResourceAvailable(eResource, true) < 0)
											{
												bBad = true;
												break;
											}
										}
									}
#endif
								}
								if (bBad)
								{
									continue;
								}
								int iCombatLandStrength = (std::max(1, pUnitEntry->GetCombat()));
								if (iCombatLandStrength > iStrengthBestLandCombat)
								{
									iStrengthBestLandCombat = iCombatLandStrength;
									eBestLandUnit = eUnit;
								}
							}
						}
					}
				}
				if (eBestLandUnit != NO_UNIT)
				{
					CvUnitEntry* pkbUnitEntry = GC.getUnitInfo(eBestLandUnit);
					if (pkbUnitEntry)
					{
						UnitAITypes eUnitAI = pkbUnitEntry->GetDefaultUnitAIType();
						CvUnit* pUnit2 = CreateUnit(eBestLandUnit, eUnitAI, REASON_TRAIN);
						if (pUnit2)
						{
							if (!pUnit2->jumpToNearestValidPlot())
							{
								pUnit2->kill(false);	// Could not find a valid spot!
							}
							CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
							if (pNotifications)
							{
								Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CONQUEST_OF_WORLD_UNIT");
								strText << pUnit2->getNameKey() << getNameKey();
								Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CONQUEST_OF_WORLD_UNIT");
								strSummary << getNameKey();
								pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pUnit2->getX(), pUnit2->getY(), -1);
							}
						}
					}
				}
				else
				{
					UnitTypes eWarrior = (UnitTypes)GC.getInfoTypeForString("UNIT_WARRIOR");
					CvUnitEntry* pkbUnitEntry = GC.getUnitInfo(eWarrior);
					if (pkbUnitEntry)
					{
						UnitAITypes eUnitAI = pkbUnitEntry->GetDefaultUnitAIType();
						CvUnit* pUnit2 = CreateUnit(eWarrior, eUnitAI, REASON_TRAIN);
						if (pUnit2)
						{
							if (!pUnit2->jumpToNearestValidPlot())
							{
								pUnit2->kill(false);	// Could not find a valid spot!
							}
							CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
							if (pNotifications)
							{
								Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CONQUEST_OF_WORLD_UNIT");
								strText << pUnit2->getNameKey() << getNameKey();
								Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CONQUEST_OF_WORLD_UNIT");
								strSummary << getNameKey();
								pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), pUnit2->getX(), pUnit2->getY(), -1);
							}
						}
					}
				}
			}
		}

		//whoever invented this should be crucified
		if (kOwner.GetPlayerTraits()->IsFreeZuluPikemanToImpi())
		{
			UnitClassTypes ePikemanClass = (UnitClassTypes)GC.getInfoTypeForString("UNITCLASS_PIKEMAN");
			UnitTypes eZuluImpi = (UnitTypes)GC.getInfoTypeForString("UNIT_ZULU_IMPI");
			if (pUnit != NULL && pUnit->getUnitClassType() == ePikemanClass && this->canTrain(eZuluImpi, false, false, true))
			{
				CvUnitEntry* pkcUnitEntry = GC.getUnitInfo(eZuluImpi);
				if (pkcUnitEntry)
				{
					UnitAITypes eZuluImpiAI = pkcUnitEntry->GetDefaultUnitAIType();
					CvUnit* pZuluImpi = kOwner.initUnit(eZuluImpi, pUnit->getX(), pUnit->getY(), eZuluImpiAI);
					pZuluImpi->convert(pUnit, true);
					pUnit = pZuluImpi;
				}
			}
		}
#endif
#if defined(MOD_EVENTS_CITY)
		if (MOD_EVENTS_CITY)
		{
			GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityTrained, getOwner(), GetID(), pUnit->GetID(), false, false);
		}
		else
		{
#endif
			ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
			if (pkScriptSystem)
			{
				CvLuaArgsHandle args;
				args->Push(getOwner());
				args->Push(GetID());
				args->Push(pUnit->GetID());
				args->Push(false); // bGold
				args->Push(false); // bFaith/bCulture

				bool bResult = false;
				LuaSupport::CallHook(pkScriptSystem, "CityTrained", args.get(), bResult);
			}
#if defined(MOD_EVENTS_CITY)
		}
#endif

		int iProductionNeeded = getProductionNeeded(eTrainUnit) * 100;
#if defined(MOD_BALANCE_CORE)
		if (!pUnit->IsCivilianUnit())
		{
			GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_U_PROD, true, NO_GREATPERSON, NO_BUILDING, (iProductionNeeded / 100), false, NO_PLAYER, NULL, false, this);
		}
#endif
		if (bCanOverflow)
		{
			// max overflow is the value of the item produced (to eliminate prebuild exploits)
			int iOverflow = getUnitProductionTimes100(eTrainUnit) - iProductionNeeded;
			int iMaxOverflow = std::max(iProductionNeeded, getCurrentProductionDifferenceTimes100(false, false));
			int iLostProduction = std::max(0, iOverflow - iMaxOverflow);
			iOverflow = std::min(iMaxOverflow, iOverflow);

			if (iOverflow > 0)
			{
				changeOverflowProductionTimes100(iOverflow);
			}
			setUnitProduction(eTrainUnit, 0);

			int iProductionGold = ((iLostProduction * /*100*/ GD_INT_GET(MAXED_UNIT_GOLD_PERCENT)) / 100);
			if (iProductionGold > 0)
			{
				kOwner.GetTreasury()->ChangeGoldTimes100(iProductionGold);
			}
		}
		else
		{
			changeUnitProductionTimes100(eTrainUnit, -iProductionNeeded);
		}
	}
	else
	{
		// create notification
		setUnitProduction(eTrainUnit, getProductionNeeded(eTrainUnit) - 1);

		CvNotifications* pNotifications = kOwner.GetNotifications();
		if (pNotifications)
		{
			Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_REMOVED_UNIT");
			strText << getNameKey();
			strText << GC.getUnitInfo(eTrainUnit)->GetDescription();
			Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_REMOVED_UNIT");
			pNotifications->Add(NOTIFICATION_GENERIC, strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), -1);
		}
	}

	//immediately check if the AI should start a found city operation so we can queue up the escort for production
	if (!GET_PLAYER(m_eOwner).isHuman() && pUnit->isFound())
		EconomicAIHelpers::IsTestStrategy_FoundCity(NO_ECONOMICAISTRATEGY,&GET_PLAYER(m_eOwner));
}

//	--------------------------------------------------------------------------------
/// Create building by completing production in city, separated out from popOrder() so other functions can call this
void CvCity::produce(BuildingTypes eConstructBuilding, bool bCanOverflow)
{
	m_iThingsProduced++;

	CvPlayerAI& kOwner = GET_PLAYER(getOwner());

	int iProductionNeeded = getProductionNeeded(eConstructBuilding) * 100;
	bool bResult = CreateBuilding(eConstructBuilding);
	DEBUG_VARIABLE(bResult);
	CvAssertMsg(bResult, "CreateBuilding failed");

#if defined(MOD_EVENTS_CITY)
	if (MOD_EVENTS_CITY) {
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityConstructed, getOwner(), GetID(), eConstructBuilding, false, false);
	}
	else {
#endif
		ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
		if (pkScriptSystem)
		{
			CvLuaArgsHandle args;
			args->Push(getOwner());
			args->Push(GetID());
			args->Push(eConstructBuilding);
			args->Push(false); // bGold
			args->Push(false); // bFaith/bCulture

			bool bScriptResult = false;
			LuaSupport::CallHook(pkScriptSystem, "CityConstructed", args.get(), bScriptResult);
		}
#if defined(MOD_EVENTS_CITY)
	}
#endif		
	if (bCanOverflow)
	{
		// max overflow is the value of the item produced (to eliminate prebuild exploits)
		int iOverflow = m_pCityBuildings->GetBuildingProductionTimes100(eConstructBuilding) - iProductionNeeded;
		int iMaxOverflow = std::max(iProductionNeeded, getCurrentProductionDifferenceTimes100(false, false));
		int iLostProduction = std::max(0, iOverflow - iMaxOverflow);
		iOverflow = std::min(iMaxOverflow, iOverflow);
		if (iOverflow > 0)
		{
			changeOverflowProductionTimes100(iOverflow);
		}
		m_pCityBuildings->SetBuildingProduction(eConstructBuilding, 0);

		int iProductionGold = ((iLostProduction * /*100*/ GD_INT_GET(MAXED_BUILDING_GOLD_PERCENT)) / 100);
		if (iProductionGold > 0)
		{
			kOwner.GetTreasury()->ChangeGoldTimes100(iProductionGold);
		}
	}
	else
	{
		m_pCityBuildings->ChangeBuildingProduction(eConstructBuilding, -iProductionNeeded);
	}

	if (GC.getLogging() && GC.getAILogging())
	{
		CvBuildingEntry* pkConstructBuildingInfo = GC.getBuildingInfo(eConstructBuilding);
		if (pkConstructBuildingInfo)
		{
			if (kOwner.GetWonderProductionAI()->IsWonder(*pkConstructBuildingInfo))
			{
				CvString strBaseString;
				CvString strOutBuf;
				CvString playerName = kOwner.getCivilizationShortDescription();
				strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());
				strBaseString += playerName + ", ";
				strOutBuf.Format("%s, WONDER - Finished %s", getName().GetCString(), pkConstructBuildingInfo->GetDescription());
				strBaseString += strOutBuf;
				kOwner.GetCitySpecializationAI()->LogMsg(strBaseString);
			}
		}

	}
}

//	--------------------------------------------------------------------------------
/// Create project by completing production in city, separated out from popOrder() so other functions can call this
void CvCity::produce(ProjectTypes eCreateProject, bool bCanOverflow)
{
	m_iThingsProduced++;

	CvPlayerAI& kOwner = GET_PLAYER(getOwner());

	bool bResult = CreateProject(eCreateProject);
	DEBUG_VARIABLE(bResult);
	CvAssertMsg(bResult, "Failed to create project");

#if defined(MOD_EVENTS_CITY)
	if (MOD_EVENTS_CITY) {
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityCreated, getOwner(), GetID(), eCreateProject, false, false);
	}
	else {
#endif
		ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
		if (pkScriptSystem)
		{
			CvLuaArgsHandle args;
			args->Push(getOwner());
			args->Push(GetID());
			args->Push(eCreateProject);
			args->Push(false); // bGold
			args->Push(false); // bFaith/bCulture

			bool bScriptResult = false;
			LuaSupport::CallHook(pkScriptSystem, "CityCreated", args.get(), bScriptResult);
		}
#if defined(MOD_EVENTS_CITY)
	}
#endif

	int iProductionNeeded = getProductionNeeded(eCreateProject) * 100;
	if (bCanOverflow)
	{
		// max overflow is the value of the item produced (to eliminate prebuild exploits)
		int iOverflow = getProjectProductionTimes100(eCreateProject) - iProductionNeeded;
		int iMaxOverflow = std::max(iProductionNeeded, getCurrentProductionDifferenceTimes100(false, false));
		int iLostProduction = std::max(0, iOverflow - iMaxOverflow);
		iOverflow = std::min(iMaxOverflow, iOverflow);

		if (iOverflow > 0)
		{
			changeOverflowProductionTimes100(iOverflow);
		}
		setProjectProduction(eCreateProject, 0);

		int iProductionGold = ((iLostProduction * /*300*/ GD_INT_GET(MAXED_PROJECT_GOLD_PERCENT)) / 100);
		if (iProductionGold > 0)
		{
			kOwner.GetTreasury()->ChangeGoldTimes100(iProductionGold);
		}
	}
	else
	{
		changeProjectProductionTimes100(eCreateProject, -iProductionNeeded);
	}
}

//	--------------------------------------------------------------------------------
/// Create specialist by completing production in city, separated out from popOrder() so other functions can call this
void CvCity::produce(SpecialistTypes eSpecialist, bool bCanOverflow)
{
	m_iThingsProduced++;

	int iProductionNeeded = getProductionNeeded(eSpecialist) * 100;

	if (bCanOverflow)
	{
		// max overflow is the value of the item produced (to eliminate prebuild exploits)
		int iOverflow = getSpecialistProductionTimes100(eSpecialist) - iProductionNeeded;
		int iMaxOverflow = std::max(iProductionNeeded, getCurrentProductionDifferenceTimes100(false, false));
		iOverflow = std::min(iMaxOverflow, iOverflow);
		if (iOverflow > 0)
		{
			changeOverflowProductionTimes100(iOverflow);
		}

		setSpecialistProduction(eSpecialist, 0);
	}
	else
	{
		changeSpecialistProductionTimes100(eSpecialist, -iProductionNeeded);
	}
}

//	--------------------------------------------------------------------------------
CvUnit* CvCity::CreateUnit(UnitTypes eUnitType, UnitAITypes eAIType, UnitCreationReason eReason, bool bUseToSatisfyOperation, bool bIsPurchase)
{
	VALIDATE_OBJECT
	CvPlot* pUnitPlot = GetPlotForNewUnit(eUnitType);
	//if there's no free plot around, then stack it in the city
	if (!pUnitPlot)
		pUnitPlot = plot();

	CvPlayer& thisPlayer = GET_PLAYER(getOwner());
	CvUnit* pUnit = thisPlayer.initUnit(eUnitType, pUnitPlot->getX(), pUnitPlot->getY(), eAIType, eReason);
	if (!pUnit)
		return NULL;

	if (MOD_BALANCE_CORE_UNIT_CREATION_DAMAGED && !pUnit->IsCivilianUnit())
	{
		int iCityDamagePercent = min(80, (100 * getDamage()) / max(1,GetMaxHitPoints()));
		int iUnitDamage = (pUnit->GetCurrHitPoints() * iCityDamagePercent) / 100;
		pUnit->changeDamage( min(iUnitDamage,pUnit->GetMaxHitPoints()-1) );
	}

	addProductionExperience(pUnit, false, bIsPurchase);

	if ((eReason != REASON_BUY && eReason != REASON_FAITH_BUY) || pUnit->getUnitInfo().CanMoveAfterPurchase())
		pUnit->restoreFullMoves();
	else
		pUnit->finishMoves();

	if (pUnit->isTrade())
	{
		if (GC.getLogging() && GC.getAILogging())
		{
			CvString strCiv = GET_PLAYER(getOwner()).getCivilizationAdjective();
			CvString strLogString;
			strLogString.Format("TRADE UNIT MADE: %s %s at %d,d", strCiv.c_str(), pUnit->getName().c_str(), pUnit->getX(), pUnit->getY());
			GET_PLAYER(getOwner()).GetHomelandAI()->LogHomelandMessage(strLogString);
		}
	}
	if (MOD_BALANCE_CORE_SETTLERS_CONSUME_POP)
	{
		if (pUnit->getUnitInfo().IsFoodProduction() && getPopulation() > 1)
			changePopulation(-1);
	}

	CvPlot* pRallyPlot = getRallyPlot();
	if (pRallyPlot != NULL)
	{
		pUnit->PushMission(CvTypes::getMISSION_MOVE_TO(), pRallyPlot->getX(), pRallyPlot->getY());
	}

	if (bUseToSatisfyOperation)
	{
		if (m_unitBeingBuiltForOperation.IsValid())
		{
			thisPlayer.CityFinishedBuildingUnitForOperationSlot(m_unitBeingBuiltForOperation, pUnit);
			m_unitBeingBuiltForOperation.Invalidate();
		}
		else
		{
			vector<pair<size_t, size_t>> freeSlotsPerOp;
			// Check existing armies this unit could fit into if it wasn't automatically added to one.
			for (size_t i = 0; i < GET_PLAYER(m_eOwner).getNumAIOperations(); i++)
			{
				CvAIOperation* pOp = GET_PLAYER(m_eOwner).getAIOperationByIndex(i);
				if (pOp->GetOperationState() == AI_OPERATION_STATE_RECRUITING_UNITS)
				{
					//only look at the first army ...
					CvArmyAI* pFirstArmy = pOp->GetArmy(0);
					if (pFirstArmy)
						freeSlotsPerOp.push_back(make_pair(pFirstArmy->GetOpenSlots(true).size(),i));
				}
			}
			//try the army which is closest to completion first!
			if (!freeSlotsPerOp.empty())
			{ 
				//default sort order is ascending by first pair member 
				std::stable_sort(freeSlotsPerOp.begin(), freeSlotsPerOp.end());
				for (size_t i=0; i<freeSlotsPerOp.size(); i++)
					if (GET_PLAYER(m_eOwner).getAIOperationByIndex( freeSlotsPerOp[i].second )->RecruitUnit(pUnit))
						break;
			}
		}
	}

	// Any AI unit with explore AI as a secondary unit AI (e.g. warriors) are assigned that unit AI if this AI player needs to explore more
	else if (!pUnit->isHuman() && EconomicAIHelpers::CannotMinorCiv(&thisPlayer, (EconomicAIStrategyTypes)GC.getInfoTypeForString("ECONOMICAISTRATEGY_NEED_RECON")))
	{
		EconomicAIStrategyTypes eStrategy = (EconomicAIStrategyTypes)GC.getInfoTypeForString("ECONOMICAISTRATEGY_NEED_RECON");
		if (thisPlayer.GetEconomicAI()->IsUsingStrategy(eStrategy))
		{
			if (pUnit->getUnitInfo().GetUnitAIType(UNITAI_EXPLORE) && pUnit->AI_getUnitAIType() != UNITAI_EXPLORE)
			{
				// Now make sure there isn't a critical military threat
				if (thisPlayer.GetMilitaryAI()->ShouldFightBarbarians())
				{
					if (GC.getLogging() && GC.getAILogging())
					{
						CvString strLogString;
						strLogString.Format("Not assigning explore AI to %s due to threats, X: %d, Y: %d", pUnit->getName().GetCString(), pUnit->getX(), pUnit->getY());
						thisPlayer.GetHomelandAI()->LogHomelandMessage(strLogString);
					}
				}
				else
				{
					pUnit->AI_setUnitAIType(UNITAI_EXPLORE);
					if (GC.getLogging() && GC.getAILogging())
					{
						CvString strLogString;
						strLogString.Format("Assigning explore unit AI to %s, X: %d, Y: %d", pUnit->getName().GetCString(), pUnit->getX(), pUnit->getY());
						thisPlayer.GetHomelandAI()->LogHomelandMessage(strLogString);
					}
				}
			}
		}
		eStrategy = (EconomicAIStrategyTypes)GC.getInfoTypeForString("ECONOMICAISTRATEGY_NEED_RECON_SEA");
		EconomicAIStrategyTypes eOtherStrategy = (EconomicAIStrategyTypes)GC.getInfoTypeForString("ECONOMICAISTRATEGY_REALLY_NEED_RECON_SEA");
		if (thisPlayer.GetEconomicAI()->IsUsingStrategy(eStrategy) || thisPlayer.GetEconomicAI()->IsUsingStrategy(eOtherStrategy))
		{
			if (pUnit->getUnitInfo().GetUnitAIType(UNITAI_EXPLORE_SEA))
			{
				pUnit->AI_setUnitAIType(UNITAI_EXPLORE_SEA);
				if (GC.getLogging() && GC.getAILogging())
				{
					CvString strLogString;
					strLogString.Format("Assigning explore sea unit AI to %s, X: %d, Y: %d", pUnit->getName().GetCString(), pUnit->getX(), pUnit->getY());
					thisPlayer.GetHomelandAI()->LogHomelandMessage(strLogString);
				}
			}
		}
	}
	//Increment for stat tracking and achievements
	if (pUnit->isHuman())
	{
		IncrementUnitStatCount(pUnit);
	}

	if (eReason == REASON_TRAIN || eReason == REASON_BUY || eReason == REASON_FAITH_BUY)
		thisPlayer.changeUnitsBuiltCount(eUnitType, 1);

	return pUnit;
}

//	--------------------------------------------------------------------------------
bool CvCity::CreateBuilding(BuildingTypes eBuildingType)
{
	VALIDATE_OBJECT

	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuildingType);
	if (pkBuildingInfo == NULL)
		return false;

	const BuildingClassTypes eBuildingClass = pkBuildingInfo->GetBuildingClassType();

	CvPlayerAI& kPlayer = GET_PLAYER(getOwner());

	if (kPlayer.isBuildingClassMaxedOut(eBuildingClass, 0))
	{
		kPlayer.removeBuildingClass(eBuildingClass);
	}

	m_pCityBuildings->SetNumRealBuilding(eBuildingType, m_pCityBuildings->GetNumRealBuilding(eBuildingType) + 1);

	//Achievements
	if (MOD_API_ACHIEVEMENTS && kPlayer.isHuman() && !GC.getGame().isGameMultiPlayer())
	{
		CvBuildingClassInfo* pBuildingClass = GC.getBuildingClassInfo(eBuildingClass);
		if (pBuildingClass && ::isWorldWonderClass(*pBuildingClass))
		{
			int iCount = 0;
			CvGameTrade* pGameTrade = GC.getGame().GetGameTrade();
			for (uint ui = 0; ui < pGameTrade->GetNumTradeConnections(); ui++)
			{
				if (pGameTrade->IsTradeRouteIndexEmpty(ui))
				{
					continue;
				}

				if (pGameTrade->GetTradeConnection(ui).m_eConnectionType == TRADE_CONNECTION_PRODUCTION)
				{
					CvCity* pDestCity = CvGameTrade::GetDestCity(pGameTrade->GetTradeConnection(ui));
					if (pDestCity->getX() == getX() && pDestCity->getY() == getY())
					{
						iCount++;
					}
				}
			}

			if (iCount >= 3)
			{
				gDLL->UnlockAchievement(ACHIEVEMENT_XP2_31);
			}
		}

		CheckForAchievementBuilding(eBuildingType);
	}

	return true;
}


//	--------------------------------------------------------------------------------
bool CvCity::CreateProject(ProjectTypes eProjectType)
{
	VALIDATE_OBJECT

	CvPlayer& thisPlayer = GET_PLAYER(getOwner());
	CvTeam& thisTeam = GET_TEAM(getTeam());
	thisTeam.changeProjectCount(eProjectType, 1);

	changeProjectCount(eProjectType, 1);

	ProjectTypes ApolloProgram = (ProjectTypes)GD_INT_GET(SPACE_RACE_TRIGGER_PROJECT);
	ProjectTypes capsuleID = (ProjectTypes)GC.getSPACESHIP_CAPSULE();
	ProjectTypes boosterID = (ProjectTypes)GC.getSPACESHIP_BOOSTER();
	ProjectTypes stasisID = (ProjectTypes)GC.getSPACESHIP_STASIS();
	ProjectTypes engineID = (ProjectTypes)GC.getSPACESHIP_ENGINE();

	enum eSpaceshipState
	{
		eUnderConstruction = 0x0000,
		eFrame = 0x0001,
		eCapsule = 0x0002,
		eStasis_Chamber = 0x0004,
		eEngine = 0x0008,
		eBooster1 = 0x0010,
		eBooster2 = 0x0020,
		eBooster3 = 0x0040,
		eConstructed = 0x0080,
	};

	if (eProjectType == ApolloProgram)
	{
		CvCity* theCapital = thisPlayer.getCapitalCity();
		if (theCapital)
		{
			CvInterfacePtr<ICvPlot1> pDllPlot(new CvDllPlot(theCapital->plot()));
			gDLL->GameplaySpaceshipRemoved(pDllPlot.get());
			gDLL->GameplaySpaceshipCreated(pDllPlot.get(), eUnderConstruction + eFrame);
		}
	}
	else if (GC.getProjectInfo(eProjectType)->IsSpaceship())
	{
		VictoryTypes eVictory = (VictoryTypes)GC.getProjectInfo(eProjectType)->GetVictoryPrereq();

		if (NO_VICTORY != eVictory && GET_TEAM(getTeam()).canLaunch(eVictory))
		{
			CvInterfacePtr<ICvPlot1> pDllPlot(new CvDllPlot(plot()));
			gDLL->GameplaySpaceshipEdited(pDllPlot.get(), eConstructed);
			gDLL->sendLaunch(getOwner(), eVictory);
		}
		else
		{
			//show the spaceship progress

			// this section is kind of hard-coded but it is completely hard-coded on the engine-side so I have to give it the numbers it expects
			int spaceshipState = eFrame;

			if ((thisTeam.getProjectCount((ProjectTypes)capsuleID)) == 1)
			{
				spaceshipState += eCapsule;
			}

			if ((thisTeam.getProjectCount((ProjectTypes)stasisID)) == 1)
			{
				spaceshipState += eStasis_Chamber;
			}

			if ((thisTeam.getProjectCount((ProjectTypes)engineID)) == 1)
			{
				spaceshipState += eEngine;
			}

			if ((thisTeam.getProjectCount((ProjectTypes)boosterID)) >= 1)
			{
				spaceshipState += eBooster1;
			}

			if ((thisTeam.getProjectCount((ProjectTypes)boosterID)) >= 2)
			{
				spaceshipState += eBooster2;
			}

			if ((thisTeam.getProjectCount((ProjectTypes)boosterID)) == 3)
			{
				spaceshipState += eBooster3;
			}

			CvInterfacePtr<ICvPlot1> pDllPlot(new CvDllPlot(plot()));
			gDLL->GameplaySpaceshipEdited(pDllPlot.get(), spaceshipState);
		}
	}

	CvProjectEntry* pProject = GC.getProjectInfo(eProjectType);
	if (pProject)
	{
		GET_PLAYER(getOwner()).GetTreasury()->ChangeBaseBuildingGoldMaintenance(pProject->GetGoldMaintenance()); // Maintenance cost
		ChangeUnmoddedHappinessFromBuildings(pProject->GetHappiness());
		ChangeEmpireSizeModifierReduction(pProject->GetEmpireSizeModifierReduction());
		ChangeDistressFlatReduction(pProject->GetDistressFlatReduction());
		ChangePovertyFlatReduction(pProject->GetPovertyFlatReduction());
		ChangeIlliteracyFlatReduction(pProject->GetIlliteracyFlatReduction());
		ChangeBoredomFlatReduction(pProject->GetBoredomFlatReduction());
		ChangeReligiousUnrestFlatReduction(pProject->GetReligiousUnrestFlatReduction());
		ChangeBasicNeedsMedianModifier(pProject->GetBasicNeedsMedianModifier());
		ChangeGoldMedianModifier(pProject->GetGoldMedianModifier());
		ChangeScienceMedianModifier(pProject->GetScienceMedianModifier());
		ChangeCultureMedianModifier(pProject->GetCultureMedianModifier());
		ChangeReligiousUnrestModifier(pProject->GetReligiousUnrestModifier());
		ChangeEspionageModifier(pProject->GetEspionageMod());
	}

	GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityProjectComplete, getOwner(), GetID(), eProjectType);

	return true;
}

void CvCity::changeProjectCount(ProjectTypes eProject, int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(eProject >= 0, "ePlayer expected to be >= 0");
	CvAssertMsg(eProject < GC.getNumProjectInfos(), "ePlayer expected to be < NUM_DOMAIN_TYPES");
	m_aiNumProjects[eProject] = m_aiNumProjects[eProject] + iValue;
}

int CvCity::getProjectCount(ProjectTypes eProject) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eProject >= 0, "ePlayer expected to be >= 0");
	CvAssertMsg(eProject < GC.getNumProjectInfos(), "ePlayer expected to be < NUM_DOMAIN_TYPES");
	return m_aiNumProjects[eProject];
}

bool IsValidPlotForUnitType(CvPlot* pPlot, PlayerTypes ePlayer, CvUnitEntry* pkUnitInfo)
{
	if (!pPlot->isValidMovePlot(ePlayer))
		return false;

	bool bAccept = false;
	switch (pkUnitInfo->GetDomainType())
	{
	case NO_DOMAIN:
	case DOMAIN_IMMOBILE:
		break;
	case DOMAIN_AIR:
		bAccept = pPlot->isCity();
		break;
	case DOMAIN_LAND:
		bAccept = !pPlot->isWater();
		break;
	case DOMAIN_SEA:
		bAccept = pPlot->isWater() || pPlot->isCoastalCityOrPassableImprovement(ePlayer, true, true);
		break;
	case DOMAIN_HOVER:
		bAccept = true;
		break;
	}

	if (!bAccept)
		return false;

	//civilians can always stack
	//note that this also allows airplanes! (they may need to rebase later)
	if (pkUnitInfo->GetCombat() == 0)
		return true;

	const IDInfo* pUnitNode = pPlot->headUnitNode();
	while (pUnitNode != NULL)
	{
		const CvUnit* pLoopUnit = ::GetPlayerUnit(*pUnitNode);
		if (pLoopUnit != NULL)
		{
			// check stacking (see also CountStackingUnitsAtPlot)
			if (pLoopUnit->IsCombatUnit() && pLoopUnit->getDomainType() == pkUnitInfo->GetDomainType())
				return false;
		}

		pUnitNode = pPlot->nextUnitNode(pUnitNode);
	}

	return true;
}

CvPlot* CvCity::GetPlotForNewUnit(UnitTypes eUnitType, bool bAllowCenterPlot) const
{
	VALIDATE_OBJECT
	CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnitType);
	if (pkUnitInfo == NULL)
		return NULL;

	//use city plot if free
	CvPlot* pCityPlot = plot();
	if (bAllowCenterPlot && IsValidPlotForUnitType(pCityPlot, getOwner(), pkUnitInfo))
		return pCityPlot;

	//don't be too predictable with the chosen plot - but zero always maps to zero
	int aiShuffle[3][7] = {
		{ 0, 5, 4, 2, 1, 3, 6 },
		{ 0, 3, 6, 4, 1, 2, 5 },
		{ 0, 1, 2, 4, 5, 6, 3 } };
	int iShuffleType = GC.getGame().getSmallFakeRandNum(3, plot()->GetPlotIndex() + GET_PLAYER(m_eOwner).getNumUnits());

	//check city plot and adjacent plots
	vector<CvPlot*> validChoices;
	for (int i = 0; i < RING1_PLOTS; i++)
	{
		CvPlot* pPlot = iterateRingPlots(plot(), aiShuffle[iShuffleType][i]);
		if (pPlot == NULL)
			continue;

		if (IsValidPlotForUnitType(pPlot, getOwner(), pkUnitInfo))
			validChoices.push_back(pPlot);
	}

	//first choice is route and no enemy
	for (size_t i = 0; i < validChoices.size(); i++)
		if (validChoices[i]->isValidRoute(NULL) && validChoices[i]->GetNumEnemyUnitsAdjacent(getTeam(), (DomainTypes)pkUnitInfo->GetDomainType()) == 0)
			return validChoices[i];

	//now check for plots with route
	for (size_t i = 0; i < validChoices.size(); i++)
		if (validChoices[i]->isValidRoute(NULL))
			return validChoices[i];

	//now try to find one without enemies around
	for (size_t i = 0; i < validChoices.size(); i++)
		if (validChoices[i]->GetNumEnemyUnitsAdjacent(getTeam(), (DomainTypes)pkUnitInfo->GetDomainType()) == 0)
			return validChoices[i];

	//ok, let's just take the first one
	if (!validChoices.empty())
		return validChoices.front();

	return NULL;
}

//	--------------------------------------------------------------------------------
bool CvCity::CanPlaceUnitHere(UnitTypes eUnitType) const
{
	CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnitType);

	//similar to GetPlotForNewUnit but without the RNG calls
	for (int i = 0; i < RING1_PLOTS; i++)
	{
		CvPlot* pPlot = iterateRingPlots(plot(), i);
		if (!pPlot)
			continue;

		if (IsValidPlotForUnitType(pPlot, getOwner(), pkUnitInfo))
			return true;
	}

	return false;
}

//	--------------------------------------------------------------------------------
// Is this city allowed to purchase something right now?
bool CvCity::IsCanPurchase(bool bTestPurchaseCost, bool bTestTrainable, UnitTypes eUnitType, BuildingTypes eBuildingType, ProjectTypes eProjectType, YieldTypes ePurchaseYield)
{
	std::vector<int> vTotalBuildingCount(GC.getNumBuildingInfos(), 0);
	int iLoop = 0;
	for (const CvCity* pLoopCity = GET_PLAYER(m_eOwner).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(m_eOwner).nextCity(&iLoop))
	{
		const std::vector<BuildingTypes>& vBuildings = pLoopCity->GetCityBuildings()->GetAllBuildingsHere();
		for (size_t i = 0; i < vBuildings.size(); i++)
			vTotalBuildingCount[vBuildings[i]]++;
	}

	return IsCanPurchase(vTotalBuildingCount, bTestPurchaseCost, bTestTrainable, eUnitType, eBuildingType, eProjectType, ePurchaseYield);
}

bool CvCity::IsCanPurchase(const std::vector<int>& vPreExistingBuildings, bool bTestPurchaseCost, bool bTestTrainable, UnitTypes eUnitType, BuildingTypes eBuildingType, ProjectTypes eProjectType, YieldTypes ePurchaseYield)
{
	CvAssertMsg(eUnitType >= 0 || eBuildingType >= 0 || eProjectType >= 0, "No valid passed in");
	CvAssertMsg(!(eUnitType >= 0 && eBuildingType >= 0) && !(eUnitType >= 0 && eProjectType >= 0) && !(eBuildingType >= 0 && eProjectType >= 0), "Only one being passed");

	// Can't purchase anything in a puppeted city
	// slewis - The Venetian Exception
	bool bIsPuppet = IsPuppet();
	bool bVenetianException = false;
#if defined(MOD_BALANCE_CORE_PUPPET_PURCHASE)
	bool bPuppetExceptionUnit = false;
	bool bPuppetExceptionBuilding = false;
	bool bAllowsPuppetPurchase = IsAllowPuppetPurchase();
	if (MOD_BALANCE_CORE_PUPPET_PURCHASE && bIsPuppet && !bAllowsPuppetPurchase)
	{
		if (eUnitType >= 0)
		{
			CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnitType);
			if (pkUnitInfo)
			{
				if (pkUnitInfo->IsPuppetPurchaseOverride())
				{
					bPuppetExceptionUnit = true;
				}
			}
		}
		else if (eBuildingType >= 0)
		{
			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuildingType);
			if (pkBuildingInfo)
			{
				if (pkBuildingInfo->IsPuppetPurchaseOverride())
				{
					bPuppetExceptionBuilding = true;
				}
			}
		}
	}
#endif
#if defined(MOD_GLOBAL_PURCHASE_FAITH_BUILDINGS_IN_PUPPETS)
	bool bPuppetExceptionFaithBuilding = false;
	if (MOD_GLOBAL_PURCHASE_FAITH_BUILDINGS_IN_PUPPETS && bIsPuppet && eBuildingType >= 0 && ePurchaseYield == YIELD_FAITH)
	{
		bPuppetExceptionFaithBuilding = true;
	}
#endif
	if (GET_PLAYER(m_eOwner).GetPlayerTraits()->IsNoAnnexing() && bIsPuppet)
	{
		bVenetianException = true;
	}
#if defined(MOD_BALANCE_CORE_PUPPET_PURCHASE) && defined(MOD_GLOBAL_PURCHASE_FAITH_BUILDINGS_IN_PUPPETS)
	if (bIsPuppet && !bVenetianException && !bPuppetExceptionBuilding && !bPuppetExceptionUnit && !bAllowsPuppetPurchase && !bPuppetExceptionFaithBuilding)
#elif defined(MOD_BALANCE_CORE_PUPPET_PURCHASE)
	if (bIsPuppet && !bVenetianException && !bPuppetExceptionBuilding && !bPuppetExceptionUnit && !bAllowsPuppetPurchase)
#elif defined(MOD_GLOBAL_PURCHASE_FAITH_BUILDINGS_IN_PUPPETS)
	if (bIsPuppet && !bVenetianException && !bPuppetExceptionFaithBuilding)
#else
	if (bIsPuppet && !bVenetianException)
#endif
	{
		return false;
	}

	// Check situational reasons we can't purchase now (similar to not having enough gold or faith)
	if (bTestPurchaseCost)
	{
		// Can't purchase things if the city is in resistance or is being razed
		if (IsResistance() || IsRazing())
			return false;

		// if we're purchasing a unit
		if (eUnitType >= 0)
		{
			// if we can't add this unit to this tile, then don't!
			if (!CanPlaceUnitHere(eUnitType))
				return false;
		}
	}

	// What are we buying this with?
	switch (ePurchaseYield)
	{
	case YIELD_GOLD:
	{
		int iGoldCost = -1;

		// Unit
		if (eUnitType != NO_UNIT)
		{
			if (!canTrain(eUnitType, false, !bTestTrainable, false /*bIgnoreCost*/, true /*bWillPurchase*/))
				return false;

			iGoldCost = GetPurchaseCost(eUnitType);
#if defined(MOD_BALANCE_CORE_PUPPET_PURCHASE)
			if (MOD_BALANCE_CORE_PUPPET_PURCHASE && bIsPuppet && !bPuppetExceptionUnit && !bAllowsPuppetPurchase && !bVenetianException)
			{
				return false;
			}
			//Have we already invested here?
			CvUnitEntry* pGameUnit = GC.getUnitInfo(eUnitType);
			if (MOD_BALANCE_CORE_UNIT_INVESTMENTS || (MOD_BALANCE_VP && pGameUnit->GetSpaceshipProject() != NO_PROJECT))
			{
				const UnitClassTypes eUnitClass = (UnitClassTypes)(pGameUnit->GetUnitClassType());
				if (IsUnitInvestment(eUnitClass))
				{
					return false;
				}
			}
#endif
		}
		// Building
		else if (eBuildingType != NO_BUILDING)
		{
			if (!canConstruct(eBuildingType, vPreExistingBuildings, false, !bTestTrainable, false /*bIgnoreCost*/, true /*bWillPurchase*/))
			{
				bool bAlreadyUnderConstruction = canConstruct(eBuildingType, true, !bTestTrainable) && getFirstBuildingOrder(eBuildingType) != -1;
				if (!bAlreadyUnderConstruction)
				{
					return false;
				}
			}

			iGoldCost = GetPurchaseCost(eBuildingType);
#if defined(MOD_BALANCE_CORE_PUPPET_PURCHASE)
			if (MOD_BALANCE_CORE_PUPPET_PURCHASE && bIsPuppet && !bPuppetExceptionBuilding && !bAllowsPuppetPurchase && !bVenetianException)
			{
				return false;
			}
#endif
#if defined(MOD_BALANCE_CORE_BUILDING_INVESTMENTS)
			if (MOD_BALANCE_CORE_BUILDING_INVESTMENTS && (NO_BUILDING != eBuildingType))
			{
				//Have we already invested here?
				CvBuildingEntry* pGameBuilding = GC.getBuildingInfo(eBuildingType);
				const BuildingClassTypes eBuildingClass = (BuildingClassTypes)(pGameBuilding->GetBuildingClassType());
				if (IsBuildingInvestment(eBuildingClass))
				{
					return false;
				}

				if (getProductionTurnsLeft(eBuildingType, 0) == 1) //Can't invest when only 1 turn left, for parity with AI
				{
					return false;
				}
			}
		}
#endif	
		// Project
		else if (eProjectType != NO_PROJECT)
		{
			if (/*1*/ GD_INT_GET(PROJECT_PURCHASING_DISABLED) == 1)
				return false;

			if (!canCreate(eProjectType, false, !bTestTrainable))
				return false;

			iGoldCost = GetPurchaseCost(eProjectType);
		}

		if (iGoldCost == -1)
		{
			return false;
		}
		else
		{
			if (bTestPurchaseCost)
			{
				// Trying to buy something when you don't have enough money!!
				if (iGoldCost > GET_PLAYER(getOwner()).GetTreasury()->GetGold())
					return false;
#if defined(MOD_BALANCE_CORE)
				if (eUnitType != NO_UNIT && (GC.getUnitInfo(eUnitType)->GetCombat() <= 0 && GC.getUnitInfo(eUnitType)->GetRangedCombat() <= 0) && MOD_BALANCE_CORE && (GetUnitPurchaseCooldown(true) - GetUnitPurchaseCooldownMod(true)) > 0)
				{
					return false;
				}
				else if (eUnitType != NO_UNIT && (GC.getUnitInfo(eUnitType)->GetCombat() > 0 || GC.getUnitInfo(eUnitType)->GetRangedCombat() > 0) && MOD_BALANCE_CORE && (GetUnitPurchaseCooldown() - GetUnitPurchaseCooldownMod(false)) > 0)
				{
					return false;
				}
				if (NO_BUILDING != eBuildingType && MOD_BALANCE_CORE && GetBuildingPurchaseCooldown() > 0)
				{
					return false;
				}
				if (eUnitType != NO_UNIT)
				{
					CvUnitEntry* thisUnitInfo = GC.getUnitInfo(eUnitType);
					// See if there are any BuildingClass requirements
					const int iNumBuildingClassInfos = GC.getNumBuildingClassInfos();
					for (int iBuildingClassLoop = 0; iBuildingClassLoop < iNumBuildingClassInfos; iBuildingClassLoop++)
					{
						const BuildingClassTypes eBuildingClass = (BuildingClassTypes)iBuildingClassLoop;
						CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);
						if (!pkBuildingClassInfo)
						{
							continue;
						}

						// Requires Building
						if (thisUnitInfo->GetBuildingClassPurchaseRequireds(eBuildingClass))
						{
							if (GetCityBuildings()->GetNumBuildingClass(eBuildingClass) == 0)
							{
								return false;
							}
						}
					}
				}
#endif	
			}
		}
	}
	break;

	case YIELD_FAITH:
	{
		int iFaithCost = -1;
		// Unit
		if (eUnitType != NO_UNIT)
		{
			iFaithCost = GetFaithPurchaseCost(eUnitType, true);
			if (iFaithCost < 1)
			{
				return false;
			}
#if defined(MOD_BALANCE_CORE_PUPPET_PURCHASE)
			if (MOD_BALANCE_CORE_PUPPET_PURCHASE && bIsPuppet && !bPuppetExceptionUnit && !bAllowsPuppetPurchase && !bVenetianException)
			{
				return false;
			}
#endif
			CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnitType);

			if (pkUnitInfo)
			{
				//naval units are only for the UA!
				if (pkUnitInfo->GetDomainType() == DOMAIN_SEA && pkUnitInfo->GetSpecialUnitType() == NO_SPECIALUNIT && !GET_PLAYER(m_eOwner).GetPlayerTraits()->IsCanPurchaseNavalUnitsFaith())
					return false;

				ReligionTypes eReligion;
				if (pkUnitInfo->IsFoundReligion())
				{
					eReligion = GET_PLAYER(m_eOwner).GetReligions()->GetOwnedReligion();
				}
				else
				{
					eReligion = GetCityReligions()->GetReligiousMajority();
				}
				const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, m_eOwner);
				bool bSpecificBeliefBlocked = false;
				if (pReligion)
				{
					if (pkUnitInfo->IsRequiresEnhancedReligion() && !(GC.getGame().GetGameReligions()->GetReligion(eReligion, m_eOwner)->m_bEnhanced))
					{
						return false;
					}

					BeliefTypes SpecificBelief = pReligion->m_Beliefs.GetSpecificFaithBuyingEnabledBelief(eUnitType);
					if (SpecificBelief != NO_BELIEF)
					{
						bSpecificBeliefBlocked = true;
						TechTypes ePrereqTech = (TechTypes)pkUnitInfo->GetPrereqAndTech();
						TechTypes eObsoleteTech = (TechTypes)pkUnitInfo->GetObsoleteTech();
						if (ePrereqTech != -1 || eObsoleteTech != -1)
						{
							if (!canTrain(eUnitType, false, !bTestTrainable, false /*bIgnoreCost*/, true /*bWillPurchase*/))
							{
								return false;
							}
						}
						if (pReligion->m_Beliefs.IsSpecificFaithBuyingEnabled(eUnitType, getOwner(), this))
						{
							bSpecificBeliefBlocked = false;
							if (canTrain(eUnitType, false, !bTestTrainable, false /*bIgnoreCost*/, true /*bWillPurchase*/))
							{
								if (!bTestPurchaseCost) {
									return true;
								}
								if (iFaithCost <= GET_PLAYER(getOwner()).GetFaith())
								{
									return true;
								}
							}
						}
					}
				}

				if (pkUnitInfo->IsRequiresFaithPurchaseEnabled())
				{

					if (pkUnitInfo->GetBeliefUnlock() != NO_BELIEF)
					{
						if (!HasBelief((BeliefTypes)pkUnitInfo->GetBeliefUnlock()))
						{
							return false;
						}
					}

					TechTypes ePrereqTech = (TechTypes)pkUnitInfo->GetPrereqAndTech();
					if (ePrereqTech == -1)
					{
						const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, m_eOwner);
						if (pReligion)
						{
							if (!pReligion->m_Beliefs.IsFaithBuyingEnabled((EraTypes)0, getOwner(), this)) // Ed?
							{
								return false;
							}
							if (!canTrain(eUnitType, false, !bTestTrainable, false /*bIgnoreCost*/, true /*bWillPurchase*/))
							{
								return false;
							}
						}
						else
							return false;
					}
					else
					{
						CvTechEntry* pkTechInfo = GC.GetGameTechs()->GetEntry(ePrereqTech);
						if (!pkTechInfo)
						{
							return false;
						}
						else
						{
							const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eReligion, m_eOwner);
							if (pReligion)
							{
								if (!pReligion->m_Beliefs.IsFaithBuyingEnabled((EraTypes)pkTechInfo->GetEra(), getOwner(), this))
								{
									return false;
								}
								else if (pkUnitInfo->GetDefaultUnitAIType() == UNITAI_ARCHAEOLOGIST)
								{
									return false;
								}

								if (!canTrain(eUnitType, false, !bTestTrainable, false /*bIgnoreCost*/, true /*bWillPurchase*/))
								{
									return false;
								}
							}
							else
								return false;
						}
					}
				}
				else
				{
					if (pkUnitInfo->GetBeliefUnlock() != NO_BELIEF)
					{
						if (!HasBelief((BeliefTypes)pkUnitInfo->GetBeliefUnlock()))
						{
							return false;
						}
					}
					if (bSpecificBeliefBlocked)
					{
						return false;
					}

					// Missionaries, Inquisitors and Prophets
					// We need a full religion and not just a pantheon,
					// and also to test that the player can build the unit, specifically the check for a civ specific version of the unit
					if (eReligion <= RELIGION_PANTHEON || !canTrain(eUnitType, false, !bTestTrainable, true /*bIgnoreCost*/, true /*bWillPurchase*/))
					{
						return false;
					}
				}
			}
		}
		// Building
		else if (eBuildingType != NO_BUILDING)
		{
			CvBuildingEntry* pkBuildingInfo = GC.GetGameBuildings()->GetEntry(eBuildingType);

			// Religion-enabled building
			if (pkBuildingInfo && pkBuildingInfo->IsUnlockedByBelief())
			{
				ReligionTypes eMajority = GetCityReligions()->GetReligiousMajority();
				if (eMajority <= RELIGION_PANTHEON)
				{
					return false;
				}
				const CvReligion* pReligion = GetCityReligions()->GetMajorityReligion();
				if (pReligion == NULL)
					return false;

				if (!pReligion->m_Beliefs.IsBuildingClassEnabled(pkBuildingInfo->GetBuildingClassType(), getOwner(), this))
				{
					return false;
				}
			}

			if (!canConstruct(eBuildingType, false, !bTestTrainable, true /*bIgnoreCost*/, true /*bWillPurchase*/))
			{
				return false;
			}

			if (GetCityBuildings()->GetNumBuilding(eBuildingType) > 0)
			{
				return false;
			}

			TechTypes ePrereqTech = (TechTypes)pkBuildingInfo->GetPrereqAndTech();
			if (ePrereqTech != NO_TECH)
			{
				CvTechEntry* pkTechInfo = GC.GetGameTechs()->GetEntry(ePrereqTech);
				if (pkTechInfo && !GET_TEAM(GET_PLAYER(getOwner()).getTeam()).GetTeamTechs()->HasTech(ePrereqTech))
				{
					return false;
				}
			}

			iFaithCost = GetFaithPurchaseCost(eBuildingType);
			if (iFaithCost < 1)
			{
				return false;
			}
		}

		if (iFaithCost > 0)
		{
			if (bTestPurchaseCost)
			{
#if defined(MOD_BALANCE_CORE)
				if (eUnitType != NO_UNIT)
				{
					CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnitType);
					if (pkUnitInfo && GET_PLAYER(getOwner()).GetFaithPurchaseCooldown() > 0 && pkUnitInfo->GetGlobalFaithCooldown() > 0)
					{
						return false;
					}
					// Faith counterpart to PurchaseCooldown
					if ((GC.getUnitInfo(eUnitType)->GetCombat() <= 0 && GC.getUnitInfo(eUnitType)->GetRangedCombat() <= 0) && GC.getUnitInfo(eUnitType)->GetLocalFaithCooldown() > 0 && GetUnitFaithPurchaseCooldown(true) > 0)
					{
						return false;
					}
					else if ((GC.getUnitInfo(eUnitType)->GetCombat() > 0 || GC.getUnitInfo(eUnitType)->GetRangedCombat() > 0) && GC.getUnitInfo(eUnitType)->GetLocalFaithCooldown() > 0 && GetUnitFaithPurchaseCooldown() > 0)
					{
						return false;
					}
				}
#endif
				// Trying to buy something when you don't have enough faith!!
				if (iFaithCost > GET_PLAYER(getOwner()).GetFaith())
				{
					return false;
				}
			}
		}
	}
	break;
	default:
		// This function is accessible from Lua scripts so it's incorrect to assume this is unreachable unless we make the Lua function
		// throw errors for non-gold/faith inputs.
		CvAssertMsg(false, "CvCity::IsCanPurchase expects either YIELD_GOLD or YIELD_FAITH as ePurchaseYield");
		return false;
	}

	return true;
}

//	--------------------------------------------------------------------------------
// purchase something at the city
void CvCity::Purchase(UnitTypes eUnitType, BuildingTypes eBuildingType, ProjectTypes eProjectType, YieldTypes ePurchaseYield)
{
	VALIDATE_OBJECT

	CvPlayer& kPlayer = GET_PLAYER(getOwner());

	switch (ePurchaseYield)
	{
	case YIELD_GOLD:
	{
		// Can we actually buy this thing?
		if (!IsCanPurchase(/*bTestPurchaseCost*/ true, /*bTestTrainable*/ true, eUnitType, eBuildingType, eProjectType, YIELD_GOLD))
			return;

		int iGoldCost = 0;

		kPlayer.GetTreasury();

		// Unit
		if (eUnitType != NO_UNIT) {
			iGoldCost = GetPurchaseCost(eUnitType);
			CvUnitEntry* pGameUnit = GC.getUnitInfo(eUnitType);
			if (pGameUnit != NULL)
			{
				kPlayer.GetTreasury()->LogExpenditure((CvString)pGameUnit->GetText(), iGoldCost, 2);
			}
#if defined(MOD_BALANCE_CORE)
			bool bCivilian = (pGameUnit->GetCombat() <= 0 && pGameUnit->GetRangedCombat() <= 0);
			SetUnitPurchaseCooldown(bCivilian, pGameUnit->GetCooldown() - GetUnitPurchaseCooldownMod(bCivilian));
#endif
			// Building
		}
		else if (eBuildingType != NO_BUILDING) {
			iGoldCost = GetPurchaseCost(eBuildingType);
			CvBuildingEntry* pGameBuilding = GC.getBuildingInfo(eBuildingType);
			if (pGameBuilding != NULL)
			{
				kPlayer.GetTreasury()->LogExpenditure((CvString)pGameBuilding->GetText(), iGoldCost, 2);
			}
#if defined(MOD_BALANCE_CORE)
			SetBuildingPurchaseCooldown(pGameBuilding->GetCooldown());
#endif
			// Project
		}
		else if (eProjectType != NO_PROJECT) {
			iGoldCost = GetPurchaseCost(eProjectType);
			kPlayer.GetTreasury()->LogExpenditure((CvString)GC.getProjectInfo(eProjectType)->GetText(), iGoldCost, 2);
		}

		GET_PLAYER(getOwner()).GetTreasury()->ChangeGold(-iGoldCost);
#if defined(MOD_BALANCE_CORE)
		if (iGoldCost > 0)
		{
			GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_PURCHASE, false, NO_GREATPERSON, NO_BUILDING, iGoldCost, false, NO_PLAYER, NULL, false, this);
		}
#endif

		bool bResult = false;
		if (eUnitType >= 0)
		{
			CvUnitEntry* pGameUnit = GC.getUnitInfo(eUnitType);
			if (pGameUnit)
			{
				bool bInvest = MOD_BALANCE_CORE_UNIT_INVESTMENTS || (MOD_BALANCE_VP && pGameUnit->GetSpaceshipProject() != NO_PROJECT);
				if (bInvest)
				{
					const UnitClassTypes eUnitClass = (UnitClassTypes)(pGameUnit->GetUnitClassType());
					if (eUnitClass != NO_UNITCLASS)
					{
						SetUnitInvestment(eUnitClass, true);
						if (getProductionProcess() != NO_PROCESS)
						{
							clearOrderQueue();
						}

						if (!hasOrder(ORDER_TRAIN, eUnitType, -1))
						{
							pushOrder(ORDER_TRAIN, eUnitType, -1, false, false, true, false);
						}
					}
				}
				else
				{
					CvUnit* pUnit = CreateUnit(eUnitType, NO_UNITAI, REASON_BUY, false, true);
					if (pUnit)
					{
						if (pUnit->isFreeUpgrade() || GET_PLAYER(getOwner()).GetPlayerTraits()->IsFreeUpgrade())
						{
							UnitTypes eUpgradeUnit = pUnit->GetUpgradeUnitType();
							if (eUpgradeUnit != NO_UNIT && this->canTrain(eUpgradeUnit, false, false, true))
							{
								pUnit->DoUpgrade(true);
							}
						}
						if (kPlayer.GetPlayerTraits()->IsFreeZuluPikemanToImpi())
						{
							UnitClassTypes ePikemanClass = (UnitClassTypes)GC.getInfoTypeForString("UNITCLASS_PIKEMAN");
							UnitTypes eZuluImpi = (UnitTypes)GC.getInfoTypeForString("UNIT_ZULU_IMPI");
							if (pUnit != NULL && pUnit->getUnitClassType() == ePikemanClass && this->canTrain(eZuluImpi, false, false, true))
							{
								CvUnitEntry* pkcUnitEntry = GC.getUnitInfo(eZuluImpi);
								if (pkcUnitEntry)
								{
									UnitAITypes eZuluImpiAI = pkcUnitEntry->GetDefaultUnitAIType();
									CvUnit* pZuluImpi = kPlayer.initUnit(eZuluImpi, pUnit->getX(), pUnit->getY(), eZuluImpiAI);
									pZuluImpi->convert(pUnit, true);
								}
							}
						}
						if (pUnit->isTrade())
						{
							if (GC.getLogging() && GC.getAILogging())
							{
								CvString strCiv = GET_PLAYER(getOwner()).getCivilizationAdjective();
								CvString strLogString;
								strLogString.Format("TRADE UNIT BOUGHT: %s %s at %d,d", strCiv.c_str(), pUnit->getName().c_str(), pUnit->getX(), pUnit->getY());
								GET_PLAYER(getOwner()).GetHomelandAI()->LogHomelandMessage(strLogString);
							}
						}

#if defined(MOD_EVENTS_CITY)
						if (MOD_EVENTS_CITY) {
							GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityTrained, getOwner(), GetID(), pUnit->GetID(), true, false);
						}
						else {
#endif
							ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
							if (pkScriptSystem)
							{
								CvLuaArgsHandle args;
								args->Push(getOwner());
								args->Push(GetID());
								args->Push(pUnit->GetID());
								args->Push(true); // bGold
								args->Push(false); // bFaith/bCulture

								bool bScriptResult = false;
								LuaSupport::CallHook(pkScriptSystem, "CityTrained", args.get(), bScriptResult);
							}
#if defined(MOD_EVENTS_CITY)
						}
#endif
					}
				}
#if defined(MOD_BALANCE_CORE_UNIT_INVESTMENTS)
			}
#endif
		}
		else if (eBuildingType >= 0)
		{
			if (MOD_BALANCE_CORE_BUILDING_INVESTMENTS)
			{
				CvBuildingEntry* pGameBuilding = GC.getBuildingInfo(eBuildingType);
				if (pGameBuilding)
				{
					const BuildingClassTypes eBuildingClass = (BuildingClassTypes)(pGameBuilding->GetBuildingClassType());
					if (eBuildingClass != NO_BUILDINGCLASS)
					{
						SetBuildingInvestment(eBuildingClass, true);

						if (!hasOrder(ORDER_CONSTRUCT, eBuildingType, -1))
						{
							//we purchased it so let's assume it's urgent and put it at the head of the list
							pushOrder(ORDER_CONSTRUCT, eBuildingType, -1, false, false, false);
						}
					}
				}
			}
			else
			{
				bResult = CreateBuilding(eBuildingType);

				if (MOD_EVENTS_CITY) {
					GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityConstructed, getOwner(), GetID(), eBuildingType, true, false);
				}
				else {

					CvBuildingEntry* pkPurchasedBuildingInfo = GC.getBuildingInfo(eBuildingType);
					if (pkPurchasedBuildingInfo)
					{
						const BuildingClassTypes ePurchasedClass = (BuildingClassTypes)pkPurchasedBuildingInfo->GetBuildingClassType();
						if (ePurchasedClass != NO_BUILDINGCLASS)
						{
							SetPurchased(ePurchasedClass, true);
						}
					}

					ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
					if (pkScriptSystem)
					{
						CvLuaArgsHandle args;
						args->Push(getOwner());
						args->Push(GetID());
						args->Push(eBuildingType);
						args->Push(true); // bGold
						args->Push(false); // bFaith/bCulture

						bool bScriptResult = false;
						LuaSupport::CallHook(pkScriptSystem, "CityConstructed", args.get(), bScriptResult);
					}
#if defined(MOD_EVENTS_CITY)
				}
#endif

				CleanUpQueue(); // cleans out items from the queue that may be invalidated by the recent construction
				CvAssertMsg(bResult, "Unable to create building");
#if defined(MOD_BALANCE_CORE_BUILDING_INVESTMENTS)
			}
#endif
		}
		else if (eProjectType >= 0)
		{
			bResult = CreateProject(eProjectType);
			CvAssertMsg(bResult, "Unable to create project");

#if defined(MOD_EVENTS_CITY)
			if (MOD_EVENTS_CITY) {
				GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityCreated, getOwner(), GetID(), eProjectType, true, false);
			}
			else {
#endif
				ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
				if (pkScriptSystem)
				{
					CvLuaArgsHandle args;
					args->Push(getOwner());
					args->Push(GetID());
					args->Push(eProjectType);
					args->Push(true); // bGold
					args->Push(false); // bFaith/bCulture

					bool bScriptResult = false;
					LuaSupport::CallHook(pkScriptSystem, "CityCreated", args.get(), bScriptResult);
				}
#if defined(MOD_EVENTS_CITY)
			}
#endif
		}
	}
	break;
	case YIELD_FAITH:
	{
		int iFaithCost = 0;

		// Can we actually buy this thing?
		if (!IsCanPurchase(/*bTestPurchaseCost*/ true, /*bTestTrainable*/ true, eUnitType, eBuildingType, eProjectType, YIELD_FAITH))
			return;

		// Unit
		if (eUnitType != NO_UNIT)
			iFaithCost = GetFaithPurchaseCost(eUnitType, true  /*bIncludeBeliefDiscounts*/);
		// Building
		else if (eBuildingType != NO_BUILDING)
			iFaithCost = GetFaithPurchaseCost(eBuildingType);

		if (eUnitType >= 0)
		{
			CvUnit* pUnit = CreateUnit(eUnitType, NO_UNITAI, REASON_FAITH_BUY);
			if (pUnit==NULL)
				return;	// Can't create the unit, most likely we have no place for it.  We have not deducted the cost yet so just exit.

			if (pUnit->getUnitInfo().GetGlobalFaithCooldown() > 0)
			{
				int iCooldown = pUnit->getUnitInfo().GetGlobalFaithCooldown();
				iCooldown *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iCooldown /= 100;
				kPlayer.ChangeFaithPurchaseCooldown(iCooldown);
			}
			if (pUnit->getUnitInfo().GetLocalFaithCooldown() > 0)
			{
				bool bCivilian = (pUnit->getUnitInfo().GetCombat() <= 0 && pUnit->getUnitInfo().GetRangedCombat() <= 0);
				int iCooldown = pUnit->getUnitInfo().GetLocalFaithCooldown();
				iCooldown *= GC.getGame().getGameSpeedInfo().getTrainPercent();
				iCooldown /= 100;
				ChangeUnitFaithPurchaseCooldown(bCivilian, iCooldown);
			}

			if (pUnit->isFreeUpgrade() || GET_PLAYER(getOwner()).GetPlayerTraits()->IsFreeUpgrade())
			{
				UnitTypes eUpgradeUnit = pUnit->GetUpgradeUnitType();
				if (eUpgradeUnit != NO_UNIT && this->canTrain(eUpgradeUnit, false, false, true))
				{
					pUnit->DoUpgrade(true);
				}
			}
			if (kPlayer.GetPlayerTraits()->IsFreeZuluPikemanToImpi())
			{
				UnitClassTypes ePikemanClass = (UnitClassTypes)GC.getInfoTypeForString("UNITCLASS_PIKEMAN");
				UnitTypes eZuluImpi = (UnitTypes)GC.getInfoTypeForString("UNIT_ZULU_IMPI");
				if (pUnit != NULL && pUnit->getUnitClassType() == ePikemanClass && this->canTrain(eZuluImpi, false, false, true))
				{
					CvUnitEntry* pkcUnitEntry = GC.getUnitInfo(eZuluImpi);
					if (pkcUnitEntry)
					{
						UnitAITypes eZuluImpiAI = pkcUnitEntry->GetDefaultUnitAIType();
						CvUnit* pZuluImpi = kPlayer.initUnit(eZuluImpi, pUnit->getX(), pUnit->getY(), eZuluImpiAI);
						pZuluImpi->convert(pUnit, true);
					}
				}
			}

#if defined(MOD_EVENTS_CITY)
			if (MOD_EVENTS_CITY) {
				GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityTrained, getOwner(), GetID(), pUnit->GetID(), false, true);
			}
			else {
#endif
				ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
				if (pkScriptSystem)
				{
					CvLuaArgsHandle args;
					args->Push(getOwner());
					args->Push(GetID());
					args->Push(pUnit->GetID());
					args->Push(false); // bGold
					args->Push(true); // bFaith/bCulture

					bool bResult = false;
					LuaSupport::CallHook(pkScriptSystem, "CityTrained", args.get(), bResult);
				}
#if defined(MOD_EVENTS_CITY)
			}
#endif

			// Prophets are always of the religion the player founded
			ReligionTypes eReligion;
			if (pUnit->getUnitInfo().IsFoundReligion())
			{
				eReligion = kPlayer.GetReligions()->GetOwnedReligion();
			}
			else
			{
				eReligion = GetCityReligions()->GetReligiousMajority();
			}

			pUnit->GetReligionDataMutable()->SetFullStrength(pUnit->getOwner(), pUnit->getUnitInfo(), eReligion, this);

			kPlayer.ChangeFaith(-iFaithCost);

			UnitClassTypes eUnitClass = pUnit->getUnitClassType();
			if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_WRITER"))
			{
				kPlayer.incrementWritersFromFaith();
			}
			else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_ARTIST"))
			{
				kPlayer.incrementArtistsFromFaith();
			}
			else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_MUSICIAN"))
			{
				kPlayer.incrementMusiciansFromFaith();
			}
			else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_SCIENTIST"))
			{
				kPlayer.incrementScientistsFromFaith();
			}
			else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_MERCHANT"))
			{
				kPlayer.incrementMerchantsFromFaith();
			}
			else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_ENGINEER"))
			{
				kPlayer.incrementEngineersFromFaith();
			}
			else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_GREAT_GENERAL"))
			{
				kPlayer.incrementGeneralsFromFaith();
			}
			else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_GREAT_ADMIRAL"))
			{
				kPlayer.incrementAdmiralsFromFaith();
				CvPlot* pSpawnPlot = kPlayer.GetBestCoastalSpawnPlot(pUnit);
				if (pUnit->plot() != pSpawnPlot)
				{
					pUnit->setXY(pSpawnPlot->getX(), pSpawnPlot->getY());
				}
			}
			else if (eUnitClass == GC.getInfoTypeForString("UNITCLASS_PROPHET"))
			{
#if defined(MOD_GLOBAL_TRULY_FREE_GP)
				kPlayer.GetReligions()->ChangeNumProphetsSpawned(1, false);
#else
				kPlayer.GetReligions()->ChangeNumProphetsSpawned(1);
#endif
			}
			else if (MOD_BALANCE_VP && eUnitClass == GC.getInfoTypeForString("UNITCLASS_GREAT_DIPLOMAT"))
			{
				kPlayer.incrementDiplomatsFromFaith();
			}
#if defined(MOD_BALANCE_CORE)
			else if (pUnit->getUnitInfo().IsGPExtra() == 1)
			{
				kPlayer.incrementGPExtra1FromFaith();
			}
			else if (pUnit->getUnitInfo().IsGPExtra() == 2)
			{
				kPlayer.incrementGPExtra2FromFaith();
			}
			else if (pUnit->getUnitInfo().IsGPExtra() == 3)
			{
				kPlayer.incrementGPExtra3FromFaith();
			}
			else if (pUnit->getUnitInfo().IsGPExtra() == 4)
			{
				kPlayer.incrementGPExtra4FromFaith();
			}
			else if (pUnit->getUnitInfo().IsGPExtra() == 5)
			{
				kPlayer.incrementGPExtra5FromFaith();
			}
#endif

			if (GC.getLogging())
			{
				CvString strLogMsg;
				CvString temp;
				strLogMsg = kPlayer.getCivilizationShortDescription();
				strLogMsg += ", FAITH UNIT PURCHASE, ";
				strLogMsg += pUnit->getName();
				strLogMsg += ", ";
				strLogMsg += getName();
				strLogMsg += ", Faith Cost: ";
				temp.Format("%d", iFaithCost);
				strLogMsg += temp;
				strLogMsg += ", Faith Left: ";
				temp.Format("%d", kPlayer.GetFaith());
				strLogMsg += temp;
				GC.getGame().GetGameReligions()->LogReligionMessage(strLogMsg);
			}
		}

		else if (eBuildingType >= 0)
		{
			bool bResult = false;
			bResult = CreateBuilding(eBuildingType);
			CleanUpQueue(); // cleans out items from the queue that may be invalidated by the recent construction
			CvAssertMsg(bResult, "Unable to create building");

#if defined(MOD_EVENTS_CITY)
			if (MOD_EVENTS_CITY) {
				GAMEEVENTINVOKE_HOOK(GAMEEVENT_CityConstructed, getOwner(), GetID(), eBuildingType, false, true);
			}
			else {
#endif
#if defined(MOD_BALANCE_CORE)
				CvBuildingEntry* pkPurchasedBuildingInfo = GC.getBuildingInfo(eBuildingType);
				if (pkPurchasedBuildingInfo)
				{
					const BuildingClassTypes ePurchasedClass = (BuildingClassTypes)pkPurchasedBuildingInfo->GetBuildingClassType();
					if (ePurchasedClass != NO_BUILDINGCLASS)
					{
						SetPurchased(ePurchasedClass, true);
					}
				}
#endif
				ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();
				if (pkScriptSystem)
				{
					CvLuaArgsHandle args;
					args->Push(getOwner());
					args->Push(GetID());
					args->Push(eBuildingType);
					args->Push(false); // bGold
					args->Push(true); // bFaith/bCulture

					bool bScriptResult = false;
					LuaSupport::CallHook(pkScriptSystem, "CityConstructed", args.get(), bScriptResult);
				}
#if defined(MOD_EVENTS_CITY)
			}
#endif

			kPlayer.ChangeFaith(-iFaithCost);

			if (GC.getLogging())
			{
				CvString strLogMsg;
				CvString temp;
				strLogMsg = kPlayer.getCivilizationShortDescription();
				strLogMsg += ", FAITH BUILDING PURCHASE, ";

				CvBuildingXMLEntries* pGameBuildings = GC.GetGameBuildings();
				if (pGameBuildings != NULL)
				{
					CvBuildingEntry* pBuildingEntry = pGameBuildings->GetEntry(eBuildingType);
					if (pBuildingEntry != NULL)
					{
						strLogMsg += pBuildingEntry->GetDescription();
						strLogMsg += ", ";
					}
				}
				strLogMsg += getName();
				strLogMsg += ", Faith Cost: ";
				temp.Format("%d", iFaithCost);
				strLogMsg += temp;
				strLogMsg += ", Faith Left: ";
				temp.Format("%d", kPlayer.GetFaith());
				strLogMsg += temp;
				GC.getGame().GetGameReligions()->LogReligionMessage(strLogMsg);
			}
		}

		if (iFaithCost > 0)
		{
			GET_PLAYER(getOwner()).doInstantYield(INSTANT_YIELD_TYPE_FAITH_PURCHASE, true, NO_GREATPERSON, NO_BUILDING, iFaithCost, false, NO_PLAYER, NULL, false, this);
		}
	}
	break;
	default:
		// This function is accessible from Lua scripts and network callbacks so it's incorrect to assume this is unreachable.
		CvAssertMsg(false, "CvCity::Purchase expects either YIELD_GOLD or YIELD_FAITH as ePurchaseYield");
	}
}


// Protected Functions...

//	--------------------------------------------------------------------------------
void CvCity::doGrowth()
{
	VALIDATE_OBJECT
	// here would be a good place to override this in Lua

	// No growth or starvation if being razed
	if (IsRazing())
	{
		return;
	}
	//No growth or starvation if in resistance
	if (IsResistance())
	{
		return;
	}

	int iFoodPerTurn100 = foodDifferenceTimes100();
	int iFoodReqForGrowth = growthThreshold();

	if (iFoodPerTurn100 < 0)
	{
		CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
		if (pNotifications)
		{
			Localization::String text = Localization::Lookup("TXT_KEY_NTFN_CITY_STARVING");
			text << getNameKey();
			Localization::String summary = Localization::Lookup("TXT_KEY_NTFN_CITY_STARVING_S");
			summary << getNameKey();

			pNotifications->Add(NOTIFICATION_STARVING, text.toUTF8(), summary.toUTF8(), getX(), getY(), -1);
		}
	}

	changeFoodTimes100(iFoodPerTurn100);

	//can't grow while starving
	if (getFood() >= iFoodReqForGrowth)
	{
		if (GetCityCitizens()->IsForcedAvoidGrowth())  // don't grow a city if we are at *forced* avoid growth
		{
			setFood(iFoodReqForGrowth);
		}
		else
		{
			int iFoodKept = (iFoodReqForGrowth * getMaxFoodKeptPercent()) / 100;
			int iFoodStoreChange = max(0, iFoodReqForGrowth - iFoodKept);

			changeFood(-iFoodStoreChange);
			changePopulation(1);

			// Only show notification if the city is small
			if (getPopulation() <= 5)
			{
				CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
				if (pNotifications)
				{
					Localization::String localizedText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_GROWTH");
					localizedText << getNameKey() << getPopulation();
					Localization::String localizedSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_GROWTH");
					localizedSummary << getNameKey();
					pNotifications->Add(NOTIFICATION_CITY_GROWTH, localizedText.toUTF8(), localizedSummary.toUTF8(), getX(), getY(), GetID());
				}
			}
		}
	}
	//starving
	else if (getFood() == 0 && iFoodPerTurn100 < 0 && getPopulation()>1)
	{
		changePopulation(-1);
	}
}

//	--------------------------------------------------------------------------------
bool CvCity::doCheckProduction()
{
	VALIDATE_OBJECT
	OrderData* pOrderNode = NULL;
	UnitTypes eUpgradeUnit;
	int iUpgradeProduction = 0;
	int iProductionGold = 0;
	bool bOK = true;

	int iMaxedUnitGoldPercent = /*100*/ GD_INT_GET(MAXED_UNIT_GOLD_PERCENT);
	int iMaxedBuildingGoldPercent = /*100*/ GD_INT_GET(MAXED_BUILDING_GOLD_PERCENT);
	int iMaxedProjectGoldPercent = /*300*/ GD_INT_GET(MAXED_PROJECT_GOLD_PERCENT);

	CvPlayerAI& thisPlayer = GET_PLAYER(getOwner());

	for (int iI = 0; iI < GC.getNumUnitInfos(); iI++)
	{
		const UnitTypes eUnit = static_cast<UnitTypes>(iI);
		CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
		if (pkUnitInfo)
		{
			int iUnitProduction = getUnitProduction(eUnit);
			if (iUnitProduction > 0)
			{
				if (thisPlayer.isProductionMaxedUnitClass((UnitClassTypes)(pkUnitInfo)->GetUnitClassType()))
				{
					iProductionGold = ((iUnitProduction * iMaxedUnitGoldPercent) / 100);

					if (iProductionGold > 0)
					{
						thisPlayer.GetTreasury()->ChangeGold(iProductionGold);

						if (getOwner() == GC.getGame().getActivePlayer())
						{
							Localization::String localizedText = Localization::Lookup("TXT_KEY_MISC_LOST_WONDER_PROD_CONVERTED");
							localizedText << getNameKey() << GC.getUnitInfo((UnitTypes)iI)->GetTextKey() << iProductionGold;
							DLLUI->AddCityMessage(0, GetIDInfo(), getOwner(), false, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), localizedText.toUTF8());
						}
					}

					setUnitProduction(((UnitTypes)iI), 0);
				}
			}
		}
	}

	for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		const BuildingTypes eExpiredBuilding = static_cast<BuildingTypes>(iI);
		CvBuildingEntry* pkExpiredBuildingInfo = GC.getBuildingInfo(eExpiredBuilding);

		//skip if null
		if (pkExpiredBuildingInfo == NULL)
			continue;

		int iBuildingProduction = m_pCityBuildings->GetBuildingProduction(eExpiredBuilding);
		if (iBuildingProduction > 0)
		{
			const BuildingClassTypes eExpiredBuildingClass = (BuildingClassTypes)(pkExpiredBuildingInfo->GetBuildingClassType());

			if (thisPlayer.isProductionMaxedBuildingClass(eExpiredBuildingClass))
			{
				// Beaten to a world wonder by someone?
				if (isWorldWonderClass(pkExpiredBuildingInfo->GetBuildingClassInfo()))
				{
					for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
					{
						PlayerTypes eLoopPlayer = (PlayerTypes)iPlayerLoop;

						// Found the culprit
						if (GET_PLAYER(eLoopPlayer).getBuildingClassCount(eExpiredBuildingClass) > 0)
						{
							GET_PLAYER(getOwner()).GetDiplomacyAI()->ChangeNumWondersBeatenTo(eLoopPlayer, 1);
							break;
						}
					}

					CvInterfacePtr<ICvCity1> pDllCity(new CvDllCity(this));
					DLLUI->AddDeferredWonderCommand(WONDER_REMOVED, pDllCity.get(), (BuildingTypes)eExpiredBuilding, 0);

					//Add "achievement" for sucking it up
					if (MOD_API_ACHIEVEMENTS)
						gDLL->IncrementSteamStatAndUnlock(ESTEAMSTAT_BEATWONDERS, 10, ACHIEVEMENT_SUCK_AT_WONDERS);
				}

				iProductionGold = ((iBuildingProduction * iMaxedBuildingGoldPercent) / 100);
#if defined(MOD_BALANCE_CORE_BUILDING_INVESTMENTS)
				const BuildingClassTypes eWonderClass = (BuildingClassTypes)pkExpiredBuildingInfo->GetBuildingClassType();
				if (MOD_BALANCE_CORE_BUILDING_INVESTMENTS && IsBuildingInvestment(eWonderClass) && isWorldWonderClass(pkExpiredBuildingInfo->GetBuildingClassInfo()))
				{
					iProductionGold += ((25 * iMaxedBuildingGoldPercent) / 100);
				}
#endif
				if (iProductionGold > 0 && isWorldWonderClass(pkExpiredBuildingInfo->GetBuildingClassInfo()))
				{
#if defined(MOD_BALANCE_CORE_WONDERS_VARIABLE_REWARD)
					if (MOD_BALANCE_CORE_WONDERS_VARIABLE_REWARD && GD_INT_GET(BALANCE_WONDER_BEATEN_CONSOLATION_PRIZE) != 0)
					{
						int iEra = thisPlayer.GetCurrentEra();
						if (iEra <= 0)
						{
							iEra = 1;
						}
						if (GD_INT_GET(BALANCE_WONDER_BEATEN_CONSOLATION_PRIZE) == 1)
						{
							//Wonders converted into Gold (default).
							thisPlayer.GetTreasury()->ChangeGold(iProductionGold * iEra);
						}
						if (GD_INT_GET(BALANCE_WONDER_BEATEN_CONSOLATION_PRIZE) == 2)
						{
							//Wonders converted into Culture Points.
							iProductionGold = (iProductionGold * /*33*/ GD_INT_GET(BALANCE_CULTURE_PERCENTAGE_VALUE)) / 100;
							thisPlayer.changeJONSCulture(iProductionGold * iEra);
							ChangeJONSCultureStored(iProductionGold * iEra);
						}
						if (GD_INT_GET(BALANCE_WONDER_BEATEN_CONSOLATION_PRIZE) == 3)
						{
							//Wonders Converted into Golden Age Points.
							iProductionGold = (iProductionGold * /*25*/ GD_INT_GET(BALANCE_GA_PERCENTAGE_VALUE)) / 100;
							thisPlayer.ChangeGoldenAgeProgressMeter(iProductionGold * iEra);
						}
						if (GD_INT_GET(BALANCE_WONDER_BEATEN_CONSOLATION_PRIZE) == 4)
						{
							//Wonders Converted into Science Points
							iProductionGold = (iProductionGold * /*10*/ GD_INT_GET(BALANCE_SCIENCE_PERCENTAGE_VALUE)) / 100;
							int iBeakersBonus = thisPlayer.getYieldPerTurnHistory(YIELD_SCIENCE, iProductionGold);
							if (iBeakersBonus > 0)
							{
								TechTypes eCurrentTech = thisPlayer.GetPlayerTechs()->GetCurrentResearch();
								if (eCurrentTech == NO_TECH)
								{
									thisPlayer.changeOverflowResearch(iBeakersBonus * iEra);
								}
								else
								{
									GET_TEAM(thisPlayer.getTeam()).GetTeamTechs()->ChangeResearchProgress(eCurrentTech, (iBeakersBonus * iEra), thisPlayer.GetID());
								}
							}
						}
						if (GD_INT_GET(BALANCE_WONDER_BEATEN_CONSOLATION_PRIZE) == 5)
						{
							//Wonders Converted into Faith Points
							iProductionGold = (iProductionGold * /*10*/ GD_INT_GET(BALANCE_FAITH_PERCENTAGE_VALUE)) / 100;
							thisPlayer.ChangeFaith(iProductionGold * iEra);
						}
					}
					else
					{
#endif
						thisPlayer.GetTreasury()->ChangeGold(iProductionGold);
#if defined(MOD_BALANCE_CORE_WONDERS_VARIABLE_REWARD)
					}
#endif

					if (getOwner() == GC.getGame().getActivePlayer())
					{
						// Notification
						CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
						if (pNotifications)
						{
							Localization::String strText = Localization::Lookup("TXT_KEY_MISC_LOST_WONDER_PROD_CONVERTED");
							strText << getNameKey();
							strText << pkExpiredBuildingInfo->GetTextKey();
							strText << iProductionGold;
							Localization::String strSummary = Localization::Lookup("TXT_KEY_MISC_LOST_WONDER_PROD_CONVERTED_S");
							strSummary << getNameKey();
							strSummary << pkExpiredBuildingInfo->GetTextKey();
							pNotifications->Add(NOTIFICATION_WONDER_BEATEN, strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), eExpiredBuilding, GetID());
						}
					}
				}

				m_pCityBuildings->SetBuildingProduction(eExpiredBuilding, 0);
			}
		}
	}

	for (int iI = 0; iI < GC.getNumProjectInfos(); iI++)
	{
		int iProjectProduction = getProjectProduction((ProjectTypes)iI);
		if (iProjectProduction > 0)
		{
			if (thisPlayer.isProductionMaxedProject((ProjectTypes)iI))
			{
				iProductionGold = ((iProjectProduction * iMaxedProjectGoldPercent) / 100);

				if (iProductionGold > 0)
				{
					thisPlayer.GetTreasury()->ChangeGold(iProductionGold);

					if (getOwner() == GC.getGame().getActivePlayer())
					{
						Localization::String localizedText = Localization::Lookup("TXT_KEY_MISC_LOST_WONDER_PROD_CONVERTED");
						localizedText << getNameKey() << GC.getProjectInfo((ProjectTypes)iI)->GetTextKey() << iProductionGold;
						DLLUI->AddCityMessage(0, GetIDInfo(), getOwner(), false, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), localizedText.toUTF8());
					}
				}

				setProjectProduction(((ProjectTypes)iI), 0);
			}
		}
	}

	if (!isProduction() && isHuman() && !isProductionAutomated() && !IsIgnoreCityForHappiness())
	{
		chooseProduction();
		return bOK;
	}

	// Can now construct an Upgraded version of this Unit
	for (int iI = 0; iI < GC.getNumUnitInfos(); iI++)
	{
		if (getFirstUnitOrder((UnitTypes)iI) != -1)
		{
			// If we can still actually train this Unit type then don't auto-upgrade it yet
			if (canTrain((UnitTypes)iI, true))
			{
				continue;
			}

			eUpgradeUnit = allUpgradesAvailable((UnitTypes)iI);

			if (eUpgradeUnit != NO_UNIT)
			{
				CvAssertMsg(eUpgradeUnit != iI, "Trying to upgrade a Unit to itself");
				iUpgradeProduction = getUnitProduction((UnitTypes)iI);
				setUnitProduction(((UnitTypes)iI), 0);
				setUnitProduction(eUpgradeUnit, iUpgradeProduction);

				pOrderNode = headOrderQueueNode();

				while (pOrderNode != NULL)
				{
					if (pOrderNode->eOrderType == ORDER_TRAIN)
					{
						if (pOrderNode->iData1 == iI)
						{
							thisPlayer.changeUnitClassMaking(((UnitClassTypes)(GC.getUnitInfo((UnitTypes)(pOrderNode->iData1))->GetUnitClassType())), -1);
							pOrderNode->iData1 = eUpgradeUnit;
							thisPlayer.changeUnitClassMaking(((UnitClassTypes)(GC.getUnitInfo((UnitTypes)(pOrderNode->iData1))->GetUnitClassType())), 1);
						}
					}

					pOrderNode = nextOrderQueueNode(pOrderNode);
				}
			}
		}
	}

	// Can now construct an Upgraded version of this Building
	for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
		if (pkBuildingInfo)
		{
			if (getFirstBuildingOrder(eBuilding) != -1)
			{
				BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkBuildingInfo->GetReplacementBuildingClass();

				if (eBuildingClass != NO_BUILDINGCLASS)
				{
					BuildingTypes eUpgradeBuilding = ((BuildingTypes)(thisPlayer.getCivilizationInfo().getCivilizationBuildings(eBuildingClass)));

					if (canConstruct(eUpgradeBuilding))
					{
						CvAssertMsg(eUpgradeBuilding != iI, "Trying to upgrade a Building to itself");
						iUpgradeProduction = m_pCityBuildings->GetBuildingProduction(eBuilding);
						m_pCityBuildings->SetBuildingProduction((eBuilding), 0);
						m_pCityBuildings->SetBuildingProduction(eUpgradeBuilding, iUpgradeProduction);

						pOrderNode = headOrderQueueNode();

						while (pOrderNode != NULL)
						{
							if (pOrderNode->eOrderType == ORDER_CONSTRUCT)
							{
								if (pOrderNode->iData1 == iI)
								{
									CvBuildingEntry* pkOrderBuildingInfo = GC.getBuildingInfo((BuildingTypes)pOrderNode->iData1);
									CvBuildingEntry* pkUpgradeBuildingInfo = GC.getBuildingInfo(eUpgradeBuilding);

									if (NULL != pkOrderBuildingInfo && NULL != pkUpgradeBuildingInfo)
									{
										const BuildingClassTypes eOrderBuildingClass = (BuildingClassTypes)pkOrderBuildingInfo->GetBuildingClassType();
										const BuildingClassTypes eUpgradeBuildingClass = (BuildingClassTypes)pkUpgradeBuildingInfo->GetBuildingClassType();

										thisPlayer.changeBuildingClassMaking(eOrderBuildingClass, -1);
										pOrderNode->iData1 = eUpgradeBuilding;
										thisPlayer.changeBuildingClassMaking(eUpgradeBuildingClass, 1);

									}
								}
							}

							pOrderNode = nextOrderQueueNode(pOrderNode);
						}
					}
				}
			}
		}
	}

	return CleanUpQueue();
}


//	--------------------------------------------------------------------------------
void CvCity::doProduction(bool bAllowNoProduction)
{
	VALIDATE_OBJECT

	if (!isHuman() || isProductionAutomated())
	{
		if (!isProduction() || isProductionProcess() || AI_isChooseProductionDirty())
		{
			AI_chooseProduction(false /*bInterruptWonders*/, false);
		}
	}

	if (!bAllowNoProduction && !isProduction())
	{
		return;
	}

	if (isProduction())
	{
		if (isProductionBuilding())
		{
			const OrderData* pOrderNode = headOrderQueueNode();
			int iData1 = -1;
			if (pOrderNode != NULL)
			{
				iData1 = pOrderNode->iData1;
			}

			const BuildingTypes eBuilding = static_cast<BuildingTypes>(iData1);
			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
			if (pkBuildingInfo)
			{
				if (isWorldWonderClass(pkBuildingInfo->GetBuildingClassInfo()))
				{
					if (m_pCityBuildings->GetBuildingProduction(eBuilding) == 0)  // otherwise we are probably already showing this
					{
						CvInterfacePtr<ICvCity1> pDllCity(new CvDllCity(this));
						DLLUI->AddDeferredWonderCommand(WONDER_CREATED, pDllCity.get(), eBuilding, 0);
					}
				}
			}
		}

		changeProductionTimes100(getCurrentProductionDifferenceTimes100(false, true));

#if defined(MOD_PROCESS_STOCKPILE)
		if (!(MOD_PROCESS_STOCKPILE && isProductionProcess()))
#endif
			setOverflowProduction(0);
		setFeatureProduction(0);

#if defined(MOD_PROCESS_STOCKPILE)
		if (getProduction() >= getProductionNeeded())
#else
		if (getProduction() >= getProductionNeeded() && !isProductionProcess())
#endif
		{
#if defined(MOD_PROCESS_STOCKPILE)
			popOrder(0, !isProductionProcess(), true);
#else
			popOrder(0, true, true);
#endif
		}
	}
	else
	{
		changeOverflowProductionTimes100(getCurrentProductionDifferenceTimes100(false, false));
	}
}


//	--------------------------------------------------------------------------------
void CvCity::doProcess()
{
	ProcessTypes eProcess = getProductionProcess();
	CvAssertMsg(eProcess != NO_PROCESS, "Invalid Process for city production. Please send Anton your save file and version.");
	if (eProcess == NO_PROCESS) return;

#if defined(MOD_PROCESS_STOCKPILE)
	if (MOD_PROCESS_STOCKPILE && eProcess == GC.getInfoTypeForString("PROCESS_STOCKPILE"))
	{
		int iPile = getCurrentProductionDifferenceTimes100(false, false);
		// Can't use changeOverflowProductionTimes100() here as it asserts above 250 production
		setOverflowProductionTimes100(getOverflowProductionTimes100() + iPile);
		CUSTOMLOG("Adding %i production to the stockpile of %s (for a total of %i)", iPile / 100, getName().c_str(), getOverflowProduction());
	}
#endif
}


//	--------------------------------------------------------------------------------
void CvCity::doDecay()
{
	VALIDATE_OBJECT
	int iBuildingProductionDecayTime = /*50*/ GD_INT_GET(BUILDING_PRODUCTION_DECAY_TIME);
	int iBuildingProductionDecayPercent = /*99*/ GD_INT_GET(BUILDING_PRODUCTION_DECAY_PERCENT);

	for (int iI = 0; iI < GC.getNumBuildingInfos(); iI++)
	{
		if (getProductionBuilding() != ((BuildingTypes)iI))
		{
			if (m_pCityBuildings->GetBuildingProduction((BuildingTypes)iI) > 0)
			{
				m_pCityBuildings->ChangeBuildingProductionTime(((BuildingTypes)iI), 1);

				if (isHuman())
				{
					if (m_pCityBuildings->GetBuildingProductionTime((BuildingTypes)iI) > iBuildingProductionDecayTime)
					{
						m_pCityBuildings->SetBuildingProduction(((BuildingTypes)iI), ((m_pCityBuildings->GetBuildingProduction((BuildingTypes)iI) * iBuildingProductionDecayPercent) / 100));
					}
				}
			}
			else
			{
				m_pCityBuildings->SetBuildingProductionTime(((BuildingTypes)iI), 0);
			}
		}
	}

	int iUnitProductionDecayTime = /*10*/ GD_INT_GET(UNIT_PRODUCTION_DECAY_TIME);
	int iUnitProductionDecayPercent = /*98*/ GD_INT_GET(UNIT_PRODUCTION_DECAY_PERCENT);

	for (int iI = 0; iI < GC.getNumUnitInfos(); iI++)
	{
		const UnitTypes eUnit = static_cast<UnitTypes>(iI);
		CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);
		if (pkUnitInfo)
		{
			if (getProductionUnit() != eUnit)
			{
				if (getUnitProduction(eUnit) > 0)
				{
					changeUnitProductionTime(eUnit, 1);

					if (isHuman())
					{
						if (getUnitProductionTime(eUnit) > iUnitProductionDecayTime)
						{
							setUnitProduction(eUnit, ((getUnitProduction(eUnit) * iUnitProductionDecayPercent) / 100));
						}
					}
				}
				else
				{
					setUnitProductionTime(eUnit, 0);
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
void CvCity::doMeltdown()
{
	VALIDATE_OBJECT

	int iNumBuildingInfos = GC.getNumBuildingInfos();
	for (int iI = 0; iI < iNumBuildingInfos; iI++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
		if (NULL != pkBuildingInfo && m_pCityBuildings->GetNumBuilding((BuildingTypes)iI) > 0)
		{
			if (pkBuildingInfo->GetNukeExplosionRand() != 0)
			{
				if (GC.getGame().getJonRandNum(pkBuildingInfo->GetNukeExplosionRand(), "Meltdown!!!") == 0)
				{
					if (m_pCityBuildings->GetNumRealBuilding((BuildingTypes)iI) > 0)
					{
						m_pCityBuildings->SetNumRealBuilding(((BuildingTypes)iI), 0);
					}

					CvUnitCombat::ApplyNuclearExplosionDamage(plot(), 1);

					if (getOwner() == GC.getGame().getActivePlayer())
					{
						Localization::String localizedText = Localization::Lookup("TXT_KEY_MISC_MELTDOWN_CITY");
						localizedText << getNameKey();

						DLLUI->AddCityMessage(0, GetIDInfo(), getOwner(), false, /*10*/ GD_INT_GET(EVENT_MESSAGE_TIME), localizedText.toUTF8()/*, "AS2D_MELTDOWN", MESSAGE_TYPE_MINOR_EVENT, NULL, (ColorTypes)GC.getInfoTypeForString("COLOR_RED"), getX(), getY(), true, true*/);
					}

					break;
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
CvCityStrategyAI* CvCity::GetCityStrategyAI() const
{
	VALIDATE_OBJECT
	return m_pCityStrategyAI;
}

//	--------------------------------------------------------------------------------
CvCityCitizens* CvCity::GetCityCitizens() const
{
	VALIDATE_OBJECT
	return m_pCityCitizens;
}

//	--------------------------------------------------------------------------------
CvCityReligions* CvCity::GetCityReligions() const
{
	VALIDATE_OBJECT
	return m_pCityReligions;
}

//	--------------------------------------------------------------------------------
CvCityEmphases* CvCity::GetCityEmphases() const
{
	VALIDATE_OBJECT
	return m_pEmphases;
}

//	--------------------------------------------------------------------------------
CvCityEspionage* CvCity::GetCityEspionage() const
{
	VALIDATE_OBJECT
	return m_pCityEspionage;
}

//	--------------------------------------------------------------------------------
CvCityCulture* CvCity::GetCityCulture() const
{
	VALIDATE_OBJECT
	return m_pCityCulture;
}

// Private Functions...

template<typename City, typename Visitor>
void CvCity::Serialize(City& city, Visitor& visitor)
{
	const bool bLoading = visitor.isLoading();
	const bool bSaving = visitor.isSaving();

	visitor(city.m_iAutomatons);

	// FIXME - Values in this chunk were formerly FAutoVariables. Remove any that shouldn't be saved.
	visitor(city.m_eOwner);
	visitor(city.m_iX);
	visitor(city.m_iY);
	visitor(city.m_iID);
	visitor(city.m_iRallyX);
	visitor(city.m_iRallyY);
	visitor(city.m_iGameTurnFounded);
	visitor(city.m_iGameTurnAcquired);
	visitor(city.m_iGameTurnLastExpanded);
	visitor(city.m_iPopulation);
	visitor(city.m_iHighestPopulation);
	visitor(city.m_iExtraHitPoints);
	visitor(city.m_iNumGreatPeople);
	visitor(city.m_iBaseGreatPeopleRate);
	visitor(city.m_iGreatPeopleRateModifier);
	visitor(city.m_iJONSCultureStored);
	visitor(city.m_iJONSCultureLevel);
	visitor(city.m_iJONSCulturePerTurnFromPolicies);
	visitor(city.m_iJONSCulturePerTurnFromSpecialists);
	visitor(city.m_iaAddedYieldPerTurnFromTraits);
	visitor(city.m_iFaithPerTurnFromPolicies);
	visitor(city.m_iAdditionalFood);
	visitor(city.m_iCityBuildingBombardRange);
	visitor(city.m_iCityIndirectFire);
	visitor(city.m_iCityBuildingRangeStrikeModifier);
	visitor(city.m_iCultureRateModifier);
	visitor(city.m_iNumWorldWonders);
	visitor(city.m_iNumTeamWonders);
	visitor(city.m_iNumNationalWonders);
	visitor(city.m_iWonderProductionModifier);
	visitor(city.m_iCapturePlunderModifier);
	visitor(city.m_iBorderGrowthRateIncrease);
	visitor(city.m_iPlotCultureCostModifier);
	visitor(city.m_iPlotBuyCostModifier);
	visitor(city.m_iCityWorkingChange);
	visitor(city.m_iCitySupplyModifier);
	visitor(city.m_iCitySupplyFlat);
	visitor(city.m_iDamageReductionFlat);
	visitor(city.m_bAllowsProductionTradeRoutes);
	visitor(city.m_bAllowsFoodTradeRoutes);
	visitor(city.m_bAllowPuppetPurchase);
	visitor(city.m_iCityAutomatonWorkersChange);
	visitor(city.m_iMaintenance);
	visitor(city.m_iHealRate);
	visitor(city.m_iNoOccupiedUnhappinessCount);
	visitor(city.m_iLocalGainlessPillageCount);
	visitor(city.m_iFood);
	visitor(city.m_iMaxFoodKeptPercent);
	visitor(city.m_iOverflowProduction);
	visitor(city.m_iFeatureProduction);
	visitor(city.m_iMilitaryProductionModifier);
	visitor(city.m_iSpaceProductionModifier);
	visitor(city.m_iFreeExperience);
	visitor(city.m_iMaxAirUnits);
	visitor(city.m_iNukeModifier);
	visitor(city.m_iTradeRouteTargetBonus);
	visitor(city.m_iTradeRouteRecipientBonus);
	visitor(city.m_iTradeRouteSeaGoldBonus);
	visitor(city.m_iTradeRouteLandGoldBonus);
	visitor(city.m_iNumTradeRouteBonus);
	visitor(city.m_iCityConnectionTradeRouteGoldModifier);
	visitor(city.m_iCitySizeBoost);
	visitor(city.m_iSpecialistFreeExperience);
	visitor(city.m_iStrengthValue);
	visitor(city.m_iDamage);
	visitor(city.m_iThreatValue);
	visitor(city.m_hGarrison);
	visitor(city.m_iResourceDemanded);
	visitor(city.m_iResourceDemandedCounter);
	visitor(city.m_iWeLoveTheKingDayCounter);
	visitor(city.m_iLastTurnGarrisonAssigned);
	visitor(city.m_iThingsProduced);
	visitor(city.m_iDemandResourceCounter);
	visitor(city.m_iResistanceTurns);
	visitor(city.m_iRazingTurns);
	visitor(city.m_iLowestRazingPop);
	visitor(city.m_iCountExtraLuxuries);
	visitor(city.m_iCheapestPlotInfluenceDistance);
	visitor(city.m_iEspionageModifier);
	visitor(city.m_iEspionageTurnsModifierEnemy);
	visitor(city.m_iConversionModifier);
	visitor(city.m_bNeverLost);
	visitor(city.m_bDrafted);
	visitor(city.m_bProductionAutomated);
	visitor(city.m_bLayoutDirty);
	visitor(city.m_bMadeAttack);
	visitor(city.m_bOccupied);
	visitor(city.m_bPuppet);
	visitor(city.m_bIgnoreCityForHappiness);
	visitor(city.m_bIndustrialRouteToCapital);
	visitor(city.m_iTerrainImprovementNeed);
	visitor(city.m_ePreviousOwner);
	visitor(city.m_eOriginalOwner);
	visitor(city.m_ePlayersReligion);
	visitor(city.m_aiSeaPlotYield);
	visitor(city.m_aiRiverPlotYield);
	visitor(city.m_aiLakePlotYield);
	visitor(city.m_aiSeaResourceYield);
	visitor(city.m_aiBaseYieldRateFromTerrain);
	visitor(city.m_aiBaseYieldRateFromBuildings);
	visitor(city.m_aiBaseYieldRateFromSpecialists);
	visitor(city.m_aiBaseYieldRateFromMisc);
	visitor(city.m_aiBaseYieldRateFromLeague);
	visitor(city.m_iTotalScienceyAid);
	visitor(city.m_iTotalArtsyAid);
	visitor(city.m_iTotalGreatWorkAid);
	visitor(city.m_aiChangeGrowthExtraYield);
	visitor(city.m_iHappinessFromEmpire);
	visitor(city.m_iUnhappinessFromEmpire);
	visitor(city.m_iCachedBasicNeedsMedian);
	visitor(city.m_iCachedGoldMedian);
	visitor(city.m_iCachedScienceMedian);
	visitor(city.m_iCachedCultureMedian);
	visitor(city.m_iCachedTechNeedModifier);
	visitor(city.m_iCachedEmpireSizeModifier);
	visitor(city.m_iYieldMediansCachedTurn);
	visitor(city.m_aiNumProjects);
	visitor(city.m_aiLongestPotentialTradeRoute);
	visitor(city.m_aiNumTimesAttackedThisTurn);
	visitor(city.m_aiYieldFromKnownPantheons);
	visitor(city.m_aiYieldFromVictory);
	visitor(city.m_aiYieldFromVictoryGlobal);
	visitor(city.m_aiYieldFromVictoryGlobalEraScaling);
	visitor(city.m_aiYieldFromPillage);
	visitor(city.m_aiYieldFromPillageGlobal);
	visitor(city.m_aiGoldenAgeYieldMod);
	visitor(city.m_aiYieldFromWLTKD);
	visitor(city.m_aiYieldFromConstruction);
	visitor(city.m_aiYieldFromTech);
	visitor(city.m_aiYieldFromBirth);
	visitor(city.m_aiYieldFromUnitProduction);
	visitor(city.m_aiYieldFromBorderGrowth);
	visitor(city.m_aiYieldFromPolicyUnlock);
	visitor(city.m_aiYieldFromPurchase);
	visitor(city.m_aiYieldFromFaithPurchase);
	visitor(city.m_aiYieldFromUnitLevelUp);
	visitor(city.m_aiYieldFromCombatExperience);
	visitor(city.m_aiYieldPerAlly);
	visitor(city.m_aiYieldPerFriend);
	visitor(city.m_aiYieldFromInternalTREnd);
	visitor(city.m_aiYieldFromInternalTR);
	visitor(city.m_aiYieldFromProcessModifier);
	visitor(city.m_aiSpecialistRateModifier);
	visitor(city.m_aiThemingYieldBonus);
	visitor(city.m_aiYieldFromSpyAttack);
	visitor(city.m_aiYieldFromSpyDefense);
	visitor(city.m_aiNumTimesOwned);
	visitor(city.m_aiStaticCityYield);
	visitor(city.m_iTradePriorityLand);
	visitor(city.m_iTradePrioritySea);
	visitor(city.m_iUnitPurchaseCooldown);
	visitor(city.m_iUnitPurchaseCooldownCivilian);
	visitor(city.m_iUnitPurchaseCooldownMod);
	visitor(city.m_iUnitPurchaseCooldownCivilianMod);
	visitor(city.m_iUnitFaithPurchaseCooldown);
	visitor(city.m_iUnitFaithPurchaseCooldownCivilian);
	visitor(city.m_iBuildingPurchaseCooldown);
	visitor(city.m_iReligiousTradeModifier);
	visitor(city.m_iCityAirStrikeDefense);
	visitor(city.m_iFreeBuildingTradeTargetCity);
	visitor(city.m_iBaseTourism);
	visitor(city.m_iBaseTourismBeforeModifiers);
	visitor(city.m_iBorderObstacleCity);
	visitor(city.m_iBorderObstacleWater);
	visitor(city.m_iDeepWaterTileDamage);
	visitor(city.m_iNumNearbyMountains);
	visitor(city.m_iLocalUnhappinessMod);
	visitor(city.m_bNoWarmonger);
	visitor(city.m_iCitySpyRank);
	visitor(city.m_iTurnsSinceRankAnnouncement);
	visitor(city.m_iEmpireSizeModifierReduction);
	visitor(city.m_iDistressFlatReduction);
	visitor(city.m_iPovertyFlatReduction);
	visitor(city.m_iIlliteracyFlatReduction);
	visitor(city.m_iBoredomFlatReduction);
	visitor(city.m_iReligiousUnrestFlatReduction);
	visitor(city.m_iBasicNeedsMedianModifier);
	visitor(city.m_iGoldMedianModifier);
	visitor(city.m_iScienceMedianModifier);
	visitor(city.m_iCultureMedianModifier);
	visitor(city.m_iReligiousUnrestModifier);
	visitor(city.m_iTradeRouteSeaDistanceModifier);
	visitor(city.m_iTradeRouteLandDistanceModifier);
	visitor(city.m_iNukeInterceptionChance);
	visitor(city.m_aiEconomicValue);
	visitor(city.m_miInstantYieldsTotal);
	visitor(city.m_aiBaseYieldRateFromReligion);
	visitor(city.m_aiBaseYieldRateFromCSAlliance);
	visitor(city.m_aiBaseYieldRateFromCSFriendship);
	visitor(city.m_aiYieldFromMinors);
	visitor(city.m_aiResourceQuantityPerXFranchises);
	visitor(city.m_aiYieldChangeFromCorporationFranchises);
	visitor(city.m_aiResourceQuantityFromPOP);
	visitor(city.m_iLandTourismBonus);
	visitor(city.m_iSeaTourismBonus);
	visitor(city.m_iAlwaysHeal);
	visitor(city.m_iResourceDiversityModifier);
	visitor(city.m_iNoUnhappfromXSpecialists);
	visitor(city.m_aiGreatWorkYieldChange);
	visitor(city.m_aiYieldRateModifier);
	visitor(city.m_aiYieldPerPop);
	visitor(city.m_aiYieldPerReligion);
	visitor(city.m_aiPowerYieldRateModifier);
	visitor(city.m_aiResourceYieldRateModifier);
	visitor(city.m_aiExtraSpecialistYield);
	visitor(city.m_aiProductionToYieldModifier);
	visitor(city.m_aiDomainFreeExperience);
	visitor(city.m_aiDomainProductionModifier);
	visitor(city.m_abEverLiberated);
	visitor(city.m_abIsBestForWonder);
	visitor(city.m_abIsPurchased);
	visitor(city.m_abTraded);
	visitor(city.m_abIgnoredForExpansionBickering);
	visitor(city.m_abPaidAdoptionBonus);
	visitor(city.m_aiReligiousPressureModifier);
	visitor(city.m_iExtraBuildingMaintenance);
	visitor(city.m_paiNumTerrainWorked);
	visitor(city.m_paiNumFeaturelessTerrainWorked);
	visitor(city.m_paiNumFeatureWorked);
	visitor(city.m_paiNumResourceWorked);
	visitor(city.m_paiNumImprovementWorked);
	visitor(city.m_strScriptData);
	visitor(city.m_iDamageTakenThisTurn);
	visitor(city.m_iDamageTakenLastTurn);
	visitor(city.m_paiNoResource);
	visitor(city.m_paiFreeResource);
	visitor(city.m_paiNumResourcesLocal);
	visitor(city.m_paiNumUnimprovedResourcesLocal);
	visitor(city.m_paiProjectProduction);
	visitor(city.m_paiSpecialistProduction);
	visitor(city.m_paiUnitProduction);
	visitor(city.m_paiUnitProductionTime);
	visitor(city.m_paiSpecialistCount);
	visitor(city.m_paiMaxSpecialistCount);
	visitor(city.m_paiForceSpecialistCount);
	visitor(city.m_paiFreeSpecialistCount);
	visitor(city.m_paiImprovementFreeSpecialists);
	visitor(city.m_paiUnitCombatFreeExperience);
	visitor(city.m_paiUnitCombatProductionModifier);
	visitor(city.m_paiFreePromotionCount);
	visitor(city.m_paiBuildingClassCulture);
	visitor(city.m_paiHurryModifier);
	visitor(city.m_iHappinessDelta);
	visitor(city.m_iPillagedPlots);
	visitor(city.m_iGrowthEvent);
	visitor(city.m_iGrowthFromTourism);
	visitor(city.m_iBuildingClassHappiness);
	visitor(city.m_iReligionHappiness);
	visitor(city.m_vClosestNeighbors);
	visitor(city.m_iBaseHappinessFromBuildings);
	visitor(city.m_iUnmoddedHappinessFromBuildings);
	visitor(city.m_bRouteToCapitalConnectedLastTurn);
	visitor(city.m_bRouteToCapitalConnectedThisTurn);
	visitor(city.m_strName);
	visitor(city.m_bOwedCultureBuilding);
	visitor(city.m_bOwedFoodBuilding);
	visitor(city.m_aiEventCooldown);
	visitor(city.m_abEventActive);
	visitor(city.m_abEventChoiceActive);
	visitor(city.m_abEventChoiceFired);
	visitor(city.m_abEventFired);
	visitor(city.m_aiEventChoiceDuration);
	visitor(city.m_aiEventIncrement);
	visitor(city.m_aiEventCityYield);
	visitor(city.m_aiEventCityYieldModifier);
	visitor(city.m_iEventHappiness);
	visitor(city.m_iCityEventCooldown);
	visitor(city.m_bIsColony);
	visitor(city.m_iProvinceLevel);
	visitor(city.m_iOrganizedCrime);
	visitor(city.m_iResistanceCounter);
	visitor(city.m_iPlagueCounter);
	visitor(city.m_iPlagueTurns);
	visitor(city.m_iPlagueType);
	visitor(city.m_iSappedTurns);
	visitor(city.m_iLoyaltyCounter);
	visitor(city.m_iDisloyaltyCounter);
	visitor(city.m_iLoyaltyStateType);
	visitor(city.m_aiYieldModifierFromHappiness);
	visitor(city.m_aiYieldModifierFromHealth);
	visitor(city.m_aiYieldModifierFromCrime);
	visitor(city.m_aiYieldModifierFromDevelopment);
	visitor(city.m_aiYieldFromHappiness);
	visitor(city.m_aiYieldFromHealth);
	visitor(city.m_aiYieldFromCrime);
	visitor(city.m_aiYieldFromDevelopment);
	visitor(city.m_aiTempCaptureData);
	visitor(city.m_abTempCaptureData);
	visitor(city.m_bIsPendingCapture);
	visitor(city.m_iPopulationRank);
	visitor(city.m_bPopulationRankValid);
	visitor(city.m_aiBaseYieldRank);
	visitor(city.m_abBaseYieldRankValid);
	visitor(city.m_aiYieldRank);
	visitor(city.m_abYieldRankValid);
	visitor(city.m_abOwedChosenBuilding);
	visitor(city.m_abBuildingInvestment);
	visitor(city.m_abUnitInvestment);
	visitor(city.m_abBuildingConstructed);
	visitor(city.m_aiBonusSightEspionage);

	visitor(*city.m_pCityBuildings);

	// m_orderQueue
	{
		uint32 uLength;
		if (bSaving)
			uLength = uint32(city.m_orderQueue.getLength());
		visitor(uLength);

		for (uint32 uIdx = 0; uIdx < uLength; ++uIdx)
		{
			OrderData order;
			if (bSaving)
				order = *city.m_orderQueue.getAt(uIdx);

			visitor(order.eOrderType);

			// Now we have to translate the data because most of them contain indices into Infos tables and it is very bad to save an index since the table order can change
			switch (order.eOrderType)
			{
			case ORDER_TRAIN:
				visitor.template as<UnitTypes>(order.iData1);
				visitor.template as<UnitAITypes>(order.iData2);
				break;

			case ORDER_CONSTRUCT:
				visitor.template as<BuildingTypes>(order.iData1);
				visitor(order.iData2);
				break;

			case ORDER_CREATE:
				visitor.template as<ProjectTypes>(order.iData1);
				visitor(order.iData2);
				break;

			case ORDER_PREPARE:
				visitor.template as<SpecialistTypes>(order.iData1);
				visitor(order.iData2);
				break;

			case ORDER_MAINTAIN:
				visitor.template as<ProcessTypes>(order.iData1);
				visitor(order.iData2);
				break;

			default:
				CvAssertMsg(false, "order.eOrderType failed to match a valid option");
				visitor(order.iData1);
				visitor(order.iData2);
				break;
			}

			visitor(order.bSave);
			visitor(order.bRush);

			if (bLoading)
			{
				bool bIsValid = false;
				switch (order.eOrderType)
				{
				case NO_ORDER:
					break;

				case ORDER_TRAIN:
					bIsValid = GC.getUnitInfo(UnitTypes(order.iData1)) != NULL;
					break;

				case ORDER_CONSTRUCT:
					bIsValid = GC.getBuildingInfo(BuildingTypes(order.iData1)) != NULL;
					break;

				case ORDER_CREATE:
					bIsValid = GC.getProjectInfo(ProjectTypes(order.iData1)) != NULL;
					break;

				case ORDER_PREPARE:
					bIsValid = GC.getSpecialistInfo(SpecialistTypes(order.iData1)) != NULL;
					break;

				case ORDER_MAINTAIN:
					bIsValid = GC.getProcessInfo(ProcessTypes(order.iData1)) != NULL;
					break;
				}

				CvAssertMsg(bIsValid, "Unit in build queue is invalid");
				if (bIsValid)
					city.m_orderQueue.insertAtEnd(&order);
			}
		}
	}

	visitor(*city.m_pCityStrategyAI);
	if (bLoading && city.m_eOwner != NO_PLAYER)
		GET_PLAYER(city.getOwner()).GetFlavorManager()->AddFlavorRecipient(city.m_pCityStrategyAI, false /* bPropogateFlavorValues */);

	visitor(*city.m_pCityCitizens);
	visitor(*city.m_pCityReligions);
	visitor(*city.m_pEmphases);
	visitor(*city.m_pCityEspionage);

	visitor(city.m_yieldChanges);
	visitor(city.m_eventYields);
	visitor(city.m_ppiGreatPersonProgressFromConstruction);
	visitor(city.m_aiYieldPerPopInEmpire);
}

//	--------------------------------------------------------------------------------
void CvCity::read(FDataStream& kStream)
{
	VALIDATE_OBJECT
	// Init data before load
	reset();

	// Perform shared serialize
	CvStreamLoadVisitor serialVisitor(kStream);
	Serialize(*this, serialVisitor);

#if defined(MOD_BALANCE_CORE)
	GetCityStrategyAI()->PrecalcYieldStats();
#endif

	CvCityManager::OnCityCreated(this);
}

//	--------------------------------------------------------------------------------
void CvCity::write(FDataStream& kStream) const
{
	VALIDATE_OBJECT

	// Perform shared serialize
	CvStreamSaveVisitor serialVisitor(kStream);
	Serialize(*this, serialVisitor);
}


//	--------------------------------------------------------------------------------
bool CvCity::isValidBuildingLocation(BuildingTypes eBuilding) const
{
	VALIDATE_OBJECT

	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if (pkBuildingInfo == NULL)
		return false;

	// Requires coast
	if (pkBuildingInfo->IsWater())
	{
		//-1 is ocean (fast check)
		if (!isCoastal(-1) || !isCoastal(pkBuildingInfo->GetMinAreaSize()))
			return false;
	}

	// Requires River
	if (pkBuildingInfo->IsRiver())
	{
		if (!(plot()->isRiver()))
			return false;
	}

	// Requires Fresh Water
	if (pkBuildingInfo->IsFreshWater())
	{
		if (!plot()->isFreshWater())
			return false;
	}
#if defined(MOD_BALANCE_CORE)
	//Requires no fresh water
	if (MOD_BALANCE_CORE)
	{
		if (pkBuildingInfo->IsNoWater())
		{
			if (plot()->isFreshWater())
				return false;
		}
		if (pkBuildingInfo->IsNoRiver())
		{
			if (plot()->isRiver())
				return false;
		}
		//Must not be on coast
		if (pkBuildingInfo->IsNoCoast())
		{
			if (isCoastal(-1))
				return false;
		}
		//Capital Only
		if (pkBuildingInfo->IsCapitalOnly())
		{
			if (!isCapital())
			{
				return false;
			}
		}
	}
#endif
	// Requires adjacent Mountain
	if (pkBuildingInfo->IsMountain())
	{
		bool bFoundMountain = false;

		CvPlot* pAdjacentPlot = NULL;
		for (int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; iDirectionLoop++)
		{
			pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iDirectionLoop));

			if (pAdjacentPlot != NULL)
			{
				if (pAdjacentPlot->isMountain())
				{
					bFoundMountain = true;
					break;
				}
			}
		}

		if (!bFoundMountain)
			return false;
	}

	// Requires nearby Mountain (within 2 tiles)
	if (pkBuildingInfo->IsNearbyMountainRequired())
	{
		bool bFoundMountain = false;

		const int iMountainRange = 2;
		CvPlot* pLoopPlot = NULL;

		for (int iDX = -iMountainRange; iDX <= iMountainRange; iDX++)
		{
			for (int iDY = -iMountainRange; iDY <= iMountainRange; iDY++)
			{
				pLoopPlot = plotXYWithRangeCheck(getX(), getY(), iDX, iDY, iMountainRange);
				if (pLoopPlot)
				{
					if (pLoopPlot->isMountain() && !pLoopPlot->IsNaturalWonder() && pLoopPlot->getOwner() == getOwner())
					{
						bFoundMountain = true;
						break;
					}
				}
			}

			if (bFoundMountain == true)
				break;
		}

		if (!bFoundMountain)
			return false;
	}

	// Requires Hills
	if (pkBuildingInfo->IsHill())
	{
		if (!plot()->isHills())
			return false;
	}

	// Requires Flat
	if (pkBuildingInfo->IsFlat())
	{
		if (plot()->isHills())
			return false;
	}

	// Requires city not built on certain terrain?
	TerrainTypes eTerrainProhibited = (TerrainTypes)pkBuildingInfo->GetProhibitedCityTerrain();
	if (eTerrainProhibited != NO_TERRAIN)
	{
		if (plot()->getTerrainType() == eTerrainProhibited)
		{
			return false;
		}
	}

	// Requires city to be on or next to a particular terrain type?
	TerrainTypes eTerrainRequired = (TerrainTypes)pkBuildingInfo->GetNearbyTerrainRequired();
	if (eTerrainRequired != NO_TERRAIN)
	{
		bool bFoundTerrain = false;

		// City on the right terrain?
		if (plot()->getTerrainType() == eTerrainRequired)
			bFoundTerrain = true;

		// Check adjacent plots
		if (!bFoundTerrain)
		{
			CvPlot* pAdjacentPlot = NULL;
			for (int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; iDirectionLoop++)
			{
				pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iDirectionLoop));

				if (pAdjacentPlot != NULL)
				{
					// City adjacent to the right terrain?
					if (pAdjacentPlot->getTerrainType() == eTerrainRequired)
					{
						bFoundTerrain = true;
						break;
					}
				}
			}
		}

		// Didn't find nearby required terrain
		if (!bFoundTerrain)
			return false;
	}
#if defined(MOD_BALANCE_CORE)
	if (pkBuildingInfo->IsAnyBodyOfWater())
	{
		if (plot()->isFreshWater() || isCoastal(pkBuildingInfo->GetMinAreaSize()))
		{
			return true;
		}
		else
		{
			return false;
		}
	}
#endif
	return true;
}


// CACHE: cache frequently used values
///////////////////////////////////////

//	--------------------------------------------------------------------------------
void CvCity::invalidatePopulationRankCache()
{
	VALIDATE_OBJECT
	m_bPopulationRankValid = false;
}

//	--------------------------------------------------------------------------------
void CvCity::invalidateYieldRankCache(YieldTypes eYield)
{
	VALIDATE_OBJECT
	CvAssertMsg(eYield >= NO_YIELD && eYield < NUM_YIELD_TYPES, "invalidateYieldRankCache passed bogus yield index");

	if (eYield == NO_YIELD)
	{
		for (int iI = 0; iI < NUM_YIELD_TYPES; iI++)
		{
			m_abBaseYieldRankValid[iI] = false;
			m_abYieldRankValid[iI] = false;
		}
	}
	else
	{
		m_abBaseYieldRankValid[eYield] = false;
		m_abYieldRankValid[eYield] = false;
	}
}

//	--------------------------------------------------------------------------------
bool CvCity::isMadeAttack() const
{
	VALIDATE_OBJECT
	return m_bMadeAttack;
}

//	--------------------------------------------------------------------------------
void CvCity::setMadeAttack(bool bNewValue)
{
	VALIDATE_OBJECT
	m_bMadeAttack = bNewValue;
}

void CvCity::ChangeNumTimesAttackedThisTurn(PlayerTypes ePlayer, int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(ePlayer >= 0, "ePlayer expected to be >= 0");
	CvAssertMsg(ePlayer < REALLY_MAX_PLAYERS, "ePlayer expected to be < NUM_DOMAIN_TYPES");
	m_aiNumTimesAttackedThisTurn[ePlayer] = m_aiNumTimesAttackedThisTurn[ePlayer] + iValue;
}
int CvCity::GetNumTimesAttackedThisTurn(PlayerTypes ePlayer) const
{
	VALIDATE_OBJECT
	CvAssertMsg(ePlayer >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(ePlayer < REALLY_MAX_PLAYERS, "eIndex expected to be < NUM_DOMAIN_TYPES");
	return m_aiNumTimesAttackedThisTurn[ePlayer];
}

int CvCity::getCityBuildingBombardRange() const
{
	VALIDATE_OBJECT
	return m_iCityBuildingBombardRange;
}
void CvCity::changeCityBuildingBombardRange(int iValue)
{
	if (iValue != 0)
	{
		m_iCityBuildingBombardRange += iValue;
	}
}
bool CvCity::getCityIndirectFire() const
{
	VALIDATE_OBJECT
	return m_iCityIndirectFire > 0;
}
void CvCity::changeCityIndirectFire(int iValue)
{
	if (iValue != 0)
	{
		m_iCityIndirectFire += iValue;
	}
}

int CvCity::getCityBuildingRangeStrikeModifier() const
{
	VALIDATE_OBJECT
	return m_iCityBuildingRangeStrikeModifier;
}
void CvCity::changeCityBuildingRangeStrikeModifier(int iValue)
{
	if (iValue != 0)
	{
		m_iCityBuildingRangeStrikeModifier += iValue;
	}
}


#if defined(MOD_EVENTS_CITY_BOMBARD)
//	--------------------------------------------------------------------------------
int CvCity::getBombardRange() const
{
	bool bIndirectFireAllowed = false;
	return getBombardRange(bIndirectFireAllowed);
}

//	--------------------------------------------------------------------------------
int CvCity::getBombardRange(bool& bIndirectFireAllowed) const
{
	VALIDATE_OBJECT

	if (MOD_BALANCE_CORE_BOMBARD_RANGE_BUILDINGS)
	{
		bIndirectFireAllowed = getCityIndirectFire();
		return 1 + getCityBuildingBombardRange();
	}

	if (MOD_EVENTS_CITY_BOMBARD) {
		int iValue = 0;
		if (GAMEEVENTINVOKE_VALUE(iValue, GAMEEVENT_GetBombardRange, getOwner(), GetID()) == GAMEEVENTRETURN_VALUE) {
			// Defend against modder stupidity!
			if (iValue != 0 && ::abs(iValue) <= /*2*/ GD_INT_GET(MAX_CITY_ATTACK_RANGE)) {
				bIndirectFireAllowed = (iValue < 0);
				return ::abs(iValue);
			}
		}
	}

	bIndirectFireAllowed = /*1*/ GD_INT_GET(CAN_CITY_USE_INDIRECT_FIRE) > 0;
	return /*2*/ GD_INT_GET(CITY_ATTACK_RANGE);
}
#endif

//	--------------------------------------------------------------------------------
bool CvCity::canRangeStrike() const
{
	VALIDATE_OBJECT

	if (MOD_CORE_NO_RANGED_ATTACK_FROM_CITIES)
		return false;

	// Can't shoot when in resistance
	if (IsResistance() || IsRazing())
		return false;

	// Can't shoot if we have no HP left (shouldn't really ever happen)
	if (getDamage() == GetMaxHitPoints())
		return false;

	// Apparently it's possible for someone to fire during another player's turn
	if (!GET_PLAYER(getOwner()).isTurnActive())
		return false;

	return true;
}

//	--------------------------------------------------------------------------------
bool CvCity::CanRangeStrikeNow() const
{
	if (!canRangeStrike())
		return false;

	if (isMadeAttack())
		return false;

#if defined(MOD_EVENTS_CITY_BOMBARD)
	int iRange = getBombardRange();
#else
	int iRange = /*2*/ GD_INT_GET(CITY_ATTACK_RANGE);
#endif

	CvPlot* pPlot = plot();
	for (int iRing=1; iRing<=min(5,iRange); iRing++)
	{
		for (int i = RING_PLOTS[iRing-1]; i < RING_PLOTS[iRing]; i++)
		{
			CvPlot* pTargetPlot = iterateRingPlots(pPlot, i);
			if (!pTargetPlot)
				continue;

			//this checks everything, visibility, LOS, target type etc
			if (canRangeStrikeAt(pTargetPlot->getX(), pTargetPlot->getY()))
				return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
/// Does this City have a Building that allows it to Range Strike?
bool CvCity::IsHasBuildingThatAllowsRangeStrike() const
{
	VALIDATE_OBJECT
	bool bHasBuildingThatAllowsRangeStrike = false;

	for (int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
	{
		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);
		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

		if (pkBuildingInfo)
		{
			// Has this Building
			if (GetCityBuildings()->GetNumBuilding(eBuilding) > 0)
			{
				// Does it grant Range Strike ability?
				if (pkBuildingInfo->IsAllowsRangeStrike())
				{
					bHasBuildingThatAllowsRangeStrike = true;
					break;
				}
			}
		}
	}

	return bHasBuildingThatAllowsRangeStrike;
}

//	--------------------------------------------------------------------------------
bool CvCity::canRangeStrikeAt(int iX, int iY) const
{
	VALIDATE_OBJECT
	if (!canRangeStrike())
	{
		return false;
	}

	const CvPlot* pTargetPlot = GC.getMap().plot(iX, iY);

	if (NULL == pTargetPlot)
	{
		return false;
	}

	if (!pTargetPlot->isVisible(getTeam()))
	{
		return false;
	}

#if defined(MOD_EVENTS_CITY_BOMBARD)
	bool bIndirectFireAllowed = false; // By reference, yuck!!!
	int iAttackRange = getBombardRange(bIndirectFireAllowed);
#else
	int iAttackRange = /*2*/ GD_INT_GET(CITY_ATTACK_RANGE);
#endif

	if (plotDistance(plot()->getX(), plot()->getY(), pTargetPlot->getX(), pTargetPlot->getY()) > iAttackRange)
	{
		return false;
	}

#if defined(MOD_EVENTS_CITY_BOMBARD)
	if (!bIndirectFireAllowed)
#else
	if (/*1*/ GD_INT_GET(CAN_CITY_USE_INDIRECT_FIRE) > 0)
#endif
	{
		if (!plot()->canSeePlot(pTargetPlot, getTeam(), iAttackRange, NO_DIRECTION))
		{
			return false;
		}
	}

	// If it's NOT a city, see if there are any units to aim for
	if (!pTargetPlot->isCity())
	{
		if (!canRangedStrikeTarget(*pTargetPlot))
		{
			return false;
		}
	}
	else // I don't want cities attacking each other directly
	{
		return false;
	}

	return true;
}

//	----------------------------------------------------------------------------
CityTaskResult CvCity::rangeStrike(int iX, int iY)
{
	VALIDATE_OBJECT
	CvUnit* pDefender = NULL;

	CityTaskResult eResult = TASK_ABORTED;

	CvPlot* pPlot = GC.getMap().plot(iX, iY);
	if (NULL == pPlot)
	{
		return eResult;
	}

#if defined(MOD_BALANCE_CORE_MILITARY)
	if (!canRangeStrikeAt(iX, iY) || rangedStrikeTarget(pPlot) == NULL || isMadeAttack())
#else
	if (!canRangeStrikeAt(iX, iY))
#endif
	{
		return eResult;
	}

	setMadeAttack(true);

	// No City
	if (!pPlot->isCity())
	{
		pDefender = rangedStrikeTarget(pPlot);

		CvAssert(pDefender != NULL);
		if (!pDefender) return TASK_ABORTED;

		CvCombatInfo kCombatInfo;
		CvUnitCombat::GenerateRangedCombatInfo(*this, pDefender, *pPlot, &kCombatInfo);

		uint uiParentEventID = 0;
		if (!CvPreGame::quickCombat())
		{
			// Center camera here!
			bool isTargetVisibleToActivePlayer = pPlot->isActiveVisible();
			if (isTargetVisibleToActivePlayer)
			{
				CvInterfacePtr<ICvPlot1> pDllPlot = GC.WrapPlotPointer(pPlot);
				DLLUI->lookAt(pDllPlot.get(), CAMERALOOKAT_NORMAL);
			}

			kCombatInfo.setVisualizeCombat(pPlot->isActiveVisible());

			CvInterfacePtr<ICvCombatInfo1> pDllCombatInfo(new CvDllCombatInfo(&kCombatInfo));
			uiParentEventID = gDLL->GameplayCityCombat(pDllCombatInfo.get());

			// Set the combat units so that other missions do not continue until combat is over.
			pDefender->setCombatCity(this);
			setCombatUnit(pDefender);
			eResult = TASK_QUEUED;
		}
		else
		{
			eResult = TASK_COMPLETED;
		}

		CvUnitCombat::ResolveCombat(kCombatInfo, uiParentEventID);
	}

	return eResult;
}

//	--------------------------------------------------------------------------------
bool CvCity::canRangedStrikeTarget(const CvPlot& targetPlot) const
{
	VALIDATE_OBJECT
	return (rangedStrikeTarget(&targetPlot) != 0);
}

CvUnit* CvCity::getBestRangedStrikeTarget() const
{
	if (!canRangeStrike())
		return NULL;

	if (isMadeAttack())
		return NULL;

#if defined(MOD_EVENTS_CITY_BOMBARD)
	int iRange = getBombardRange();
#else
	int iRange = /*2*/ GD_INT_GET(CITY_ATTACK_RANGE);
#endif

	int iBestScore = 0;
	CvUnit* pBestTarget = NULL;

	CvPlot* pPlot = plot();
	for (int iRing=1; iRing<=min(5,iRange); iRing++)
	{
		for (int i = RING_PLOTS[iRing-1]; i < RING_PLOTS[iRing]; i++)
		{
			CvPlot* pTargetPlot = iterateRingPlots(pPlot, i);
			if (!pTargetPlot)
				continue;

			//this checks everything, visibility, LOS, target type etc
			if (canRangeStrikeAt(pTargetPlot->getX(), pTargetPlot->getY()))
			{
				//a bit redundant with the internal of canRangeStrikeAt but that's life
				CvUnit* pTarget = rangedStrikeTarget(pTargetPlot);
				int iDamage = rangeCombatDamage(pTarget, false, NULL);
				if (iDamage > iBestScore)
				{
					iBestScore = iDamage;
					pBestTarget = pTarget;
				}
			}
		}
	}

	return pBestTarget;
}

//	--------------------------------------------------------------------------------
CvUnit* CvCity::rangedStrikeTarget(const CvPlot* pPlot) const
{
	VALIDATE_OBJECT
	CvUnit* pDefender = pPlot->getBestDefender(NO_PLAYER, getOwner(), NULL, true, false, false, /*bNoncombatAllowed*/ true);

	if (pDefender)
	{
		if (!pDefender->IsDead())
		{
#if defined(MOD_GLOBAL_SUBS_UNDER_ICE_IMMUNITY)
			// If the defender is a sub and the plot is ice, return NULL
			if (pDefender->getInvisibleType() == 0 && pPlot->getFeatureType() == FEATURE_ICE) {
				return NULL;
			}
#endif

			return pDefender;
		}
	}

	return NULL;
}

//	--------------------------------------------------------------------------------
int CvCity::rangeCombatUnitDefense(const CvUnit* pDefender, const CvPlot* pInPlot, bool bQuickAndDirty) const
{
	if (pInPlot == NULL)
		pInPlot = pDefender->plot();

	int iDefenderStrength = 0;

	if (pDefender->CanEverEmbark() && pInPlot->needsEmbarkation(pDefender))
	{
		iDefenderStrength = pDefender->GetEmbarkedUnitDefense();
	}
	// Use Ranged combat value for defender, UNLESS it's a boat or an Impi (ranged support)
#if defined(MOD_BALANCE_CORE)
	//Correction - make this apply to all ranged units, naval too.
	else if (!pDefender->isRangedSupportFire() && pDefender->IsCanAttackRanged())
#else
	else if (!pDefender->isRangedSupportFire() && !pDefender->getDomainType() == DOMAIN_SEA)
#endif
	{
		//have to consider embarkation explicitly
		if ((!pInPlot && pDefender->isEmbarked()) || (pInPlot && pInPlot->needsEmbarkation(pDefender) && pDefender->CanEverEmbark()))
			iDefenderStrength = pDefender->GetEmbarkedUnitDefense();
		else
			iDefenderStrength = pDefender->GetMaxRangedCombatStrength(NULL, this, false, pInPlot, plot(), false, bQuickAndDirty);
	}
	else
	{
		iDefenderStrength = pDefender->GetMaxDefenseStrength(pInPlot, NULL, NULL, /*bFromRangedAttack*/ true, bQuickAndDirty);
	}

	return iDefenderStrength;
}

//	--------------------------------------------------------------------------------
int CvCity::rangeCombatDamage(const CvUnit* pDefender, bool bIncludeRand, const CvPlot* pInPlot, bool bQuickAndDirty) const
{
	if (pDefender == NULL)
		return 0;

	// If this is a defenseless unit, do a fixed amount of damage
	if (!pDefender->IsCanDefend())
		return /*40*/ GD_INT_GET(NONCOMBAT_UNIT_RANGED_DAMAGE);

	if (pInPlot == NULL)
		pInPlot = pDefender->plot();

	int iAttackerStrength = getStrengthValue(true, false, pDefender);
	int iDefenderStrength = rangeCombatUnitDefense(pDefender, pInPlot, bQuickAndDirty);
	int iModifier = 0 - pDefender->GetDamageReductionCityAssault(); //watch the minus
	int iRandomSeed = bIncludeRand ? (pDefender->plot()->GetPlotIndex() + iAttackerStrength + iDefenderStrength) : 0;

	return CvUnitCombat::DoDamageMath(
		iAttackerStrength,
		iDefenderStrength,
		/*2400*/ GD_INT_GET(RANGE_ATTACK_SAME_STRENGTH_MIN_DAMAGE), //ignore the min part, it's misleading
		/*1200*/ GD_INT_GET(RANGE_ATTACK_SAME_STRENGTH_POSSIBLE_EXTRA_DAMAGE),
		iRandomSeed,
		iModifier) / 100;
}

//	--------------------------------------------------------------------------------
int CvCity::GetAirStrikeDefenseDamage(const CvUnit* pAttacker, bool bIncludeRand) const
{
	//base value
	int iBaseValue = 15;

	if (MOD_BALANCE_CORE_MILITARY_PROMOTION_ADVANCED)
	{
		iBaseValue = GetCityAirStrikeDefense();

		if (pAttacker != NULL && pAttacker->GetInterceptionDefenseDamageModifier() != 0)
		{
			iBaseValue = iBaseValue * (100 + pAttacker->GetInterceptionDefenseDamageModifier());
			iBaseValue /= 100;
		}
	}

	if (bIncludeRand)
		return iBaseValue + GC.getGame().getSmallFakeRandNum(10, plot()->GetPlotIndex() + GET_PLAYER(getOwner()).GetPseudoRandomSeed());
	else
		return iBaseValue;
}

bool CvCity::IsEnemyInRange(int iRange, bool bMustBeAbleToAttack)
{
	iRange = range(iRange, 1, 5);
	for (int i = RING0_PLOTS; i < RING_PLOTS[iRange]; i++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(plot(), i);
		if (!pLoopPlot)
			continue;

		if (bMustBeAbleToAttack)
		{
			if (canRangeStrikeAt(pLoopPlot->getX(), pLoopPlot->getY()))
				return true;
		}
		else
		{
			if (pLoopPlot->isEnemyUnit(getOwner(), true, true))
				return true;
		}
	}

	return false;
}

//	--------------------------------------------------------------------------------
void CvCity::DoNearbyEnemy()
{
	// Can't actually range strike
	if (!canRangeStrike())
		return;

#if defined(MOD_BALANCE_CORE_MILITARY)
	if (isMadeAttack())
		return;
#endif

#if defined(MOD_EVENTS_CITY_BOMBARD)
	int iSearchRange = getBombardRange();
#else
	int iSearchRange = /*2*/ GD_INT_GET(CITY_ATTACK_RANGE);
#endif

	if (IsEnemyInRange(iSearchRange, true))
	{
		// Notification
		CvNotifications* pNotifications = GET_PLAYER(getOwner()).GetNotifications();
		if (pNotifications)
		{
			Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_CITY_CAN_SHOOT");
			strText << getNameKey();
			Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_CITY_CAN_SHOOT");
			strSummary << getNameKey();
			pNotifications->Add(NOTIFICATION_CITY_RANGE_ATTACK, strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), GetID());
		}
	}
}

bool CvCity::IsInDanger(PlayerTypes eEnemy) const
{
	//unit strength doesn't matter if the city is low on hitpoints
	if (isInDangerOfFalling())
		return true;

	//cannot use the tactical zone here, because it's not specific to a certain enemy
	//but we can use the danger plots to exclude some cities
	if (GET_PLAYER(getOwner()).GetPlotDanger(this) == 0)
		return false;

	int iFriendlyPower = GetPower();
	int iEnemyPower = 0;
	bool bFriendlyGeneralInTheVicinity = false;
	bool bEnemyGeneralInTheVicinity = false;
	for (int i = RING0_PLOTS; i < RING4_PLOTS; i++)
	{
		CvPlot* pPlot = iterateRingPlots(plot(), i);
		if (!pPlot)
			continue;

		for (int j = 0; j < pPlot->getNumUnits(); j++)
		{
			CvUnit* pUnit = pPlot->getUnitByIndex(j);
			if (pUnit->IsCombatUnit())
			{
				if (pUnit->getTeam() == getTeam())
					iFriendlyPower += pUnit->GetPower();
				if (pUnit->getOwner() == eEnemy)
					iEnemyPower += pUnit->GetPower();
			}
			else if (pUnit->IsGreatGeneral())
			{
				if (pUnit->getTeam() == getTeam())
					bFriendlyGeneralInTheVicinity = true;
				if (pUnit->getOwner() == eEnemy)
					bEnemyGeneralInTheVicinity = true;
			}
		}
	}

	if (bFriendlyGeneralInTheVicinity)
	{
		iFriendlyPower *= 11;
		iFriendlyPower /= 10;
	}

	if (bEnemyGeneralInTheVicinity)
	{
		iEnemyPower *= 11;
		iEnemyPower /= 10;
	}

	return (iEnemyPower > iFriendlyPower);
}

bool CvCity::IsInDangerFromPlayers(vector<PlayerTypes>& vWarAllies) const
{
	if (vWarAllies.empty())
		return false;

	for (std::vector<PlayerTypes>::iterator it = vWarAllies.begin(); it != vWarAllies.end(); it++)
	{
		if (GET_PLAYER(*it).isAlive() && IsInDanger(*it))
			return true;
	}

	return false;
}

//	--------------------------------------------------------------------------------
void CvCity::CheckForAchievementBuilding(BuildingTypes eBuilding)
{
	if (!MOD_API_ACHIEVEMENTS)
		return;

	CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);
	if (pkBuildingInfo == NULL)
		return;

	const char* szBuildingTypeChar = pkBuildingInfo->GetType();
	CvString szBuilding = szBuildingTypeChar;

	if (szBuilding == "BUILDING_LONGHOUSE")
	{
		CvPlot* pLoopPlot = NULL;
		int nForests = 0;

		for (int iI = 0; iI < GetNumWorkablePlots(); iI++)
		{
			pLoopPlot = iterateRingPlots(getX(), getY(), iI);

			if (pLoopPlot != NULL)
			{
				if (pLoopPlot->getOwner() == getOwner())
				{
					if (pLoopPlot->getFeatureType() == FEATURE_FOREST)
					{
						nForests++;
					}
				}
			}
		}
		if (nForests >= 4)
		{
			gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_LONGHOUSE);
		}
	}
	if (szBuilding == "BUILDING_FLOATING_GARDENS")
	{
		int iCityX = getX();
		int iCityY = getY();
		PlayerTypes eCityOwner = getOwner();

		for (int iI = 0; iI < GetNumWorkablePlots(); iI++)
		{
			CvPlot* pLoopPlot = iterateRingPlots(iCityX, iCityY, iI);

			if (pLoopPlot != NULL && pLoopPlot->getOwner() == eCityOwner && pLoopPlot->isLake())
			{
				gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_GARDENS);
				break;
			}
		}
	}
	//DLC_06 achievement: Build Statue of Zeus and Temple of Artemis in same city
	if (szBuilding == "BUILDING_STATUE_ZEUS" || szBuilding == "BUILDING_TEMPLE_ARTEMIS")
	{
		CvString szOtherWonder = "";
		if (szBuilding == "BUILDING_STATUE_ZEUS")
		{
			szOtherWonder = "BUILDING_TEMPLE_ARTEMIS";
		}
		else
		{
			szOtherWonder = "BUILDING_STATUE_ZEUS";
		}
		BuildingTypes eOtherWonder = (BuildingTypes)GC.getInfoTypeForString(szOtherWonder, true);
		if (eOtherWonder != NO_BUILDING)
		{
			PlayerTypes eCityOwner = getOwner();
			if (GetCityBuildings()->GetNumBuilding(eOtherWonder) > 0)
			{
				if (GetCityBuildings()->GetBuildingOriginalOwner(eOtherWonder) == eCityOwner)
				{
					gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_ZEUS_AND_ARTEMIS);
				}
			}
		}
	}
}

//	--------------------------------------------------------------------------------
void CvCity::IncrementUnitStatCount(CvUnit* pUnit)
{
	if (!MOD_API_ACHIEVEMENTS)
		return;

	CvString szUnitType = pUnit->getUnitInfo().GetType();

	if (szUnitType == "UNIT_WARRIOR")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_WARRIOR);
	}
	else if (szUnitType == "UNIT_SETTLER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_SETTLER);
	}
	else if (szUnitType == "UNIT_WORKER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_WORKER);
	}
	else if (szUnitType == "UNIT_WORKBOAT")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_WORKBOAT);
	}
	else if (szUnitType == "UNIT_GREAT_GENERAL")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_GREATGENERALS);
	}
	else if (szUnitType == "UNIT_SS_STASIS_CHAMBER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_SSSTASISCHAMBER);
	}
	else if (szUnitType == "UNIT_SS_ENGINE")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_SSENGINE);
	}
	else if (szUnitType == "UNIT_SS_COCKPIT")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_SSCOCKPIT);
	}
	else if (szUnitType == "UNIT_SS_BOOSTER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_SSBOOSTER);
	}
	else if (szUnitType == "UNIT_MISSILE_CRUISER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_MISSILECRUISER);
	}
	else if (szUnitType == "UNIT_NUCLEAR_SUBMARINE")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_NUCLEARSUBMARINE);
	}
	else if (szUnitType == "UNIT_CARRIER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_CARRIER);
	}
	else if (szUnitType == "UNIT_BATTLESHIP")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_BATTLESHIP);
	}
	else if (szUnitType == "UNIT_SUBMARINE")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_SUBMARINE);
	}
	else if (szUnitType == "UNIT_DESTROYER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_DESTROYER);
	}
	else if (szUnitType == "UNIT_IRONCLAD")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_IRONCLAD);
	}
	else if (szUnitType == "UNIT_FRIGATE")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_FRIGATE);
	}
	else if (szUnitType == "UNIT_ENGLISH_SHIPOFTHELINE")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_SHIPOFTHELINE);
	}
	else if (szUnitType == "UNIT_CARAVEL")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_CARAVEL);
	}
	else if (szUnitType == "UNIT_TRIREME")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_TRIREME);
	}
	else if (szUnitType == "UNIT_MECH")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_GIANTDEATHROBOT);
	}
	else if (szUnitType == "UNIT_NUCLEAR_MISSILE")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_NUCLEARMISSILE);
	}
	else if (szUnitType == "UNIT_STEALTH_BOMBER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_STEALTHBOMBER);
	}
	else if (szUnitType == "UNIT_JET_FIGHTER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_JETFIGHTER);
	}
	else if (szUnitType == "UNIT_GUIDED_MISSILE")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_GUIDEDMISSILE);
	}
	else if (szUnitType == "UNIT_MODERN_ARMOR")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_MODERNARMOR);
	}
	else if (szUnitType == "UNIT_HELICOPTER_GUNSHIP")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_HELICOPTERGUNSHIP);
	}
	else if (szUnitType == "UNIT_MOBILE_SAM")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_MOBILESAM);
	}
	else if (szUnitType == "UNIT_ROCKET_ARTILLERY")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_ROCKETARTILLERY);
	}
	else if (szUnitType == "UNIT_MECHANIZED_INFANTRY")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_MECHANIZEDINFANTRY);
	}
	else if (szUnitType == "UNIT_ATOMIC_BOMB")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_ATOMICBOMB);
	}
	else if (szUnitType == "UNIT_BOMBER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_BOMBER);
	}
	else if (szUnitType == "UNIT_AMERICAN_B17")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_B17);
	}
	else if (szUnitType == "UNIT_FIGHTER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_FIGHTER);
	}
	else if (szUnitType == "UNIT_JAPANESE_ZERO")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_ZERO);
	}
	else if (szUnitType == "UNIT_PARATROOPER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_PARATROOPER);
	}
	else if (szUnitType == "UNIT_TANK")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_TANK);
	}
	else if (szUnitType == "UNIT_GERMAN_PANZER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_PANZER);
	}
	else if (szUnitType == "UNIT_ARTILLERY")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_ARTILLERY);
	}
	else if (szUnitType == "UNIT_ANTI_AIRCRAFT_GUN")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_ANTIAIRCRAFTGUN);
	}
	else if (szUnitType == "UNIT_ANTI_TANK_GUN")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_ANTITANKGUN);
	}
	else if (szUnitType == "UNIT_INFANTRY")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_INFANTRY);
	}
	else if (szUnitType == "UNIT_FRENCH_FOREIGNLEGION")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_FOREIGNLEGION);
	}
	else if (szUnitType == "UNIT_CAVALRY")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_CAVALRY);
	}
	else if (szUnitType == "UNIT_RUSSIAN_COSSACK")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_COSSACK);
	}
	else if (szUnitType == "UNIT_RIFLEMAN")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_RIFLEMAN);
	}
	else if (szUnitType == "UNIT_LANCER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_LANCER);
	}
	else if (szUnitType == "UNIT_OTTOMAN_SIPAHI")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_SIPAHI);
	}
	else if (szUnitType == "UNIT_CANNON")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_CANNON);
	}
	else if (szUnitType == "UNIT_MUSKETMAN")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_MUSKETMAN);
	}
	else if (szUnitType == "UNIT_AMERICAN_MINUTEMAN")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_MINUTEMAN);
	}
	else if (szUnitType == "UNIT_FRENCH_MUSKETEER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_MUSKETEER);
	}
	else if (szUnitType == "UNIT_OTTOMAN_JANISSARY")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_JANISSARY);
	}
	else if (szUnitType == "UNIT_LONGSWORDSMAN")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_LONGSWORDSMAN);
	}
	else if (szUnitType == "UNIT_JAPANESE_SAMURAI")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_SAMURAI);
	}
	else if (szUnitType == "UNIT_TREBUCHET")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_TREBUCHET);
	}
	else if (szUnitType == "UNIT_KNIGHT")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_KNIGHT);
	}
	else if (szUnitType == "UNIT_SIAMESE_WARELEPHANT")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_NARESUANSELEPHANT);
	}
	else if (szUnitType == "UNIT_SONGHAI_MUSLIMCAVALRY")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_MANDEKALUCAVALRY);
	}
	else if (szUnitType == "UNIT_CROSSBOWMAN")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_CROSSBOWMAN);
	}
	else if (szUnitType == "UNIT_CHINESE_CHUKONU")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_CHUKONU);
	}
	else if (szUnitType == "UNIT_ARABIAN_CAMELARCHER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_CAMELARCHER);
	}
	else if (szUnitType == "UNIT_ENGLISH_LONGBOWMAN")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_LONGBOWMAN);
	}
	else if (szUnitType == "UNIT_PIKEMAN")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_PIKEMAN);
	}
	else if (szUnitType == "UNIT_GERMAN_LANDSKNECHT")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_LANDSKNECHT);
	}
	else if (szUnitType == "UNIT_CATAPULT")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_CATAPULT);
	}
	else if (szUnitType == "UNIT_ROMAN_BALLISTA")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_BALLISTA);
	}
	else if (szUnitType == "UNIT_HORSEMAN")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_HORSEMAN);
	}
	else if (szUnitType == "UNIT_GREEK_COMPANIONCAVALRY")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_COMPANIONCAVALRY);
	}
	else if (szUnitType == "UNIT_SWORDSMAN")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_SWORDSMAN);
	}
	else if (szUnitType == "UNIT_IROQUOIAN_MOHAWKWARRIOR")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_MOHAWKWARRIOR);
	}
	else if (szUnitType == "UNIT_ROMAN_LEGION")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_LEGION);
	}
	else if (szUnitType == "UNIT_CHARIOT_ARCHER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_CHARIOTARCHER);
	}
	else if (szUnitType == "UNIT_EGYPTIAN_WARCHARIOT")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_WARCHARIOT);
	}
	else if (szUnitType == "UNIT_INDIAN_WARELEPHANT")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_WARELEPHANT);
	}
	else if (szUnitType == "UNIT_SPEARMAN")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_SPEARMAN);
	}
	else if (szUnitType == "UNIT_GREEK_HOPLITE")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_HOPLITE);
	}
	else if (szUnitType == "UNIT_PERSIAN_IMMORTAL")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_IMMORTAL);
	}
	else if (szUnitType == "UNIT_ARCHER")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_ARCHER);
	}
	else if (szUnitType == "UNIT_SCOUT")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_SCOUT);
	}
	else if (szUnitType == "UNIT_AZTEC_JAGUAR")
	{
		gDLL->IncrementSteamStat(ESTEAMSTAT_JAGUAR);
	}
	else
	{
		//OutputDebugString("No stat for unit type %s.", szUnitType.c_str());
	}

	if (AreAllUnitsBuilt())
	{
		gDLL->UnlockAchievement(ACHIEVEMENT_ALL_UNITS);
	}
}

//	--------------------------------------------------------------------------------
// Check to see if all the units have been built
bool CvCity::AreAllUnitsBuilt()
{
	int iUnitStatStart = 1;   //As they're defined on the backend
	int iUnitStatEnd = 79;
	int32 nStat = 0;

	for (int iI = iUnitStatStart; iI < iUnitStatEnd; iI++)
	{
		if (gDLL->GetSteamStat((ESteamStat)iI, &nStat))
		{
			if (nStat <= 0)
			{
				return false;
			}
		}
	}
	//Whoops, one is out of order
	if (gDLL->GetSteamStat(ESTEAMSTAT_CAVALRY, &nStat))
	{
		if (nStat <= 0)
		{
			return false;
		}
	}
	return true;

}

//	--------------------------------------------------------------------------------
/// Which unit would we build if we are building one for an operation?
UnitTypes CvCity::GetUnitForOperation()
{
	VALIDATE_OBJECT
	UnitTypes eBestUnit = NO_UNIT;
	UnitAITypes eUnitAI = NO_UNITAI;

	CvPlayerAI& kPlayer = GET_PLAYER(getOwner());

	bool bSameCity = false;
	OperationSlot thisOperationSlot = kPlayer.PeekAtNextUnitToBuildForOperationSlot(this, bSameCity);
	if (thisOperationSlot.IsValid() && bSameCity)
	{
		CvArmyAI* pThisArmy = kPlayer.getArmyAI(thisOperationSlot.m_iArmyID);
		CvAIOperation* pThisOperation = kPlayer.getAIOperation(thisOperationSlot.m_iOperationID);

		if (pThisArmy && pThisOperation)
		{
			if (!HasAccessToLandmass(pThisOperation->GetMusterPlot()->getLandmass()))
				return NO_UNIT;

			// figure out the primary and secondary unit type to potentially build
			CvFormationSlotEntry slotEntry = pThisArmy->GetSlotInfo(thisOperationSlot.m_iSlotID);

			eUnitAI = slotEntry.m_primaryUnitType;
			eBestUnit = m_pCityStrategyAI->GetUnitProductionAI()->RecommendUnit(eUnitAI, true);
			if (eBestUnit == NO_UNIT)
			{
				eUnitAI = slotEntry.m_secondaryUnitType;
				eBestUnit = m_pCityStrategyAI->GetUnitProductionAI()->RecommendUnit(eUnitAI, true);
			}

			if (eBestUnit != NO_UNIT)
			{
				return eBestUnit;
			}
		}
	}
	return NO_UNIT;
}

//	--------------------------------------------------------------------------------
/// What does a City shoot when attacking a Unit?
const char* CvCity::GetCityBombardEffectTag() const
{
	EraTypes eCityEra = GET_TEAM(getTeam()).GetCurrentEra();

	return GC.getEraInfo(eCityEra)->GetCityBombardEffectTag();
}

//	--------------------------------------------------------------------------------
uint CvCity::GetCityBombardEffectTagHash() const
{
	EraTypes eCityEra = GET_TEAM(getTeam()).GetCurrentEra();

	return GC.getEraInfo(eCityEra)->GetCityBombardEffectTagHash();
}

//	---------------------------------------------------------------------------
int CvCity::GetMaxHitPoints() const
{
	return /*200 in CP, 300 in VP*/ GD_INT_GET(MAX_CITY_HIT_POINTS) + GetExtraHitPoints();
}

//	--------------------------------------------------------------------------------
int CvCity::GetExtraHitPoints() const
{
	// Population mod
	int iPopBonus = 0;
	if (MOD_BALANCE_CORE_CITY_DEFENSE_SWITCH)
		iPopBonus = getPopulation() * /*40 in CP, 10 in VP*/ GD_INT_GET(CITY_STRENGTH_POPULATION_CHANGE);

	return m_iExtraHitPoints + iPopBonus;
}

//	--------------------------------------------------------------------------------
void CvCity::ChangeExtraHitPoints(int iValue)
{
	if (iValue != 0)
	{
		m_iExtraHitPoints += iValue;
		FAssertMsg(m_iExtraHitPoints >= 0, "Trying to set ExtraHitPoints to a negative value");
		if (m_iExtraHitPoints < 0)
			m_iExtraHitPoints = 0;

		int iCurrentDamage = getDamage();
		if (iCurrentDamage > GetMaxHitPoints())
			setDamage(iCurrentDamage);		// Call setDamage, it will clamp the value.
	}
}

//	--------------------------------------------------------------------------------
const CvSyncArchive<CvCity>& CvCity::getSyncArchive() const
{
	return m_syncArchive;
}

//	--------------------------------------------------------------------------------
CvSyncArchive<CvCity>& CvCity::getSyncArchive()
{
	return m_syncArchive;
}

//	--------------------------------------------------------------------------------
std::string CvCity::debugDump(const FAutoVariableBase& /*var*/) const
{
	std::string result = "Game Turn : ";
	char gameTurnBuffer[8] = { 0 };
	int gameTurn = GC.getGame().getGameTurn();
	sprintf_s(gameTurnBuffer, "%d\0", gameTurn);
	result += gameTurnBuffer;
	return result;
}

//	--------------------------------------------------------------------------------
std::string CvCity::stackTraceRemark(const FAutoVariableBase& var) const
{
	std::string result = debugDump(var);
	//example
	/*
	if(&var == &m_aiBaseYieldRateFromTerrain)
	{
		result += std::string("\nlast yield used to update from terrain = ") + FSerialization::toString(s_lastYieldUsedToUpdateRateFromTerrain) + std::string("\n");
		result += std::string("change value used for update = ") + FSerialization::toString(s_changeYieldFromTerreain) + std::string("\n");
	}
	*/
	return result;
}

//	---------------------------------------------------------------------------
bool CvCity::IsBusy() const
{
	return getCombatUnit() != NULL;
}

//	---------------------------------------------------------------------------
const CvUnit* CvCity::getCombatUnit() const
{
	return ::GetPlayerUnit(m_combatUnit);
}

//	---------------------------------------------------------------------------
CvUnit* CvCity::getCombatUnit()
{
	return ::GetPlayerUnit(m_combatUnit);
}

//	---------------------------------------------------------------------------
void CvCity::setCombatUnit(CvUnit* pCombatUnit, bool /*bAttacking*/)
{
	if (pCombatUnit != NULL)
	{
		CvAssertMsg(getCombatUnit() == NULL, "Combat Unit is not expected to be assigned");
		CvAssertMsg(!(plot()->isCityFighting()), "(plot()->isCityFighting()) did not return false as expected");
		m_combatUnit = pCombatUnit->GetIDInfo();
	}
	else
	{
		clearCombat();
	}
}

//	----------------------------------------------------------------------------
void CvCity::clearCombat()
{
	if (getCombatUnit() != NULL)
	{
		CvAssertMsg(plot()->isCityFighting(), "plot()->isCityFighting is expected to be true");
		m_combatUnit.reset();
	}
}

//	----------------------------------------------------------------------------
//	Return true if the city is fighting with someone.	Equivalent to the CvUnit call.
bool CvCity::isFighting() const
{
	return getCombatUnit() != NULL;
}

//	----------------------------------------------------------------------------
bool CvCity::HasBelief(BeliefTypes iBeliefType) const
{
	const ReligionTypes iReligion = GetCityReligions()->GetReligiousMajority();
	const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(iReligion, getOwner());

	return (pReligion && pReligion->m_Beliefs.HasBelief(iBeliefType));
}

bool CvCity::HasBuilding(BuildingTypes iBuildingType) const
{
	return (GetCityBuildings()->GetNumBuilding(iBuildingType) > 0);
}

bool CvCity::HasBuildingClass(BuildingClassTypes iBuildingClassType) const
{
	if (MOD_BUILDINGS_THOROUGH_PREREQUISITES)
	{
		return GetCityBuildings()->HasBuildingClass(iBuildingClassType);
	}
	else
	{
		return HasBuilding((BuildingTypes)getCivilizationInfo().getCivilizationBuildings(iBuildingClassType));
	}
}

bool CvCity::HasAnyWonder() const
{
	return (getNumWorldWonders() > 0);
}

bool CvCity::HasWonder(BuildingTypes iBuildingType) const
{
	return HasBuilding(iBuildingType);
}

bool CvCity::IsBuildingWorldWonder() const
{
	if (getProductionBuilding() == NO_BUILDING)
		return false;

	const CvBuildingClassInfo& kBuildingClass = GC.getBuildingInfo(getProductionBuilding())->GetBuildingClassInfo();

	return ::isWorldWonderClass(kBuildingClass);
}

bool CvCity::IsCivilization(CivilizationTypes iCivilizationType) const
{
	return (GET_PLAYER(getOwner()).getCivilizationType() == iCivilizationType);
}

bool CvCity::HasFeature(FeatureTypes iFeatureType) const
{
	int iX = getX(); int iY = getY(); int iOwner = getOwner();

	for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(iX, iY, iCityPlotLoop);

		// Invalid plot or not owned by this player
		if (pLoopPlot == NULL || pLoopPlot->getOwner() != iOwner) {
			continue;
		}

		if (pLoopPlot->HasFeature(iFeatureType)) {
			return true;
		}
	}

	return false;
}

bool CvCity::HasWorkedFeature(FeatureTypes iFeatureType) const
{
	int iX = getX(); int iY = getY(); int iOwner = getOwner();

	for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(iX, iY, iCityPlotLoop);

		// Invalid plot or not owned by this player
		if (pLoopPlot == NULL || pLoopPlot->getOwner() != iOwner) {
			continue;
		}

		// Not being worked by this city
		if (!GetCityCitizens()->IsWorkingPlot(pLoopPlot)) {
			continue;
		}

		if (pLoopPlot->HasFeature(iFeatureType)) {
			return true;
		}
	}

	return false;
}

bool CvCity::HasAnyNaturalWonder() const
{
	int iX = getX(); int iY = getY(); int iOwner = getOwner();

	for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(iX, iY, iCityPlotLoop);

		// Invalid plot or not owned by this player
		if (pLoopPlot == NULL || pLoopPlot->getOwner() != iOwner) {
			continue;
		}
		if (pLoopPlot->IsNaturalWonder()) {
			return true;
		}
	}

	return false;
}

bool CvCity::HasNaturalWonder(FeatureTypes iFeatureType) const
{
	return HasFeature(iFeatureType);
}

bool CvCity::HasImprovement(ImprovementTypes iImprovementType) const
{
	int iX = getX(); int iY = getY(); int iOwner = getOwner();

	for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(iX, iY, iCityPlotLoop);

		// Invalid plot or not owned by this player
		if (pLoopPlot == NULL || pLoopPlot->getOwner() != iOwner) {
			continue;
		}

		if (pLoopPlot->HasImprovement(iImprovementType)) {
			return true;
		}
	}

	return false;
}

bool CvCity::HasWorkedImprovement(ImprovementTypes iImprovementType) const
{
	int iX = getX(); int iY = getY(); int iOwner = getOwner();

	for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(iX, iY, iCityPlotLoop);

		// Invalid plot or not owned by this player
		if (pLoopPlot == NULL || pLoopPlot->getOwner() != iOwner) {
			continue;
		}

		// Not being worked by this city
		if (!GetCityCitizens()->IsWorkingPlot(pLoopPlot)) {
			continue;
		}

		if (pLoopPlot->HasImprovement(iImprovementType)) {
			return true;
		}
	}

	return false;
}

bool CvCity::HasPlotType(PlotTypes iPlotType) const
{
	int iX = getX(); int iY = getY(); int iOwner = getOwner();

	for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(iX, iY, iCityPlotLoop);

		// Invalid plot or not owned by this player
		if (pLoopPlot == NULL || pLoopPlot->getOwner() != iOwner) {
			continue;
		}

		if (pLoopPlot->HasPlotType(iPlotType)) {
			return true;
		}
	}

	return false;
}

bool CvCity::HasWorkedPlotType(PlotTypes iPlotType) const
{
	int iX = getX(); int iY = getY(); int iOwner = getOwner();

	for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(iX, iY, iCityPlotLoop);

		// Invalid plot or not owned by this player
		if (pLoopPlot == NULL || pLoopPlot->getOwner() != iOwner) {
			continue;
		}

		// Not being worked by this city
		if (!GetCityCitizens()->IsWorkingPlot(pLoopPlot)) {
			continue;
		}

		if (pLoopPlot->HasPlotType(iPlotType)) {
			return true;
		}
	}

	return false;
}

bool CvCity::HasAnyReligion() const
{
	return (GetCityReligions()->IsReligionInCity());
}

bool CvCity::HasReligion(ReligionTypes iReligionType) const
{
	return (HasAnyReligion() && GetCityReligions()->GetNumFollowers(iReligionType) > 0);
}

bool CvCity::HasResource(ResourceTypes iResourceType) const
{
	int iX = getX(); int iY = getY(); int iOwner = getOwner();

	for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(iX, iY, iCityPlotLoop);

		// Invalid plot or not owned by this player
		if (pLoopPlot == NULL || pLoopPlot->getOwner() != iOwner) {
			continue;
		}

		// Team can't see the resource here
		if (pLoopPlot->getResourceType(getTeam()) != iResourceType) {
			continue;
		}

		// Resource not linked to this city
		// if (pLoopPlot->GetResourceLinkedCity() != this) {
		// 	continue;
		// }

		if (pLoopPlot->HasResource(iResourceType)) {
			return true;
		}
	}

	return false;
}

bool CvCity::HasWorkedResource(ResourceTypes iResourceType) const
{
	int iX = getX(); int iY = getY(); int iOwner = getOwner();

	for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(iX, iY, iCityPlotLoop);

		// Invalid plot or not owned by this player
		if (pLoopPlot == NULL || pLoopPlot->getOwner() != iOwner) {
			continue;
		}

		// Team can't see the resource here
		if (pLoopPlot->getResourceType(getTeam()) != iResourceType) {
			continue;
		}

		// Not being worked by this city
		if (!GetCityCitizens()->IsWorkingPlot(pLoopPlot)) {
			continue;
		}

		if (pLoopPlot->HasResource(iResourceType)) {
			return true;
		}
	}

	return false;
}

bool CvCity::IsConnectedTo(CvCity* pCity) const
{
	return GET_PLAYER(getOwner()).IsCityConnectedToCity((CvCity*)this, pCity);
}

bool CvCity::HasSpecialistSlot(SpecialistTypes iSpecialistType) const
{
	for (int iBuildingType = 0; iBuildingType < GC.getNumBuildingInfos(); iBuildingType++) {
		if (HasBuilding((BuildingTypes)iBuildingType)) {
			CvBuildingEntry* pkBuilding = GC.getBuildingInfo((BuildingTypes)iBuildingType);
			if (pkBuilding && pkBuilding->GetSpecialistType() == iSpecialistType && pkBuilding->GetSpecialistCount() > 0) {
				return true;
			}
		}
	}

	return false;
}

bool CvCity::HasSpecialist(SpecialistTypes iSpecialistType) const
{
	return (GetCityCitizens()->GetSpecialistCount(iSpecialistType) > 0);
}

bool CvCity::HasTerrain(TerrainTypes iTerrainType) const
{
	int iX = getX(); int iY = getY(); int iOwner = getOwner();

	for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(iX, iY, iCityPlotLoop);

		// Invalid plot or not owned by this player
		if (pLoopPlot == NULL || pLoopPlot->getOwner() != iOwner) {
			continue;
		}

		if (pLoopPlot->HasTerrain(iTerrainType)) {
			return true;
		}
	}

	return false;
}

bool CvCity::HasWorkedTerrain(TerrainTypes iTerrainType) const
{
	int iX = getX(); int iY = getY(); int iOwner = getOwner();

	for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(iX, iY, iCityPlotLoop);

		// Invalid plot or not owned by this player
		if (pLoopPlot == NULL || pLoopPlot->getOwner() != iOwner) {
			continue;
		}

		// Not being worked by this city
		if (!GetCityCitizens()->IsWorkingPlot(pLoopPlot)) {
			continue;
		}

		if (pLoopPlot->HasTerrain(iTerrainType)) {
			return true;
		}
	}

	return false;
}

bool CvCity::HasAnyDomesticTradeRoute(bool bOutgoing) const
{
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();
	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute))
			continue;

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));
		if (bOutgoing && GetID() == pConnection->m_iOriginID && getOwner() == pConnection->m_eDestOwner)
			return true;
		if (!bOutgoing && GetID() == pConnection->m_iDestID && getOwner() == pConnection->m_eOriginOwner)
			return true;
	}

	return false;
}

bool CvCity::HasAnyInternationalTradeRoute(bool bOutgoing) const
{
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();
	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute))
			continue;

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));
		if (bOutgoing && GetID() == pConnection->m_iOriginID && getOwner() != pConnection->m_eDestOwner)
			return true;
		if (!bOutgoing && GetID() == pConnection->m_iDestID && getOwner() != pConnection->m_eOriginOwner)
			return true;
	}

	return false;
}

bool CvCity::HasTradeRouteToAnyCity() const
{
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();
	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute))
			continue;

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));
		if (GetID() == pConnection->m_iOriginID)
			return true;
	}

	return false;
}

bool CvCity::HasTradeRouteTo(CvCity* pCity) const
{
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();
	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute))
			continue;

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));
		if (GetID() == pConnection->m_iOriginID && pCity->GetID() == pConnection->m_iDestID)
			return true;
	}

	return false;
}

bool CvCity::HasTradeRouteFromAnyCity() const
{
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();
	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute))
			continue;

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));
		if (GetID() == pConnection->m_iDestID)
			return true;
	}

	return false;
}

bool CvCity::HasTradeRouteFrom(CvCity* pCity) const
{
	CvGameTrade* pTrade = GC.getGame().GetGameTrade();
	for (uint iTradeRoute = 0; iTradeRoute < pTrade->GetNumTradeConnections(); iTradeRoute++) {
		if (pTrade->IsTradeRouteIndexEmpty(iTradeRoute))
			continue;

		const TradeConnection* pConnection = &(pTrade->GetTradeConnection(iTradeRoute));
		if (GetID() == pConnection->m_iDestID && pCity->GetID() == pConnection->m_iOriginID)
			return true;
	}

	return false;
}

bool CvCity::IsOnFeature(FeatureTypes iFeatureType) const
{
	return plot()->HasFeature(iFeatureType);
}

bool CvCity::IsAdjacentToFeature(FeatureTypes iFeatureType) const
{
	return plot()->IsAdjacentToFeature(iFeatureType);
}

bool CvCity::IsWithinDistanceOfFeature(FeatureTypes iFeatureType, int iDistance) const
{
	return plot()->IsWithinDistanceOfFeature(iFeatureType, iDistance);
}
#if defined(MOD_BALANCE_CORE)
bool CvCity::IsWithinDistanceOfUnit(UnitTypes eOtherUnit, int iDistance, bool bIsFriendly, bool bIsEnemy) const
{
	return plot()->IsWithinDistanceOfUnit(getOwner(), eOtherUnit, iDistance, bIsFriendly, bIsEnemy);
}
bool CvCity::IsWithinDistanceOfUnitClass(UnitClassTypes eUnitClass, int iDistance, bool bIsFriendly, bool bIsEnemy) const
{
	return plot()->IsWithinDistanceOfUnitClass(getOwner(), eUnitClass, iDistance, bIsFriendly, bIsEnemy);
}
bool CvCity::IsWithinDistanceOfUnitCombatType(UnitCombatTypes eUnitCombat, int iDistance, bool bIsFriendly, bool bIsEnemy) const
{
	return plot()->IsWithinDistanceOfUnitCombatType(getOwner(), eUnitCombat, iDistance, bIsFriendly, bIsEnemy);
}
bool CvCity::IsWithinDistanceOfUnitPromotion(PromotionTypes eUnitPromotion, int iDistance, bool bIsFriendly, bool bIsEnemy) const
{
	return plot()->IsWithinDistanceOfUnitPromotion(getOwner(), eUnitPromotion, iDistance, bIsFriendly, bIsEnemy);
}
#endif
bool CvCity::IsOnImprovement(ImprovementTypes iImprovementType) const
{
	return plot()->HasImprovement(iImprovementType);
}

bool CvCity::IsAdjacentToImprovement(ImprovementTypes iImprovementType) const
{
	return plot()->IsAdjacentToImprovement(iImprovementType);
}

bool CvCity::IsWithinDistanceOfImprovement(ImprovementTypes iImprovementType, int iDistance) const
{
	return plot()->IsWithinDistanceOfImprovement(iImprovementType, iDistance);
}

bool CvCity::IsOnPlotType(PlotTypes iPlotType) const
{
	return plot()->HasPlotType(iPlotType);
}

bool CvCity::IsAdjacentToPlotType(PlotTypes iPlotType) const
{
	return plot()->IsAdjacentToPlotType(iPlotType);
}

bool CvCity::IsWithinDistanceOfPlotType(PlotTypes iPlotType, int iDistance) const
{
	return plot()->IsWithinDistanceOfPlotType(iPlotType, iDistance);
}

bool CvCity::IsOnResource(ResourceTypes iResourceType) const
{
	return plot()->HasResource(iResourceType);
}

bool CvCity::IsAdjacentToResource(ResourceTypes iResourceType) const
{
	return plot()->IsAdjacentToResource(iResourceType);
}

bool CvCity::IsWithinDistanceOfResource(ResourceTypes iResourceType, int iDistance) const
{
	return plot()->IsWithinDistanceOfResource(iResourceType, iDistance);
}

bool CvCity::IsOnTerrain(TerrainTypes iTerrainType) const
{
	return plot()->HasTerrain(iTerrainType);
}

bool CvCity::IsAdjacentToTerrain(TerrainTypes iTerrainType) const
{
	return plot()->IsAdjacentToTerrain(iTerrainType);
}

bool CvCity::IsWithinDistanceOfTerrain(TerrainTypes iTerrainType, int iDistance) const
{
	return plot()->IsWithinDistanceOfTerrain(iTerrainType, iDistance);
}

int CvCity::CountNumWorkedFeature(FeatureTypes iFeatureType)
{
	int iX = getX(); int iY = getY(); int iOwner = getOwner();
	int iNum = 0;

	for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(iX, iY, iCityPlotLoop);

		// Invalid plot or not owned by this player
		if (pLoopPlot == NULL || pLoopPlot->getOwner() != iOwner)
		{
			continue;
		}

		// Not being worked by this city
		if (!GetCityCitizens()->IsWorkingPlot(pLoopPlot))
		{
			continue;
		}

		if (pLoopPlot->HasFeature(iFeatureType))
		{
			iNum++;
		}
	}

	return iNum;
}

int CvCity::CountNumWorkedImprovement(ImprovementTypes eImprovement, bool IgnorePillaged)
{
	int iX = getX(); int iY = getY(); int iOwner = getOwner();
	int iNum = 0;

	for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(iX, iY, iCityPlotLoop);

		// Invalid plot or not owned by this player
		if (pLoopPlot == NULL || pLoopPlot->getOwner() != iOwner)
		{
			continue;
		}

		// Not being worked by this city
		if (!GetCityCitizens()->IsWorkingPlot(pLoopPlot))
		{
			continue;
		}

		if (pLoopPlot->IsImprovementPillaged() && IgnorePillaged)
			continue;

		if (pLoopPlot->getImprovementType() == eImprovement)
		{
			iNum++;
		}
	}

	return iNum;
}

int CvCity::CountNumWorkedResource(ResourceTypes eResource)
{
	int iX = getX(); int iY = getY(); int iOwner = getOwner();
	int iNum = 0;

	for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(iX, iY, iCityPlotLoop);

		// Invalid plot or not owned by this player
		if (pLoopPlot == NULL || pLoopPlot->getOwner() != iOwner)
		{
			continue;
		}

		// Not being worked by this city
		if (!GetCityCitizens()->IsWorkingPlot(pLoopPlot))
		{
			continue;
		}

		if (pLoopPlot->getResourceType() == eResource)
		{
			iNum++;
		}
	}

	return iNum;
}

int CvCity::CountNumImprovement(ImprovementTypes eImprovement)
{
	int iX = getX(); int iY = getY(); int iOwner = getOwner();
	int iNum = 0;

	for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(iX, iY, iCityPlotLoop);

		// Invalid plot or not owned by this player
		if (pLoopPlot == NULL || pLoopPlot->getOwner() != iOwner)
		{
			continue;
		}

		// Does not belong to this city
		if (!GetCityCitizens()->IsCanWork(pLoopPlot))
		{
			continue;
		}

		if (pLoopPlot->getImprovementType() == eImprovement)
		{
			iNum++;
		}
	}

	return iNum;
}
int CvCity::CountNumWorkedRiverTiles(TerrainTypes eTerrain)
{
	int iX = getX(); int iY = getY(); int iOwner = getOwner();
	int iNum = 0;

	for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(iX, iY, iCityPlotLoop);

		// Invalid plot or not owned by this player
		if (pLoopPlot == NULL || pLoopPlot->getOwner() != iOwner)
		{
			continue;
		}

		if (!pLoopPlot->isRiver())
		{
			continue;
		}

		// Does not belong to this city
		if (!GetCityCitizens()->IsWorkingPlot(iCityPlotLoop))
		{
			continue;
		}

		if (eTerrain == NO_TERRAIN)
		{
			iNum++;
		}
		else if (eTerrain == pLoopPlot->getTerrainType())
		{
			iNum++;
		}
	}

	return iNum;
}

//	--------------------------------------------------------------------------------
#if defined(MOD_CORE_PER_TURN_DAMAGE)
int CvCity::addDamageReceivedThisTurn(int iDamage)
{
	m_iDamageTakenThisTurn += iDamage;
	return m_iDamageTakenThisTurn;
}

void CvCity::flipDamageReceivedPerTurn()
{
	//basic smoothing so we don't overeact if the enemy doesn't do damage in a particular turn
	m_iDamageTakenLastTurn = (m_iDamageTakenThisTurn * 80 + m_iDamageTakenLastTurn * 20) / 100;
	m_iDamageTakenThisTurn = 0;
}

bool CvCity::isInDangerOfFalling(bool bExtraCareful) const
{
	int iHitpoints = GetMaxHitPoints() - getDamage();
	int iExtraDamage = bExtraCareful ? m_iDamageTakenLastTurn / 3 : 0;

	if (m_iDamageTakenLastTurn+iExtraDamage > iHitpoints)
		return true;

	//special: if a city has just been conquered it's vulnerable but m_iDamageTakenLastTurn is zero
	if (GC.getGame().getGameTurn() - getGameTurnAcquired() < 2)
		if (GET_PLAYER(getOwner()).GetPlotDanger(this) > iHitpoints)
			return true;

	return false;
}

bool CvCity::isUnderSiege() const
{
	//lots of possible conditions, many overlapping ... let's make sure we cover all angles
	return m_iDamageTakenLastTurn > 0 || plot()->GetNumEnemyUnitsAdjacent(getTeam(), NO_DOMAIN) > 0 || (IsBlockadedWaterAndLand() && getDamage() >= GetMaxHitPoints()/4) || isInDangerOfFalling();
}

int CvCity::getDamageTakenLastTurn() const
{
	return m_iDamageTakenLastTurn;
}

#endif

#if defined(MOD_BALANCE_CORE)
//the closest friendly cities - up to 4 entries 
const std::vector<int>& CvCity::GetClosestFriendlyNeighboringCities() const
{
	return m_vClosestNeighbors;
}

void CvCity::UpdateClosestFriendlyNeighbors()
{
	struct SCityWithScore
	{
		CvCity* city;
		int score;
		SCityWithScore(CvCity* ptr, int i) : city(ptr), score(i) {}
		bool operator<(const SCityWithScore& rhs) const { return score < rhs.score; }
	};

	std::vector<SCityWithScore> allNeighbors;

	CvPlayer& kOwner = GET_PLAYER(getOwner());
	int iLoop = 0;
	for (CvCity* pCity = kOwner.firstCity(&iLoop); pCity != NULL; pCity = kOwner.nextCity(&iLoop))
	{
		//we are not our own neighbor
		if (pCity == this)
			continue;

		int iDistance = plotDistance(this->getX(), this->getY(), pCity->getX(), pCity->getY());
		allNeighbors.push_back(SCityWithScore(pCity, iDistance));
	}

	std::stable_sort(allNeighbors.begin(), allNeighbors.end());

	m_vClosestNeighbors.clear();
	for (size_t i = 0; i < min<size_t>(6, allNeighbors.size()); i++)
		m_vClosestNeighbors.push_back(allNeighbors[i].city->GetID());
}

void CvCity::AttachUnit(CvUnit* pUnit)
{
	if (pUnit)
		m_vAttachedUnits.push_back(pUnit->GetID());
}

void CvCity::ClearAttachedUnits()
{
	m_vAttachedUnits.clear();
}

const std::vector<int>& CvCity::GetAttachedUnits() const
{
	return m_vAttachedUnits;
}

int CvCity::CountFeature(FeatureTypes iFeatureType) const
{
	int iCount = 0;

	for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(getX(), getY(), iCityPlotLoop);

		// Invalid plot or not owned by this city
		if (pLoopPlot == NULL || pLoopPlot->getOwningCityID() != GetID())
			continue;

		if (pLoopPlot->HasFeature(iFeatureType))
			++iCount;
	}

	return iCount;
}

int CvCity::CountWorkedFeature(FeatureTypes iFeatureType) const
{
	int iCount = 0;
	int iX = getX(); int iY = getY(); int iOwner = getOwner();

	for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(iX, iY, iCityPlotLoop);

		// Invalid plot or not owned by this player
		if (pLoopPlot == NULL || pLoopPlot->getOwner() != iOwner) {
			continue;
		}

		// Not being worked by this city
		if (!GetCityCitizens()->IsWorkingPlot(pLoopPlot)) {
			continue;
		}

		if (pLoopPlot->HasFeature(iFeatureType)) {
			++iCount;
		}
	}

	return iCount;
}

int CvCity::CountImprovement(ImprovementTypes iImprovementType, bool bOnlyCreated) const
{
	int iCount = 0;

	for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(getX(), getY(), iCityPlotLoop);

		// Invalid plot or not owned by this city
		if (pLoopPlot == NULL || pLoopPlot->getOwningCityID() != GetID())
			continue;

		if (pLoopPlot->HasImprovement(iImprovementType))
		{
			if (bOnlyCreated && pLoopPlot->GetPlayerThatBuiltImprovement() != getOwner())
				continue;

			++iCount;
		}
	}

	return iCount;
}

int CvCity::CountWorkedImprovement(ImprovementTypes iImprovementType) const
{
	int iCount = 0;
	int iX = getX(); int iY = getY(); int iOwner = getOwner();

	for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(iX, iY, iCityPlotLoop);

		// Invalid plot or not owned by this player
		if (pLoopPlot == NULL || pLoopPlot->getOwner() != iOwner) {
			continue;
		}

		// Not being worked by this city
		if (!GetCityCitizens()->IsWorkingPlot(pLoopPlot)) {
			continue;
		}

		if (pLoopPlot->HasImprovement(iImprovementType)) {
			++iCount;
		}
	}

	return iCount;
}

int CvCity::CountPlotType(PlotTypes iPlotType) const
{
	int iCount = 0;

	for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(getX(), getY(), iCityPlotLoop);

		// Invalid plot or not owned by this city
		if (pLoopPlot == NULL || pLoopPlot->getOwningCityID() != GetID())
			continue;

		if (pLoopPlot->HasPlotType(iPlotType))
			++iCount;
	}

	return iCount;
}

int CvCity::CountWorkedPlotType(PlotTypes iPlotType) const
{
	int iCount = 0;
	int iX = getX(); int iY = getY(); int iOwner = getOwner();

	for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(iX, iY, iCityPlotLoop);

		// Invalid plot or not owned by this player
		if (pLoopPlot == NULL || pLoopPlot->getOwner() != iOwner) {
			continue;
		}

		// Not being worked by this city
		if (!GetCityCitizens()->IsWorkingPlot(pLoopPlot)) {
			continue;
		}

		if (pLoopPlot->HasPlotType(iPlotType)) {
			++iCount;
		}
	}

	return iCount;
}

int CvCity::CountResource(ResourceTypes iResourceType) const
{
	int iCount = 0;
	int iX = getX(); int iY = getY(); int iOwner = getOwner();

	for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(iX, iY, iCityPlotLoop);

		// Invalid plot or not owned by this player
		if (pLoopPlot == NULL || pLoopPlot->getOwner() != iOwner) {
			continue;
		}

		// Not owned by this city
		if (!GetCityCitizens()->IsCanWork(pLoopPlot))
			continue;

		if (pLoopPlot->HasResource(iResourceType)) {
			++iCount;
		}
	}

	return iCount;
}

int CvCity::CountWorkedResource(ResourceTypes iResourceType) const
{
	int iCount = 0;
	int iX = getX(); int iY = getY(); int iOwner = getOwner();

	for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(iX, iY, iCityPlotLoop);

		// Invalid plot or not owned by this player
		if (pLoopPlot == NULL || pLoopPlot->getOwner() != iOwner) {
			continue;
		}

		// Not being worked by this city
		if (!GetCityCitizens()->IsWorkingPlot(pLoopPlot)) {
			continue;
		}

		if (pLoopPlot->HasResource(iResourceType)) {
			++iCount;
		}
	}

	return iCount;
}

int CvCity::CountTerrain(TerrainTypes iTerrainType) const
{
	int iCount = 0;

	for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(getX(), getY(), iCityPlotLoop);

		// Invalid plot or not owned by this city
		if (pLoopPlot == NULL || pLoopPlot->getOwningCityID() != GetID())
			continue;

		if (pLoopPlot->HasTerrain(iTerrainType))
			++iCount;
	}

	return iCount;
}

int CvCity::CountWorkedTerrain(TerrainTypes iTerrainType) const
{
	int iCount = 0;
	int iX = getX(); int iY = getY(); int iOwner = getOwner();

	for (int iCityPlotLoop = 0; iCityPlotLoop < GetNumWorkablePlots(); iCityPlotLoop++)
	{
		CvPlot* pLoopPlot = iterateRingPlots(iX, iY, iCityPlotLoop);

		// Invalid plot or not owned by this player
		if (pLoopPlot == NULL || pLoopPlot->getOwner() != iOwner) {
			continue;
		}

		// Not being worked by this city
		if (!GetCityCitizens()->IsWorkingPlot(pLoopPlot)) {
			continue;
		}

		if (pLoopPlot->HasTerrain(iTerrainType)) {
			++iCount;
		}
	}

	return iCount;
}

int CvCity::CountAllOwnedTerrain(TerrainTypes iTerrainType) const
{
	int iCount = 0;
	int iOwner = getOwner();

	// Loop through all plots in a map, rather than count x number of rings around the city (to cover niche cases such as someone making a citadel snake)
	for (int iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++) 
	{
		CvPlot* pLoopPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);

		// Invalid plot or not owned by this player
		if (pLoopPlot == NULL || pLoopPlot->getOwner() != iOwner) {
			continue;
		}

		//should we check owner or effective owner?
		if (pLoopPlot->getOwningCityID() != GetID())
			continue;


		if (pLoopPlot->HasTerrain(iTerrainType)) {
			++iCount;
		}
	}

	return iCount;
}
#endif

#if defined(MOD_BALANCE_CORE_JFD)
bool CvCity::IsColony() const
{
	return m_bIsColony;
}
void CvCity::SetColony(bool bValue)
{
	if (m_bIsColony != bValue)
	{
		m_bIsColony = bValue;
	}
}
int CvCity::GetProvinceLevel() const
{
	return m_iProvinceLevel;
}
void CvCity::SetProvinceLevel(int iValue)
{
	if (iValue != m_iProvinceLevel)
	{
		int iOldLevel = m_iProvinceLevel;
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_ProvinceLevelChanged, getOwner(), GetID(), iOldLevel, iValue);
		m_iProvinceLevel = iValue;
	}
}

int CvCity::GetOrganizedCrime() const
{
	return m_iOrganizedCrime;
}
void CvCity::SetOrganizedCrime(int iValue)
{
	if (m_iOrganizedCrime != iValue)
	{
		m_iOrganizedCrime = iValue;
	}
}
bool CvCity::HasOrganizedCrime()
{
	return(m_iOrganizedCrime >= 0);
}

void CvCity::ChangeResistanceCounter(int iValue)
{
	if (iValue != 0)
	{
		m_iResistanceCounter += iValue;
	}
}
void CvCity::SetResistanceCounter(int iValue)
{
	if (iValue != m_iResistanceCounter)
	{
		m_iResistanceCounter = iValue;
	}
}
int CvCity::GetResistanceCounter() const
{
	return m_iResistanceCounter;
}

void CvCity::ChangePlagueCounter(int iValue)
{
	if (iValue != 0)
	{
		m_iPlagueCounter += iValue;
	}
}
void CvCity::SetPlagueCounter(int iValue)
{
	if (iValue != m_iPlagueCounter)
	{
		m_iPlagueCounter = iValue;
	}
}
int CvCity::GetPlagueCounter() const
{
	return m_iPlagueCounter;
}

int CvCity::GetPlagueTurns() const
{
	return m_iPlagueTurns;
}
void CvCity::ChangePlagueTurns(int iValue) //Set in city::doturn
{
	if (iValue != 0)
	{
		m_iPlagueTurns += iValue;
	}
}
void CvCity::SetPlagueTurns(int iValue)
{
	if (iValue != m_iPlagueTurns)
	{
		m_iPlagueTurns = iValue;
	}
}

int CvCity::GetSappedTurns() const
{
	return m_iSappedTurns;
}
void CvCity::SetSappedTurns(int iValue)
{
	m_iSappedTurns = iValue;
}
void CvCity::ChangeSappedTurns(int iValue) //Set in city::doturn
{
	m_iSappedTurns += iValue;
}

int CvCity::GetBonusEspionageSightTurns(PlayerTypes ePlayer) const
{
	VALIDATE_OBJECT
	CvAssertMsg(ePlayer >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "eIndex expected to be < MAX_CIV_PLAYERS");

	return m_aiBonusSightEspionage[ePlayer];
}

void CvCity::UpdateBonusEspionageSightTurns(PlayerTypes ePlayer, int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(ePlayer >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "eIndex expected to be < MAX_CIV_PLAYERS");

	m_aiBonusSightEspionage[ePlayer] += iValue;
}

void CvCity::SetBonusEspionageSightTurns(PlayerTypes ePlayer, int iValue)
{
	VALIDATE_OBJECT
	CvAssertMsg(ePlayer >= 0, "eIndex expected to be >= 0");
	CvAssertMsg(ePlayer < MAX_CIV_PLAYERS, "eIndex expected to be < MAX_CIV_PLAYERS");

	m_aiBonusSightEspionage[ePlayer] = iValue;
}

int CvCity::GetPlagueType() const
{
	return m_iPlagueType;
}
void CvCity::SetPlagueType(int iValue)
{
	if (iValue != m_iPlagueTurns)
	{
		m_iPlagueType = iValue;
	}
}
bool CvCity::HasPlague()
{
	return(m_iPlagueType >= 0);
}

void CvCity::ChangeLoyaltyCounter(int iValue)
{
	if (iValue != 0)
	{
		m_iLoyaltyCounter += iValue;
	}
}
void CvCity::SetLoyaltyCounter(int iValue)
{
	if (iValue != m_iLoyaltyCounter)
	{
		m_iLoyaltyCounter = iValue;
	}
}
int CvCity::GetLoyaltyCounter() const
{
	return m_iLoyaltyCounter;
}

void CvCity::ChangeDisloyaltyCounter(int iValue)
{
	if (iValue != 0)
	{
		m_iDisloyaltyCounter += iValue;
	}
}
void CvCity::SetDisloyaltyCounter(int iValue)
{
	if (iValue != m_iDisloyaltyCounter)
	{
		m_iDisloyaltyCounter = iValue;
	}
}
int CvCity::GetDisloyaltyCounter() const
{
	return m_iDisloyaltyCounter;
}

int CvCity::GetLoyaltyState() const
{
	return m_iLoyaltyStateType;
}
void CvCity::SetLoyaltyState(int iLoyalty)
{
	if (iLoyalty != m_iLoyaltyStateType)
	{
		int iOldLoyalty = m_iLoyaltyStateType;
		GAMEEVENTINVOKE_HOOK(GAMEEVENT_LoyaltyStateChanged, getOwner(), GetID(), iOldLoyalty, iLoyalty);
		m_iLoyaltyStateType = iLoyalty;
	}
}

void CvCity::SetYieldModifierFromHappiness(YieldTypes eYield, int iValue)
{
	if (GetYieldModifierFromHappiness(eYield) != iValue)
	{
		m_aiYieldModifierFromHappiness[eYield] = iValue;
		UpdateCityYields(eYield);
	}
}
int CvCity::GetYieldModifierFromHappiness(YieldTypes eYield) const
{
	VALIDATE_OBJECT
		CvAssertMsg(eYield >= 0, "eYield expected to be >= 0");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eYield expected to be < NUM_YIELD_TYPES");

	return m_aiYieldModifierFromHappiness[eYield];
}

void CvCity::SetYieldModifierFromHealth(YieldTypes eYield, int iValue)
{
	if (GetYieldModifierFromHealth(eYield) != iValue)
	{
		m_aiYieldModifierFromHealth[eYield] = iValue;
		UpdateCityYields(eYield);
	}
}
int CvCity::GetYieldModifierFromHealth(YieldTypes eYield) const
{
	VALIDATE_OBJECT
	return m_aiYieldModifierFromHealth[eYield];
}

void CvCity::SetYieldModifierFromCrime(YieldTypes eYield, int iValue)
{
	if (GetYieldModifierFromCrime(eYield) != iValue)
	{
		m_aiYieldModifierFromCrime[eYield] = iValue;
		UpdateCityYields(eYield);
	}
}
int CvCity::GetYieldModifierFromCrime(YieldTypes eYield) const
{
	VALIDATE_OBJECT
	return m_aiYieldModifierFromCrime[eYield];
}

void CvCity::SetYieldModifierFromDevelopment(YieldTypes eYield, int iValue)
{
	if (GetYieldModifierFromDevelopment(eYield) != iValue)
	{
		m_aiYieldModifierFromDevelopment[eYield] = iValue;
		UpdateCityYields(eYield);
	}
}
int CvCity::GetYieldModifierFromDevelopment(YieldTypes eYield) const
{
	VALIDATE_OBJECT
	return m_aiYieldModifierFromDevelopment[eYield];
}

void CvCity::SetYieldFromHappiness(YieldTypes eYield, int iValue)
{
	if (GetYieldFromHappiness(eYield) != iValue)
	{
		m_aiYieldFromHappiness[eYield] = iValue;
		UpdateCityYields(eYield);
	}
}
int CvCity::GetYieldFromHappiness(YieldTypes eYield) const
{
	VALIDATE_OBJECT
	return m_aiYieldFromHappiness[eYield];
}

void CvCity::SetYieldFromHealth(YieldTypes eYield, int iValue)
{
	if (GetYieldFromHealth(eYield) != iValue)
	{
		m_aiYieldFromHealth[eYield] = iValue;
		UpdateCityYields(eYield);
	}
}
int CvCity::GetYieldFromHealth(YieldTypes eYield) const
{
	VALIDATE_OBJECT
	return m_aiYieldFromHealth[eYield];
}
void CvCity::SetYieldFromCrime(YieldTypes eYield, int iValue)
{
	if (GetYieldFromCrime(eYield) != iValue)
	{
		m_aiYieldFromCrime[eYield] = iValue;
		UpdateCityYields(eYield);
	}
}
int CvCity::GetYieldFromCrime(YieldTypes eYield) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eYield >= 0, "eYield expected to be >= 0");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eYield expected to be < NUM_YIELD_TYPES");

	return m_aiYieldFromCrime[eYield];
}

void CvCity::SetYieldFromDevelopment(YieldTypes eYield, int iValue)
{
	if (GetYieldFromDevelopment(eYield) != iValue)
	{
		m_aiYieldFromDevelopment[eYield] = iValue;
		UpdateCityYields(eYield);
	}
}
int CvCity::GetYieldFromDevelopment(YieldTypes eYield) const
{
	VALIDATE_OBJECT
	CvAssertMsg(eYield >= 0, "eYield expected to be >= 0");
	CvAssertMsg(eYield < NUM_YIELD_TYPES, "eYield expected to be < NUM_YIELD_TYPES");

	return m_aiYieldFromDevelopment[eYield];
}
#endif


FDataStream& operator<<(FDataStream& saveTo, const SCityExtraYields& readFrom)
{
	saveTo << readFrom.forTerrain;
	saveTo << readFrom.forXTerrain;
	saveTo << readFrom.forTerrainFromBuildings;
	saveTo << readFrom.forTerrainFromReligion;

	saveTo << readFrom.forFeature;
	saveTo << readFrom.forXFeature;
	saveTo << readFrom.forFeatureFromBuildings;
	saveTo << readFrom.forFeatureFromReligion;
	saveTo << readFrom.forFeatureUnimproved;

	saveTo << readFrom.forImprovement;
	saveTo << readFrom.forSpecialist;
	saveTo << readFrom.forResource;
	saveTo << readFrom.forPlot;
	saveTo << readFrom.forYield;
	saveTo << readFrom.forActualYield;
	saveTo << readFrom.forLocalBuilding;
	saveTo << readFrom.forReligionBuilding;
	return saveTo;
}
FDataStream& operator>>(FDataStream& loadFrom, SCityExtraYields& writeTo)
{
	loadFrom >> writeTo.forTerrain;
	loadFrom >> writeTo.forXTerrain;
	loadFrom >> writeTo.forTerrainFromBuildings;
	loadFrom >> writeTo.forTerrainFromReligion;

	loadFrom >> writeTo.forFeature;
	loadFrom >> writeTo.forXFeature;
	loadFrom >> writeTo.forFeatureFromBuildings;
	loadFrom >> writeTo.forFeatureFromReligion;
	loadFrom >> writeTo.forFeatureUnimproved;

	loadFrom >> writeTo.forImprovement;
	loadFrom >> writeTo.forSpecialist;
	loadFrom >> writeTo.forResource;
	loadFrom >> writeTo.forPlot;
	loadFrom >> writeTo.forYield;
	loadFrom >> writeTo.forActualYield;
	loadFrom >> writeTo.forLocalBuilding;
	loadFrom >> writeTo.forReligionBuilding;
	return loadFrom;
}

FDataStream& operator<<(FDataStream& saveTo, const SCityEventYields& readFrom)
{
	saveTo << readFrom.forBuilding;
	saveTo << readFrom.forBuildingModifier;
	saveTo << readFrom.forFeature;
	saveTo << readFrom.forImprovement;
	saveTo << readFrom.forResource;
	saveTo << readFrom.forSpecialist;
	saveTo << readFrom.forTerrain;
	return saveTo;
}
FDataStream& operator>>(FDataStream& loadFrom, SCityEventYields& writeTo)
{
	loadFrom >> writeTo.forBuilding;
	loadFrom >> writeTo.forBuildingModifier;
	loadFrom >> writeTo.forFeature;
	loadFrom >> writeTo.forImprovement;
	loadFrom >> writeTo.forResource;
	loadFrom >> writeTo.forSpecialist;
	loadFrom >> writeTo.forTerrain;
	return loadFrom;
}
